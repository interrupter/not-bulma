var notBulma = (function (exports) {
	'use strict';

	var DEV = true;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * TODO replace with Promise.withResolvers once supported widely enough
	 * @template T
	 */
	function deferred() {
		/** @type {(value: T) => void} */
		var resolve;

		/** @type {(reason: any) => void} */
		var reject;

		/** @type {Promise<T>} */
		var promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});

		// @ts-expect-error
		return { promise, resolve, reject };
	}

	/**
	 * @template V
	 * @param {V} value
	 * @param {V | (() => V)} fallback
	 * @param {boolean} [lazy]
	 * @returns {V}
	 */
	function fallback(value, fallback, lazy = false) {
		return value === undefined
			? lazy
				? /** @type {() => V} */ (fallback)()
				: /** @type {V} */ (fallback)
			: value;
	}

	// General flags
	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;

	// Flags exclusive to effects
	/** Set once an effect that should run synchronously has run */
	const EFFECT_RAN = 1 << 15;
	/**
	 * 'Transparent' effects do not create a transition boundary.
	 * This is on a block effect 99% of the time but may also be on a branch effect if its parent block effect was pruned
	 */
	const EFFECT_TRANSPARENT = 1 << 16;
	const EAGER_EFFECT = 1 << 17;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_PRESERVED = 1 << 19;
	const USER_EFFECT = 1 << 20;

	// Flags exclusive to deriveds
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	/**
	 * Tells that we marked this derived and its reactions as visited during the "mark as (maybe) dirty"-phase.
	 * Will be lifted during execution of the derived and during checking its dirty state (both are necessary
	 * because a derived might be checked but not executed).
	 */
	const WAS_MARKED = 1 << 15;

	// Flags used for async
	const REACTION_IS_UPDATING = 1 << 21;
	const ASYNC = 1 << 22;

	const ERROR_VALUE = 1 << 23;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');
	const PROXY_PATH_SYMBOL = Symbol('proxy path');

	/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
	const STALE_REACTION = new (class StaleReactionError extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();

	const ELEMENT_NODE = 1;
	const TEXT_NODE = 3;
	const COMMENT_NODE = 8;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Context was not set in a parent component
	 * @returns {never}
	 */
	function missing_context() {
		{
			const error = new Error(`missing_context\nContext was not set in a parent component\nhttps://svelte.dev/e/missing_context`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Cannot create a `$derived(...)` with an `await` expression outside of an effect tree
	 * @returns {never}
	 */
	function async_derived_orphan() {
		{
			const error = new Error(`async_derived_orphan\nCannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
	 * @returns {never}
	 */
	function bind_invalid_checkbox_value() {
		{
			const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		{
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Cannot use `fork(...)` unless the `experimental.async` compiler option is `true`
	 * @returns {never}
	 */
	function experimental_async_fork() {
		{
			const error = new Error(`experimental_async_fork\nCannot use \`fork(...)\` unless the \`experimental.async\` compiler option is \`true\`\nhttps://svelte.dev/e/experimental_async_fork`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Cannot commit a fork that was already discarded
	 * @returns {never}
	 */
	function fork_discarded() {
		{
			const error = new Error(`fork_discarded\nCannot commit a fork that was already discarded\nhttps://svelte.dev/e/fork_discarded`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Cannot create a fork inside an effect or when state changes are pending
	 * @returns {never}
	 */
	function fork_timing() {
		{
			const error = new Error(`fork_timing\nCannot create a fork inside an effect or when state changes are pending\nhttps://svelte.dev/e/fork_timing`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * `getAbortSignal()` can only be called inside an effect or derived
	 * @returns {never}
	 */
	function get_abort_signal_outside_reaction() {
		{
			const error = new Error(`get_abort_signal_outside_reaction\n\`getAbortSignal()\` can only be called inside an effect or derived\nhttps://svelte.dev/e/get_abort_signal_outside_reaction`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Failed to hydrate the application
	 * @returns {never}
	 */
	function hydration_failed() {
		{
			const error = new Error(`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`
	 * @returns {never}
	 */
	function invalid_snippet() {
		{
			const error = new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * `%name%(...)` cannot be used in runes mode
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_legacy_only(name) {
		{
			const error = new Error(`lifecycle_legacy_only\n\`${name}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Rest element properties of `$props()` such as `%property%` are readonly
	 * @param {string} property
	 * @returns {never}
	 */
	function props_rest_readonly(property) {
		{
			const error = new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		{
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			const error = new Error(`state_unsafe_mutation\nUpdating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	/**
	 * A `<svelte:boundary>` `reset` function cannot be called while an error is still being handled
	 * @returns {never}
	 */
	function svelte_boundary_reset_onerror() {
		{
			const error = new Error(`svelte_boundary_reset_onerror\nA \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled\nhttps://svelte.dev/e/svelte_boundary_reset_onerror`);

			error.name = 'Svelte error';

			throw error;
		}
	}

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const HYDRATION_START = '[';
	/** used to indicate that an `{:else}...` block was rendered */
	const HYDRATION_START_ELSE = '[!';
	const HYDRATION_END = ']';
	const HYDRATION_ERROR = {};

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml';
	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	const ATTACHMENT_KEY = '@attach';

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold$1 = 'font-weight: bold';
	var normal$1 = 'font-weight: normal';

	/**
	 * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value
	 * @param {string} attribute
	 * @param {string} html
	 * @param {string} value
	 */
	function hydration_attribute_changed(attribute, html, value) {
		{
			console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${attribute}\` attribute on \`${html}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`, bold$1, normal$1);
		}
	}

	/**
	 * The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value
	 * @param {string | undefined | null} [location]
	 */
	function hydration_html_changed(location) {
		{
			console.warn(
				`%c[svelte] hydration_html_changed\n%c${location
				? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value`
				: 'The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value'}\nhttps://svelte.dev/e/hydration_html_changed`,
				bold$1,
				normal$1
			);
		}
	}

	/**
	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
	 * @param {string | undefined | null} [location]
	 */
	function hydration_mismatch(location) {
		{
			console.warn(
				`%c[svelte] hydration_mismatch\n%c${'Hydration failed because the initial UI does not match what was rendered on the server'}\nhttps://svelte.dev/e/hydration_mismatch`,
				bold$1,
				normal$1
			);
		}
	}

	/**
	 * The `render` function passed to `createRawSnippet` should return HTML for a single element
	 */
	function invalid_raw_snippet_render() {
		{
			console.warn(`%c[svelte] invalid_raw_snippet_render\n%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element\nhttps://svelte.dev/e/invalid_raw_snippet_render`, bold$1, normal$1);
		}
	}

	/**
	 * Tried to unmount a component that was not mounted
	 */
	function lifecycle_double_unmount() {
		{
			console.warn(`%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount`, bold$1, normal$1);
		}
	}

	/**
	 * The `value` property of a `<select multiple>` element should be an array, but it received a non-array value. The selection will be kept as is.
	 */
	function select_multiple_invalid_value() {
		{
			console.warn(`%c[svelte] select_multiple_invalid_value\n%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.\nhttps://svelte.dev/e/select_multiple_invalid_value`, bold$1, normal$1);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold$1, normal$1);
		}
	}

	/**
	 * Tried to unmount a state proxy, rather than a component
	 */
	function state_proxy_unmount() {
		{
			console.warn(`%c[svelte] state_proxy_unmount\n%cTried to unmount a state proxy, rather than a component\nhttps://svelte.dev/e/state_proxy_unmount`, bold$1, normal$1);
		}
	}

	/**
	 * A `<svelte:boundary>` `reset` function only resets the boundary the first time it is called
	 */
	function svelte_boundary_reset_noop() {
		{
			console.warn(`%c[svelte] svelte_boundary_reset_noop\n%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called\nhttps://svelte.dev/e/svelte_boundary_reset_noop`, bold$1, normal$1);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {boolean} value */
	function set_hydrating(value) {
		hydrating = value;
	}

	/**
	 * The node that is currently being hydrated. This starts out as the first node inside the opening
	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
	 * time we leave the block it is the closing comment, which serves as the block's anchor.
	 * @type {TemplateNode}
	 */
	let hydrate_node;

	/** @param {TemplateNode} node */
	function set_hydrate_node(node) {
		if (node === null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return (hydrate_node = node);
	}

	function hydrate_next() {
		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
	}

	/** @param {TemplateNode} node */
	function reset(node) {
		if (!hydrating) return;

		// If the node has remaining siblings, something has gone wrong
		if (get_next_sibling(hydrate_node) !== null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		hydrate_node = node;
	}

	function next(count = 1) {
		if (hydrating) {
			var i = count;
			var node = hydrate_node;

			while (i--) {
				node = /** @type {TemplateNode} */ (get_next_sibling(node));
			}

			hydrate_node = node;
		}
	}

	/**
	 * Skips or removes (depending on {@link remove}) all nodes starting at `hydrate_node` up until the next hydration end comment
	 * @param {boolean} remove
	 */
	function skip_nodes(remove = true) {
		var depth = 0;
		var node = hydrate_node;

		while (true) {
			if (node.nodeType === COMMENT_NODE) {
				var data = /** @type {Comment} */ (node).data;

				if (data === HYDRATION_END) {
					if (depth === 0) return node;
					depth -= 1;
				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
					depth += 1;
				}
			}

			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
			if (remove) node.remove();
			node = next;
		}
	}

	/**
	 *
	 * @param {TemplateNode} node
	 */
	function read_hydration_instruction(node) {
		if (!node || node.nodeType !== COMMENT_NODE) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return /** @type {Comment} */ (node).data;
	}

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:
	 * 
	 * %properties%
	 * @param {string | undefined | null} [properties]
	 */
	function state_snapshot_uncloneable(properties) {
		{
			console.warn(
				`%c[svelte] state_snapshot_uncloneable\n%c${properties
				? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}`
				: 'Value cannot be cloned with `$state.snapshot` — the original value was returned'}\nhttps://svelte.dev/e/state_snapshot_uncloneable`,
				bold,
				normal
			);
		}
	}

	/** @import { Snapshot } from './types' */

	/**
	 * In dev, we keep track of which properties could not be cloned. In prod
	 * we don't bother, but we keep a dummy array around so that the
	 * signature stays the same
	 * @type {string[]}
	 */
	const empty = [];

	/**
	 * @template T
	 * @param {T} value
	 * @param {boolean} [skip_warning]
	 * @param {boolean} [no_tojson]
	 * @returns {Snapshot<T>}
	 */
	function snapshot(value, skip_warning = false, no_tojson = false) {
		if (!skip_warning) {
			/** @type {string[]} */
			const paths = [];

			const copy = clone(value, new Map(), '', paths, null, no_tojson);
			if (paths.length === 1 && paths[0] === '') {
				// value could not be cloned
				state_snapshot_uncloneable();
			} else if (paths.length > 0) {
				// some properties could not be cloned
				const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
				const excess = paths.length - slice.length;

				let uncloned = slice.map((path) => `- <value>${path}`).join('\n');
				if (excess > 0) uncloned += `\n- ...and ${excess} more`;

				state_snapshot_uncloneable(uncloned);
			}

			return copy;
		}

		return clone(value, new Map(), '', empty, null, no_tojson);
	}

	/**
	 * @template T
	 * @param {T} value
	 * @param {Map<T, Snapshot<T>>} cloned
	 * @param {string} path
	 * @param {string[]} paths
	 * @param {null | T} [original] The original value, if `value` was produced from a `toJSON` call
	 * @param {boolean} [no_tojson]
	 * @returns {Snapshot<T>}
	 */
	function clone(value, cloned, path, paths, original = null, no_tojson = false) {
		if (typeof value === 'object' && value !== null) {
			var unwrapped = cloned.get(value);
			if (unwrapped !== undefined) return unwrapped;

			if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value));
			if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value));

			if (is_array(value)) {
				var copy = /** @type {Snapshot<any>} */ (Array(value.length));
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var i = 0; i < value.length; i += 1) {
					var element = value[i];
					if (i in value) {
						copy[i] = clone(element, cloned, `${path}[${i}]` , paths, null, no_tojson);
					}
				}

				return copy;
			}

			if (get_prototype_of(value) === object_prototype) {
				/** @type {Snapshot<any>} */
				copy = {};
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var key in value) {
					copy[key] = clone(
						// @ts-expect-error
						value[key],
						cloned,
						`${path}.${key}` ,
						paths,
						null,
						no_tojson
					);
				}

				return copy;
			}

			if (value instanceof Date) {
				return /** @type {Snapshot<T>} */ (structuredClone(value));
			}

			if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function' && !no_tojson) {
				return clone(
					/** @type {T & { toJSON(): any } } */ (value).toJSON(),
					cloned,
					`${path}.toJSON()` ,
					paths,
					// Associate the instance with the toJSON clone
					value
				);
			}
		}

		if (value instanceof EventTarget) {
			// can't be cloned
			return /** @type {Snapshot<T>} */ (value);
		}

		try {
			return /** @type {Snapshot<T>} */ (structuredClone(value));
		} catch (e) {
			{
				paths.push(path);
			}

			return /** @type {Snapshot<T>} */ (value);
		}
	}

	/** @import { Derived, Reaction, Value } from '#client' */

	/**
	 * @param {string} label
	 * @returns {Error & { stack: string } | null}
	 */
	function get_stack(label) {
		// @ts-ignore stackTraceLimit doesn't exist everywhere
		const limit = Error.stackTraceLimit;

		// @ts-ignore
		Error.stackTraceLimit = Infinity;
		let error = Error();

		// @ts-ignore
		Error.stackTraceLimit = limit;

		const stack = error.stack;

		if (!stack) return null;

		const lines = stack.split('\n');
		const new_lines = ['\n'];

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];
			const posixified = line.replaceAll('\\', '/');

			if (line === 'Error') {
				continue;
			}

			if (line.includes('validate_each_keys')) {
				return null;
			}

			if (posixified.includes('svelte/src/internal') || posixified.includes('node_modules/.vite')) {
				continue;
			}

			new_lines.push(line);
		}

		if (new_lines.length === 1) {
			return null;
		}

		define_property(error, 'stack', {
			value: new_lines.join('\n')
		});

		define_property(error, 'name', {
			value: label
		});

		return /** @type {Error & { stack: string }} */ (error);
	}

	/**
	 * @param {Value} source
	 * @param {string} label
	 */
	function tag(source, label) {
		source.label = label;
		tag_proxy(source.v, label);

		return source;
	}

	/**
	 * @param {unknown} value
	 * @param {string} label
	 */
	function tag_proxy(value, label) {
		// @ts-expect-error
		value?.[PROXY_PATH_SYMBOL]?.(label);
		return value;
	}

	/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */

	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/** @type {DevStackEntry | null} */
	let dev_stack = null;

	/** @param {DevStackEntry | null} stack */
	function set_dev_stack(stack) {
		dev_stack = stack;
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * Returns a `[get, set]` pair of functions for working with context in a type-safe way.
	 *
	 * `get` will throw an error if no parent component called `set`.
	 *
	 * @template T
	 * @returns {[() => T, (context: T) => T]}
	 * @since 5.40.0
	 */
	function createContext() {
		const key = {};

		return [
			() => {
				if (!hasContext(key)) {
					missing_context();
				}

				return getContext(key);
			},
			(context) => setContext(key, context)
		];
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * [`createContext`](https://svelte.dev/docs/svelte/svelte#createContext) is a type-safe alternative.
	 *
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		const context_map = get_or_init_context_map('getContext');
		const result = /** @type {T} */ (context_map.get(key));
		return result;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * [`createContext`](https://svelte.dev/docs/svelte/svelte#createContext) is a type-safe alternative.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map('setContext');

		context_map.set(key, context);
		return context;
	}

	/**
	 * Checks whether a given `key` has been set in the context of a parent component.
	 * Must be called during component initialisation.
	 *
	 * @param {any} key
	 * @returns {boolean}
	 */
	function hasContext(key) {
		const context_map = get_or_init_context_map('hasContext');
		return context_map.has(key);
	}

	/**
	 * Retrieves the whole context map that belongs to the closest parent component.
	 * Must be called during component initialisation. Useful, for example, if you
	 * programmatically create a component and want to pass the existing context to it.
	 *
	 * @template {Map<any, any>} [T=Map<any, any>]
	 * @returns {T}
	 */
	function getAllContexts() {
		const context_map = get_or_init_context_map('getAllContexts');
		return /** @type {T} */ (context_map);
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			i: false,
			c: null,
			e: null,
			s: props,
			x: null,
			l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
		};

		{
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		var context = /** @type {ComponentContext} */ (component_context);
		var effects = context.e;

		if (effects !== null) {
			context.e = null;

			for (var fn of effects) {
				create_user_effect(fn);
			}
		}

		if (component !== undefined) {
			context.x = component;
		}

		context.i = true;

		component_context = context.p;

		{
			dev_current_component_function = component_context?.function ?? null;
		}

		return component ?? /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component(name);
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0 && !is_flushing_sync) {
			var tasks = micro_tasks;
			queueMicrotask(() => {
				// If this is false, a flushSync happened in the meantime. Do _not_ run new scheduled microtasks in that case
				// as the ordering of microtasks would be broken at that point - consider this case:
				// - queue_micro_task schedules microtask A to flush task X
				// - synchronously after, flushSync runs, processing task X
				// - synchronously after, some other microtask B is scheduled, but not through queue_micro_task but for example a Promise.resolve() in user code
				// - synchronously after, queue_micro_task schedules microtask C to flush task Y
				// - one tick later, microtask A now resolves, flushing task Y before microtask B, which is incorrect
				// This if check prevents that race condition (that realistically will only happen in tests)
				if (tasks === micro_tasks) run_micro_tasks();
			});
		}

		micro_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		while (micro_tasks.length > 0) {
			run_micro_tasks();
		}
	}

	/** @import { Derived, Effect } from '#client' */
	/** @import { Boundary } from './dom/blocks/boundary.js' */

	const adjustments = new WeakMap();

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = active_effect;

		// for unowned deriveds, don't throw until we read the value
		if (effect === null) {
			/** @type {Derived} */ (active_reaction).f |= ERROR_VALUE;
			return error;
		}

		if (error instanceof Error && !adjustments.has(error)) {
			adjustments.set(error, get_adjustments(error, effect));
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {
				if (!effect.parent && error instanceof Error) {
					apply_adjustments(error);
				}

				throw error;
			}

			/** @type {Boundary} */ (effect.b).error(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					/** @type {Boundary} */ (effect.b).error(error);
					return;
				} catch (e) {
					error = e;
				}
			}

			effect = effect.parent;
		}

		if (error instanceof Error) {
			apply_adjustments(error);
		}

		throw error;
	}

	/**
	 * Add useful information to the error message/stack in development
	 * @param {Error} error
	 * @param {Effect} effect
	 */
	function get_adjustments(error, effect) {
		const message_descriptor = get_descriptor(error, 'message');

		// if the message was already changed and it's not configurable we can't change it
		// or it will throw a different error swallowing the original error
		if (message_descriptor && !message_descriptor.configurable) return;

		var indent = is_firefox ? '  ' : '\t';
		var component_stack = `\n${indent}in ${effect.fn?.name || '<unknown>'}`;
		var context = effect.ctx;

		while (context !== null) {
			component_stack += `\n${indent}in ${context.function?.[FILENAME].split('/').pop()}`;
			context = context.p;
		}

		return {
			message: error.message + `\n${component_stack}\n`,
			stack: error.stack
				?.split('\n')
				.filter((line) => !line.includes('svelte/src/internal'))
				.join('\n')
		};
	}

	/**
	 * @param {Error} error
	 */
	function apply_adjustments(error) {
		const adjusted = adjustments.get(error);

		if (adjusted) {
			define_property(error, 'message', {
				value: adjusted.message
			});

			define_property(error, 'stack', {
				value: adjusted.stack
			});
		}
	}

	/** @import { Fork } from 'svelte' */
	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	/**
	 * @typedef {{
	 *   parent: EffectTarget | null;
	 *   effect: Effect | null;
	 *   effects: Effect[];
	 *   render_effects: Effect[];
	 *   block_effects: Effect[];
	 * }} EffectTarget
	 */

	/** @type {Set<Batch>} */
	const batches = new Set();

	/** @type {Batch | null} */
	let current_batch = null;

	/**
	 * This is needed to avoid overwriting inputs in non-async mode
	 * TODO 6.0 remove this, as non-async mode will go away
	 * @type {Batch | null}
	 */
	let previous_batch = null;

	/**
	 * When time travelling (i.e. working in one batch, while other batches
	 * still have ongoing work), we ignore the real values of affected
	 * signals in favour of their values within the batch
	 * @type {Map<Value, any> | null}
	 */
	let batch_values = null;

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing = false;
	let is_flushing_sync = false;

	class Batch {
		committed = false;

		/**
		 * The current values of any sources that are updated in this batch
		 * They keys of this map are identical to `this.#previous`
		 * @type {Map<Source, any>}
		 */
		current = new Map();

		/**
		 * The values of any sources that are updated in this batch _before_ those updates took place.
		 * They keys of this map are identical to `this.#current`
		 * @type {Map<Source, any>}
		 */
		previous = new Map();

		/**
		 * When the batch is committed (and the DOM is updated), we need to remove old branches
		 * and append new ones by calling the functions added inside (if/each/key/etc) blocks
		 * @type {Set<() => void>}
		 */
		#commit_callbacks = new Set();

		/**
		 * If a fork is discarded, we need to destroy any effects that are no longer needed
		 * @type {Set<(batch: Batch) => void>}
		 */
		#discard_callbacks = new Set();

		/**
		 * The number of async effects that are currently in flight
		 */
		#pending = 0;

		/**
		 * The number of async effects that are currently in flight, _not_ inside a pending boundary
		 */
		#blocking_pending = 0;

		/**
		 * A deferred that resolves when the batch is committed, used with `settled()`
		 * TODO replace with Promise.withResolvers once supported widely enough
		 * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
		 */
		#deferred = null;

		/**
		 * Deferred effects (which run after async work has completed) that are DIRTY
		 * @type {Effect[]}
		 */
		#dirty_effects = [];

		/**
		 * Deferred effects that are MAYBE_DIRTY
		 * @type {Effect[]}
		 */
		#maybe_dirty_effects = [];

		/**
		 * A set of branches that still exist, but will be destroyed when this batch
		 * is committed — we skip over these during `process`
		 * @type {Set<Effect>}
		 */
		skipped_effects = new Set();

		is_fork = false;

		/**
		 *
		 * @param {Effect[]} root_effects
		 */
		process(root_effects) {
			queued_root_effects = [];

			previous_batch = null;

			this.apply();

			/** @type {EffectTarget} */
			var target = {
				parent: null,
				effect: null,
				effects: [],
				render_effects: [],
				block_effects: []
			};

			for (const root of root_effects) {
				this.#traverse_effect_tree(root, target);
			}

			if (!this.is_fork) {
				this.#resolve();
			}

			if (this.#blocking_pending > 0 || this.is_fork) {
				this.#defer_effects(target.effects);
				this.#defer_effects(target.render_effects);
				this.#defer_effects(target.block_effects);
			} else {
				// If sources are written to, then work needs to happen in a separate batch, else prior sources would be mixed with
				// newly updated sources, which could lead to infinite loops when effects run over and over again.
				previous_batch = this;
				current_batch = null;

				flush_queued_effects(target.render_effects);
				flush_queued_effects(target.effects);

				previous_batch = null;

				this.#deferred?.resolve();
			}

			batch_values = null;
		}

		/**
		 * Traverse the effect tree, executing effects or stashing
		 * them for later execution as appropriate
		 * @param {Effect} root
		 * @param {EffectTarget} target
		 */
		#traverse_effect_tree(root, target) {
			root.f ^= CLEAN;

			var effect = root.first;

			while (effect !== null) {
				var flags = effect.f;
				var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
				var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

				var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);

				if ((effect.f & BOUNDARY_EFFECT) !== 0 && effect.b?.is_pending()) {
					target = {
						parent: target,
						effect,
						effects: [],
						render_effects: [],
						block_effects: []
					};
				}

				if (!skip && effect.fn !== null) {
					if (is_branch) {
						effect.f ^= CLEAN;
					} else if ((flags & EFFECT) !== 0) {
						target.effects.push(effect);
					} else if (is_dirty(effect)) {
						if ((effect.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect);
						update_effect(effect);
					}

					var child = effect.first;

					if (child !== null) {
						effect = child;
						continue;
					}
				}

				var parent = effect.parent;
				effect = effect.next;

				while (effect === null && parent !== null) {
					if (parent === target.effect) {
						// TODO rather than traversing into pending boundaries and deferring the effects,
						// could we just attach the effects _to_ the pending boundary and schedule them
						// once the boundary is ready?
						this.#defer_effects(target.effects);
						this.#defer_effects(target.render_effects);
						this.#defer_effects(target.block_effects);

						target = /** @type {EffectTarget} */ (target.parent);
					}

					effect = parent.next;
					parent = parent.parent;
				}
			}
		}

		/**
		 * @param {Effect[]} effects
		 */
		#defer_effects(effects) {
			for (const e of effects) {
				const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
				target.push(e);

				// mark as clean so they get scheduled if they depend on pending async state
				set_signal_status(e, CLEAN);
			}
		}

		/**
		 * Associate a change to a given source with the current
		 * batch, noting its previous and current values
		 * @param {Source} source
		 * @param {any} value
		 */
		capture(source, value) {
			if (!this.previous.has(source)) {
				this.previous.set(source, value);
			}

			this.current.set(source, source.v);
			batch_values?.set(source, source.v);
		}

		activate() {
			current_batch = this;
		}

		deactivate() {
			current_batch = null;
			batch_values = null;
		}

		flush() {
			this.activate();

			if (queued_root_effects.length > 0) {
				flush_effects();

				if (current_batch !== null && current_batch !== this) {
					// this can happen if a new batch was created during `flush_effects()`
					return;
				}
			} else if (this.#pending === 0) {
				this.process([]); // TODO this feels awkward
			}

			this.deactivate();
		}

		discard() {
			for (const fn of this.#discard_callbacks) fn(this);
			this.#discard_callbacks.clear();
		}

		#resolve() {
			if (this.#blocking_pending === 0) {
				// append/remove branches
				for (const fn of this.#commit_callbacks) fn();
				this.#commit_callbacks.clear();
			}

			if (this.#pending === 0) {
				this.#commit();
			}
		}

		#commit() {
			// If there are other pending batches, they now need to be 'rebased' —
			// in other words, we re-run block/async effects with the newly
			// committed state, unless the batch in question has a more
			// recent value for a given source
			if (batches.size > 1) {
				this.previous.clear();

				var previous_batch_values = batch_values;
				var is_earlier = true;

				/** @type {EffectTarget} */
				var dummy_target = {
					parent: null,
					effect: null,
					effects: [],
					render_effects: [],
					block_effects: []
				};

				for (const batch of batches) {
					if (batch === this) {
						is_earlier = false;
						continue;
					}

					/** @type {Source[]} */
					const sources = [];

					for (const [source, value] of this.current) {
						if (batch.current.has(source)) {
							if (is_earlier && value !== batch.current.get(source)) {
								// bring the value up to date
								batch.current.set(source, value);
							} else {
								// same value or later batch has more recent value,
								// no need to re-run these effects
								continue;
							}
						}

						sources.push(source);
					}

					if (sources.length === 0) {
						continue;
					}

					// Re-run async/block effects that depend on distinct values changed in both batches
					const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
					if (others.length > 0) {
						/** @type {Set<Value>} */
						const marked = new Set();
						/** @type {Map<Reaction, boolean>} */
						const checked = new Map();
						for (const source of sources) {
							mark_effects(source, others, marked, checked);
						}

						if (queued_root_effects.length > 0) {
							current_batch = batch;
							batch.apply();

							for (const root of queued_root_effects) {
								batch.#traverse_effect_tree(root, dummy_target);
							}

							// TODO do we need to do anything with `target`? defer block effects?

							queued_root_effects = [];
							batch.deactivate();
						}
					}
				}

				current_batch = null;
				batch_values = previous_batch_values;
			}

			this.committed = true;
			batches.delete(this);
		}

		/**
		 *
		 * @param {boolean} blocking
		 */
		increment(blocking) {
			this.#pending += 1;
			if (blocking) this.#blocking_pending += 1;
		}

		/**
		 *
		 * @param {boolean} blocking
		 */
		decrement(blocking) {
			this.#pending -= 1;
			if (blocking) this.#blocking_pending -= 1;

			this.revive();
		}

		revive() {
			for (const e of this.#dirty_effects) {
				set_signal_status(e, DIRTY);
				schedule_effect(e);
			}

			for (const e of this.#maybe_dirty_effects) {
				set_signal_status(e, MAYBE_DIRTY);
				schedule_effect(e);
			}

			this.#dirty_effects = [];
			this.#maybe_dirty_effects = [];

			this.flush();
		}

		/** @param {() => void} fn */
		oncommit(fn) {
			this.#commit_callbacks.add(fn);
		}

		/** @param {(batch: Batch) => void} fn */
		ondiscard(fn) {
			this.#discard_callbacks.add(fn);
		}

		settled() {
			return (this.#deferred ??= deferred()).promise;
		}

		static ensure() {
			if (current_batch === null) {
				const batch = (current_batch = new Batch());
				batches.add(current_batch);

				if (!is_flushing_sync) {
					Batch.enqueue(() => {
						if (current_batch !== batch) {
							// a flushSync happened in the meantime
							return;
						}

						batch.flush();
					});
				}
			}

			return current_batch;
		}

		/** @param {() => void} task */
		static enqueue(task) {
			queue_micro_task(task);
		}

		apply() {
			return;
		}
	}

	/**
	 * Synchronously flush any pending updates.
	 * Returns void if no callback is provided, otherwise returns the result of calling the callback.
	 * @template [T=void]
	 * @param {(() => T) | undefined} [fn]
	 * @returns {T}
	 */
	function flushSync(fn) {

		var was_flushing_sync = is_flushing_sync;
		is_flushing_sync = true;

		try {
			var result;

			if (fn) {
				if (current_batch !== null) {
					flush_effects();
				}

				result = fn();
			}

			while (true) {
				flush_tasks();

				if (queued_root_effects.length === 0) {
					current_batch?.flush();

					// we need to check again, in case we just updated an `$effect.pending()`
					if (queued_root_effects.length === 0) {
						// this would be reset in `flush_effects()` but since we are early returning here,
						// we need to reset it here as well in case the first time there's 0 queued root effects
						last_scheduled_effect = null;

						return /** @type {T} */ (result);
					}
				}

				flush_effects();
			}
		} finally {
			is_flushing_sync = was_flushing_sync;
		}
	}

	function flush_effects() {
		var was_updating_effect = is_updating_effect;
		is_flushing = true;

		try {
			var flush_count = 0;
			set_is_updating_effect(true);

			while (queued_root_effects.length > 0) {
				var batch = Batch.ensure();

				if (flush_count++ > 1000) {
					if (DEV) {
						var updates = new Map();

						for (const source of batch.current.keys()) {
							for (const [stack, update] of source.updated ?? []) {
								var entry = updates.get(stack);

								if (!entry) {
									entry = { error: update.error, count: 0 };
									updates.set(stack, entry);
								}

								entry.count += update.count;
							}
						}

						for (const update of updates.values()) {
							// eslint-disable-next-line no-console
							console.error(update.error);
						}
					}

					infinite_loop_guard();
				}

				batch.process(queued_root_effects);
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			set_is_updating_effect(was_updating_effect);

			last_scheduled_effect = null;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {
			{
				// stack contains no useful information, replace it
				define_property(error, 'stack', { value: '' });
			}

			// Best effort: invoke the boundary nearest the most recent
			// effect and hope that it's relevant to the infinite loop
			invoke_error_boundary(error, last_scheduled_effect);
		}
	}

	/** @type {Set<Effect> | null} */
	let eager_block_effects = null;

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		var i = 0;

		while (i < length) {
			var effect = effects[i++];

			if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
				eager_block_effects = new Set();

				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					// if there's no teardown or abort controller we completely unlink
					// the effect from the graph
					if (effect.teardown === null && effect.ac === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}

				// If update_effect() has a flushSync() in it, we may have flushed another flush_queued_effects(),
				// which already handled this logic and did set eager_block_effects to null.
				if (eager_block_effects?.size > 0) {
					old_values.clear();

					for (const e of eager_block_effects) {
						// Skip eager effects that have already been unmounted
						if ((e.f & (DESTROYED | INERT)) !== 0) continue;

						// Run effects in order from ancestor to descendant, else we could run into nullpointers
						/** @type {Effect[]} */
						const ordered_effects = [e];
						let ancestor = e.parent;
						while (ancestor !== null) {
							if (eager_block_effects.has(ancestor)) {
								eager_block_effects.delete(ancestor);
								ordered_effects.push(ancestor);
							}
							ancestor = ancestor.parent;
						}

						for (let j = ordered_effects.length - 1; j >= 0; j--) {
							const e = ordered_effects[j];
							// Skip eager effects that have already been unmounted
							if ((e.f & (DESTROYED | INERT)) !== 0) continue;
							update_effect(e);
						}
					}

					eager_block_effects.clear();
				}
			}
		}

		eager_block_effects = null;
	}

	/**
	 * This is similar to `mark_reactions`, but it only marks async/block effects
	 * depending on `value` and at least one of the other `sources`, so that
	 * these effects can re-run after another batch has been committed
	 * @param {Value} value
	 * @param {Source[]} sources
	 * @param {Set<Value>} marked
	 * @param {Map<Reaction, boolean>} checked
	 */
	function mark_effects(value, sources, marked, checked) {
		if (marked.has(value)) return;
		marked.add(value);

		if (value.reactions !== null) {
			for (const reaction of value.reactions) {
				const flags = reaction.f;

				if ((flags & DERIVED) !== 0) {
					mark_effects(/** @type {Derived} */ (reaction), sources, marked, checked);
				} else if (
					(flags & (ASYNC | BLOCK_EFFECT)) !== 0 &&
					(flags & DIRTY) === 0 && // we may have scheduled this one already
					depends_on(reaction, sources, checked)
				) {
					set_signal_status(reaction, DIRTY);
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/**
	 * When committing a fork, we need to trigger eager effects so that
	 * any `$state.eager(...)` expressions update immediately. This
	 * function allows us to discover them
	 * @param {Value} value
	 * @param {Set<Effect>} effects
	 */
	function mark_eager_effects(value, effects) {
		if (value.reactions === null) return;

		for (const reaction of value.reactions) {
			const flags = reaction.f;

			if ((flags & DERIVED) !== 0) {
				mark_eager_effects(/** @type {Derived} */ (reaction), effects);
			} else if ((flags & EAGER_EFFECT) !== 0) {
				set_signal_status(reaction, DIRTY);
				effects.add(/** @type {Effect} */ (reaction));
			}
		}
	}

	/**
	 * @param {Reaction} reaction
	 * @param {Source[]} sources
	 * @param {Map<Reaction, boolean>} checked
	 */
	function depends_on(reaction, sources, checked) {
		const depends = checked.get(reaction);
		if (depends !== undefined) return depends;

		if (reaction.deps !== null) {
			for (const dep of reaction.deps) {
				if (sources.includes(dep)) {
					return true;
				}

				if ((dep.f & DERIVED) !== 0 && depends_on(/** @type {Derived} */ (dep), sources, checked)) {
					checked.set(/** @type {Derived} */ (dep), true);
					return true;
				}
			}
		}

		checked.set(reaction, false);

		return false;
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			// if the effect is being scheduled because a parent (each/await/etc) block
			// updated an internal source, bail out or we'll cause a second flush
			if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0) {
				return;
			}

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 * Creates a 'fork', in which state changes are evaluated but not applied to the DOM.
	 * This is useful for speculatively loading data (for example) when you suspect that
	 * the user is about to take some action.
	 *
	 * Frameworks like SvelteKit can use this to preload data when the user touches or
	 * hovers over a link, making any subsequent navigation feel instantaneous.
	 *
	 * The `fn` parameter is a synchronous function that modifies some state. The
	 * state changes will be reverted after the fork is initialised, then reapplied
	 * if and when the fork is eventually committed.
	 *
	 * When it becomes clear that a fork will _not_ be committed (e.g. because the
	 * user navigated elsewhere), it must be discarded to avoid leaking memory.
	 *
	 * @param {() => void} fn
	 * @returns {Fork}
	 * @since 5.42
	 */
	function fork(fn) {
		{
			experimental_async_fork();
		}

		if (current_batch !== null) {
			fork_timing();
		}

		var batch = Batch.ensure();
		batch.is_fork = true;

		var committed = false;
		var settled = batch.settled();

		flushSync(fn);

		// revert state changes
		for (var [source, value] of batch.previous) {
			source.v = value;
		}

		return {
			commit: async () => {
				if (committed) {
					await settled;
					return;
				}

				if (!batches.has(batch)) {
					fork_discarded();
				}

				committed = true;

				batch.is_fork = false;

				// apply changes
				for (var [source, value] of batch.current) {
					source.v = value;
				}

				// trigger any `$state.eager(...)` expressions with the new state.
				// eager effects don't get scheduled like other effects, so we
				// can't just encounter them during traversal, we need to
				// proactively flush them
				// TODO maybe there's a better implementation?
				flushSync(() => {
					/** @type {Set<Effect>} */
					var eager_effects = new Set();

					for (var source of batch.current.keys()) {
						mark_eager_effects(source, eager_effects);
					}

					set_eager_effects(eager_effects);
					flush_eager_effects();
				});

				batch.revive();
				await settled;
			},
			discard: () => {
				if (!committed && batches.has(batch)) {
					batches.delete(batch);
					batch.discard();
				}
			}
		};
	}

	/**
	 * Returns a `subscribe` function that integrates external event-based systems with Svelte's reactivity.
	 * It's particularly useful for integrating with web APIs like `MediaQuery`, `IntersectionObserver`, or `WebSocket`.
	 *
	 * If `subscribe` is called inside an effect (including indirectly, for example inside a getter),
	 * the `start` callback will be called with an `update` function. Whenever `update` is called, the effect re-runs.
	 *
	 * If `start` returns a cleanup function, it will be called when the effect is destroyed.
	 *
	 * If `subscribe` is called in multiple effects, `start` will only be called once as long as the effects
	 * are active, and the returned teardown function will only be called when all effects are destroyed.
	 *
	 * It's best understood with an example. Here's an implementation of [`MediaQuery`](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery):
	 *
	 * ```js
	 * import { createSubscriber } from 'svelte/reactivity';
	 * import { on } from 'svelte/events';
	 *
	 * export class MediaQuery {
	 * 	#query;
	 * 	#subscribe;
	 *
	 * 	constructor(query) {
	 * 		this.#query = window.matchMedia(`(${query})`);
	 *
	 * 		this.#subscribe = createSubscriber((update) => {
	 * 			// when the `change` event occurs, re-run any effects that read `this.current`
	 * 			const off = on(this.#query, 'change', update);
	 *
	 * 			// stop listening when all the effects are destroyed
	 * 			return () => off();
	 * 		});
	 * 	}
	 *
	 * 	get current() {
	 * 		// This makes the getter reactive, if read in an effect
	 * 		this.#subscribe();
	 *
	 * 		// Return the current state of the query, whether or not we're in an effect
	 * 		return this.#query.matches;
	 * 	}
	 * }
	 * ```
	 * @param {(update: () => void) => (() => void) | void} start
	 * @since 5.7.0
	 */
	function createSubscriber(start) {
		let subscribers = 0;
		let version = source(0);
		/** @type {(() => void) | void} */
		let stop;

		{
			tag(version, 'createSubscriber version');
		}

		return () => {
			if (effect_tracking()) {
				get$3(version);

				render_effect(() => {
					if (subscribers === 0) {
						stop = untrack(() => start(() => increment(version)));
					}

					subscribers += 1;

					return () => {
						queue_micro_task(() => {
							// Only count down after a microtask, else we would reach 0 before our own render effect reruns,
							// but reach 1 again when the tick callback of the prior teardown runs. That would mean we
							// re-subcribe unnecessarily and create a memory leak because the old subscription is never cleaned up.
							subscribers -= 1;

							if (subscribers === 0) {
								stop?.();
								stop = undefined;
								// Increment the version to ensure any dependent deriveds are marked dirty when the subscription is picked up again later.
								// If we didn't do this then the comparison of write versions would determine that the derived has a later version than
								// the subscriber, and it would not be re-run.
								increment(version);
							}
						});
					};
				});
			}
		};
	}

	/** @import { Effect, Source, TemplateNode, } from '#client' */

	/**
	 * @typedef {{
	 * 	 onerror?: (error: unknown, reset: () => void) => void;
	 *   failed?: (anchor: Node, error: () => unknown, reset: () => () => void) => void;
	 *   pending?: (anchor: Node) => void;
	 * }} BoundaryProps
	 */

	var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;

	/**
	 * @param {TemplateNode} node
	 * @param {BoundaryProps} props
	 * @param {((anchor: Node) => void)} children
	 * @returns {void}
	 */
	function boundary(node, props, children) {
		new Boundary(node, props, children);
	}

	class Boundary {
		/** @type {Boundary | null} */
		parent;

		#pending = false;

		/** @type {TemplateNode} */
		#anchor;

		/** @type {TemplateNode | null} */
		#hydrate_open = hydrating ? hydrate_node : null;

		/** @type {BoundaryProps} */
		#props;

		/** @type {((anchor: Node) => void)} */
		#children;

		/** @type {Effect} */
		#effect;

		/** @type {Effect | null} */
		#main_effect = null;

		/** @type {Effect | null} */
		#pending_effect = null;

		/** @type {Effect | null} */
		#failed_effect = null;

		/** @type {DocumentFragment | null} */
		#offscreen_fragment = null;

		/** @type {TemplateNode | null} */
		#pending_anchor = null;

		#local_pending_count = 0;
		#pending_count = 0;

		#is_creating_fallback = false;

		/**
		 * A source containing the number of pending async deriveds/expressions.
		 * Only created if `$effect.pending()` is used inside the boundary,
		 * otherwise updating the source results in needless `Batch.ensure()`
		 * calls followed by no-op flushes
		 * @type {Source<number> | null}
		 */
		#effect_pending = null;

		#effect_pending_subscriber = createSubscriber(() => {
			this.#effect_pending = source(this.#local_pending_count);

			{
				tag(this.#effect_pending, '$effect.pending()');
			}

			return () => {
				this.#effect_pending = null;
			};
		});

		/**
		 * @param {TemplateNode} node
		 * @param {BoundaryProps} props
		 * @param {((anchor: Node) => void)} children
		 */
		constructor(node, props, children) {
			this.#anchor = node;
			this.#props = props;
			this.#children = children;

			this.parent = /** @type {Effect} */ (active_effect).b;

			this.#pending = !!this.#props.pending;

			this.#effect = block(() => {
				/** @type {Effect} */ (active_effect).b = this;

				if (hydrating) {
					const comment = this.#hydrate_open;
					hydrate_next();

					const server_rendered_pending =
						/** @type {Comment} */ (comment).nodeType === COMMENT_NODE &&
						/** @type {Comment} */ (comment).data === HYDRATION_START_ELSE;

					if (server_rendered_pending) {
						this.#hydrate_pending_content();
					} else {
						this.#hydrate_resolved_content();
					}
				} else {
					var anchor = this.#get_anchor();

					try {
						this.#main_effect = branch(() => children(anchor));
					} catch (error) {
						this.error(error);
					}

					if (this.#pending_count > 0) {
						this.#show_pending_snippet();
					} else {
						this.#pending = false;
					}
				}

				return () => {
					this.#pending_anchor?.remove();
				};
			}, flags);

			if (hydrating) {
				this.#anchor = hydrate_node;
			}
		}

		#hydrate_resolved_content() {
			try {
				this.#main_effect = branch(() => this.#children(this.#anchor));
			} catch (error) {
				this.error(error);
			}

			// Since server rendered resolved content, we never show pending state
			// Even if client-side async operations are still running, the content is already displayed
			this.#pending = false;
		}

		#hydrate_pending_content() {
			const pending = this.#props.pending;
			if (!pending) {
				return;
			}
			this.#pending_effect = branch(() => pending(this.#anchor));

			Batch.enqueue(() => {
				var anchor = this.#get_anchor();

				this.#main_effect = this.#run(() => {
					Batch.ensure();
					return branch(() => this.#children(anchor));
				});

				if (this.#pending_count > 0) {
					this.#show_pending_snippet();
				} else {
					pause_effect(/** @type {Effect} */ (this.#pending_effect), () => {
						this.#pending_effect = null;
					});

					this.#pending = false;
				}
			});
		}

		#get_anchor() {
			var anchor = this.#anchor;

			if (this.#pending) {
				this.#pending_anchor = create_text();
				this.#anchor.before(this.#pending_anchor);

				anchor = this.#pending_anchor;
			}

			return anchor;
		}

		/**
		 * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
		 * @returns {boolean}
		 */
		is_pending() {
			return this.#pending || (!!this.parent && this.parent.is_pending());
		}

		has_pending_snippet() {
			return !!this.#props.pending;
		}

		/**
		 * @param {() => Effect | null} fn
		 */
		#run(fn) {
			var previous_effect = active_effect;
			var previous_reaction = active_reaction;
			var previous_ctx = component_context;

			set_active_effect(this.#effect);
			set_active_reaction(this.#effect);
			set_component_context(this.#effect.ctx);

			try {
				return fn();
			} catch (e) {
				handle_error(e);
				return null;
			} finally {
				set_active_effect(previous_effect);
				set_active_reaction(previous_reaction);
				set_component_context(previous_ctx);
			}
		}

		#show_pending_snippet() {
			const pending = /** @type {(anchor: Node) => void} */ (this.#props.pending);

			if (this.#main_effect !== null) {
				this.#offscreen_fragment = document.createDocumentFragment();
				this.#offscreen_fragment.append(/** @type {TemplateNode} */ (this.#pending_anchor));
				move_effect(this.#main_effect, this.#offscreen_fragment);
			}

			if (this.#pending_effect === null) {
				this.#pending_effect = branch(() => pending(this.#anchor));
			}
		}

		/**
		 * Updates the pending count associated with the currently visible pending snippet,
		 * if any, such that we can replace the snippet with content once work is done
		 * @param {1 | -1} d
		 */
		#update_pending_count(d) {
			if (!this.has_pending_snippet()) {
				if (this.parent) {
					this.parent.#update_pending_count(d);
				}

				// if there's no parent, we're in a scope with no pending snippet
				return;
			}

			this.#pending_count += d;

			if (this.#pending_count === 0) {
				this.#pending = false;

				if (this.#pending_effect) {
					pause_effect(this.#pending_effect, () => {
						this.#pending_effect = null;
					});
				}

				if (this.#offscreen_fragment) {
					this.#anchor.before(this.#offscreen_fragment);
					this.#offscreen_fragment = null;
				}
			}
		}

		/**
		 * Update the source that powers `$effect.pending()` inside this boundary,
		 * and controls when the current `pending` snippet (if any) is removed.
		 * Do not call from inside the class
		 * @param {1 | -1} d
		 */
		update_pending_count(d) {
			this.#update_pending_count(d);

			this.#local_pending_count += d;

			if (this.#effect_pending) {
				internal_set(this.#effect_pending, this.#local_pending_count);
			}
		}

		get_effect_pending() {
			this.#effect_pending_subscriber();
			return get$3(/** @type {Source<number>} */ (this.#effect_pending));
		}

		/** @param {unknown} error */
		error(error) {
			var onerror = this.#props.onerror;
			let failed = this.#props.failed;

			// If we have nothing to capture the error, or if we hit an error while
			// rendering the fallback, re-throw for another boundary to handle
			if (this.#is_creating_fallback || (!onerror && !failed)) {
				throw error;
			}

			if (this.#main_effect) {
				destroy_effect(this.#main_effect);
				this.#main_effect = null;
			}

			if (this.#pending_effect) {
				destroy_effect(this.#pending_effect);
				this.#pending_effect = null;
			}

			if (this.#failed_effect) {
				destroy_effect(this.#failed_effect);
				this.#failed_effect = null;
			}

			if (hydrating) {
				set_hydrate_node(/** @type {TemplateNode} */ (this.#hydrate_open));
				next();
				set_hydrate_node(skip_nodes());
			}

			var did_reset = false;
			var calling_on_error = false;

			const reset = () => {
				if (did_reset) {
					svelte_boundary_reset_noop();
					return;
				}

				did_reset = true;

				if (calling_on_error) {
					svelte_boundary_reset_onerror();
				}

				// If the failure happened while flushing effects, current_batch can be null
				Batch.ensure();

				this.#local_pending_count = 0;

				if (this.#failed_effect !== null) {
					pause_effect(this.#failed_effect, () => {
						this.#failed_effect = null;
					});
				}

				// we intentionally do not try to find the nearest pending boundary. If this boundary has one, we'll render it on reset
				// but it would be really weird to show the parent's boundary on a child reset.
				this.#pending = this.has_pending_snippet();

				this.#main_effect = this.#run(() => {
					this.#is_creating_fallback = false;
					return branch(() => this.#children(this.#anchor));
				});

				if (this.#pending_count > 0) {
					this.#show_pending_snippet();
				} else {
					this.#pending = false;
				}
			};

			var previous_reaction = active_reaction;

			try {
				set_active_reaction(null);
				calling_on_error = true;
				onerror?.(error, reset);
				calling_on_error = false;
			} catch (error) {
				invoke_error_boundary(error, this.#effect && this.#effect.parent);
			} finally {
				set_active_reaction(previous_reaction);
			}

			if (failed) {
				queue_micro_task(() => {
					this.#failed_effect = this.#run(() => {
						Batch.ensure();
						this.#is_creating_fallback = true;

						try {
							return branch(() => {
								failed(
									this.#anchor,
									() => error,
									() => reset
								);
							});
						} catch (error) {
							invoke_error_boundary(error, /** @type {Effect} */ (this.#effect.parent));
							return null;
						} finally {
							this.#is_creating_fallback = false;
						}
					});
				});
			}
		}
	}

	/** @import { Effect, TemplateNode, Value } from '#client' */

	/**
	 * @param {Array<Promise<void>>} blockers
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {(values: Value[]) => any} fn
	 */
	function flatten(blockers, sync, async, fn) {
		const d = is_runes() ? derived : derived_safe_equal;

		if (async.length === 0 && blockers.length === 0) {
			fn(sync.map(d));
			return;
		}

		var batch = current_batch;
		var parent = /** @type {Effect} */ (active_effect);

		var restore = capture();

		function run() {
			Promise.all(async.map((expression) => async_derived(expression)))
				.then((result) => {
					restore();

					try {
						fn([...sync.map(d), ...result]);
					} catch (error) {
						// ignore errors in blocks that have already been destroyed
						if ((parent.f & DESTROYED) === 0) {
							invoke_error_boundary(error, parent);
						}
					}

					batch?.deactivate();
					unset_context();
				})
				.catch((error) => {
					invoke_error_boundary(error, parent);
				});
		}

		if (blockers.length > 0) {
			Promise.all(blockers).then(() => {
				restore();

				try {
					return run();
				} finally {
					batch?.deactivate();
					unset_context();
				}
			});
		} else {
			run();
		}
	}

	/**
	 * Captures the current effect context so that we can restore it after
	 * some asynchronous work has happened (so that e.g. `await a + b`
	 * causes `b` to be registered as a dependency).
	 */
	function capture() {
		var previous_effect = active_effect;
		var previous_reaction = active_reaction;
		var previous_component_context = component_context;
		var previous_batch = current_batch;

		{
			var previous_dev_stack = dev_stack;
		}

		return function restore(activate_batch = true) {
			set_active_effect(previous_effect);
			set_active_reaction(previous_reaction);
			set_component_context(previous_component_context);
			if (activate_batch) previous_batch?.activate();

			{
				set_dev_stack(previous_dev_stack);
			}
		};
	}

	function unset_context() {
		set_active_effect(null);
		set_active_reaction(null);
		set_component_context(null);

		{
			set_dev_stack(null);
		}
	}

	/** @import { Derived, Effect, Source } from '#client' */
	/** @import { Batch } from './batch.js'; */

	const recent_async_deriveds = new Set();

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_PRESERVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (UNINITIALIZED),
			wv: 0,
			parent: parent_derived ?? active_effect,
			ac: null
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V | Promise<V>} fn
	 * @param {string} [location] If provided, print a warning if the value is not read immediately after update
	 * @returns {Promise<Source<V>>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function async_derived(fn, location) {
		let parent = /** @type {Effect | null} */ (active_effect);

		if (parent === null) {
			async_derived_orphan();
		}

		var boundary = /** @type {Boundary} */ (parent.b);

		var promise = /** @type {Promise<V>} */ (/** @type {unknown} */ (undefined));
		var signal = source(/** @type {V} */ (UNINITIALIZED));

		// only suspend in async deriveds created on initialisation
		var should_suspend = !active_reaction;

		/** @type {Map<Batch, ReturnType<typeof deferred<V>>>} */
		var deferreds = new Map();

		async_effect(() => {

			/** @type {ReturnType<typeof deferred<V>>} */
			var d = deferred();
			promise = d.promise;

			try {
				// If this code is changed at some point, make sure to still access the then property
				// of fn() to read any signals it might access, so that we track them as dependencies.
				// We call `unset_context` to undo any `save` calls that happen inside `fn()`
				Promise.resolve(fn())
					.then(d.resolve, d.reject)
					.then(() => {
						if (batch === current_batch && batch.committed) {
							// if the batch was rejected as stale, we need to cleanup
							// after any `$.save(...)` calls inside `fn()`
							batch.deactivate();
						}

						unset_context();
					});
			} catch (error) {
				d.reject(error);
				unset_context();
			}

			var batch = /** @type {Batch} */ (current_batch);

			if (should_suspend) {
				var blocking = !boundary.is_pending();

				boundary.update_pending_count(1);
				batch.increment(blocking);

				deferreds.get(batch)?.reject(STALE_REACTION);
				deferreds.delete(batch); // delete to ensure correct order in Map iteration below
				deferreds.set(batch, d);
			}

			/**
			 * @param {any} value
			 * @param {unknown} error
			 */
			const handler = (value, error = undefined) => {

				batch.activate();

				if (error) {
					if (error !== STALE_REACTION) {
						signal.f |= ERROR_VALUE;

						// @ts-expect-error the error is the wrong type, but we don't care
						internal_set(signal, error);
					}
				} else {
					if ((signal.f & ERROR_VALUE) !== 0) {
						signal.f ^= ERROR_VALUE;
					}

					internal_set(signal, value);

					// All prior async derived runs are now stale
					for (const [b, d] of deferreds) {
						deferreds.delete(b);
						if (b === batch) break;
						d.reject(STALE_REACTION);
					}
				}

				if (should_suspend) {
					boundary.update_pending_count(-1);
					batch.decrement(blocking);
				}
			};

			d.promise.then(handler, (e) => handler(null, e || 'unknown'));
		});

		teardown(() => {
			for (const d of deferreds.values()) {
				d.reject(STALE_REACTION);
			}
		});

		{
			// add a flag that lets this be printed as a derived
			// when using `$inspect.trace()`
			signal.f |= ASYNC;
		}

		return new Promise((fulfil) => {
			/** @param {Promise<V>} p */
			function next(p) {
				function go() {
					if (p === promise) {
						fulfil(signal);
					} else {
						// if the effect re-runs before the initial promise
						// resolves, delay resolution until we have a value
						next(promise);
					}
				}

				p.then(go, go);
			}

			next(promise);
		});
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function user_derived(fn) {
		const d = derived(fn);

		push_reaction_value(d);

		return d;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			let prev_eager_effects = eager_effects;
			set_eager_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				derived.f &= ~WAS_MARKED;
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_eager_effects(prev_eager_effects);
				stack.pop();
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			// TODO can we avoid setting `derived.v` when `batch_values !== null`,
			// without causing the value to be stale later?
			derived.v = value;
			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) {
			return;
		}

		if (batch_values !== null) {
			batch_values.set(derived, derived.v);
		} else {
			var status =
				(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

			set_signal_status(derived, status);
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Set<any>} */
	let eager_effects = new Set();

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	/**
	 * @param {Set<any>} v
	 */
	function set_eager_effects(v) {
		eager_effects = v;
	}

	let eager_effects_deferred = false;

	function set_eager_effects_deferred() {
		eager_effects_deferred = true;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Value<V>} source
	 * @param {V} value
	 */
	function mutate(source, value) {
		set(
			source,
			untrack(() => get$3(source))
		);
		return value;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			// since we are untracking the function inside `$inspect.with` we need to add this check
			// to ensure we error if state is set inside an inspect effect
			(!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 &&
			!current_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		{
			tag_proxy(new_value, /** @type {string} */ (source.label));
		}

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			var batch = Batch.ensure();
			batch.capture(source, old_value);

			{
				if (active_effect !== null) {
					const error = get_stack('updated at');

					if (error !== null) {
						source.updated ??= new Map();
						let entry = source.updated.get(error.stack);

						if (!entry) {
							entry = { error, count: 0 };
							source.updated.set(error.stack, entry);
						}

						entry.count++;
					}
				}

				if (active_effect !== null) {
					source.set_during_effect = true;
				}
			}

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
				flush_eager_effects();
			}
		}

		return value;
	}

	function flush_eager_effects() {
		eager_effects_deferred = false;

		const inspects = Array.from(eager_effects);

		for (const effect of inspects) {
			// Mark clean inspect-effects as maybe dirty and then check their dirtiness
			// instead of just updating the effects - this way we avoid overfiring.
			if ((effect.f & CLEAN) !== 0) {
				set_signal_status(effect, MAYBE_DIRTY);
			}

			if (is_dirty(effect)) {
				update_effect(effect);
			}
		}

		eager_effects.clear();
	}

	/**
	 * @template {number | bigint} T
	 * @param {Source<T>} source
	 * @param {1 | -1} [d]
	 * @returns {T}
	 */
	function update(source, d = 1) {
		var value = get$3(source);
		var result = d === 1 ? value++ : value--;

		set(source, value);

		// @ts-expect-error
		return result;
	}

	/**
	 * Silently (without using `get`) increment a source
	 * @param {Source<number>} source
	 */
	function increment(source) {
		set(source, source.v + 1);
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if ((flags & EAGER_EFFECT) !== 0) {
				eager_effects.add(reaction);
				continue;
			}

			var not_dirty = (flags & DIRTY) === 0;

			// don't set a DIRTY reaction to MAYBE_DIRTY
			if (not_dirty) {
				set_signal_status(reaction, status);
			}

			if ((flags & DERIVED) !== 0) {
				if ((flags & WAS_MARKED) === 0) {
					reaction.f |= WAS_MARKED;
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				}
			} else if (not_dirty) {
				if ((flags & BLOCK_EFFECT) !== 0) {
					if (eager_block_effects !== null) {
						eager_block_effects.add(/** @type {Effect} */ (reaction));
					}
				}

				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @import { Source } from '#client' */

	// TODO move all regexes into shared module?
	const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);
		var parent_version = update_version;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			if (update_version === parent_version) {
				return fn();
			}

			// child source is being created after the initial proxy —
			// prevent it from being associated with the current reaction
			var reaction = active_reaction;
			var version = update_version;

			set_active_reaction(null);
			set_update_version(parent_version);

			var result = fn();

			set_active_reaction(reaction);
			set_update_version(version);

			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length));
			{
				value = /** @type {any} */ (inspectable_array(/** @type {any[]} */ (value)));
			}
		}

		/** Used in dev for $inspect.trace() */
		var path = '';
		let updating = false;
		/** @param {string} new_path */
		function update_path(new_path) {
			if (updating) return;
			updating = true;
			path = new_path;

			tag(version, `${path} version`);

			// rename all child sources and child proxies
			for (const [prop, source] of sources) {
				tag(source, get_label(path, prop));
			}
			updating = false;
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value);
						sources.set(prop, s);
						if (typeof prop === 'string') {
							tag(s, get_label(path, prop));
						}
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED));
						sources.set(prop, s);
						increment(version);

						{
							tag(s, get_label(path, prop));
						}
					}
				} else {
					set(s, UNINITIALIZED);
					increment(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				if (prop === PROXY_PATH_SYMBOL) {
					return update_path;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p);

						{
							tag(s, get_label(path, prop));
						}

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get$3(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get$3(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p);

							{
								tag(s, get_label(path, prop));
							}

							return s;
						});

						sources.set(prop, s);
					}

					var value = get$3(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create an uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED));
							sources.set(i + '', other_s);

							{
								tag(other_s, get_label(path, i));
							}
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined));

						{
							tag(s, get_label(path, prop));
						}
						set(s, proxy(value));

						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					increment(version);
				}

				return true;
			},

			ownKeys(target) {
				get$3(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {string} path
	 * @param {string | symbol} prop
	 */
	function get_label(path, prop) {
		if (typeof prop === 'symbol') return `${path}[Symbol(${prop.description ?? ''})]`;
		if (regex_is_valid_identifier.test(prop)) return `${path}.${prop}`;
		return /^\d+$/.test(prop) ? `${path}[${prop}]` : `${path}['${prop}']`;
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	const ARRAY_MUTATING_METHODS = new Set([
		'copyWithin',
		'fill',
		'pop',
		'push',
		'reverse',
		'shift',
		'sort',
		'splice',
		'unshift'
	]);

	/**
	 * Wrap array mutating methods so $inspect is triggered only once and
	 * to prevent logging an array in intermediate state (e.g. with an empty slot)
	 * @param {any[]} array
	 */
	function inspectable_array(array) {
		return new Proxy(array, {
			get(target, prop, receiver) {
				var value = Reflect.get(target, prop, receiver);
				if (!ARRAY_MUTATING_METHODS.has(/** @type {string} */ (prop))) {
					return value;
				}

				/**
				 * @this {any[]}
				 * @param {any[]} args
				 */
				return function (...args) {
					set_eager_effects_deferred();
					var result = value.apply(this, args);
					flush_eager_effects();
					return result;
				};
			}
		});
	}

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/** @import { Effect, TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}

		{
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		if (!hydrating) {
			return get_first_child(node);
		}

		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
		if (child === null) {
			child = hydrate_node.appendChild(create_text());
		} else if (is_text && child.nodeType !== TEXT_NODE) {
			var text = create_text();
			child?.before(text);
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(child);
		return child;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode | TemplateNode[]} fragment
	 * @param {boolean} [is_text]
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text = false) {
		if (!hydrating) {
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}

		// if an {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
			var text = create_text();

			hydrate_node?.before(text);
			set_hydrate_node(text);
			return text;
		}

		return hydrate_node;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = hydrating ? hydrate_node : node;
		var last_sibling;

		while (count--) {
			last_sibling = next_sibling;
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		if (!hydrating) {
			return next_sibling;
		}

		// if a sibling {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
			var text = create_text();
			// If the next sibling is `null` and we're handling text then it's because
			// the SSR content was empty for the text, so we need to generate a new text
			// node and insert it after the last sibling
			if (next_sibling === null) {
				last_sibling?.after(text);
			} else {
				next_sibling.before(text);
			}
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(next_sibling);
		return /** @type {TemplateNode} */ (next_sibling);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/**
	 * Returns `true` if we're updating the current block, for example `condition` in
	 * an `{#if condition}` block just changed. In this case, the branch should be
	 * appended (or removed) at the same time as other updates within the
	 * current `<svelte:boundary>`
	 */
	function should_defer_append() {
		return false;
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	/**
	 * The child of a textarea actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLTextAreaElement} dom
	 * @returns {void}
	 */
	function remove_textarea_child(dom) {
		if (hydrating && get_first_child(dom) !== null) {
			clear_text_content(dom);
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		{
			// Ensure the parent is never an inspect effect
			while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
				parent = parent.parent;
			}
		}

		if (parent !== null && (parent.f & INERT) !== 0) {
			type |= INERT;
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			b: parent && parent.b,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0,
			ac: null
		};

		{
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		if (push) {
			/** @type {Effect | null} */
			var e = effect;

			// if an effect has already ran and doesn't need to be kept in the tree
			// (because it won't re-run, has no DOM, and has no teardown etc)
			// then we skip it and go to its child (if any)
			if (
				sync &&
				e.deps === null &&
				e.teardown === null &&
				e.nodes_start === null &&
				e.first === e.last && // either `null`, or a singular child
				(e.f & EFFECT_PRESERVED) === 0
			) {
				e = e.first;
				if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e !== null) {
					e.f |= EFFECT_TRANSPARENT;
				}
			}

			if (e !== null) {
				e.parent = parent;

				if (parent !== null) {
					push_effect(e, parent);
				}

				// if we're in a derived, add the effect there too
				if (
					active_reaction !== null &&
					(active_reaction.f & DERIVED) !== 0 &&
					(type & ROOT_EFFECT) === 0
				) {
					var derived = /** @type {Derived} */ (active_reaction);
					(derived.effects ??= []).push(e);
				}
			}
		}

		return effect;
	}

	/**
	 * Internal representation of `$effect.tracking()`
	 * @returns {boolean}
	 */
	function effect_tracking() {
		return active_reaction !== null && !untracking;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		{
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var flags = /** @type {Effect} */ (active_effect).f;
		var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;

		if (defer) {
			// Top-level `$effect(...)` in an unmounted component — defer until mount
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push(fn);
		} else {
			// Everything else — create immediately
			return create_user_effect(fn);
		}
	}

	/**
	 * @param {() => void | (() => void)} fn
	 */
	function create_user_effect(fn) {
		return create_effect(EFFECT | USER_EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		{
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		Batch.ensure();
		const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean, deps: () => any }} */
		var token = { effect: null, ran: false, deps };

		context.l.$.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			// Run dirty `$:` statements
			for (var token of context.l.$) {
				token.deps();

				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (is_dirty(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function async_effect(fn) {
		return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {Array<Promise<void>>} blockers
	 */
	function template_effect(fn, sync = [], async = [], blockers = []) {
		flatten(blockers, sync, async, (values) => {
			create_effect(RENDER_EFFECT, () => fn(...values.map(get$3)), true);
		});
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		var effect = create_effect(BLOCK_EFFECT | flags, fn, true);
		{
			effect.dev_stack = dev_stack;
		}
		return effect;
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			const controller = effect.ac;

			if (controller !== null) {
				without_reactive_context(() => {
					controller.abort(STALE_REACTION);
				});
			}

			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes_start !== null &&
			effect.nodes_end !== null
		) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		{
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
			effect.ac =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 * @param {boolean} [destroy]
	 */
	function pause_effect(effect, callback, destroy = true) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			if (destroy) destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent =
				(child.f & EFFECT_TRANSPARENT) !== 0 ||
				// If this is a branch effect without a block effect parent,
				// it means the parent block effect was pruned. In that case,
				// transparency information was transferred to the branch effect.
				((child.f & BRANCH_EFFECT) !== 0 && (effect.f & BLOCK_EFFECT) !== 0);
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update. we don't use `is_dirty`
		// here because we don't want to eagerly recompute a derived like
		// `{#if foo}{foo.bar()}{/if}` if `foo` is now `undefined
		if ((effect.f & CLEAN) === 0) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {DocumentFragment} fragment
	 */
	function move_effect(effect, fragment) {
		var node = effect.nodes_start;
		var end = effect.nodes_end;

		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			fragment.append(node);
			node = next;
		}
	}

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_updating_effect = false;

	/** @param {boolean} value */
	function set_is_updating_effect(value) {
		is_updating_effect = value;
	}

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | Source[]}
	 */
	let current_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && (true)) {
			if (current_sources === null) {
				current_sources = [value];
			} else {
				current_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	let update_version = read_version;

	/** @param {number} value */
	function set_update_version(value) {
		update_version = value;
	}

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function is_dirty(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (flags & DERIVED) {
				reaction.f &= ~WAS_MARKED;
			}

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency, unless the effect has already been destroyed
				// (which can happen if the derived is read by an async derived)
				if (
					(is_disconnected || is_unowned_connected) &&
					(active_effect === null || (active_effect.f & DESTROYED) === 0)
				) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (is_dirty(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		if (current_sources?.includes(signal)) {
			return;
		}

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_sources = current_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var previous_update_version = update_version;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		current_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		update_version = ++read_version;

		if (reaction.ac !== null) {
			without_reactive_context(() => {
				/** @type {AbortController} */ (reaction.ac).abort(STALE_REACTION);
			});

			reaction.ac = null;
		}

		try {
			reaction.f |= REACTION_IS_UPDATING;
			var fn = /** @type {Function} */ (reaction.fn);
			var result = fn();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (
					!skip_reaction ||
					// Deriveds that already have reactions can cleanup, so we still add them as reactions
					((flags & DERIVED) !== 0 &&
						/** @type {import('#client').Derived} */ (reaction).reactions !== null)
				) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			if ((reaction.f & ERROR_VALUE) !== 0) {
				reaction.f ^= ERROR_VALUE;
			}

			return result;
		} catch (error) {
			return handle_error(error);
		} finally {
			reaction.f ^= REACTION_IS_UPDATING;
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			current_sources = previous_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
			update_version = previous_update_version;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}

		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		{
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
			var previous_stack = /** @type {any} */ (dev_stack);
			// only block effects have a dev stack, keep the current one otherwise
			set_dev_stack(effect.dev_stack ?? dev_stack);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;

			{
				set_dev_current_component_function(previous_component_fn);
				set_dev_stack(previous_stack);
			}
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {

		await Promise.resolve();

		// By calling flushSync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flushSync();
	}

	/**
	 * Returns a promise that resolves once any state changes, and asynchronous work resulting from them,
	 * have resolved and the DOM has been updated
	 * @returns {Promise<void>}
	 * @since 5.36
	 */
	function settled() {
		return Batch.ensure().settled();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get$3(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			// if we're in a derived that is being read inside an _async_ derived,
			// it's possible that the effect was already destroyed. In this case,
			// we don't add the dependency, because that would create a memory leak
			var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;

			if (!destroyed && !current_sources?.includes(signal)) {
				var deps = active_reaction.deps;

				if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
					// we're in the effect init/update cycle
					if (signal.rv < read_version) {
						signal.rv = read_version;

						// If the signal is accessing the same dependencies in the same
						// order as it did last time, increment `skipped_deps`
						// rather than updating `new_deps`, which creates GC cost
						if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
							skipped_deps++;
						} else if (new_deps === null) {
							new_deps = [signal];
						} else if (!skip_reaction || !new_deps.includes(signal)) {
							// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
							// an unowned derived because skip_reaction is true, then we need to ensure that
							// we don't have duplicates
							new_deps.push(signal);
						}
					}
				} else {
					// we're adding a dependency outside the init/update cycle
					// (i.e. after an `await`)
					(active_reaction.deps ??= []).push(signal);

					var reactions = signal.reactions;

					if (reactions === null) {
						signal.reactions = [active_reaction];
					} else if (!reactions.includes(active_reaction)) {
						reactions.push(active_reaction);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		{
			// TODO reinstate this, but make it actually work
			// if (current_async_effect) {
			// 	var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0;
			// 	var was_read = current_async_effect.deps?.includes(signal);

			// 	if (!tracking && !untracking && !was_read) {
			// 		w.await_reactivity_loss(/** @type {string} */ (signal.label));

			// 		var trace = get_stack('traced at');
			// 		// eslint-disable-next-line no-console
			// 		if (trace) console.warn(trace);
			// 	}
			// }

			recent_async_deriveds.delete(signal);
		}

		if (is_destroying_effect) {
			if (old_values.has(signal)) {
				return old_values.get(signal);
			}

			if (is_derived) {
				derived = /** @type {Derived} */ (signal);

				var value = derived.v;

				// if the derived is dirty and has reactions, or depends on the values that just changed, re-execute
				// (a derived can be maybe_dirty due to the effect destroy removing its last reaction)
				if (
					((derived.f & CLEAN) === 0 && derived.reactions !== null) ||
					depends_on_old_values(derived)
				) {
					value = execute_derived(derived);
				}

				old_values.set(derived, value);

				return value;
			}
		} else if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (batch_values?.has(derived)) {
				return batch_values.get(derived);
			}

			if (is_dirty(derived)) {
				update_derived(derived);
			}
		}

		if (batch_values?.has(signal)) {
			return batch_values.get(signal);
		}

		if ((signal.f & ERROR_VALUE) !== 0) {
			throw signal.v;
		}

		return signal.v;
	}

	/** @param {Derived} derived */
	function depends_on_old_values(derived) {
		if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst
		if (derived.deps === null) return false;

		for (const dep of derived.deps) {
			if (old_values.has(dep)) {
				return true;
			}

			if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	const regex_return_characters = /\r/g;

	/**
	 * @param {string} str
	 * @returns {string}
	 */
	function hash(str) {
		str = str.replace(regex_return_characters, '');
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return (hash >>> 0).toString(36);
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function can_delegate_event(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject',
		novalidate: 'noValidate',
		allowfullscreen: 'allowFullscreen',
		disablepictureinpicture: 'disablePictureInPicture',
		disableremoteplayback: 'disableRemotePlayback'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** List of elements that require raw contents and should not have SSR comments put in them */
	const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);

	/** @param {string} name */
	function is_raw_text_element(name) {
		return RAW_TEXT_ELEMENTS.includes(/** @type {typeof RAW_TEXT_ELEMENTS[number]} */ (name));
	}

	/**
	 * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
	 * @template {string | undefined} T
	 * @param {T} location
	 * @returns {T};
	 */
	function sanitize_location(location) {
		return /** @type {T} */ (location?.replace(/\//g, '/\u200b'));
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		if (
			dom === document.body ||
			// @ts-ignore
			dom === window ||
			// @ts-ignore
			dom === document ||
			// Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
			dom instanceof HTMLMediaElement
		) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	// used to store the reference to the currently propagated event
	// to prevent garbage collection between microtasks in Firefox
	// If the event object is GCed too early, the expando __root property
	// set on the event object is lost, causing the event delegation
	// to process the event twice
	let last_propagated_event = null;

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		last_propagated_event = event;

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// the `last_propagated_event === event` check is redundant, but
		// without it the variable will be DCE'd and things will
		// fail mysteriously in Firefox
		// @ts-expect-error is added below
		var handled_at = last_propagated_event === event && event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						delegated.call(current_target, event);
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { TemplateStructure } from './types' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {
			if (hydrating) {
				assign_nodes(hydrate_node, null);
				return hydrate_node;
			}

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text(value = '') {
		if (!hydrating) {
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}

		var node = hydrate_node;

		if (node.nodeType !== TEXT_NODE) {
			// if an {expression} is empty during SSR, we need to insert an empty text node
			node.before((node = create_text()));
			set_hydrate_node(node);
		}

		assign_nodes(node, node);
		return node;
	}

	/**
	 * @returns {TemplateNode | DocumentFragment}
	 */
	function comment() {
		// we're not delegating to `template` here for performance reasons
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {
		if (hydrating) {
			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
			hydrate_next();
			return;
		}

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true — block effects should run their intro transitions —
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/** @param {boolean} value */
	function set_should_intro(value) {
		should_intro = value;
	}

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/**
	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {{} extends Props ? {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props?: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	} : {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	}} options
	 * @returns {Exports}
	 */
	function hydrate(component, options) {
		init_operations();
		options.intro = options.intro ?? false;
		const target = options.target;
		const was_hydrating = hydrating;
		const previous_hydrate_node = hydrate_node;

		try {
			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
			while (
				anchor &&
				(anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
			) {
				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
			}

			if (!anchor) {
				throw HYDRATION_ERROR;
			}

			set_hydrating(true);
			set_hydrate_node(/** @type {Comment} */ (anchor));

			const instance = _mount(component, { ...options, anchor });

			set_hydrating(false);

			return /**  @type {Exports} */ (instance);
		} catch (error) {
			// re-throw Svelte errors - they are certainly not related to hydration
			if (
				error instanceof Error &&
				error.message.split('\n').some((line) => line.startsWith('https://svelte.dev/e/'))
			) {
				throw error;
			}
			if (error !== HYDRATION_ERROR) {
				// eslint-disable-next-line no-console
				console.warn('Failed to hydrate: ', error);
			}

			if (options.recover === false) {
				hydration_failed();
			}

			// If an error occurred above, the operations might not yet have been initialised.
			init_operations();
			clear_text_content(target);

			set_hydrating(false);
			return mount(component, options);
		} finally {
			set_hydrating(was_hydrating);
			set_hydrate_node(previous_hydrate_node);
		}
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		/** @type {Set<string>} */
		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			boundary(
				/** @type {TemplateNode} */ (anchor_node),
				{
					pending: () => {}
				},
				(anchor_node) => {
					if (context) {
						push({});
						var ctx = /** @type {ComponentContext} */ (component_context);
						ctx.c = context;
					}

					if (events) {
						// We can't spread the object or else we'd lose the state proxy stuff, if it is one
						/** @type {any} */ (props).$$events = events;
					}

					if (hydrating) {
						assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
					}

					should_intro = intro;
					// @ts-expect-error the public typings are not what the actual function looks like
					component = Component(anchor_node, props) || {};
					should_intro = true;

					if (hydrating) {
						/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;

						if (
							hydrate_node === null ||
							hydrate_node.nodeType !== COMMENT_NODE ||
							/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
						) {
							hydration_mismatch();
							throw HYDRATION_ERROR;
						}
					}

					if (context) {
						pop();
					}
				}
			);

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		{
			if (STATE_SYMBOL in component) {
				state_proxy_unmount();
			} else {
				lifecycle_double_unmount();
			}
		}

		return Promise.resolve();
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @typedef {{ effect: Effect, fragment: DocumentFragment }} Branch
	 */

	/**
	 * @template Key
	 */
	class BranchManager {
		/** @type {TemplateNode} */
		anchor;

		/** @type {Map<Batch, Key>} */
		#batches = new Map();

		/** @type {Map<Key, Effect>} */
		#onscreen = new Map();

		/** @type {Map<Key, Branch>} */
		#offscreen = new Map();

		/**
		 * Whether to pause (i.e. outro) on change, or destroy immediately.
		 * This is necessary for `<svelte:element>`
		 */
		#transition = true;

		/**
		 * @param {TemplateNode} anchor
		 * @param {boolean} transition
		 */
		constructor(anchor, transition = true) {
			this.anchor = anchor;
			this.#transition = transition;
		}

		#commit = () => {
			var batch = /** @type {Batch} */ (current_batch);

			// if this batch was made obsolete, bail
			if (!this.#batches.has(batch)) return;

			var key = /** @type {Key} */ (this.#batches.get(batch));

			var onscreen = this.#onscreen.get(key);

			if (onscreen) {
				// effect is already in the DOM — abort any current outro
				resume_effect(onscreen);
			} else {
				// effect is currently offscreen. put it in the DOM
				var offscreen = this.#offscreen.get(key);

				if (offscreen) {
					this.#onscreen.set(key, offscreen.effect);
					this.#offscreen.delete(key);

					// remove the anchor...
					/** @type {TemplateNode} */ (offscreen.fragment.lastChild).remove();

					// ...and append the fragment
					this.anchor.before(offscreen.fragment);
					onscreen = offscreen.effect;
				}
			}

			for (const [b, k] of this.#batches) {
				this.#batches.delete(b);

				if (b === batch) {
					// keep values for newer batches
					break;
				}

				const offscreen = this.#offscreen.get(k);

				if (offscreen) {
					// for older batches, destroy offscreen effects
					// as they will never be committed
					destroy_effect(offscreen.effect);
					this.#offscreen.delete(k);
				}
			}

			// outro/destroy all onscreen effects...
			for (const [k, effect] of this.#onscreen) {
				// ...except the one that was just committed
				if (k === key) continue;

				const on_destroy = () => {
					const keys = Array.from(this.#batches.values());

					if (keys.includes(k)) {
						// keep the effect offscreen, as another batch will need it
						var fragment = document.createDocumentFragment();
						move_effect(effect, fragment);

						fragment.append(create_text()); // TODO can we avoid this?

						this.#offscreen.set(k, { effect, fragment });
					} else {
						destroy_effect(effect);
					}

					this.#onscreen.delete(k);
				};

				if (this.#transition || !onscreen) {
					pause_effect(effect, on_destroy, false);
				} else {
					on_destroy();
				}
			}
		};

		/**
		 * @param {Batch} batch
		 */
		#discard = (batch) => {
			this.#batches.delete(batch);

			const keys = Array.from(this.#batches.values());

			for (const [k, branch] of this.#offscreen) {
				if (!keys.includes(k)) {
					destroy_effect(branch.effect);
					this.#offscreen.delete(k);
				}
			}
		};

		/**
		 *
		 * @param {any} key
		 * @param {null | ((target: TemplateNode) => void)} fn
		 */
		ensure(key, fn) {
			var batch = /** @type {Batch} */ (current_batch);
			var defer = should_defer_append();

			if (fn && !this.#onscreen.has(key) && !this.#offscreen.has(key)) {
				if (defer) {
					var fragment = document.createDocumentFragment();
					var target = create_text();

					fragment.append(target);

					this.#offscreen.set(key, {
						effect: branch(() => fn(target)),
						fragment
					});
				} else {
					this.#onscreen.set(
						key,
						branch(() => fn(this.anchor))
					);
				}
			}

			this.#batches.set(batch, key);

			if (defer) {
				for (const [k, effect] of this.#onscreen) {
					if (k === key) {
						batch.skipped_effects.delete(effect);
					} else {
						batch.skipped_effects.add(effect);
					}
				}

				for (const [k, branch] of this.#offscreen) {
					if (k === key) {
						batch.skipped_effects.delete(branch.effect);
					} else {
						batch.skipped_effects.add(branch.effect);
					}
				}

				batch.oncommit(this.#commit);
				batch.ondiscard(this.#discard);
			} else {
				if (hydrating) {
					this.anchor = hydrate_node;
				}

				this.#commit();
			}
		}
	}

	/** @import { TemplateNode } from '#client' */

	// TODO reinstate https://github.com/sveltejs/svelte/pull/15250

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {
		if (hydrating) {
			hydrate_next();
		}

		var branches = new BranchManager(node);
		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		/**
		 * @param {boolean} condition,
		 * @param {null | ((anchor: Node) => void)} fn
		 */
		function update_branch(condition, fn) {
			if (hydrating) {
				const is_else = read_hydration_instruction(node) === HYDRATION_START_ELSE;

				if (condition === is_else) {
					// Hydration mismatch: remove everything inside the anchor and start fresh.
					// This could happen with `{#if browser}...{/if}`, for example
					var anchor = skip_nodes();

					set_hydrate_node(anchor);
					branches.anchor = anchor;

					set_hydrating(false);
					branches.ensure(condition, fn);
					set_hydrating(true);

					return;
				}
			}

			branches.ensure(condition, fn);
		}

		block(() => {
			var has_branch = false;

			fn((fn, flag = true) => {
				has_branch = true;
				update_branch(flag, fn);
			});

			if (!has_branch) {
				update_branch(false, null);
			}
		}, flags);
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	/**
	 * The row of a keyed each block that is currently updating. We track this
	 * so that `animate:` directives have something to attach themselves to
	 * @type {EachItem | null}
	 */
	let current_each_item = null;

	/** @param {EachItem | null} item */
	function set_current_each_item(item) {
		current_each_item = item;
	}

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index$e(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 */
	function pause_effects(state, items, controlled_anchor) {
		var items_map = state.items;

		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = hydrating
				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
				: parent_node.appendChild(create_text());
		}

		if (hydrating) {
			hydrate_next();
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		/** @type {Map<any, EachItem>} */
		var offscreen_items = new Map();

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		/** @type {V[]} */
		var array;

		/** @type {Effect} */
		var each_effect;

		function commit() {
			reconcile(
				each_effect,
				array,
				state,
				offscreen_items,
				anchor,
				render_fn,
				flags,
				get_key,
				get_collection
			);

			if (fallback_fn !== null) {
				if (array.length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}
		}

		block(() => {
			// store a reference to the effect so that we can update the start/end nodes in reconciliation
			each_effect ??= /** @type {Effect} */ (active_effect);

			array = /** @type {V[]} */ (get$3(each_array));
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;

				if (is_else !== (length === 0)) {
					// hydration mismatch — remove the server-rendered DOM and start over
					anchor = skip_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			// this is separate to the previous block because `hydrating` might change
			if (hydrating) {
				/** @type {EachItem | null} */
				var prev = null;

				/** @type {EachItem} */
				var item;

				for (var i = 0; i < length; i++) {
					if (
						hydrate_node.nodeType === COMMENT_NODE &&
						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
					) {
						// The server rendered fewer items than expected,
						// so break out and continue appending non-hydrated items
						anchor = /** @type {Comment} */ (hydrate_node);
						mismatch = true;
						set_hydrating(false);
						break;
					}

					var value = array[i];
					var key = get_key(value, i);
					item = create_item(
						hydrate_node,
						state,
						prev,
						null,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
					state.items.set(key, item);

					prev = item;
				}

				// remove excess nodes
				if (length > 0) {
					set_hydrate_node(skip_nodes());
				}
			}

			if (hydrating) {
				if (length === 0 && fallback_fn) {
					fallback = branch(() => fallback_fn(anchor));
				}
			} else {
				if (should_defer_append()) {
					var keys = new Set();
					var batch = /** @type {Batch} */ (current_batch);

					for (i = 0; i < length; i += 1) {
						value = array[i];
						key = get_key(value, i);

						var existing = state.items.get(key) ?? offscreen_items.get(key);

						if (existing) {
							// update before reconciliation, to trigger any async updates
							if ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
								update_item(existing, value, i, flags);
							}
						} else {
							item = create_item(
								null,
								state,
								null,
								null,
								value,
								key,
								i,
								render_fn,
								flags,
								get_collection,
								true
							);

							offscreen_items.set(key, item);
						}

						keys.add(key);
					}

					for (const [key, item] of state.items) {
						if (!keys.has(key)) {
							batch.skipped_effects.add(item.e);
						}
					}

					batch.oncommit(commit);
				} else {
					commit();
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get$3(each_array);
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Effect} each_effect
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Map<any, EachItem>} offscreen_items
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(
		each_effect,
		array,
		state,
		offscreen_items,
		anchor,
		render_fn,
		flags,
		get_key,
		get_collection
	) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);

			item = items.get(key);

			if (item === undefined) {
				var pending = offscreen_items.get(key);

				if (pending !== undefined) {
					offscreen_items.delete(key);
					items.set(key, pending);

					var next = prev ? prev.next : current;

					link(state, prev, pending);
					link(state, pending, next);

					move(pending, next, anchor);
					prev = pending;
				} else {
					var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

					prev = create_item(
						child_anchor,
						state,
						prev,
						prev === null ? state.first : prev.next,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
				}

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		each_effect.first = state.first && state.first.e;
		each_effect.last = prev && prev.e;

		for (var unused of offscreen_items.values()) {
			destroy_effect(unused.e);
		}

		offscreen_items.clear();
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node | null} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {boolean} [deferred]
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection,
		deferred
	) {
		var previous_each_item = current_each_item;
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).trace = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		current_each_item = item;

		try {
			if (anchor === null) {
				var fragment = document.createDocumentFragment();
				fragment.append((anchor = create_text()));
			}

			item.e = branch(() => render_fn(/** @type {Node} */ (anchor), v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				if (!deferred) {
					state.first = item;
				}
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
			current_each_item = previous_each_item;
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== null && node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element} element
	 * @param {string | null} server_hash
	 * @param {string} value
	 */
	function check_hash(element, server_hash, value) {
		if (!server_hash || server_hash === hash(String(value ?? ''))) return;

		let location;

		// @ts-expect-error
		const loc = element.__svelte_meta?.loc;
		if (loc) {
			location = `near ${loc.file}:${loc.line}:${loc.column}`;
		} else if (dev_current_component_function?.[FILENAME]) {
			location = `in ${dev_current_component_function[FILENAME]}`;
		}

		hydration_html_changed(sanitize_location(location));
	}

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} [svg]
	 * @param {boolean} [mathml]
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
		var anchor = node;

		var value = '';

		template_effect(() => {
			var effect = /** @type {Effect} */ (active_effect);

			if (value === (value = get_value() ?? '')) {
				if (hydrating) hydrate_next();
				return;
			}

			if (effect.nodes_start !== null) {
				remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
				effect.nodes_start = effect.nodes_end = null;
			}

			if (value === '') return;

			if (hydrating) {
				// We're deliberately not trying to repair mismatches between server and client,
				// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)
				var hash = /** @type {Comment} */ (hydrate_node).data;
				var next = hydrate_next();
				var last = next;

				while (
					next !== null &&
					(next.nodeType !== COMMENT_NODE || /** @type {Comment} */ (next).data !== '')
				) {
					last = next;
					next = /** @type {TemplateNode} */ (get_next_sibling(next));
				}

				if (next === null) {
					hydration_mismatch();
					throw HYDRATION_ERROR;
				}

				if (!skip_warning) {
					check_hash(/** @type {Element} */ (next.parentNode), hash, value);
				}

				assign_nodes(hydrate_node, last);
				anchor = set_hydrate_node(next);
				return;
			}

			var html = value + '';
			if (svg) html = `<svg>${html}</svg>`;
			else if (mathml) html = `<math>${html}</math>`;

			// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
			// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
			/** @type {DocumentFragment | Element} */
			var node = create_fragment_from_html(html);

			if (svg || mathml) {
				node = /** @type {Element} */ (get_first_child(node));
			}

			assign_nodes(
				/** @type {TemplateNode} */ (get_first_child(node)),
				/** @type {TemplateNode} */ (node.lastChild)
			);

			if (svg || mathml) {
				while (get_first_child(node)) {
					anchor.before(/** @type {Node} */ (get_first_child(node)));
				}
			} else {
				anchor.before(node);
			}
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props[name === 'default' ? 'children' : name];
			is_interop = true;
		}

		if (slot_fn === undefined) {
			if (fallback_fn !== null) {
				fallback_fn(anchor);
			}
		} else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var branches = new BranchManager(node);

		block(() => {
			const snippet = get_snippet() ?? null;

			if (snippet == null) {
				invalid_snippet();
			}

			branches.ensure(snippet, snippet && ((anchor) => snippet(anchor, ...args)));
		}, EFFECT_TRANSPARENT);
	}

	/**
	 * Create a snippet programmatically
	 * @template {unknown[]} Params
	 * @param {(...params: Getters<Params>) => {
	 *   render: () => string
	 *   setup?: (element: Element) => void | (() => void)
	 * }} fn
	 * @returns {Snippet<Params>}
	 */
	function createRawSnippet(fn) {
		// @ts-expect-error the types are a lie
		return (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {
			var snippet = fn(...params);

			/** @type {Element} */
			var element;

			if (hydrating) {
				element = /** @type {Element} */ (hydrate_node);
				hydrate_next();
			} else {
				var html = snippet.render().trim();
				var fragment = create_fragment_from_html(html);
				element = /** @type {Element} */ (get_first_child(fragment));

				if ((get_next_sibling(element) !== null || element.nodeType !== ELEMENT_NODE)) {
					invalid_raw_snippet_render();
				}

				anchor.before(element);
			}

			const result = snippet.setup?.(element);
			assign_nodes(element, element);

			if (typeof result === 'function') {
				teardown(result);
			}
		};
	}

	/** @import { TemplateNode, Dom } from '#client' */

	/**
	 * @template P
	 * @template {(props: P) => void} C
	 * @param {TemplateNode} node
	 * @param {() => C} get_component
	 * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn
	 * @returns {void}
	 */
	function component(node, get_component, render_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var branches = new BranchManager(node);

		block(() => {
			var component = get_component() ?? null;
			branches.ensure(component, component && ((target) => render_fn(target, component)));
		}, EFFECT_TRANSPARENT);
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
		let was_hydrating = hydrating;

		if (hydrating) {
			hydrate_next();
		}

		/** @type {null | Element} */
		var element = null;

		if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
			element = /** @type {Element} */ (hydrate_node);
			hydrate_next();
		}

		var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);

		/**
		 * The keyed `{#each ...}` item block, if any, that this element is inside.
		 * We track this so we can set it when changing the element, allowing any
		 * `animate:` directive to bind itself to the correct block
		 */
		var each_item_block = current_each_item;

		var branches = new BranchManager(anchor, false);

		block(() => {
			const next_tag = get_tag() || null;
			var ns = next_tag === 'svg' ? NAMESPACE_SVG : null;

			if (next_tag === null) {
				branches.ensure(null, null);
				set_should_intro(true);
				return;
			}

			branches.ensure(next_tag, (anchor) => {
				// See explanation of `each_item_block` above
				var previous_each_item = current_each_item;
				set_current_each_item(each_item_block);

				if (next_tag) {
					element = hydrating
						? /** @type {Element} */ (element)
						: ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					assign_nodes(element, element);

					if (render_fn) {
						if (hydrating && is_raw_text_element(next_tag)) {
							// prevent hydration glitches
							element.append(document.createComment(''));
						}

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							hydrating ? get_first_child(element) : element.appendChild(create_text())
						);

						if (hydrating) {
							if (child_anchor === null) {
								set_hydrating(false);
							} else {
								set_hydrate_node(child_anchor);
							}
						}

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				}

				set_current_each_item(previous_each_item);

				if (hydrating) {
					set_hydrate_node(anchor);
				}
			});

			// revert to the default state after the effect has been created
			set_should_intro(true);

			return () => {
				if (next_tag) {
					// if we're in this callback because we're re-running the effect,
					// disable intros (unless no element is currently displayed)
					set_should_intro(false);
				}
			};
		}, EFFECT_TRANSPARENT);

		teardown(() => {
			set_should_intro(true);
		});

		if (was_hydrating) {
			set_hydrating(true);
			set_hydrate_node(anchor);
		}
	}

	/** @import { Effect } from '#client' */

	// TODO in 6.0 or 7.0, when we remove legacy mode, we can simplify this by
	// getting rid of the block/branch stuff and just letting the effect rip.
	// see https://github.com/sveltejs/svelte/pull/15962

	/**
	 * @param {Element} node
	 * @param {() => (node: Element) => void} get_fn
	 */
	function attach(node, get_fn) {
		/** @type {false | undefined | ((node: Element) => void)} */
		var fn = undefined;

		/** @type {Effect | null} */
		var e;

		block(() => {
			if (fn !== (fn = get_fn())) {
				if (e) {
					destroy_effect(e);
					e = null;
				}

				if (fn) {
					e = branch(() => {
						effect(() => /** @type {(node: Element) => void} */ (fn)(node));
					});
				}
			}
		});
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 *
	 * @param {Record<string,any>} styles
	 * @param {boolean} important
	 */
	function append_styles(styles, important = false) {
		var separator = important ? ' !important;' : ';';
		var css = '';

		for (var key in styles) {
			var value = styles[key];
			if (value != null && value !== '') {
				css += ' ' + key + ': ' + value + separator;
			}
		}

		return css;
	}

	/**
	 * @param {string} name
	 * @returns {string}
	 */
	function to_css_name(name) {
		if (name[0] !== '-' || name[1] !== '-') {
			return name.toLowerCase();
		}
		return name;
	}

	/**
	 * @param {any} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]
	 * @returns {string | null}
	 */
	function to_style(value, styles) {
		if (styles) {
			var new_style = '';

			/** @type {Record<string,any> | undefined} */
			var normal_styles;

			/** @type {Record<string,any> | undefined} */
			var important_styles;

			if (Array.isArray(styles)) {
				normal_styles = styles[0];
				important_styles = styles[1];
			} else {
				normal_styles = styles;
			}

			if (value) {
				value = String(value)
					.replaceAll(/\s*\/\*.*?\*\/\s*/g, '')
					.trim();

				/** @type {boolean | '"' | "'"} */
				var in_str = false;
				var in_apo = 0;
				var in_comment = false;

				var reserved_names = [];

				if (normal_styles) {
					reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
				}
				if (important_styles) {
					reserved_names.push(...Object.keys(important_styles).map(to_css_name));
				}

				var start_index = 0;
				var name_index = -1;

				const len = value.length;
				for (var i = 0; i < len; i++) {
					var c = value[i];

					if (in_comment) {
						if (c === '/' && value[i - 1] === '*') {
							in_comment = false;
						}
					} else if (in_str) {
						if (in_str === c) {
							in_str = false;
						}
					} else if (c === '/' && value[i + 1] === '*') {
						in_comment = true;
					} else if (c === '"' || c === "'") {
						in_str = c;
					} else if (c === '(') {
						in_apo++;
					} else if (c === ')') {
						in_apo--;
					}

					if (!in_comment && in_str === false && in_apo === 0) {
						if (c === ':' && name_index === -1) {
							name_index = i;
						} else if (c === ';' || i === len - 1) {
							if (name_index !== -1) {
								var name = to_css_name(value.substring(start_index, name_index).trim());

								if (!reserved_names.includes(name)) {
									if (c !== ';') {
										i++;
									}

									var property = value.substring(start_index, i).trim();
									new_style += ' ' + property + ';';
								}
							}

							start_index = i + 1;
							name_index = -1;
						}
					}
				}
			}

			if (normal_styles) {
				new_style += append_styles(normal_styles);
			}

			if (important_styles) {
				new_style += append_styles(important_styles, true);
			}

			new_style = new_style.trim();
			return new_style === '' ? null : new_style;
		}

		return value == null ? null : String(value);
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			hydrating ||
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			if (!hydrating || next_class_name !== dom.getAttribute('class')) {
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {Record<string, any>} prev
	 * @param {Record<string, any>} next
	 * @param {string} [priority]
	 */
	function update_styles(dom, prev = {}, next, priority) {
		for (var key in next) {
			var value = next[key];

			if (prev[key] !== value) {
				if (next[key] == null) {
					dom.style.removeProperty(key);
				} else {
					dom.style.setProperty(key, value, priority);
				}
			}
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {string | null} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]
	 */
	function set_style(dom, value, prev_styles, next_styles) {
		// @ts-expect-error
		var prev = dom.__style;

		if (hydrating || prev !== value) {
			var next_style_attr = to_style(value, next_styles);

			if (!hydrating || next_style_attr !== dom.getAttribute('style')) {
				if (next_style_attr == null) {
					dom.removeAttribute('style');
				} else {
					dom.style.cssText = next_style_attr;
				}
			}

			// @ts-expect-error
			dom.__style = value;
		} else if (next_styles) {
			if (Array.isArray(next_styles)) {
				update_styles(dom, prev_styles?.[0], next_styles[0]);
				update_styles(dom, prev_styles?.[1], next_styles[1], 'important');
			} else {
				update_styles(dom, prev_styles, next_styles);
			}
		}

		return next_styles;
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} mounting
	 */
	function select_option(select, value, mounting = false) {
		if (select.multiple) {
			// If value is null or undefined, keep the selection as is
			if (value == undefined) {
				return;
			}

			// If not an array, warn and keep the selection as is
			if (!is_array(value)) {
				return select_multiple_invalid_value();
			}

			// Otherwise, update the selection
			for (var option of select.options) {
				option.selected = value.includes(get_option_value(option));
			}

			return;
		}

		for (option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @param {HTMLSelectElement} select
	 */
	function init_select(select) {
		var observer = new MutationObserver(() => {
			// @ts-ignore
			select_option(select, select.__value);
			// Deliberately don't update the potential binding value,
			// the model should be preserved unless explicitly changed
		});

		observer.observe(select, {
			// Listen to option element changes
			childList: true,
			subtree: true, // because of <optgroup>
			// Listen to option element value attribute changes
			// (doesn't get notified of select value changes,
			// because that property is not reflected as an attribute)
			attributes: true,
			attributeFilter: ['value']
		});

		teardown(() => {
			observer.disconnect();
		});
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/** @import { Effect } from '#client' */

	const CLASS = Symbol('class');
	const STYLE = Symbol('style');

	const IS_CUSTOM_ELEMENT = Symbol('is custom element');
	const IS_HTML = Symbol('is html');

	/**
	 * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLInputElement} input
	 * @returns {void}
	 */
	function remove_input_defaults(input) {
		if (!hydrating) return;

		var already_removed = false;

		// We try and remove the default attributes later, rather than sync during hydration.
		// Doing it sync during hydration has a negative impact on performance, but deferring the
		// work in an idle task alleviates this greatly. If a form reset event comes in before
		// the idle callback, then we ensure the input defaults are cleared just before.
		var remove_defaults = () => {
			if (already_removed) return;
			already_removed = true;

			// Remove the attributes but preserve the values
			if (input.hasAttribute('value')) {
				var value = input.value;
				set_attribute(input, 'value', null);
				input.value = value;
			}

			if (input.hasAttribute('checked')) {
				var checked = input.checked;
				set_attribute(input, 'checked', null);
				input.checked = checked;
			}
		};

		// @ts-expect-error
		input.__on_r = remove_defaults;
		queue_micro_task(remove_defaults);
		add_form_reset_listener();
	}

	/**
	 * @param {Element} element
	 * @param {any} value
	 */
	function set_value(element, value) {
		var attributes = get_attributes(element);

		if (
			attributes.value ===
				(attributes.value =
					// treat null and undefined the same for the initial value
					value ?? undefined) ||
			// @ts-expect-error
			// `progress` elements always need their value set when it's `0`
			(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))
		) {
			return;
		}

		// @ts-expect-error
		element.value = value ?? '';
	}

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		var attributes = get_attributes(element);

		if (hydrating) {
			attributes[attribute] = element.getAttribute(attribute);

			if (
				attribute === 'src' ||
				attribute === 'srcset' ||
				(attribute === 'href' && element.nodeName === 'LINK')
			) {
				if (!skip_warning) {
					check_src_in_dev_hydration(element, attribute, value ?? '');
				}

				// If we reset these attributes, they would result in another network request, which we want to avoid.
				// We assume they are the same between client and server as checking if they are equal is expensive
				// (we can't just compare the strings as they can be different between client and server but result in the
				// same url, so we would need to create hidden anchor elements to compare them)
				return;
			}
		}

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string | symbol, any> | undefined} prev
	 * @param {Record<string | symbol, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [should_remove_defaults]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		should_remove_defaults = false,
		skip_warning = false
	) {
		if (hydrating && should_remove_defaults && element.tagName === 'INPUT') {
			var input = /** @type {HTMLInputElement} */ (element);
			var attribute = input.type === 'checkbox' ? 'defaultChecked' : 'defaultValue';

			if (!(attribute in next)) {
				remove_input_defaults(input);
			}
		}

		var attributes = get_attributes(element);

		var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
		var preserve_attribute_case = !attributes[IS_HTML];

		// If we're hydrating but the custom element is from Svelte, and it already scaffolded,
		// then it might run block logic in hydration mode, which we have to prevent.
		let is_hydrating_custom_element = hydrating && is_custom_element;
		if (is_hydrating_custom_element) {
			set_hydrating(false);
		}

		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		} else if (css_hash || next[CLASS]) {
			next.class = null; /* force call to set_class() */
		}

		if (next[STYLE]) {
			next.style ??= null; /* force call to set_style() */
		}

		var setters = get_setters(element);

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			if (key === 'class') {
				var is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';
				set_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);
				current[key] = value;
				current[CLASS] = next[CLASS];
				continue;
			}

			if (key === 'style') {
				set_style(element, value, prev?.[STYLE], next[STYLE]);
				current[key] = value;
				current[STYLE] = next[STYLE];
				continue;
			}

			var prev_value = current[key];

			// Skip if value is unchanged, unless it's `undefined` and the element still has the attribute
			if (value === prev_value && !(value === undefined && element.hasAttribute(key))) {
				continue;
			}

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = can_delegate_event(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style') {
				// avoid using the setter
				set_attribute(element, key, value);
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {
				// @ts-ignore We're not running this for custom elements because __value is actually
				// how Lit stores the current value on the element, and messing with that would break things.
				element.value = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked — preserve
						let input = /** @type {HTMLInputElement} */ (element);
						const use_default = prev === undefined;
						if (name === 'value') {
							let previous = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = previous;
							// @ts-ignore
							input.value = input.__value = use_default ? previous : null;
						} else {
							let previous = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = previous;
							input.checked = use_default ? previous : false;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
					// remove it from attributes's cache
					if (name in attributes) attributes[name] = UNINITIALIZED;
				} else if (typeof value !== 'function') {
					set_attribute(element, name, value, skip_warning);
				}
			}
		}

		if (is_hydrating_custom_element) {
			set_hydrating(true);
		}

		return current;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {(...expressions: any) => Record<string | symbol, any>} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {Array<Promise<void>>} blockers
	 * @param {string} [css_hash]
	 * @param {boolean} [should_remove_defaults]
	 * @param {boolean} [skip_warning]
	 */
	function attribute_effect(
		element,
		fn,
		sync = [],
		async = [],
		blockers = [],
		css_hash,
		should_remove_defaults = false,
		skip_warning = false
	) {
		flatten(blockers, sync, async, (values) => {
			/** @type {Record<string | symbol, any> | undefined} */
			var prev = undefined;

			/** @type {Record<symbol, Effect>} */
			var effects = {};

			var is_select = element.nodeName === 'SELECT';
			var inited = false;

			block(() => {
				var next = fn(...values.map(get$3));
				/** @type {Record<string | symbol, any>} */
				var current = set_attributes(
					element,
					prev,
					next,
					css_hash,
					should_remove_defaults,
					skip_warning
				);

				if (inited && is_select && 'value' in next) {
					select_option(/** @type {HTMLSelectElement} */ (element), next.value);
				}

				for (let symbol of Object.getOwnPropertySymbols(effects)) {
					if (!next[symbol]) destroy_effect(effects[symbol]);
				}

				for (let symbol of Object.getOwnPropertySymbols(next)) {
					var n = next[symbol];

					if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
						if (effects[symbol]) destroy_effect(effects[symbol]);
						effects[symbol] = branch(() => attach(element, () => n));
					}

					current[symbol] = n;
				}

				prev = current;
			});

			if (is_select) {
				var select = /** @type {HTMLSelectElement} */ (element);

				effect(() => {
					select_option(select, /** @type {Record<string | symbol, any>} */ (prev).value, true);
					init_select(select);
				});
			}

			inited = true;
		});
	}

	/**
	 *
	 * @param {Element} element
	 */
	function get_attributes(element) {
		return /** @type {Record<string | symbol, unknown>} **/ (
			// @ts-expect-error
			element.__attributes ??= {
				[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),
				[IS_HTML]: element.namespaceURI === NAMESPACE_HTML
			}
		);
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var cache_key = element.getAttribute('is') || element.nodeName;
		var setters = setters_cache.get(cache_key);
		if (setters) return setters;
		setters_cache.set(cache_key, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {any} element
	 * @param {string} attribute
	 * @param {string} value
	 */
	function check_src_in_dev_hydration(element, attribute, value) {
		if (attribute === 'srcset' && srcset_url_equal(element, value)) return;
		if (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;

		hydration_attribute_changed(
			attribute,
			element.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),
			String(value)
		);
	}

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
	}

	/** @param {string} srcset */
	function split_srcset(srcset) {
		return srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));
	}

	/**
	 * @param {HTMLSourceElement | HTMLImageElement} element
	 * @param {string} srcset
	 * @returns {boolean}
	 */
	function srcset_url_equal(element, srcset) {
		var element_urls = split_srcset(element.srcset);
		var urls = split_srcset(srcset);

		return (
			urls.length === element_urls.length &&
			urls.every(
				([url, width], i) =>
					width === element_urls[i][1] &&
					// We need to test both ways because Vite will create an a full URL with
					// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
					// relative URLs inside srcset are not automatically resolved to absolute URLs by
					// browsers (in contrast to img.src). This means both SSR and DOM code could
					// contain relative or absolute URLs.
					(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
			)
		);
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @returns {void}
	 */
	function run_tasks() {
		// use `raf.now()` instead of the `requestAnimationFrame` callback argument, because
		// otherwise things can get wonky https://github.com/sveltejs/svelte/pull/14541
		const now = raf.now();

		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		without_reactive_context(() => {
			element.dispatchEvent(new CustomEvent(type));
		});
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear$1 = (t) => t;

	/**
	 * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager
	 * and attaches it to the block, so that moves can be animated following reconciliation.
	 * @template P
	 * @param {Element} element
	 * @param {() => AnimateFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 */
	function animation(element, get_fn, get_params) {
		var item = /** @type {EachItem} */ (current_each_item);

		/** @type {DOMRect} */
		var from;

		/** @type {DOMRect} */
		var to;

		/** @type {Animation | undefined} */
		var animation;

		/** @type {null | { position: string, width: string, height: string, transform: string }} */
		var original_styles = null;

		item.a ??= {
			element,
			measure() {
				from = this.element.getBoundingClientRect();
			},
			apply() {
				animation?.abort();

				to = this.element.getBoundingClientRect();

				if (
					from.left !== to.left ||
					from.right !== to.right ||
					from.top !== to.top ||
					from.bottom !== to.bottom
				) {
					const options = get_fn()(this.element, { from, to }, get_params?.());

					animation = animate(this.element, options, undefined, 1, () => {
						animation?.abort();
						animation = undefined;
					});
				}
			},
			fix() {
				// If an animation is already running, transforming the element is likely to fail,
				// because the styles applied by the animation take precedence. In the case of crossfade,
				// that means the `translate(...)` of the crossfade transition overrules the `translate(...)`
				// we would apply below, leading to the element jumping somewhere to the top left.
				if (element.getAnimations().length) return;

				// It's important to destructure these to get fixed values - the object itself has getters,
				// and changing the style to 'absolute' can for example influence the width.
				var { position, width, height } = getComputedStyle(element);

				if (position !== 'absolute' && position !== 'fixed') {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					original_styles = {
						position: style.position,
						width: style.width,
						height: style.height,
						transform: style.transform
					};

					style.position = 'absolute';
					style.width = width;
					style.height = height;
					var to = element.getBoundingClientRect();

					if (from.left !== to.left || from.top !== to.top) {
						var transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`;
						style.transform = style.transform ? `${style.transform} ${transform}` : transform;
					}
				}
			},
			unfix() {
				if (original_styles) {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					style.position = original_styles.position;
					style.width = original_styles.width;
					style.height = original_styles.height;
					style.transform = original_styles.transform;
				}
			}
		};

		// in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called
		// when an animation manager already exists, if the tag changes. in that case, we need to
		// swap out the element rather than creating a new manager, in case it happened at the same
		// moment as a reconciliation
		item.a.element = element;
	}

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = 'both' ;

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/**
		 * The default overflow style, stashed so we can revert changes during the transition
		 * that are necessary to work around a Safari <18 bug
		 * TODO 6.0 remove this, if older versions of Safari have died out enough
		 */
		var overflow = element.style.overflow;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			return without_reactive_context(() => {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			});
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;

					element.style.overflow = overflow;
				});
			},
			out(fn) {

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value — `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear$1 } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		//
		// fill forwards to prevent the element from rendering without styles applied
		// see https://github.com/sveltejs/svelte/issues/14732
		var animation = element.animate(keyframes, { duration: delay, fill: 'forwards' });

		animation.onfinish = () => {
			// remove dummy animation from the stack to prevent conflict with main animation
			animation.cancel();

			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				/**
				 * Whether or not the CSS includes `overflow: hidden`, in which case we need to
				 * add it as an inline style to work around a Safari <18 bug
				 * TODO 6.0 remove this, if possible
				 */
				var needs_overflow_hidden = false;

				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css_to_keyframe(css(t, 1 - t));
						keyframes.push(styles);

						needs_overflow_hidden ||= styles.overflow === 'hidden';
					}
				}

				if (needs_overflow_hidden) {
					/** @type {HTMLElement} */ (element).style.overflow = 'hidden';
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/** @import { Batch } from '../../../reactivity/batch.js' */

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var batches = new WeakSet();

		listen_to_event_and_reset_event(input, 'input', async (is_reset) => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}

			// Because `{#each ...}` blocks work by updating sources inside the flush,
			// we need to wait a tick before checking to see if we should forcibly
			// update the input and reset the selection state
			await tick();

			// Respect any validation in accessors
			if (value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;
				var length = input.value.length;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					var new_length = input.value.length;
					// If cursor was at end and new input is longer, move cursor to new end
					if (start === end && end === length && new_length > length) {
						input.selectionStart = new_length;
						input.selectionEnd = new_length;
					} else {
						input.selectionStart = start;
						input.selectionEnd = Math.min(end, new_length);
					}
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			(hydrating && input.defaultValue !== input.value) ||
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}
		}

		render_effect(() => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			var value = get();

			if (input === document.activeElement) {
				// we need both, because in non-async mode, render effects run before previous_batch is set
				var batch = /** @type {Batch} */ (previous_batch ?? current_batch);

				// Never rewrite the contents of a focused input. We can get here if, for example,
				// an update is deferred because of async work depending on the input:
				//
				// <input bind:value={query}>
				// <p>{await find(query)}</p>
				if (batches.has(batch)) {
					return;
				}
			}

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			(hydrating && input.defaultChecked !== input.checked) ||
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Makes an `export`ed (non-prop) variable available on the `$$props` object
	 * so that consumers can do `bind:x` on the component.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} prop
	 * @param {V} value
	 * @returns {void}
	 */
	function bind_prop(props, prop, value) {
		var desc = get_descriptor(props, prop);

		if (desc && desc.set) {
			props[prop] = value;
			teardown(() => {
				props[prop] = null;
			});
		}
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = get_parts?.() || [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/**
	 * Substitute for the `preventDefault` event modifier
	 * @deprecated
	 * @param {(event: Event, ...args: Array<unknown>) => void} fn
	 * @returns {(event: Event, ...args: unknown[]) => void}
	 */
	function preventDefault(fn) {
		return function (...args) {
			var event = /** @type {Event} */ (args[0]);
			event.preventDefault();
			// @ts-ignore
			return fn?.apply(this, args);
		};
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get$3(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get$3(signal);
		}

		props();
	}

	/**
	 * @this {any}
	 * @param {Record<string, unknown>} $$props
	 * @param {Event} event
	 * @returns {void}
	 */
	function bubble_event($$props, event) {
		var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[
			event.type
		];

		var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];

		for (var fn of callbacks) {
			// Preserve "this" context
			fn.call(this, event);
		}
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * @template T
	 * @param {Readable<T>} store
	 * @returns {T}
	 */
	function get$2(store) {
		let value;
		subscribe_to_store(store, (_) => (value = _))();
		// @ts-expect-error
		return value;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	let IS_UNMOUNTED = Symbol();

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		{
			entry.source.label = store_name;
		}

		// if the component that setup this is already unmounted we don't want to register a subscription
		if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		// if the component that setup this stores is already unmounted the source will be out of sync
		// so we just use the `get` for the stores, less performant but it avoids to create a memory leak
		// and it will keep the value consistent
		if (store && IS_UNMOUNTED in stores) {
			return get$2(store);
		}

		return get$3(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {[StoreReferencesContainer, ()=>void]}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		function cleanup() {
			teardown(() => {
				for (var store_name in stores) {
					const ref = stores[store_name];
					ref.unsubscribe();
				}
				define_property(stores, IS_UNMOUNTED, {
					enumerable: false,
					value: true
				});
			});
		}

		return [stores, cleanup];
	}

	/**
	 * Updates a store with a new value.
	 * @param {Store<V>} store  the store to update
	 * @param {any} expression  the expression that mutates the store
	 * @param {V} new_value  the new store value
	 * @template V
	 */
	function store_mutate(store, expression, new_value) {
		store.set(new_value);
		return expression;
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Effect, Source } from './types.js' */

	/**
	 * @param {((value?: number) => number)} fn
	 * @param {1 | -1} [d]
	 * @returns {number}
	 */
	function update_prop(fn, d = 1) {
		const value = fn();
		fn(value + d);
		return value;
	}

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {
			{
				// TODO should this happen in prod too?
				props_rest_readonly(`${target.name}.${String(key)}`);
			}

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			{ props, exclude, name, other: {}, to_proxy: [] } ,
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for legacy $$restProps and $$props
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number>, parent_effect: Effect }>}}
	 */
	const legacy_rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			get$3(target.version);
			return key in target.special ? target.special[key]() : target.props[key];
		},
		set(target, key, value) {
			if (!(key in target.special)) {
				var previous_effect = active_effect;

				try {
					set_active_effect(target.parent_effect);

					// Handle props that can temporarily get out of sync with the parent
					/** @type {Record<string, (v?: unknown) => unknown>} */
					target.special[key] = prop(
						{
							get [key]() {
								return target.props[key];
							}
						},
						/** @type {string} */ (key),
						PROPS_IS_UPDATED
					);
				} finally {
					set_active_effect(previous_effect);
				}
			}

			target.special[key](value);
			update(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun
			return true;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		deleteProperty(target, key) {
			// Svelte 4 allowed for deletions on $$restProps
			if (target.exclude.includes(key)) return true;
			target.exclude.push(key);
			update(target.version);
			return true;
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @returns {Record<string, unknown>}
	 */
	function legacy_rest_props(props, exclude) {
		return new Proxy(
			{
				props,
				exclude,
				special: {},
				version: source(0),
				// TODO this is only necessary because we need to track component
				// destruction inside `prop`, because of `bind:this`, but it
				// seems likely that we can simplify `bind:this` instead
				parent_effect: /** @type {Effect} */ (active_effect)
			},
			legacy_rest_props_handler
		);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @type {ProxyHandler<{ props: Array<Record<string | symbol, unknown> | (() => Record<string | symbol, unknown>)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (!p) continue;

				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}

				for (const key of Object.getOwnPropertySymbols(p)) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;

		var get_fallback = () => {
			if (fallback_dirty) {
				fallback_dirty = false;

				fallback_value = lazy
					? untrack(/** @type {() => V} */ (fallback))
					: /** @type {V} */ (fallback);
			}

			return fallback_value;
		};

		/** @type {((v: V) => void) | undefined} */
		var setter;

		if (bindable) {
			// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
			// or `createClassComponent(Component, props)`
			var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

			setter =
				get_descriptor(props, key)?.set ??
				(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);
		}

		var initial_value;
		var is_store_sub = false;

		if (bindable) {
			[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			initial_value = /** @type {V} */ (props[key]);
		}

		if (initial_value === undefined && fallback !== undefined) {
			initial_value = get_fallback();

			if (setter) {
				if (runes) props_invalid_value(key);
				setter(initial_value);
			}
		}

		/** @type {() => V} */
		var getter;

		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				return value;
			};
		} else {
			getter = () => {
				var value = /** @type {V} */ (props[key]);

				if (value !== undefined) {
					// in legacy mode, we don't revert to the fallback value
					// if the prop goes from defined to undefined. The easiest
					// way to model this is to make the fallback undefined
					// as soon as the prop has a value
					fallback_value = /** @type {V} */ (undefined);
				}

				return value === undefined ? fallback_value : value;
			};
		}

		// prop is never written to — we only need a getter
		if (runes && (flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// prop is written to, but the parent component had `bind:foo` which
		// means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return /** @type {() => V} */ (
				function (/** @type {V} */ value, /** @type {boolean} */ mutation) {
					if (arguments.length > 0) {
						// We don't want to notify if the value was mutated and the parent is in runes mode.
						// In that case the state proxy (if it exists) should take care of the notification.
						// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
						// has changed because the parent will not be able to detect the change otherwise.
						if (!runes || !mutation || legacy_parent || is_store_sub) {
							/** @type {Function} */ (setter)(mutation ? getter() : value);
						}

						return value;
					}

					return getter();
				}
			);
		}

		// Either prop is written to, but there's no binding, which means we
		// create a derived that we can write to locally.
		// Or we are in legacy mode where we always create a derived to replicate that
		// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
		var overridden = false;

		var d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
			overridden = false;
			return getter();
		});

		{
			d.label = key;
		}

		// Capture the initial value if it's bindable
		if (bindable) get$3(d);

		var parent_effect = /** @type {Effect} */ (active_effect);

		return /** @type {() => V} */ (
			function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					const new_value = mutation ? get$3(d) : runes && bindable ? proxy(value) : value;

					set(d, new_value);
					overridden = true;

					if (fallback_value !== undefined) {
						fallback_value = new_value;
					}

					return value;
				}

				// special case — avoid recalculating the derived if we're in a
				// teardown function and the prop was overridden locally, or the
				// component was already destroyed (this latter part is necessary
				// because `bind:this` can read props after the component has
				// been destroyed. TODO simplify `bind:this`
				if ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {
					return d.v;
				}

				return get$3(d);
			}
		);
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	{
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	/**
	 * Returns an [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that aborts when the current [derived](https://svelte.dev/docs/svelte/$derived) or [effect](https://svelte.dev/docs/svelte/$effect) re-runs or is destroyed.
	 *
	 * Must be called while a derived or effect is running.
	 *
	 * ```svelte
	 * <script>
	 * 	import { getAbortSignal } from 'svelte';
	 *
	 * 	let { id } = $props();
	 *
	 * 	async function getData(id) {
	 * 		const response = await fetch(`/items/${id}`, {
	 * 			signal: getAbortSignal()
	 * 		});
	 *
	 * 		return await response.json();
	 * 	}
	 *
	 * 	const data = $derived(await getData(id));
	 * </script>
	 * ```
	 */
	function getAbortSignal() {
		if (active_reaction === null) {
			get_abort_signal_outside_reaction();
		}

		return (active_reaction.ac ??= new AbortController()).signal;
	}

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onMount');
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onDestroy');
		}

		onMount(() => () => untrack(fn));
	}

	/**
	 * @template [T=any]
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {any}params_0
	 * @returns {CustomEvent<T>}
	 */
	function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: null; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events)
	 * @template {Record<string, any>} [EventMap = any]
	 * @returns {EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const active_component_context = component_context;
		if (active_component_context === null) {
			lifecycle_outside_component('createEventDispatcher');
		}

		/**
		 * @param [detail]
		 * @param [options]
		 */
		return (type, detail, options) => {
			const events = /** @type {Record<string, Function | Function[]>} */ (
				active_component_context.s.$$events
			)?.[/** @type {string} */ (type)];

			if (events) {
				const callbacks = is_array(events) ? events.slice() : [events];
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = create_custom_event(/** @type {string} */ (type), detail, options);
				for (const fn of callbacks) {
					fn.call(active_component_context.x, event);
				}
				return !event.defaultPrevented;
			}

			return true;
		};
	}

	// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`.
	 *
	 * In runes mode use `$effect.pre` instead.
	 *
	 * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('beforeUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('beforeUpdate');
		}

		init_update_callbacks(component_context).b.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`.
	 *
	 * In runes mode use `$effect` instead.
	 *
	 * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('afterUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('afterUpdate');
		}

		init_update_callbacks(component_context).a.push(fn);
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	var indexClient = /*#__PURE__*/Object.freeze({
		__proto__: null,
		afterUpdate: afterUpdate,
		beforeUpdate: beforeUpdate,
		createContext: createContext,
		createEventDispatcher: createEventDispatcher,
		createRawSnippet: createRawSnippet,
		flushSync: flushSync,
		fork: fork,
		getAbortSignal: getAbortSignal,
		getAllContexts: getAllContexts,
		getContext: getContext,
		hasContext: hasContext,
		hydrate: hydrate,
		mount: mount,
		onDestroy: onDestroy,
		onMount: onMount,
		setContext: setContext,
		settled: settled,
		tick: tick,
		unmount: unmount,
		untrack: untrack
	});

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	function _assertClassBrand(e, t, n) {
	  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
	  throw new TypeError("Private element is not present on this object");
	}
	function _assertThisInitialized(e) {
	  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  return e;
	}
	function _callSuper(t, o, e) {
	  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
	}
	function _checkPrivateRedeclaration(e, t) {
	  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	function _classCallCheck(a, n) {
	  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}
	function _classPrivateFieldGet2(s, a) {
	  return s.get(_assertClassBrand(s, a));
	}
	function _classPrivateFieldInitSpec(e, t, a) {
	  _checkPrivateRedeclaration(e, t), t.set(e, a);
	}
	function _classPrivateFieldSet2(s, a, r) {
	  return s.set(_assertClassBrand(s, a), r), r;
	}
	function _classPrivateMethodInitSpec(e, a) {
	  _checkPrivateRedeclaration(e, a), a.add(e);
	}
	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: false
	  }), e;
	}
	function _defineProperty(e, r, t) {
	  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: true,
	    configurable: true,
	    writable: true
	  }) : e[r] = t, e;
	}
	function _getPrototypeOf(t) {
	  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
	    return t.__proto__ || Object.getPrototypeOf(t);
	  }, _getPrototypeOf(t);
	}
	function _inherits(t, e) {
	  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	  t.prototype = Object.create(e && e.prototype, {
	    constructor: {
	      value: t,
	      writable: true,
	      configurable: true
	    }
	  }), Object.defineProperty(t, "prototype", {
	    writable: false
	  }), e && _setPrototypeOf(t, e);
	}
	function _isNativeReflectConstruct() {
	  try {
	    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	  } catch (t) {}
	  return (_isNativeReflectConstruct = function () {
	    return !!t;
	  })();
	}
	function _possibleConstructorReturn(t, e) {
	  if (e && ("object" == typeof e || "function" == typeof e)) return e;
	  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	  return _assertThisInitialized(t);
	}
	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}

	const inputValuesExtractors = Object.freeze({
	  checkbox: function (inpEl, defaultValue = undefined) {
	    if (typeof defaultValue == "object" && Object.hasOwn(defaultValue, "checked") && Object.hasOwn(defaultValue, "unchecked")) {
	      return inpEl.checked ? defaultValue.checked : defaultValue.unchecked;
	    } else if (Object.hasOwn(inpEl, "value") && typeof inpEl.value !== "undefined") {
	      return inpEl.checked ? inpEl.value : false;
	    } else {
	      return inpEl.checked;
	    }
	  }
	});

	/**
	 * Collection of common to UI functions and properties
	 *
	 * @class UICommon
	 */
	let UICommon$1 = /*#__PURE__*/function () {
	  function UICommon() {
	    _classCallCheck(this, UICommon);
	  }
	  return _createClass(UICommon, null, [{
	    key: "inputValuesExtractors",
	    get: function () {
	      return inputValuesExtractors;
	    }
	  }, {
	    key: "extractValueFromInput",
	    value: function extractValueFromInput(inpEl, defaultValue = undefined) {
	      if (!inpEl) return defaultValue;
	      if (Object.hasOwn(UICommon.inputValuesExtractors, inpEl.type)) {
	        return UICommon.inputValuesExtractors[inpEl.type](inpEl, defaultValue);
	      }
	      return inpEl.value;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string}      field    field name
	     * @param {import('./events.types').UIEventInputChangeCallback}    onchange
	     * @param {any}         [defaultValue=undefined]
	     * @param {object}      [additional = {}]
	     * @return {import('./events.types').UIEventCallback}
	     * @memberof UICommon
	     */
	  }, {
	    key: "onInput",
	    value: function onInput(field, onchange, defaultValue = undefined, additional = {}) {
	      if (typeof onchange !== "function") {
	        return undefined;
	      }
	      return function (event) {
	        typeof event?.preventDefault === "function" && event?.preventDefault();
	        const value = UICommon.extractValueFromInput(event?.currentTarget, defaultValue);
	        return onchange({
	          field,
	          value
	        }, event, additional);
	      };
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {KeyboardEvent} e
	     * @memberof UICommon
	     */
	  }, {
	    key: "isEnterEvent",
	    value: function isEnterEvent(e) {
	      return e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.shiftKey;
	    }
	  }, {
	    key: "onlyOnEnter",
	    value: function onlyOnEnter(callback) {
	      return function (e) {
	        if (UICommon.isEnterEvent(e)) {
	          return callback(e);
	        } else {
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "isMobile",
	    value: function isMobile() {
	      const testMobile = window.matchMedia || window.msMatchMedia;
	      if (testMobile) {
	        let testQuery = "(pointer:coarse)";
	        if (arguments.length) {
	          const max_width = typeof arguments[0] === "boolean" ? this.MOBILE_WIDTH_BREAK_POINT : arguments[0];
	          testQuery = `only screen and (max-width: ${max_width}px)`;
	        }
	        return testMobile(testQuery).matches;
	      }
	      return false;
	    }
	  }, {
	    key: "removeBodyScroll",
	    value: function removeBodyScroll() {
	      document.body.classList.add(this.SCROLL_DISABLER_CLASS);
	    }
	  }, {
	    key: "restoreBodyScroll",
	    value: function restoreBodyScroll() {
	      document.body.classList.remove(this.SCROLL_DISABLER_CLASS);
	    }

	    /**
	     *  Reformats input from any string to strict phone format
	     *  @param {string}    val    free style phone number
	     *  @param {string}    [filler=UICommon.FILLER]    free style phone number
	     *  @returns {string}          phone number
	     **/
	  }, {
	    key: "formatPhone",
	    value: function formatPhone(val, filler = this.FILLER) {
	      //starting from 11 digits in phone number
	      const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];
	      let digits = val.replace(/\D/g, "");
	      //if there are more, move them to country code slot
	      if (digits.length > 11) {
	        let d = digits.length - 11;
	        while (d > 0) {
	          d--;
	          slots.unshift(1);
	        }
	      }
	      let stack = ["", "", "", "", ""];
	      Array.from(digits).forEach(function (digit, index) {
	        let slot = slots[index];
	        stack[slot - 1] = stack[slot - 1] + digit;
	      });
	      //creating map of parts lengths
	      const lens = slots.reduce(function (acc, curr) {
	        if (typeof acc[curr] === "undefined") {
	          acc[curr] = 1;
	        } else {
	          acc[curr] += 1;
	        }
	        return acc;
	      }, {});
	      //fill empty positions with filler (_)
	      for (let t in stack) {
	        let dif = lens[parseInt(t) + 1] - stack[t].length;
	        while (dif > 0) {
	          stack[t] = stack[t] + filler;
	          dif--;
	        }
	      }
	      return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;
	    }
	  }, {
	    key: "setMoneySign",
	    value: function setMoneySign(val) {
	      this.MONEY_SIGN = val;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {number} price
	     * @return {string}
	     * @memberof UICommon
	     */
	  }, {
	    key: "formatPrice",
	    value: function formatPrice(price) {
	      let major = Math.floor(price / 100),
	        minor = price % 100;
	      return `${this.MONEY_SIGN}${major.toString()}.${minor.toString()}`;
	    }
	  }, {
	    key: "formatLocaleDatetime",
	    value: function formatLocaleDatetime(dt, opts = {
	      date: true,
	      time: true
	    }) {
	      const date = dt.toLocaleDateString(window.navigator.language);
	      const time = dt.toLocaleTimeString(window.navigator.language);
	      if (opts.date && opts.time) {
	        return `${date} ${time}`;
	      } else if (opts.date && !opts.time) {
	        return date;
	      } else {
	        return time;
	      }
	    }
	  }, {
	    key: "tryFormatLocaleDateTime",
	    value: function tryFormatLocaleDateTime(value, opts = {
	      date: true,
	      time: true
	    }) {
	      if (typeof value == "string" || typeof value == "number") {
	        const dt = new Date(value);
	        return UICommon.formatLocaleDatetime(dt, opts);
	      } else if (typeof value == "object") {
	        return UICommon.formatLocaleDatetime(value, opts);
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "formatTimestamp",
	    value: function formatTimestamp(timestamp, offset = 0) {
	      let offsetLocal = new Date().getTimezoneOffset();
	      let deltaOffset = (offsetLocal - offset) * 60 * 1000;
	      let localDateTime = new Date(parseInt(timestamp) - deltaOffset);
	      return localDateTime.toLocaleString(window.navigator.language);
	    }
	  }, {
	    key: "declOfNum",
	    value: function declOfNum(n, text_forms) {
	      n = Math.abs(n) % 100;
	      let n1 = n % 10;
	      if (n > 10 && n < 20) {
	        return text_forms[2];
	      }
	      if (n1 > 1 && n1 < 5) {
	        return text_forms[1];
	      }
	      if (n1 == 1) {
	        return text_forms[0];
	      }
	      return text_forms[2];
	    }
	  }, {
	    key: "humanizedTimeDiff",
	    value: function humanizedTimeDiff(date /* unix time */) {
	      let currentTime = new Date().getTime();
	      let sec = Math.round((currentTime - date) / 1000);
	      let unit;
	      if (sec < 60) {
	        unit = this.declOfNum(sec, this.TIME.SECONDS);
	        return `${sec} ${unit} назад`;
	      } else if (sec < 3600) {
	        let min = Math.floor(sec / 60);
	        unit = this.declOfNum(min, this.TIME.MINUTES);
	        return `${min} ${unit} назад`;
	      } else {
	        let hours = Math.floor(sec / (60 * 60));
	        unit = this.declOfNum(hours, this.TIME.HOURS);
	        return `${hours} ${unit} назад`;
	      }
	    }
	  }, {
	    key: "stylesObjectToString",
	    value: function stylesObjectToString(styles = {}) {
	      if (typeof styles === "object") {
	        Object.keys(styles).map(function (prop) {
	          return `${prop}: ${styles.prop};`;
	        }).join("");
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "stringOrNumber",
	    value: function stringOrNumber(val) {
	      return ["string", "number"].indexOf(typeof val) > -1;
	    }
	  }, {
	    key: "stringsOfNumbers",
	    value: function stringsOfNumbers(list) {
	      return list.every(this.stringOrNumber);
	    }
	  }]);
	}();
	_defineProperty(UICommon$1, "CLEAR_MACRO", "__CLEAR__");
	_defineProperty(UICommon$1, "ERROR_DEFAULT", "Что пошло не так.");
	_defineProperty(UICommon$1, "DEFAULT_REDIRECT_TIMEOUT", 3000);
	_defineProperty(UICommon$1, "CLASS_OK", "is-success");
	_defineProperty(UICommon$1, "CLASS_ERR", "is-danger");
	_defineProperty(UICommon$1, "SCROLL_DISABLER_CLASS", "remove-scroll");
	_defineProperty(UICommon$1, "FILLER", "_");
	_defineProperty(UICommon$1, "SCROLL_OPTIONS", {
	  top: 0,
	  behavior: "smooth"
	});
	_defineProperty(UICommon$1, "MOBILE_WIDTH_BREAK_POINT", 760);
	_defineProperty(UICommon$1, "MONEY_SIGN", "&#8381;");
	_defineProperty(UICommon$1, "TIME", {
	  SECONDS: ["секунду", "секунды", "секунд"],
	  MINUTES: ["минуту", "минуты", "минут"],
	  HOURS: ["час", "часа", "часов"]
	});

	var root$_ = from_html(`<div><!></div>`);

	function Ui_block($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string}   [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class', 'children']);

		var div = root$_();

		attribute_effect(div, () => ({ class: `block ${classes() ?? ''}`, ...others }));

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
	}

	function Ui_block_inner_vertical($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const DEFAULT_CLASSES_INNER = "block-inner-vertical";
		let classesInner = state(DEFAULT_CLASSES_INNER);

		user_effect(() => {
			set(classesInner, `block-inner-vertical ${classes()}`);
		});

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);

		Ui_block($$anchor, {
			get id() {
				return id();
			},

			get class() {
				return get$3(classesInner);
			},

			get onclick() {
				return onclick();
			},

			get onkeyup() {
				return onKeyUp;
			},

			get role() {
				return role();
			},

			get tabIndex() {
				return tabIndex();
			},

			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				snippet(node, () => $$props.children ?? noop);
				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});

		pop();
	}

	var root$Z = from_html(`<div><!></div>`);

	function Ui_box($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$Z();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_class(div, 1, `box ${classes() ?? ''} `);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root$Y = from_html(`<div><!></div>`);

	function Ui_content($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$Y();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_class(div, 1, `content ${classes() ?? ''}`);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root$X = from_html(`<div><!></div>`);

	function Ui_clickable_div($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 3, ""),
			preventDefault = prop($$props, 'preventDefault', 3, true),
			click = prop($$props, 'click', 3, true),
			enter = prop($$props, 'enter', 3, true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'preventDefault',
				'click',
				'enter',
				'callback',
				'children'
			]);

		const mouseEvent = (e) => {
			preventDefault() && e.preventDefault();
			$$props.callback(e);
		};

		const keyboardEvent = (e) => {
			preventDefault() && e.preventDefault();

			if (e && e.key == "Enter") {
				$$props.callback(e);
			}
		};

		var div = root$X();

		attribute_effect(div, () => ({
			class: classes(),
			role: 'button',
			tabindex: '0',
			onkeyup: enter() ? keyboardEvent : undefined,
			onclick: click() ? mouseEvent : undefined,
			...others
		}));

		var node = child(div);

		snippet(node, () => $$props.children);
		reset(div);
		append($$anchor, div);
		pop();
	}

	var index$d = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBlock: Ui_block,
		UIBlockInnerVertical: Ui_block_inner_vertical,
		UIBox: Ui_box,
		UIClickableDiv: Ui_clickable_div,
		UIContent: Ui_content
	});

	function initDict(target = {}) {
	  const handler = {
	    get: function (target, prop) {
	      if (!Object.hasOwn(target, prop)) {
	        return prop;
	      }
	      return Reflect.get(...arguments);
	    }
	  };
	  return new Proxy(target, handler);
	}
	function createLocale() {
	  //const { subscribe, set, update } = writable(initDict());
	  const newLocale = writable(initDict());
	  return {
	    subscribe: newLocale.subscribe,
	    update: newLocale.update,
	    set: function (val) {
	      newLocale.set(initDict(val));
	    },
	    reset: function () {
	      return newLocale.set(initDict());
	    }
	  };
	}
	const LOCALE = createLocale();

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EventEmitter$2 = {exports: {}};

	/*!
	 * EventEmitter v5.2.9 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - https://oli.me.uk/
	 * @preserve
	 */
	var EventEmitter$1 = EventEmitter$2.exports;

	var hasRequiredEventEmitter;

	function requireEventEmitter () {
		if (hasRequiredEventEmitter) return EventEmitter$2.exports;
		hasRequiredEventEmitter = 1;
		(function (module) {
	(function (exports) {

			    /**
			     * Class for managing events.
			     * Can be extended to provide event functionality in other classes.
			     *
			     * @class EventEmitter Manages event registering and emitting.
			     */
			    function EventEmitter() {}

			    // Shortcuts to improve speed and size
			    var proto = EventEmitter.prototype;
			    var originalGlobalValue = exports.EventEmitter;

			    /**
			     * Finds the index of the listener for the event in its storage array.
			     *
			     * @param {Function[]} listeners Array of listeners to search through.
			     * @param {Function} listener Method to look for.
			     * @return {Number} Index of the specified listener, -1 if not found
			     * @api private
			     */
			    function indexOfListener(listeners, listener) {
			        var i = listeners.length;
			        while (i--) {
			            if (listeners[i].listener === listener) {
			                return i;
			            }
			        }

			        return -1;
			    }

			    /**
			     * Alias a method while keeping the context correct, to allow for overwriting of target method.
			     *
			     * @param {String} name The name of the target method.
			     * @return {Function} The aliased method
			     * @api private
			     */
			    function alias(name) {
			        return function aliasClosure() {
			            return this[name].apply(this, arguments);
			        };
			    }

			    /**
			     * Returns the listener array for the specified event.
			     * Will initialise the event object and listener arrays if required.
			     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
			     * Each property in the object response is an array of listener functions.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Function[]|Object} All listener functions for the event.
			     */
			    proto.getListeners = function getListeners(evt) {
			        var events = this._getEvents();
			        var response;
			        var key;

			        // Return a concatenated array of all matching events if
			        // the selector is a regular expression.
			        if (evt instanceof RegExp) {
			            response = {};
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    response[key] = events[key];
			                }
			            }
			        }
			        else {
			            response = events[evt] || (events[evt] = []);
			        }

			        return response;
			    };

			    /**
			     * Takes a list of listener objects and flattens it into a list of listener functions.
			     *
			     * @param {Object[]} listeners Raw listener objects.
			     * @return {Function[]} Just the listener functions.
			     */
			    proto.flattenListeners = function flattenListeners(listeners) {
			        var flatListeners = [];
			        var i;

			        for (i = 0; i < listeners.length; i += 1) {
			            flatListeners.push(listeners[i].listener);
			        }

			        return flatListeners;
			    };

			    /**
			     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Object} All listener functions for an event in an object.
			     */
			    proto.getListenersAsObject = function getListenersAsObject(evt) {
			        var listeners = this.getListeners(evt);
			        var response;

			        if (listeners instanceof Array) {
			            response = {};
			            response[evt] = listeners;
			        }

			        return response || listeners;
			    };

			    function isValidListener (listener) {
			        if (typeof listener === 'function' || listener instanceof RegExp) {
			            return true
			        } else if (listener && typeof listener === 'object') {
			            return isValidListener(listener.listener)
			        } else {
			            return false
			        }
			    }

			    /**
			     * Adds a listener function to the specified event.
			     * The listener will not be added if it is a duplicate.
			     * If the listener returns true then it will be removed after it is called.
			     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListener = function addListener(evt, listener) {
			        if (!isValidListener(listener)) {
			            throw new TypeError('listener must be a function');
			        }

			        var listeners = this.getListenersAsObject(evt);
			        var listenerIsWrapped = typeof listener === 'object';
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
			                listeners[key].push(listenerIsWrapped ? listener : {
			                    listener: listener,
			                    once: false
			                });
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of addListener
			     */
			    proto.on = alias('addListener');

			    /**
			     * Semi-alias of addListener. It will add a listener that will be
			     * automatically removed after its first execution.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addOnceListener = function addOnceListener(evt, listener) {
			        return this.addListener(evt, {
			            listener: listener,
			            once: true
			        });
			    };

			    /**
			     * Alias of addOnceListener.
			     */
			    proto.once = alias('addOnceListener');

			    /**
			     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
			     * You need to tell it what event names should be matched by a regex.
			     *
			     * @param {String} evt Name of the event to create.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvent = function defineEvent(evt) {
			        this.getListeners(evt);
			        return this;
			    };

			    /**
			     * Uses defineEvent to define multiple events.
			     *
			     * @param {String[]} evts An array of event names to define.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvents = function defineEvents(evts) {
			        for (var i = 0; i < evts.length; i += 1) {
			            this.defineEvent(evts[i]);
			        }
			        return this;
			    };

			    /**
			     * Removes a listener function from the specified event.
			     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to remove the listener from.
			     * @param {Function} listener Method to remove from the event.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListener = function removeListener(evt, listener) {
			        var listeners = this.getListenersAsObject(evt);
			        var index;
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key)) {
			                index = indexOfListener(listeners[key], listener);

			                if (index !== -1) {
			                    listeners[key].splice(index, 1);
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of removeListener
			     */
			    proto.off = alias('removeListener');

			    /**
			     * Adds listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
			     * You can also pass it a regular expression to add the array of listeners to all events that match it.
			     * Yeah, this function does quite a bit. That's probably a bad thing.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListeners = function addListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(false, evt, listeners);
			    };

			    /**
			     * Removes listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be removed.
			     * You can also pass it a regular expression to remove the listeners from all events that match it.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListeners = function removeListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(true, evt, listeners);
			    };

			    /**
			     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
			     * The first argument will determine if the listeners are removed (true) or added (false).
			     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be added/removed.
			     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
			     *
			     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
			        var i;
			        var value;
			        var single = remove ? this.removeListener : this.addListener;
			        var multiple = remove ? this.removeListeners : this.addListeners;

			        // If evt is an object then pass each of its properties to this method
			        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			            for (i in evt) {
			                if (evt.hasOwnProperty(i) && (value = evt[i])) {
			                    // Pass the single listener straight through to the singular method
			                    if (typeof value === 'function') {
			                        single.call(this, i, value);
			                    }
			                    else {
			                        // Otherwise pass back to the multiple function
			                        multiple.call(this, i, value);
			                    }
			                }
			            }
			        }
			        else {
			            // So evt must be a string
			            // And listeners must be an array of listeners
			            // Loop over it and pass each one to the multiple method
			            i = listeners.length;
			            while (i--) {
			                single.call(this, evt, listeners[i]);
			            }
			        }

			        return this;
			    };

			    /**
			     * Removes all listeners from a specified event.
			     * If you do not specify an event then all listeners will be removed.
			     * That means every event will be emptied.
			     * You can also pass a regex to remove all events that match it.
			     *
			     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeEvent = function removeEvent(evt) {
			        var type = typeof evt;
			        var events = this._getEvents();
			        var key;

			        // Remove different things depending on the state of evt
			        if (type === 'string') {
			            // Remove all listeners for the specified event
			            delete events[evt];
			        }
			        else if (evt instanceof RegExp) {
			            // Remove all events matching the regex.
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    delete events[key];
			                }
			            }
			        }
			        else {
			            // Remove all listeners in all events
			            delete this._events;
			        }

			        return this;
			    };

			    /**
			     * Alias of removeEvent.
			     *
			     * Added to mirror the node API.
			     */
			    proto.removeAllListeners = alias('removeEvent');

			    /**
			     * Emits an event of your choice.
			     * When emitted, every listener attached to that event will be executed.
			     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
			     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
			     * So they will not arrive within the array on the other side, they will be separate.
			     * You can also pass a regular expression to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {Array} [args] Optional array of arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emitEvent = function emitEvent(evt, args) {
			        var listenersMap = this.getListenersAsObject(evt);
			        var listeners;
			        var listener;
			        var i;
			        var key;
			        var response;

			        for (key in listenersMap) {
			            if (listenersMap.hasOwnProperty(key)) {
			                listeners = listenersMap[key].slice(0);

			                for (i = 0; i < listeners.length; i++) {
			                    // If the listener returns true then it shall be removed from the event
			                    // The function is executed either with a basic call or an apply if there is an args array
			                    listener = listeners[i];

			                    if (listener.once === true) {
			                        this.removeListener(evt, listener.listener);
			                    }

			                    response = listener.listener.apply(this, args || []);

			                    if (response === this._getOnceReturnValue()) {
			                        this.removeListener(evt, listener.listener);
			                    }
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of emitEvent
			     */
			    proto.trigger = alias('emitEvent');

			    /**
			     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
			     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {...*} Optional additional arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emit = function emit(evt) {
			        var args = Array.prototype.slice.call(arguments, 1);
			        return this.emitEvent(evt, args);
			    };

			    /**
			     * Sets the current value to check against when executing listeners. If a
			     * listeners return value matches the one set here then it will be removed
			     * after execution. This value defaults to true.
			     *
			     * @param {*} value The new value to check for when executing listeners.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.setOnceReturnValue = function setOnceReturnValue(value) {
			        this._onceReturnValue = value;
			        return this;
			    };

			    /**
			     * Fetches the current value to check against when executing listeners. If
			     * the listeners return value matches this one then it should be removed
			     * automatically. It will return true by default.
			     *
			     * @return {*|Boolean} The current value to check for or the default, true.
			     * @api private
			     */
			    proto._getOnceReturnValue = function _getOnceReturnValue() {
			        if (this.hasOwnProperty('_onceReturnValue')) {
			            return this._onceReturnValue;
			        }
			        else {
			            return true;
			        }
			    };

			    /**
			     * Fetches the events object and creates one if required.
			     *
			     * @return {Object} The events storage object.
			     * @api private
			     */
			    proto._getEvents = function _getEvents() {
			        return this._events || (this._events = {});
			    };

			    /**
			     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
			     *
			     * @return {Function} Non conflicting EventEmitter class.
			     */
			    EventEmitter.noConflict = function noConflict() {
			        exports.EventEmitter = originalGlobalValue;
			        return EventEmitter;
			    };

			    // Expose the class either via AMD, CommonJS or the global object
			    if (module.exports){
			        module.exports = EventEmitter;
			    }
			    else {
			        exports.EventEmitter = EventEmitter;
			    }
			}(typeof window !== 'undefined' ? window : EventEmitter$1 || {})); 
		} (EventEmitter$2));
		return EventEmitter$2.exports;
	}

	var EventEmitterExports = requireEventEmitter();
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(EventEmitterExports);

	/*
		:property.sub1.func().funcProp
		 = return funcProp of function result of sub1 property of property of object
		:{::helperVal}.sub
		 = return sub property of object property with name retrieved from helperVal property of helpers object
		:{::helperFunc()}.sub
		= return sub property of object property with name retrieved from helperVal function result of helpers object.
		if helpersFunx return 'car' then source path becomes :car.sub

	*/

	var src$1;
	var hasRequiredSrc$1;

	function requireSrc$1 () {
		if (hasRequiredSrc$1) return src$1;
		hasRequiredSrc$1 = 1;
		const SUB_PATH_START = "{",
		    SUB_PATH_END = "}",
		    PATH_SPLIT = ".",
		    PATH_START_OBJECT = ":",
		    PATH_START_HELPERS = "::",
		    FUNCTION_MARKER = "()",
		    MAX_DEEP = 10;

		/**
		 * Set of tools to use notPath property access notation
		 * : is for item
		 * :: is for helpers
		 * {} subpath
		 * . path splitter
		 * () function and should be executed with params (item, helper | undefined)
		 * sub-paths will be parsed and replaced by results in source path
		 */
		class notPath {
		    static get SUB_PATH_START() {
		        return SUB_PATH_START;
		    }
		    static get SUB_PATH_END() {
		        return SUB_PATH_END;
		    }
		    static get PATH_SPLIT() {
		        return PATH_SPLIT;
		    }
		    static get PATH_START_OBJECT() {
		        return PATH_START_OBJECT;
		    }
		    static get PATH_START_HELPERS() {
		        return PATH_START_HELPERS;
		    }
		    static get FUNCTION_MARKER() {
		        return FUNCTION_MARKER;
		    }
		    static get MAX_DEEP() {
		        return MAX_DEEP;
		    }

		    /*
				input ':{::helperVal}.sub'
				return ::helperVal
			*/

		    /**
		     * Returns first subpath in path
		     * if subpath not closed will return it anyway
		     * @param {string} path path in string notation
		     * @return {string|null} subpath or null if no sub path were found
		     */
		    static findNextSubPath(path) {
		        let subPath = "",
		            find = false;
		        for (let i = 0; i < path.length; i++) {
		            if (path[i] === SUB_PATH_START) {
		                find = true;
		                subPath = "";
		            } else {
		                if (path[i] === SUB_PATH_END && find) {
		                    return subPath;
		                } else {
		                    subPath += path[i];
		                }
		            }
		        }
		        return find ? subPath : null;
		    }

		    /**
		     * Replace sub-path in parent path by parsed version
		     * @param {string} path path to process
		     * @param {string} sub sub path to replace
		     * @param {string} parsed parsed sub path
		     * @return {string} parsed path
		     */

		    static replaceSubPath(path, sub, parsed) {
		        let subf = SUB_PATH_START + sub + SUB_PATH_END,
		            i = 0;
		        while (path.indexOf(subf) > -1 && i < MAX_DEEP) {
		            path = path.replace(subf, parsed);
		            i++;
		        }
		        return path;
		    }

		    /**
		     * Parses path while there any sub-paths
		     * @param {string} path raw unparsed path
		     * @param {object} item data
		     * @param {object} helpers helpers
		     * @return {string} parsed path
		     */
		    static parseSubs(path, item, helpers) {
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            i++;
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		        }
		        return path;
		    }

		    /**
		     * Get property value
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} [helpers] helpers object
		     */

		    static get(path, item, helpers = undefined) {
		        switch (path) {
		            case PATH_START_OBJECT:
		                return item;
		            case PATH_START_HELPERS:
		                return helpers;
		        }
		        path = this.parseSubs(path, item, helpers);
		        return this.getValueByPath(
		            path.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		            path,
		            item,
		            helpers
		        );
		    }

		    /**
		     * Set property value
		     * @param {string}  path path to property
		     * @param {object}  item item object
		     * @param {object}  helpers         helpers object if 4 arguments or attrValue if only 3 provided
		     * @param {any}     [attrValue]     value we want to assign
		     */

		    static set(path, item, helpers, attrValue = undefined) {
		        if (arguments.length === 3) {
		            attrValue = helpers;
		            helpers = undefined;
		        }
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		            i++;
		        }
		        this.setValueByPath(item, path, attrValue);
		        if (
		            item.isRecord &&
		            this.normilizePath(path).length > 1 &&
		            item.__isActive
		        ) {
		            item.trigger("change", item, path, attrValue);
		        }
		    }

		    /**
		     * Set target property to null
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} helpers helpers object
		     */

		    static unset(path, item, helpers) {
		        this.set(path, item, helpers, null);
		    }

		    /**
		     * Parses step key, transforms it to end-form
		     * @param {string} step not parsed step key
		     * @param {object} item item object
		     * @param {object} helper helpers object
		     * @return {string|number} parsed step key
		     */

		    static parsePathStep(step, item, helper) {
		        let rStep = null;
		        if (step.indexOf(PATH_START_HELPERS) === 0 && helper) {
		            rStep = step.replace(PATH_START_HELPERS, "");
		            if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                rStep = rStep.replace(FUNCTION_MARKER, "");
		                if (Object.prototype.hasOwnProperty.call(helper, rStep)) {
		                    return helper[rStep](item, undefined);
		                }
		            } else {
		                return helper[rStep];
		            }
		        } else {
		            if (step.indexOf(PATH_START_OBJECT) === 0 && item) {
		                rStep = step.replace(PATH_START_OBJECT, "");
		                if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                    rStep = rStep.replace(FUNCTION_MARKER, "");
		                    if (Object.prototype.hasOwnProperty.call(item, rStep)) {
		                        return item[rStep](item, undefined);
		                    }
		                } else {
		                    return item[rStep];
		                }
		            }
		        }
		        return step;
		    }

		    //::fieldName.result
		    //{}
		    //{fieldName: 'targetRecordField'}
		    ////['targetRecordField', 'result']
		    /**
		     * Transforms path with sub paths to path without
		     * @param {string|array} path path to target property
		     * @param {object} item item object
		     * @param {object} helper helper object
		     * @return {array} parsed path
		     **/
		    static parsePath(path, item, helper) {
		        if (!Array.isArray(path)) {
		            path = path.split(PATH_SPLIT);
		        }
		        for (var i = 0; i < path.length; i++) {
		            path[i] = this.parsePathStep(path[i], item, helper);
		        }
		        return path;
		    }

		    /**
		     * Transforms path from string notation to array of keys
		     * @param {string|array} path  input path, if array does nothing
		     * @return {array} path in array notation
		     */

		    static normilizePath(path) {
		        if (Array.isArray(path)) {
		            return path;
		        } else {
		            while (path.indexOf(PATH_START_OBJECT) > -1) {
		                path = path.replace(PATH_START_OBJECT, "");
		            }
		            return path.split(PATH_SPLIT);
		        }
		    }

		    /*
				small = ["todo"],
				big = ["todo", "length"]
				return true;

			*/

		    /**
		     * Identifies if first path includes second, compared from start,
		     * no floating start position inside ['join', 'me'], ['me']
		     * will result in false
		     * @param {array} big where we will search
		     * @param {array} small what we will search
		     * @return {boolean} if we succeed
		     */

		    static ifFullSubPath(big, small) {
		        if (big.length < small.length) {
		            return false;
		        }
		        for (let t = 0; t < small.length; t++) {
		            if (small[t] !== big[t]) {
		                return false;
		            }
		        }
		        return true;
		    }

		    /**
		     * Getter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be used as getter
		     * @param {string|array} attrPath path to property
		     * @param {object} item supporting data
		     * @param {helpers} object  supporting helpers
		     */

		    static getValueByPath(object, attrPath, item, helpers) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift(),
		            isFunction = attrName.indexOf(FUNCTION_MARKER) > -1;
		        if (isFunction) {
		            attrName = attrName.replace(FUNCTION_MARKER, "");
		        }
		        if (
		            (typeof object === "object" || typeof object === "function") &&
		            typeof object !== "undefined" &&
		            object !== null &&
		            typeof object[attrName] !== "undefined" &&
		            object[attrName] !== null
		        ) {
		            let newObj = isFunction
		                ? object[attrName]({
		                      item,
		                      helpers,
		                  })
		                : object[attrName];
		            if (attrPath.length > 0) {
		                return this.getValueByPath(newObj, attrPath, item, helpers);
		            } else {
		                return newObj;
		            }
		        } else {
		            return undefined;
		        }
		    }

		    /**
		     * Setter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be modified
		     * @param {string|array} attrPath path to property
		     * @param {any} attrValue  value to assign
		     */

		    static setValueByPath(object, attrPath, attrValue) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift();
		        if (attrPath.length > 0) {
		            if (!Object.prototype.hasOwnProperty.call(object, attrName)) {
		                object[attrName] = {};
		            }
		            this.setValueByPath(object[attrName], attrPath, attrValue);
		        } else {
		            object[attrName] = attrValue;
		        }
		    }

		    /**
		     * Joins passed in strings with PATH_SPLIT
		     * @param {string} arguments path to be glued
		     * @return {string} composite path
		     */

		    static join() {
		        let args = Array.prototype.slice.call(arguments);
		        return args.join(PATH_SPLIT);
		    }
		}

		src$1 = notPath;
		return src$1;
	}

	var notPath$1;
	var hasRequiredNotPath;

	function requireNotPath () {
		if (hasRequiredNotPath) return notPath$1;
		hasRequiredNotPath = 1;
		notPath$1 = requireSrc$1();
		return notPath$1;
	}

	var notPathExports = requireNotPath();
	var notPath = /*@__PURE__*/getDefaultExportFromCjs(notPathExports);

	var _notCommon;

	/*
	https://github.com/TehShrike/is-mergeable-object

	Included for convinience only. All rights belongs to their authors and etc.
	start of my code marked.

	*/

	let isMergeableObject = function isMergeableObject(value) {
	  return isNonNullObject(value) && !isSpecial(value);
	};
	function isNonNullObject(value) {
	  return !!value && typeof value === "object";
	}
	function isSpecial(value) {
	  var stringValue = Object.prototype.toString.call(value);
	  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
	function isReactElement(value) {
	  return value.$$typeof === REACT_ELEMENT_TYPE;
	}

	/*
	https://github.com/KyleAMathews/deepmerge

	The MIT License (MIT)

	Copyright (c) 2012 Nicholas Fisher

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	function emptyTarget(val) {
	  return Array.isArray(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	  const clone = !optionsArgument || optionsArgument.clone !== false;
	  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
	}
	function defaultArrayMerge(target, source, optionsArgument) {
	  return target.concat(source).map(function (element) {
	    return cloneUnlessOtherwiseSpecified(element, optionsArgument);
	  });
	}
	function mergeObject(target, source, optionsArgument) {
	  const destination = {};
	  if (isMergeableObject(target)) {
	    Object.keys(target).forEach(function (key) {
	      destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);
	    });
	  }
	  Object.keys(source).forEach(function (key) {
	    if (!isMergeableObject(source[key]) || !target[key]) {
	      destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);
	    } else {
	      destination[key] = deepmerge(target[key], source[key], optionsArgument);
	    }
	  });
	  return destination;
	}
	function deepmerge(target, source, optionsArgument) {
	  const sourceIsArray = Array.isArray(source);
	  const targetIsArray = Array.isArray(target);
	  const options = optionsArgument || {
	    arrayMerge: defaultArrayMerge
	  };
	  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
	  if (!sourceAndTargetTypesMatch) {
	    return cloneUnlessOtherwiseSpecified(source, optionsArgument);
	  } else if (sourceIsArray) {
	    const arrayMerge = options.arrayMerge || defaultArrayMerge;
	    return arrayMerge(target, source, optionsArgument);
	  } else {
	    return mergeObject(target, source, optionsArgument);
	  }
	}
	deepmerge.all = function deepmergeAll(array, optionsArgument) {
	  if (!Array.isArray(array)) {
	    throw new Error("first argument should be an array");
	  }
	  return array.reduce(function (prev, next) {
	    return deepmerge(prev, next, optionsArgument);
	  }, {});
	};

	/**
	 *  Collection of common functions
	 *  @class
	 */
	let notCommon$1 = /*#__PURE__*/function () {
	  function notCommon() {
	    _classCallCheck(this, notCommon);
	  }
	  return _createClass(notCommon, null, [{
	    key: "isError",
	    value:
	    /**
	     *  @static {function} isError  function to perform object test, if it's an error object or not
	     * @param   {object}    e   object to test
	     */
	    function isError(e) {
	      return e instanceof Error ||
	      // @ts-ignore
	      Object.hasOwn(e, "status") && e.status === "error";
	    }
	  }, {
	    key: "mute",
	    value: function mute() {
	      notCommon.ENV_TYPE = "production";
	    }
	  }, {
	    key: "pad",
	    value: function pad(n) {
	      return n < 10 ? "0" + n : n;
	    }
	    /**
	     *  Returns today Date object without hours, minutes, seconds
	     *  @return {number}  current date with 00:00:00 in ms of unix time
	     */
	  }, {
	    key: "getTodayDate",
	    value: function getTodayDate() {
	      let t = new Date();
	      return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
	    }

	    /**
	     *  Returns true if object has field of name
	     *   @param   {object}    obj    some object
	     *  @param  {string}    name  field name
	     *  @return {boolean}          if object contains field with name
	     **/
	  }, {
	    key: "objHas",
	    value: function objHas(obj, name) {
	      // @ts-ignore
	      return Object.hasOwn(obj, name);
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "copyObj",
	    value: function copyObj(obj) {
	      return JSON.parse(JSON.stringify(obj));
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "partCopyObj",
	    value: function partCopyObj(obj, list) {
	      let partObj = Object.keys(obj).reduce(function (prev, curr) {
	        if (list.includes(curr)) {
	          prev[curr] = obj[curr];
	        }
	        return prev;
	      }, {});
	      return JSON.parse(JSON.stringify(partObj));
	    }
	  }, {
	    key: "compareTwoArrays",
	    value: function compareTwoArrays(a, b) {
	      return a.length === b.length && a.every(function (element, index) {
	        return element === b[index];
	      });
	    }

	    /**
	     * Test argument type to be 'function'
	     * @param {any}  func    possible function
	     * @return {boolean}     if this is a function
	     **/
	  }, {
	    key: "isFunc",
	    value: function isFunc(func) {
	      return typeof func === "function";
	    }

	    /**
	     * Returns true if argument is Async function
	     * @param {function} func  to test
	     * @return {boolean}       if this function is constructed as AsyncFunction
	     **/
	  }, {
	    key: "isAsync",
	    value: function isAsync(func) {
	      return func.constructor.name === "AsyncFunction";
	    }

	    /**
	     *  Executes method of object in appropriate way inside Promise
	     * @param {object}   obj     original object
	     * @param {string}   name    method name to execute
	     * @param {Array}     params  array of params
	     * @return {Promise}          results of method execution
	     **/
	  }, {
	    key: "executeObjectFunction",
	    value: async function executeObjectFunction(obj, name, params) {
	      if (obj) {
	        // @ts-ignore
	        const proc = notPath.get(":" + name, obj);
	        if (notCommon.isFunc(proc)) {
	          if (notCommon.isAsync(proc)) {
	            return await proc(...params);
	          } else {
	            return proc(...params);
	          }
	        }
	      }
	    }

	    /**
	     *  Executes method of object in apropriate way inside Promise
	     * @param {Object}   from     original object
	     * @param {Object}   to    method name to execute
	     * @param {Array}     list  array of params
	     * @return {undefined}          results of method execution
	     **/
	  }, {
	    key: "mapBind",
	    value: function mapBind(from, to, list) {
	      list.forEach(function (item) {
	        if (typeof from[item] === "function") {
	          to[item] = from[item].bind(from);
	        }
	      });
	    }
	  }, {
	    key: "isClass",
	    value: function isClass(fn) {
	      return /^\s*class/.test(fn.toString());
	    }
	  }, {
	    key: "detectType",
	    value: function detectType(testie) {
	      if (typeof testie !== "function") {
	        return typeof testie;
	      } else {
	        if (notCommon.isClass(testie)) {
	          return "class";
	        } else {
	          return "function";
	        }
	      }
	    }

	    //Проверка является ли переменная массивом
	  }, {
	    key: "isArray",
	    value: function isArray(data) {
	      return typeof data == "object" && data instanceof Array;
	    }
	  }, {
	    key: "localIsoDate",
	    value: function localIsoDate(date) {
	      date = date || new Date();
	      let localIsoString = date.getFullYear() + "-" + notCommon.pad(date.getMonth() + 1) + "-" + notCommon.pad(date.getDate()) + "T" + notCommon.pad(date.getHours()) + ":" + notCommon.pad(date.getMinutes()) + ":" + notCommon.pad(date.getSeconds());
	      return localIsoString;
	    }
	  }, {
	    key: "getToday",
	    value: function getToday() {
	      let today = new Date();
	      let date = today.getFullYear() + "-" + notCommon.pad(today.getMonth() + 1) + "-" + notCommon.pad(today.getDate());
	      return date;
	    }
	  }, {
	    key: "backlogAdd",
	    value: function backlogAdd(msg, type = "log") {
	      if (notCommon.get("backlog") === true) {
	        notCommon.backlog.push({
	          msg,
	          type
	        });
	      }
	    }
	  }, {
	    key: "dumpBacklog",
	    value: function dumpBacklog() {
	      while (notCommon.backlog.length) {
	        let row = notCommon.backlog.shift();
	        window[notCommon.LOG][row.type](...row.msg);
	      }
	    }
	  }, {
	    key: "logMsg",
	    value: function logMsg() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].log(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "log");
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      notCommon.logMsg(...arguments);
	    }
	  }, {
	    key: "createLogger",
	    value: function createLogger(prefix) {
	      return {
	        log: notCommon.genLogMsg(prefix),
	        error: notCommon.genLogError(prefix),
	        debug: notCommon.genLogDebug(prefix),
	        report: notCommon.report
	      };
	    }

	    //Генерация метода вывода сообщений в консоль с указанием префикса.
	  }, {
	    key: "genLogMsg",
	    value: function genLogMsg(prefix) {
	      return function () {
	        //not arrow bc of arguments special var is not available in arrow functions
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].log(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "log");
	      };
	    }

	    /**
	     * Определяет является ли окружение окружением разработки
	     * @returns  {boolean} true если это запущено в окружении разработки
	     **/
	  }, {
	    key: "isDev",
	    value: function isDev() {
	      return notCommon.ENV_TYPE === notCommon.DEV_ENV;
	    }
	  }, {
	    key: "debug",
	    value: function debug() {
	      if (notCommon.isDev()) {
	        return notCommon.logMsg(...arguments);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "genLogDebug",
	    value: function genLogDebug(prefix) {
	      if (notCommon.isDev()) {
	        return notCommon.genLogMsg(prefix);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      notCommon.logError(...arguments);
	    }

	    //Функция вывода сообщения об ошибке
	  }, {
	    key: "logError",
	    value: function logError() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].error(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "error");
	    }
	  }, {
	    key: "genLogError",
	    value: function genLogError(prefix) {
	      return function () {
	        //do not change to arrow function, bc of arguments
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].error(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "error");
	      };
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon.getApp()) {
	        let reporter = notCommon.getApp().getService("nsErrorReporter");
	        if (reporter) {
	          reporter.report(e).catch(notCommon.error);
	        }
	      } else {
	        if (!notCommon.get("production")) {
	          notCommon.error(...arguments);
	        }
	      }
	    }
	  }, {
	    key: "trace",
	    value: function trace() {
	      if (!notCommon.get("production")) {
	        notCommon.trace(...arguments);
	      }
	    }
	  }, {
	    key: "trimBackslash",
	    value: function trimBackslash(str) {
	      if (str.indexOf("/") === 0) {
	        str = str.substring(1);
	      }
	      if (str[str.length - 1] === "/") {
	        str = str.substring(0, str.length - 1);
	      }
	      return str;
	    }

	    /**
	     *  Builds URL with structure like prefix/module/model/id/action
	     * If some part absent or set to false it will be excluded from result
	     *  @param {object} urlParts
	     *  @param {string} [urlParts.prefix='']
	     *  @param {string} [urlParts.module='']
	     *  @param {string} [urlParts.model='']
	     *  @param {string} [urlParts.id='']
	     *  @param {string} [urlParts.action='']
	     *  @return {string}  url path
	     */
	  }, {
	    key: "buildURL",
	    value: function buildURL({
	      prefix,
	      module,
	      model,
	      id,
	      action
	    } = {
	      prefix: "",
	      module: "",
	      model: "",
	      id: "",
	      action: ""
	    }) {
	      let url = ["/"];
	      if (prefix) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(prefix)));
	      }
	      if (module) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(module)));
	      }
	      if (model) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(model)));
	      }
	      if (id) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(id)));
	      }
	      if (action) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(action)));
	      }
	      url = url.filter(function (el) {
	        return el !== "";
	      });
	      return url.join("/").replace(/\/\//g, "/");
	    }
	  }, {
	    key: "capitalizeFirstLetter",
	    value: function capitalizeFirstLetter(name) {
	      return name.charAt(0).toUpperCase() + name.slice(1);
	    }
	  }, {
	    key: "lowerFirstLetter",
	    value: function lowerFirstLetter(string) {
	      return string.charAt(0).toLowerCase() + string.slice(1);
	    }
	  }, {
	    key: "strLengthCap",
	    value: function strLengthCap(str, MAX_TITLE_LENGTH = 50, POST_FIX = "...") {
	      if (typeof str === "string" && str.length > MAX_TITLE_LENGTH) {
	        return str.substr(0, MAX_TITLE_LENGTH) + POST_FIX;
	      } else {
	        return str;
	      }
	    }
	  }, {
	    key: "escapeHtml",
	    value: function escapeHtml(unsafe) {
	      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
	    }
	  }, {
	    key: "startApp",
	    value: function startApp(starter) {
	      document.addEventListener("DOMContentLoaded", starter);
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon.get("app");
	    }
	  }, {
	    key: "extendAppConfig",
	    value: function extendAppConfig(conf, conf2) {
	      return notCommon.deepMerge(conf, conf2);
	    }
	  }, {
	    key: "absorbModule",
	    value: function absorbModule() {
	      let defaultConf,
	        //app options
	        mod,
	        //module options
	        targets = {}; //various collections
	      if (arguments.length == 1) {
	        targets = {
	          ...arguments[0]
	        };
	        if (Object.hasOwnProperty.call(arguments[0], "defaultConf")) {
	          defaultConf = arguments[0].defaultConf;
	          delete targets.defaultConf;
	        }
	        if (Object.hasOwnProperty.call(arguments[0], "mod")) {
	          mod = arguments[0].mod;
	          delete targets.mod;
	        }
	      } else {
	        notCommon.log("WARNING: absorbModule format obsoleted, use object {defaultConf, mod, services, uis, wsc, etc}");
	        defaultConf = arguments[0];
	        mod = arguments[1];
	        if (arguments.length > 2) {
	          targets.services = arguments[2];
	        }
	        if (arguments.length > 3) {
	          targets.uis = arguments[3];
	        }
	        if (arguments.length > 4) {
	          targets.wcs = arguments[4];
	        }
	      }
	      for (let prop in mod) {
	        //add manifest to other
	        if (prop === "manifest") {
	          defaultConf = notCommon.extendAppConfig(defaultConf, mod.manifest);
	          continue;
	        }
	        if (typeof notCommon.get(`absorb.${prop}`) === "function") {
	          // @ts-ignore
	          if (!Object.hasOwn(targets, prop)) {
	            targets[prop] = {};
	            notCommon.log(`WARNING: no accamulator object provided for '${prop}' collection`);
	          }
	          notCommon.get(`absorb.${prop}`)(targets[prop], mod[prop]);
	        } else if (prop.indexOf("nc") === 0) {
	          // @ts-ignore
	          if (!Object.hasOwn(defaultConf, "controllers")) {
	            defaultConf.controllers = {};
	          }
	          defaultConf.controllers[prop] = mod[prop];
	        } else {
	          //in case of some other stuff presented, isolating it in special var
	          // @ts-ignore
	          if (!Object.hasOwn(window, "notEnv")) {
	            // @ts-ignore
	            window.notEnv = {};
	          }
	          // @ts-ignore
	          window.notEnv[prop] = mod[prop];
	        }
	      }
	      return defaultConf;
	    }
	  }, {
	    key: "defineIfNotExists",
	    value: function defineIfNotExists(obj, key, defaultValue) {
	      // @ts-ignore
	      if (!Object.hasOwn(obj, key)) {
	        obj[key] = defaultValue;
	      }
	    }
	  }, {
	    key: "register",
	    value: function register(key, val) {
	      notCommon.registry[key] = val;
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      // @ts-ignore
	      return Object.hasOwn(notCommon.registry, key) ? notCommon.registry[key] : null;
	    }

	    /**
	     * Moves item inside array from old_index to new_index
	     * @static
	     * @param {Array<any>} array
	     * @param {number} old_index
	     * @param {number} new_index
	     * @memberof notCommon
	     */
	  }, {
	    key: "moveItem",
	    value: function moveItem(array, old_index, new_index) {
	      const inRange = function (num) {
	        return num < array.length && num > -1;
	      };
	      if (inRange(new_index) && inRange(old_index)) {
	        array.splice(new_index, 0, array.splice(old_index, 1)[0]);
	      }
	    }
	  }, {
	    key: "stripProxy",
	    value: function stripProxy(obj) {
	      if (typeof obj !== "undefined" && obj !== null) {
	        if (obj.isProxy) {
	          if (Array.isArray(obj)) {
	            obj = Array.from(obj);
	          } else {
	            obj = Object.assign({}, obj);
	          }
	          for (let t in obj) {
	            // @ts-ignore
	            if (Object.hasOwn(obj, t)) {
	              obj[t] = notCommon.stripProxy(obj[t]);
	            }
	          }
	        }
	      }
	      return obj;
	    }
	  }, {
	    key: "pipe",
	    value: function pipe(data /* feed data */, funcs /* functions array */) {
	      let result;
	      for (let func of funcs) {
	        result = func(result || data);
	      }
	      return result;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string} type
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getAPI",
	    value: function getAPI(type) {
	      return notCommon.getManager()?.getAPI(type) ?? null;
	    }
	  }, {
	    key: "setManager",
	    value: function setManager(v) {
	      notCommon.MANAGER = v;
	    }

	    /**
	     *
	     *
	     * @static
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getManager",
	    value: function getManager() {
	      return notCommon.MANAGER;
	    }
	  }, {
	    key: "getJSON",
	    value: function getJSON(url) {
	      return fetch(url).then(function (response) {
	        return response.json();
	      });
	    }
	  }, {
	    key: "wait",
	    value: function wait(sec) {
	      return new Promise(function (res) {
	        setTimeout(res, sec * 1000);
	      });
	    }
	  }, {
	    key: "registerWidgetEvents",
	    value: function registerWidgetEvents(events) {
	      if (notCommon.getApp()) {
	        Object.keys(events).forEach(function (eventName) {
	          notCommon.getApp().on(eventName, events[eventName]);
	        });
	      }
	    }
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      notCommon.getApp() && notCommon.getApp().getWorking("router").navigate(url);
	    }
	  }, {
	    key: "select",
	    value: function select(variantsSet, value, def) {
	      if (variantsSet && typeof variantsSet == "object" && notCommon.objHas(variantsSet, value) && typeof variantsSet[value] !== "undefined" && variantsSet[value] !== null) {
	        return variantsSet[value];
	      } else {
	        return def;
	      }
	    }
	  }]);
	}();
	_notCommon = notCommon$1;
	/**
	 *  @static {Object} [MANAGER=null]  application manager, in some cases used to control initialization routine
	 */
	_defineProperty(notCommon$1, "MANAGER", null);
	/**
	 *  @static {string} [LOG="console"]  logger, window[LOG]
	 */
	_defineProperty(notCommon$1, "LOG", "console");
	/**
	 *  @static {function} deepMerge  function to perform deep merges of objects
	 */
	_defineProperty(notCommon$1, "deepMerge", deepmerge);
	_defineProperty(notCommon$1, "TZ_OFFSET", new Date().getTimezoneOffset() / 60 * -1);
	_defineProperty(notCommon$1, "DEV_ENV", "production");
	// @ts-ignore
	_defineProperty(notCommon$1, "ENV_TYPE", window.NOT_ENV_TYPE ?? _notCommon.DEV_ENV);
	_defineProperty(notCommon$1, "NOOP", function () {});
	_defineProperty(notCommon$1, "backlog", []);
	_defineProperty(notCommon$1, "registry", {});
	function absorbServices(target, src) {
	  if (target) {
	    for (let serv in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, serv)) {
	        notCommon$1.logError(`services property duplication ${serv}`);
	      }
	      target[serv] = src[serv];
	    }
	  }
	}
	function extendWSClient(wcs, wscName, wscOptions) {
	  // @ts-ignore
	  if (!Object.hasOwn(wcs, wscName)) {
	    wcs[wscName] = {
	      connection: {},
	      router: {
	        routes: {}
	      },
	      messenger: {}
	    };
	  }
	  let target = wcs[wscName];
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "router")) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions.router, "routes")) {
	      for (let routeType in wscOptions.router.routes) {
	        // @ts-ignore
	        if (!Object.hasOwn(target.router.routes, routeType)) {
	          target.router.routes[routeType] = {};
	        }
	        Object.assign(target.router.routes[routeType], {
	          ...wscOptions.router.routes[routeType]
	        });
	      }
	    }
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "messenger")) {
	    Object.assign(target.messenger, {
	      ...wscOptions.messenger
	    });
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "connection")) {
	    Object.assign(target.connection, {
	      ...wscOptions.connection
	    });
	  }
	  for (let t of ["name", "getToken", "logger", "identity", "credentials"]) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions, t)) {
	      target[t] = wscOptions[t];
	    }
	  }
	}
	function absorbWSC(target, src) {
	  if (target) {
	    for (let wsClientName in src) {
	      extendWSClient(target, wsClientName, src[wsClientName]);
	    }
	  }
	}
	function absorbUIs(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`uis property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	function absorbFields(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`fields property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	notCommon$1.register("absorb.wsc", absorbWSC);
	notCommon$1.register("absorb.services", absorbServices);
	notCommon$1.register("absorb.uis", absorbUIs);
	notCommon$1.register("absorb.uis", absorbFields);

	/**
	 * strings localization and formating model
	 * @class
	 */
	let notLocale = /*#__PURE__*/function (_EventEmitter) {
	  function notLocale() {
	    var _this;
	    _classCallCheck(this, notLocale);
	    _this = _callSuper(this, notLocale);
	    _this.dict = {}; //dictionary of phrases
	    _this.helpers = {}; //additional helper functions and constants
	    let dict = _this.restoreFromStorage();
	    if (dict) {
	      _this.set(dict);
	    }
	    return _this;
	  }

	  /**
	   * String format should comply notPath standart.
	   * {path_to_access} - is
	   * : - is used to access to params
	   * :: - is used to access to helpers
	   * Welcome, {:where}! - will replace {:where} with content of params.where
	   * Welcome, {::where}! - will replace {:where} with content of this.helpers.where
	   * () - after path is to invoke function of target object
	   * Welcome, {::where()}! - will try to exec this.helpers.where(params, undefined)
	   * @param    {string}  str         localized string template with mark to include data
	   * @param    {object}  params      params to use in string
	   * @returns  {string}              localized version of string with
	   */
	  _inherits(notLocale, _EventEmitter);
	  return _createClass(notLocale, [{
	    key: "format",
	    value: function format(str, params) {
	      return notPath.parseSubs(str, params, this.helpers);
	    }

	    /**
	     * Return localized version of string with injected data from provided object
	     * may also use Locale.helpers as source of data
	     * @param {string}   phrase    name of string to localize
	     * @param {object}   params    object with data to inject in phrase template
	     * @return {string}            localized string with injected data
	     */
	  }, {
	    key: "say",
	    value: function say(phrase, params = false) {
	      try {
	        if (notCommon$1.objHas(this.dict, phrase)) {
	          let tmpl = this.dict[phrase],
	            result = "";
	          if (params) {
	            result = this.format(tmpl, params);
	          } else {
	            result = tmpl;
	          }
	          return result;
	        } else {
	          throw new Error(`Unknown locale phrase: ${phrase}`);
	        }
	      } catch (e) {
	        notCommon$1.debug(e);
	        return phrase;
	      }
	    }

	    /**
	     * Setting new dictionary. triggers event 'change'
	     * @param {object}     dict      vocabulary of phrases and templates
	     **/
	  }, {
	    key: "set",
	    value: function set(dict) {
	      LOCALE.set(dict);
	      this.saveToStorage(dict);
	      this.dict = Object.assign({}, {
	        ...dict
	      });
	      this.emit("change");
	    }
	  }, {
	    key: "saveToStorage",
	    value: function saveToStorage(dict) {
	      if (window.localStorage) {
	        try {
	          return window.localStorage.setItem("dictionary", JSON.stringify(dict));
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "restoreFromStorage",
	    value: function restoreFromStorage() {
	      if (window.localStorage) {
	        try {
	          let str = window.localStorage.getItem("dictionary");
	          if (str) {
	            let dict = JSON.parse(str);
	            return dict;
	          } else {
	            return false;
	          }
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }

	    /**
	     * Returns writable store of phrases
	     * @return {object}  writable store
	     */
	  }, {
	    key: "vocabulary",
	    value: function vocabulary() {
	      return LOCALE;
	    }
	  }]);
	}(EventEmitter);
	var notLocale$1 = new notLocale();

	const say = notLocale$1.say.bind(notLocale$1);

	var root_1$y = from_html(`<span> </span>`);

	function Ui_tag($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "tagId"]                                  if we want to address this tag, as tag-{id}:{eventName}, ex. tag-tagId:update
		 * @property {string}   [title = "tag"]                                 tag title
		 * @property {string}   [color = "info"]                                bulma color
		 * @property {string}   [size = "normal"]                               bulma size
		 * @property {string}   [padding = "normal"]                            size of left/right paddings (small = 0.5em, normal = 1em, big = 1.5em, large = 2em), class names is is-padded-{padding}
		 * @property {boolean}  [bold = false]                                  title styling
		 * @property {boolean}  [right = false]                                 tag positioning on the right, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [left = false]                                  tag positioning on the left, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [top = false]                                   tag positioning on the top, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [bottom = false]                                tag positioning on the bottom, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {string}   [class  = ""]                                   additional css classes list
		 * @property {object}   [events = {}]                                   list of events {name:callback}
		 * @property {function} [register = notCommon.registerWidgetEvents]     register event handlers
		 * @property {function} [onUpdate = (data) => title = data.title;]
		 * @property {function} [action]                                        onclick/onkeydown callback
		 * @property {object}   [vars = {}]                                     css vars list
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "tagId"),
			title = prop($$props, 'title', 7, "tag"),
			color = prop($$props, 'color', 3, "info"),
			size = prop($$props, 'size', 3, "normal"),
			padding = prop($$props, 'padding', 3, "normal"),
			bold = prop($$props, 'bold', 3, false),
			right = prop($$props, 'right', 3, false),
			left = prop($$props, 'left', 3, false),
			top = prop($$props, 'top', 3, false),
			bottom = prop($$props, 'bottom', 3, false),
			classes = prop($$props, 'class', 3, ""),
			events = prop($$props, 'events', 23, () => ({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "title")) {
					title(data.title);
				}
			}),
			vars = prop($$props, 'vars', 19, () => ({})),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		let sided = user_derived(() => right() || left() || top() || bottom());
		let hCentered = user_derived(() => !right() && !left() && get$3(sided));
		let vCentered = user_derived(() => !bottom() && !top() && get$3(sided));

		function getStandartUpdateEventName() {
			return `tag-${id()}:update`;
		}

		let style = state("");

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events()[getStandartUpdateEventName()] = onUpdate();
			}

			register()(events());
		});

		user_effect(() => {
			set(
				style,
				Object.keys(snapshot(vars())).map((varName) => {
					return `${varName}: ${vars()[varName]};`;
				}).join(""),
				true
			);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$y();

				span.__keydown = function (...$$args) {
					($$props.action ? $$props.action : undefined)?.apply(this, $$args);
				};

				span.__click = function (...$$args) {
					($$props.action ? $$props.action : undefined)?.apply(this, $$args);
				};

				let classes_1;
				var text = child(span, true);

				reset(span);

				template_effect(() => {
					set_attribute(span, 'role', role());
					set_attribute(span, 'tabindex', tabIndex());
					set_attribute(span, 'id', `tag-${id() ?? ''}`);

					classes_1 = set_class(
						span,
						1,
						`
  tag
  ${padding() !== 'normal' ? `is-padded-${padding()}` : ''}
  is-${size() ?? ''}
  is-${color() ?? ''}  
  ${classes() ?? ''}`,
						null,
						classes_1,
						{
							'is-clickable': $$props.action,
							'has-text-weight-bold': bold(),
							'is-vertical-centered': get$3(vCentered),
							'is-horizontal-centered': get$3(hCentered),
							'is-sided': get$3(sided),
							'is-sided-right': right(),
							'is-sided-left': left(),
							'is-sided-top': top(),
							'is-sided-bottom': bottom()
						}
					);

					set_style(span, get$3(style));
					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['keydown', 'click']);

	function Ui_boolean($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_TRUE = "not-node:booleans_true"]
		 * @property {string} [LC_FALSE = "not-node:booleans_false"]
		 * @property {any} value
		 * @property {boolean} [inverted = false]
		 */
		/** @type {Props} */
		let LC_TRUE = prop($$props, 'LC_TRUE', 3, "not-node:booleans_true"),
			LC_FALSE = prop($$props, 'LC_FALSE', 3, "not-node:booleans_false"),
			inverted = prop($$props, 'inverted', 3, false);

		const FALSE_VALUE = { title: LC_FALSE(), color: inverted() ? "success" : "danger" };
		const TRUE_VALUE = { title: LC_TRUE(), color: inverted() ? "danger" : "success" };

		//if inverted === true, inverts value
		let tagValue = user_derived(() => $$props.value ? TRUE_VALUE : FALSE_VALUE);

		Ui_tag($$anchor, spread_props(() => get$3(tagValue)));
	}

	var root$W = from_html(`<span class="label"> <!></span>`);

	function Ui_boolean_labeled($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {boolean} value
		 * @property {boolean} [inverted = false]
		 * @property {string} label
		 */
		/** @type {Props} */
		let inverted = prop($$props, 'inverted', 3, false);

		var span = root$W();
		var text = child(span);
		var node = sibling(text);

		Ui_boolean(node, {
			get value() {
				return $$props.value;
			},

			get inverted() {
				return inverted();
			}
		});

		reset(span);
		template_effect(() => set_text(text, `${$LOCALE()[$$props.label] ?? ''}: `));
		append($$anchor, span);
		pop();
		$$cleanup();
	}

	function Ui_booleans($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {array}    values
		 * @property {boolean}  [inverted = false]
		 * @property {function}      [componentConstructor = UIBoolean]
		 * @property {function} [itemRenderer]                          if supplied will be used instead of componentConstructor
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			inverted = prop($$props, 'inverted', 3, false),
			ItemConstructor = prop($$props, 'componentConstructor', 3, Ui_boolean);

		let _values = state(proxy([]));

		onMount(() => {
			if (typeof values() === "boolean") {
				set(_values, [{ value: values() }], true);
			} else if (Array.isArray(values())) {
				if (values().every((itm) => typeof itm === "boolean")) {
					set(
						_values,
						values().map((itm) => {
							return { value: itm };
						}),
						true
					);
				} else {
					set(_values, [...values()], true);
				}
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, () => get$3(_values), index$e, ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent = ($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							snippet(node_3, () => $$props.itemRenderer, () => get$3(item), () => index);
							append($$anchor, fragment_3);
						};

						var alternate = ($$anchor) => {
							var fragment_4 = comment();
							var node_4 = first_child(fragment_4);

							{
								let $0 = user_derived(() => inverted() || get$3(item).inverted);

								component(node_4, ItemConstructor, ($$anchor, ItemConstructor_1) => {
									ItemConstructor_1($$anchor, spread_props(() => get$3(item), {
										get inverted() {
											return get$3($0);
										}
									}));
								});
							}

							append($$anchor, fragment_4);
						};

						if_block(node_2, ($$render) => {
							if ($$props.itemRenderer) $$render(consequent); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$3(_values).length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$x = from_html(`<span role="button" tabindex="0"><i></i></span>`);
	var root_2$o = from_html(`<span class="icon is-small is-right is-clickable is-vertical-middle" role="button" tabindex="0"><i></i></span>`);
	var root$V = from_html(`<span> </span> <!> <!>`, 1);

	function Ui_censored($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [hidden = true]
		 * @property {boolean}  [showable = true]
		 * @property {boolean}  [copiable = true]
		 * @property {string}   [copyIcon = 'copy']
		 * @property {string}   [showIcon = 'eye']
		 * @property {string}   [hideIcon = 'eye-slash']
		 * @property {number}   [maxLength = 20]
		 * @property {string}   [shadowClass = "has-background-primary-90"]
		 * @property {boolean}  [tooltip = true]
		 * @property {number}   [tooltipTTL = 2000]
		 * @property {string}   [tooltipText = "Скопировано в буфер"]
		 * @property {string}   [tooltipClass = "has-tooltip-info"]
		 * @property {string}   [value = ""]
		 * @property {function} [onerror]
		 */
		/** @type {Props} */
		let hidden = prop($$props, 'hidden', 15, true),
			showable = prop($$props, 'showable', 3, true),
			copiable = prop($$props, 'copiable', 3, true),
			copyIcon = prop($$props, 'copyIcon', 3, "copy"),
			showIcon = prop($$props, 'showIcon', 3, "eye"),
			hideIcon = prop($$props, 'hideIcon', 3, "eye-slash"),
			maxLength = prop($$props, 'maxLength', 3, 20),
			shadowClass = prop($$props, 'shadowClass', 3, "has-background-primary-90"),
			tooltip = prop($$props, 'tooltip', 3, true),
			tooltipTTL = prop($$props, 'tooltipTTL', 3, 2000),
			tooltipText = prop($$props, 'tooltipText', 3, "Скопировано в буфер"),
			tooltipClass = prop($$props, 'tooltipClass', 3, "has-tooltip-info"),
			value = prop($$props, 'value', 3, "");

		function toggleView() {
			hidden(!hidden());
		}

		let contentCopied = state(false),
			tooltipActive = user_derived(() => tooltip() && get$3(contentCopied)),
			tooltipTarget = state(void 0);

		async function copyContent() {
			try {
				await navigator.clipboard.writeText(value());

				if (tooltip()) {
					set(contentCopied, true);
					get$3(tooltipTarget).dataset.tooltip = tooltipText();

					setTimeout(
						() => {
							set(contentCopied, false);
							get$3(tooltipTarget).removeAttribute("data-tooltip");
						},
						tooltipTTL()
					);
				}
			} catch(err) {
				$$props.onerror && $$props.onerror(err);
			}
		}

		var fragment = root$V();
		var span = first_child(fragment);
		var text = child(span, true);

		reset(span);

		var node = sibling(span, 2);

		{
			var consequent = ($$anchor) => {
				var span_1 = root_1$x();

				span_1.__click = copyContent;
				span_1.__keydown = copyContent;

				var i = child(span_1);

				reset(span_1);
				bind_this(span_1, ($$value) => set(tooltipTarget, $$value), () => get$3(tooltipTarget));

				template_effect(() => {
					set_class(span_1, 1, "icon is-small is-right is-clickable " + (get$3(tooltipActive) ? ` ${tooltipClass()} ` : "") + " is-vertical-middle");
					set_class(i, 1, `fas fa-${copyIcon() ?? ''}`);
				});

				append($$anchor, span_1);
			};

			if_block(node, ($$render) => {
				if (copiable()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var span_2 = root_2$o();

				span_2.__click = toggleView;
				span_2.__keydown = toggleView;

				var i_1 = child(span_2);

				reset(span_2);
				template_effect(() => set_class(i_1, 1, `fas fa-${(hidden() ? showIcon() : hideIcon()) ?? ''}`));
				append($$anchor, span_2);
			};

			if_block(node_1, ($$render) => {
				if (showable()) $$render(consequent_1);
			});
		}

		template_effect(() => {
			set_class(span, 1, (hidden() ? "is-censored " + shadowClass() : "") + " is-vertical-middle ");
			set_style(span, `display:inline-block; width: ${maxLength()}rem; height: var(--bulma-size-medium); overflow-x:hidden;`);
			set_text(text, hidden() ? "" : value());
		});

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keydown']);

	var root$U = from_html(`<span> </span>`);

	function Ui_indicator($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "tagId"] - if we want to address this indicator
		 * @property {string}   [state = "light"]
		 * @property {string}   [size = "normal"]
		 * @property {any}      [labels = {black, dark, light, white, primary, link, info, success, warning, danger}]
		 * @property {string}   [class = "max-1"]
		 * @property {string}   [padding = "normal"]
		 * @property {boolean}  [bold = false]
		 * @property {boolean}  [right = false]
		 * @property {boolean}  [left = left]
		 * @property {boolean}  [top = false]
		 * @property {boolean}  [bottom = false]
		 * @property {any}      [events = {}]
		 * @property {any}      [register = notCommon.registerWidgetEvents] - register event handlers
		 * @property {any}      [onUpdate = (data) => currentState = data.state]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "tagId"),
			currentState = prop($$props, 'state', 15, "light"),
			size = prop($$props, 'size', 3, "normal"),
			labels = prop($$props, 'labels', 19, () => ({
				black: "black",
				dark: "dark",
				light: "light",
				white: "white",
				primary: "primary",
				link: "link",
				info: "info",
				success: "success",
				warning: "warning",
				danger: "danger"
			})),
			classes = prop($$props, 'class', 3, "mx-1"),
			padding = prop($$props, 'padding', 3, "normal"),
			bold = prop($$props, 'bold', 3, false),
			right = prop($$props, 'right', 3, false),
			left = prop($$props, 'left', 3, false),
			top = prop($$props, 'top', 3, false),
			bottom = prop($$props, 'bottom', 3, false),
			events = prop($$props, 'events', 31, () => proxy({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "state")) {
					currentState(data.state);
				}
			});

		function getStandartUpdateEventName() {
			return `indicator-${id()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		let sided = user_derived(() => right() || left() || top() || bottom());
		var span = root$U();
		let classes_1;
		var text = child(span, true);

		reset(span);

		template_effect(() => {
			classes_1 = set_class(span, 1, `tag is-${size() ?? ''} ${padding() !== 'normal' ? `is-padded-${padding()}` : ''} is-${currentState() ?? ''} ${classes() ?? ''}`, null, classes_1, {
				'has-text-weight-bold': bold(),
				'is-sided': get$3(sided),
				'is-sided-right': right(),
				'is-sided-left': left(),
				'is-sided-top': top(),
				'is-sided-bottom': bottom()
			});

			set_text(text, labels()[currentState()]);
		});

		append($$anchor, span);
		pop();
	}

	var root_3$i = from_html(`<span class="title"> </span>`);
	var root_1$w = from_html(`<div><!></div>`);

	function Ui_loader($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		//hidden - no loader
		//container - parent container of form
		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [loading = false]       state if form loading
		 * @property {string}   [size = 'container']    (page, container, hidden)
		 * @property {string}   [title = 'Waiting...']  LC string
		 * @property {number}   [ttl]                   time to live, will be closed after ttl ms
		 * @property {snippet}  [children]              snippets may be provided
		 */
		/** @type {Props} */
		let loading = prop($$props, 'loading', 7, false),
			size = prop($$props, 'size', 3, "container"),
			title = prop($$props, 'title', 3, "Waiting...");

		let ttlTimer;

		onMount(() => {
			if ($$props.ttl) {
				ttlTimer = setTimeout(
					() => {
						loading(false);
						$$props.onreject();
					},
					$$props.ttl
				);
			}
		});

		onDestroy(() => {
			if (ttlTimer) {
				clearTimeout(ttlTimer);
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$w();
				let classes;
				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						snippet(node_2, () => $$props.children ?? noop);
						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var span = root_3$i();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span);
					};

					if_block(node_1, ($$render) => {
						if ($$props.children) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(div);
				template_effect(() => classes = set_class(div, 1, clsx(size() === "page" ? "pageloader" : "containerloader"), null, classes, { 'is-active': loading() }));
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (size() !== "hidden") $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$T = from_html(`<option> </option>`);

	function Ui_select_option($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		var option = root$T();
		var text = child(option, true);

		reset(option);

		var option_value = {};

		template_effect(() => {
			set_selected(option, $$props.selected);
			set_text(text, $LOCALE()[$$props.title]);

			if (option_value !== (option_value = $$props.value)) {
				option.value = (option.__value = $$props.value) ?? '';
			}
		});

		append($$anchor, option);
		pop();
		$$cleanup();
	}

	var root_3$h = from_html(`<span class="mr-2"> </span>`);
	var root_5$a = from_html(`<span class="mr-2"> </span>`);
	var root_6$c = from_html(`<div><select><!><!></select></div>`);

	function Ui_select($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} [value]
		 * @property {any}      [variants]
		 * @property {string} [placeholder = ""]
		 * @property {boolean}  [emptyValueEnabled = true]
		 * @property {string|number}  [emptyValue]
		 * @property {string} [emptyValueTitle = "no-selection"]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {string} [size]
		 * @property {string} [color]
		 * @property {boolean} [valid]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, ""),
			variants = prop($$props, 'variants', 19, () => []);
			prop($$props, 'placeholder', 3, "");
			let emptyValueTitle = prop($$props, 'emptyValueTitle', 3, "no-selection"),
			emptyValueEnabled = prop($$props, 'emptyValueEnabled', 3, true),
			emptyValue = prop($$props, 'emptyValue', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "select"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'placeholder',
				'emptyValueTitle',
				'emptyValueEnabled',
				'emptyValue',
				'fieldname',
				'required',
				'readonly',
				'size',
				'color',
				'loading',
				'valid',
				'class',
				'onchange'
			]);

		let selectedVariants = state(proxy([]));

		function filterSelectedVariants(variant) {
			if (value()) {
				return value() == variant.id;
			} else {
				return false;
			}
		}

		function checkOnClearMacro(newValue) {
			if (newValue === UICommon$1.CLEAR_MACRO) {
				value("");
			} else {
				value(newValue);
			}
		}

		function alreadyProcessed(newValue) {
			if (Array.isArray(newValue) && Array.isArray(value())) {
				if (notCommon$1.compareTwoArrays(value(), newValue)) {
					return true;
				}
			} else {
				if (newValue === value()) {
					return true;
				}
			}

			return false;
		}

		function onInput(ev) {
			const data = { field: fieldname(), value: ev.currentTarget.value };

			if (alreadyProcessed(data.value)) {
				return;
			}

			checkOnClearMacro(data.value);
			onchange()(data);
		}

		user_effect(() => {
			set(selectedVariants, Array.isArray(variants()) ? variants().filter(filterSelectedVariants) : [], true);
		});

		let invalid = user_derived(() => !valid());

		onMount(() => {
			if (readonly()) return;

			if (!value()) {
				if (emptyValueEnabled() && variants().length) {
					value(variants()[0].id);
					onchange()({ field: fieldname(), value: variants()[0].id });
				}
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$3(selectedVariants), index$e, ($$anchor, selectedVariant) => {
							var span = root_3$h();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$3(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var span_1 = root_5$a();
								var text_1 = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
								append($$anchor, span_1);
							};

							if_block(
								node_3,
								($$render) => {
									if (emptyValueEnabled()) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var div = root_6$c();
				var select = child(div);

				attribute_effect(select, () => ({
					id: `form-field-select-${fieldname() ?? ''}`,
					name: fieldname(),
					oninput: onInput,
					onblur: onInput,
					readonly: readonly(),
					required: required(),
					invalid: get$3(invalid),
					size: $$props.size,
					...others
				}));

				var node_4 = child(select);

				{
					var consequent_3 = ($$anchor) => {
						Ui_select_option($$anchor, {
							get value() {
								return emptyValue();
							},

							get title() {
								return emptyValueTitle();
							}
						});
					};

					if_block(node_4, ($$render) => {
						if (emptyValueEnabled()) $$render(consequent_3);
					});
				}

				var node_5 = sibling(node_4);

				each(node_5, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					{
						let $0 = user_derived(() => value() == get$3(variant).id);

						Ui_select_option($$anchor, {
							get value() {
								return get$3(variant).id;
							},

							get selected() {
								return get$3($0);
							},

							get title() {
								return get$3(variant).title;
							}
						});
					}
				});

				reset(select);
				reset(div);
				template_effect(() => set_class(div, 1, `select ${$$props.loading ? `is-loading` : ''} ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`));
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_2); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$f = from_html(`<span class="icon"><i></i></span>`);
	var root_5$9 = from_html(`<span> </span>`);
	var root_6$b = from_html(`<span class="icon"><i></i></span>`);
	var root_3$g = from_html(`<!> <!> <!>`, 1);
	var root$S = from_html(`<button><!></button>`);

	function Ui_button($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [action]
		 * @property {function} [onclick]
		 * @property {any} value
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			state = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			style = prop($$props, 'style', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			icon = prop($$props, 'icon', 3, false),
			iconSide = prop($$props, 'iconSide', 3, "right"),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			}),
			action = prop($$props, 'action', 3, () => {
				return true;
			});

		function onClick(event) {
			event.stopPropagation();
			onclick() && onclick()({ event, value: $$props.value });

			return action() && action()(event, $$props.value);
		}

		var button = root$S();

		button.__click = onClick;

		var node = child(button);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_4 = ($$anchor) => {
						var fragment_2 = root_3$g();
						var node_3 = first_child(fragment_2);

						{
							var consequent_1 = ($$anchor) => {
								var span = root_4$f();
								var i = child(span);

								reset(span);
								template_effect(() => set_class(i, 1, `fas fa-${icon() ?? ''} ${size() ? `is-${size()}` : ''}`));
								append($$anchor, span);
							};

							if_block(node_3, ($$render) => {
								if (iconSide() === "left") $$render(consequent_1);
							});
						}

						var node_4 = sibling(node_3, 2);

						{
							var consequent_2 = ($$anchor) => {
								var span_1 = root_5$9();
								var text = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text, $LOCALE()[title()]));
								append($$anchor, span_1);
							};

							if_block(node_4, ($$render) => {
								if (title()) $$render(consequent_2);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_3 = ($$anchor) => {
								var span_2 = root_6$b();
								var i_1 = child(span_2);

								reset(span_2);
								template_effect(() => set_class(i_1, 1, `fas fa-${icon() ?? ''} ${size() ? `is-${size()}` : ''}`));
								append($$anchor, span_2);
							};

							if_block(node_5, ($$render) => {
								if (iconSide() === "right") $$render(consequent_3);
							});
						}

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[title()]));
						append($$anchor, text_1);
					};

					if_block(
						node_2,
						($$render) => {
							if (icon()) $$render(consequent_4); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		reset(button);

		template_effect(() => {
			button.disabled = disabled();
			set_attribute(button, 'type', type() ? type() : "");
			set_style(button, style());

			set_class(button, 1, `
  button
  ${classes() ?? ''}
  ${state() ? `is-${state()}` : ''}
  ${inverted() ? `is-inverted` : ''}
  ${outlined() ? `is-outlined` : ''}
  ${raised() ? `is-raised` : ''}
  ${rounded() ? `is-rounded` : ''}
  ${light() ? `is-light` : ''}
  ${loading() ? `is-loading` : ''}
  ${color() ? `is-${color()}` : ''}
  ${size() ? `is-${size()}` : ''}
  `);
		});

		append($$anchor, button);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root$R = from_html(`<button></button>`);

	function Ui_button_close($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [ariaLabel = "delete button"]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {function} [onclick]
		 * @property {any} value
		 */
		/** @type {Props} */
		let ariaLabel = prop($$props, 'ariaLabel', 3, "delete button");
			prop($$props, 'light', 3, false);
			prop($$props, 'loading', 3, false);
			prop($$props, 'raised', 3, false);
			prop($$props, 'outlined', 3, false);
			prop($$props, 'inverted', 3, false);
			prop($$props, 'rounded', 3, false);
			let disabled = prop($$props, 'disabled', 3, false);
			prop($$props, 'state', 3, "");
			prop($$props, 'color', 3, "");
			let size = prop($$props, 'size', 3, ""),
			style = prop($$props, 'style', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			});

		function onClick(event) {
			event.stopPropagation();
			onclick() && onclick()({ event, value: $$props.value });
		}

		var button = root$R();

		button.__click = onClick;

		template_effect(() => {
			set_attribute(button, 'aria-label', ariaLabel());
			button.disabled = disabled();
			set_style(button, style());

			set_class(button, 1, `
  delete
  ${classes() ?? ''}  
  ${size() ? `is-${size()}` : ''}
  `);
		});

		append($$anchor, button);
		pop();
	}

	delegate(['click']);

	var root$Q = from_html(`<div></div>`);

	function Ui_buttons($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {Array<object>} [values = []]
		 * @property {boolean} [centered = false]
		 * @property {boolean} [right = false]
		 * @property {string} [class = '']
		 * @property {import('svelte').Component} [buttonComponent = UIButton]
		 * @property {import('../events.types').UIEventInputChangeCallback} [action = ()=>true]
		 * @property {import('../events.types').UIEventCallback} [onclick = ()=>true]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			classes = prop($$props, 'class', 3, ""),
			SvelteComponent = prop($$props, 'buttonComponent', 3, Ui_button),
			action = prop($$props, 'action', 3, () => {
				return true;
			}),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			});

		let _values = state(proxy([]));

		user_effect(() => {
			set(
				_values,
				values().map((itm) => {
					if (isNaN(itm.id)) {
						itm.id = Math.round(Math.random() * 100);
					}

					return itm;
				}),
				true
			);
		});

		var div = root$Q();
		let classes_1;

		each(div, 21, () => get$3(_values), (item) => item.id, ($$anchor, item, $$index) => {
			var fragment = comment();
			var node = first_child(fragment);

			component(node, SvelteComponent, ($$anchor, SvelteComponent_1) => {
				SvelteComponent_1($$anchor, spread_props(
					{
						get action() {
							return action();
						},

						get onclick() {
							return onclick();
						}
					},
					() => get$3(item),
					{
						get value() {
							return get$3(item).value;
						},

						set value($$value) {
							(get$3(item).value = $$value);
						}
					}
				));
			});

			append($$anchor, fragment);
		});

		reset(div);
		template_effect(() => classes_1 = set_class(div, 1, `buttons has-addons ${classes() ?? ''}`, null, classes_1, { 'is-right': right(), 'is-centered': centered() }));
		append($$anchor, div);
		pop();
	}

	var root$P = from_html(`<div><div class="column"><!></div> <div class="column"><!></div> <div class="column"><!></div></div>`);

	function Ui_buttons_row($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {any} [left]
		 * @property {any} [center]
		 * @property {any} [right]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			left = prop($$props, 'left', 19, () => []),
			center = prop($$props, 'center', 19, () => []),
			right = prop($$props, 'right', 19, () => []);

		var div = root$P();
		var div_1 = child(div);
		var node = child(div_1);

		Ui_buttons(node, {
			get values() {
				return left();
			}
		});

		reset(div_1);

		var div_2 = sibling(div_1, 2);
		var node_1 = child(div_2);

		Ui_buttons(node_1, {
			get values() {
				return center();
			},

			centered: true
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);
		var node_2 = child(div_3);

		Ui_buttons(node_2, {
			get values() {
				return right();
			},

			right: true
		});

		reset(div_3);
		reset(div);
		template_effect(() => set_class(div, 1, `columns ${classes() ?? ''}`));
		append($$anchor, div);
	}

	function Ui_button_switch($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [uiOff]
		 * @property {function} [uiOn]
		 * @property {function} [action]
		 * @property {any} value
		 * @property {boolean} [selected]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			activeState = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			icon = prop($$props, 'icon', 3, false),
			iconSide = prop($$props, 'iconSide', 3, "right"),
			uiOff = prop($$props, 'uiOff', 3, () => {
				return { color: "" };
			}),
			uiOn = prop($$props, 'uiOn', 3, () => {
				return { color: "success" };
			}),
			action = prop($$props, 'action', 3, () => {
				return !selected();
			}),
			onclick = prop($$props, 'onclick', 3, () => {}),
			onchange = prop($$props, 'onchange', 3, () => {}),
			selected = prop($$props, 'selected', 15, false);

		let childProps = state(proxy({
			title: title(),
			light: light(),
			loading: loading(),
			raised: raised(),
			outlined: outlined(),
			inverted: inverted(),
			rounded: rounded(),
			disabled: disabled(),
			type: type(),
			color: color(),
			size: size(),
			class: classes(),
			icon: icon(),
			iconSide: iconSide(),
			value: $$props.value
		}));

		let uiElement = state(void 0);

		onMount(() => {
			updateUI();
		});

		function onClick(event) {
			selected(action()(event, $$props.value, selected()));
			updateUI();
			onclick()({ value: $$props.value, selected: selected() });
			onchange()({ value: $$props.value, selected: selected() });
		}

		function updateUI() {
			if (get$3(uiElement)) {
				const propsChanges = selected()
					? uiOn()($$props.value, selected())
					: uiOff()($$props.value, selected());

				Object.keys(propsChanges).forEach((key) => {
					get$3(childProps)[key] = propsChanges[key];
				});

				set(childProps, get$3(childProps), true);
			}
		}

		user_effect(() => {
			if (typeof selected() !== "undefined") updateUI();
		});

		var $$exports = { updateUI };

		bind_this(
			Ui_button($$anchor, spread_props(() => get$3(childProps), {
				get state() {
					return activeState();
				},

				onclick: onClick
			})),
			($$value) => set(uiElement, $$value, true),
			() => get$3(uiElement)
		);

		return pop($$exports);
	}

	var root$O = from_html(`<div></div>`);

	function Ui_buttons_switchers($$anchor, $$props) {
		push($$props, true);

		const uis = {};

		function updateItemUI(item) {
			uis[item.id].updateUI();
		}

		const defaultAction = (ev, value, selected) => {
			const countOfSelected = countSelected();

			if (countOfSelected === min() && selected) {
				return selected;
			}

			if (countOfSelected === max() && selected !== true) {
				return selected;
			}

			const indexOfCurrent = _values.findIndex((itm) => itm.value === value);
			let newSelected = selected;

			if (indexOfCurrent > -1) {
				newSelected = !newSelected;

				const cnt = countSelected() + (newSelected ? 1 : -1);

				if (min()) {
					if (cnt < min()) {
						selectUpToMin(cnt, indexOfCurrent);
					}
				}

				if (max()) {
					if (max() < cnt) {
						deselectDownToMin(cnt, indexOfCurrent);
					}
				}

				return newSelected;
			}

			return newSelected;
		};

		/**
		 * @typedef {Object} Props
		 * @property {array<object>} [values]
		 * @property {boolean} [centered]
		 * @property {boolean} [right]
		 * @property {string} [class]
		 * @property {import('svelte').Component}      [buttonComponent = UIButtonSwitch]
		 * @property {object}   [buttonProps = {}]
		 * @property {function} [action = (event, value, selected) => boolean]  fires on button switch click, returns new state of selected
		 * @property {function} [onclick]
		 * @property {function} [onchange]
		 * @property {number} [min = 0]
		 * @property {number} [max = 100]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 23, () => []),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			classes = prop($$props, 'class', 3, ""),
			buttonComponent = prop($$props, 'buttonComponent', 3, Ui_button_switch),
			buttonProps = prop($$props, 'buttonProps', 19, () => ({})),
			action = prop($$props, 'action', 3, defaultAction),
			onclick = prop($$props, 'onclick', 3, () => true),
			onchange = prop($$props, 'onchange', 3, () => true),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100);
		let _values = proxy(values());

		function onChange() {
			values(snapshot(_values));

			const selected = values().filter((itm) => itm.selected);
			const selectedIds = selected.map((itm) => itm.id);
			const selectedCount = selectedIds.length;

			onchange() && onchange()({ values: values(), selected, selectedIds, selectedCount });
		}

		function selectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = true;
				updateItemUI(itm);
			});

			onChange();
		}

		function deselectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = false;
				updateItemUI(itm);
			});

			onChange();
		}

		onMount(() => {
			const selectedCount = countSelected();

			if (min() && selectedCount < min()) {
				selectUpToMin(selectedCount, -1);
			}
		});

		function addToHistory(id) {
		}

		function countSelected() {
			const countOfSelected = _values.filter((btn) => {
				return btn.selected;
			}).length;

			return countOfSelected;
		}

		function toggleFirstSuited(toValue) {
			const index = _values.findIndex((itm) => !toValue == itm.selected);

			if (index > -1) {
				_values[index].selected = toValue;
				updateItemUI(_values[index]);
			}
		}

		function selectUpToMin(cnt, indexOfCurrent) {
			let delta = min() - cnt;

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (!_values[t].selected) {
					_values[t].selected = true;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function deselectDownToMin(cnt, indexOfCurrent) {
			let delta = cnt - max();

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (_values[t].selected) {
					_values[t].selected = false;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function updateUI() {
			Object.keys(uis).forEach((itemId) => {
				if (uis[itemId]) {
					uis[itemId].updateUI && uis[itemId].updateUI();
				}
			});
		}

		var $$exports = {
			selectAll,
			deselectAll,
			addToHistory,
			countSelected,
			toggleFirstSuited,
			selectUpToMin,
			deselectDownToMin,
			updateUI
		};

		var div = root$O();

		each(div, 23, () => _values, (item) => item.id, ($$anchor, item, index) => {
			const SvelteComponent = user_derived(buttonComponent);
			var fragment = comment();
			var node = first_child(fragment);

			component(node, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
				bind_this(
					SvelteComponent_1($$anchor, spread_props(
						{
							get action() {
								return action();
							}
						},
						() => get$3(item),
						buttonProps,
						{
							get onclick() {
								return onclick();
							},

							onchange: onChange,

							get selected() {
								return _values[get$3(index)].selected;
							},

							set selected($$value) {
								_values[get$3(index)].selected = $$value;
							}
						}
					)),
					($$value, item) => uis[item.id] = $$value,
					(item) => uis?.[item.id],
					() => [get$3(item)]
				);
			});

			append($$anchor, fragment);
		});

		reset(div);
		template_effect(() => set_class(div, 1, `buttons has-addons ${centered() ? 'is-centered' : ''} ${right() ? 'is-right' : ''} ${classes() ?? ''}`));
		append($$anchor, div);

		return pop($$exports);
	}

	var index$c = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIButton: Ui_button,
		UIButtonClose: Ui_button_close,
		UIButtonSwitch: Ui_button_switch,
		UIButtons: Ui_buttons,
		UIButtonsRow: Ui_buttons_row,
		UIButtonsSwitchers: Ui_buttons_switchers
	});

	var root$N = from_html(`<div><!></div>`);

	function Ui_field($$anchor, $$props) {
		let grouped = prop($$props, 'grouped', 3, false),
			addons = prop($$props, 'addons', 3, false),
			multiline = prop($$props, 'multiline', 3, false),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'grouped',
				'addons',
				'multiline',
				'class',
				'children'
			]);

		var div = root$N();

		attribute_effect(div, () => ({
			class: `field ${classes() ?? ''}`,
			...others,

			[CLASS]: {
				'has-addons': addons(),
				'is-grouped': grouped(),
				'is-multiline': multiline()
			}
		}));

		var node = child(div);

		snippet(node, () => $$props.children);
		reset(div);
		append($$anchor, div);
	}

	var root$M = from_html(`<p><!></p>`);

	function Ui_control($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class='']
		 * @property {boolean} [hasIconsLeft=false]
		 * @property {boolean} [hasIconsRight=false]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			hasIconsLeft = prop($$props, 'hasIconsLeft', 3, false),
			hasIconsRight = prop($$props, 'hasIconsRight', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'hasIconsLeft',
				'hasIconsRight',
				'children'
			]);

		var p = root$M();

		attribute_effect(p, () => ({
			class: `control ${classes() ?? ''}`,
			...others,

			[CLASS]: {
				'has-icons-left': hasIconsLeft(),
				'has-icons-right': hasIconsRight()
			}
		}));

		var node = child(p);

		snippet(node, () => $$props.children ?? noop);
		reset(p);
		append($$anchor, p);
	}

	var root_4$e = from_html(`<!> <!>`, 1);

	function Ui_select_from_model_on_demand_inline($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_API_MODEL_GETTER = (
			modelName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch
		) => {
			return notCommon$1.getApp().getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
		};

		const DEFAULT_API_REQUEST = (apiModel, actionName) => {
			return apiModel[`$` + actionName]();
		};

		/**
		 * @typedef {Object} Props
		 * @property {string}   value                                       id of selected variant
		 * @property {array}    [variants = []]                             list of variants
		 * @property {boolean}  [loaded = false]                            true if we already loaded variants from server via API
		 * @property {string}   [placeholder = "empty select item"]         placeholder title
		 * @property {string}   [fieldname = "selectFromModel"]             this input fieldname
		 * @property {string}   [modelName = ""]                            API modelName
		 * @property {string}   [actionName = ""]                           API actionName
		 * @property {object}   [actionFilter = {}]                         API filtering rules
		 * @property {object}   [actionSorter = {}]                         API sorting rules
		 * @property {object}   [actionPager = {}]                          API pager state
		 * @property {object}   [actionSearch = undefined]                  API search string
		 * @property {string}   [optionId = ":_id"]                         variant object id field name
		 * @property {string}   [optionTitle = ":title"]                    variant object title field name
		 * @property {boolean}  [required = false]                          field is required
		 * @property {boolean}  [readonly = false]                          field is reaonly
		 * @property {number}   [size]                                      how many variants would be visible at once, default: 1
		 * @property {boolean}  [valid = true]                              field is valid
		 * @property {function} [onreject = () => false]                    callback on reject of selection process
		 * @property {function} [onresolve = () => true]                    callback on resolve of selection process
		 * @property {function} [onerror = () => true]                      callback on error
		 */
		/** @type {Props} */
		let variants = prop($$props, 'variants', 23, () => []),
			loaded = prop($$props, 'loaded', 7, false),
			placeholder = prop($$props, 'placeholder', 3, "empty select item"),
			fieldname = prop($$props, 'fieldname', 3, "selectFromModel"),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			apiModelGetter = prop($$props, 'apiModelGetter', 3, DEFAULT_API_MODEL_GETTER),
			apiRequest = prop($$props, 'apiRequest', 3, DEFAULT_API_REQUEST),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			onreject = prop($$props, 'onreject', 3, () => false),
			onresolve = prop($$props, 'onresolve', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => true);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let disabled = user_derived(() => !loaded());
		let componentState = state("hidden");
		let resultsList = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const response = await apiRequest()(apiModelGetter()(modelName(), actionFilter(), actionSorter(), actionPager(), actionSearch()), actionName());

				if (notCommon$1.isError(response)) {
					loaded(false);
					onerror()(response.errors || [response.message]);
				} else {
					resultsList = response.result;

					variants(resultsList.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					}));

					loaded(true);
				}
			}
		});

		let resolvedValue;

		function onModelChanged({ value: selectedValue }) {
			if (resultsList.length > variants().length) {
				resolvedValue = resultsList.find((item) => notPath.get(optionId(), item) == selectedValue);
			} else {
				resolvedValue = variants().find((item) => item.id == selectedValue);
			}
		}

		const ACTIONS = {
			add: {
				color: "primary",
				icon: "plus",

				action() {
					set(componentState, "show");
				}
			},

			resolve: {
				icon: "check",
				color: "primary",

				action() {
					set(componentState, "hidden");
					onresolve()({ field: fieldname(), value: snapshot(resolvedValue) });
				}
			},

			reject: {
				icon: "xmark",
				color: "danger",

				action() {
					set(componentState, "hidden");
					onreject()();
				}
			}
		};

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_button($$anchor, spread_props(() => ACTIONS.add));
			};

			var alternate = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_field($$anchor, {
							addons: true,

							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_4$e();
								var node_2 = first_child(fragment_4);

								Ui_control(node_2, {
									children: ($$anchor, $$slotProps) => {
										Ui_select($$anchor, {
											get value() {
												return $$props.value;
											},

											get variants() {
												return variants();
											},

											get placeholder() {
												return placeholder();
											},

											get fieldname() {
												return fieldname();
											},

											get required() {
												return required();
											},

											get readonly() {
												return readonly();
											},

											get disabled() {
												return get$3(disabled);
											},

											get size() {
												return $$props.size;
											},

											get color() {
												return $$props.color;
											},

											get valid() {
												return valid();
											},

											onchange: onModelChanged
										});
									},

									$$slots: { default: true }
								});

								var node_3 = sibling(node_2, 2);

								Ui_control(node_3, {
									children: ($$anchor, $$slotProps) => {
										{
											let $0 = user_derived(() => [ACTIONS.resolve, ACTIONS.reject]);

											Ui_buttons($$anchor, {
												get values() {
													return get$3($0);
												}
											});
										}
									},

									$$slots: { default: true }
								});

								append($$anchor, fragment_4);
							},

							$$slots: { default: true }
						});
					};

					if_block(
						node_1,
						($$render) => {
							if (get$3(componentState) == "show") $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (get$3(componentState) === "hidden") $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_select_from_model_with_search_modal($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_SERVICE_GETTER = (serviceName) => {
			if (!serviceName) throw new Error("serviceName is not set");

			return notCommon$1.getApp().getService(serviceName);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string|number}   value
		 * @property {string}   [icon = '']
		 * @property {string}   [fieldname = '']
		 * @property {boolean}  [readonly = false]
		 * @property {string}   [serviceName = ''] - Set this, as ns[ModelName], should be registered in notApp
		 * @property {string}   [serviceOpenSelectorMethod = "openSelector"] - Set this
		 * @property {string}   [serviceLoadDataMethod = "loadData"] - Set this
		 * @property {object}   [modelData = null]
		 * @property {boolean}  [loading = false]
		 * @property {function} [selectedModelTitleFormatter = (data) => data._id]
		 * @property {function} [serviceGetter = (serviceName)=>notCommon.getApp().getService(serviceName)]
		 * @property {string}   [loadingLabel = "not-node:loading_label"]
		 * @property {string}   [isEmptyLabel = "not-node:field_value_is_empty_placeholder"]
		 * @property {function} [onchange = () => true]
		 * @property {object}   [openSelectorButtonProps = {}]
		 * @property {object}   [resetButtonProps = {}]
		 * @property {object}   [emptyButtonProps = {}]
		 * @property {object}   [valueButtonProps = {}]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15),
			icon = prop($$props, 'icon', 3, "search"),
			fieldname = prop($$props, 'fieldname', 3, ""),
			readonly = prop($$props, 'readonly', 3, false),
			serviceName = prop($$props, 'serviceName', 3, ""),
			serviceOpenSelectorMethod = prop($$props, 'serviceOpenSelectorMethod', 3, "openSelector"),
			serviceLoadDataMethod = prop($$props, 'serviceLoadDataMethod', 3, "loadData"),
			modelData = prop($$props, 'modelData', 15, null),
			loading = prop($$props, 'loading', 15, false),
			selectedModelTitleFormatter = prop($$props, 'selectedModelTitleFormatter', 3, (data) => `${data._id}`),
			serviceGetter = prop($$props, 'serviceGetter', 3, DEFAULT_SERVICE_GETTER),
			loadingLabel = prop($$props, 'loadingLabel', 3, "not-node:loading_label"),
			isEmptyLabel = prop($$props, 'isEmptyLabel', 3, "not-node:field_value_is_empty_placeholder"),
			onchange = prop($$props, 'onchange', 3, () => true),
			openSelectorButtonProps = prop($$props, 'openSelectorButtonProps', 19, () => ({})),
			resetButtonProps = prop($$props, 'resetButtonProps', 19, () => ({})),
			emptyButtonProps = prop($$props, 'emptyButtonProps', 19, () => ({})),
			valueButtonProps = prop($$props, 'valueButtonProps', 19, () => ({}));

		function openModelSearchAndSelect() {
			if (!serviceOpenSelectorMethod()) {
				throw new Error("serviceOpenSelectorMethod is not set");
			}

			const service = serviceGetter()(serviceName());

			service[serviceOpenSelectorMethod()]().then((result) => {
				value(result._id);
				modelData(result);

				return value();
			}).then((value) => {
				onchange()({ field: fieldname(), value, data: modelData() });
			}).catch((e) => {
				notCommon$1.report(e);
			});
		}

		function resetSelectedModel() {
			value(undefined);
			modelData(null);
			onchange()({ field: fieldname(), value: value() });
		}

		async function loadModelData() {
			try {
				if (!modelData() && value()) {
					loading(true);
					modelData(await getService()[serviceLoadDataMethod()](value()));
				}
			} catch(e) {
				notCommon$1.report(e);
			} finally {
				loading(false);
			}
		}

		onMount(() => {
			loadModelData();
		});

		const AVAILABLE_BUTTONS = [
			{
				id: 1,
				action: openModelSearchAndSelect,
				icon: icon(),
				color: "warning",
				...openSelectorButtonProps()
			},

			{
				id: 2,
				action: resetSelectedModel,
				icon: "times",
				color: "danger",
				...resetButtonProps()
			}
		];

		function getModelButton() {
			if (loading()) {
				return { disabled: true, loading: loading(), title: loadingLabel() };
			} else {
				if (modelData()) {
					return {
						disabled: readonly(),
						action: openModelSearchAndSelect,
						title: selectedModelTitleFormatter()(modelData()),
						...valueButtonProps()
					};
				} else {
					return { disabled: true, title: isEmptyLabel(), ...emptyButtonProps() };
				}
			}
		}

		let VISIBLE_BUTTONS = state(proxy([]));

		user_effect(() => {
			if (value()) {
				set(VISIBLE_BUTTONS, [getModelButton(), ...readonly() ? [] : AVAILABLE_BUTTONS], true);
			} else {
				set(
					VISIBLE_BUTTONS,
					[
						getModelButton(),
						...readonly() ? [] : [AVAILABLE_BUTTONS[0]]
					],
					true
				);
			}
		});

		Ui_control($$anchor, {
			children: ($$anchor, $$slotProps) => {
				Ui_buttons($$anchor, {
					get values() {
						return get$3(VISIBLE_BUTTONS);
					},

					class: "is-no-flex-wrap"
				});
			},

			$$slots: { default: true }
		});

		pop();
	}

	var root$L = from_html(`<progress> </progress>`);

	function Ui_progress($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any}      value
		 * @property {number}   [max = 100]
		 * @property {string}   [color = ""]
		 * @property {string}   [size = ""]
		 * @property {string}   [class = ""]
		 **/
		/** @type {Props} */
		let max = prop($$props, 'max', 3, 100),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, "");

		var progress = root$L();
		var text = child(progress);

		reset(progress);

		template_effect(() => {
			set_class(progress, 1, `
  progress
  ${classes() ?? ''}
  ${color() ? `is-${color()}` : ''}
  ${size() ? `is-${size()}` : ''}`);

			set_value(progress, $$props.value);
			set_attribute(progress, 'max', max());
			set_text(text, `${$$props.value ?? ''}%`);
		});

		append($$anchor, progress);
	}

	function Ui_show_one_from_list($$anchor, $$props) {
		push($$props, true);

		const defaultFilter = (value) => value[idFieldName()] === $$props.id;

		/**
		 * @typedef {Object} Props
		 * @property {string|number}    id                          id of active item
		 * @property {array}            [values = []]               list of items
		 * @property {function}         UIComponent                 component to show active item
		 * @property {function}         component                   snippet to show active item
		 * @property {function}         UIPlaceholder               placeholder if active is unset
		 * @property {function}         placeholder                 snippet to show placeholder
		 * @property {object}           [placeholderProps = {}]     placeholder props
		 * @property {object}           [active = {}]               current active element
		 * @property {string}           [idFieldName = "_id"]       name of item property used as identificator
		 * @property {function}         [filter = (value) => value[idFieldName] === id] filtering function to select active item. default is to search for item with selected id
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			active = prop($$props, 'active', 31, () => proxy({})),
			idFieldName = prop($$props, 'idFieldName', 3, "_id"),
			filter = prop($$props, 'filter', 3, defaultFilter);

		user_effect(() => {
			active(Array.isArray(values()) && values().length && typeof $$props.id !== "undefined" ? values().find(filter() || defaultFilter) : undefined);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						snippet(node_2, () => $$props.component, active);
						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var fragment_4 = comment();
								var node_4 = first_child(fragment_4);

								component(node_4, () => $$props.UIComponent, ($$anchor, UIComponent_1) => {
									UIComponent_1($$anchor, spread_props(active));
								});

								append($$anchor, fragment_4);
							};

							if_block(
								node_3,
								($$render) => {
									if ($$props.UIComponent) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if ($$props.component) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_2 = ($$anchor) => {
				var fragment_5 = comment();
				var node_5 = first_child(fragment_5);

				{
					var consequent_5 = ($$anchor) => {
						var fragment_6 = comment();
						var node_6 = first_child(fragment_6);

						{
							var consequent_3 = ($$anchor) => {
								var fragment_7 = comment();
								var node_7 = first_child(fragment_7);

								snippet(node_7, () => $$props.placeholder, () => $$props.placeholderProps);
								append($$anchor, fragment_7);
							};

							var alternate_1 = ($$anchor) => {
								var fragment_8 = comment();
								var node_8 = first_child(fragment_8);

								{
									var consequent_4 = ($$anchor) => {
										var fragment_9 = comment();
										var node_9 = first_child(fragment_9);

										component(node_9, () => $$props.UIPlaceholder, ($$anchor, UIPlaceholder_1) => {
											UIPlaceholder_1($$anchor, spread_props(() => $$props.placeholderProps));
										});

										append($$anchor, fragment_9);
									};

									if_block(
										node_8,
										($$render) => {
											if ($$props.UIPlaceholder) $$render(consequent_4);
										},
										true
									);
								}

								append($$anchor, fragment_8);
							};

							if_block(node_6, ($$render) => {
								if ($$props.placeholder) $$render(consequent_3); else $$render(alternate_1, false);
							});
						}

						append($$anchor, fragment_6);
					};

					if_block(
						node_5,
						($$render) => {
							if ($$props.UIPlaceholder) $$render(consequent_5);
						},
						true
					);
				}

				append($$anchor, fragment_5);
			};

			if_block(node, ($$render) => {
				if (active()) $$render(consequent_2); else $$render(alternate_2, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$K = from_html(`<div><!> <!></div> <!>`, 1);

	function Ui_tag_value($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "taggedValueId"] - if we want to address this tag
		 * @property {object}   title
		 * @property {object}   value
		 * @property {array}    [actions = []]
		 * @property {string}   [class = '']
		 * @property {any}      [actionsGroupContructor = UIButtons]
		 * @property {any}      [actionsGroupProps = {}]
		 * @property {boolean}  [readonly = false]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "taggedValueId"),
			actions = prop($$props, 'actions', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			ActionsGroupContructor = prop($$props, 'actionsGroupContructor', 3, Ui_buttons),
			actionsGroupProps = prop($$props, 'actionsGroupProps', 19, () => ({})),
			readonly = prop($$props, 'readonly', 3, false);

		var fragment = root$K();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.title));
			};

			if_block(node, ($$render) => {
				if ($$props.title) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.value));
			};

			if_block(node_1, ($$render) => {
				if ($$props.value) $$render(consequent_1);
			});
		}

		reset(div);

		var node_2 = sibling(div, 2);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				component(node_3, ActionsGroupContructor, ($$anchor, ActionsGroupContructor_1) => {
					ActionsGroupContructor_1($$anchor, spread_props(
						{
							get values() {
								return actions();
							}
						},
						actionsGroupProps
					));
				});

				append($$anchor, fragment_3);
			};

			if_block(node_2, ($$render) => {
				if (!readonly() && actions() && actions().length) $$render(consequent_2);
			});
		}

		template_effect(() => {
			set_class(div, 1, `tags has-addons ${classes() ?? ''}`);
			set_attribute(div, 'id', id());
		});

		append($$anchor, fragment);
		pop();
	}

	enable_legacy_mode_flag();

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/


	/**
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/** @import { FlipParams, AnimationConfig } from './public.js' */

	/**
	 * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.
	 * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).
	 *
	 * @param {Element} node
	 * @param {{ from: DOMRect; to: DOMRect }} fromTo
	 * @param {FlipParams} params
	 * @returns {AnimationConfig}
	 */
	function flip(node, { from, to }, params = {}) {
		var { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;

		var style = getComputedStyle(node);

		// find the transform origin, expressed as a pair of values between 0 and 1
		var transform = style.transform === 'none' ? '' : style.transform;
		var [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
		ox /= node.clientWidth;
		oy /= node.clientHeight;

		// calculate effect of parent transforms and zoom
		var zoom = get_zoom(node); // https://drafts.csswg.org/css-viewport/#effective-zoom
		var sx = node.clientWidth / to.width / zoom;
		var sy = node.clientHeight / to.height / zoom;

		// find the starting position of the transform origin
		var fx = from.left + from.width * ox;
		var fy = from.top + from.height * oy;

		// find the ending position of the transform origin
		var tx = to.left + to.width * ox;
		var ty = to.top + to.height * oy;

		// find the translation at the start of the transform
		var dx = (fx - tx) * sx;
		var dy = (fy - ty) * sy;

		// find the relative scale at the start of the transform
		var dsx = from.width / to.width;
		var dsy = from.height / to.height;

		return {
			delay,
			duration: typeof duration === 'function' ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
			easing,
			css: (t, u) => {
				var x = u * dx;
				var y = u * dy;
				var sx = t + u * dsx;
				var sy = t + u * dsy;

				return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
			}
		};
	}

	/**
	 * @param {Element} element
	 */
	function get_zoom(element) {
		if ('currentCSSZoom' in element) {
			return /** @type {number} */ (element.currentCSSZoom);
		}

		/** @type {Element | null} */
		var current = element;
		var zoom = 1;

		while (current !== null) {
			zoom *= +getComputedStyle(current).zoom;
			current = /** @type {Element | null} */ (current.parentElement);
		}

		return zoom;
	}

	/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */


	/** @param {number} x */
	const linear = (x) => x;

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * @param {Element} node
	 * @param {FadeParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = linear } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	var root_1$v = from_html(`<option selected class="svelte-wl7m3y"> </option>`);
	var root_4$d = from_html(`<option selected class="svelte-wl7m3y"> </option>`);
	var root_7$3 = from_html(`<div class="tags has-addons svelte-wl7m3y"><span class="tag svelte-wl7m3y"> </span> <span class="tag is-delete svelte-wl7m3y"></span></div>`);
	var root_6$a = from_html(`<div><!></div>`);
	var root_8$2 = from_html(`<span class="autocomplete-clear-button svelte-wl7m3y"><!></span>`);
	var root_11$2 = from_html(`<div><!></div>`);
	var root_17 = from_html(`<div class="autocomplete-list-item-no-results svelte-wl7m3y"> </div>`);
	var root_9$1 = from_html(`<!> <!> <!>`, 1);
	var root_19$2 = from_html(`<div class="autocomplete-list-item-loading svelte-wl7m3y"><!></div>`);
	var root_22$1 = from_html(`<div class="autocomplete-list-item-create svelte-wl7m3y"><!></div>`);
	var root_25 = from_html(`<div class="autocomplete-list-item-no-results svelte-wl7m3y"><!></div>`);
	var root$J = from_html(`<div><select class="svelte-wl7m3y"><!></select> <div class="input-container svelte-wl7m3y"><!> <input/> <!></div> <div><!></div></div>`);

	function SimpleAutocomplete($$anchor, $$props) {
		const $$sanitized_props = legacy_rest_props($$props, ['children', '$$slots', '$$events', '$$legacy']);

		const $$restProps = legacy_rest_props($$sanitized_props, [
			'highlightFilter',
			'items',
			'searchFunction',
			'labelFieldName',
			'keywordsFieldName',
			'valueFieldName',
			'labelFunction',
			'keywordsFunction',
			'valueFunction',
			'keywordsCleanFunction',
			'textCleanFunction',
			'beforeChange',
			'onChange',
			'onFocus',
			'onBlur',
			'onCreate',
			'selectFirstIfEmpty',
			'minCharactersToSearch',
			'maxItemsToShowInList',
			'multiple',
			'create',
			'ignoreAccents',
			'matchAllKeywords',
			'sortByMatchedKeywords',
			'itemFilterFunction',
			'itemSortFunction',
			'lock',
			'delay',
			'localFiltering',
			'localSorting',
			'cleanUserText',
			'lowercaseKeywords',
			'closeOnBlur',
			'orderableSelection',
			'hideArrow',
			'showClear',
			'clearText',
			'showLoadingIndicator',
			'noResultsText',
			'loadingText',
			'moreItemsText',
			'createText',
			'placeholder',
			'className',
			'inputClassName',
			'inputId',
			'name',
			'selectName',
			'selectId',
			'title',
			'html5autocomplete',
			'autocompleteOffValue',
			'readonly',
			'dropdownClassName',
			'disabled',
			'noInputStyles',
			'required',
			'debug',
			'tabindex',
			'selectedItem',
			'value',
			'highlightedItem',
			'text'
		]);

		push($$props, false);

		const showList = mutable_source();
		const hasSelection = mutable_source();
		const clearable = mutable_source();
		const locked = mutable_source();

		// the list of items  the user can select from
		let items = prop($$props, 'items', 28, () => []);

		/**
		 * function to use to get all items (alternative to providing items)
		 * @type {boolean|function}
		 */
		let searchFunction = prop($$props, 'searchFunction', 8, false);

		// field of each item that's used for the labels in the list
		let labelFieldName = prop($$props, 'labelFieldName', 8, undefined);

		let keywordsFieldName = prop($$props, 'keywordsFieldName', 24, labelFieldName);
		let valueFieldName = prop($$props, 'valueFieldName', 8, undefined);

		let labelFunction = prop($$props, 'labelFunction', 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return labelFieldName() ? item[labelFieldName()] : item;
		});

		let keywordsFunction = prop($$props, 'keywordsFunction', 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return keywordsFieldName() ? item[keywordsFieldName()] : labelFunction()(item);
		});

		let valueFunction = prop($$props, 'valueFunction', 8, function (item, forceSingle = false) {
			if (item === undefined || item === null) {
				return item;
			}

			if (!multiple() || forceSingle) {
				return valueFieldName() ? item[valueFieldName()] : item;
			} else {
				return item.map((i) => valueFieldName() ? i[valueFieldName()] : i);
			}
		});

		let keywordsCleanFunction = prop($$props, 'keywordsCleanFunction', 8, function (keywords) {
			return keywords;
		});

		let textCleanFunction = prop($$props, 'textCleanFunction', 8, function (userEnteredText) {
			return userEnteredText;
		});

		// events
		let beforeChange = prop($$props, 'beforeChange', 8, function (oldSelectedItem, newSelectedItem) {
			return true;
		});

		let onChange = prop($$props, 'onChange', 8, function (newSelectedItem) {});
		let onFocus = prop($$props, 'onFocus', 8, function () {});
		let onBlur = prop($$props, 'onBlur', 8, function () {});

		let onCreate = prop($$props, 'onCreate', 8, function (text) {
			if (debug()) {
				console.log("onCreate: " + text);
			}
		});

		// Behaviour properties
		let selectFirstIfEmpty = prop($$props, 'selectFirstIfEmpty', 8, false);

		let minCharactersToSearch = prop($$props, 'minCharactersToSearch', 8, 1);
		let maxItemsToShowInList = prop($$props, 'maxItemsToShowInList', 8, 0);
		let multiple = prop($$props, 'multiple', 8, false);
		let create = prop($$props, 'create', 8, false);

		// ignores the accents when matching items
		let ignoreAccents = prop($$props, 'ignoreAccents', 8, true);

		// all the input keywords should be matched in the item keywords
		let matchAllKeywords = prop($$props, 'matchAllKeywords', 8, true);

		// sorts the items by the number of matchink keywords
		let sortByMatchedKeywords = prop($$props, 'sortByMatchedKeywords', 8, false);

		// allow users to use a custom item filter function
		let itemFilterFunction = prop($$props, 'itemFilterFunction', 8, undefined);

		// allow users to use a custom item sort function
		let itemSortFunction = prop($$props, 'itemSortFunction', 8, undefined);

		// do not allow re-selection after initial selection
		let lock = prop($$props, 'lock', 8, false);

		// delay to wait after a keypress to search for new items
		let delay = prop($$props, 'delay', 8, 0);

		// true to perform local filtering of items, even if searchFunction is provided
		let localFiltering = prop($$props, 'localFiltering', 8, true);

		// true to perform local sortying of items
		let localSorting = prop($$props, 'localSorting', 8, true);

		// true to clean the user entered text (removes spaces)
		let cleanUserText = prop($$props, 'cleanUserText', 8, true);

		// true to lowercase the keywords derived from each item (lowercase)
		let lowercaseKeywords = prop($$props, 'lowercaseKeywords', 8, true);

		// true to close the dropdown when the component loses focus
		let closeOnBlur = prop($$props, 'closeOnBlur', 8, false);

		// true to allow selection reordering by drag and drop, needs multiple to true
		let orderableSelection = prop($$props, 'orderableSelection', 8, false);

		// UI properties
		// option to hide the dropdown arrow
		let hideArrow = prop($$props, 'hideArrow', 8, false);

		// option to show clear selection button
		let showClear = prop($$props, 'showClear', 8, false);

		// text to use for clear
		let clearText = prop($$props, 'clearText', 8, "&#10006;");

		// option to show loading indicator when the async function is executed
		let showLoadingIndicator = prop($$props, 'showLoadingIndicator', 8, false);

		// text displayed when no items match the input text
		let noResultsText = prop($$props, 'noResultsText', 8, "No results found");

		// text displayed when async data is being loaded
		let loadingText = prop($$props, 'loadingText', 8, "Loading results...");

		// text displayed when the user text matches a lot of items and we can not display them all in the dropdown
		let moreItemsText = prop($$props, 'moreItemsText', 8, "items not shown");

		// text displayed when async data is being loaded
		let createText = prop($$props, 'createText', 8, "Not found, add anyway?");

		// the text displayed when no option is selected
		let placeholder = prop($$props, 'placeholder', 8, undefined);

		// apply a className to the control
		let className = prop($$props, 'className', 8, undefined);

		// HTML input UI properties
		// apply a className to the input control
		let inputClassName = prop($$props, 'inputClassName', 8, undefined);

		// apply a id to the input control
		let inputId = prop($$props, 'inputId', 8, undefined);

		// generate an HTML input with this name
		let name = prop($$props, 'name', 8, undefined);

		// generate a <select> tag that holds the value
		let selectName = prop($$props, 'selectName', 8, undefined);

		// apply a id to the <select>
		let selectId = prop($$props, 'selectId', 8, undefined);

		// add the title to the HTML input
		let title = prop($$props, 'title', 8, undefined);

		// enable the html5 autocompletion to the HTML input
		let html5autocomplete = prop($$props, 'html5autocomplete', 8, undefined);

		// enable the html5 autocompletion value
		let autocompleteOffValue = prop($$props, 'autocompleteOffValue', 8, "off");

		// make the input readonly
		let readonly = prop($$props, 'readonly', 8, undefined);

		// apply a className to the dropdown div
		let dropdownClassName = prop($$props, 'dropdownClassName', 8, undefined);

		// adds the disabled tag to the HTML input
		let disabled = prop($$props, 'disabled', 8, false);

		// remove the autocomplete-input class of the input
		let noInputStyles = prop($$props, 'noInputStyles', 8, false);

		// adds the required attribute to the HTML input
		let required = prop($$props, 'required', 8, null);

		let debug = prop($$props, 'debug', 8, false);

		// add tabindex support for the input
		// set standard to 0: https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
		let tabindex = prop($$props, 'tabindex', 8, 0);

		// --- Public State ----
		// selected item state
		let selectedItem = prop($$props, 'selectedItem', 28, () => multiple() ? [] : undefined);

		let value = prop($$props, 'value', 12, undefined);
		let highlightedItem = prop($$props, 'highlightedItem', 12, undefined);

		// --- Internal State ----
		const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);

		// HTML elements
		let input = mutable_source();

		let list = mutable_source();
		let inputContainer = mutable_source();

		// UI state
		let opened = mutable_source(false);

		let loading = mutable_source(false);
		let highlightIndex = mutable_source(-1);
		let text$1 = prop($$props, 'text', 12, undefined);
		let filteredTextLength = mutable_source(0);

		// view model
		let filteredListItems = mutable_source();

		let listItems = [];

		// requests/responses counters
		let lastRequestId = 0;

		let lastResponseId = 0;

		// other state
		let inputDelayTimeout;

		let setPositionOnNextUpdate = mutable_source(false);

		// --- Lifecycle events ---
		afterUpdate(() => {
			if (get$3(setPositionOnNextUpdate)) {
				setScrollAwareListPosition();
			}

			set(setPositionOnNextUpdate, false);
		});

		// --- Functions ---
		function safeFunction(theFunction, argument) {
			if (typeof theFunction !== "function") {
				console.error("Not a function: " + theFunction + ", argument: " + argument);

				return undefined;
			}

			let result;

			try {
				result = theFunction(argument);
			} catch(error) {
				console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
			}

			return result;
		}

		function safeStringFunction(theFunction, argument) {
			let result = safeFunction(theFunction, argument);

			if (result === undefined || result === null) {
				result = "";
			}

			if (typeof result !== "string") {
				result = result.toString();
			}

			return result;
		}

		function safeLabelFunction(item) {
			// console.log("labelFunction: " + labelFunction);
			// console.log("safeLabelFunction, item: " + item);
			return safeStringFunction(labelFunction(), item);
		}

		function safeKeywordsFunction(item) {
			// console.log("safeKeywordsFunction");
			const keywords = safeStringFunction(keywordsFunction(), item);

			let result = safeStringFunction(keywordsCleanFunction(), keywords);

			result = lowercaseKeywords() ? result.toLowerCase().trim() : result;

			if (ignoreAccents()) {
				result = removeAccents(result);
			}

			if (debug()) {
				console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
			}

			return result;
		}

		function prepareListItems() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete prepare list ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Prepare items to search");
				console.log("items: " + JSON.stringify(items()));
			}

			if (!Array.isArray(items())) {
				console.warn("Autocomplete items / search function did not return array but", items());
				items([]);
			}

			const length = items() ? items().length : 0;

			listItems = new Array(length);

			if (length > 0) {
				items().forEach((item, i) => {
					const listItem = getListItem(item);

					if (listItem === undefined) {
						console.log("Undefined item for: ", item);
					}

					listItems[i] = listItem;
				});
			}

			set(filteredListItems, listItems);

			if (debug()) {
				console.log(listItems.length + " items to search");
				console.timeEnd(timerId);
			}
		}

		function getListItem(item) {
			return {
				// keywords representation of the item
				keywords: localFiltering() ? safeKeywordsFunction(item) : [],

				// item label
				label: safeLabelFunction(item),

				// store reference to the origial item
				item
			};
		}

		// -- Reactivity --
		function onSelectedItemChanged() {
			value(valueFunction()(selectedItem()));

			if (selectedItem() && !multiple()) {
				text$1(safeLabelFunction(selectedItem()));
			}

			set(filteredListItems, listItems);
			onChange()(selectedItem());
		}

		function prepareUserEnteredText(userEnteredText) {
			if (userEnteredText === undefined || userEnteredText === null) {
				return "";
			}

			if (!cleanUserText()) {
				return userEnteredText;
			}

			const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
			const cleanUserEnteredText = safeStringFunction(textCleanFunction(), textFiltered);

			const textTrimmed = lowercaseKeywords()
				? cleanUserEnteredText.toLowerCase().trim()
				: cleanUserEnteredText.trim();

			return textTrimmed;
		}

		function numberOfMatches(listItem, searchWords) {
			if (!listItem) {
				return 0;
			}

			const itemKeywords = listItem.keywords;
			let matches = 0;

			searchWords.forEach((searchWord) => {
				if (itemKeywords.includes(searchWord)) {
					matches++;
				}
			});

			return matches;
		}

		async function search() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete search ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Searching user entered text: '" + text$1() + "'");
			}

			let textFiltered = prepareUserEnteredText(text$1());

			if (minCharactersToSearch() > 1 && textFiltered.length < minCharactersToSearch()) {
				textFiltered = "";
			}

			set(filteredTextLength, textFiltered.length);

			if (debug()) {
				console.log("Changed user entered text '" + text$1() + "' into '" + textFiltered + "'");
			}

			// if no search text load all items
			if (textFiltered === "") {
				if (searchFunction()) {
					// we will need to rerun the search
					items([]);

					if (debug()) {
						console.log("User entered text is empty clear list of items");
					}
				} else {
					set(filteredListItems, listItems);

					if (debug()) {
						console.log("User entered text is empty set the list of items to all items");
					}
				}

				if (closeIfMinCharsToSearchReached()) {
					if (debug()) {
						console.timeEnd(timerId);
					}

					return;
				}
			}

			if (!searchFunction()) {
				// internal search
				processListItems(textFiltered);
			} else {
				// external search which provides items
				lastRequestId = lastRequestId + 1;

				const currentRequestId = lastRequestId;

				set(loading, true);

				// searchFunction is a generator
				if (searchFunction().constructor.name === "AsyncGeneratorFunction") {
					for await (const chunk of searchFunction()(textFiltered, maxItemsToShowInList())) {
						// a chunk of an old response: throw it away
						if (currentRequestId < lastResponseId) {
							return false;
						}

						// a chunk for a new response: reset the item list
						if (currentRequestId > lastResponseId) {
							items([]);
						}

						lastResponseId = currentRequestId;
						items([...items(), ...chunk]);
						processListItems(textFiltered);
					}

					// there was nothing in the chunk
					if (lastResponseId < currentRequestId) {
						lastResponseId = currentRequestId;
						items([]);
						processListItems(textFiltered);
					}
				} else // searchFunction is a regular function
				{
					let result = await searchFunction()(textFiltered, maxItemsToShowInList());

					// If a response to a newer request has been received
					// while responses to this request were being loaded,
					// then we can just throw away this outdated results.
					if (currentRequestId < lastResponseId) {
						return false;
					}

					lastResponseId = currentRequestId;
					items(result);
					processListItems(textFiltered);
				}

				set(loading, false);
			}

			if (debug()) {
				console.timeEnd(timerId);
				console.log("Search found " + get$3(filteredListItems).length + " items");
			}
		}

		function defaultItemFilterFunction(listItem, searchWords) {
			const matches = numberOfMatches(listItem, searchWords);

			if (matchAllKeywords()) {
				return matches >= searchWords.length;
			} else {
				return matches > 0;
			}
		}

		function defaultItemSortFunction(obj1, obj2, searchWords) {
			return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
		}

		function processListItems(textFiltered) {
			// cleans, filters, orders, and highlights the list items
			prepareListItems();

			const textFilteredWithoutAccents = ignoreAccents() ? removeAccents(textFiltered) : textFiltered;
			const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter((word) => word !== "");

			// local search
			let tempfilteredListItems;

			if (localFiltering()) {
				if (itemFilterFunction()) {
					tempfilteredListItems = listItems.filter((item) => itemFilterFunction()(item.item, searchWords));
				} else {
					tempfilteredListItems = listItems.filter((item) => defaultItemFilterFunction(item, searchWords));
				}

				if (localSorting()) {
					if (itemSortFunction()) {
						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction()(item1.item, item2.item, searchWords));
					} else {
						if (sortByMatchedKeywords()) {
							tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
						}
					}
				}
			} else {
				tempfilteredListItems = listItems;
			}

			const hlfilter = highlightFilter(searchWords, "label");

			set(filteredListItems, tempfilteredListItems.map(hlfilter));
			closeIfMinCharsToSearchReached();

			return true;
		}

		// $: text, search();
		function afterCreate(createdItem) {
			let listItem;

			if (debug()) {
				console.log("createdItem", createdItem);
			}

			if ("undefined" !== typeof createdItem) {
				prepareListItems();
				set(filteredListItems, listItems);

				let index = findItemIndex(createdItem, get$3(filteredListItems));

				// if the items array was not updated, add the created item manually
				if (index <= 0) {
					items([createdItem]);
					prepareListItems();
					set(filteredListItems, listItems);
					index = 0;
				}

				if (index >= 0) {
					set(highlightIndex, index);
					listItem = get$3(filteredListItems)[get$3(highlightIndex)];
				}
			}

			return listItem;
		}

		function selectListItem(listItem) {
			if (debug()) {
				console.log("selectListItem", listItem);
			}

			if ("undefined" === typeof listItem && create()) {
				// allow undefined items if create is enabled
				const createdItem = onCreate()(text$1());

				if ("undefined" !== typeof createdItem) {
					if (typeof createdItem.then === "function") {
						createdItem.then((newItem) => {
							if ("undefined" !== typeof newItem) {
								const newListItem = afterCreate(newItem);

								if ("undefined" !== typeof newListItem) {
									selectListItem(newListItem);
								}
							}
						});

						return true;
					} else {
						listItem = afterCreate(createdItem);
					}
				}
			}

			if ("undefined" === typeof listItem) {
				if (debug()) {
					console.log(`listItem is undefined. Can not select.`);
				}

				return false;
			}

			if (get$3(locked)) {
				return true;
			}

			const newSelectedItem = listItem.item;

			if (beforeChange()(selectedItem(), newSelectedItem)) {
				// simple selection
				if (!multiple()) {
					selectedItem(undefined // triggers change even if the the same item is selected
					);
					selectedItem(newSelectedItem);
				} else // first selection of multiple ones
				if (!selectedItem()) {
					selectedItem([newSelectedItem]);
				} else // selecting something already selected => unselect it
				if (selectedItem().includes(newSelectedItem)) {
					selectedItem(selectedItem().filter((i) => i !== newSelectedItem));
				} else // adds the element to the selection
				{
					selectedItem([...selectedItem(), newSelectedItem]);
				}
			}

			return true;
		}

		function selectItem() {
			if (debug()) {
				console.log("selectItem", get$3(highlightIndex));
			}

			const listItem = get$3(filteredListItems)[get$3(highlightIndex)];

			if (selectListItem(listItem)) {
				if (debug()) {
					console.log("selectListItem true, closing");
				}

				close();

				if (multiple()) {
					text$1("");
					get$3(input).focus();
				}
			} else {
				if (debug()) {
					console.log("selectListItem false, not closing");
				}
			}
		}

		function up() {
			if (debug()) {
				console.log("up");
			}

			open();

			if (get$3(highlightIndex) > 0) {
				update(highlightIndex, -1);
			}

			highlight();
		}

		function down() {
			if (debug()) {
				console.log("down");
			}

			open();

			if (get$3(highlightIndex) < get$3(filteredListItems).length - 1) {
				update(highlightIndex);
			}

			highlight();
		}

		function highlight() {
			if (debug()) {
				console.log("highlight");
			}

			const query = ".selected";

			if (debug()) {
				console.log("Seaching DOM element: " + query + " in " + get$3(list));
			}

			/**
			 * @param {Element} el
			 */
			const el = get$3(list) && get$3(list).querySelector(query);

			if (el) {
				if (typeof el.scrollIntoViewIfNeeded === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoViewIfNeeded();
				} else if (el.scrollIntoView === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoView();
				} else {
					if (debug()) {
						console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
					}
				}
			} else {
				if (debug()) {
					console.warn("Selected item not found to scroll into view");
				}
			}
		}

		function onListItemClick(listItem) {
			if (debug()) {
				console.log("onListItemClick");
			}

			if (selectListItem(listItem)) {
				close();

				if (multiple()) {
					text$1("");
					get$3(input).focus();
				}
			}
		}

		function onDocumentClick(e) {
			if (debug()) {
				console.log("onDocumentClick");
			}

			if (e.composedPath().some((path) => path.classList && path.classList.contains(uniqueId))) {
				if (debug()) {
					console.log("onDocumentClick inside");
				}

				// resetListToAllItemsAndOpen();
				highlight();
			} else {
				if (debug()) {
					console.log("onDocumentClick outside");
				}

				close();
			}
		}

		function onKeyDown(e) {
			if (debug()) {
				console.log("onKeyDown");
			}

			let key = e.key;

			if (key === "Tab" && e.shiftKey) key = "ShiftTab";

			const fnmap = {
				Tab: get$3(opened) ? close : null,
				ShiftTab: get$3(opened) ? close : null,
				ArrowDown: down.bind(this),
				ArrowUp: up.bind(this),
				Escape: onEsc.bind(this),
				Backspace: multiple() && get$3(hasSelection) && !text$1() ? onBackspace.bind(this) : null
			};

			const fn = fnmap[key];

			if (typeof fn === "function") {
				fn(e);
			}
		}

		function onKeyPress(e) {
			if (debug()) {
				console.log("onKeyPress");
			}

			if (e.key === "Enter") {
				onEnter(e);
			}
		}

		function onEnter(e) {
			if (get$3(opened)) {
				e.preventDefault();
				selectItem();
			}
		}

		function onInput(e) {
			if (debug()) {
				console.log("onInput");
			}

			text$1(e.target.value);

			if (inputDelayTimeout) {
				clearTimeout(inputDelayTimeout);
			}

			if (delay()) {
				inputDelayTimeout = setTimeout(processInput, delay());
			} else {
				processInput();
			}
		}

		function unselectItem(tag) {
			if (debug()) {
				console.log("unselectItem", tag);
			}

			selectedItem(selectedItem().filter((i) => i !== tag));
			get$3(input).focus();
		}

		function processInput() {
			if (search()) {
				set(highlightIndex, 0);
				open();
			}
		}

		function onInputClick() {
			if (debug()) {
				console.log("onInputClick");
			}

			resetListToAllItemsAndOpen();
		}

		function onEsc(e) {
			if (debug()) {
				console.log("onEsc");
			}

			//if (text) return clear();
			e.stopPropagation();

			if (get$3(opened)) {
				get$3(input).focus();
				close();
			}
		}

		function onBackspace(e) {
			if (debug()) {
				console.log("onBackspace");
			}

			unselectItem(selectedItem()[selectedItem().length - 1]);
		}

		function onFocusInternal() {
			if (debug()) {
				console.log("onFocus");
			}

			onFocus()();
			resetListToAllItemsAndOpen();
		}

		function onBlurInternal() {
			if (debug()) {
				console.log("onBlur");
			}

			if (closeOnBlur()) {
				close();
			}

			onBlur()();
		}

		function resetListToAllItemsAndOpen() {
			if (debug()) {
				console.log("resetListToAllItemsAndOpen");
			}

			if (searchFunction() && !listItems.length) {
				search();
			} else if (!text$1()) {
				set(filteredListItems, listItems);
			}

			open();

			// find selected item
			if (selectedItem()) {
				if (debug()) {
					console.log("Searching currently selected item: " + JSON.stringify(selectedItem()));
				}

				const index = findItemIndex(selectedItem(), get$3(filteredListItems));

				if (index >= 0) {
					set(highlightIndex, index);
					highlight();
				}
			}
		}

		function findItemIndex(item, items) {
			if (debug()) {
				console.log("Finding index for item", item);
			}

			let index = -1;

			for (let i = 0; i < items.length; i++) {
				const listItem = items[i];

				if ("undefined" === typeof listItem) {
					if (debug()) {
						console.log(`listItem ${i} is undefined. Skipping.`);
					}

					continue;
				}

				if (debug()) {
					console.log("Item " + i + ": " + JSON.stringify(listItem));
				}

				if (item === listItem.item) {
					index = i;

					break;
				}
			}

			if (debug()) {
				if (index >= 0) {
					console.log("Found index for item: " + index);
				} else {
					console.warn("Not found index for item: " + item);
				}
			}

			return index;
		}

		function open() {
			if (debug()) {
				console.log("open");
			}

			// check if the search text has more than the min chars required
			if (get$3(locked) || notEnoughSearchText()) {
				return;
			}

			set(setPositionOnNextUpdate, true);
			set(opened, true);
		}

		function close() {
			if (debug()) {
				console.log("close");
			}

			set(opened, false);
			set(loading, false);

			if (!text$1() && selectFirstIfEmpty()) {
				set(highlightIndex, 0);
				selectItem();
			}
		}

		function notEnoughSearchText() {
			return minCharactersToSearch() > 0 && get$3(filteredTextLength) < minCharactersToSearch() && (// When no searchFunction is defined, the menu should always open when the input is focused
			searchFunction() || get$3(filteredTextLength) > 0);
		}

		function closeIfMinCharsToSearchReached() {
			if (notEnoughSearchText()) {
				close();

				return true;
			}

			return false;
		}

		function clear() {
			if (debug()) {
				console.log("clear");
			}

			text$1("");
			selectedItem(multiple() ? [] : undefined);

			setTimeout(() => {
				get$3(input).focus();
			});
		}

		function highlightFilter(keywords, field) {
			return (item) => {
				let label = item[field];
				const newItem = Object.assign({ highlighted: undefined }, item);

				newItem.highlighted = label;

				const labelLowercase = label.toLowerCase();
				const labelLowercaseNoAc = ignoreAccents() ? removeAccents(labelLowercase) : labelLowercase;

				if (keywords && keywords.length) {
					const positions = [];

					for (let i = 0; i < keywords.length; i++) {
						let keyword = keywords[i];

						if (ignoreAccents()) {
							keyword = removeAccents(keyword);
						}

						const keywordLen = keyword.length;
						let pos1 = 0;

						do {
							pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

							if (pos1 >= 0) {
								let pos2 = pos1 + keywordLen;

								positions.push([pos1, pos2]);
								pos1 = pos2;
							}
						} while (pos1 !== -1);
					}

					if (positions.length > 0) {
						const keywordPatterns = new Set();

						for (let i = 0; i < positions.length; i++) {
							const pair = positions[i];
							const pos1 = pair[0];
							const pos2 = pair[1];
							const keywordPattern = labelLowercase.substring(pos1, pos2);

							keywordPatterns.add(keywordPattern);
						}

						for (let keywordPattern of keywordPatterns) {
							// FIXME pst: workarond for wrong replacement <b> tags
							if (keywordPattern === "b") {
								continue;
							}

							const reg = new RegExp("(" + keywordPattern + ")", "ig");
							const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");

							newItem.highlighted = newHighlighted;
						}
					}
				}

				return newItem;
			};
		}

		function removeAccents(str) {
			return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
		}

		function isConfirmed(listItem) {
			if (!selectedItem()) {
				return false;
			}

			if (multiple()) {
				return selectedItem().includes(listItem);
			} else {
				return listItem === selectedItem();
			}
		}

		let draggingOver = mutable_source(false);

		function dragstart(event, index) {
			if (orderableSelection()) {
				event.dataTransfer.setData("source", index);
			}
		}

		function dragover(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, index);
			}
		}

		function dragleave(event, index) {
			if (orderableSelection()) {
				set(draggingOver, false);
			}
		}

		function drop(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, false);

				let from = parseInt(event.dataTransfer.getData("source"));
				let to = index;

				if (from != to) {
					moveSelectedItem(from, to);
				}
			}
		}

		function moveSelectedItem(from, to) {
			let newSelection = [...selectedItem()];

			if (from < to) {
				newSelection.splice(to + 1, 0, newSelection[from]);
				newSelection.splice(from, 1);
			} else {
				newSelection.splice(to, 0, newSelection[from]);
				newSelection.splice(from + 1, 1);
			}

			selectedItem(newSelection);
		}

		function setScrollAwareListPosition() {
			const { height: viewPortHeight } = window.visualViewport;
			const { bottom: inputButtom, height: inputHeight } = get$3(inputContainer).getBoundingClientRect();
			const { height: listHeight } = get$3(list).getBoundingClientRect();

			if (inputButtom + listHeight > viewPortHeight) {
				mutate(list, get$3(list).style.top = `-${inputHeight + listHeight}px`);
			} else {
				mutate(list, get$3(list).style.top = "0px");
			}
		}

		legacy_pre_effect(
			() => (
				deep_read_state(items()),
				deep_read_state(searchFunction())
			),
			() => {
				(items(), searchFunction() || prepareListItems());
			}
		);

		legacy_pre_effect(() => (deep_read_state(selectedItem())), () => {
			(selectedItem(), onSelectedItemChanged());
		});

		legacy_pre_effect(() => (get$3(filteredListItems), get$3(highlightIndex)), () => {
			highlightedItem(get$3(filteredListItems) && get$3(highlightIndex) && get$3(highlightIndex) >= 0 && get$3(highlightIndex) < get$3(filteredListItems).length
				? get$3(filteredListItems)[get$3(highlightIndex)].item
				: null);
		});

		legacy_pre_effect(
			() => (
				get$3(opened),
				deep_read_state(items()),
				get$3(filteredTextLength)
			),
			() => {
				set(showList, get$3(opened) && (items() && items().length > 0 || get$3(filteredTextLength) > 0));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(multiple()),
				deep_read_state(selectedItem())
			),
			() => {
				set(hasSelection, multiple() && selectedItem() && selectedItem().length > 0 || !multiple() && selectedItem());
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(showClear()),
				deep_read_state(lock()),
				deep_read_state(multiple()),
				get$3(hasSelection)
			),
			() => {
				set(clearable, showClear() || (lock() || multiple()) && get$3(hasSelection));
			}
		);

		legacy_pre_effect(() => (deep_read_state(lock()), get$3(hasSelection)), () => {
			set(locked, lock() && get$3(hasSelection));
		});

		legacy_pre_effect_reset();

		var $$exports = { highlightFilter };

		init();

		var div = root$J();

		event('click', $window, onDocumentClick);
		event('scroll', $window, () => set(setPositionOnNextUpdate, true));

		let classes;
		var select = child(div);
		var node = child(select);

		{
			var consequent = ($$anchor) => {
				var option = root_1$v();
				var text_1 = child(option, true);

				reset(option);

				var option_value = {};

				template_effect(
					($0, $1) => {
						set_text(text_1, $0);

						if (option_value !== (option_value = $1)) {
							option.value = (option.__value = $1) ?? '';
						}
					},
					[
						() => (
							deep_read_state(selectedItem()),
							untrack(() => safeLabelFunction(selectedItem()))
						),

						() => (
							deep_read_state(valueFunction()),
							deep_read_state(selectedItem()),
							untrack(() => valueFunction()(selectedItem(), true))
						)
					]
				);

				append($$anchor, option);
			};

			var alternate = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 1, selectedItem, index$e, ($$anchor, i) => {
							var option_1 = root_4$d();
							var text_2 = child(option_1, true);

							reset(option_1);

							var option_1_value = {};

							template_effect(
								($0, $1) => {
									set_text(text_2, $0);

									if (option_1_value !== (option_1_value = $1)) {
										option_1.value = (option_1.__value = $1) ?? '';
									}
								},
								[
									() => (get$3(i), untrack(() => safeLabelFunction(get$3(i)))),

									() => (
										deep_read_state(valueFunction()),
										get$3(i),
										untrack(() => valueFunction()(get$3(i), true))
									)
								]
							);

							append($$anchor, option_1);
						});

						append($$anchor, fragment_1);
					};

					if_block(
						node_1,
						($$render) => {
							if (multiple() && get$3(hasSelection)) $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment);
			};

			if_block(node, ($$render) => {
				if (!multiple() && get$3(hasSelection)) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(select);

		var div_1 = sibling(select, 2);
		var node_3 = child(div_1);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_2 = comment();
				var node_4 = first_child(fragment_2);

				each(node_4, 11, selectedItem, (tagItem) => valueFunction()(tagItem, true), ($$anchor, tagItem, i) => {
					var div_2 = root_6$a();

					set_attribute(div_2, 'draggable', true);

					let classes_1;
					var node_5 = child(div_2);

					{
						let $0 = derived_safe_equal(() => (
							get$3(tagItem),
							untrack(() => safeLabelFunction(get$3(tagItem)))
						));

						slot(
							node_5,
							$$props,
							'tag',
							{
								get label() {
									return get$3($0);
								},

								get item() {
									return get$3(tagItem);
								},

								unselectItem
							},
							($$anchor) => {
								var div_3 = root_7$3();
								var span = child(div_3);
								var text_3 = child(span, true);

								reset(span);

								var span_1 = sibling(span, 2);
								var event_handler = user_derived(() => unselectItem(get$3(tagItem)));

								reset(div_3);

								template_effect(($0) => set_text(text_3, $0), [
									() => (
										get$3(tagItem),
										untrack(() => safeLabelFunction(get$3(tagItem)))
									)
								]);

								event('click', span_1, preventDefault(function (...$$args) {
									get$3(event_handler)?.apply(this, $$args);
								}));

								event('keypress', span_1, preventDefault((e) => {
									e.key == "Enter" && unselectItem(get$3(tagItem));
								}));

								append($$anchor, div_3);
							}
						);
					}

					reset(div_2);
					template_effect(() => classes_1 = set_class(div_2, 1, 'svelte-wl7m3y', null, classes_1, { 'is-active': get$3(draggingOver) === get$3(i) }));
					animation(div_2, () => flip, () => ({ duration: 200 }));
					transition(3, div_2, () => fade, () => ({ duration: 200 }));
					event('dragstart', div_2, (event) => dragstart(event, get$3(i)));
					event('dragover', div_2, (event) => dragover(event, get$3(i)));
					event('dragleave', div_2, (event) => dragleave(event, get$3(i)));
					event('drop', div_2, (event) => drop(event, get$3(i)));
					append($$anchor, div_2);
				});

				append($$anchor, fragment_2);
			};

			if_block(node_3, ($$render) => {
				if (multiple() && get$3(hasSelection)) $$render(consequent_2);
			});
		}

		var input_1 = sibling(node_3, 2);

		attribute_effect(
			input_1,
			() => ({
				type: 'text',
				class: `${(inputClassName() ? inputClassName() : '') ?? ''} ${noInputStyles() ? '' : 'input autocomplete-input'}`,
				id: inputId() ? inputId() : "",
				autocomplete: html5autocomplete() ? "on" : autocompleteOffValue(),
				placeholder: placeholder(),
				name: name(),
				disabled: disabled(),
				required: required(),
				title: title(),
				readonly: readonly() || get$3(locked),
				tabindex: tabindex(),
				...$$restProps
			}),
			void 0,
			void 0,
			void 0,
			'svelte-wl7m3y',
			true
		);

		bind_this(input_1, ($$value) => set(input, $$value), () => get$3(input));

		var node_6 = sibling(input_1, 2);

		{
			var consequent_3 = ($$anchor) => {
				var span_2 = root_8$2();
				var node_7 = child(span_2);

				html(node_7, clearText);
				reset(span_2);
				event('click', span_2, clear);

				event('keypress', span_2, (e) => {
					e.key == "Enter" && clear();
				});

				append($$anchor, span_2);
			};

			if_block(node_6, ($$render) => {
				if (get$3(clearable)) $$render(consequent_3);
			});
		}

		reset(div_1);
		bind_this(div_1, ($$value) => set(inputContainer, $$value), () => get$3(inputContainer));

		var div_4 = sibling(div_1, 2);
		var node_8 = child(div_4);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_3 = root_9$1();
				var node_9 = first_child(fragment_3);

				slot(
					node_9,
					$$props,
					'dropdown-header',
					{
						get nbItems() {
							return (
								get$3(filteredListItems),
								untrack(() => get$3(filteredListItems).length)
							);
						},

						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					null
				);

				var node_10 = sibling(node_9, 2);

				each(node_10, 1, () => get$3(filteredListItems), index$e, ($$anchor, listItem, i) => {
					var fragment_4 = comment();
					var node_11 = first_child(fragment_4);

					{
						var consequent_5 = ($$anchor) => {
							var div_5 = root_11$2();
							let classes_2;
							var node_12 = child(div_5);

							slot(
								node_12,
								$$props,
								'item',
								{
									get item() {
										return (get$3(listItem), untrack(() => get$3(listItem).item));
									},

									get label() {
										return (
											get$3(listItem),
											untrack(() => get$3(listItem).highlighted ? get$3(listItem).highlighted : get$3(listItem).label)
										);
									}
								},
								($$anchor) => {
									var fragment_5 = comment();
									var node_13 = first_child(fragment_5);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_6 = comment();
											var node_14 = first_child(fragment_6);

											html(node_14, () => (
												get$3(listItem),
												untrack(() => get$3(listItem).highlighted)
											));

											append($$anchor, fragment_6);
										};

										var alternate_1 = ($$anchor) => {
											var fragment_7 = comment();
											var node_15 = first_child(fragment_7);

											html(node_15, () => (get$3(listItem), untrack(() => get$3(listItem).label)));
											append($$anchor, fragment_7);
										};

										if_block(node_13, ($$render) => {
											if ((
												get$3(listItem),
												untrack(() => get$3(listItem).highlighted)
											)) $$render(consequent_4); else $$render(alternate_1, false);
										});
									}

									append($$anchor, fragment_5);
								}
							);

							reset(div_5);

							template_effect(($0) => classes_2 = set_class(div_5, 1, 'autocomplete-list-item svelte-wl7m3y', null, classes_2, $0), [
								() => ({
									selected: i === get$3(highlightIndex),
									confirmed: isConfirmed(get$3(listItem).item)
								})
							]);

							event('click', div_5, () => onListItemClick(get$3(listItem)));

							event('keypress', div_5, (e) => {
								e.key == "Enter" && onListItemClick(get$3(listItem));
							});

							event('pointerenter', div_5, () => {
								set(highlightIndex, i);
							});

							append($$anchor, div_5);
						};

						if_block(node_11, ($$render) => {
							if (get$3(listItem) && (maxItemsToShowInList() <= 0 || i < maxItemsToShowInList())) $$render(consequent_5);
						});
					}

					append($$anchor, fragment_4);
				});

				var node_16 = sibling(node_10, 2);

				slot(
					node_16,
					$$props,
					'dropdown-footer',
					{
						get nbItems() {
							return (
								get$3(filteredListItems),
								untrack(() => get$3(filteredListItems).length)
							);
						},

						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					($$anchor) => {
						var fragment_8 = comment();
						var node_17 = first_child(fragment_8);

						{
							var consequent_7 = ($$anchor) => {
								var fragment_9 = comment();
								var node_18 = first_child(fragment_9);

								{
									var consequent_6 = ($$anchor) => {
										var div_6 = root_17();
										var text_4 = child(div_6);

										reset(div_6);

										template_effect(() => set_text(text_4, `...${(
										get$3(filteredListItems),
										deep_read_state(maxItemsToShowInList()),
										untrack(() => get$3(filteredListItems).length - maxItemsToShowInList())
									) ?? ''}
              ${moreItemsText() ?? ''}`));

										append($$anchor, div_6);
									};

									if_block(node_18, ($$render) => {
										if (moreItemsText()) $$render(consequent_6);
									});
								}

								append($$anchor, fragment_9);
							};

							if_block(node_17, ($$render) => {
								if ((
									deep_read_state(maxItemsToShowInList()),
									get$3(filteredListItems),
									untrack(() => maxItemsToShowInList() > 0 && get$3(filteredListItems).length > maxItemsToShowInList())
								)) $$render(consequent_7);
							});
						}

						append($$anchor, fragment_8);
					}
				);

				append($$anchor, fragment_3);
			};

			var alternate_4 = ($$anchor) => {
				var fragment_10 = comment();
				var node_19 = first_child(fragment_10);

				{
					var consequent_9 = ($$anchor) => {
						var div_7 = root_19$2();
						var node_20 = child(div_7);

						slot(
							node_20,
							$$props,
							'loading',
							{
								get loadingText() {
									return loadingText();
								}
							},
							($$anchor) => {
								var text_5 = text();

								template_effect(() => set_text(text_5, loadingText()));
								append($$anchor, text_5);
							}
						);

						reset(div_7);
						append($$anchor, div_7);
					};

					var alternate_3 = ($$anchor) => {
						var fragment_12 = comment();
						var node_21 = first_child(fragment_12);

						{
							var consequent_10 = ($$anchor) => {
								var div_8 = root_22$1();
								var node_22 = child(div_8);

								slot(
									node_22,
									$$props,
									'create',
									{
										get createText() {
											return createText();
										}
									},
									($$anchor) => {
										var text_6 = text();

										template_effect(() => set_text(text_6, createText()));
										append($$anchor, text_6);
									}
								);

								reset(div_8);
								event('click', div_8, selectItem);

								event('keypress', div_8, (e) => {
									e.key == "Enter" && selectItem();
								});

								append($$anchor, div_8);
							};

							var alternate_2 = ($$anchor) => {
								var fragment_14 = comment();
								var node_23 = first_child(fragment_14);

								{
									var consequent_11 = ($$anchor) => {
										var div_9 = root_25();
										var node_24 = child(div_9);

										slot(
											node_24,
											$$props,
											'no-results',
											{
												get noResultsText() {
													return noResultsText();
												}
											},
											($$anchor) => {
												var text_7 = text();

												template_effect(() => set_text(text_7, noResultsText()));
												append($$anchor, text_7);
											}
										);

										reset(div_9);
										append($$anchor, div_9);
									};

									if_block(
										node_23,
										($$render) => {
											if (noResultsText()) $$render(consequent_11);
										},
										true
									);
								}

								append($$anchor, fragment_14);
							};

							if_block(
								node_21,
								($$render) => {
									if (create()) $$render(consequent_10); else $$render(alternate_2, false);
								},
								true
							);
						}

						append($$anchor, fragment_12);
					};

					if_block(
						node_19,
						($$render) => {
							if (get$3(loading) && loadingText()) $$render(consequent_9); else $$render(alternate_3, false);
						},
						true
					);
				}

				append($$anchor, fragment_10);
			};

			if_block(node_8, ($$render) => {
				if ((
					get$3(filteredListItems),
					untrack(() => get$3(filteredListItems) && get$3(filteredListItems).length > 0)
				)) $$render(consequent_8); else $$render(alternate_4, false);
			});
		}

		reset(div_4);
		bind_this(div_4, ($$value) => set(list, $$value), () => get$3(list));
		reset(div);

		template_effect(() => {
			classes = set_class(div, 1, `${(className() ? className() : '') ?? ''} autocomplete select is-fullwidth ${uniqueId}`, 'svelte-wl7m3y', classes, {
				'hide-arrow': hideArrow() || !items().length,
				'is-multiple': multiple(),
				'show-clear': get$3(clearable),
				'is-loading': showLoadingIndicator() && get$3(loading)
			});

			set_attribute(select, 'name', selectName());
			set_attribute(select, 'id', selectId());
			select.multiple = multiple();

			set_class(
				div_4,
				1,
				`${(dropdownClassName() ? dropdownClassName() : '') ?? ''} autocomplete-list ${get$3(showList) ? '' : 'hidden'}
    is-fullwidth`,
				'svelte-wl7m3y'
			);
		});

		bind_value(input_1, text$1);
		event('input', input_1, onInput);
		event('focus', input_1, onFocusInternal);
		event('blur', input_1, onBlurInternal);
		event('keydown', input_1, onKeyDown);
		event('click', input_1, onInputClick);
		event('keypress', input_1, onKeyPress);
		event('dragover', input_1, (event) => dragover(event, selectedItem().length - 1));
		event('drop', input_1, (event) => drop(event, selectedItem().length - 1));
		append($$anchor, div);
		bind_prop($$props, 'highlightFilter', highlightFilter);

		return pop($$exports);
	}

	var root_1$u = from_html(`<p> </p>`);
	var root_2$n = from_html(`<input/>`);

	function Ui_textfield($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "textfield"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			size = prop($$props, 'size', 3, "normal"),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'required',
				'disabled',
				'size',
				'readonly',
				'valid',
				'color',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$u();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$n();

				attribute_effect(
					input,
					() => ({
						id: `form-field-textfield-${fieldname() ?? ''}`,
						class: `input ${size() ? `is-${size()}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
						type: 'text',
						name: fieldname(),
						invalid: get$3(invalid),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_3$f = from_html(`<p> </p>`);

	function Ui_autocomplete($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * More properties at https://github.com/pstanoev/simple-svelte-autocomplete#properties
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {string} [placeholder = '']
		 * @property {string} [fieldname = 'autocomplete']
		 * @property {boolean} [disabled = false]
		 * @property {boolean} [readonly = false]
		 * @property {boolean} [required = false]
		 * @property {boolean} [valid = true]
		 * @property {function} [onchange]
		 */
		/** @type {Props} */
		let //generic input props
			value = prop($$props, 'value', 15),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "autocomplete"),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			required = prop($$props, 'required', 3, false),
			valid = prop($$props, 'valid', 3, true),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'disabled',
				'readonly',
				'required',
				'valid',
				'onchange'
			]);

		let invalid = user_derived(() => !valid());

		function onChange(val) {
			if (onchange()) {
				onchange()({ value: snapshot(val), field: fieldname() });
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				{
					let $0 = user_derived(() => value() ? value().title : "");

					Ui_textfield($$anchor, spread_props(
						{
							get value() {
								return get$3($0);
							},

							get fieldname() {
								return fieldname();
							},

							get placeholder() {
								return placeholder();
							}
						},
						() => others
					));
				}
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var p = root_3$f();
						var text = child(p, true);

						reset(p);
						template_effect(() => set_text(text, value() ? value()?.title ?? "" : ""));
						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						SimpleAutocomplete($$anchor, spread_props(
							{
								onChange,

								get placeholder() {
									return $LOCALE()[placeholder()];
								},

								get valid() {
									return valid();
								},

								get invalid() {
									return get$3(invalid);
								},

								get required() {
									return required();
								}
							},
							() => others,
							{
								get selectedItem() {
									return value();
								},

								set selectedItem($$value) {
									value($$value);
								}
							}
						));
					};

					if_block(
						node_1,
						($$render) => {
							if (readonly()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (disabled()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$I = from_html(`<input/>`);

	function Ui_color($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "color"),
			disabled = prop($$props, 'disabled', 3, false),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'size',
				'color',
				'disabled',
				'required',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var input = root$I();

		attribute_effect(
			input,
			() => ({
				id: `form-field-color-${fieldname() ?? ''}`,
				class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
				type: 'color',
				name: fieldname(),
				invalid: get$3(invalid),
				required: required(),
				readonly: readonly(),
				disabled: disabled(),
				placeholder: $LOCALE()[placeholder()],
				autocomplete: fieldname(),
				'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
				'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
				...optionalProps,
				...others
			}),
			void 0,
			void 0,
			void 0,
			void 0,
			true
		);

		bind_value(input, value);
		append($$anchor, input);
		pop();
		$$cleanup();
	}

	var root$H = from_html(`<label><!></label>`);

	function Ui_label($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} for
		 * @property {string} [label='label']
		 * @property {string} [class = '']
		 */
		/** @type {Props} */
		let label = prop($$props, 'label', 3, "label"),
			labelClass = prop($$props, 'class', 3, "");

		var label_1 = root$H();
		var node = child(label_1);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var text$1 = text();

				template_effect(() => set_text(text$1, label() ? $LOCALE()[label()] : ""));
				append($$anchor, text$1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(label_1);

		template_effect(() => {
			set_class(label_1, 1, `label ${labelClass() ?? ''}`);
			set_attribute(label_1, 'for', $$props.for);
		});

		append($$anchor, label_1);
		pop();
		$$cleanup();
	}

	var root_3$e = from_html(`<input/> `, 1);

	function Ui_checkbox($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @component
		 * checkbox with true or false values
		 **/
		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, false),
			label = prop($$props, 'label', 3, "checkbox"),
			fieldname = prop($$props, 'fieldname', 3, "checkbox"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			labelClass = prop($$props, 'labelClass', 3, "checkbox"),
			reactOn = prop($$props, 'reactOn', 19, () => ["onchange", "oninput"]),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'label',
				'fieldname',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class',
				'labelClass',
				'reactOn'
			]);

		let invalid = user_derived(() => !valid());
		const id = `form-field-checkbox-${fieldname()}`;
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange, undefined, { id: $$props?.id });

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		Ui_label($$anchor, {
			get class() {
				return labelClass();
			},

			get disabled() {
				return disabled();
			},

			get for() {
				return id;
			},

			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_boolean($$anchor, {
							get LC_TRUE() {
								return label();
							},

							get LC_FALSE() {
								return label();
							},

							get value() {
								return value();
							}
						});
					};

					var alternate = ($$anchor) => {
						var fragment_3 = root_3$e();
						var input = first_child(fragment_3);

						attribute_effect(
							input,
							() => ({
								id,
								class: classes(),
								type: 'checkbox',
								name: fieldname(),
								required: required(),
								readonly: readonly(),
								invalid: get$3(invalid),
								disabled: disabled(),
								'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
								'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
								...optionalProps,
								...others
							}),
							void 0,
							void 0,
							void 0,
							void 0,
							true
						);

						var text = sibling(input);

						template_effect(() => set_text(text, ` ${$LOCALE()[label()] ?? ''}`));
						bind_checked(input, value);
						append($$anchor, fragment_3);
					};

					if_block(node, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	function Ui_checkbox_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 27, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "checkbox-list"),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'fieldname'
			]);

		function onchange(data, ev, additional) {
			if (!additional) {
				return;
			}

			if (data.value) {
				if (!value().includes(additional.id)) {
					value().push(additional.id);
				}
			} else {
				if (value().includes(additional.id)) {
					value().splice(value().indexOf(additional.id), 1);
				}
			}

			$$props?.onchange({ field: fieldname(), value: snapshot(value()) }, ev, additional);
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, variants, (item) => item.id, ($$anchor, item) => {
			{
				let $0 = user_derived(() => `${fieldname()}-${get$3(item).id}`);
				let $1 = user_derived(() => value().includes(get$3(item).id));

				Ui_checkbox($$anchor, spread_props(() => others, () => get$3(item), {
					get fieldname() {
						return get$3($0);
					},

					get value() {
						return get$3($1);
					},

					onchange
				}));
			}
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$t = from_html(`<p><time> </time></p>`);
	var root_2$m = from_html(`<input/>`);

	function Ui_date($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy(new Date())),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "datetime"),
			pattern = prop($$props, 'pattern', 3, "d{4}-d{2}-d{2}"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'pattern',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		onMount(() => {
			if (value() instanceof Date) {
				value(value().toISOString().split("T")[0]);
			} else if (value().indexOf("T") > 0) {
				value(value().split("T")[0]);
			}
		});

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$t();
				var time = child(p);
				var text = child(time, true);

				reset(time);
				reset(p);

				template_effect(
					($0) => {
						set_attribute(time, 'datetime', value());
						set_text(text, $0);
					},
					[() => UICommon$1.tryFormatLocaleDateTime(value())]
				);

				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$m();

				attribute_effect(
					input,
					() => ({
						id: `form-field-date-${fieldname() ?? ''}`,
						class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
						type: 'date',
						name: fieldname(),
						invalid: get$3(invalid),
						required: required(),
						readonly: readonly(),
						disabled: disabled(),
						placeholder: $LOCALE()[placeholder()],
						pattern: pattern(),
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$l = from_html(`<p> </p>`);
	var root_3$d = from_html(`<input/>`);

	function Ui_datetime_in_tz($$anchor, $$props) {
		push($$props, true);

		function removeMsFromDate(isoDate, markAsZULU = false) {
			return isoDate.split(".")[0] + (markAsZULU ? "" : "Z");
		}

		function removeSecFromDate(isoDate, markAsZULU = false) {
			return isoDate.slice(0, isoDate.lastIndexOf(":")) + (markAsZULU ? "" : "Z");
		}

		function shiftDatetime(isoDate, shift) {
			try {
				const dateUtc = new Date(markAsZULU(isoDate)).getTime();
				const offset = shift * -60000;

				if (dateIsValid(dateUtc + offset)) {
					const newDate = new Date(dateUtc + offset);
					const newIsoDate = newDate.toISOString();

					return removeSecFromDate(removeMsFromDate(newIsoDate, true), true);
				}
			} catch {
				return;
			}
		}

		function markAsZULU(dateString) {
			return dateString && dateString.at(-1) !== "Z" ? dateString + "Z" : dateString;
		}

		function humanReadable(isoDate) {
			return UICommon$1.tryFormatLocaleDateTime(isoDate);
		}

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, 'fieldname', 3, "datetimeInTZ"),
			value = prop($$props, 'value', 31, () => proxy(removeSecFromDate(removeMsFromDate(new Date().toISOString())))),
			timezoneOffset = prop($$props, 'timezoneOffset', 3, 0);
			prop($$props, 'human', 3, true);
			let required = prop($$props, 'required', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'fieldname',
				'value',
				'timezoneOffset',
				'human',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class',
				'onchange'
			]);

		let shiftedValue = state(void 0),
			prevShiftedValue;

		const setShifted = (val) => {
			if (dateIsValid(val)) {
				prevShiftedValue = get$3(shiftedValue);
				set(shiftedValue, val, true);
			}
		};

		const resetShiftedValue = () => {
			set(shiftedValue, prevShiftedValue, true);
		};

		onMount(() => {
			setShifted(shiftDatetime(value(), timezoneOffset()));
		});

		const dateIsValid = (date) => {
			try {
				new Date(date);

				return true;
			} catch {
				return false;
			}
		};

		const changed = () => value() !== shiftDatetime(get$3(shiftedValue), -timezoneOffset());

		const dispatchChange = () => {
			setShifted(get$3(shiftedValue));
			value(markAsZULU(shiftDatetime(get$3(shiftedValue), -timezoneOffset())));
			onchange()({ field: fieldname(), value: snapshot(value()) });
		};

		function onChange(ev) {
			if (ev.currentTarget.value && get$3(shiftedValue) && dateIsValid(get$3(shiftedValue))) {
				if (changed()) {
					dispatchChange();
				}

				return true;
			} else {
				resetShiftedValue();
			}

			return false;
		}

		let invalid = user_derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var p = root_2$l();
						var text = child(p, true);

						reset(p);
						template_effect(($0) => set_text(text, $0), [() => humanReadable(get$3(shiftedValue))]);
						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						var input = root_3$d();

						attribute_effect(
							input,
							() => ({
								id: `form-field-datetime-in-timezone-${fieldname() ?? ''}`,
								class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
								type: 'datetime-local',
								name: fieldname(),
								invalid: get$3(invalid),
								disabled: disabled(),
								required: required(),
								readonly: readonly(),
								autocomplete: fieldname(),
								onchange: onChange,
								onblur: onChange,
								oninput: onChange,
								'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
								'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
								...others
							}),
							void 0,
							void 0,
							void 0,
							void 0,
							true
						);

						bind_value(input, () => get$3(shiftedValue), ($$value) => set(shiftedValue, $$value));
						append($$anchor, input);
					};

					if_block(node_1, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$3(shiftedValue)) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$s = from_html(`<p> </p>`);
	var root_2$k = from_html(`<input/>`);

	function Ui_email($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "email"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$s();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$k();

				attribute_effect(
					input,
					() => ({
						id: `form-field-email-${fieldname() ?? ''}`,
						class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
						type: 'email',
						name: fieldname(),
						invalid: get$3(invalid),
						required: required(),
						readonly: readonly(),
						disabled: disabled(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$G = from_html(`<input type="hidden"/>`);

	function Ui_hidden($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			fieldname = prop($$props, 'fieldname', 3, "hidden"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'fieldname',
				'required',
				'readonly'
			]);

		var input = root$G();

		remove_input_defaults(input);

		template_effect(() => {
			set_attribute(input, 'id', `form-field-hidden-${fieldname() ?? ''}`);
			input.required = required();
			input.readOnly = readonly();
			set_attribute(input, 'name', fieldname());
			set_attribute(input, 'others', others);
		});

		bind_value(input, value);
		append($$anchor, input);
		pop();
	}

	var root_1$r = from_html(`<p> </p>`);
	var root_2$j = from_html(`<textarea></textarea>`);

	function Ui_textarea($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "textarea"),
			rows = prop($$props, 'rows', 3, 10),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'rows',
				'size',
				'color',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$r();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var textarea = root_2$j();

				remove_textarea_child(textarea);

				attribute_effect(textarea, () => ({
					id: `form-field-textarea-${fieldname() ?? ''}`,
					class: `textarea ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					placeholder: $LOCALE()[placeholder()],
					rows: rows(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(textarea, value);
				append($$anchor, textarea);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_json_area($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy({})),
			fieldname = prop($$props, 'fieldname', 3, "jsonarea"),
			valid = prop($$props, 'valid', 15, true),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => {}),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur"]),
			colorValid = prop($$props, 'colorValid', 3, "success"),
			colorInvalid = prop($$props, 'colorInvalid', 3, "danger"),
			validationDelay = prop($$props, 'validationDelay', 3, 1000),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'fieldname',
				'valid',
				'onchange',
				'onerror',
				'reactOn',
				'colorValid',
				'colorInvalid',
				'validationDelay'
			]);

		let _value = state("{}");

		onMount(() => {
			try {
				set(_value, JSON.stringify(snapshot(value()), null, 4), true);
			} catch {
				set(_value, "{}");
			}
		});

		let delayedValidation;

		function onChange(val) {
			try {
				value(JSON.parse(val));
				valid(true);
				onchange()({ field: fieldname(), value: snapshot(value()) });
			} catch(error) {
				valid(false);
				onerror()(error);
			}

			return true;
		}

		function delayedOnChange(data) {
			const { value: val } = data;

			if (delayedValidation) {
				clearTimeout(delayedValidation);
			}

			delayedValidation = setTimeout(
				() => {
					onChange(val);
				},
				validationDelay()
			);
		}

		let color = user_derived(() => valid() ? colorValid() : colorInvalid());

		Ui_textarea($$anchor, spread_props(
			{
				get fieldname() {
					return fieldname();
				},

				onchange: delayedOnChange,

				get reactOn() {
					return reactOn();
				},

				get valid() {
					return valid();
				},

				get color() {
					return get$3(color);
				}
			},
			() => others,
			{
				get value() {
					return get$3(_value);
				},

				set value($$value) {
					set(_value, $$value, true);
				}
			}
		));

		pop();
	}

	var _lib = /*#__PURE__*/new WeakMap();
	let Lib = /*#__PURE__*/function () {
	  function Lib(seedLib) {
	    _classCallCheck(this, Lib);
	    _classPrivateFieldInitSpec(this, _lib, {});
	    if (seedLib instanceof Lib) {
	      this.import(seedLib.getContent());
	    }
	  }

	  /**
	   *
	   * @params {string}  mode what to do if element exists [replace|add|skip]
	   */
	  return _createClass(Lib, [{
	    key: "add",
	    value: function add(name, comp, mode = "replace") {
	      if (this.contains(name)) {
	        if (mode === "replace") {
	          _classPrivateFieldGet2(_lib, this)[name] = comp;
	        } else if (mode === "add") {
	          _classPrivateFieldGet2(_lib, this)[name] = Object.assign(_classPrivateFieldGet2(_lib, this)[name], comp);
	        }
	      } else {
	        _classPrivateFieldGet2(_lib, this)[name] = comp;
	      }
	    }
	  }, {
	    key: "get",
	    value: function get(name) {
	      return _classPrivateFieldGet2(_lib, this)[name];
	    }
	  }, {
	    key: "contains",
	    value: function contains(name) {
	      return Object.hasOwn(_classPrivateFieldGet2(_lib, this), name);
	    }
	  }, {
	    key: "import",
	    value: function _import(bulk, mode = "replace") {
	      for (let f in bulk) {
	        this.add(f, bulk[f], mode);
	      }
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return Object.keys(_classPrivateFieldGet2(_lib, this)).length === 0;
	    }
	  }, {
	    key: "getContent",
	    value: function getContent() {
	      return {
	        ..._classPrivateFieldGet2(_lib, this)
	      };
	    }
	  }]);
	}();

	/*
	 * Библиотека UI конструкторов
	 */

	const COMPONENTS$1 = new Lib();
	const FIELDS$1 = new Lib();
	const VARIANTS$1 = new Lib();

	var root$F = from_html(`<!> <!>`, 1);

	function Ui_title($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/* eslint svelte/no-at-html-tags: 0 */
		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = `title-${Math.random()}`]
		 * @property {string}   [title = '']
		 * @property {string}   [subtitle]
		 * @property {number}   [size = 1]
		 * @property {number}   [subsize]
		 * @property {boolean}  [spaced = false]
		 * @property {string}   [align = 'left']
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 19, () => `title-${Math.random()}`),
			title = prop($$props, 'title', 3, ""),
			size = prop($$props, 'size', 3, 1),
			spaced = prop($$props, 'spaced', 3, false),
			align = prop($$props, 'align', 3, "left");

		const scrollToTop = (options = UICommon$1.SCROLL_OPTIONS) => {
			setTimeout(
				() => {
					document.getElementById(id()).scrollIntoView(options);
				},
				100
			);
		};

		let size2 = user_derived(() => $$props.subsize
			? $$props.subsize
			: parseInt(size()) < 6 ? parseInt(size()) + 1 : size());

		let spacedStyle = user_derived(() => spaced() ? "has-text-justified" : "");
		let resultTitle = user_derived(() => `<h${size()} id="${id()}" style="text-align: ${align()};" class="title ${get$3(spacedStyle)} is-${size()}">${$LOCALE()[title()]}</h${size()}>`);
		let resultSubtitle = user_derived(() => `<h${get$3(size2)} id="${id()}" style="text-align: ${align()};" class="subtitle is-${get$3(size2)}">${$LOCALE()[$$props.subtitle]}</h${get$3(size2)}>`);
		var $$exports = { scrollToTop };
		var fragment = root$F();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				html(node_1, () => get$3(resultTitle));
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_3 = first_child(fragment_2);

				html(node_3, () => get$3(resultSubtitle));
				append($$anchor, fragment_2);
			};

			if_block(node_2, ($$render) => {
				if ($$props.subtitle) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	function Ui_list_empty_placeholder($$anchor, $$props) {
		/**
		 * @typedef {object}    Props
		 * @property {string}   [title = "not-node:empty_list_placeholder"]
		 * @property {number}   [size = 4]
		 * @property {string}   [align = 'center']
		 */
		/**
		 * @type Props
		 */
		let title = prop($$props, 'title', 3, "not-node:empty_list_placeholder"),
			size = prop($$props, 'size', 3, 4),
			align = prop($$props, 'align', 3, "center"),
			others = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'title', 'size', 'align']);

		Ui_title($$anchor, spread_props(
			{
				get title() {
					return title();
				},

				get size() {
					return size();
				},

				get align() {
					return align();
				}
			},
			() => others
		));
	}

	var root_1$q = from_html(`<span class="icon"><i></i></span>`);
	var root_4$c = from_html(`<span> </span>`);
	var root_2$i = from_html(`<!> <!> <!> <!>`, 1);
	var root_6$9 = from_html(` <!>`, 1);
	var root$E = from_html(`<a><!></a>`);

	function Ui_link($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		const sideIcon = ($$anchor) => {
			var span = root_1$q();
			var i = child(span);

			reset(span);
			template_effect(() => set_class(i, 1, `fas fa-${$$props.icon ?? ''} ${size() ? `is-${size()}` : ''}`));
			append($$anchor, span);
		};

		let title = prop($$props, 'title', 3, ""),
			url = prop($$props, 'url', 3, ""),
			href = prop($$props, 'href', 3, ""),
			target = prop($$props, 'target', 3, "_blank"),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			button = prop($$props, 'button', 3, true),
			activeState = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			iconSide = prop($$props, 'iconSide', 3, "right");

		var a = root$E();

		a.__click = function (...$$args) {
			($$props.action || $$props.onclick)?.apply(this, $$args);
		};

		let classes_1;
		var node = child(a);

		{
			var consequent_3 = ($$anchor) => {
				var fragment = root_2$i();
				var node_1 = first_child(fragment);

				{
					var consequent = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_1, ($$render) => {
						if (iconSide() === "left") $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						var span_1 = root_4$c();
						var text = child(span_1, true);

						reset(span_1);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span_1);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_1);
					});
				}

				var node_3 = sibling(node_2, 2);

				snippet(node_3, () => $$props.children ?? noop);

				var node_4 = sibling(node_3, 2);

				{
					var consequent_2 = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_4, ($$render) => {
						if (iconSide() === "right") $$render(consequent_2);
					});
				}

				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = root_6$9();
				var text_1 = first_child(fragment_3, true);
				var node_5 = sibling(text_1);

				snippet(node_5, () => $$props.children ?? noop);
				template_effect(() => set_text(text_1, $LOCALE()[title()]));
				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if ($$props.icon) $$render(consequent_3); else $$render(alternate, false);
			});
		}

		reset(a);

		template_effect(() => {
			set_attribute(a, 'href', url() || href());
			set_attribute(a, 'target', target());
			set_attribute(a, 'download', $$props.download);
			set_attribute(a, 'rel', $$props.rel);

			classes_1 = set_class(a, 1, `${classes() ?? ''} ${activeState() ? `is-${activeState()}` : ''} ${color() ? `is-${color()}` : ''} ${type() ? `is-${type()}` : ''} ${size() ? `is-${size()}` : ''}`, null, classes_1, {
				button: button(),
				'is-light': light(),
				'is-inverted': inverted(),
				'is-outlined': outlined(),
				'is-raised': raised(),
				'is-rounded': rounded(),
				'is-loading': loading()
			});
		});

		append($$anchor, a);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root_3$c = from_html(`<div><p class="control"><!></p></div>`);
	var root_4$b = from_html(`<div><!></div>`);

	function Ui_links($$anchor, $$props) {
		const listLinks = ($$anchor) => {
			var fragment = comment();
			var node = first_child(fragment);

			each(node, 17, values, (item) => item.id, ($$anchor, item) => {
				Ui_link($$anchor, spread_props(() => get$3(item), itemsProps));
			});

			append($$anchor, fragment);
		};

		let values = prop($$props, 'values', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			joined = prop($$props, 'joined', 3, true),
			itemsProps = prop($$props, 'itemsProps', 19, () => ({}));

		var fragment_2 = comment();
		var node_1 = first_child(fragment_2);

		{
			var consequent = ($$anchor) => {
				var div = root_3$c();
				let classes_1;
				var p = child(div);
				var node_2 = child(p);

				listLinks(node_2);
				reset(p);
				reset(div);
				template_effect(() => classes_1 = set_class(div, 1, `field has-addons ${classes() ?? ''}`, null, classes_1, { 'is-centered': centered(), 'is-right': right() }));
				append($$anchor, div);
			};

			var alternate = ($$anchor) => {
				var div_1 = root_4$b();
				let classes_2;
				var node_3 = child(div_1);

				listLinks(node_3);
				reset(div_1);
				template_effect(() => classes_2 = set_class(div_1, 1, `buttons ${classes() ?? ''}`, null, classes_2, { 'is-centered': centered(), 'is-right': right() }));
				append($$anchor, div_1);
			};

			if_block(node_1, ($$render) => {
				if (joined()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment_2);
	}

	var root_1$p = from_html(`<!> <!>`, 1);
	var root_19$1 = from_html(`<figure class="image is-64x64"><img class="is-rounded"/></figure>`);
	var root_24$1 = from_html(`<div class="list-item-controls"><!> <!></div>`);
	var root$D = from_html(`<div><!> <!> <!></div>`);

	function Ui_list_item($$anchor, $$props) {
		push($$props, true);

		const itemContent = ($$anchor) => {
			var fragment = root_1$p();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					snippet(node_1, () => $$props.titleRenderer, () => paramsSet);
					append($$anchor, fragment_1);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent_2 = ($$anchor) => {
							{
								let $0 = user_derived(() => callbackTemplate($$props.onclickTitle));

								Ui_clickable_div($$anchor, {
									class: 'list-item-title',

									get callback() {
										return get$3($0);
									},

									children: ($$anchor, $$slotProps) => {
										var fragment_4 = comment();
										var node_3 = first_child(fragment_4);

										{
											var consequent_1 = ($$anchor) => {
												var fragment_5 = comment();
												var node_4 = first_child(fragment_5);

												component(node_4, UITitleComponent, ($$anchor, UITitleComponent_1) => {
													UITitleComponent_1($$anchor, spread_props(() => get$3(titleProps), titleComponentProps, { onchange }));
												});

												append($$anchor, fragment_5);
											};

											var alternate = ($$anchor) => {
												var text$1 = text();

												template_effect(() => set_text(text$1, $$props.title));
												append($$anchor, text$1);
											};

											if_block(node_3, ($$render) => {
												if (UITitleComponent()) $$render(consequent_1); else $$render(alternate, false);
											});
										}

										append($$anchor, fragment_4);
									},

									$$slots: { default: true }
								});
							}
						};

						if_block(
							node_2,
							($$render) => {
								if ($$props.title) $$render(consequent_2);
							},
							true
						);
					}

					append($$anchor, fragment_2);
				};

				if_block(node, ($$render) => {
					if ($$props.titleRenderer) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			var node_5 = sibling(node, 2);

			{
				var consequent_3 = ($$anchor) => {
					var fragment_7 = comment();
					var node_6 = first_child(fragment_7);

					snippet(node_6, () => $$props.descriptionRenderer, () => paramsSet);
					append($$anchor, fragment_7);
				};

				var alternate_3 = ($$anchor) => {
					var fragment_8 = comment();
					var node_7 = first_child(fragment_8);

					{
						var consequent_5 = ($$anchor) => {
							{
								let $0 = user_derived(() => callbackTemplate($$props.onclickDescription));

								Ui_clickable_div($$anchor, {
									class: 'list-item-description',

									get callback() {
										return get$3($0);
									},

									children: ($$anchor, $$slotProps) => {
										var fragment_10 = comment();
										var node_8 = first_child(fragment_10);

										{
											var consequent_4 = ($$anchor) => {
												var fragment_11 = comment();
												var node_9 = first_child(fragment_11);

												component(node_9, () => $$props.descriptionComponent, ($$anchor, UIDescriptionComponent_1) => {
													UIDescriptionComponent_1($$anchor, spread_props(() => get$3(descriptionProps), descriptionComponentProps, {
														onchange,

														get onclick() {
															return $$props.onclick;
														}
													}));
												});

												append($$anchor, fragment_11);
											};

											var alternate_2 = ($$anchor) => {
												var text_1 = text();

												template_effect(() => set_text(text_1, $$props.description));
												append($$anchor, text_1);
											};

											if_block(node_8, ($$render) => {
												if ($$props.descriptionComponent) $$render(consequent_4); else $$render(alternate_2, false);
											});
										}

										append($$anchor, fragment_10);
									},

									$$slots: { default: true }
								});
							}
						};

						if_block(
							node_7,
							($$render) => {
								if ($$props.description) $$render(consequent_5);
							},
							true
						);
					}

					append($$anchor, fragment_8);
				};

				if_block(node_5, ($$render) => {
					if ($$props.descriptionRenderer) $$render(consequent_3); else $$render(alternate_3, false);
				});
			}

			append($$anchor, fragment);
		};

		let actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			listActions = prop($$props, 'listActions', 19, () => []),
			listLinks = prop($$props, 'listLinks', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			commonClass = prop($$props, 'commonClass', 3, ""),
			image = prop($$props, 'image', 3, ""),
			index = prop($$props, 'index', 19, () => -1),
			first = prop($$props, 'first', 3, false),
			last = prop($$props, 'last', 3, false),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			UITitleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({}));
			prop($$props, 'imageComponentProps', 19, () => ({}));

		function onClick() {
			$$props.onclick && $$props.onclick($$props.value);
		}

		let allActions = state(proxy([]));
		let allLinks = state(proxy([]));

		const callbackTemplate = (callback) => {
			return () => {
				if (callback) {
					onClick();
					callback && callback($$props.value);
				}
			};
		};

		user_effect(() => {
			set(
				allActions,
				[...actions(), ...listActions()].map((btn, index) => {
					return {
						...btn,
						id: index,
						action: btn.action ? () => btn.action($$props.value) : undefined
					};
				}),
				true
			);

			set(
				allLinks,
				[...links(), ...listLinks()].map((link, index) => {
					link.id = index;

					return link;
				}),
				true
			);
		});

		const paramsSet = {
			title: $$props.title,
			description: $$props.description,
			image: image(),
			value: $$props.value,
			index: index()
		};

		const clickableItemElementAttributes = {
			role: "button",
			tabindex: "0",
			onclick: onClick,

			onkeyup: (e) => {
				if (e && e.key == "Enter") {
					onClick();
				}
			}
		};

		const additionalElementAttributes = $$props.onclick ? clickableItemElementAttributes : {};
		let imageProps = state(proxy({}));
		let titleProps = state(proxy({}));
		let descriptionProps = state(proxy({}));

		user_effect(() => {
			if (typeof image() === "object") {
				set(imageProps, { ...image() }, true);
			} else {
				set(imageProps, { image: image() }, true);
			}
		});

		user_effect(() => {
			if (typeof $$props.title === "object") {
				set(titleProps, { ...$$props.title }, true);
			} else {
				set(titleProps, { title: $$props.title }, true);
			}
		});

		user_effect(() => {
			if (typeof $$props.description === "object") {
				set(descriptionProps, { ...$$props.description }, true);
			} else {
				set(descriptionProps, { description: $$props.description }, true);
			}
		});

		var div = root$D();

		attribute_effect(div, () => ({
			...additionalElementAttributes,
			class: `list-item ${classes() ?? ''} ${commonClass() ?? ''} ${`list-item-at-${index()}`}`,

			[CLASS]: {
				'is-clickable': $$props.onclick,
				'list-item-last': last(),
				'list-item-first': first(),
				'list-item-odd': index() % 2 === 1,
				'list-item-even': index() % 2 === 0
			}
		}));

		var node_10 = child(div);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_13 = comment();
				var node_11 = first_child(fragment_13);

				{
					var consequent_6 = ($$anchor) => {
						var fragment_14 = comment();
						var node_12 = first_child(fragment_14);

						snippet(node_12, () => $$props.imageRenderer, () => paramsSet);
						append($$anchor, fragment_14);
					};

					var alternate_5 = ($$anchor) => {
						{
							let $0 = user_derived(() => callbackTemplate($$props.onclickImage));

							Ui_clickable_div($$anchor, {
								class: 'list-item-image',

								get callback() {
									return get$3($0);
								},

								children: ($$anchor, $$slotProps) => {
									var fragment_16 = comment();
									var node_13 = first_child(fragment_16);

									{
										var consequent_7 = ($$anchor) => {
											var fragment_17 = comment();
											var node_14 = first_child(fragment_17);

											component(node_14, () => $$props.imageComponent, ($$anchor, UIImageComponent_1) => {
												UIImageComponent_1($$anchor, spread_props(() => get$3(imageProps)));
											});

											append($$anchor, fragment_17);
										};

										var alternate_4 = ($$anchor) => {
											var figure = root_19$1();
											var img = child(figure);

											reset(figure);

											template_effect(() => {
												set_attribute(img, 'src', image());
												set_attribute(img, 'alt', $$props.title ? $$props.title?.title || $$props.title : image());
											});

											append($$anchor, figure);
										};

										if_block(node_13, ($$render) => {
											if ($$props.imageComponent) $$render(consequent_7); else $$render(alternate_4, false);
										});
									}

									append($$anchor, fragment_16);
								},

								$$slots: { default: true }
							});
						}
					};

					if_block(node_11, ($$render) => {
						if ($$props.imageRenderer) $$render(consequent_6); else $$render(alternate_5, false);
					});
				}

				append($$anchor, fragment_13);
			};

			if_block(node_10, ($$render) => {
				if (image()) $$render(consequent_8);
			});
		}

		var node_15 = sibling(node_10, 2);

		{
			var consequent_9 = ($$anchor) => {
				var fragment_18 = comment();
				var node_16 = first_child(fragment_18);

				component(node_16, () => $$props.listItemContentComponent, ($$anchor, UIListItemContentComponent_1) => {
					UIListItemContentComponent_1($$anchor, spread_props(listItemContentComponentProps, {
						children: ($$anchor, $$slotProps) => {
							itemContent($$anchor);
						},

						$$slots: { default: true }
					}));
				});

				append($$anchor, fragment_18);
			};

			var alternate_6 = ($$anchor) => {
				{
					let $0 = user_derived(() => callbackTemplate($$props.onclickContent));

					Ui_clickable_div($$anchor, {
						class: 'list-item-content',

						get callback() {
							return get$3($0);
						},

						children: ($$anchor, $$slotProps) => {
							itemContent($$anchor);
						},

						$$slots: { default: true }
					});
				}
			};

			if_block(node_15, ($$render) => {
				if ($$props.listItemContentComponent) $$render(consequent_9); else $$render(alternate_6, false);
			});
		}

		var node_17 = sibling(node_15, 2);

		{
			var consequent_12 = ($$anchor) => {
				var div_1 = root_24$1();
				var node_18 = child(div_1);

				{
					var consequent_10 = ($$anchor) => {
						Ui_buttons($$anchor, {
							get values() {
								return get$3(allActions);
							},

							right: true
						});
					};

					if_block(node_18, ($$render) => {
						if (get$3(allActions) && get$3(allActions).length) $$render(consequent_10);
					});
				}

				var node_19 = sibling(node_18, 2);

				{
					var consequent_11 = ($$anchor) => {
						Ui_links($$anchor, {
							get values() {
								return get$3(allLinks);
							},

							right: true
						});
					};

					if_block(node_19, ($$render) => {
						if (get$3(allLinks) && get$3(allLinks).length) $$render(consequent_11);
					});
				}

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_17, ($$render) => {
				if (get$3(allActions) && get$3(allActions).length || get$3(allLinks) && get$3(allLinks).length) $$render(consequent_12);
			});
		}

		reset(div);
		append($$anchor, div);
		pop();
	}

	function Ui_list_block($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [idFieldName = "id"]
		 * @property {array}    [items = []]
		 * @property {array}    [actions = []]
		 * @property {array}    [links = []]
		 * @property {string}   [itemClass = ""]
		 * @property {object}   [listItemContentComponent]
		 * @property {object}   [listItemContentComponentProps = {}]
		 * @property {function} [listItemRenderer]
		 * @property {function} [listItemComponent = UIListItem]
		 * @property {object}   [listItemComponentProps = {}]
		 * @property {function} [titleRenderer]
		 * @property {function} [titleComponent = UITitle]
		 * @property {object}   [titleComponentProps = { size: 6 }]
		 * @property {function} [descriptionRenderer]
		 * @property {function} [descriptionComponent]
		 * @property {object}   [descriptionComponentProps = {}]
		 * @property {function} [imageRenderer]
		 * @property {function} imageComponent
		 * @property {object}   [imageComponentProps = {}]
		 * @property {function} [onclick]
		 * @property {function} [onclickContent]
		 * @property {function} [onclickDescription]
		 * @property {function} [onclickImage]
		 * @property {function} [onclickTitle]
		 */
		/** @type {Props} */
		let idFieldName = prop($$props, 'idFieldName', 3, "id"),
			items = prop($$props, 'items', 19, () => []),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			itemClass = prop($$props, 'itemClass', 3, ""),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			UIListItemComponent = prop($$props, 'listItemComponent', 3, Ui_list_item),
			listItemComponentProps = prop($$props, 'listItemComponentProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 19, items, (item) => item[idFieldName()], ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent = ($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							snippet(node_3, () => $$props.listItemRenderer, () => get$3(item), () => get$3(index));
							append($$anchor, fragment_3);
						};

						var alternate = ($$anchor) => {
							var fragment_4 = comment();
							var node_4 = first_child(fragment_4);

							{
								let $0 = user_derived(() => get$3(index) === 0);
								let $1 = user_derived(() => get$3(index) === items().length - 1);

								component(node_4, UIListItemComponent, ($$anchor, UIListItemComponent_1) => {
									UIListItemComponent_1($$anchor, spread_props(
										listItemComponentProps,
										{
											get listItemContentComponent() {
												return $$props.listItemContentComponent;
											},

											get listItemContentComponentProps() {
												return listItemContentComponentProps();
											},

											get titleRenderer() {
												return $$props.titleRenderer;
											},

											get titleComponent() {
												return titleComponent();
											},

											get titleComponentProps() {
												return titleComponentProps();
											},

											get descriptionRenderer() {
												return $$props.descriptionRenderer;
											},

											get descriptionComponent() {
												return $$props.descriptionComponent;
											},

											get descriptionComponentProps() {
												return descriptionComponentProps();
											},

											get imageRenderer() {
												return $$props.imageRenderer;
											},

											get imageComponent() {
												return $$props.imageComponent;
											},

											get imageComponentProps() {
												return imageComponentProps();
											}
										},
										() => items()[get$3(index)],
										{
											get listActions() {
												return actions();
											},

											get listLinks() {
												return links();
											},

											get value() {
												return items()[get$3(index)].value;
											},

											get commonClass() {
												return itemClass();
											},

											get index() {
												return get$3(index);
											},

											get first() {
												return get$3($0);
											},

											get last() {
												return get$3($1);
											},

											get onclick() {
												return $$props.onclick;
											},

											get onclickContent() {
												return $$props.onclickContent;
											},

											get onclickDescription() {
												return $$props.onclickDescription;
											},

											get onclickImage() {
												return $$props.onclickImage;
											},

											get onclickTitle() {
												return $$props.onclickTitle;
											}
										}
									));
								});
							}

							append($$anchor, fragment_4);
						};

						if_block(node_2, ($$render) => {
							if ($$props.listItemRenderer) $$render(consequent); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$o = from_html(`<div><!></div>`);

	function Ui_list($$anchor, $$props) {
		push($$props, true);

		//customization
		/**
		 * @typedef {Object} Props
		 * @property {string} [class = ""]
		 * @property {array} [items = []]
		 * @property {array} [actions = []]
		 * @property {array} [links = []]
		 * @property {boolean} [actionsVisible = false]
		 * @property {boolean} [itemsHoverable = false]
		 * @property {boolean} [overflowEllipsis = false]
		 * @property {boolean} [hiddenImages = false]
		 * @property {string} [itemClass = '']
		 * @property {number} itemLength
		 * @property {string} [idFieldName = 'id']
		 * @property {function} [emptyListPlaceholderComponent = UIListEmptyPlaceholder] - empty
		 * @property {object} [emptyListPlaceholderComponentProps = {}]
		 * @property {function} [listItemComponent = UIListItem] - item
		 * @property {object} [listItemComponentProps = {}]
		 * @property {function} [titleComponent = UITitle] - item parts
		 * @property {object} [titleComponentProps = {size: 6}]
		 * @property {function} [descriptionComponent]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [imageComponent]
		 * @property {object} [imageComponentProps = {}]
		 * @property {function} [onchange]                  callback
		 * @property {function} [onclick]                   callback
		 * @property {function} [onclickContent]            callback
		 * @property {function} [onclickDescription]        callback
		 * @property {function} [onclickImage]              callback
		 * @property {function} [onclickTitle]              callback
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			actionsVisible = prop($$props, 'actionsVisible', 3, false),
			itemsHoverable = prop($$props, 'itemsHoverable', 3, false),
			overflowEllipsis = prop($$props, 'overflowEllipsis', 3, false),
			hiddenImages = prop($$props, 'hiddenImages', 3, false),
			itemClass = prop($$props, 'itemClass', 3, ""),
			idFieldName = prop($$props, 'idFieldName', 3, "id"),
			UIEmptyListPlaceholderComponent = prop($$props, 'emptyListPlaceholderComponent', 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, 'emptyListPlaceholderComponentProps', 19, () => ({})),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			listItemComponent = prop($$props, 'listItemComponent', 3, Ui_list_item),
			listItemComponentProps = prop($$props, 'listItemComponentProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$o();
				let classes_1;
				var node_1 = child(div);

				Ui_list_block(node_1, {
					get items() {
						return items();
					},

					get itemClass() {
						return itemClass();
					},

					get listItemContentComponent() {
						return $$props.listItemContentComponent;
					},

					get listItemContentComponentProps() {
						return listItemContentComponentProps();
					},

					get listItemRenderer() {
						return $$props.listItemRenderer;
					},

					get listItemComponent() {
						return listItemComponent();
					},

					get listItemComponentProps() {
						return listItemComponentProps();
					},

					get idFieldName() {
						return idFieldName();
					},

					get titleRenderer() {
						return $$props.titleRenderer;
					},

					get titleComponent() {
						return titleComponent();
					},

					get titleComponentProps() {
						return titleComponentProps();
					},

					get descriptionRenderer() {
						return $$props.descriptionRenderer;
					},

					get descriptionComponent() {
						return $$props.descriptionComponent;
					},

					get descriptionComponentProps() {
						return descriptionComponentProps();
					},

					get imageRenderer() {
						return $$props.imageRenderer;
					},

					get imageComponent() {
						return $$props.imageComponent;
					},

					get imageComponentProps() {
						return imageComponentProps();
					},

					get actions() {
						return actions();
					},

					get links() {
						return links();
					},

					get onchange() {
						return $$props.onchange;
					},

					get onclick() {
						return $$props.onclick;
					},

					get onclickContent() {
						return $$props.onclickContent;
					},

					get onclickDescription() {
						return $$props.onclickDescription;
					},

					get onclickImage() {
						return $$props.onclickImage;
					},

					get onclickTitle() {
						return $$props.onclickTitle;
					}
				});

				reset(div);

				template_effect(() => {
					set_style(div, $$props.itemLength ? `--length: ${$$props.itemLength};` : "");

					classes_1 = set_class(div, 1, `list ${classes() ?? ''}`, null, classes_1, {
						'has-visible-pointer-controls': actionsVisible(),
						'has-hoverable-list-items': itemsHoverable(),
						'has-overflow-ellipsis': overflowEllipsis(),
						'has-hidden-images': hiddenImages()
					});
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_2 = comment();
						var node_3 = first_child(fragment_2);

						snippet(node_3, () => $$props.emptyListRenderer, emptyListPlaceholderComponentProps);
						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_4 = first_child(fragment_3);

						component(node_4, UIEmptyListPlaceholderComponent, ($$anchor, UIEmptyListPlaceholderComponent_1) => {
							UIEmptyListPlaceholderComponent_1($$anchor, spread_props(emptyListPlaceholderComponentProps));
						});

						append($$anchor, fragment_3);
					};

					if_block(
						node_2,
						($$render) => {
							if ($$props.emptyListRenderer) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$C = from_html(`<!> <!>`, 1);

	function Ui_list_of_models($$anchor, $$props) {
		push($$props, true);

		//field props
		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted] - svelte-ignore unused-export-let
		 * @property {any} [value]
		 * @property {string} [placeholder]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid] - validation
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 * @property {string} [modelName] - model bindings
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId] - presentation
		 * @property {string} [optionTitle]
		 * @property {string} [selectorUI] - selector UI to add new item to list
		 * @property {any} [selectorUIProps]
		 * @property {string} [itemUI] - list item UI to present in readonly or editable variants
		 * @property {any} [itemUIProps]
		 * @property {any} [transformValueItemToListItem]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 23, () => []),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "selectFromModel"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false);
			prop($$props, 'multiple', 3, false);
			prop($$props, 'size', 3, 8);
			let valid = prop($$props, 'valid', 3, true),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			selectorUI = prop($$props, 'selectorUI', 3, "UISelectFromModelOnDemandInline"),
			selectorUIProps = prop($$props, 'selectorUIProps', 19, () => ({})),
			itemUI = prop($$props, 'itemUI', 3, "UIListItem"),
			itemUIProps = prop($$props, 'itemUIProps', 19, () => ({})),
			transformValueItemToListItem = prop($$props, 'transformValueItemToListItem', 3, (item) => {
				return item
					? {
						id: item._id,
						title: item.title,
						description: item.description,
						value: item
					}
					: undefined;
			});

		let items = state(proxy([]));

		const transformValueToItems = (val) => {
			return Array.isArray(val) ? val.map(transformValueItemToListItem()) : [];
		};

		function addItem(item) {
			if (!Array.isArray(snapshot(value()))) {
				value([]);
			}

			value().push(item);
			set(items, transformValueToItems(value()), true);
		}

		const getItemIndexInValue = (listItem) => {
			return value().findIndex((valueItem) => valueItem.id === listItem.id);
		};

		const ACTIONS = [
			{
				action(listItem) {
					const itemIndex = getItemIndexInValue(listItem);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex - 1);
						value(valCopy);
						set(items, transformValueToItems(value()), true);
					}
				},

				title: "",
				icon: "arrow-up",
				color: "normal"
			},

			{
				action: (listItem) => {
					const itemIndex = getItemIndexInValue(listItem);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex + 1);
						value(valCopy);
						set(items, transformValueToItems(value()), true);
					}
				},

				title: "",
				icon: "arrow-down",
				color: "normal"
			},

			{
				action: (listItem) => {
					const itemIndex = getItemIndexInValue(listItem);

					if (itemIndex > -1) {
						value().splice(itemIndex, 1);
						set(items, transformValueToItems(value()), true);
					}
				},

				title: "",
				icon: "trash",
				color: "danger"
			}
		];

		var fragment = root$C();
		var node = first_child(fragment);

		{
			let $0 = user_derived(() => COMPONENTS$1.get(itemUI()));

			Ui_list(node, spread_props(
				{
					get listItemComponent() {
						return get$3($0);
					}
				},
				itemUIProps,
				{
					get items() {
						return get$3(items);
					},

					get actions() {
						return ACTIONS;
					}
				}
			));
		}

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				const SvelteComponent = user_derived(() => COMPONENTS$1.get(selectorUI()));
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				component(node_2, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
					SvelteComponent_1($$anchor, spread_props(selectorUIProps, {
						get modelName() {
							return modelName();
						},

						get actionName() {
							return actionName();
						},

						get actionFilter() {
							return actionFilter();
						},

						get actionSorter() {
							return actionSorter();
						},

						get actionPager() {
							return actionPager();
						},

						get actionSearch() {
							return actionSearch();
						},

						get optionId() {
							return optionId();
						},

						get optionTitle() {
							return optionTitle();
						},

						get placeholder() {
							return placeholder();
						},

						get fieldname() {
							return fieldname();
						},

						get required() {
							return required();
						},

						multiple: false,

						get valid() {
							return valid();
						},

						onresolve: (e) => addItem(e.value)
					}));
				});

				append($$anchor, fragment_1);
			};

			if_block(node_1, ($$render) => {
				if (!readonly()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$B = from_html(`<div><!></div>`);

	function Ui_column($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {boolean} [narrow=false]
		 * @property {any} size
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			narrow = prop($$props, 'narrow', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'size',
				'narrow',
				'children'
			]);

		var div = root$B();

		attribute_effect(div, () => ({
			class: `column ${classes() ?? ''} ${$$props.size ? `is-${$$props.size}` : ''}`,
			...others,
			[CLASS]: { 'is-narrow': narrow() }
		}));

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
	}

	var root$A = from_html(`<div><!></div>`);

	function Ui_columns($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class', 'children']);

		var div = root$A();

		attribute_effect(div, () => ({ class: `columns ${classes() ?? ''}`, ...others }));

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
	}

	var root$z = from_html(`<div><!></div>`);

	function Ui_container($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class = '']
		 * @property {string} [title = '']
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {boolean} [widescreen=false]
		 * @property {boolean} [fullhd=false]
		 * @property {boolean} [maxDesktop=false]
		 * @property {boolean} [maxWidescreen=false]
		 * @property {boolean} [fluid = false]
		 * @property {import('svelte').Snippet} [children]
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			title = prop($$props, 'title', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0"),
			widescreen = prop($$props, 'widescreen', 3, false),
			fullhd = prop($$props, 'fullhd', 3, false),
			maxDesktop = prop($$props, 'maxDesktop', 3, false),
			maxWidescreen = prop($$props, 'maxWidescreen', 3, false),
			fluid = prop($$props, 'fluid', 3, false);

		var div = root$z();
		let classes_1;

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_attribute(div, 'title', title());

			classes_1 = set_class(div, 1, `container ${classes() ?? ''}`, null, classes_1, {
				'is-widescreen': widescreen(),
				'is-fullhd': fullhd(),
				'is-max-desktop': maxDesktop(),
				'is-max-widescreen': maxWidescreen(),
				'is-fluid': fluid()
			});

			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
	}

	delegate(['click', 'keyup']);

	var root$y = from_html(`<footer><!></footer>`);

	function Ui_footer($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, "");

		var footer = root$y();
		var node = child(footer);

		snippet(node, () => $$props.children ?? noop);
		reset(footer);

		template_effect(() => {
			set_attribute(footer, 'id', id());
			set_class(footer, 1, `footer ${classes() ?? ''} `);
		});

		append($$anchor, footer);
	}

	var root$x = from_html(`<section><!></section>`);

	function Ui_section$2($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class]
		 * @property {string} [role="button"]
		 * @property {number} [tabIndex = 0]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		var section = root$x();

		section.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		section.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(section);

		snippet(node, () => $$props.children ?? noop);
		reset(section);

		template_effect(() => {
			set_attribute(section, 'id', id());
			set_class(section, 1, `section ${classes() ?? ''}`);
			set_attribute(section, 'role', role());
			set_attribute(section, 'tabindex', tabIndex());
		});

		append($$anchor, section);
	}

	delegate(['click', 'keyup']);

	function Ui_level_item($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [tag]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let tag = prop($$props, 'tag', 3, "div");

		var fragment = comment();
		var node = first_child(fragment);

		element(node, tag, false, ($$element, $$anchor) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					snippet(node_2, () => $$props.children ?? noop);
					append($$anchor, fragment_2);
				};

				var alternate = ($$anchor) => {};

				if_block(node_1, ($$render) => {
					if ($$props.children) $$render(consequent); else $$render(alternate, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$w = from_html(`<nav class="level"><div class="level-left"><!></div> <div class="level-right"><!></div></nav>`);

	function Ui_level($$anchor, $$props) {
		var nav = root$w();
		var div = child(nav);
		var node = child(div);

		snippet(node, () => $$props.left ?? noop);
		reset(div);

		var div_1 = sibling(div, 2);
		var node_1 = child(div_1);

		snippet(node_1, () => $$props.right ?? noop);
		reset(div_1);
		reset(nav);
		append($$anchor, nav);
		/**
		 * @typedef {Object} Props
		 * @property {import('svelte').Snippet} [left]
		 * @property {import('svelte').Snippet} [right]
		 */
		/** @type {Props} */
	}

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIColumn: Ui_column,
		UIColumns: Ui_columns,
		UIContainer: Ui_container,
		UIFooter: Ui_footer,
		UILevel: Ui_level,
		UILevelItem: Ui_level_item,
		UISection: Ui_section$2
	});

	var root_1$n = from_html(`<p> </p>`);
	var root_2$h = from_html(`<input/>`);

	function Ui_number($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, 0),
			placeholder = prop($$props, 'placeholder', 3, "0.0"),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100),
			step = prop($$props, 'step', 3, 1),
			fieldname = prop($$props, 'fieldname', 3, "number"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'min',
				'max',
				'step',
				'fieldname',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$n();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$h();

				attribute_effect(
					input,
					() => ({
						id: `form-field-number-${fieldname() ?? ''}`,
						class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
						type: 'number',
						name: fieldname(),
						invalid: get$3(invalid),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						min: min(),
						max: max(),
						step: step(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$g = from_html(`<!> <!> <!>`, 1);
	var root_8$1 = from_html(`<!> <!> <!>`, 1);
	var root$v = from_html(`<!> <!> <!>`, 1);

	function Ui_named_numbers_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, 'fieldname', 3, "numbers_list"),
			value = prop($$props, 'value', 23, () => ({})),
			defaultItemTitle = prop($$props, 'defaultItemTitle', 3, ""),
			defaultItemValue = prop($$props, 'defaultItemValue', 3, 0),
			label = prop($$props, 'label', 3, "named numbers list"),
			labelSize = prop($$props, 'labelSize', 3, 5),
			placeholder = prop($$props, 'placeholder', 3, "new item"),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false);
			prop($$props, 'required', 3, true);
			prop($$props, 'valid', 3, true);
			let onchange = prop($$props, 'onchange', 3, () => true),
			classes = prop($$props, 'class', 3, "");

		const createNewVal = () => {
			return { id: defaultItemTitle(), number: defaultItemValue() };
		};

		let newVal = state(proxy(createNewVal()));

		const transformObjectToList = () => {
			return Object.keys(value()).map((name) => {
				return { id: name, title: name, number: value()[name] };
			});
		};

		let list = state(proxy(transformObjectToList()));

		function remove(id) {
			if (notCommon$1.objHas(value(), id)) {
				delete value()[id];
				value(value());
				set(list, transformObjectToList(), true);
				onchange()({ value: value(), field: fieldname() });
			}
		}

		function add() {
			const id = get$3(newVal).id.trim();
			const number = parseInt(get$3(newVal).number);

			if (id && id !== "" && !isNaN(number) && !notCommon$1.objHas(value(), id)) {
				value()[id] = number;
			}

			set(list, transformObjectToList(), true);
			onchange()({ value: snapshot(value()), field: fieldname() });
			set(newVal, createNewVal(), true);
		}

		var fragment = root$v();
		var node = first_child(fragment);

		Ui_title(node, {
			get title() {
				return label();
			},

			get size() {
				return labelSize();
			}
		});

		var node_1 = sibling(node, 2);

		each(node_1, 17, () => get$3(list), (item) => item.id, ($$anchor, item) => {
			Ui_columns($$anchor, {
				get class() {
					return classes();
				},

				get disabled() {
					return disabled();
				},

				children: ($$anchor, $$slotProps) => {
					var fragment_2 = root_2$g();
					var node_2 = first_child(fragment_2);

					Ui_column(node_2, {
						classes: 'is-6',

						children: ($$anchor, $$slotProps) => {
							next();

							var text$1 = text();

							template_effect(() => set_text(text$1, get$3(item).title));
							append($$anchor, text$1);
						},

						$$slots: { default: true }
					});

					var node_3 = sibling(node_2, 2);

					Ui_column(node_3, {
						classes: 'is-4',

						children: ($$anchor, $$slotProps) => {
							next();

							var text_1 = text();

							template_effect(() => set_text(text_1, get$3(item).number));
							append($$anchor, text_1);
						},

						$$slots: { default: true }
					});

					var node_4 = sibling(node_3, 2);

					{
						var consequent = ($$anchor) => {
							Ui_column($$anchor, {
								classes: 'is-2',

								children: ($$anchor, $$slotProps) => {
									Ui_button($$anchor, { icon: "minus", action: () => remove(get$3(item).id) });
								},

								$$slots: { default: true }
							});
						};

						if_block(node_4, ($$render) => {
							if (!readonly()) $$render(consequent);
						});
					}

					append($$anchor, fragment_2);
				},

				$$slots: { default: true }
			});
		});

		var node_5 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_columns($$anchor, {
					get class() {
						return classes();
					},

					children: ($$anchor, $$slotProps) => {
						var fragment_8 = root_8$1();
						var node_6 = first_child(fragment_8);

						Ui_column(node_6, {
							classes: 'is-6',

							children: ($$anchor, $$slotProps) => {
								Ui_textfield($$anchor, {
									get placeholder() {
										return placeholder();
									},

									required: false,

									get value() {
										return get$3(newVal).id;
									},

									set value($$value) {
										get$3(newVal).id = $$value;
									}
								});
							},

							$$slots: { default: true }
						});

						var node_7 = sibling(node_6, 2);

						Ui_column(node_7, {
							classes: 'is-4',

							children: ($$anchor, $$slotProps) => {
								Ui_number($$anchor, {
									get value() {
										return get$3(newVal).number;
									},

									set value($$value) {
										get$3(newVal).number = $$value;
									}
								});
							},

							$$slots: { default: true }
						});

						var node_8 = sibling(node_7, 2);

						Ui_column(node_8, {
							classes: 'is-2',

							children: ($$anchor, $$slotProps) => {
								Ui_button($$anchor, { icon: "plus", action: () => add() });
							},

							$$slots: { default: true }
						});

						append($$anchor, fragment_8);
					},

					$$slots: { default: true }
				});
			};

			if_block(node_5, ($$render) => {
				if (!readonly()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$u = from_html(`<input/>`);

	function Ui_password($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "password"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var input = root$u();

		attribute_effect(
			input,
			() => ({
				id: `form-field-password-${fieldname() ?? ''}`,
				class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
				type: 'password',
				name: fieldname(),
				invalid: get$3(invalid),
				required: required(),
				readonly: readonly(),
				disabled: disabled(),
				placeholder: $LOCALE()[placeholder()],
				autocomplete: fieldname(),
				'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
				'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
				...optionalProps,
				...others
			}),
			void 0,
			void 0,
			void 0,
			void 0,
			true
		);

		bind_value(input, value);
		append($$anchor, input);
		pop();
		$$cleanup();
	}

	var root_1$m = from_html(`<figure><img/></figure>`);
	var root_2$f = from_html(`<a><!></a>`);

	function Ui_image($$anchor, $$props) {
		const imageFigure = ($$anchor) => {
			var figure = root_1$m();
			let classes_1;
			var img = child(figure);

			img.__click = function (...$$args) {
				onclick()?.apply(this, $$args);
			};

			img.__keyup = function (...$$args) {
				onkeyup()?.apply(this, $$args);
			};

			reset(figure);

			template_effect(
				($0) => {
					classes_1 = set_class(figure, 1, `image ${classes() ?? ''} ${$0 ?? ''}`, null, classes_1, {
						'is-contained': contained(),
						'is-covered': covered(),
						'is-clickable': onclick() && $$props.pointable !== false || $$props.pointable
					});

					set_style(figure, ($$props.width ? `width: ${$$props.width};` : "") + ($$props.height ? `height: ${$$props.height};` : ""));
					set_attribute(img, 'alt', $$props.alt || $$props.title);
					set_attribute(img, 'title', $$props.title);
					set_attribute(img, 'src', $$props.url || $$props.image);
					set_attribute(img, 'crossorigin', cors());
				},
				[
					() => !$$props.width && !$$props.height
						? isNaN(size()) ? `is-${size()}` : `is-${size()}x${size()}`
						: ''
				]
			);

			append($$anchor, figure);
		};

		let cors = prop($$props, 'cors', 3, "anonymous"),
			size = prop($$props, 'size', 3, 64),
			contained = prop($$props, 'contained', 3, false),
			covered = prop($$props, 'covered', 3, false),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, undefined),
			onkeyup = prop($$props, 'onkeyup', 3, undefined);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var a = root_2$f();

				a.__click = function (...$$args) {
					onclick()?.apply(this, $$args);
				};

				var node_1 = child(a);

				imageFigure(node_1);
				reset(a);

				template_effect(() => {
					set_attribute(a, 'href', $$props.urlFull);
					set_attribute(a, 'title', $$props.title || $$props.alt);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				imageFigure($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.urlFull) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
	}

	delegate(['click', 'keyup']);

	function Ui_radio_buttons($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {any} [variants] - [
		array of groups
		{
		id:number,
		title:string|object,
		image:string|object,
		variants = [
		array of values variants in group
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}]
		}
		]
		 * @property {any} value - multiple && multiple in group
		{
		array of arrays of selected values in group
		if no selection group should be empty array
		[groupId]: [...variantsId]
		}
		multiple && one in group
		{
		[groupId]: variantId
		}
		only one (not multiple && one in group)
		{
		group: groupId
		value: variantId
		}
		 * @property {any} title
		 * @property {any} image
		 * @property {any} [buttonProps]
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [getUIItem]
		 * @property {any} [getDefaultItemSublime]
		 * @property {any} [uiOn]
		 * @property {any} [uiOff]
		 */
		/** @type {Props} */
		let fieldname = prop($$props, 'fieldname', 3, "radio-buttons"),
			variants = prop($$props, 'variants', 19, () => []),
			value = prop($$props, 'value', 7),
			buttonProps = prop($$props, 'buttonProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			listComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({})),
			returnVariant = prop($$props, 'returnVariant', 3, false);
			prop($$props, 'getUIItem', 3, (valueId) => {
				return variantsButtons.find((btnVal) => btnVal.value === valueId);
			});
			let UIItemHasValue = prop($$props, 'UIItemHasValue', 3, (item, val) => {
				return item.value == val;
			}),
			getDefaultItemSublime = prop($$props, 'getDefaultItemSublime', 3, () => {
				return variants()[0].value;
			}),
			uiOn = prop($$props, 'uiOn', 3, (item) => {
				item.color = "success";

				return item;
			}),
			uiOff = prop($$props, 'uiOff', 3, (item) => {
				item.color = "";

				return item;
			}),
			onchange = prop($$props, 'onchange', 3, () => true);

		onMount(() => {
			initVariantsButton();
			selectDefault();
		});

		let variantsButtons = [],
			listItems = state(proxy([]));

		function initVariantsButton() {
			variantsButtons = variants().map((variant) => {
				return { ...buttonProps(), ...variant };
			});

			set(
				listItems,
				[
					{
						id: 0,
						title: $$props.title,
						image: $$props.image,
						description: { values: variantsButtons }
					}
				],
				true
			);
		}

		const getCurrentVariant = () => {
			snapshot(value());

			return variants().find((va) => va.value === value());
		};

		//
		function toggle(selectedValue) {
			let ui = { on: undefined, off: undefined };

			//
			if (typeof value() !== "undefined") {
				ui.off = value();
			}

			if (typeof selectedValue !== "undefined") {
				ui.on = selectedValue;
			}

			value(selectedValue);
			updateUI(ui);

			//
			onchange()({
				field: fieldname(),
				value: returnVariant() ? getCurrentVariant() : snapshot(value())
			});
		}

		//
		function updateUI(changes) {
			for (let t in variantsButtons) {
				if (typeof changes.off !== "undefined" && UIItemHasValue()(variantsButtons[t], changes.off)) {
					variantsButtons[t] = uiOff()(variantsButtons[t]);
				}

				if (typeof changes.on !== "undefined" && UIItemHasValue()(variantsButtons[t], changes.on)) {
					variantsButtons[t] = uiOn()(variantsButtons[t]);
				}
			}

			get$3(listItems)[0].description.values = variantsButtons;
		}

		//
		function selectDefault() {
			if (variants().length > 0) {
				if (typeof value() === "undefined") {
					const defValue = getDefaultItemSublime()();

					toggle(defValue);
				} else {
					updateUI({ on: value() });
				}
			}
		}

		const SvelteComponent = user_derived(listComponent);
		var fragment = comment();
		var node = first_child(fragment);

		{
			let $0 = user_derived(() => ({
				...descriptionComponentProps(),

				action(event, value) {
					toggle(value);
				}
			}));

			component(node, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
				SvelteComponent_1($$anchor, spread_props(listComponentProps, {
					get items() {
						return get$3(listItems);
					},

					get titleComponent() {
						return titleComponent();
					},

					get titleComponentProps() {
						return titleComponentProps();
					},

					get descriptionComponent() {
						return descriptionComponent();
					},

					get descriptionComponentProps() {
						return get$3($0);
					},

					get imageComponent() {
						return imageComponent();
					},

					get imageComponentProps() {
						return imageComponentProps();
					}
				}));
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$l = from_html(`<p> </p>`);
	var root_4$a = from_html(`<option></option>`);
	var root_3$b = from_html(`<datalist></datalist>`);
	var root_2$e = from_html(`<input/> <output> </output> <!>`, 1);

	function Ui_range($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, 10),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100),
			step = prop($$props, 'step', 3, 1),
			tickmarks = prop($$props, 'tickmarks', 3, false),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "range"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'min',
				'max',
				'step',
				'tickmarks',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$l();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var fragment_1 = root_2$e();
				var input = first_child(fragment_1);

				attribute_effect(
					input,
					() => ({
						id: `form-field-range-${fieldname() ?? ''}`,
						class: `input big-number slider has-output ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''}  ${classes() ?? ''}`,
						type: 'range',
						name: fieldname(),
						min: min(),
						max: max(),
						step: step(),
						list: `form-field-range-${fieldname() ?? ''}-tickmarks`,
						invalid: get$3(invalid),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				var output = sibling(input, 2);
				var text_1 = child(output, true);

				reset(output);

				var node_1 = sibling(output, 2);

				{
					var consequent_1 = ($$anchor) => {
						var datalist = root_3$b();

						each(datalist, 21, tickmarks, index$e, ($$anchor, tickmark) => {
							var option = root_4$a();
							var option_value = {};

							template_effect(() => {
								set_attribute(option, 'label', get$3(tickmark).label);

								if (option_value !== (option_value = get$3(tickmark).value)) {
									option.value = (option.__value = get$3(tickmark).value) ?? '';
								}
							});

							append($$anchor, option);
						});

						reset(datalist);
						template_effect(() => set_attribute(datalist, 'id', `form-field-range-${fieldname() ?? ''}-tickmarks`));
						append($$anchor, datalist);
					};

					if_block(node_1, ($$render) => {
						if (Array.isArray(tickmarks()) && tickmarks().length) $$render(consequent_1);
					});
				}

				template_effect(() => {
					set_attribute(output, 'for', `form-field-range-${fieldname() ?? ''}`);
					set_text(text_1, value());
				});

				bind_value(input, value);
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_3$a = from_html(`<span class="mr-2"> </span>`);
	var root_5$8 = from_html(`<span class="mr-2"> </span>`);
	var root_6$8 = from_html(`<div><select><!><!></select></div>`);

	function Ui_select_multiple($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} [value = []]
		 * @property {any}      [variants = []]
		 * @property {string} [placeholder = ""]
		 * @property {boolean}  [emptyValueEnabled = true]
		 * @property {string|number}  [emptyValue]
		 * @property {string} [emptyValueTitle = "no-selection"]
		 * @property {string} [fieldname="select-multiple"]
		 * @property {boolean} [required = true]
		 * @property {boolean} [readonly = false]
		 * @property {number} [rows = 8]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {boolean} [valid = true]
		 * @property {string}   [class = ""]
		 * @property {function} [onchange = ({value:array of string|number, field:string, variants:array of object})=>true]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 23, () => []),
			variants = prop($$props, 'variants', 19, () => []);
			prop($$props, 'placeholder', 3, "");
			let emptyValueTitle = prop($$props, 'emptyValueTitle', 3, "no-selection"),
			emptyValueEnabled = prop($$props, 'emptyValueEnabled', 3, true),
			fieldname = prop($$props, 'fieldname', 3, "select-multiple"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			rows = prop($$props, 'rows', 3, 8),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'placeholder',
				'emptyValueTitle',
				'emptyValueEnabled',
				'emptyValue',
				'fieldname',
				'required',
				'readonly',
				'rows',
				'color',
				'size',
				'valid',
				'class',
				'onchange'
			]);

		let lastValue = snapshot(value());

		function isClearValueMacro(plainValue) {
			return plainValue.includes(UICommon$1.CLEAR_MACRO);
		}

		function getSelectedOptionsValues(ev) {
			return Array.from(ev.selectedOptions).map((el) => typeof el.__value !== "undefined" ? el.__value : el.value);
		}

		function getEmptyValue() {
			return typeof $$props.emptyValue === "undefined" ? UICommon$1.CLEAR_MACRO : $$props.emptyValue;
		}

		function idToVariant(id) {
			return variants().find((variant) => variant.id == id);
		}

		function valueIdsToVariants() {
			const ev = getEmptyValue();

			return value().filter((id) => id !== ev).map(idToVariant);
		}

		function onInput(ev) {
			let selectedIds = getSelectedOptionsValues(ev.currentTarget);

			if (isClearValueMacro(selectedIds)) {
				selectedIds = [];
			}

			const newValue = selectedIds;

			value(selectedIds);

			if (notCommon$1.compareTwoArrays(newValue, lastValue)) {
				return;
			}

			lastValue = newValue;

			onchange()({
				value: newValue,
				field: fieldname(),
				variants: valueIdsToVariants()
			});
		}

		let selectedVariants = user_derived(() => value() && Array.isArray(value()) ? valueIdsToVariants(value()) : []);
		let invalid = user_derived(() => !valid());
		let UI_CLASSES = user_derived(() => [$$props.size, $$props.color].filter((val) => val).map((val) => `is-${val}`).join(" "));
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$3(selectedVariants), index$e, ($$anchor, selectedVariant) => {
							var span = root_3$a();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$3(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var span_1 = root_5$8();
								var text_1 = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
								append($$anchor, span_1);
							};

							if_block(
								node_3,
								($$render) => {
									if (emptyValueEnabled()) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if (value() && Array.isArray(value()) && value().length) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var div = root_6$8();
				var select = child(div);

				attribute_effect(select, () => ({
					multiple: 'true',
					id: `form-field-select-${fieldname() ?? ''}`,
					name: fieldname(),
					oninput: onInput,
					onchange: onInput,
					onblur: onInput,
					value: value(),
					readonly: readonly(),
					required: required(),
					invalid: get$3(invalid),
					size: rows(),
					...others
				}));

				var node_4 = child(select);

				{
					var consequent_3 = ($$anchor) => {
						{
							let $0 = user_derived(() => typeof $$props.emptyValue === "undefined" ? UICommon$1.CLEAR_MACRO : $$props.emptyValue);

							Ui_select_option($$anchor, {
								get value() {
									return get$3($0);
								},

								get title() {
									return emptyValueTitle();
								}
							});
						}
					};

					if_block(node_4, ($$render) => {
						if (emptyValueEnabled()) $$render(consequent_3);
					});
				}

				var node_5 = sibling(node_4);

				each(node_5, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					Ui_select_option($$anchor, {
						get value() {
							return get$3(variant).id;
						},

						get title() {
							return get$3(variant).title;
						}
					});
				});

				reset(select);
				reset(div);
				template_effect(() => set_class(div, 1, `select is-multiple ${get$3(UI_CLASSES) ?? ''} ${classes() ?? ''} `));
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_2); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	const DEFAULT_STATUS_SUCCESS = "ok";
	const NAVIGATION_DELAY_SHORT = 500;
	const NAVIGATION_DELAY_NORMAL = 1500;
	const NAVIGATION_DELAY_LONG = 5000;
	const NAVIGATION_DELAYS = {
	  SHORT: NAVIGATION_DELAY_SHORT,
	  NORMAL: NAVIGATION_DELAY_NORMAL,
	  LONG: NAVIGATION_DELAY_LONG
	};
	const NAVIGATION_DELAY_DEFAULT = NAVIGATION_DELAY_NORMAL;

	function Ui_select_from_model($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_API_MODEL_GETTER = (
			modelName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch
		) => {
			return notCommon$1.getApp().getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
		};

		const DEFAULT_API_REQUEST = (apiModel, actionName) => {
			return apiModel[`$` + actionName]();
		};

		/**
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {string} [placeholder]
		 * @property {string} [emptyValueTitle]
		 * @property {string} [emptyValue]
		 * @property {boolean} [emptyValueEnabled]
		 * @property {string} [fieldname]
		 * @property {string} [modelName]
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId]
		 * @property {string} [optionTitle]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [returnVariant]
		 * @property {function} [onchange = ({value:array of string|number, field:string, variants:array of object})=>true]
		 * @property {function} [onerror = (message:string):void]
		 */
		/** @type {Props} */
		let modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			disabled = prop($$props, 'disabled', 3, false),
			apiModelGetter = prop($$props, 'apiModelGetter', 3, DEFAULT_API_MODEL_GETTER),
			apiRequest = prop($$props, 'apiRequest', 3, DEFAULT_API_REQUEST),
			returnVariant = prop($$props, 'returnVariant', 3, false),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => {}),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'modelName',
				'actionName',
				'actionFilter',
				'actionSorter',
				'actionPager',
				'actionSearch',
				'optionId',
				'optionTitle',
				'disabled',
				'apiModelGetter',
				'apiRequest',
				'returnVariant',
				'class',
				'onchange',
				'onerror'
			]);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let loaded = state(false);
		let variants = state(proxy([]));
		let resultsList = [];
		let uiDisabled = user_derived(() => disabled() || !get$3(loaded));

		onMount(async () => {
			if (argumentsSetProvided()) {
				const response = await apiRequest()(apiModelGetter()(modelName(), actionFilter(), actionSorter(), actionPager(), actionSearch()), actionName());

				if (notCommon$1.isError(response)) {
					set(loaded, false);
					onerror()(response.errors || [response.message]);
				} else {
					resultsList = response.result;

					set(
						variants,
						resultsList.map((item) => {
							return {
								id: notPath.get(optionId(), item),
								title: notPath.get(optionTitle(), item)
							};
						}),
						true
					);

					set(loaded, true);
				}
			}
		});

		function onChange(data) {
			if (returnVariant()) {
				onchange()({
					...data,
					value: get$3(variants).find((itm) => itm.id === data.value)
				});
			} else {
				onchange()(data);
			}
		}

		{
			let $0 = user_derived(() => !get$3(loaded));

			Ui_select($$anchor, spread_props(
				{
					get value() {
						return $$props.value;
					},

					get variants() {
						return get$3(variants);
					},

					get class() {
						return classes();
					},

					get disabled() {
						return get$3(uiDisabled);
					},

					onchange: onChange,

					get loading() {
						return get$3($0);
					}
				},
				() => others
			));
		}

		pop();
	}

	var root_2$d = from_html(`<!> <input/> <label class="label"><!></label>`, 1);

	function Ui_switch$1($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, false),
			label = prop($$props, 'label', 3, ""),
			hideLabel = prop($$props, 'hideLabel', 3, false),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "switch"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur", "oninput"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'label',
				'hideLabel',
				'placeholder',
				'fieldname',
				'size',
				'color',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_boolean($$anchor, {
					get LC_TRUE() {
						return label();
					},

					get LC_FALSE() {
						return label();
					},

					get value() {
						return value();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = root_2$d();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_boolean($$anchor, { value: false });
					};

					if_block(node_1, ($$render) => {
						if (!label() && !hideLabel()) $$render(consequent_1);
					});
				}

				var input = sibling(node_1, 2);

				attribute_effect(
					input,
					() => ({
						id: `form-field-switch-${fieldname() ?? ''}`,
						class: `switch ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
						type: 'checkbox',
						name: fieldname(),
						placeholder: $LOCALE()[placeholder()],
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						invalid: get$3(invalid),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				var label_1 = sibling(input, 2);
				var node_2 = child(label_1);

				{
					var consequent_3 = ($$anchor) => {
						var fragment_4 = comment();
						var node_3 = first_child(fragment_4);

						{
							var consequent_2 = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[label()]));
								append($$anchor, text$1);
							};

							var alternate = ($$anchor) => {
								Ui_boolean($$anchor, { value: false });
							};

							if_block(node_3, ($$render) => {
								if (label()) $$render(consequent_2); else $$render(alternate, false);
							});
						}

						append($$anchor, fragment_4);
					};

					if_block(node_2, ($$render) => {
						if (!hideLabel()) $$render(consequent_3);
					});
				}

				reset(label_1);
				template_effect(() => set_attribute(label_1, 'for', `form-field-switch-${fieldname() ?? ''}`));
				bind_checked(input, value);
				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$9 = from_html(`<div class="switch-list-item"><input/> <!></div>`);

	function Ui_switch_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "switch"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur", "oninput"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, " is-rounded "),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'fieldname',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class',
				'onchange'
			]);

		function addId(varId) {
			if (!value().includes(varId)) {
				value().push(varId);
				value(value());
			}
		}

		function remId(varId) {
			if (value().includes(varId)) {
				value().splice(value().indexOf(varId), 1);
				value(value());
			}
		}

		function onChange(eventData, ev) {
			const varId = ev.target.id.split("-variant-").at(-1);

			ev.target.checked ? addId(varId) : remId(varId);

			let data = { field: fieldname(), value: snapshot(value()) };

			onchange()(data);

			return true;
		}

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof others.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), onChange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var text$1 = text();

						template_effect(($0) => set_text(text$1, $0), [
							() => variants().filter((variant) => value().includes(variant.id)).map((variant) => variant.title).join(", ")
						]);

						append($$anchor, text$1);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = comment();
				var node_2 = first_child(fragment_3);

				each(node_2, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					var div = root_4$9();
					var input = child(div);

					attribute_effect(
						input,
						($0) => ({
							type: 'checkbox',
							class: `switch ${classes() ?? ''} ${get$3(variant).type ? `is-${get$3(variant).type}` : ''}`,
							id: `form-field-switch-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							checked: $0,
							name: fieldname(),
							disabled: disabled(),
							required: required(),
							readonly: readonly(),
							invalid: get$3(invalid),
							'aria-controls': `input-field-helper-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							'aria-describedby': `input-field-helper-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							...optionalProps,
							...others
						}),
						[() => value().includes(get$3(variant).id)],
						void 0,
						void 0,
						void 0,
						true
					);

					var node_3 = sibling(input, 2);

					Ui_label(node_3, {
						class: 'label',

						get for() {
							return `form-field-switch-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`;
						},

						get label() {
							return get$3(variant).title;
						}
					});

					reset(div);
					append($$anchor, div);
				});

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_4$8 = from_html(`<button aria-label="delete button" class="delete is-small"></button>`);
	var root_3$9 = from_html(`<span> <!></span>`);
	var root_6$7 = from_html(`<div class="select is-small"><select><!><!></select></div> <!>`, 1);
	var root_1$k = from_html(`<!> <!>`, 1);

	function Ui_tag_select($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		onMount(() => {
			clearValueFromDeadVariants();
		});

		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_ADD = "not-node:add_label"]
		 * @property {string} [LC_SELECT_FROM_LIST = "not-node:select_from_list_label"]
		 * @property {array<string|number>} [value] - list of item ids
		 * @property {array<object>} [variants]
		 * @property {string} [fieldname = 'tag']
		 * @property {boolean} [readonly = false] - export let required = true;
		 * @property {boolean} [valid = true]
		 * @property {function} [beforeAdd]
		 * @property {function} [getItemId]
		 * @property {function} [getItemTitle]
		 * @property {function} [getItemType]
		 * @property {function} [buildItem]
		 */
		/** @type {Props} */
		let LC_ADD = prop($$props, 'LC_ADD', 3, "not-node:add_label"),
			LC_SELECT_FROM_LIST = prop($$props, 'LC_SELECT_FROM_LIST', 3, "not-node:select_from_list_label"),
			value = prop($$props, 'value', 31, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "tag"),
			readonly = prop($$props, 'readonly', 3, false);
			prop($$props, 'valid', 3, true);
			let beforeAdd = prop($$props, 'beforeAdd', 3, (/*variant, variants*/) => {
				return true;
			}),
			getItemId = prop($$props, 'getItemId', 3, (variant) => {
				return variant.id;
			}),
			getItemTitle = prop($$props, 'getItemTitle', 3, (variant) => {
				return variant.title;
			}),
			//eslint-disable-next-line no-unused-vars
			getItemType = prop($$props, 'getItemType', 3, (variant) => {
				return variant?.type ?? "info";
			}),
			buildItem = prop($$props, 'buildItem', 3, (variant) => {
				return {
					id: getItemId()(variant),
					title: getItemTitle()(variant),
					type: getItemType()(variant)
				};
			}),
			classes = prop($$props, 'class', 3, "");

		function variantIdToVariant(id) {
			return variants().find((variant) => getItemId()(variant) == id);
		}

		function changeEvent() {
			$$props.onchange({ field: fieldname(), value: value() });
		}

		function remove(e) {
			e && e.preventDefault();

			let id = e.currentTarget.dataset.id;

			if (value().includes(id)) {
				value().splice(value().indexOf(id), 1);
				value(value());
				changeEvent();
			}

			return false;
		}

		function add(e) {
			e && e.preventDefault();

			let id = e.currentTarget.parentNode.querySelector("select").value;
			const variant = variantIdToVariant(id);

			if (!variant) {
				return false;
			}

			if (!beforeAdd()(variant, variants())) {
				return false;
			}

			if (id && value().indexOf(id) === -1) {
				value().push(id);
				value(value());
				changeEvent();
			}

			return false;
		}

		function clearValueFromDeadVariants() {
			value(value().filter(variantIdToVariant));

			return value();
		}

		/*
		item = {
		  id,        //unique
		  title,     //some text
		  type       //for coloring items, usual html template names danger, success, etc
		}
		*/
		let items = user_derived(() => value().map(variantIdToVariant).filter((variant) => variant).map(buildItem()));

		Ui_columns($$anchor, {
			get class() {
				return classes();
			},

			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$k();
				var node = first_child(fragment_1);

				Ui_column(node, {
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, () => get$3(items), (item) => item.id, ($$anchor, item) => {
							var span = root_3$9();
							var text = child(span);
							var node_2 = sibling(text);

							{
								var consequent = ($$anchor) => {
									var button = root_4$8();

									button.__click = remove;
									template_effect(() => set_attribute(button, 'data-id', get$3(item).id));
									append($$anchor, button);
								};

								if_block(node_2, ($$render) => {
									if (!readonly()) $$render(consequent);
								});
							}

							reset(span);

							template_effect(() => {
								set_class(span, 1, `mx-1 tag is-${get$3(item).type ?? ''}`);
								set_text(text, `${$LOCALE()[get$3(item).title] ?? ''} `);
							});

							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					},

					$$slots: { default: true }
				});

				var node_3 = sibling(node, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_column($$anchor, {
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_6$7();
								var div = first_child(fragment_4);
								var select = child(div);
								var node_4 = child(select);

								Ui_select_option(node_4, {
									value: -1,
									selected: true,

									get title() {
										return LC_SELECT_FROM_LIST();
									}
								});

								var node_5 = sibling(node_4);

								each(node_5, 17, variants, index$e, ($$anchor, variant) => {
									Ui_select_option($$anchor, {
										get value() {
											return get$3(variant).id;
										},

										get title() {
											return get$3(variant).title;
										}
									});
								});

								reset(select);
								reset(div);

								var node_6 = sibling(div, 2);

								Ui_button(node_6, {
									color: "primary",
									size: "small",
									action: add,

									get title() {
										return LC_ADD();
									}
								});

								append($$anchor, fragment_4);
							},

							$$slots: { default: true }
						});
					};

					if_block(node_3, ($$render) => {
						if (!readonly()) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root_1$j = from_html(`<p> </p>`);
	var root_2$c = from_html(`<input/>`);

	function Ui_telephone($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, "+7 987 654-32-10"),
			pattern = prop($$props, 'pattern', 3, "\\+[0-9]{1,3}\\s+[0-9]{3}\\s+[0-9]{3}-[0-9]{2}-[0-9]{2}"),
			fieldname = prop($$props, 'fieldname', 3, "telephone"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'pattern',
				'fieldname',
				'required',
				'disabled',
				'readonly',
				'color',
				'size',
				'valid',
				'class'
			]);

		let invalid = user_derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$j();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$c();

				attribute_effect(
					input,
					() => ({
						id: `form-field-telephone-${fieldname() ?? ''}`,
						class: `input ${$$props.size ? `is-${$$props.size}` : ''} ${$$props.color ? `is-${$$props.color}` : ''} ${classes() ?? ''}`,
						type: 'tel',
						name: fieldname(),
						pattern: pattern(),
						invalid: get$3(invalid),
						required: required(),
						readonly: readonly(),
						disabled: disabled(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					}),
					void 0,
					void 0,
					void 0,
					void 0,
					true
				);

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIAutocomplete: Ui_autocomplete,
		UICheckbox: Ui_checkbox,
		UICheckboxList: Ui_checkbox_list,
		UIColor: Ui_color,
		UIControl: Ui_control,
		UIDate: Ui_date,
		UIDatetimeInTZ: Ui_datetime_in_tz,
		UIEmail: Ui_email,
		UIField: Ui_field,
		UIHidden: Ui_hidden,
		UIJSONArea: Ui_json_area,
		UILabel: Ui_label,
		UIListOfModels: Ui_list_of_models,
		UINamedNumbersList: Ui_named_numbers_list,
		UINumber: Ui_number,
		UIPassword: Ui_password,
		UIRadioButtons: Ui_radio_buttons,
		UIRange: Ui_range,
		UISelect: Ui_select,
		UISelectFromModel: Ui_select_from_model,
		UISelectMultiple: Ui_select_multiple,
		UISelectOption: Ui_select_option,
		UISwitch: Ui_switch$1,
		UISwitchList: Ui_switch_list,
		UITagSelect: Ui_tag_select,
		UITelephone: Ui_telephone,
		UITextarea: Ui_textarea,
		UITextfield: Ui_textfield
	});

	function Ui_tag_value_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {object}    Props
		 * @property {array}    values = []
		 * @property {boolean}  [grouped = true]
		 * @property {boolean}  [multiline = true]
		 */
		/**
		 * @type   Props
		 */
		let values = prop($$props, 'values', 19, () => []),
			grouped = prop($$props, 'grouped', 3, true),
			multiline = prop($$props, 'multiline', 3, true);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_field($$anchor, {
					get grouped() {
						return grouped();
					},

					get multiline() {
						return multiline();
					},

					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, values, index$e, ($$anchor, tagValueProps) => {
							Ui_control($$anchor, {
								children: ($$anchor, $$slotProps) => {
									Ui_tag_value($$anchor, spread_props(() => get$3(tagValueProps)));
								},

								$$slots: { default: true }
							});
						});

						append($$anchor, fragment_2);
					},

					$$slots: { default: true }
				});
			};

			if_block(node, ($$render) => {
				if (values().length) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_3$8 = from_html(`<span> </span> `, 1);
	var root_1$i = from_html(`<p><!></p>`);

	function Ui_errors_list($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {array<string>}  [errors = []]
		 * @property {boolean} [show = false]
		 * @property {string} [class = '']
		 * @property {string} [id = 'errors-list']
		 */
		/** @type {Props} */
		let errors = prop($$props, 'errors', 19, () => []),
			show = prop($$props, 'show', 3, false),
			classes = prop($$props, 'class', 3, ""),
			id = prop($$props, 'id', 3, "errors-list");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var p = root_1$i();
				var node_1 = child(p);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 17, errors, index$e, ($$anchor, error, index) => {
							var fragment_2 = root_3$8();
							var span = first_child(fragment_2);
							var text = child(span, true);

							reset(span);

							var text_1 = sibling(span, 1, true);

							template_effect(() => {
								set_text(text, $LOCALE()[get$3(error)]);
								set_text(text_1, index < errors().length - 1 ? ", " : "");
							});

							append($$anchor, fragment_2);
						});

						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var text_2 = text(' ');

						append($$anchor, text_2);
					};

					if_block(node_1, ($$render) => {
						if (show()) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(p);

				template_effect(() => {
					set_class(p, 1, `help ${classes() ?? ''}`);
					set_attribute(p, 'id', id());
				});

				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if (Array.isArray(errors()) && errors().length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_1$h = from_html(`<p><strong> </strong> <small>@</small> <strong> </strong></p>`);
	var root$t = from_html(`<article class="media"><figure class="media-left"><p class="image is-32x32"><img/></p></figure> <div class="media-content"><!></div></article>`);

	function Ui_user_card($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [id = "userCard"]
		 * @property {string}       [image = "https://bulma.io/images/placeholders/32x32.png"]
		 * @property {string}       [username = "John Doe"]
		 * @property {string}       [role = "admin"]
		 * @property {object}       [events = {}]
		 * @property {function}     [register = notCommon.registerWidgetEvents] - register event handlers
		 * @property {function}     [onUpdate = (data)=> {username=data.username; role = data.role;}]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "userCard"),
			image = prop($$props, 'image', 3, "https://bulma.io/images/placeholders/32x32.png"),
			username = prop($$props, 'username', 7, "John Doe"),
			role = prop($$props, 'role', 7, "admin"),
			events = prop($$props, 'events', 23, () => ({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "username")) {
					username(data.username);
				}

				if (Object.hasOwn(data, "role")) {
					role(data.role);
				}
			});

		function getCompId() {
			return `usercard-${id()}`;
		}

		function getStandartUpdateEventName() {
			return `${getCompId()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events()[getStandartUpdateEventName()] = onUpdate();
			}

			register()(events());
		});

		var $$exports = { getCompId, getStandartUpdateEventName };
		var article = root$t();
		var figure = child(article);
		var p = child(figure);
		var img = child(p);

		reset(p);
		reset(figure);

		var div = sibling(figure, 2);
		var node = child(div);

		Ui_content(node, {
			children: ($$anchor, $$slotProps) => {
				var p_1 = root_1$h();
				var strong = child(p_1);
				var text = child(strong, true);

				reset(strong);

				var strong_1 = sibling(strong, 4);
				var text_1 = child(strong_1, true);

				reset(strong_1);
				reset(p_1);

				template_effect(() => {
					set_text(text, username());
					set_text(text_1, role());
				});

				append($$anchor, p_1);
			},

			$$slots: { default: true }
		});

		reset(div);
		reset(article);

		template_effect(
			($0) => {
				set_attribute(article, 'id', $0);
				set_attribute(img, 'src', image());
				set_attribute(img, 'alt', username());
			},
			[getCompId]
		);

		append($$anchor, article);

		return pop($$exports);
	}

	var root_1$g = from_html(`<span><span><i></i> <span> </span></span></span>`);
	var root_2$b = from_html(`<span><i></i></span>`);

	function Ui_icon_font($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""]
		 * @property {string} [font = ""]
		 * @property {string} [size = ""]
		 * @property {string} [side = ""]
		 * @property {string} [class = ""]
		 * @property {boolean} [pointable = false]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			font = prop($$props, 'font', 3, ""),
			side = prop($$props, 'side', 3, ""),
			size = prop($$props, 'size', 3, ""),
			pointable = prop($$props, 'pointable', 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$g();
				var span_1 = child(span);
				var i = child(span_1);
				var span_2 = sibling(i, 2);
				var text = child(span_2, true);

				reset(span_2);
				reset(span_1);
				reset(span);

				template_effect(() => {
					set_class(span, 1, `icon-text ${pointable() ? 'is-clickable' : ''}`);
					set_class(span_1, 1, `icon ${size() ? `is-${size()}` : ''}`);

					set_class(i, 1, `is-title-icon fas
      fa-${font() ?? ''}
      ${size() == 'medium' ? 'fa-lg' : ''}
      ${size() == 'large' ? 'fa-2x' : ''}
      `);

					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			var alternate = ($$anchor) => {
				var span_3 = root_2$b();
				var i_1 = child(span_3);

				reset(span_3);

				template_effect(() => {
					set_class(span_3, 1, `
        ${pointable() ? 'is-clickable' : ''}
        ${side() ? `is-${side()}` : ''}
        icon ${size() ? `is-${size()}` : ''} ${size() == 'medium' ? 'fa-lg' : ''}
${size() == 'large' ? 'fa-2x' : ''}`);

					set_class(i_1, 1, `fas fa-${font() ?? ''}`);
				});

				append($$anchor, span_3);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$7 = from_html(`<!> <!>`, 1);

	function Ui_simple_search_input($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [placeholder = 'not-node:field_search_placeholder']
		 * @property {string}   [term = '']
		 * @property {string}   [fieldname = 'searchTermInput']
		 * @property {string}   [icon = 'search']
		 * @property {function} [onchange]
		 */
		/** @type {Props} */
		let placeholder = prop($$props, 'placeholder', 3, "not-node:field_search_placeholder"),
			term = prop($$props, 'term', 15, ""),
			fieldname = prop($$props, 'fieldname', 3, "searchTermInput"),
			icon = prop($$props, 'icon', 3, "search"),
			iconSide = prop($$props, 'iconSide', 3, "left"),
			size = prop($$props, 'size', 3, "normal"),
			required = prop($$props, 'required', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'placeholder',
				'term',
				'fieldname',
				'icon',
				'iconSide',
				'size',
				'required'
			]);

		let hasIconsLeft = user_derived(() => icon() && iconSide() === "left");
		let hasIconsRight = user_derived(() => icon() && iconSide() === "right");

		Ui_columns($$anchor, {
			role: 'none',

			children: ($$anchor, $$slotProps) => {
				Ui_column($$anchor, {
					role: 'none',

					children: ($$anchor, $$slotProps) => {
						Ui_field($$anchor, {
							children: ($$anchor, $$slotProps) => {
								Ui_control($$anchor, {
									get hasIconsLeft() {
										return get$3(hasIconsLeft);
									},

									get hasIconsRight() {
										return get$3(hasIconsRight);
									},

									children: ($$anchor, $$slotProps) => {
										var fragment_4 = root_4$7();
										var node = first_child(fragment_4);

										Ui_textfield(node, spread_props(
											{
												get placeholder() {
													return placeholder();
												},

												get fieldname() {
													return fieldname();
												},

												get required() {
													return required();
												},

												get size() {
													return size();
												},

												role: "searchbox"
											},
											() => others,
											{
												get value() {
													return term();
												},

												set value($$value) {
													term($$value);
												}
											}
										));

										var node_1 = sibling(node, 2);

										{
											var consequent = ($$anchor) => {
												Ui_icon_font($$anchor, {
													get font() {
														return icon();
													},

													get side() {
														return iconSide();
													}
												});
											};

											if_block(node_1, ($$render) => {
												if (icon()) $$render(consequent);
											});
										}

										append($$anchor, fragment_4);
									},

									$$slots: { default: true }
								});
							},

							$$slots: { default: true }
						});
					},

					$$slots: { default: true }
				});
			},

			$$slots: { default: true }
		});

		pop();
	}

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBoolean: Ui_boolean,
		UIBooleanLabeled: Ui_boolean_labeled,
		UIBooleans: Ui_booleans,
		UICensored: Ui_censored,
		UIErrorsList: Ui_errors_list,
		UIIndicator: Ui_indicator,
		UILoader: Ui_loader,
		UIProgress: Ui_progress,
		UISelectFromModelOnDemandInline: Ui_select_from_model_on_demand_inline,
		UISelectFromModelWithSearchModal: Ui_select_from_model_with_search_modal,
		UIShowOneFromList: Ui_show_one_from_list,
		UISimpleSearchInput: Ui_simple_search_input,
		UITag: Ui_tag,
		UITagValue: Ui_tag_value,
		UITagValueList: Ui_tag_value_list,
		UITitle: Ui_title,
		UIUserCard: Ui_user_card
	});

	function Ui_form_input_errors($$anchor, $$props) {
		push($$props, true);

		let id = prop($$props, 'id', 3, "generic-field"),
			classes = prop($$props, 'class', 3, "");

		let allErrors = state(proxy([]));
		let showErrors = state(true);

		user_effect(() => {
			set(
				allErrors,
				[
					...Array.isArray($$props.errors) ? $$props.errors : [],
					...Array.isArray($$props.formErrors) ? $$props.formErrors : []
				],
				true
			);

			set(showErrors, $$props.inputStarted && $$props.validated && !$$props.valid, true);
		});

		Ui_errors_list($$anchor, {
			get show() {
				return get$3(showErrors);
			},

			get errors() {
				return get$3(allErrors);
			},

			get class() {
				return classes();
			},

			get id() {
				return id();
			}
		});

		pop();
	}

	var root$s = from_html(`<span class="is-tag-container"><!> <!></span>`);

	function Ui_icon_button_with_tag($$anchor, $$props) {
		push($$props, true);

		let button = prop($$props, 'button', 19, () => ({})),
			tag = prop($$props, 'tag', 19, () => ({}));

		let vars = state(proxy({}));

		let tagPosition = {
			left: !!$$props.left,
			right: !!$$props.right,
			top: !!$$props.top,
			bottom: !!$$props.bottom
		};

		onMount(() => {
			if ($$props.left) {
				get$3(vars)[`--siding-left-size`] = $$props.left;
			}

			if ($$props.right) {
				get$3(vars)["--siding-right-size"] = $$props.right;
			}

			if ($$props.top) {
				get$3(vars)["--siding-top-size"] = $$props.top;
			}

			if ($$props.bottom) {
				get$3(vars)["--siding-bottom-size"] = $$props.bottom;
			}

			set(vars, get$3(vars), true);
		});

		var span = root$s();
		var node = child(span);

		Ui_button(node, spread_props(button));

		var node_1 = sibling(node, 2);

		Ui_tag(node_1, spread_props(
			tag,
			{
				get vars() {
					return get$3(vars);
				}
			},
			() => tagPosition
		));

		reset(span);
		append($$anchor, span);
		pop();
	}

	var root$r = from_html(`<div><!></div>`);

	function Ui_icon_floating($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [trigger] - export let direction = 'left';  //left/right/top/bottom/around
		 */
		/** @type {Props} */
		let trigger = prop($$props, 'trigger', 19, () => ({
				title: "Click me!",
				icon: "plus",
				color: "primary",
				size: "medium",
				onclick: () => true
			})),
			top = prop($$props, 'top', 3, "2em"),
			left = prop($$props, 'left', 3, "2em"),
			classes = prop($$props, 'class', 3, "");

		let positionStyle = state("");

		onMount(() => {
			set(positionStyle, "");

			if (top()) {
				set(positionStyle, get$3(positionStyle) + `top: ${top()};`);
			}

			if (left()) {
				set(positionStyle, get$3(positionStyle) + `left: ${left()};`);
			}

			if ($$props.right) {
				set(positionStyle, get$3(positionStyle) + `right: ${$$props.right};`);
			}

			if ($$props.bottom) {
				set(positionStyle, get$3(positionStyle) + `bottom: ${$$props.bottom};`);
			}
		});

		var div = root$r();
		var node = child(div);

		Ui_button(node, spread_props(trigger));
		reset(div);

		template_effect(() => {
			set_class(div, 1, `is-absolute ${classes() ?? ''}`);
			set_style(div, get$3(positionStyle));
		});

		append($$anchor, div);
		pop();
	}

	var root_3$7 = from_html(`<span class="icon"><!></span>`);
	var root_5$7 = from_html(`<figure><img/></figure>`);

	function Ui_icon($$anchor, $$props) {
		/* eslint svelte/no-at-html-tags: 0 */
		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""] - font icon title
		 * @property {string} [size = ""]  - font icon size
		 * @property {string} [font = ""] - font icon name
		 * @property {string} [svg = ""] - svg icon
		 * @property {string} [src = ""] - image icon
		 * @property {number|string} width
		 * @property {number|string} height
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			size = prop($$props, 'size', 3, ""),
			font = prop($$props, 'font', 3, ""),
			svg = prop($$props, 'svg', 3, ""),
			src = prop($$props, 'src', 3, "");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return font();
					},

					get size() {
						return size();
					},

					get title() {
						return title();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var span = root_3$7();
						var node_2 = child(span);

						html(node_2, svg);
						reset(span);
						append($$anchor, span);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								var figure = root_5$7();
								var img = child(figure);

								reset(figure);

								template_effect(() => {
									set_class(figure, 1, `image ${$$props.width && $$props.height ? `is-${$$props.width}x${$$props.height}` : ''} `);
									set_attribute(img, 'src', src());
									set_attribute(img, 'title', title());
									set_attribute(img, 'alt', title());
									set_attribute(img, 'width', $$props.width);
									set_attribute(img, 'height', $$props.height);
								});

								append($$anchor, figure);
							};

							if_block(
								node_3,
								($$render) => {
									if (src()) $$render(consequent_2);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (svg()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (font()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
	}

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIIcon: Ui_icon,
		UIIconButtonWithTag: Ui_icon_button_with_tag,
		UIIconFloating: Ui_icon_floating,
		UIIconFont: Ui_icon_font
	});

	function Ui_form_input_validated_icon($$anchor, $$props) {
		let side = prop($$props, 'side', 3, "right"),
			size = prop($$props, 'size', 3, "small");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				{
					let $0 = user_derived(() => $$props.valid ? "check" : "exclamation-triangle");

					Ui_icon_font($$anchor, {
						get font() {
							return get$3($0);
						},

						get side() {
							return side();
						},

						get size() {
							return size();
						}
					});
				}
			};

			if_block(node, ($$render) => {
				if ($$props.validated === true) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root$q = from_html(`<!> <!> <!>`, 1);

	function Ui_form_input($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [value]
		 * @property {boolean} [readonly]
		 * @property {object}  UIInput
		 * @property {string} fieldtype
		 * @property {string} fieldname
		 * @property {string} [fieldnamePrefix = "form-field-"]
		 * @property {string} [icon]
		 * @property {string} [iconSide = 'left']
		 * @property {string} [iconSize= 'small']
		 * @property {boolean} [valid = true]
		 * @property {boolean} [validated = false]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, "");
			prop($$props, 'fieldnamePrefix', 3, "form-field-");
			let valid = prop($$props, 'valid', 3, true),
			validated = prop($$props, 'validated', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'readonly',
				'UIInput',
				'label',
				'fieldtype',
				'fieldname',
				'fieldnamePrefix',
				'icon',
				'valid',
				'validated'
			]);

		var fragment = root$q();
		var node = first_child(fragment);

		component(node, () => $$props.UIInput, ($$anchor, UIInput_1) => {
			UIInput_1($$anchor, spread_props(
				{
					get fieldtype() {
						return $$props.fieldtype;
					},

					get fieldname() {
						return $$props.fieldname;
					},

					get valid() {
						return valid();
					},

					get readonly() {
						return $$props.readonly;
					}
				},
				() => others,
				{
					get value() {
						return value();
					},

					set value($$value) {
						value($$value);
					}
				}
			));
		});

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return $$props.icon;
					},

					side: iconSide,
					size: iconSize
				});
			};

			if_block(node_1, ($$render) => {
				if ($$props.icon) $$render(consequent);
			});
		}

		var node_2 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_form_input_validated_icon($$anchor, {
					get validated() {
						return validated();
					},

					get valid() {
						return valid();
					}
				});
			};

			if_block(node_2, ($$render) => {
				if (!$$props.readonly) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_4$6 = from_html(`<!> <!>`, 1);
	var root_6$6 = from_html(` <!>`, 1);
	var root$p = from_html(`<!> <!>`, 1);

	function Ui_form_control($$anchor, $$props) {
		push($$props, true);

		const control = ($$anchor) => {
			Ui_control($$anchor, {
				get class() {
					return get$3(iconClasses);
				},

				children: ($$anchor, $$slotProps) => {
					Ui_form_input($$anchor, spread_props(
						{
							get UIInput() {
								return $$props.UIInput;
							},

							get placeholder() {
								return placeholder();
							},

							get fieldtype() {
								return $$props.fieldtype;
							},

							get fieldname() {
								return $$props.fieldname;
							},

							get fieldnamePrefix() {
								return fieldnamePrefix();
							},

							get icon() {
								return icon();
							},

							get iconSide() {
								return iconSide();
							},

							get iconSize() {
								return iconSize();
							},

							get required() {
								return required();
							},

							get readonly() {
								return readonly();
							},

							get disabled() {
								return disabled();
							},

							get inputStarted() {
								return inputStarted();
							},

							get validated() {
								return validated();
							},

							get valid() {
								return valid();
							},

							get onchange() {
								return onchange();
							},

							get onerror() {
								return onerror();
							}
						},
						() => others,
						{
							get value() {
								return value();
							},

							set value($$value) {
								value($$value);
							}
						}
					));
				},

				$$slots: { default: true }
			});
		};

		let value = prop($$props, 'value', 15, ""),
			inputStarted = prop($$props, 'inputStarted', 3, false),
			labelVertical = prop($$props, 'labelVertical', 3, true),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldnamePrefix = prop($$props, 'fieldnamePrefix', 3, "form-field-"),
			icon = prop($$props, 'icon', 3, ""),
			iconSide = prop($$props, 'iconSide', 3, "left"),
			iconSize = prop($$props, 'iconSize', 3, "small"),
			required = prop($$props, 'required', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			validated = prop($$props, 'validated', 3, false),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => true),
			formErrors = prop($$props, 'formErrors', 19, () => []),
			errors = prop($$props, 'errors', 19, () => []),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'UIInput',
				'inputStarted',
				'label',
				'labelVertical',
				'placeholder',
				'fieldtype',
				'fieldname',
				'fieldnamePrefix',
				'icon',
				'iconSide',
				'iconSize',
				'required',
				'readonly',
				'disabled',
				'valid',
				'validated',
				'onchange',
				'onerror',
				'formErrors',
				'errors'
			]);

		let iconClasses = user_derived(() => (icon() ? " has-icons-left " : "") + " has-icons-right ");
		var fragment_2 = root$p();
		var node = first_child(fragment_2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_1 = first_child(fragment_3);

				{
					var consequent = ($$anchor) => {
						var fragment_4 = root_4$6();
						var node_2 = first_child(fragment_4);

						Ui_label(node_2, {
							get class() {
								return $$props.fieldtype;
							},

							get for() {
								return `${fieldnamePrefix() ?? ''}${$$props.fieldtype ?? ''}-${$$props.fieldname ?? ''}`;
							},

							get label() {
								return $$props.label;
							}
						});

						var node_3 = sibling(node_2, 2);

						control(node_3);
						append($$anchor, fragment_4);
					};

					var alternate = ($$anchor) => {
						Ui_label($$anchor, {
							get class() {
								return $$props.fieldtype;
							},

							get for() {
								return `${fieldnamePrefix() ?? ''}${$$props.fieldtype ?? ''}-${$$props.fieldname ?? ''}`;
							},

							children: ($$anchor, $$slotProps) => {
								next();

								var fragment_6 = root_6$6();
								var text = first_child(fragment_6);
								var node_4 = sibling(text);

								control(node_4);
								template_effect(() => set_text(text, `${$$props.label ?? ''}: `));
								append($$anchor, fragment_6);
							},

							$$slots: { default: true }
						});
					};

					if_block(node_1, ($$render) => {
						if (labelVertical()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_3);
			};

			var alternate_1 = ($$anchor) => {
				control($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.label) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		var node_5 = sibling(node, 2);

		Ui_form_input_errors(node_5, {
			get inputStarted() {
				return inputStarted();
			},

			get validated() {
				return validated();
			},

			get valid() {
				return valid();
			},

			get errors() {
				return errors();
			},

			get formErrors() {
				return formErrors();
			},

			get id() {
				return `input-field-helper-${$$props.fieldname ?? ''}`;
			}
		});

		append($$anchor, fragment_2);
		pop();
	}

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIFormControl: Ui_form_control,
		UIFormInput: Ui_form_input,
		UIFormInputErrors: Ui_form_input_errors,
		UIFormInputValidatedIcon: Ui_form_input_validated_icon
	});

	function Ui_images($$anchor, $$props) {
		let values = prop($$props, 'values', 19, () => []),
			override = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'values']);

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.url, ($$anchor, item) => {
			Ui_image($$anchor, spread_props(() => get$3(item), () => override));
		});

		append($$anchor, fragment);
	}

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIImage: Ui_image,
		UIImages: Ui_images
	});

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UILink: Ui_link,
		UILinks: Ui_links
	});

	function Ui_endless_list_navigation($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {number}   [page]                - current page
		 * @property {number}   [pages]               - total count of pages
		 * @property {any}      [buttonsRowComponent = UIButtonsRow] - buttons row ui svelte component
		 * @property {object}   [buttonsRowComponentProps]   - buttons row component properties
		 * @property {object}   [buttonPrevProps]   - prev button ui component properties
		 * @property {object}   [buttonProgressProps]   - center/progress button ui component properties
		 * @property {object}   [buttonNextProps]   - next button ui component properties
		 * @property {function} [onnext]            - callback on next
		 * @property {function} [onprev]            - callback on prev
		 * @property    {string}    [progressTitleStart = '']  - prefix of progress button title
		 * @property    {string}    [progressTitleDelimiter = ' / ']  - text that breaks numbers of current page and total count of pages
		 * @property    {string}    [progressTitleEnd = '']  - suffix of progress button title
		 */
		/** @type {Props} */
		let page = prop($$props, 'page', 7, 0),
			pages = prop($$props, 'pages', 3, 0),
			UIButtonsRowComponent = prop($$props, 'buttonsRowComponent', 3, Ui_buttons_row),
			buttonsRowComponentProps = prop($$props, 'buttonsRowComponentProps', 19, () => ({})),
			buttonPrevProps = prop($$props, 'buttonPrevProps', 19, () => ({ title: "not-node:list_navigation_prev_button_label" })),
			buttonProgressProps = prop($$props, 'buttonProgressProps', 19, () => ({})),
			buttonNextProps = prop($$props, 'buttonNextProps', 19, () => ({ title: "not-node:list_navigation_next_button_label" })),
			//this is placeholders for demonstration purposes only, `page` should be modified outside in onprev/onnext callbacks
			onprev = prop($$props, 'onprev', 3, () => {
				page() > 0 && update_prop(page, -1);
			}),
			onnext = prop($$props, 'onnext', 3, () => {
				page() < pages() - 1 && update_prop(page);
			}),
			progressTitleStart = prop($$props, 'progressTitleStart', 3, ""),
			progressTitleDelimiter = prop($$props, 'progressTitleDelimiter', 3, " / "),
			progressTitleEnd = prop($$props, 'progressTitleEnd', 3, "");

		let currentPage = user_derived(() => page() + 1);
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					let $0 = user_derived(() => get$3(currentPage) > 1 ? [{ ...buttonPrevProps(), action: onprev() }] : []);

					let $1 = user_derived(() => pages() > 1
						? [
							{
								...buttonProgressProps(),
								title: `${progressTitleStart()}${get$3(currentPage)}${progressTitleDelimiter()}${pages()}${progressTitleEnd()}`,
								disabled: true
							}
						]
						: []);

					let $2 = user_derived(() => get$3(currentPage) < pages() ? [{ ...buttonNextProps(), action: onnext() }] : []);

					component(node_1, UIButtonsRowComponent, ($$anchor, UIButtonsRowComponent_1) => {
						UIButtonsRowComponent_1($$anchor, spread_props(buttonsRowComponentProps, {
							get left() {
								return get$3($0);
							},

							get center() {
								return get$3($1);
							},

							get right() {
								return get$3($2);
							}
						}));
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (pages() > 0) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root_1$f = from_html(`<span> </span>`);

	function Ui_endless_list_simple_item($$anchor, $$props) {
		push($$props, true);

		function click(e) {
			e.preventDefault();
			$$props.onclick({ _id: $$props._id, id: $$props.id, title: $$props.title });

			return false;
		}

		Ui_box($$anchor, {
			onclick: click,
			onkeyup: click,
			class: 'list-item-selectable',

			children: ($$anchor, $$slotProps) => {
				var span = root_1$f();
				var text = child(span, true);

				reset(span);
				template_effect(() => set_text(text, $$props.title));
				append($$anchor, span);
			},

			$$slots: { default: true }
		});

		pop();
	}

	var root$o = from_html(`<!> <!>`, 1);

	function Ui_endless_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [data]
		 * @property {any} [itemComponent = UIEndlessListSimpleItem] - list element
		 * @property {any} [itemComponentProps]
		 * @property {any} [emptyListPlaceholderComponent = UIEndlessListEmptyPlaceholder] - if list is empty
		 * @property {any} [emptyListPlaceholderComponentProps]
		 * @property {any} [listNavigationComponent = UIEndlessListNavigation] - prev and next block
		 * @property {any} [listNavigationComponentProps]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			data = prop($$props, 'data', 31, () => proxy({ list: [], skip: 0, count: 0, page: 0, pages: 0 })),
			UIItemComponent = prop($$props, 'itemComponent', 3, Ui_endless_list_simple_item),
			itemComponentProps = prop($$props, 'itemComponentProps', 19, () => ({})),
			UIEmptyListPlaceholder = prop($$props, 'emptyListPlaceholderComponent', 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, 'emptyListPlaceholderComponentProps', 19, () => ({})),
			UINavigationComponent = prop($$props, 'listNavigationComponent', 3, Ui_endless_list_navigation),
			listNavigationComponentProps = prop($$props, 'listNavigationComponentProps', 19, () => ({}));

		var fragment = root$o();
		var node = first_child(fragment);

		Ui_block(node, {
			get class() {
				return classes();
			},

			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 19, () => data().list, (item) => item.id, ($$anchor, item, index) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							{
								var consequent = ($$anchor) => {
									var fragment_4 = comment();
									var node_4 = first_child(fragment_4);

									snippet(node_4, () => $$props.itemRenderer, () => get$3(item), () => get$3(index));
									append($$anchor, fragment_4);
								};

								var alternate = ($$anchor) => {
									var fragment_5 = comment();
									var node_5 = first_child(fragment_5);

									component(node_5, UIItemComponent, ($$anchor, UIItemComponent_1) => {
										UIItemComponent_1($$anchor, spread_props(
											{
												get onclick() {
													return $$props.onselect;
												}
											},
											itemComponentProps,
											() => get$3(item)
										));
									});

									append($$anchor, fragment_5);
								};

								if_block(node_3, ($$render) => {
									if ($$props.itemRenderer) $$render(consequent); else $$render(alternate, false);
								});
							}

							append($$anchor, fragment_3);
						});

						append($$anchor, fragment_2);
					};

					var alternate_1 = ($$anchor) => {
						var fragment_6 = comment();
						var node_6 = first_child(fragment_6);

						component(node_6, UIEmptyListPlaceholder, ($$anchor, UIEmptyListPlaceholder_1) => {
							UIEmptyListPlaceholder_1($$anchor, spread_props(emptyListPlaceholderComponentProps));
						});

						append($$anchor, fragment_6);
					};

					if_block(node_1, ($$render) => {
						if (data()?.list?.length) $$render(consequent_1); else $$render(alternate_1, false);
					});
				}

				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});

		var node_7 = sibling(node, 2);

		component(node_7, UINavigationComponent, ($$anchor, UINavigationComponent_1) => {
			UINavigationComponent_1($$anchor, spread_props(listNavigationComponentProps, {
				get onprev() {
					return $$props.onprev;
				},

				get onnext() {
					return $$props.onnext;
				},

				get page() {
					return data().page;
				},

				set page($$value) {
					data(data().page = $$value, true);
				},

				get pages() {
					return data().pages;
				},

				set pages($$value) {
					data(data().pages = $$value, true);
				},

				get skip() {
					return data().skip;
				},

				set skip($$value) {
					data(data().skip = $$value, true);
				},

				get count() {
					return data().count;
				},

				set count($$value) {
					data(data().count = $$value, true);
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	function Ui_list_select($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {string}       [fieldname = "list-select"]                             field name
		 * @property {boolean}      [multiple = false]                                      if want not one variant selected
		 * @property {boolean}      [atLeastOne = true]                                     no empty result
		 * @property {array<import('./types.js').Variants>} [variants = []]           variants to select from
		 * @property {array<object>} value                                                  [...selectedItemsValues]
		 * @property {array<string|number>} [selectedVariantsIds = []]                      [...selectedItemsIds]
		 * @property {function}     [titleComponent = UITitle]
		 * @property {object}       [titleComponentProps= { size: 5 }]
		 * @property {function}     [imageComponent = UIImage]
		 * @property {object}       [imageComponentProps= { covered: true }]
		 * @property {function}     [listComponent = UIList]
		 * @property {object}       [listComponentProps = {actionsVisible: true}]
		 * @property {function}     [sublimeValue = (value) => value.id]
		 * @property {function}     [updateVariant = (valueId, props, toggleTitle) => void]
		 * @property {function}     [getItemIndex = (items, valueId) => number]
		 * @property {function}     [getItem = (items, { valueId }) => object]
		 * @property {function}     [getItemValue = (items, { valueId }) => object]
		 * @property {function}     [getDefaultItemSublime = (items) => string]
		 * @property {function}     [updateVariant = (items, valueId, props, toggleTitle) => void]
		 * @property {function}     [uiOn = (items, { valueId }) => void]
		 * @property {function}     [uiOff = (items, { valueId }) => void]
		 * @property {function}     [extendVariantToItemList = (item) => object]
		 */
		let items = state(proxy([]));

		/** @type {Props} */
		let fieldname = prop($$props, 'fieldname', 3, "list-select"),
			multiple = prop($$props, 'multiple', 3, false),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			variants = prop($$props, 'variants', 19, () => []),
			//variants to select from
			value = prop($$props, 'value', 23, () => []),
			//selected objects
			selectedVariantsIds = prop($$props, 'selectedVariantsIds', 23, () => []),
			//only ids of selected variants
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({ actionsVisible: true })),
			sublimeValue = prop($$props, 'sublimeValue', 3, (value) => value.id //object -> id
			),
			getItemIndex = prop($$props, 'getItemIndex', 3, (items, valueId) => items.findIndex((val) => val.value.id === valueId)),
			getItem = prop($$props, 'getItem', 3, (items, { valueId }) => {
				const index = getItemIndex()(items, valueId);

				//returns variants by its id
				return index > -1
					? items.find((btnVal) => btnVal.value.id === valueId)
					: undefined;
			}),
			getItemValue = prop($$props, 'getItemValue', 3, (items, { valueId }) => {
				// returns variant's value by id of variant
				const item = getItem()(items, { valueId });

				return item ? item.value : undefined;
			}),
			getDefaultItemSublime = prop($$props, 'getDefaultItemSublime', 3, (items) => {
				return items && items.length ? items[0].id : undefined;
			}),
			updateVariant = prop($$props, 'updateVariant', 3, (items, valueId, itemProps, buttonProps) => {
				const index = getItemIndex()(items, valueId);

				if (index === -1) {
					return;
				}

				Object.keys(itemProps).forEach((key) => {
					items[index][key] = itemProps[key];
				});

				if (Array.isArray(items[index].actions) && items[index].actions.length) {
					Object.keys(buttonProps).forEach((key) => {
						items[index].actions[0][key] = buttonProps[key];
					});
				}
			}),
			uiOn = prop($$props, 'uiOn', 3, (items, { valueId }) => {
				updateVariant()(items, valueId, { class: "has-background-success" }, { title: "not-node:booleans_true", color: "success" });
			}),
			uiOff = prop($$props, 'uiOff', 3, (items, { valueId }) => {
				updateVariant()(items, valueId, { class: "" }, { title: "not-node:booleans_false", color: "danger" });
			}),
			extendVariantToItemList = prop($$props, 'extendVariantToItemList', 3, (itm) => {
				const res = { ...itm };

				res.actions = [
					{
						title: "not-node:booleans_false",
						color: "danger",
						light: true,
						action: toggle
					}
				];

				return res;
			}),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'fieldname',
				'multiple',
				'atLeastOne',
				'variants',
				'value',
				'selectedVariantsIds',
				'titleComponentProps',
				'imageComponent',
				'imageComponentProps',
				'listComponent',
				'listComponentProps',
				'sublimeValue',
				'getItemIndex',
				'getItem',
				'getItemValue',
				'getDefaultItemSublime',
				'updateVariant',
				'uiOn',
				'uiOff',
				'extendVariantToItemList',
				'onchange'
			]);

		onMount(() => {
			set(items, variants().map(extendVariantToItemList()), true);

			if (value() && Array.isArray(value())) {
				if (atLeastOne() && value().length) {
					value().forEach((itemValue) => {
						let ui = updateSelected(itemValue);

						updateUI(ui);
					});
				}

				return;
			}

			selectDefault();
		});

		//
		function countOfSelected() {
			return Array.isArray(value()) ? selectedVariantsIds().length : 0;
		}

		const notLastOne = () => !(atLeastOne() && countOfSelected() === 1);

		//
		function updateSelected(detail) {
			const valueId = sublimeValue()(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (!Array.isArray(selectedVariantsIds())) {
				selectedVariantsIds([]);
			}

			if (multiple()) {
				if (selectedVariantsIds().includes(valueId)) {
					if (notLastOne()) {
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
						ui.off = { valueId };
					}
				} else {
					selectedVariantsIds().push(valueId);
					ui.on = { valueId };
				}
			} else {
				if (atLeastOne()) {
					if (!selectedVariantsIds().includes(valueId)) {
						if (countOfSelected() > 0) {
							ui.off = { valueId: selectedVariantsIds().pop() };
						}

						ui.on = { valueId };
						selectedVariantsIds([valueId]);
					}
				} else {
					if (selectedVariantsIds().includes(valueId)) {
						ui.off = { valueId };
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
					} else {
						ui.on = { valueId };
						selectedVariantsIds().push(valueId);
					}
				}
			}

			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);

			updateUI(ui);

			//
			updateValue();

			//
			$$props.onchange({
				field: fieldname(),
				value: snapshot(value()),
				ids: snapshot(selectedVariantsIds())
			});
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(get$3(items), changes.off);
			}

			if (changes.on) {
				uiOn()(get$3(items), changes.on);
			}
		}

		//
		function updateValue() {
			let newVal = [];

			if (typeof selectedVariantsIds() !== "undefined" && Array.isArray(selectedVariantsIds())) {
				newVal = selectedVariantsIds().filter((val) => typeof val !== "undefined").map((valueId) => getItemValue()(get$3(items), { valueId }));
			}

			value(newVal);
		}

		//
		function selectDefault() {
			if (atLeastOne() && get$3(items).length > 0) {
				const defValueId = getDefaultItemSublime()(get$3(items));

				if (defValueId) {
					toggle({ id: defValueId });
				}
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		component(node, UIListComponent, ($$anchor, UIListComponent_1) => {
			UIListComponent_1($$anchor, spread_props(
				{
					get titleComponentProps() {
						return titleComponentProps();
					},

					get imageComponent() {
						return imageComponent();
					},

					get imageComponentProps() {
						return imageComponentProps();
					}
				},
				() => others,
				listComponentProps,
				{
					get items() {
						return get$3(items);
					}
				}
			));
		});

		append($$anchor, fragment);
		pop();
	}

	/**
	 * Collection of static methods to work with SelectorGroups objects
	 *
	 * @class ListGroupsUITreeDTO
	 */
	let ListGroupsUITreeDTO = /*#__PURE__*/function () {
	  function ListGroupsUITreeDTO() {
	    _classCallCheck(this, ListGroupsUITreeDTO);
	  }
	  return _createClass(ListGroupsUITreeDTO, null, [{
	    key: "convertGroupTitle",
	    value:
	    /**
	     *
	     * Returns title field from object as string
	     * @static
	     * @param {Object}  val
	     * @param {string}  val.title
	     * @return {string}
	     * @memberof ListGroupsUITreeDTO
	     */
	    function convertGroupTitle({
	      title
	    }) {
	      return title;
	    } //refactored

	    /**
	     *
	     * Returns image field from object as string
	     * @static
	     * @param {Object}  val
	     * @param {string}  val.image
	     * @return {string}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertGroupImage",
	    value: function convertGroupImage({
	      image
	    }) {
	      return image;
	    } //refactored

	    /**
	     * Converts variant object to selector item object
	     *
	     * @static
	     * @param {import('../../types.js').Variant} variant
	     * @return {import('../../types.js').SelectorItem}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertVariant",
	    value: function convertVariant(variant, groupId) {
	      return {
	        id: variant.id,
	        title: variant.title,
	        value: {
	          valueId: variant.id,
	          groupId
	        } //what we will sublime
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').VariantsGroup} group
	     * @return {import('../../types.js').SelectorGroup}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertVariantsGroup",
	    value: function convertVariantsGroup(group) {
	      var _this = this;
	      return {
	        id: group.id,
	        title: this.convertGroupTitle(group),
	        image: this.convertGroupImage(group),
	        description: {
	          values: group.variants.map(function (itm) {
	            return _this.convertVariant(itm, group.id);
	          })
	        }
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').VariantsGroups} variants
	     * @return {import('../../types.js').SelectorGroups}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "buildSelectorItemsFromVariants",
	    value: function buildSelectorItemsFromVariants(variants) {
	      var _this2 = this;
	      return variants.map(function (itm) {
	        return _this2.convertVariantsGroup(itm);
	      });
	    } //refactored

	    /**
	     *
	     * Returns {group: number, id: number} as SelectedVariant type {groupId: string|number, valueId: string|number}
	     * @static
	     * @param   {object} value
	     * @return  {import('../../types.js').SelectedVariant}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "sublimeValue",
	    value: function sublimeValue(value) {
	      return {
	        groupId: value.group || value.groupId,
	        valueId: value.id || value.valueId
	      };
	    } //refactored

	    /**
	     * Returns index of group in array by groupId or undefined if its not found
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} groupId
	     * @static
	     * @returns {number|undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroupIndex",
	    value: function getSelectorGroupIndex(selectorGroupsItems, groupId) {
	      const index = selectorGroupsItems.findIndex(function (group) {
	        return group.id === groupId;
	      });
	      return index > -1 ? index : undefined;
	    } //refactored

	    /**
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} index
	     * @return {import('../../types.js').SelectorGroup}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroup",
	    value: function getSelectorGroup(selectorGroupsItems, index) {
	      return selectorGroupsItems[index];
	    } //refactored

	    /**
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroup} group
	     * @return {boolean}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "selectorGroupHasVariants",
	    value: function selectorGroupHasVariants(group) {
	      return group && group.description && Array.isArray(group.description.values);
	    } //refactored

	    /**
	     *
	     *
	     * @param {import('../../types.js').SelectorGroup} group
	     * @return {import("../../types.js").SelectorItems}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroupVariants",
	    value: function getSelectorGroupVariants(group) {
	      return group.description.values;
	    }

	    /**
	     * Returns comparation function, (val: SelectorItem)=>boolean,
	     * which checks if val has specified variantId
	     *
	     * @static
	     * @param {import('../../types.js').VariantId} variantId
	     * @return {function}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "compareSelectorGroupValueIdWith",
	    value: function compareSelectorGroupValueIdWith(variantId) {
	      return function (val) {
	        return val?.value?.valueId === variantId;
	      };
	    } //refactored

	    /**
	     * Returns index of item in group by groupIndex and item valueId or undefined if its not found
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} groupIndex
	     * @param {import('../../types.js').VariantId} valueId
	     * @returns {number|undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItemIndex",
	    value: function getSelectorItemIndex(selectorGroupsItems, groupIndex, valueId) {
	      const group = this.getSelectorGroup(selectorGroupsItems, groupIndex);
	      if (!this.selectorGroupHasVariants(group)) {
	        return undefined;
	      }
	      const itemIndex = this.getSelectorGroupVariants(group).findIndex(this.compareSelectorGroupValueIdWith(valueId));
	      return itemIndex > -1 ? itemIndex : undefined;
	    } //refactored

	    /**
	     * Returns {groupIndex: number, itemIndex: number} or undefined from VariantsGroups by groupId, valueId
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').VariantId} groupId
	     * @param {import('../../types.js').VariantId} valueId
	     * @return {import('../../types.js').ItemIndexes | undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItemIndexes",
	    value: function getSelectorItemIndexes(selectorGroupsItems, groupId, valueId) {
	      const groupIndex = this.getSelectorGroupIndex(selectorGroupsItems, groupId);
	      if (groupIndex === -1 || typeof groupIndex === "undefined") {
	        return undefined;
	      }
	      const itemIndex = this.getSelectorItemIndex(selectorGroupsItems, groupIndex, valueId);
	      if (itemIndex === -1 || typeof itemIndex === "undefined") {
	        return undefined;
	      }
	      return {
	        groupIndex,
	        itemIndex
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups}   selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}       itemIds
	     * @return {import('../../types.js').SelectorItem}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItem",
	    value: function getSelectorItem(selectorGroupsItems, itemIds) {
	      /** @type {import('../../types.js').ItemIndexes | undefined} */
	      const indexes = this.getSelectorItemIndexes(selectorGroupsItems, itemIds.groupId, itemIds.valueId);
	      if (indexes) {
	        const group = this.getSelectorGroup(selectorGroupsItems, indexes.groupIndex);
	        if (!this.selectorGroupHasVariants(group)) {
	          return undefined;
	        }
	        const groupVariants = this.getSelectorGroupVariants(group);
	        return groupVariants[indexes.itemIndex];
	      }
	      return undefined;
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @return {import('../../types.js').SelectedVariant | undefined}
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "getDefaultSelectorItemSublime",
	    value: function getDefaultSelectorItemSublime(selectorGroupsItems) {
	      if (selectorGroupsItems && selectorGroupsItems.length && this.selectorGroupHasVariants(selectorGroupsItems[0])) {
	        const groupId = selectorGroupsItems[0].id;
	        const valueId = selectorGroupsItems[0].description.values[0]?.value?.valueId;
	        if (UICommon$1.stringsOfNumbers([groupId, valueId])) {
	          return {
	            groupId,
	            valueId
	          };
	        }
	      }
	      return undefined;
	    } //refactored

	    /**
	     * Changes selector items
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds} itemIds
	     * @param {object} itemProps
	     * @param {object} actionsUIProps
	     * @return {undefined}
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "updateSelectorItem",
	    value: function updateSelectorItem(selectorGroupsItems, itemIds, itemProps, actionsUIProps) {
	      const indexes = this.getSelectorItemIndexes(selectorGroupsItems, itemIds.groupId, itemIds.valueId);
	      if (typeof indexes === "undefined") {
	        return;
	      }
	      Object.keys(itemProps).forEach(function (key) {
	        selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex][key] = itemProps[key];
	      });
	      if (Array.isArray(selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex].actions) && selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex].actions.length) {
	        Object.keys(uiProps).forEach(function (key) {
	          selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex][0][key] = actionsUIProps[key];
	        });
	      }
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}   itemIds
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "uiOn",
	    value: function uiOn(selectorGroupsItems, itemIds) {
	      this.updateSelectorItem(selectorGroupsItems, itemIds, {
	        ...this.UI_PROPS_DELTA_ON
	      }, {
	        ...this.UI_PROPS_DELTA_ON_ACTION
	      });
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}   itemIds
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "uiOff",
	    value: function uiOff(selectorGroupsItems, itemIds) {
	      this.updateSelectorItem(selectorGroupsItems, itemIds, {
	        ...this.UI_PROPS_DELTA_OFF
	      }, {
	        ...this.UI_PROPS_DELTA_OFF_ACTION
	      });
	    } //refactored
	  }, {
	    key: "syncUIWithValue",
	    value: function syncUIWithValue(selectorGroups, itemInValue) {
	      for (const group of selectorGroups) {
	        const items = this.getSelectorGroupVariants(group);
	        for (const item of items) {
	          const itemIds = {
	            groupId: group.id,
	            valueId: item.id
	          };
	          if (itemInValue(itemIds)) {
	            this.uiOn(selectorGroups, itemIds);
	          } else {
	            this.uiOff(selectorGroups, itemIds);
	          }
	        }
	      }
	      return selectorGroups;
	    }
	  }]);
	}();
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_ON", {
	  class: "has-background-success"
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_OFF", {
	  class: ""
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_ON_ACTION", {
	  title: "not-node:booleans_true",
	  color: "success"
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_OFF_ACTION", {
	  title: "not-node:booleans_false",
	  color: "danger"
	});

	let ListGroupsValueDTOMultipleBehaviour = /*#__PURE__*/function () {
	  function ListGroupsValueDTOMultipleBehaviour() {
	    _classCallCheck(this, ListGroupsValueDTOMultipleBehaviour);
	  }
	  return _createClass(ListGroupsValueDTOMultipleBehaviour, null, [{
	    key: "countItemsInValue",
	    value: function countItemsInValue(value) {
	      if (value) {
	        return Object.values(value).reduce(function (a, b) {
	          return a += b.length;
	        }, 0);
	      } else {
	        return 0;
	      }
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value) {
	      return typeof value === "object" && Object.values(value).every(this.groupItemsIsValid) ? value : {};
	    }
	  }, {
	    key: "groupItemsIsValid",
	    value: function groupItemsIsValid(groupItems) {
	      if (!Array.isArray(groupItems)) {
	        return false;
	      }
	      return groupItems.every(function (itm) {
	        return UICommon$1.stringOrNumber(itm);
	      });
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item) {
	      return Object.hasOwn(value, item.groupId) && value[item.groupId].includes(item.valueId);
	    }
	  }, {
	    key: "clearFromEmptyGroups",
	    value: function clearFromEmptyGroups(value) {
	      var _this = this;
	      Object.keys(value).forEach(function (key) {
	        if (_this.groupIsEmpty(value[key])) {
	          delete value[key];
	        }
	      });
	    }
	  }, {
	    key: "groupIsEmpty",
	    value: function groupIsEmpty(group) {
	      if (group && Array.isArray(group)) {
	        if (group.length === 0) {
	          return true;
	        }
	      } else {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "groupIsFull",
	    value: function groupIsFull(valueGroup, variantsGroup) {
	      return valueGroup.length === variantsGroup?.variants?.length;
	    }
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      if (options.atLeastOne && this.countItemsInValue(value) === 1) {
	        return;
	      }
	      value[item.groupId].splice(value[item.groupId].indexOf(item.valueId), 1);
	      this.clearFromEmptyGroups(value, options);
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {*} value
	     * @param {*} item
	     * @param {import('../../types.js').ListGroupsOptions} options
	     * @memberof ListGroupsValueDTOMultipleBehaviour
	     */
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item, options) {
	      if (options.onlyOnePerGroup) {
	        value[item.groupId] = [item.valueId];
	      } else {
	        if (!value[item.groupId] || !Array.isArray(value[item.groupId])) {
	          value[item.groupId] = [item.valueId];
	        } else {
	          if (!value[item.groupId].includes(item.valueId)) {
	            value[item.groupId].push(item.valueId);
	          }
	        }
	      }
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll(variants, value, options) {
	      var _this2 = this;
	      variants.forEach(function (variantsGroup) {
	        variantsGroup.variants.forEach(function (variant) {
	          _this2.addItemToValue(value, {
	            valueId: variant.id,
	            groupId: variantsGroup.id
	          }, options);
	        });
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone(variants, value, options) {
	      Object.keys(value).forEach(function (groupId) {
	        delete value[groupId];
	      });
	    }
	  }, {
	    key: "selectAllInGroup",
	    value: function selectAllInGroup(variants, value, groupId, options) {
	      var _this3 = this;
	      if (!UICommon$1.stringOrNumber(groupId)) {
	        return;
	      }
	      const variantsGroup = variants.find(function (itm) {
	        return itm.id == groupId;
	      });
	      if (!variantsGroup || !variantsGroup.variants || !Array.isArray(variantsGroup.variants)) {
	        return;
	      }
	      variantsGroup.variants.forEach(function (variant) {
	        _this3.addItemToValue(value, {
	          groupId,
	          valueId: variant.id
	        });
	      });
	    }
	  }, {
	    key: "selectNoneInGroup",
	    value: function selectNoneInGroup(variants, value, groupId, options) {
	      if (value[groupId]) {
	        delete value[groupId];
	      }
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      var _this4 = this;
	      const result = {};
	      variants.forEach(function (group) {
	        if (_this4.groupIsEmpty(group.id)) return;
	        group.variants.forEach(function (variant) {
	          if (_this4.itemInValue(value, {
	            groupId: group.id,
	            valueId: variant.id
	          })) {
	            if (Array.isArray(result[group.id])) {
	              result[group.id].push(variant);
	            } else {
	              result[group.id] = [variant];
	            }
	          }
	        });
	      });
	      return result;
	    }
	  }]);
	}();

	let ListGroupsValueDTOSingleBehaviour = /*#__PURE__*/function () {
	  function ListGroupsValueDTOSingleBehaviour() {
	    _classCallCheck(this, ListGroupsValueDTOSingleBehaviour);
	  }
	  return _createClass(ListGroupsValueDTOSingleBehaviour, null, [{
	    key: "countItemsInValue",
	    value: function countItemsInValue(value) {
	      return value && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) ? 1 : 0;
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value) {
	      return value && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) ? value : {
	        valueId: undefined,
	        groupId: undefined
	      };
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item) {
	      return Object.hasOwn(value, "groupId") && Object.hasOwn(value, "valueId") && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) && value.groupId == item.groupId && value.valueId == item.valueId;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {*} value
	     * @param {*} item
	     * @param {import('../../types.js').ListGroupsOptions} options
	     * @memberof ListGroupsValueDTOSingleBehaviour
	     */
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      if (!options.atLeastOne) {
	        value[item.groupId].splice(value[item.groupId].indexOf(item.valueId), 1);
	      }
	    }
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item) {
	      if (typeof value === "undefined") {
	        value = this.initValue();
	      }
	      value.valueId = item.valueId;
	      value.groupId = item.groupId;
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      if (this.countItemsInValue(value)) {
	        return variants.find(function (group) {
	          return group.id === value.groupId;
	        }).variants.find(function (variant) {
	          return variant.id === value.valueId;
	        });
	      } else {
	        return {};
	      }
	    }
	  }]);
	}();

	let ListGroupsValueDTO = /*#__PURE__*/function () {
	  function ListGroupsValueDTO() {
	    _classCallCheck(this, ListGroupsValueDTO);
	  }
	  return _createClass(ListGroupsValueDTO, null, [{
	    key: "behaviour",
	    value: function behaviour(options) {
	      return options.multiple ? ListGroupsValueDTOMultipleBehaviour : ListGroupsValueDTOSingleBehaviour;
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value, options) {
	      return this.behaviour(options).initValue(value);
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item, options) {
	      return this.behaviour(options).itemInValue(value, item, options);
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectedValues} value
	     * @param {Object} item
	     * @param {ListGroupsOptions} options
	     * @memberof ListGroupsValueDTO
	     */
	  }, {
	    key: "toggle",
	    value: function toggle(value, item, options) {
	      if (this.itemInValue(value, item, options)) {
	        this.removeItemFromValue(value, item, options);
	      } else {
	        this.addItemToValue(value, item, options);
	      }
	    }
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      this.behaviour(options).removeItemFromValue(value, item, options);
	    }
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item, options) {
	      this.behaviour(options).addItemToValue(value, item, options);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll(variants, value, options) {
	      this.behaviour(options).selectAll(variants, value, options);
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone(variants, value, options) {
	      this.behaviour(options).selectNone(variants, value, options);
	    }
	  }, {
	    key: "selectAllInGroup",
	    value: function selectAllInGroup(variants, value, groupId, options) {
	      this.behaviour(options).selectAllInGroup(variants, value, groupId, options);
	    }
	  }, {
	    key: "selectNoneInGroup",
	    value: function selectNoneInGroup(variants, value, groupId, options) {
	      this.behaviour(options).selectNoneInGroup(variants, value, groupId, options);
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      return this.behaviour(options).valueAsVariants(value, variants);
	    }
	  }]);
	}();

	function Ui_list_select_with_groups($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {string}       [fieldname = "list-select"]                             field name
		 * @property {function}     [onchange]  callback on value change event
		 * @property {array<import('./types.js').VariantsGroups>}   [variants = []]           variants to select from
		 * @property {array<import('./types.js').SelectedValues}  [variantsSelected] - multiple && multiple in group
		 * @property {array<import('./types.js').SelectedVariants}  value - {[groupId]: [...valuesOfSelectedItems]}
		 * @property {object}       [behaviourUI = ListGroupsUITreeDTO]
		 * @property {object}       [behaviourValue = ListGroupsValueDTO]
		 * @property {boolean}      [multiple = false]                                      if want not one variant selected
		 * @property {boolean}      [onlyOnePerGroup = true]
		 * @property {boolean}      [atLeastOne = true]                                     no empty result
		 * @property {function}     [titleComponent = UITitle]
		 * @property {object}       [titleComponentProps= { size: 5 }]
		 * @property {function}     [imageComponent = UIImage]
		 * @property {object}       [imageComponentProps= { covered: true }]
		 * @property {function}     [descriptionComponent = UIButtons]
		 * @property {object}       [descriptionComponentProps = {}]
		 * @property {function}     [listComponent = UIList]
		 * @property {object}       [listComponentProps = {}]
		 */
		let selectorGroups = state(proxy([]));

		/** @type {Props} */
		let onchange = prop($$props, 'onchange', 3, () => true),
			fieldname = prop($$props, 'fieldname', 3, "list-select-tags"),
			variants = prop($$props, 'variants', 19, () => []),
			variantsSelected = prop($$props, 'variantsSelected', 23, () => ({})),
			value = prop($$props, 'value', 7),
			behaviourUI = prop($$props, 'behaviourUI', 3, ListGroupsUITreeDTO),
			behaviourValue = prop($$props, 'behaviourValue', 3, ListGroupsValueDTO),
			multiple = prop($$props, 'multiple', 3, false),
			onlyOnePerGroup = prop($$props, 'onlyOnePerGroup', 3, true),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({}));

		function updateUI() {
			set(
				selectorGroups,
				behaviourUI().syncUIWithValue(get$3(selectorGroups), (itemIds) => behaviourValue().itemInValue(value(), itemIds, {
					multiple: multiple(),
					onlyOnePerGroup: onlyOnePerGroup(),
					atLeastOne: atLeastOne()
				})),
				true
			);
		}

		onMount(() => {
			set(selectorGroups, behaviourUI().buildSelectorItemsFromVariants(variants()), true);

			value(behaviourValue().initValue(value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}));

			updateUI();
		});

		const valueAsVariants = () => behaviourValue().valueAsVariants(value(), variants());

		function triggerChange() {
			variantsSelected(valueAsVariants());
			onchange()({ field: fieldname(), value: value() });
		}

		const toggleItem = (itemValue) => {
			behaviourValue().toggle(value(), itemValue, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		var $$exports = { valueAsVariants, toggleItem };
		var fragment = comment();
		var node = first_child(fragment);

		{
			let $0 = user_derived(() => ({
				action(event, itemValue) {
					toggleItem(itemValue);
				},

				...descriptionComponentProps()
			}));

			component(node, UIListComponent, ($$anchor, UIListComponent_1) => {
				UIListComponent_1($$anchor, spread_props(listComponentProps, {
					get titleComponent() {
						return titleComponent();
					},

					get titleComponentProps() {
						return titleComponentProps();
					},

					get descriptionComponent() {
						return descriptionComponent();
					},

					get descriptionComponentProps() {
						return get$3($0);
					},

					get imageComponent() {
						return imageComponent();
					},

					get imageComponentProps() {
						return imageComponentProps();
					},

					get items() {
						return get$3(selectorGroups);
					}
				}));
			});
		}

		append($$anchor, fragment);

		return pop($$exports);
	}

	var root$n = from_html(`<!> <!>`, 1);

	function Ui_list_select_buttons_with_groups($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {function} [onchange]  callback on value change event
		 * @property {string} [fieldname="list-select-tags"]
		 * @property {import('../types').VariantsGroups} [variants = []] -
		 * @property {import('../types').SelectedValues} [variantsSelected = {}] - multiple && multiple in group
		 * @property {import('../types').SelectedVariants} [value = []]
		 * @property {object} [behaviourUI = ListGroupsUITreeDTO]
		 * @property {object} [behaviourValue = ListGroupsValueDTO]
		 * @property {boolean} [multiple = true]
		 * @property {boolean} [onlyOnePerGroup = true]
		 * @property {boolean} [atLeastOne = true]
		 * @property {function} [titleComponent = UITitle]
		 * @property {object} [titleComponentProps = { size: 5}]
		 * @property {function} [imageComponent = UIImage]
		 * @property {object} [imageComponentProps = { covered: true }]
		 * @property {function} [descriptionComponent = UIButtonsSwitchers]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [listComponent = UIList]
		 * @property {object} [listComponentProps = {}]
		 * @property {Array<string>} [actionsList=["selectAll", "selectNone"]]
		 */
		/** @type {Props} */
		let onchange = prop($$props, 'onchange', 3, () => true),
			fieldname = prop($$props, 'fieldname', 3, "list-select-tags"),
			variants = prop($$props, 'variants', 19, () => []),
			variantsSelected = prop($$props, 'variantsSelected', 23, () => ({})),
			value = prop($$props, 'value', 7),
			//behaviour managers
			behaviourUI = prop($$props, 'behaviourUI', 3, ListGroupsUITreeDTO),
			behaviourValue = prop($$props, 'behaviourValue', 3, ListGroupsValueDTO),
			//behaviour options
			multiple = prop($$props, 'multiple', 3, true),
			onlyOnePerGroup = prop($$props, 'onlyOnePerGroup', 3, true),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			//comopnents, renderers and props for them
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons_switchers),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({})),
			actionsList = prop($$props, 'actionsList', 19, () => ["selectAll", "selectNone"]);

		//
		const AVAILABLE_ACTIONS = {
			selectAll: {
				title: "Выбрать все",
				color: "success",

				action() {
					selectAll();
				}
			},

			selectNone: {
				title: "Снять выделение со всех",
				color: "",

				action() {
					selectNone();
				}
			}
		};

		let ACTIONS = state(proxy([]));
		let selectorGroups = state(proxy([]));

		function updateUI() {
			set(
				selectorGroups,
				behaviourUI().syncUIWithValue(get$3(selectorGroups), (itemIds) => behaviourValue().itemInValue(value(), itemIds, {
					multiple: multiple(),
					onlyOnePerGroup: onlyOnePerGroup(),
					atLeastOne: atLeastOne()
				})),
				true
			);
		}

		const valueAsVariants = () => behaviourValue().valueAsVariants(value(), variants());

		function triggerChange() {
			variantsSelected(valueAsVariants());
			onchange()({ field: fieldname(), value: value() });
		}

		onMount(() => {
			actionsList().forEach((name) => {
				Object.hasOwn(AVAILABLE_ACTIONS, name) ? get$3(ACTIONS).push(AVAILABLE_ACTIONS[name]) : false;
			});

			set(ACTIONS, get$3(ACTIONS), true);
			set(selectorGroups, behaviourUI().buildSelectorItemsFromVariants(variants()), true);
			value(behaviourValue().initValue(value(), { multiple: multiple() }));
			updateUI();
		});

		const selectAll = () => {
			behaviourValue().selectAll(variants(), value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectNone = () => {
			behaviourValue().selectNone(variants(), value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectAllInGroup = (groupId) => {
			behaviourValue().selectAllInGroup(variants(), value(), groupId, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectNoneInGroup = (groupId) => {
			behaviour.selectNoneInGroup(variants(), value(), groupId, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const toggleItem = (itemValue) => {
			behaviourValue().toggle(value(), itemValue, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		var $$exports = {
			valueAsVariants,
			selectAll,
			selectNone,
			selectAllInGroup,
			selectNoneInGroup,
			toggleItem
		};

		var fragment = root$n();
		var node = first_child(fragment);

		Ui_buttons(node, {
			get values() {
				return get$3(ACTIONS);
			},

			centered: true
		});

		var node_1 = sibling(node, 2);

		{
			let $0 = user_derived(() => ({
				action(event, itemValue) {
					toggleItem(itemValue);
				},

				...descriptionComponentProps()
			}));

			component(node_1, UIListComponent, ($$anchor, UIListComponent_1) => {
				UIListComponent_1($$anchor, spread_props(listComponentProps, {
					get titleComponent() {
						return titleComponent();
					},

					get titleComponentProps() {
						return titleComponentProps();
					},

					get descriptionComponent() {
						return descriptionComponent();
					},

					get descriptionComponentProps() {
						return get$3($0);
					},

					get imageComponent() {
						return imageComponent();
					},

					get imageComponentProps() {
						return imageComponentProps();
					},

					get items() {
						return get$3(selectorGroups);
					}
				}));
			});
		}

		append($$anchor, fragment);

		return pop($$exports);
	}

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIEndlessList: Ui_endless_list,
		UIEndlessListNavigation: Ui_endless_list_navigation,
		UIEndlessListSimpleItem: Ui_endless_list_simple_item,
		UIList: Ui_list,
		UIListBlock: Ui_list_block,
		UIListEmptyPlaceholder: Ui_list_empty_placeholder,
		UIListItem: Ui_list_item,
		UIListSelect: Ui_list_select,
		UIListSelectButtonsWithGroups: Ui_list_select_buttons_with_groups,
		UIListSelectWithGroups: Ui_list_select_with_groups
	});

	var root_1$e = from_html(`<div><!> <!></div>`);

	function Ui_overlay($$anchor, $$props) {
		push($$props, true);

		let overflowSave = state("");

		const defaultCloseButtonProps = {
			class: "is-absolute is-sided-right is-sided-top",
			style: "--siding-right-size: 2rem; --siding-top-size: 2rem",
			size: "normal"
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [closeButton = false]
		 * @property {object}   [closeButtonProps = defaultCloseButtonProps]
		 * @property {boolean}  [show = true]
		 * @property {boolean}  [closeOnClick = true]
		 * @property {number}   [layer = 1]
		 * @property {string}   [class = ""]
		 * @property {number}   [zIndexStep = 1000]
		 * @property {string}   [role = 'button']
		 * @property {string}   [tabIndex = 'button']
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let closeButton = prop($$props, 'closeButton', 3, false),
			closeButtonProps = prop($$props, 'closeButtonProps', 3, defaultCloseButtonProps),
			show = prop($$props, 'show', 7, true),
			closeOnClick = prop($$props, 'closeOnClick', 3, true),
			layer = prop($$props, 'layer', 3, 1),
			classes = prop($$props, 'class', 3, ""),
			onreject = prop($$props, 'onreject', 3, () => false),
			zIndexStep = prop($$props, 'zIndexStep', 3, 1000),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		function overlayClick(e) {
			if (closeOnClick()) {
				closeOverlay(e);
			}
		}

		function closeButtonClick() {
			rejectOverlay();
		}

		function closeOverlay(e) {
			try {
				if (e && e.originalTarget) {
					const target = e.originalTarget;

					if (target.classList && target.classList.contains("is-overlay")) {
						rejectOverlay();
					}
				}

				//eslint-disable-next-line no-empty
			} catch {}
		}

		function rejectOverlay(data = {}) {
			show(false);
			onreject()(data);
		}

		onMount(() => {
			set(overflowSave, document.body.style.overflow, true);

			if (show()) {
				document.body.style.overflow = "hidden";
			} else {
				document.body.style.overflow = get$3(overflowSave);
			}
		});

		onDestroy(() => {
			document.body.style.overflow = get$3(overflowSave);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$e();

				div.__click = overlayClick;
				div.__keyup = overlayClick;

				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						Ui_button_close($$anchor, spread_props(closeButtonProps, { onclick: closeButtonClick }));
					};

					if_block(node_1, ($$render) => {
						if (closeButton()) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				snippet(node_2, () => $$props.children ?? noop);
				reset(div);

				template_effect(() => {
					set_class(div, 1, `is-overlay not-overlay ${classes() ?? ''}`);
					set_attribute(div, 'role', role());
					set_attribute(div, 'tabindex', tabIndex());
					set_style(div, `z-index: ${zIndexStep() * layer()};`);
				});

				transition(3, div, () => fade);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_5$6 = from_html(`<!> <!> <!> <!>`, 1);
	var root_3$6 = from_html(`<!> <!> <!>`, 1);

	function Ui_modal($$anchor, $$props) {
		const buttons = ($$anchor, $$arg0) => {
			let moreClassess = derived_safe_equal(() => fallback($$arg0?.(), ""));

			{
				let $0 = user_derived(() => buttonsClass() || get$3(moreClassess));
				let $1 = user_derived(() => closeButton() ? [closeButton()] : []);
				let $2 = user_derived(() => applyButton() ? [applyButton()] : []);

				Ui_buttons_row($$anchor, {
					get class() {
						return get$3($0);
					},

					get left() {
						return get$3($1);
					},

					get right() {
						return get$3($2);
					}
				});
			}
		};

		let buttonsPosition = prop($$props, 'buttonsPosition', 3, "bottom"),
			fullscreen = prop($$props, 'fullscreen', 3, false),
			closeButton = prop($$props, 'closeButton', 3, false),
			applyButton = prop($$props, 'applyButton', 3, false),
			titleSize = prop($$props, 'titleSize', 3, 2),
			show = prop($$props, 'show', 3, false),
			loading = prop($$props, 'loading', 3, false),
			title = prop($$props, 'title', 3, "Modal window"),
			subtitle = prop($$props, 'subtitle', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			overlayClass = prop($$props, 'overlayClass', 3, ""),
			buttonsClass = prop($$props, 'buttonsClass', 3, ""),
			WAITING_TEXT = prop($$props, 'WAITING_TEXT', 3, "Обработка");

		Ui_overlay($$anchor, {
			get show() {
				return show();
			},

			closeOnClick: false,
			closeButton: false,

			get class() {
				return overlayClass();
			},

			children: ($$anchor, $$slotProps) => {
				{
					let $0 = user_derived(() => `${classes()} ${fullscreen() ? "is-fullscreen" : ""}`);

					Ui_box($$anchor, {
						get class() {
							return get$3($0);
						},

						children: ($$anchor, $$slotProps) => {
							var fragment_3 = root_3$6();
							var node = first_child(fragment_3);

							{
								var consequent = ($$anchor) => {
									buttons($$anchor, () => "");
								};

								if_block(node, ($$render) => {
									if (buttonsPosition() === "top") $$render(consequent);
								});
							}

							var node_1 = sibling(node, 2);

							Ui_title(node_1, {
								get size() {
									return titleSize();
								},

								get title() {
									return title();
								},

								get subtitle() {
									return subtitle();
								}
							});

							var node_2 = sibling(node_1, 2);

							Ui_content(node_2, {
								children: ($$anchor, $$slotProps) => {
									var fragment_5 = root_5$6();
									var node_3 = first_child(fragment_5);

									Ui_loader(node_3, {
										size: 'page',

										get loading() {
											return loading();
										},

										get title() {
											return WAITING_TEXT();
										}
									});

									var node_4 = sibling(node_3, 2);

									{
										var consequent_1 = ($$anchor) => {
											buttons($$anchor, () => "");
										};

										if_block(node_4, ($$render) => {
											if (buttonsPosition() === "topOfContent") $$render(consequent_1);
										});
									}

									var node_5 = sibling(node_4, 2);

									snippet(node_5, () => $$props.children ?? noop);

									var node_6 = sibling(node_5, 2);

									{
										var consequent_2 = ($$anchor) => {
											buttons($$anchor, () => `is-mobile ${fullscreen() ? "is-footer" : ""}`);
										};

										if_block(node_6, ($$render) => {
											if (buttonsPosition() === "bottom") $$render(consequent_2);
										});
									}

									append($$anchor, fragment_5);
								},

								$$slots: { default: true }
							});

							append($$anchor, fragment_3);
						},

						$$slots: { default: true }
					});
				}
			},

			$$slots: { default: true }
		});
	}

	var root_2$a = from_html(`<!> <!> <!>`, 1);

	function Ui_generic_selector($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef     {Object} Props
		 * @property    {boolean}   [show]
		 * @property    {boolean}   [showSearch = true]
		 * @property    {string}    [term]
		 * @property    {(fullscreen|wide|normal|narrow)} [size]   100vw, 75vw, 50vw, 25vw
		 * @property    {any}       [inputComponent]
		 * @property    {object}    [inputComponentProps]
		 * @property    {any}       [outputComponent]
		 * @property    {object}    [outputComponentProps]
		 * @property    {object}    [buttonsProps = { centered: true, class: "mt-5",}]
		 * @property    {object}    [results]
		 * @property    {function}  [onprev]
		 * @property    {function}  [onnext]
		 * @property    {function}  [onchange]
		 * @property    {function}  [onreject]
		 * @property    {function}  [onresolve]
		 */
		/** @type {Props} */
		let show = prop($$props, 'show', 3, true),
			showSearch = prop($$props, 'showSearch', 3, true),
			term = prop($$props, 'term', 15, ""),
			size = prop($$props, 'size', 3, "narrow"),
			UIInputComponent = prop($$props, 'inputComponent', 3, Ui_simple_search_input),
			inputComponentProps = prop($$props, 'inputComponentProps', 19, () => ({})),
			UIOutputComponent = prop($$props, 'outputComponent', 3, Ui_endless_list),
			outputComponentProps = prop($$props, 'outputComponentProps', 19, () => ({})),
			buttonsProps = prop($$props, 'buttonsProps', 19, () => ({ centered: true, class: "mt-5" })),
			rejectButtonProps = prop($$props, 'rejectButtonProps', 19, () => ({})),
			results = prop($$props, 'results', 31, () => proxy({ list: [], page: 0, pages: 0, skip: 0, count: 0 }));

		const buttons = [
			{
				title: $LOCALE()["not-node:button_cancel_label"],
				action: $$props.onreject,
				...rejectButtonProps()
			}
		];

		Ui_overlay($$anchor, {
			get onreject() {
				return $$props.onreject;
			},

			get show() {
				return show();
			},

			closeOnClick: true,
			closeButton: false,

			children: ($$anchor, $$slotProps) => {
				Ui_box($$anchor, {
					get class() {
						return `modal-selector ${size() ?? ''}`;
					},

					children: ($$anchor, $$slotProps) => {
						var fragment_2 = root_2$a();
						var node = first_child(fragment_2);

						{
							var consequent = ($$anchor) => {
								var fragment_3 = comment();
								var node_1 = first_child(fragment_3);

								component(node_1, UIInputComponent, ($$anchor, UIInputComponent_1) => {
									UIInputComponent_1($$anchor, spread_props(
										{
											get onchange() {
												return $$props.onchange;
											}
										},
										inputComponentProps,
										{
											get term() {
												return term();
											},

											set term($$value) {
												term($$value);
											}
										}
									));
								});

								append($$anchor, fragment_3);
							};

							if_block(node, ($$render) => {
								if (showSearch()) $$render(consequent);
							});
						}

						var node_2 = sibling(node, 2);

						component(node_2, UIOutputComponent, ($$anchor, UIOutputComponent_1) => {
							UIOutputComponent_1($$anchor, spread_props(
								{
									get onprev() {
										return $$props.onprev;
									},

									get onnext() {
										return $$props.onnext;
									},

									get onselect() {
										return $$props.onresolve;
									},

									class: 'has-height-up-to-60 overflow-scroll'
								},
								outputComponentProps,
								{
									get itemRenderer() {
										return $$props.itemRenderer;
									},

									get data() {
										return results();
									},

									set data($$value) {
										results($$value);
									}
								}
							));
						});

						var node_3 = sibling(node_2, 2);

						Ui_buttons(node_3, spread_props(buttonsProps, {
							get values() {
								return buttons;
							}
						}));

						append($$anchor, fragment_2);
					},

					$$slots: { default: true }
				});
			},

			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIGenericSelector: Ui_generic_selector,
		UIModal: Ui_modal,
		UIOverlay: Ui_overlay
	});

	var root$m = from_html(`<div><!></div>`);

	function Ui_navbar_brand_wrapper($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 */
		/** @type {Props} */
		let classPrefix = prop($$props, 'classPrefix', 3, "navbar-brand"),
			classes = prop($$props, 'class', 3, ""),
			other = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'classPrefix',
				'class',
				'children'
			]);

		var div = root$m();

		attribute_effect(div, ($0) => ({ class: $0, ...other }), [() => [classPrefix(), classes()].join(" ")]);

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
		pop();
	}

	var root_2$9 = from_html(`<span> </span>`);
	var root$l = from_html(`<a aria-label="brand"><!> <!></a>`);

	function Ui_navbar_brand_item($$anchor, $$props) {
		push($$props, true);

		/* eslint svelte/no-at-html-tags: 0 */
		/**
		 * @typedef {Object} Props
		 * @property {string} [url]
		 * @property {string} [title]
		 * @property {any} [icon]
		 */
		/** @type {Props} */
		let url = prop($$props, 'url', 3, "/"),
			title = prop($$props, 'title', 3, ""),
			icon = prop($$props, 'icon', 19, () => ({ src: "https://placehold.co/56x56.png", width: 56, height: 56 })),
			classPrefix = prop($$props, 'classPrefix', 3, "navbar-item"),
			titleClass = prop($$props, 'titleClass', 3, "navbar-item-brand-title"),
			classes = prop($$props, 'class', 3, "");

		var a = root$l();
		var node = child(a);

		{
			var consequent = ($$anchor) => {
				Ui_icon($$anchor, spread_props(icon));
			};

			if_block(node, ($$render) => {
				if (icon()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var span = root_2$9();
				var text = child(span, true);

				reset(span);

				template_effect(() => {
					set_class(span, 1, clsx(titleClass()));
					set_text(text, title());
				});

				append($$anchor, span);
			};

			if_block(node_1, ($$render) => {
				if (title()) $$render(consequent_1);
			});
		}

		reset(a);

		template_effect(
			($0) => {
				set_class(a, 1, $0);
				set_attribute(a, 'href', url());
			},
			[() => clsx([classPrefix(), classes()].join(" "))]
		);

		append($$anchor, a);
		pop();
	}

	var root_1$d = from_html(`<!> <!>`, 1);

	function Ui_navbar_brand($$anchor, $$props) {
		Ui_navbar_brand_wrapper($$anchor, {
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$d();
				var node = first_child(fragment_1);

				Ui_navbar_brand_item(node, spread_props(() => $$props.brand));

				var node_1 = sibling(node, 2);

				snippet(node_1, () => $$props.children ?? noop);
				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});
	}

	function Ui_navbar_item_link($$anchor, $$props) {
		push($$props, true);

		let classPrefix = prop($$props, 'classPrefix', 3, "navbar-item"),
			classes = prop($$props, 'class', 3, ""),
			target = prop($$props, 'target', 3, "_self"),
			other = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'classPrefix',
				'class',
				'children',
				'target'
			]);

		{
			let $0 = user_derived(() => [classPrefix(), classes()].join(" "));

			Ui_link($$anchor, spread_props(
				{
					get class() {
						return get$3($0);
					},

					get target() {
						return target();
					}
				},
				() => other,
				{
					children: ($$anchor, $$slotProps) => {
						var fragment_1 = comment();
						var node = first_child(fragment_1);

						snippet(node, () => $$props.children ?? noop);
						append($$anchor, fragment_1);
					},

					$$slots: { default: true }
				}
			));
		}

		pop();
	}

	var root$k = from_html(`<div><!></div>`);

	function Ui_navbar_item_wrapper($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = ""]
		 * @property {string}   [classPrefix = "navbar-item"]
		 * @property {string}   [hidden = ""]
		 * @property {string}   [class = ""]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex = 0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classPrefix = prop($$props, 'classPrefix', 3, "navbar-item"),
			hidden = prop($$props, 'hidden', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0);

		const onKeyUp = $$props.onkeyup ?? ($$props.onclick ? UICommon$1.onlyOnEnter($$props.onclick) : undefined);
		var div = root$k();

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(
			($0) => {
				set_attribute(div, 'id', id());
				set_class(div, 1, $0);
				set_attribute(div, 'role', role());
				set_attribute(div, 'tabindex', tabIndex());
			},
			[
				() => clsx([
					classPrefix(),
					hidden() ? `is-hidden-${hidden()}` : "",
					classes()
				].join(" "))
			]
		);

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_1$c = from_html(`<!> <!> <!>`, 1);

	function Ui_navbar_item_content($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_4 = ($$anchor) => {
				var fragment_1 = root_1$c();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_icon($$anchor, spread_props(() => $$props.item.icon));
					};

					var alternate_1 = ($$anchor) => {
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								const SvelteComponent = user_derived(() => COMPONENTS$1.get($$props.item.component));
								var fragment_4 = comment();
								var node_3 = first_child(fragment_4);

								component(node_3, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
									SvelteComponent_1($$anchor, spread_props(
										{
											get id() {
												return $$props.item.id;
											}
										},
										() => $$props.item.props
									));
								});

								append($$anchor, fragment_4);
							};

							var alternate = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[$$props.item.title]));
								append($$anchor, text$1);
							};

							if_block(
								node_2,
								($$render) => {
									if ($$props.item.type === "component" && $$props.item.component && COMPONENTS$1.contains($$props.item.component)) $$render(consequent_1); else $$render(alternate, false);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if ($$props.item.icon) $$render(consequent); else $$render(alternate_1, false);
					});
				}

				var node_4 = sibling(node_1, 2);

				{
					var consequent_2 = ($$anchor) => {
						Ui_tag($$anchor, spread_props(
							{
								top: true,
								right: true,
								size: 'small',

								get id() {
									return $$props.item.id;
								}
							},
							() => $$props.item.tag
						));
					};

					if_block(node_4, ($$render) => {
						if ($$props.item.tag) $$render(consequent_2);
					});
				}

				var node_5 = sibling(node_4, 2);

				{
					var consequent_3 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return $$props.item.id;
								}
							},
							() => $$props.item.indicator
						));
					};

					if_block(node_5, ($$render) => {
						if ($$props.item.indicator) $$render(consequent_3);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_2 = ($$anchor) => {
				var fragment_8 = comment();
				var node_6 = first_child(fragment_8);

				snippet(node_6, () => $$props.children ?? noop);
				append($$anchor, fragment_8);
			};

			if_block(node, ($$render) => {
				if ($$props.item) $$render(consequent_4); else $$render(alternate_2, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$j = from_html(`<hr/>`);

	function Ui_navbar_item_devider($$anchor, $$props) {
		let classPrefix = prop($$props, 'classPrefix', 3, "navbar-divider");
		var hr = root$j();

		template_effect(() => set_class(hr, 1, `${classPrefix() ?? ''} ${$$props.hidden ? `is-hidden-${$$props.hidden}` : ''}`));
		append($$anchor, hr);
	}

	function Ui_navbar_item($$anchor, $$props) {
		push($$props, true);

		prop($$props, 'class', 3, "");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_navbar_item_devider($$anchor, spread_props(() => $$props.item));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_navbar_item_link($$anchor, spread_props({ button: false }, () => $$props.item, {
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = comment();
								var node_2 = first_child(fragment_4);

								snippet(node_2, () => $$props.children ?? noop);
								append($$anchor, fragment_4);
							},

							$$slots: { default: true }
						}));
					};

					var alternate = ($$anchor) => {
						Ui_navbar_item_wrapper($$anchor, {
							get item() {
								return $$props.item;
							},

							children: ($$anchor, $$slotProps) => {
								Ui_navbar_item_content($$anchor, {
									get item() {
										return $$props.item;
									}
								});
							},

							$$slots: { default: true }
						});
					};

					if_block(
						node_1,
						($$render) => {
							if (typeof $$props.item.href === "string") $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if ($$props.item.break) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$b = from_html(`<div><!> <div><!></div></div>`);

	function Ui_navbar_item_has_dropdown($$anchor, $$props) {
		push($$props, true);

		let hoverable = prop($$props, 'hoverable', 3, true),
			dropUp = prop($$props, 'dropUp', 3, false),
			boxed = prop($$props, 'boxed', 3, false),
			root = prop($$props, 'root', 7, "/"),
			onclick = prop($$props, 'onclick', 7);

		onMount(() => {
			if (hasContext("root")) {
				root(getContext("root"));
			}

			if (hasContext("onclick")) {
				onclick(getContext("onclick"));
			}
		});

		var div = root_1$b();
		let classes;
		var node = child(div);

		snippet(node, () => $$props.label ?? noop, () => ({ root: root(), onclick: onclick() }));

		var div_1 = sibling(node, 2);
		let classes_1;
		var node_1 = child(div_1);

		snippet(node_1, () => $$props.items ?? noop, () => ({ root: root(), onclick: onclick() }));
		reset(div_1);
		reset(div);

		template_effect(() => {
			classes = set_class(div, 1, 'navbar-item has-dropdown', null, classes, { 'is-hoverable': hoverable() });
			classes_1 = set_class(div_1, 1, 'navbar-dropdown', null, classes_1, { 'is-boxed': boxed(), 'has-dropdown-up': dropUp() });
		});

		append($$anchor, div);
		pop();
	}

	var root_1$a = from_html(`<a class="navbar-link"> </a>`);

	function Ui_navbar_item_has_dropdown_label($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let others = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'item', 'label']);
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var a = root_1$a();
				var text = child(a, true);

				reset(a);
				template_effect(() => set_text(text, $LOCALE()[$$props.item.title || $$props.label]));
				append($$anchor, a);
			};

			var alternate_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						Ui_navbar_item_content($$anchor, spread_props(() => others, {
							children: ($$anchor, $$slotProps) => {
								next();

								var text_1 = text();

								template_effect(() => set_text(text_1, $$props.label));
								append($$anchor, text_1);
							},

							$$slots: { default: true }
						}));
					};

					var alternate_1 = ($$anchor) => {
						var fragment_4 = comment();
						var node_2 = first_child(fragment_4);

						{
							var consequent_2 = ($$anchor) => {
								Ui_navbar_item_generic($$anchor, {
									get item() {
										return $$props.item;
									}
								});
							};

							var alternate = ($$anchor) => {
								var fragment_6 = comment();
								var node_3 = first_child(fragment_6);

								{
									var consequent_3 = ($$anchor) => {
										var fragment_7 = comment();
										var node_4 = first_child(fragment_7);

										snippet(node_4, () => $$props.label ?? noop);
										append($$anchor, fragment_7);
									};

									if_block(
										node_3,
										($$render) => {
											if (typeof $$props.label === "function") $$render(consequent_3);
										},
										true
									);
								}

								append($$anchor, fragment_6);
							};

							if_block(
								node_2,
								($$render) => {
									if (typeof $$props.item === "object") $$render(consequent_2); else $$render(alternate, false);
								},
								true
							);
						}

						append($$anchor, fragment_4);
					};

					if_block(
						node_1,
						($$render) => {
							if (typeof $$props.label === "string") $$render(consequent_1); else $$render(alternate_1, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (!$$props.arrowless) $$render(consequent); else $$render(alternate_2, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_navbar_item_has_dropdown_items($$anchor, $$props) {
		push($$props, true);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, () => $$props.items, (item) => item.id, ($$anchor, item) => {
					Ui_navbar_item($$anchor, {
						get item() {
							return get$3(item);
						}
					});
				});

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = comment();
				var node_2 = first_child(fragment_3);

				snippet(node_2, () => $$props.children ?? noop);
				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if ($$props.items && $$props.items.length) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_navbar_item_section($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 * @property {string} [hidden]
		 * @property {boolean} [hoverable]
		 * @property {boolean} [arrowless]
		 * @property {boolean} [right]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			onclick = prop($$props, 'onclick', 3, () => {}),
			hidden = prop($$props, 'hidden', 3, ""),
			hoverable = prop($$props, 'hoverable', 3, true),
			arrowless = prop($$props, 'arrowless', 3, false),
			dropUp = prop($$props, 'dropUp', 3, false);
			prop($$props, 'right', 3, false);
			let boxed = prop($$props, 'boxed', 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				{
					const label = ($$anchor, props = noop) => {
						{
							let $0 = user_derived(() => ({ ...$$props.item, items: null }));

							Ui_navbar_item_has_dropdown_label($$anchor, spread_props(props, {
								get item() {
									return get$3($0);
								}
							}));
						}
					};

					const items = ($$anchor, props = noop) => {
						Ui_navbar_item_has_dropdown_items($$anchor, spread_props(props, {
							get items() {
								return $$props.item.items;
							}
						}));
					};

					Ui_navbar_item_has_dropdown($$anchor, {
						get hoverable() {
							return hoverable();
						},

						get hidden() {
							return hidden();
						},

						get arrowless() {
							return arrowless();
						},

						get dropUp() {
							return dropUp();
						},

						get boxed() {
							return boxed();
						},

						get root() {
							return root();
						},

						get onclick() {
							return onclick();
						},

						label,
						items,

						children: ($$anchor, $$slotProps) => {
							template_effect(() => {
								console.log({ item: snapshot($$props.item) });

								debugger;
							});
						},

						$$slots: { label: true, items: true, default: true }
					});
				}
			};

			if_block(node, ($$render) => {
				if ($$props.item && Object.hasOwn($$props.item, "items") && Array.isArray($$props.item.items) && $$props.item.items.length) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_navbar_item_generic($$anchor, $$props) {
		push($$props, true);

		let others = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'item']);
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_navbar_item_section($$anchor, spread_props(
					{
						get renderer() {
							return Ui_navbar_item;
						},

						get item() {
							return $$props.item;
						}
					},
					() => others
				));
			};

			var alternate = ($$anchor) => {
				Ui_navbar_item($$anchor, spread_props(
					{
						get item() {
							return $$props.item;
						}
					},
					() => others
				));
			};

			if_block(node, ($$render) => {
				if (Object.hasOwn($$props.item, "items") && Array.isArray($$props.item.items) && $$props.item.items.length) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$i = from_html(`<div><!></div>`);

	function Ui_navbar_menu_wrapper($$anchor, $$props) {
		push($$props, true);

		let classPrefix = prop($$props, 'classPrefix', 3, "navbar-menu"),
			classes = prop($$props, 'class', 3, ""),
			other = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'id',
				'active',
				'classPrefix',
				'class',
				'children'
			]);

		let classAttr = user_derived(() => [classPrefix(), classes()].join(" "));
		var div = root$i();

		attribute_effect(div, () => ({
			id: $$props.id,
			class: get$3(classAttr),
			...other,
			[CLASS]: { 'is-active': $$props.active }
		}));

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
		pop();
	}

	var root$h = from_html(`<div><!></div>`);

	function Ui_navbar_menu_start($$anchor, $$props) {
		let classes = prop($$props, 'class', 3, ""),
			other = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class', 'children']);

		var div = root$h();

		attribute_effect(div, () => ({ class: "navbar-start " + classes(), ...other }));

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
	}

	var root$g = from_html(`<div><!></div>`);

	function Ui_navbar_menu_end($$anchor, $$props) {
		let classes = prop($$props, 'class', 3, ""),
			other = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class', 'children']);

		var div = root$g();

		attribute_effect(div, () => ({ class: "navbar-end " + classes(), ...other }));

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);
		append($$anchor, div);
	}

	var root_2$8 = from_html(`<!> <!>`, 1);

	function Ui_navbar_menu($$anchor, $$props) {
		push($$props, true);

		let id = prop($$props, 'id', 7),
			sections = prop($$props, 'sections', 19, () => []),
			items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 7),
			onclick = prop($$props, 'onclick', 7);
			prop($$props, 'class', 3, "");

		let sectionsItemsCount = {};
		let sectionsItems = {};

		onMount(() => {
			if (hasContext("navbarId")) {
				id(getContext("navbarId"));
			}

			if (hasContext("root")) {
				root(getContext("root"));
			}

			if (hasContext("onclick")) {
				onclick(getContext("onclick"));
			}

			for (let section of sections()) {
				sectionsItems[section.id] = items().filter((t) => t.section === section.id);
				sectionsItemsCount[section.id] = items().filter((t) => t.section === section.id).length;
			}
		});

		function placeIs(targetPlaces, thisPlace) {
			if (Array.isArray(targetPlaces) && targetPlaces.includes(thisPlace)) {
				return true;
			} else if (typeof targetPlaces === "string" && targetPlaces === thisPlace) {
				return true;
			}

			return false;
		}

		Ui_navbar_menu_wrapper($$anchor, {
			get id() {
				return id();
			},

			get active() {
				return $$props.active;
			},

			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_2$8();
				var node = first_child(fragment_1);

				Ui_navbar_menu_start(node, {
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, items, (item) => item.id, ($$anchor, item) => {
							var fragment_3 = comment();
							var node_2 = first_child(fragment_3);

							{
								var consequent = ($$anchor) => {
									Ui_navbar_item_generic($$anchor, {
										hidden: 'touch',

										get root() {
											return root();
										},

										get item() {
											return get$3(item);
										},

										get onclick() {
											return onclick();
										}
									});
								};

								if_block(node_2, ($$render) => {
									if (placeIs(get$3(item).place, "start")) $$render(consequent);
								});
							}

							append($$anchor, fragment_3);
						});

						append($$anchor, fragment_2);
					},

					$$slots: { default: true }
				});

				var node_3 = sibling(node, 2);

				Ui_navbar_menu_end(node_3, {
					children: ($$anchor, $$slotProps) => {
						var fragment_5 = comment();
						var node_4 = first_child(fragment_5);

						each(node_4, 17, sections, (section) => section.id, ($$anchor, section) => {
							var fragment_6 = comment();
							var node_5 = first_child(fragment_6);

							{
								var consequent_2 = ($$anchor) => {
									const sectionIsNotEmpty = user_derived(() => sectionsItemsCount[get$3(section).id] || get$3(section).indicator || get$3(section).href || get$3(section).tag);
									var fragment_7 = comment();
									var node_6 = first_child(fragment_7);

									{
										var consequent_1 = ($$anchor) => {
											Ui_navbar_item_generic($$anchor, {
												hidden: 'touch',

												get root() {
													return root();
												},

												item,

												get onclick() {
													return onclick();
												}
											});
										};

										if_block(node_6, ($$render) => {
											if (get$3(sectionIsNotEmpty)) $$render(consequent_1);
										});
									}

									append($$anchor, fragment_7);
								};

								if_block(node_5, ($$render) => {
									if (placeIs(get$3(section).place, "end")) $$render(consequent_2);
								});
							}

							append($$anchor, fragment_6);
						});

						append($$anchor, fragment_5);
					},

					$$slots: { default: true }
				});

				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});

		pop();
	}

	var root$f = from_html(`<a><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a>`);

	function Ui_navbar_burger($$anchor, $$props) {
		push($$props, true);

		let role = prop($$props, 'role', 3, "button"),
			classPrefix = prop($$props, 'classPrefix', 3, "navbar-burger"),
			ariaLabel = prop($$props, 'ariaLabel', 3, "menu"),
			ariaExpanded = prop($$props, 'ariaExpanded', 3, "false"),
			dataTarget = prop($$props, 'dataTarget', 7, "navbarBasicExample"),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, () => {
				console.log("click");
			});

		onMount(() => {
			if (hasContext("navbarId")) {
				dataTarget(getContext("navbarId"));
			}
		});

		var a = root$f();
		let classes_1;

		a.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		template_effect(
			($0) => {
				classes_1 = set_class(a, 1, $0, null, classes_1, { 'is-active': $$props.active });
				set_attribute(a, 'role', role());
				set_attribute(a, 'aria-label', ariaLabel());
				set_attribute(a, 'aria-expanded', ariaExpanded());
				set_attribute(a, 'data-target', dataTarget());
			},
			[() => clsx([classPrefix(), classes()].join(" "))]
		);

		append($$anchor, a);
		pop();
	}

	delegate(['click']);

	var root$e = from_html(`<nav><!></nav>`);

	function Ui_navbar_wrapper($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 3, ""),
			classPrefix = prop($$props, 'classPrefix', 3, "navbar"),
			role = prop($$props, 'role', 3, "navigation"),
			ariaLabel = prop($$props, 'ariaLabel', 3, "main navigation"),
			other = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'classPrefix',
				'role',
				'ariaLabel',
				'children'
			]);

		var nav = root$e();

		attribute_effect(nav, ($0) => ({ class: $0, role: role(), 'aria-label': ariaLabel(), ...other }), [() => [classPrefix(), classes()].join(" ")]);

		var node = child(nav);

		snippet(node, () => $$props.children ?? noop);
		reset(nav);
		append($$anchor, nav);
		pop();
	}

	var root_2$7 = from_html(`<!> <!>`, 1);

	function Ui_navbar($$anchor, $$props) {
		push($$props, true);

		let id = prop($$props, 'id', 3, "navbar"),
			active = prop($$props, 'active', 7, false),
			sections = prop($$props, 'sections', 19, () => []),
			items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			navigate = prop($$props, 'navigate', 3, null),
			burgerControlsSidemenu = prop($$props, 'burgerControlsSidemenu', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, () => {});

		onMount(() => {
			setContext("root", root());
			setContext("navigate", navigate());
			setContext("burgerControlsSidemenu", burgerControlsSidemenu());
			setContext("navbarId", id());
			setContext("onclick", onclick());
		});

		function onBurgerClick() {
			active(!active());
		}

		Ui_navbar_wrapper($$anchor, {
			get class() {
				return classes();
			},

			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_2$7();
				var node = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_navbar_brand($$anchor, {
							get brand() {
								return $$props.brand;
							},

							children: ($$anchor, $$slotProps) => {
								Ui_navbar_burger($$anchor, {
									get active() {
										return active();
									},

									onclick: onBurgerClick
								});
							}});
					};

					var alternate = ($$anchor) => {
						Ui_navbar_burger($$anchor, {
							get active() {
								return active();
							},

							onclick: onBurgerClick
						});
					};

					if_block(node, ($$render) => {
						if ($$props.brand) $$render(consequent); else $$render(alternate, false);
					});
				}

				var node_1 = sibling(node, 2);

				Ui_navbar_menu(node_1, {
					get active() {
						return active();
					},

					get sections() {
						return sections();
					},

					get items() {
						return items();
					}
				});

				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		});

		pop();
	}

	var root$d = from_html(`<a><!></a>`);

	function Ui_navbar_link($$anchor, $$props) {
		push($$props, true);

		let classPrefix = prop($$props, 'classPrefix', 3, "navbar-link"),
			classes = prop($$props, 'class', 3, ""),
			other = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'classPrefix',
				'class',
				'children',
				'selected'
			]);

		var a = root$d();

		attribute_effect(
			a,
			($0) => ({
				class: $0,
				...other,
				[CLASS]: { 'is-selected': $$props.selected }
			}),
			[() => [classPrefix(), classes()].join(" ")]
		);

		var node = child(a);

		snippet(node, () => $$props.children ?? noop);
		reset(a);
		append($$anchor, a);
		pop();
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UINavbar: Ui_navbar,
		UINavbarBrand: Ui_navbar_brand,
		UINavbarBrandItem: Ui_navbar_brand_item,
		UINavbarBrandWrapper: Ui_navbar_brand_wrapper,
		UINavbarBurger: Ui_navbar_burger,
		UINavbarItemDevider: Ui_navbar_item_devider,
		UINavbarItemGeneric: Ui_navbar_item_generic,
		UINavbarItemLink: Ui_navbar_item_link,
		UINavbarLink: Ui_navbar_link,
		UINavbarMenu: Ui_navbar_menu,
		UINavbarMenuEnd: Ui_navbar_menu_end,
		UINavbarMenuStart: Ui_navbar_menu_start,
		UINavbarMenuWrapper: Ui_navbar_menu_wrapper,
		UINavbarWrapper: Ui_navbar_wrapper
	});

	var root_2$6 = from_html(`<p> </p>`);
	var root_4$5 = from_html(`<p> </p>`);
	var root$c = from_html(`<article><div class="message-header"><!></div> <div class="message-body"><!></div></article>`);

	function Ui_message($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let classes = prop($$props, 'class', 3, "");
		var article = root$c();
		var div = child(article);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.titleSnip, () => $$props.title);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var p = root_2$6();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, $LOCALE()[$$props.title]));
				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if ($$props.titleSnip) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var node_2 = child(div_1);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_3 = first_child(fragment_1);

				snippet(node_3, () => $$props.messageSnip, () => $$props.message);
				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var p_1 = root_4$5();
				var text_1 = child(p_1, true);

				reset(p_1);
				template_effect(() => set_text(text_1, $LOCALE()[$$props.message]));
				append($$anchor, p_1);
			};

			if_block(node_2, ($$render) => {
				if ($$props.messageSnip) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		reset(div_1);
		reset(article);
		template_effect(() => set_class(article, 1, `message ${classes() ?? ''} ${$$props.color ? `is-${$$props.color}` : ''}`));
		append($$anchor, article);
		pop();
		$$cleanup();
	}

	function Ui_error($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 19, () => UICommon$1.CLASS_ERR),
			props = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class']);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	function Ui_success($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 19, () => UICommon$1.CLASS_OK),
			props = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class']);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	var root_1$9 = from_html(`<div><p> </p> <!></div>`);

	function Ui_cookie($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [show = false]
		 * @property {string} [message]
		 * @property {string} [agree]
		 */
		/** @type {Props} */
		let show = prop($$props, 'show', 15, false),
			message = prop($$props, 'message', 3, "Для улучшения работы сайта и его взаимодействия с пользователями мы используем файлы cookie. Продолжая работу с сайтом, Вы разрешаете использование cookie-файлов. Вы всегда можете отключить файлы cookie в настройках Вашего браузера."),
			agree = prop($$props, 'agree', 3, "Хорошо"),
			cooldown = prop($$props, 'cooldown', 3, 31536000000),
			lsKey = prop($$props, 'lsKey', 3, "cookie_date"),
			id = prop($$props, 'id', 3, "cookie_notification");

		onMount(() => {
			let cookieDate = localStorage.getItem(lsKey());

			if (!cookieDate || +cookieDate + cooldown() < Date.now()) {
				show(true);
			}
		});

		function accept() {
			localStorage.setItem(lsKey(), Date.now());
			show(false);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$9();
				var p = child(div);
				var text$1 = child(p, true);

				reset(p);

				var node_1 = sibling(p, 2);

				Ui_button(node_1, {
					onclick: accept,
					color: 'success',
					class: 'cookie_accept',

					children: ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[agree()]));
						append($$anchor, text_1);
					},

					$$slots: { default: true }
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, 'id', id());
					set_text(text$1, $LOCALE()[message()]);
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UICookieNotification: Ui_cookie,
		UIError: Ui_error,
		UIMessage: Ui_message,
		UISuccess: Ui_success
	});

	//block elements

	var Elements = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Blocks: index$d,
		Buttons: index$c,
		Forms: index$7,
		Icons: index$8,
		Images: index$6,
		Inputs: index$a,
		Layouts: index$b,
		Links: index$5,
		Lists: index$4,
		Modals: index$3,
		Navigations: index$2,
		Notifications: index$1,
		UICommon: UICommon$1,
		Various: index$9
	});

	const META_METHOD_INIT = Symbol("init"),
	  META_DATA = Symbol("data"),
	  META_WORKING = Symbol("working"),
	  META_OPTIONS = Symbol("options");
	let notBase = /*#__PURE__*/function (_EventEmitter) {
	  function notBase(input) {
	    var _this;
	    _classCallCheck(this, notBase);
	    _this = _callSuper(this, notBase);
	    _this[META_DATA] = {};
	    _this[META_WORKING] = {};
	    _this[META_OPTIONS] = {};
	    _this[META_METHOD_INIT](input);
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notBase, _EventEmitter);
	  return _createClass(notBase, [{
	    key: META_METHOD_INIT,
	    value: function (input) {
	      if (!input) {
	        input = {};
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "data")) {
	        this.setData(input.data);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "working")) {
	        this.setWorking(input.working);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "options")) {
	        this.setOptions(input.options);
	      }
	      this.log = notCommon$1.genLogMsg(this.getWorking("name"));
	      this.info = this.log;
	      this.debug = notCommon$1.genLogDebug(this.getWorking("name"));
	      this.error = notCommon$1.genLogError(this.getWorking("name"));
	    }
	  }, {
	    key: "setCommon",
	    value: function setCommon(what, args) {
	      switch (args.length) {
	        case 1:
	          {
	            /* set collection */
	            what = args[0];
	            break;
	          }
	        case 2:
	          {
	            /* set collection element */
	            notPath.set(args[0] /* path */, what /* collection */, undefined /* helpers */, args[1] /* value */);
	            break;
	          }
	      }
	      return this;
	    }
	  }, {
	    key: "getCommon",
	    value: function getCommon(what, args) {
	      switch (args.length) {
	        /* if we want get data by path */
	        case 1:
	          {
	            return notPath.get(args[0], what);
	          }
	        /* if we want get data by path with default value */
	        case 2:
	          {
	            let res = notPath.get(args[0], what);
	            if (res === undefined) {
	              /* no data, return default value */
	              return args[1];
	            } else {
	              /* data, return it */
	              return res;
	            }
	          }
	        /* return full collection */
	        default:
	          {
	            return what;
	          }
	      }
	    }

	    /*
	    CORE OBJECT
	      DATA - information
	      OPTIONS - how to work
	      WORKING - temporarily generated in proccess
	    */
	  }, {
	    key: "setData",
	    value: function setData() {
	      if (arguments.length === 1) {
	        this[META_DATA] = arguments[0];
	      } else {
	        this.setCommon(this.getData(), arguments);
	      }
	      this.emit("change");
	      return this;
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.getCommon(this[META_DATA], arguments);
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions() {
	      if (arguments.length === 1) {
	        this[META_OPTIONS] = arguments[0];
	      } else {
	        this.setCommon(this.getOptions(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      return this.getCommon(this[META_OPTIONS], arguments);
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking() {
	      if (arguments.length === 1) {
	        this[META_WORKING] = arguments[0];
	      } else {
	        this.setCommon(this.getWorking(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking() {
	      return this.getCommon(this[META_WORKING], arguments);
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon$1.report) {
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removeEvent();
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	      this.emit("destroy");
	    }
	  }]);
	}(EventEmitter);

	const OPT_MODE_HISTORY = Symbol("history"),
	  OPT_MODE_HASH = Symbol("hash"),
	  OPT_DEFAULT_CHECK_INTERVAL = 50;
	let notRouter = /*#__PURE__*/function (_notBase) {
	  function notRouter() {
	    var _this;
	    _classCallCheck(this, notRouter);
	    _this = _callSuper(this, notRouter, [{
	      working: {
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/",
	        //always in slashes /user/, /, /input/. and no /user or input/level
	        initialized: false,
	        delays: NAVIGATION_DELAYS,
	        delay_default: NAVIGATION_DELAY_DEFAULT
	      }
	    }]);
	    _defineProperty(_this, "host", "");
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Set object with named delays
	   * @param {Object.<string, number>} delays
	   * @returns {notRouter}
	   */
	  _inherits(notRouter, _notBase);
	  return _createClass(notRouter, [{
	    key: "setDelays",
	    value: function setDelays(delays) {
	      this.setWorking("delays", delays);
	      return this;
	    }

	    /**
	     * Set default navigation delay, provided as name of one of `delays` or in number form
	     * @param {string|number} delay
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setDefaultNavigationDelay",
	    value: function setDefaultNavigationDelay(delay) {
	      this.setWorking("delay_default", this.delayAsMs(delay));
	      return this;
	    }

	    /**
	     * Returns number of ms, if not set returns NAVIGATION_DELAY_DEFAULT
	     * @returns {number}
	     */
	  }, {
	    key: "getDefaultNavigationDelay",
	    value: function getDefaultNavigationDelay() {
	      return this.getWorking(`delay_default`, NAVIGATION_DELAY_DEFAULT);
	    }

	    /**
	     *  Ensures that delay is in ms, if its provided as name of alias, searches for it and returns, if not found - returns working default_delay
	     * @param {string|number} delay    name of delay alias or number of ms
	     * @returns {number}               delay in ms
	     */
	  }, {
	    key: "delayAsMs",
	    value: function delayAsMs(delay) {
	      if (typeof delay === "number") {
	        return delay;
	      } else {
	        if (typeof delay === "string" && delay.length > 0) {
	          return this.getWorking(`delays.${delay}`, this.getDefaultNavigationDelay());
	        } else {
	          return this.getDefaultNavigationDelay();
	        }
	      }
	    }

	    /**
	     *
	     *  @param {string}              url     we go to url
	     *  @param {string|number}       delay   name of delay alias or number of ms
	     *  @returns {NodeJS.Timeout}            timeout identificator
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay, doBefore) {
	      var _this2 = this;
	      return setTimeout(function () {
	        typeof doBefore === "function" && doBefore();
	        _this2.navigate(url);
	      }, this.delayAsMs(delay));
	    }

	    /**
	     * Use browser History API
	     */
	  }, {
	    key: "history",
	    value: function history() {
	      this.setWorking("mode", OPT_MODE_HISTORY);
	    }

	    /**
	     * Use hash part as container for location information
	     */
	  }, {
	    key: "hash",
	    value: function hash() {
	      this.setWorking("mode", OPT_MODE_HASH);
	    }

	    /**
	     * root should start and end with
	     * @param {string} root
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setRoot",
	    value: function setRoot(root) {
	      this.setWorking("root", root && root !== "/" ? "/" + this.clearSlashes(root) + "/" : "/");
	      return this;
	    }

	    /**
	     * clear first and last slashes from string
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "clearSlashes",
	    value: function clearSlashes(path) {
	      return path.toString().replace(/\/$/, "").replace(/^\//, "");
	    }
	  }, {
	    key: "add",
	    value: function add(re, handler) {
	      if (typeof re == "function") {
	        handler = re;
	        re = "";
	      }
	      let rule = {
	        re: re,
	        handler: handler
	      };
	      this.getWorking("routes").push(rule);
	      return this;
	    }
	  }, {
	    key: "addList",
	    value: function addList(list) {
	      for (let t in list) {
	        this.add(t, list[t]);
	      }
	      return this;
	    }
	  }, {
	    key: "remove",
	    value: function remove(param) {
	      for (var i = 0, r; i < this.getWorking("routes").length, r = this.getWorking("routes")[i]; i++) {
	        if (r.handler === param || r.re === param) {
	          this.getWorking("routes").splice(i, 1);
	          return this;
	        }
	      }
	      return this;
	    }
	  }, {
	    key: "flush",
	    value: function flush() {
	      this.setWorking({
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/"
	      });
	      return this;
	    }
	  }, {
	    key: "isInitialized",
	    value: function isInitialized() {
	      return this.getWorking("initialized");
	    }
	  }, {
	    key: "setInitialized",
	    value: function setInitialized(val = true) {
	      return this.setWorking("initialized", val);
	    }
	  }, {
	    key: "getFragment",
	    value: function getFragment() {
	      var fragment = "";
	      if (this.getWorking("mode") === OPT_MODE_HISTORY) {
	        if (!location) return "";
	        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
	        fragment = fragment.replace(/\?(.*)$/, "");
	        fragment = this.getWorking("root") != "/" ? fragment.replace(this.getWorking("root"), "") : fragment;
	      } else {
	        if (!window) return "";
	        var match = window.location.href.match(/#(.*)$/);
	        fragment = match ? match[1] : "";
	      }
	      return this.clearSlashes(fragment);
	    }
	  }, {
	    key: "checkLocation",
	    value: function checkLocation() {
	      let current = this.getWorking("current"),
	        fragment = this.getFragment(),
	        init = this.isInitialized();
	      if (current !== fragment || !init) {
	        this.setWorking("current", fragment);
	        this.check(fragment);
	        this.setInitialized(true);
	      }
	    }
	  }, {
	    key: "hrefClick",
	    value: function hrefClick() {
	      //console.log(...arguments);
	    }
	  }, {
	    key: "getRoot",
	    value: function getRoot() {
	      return this.getWorking("root");
	    }
	  }, {
	    key: "listen",
	    value: function listen(loopInterval = OPT_DEFAULT_CHECK_INTERVAL) {
	      this.setWorking("current", "notInitialized");
	      clearInterval(this.getWorking("interval"));
	      this.setWorking("interval", setInterval(this.checkLocation.bind(this), loopInterval));
	      window.addEventListener("popstate", this.hrefClick.bind(this));
	      return this;
	    }
	  }, {
	    key: "check",
	    value: function check(f) {
	      let fragment = f || this.getFragment(),
	        failBack = null;
	      for (let i = 0; i < this.getWorking("routes").length; i++) {
	        let path = this.getWorking("root") + this.getWorking("routes")[i].re,
	          fullRE = this.clearSlashes(decodeURI(path)),
	          match = fragment.match(fullRE);
	        if (match && match.length) {
	          if (fullRE === "") {
	            match.shift();
	            failBack = {
	              route: this.getWorking("routes")[i],
	              match
	            };
	          } else {
	            match.shift();
	            this.getWorking("routes")[i].handler.apply(this.host || {}, match);
	            this.emit("afterRoute", this.getWorking("routes")[i]);
	            return this;
	          }
	        }
	      }
	      if (failBack) {
	        failBack.route.handler.apply(this.host || {}, failBack.match);
	        this.emit("afterRoute", failBack.route);
	      }
	      return this;
	    }

	    /**
	     *  Refreshes page
	     * @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      var _this3 = this;
	      if (timeout > 0) {
	        setTimeout(function () {
	          return _this3.refresh();
	        }, timeout);
	      } else {
	        this.check(this.getWorking("current"));
	      }
	    }

	    /**
	     * Changes locations
	     * @param {string} path
	     * @returns
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(path) {
	      path = path ? path : "";
	      switch (this.getWorking("mode")) {
	        case OPT_MODE_HISTORY:
	          {
	            const newRoute = this.getFullRoute(path);
	            if (newRoute === this.lastRoute) {
	              this.refresh();
	            } else {
	              this.lastRoute = newRoute;
	              history.pushState(null, "", this.lastRoute);
	            }
	            break;
	          }
	        case OPT_MODE_HASH:
	          {
	            window.location.href.match(/#(.*)$/);
	            window.location.href = window.location.href.replace(/#(.*)$/, "") + "#" + path;
	            break;
	          }
	      }
	      return this;
	    }

	    /**
	     *  returns app root + path
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "getFullRoute",
	    value: function getFullRoute(path = "") {
	      path = this.clearSlashes(path);
	      const root = this.getWorking("root");
	      if (root !== "/") {
	        if (path.indexOf(root.substring(1)) === 0) {
	          return "/" + path;
	        }
	      }
	      return this.getWorking("root") + this.clearSlashes(path);
	    }

	    /**
	     * Returns all links with n-href attribute
	     * @returns {Array<HTMLAnchorElement>}
	     */
	  }, {
	    key: "getAllLinks",
	    value: function getAllLinks() {
	      const allElements = document.body.querySelectorAll("a");
	      let list = [];
	      for (let j = 0; j < allElements.length; j++) {
	        for (let i = 0, atts = allElements[j].attributes, n = atts.length; i < n; i++) {
	          if (atts[i].nodeName.indexOf("n-href") === 0) {
	            list.push(allElements[j]);
	            break;
	          }
	        }
	      }
	      return list;
	    }

	    /**
	     * Reroute all links(anchor tags) with n-href attribute.
	     * Disable navigation to href.
	     * @returns {notRouter}
	     */
	  }, {
	    key: "reRouteExisted",
	    value: function reRouteExisted() {
	      const list = this.getAllLinks();
	      for (let t = 0; t < list.length; t++) {
	        this.initRerouting(list[t], list[t].getAttribute("n-href"));
	      }
	      return this;
	    }

	    /**
	     * If `el` is not initialized, adds onclick listener to navigate to `link` location.
	     * Disables default navigation to href.
	     * @param {HTMLAnchorElement}   el
	     * @param {string}              link
	     * @returns
	     */
	  }, {
	    key: "initRerouting",
	    value: function initRerouting(el, link) {
	      var _this4 = this;
	      // @ts-ignore
	      if (!el.notRouterInitialized) {
	        let fullLink = this.getFullRoute(link);
	        el.setAttribute("href", fullLink);
	        el.addEventListener("click", function (e) {
	          e.preventDefault();
	          _this4.navigate(link);
	          return false;
	        });
	        // @ts-ignore
	        el.notRouterInitialized = true;
	      }
	      return this;
	    }
	  }]);
	}(notBase);
	var notRouter$1 = new notRouter();

	const LOG_PREFIX$1 = "APIQuee";
	let notAPIQueue = /*#__PURE__*/function (_notBase) {
	  function notAPIQueue(options = {}) {
	    var _this;
	    _classCallCheck(this, notAPIQueue);
	    _this = _callSuper(this, notAPIQueue, [{
	      working: {
	        name: options.name ? options.name : LOG_PREFIX$1
	      },
	      options
	    }]);
	    _this.busy = false;
	    _this.queue = [];
	    _this.busySince = -1;
	    _this.afterEmpty = undefined;
	    _this.start();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIQueue, _notBase);
	  return _createClass(notAPIQueue, [{
	    key: "stop",
	    value: function stop() {
	      if (this.interval) {
	        clearInterval(this.interval);
	        this.interval = undefined;
	        this.busy = false;
	        this.busySince = -1;
	      }
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      this.stop();
	      this.interval = setInterval(this.checkQueue.bind(this), this.QUEUE_CHECK_INTERVAL);
	    }
	  }, {
	    key: "checkQueue",
	    value: function checkQueue() {
	      var _this2 = this;
	      if (!this.isEmpty() && !this.isBusy()) {
	        this.setBusy().runNext().then(this.setFree.bind(this)).catch(function (e) {
	          _this2.error && _this2.error(e);
	          _this2.setFree();
	        });
	      } else {
	        if (!this.isBusy()) {
	          if (this.afterEmpty) {
	            let t = this.afterEmpty;
	            this.afterEmpty = undefined;
	            t();
	          }
	        }
	      }
	    }
	  }, {
	    key: "addToQueue",
	    value: function addToQueue(task) {
	      this.queue.push(task);
	    }
	  }, {
	    key: "runNext",
	    value: function runNext() {
	      let list = this.queue.map(function (action) {
	        return action.title;
	      }).join(", ");
	      this.debug && this.debug(`tasks [${list}]`);
	      let task = this.queue.shift();
	      if (!notCommon$1.isFunc(task.action)) {
	        this.error && this.error("В задании нет исполнимой части, action не функция", task.title);
	        return Promise.resolve();
	      }
	      if (!notCommon$1.isFunc(task.resolve)) {
	        this.error && this.error("В задании нет возвратной части, resolve не функция", task.title);
	        return task.action();
	      }
	      return task.action().then(task.resolve);
	    }
	  }, {
	    key: "isBusy",
	    value: function isBusy() {
	      let busy = !!this.busy,
	        now = Date.now() / 1000;
	      if (busy && this.busySince > -1) {
	        if (now - this.busySince > notAPIQueue.MAX_BUSY_TIME) {
	          this.setFree();
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "setBusy",
	    value: function setBusy() {
	      this.busy = true;
	      this.busySince = Date.now() / 1000;
	      return this;
	    }
	  }, {
	    key: "setFree",
	    value: function setFree() {
	      this.busy = false;
	      this.busySince = -1;
	      return this;
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return this.queue.length === 0;
	    }

	    /**
	     * Исполнитель запросов
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @returns    {Promise}    результат функции
	     **/
	  }, {
	    key: "run",
	    value: function run(action, afterEmpty = undefined, title = "") {
	      var _this3 = this;
	      if (afterEmpty && typeof this.afterEmpty === "undefined") {
	        this.afterEmpty = afterEmpty;
	      }
	      return new Promise(function (resolve, reject) {
	        try {
	          _this3.addToQueue({
	            action,
	            resolve,
	            title
	          });
	        } catch (e) {
	          _this3.error && _this3.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "actionIsQueued",
	    value: function actionIsQueued(title) {
	      return this.queue.some(function (queued) {
	        return queued.title == title;
	      });
	    }

	    /**
	     *
	     *
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @return    {Promise}
	     * @memberof notAPIQueue
	     */
	  }, {
	    key: "runIfNotQueued",
	    value: function runIfNotQueued(action, afterEmpty = undefined, title = "") {
	      if (this.actionIsQueued(title)) {
	        return Promise.resolve();
	      } else {
	        return this.run(action, afterEmpty, title);
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIQueue, "QUEUE_CHECK_INTERVAL", 100);
	_defineProperty(notAPIQueue, "MAX_BUSY_TIME", 300);

	let notAPIOptions = {
	  rps: 50,
	  protocol: 'http',
	  host: 'localhost',
	  port: 9000
	};

	const LOG_PREFIX = 'APIConnection';
	let notAPIConnection = /*#__PURE__*/function (_notBase) {
	  function notAPIConnection(options) {
	    var _this;
	    _classCallCheck(this, notAPIConnection);
	    _this = _callSuper(this, notAPIConnection, [{
	      options,
	      working: {
	        name: options.name ? options.name : LOG_PREFIX
	      }
	    }]);
	    _this.online = null;
	    _this.run();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIConnection, _notBase);
	  return _createClass(notAPIConnection, [{
	    key: "run",
	    value: function run() {
	      this.int = window.setInterval(this.check.bind(this), 1000);
	    }
	  }, {
	    key: "pause",
	    value: function pause() {
	      window.clearInterval(this.int);
	    }
	  }, {
	    key: "resume",
	    value: function resume() {
	      this.run();
	    }
	  }, {
	    key: "isOnline",
	    value: function isOnline() {
	      return window.navigator.onLine;
	    }
	  }, {
	    key: "check",
	    value: function check() {
	      let t = this.isOnline();
	      if (this.online !== null) {
	        if (this.online !== t) {
	          this.changeState(t);
	        }
	      }
	      this.online = t;
	    }
	  }, {
	    key: "changeState",
	    value: function changeState(online = false) {
	      if (online) {
	        this.emit('online');
	      } else {
	        this.emit('offline');
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIConnection, "int", void 0);
	_defineProperty(notAPIConnection, "online", void 0);

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		notAPIConnection: notAPIConnection,
		notAPIOptions: notAPIOptions,
		notAPIQueue: notAPIQueue
	});

	const ALL$1 = {};
	function exist$1(key) {
	  return notCommon$1.objHas(ALL$1, key);
	}
	function get$1(key) {
	  if (exist$1(key)) {
	    return ALL$1[key];
	  } else {
	    return false;
	  }
	}
	function create$1(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist$1(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL$1[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL$1[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL$1[key];
	}

	/**
	 * Creates object that is fake Store
	 * Some time this is useful when you need to initialize local var,
	 * before you could get actual Stores from central storage by its ID
	 *	@params {mixed} val 	data of type that is actual storage will contain
	 * @returns {Object}
	 */

	function fake(val) {
	  return {
	    subscribe(f) {
	      f(val);
	      return function () {};
	    },
	    set() {}
	  };
	}

	var stores = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		fake: fake,
		get: get$1
	});

	const //record
	  META_INTERFACE = Symbol('interface'),
	  META_MAP_TO_INTERFACE = ['getActionsCount', 'getActions', 'setFindBy', 'resetFilter', 'setFilter', 'getFilter', 'setSorter', 'getSorter', 'resetSorter', 'setPageNumber', 'setPageSize', 'setPager', 'setReturn', 'setSearch', 'getSearch', 'resetSearch', 'resetPager', 'getPager', 'addFormFieldType', 'addFormField', 'getFieldTypes', 'getActionFormFields'],
	  DEFAULT_ACTION_PREFIX$1 = '$';

	const OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY = ["_id", "id", "ID"],
	  DEFAULT_FILTER = {},
	  DEFAULT_SEARCH = "",
	  DEFAULT_RETURN = {},
	  DEFAULT_PAGE_NUMBER = 0,
	  DEFAULT_PAGE_SIZE = 10,
	  DEFAULT_ACTION_PREFIX = "$",
	  DEFAULT_WS_ROUTE_ACTION_SPLITTER = "//";
	let notInterface = /*#__PURE__*/function (_notBase) {
	  function notInterface(manifest, options) {
	    var _this;
	    _classCallCheck(this, notInterface);
	    _this = _callSuper(this, notInterface, [{
	      working: {
	        name: "network interface for: " + (manifest.model ? manifest.model : "unknown"),
	        filter: DEFAULT_FILTER,
	        search: DEFAULT_SEARCH,
	        return: DEFAULT_RETURN,
	        pager: {
	          size: DEFAULT_PAGE_SIZE,
	          page: DEFAULT_PAGE_NUMBER
	        }
	      },
	      options
	    }]);
	    _this.manifest = manifest;
	    _this.initActions();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notInterface, _notBase);
	  return _createClass(notInterface, [{
	    key: "initActions",
	    value: function initActions() {
	      if (this.getActionsCount() > 0) {
	        let actions = this.getActions();
	        for (let actionName in actions) {
	          this.initAction(actionName);
	        }
	      }
	    }
	  }, {
	    key: "initAction",
	    value: function initAction(actionName) {
	      var _this2 = this;
	      if (!notCommon$1.objHas(this, DEFAULT_ACTION_PREFIX + actionName)) {
	        this[DEFAULT_ACTION_PREFIX + actionName] = function (opts, headers, fileUpload = false, files) {
	          return _this2.request(_this2, actionName, opts, headers, fileUpload, files);
	        };
	      }
	    }
	  }, {
	    key: "requestHTTP",
	    value: function requestHTTP(record, actionName, params, headers = {}, fileUpload = false, files) {
	      try {
	        let compositeData = Object.assign({}, record.getData && typeof record.getData === "function" ? record.getData() : record, params);
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData),
	          requestParamsEncoded = this.encodeRequest(requestParams),
	          //id = this.getID(compositeData, actionData, actionName),
	          apiServerURL = this.getServerURL(),
	          url = this.getURL(compositeData, actionData, actionName),
	          opts = {};
	        if (fileUpload) {
	          url = this.getURL(params, actionData, actionName);
	          const fd = new FormData();
	          fd.append("file", files);
	          opts.body = fd;
	        } else {
	          if (["OPTIONS", "GET"].indexOf(actionData.method.toUpperCase()) === -1) {
	            opts = {
	              method: actionData.method,
	              body: JSON.stringify(record.getData && typeof record.getData === "function" ? record.getData() : record),
	              headers: {
	                Accept: "application/json",
	                "Content-Type": "application/json"
	              }
	            };
	          }
	        }
	        opts.method = actionData.method.toUpperCase();
	        if (headers && Object.keys(headers).length) {
	          opts.headers = headers;
	        }
	        return fetch(apiServerURL + url + requestParamsEncoded, opts).then(function (response) {
	          return response.json();
	        });
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "requestWS",
	    value: function requestWS(record, actionName) {
	      try {
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData);
	        const WS = notCommon$1.getApp().getWSClient();
	        const messageName = this.getWSRequestName(actionName);
	        const payload = Object.assign({}, requestParams, record.getData());
	        if (notCommon$1.objHas(actionData, "type") && typeof actionData.type === "string" && actionData.type.length && actionData.type !== "request") {
	          return WS.message(actionData.type, messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        } else {
	          return WS.request(messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        }
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "request",
	    value: function request() {
	      let actionData = this.getActionData(arguments[1]);
	      switch (this.selectTransport(actionData)) {
	        case "ws":
	          return this.requestWS(...arguments);
	        case "http":
	          return this.requestHTTP(...arguments);
	        default:
	          throw new Error("Offline");
	      }
	    }
	  }, {
	    key: "wsIsUp",
	    value: function wsIsUp(actionData) {
	      if (actionData.ws === true) {
	        let client;
	        if (notCommon$1.objHas(actionData, "wsClient") && actionData.wsClient) {
	          client = notCommon$1.getApp().getWSClient(actionData.wsClient);
	        } else {
	          client = notCommon$1.getApp().getWSClient();
	        }
	        if (client) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "selectTransport",
	    value: function selectTransport(actionData) {
	      if (this.wsIsUp(actionData)) {
	        return "ws"; //for ws/wss
	      }
	      if (notCommon$1.objHas(actionData, "method")) {
	        return "http"; //for http/https
	      }
	      return false; //for offline
	    }
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this && this.manifest ? this.manifest.model : null;
	    }
	  }, {
	    key: "getActionData",
	    value: function getActionData(actionName) {
	      return this.getActions() && this.getActions()[actionName] ? this.getActions()[actionName] : null;
	    }
	  }, {
	    key: "getActionsCount",
	    value: function getActionsCount() {
	      return this.getActions() ? Object.keys(this.getActions()).length : 0;
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.manifest && this.manifest.actions ? this.manifest.actions : {};
	    }
	  }, {
	    key: "parseParams",
	    value: function parseParams(start, end, line, record) {
	      let fieldName = "";
	      let len = start.length;
	      while (line.indexOf(start) > -1) {
	        let ind = line.indexOf(start);
	        let startSlice = ind + len;
	        let endSlice = line.indexOf(end);
	        if (ind > endSlice) {
	          break;
	        }
	        fieldName = line.slice(startSlice, endSlice);
	        if (fieldName == "") break;
	        this.log && this.log(start + fieldName + end, notPath.get(fieldName, record));
	        line = line.replace(start + fieldName + end, notPath.get(fieldName, record));
	      }
	      return line;
	    }
	  }, {
	    key: "parseLine",
	    value: function parseLine(line, record, actionName) {
	      line = line.replace(":modelName", this.manifest.model);
	      line = line.replace(":actionName", actionName);
	      line = this.parseParams(":record[", "]", line, record);
	      line = this.parseParams(":", "?", line, record);
	      return line;
	    }
	  }, {
	    key: "getURL",
	    value: function getURL(record, actionData, actionName) {
	      var line = this.parseLine(this.manifest.url, record, actionName) + (notCommon$1.objHas(actionData, "postFix") ? this.parseLine(actionData.postFix, record, actionName) : "");
	      return line;
	    }
	  }, {
	    key: "getServerURL",
	    value: function getServerURL() {
	      return notCommon$1.getApp() ? notCommon$1.getApp().getOptions("api.server.url", "") : "";
	    }
	  }, {
	    key: "getWSRequestName",
	    value: function getWSRequestName(actionName) {
	      const modelName = this.manifest.model;
	      return `${modelName}${DEFAULT_WS_ROUTE_ACTION_SPLITTER}${actionName}`;
	    }
	  }, {
	    key: "encodeRequest",
	    value: function encodeRequest(data) {
	      let p = "?";
	      for (let t in data) {
	        if (typeof data[t] !== "undefined" && data[t] !== null) {
	          p += encodeURIComponent(t) + "=" + encodeURIComponent(data[t].constructor === Object ? JSON.stringify(data[t]) : data[t]) + "&";
	        }
	      }
	      //for test purpose only, special test server needed
	      if (this.getOptions("test")) {
	        p += "&test=1";
	        if (this.getOptions("test.session")) {
	          p += "&session=" + this.getOptions("test.session");
	        }
	        if (this.getOptions("test.session")) {
	          p += "&role=" + this.getOptions("test.role");
	        }
	      }
	      return p;
	    }
	  }, {
	    key: "collectRequestData",
	    value: function collectRequestData(actionData) {
	      let requestData = {};
	      if (notCommon$1.objHas(actionData, "data") && Array.isArray(actionData.data)) {
	        for (let i = 0; i < actionData.data.length; i++) {
	          let dataProviderName = "get" + notCommon$1.capitalizeFirstLetter(actionData.data[i]);
	          if (this[dataProviderName] && typeof this[dataProviderName] === "function") {
	            let data = this[dataProviderName](),
	              res = {};
	            if (["pager", "sorter", "filter", "search", "return"].indexOf(actionData.data[i]) > -1) {
	              res[actionData.data[i]] = data;
	            } else {
	              res = data;
	            }
	            requestData = Object.assign(requestData, res);
	          }
	        }
	      }
	      return requestData;
	    }
	  }, {
	    key: "getID",
	    value: function getID(record, actionData) {
	      let resultId,
	        list = OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY,
	        prefixes = ["", this.manifest.model];
	      if (notCommon$1.objHas(actionData, "index") && actionData.index) {
	        list = [actionData.index].concat(OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY);
	      }
	      for (let pre of prefixes) {
	        for (let t of list) {
	          if (notCommon$1.objHas(record, pre + t)) {
	            resultId = record[pre + t];
	            break;
	          }
	        }
	      }
	      return resultId;
	    }
	  }, {
	    key: "setFindBy",
	    value: function setFindBy(key, value) {
	      var obj = {};
	      obj[key] = value;
	      return this.setFilter(obj);
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(filterData = DEFAULT_FILTER) {
	      this.setWorking("filter", filterData);
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      return this.setFilter();
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getWorking("filter");
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(searchData = DEFAULT_SEARCH) {
	      this.setWorking("search", searchData);
	      return this;
	    }
	  }, {
	    key: "resetSearch",
	    value: function resetSearch() {
	      return this.setSearch();
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      return this.getWorking("search");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(sorterData) {
	      this.setWorking("sorter", sorterData);
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter() {
	      return this.setSorter({});
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(returnData = DEFAULT_RETURN) {
	      this.setWorking("return", returnData);
	      return this;
	    }
	  }, {
	    key: "resetReturn",
	    value: function resetReturn() {
	      return this.setReturn({});
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setPageNumber",
	    value: function setPageNumber(pageNumber) {
	      this.setWorking("pager.page", pageNumber);
	      return this;
	    }
	  }, {
	    key: "setPageSize",
	    value: function setPageSize(pageSize) {
	      this.setWorking("pager.size", pageSize);
	      return this;
	    }

	    //pageSize = DEFAULT_PAGE_SIZE, pageNumber = DEFAULT_PAGE_NUMBER
	  }, {
	    key: "setPager",
	    value: function setPager() {
	      if ((arguments.length < 2 || isNaN(arguments[0]) || isNaN(arguments[1])) && arguments[0].constructor === Object && notCommon$1.objHas(arguments[0], "page") && notCommon$1.objHas(arguments[0], "size")) {
	        const pager = arguments[0];
	        this.setWorking("pager", {
	          size: pager.size || DEFAULT_PAGE_SIZE,
	          page: pager.page || DEFAULT_PAGE_NUMBER
	        });
	      } else if (arguments.length === 2 && !isNaN(arguments[0]) && !isNaN(arguments[1])) {
	        this.setWorking("pager", {
	          size: arguments[0] || DEFAULT_PAGE_SIZE,
	          page: arguments[1] || DEFAULT_PAGE_NUMBER
	        });
	      }
	      return this;
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      return this.setPager();
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getWorking("pager");
	    }
	  }, {
	    key: "getRecord",
	    value: function getRecord() {
	      this.getData();
	    }
	  }, {
	    key: "getDefaultAsPlainObject",
	    value: function getDefaultAsPlainObject() {
	      if (!this.manifest || !this.manifest.fields) {
	        return {};
	      }
	      const result = {};
	      for (const fieldName of Object.keys(this.manifest.fields)) {
	        if (Object.hasOwn(this.manifest.fields[fieldName], "default")) {
	          const defaultValue = this.manifest.fields[fieldName].default;
	          if (Array.isArray(defaultValue)) {
	            result[fieldName] = [...defaultValue];
	          } else if (typeof defaultValue === "object") {
	            result[fieldName] = {
	              ...defaultValue
	            };
	          } else {
	            result[fieldName] = defaultValue;
	          }
	        }
	      }
	      return result;
	    }
	  }]);
	}(notBase);

	let notRecord = /*#__PURE__*/function (_notBase) {
	  function notRecord(manifest, item) {
	    var _this;
	    _classCallCheck(this, notRecord);
	    _this = _callSuper(this, notRecord);
	    if (typeof item === "undefined" || item === null || typeof item !== "object") {
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && item.isProxy) {
	      notCommon$1.error("this is Proxy item");
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && (item.isRecord || item.isProperty)) {
	      return _possibleConstructorReturn(_this, item);
	    } else {
	      if (Array.isArray(item)) {
	        return _possibleConstructorReturn(_this, _this.createCollection(manifest, item));
	      }
	    }
	    _this.setOptions({});
	    _this[META_INTERFACE] = new notInterface(manifest, {});
	    _this.setData(item);
	    _this.interfaceUp();
	    _this.mapToInterface();
	    _this.mapToMethods();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notRecord, _notBase);
	  return _createClass(notRecord, [{
	    key: "toDefault",
	    value: function toDefault() {
	      return this.setData(this[META_INTERFACE].getDefaultAsPlainObject());
	    }
	  }, {
	    key: "mapToInterface",
	    value: function mapToInterface() {
	      let rec = this;
	      for (let t of META_MAP_TO_INTERFACE) {
	        if (this[META_INTERFACE][t] && typeof this[META_INTERFACE][t] === "function") {
	          this[t] = function () {
	            let res = rec[META_INTERFACE][t](...arguments);
	            return res == rec[META_INTERFACE] ? rec : res;
	          };
	        }
	      }
	    }
	  }, {
	    key: "mapToMethods",
	    value: function mapToMethods() {
	      let manifest = this[META_INTERFACE].manifest,
	        app = notCommon$1.getApp(),
	        methods = {};
	      if (manifest.methods) {
	        methods = manifest.methods;
	      } else if (app) {
	        methods = app.getOptions(["models", this[META_INTERFACE].manifest.model].join("."), {});
	      }
	      if (methods) {
	        for (let t in methods) {
	          if (Object.hasOwn(methods, t)) {
	            this[t] = methods[t];
	          }
	        }
	      }
	    }
	  }, {
	    key: "createCollection",
	    value: function createCollection(manifest, items) {
	      var collection = [];
	      for (var i = 0; i < items.length; i++) {
	        collection.push(new notRecord(manifest, items[i]));
	      }
	      return collection;
	    }
	  }, {
	    key: "interfaceUp",
	    value: function interfaceUp() {
	      if (this[META_INTERFACE].getActionsCount() > 0) {
	        let actions = this[META_INTERFACE].getActions();
	        for (let i in actions) {
	          this.actionUp(i, actions[i]);
	        }
	      }
	    }
	  }, {
	    key: "actionUp",
	    value: function actionUp(index) {
	      var _this2 = this;
	      if (!Object.hasOwn(this, [DEFAULT_ACTION_PREFIX$1 + index])) {
	        this[DEFAULT_ACTION_PREFIX$1 + index] = function (...params) {
	          return _this2[META_INTERFACE].request(_this2, index, ...params);
	        };
	      }
	    }
	    /*
	    -> 'path.to.key', valueOfKey
	    <- ok, with one onChange event triggered
	    */
	  }, {
	    key: "setAttr",
	    value: function setAttr(key, value) {
	      return this.setData(key, value);
	    }

	    /*
	    ->
	    {
	    'keyPath': value,
	    'key.subPath': value2,
	    'keyPath.0.title': value3
	    }
	    <- ok, with bunch of onChange events triggered
	    */
	  }, {
	    key: "setAttrs",
	    value: function setAttrs(objectPart) {
	      //notCommon.log('setAttrs', objectPart, Object.keys(objectPart));
	      if (objectPart && typeof objectPart === "object" && Object.keys(objectPart).length > 0) {
	        for (let path in objectPart) {
	          //notCommon.log('setAttrs one to go', path);
	          this.setAttr(path, objectPart[path]);
	        }
	      }
	    }

	    /*
	    -> 'pathToKey'
	    <- value1
	    */
	  }, {
	    key: "getAttr",
	    value: function getAttr(what, plain = false) {
	      let prx = this.getData(what, {});
	      if (plain) {
	        return notCommon$1.stripProxy(prx);
	      } else {
	        return prx;
	      }
	    }

	    /*
	    -> ['pathToKey', 'path.to.key', 'simpleKey',...]
	    <- [value1, value2, value3,...]
	    */
	  }, {
	    key: "getAttrs",
	    value: function getAttrs(what) {
	      let result = [];
	      if (what && what.length > 0) {
	        for (let path of what) {
	          result.push(this.getAttr(path));
	        }
	      }
	      return result;
	    }
	  }, {
	    key: "getManifest",
	    value: function getManifest() {
	      if (this[META_INTERFACE]) {
	        return this[META_INTERFACE].manifest;
	      } else {
	        return {};
	      }
	    }
	  }, {
	    key: "setItem",
	    value: function setItem(item) {
	      this.setData(item);
	      return this;
	    }
	  }]);
	}(notBase);

	/**
	 * @const {string} [OPT_CONTROLLER_PREFIX = "nc"] controller names prefix nc aka NotController
	 */
	const OPT_CONTROLLER_PREFIX = "nc";
	/**
	 * @const {string} [OPT_RECORD_PREFIX = "nr"] record names prefix nr aka NotRecord
	 */
	const OPT_RECORD_PREFIX = "nr";
	/**
	 * @const {string} [DEFAULT_WS_CLIENT_NAME = "main"] default name of WS client
	 */
	const DEFAULT_WS_CLIENT_NAME = "main";

	/**
	 * Class of application
	 * @class
	 */
	let notApp = /*#__PURE__*/function (_notBase) {
	  /**
	   * @class
	   * @param {object} options              application options
	   * @param {string} options.name         name
	   * @param {object} options.controllers  controllers
	   * @param {string}  options.manifestURL URL of network manifest with all available models/actions/fields requests options
	   */
	  function notApp(options) {
	    var _this;
	    _classCallCheck(this, notApp);
	    _this = _callSuper(this, notApp, [{
	      working: {
	        name: options.name,
	        interfaces: {},
	        controllers: notCommon$1.objHas(options, "controllers") ? options.controllers : {},
	        initController: null,
	        currentController: null,
	        uis: {},
	        wsc: {},
	        wss: {},
	        services: {}
	      },
	      options
	    }]);
	    _this?.log && _this.log("start app");
	    notCommon$1.register("app", _this);
	    _this.initManifest();
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Initializes application according to network manifest, which is retrieved from server
	   */
	  _inherits(notApp, _notBase);
	  return _createClass(notApp, [{
	    key: "initManifest",
	    value: function initManifest() {
	      var _this2 = this;
	      notCommon$1.getJSON(this.getOptions("manifestURL")).then(function (manifest) {
	        return _this2.setInterfaceManifest(manifest);
	      }).catch(function (e) {
	        return notCommon$1.report(e);
	      });
	    }

	    /**
	     * One page routing initialization
	     */
	  }, {
	    key: "initRouter",
	    value: function initRouter() {
	      this.setWorking("router", notRouter$1);
	      this.getWorking("router").setRoot(this.getOptions("router.root"));
	      notRouter$1.reRouteExisted();
	    }

	    /**
	     * Creates all the routes handlers and pushes them into router
	     */
	  }, {
	    key: "execRouter",
	    value: function execRouter() {
	      var routieInput = {};
	      for (let t = 0; t < this.getOptions("router.manifest").length; t++) {
	        let routeBlock = this.getOptions("router.manifest")[t],
	          paths = routeBlock.paths,
	          schemes = routeBlock.schemes,
	          controller = routeBlock.controller;
	        for (let i = 0; i < paths.length; i++) {
	          let pathScheme = schemes && Array.isArray(schemes) && schemes.length > i ? schemes[i] : false;
	          routieInput[paths[i]] = this.bindController(controller, pathScheme);
	        }
	      }
	      this.getWorking("router").addList(routieInput).listen(); //.navigate(this.getOptions('router.index'));
	    }

	    /**
	     * Sets interface manifest option
	     * @param {object}  manifest    interface manifest
	     */
	  }, {
	    key: "setInterfaceManifest",
	    value: function setInterfaceManifest(manifest) {
	      Object.freeze(manifest);
	      this.setOptions("interfaceManifest", manifest);
	      this.initRouter();
	      this.update();
	    }

	    /**
	     * returns constructor of interface model
	     * @param {string}  modelName   model name
	     * @returns {object}    interface model constructor
	     */
	  }, {
	    key: "getInterfaceManifest",
	    value: function getInterfaceManifest(modelName) {
	      if (modelName) {
	        return this.getOptions("interfaceManifest")[modelName];
	      } else {
	        return this.getOptions("interfaceManifest");
	      }
	    }

	    /**
	     * Updating Application, reloads interfaces, init controller launched, start again
	     */
	  }, {
	    key: "update",
	    value: function update() {
	      //нужно инициализировать
	      //модели полученными интерфейсами
	      this.updateInterfaces();
	      //иницилицировать и запустить контроллер инициализации
	      this.initController();
	      this.startApp();
	    }

	    /**
	     * Initialization of services, startup of routing
	     */
	  }, {
	    key: "startApp",
	    value: function startApp() {
	      this.initServices();
	      //создать контроллеры
	      //роутер и привязать к нему контроллеры
	      this.execRouter();
	      this.emit("afterStarted", this);
	    }

	    /**
	     *
	     * @param {object} controllerName controller constructor
	     * @param {string[]} controllerPathScheme
	     * @returns {function} function creates new controller instance and pass in notApp instance, arguments from router parser and pathScheme
	     */
	  }, {
	    key: "bindController",
	    value: function bindController(controllerName, controllerPathScheme) {
	      let app = this;
	      return function () {
	        new controllerName(app, arguments, controllerPathScheme);
	      };
	    }

	    /**
	     * Initializes 'initialization' controller which is runs once,
	     * to perform custom initializations routines by application code
	     */
	  }, {
	    key: "initController",
	    value: function initController() {
	      if (typeof this.getOptions("initController") !== "undefined") {
	        let initController = this.getOptions("initController");
	        this.setWorking("initController", new initController(this));
	      }
	    }

	    /**
	     * Returns working controller
	     * @returns {object} working controller
	     */
	  }, {
	    key: "getCurrentController",
	    value: function getCurrentController() {
	      return this.getWorking("currentController");
	    }

	    /**
	     * Destroyes working controller then sets provided as working
	     * @param {object} ctrl controller instance
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "setCurrentController",
	    value: function setCurrentController(ctrl) {
	      let oldCtrl = this.getCurrentController();
	      if (oldCtrl && oldCtrl.destroy) {
	        oldCtrl.destroy();
	      }
	      this.setWorking("currentController", ctrl);
	      return this;
	    }

	    /**
	     * Creates arrow function: (modelInitData = {}) => notRecord
	     * Factory that creates notRecord instances with binded
	     * recordManifest and provided data to initialize record
	     * @param {Object} recordManifest
	     * @return {function}
	     * @memberof notApp
	     */
	  }, {
	    key: "createInterfaceModelFactory",
	    value: function createInterfaceModelFactory(recordManifest) {
	      return function (recordData) {
	        return new notRecord(recordManifest, recordData);
	      };
	    }

	    /**
	     * Clears interfaces, recreates all according to Options.interafaceManifest
	     */
	  }, {
	    key: "updateInterfaces",
	    value: function updateInterfaces() {
	      this.clearInterfaces();
	      let manifests = this.getOptions("interfaceManifest");
	      if (manifests) {
	        for (let name in manifests) {
	          let recordManifest = manifests[name],
	            recordMethods = this.getOptions(["models", name].join("."), {});
	          recordManifest.methods = recordMethods;
	          const nameInt = this.createInterfaceModelFactory(recordManifest);
	          this.setInterface(name, nameInt);
	        }
	      }
	    }

	    /**
	     * Converts interface name (modelName) to standartizied prefixModelName
	     * @param {string} name interface model name
	     * @returns {string}    not record name
	     */
	  }, {
	    key: "getRecordName",
	    value: function getRecordName(name) {
	      return OPT_RECORD_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Converts controller name (controllerName) to standartizied prefixControllerName
	     * @param {string} name controller name
	     * @returns {string}    not controller name
	     */
	  }, {
	    key: "getControllerName",
	    value: function getControllerName(name) {
	      return OPT_CONTROLLER_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Sets named interface factory function
	     *
	     * @param {string} name
	     * @param {function} modelFactory
	     * @return {notApp}
	     * @memberof notApp
	     */
	  }, {
	    key: "setInterface",
	    value: function setInterface(name, modelFactory) {
	      return this.setWorking(`interfaces.${name}`, modelFactory);
	    }

	    /**
	     * Returns all network interfaces
	     * @returns {object} all network insterfaces
	     */
	  }, {
	    key: "getInterfaces",
	    value: function getInterfaces() {
	      return this.getWorking("interfaces");
	    }

	    /**
	     * Sets interfaces list clear
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "clearInterfaces",
	    value: function clearInterfaces() {
	      this.setWorking("interfaces", {});
	      return this;
	    }

	    /**
	     * Sets WebSockets client
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME] name of client
	     * @param {object} wsc  notWSClient instance
	     * @returns {object} notApp instance
	     */
	    // @ts-ignore
	  }, {
	    key: "setWSClient",
	    value: function setWSClient(name = DEFAULT_WS_CLIENT_NAME, wsc) {
	      return this.setWorking(`wsc.${name}`, wsc);
	    }

	    /**
	     * Returns web sockets client instance by name
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME]
	     * @returns {object} instance of notWSClient
	     */
	  }, {
	    key: "getWSClient",
	    value: function getWSClient(name = DEFAULT_WS_CLIENT_NAME) {
	      return this.getWorking(`wsc.${name}`);
	    }

	    /**
	     * returns network interface class initializator
	     * @param {string} name name of network interface
	     * @returns {function} interface class initializator
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name) {
	      return this.getInterfaces()[name];
	    }

	    /**
	     * Returns network interface (model) initialized with provided data
	     * @param {string} name interface(modelName)
	     * @param {object} [data={}]    model data
	     * @returns network interface initializes with provided data
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data = {}) {
	      return this.getInterface(name)(data);
	    }

	    /**
	     * Sets service
	     * @param {string} name name of the service
	     * @param {object|function} val service
	     */
	  }, {
	    key: "setService",
	    value: function setService(name, val) {
	      return this.setWorking(`services.${name}`, val);
	    }

	    /**
	     * Returns service
	     * @param {string} name name of the service
	     * @returns {object|function} service
	     */
	  }, {
	    key: "getService",
	    value: function getService(name) {
	      return this.getWorking(`services.${name}`);
	    }

	    /**
	     * Initializes all provided services
	     */
	  }, {
	    key: "initServices",
	    value: function initServices() {
	      if (this.getOptions("services")) {
	        for (let servName in this.getOptions("services")) {
	          try {
	            let serv = this.getOptions(`services.${servName}`);
	            const servType = notCommon$1.detectType(serv);
	            switch (servType) {
	              case "function":
	              case "class":
	                this.setService(servName, new serv(this));
	                break;
	              default:
	                this.setService(servName, serv);
	            }
	          } catch (e) {
	            this?.error && this.error(`Service (${servName}) init error`, e);
	          }
	        }
	      }
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} moduleName   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "getConfigReaderForModule",
	    value: function getConfigReaderForModule(moduleName = "") {
	      var _this3 = this;
	      const modConfPath = ["modules", moduleName].join(".");
	      return {
	        get: function (subPath, fallback) {
	          if (subPath && typeof subPath == "string" && subPath.length) {
	            return _this3.getOptions([modConfPath, subPath].join("."), fallback);
	          } else {
	            return _this3.getOptions(modConfPath, fallback);
	          }
	        }
	      };
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} [moduleName='']   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "moduleConfig",
	    value: function moduleConfig(moduleName = "") {
	      return this.getConfigReaderForModule(moduleName);
	    }
	  }]);
	}(notBase);
	/**
	 *  @static {function} DEFAULT_WS_CLIENT_NAME  function to perform deep merges of objects
	 */
	_defineProperty(notApp, "DEFAULT_WS_CLIENT_NAME", DEFAULT_WS_CLIENT_NAME);

	/**
	 * @const {string}  [OPT_DEFAULT_ACTION_NAME = "default"]      default action name
	 */
	const OPT_DEFAULT_ACTION_NAME = "default";

	/**
	 * @const {string}  [OPT_DEFAULT_CONTAINER_SELECTOR = "main.content"]  selector of container HTML
	 *                          element
	 */
	const OPT_DEFAULT_CONTAINER_SELECTOR = "main.content";

	/**
	 * @const {string}  [OPT_DEFAULT_PLURAL_NAME = "Models"]  default plural name of entities
	 */
	const OPT_DEFAULT_PLURAL_NAME = "Models";

	/**
	 * @const {string}  [OPT_DEFAULT_SINGLE_NAME = "Model"]  default single name of entities
	 */
	const OPT_DEFAULT_SINGLE_NAME = "Model";

	/**
	 * @const {string}  [OPT_DEFAULT_MODULE_NAME="main"]  default module name
	 */
	const OPT_DEFAULT_MODULE_NAME = "main";

	/**
	 * @const {boolean}  [OPT_DEFAULT_AUTO_NAME = true]  if shoould be used auto name generator
	 */
	const OPT_DEFAULT_AUTO_NAME = true;

	/**
	 *  Basic class for user controller
	 *  @extends notBase
	 */
	let notController = /*#__PURE__*/function (_notBase) {
	  /**
	   *  @class
	   *  @param {import('./app.js').default} app
	   *  @param  {string}    name
	   */
	  function notController(app, name) {
	    var _this;
	    _classCallCheck(this, notController);
	    _this = _callSuper(this, notController, [{}]);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "els", void 0);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "make", void 0);
	    /**
	     *
	     * @type    {null|import('./app.js').default}
	     * @memberof notController
	     */
	    _defineProperty(_this, "app", void 0);
	    _this.app = app;
	    _this.app.setCurrentController(_this);
	    _this.setWorking({
	      name,
	      ready: false,
	      views: {},
	      libs: {},
	      helpers: {}
	    });
	    _this.ui = {};
	    _this.els = {};
	    _this.setData({});
	    _this.setOptions({
	      moduleName: OPT_DEFAULT_MODULE_NAME,
	      containerSelector: OPT_DEFAULT_CONTAINER_SELECTOR,
	      prefix: app.getOptions("paths.module"),
	      names: {
	        plural: OPT_DEFAULT_PLURAL_NAME,
	        single: OPT_DEFAULT_SINGLE_NAME
	      }
	    });
	    _this.setURLPrefix(app.getOptions("router.root"));
	    /*
	    сразу делаем доступными модели notRecord из nc`ControllerName` будут доступны как this.nr`ModelName`
	    */
	    let interfaces = app.getInterfaces();
	    _this.make = {};
	    for (let t in interfaces) {
	      // @ts-ignore
	      if (Object.hasOwn(interfaces, t)) {
	        _this.make[t] = interfaces[t];
	      }
	    }
	    _this.on("destroy", function () {
	      _this.app = null;
	      for (let uiName in _this.ui) {
	        _this.ui[uiName].destroy && _this.ui[uiName].destroy();
	        _this.ui[uiName].$destroy && _this.ui[uiName].$destroy();
	        _this.ui[uiName] = null;
	      }
	      _this.els = null;
	      _this.make = null;
	    });
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   *  Returns current notApp
	   *  @return {import('./app.js').default}
	   */
	  _inherits(notController, _notBase);
	  return _createClass(notController, [{
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }

	    /**
	     *  Sets default controller model
	     *  @param {import('./record.js')}  model  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModel",
	    value: function setModel(model) {
	      this.setWorking("model", model);
	      return this;
	    }

	    /**
	     *  If zero or one argument provided this modelName instance will be returned
	     *  If two provided and first is a string than instance of name will be returned initialized with second object param or empty object
	     *  @param {string|object}      [name]    modelName of instance to return or initial data for instance
	     *  @param {object}             [data]    model data
	     *  @return {import('./record.js').default}
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        const int = this.getInterface(name);
	        return int && int(data || {});
	      } else {
	        const int = this.getInterface();
	        return int && int(name || {});
	      }
	    }

	    /**
	     * Returns controller interface if name is not specified or interface of specified
	     *
	     * @param {string} [name=""]
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = "") {
	      return this.app?.getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getWorking("modelName");
	    }
	    /**
	     *  Sets default controller model name
	     *  @param {string}  modelName  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelName",
	    value: function setModelName(modelName) {
	      this.setWorking("modelName", notCommon$1.lowerFirstLetter(modelName));
	      return this;
	    }

	    /**
	     *  Returns current model primary ID field name
	     *  @return {import('./record.js')}
	     */
	  }, {
	    key: "getModelIDFieldName",
	    value: function getModelIDFieldName() {
	      return this.getWorking("modelIDFieldName", "_id");
	    }

	    /**
	     *  Sets current model primary ID field name
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelIDFieldName",
	    value: function setModelIDFieldName(val = "_id") {
	      return this.setWorking("modelIDFieldName", val);
	    }

	    /**
	     *  Marks this controller as ready
	     *  emits "ready"/"busy" events
	     *  @param {Boolean}  val  true/false
	     */
	  }, {
	    key: "setReady",
	    value: function setReady(val = true) {
	      this.setWorking("ready", val);
	      val ? this.emit("ready") : this.emit("busy");
	    }

	    /**
	     *  Sets module URL prefix
	     *  @param {string} val URL prefix
	     *  @return {notController} this
	     */
	  }, {
	    key: "setURLPrefix",
	    value: function setURLPrefix(val) {
	      this.setOptions("urlPrefix", val);
	      this.updateAutoName();
	      return this;
	    }

	    /**
	     *  Returns module url prefix
	     *  @return  {string} prefix
	     */
	  }, {
	    key: "getURLPrefix",
	    value: function getURLPrefix() {
	      return this.getOptions("urlPrefix");
	    }

	    /**
	     *  Sets module name
	     *  @param {string} val name of the module
	     *  @return {notController} this
	     */
	  }, {
	    key: "setModuleName",
	    value: function setModuleName(val) {
	      this.setOptions("moduleName", notCommon$1.lowerFirstLetter(val));
	      this.updateAutoName();
	      return this;
	    }
	    /**
	     *  Returns module name
	     *  @return  {string} module name
	     */
	  }, {
	    key: "getModuleName",
	    value: function getModuleName() {
	      return this.getOptions("moduleName");
	    }

	    /**
	     *  Returns this module path prefix
	     *  @return {string}  path to module dir
	     */
	  }, {
	    key: "getModulePrefix",
	    value: function getModulePrefix() {
	      return [notCommon$1.getApp().getOptions("paths.modules"), this.getModuleName()].join("/");
	    }

	    /**
	     *  Returns this model URL with URL prefix
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelURL",
	    value: function getModelURL() {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName()
	      });
	    }

	    /**
	     *  Returns this model action URL with URL prefix
	     * @param  {string}   id       some identificator of model
	     * @param  {string}   action   action name
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelActionURL",
	    value: function getModelActionURL(id, action = "") {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName(),
	        id,
	        action
	      });
	    }

	    /**
	     * Creates url from value content
	     * @param {object}  val
	     **/
	  }, {
	    key: "buildURL",
	    value: function buildURL(val) {
	      return notCommon$1.buildURL(val);
	    }

	    /**
	     *  Updates working name
	     *  @return {notController} this
	     */
	  }, {
	    key: "updateAutoName",
	    value: function updateAutoName() {
	      if (this.getOptions("autoName", OPT_DEFAULT_AUTO_NAME)) ;
	      return this;
	    }

	    /**
	     *  Sets object name
	     *  @param {string} val name of the object
	     *  @return {notController} this
	     */
	  }, {
	    key: "setName",
	    value: function setName(val) {
	      this.setWorking("name", val);
	      this.setOptions("autoName", false);
	      return this;
	    }

	    /**
	     *  Gets object name
	     *  @return {string}
	     */
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }

	    /**
	     *  Preload records from server, using listAll method,
	     *  returns Promise
	     *  @param {object}  list  map of preloaded records
	     *  @return {Promise}
	     */
	  }, {
	    key: "preloadLib",
	    value: function preloadLib(list = {}) {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        if (typeof list !== "object") {
	          resolve(undefined);
	        } else {
	          _this2.setWorking("loading", []);
	          for (let t in list) {
	            _this2.getWorking("loading").push(list[t]);
	            _this2.make[list[t]]({}).$listAll().then(function (data) {
	              if (!_this2.getOptions("libs")) {
	                _this2.setOptions("libs", {});
	              }
	              _this2.getOptions("libs")[t] = data;
	              if (_this2.getWorking("loading").indexOf(list[t]) > -1) {
	                _this2.getWorking("loading").splice(_this2.getWorking("loading").indexOf(list[t]), 1);
	              }
	              if (_this2.getWorking("loading").length === 0) {
	                resolve(undefined);
	              }
	            }).catch(function (err) {
	              _this2.report(err);
	              reject();
	            });
	          }
	          if (_this2.getWorking("loading").length === 0) {
	            resolve(undefined);
	          }
	        }
	      });
	    }

	    /**
	     * emits afterRender event
	     */
	  }, {
	    key: "onAfterRender",
	    value: function onAfterRender() {
	      this.emit("afterRender");
	    }

	    /**
	     *  Transform route name in action name
	     *  @param {String}   name tranform action name
	     *  @return {String}
	     */
	  }, {
	    key: "getActionName",
	    value: function getActionName(name = OPT_DEFAULT_ACTION_NAME) {
	      return "run" + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     *  Get default controller action name
	     *  @return {String} default action from options
	     */
	  }, {
	    key: "getDefaultActionName",
	    value: function getDefaultActionName() {
	      return this.getActionName(this.getOptions("defaultAction", OPT_DEFAULT_ACTION_NAME));
	    }

	    /**
	     *  Route params into specific run[Route_name] function
	     *  @param {array}   params   controller input params
	     *  @return {undefined}
	     */
	  }, {
	    key: "route",
	    value: function route(params) {
	      let [routerName, ...subParams] = params,
	        actionName = this.getActionName(routerName ? routerName : OPT_DEFAULT_ACTION_NAME);
	      if (typeof this[actionName] === "function") {
	        this.setCurrentAction(actionName);
	        this[actionName](subParams);
	      } else if (this[this.getDefaultActionName()]) {
	        this.setCurrentAction(this.getDefaultActionName());
	        this[this.getDefaultActionName()](subParams);
	      } else {
	        this.setCurrentAction(undefined);
	        this.error && this.error("No action in router", params);
	      }
	    }

	    /**
	     * Sets working action
	     * @params {string} actionName current action name
	     */
	  }, {
	    key: "setCurrentAction",
	    value: function setCurrentAction(actionName) {
	      this.setWorking("action", actionName);
	    }

	    /**
	     * Gets working action
	     * @returns {string} current action name
	     */
	  }, {
	    key: "getCurrentAction",
	    value: function getCurrentAction() {
	      return this.getWorking("action");
	    }

	    /**
	     *  Return application options
	     *  @return {object}
	     */
	  }, {
	    key: "getAppOptions",
	    value: function getAppOptions() {
	      try {
	        return this.getApp().getOptions();
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module options
	     *  @param  {string}   [moduleName]    name of the module which options requested
	     *  @return {object}
	     */
	  }, {
	    key: "getModuleOptions",
	    value: function getModuleOptions(moduleName) {
	      try {
	        return this.getApp().getOptions(["modules", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module services
	     *  @param  {string}   moduleName    name of the module which services requested
	     *  @return {object}
	     */
	  }, {
	    key: "getServices",
	    value: function getServices(moduleName) {
	      try {
	        return this.getApp().getOptions(["services", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module components
	     *  @param  {string}   moduleName    name of the module which components requested
	     *  @return {object}
	     */
	  }, {
	    key: "getComponents",
	    value: function getComponents(moduleName) {
	      try {
	        return this.getApp().getOptions(["components", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Refreshes current URL, re-run all action
	     *  @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      this.app?.getWorking("router").refresh(timeout);
	    }

	    /**
	     * Returns path pattern for router
	     * @params {number} [0] paramsCount   number of params
	     * @return {string}  pattern for controller supported url
	     */
	  }, {
	    key: "getRouter",
	    value:
	    /**
	     * Returns Application router
	     * @returns {import('./router.js').default}
	     */
	    function getRouter() {
	      return this.app?.getWorking("router");
	    }

	    /**
	     * Changes location to `url` after `delay` ms
	     * @param {string} url
	     * @param {number|string}   delay   number in ms or name of delay
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay = NAVIGATION_DELAY_DEFAULT, doBefore = function () {}) {
	      return this.getRouter().navigateWithDelay(url, delay, doBefore);
	    }

	    /**
	     * Changes location to `url`
	     * @param {string} url
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      return this.getRouter().navigate(url);
	    }

	    /**
	     *  Navigating to this controller main model `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateAction",
	    value: function navigateAction(id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), this.getModelName(), id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to this controller module model of `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModelAction",
	    value: function navigateModelAction(modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), modelName, id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to `moduleName` `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} moduleName
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModuleAction",
	    value: function navigateModuleAction(moduleName, modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      if (delay) {
	        return this.getRouter().navigateWithDelay(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }), delay, doBefore);
	      } else {
	        return this.getRouter().navigate(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }));
	      }
	    }

	    /**
	     * Creates menu item from child class constructor
	     *
	     * @static
	     * @param {notController} childConstructor
	     * @return {Array<import('./types.js').NavigationItem>}
	     * @memberof notController
	     */
	  }], [{
	    key: "MODULE_NAME",
	    get:
	    /**
	     *  @static {string} MODULE_NAME  name of module
	     */
	    function () {
	      return OPT_DEFAULT_MODULE_NAME;
	    }
	    /**
	     *  @static {string} MODEL_NAME  name of model
	     */
	  }, {
	    key: "MODEL_NAME",
	    get: function () {
	      return "ModelName";
	    }
	  }, {
	    key: "LABELS",
	    get: function () {
	      return {
	        plural: `${OPT_DEFAULT_MODULE_NAME}:model_label_plural`,
	        single: `${OPT_DEFAULT_MODULE_NAME}:model_label_single`
	      };
	    }
	  }, {
	    key: "getControllerRoute",
	    value: function getControllerRoute(paramsCount = 0) {
	      let path = [];
	      if (this.MODULE_NAME && this.MODULE_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODULE_NAME));
	      }
	      if (this.MODEL_NAME && this.MODEL_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODEL_NAME));
	      }
	      path = [path.join("/")];
	      for (let i = 0; i < paramsCount; i++) {
	        path.push("/([^/]+)");
	      }
	      return path.join("");
	    }

	    /**
	     * Returns path patterns for router
	     * @params {number} [0] paramsDeep   how many paths with params in the end
	     * @return {string[]}  patterns for controller supported url in order of simplification
	     */
	  }, {
	    key: "getControllerRoutes",
	    value: function getControllerRoutes(paramsDeep = 0) {
	      let routes = [this.getControllerRoute(0)];
	      for (let i = 0; i < paramsDeep; i++) {
	        routes.unshift(this.getControllerRoute(i + 1));
	      }
	      return routes;
	    }

	    /**
	     * Returns router rule.
	     * @returns {Object} router rule {paths:String[], controller:notController}
	     */
	  }, {
	    key: "getRoutes",
	    value: function getRoutes() {
	      return {
	        paths: this.getControllerRoutes(this.PARAMS_LENGTH),
	        controller: this
	      };
	    }
	  }, {
	    key: "getCommonMenu",
	    value: function getCommonMenu(childConstructor) {
	      return [{
	        // @ts-ignore
	        section: childConstructor.MODULE_NAME,
	        // @ts-ignore
	        title: childConstructor.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(
        // @ts-ignore
        childConstructor.MODULE_NAME
        // @ts-ignore
        )}/${notCommon$1.lowerFirstLetter(childConstructor.MODEL_NAME)}`
	      }];
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu() {}
	  }]);
	}(notBase);
	/**
	 *  @static {number} PARAMS_LENGTH  number of params in URL path
	 */
	_defineProperty(notController, "PARAMS_LENGTH", 2);

	const ALL = {};
	function exist(key) {
	  return Object.hasOwn(ALL, key);
	}
	function get(key) {
	  if (exist(key)) {
	    return ALL[key];
	  } else {
	    return false;
	  }
	}
	function create(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL[key];
	}

	var root$b = from_html(`<input type="checkbox"/> <label class="label"></label>`, 1);

	function Ui_switch($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {boolean} [value]
		 * @property {string} [fieldname]
		 * @property {boolean} [disabled]
		 * @property {boolean} [readonly]
		 * @property {string} [styling]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ''),
			value = prop($$props, 'value', 15, false),
			fieldname = prop($$props, 'fieldname', 3, 'switch'),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			styling = prop($$props, 'styling', 3, " is-rounded is-success ");

		function onInput(ev) {
			let data = {
				id: id(),
				field: fieldname(),
				value: ev.target.type === 'checkbox' ? ev.target.checked : ev.target.value
			};

			dispatch('change', data);

			return true;
		}

		var fragment = root$b();
		var input = first_child(fragment);

		remove_input_defaults(input);
		input.__input = onInput;

		var label = sibling(input, 2);

		template_effect(() => {
			set_class(input, 1, `switch ${styling() ?? ''}`);
			set_attribute(input, 'id', `edit-table-row-cell-inline-switch-${fieldname() ?? ''}-${id() ?? ''}`);
			set_attribute(input, 'name', fieldname());
			input.readOnly = readonly();
			input.disabled = disabled();
			set_attribute(label, 'for', `edit-table-row-cell-inline-switch-${fieldname() ?? ''}-${id() ?? ''}`);
		});

		bind_checked(input, value);
		append($$anchor, fragment);
		pop();
	}

	delegate(['input']);

	var root_3$5 = from_html(`<a> </a>`);
	var root_2$5 = from_html(`<div class="mx-1 tags has-addons svelte-1557h41"><span class="tag"> </span> <span><!></span></div>`);
	var root_6$5 = from_html(`<a> </a>`);
	var root_5$5 = from_html(`<span><!></span>`);

	function Ui_tags($$anchor, $$props) {
		/*
		  import { createEventDispatcher } from 'svelte';
		  let dispatch = createEventDispatcher();
		*/
		/**
		 * @typedef {Object} Props
		 * @property {any} [values] - item = {
		id,        //unique
		title,     //some text
		value,      //for double tags
		color       //coloring
		}
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []);

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.id, ($$anchor, item) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var div = root_2$5();
					var span = child(div);
					var text$1 = child(span, true);

					reset(span);

					var span_1 = sibling(span, 2);
					var node_2 = child(span_1);

					{
						var consequent = ($$anchor) => {
							var a = root_3$5();
							var text_1 = child(a, true);

							reset(a);

							template_effect(() => {
								set_attribute(a, 'href', get$3(item).url);
								set_class(a, 1, clsx(get$3(item).urlCustomClasses), 'svelte-1557h41');
								set_text(text_1, get$3(item).value);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							var text_2 = text();

							template_effect(() => set_text(text_2, get$3(item).value));
							append($$anchor, text_2);
						};

						if_block(node_2, ($$render) => {
							if (get$3(item).url) $$render(consequent); else $$render(alternate, false);
						});
					}

					reset(span_1);
					reset(div);

					template_effect(() => {
						set_text(text$1, get$3(item).title);
						set_class(span_1, 1, `tag is-${get$3(item).color ?? ''} ${get$3(item).customClasses ?? ''}`, 'svelte-1557h41');
					});

					append($$anchor, div);
				};

				var alternate_2 = ($$anchor) => {
					var span_2 = root_5$5();
					var node_3 = child(span_2);

					{
						var consequent_2 = ($$anchor) => {
							var a_1 = root_6$5();
							var text_3 = child(a_1, true);

							reset(a_1);

							template_effect(() => {
								set_attribute(a_1, 'href', get$3(item).url);
								set_class(a_1, 1, clsx(get$3(item).urlCustomClasses), 'svelte-1557h41');
								set_text(text_3, get$3(item).title);
							});

							append($$anchor, a_1);
						};

						var alternate_1 = ($$anchor) => {
							var text_4 = text();

							template_effect(() => set_text(text_4, get$3(item).title));
							append($$anchor, text_4);
						};

						if_block(node_3, ($$render) => {
							if (get$3(item).url) $$render(consequent_2); else $$render(alternate_1, false);
						});
					}

					reset(span_2);
					template_effect(() => set_class(span_2, 1, `mx-1 tag is-${get$3(item).color ?? ''} ${get$3(item).customClasses ?? ''}`, 'svelte-1557h41'));
					append($$anchor, span_2);
				};

				if_block(node_1, ($$render) => {
					if (Object.hasOwn(get$3(item), "value")) $$render(consequent_1); else $$render(alternate_2, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$a = from_html(`<td><!></td>`);

	function NotTableCell($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let title = state("");

		onMount(() => {
			if (typeof field().type === "undefined") {
				if (Object.hasOwn(field(), "titlePath")) {
					set(title, notPath.get(field().titlePath, item(), helpers()), true);
				} else if (Object.hasOwn(field(), "titleComposer") && typeof field().titleComposer === "function") {
					set(title, field().titleComposer(item(), helpers()), true);
				} else {
					set(title, notPath.get(field().path, item(), helpers()), true);
				}
			}
		});

		let getItemId = prop($$props, 'getItemId', 3, (item) => item._id),
			field = prop($$props, 'field', 19, () => ({})),
			item = prop($$props, 'item', 19, () => ({})),
			helpers = prop($$props, 'helpers', 19, () => ({}));

		var td = root$a();
		var node = child(td);

		{
			var consequent = ($$anchor) => {
				{
					let $0 = user_derived(() => notPath.get(field().path, item(), helpers()));

					Ui_links($$anchor, {
						get values() {
							return get$3($0);
						}
					});
				}
			};

			var alternate_7 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						{
							let $0 = user_derived(() => notPath.get(field().path, item(), helpers()));

							Ui_buttons($$anchor, {
								get values() {
									return get$3($0);
								}
							});
						}
					};

					var alternate_6 = ($$anchor) => {
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								{
									let $0 = user_derived(() => notPath.get(field().path, item(), helpers()));

									Ui_images($$anchor, {
										get values() {
											return get$3($0);
										}
									});
								}
							};

							var alternate_5 = ($$anchor) => {
								var fragment_5 = comment();
								var node_3 = first_child(fragment_5);

								{
									var consequent_3 = ($$anchor) => {
										{
											let $0 = user_derived(() => notPath.get(field().path, item(), helpers()));

											Ui_booleans($$anchor, {
												get values() {
													return get$3($0);
												}
											});
										}
									};

									var alternate_4 = ($$anchor) => {
										var fragment_7 = comment();
										var node_4 = first_child(fragment_7);

										{
											var consequent_4 = ($$anchor) => {
												{
													let $0 = user_derived(() => notPath.get(field().path, item(), helpers()));

													Ui_tags($$anchor, {
														get values() {
															return get$3($0);
														}
													});
												}
											};

											var alternate_3 = ($$anchor) => {
												var fragment_9 = comment();
												var node_5 = first_child(fragment_9);

												{
													var consequent_5 = ($$anchor) => {
														{
															let $0 = user_derived(() => getItemId()(item()));
															let $1 = user_derived(() => notPath.get(field().path, item(), helpers()));

															Ui_switch($$anchor, {
																get id() {
																	return get$3($0);
																},

																get fieldname() {
																	return field().path;
																},

																get value() {
																	return get$3($1);
																},

																get disabled() {
																	return field().disabled;
																},

																get readonly() {
																	return field().readonly;
																},

																$$events: {
																	change(...$$args) {
																		field().onChange?.apply(this, $$args);
																	}
																}
															});
														}
													};

													var alternate_2 = ($$anchor) => {
														var fragment_11 = comment();
														var node_6 = first_child(fragment_11);

														{
															var consequent_6 = ($$anchor) => {
																var fragment_12 = comment();
																var node_7 = first_child(fragment_12);

																{
																	let $0 = user_derived(() => getItemId()(item()));
																	let $1 = user_derived(() => notPath.get(field().path, item(), helpers()));

																	component(node_7, () => field().component, ($$anchor, field_component) => {
																		field_component($$anchor, spread_props(
																			{
																				get id() {
																					return get$3($0);
																				},

																				get fieldname() {
																					return field().path;
																				},

																				get disabled() {
																					return field().disabled;
																				},

																				get readonly() {
																					return field().readonly;
																				},

																				get value() {
																					return get$3($1);
																				}
																			},
																			() => field().options,
																			{
																				$$events: {
																					change(...$$args) {
																						field().onChange?.apply(this, $$args);
																					}
																				}
																			}
																		));
																	});
																}

																append($$anchor, fragment_12);
															};

															var alternate_1 = ($$anchor) => {
																var fragment_13 = comment();
																var node_8 = first_child(fragment_13);

																{
																	var consequent_7 = ($$anchor) => {
																		var text$1 = text();

																		template_effect(($0) => set_text(text$1, $0), [
																			() => notCommon$1.strLengthCap(notPath.get(field().path, item(), helpers()), field().maxLength)
																		]);

																		append($$anchor, text$1);
																	};

																	var alternate = ($$anchor) => {
																		var text_1 = text();

																		template_effect(($0) => set_text(text_1, $0), [
																			() => $LOCALE()[notPath.get(field().path, item(), helpers())]
																		]);

																		append($$anchor, text_1);
																	};

																	if_block(
																		node_8,
																		($$render) => {
																			if (field() && typeof field() !== "undefined" && !isNaN(field().maxLength) && field().maxLength) $$render(consequent_7); else $$render(alternate, false);
																		},
																		true
																	);
																}

																append($$anchor, fragment_13);
															};

															if_block(
																node_6,
																($$render) => {
																	if (field().component) $$render(consequent_6); else $$render(alternate_1, false);
																},
																true
															);
														}

														append($$anchor, fragment_11);
													};

													if_block(
														node_5,
														($$render) => {
															if (field().type === "switch") $$render(consequent_5); else $$render(alternate_2, false);
														},
														true
													);
												}

												append($$anchor, fragment_9);
											};

											if_block(
												node_4,
												($$render) => {
													if (field().type === "tag") $$render(consequent_4); else $$render(alternate_3, false);
												},
												true
											);
										}

										append($$anchor, fragment_7);
									};

									if_block(
										node_3,
										($$render) => {
											if (field().type === "boolean") $$render(consequent_3); else $$render(alternate_4, false);
										},
										true
									);
								}

								append($$anchor, fragment_5);
							};

							if_block(
								node_2,
								($$render) => {
									if (field().type === "image") $$render(consequent_2); else $$render(alternate_5, false);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (field().type === "button") $$render(consequent_1); else $$render(alternate_6, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (field().type === "link") $$render(consequent); else $$render(alternate_7, false);
			});
		}

		reset(td);

		template_effect(() => {
			set_class(td, 1, (field().hideOnMobile ? " is-hidden-touch " : "") + (field().classes ? ` ${field().classes} ` : ""));
			set_attribute(td, 'title', get$3(title));
		});

		append($$anchor, td);
		pop();
		$$cleanup();
	}

	var root_1$8 = from_html(`<td><input type="checkbox" placeholder=""/></td>`);
	var root$9 = from_html(`<tr><!><!></tr>`);

	function NotTableRow($$anchor, $$props) {
		push($$props, true);

		const $selectedList = () => store_get(selectedList, '$selectedList', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let dispatch = createEventDispatcher();
		let itemId = state(void 0), selectedList;

		onMount(() => {
			set(itemId, getItemId()(item()), true);
			selectedList = get($$props.id).selected;
		});

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} [item]
		 * @property {any} [helpers]
		 * @property {any} [fields]
		 * @property {boolean} [showSelect]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let item = prop($$props, 'item', 19, () => ({})),
			helpers = prop($$props, 'helpers', 19, () => ({})),
			fields = prop($$props, 'fields', 19, () => []),
			showSelect = prop($$props, 'showSelect', 3, false),
			getItemId = prop($$props, 'getItemId', 3, () => {});

		function onRowSelect(e) {
			e.preventDefault();
			dispatch('rowSelectChange', { id: get$3(itemId), selected: $selectedList()[get$3(itemId)] });

			return false;
		}

		var tr = root$9();
		var node = child(tr);

		{
			var consequent = ($$anchor) => {
				var td = root_1$8();
				var input = child(td);

				remove_input_defaults(input);
				input.__change = onRowSelect;
				reset(td);

				template_effect(
					($0, $1, $2) => {
						set_attribute(input, 'id', `table-row-select-${$0 ?? ''}`);
						set_attribute(input, 'data-id', $1);
						set_attribute(input, 'name', `row_selected_${$2 ?? ''}`);
					},
					[
						() => getItemId()(item()),
						() => getItemId()(item()),
						() => getItemId()(item())
					]
				);

				bind_checked(input, () => $selectedList()[get$3(itemId)], ($$value) => store_mutate(selectedList, untrack($selectedList)[get$3(itemId)] = $$value, untrack($selectedList)));
				append($$anchor, td);
			};

			if_block(node, ($$render) => {
				if (showSelect() && $selectedList()) $$render(consequent);
			});
		}

		var node_1 = sibling(node);

		each(node_1, 17, fields, index$e, ($$anchor, field) => {
			NotTableCell($$anchor, {
				get field() {
					return get$3(field);
				},

				get helpers() {
					return helpers();
				},

				get item() {
					return item();
				},

				get getItemId() {
					return getItemId();
				}
			});
		});

		reset(tr);
		append($$anchor, tr);
		pop();
		$$cleanup();
	}

	delegate(['change']);

	var root_1$7 = from_html(`<div class="field is-grouped"><!></div>`);
	var root_2$4 = from_html(`<div class="field is-grouped"><!></div>`);
	var root_5$4 = from_html(`<div class="field"><div class="control"><input class="input" type="text" placeholder="Поиск"/></div></div>`);
	var root_6$4 = from_html(`<th><input type="checkbox" id="table-row-select-page" placeholder="" name="row_selected_all"/></th>`);
	var root_7$2 = from_html(`<th><!></th>`);
	var root_14$1 = from_html(`<a href="" class="pagination-link is-current" aria-current="page"> </a>`);
	var root_15$1 = from_html(`<a href="" class="pagination-link"> </a>`);
	var root_13 = from_html(`<li><!></li>`);
	var root_11$1 = from_html(`<nav class="pagination is-centered" aria-label="pagination"><a href="" class="pagination-previous">Назад</a> <a href="" class="pagination-next">Вперед</a> <ul class="pagination-list"><!></ul></nav>`);
	var root$8 = from_html(`<!> <!> <!> <table class="table"><thead><tr><!><!></tr></thead><tbody></tbody></table> <!>`, 1);

	function NotTable($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} filterUI
		 * @property {any} [helpers]
		 * @property {any} [state]
		 * @property {any} [filter]
		 * @property {any} [sorter]
		 * @property {any} [fields]
		 * @property {any} [selected]
		 * @property {any} [items]
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {string} [search]
		 * @property {boolean} [showSearch]
		 * @property {boolean} [showSelect]
		 * @property {boolean} [selectAll]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let helpers = prop($$props, 'helpers', 19, () => ({})),
			state = prop($$props, 'state', 31, () => proxy({})),
			filter = prop($$props, 'filter', 31, () => proxy({})),
			sorter = prop($$props, 'sorter', 31, () => proxy({})),
			fields = prop($$props, 'fields', 19, () => []),
			selected = prop($$props, 'selected', 31, () => proxy({})),
			items = prop($$props, 'items', 31, () => proxy([])),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			search = prop($$props, 'search', 15, ""),
			showSearch = prop($$props, 'showSearch', 3, true),
			showSelect = prop($$props, 'showSelect', 3, true),
			selectAll = prop($$props, 'selectAll', 15, false),
			getItemId = prop($$props, 'getItemId', 3, (item) => item._id);

		onMount(() => {
			if (showSelect()) {
				get($$props.id).selected.subscribe((value) => {
					selected(value);
				});
			}

			get($$props.id).refined.subscribe((value) => {
				items(value);

				if (showSelect()) {
					for (let itemId in selected()) {
						if (!items().some((item) => getItemId()(item) === itemId)) {
							delete selected()[itemId];
						} else {
							if (!Object.hasOwn(selected(), itemId)) {
								selected(selected()[itemId] = false, true);
							}
						}
					}

					selected(selected());
				}
			});

			get($$props.id).state.subscribe((value) => {
				state(value);
			});
		});

		function onSearchInput(ev) {
			try {
				let data = ev.currentTarget.value.trim();

				dispatch("searchChange", data);
			} catch {
				return;
			}
		}

		function onSearchChange({ detail }) {
			try {
				dispatch("searchChange", detail);
			} catch {
				return;
			}
		}

		function onFilterChange({ detail }) {
			try {
				dispatch("filterChange", detail);
			} catch {
				return;
			}
		}

		function goPrev() {
			dispatch("goToPrevPage");
		}

		function goNext() {
			dispatch("goToNextPage");
		}

		function goTo(e) {
			e.preventDefault();

			let el = e.target;

			dispatch("goToPage", parseInt(el.dataset.page));

			return false;
		}

		function onSelectAll() {
			get($$props.id).selected.update((value) => {
				items().forEach((item) => {
					value[getItemId()(item)] = selectAll();
				});

				return value;
			});
		}

		function onFieldHeadClick(field) {
			const propPath = field.path.substring(1);

			if (Object.hasOwn(sorter(), propPath)) {
				sorter(sorter()[propPath] = parseInt(sorter()[propPath]) * -1, true);
			} else {
				sorter({ [propPath]: 1 });
			}

			dispatch("sorterChange", sorter());
		}

		var fragment = root$8();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$7();
				var node_1 = child(div);

				Ui_links(node_1, {
					get values() {
						return links();
					}
				});

				reset(div);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (links().length) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_1 = root_2$4();
				var node_3 = child(div_1);

				Ui_buttons(node_3, {
					get values() {
						return actions();
					}
				});

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_2, ($$render) => {
				if (actions().length) $$render(consequent_1);
			});
		}

		var node_4 = sibling(node_2, 2);

		{
			var consequent_3 = ($$anchor) => {
				var fragment_1 = comment();
				var node_5 = first_child(fragment_1);

				{
					var consequent_2 = ($$anchor) => {
						const SvelteComponent = user_derived(() => $$props.filterUI);
						var fragment_2 = comment();
						var node_6 = first_child(fragment_2);

						component(node_6, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
							SvelteComponent_1($$anchor, {
								get filter() {
									return filter();
								},

								set filter($$value) {
									filter($$value);
								},

								$$events: { change: onFilterChange, searchChange: onSearchChange }
							});
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_5$4();
						var div_3 = child(div_2);
						var input = child(div_3);

						remove_input_defaults(input);
						input.__input = onSearchInput;
						reset(div_3);
						reset(div_2);
						bind_value(input, search);
						append($$anchor, div_2);
					};

					if_block(node_5, ($$render) => {
						if ($$props.filterUI) $$render(consequent_2); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node_4, ($$render) => {
				if (showSearch()) $$render(consequent_3);
			});
		}

		var table = sibling(node_4, 2);
		var thead = child(table);
		var tr = child(thead);
		var node_7 = child(tr);

		{
			var consequent_4 = ($$anchor) => {
				var th = root_6$4();
				var input_1 = child(th);

				remove_input_defaults(input_1);
				input_1.__change = onSelectAll;
				reset(th);
				bind_checked(input_1, selectAll);
				append($$anchor, th);
			};

			if_block(node_7, ($$render) => {
				if (showSelect()) $$render(consequent_4);
			});
		}

		var node_8 = sibling(node_7);

		each(node_8, 17, fields, index$e, ($$anchor, field) => {
			const propPath = user_derived(() => get$3(field).path.substring(1));
			var th_1 = root_7$2();
			var event_handler = user_derived(() => onFieldHeadClick(get$3(field)));

			th_1.__click = function (...$$args) {
				get$3(event_handler)?.apply(this, $$args);
			};

			var node_9 = child(th_1);

			{
				var consequent_5 = ($$anchor) => {
					{
						let $0 = user_derived(() => sorter()[get$3(propPath)] > 0 ? "sort-up" : "sort-down");

						Ui_icon_font($$anchor, {
							get font() {
								return get$3($0);
							},

							get title() {
								return get$3(field).title;
							},

							pointable: true
						});
					}
				};

				var alternate_1 = ($$anchor) => {
					var text$1 = text();

					template_effect(() => set_text(text$1, $LOCALE()[get$3(field).title]));
					append($$anchor, text$1);
				};

				if_block(node_9, ($$render) => {
					if (get$3(field).sortable && Object.hasOwn(sorter(), get$3(propPath))) $$render(consequent_5); else $$render(alternate_1, false);
				});
			}

			reset(th_1);
			template_effect(() => set_class(th_1, 1, (get$3(field).hideOnMobile ? " is-hidden-touch" : "") + (get$3(field).sortable ? " is-clickable" : "")));
			append($$anchor, th_1);
		});

		reset(tr);
		reset(thead);

		var tbody = sibling(thead);

		each(tbody, 21, items, (item) => item._id, ($$anchor, item) => {
			NotTableRow($$anchor, {
				get id() {
					return $$props.id;
				},

				get item() {
					return get$3(item);
				},

				get fields() {
					return fields();
				},

				get helpers() {
					return helpers();
				},

				get showSelect() {
					return showSelect();
				},

				get getItemId() {
					return getItemId();
				},

				$$events: {
					rowSelectChange($$arg) {
						bubble_event.call(this, $$props, $$arg);
					}
				}
			});
		});

		reset(tbody);
		reset(table);

		var node_10 = sibling(table, 2);

		{
			var consequent_8 = ($$anchor) => {
				var nav = root_11$1();
				var a = child(nav);

				a.__click = goPrev;

				var a_1 = sibling(a, 2);

				a_1.__click = goNext;

				var ul = sibling(a_1, 2);
				var node_11 = child(ul);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_6 = comment();
						var node_12 = first_child(fragment_6);

						each(node_12, 17, () => state().pagination.pages.list, index$e, ($$anchor, page) => {
							var li = root_13();
							var node_13 = child(li);

							{
								var consequent_6 = ($$anchor) => {
									var a_2 = root_14$1();
									var text_1 = child(a_2, true);

									reset(a_2);

									template_effect(() => {
										set_attribute(a_2, 'aria-label', `Страница ${get$3(page).index ?? ''}`);
										set_text(text_1, get$3(page).index + 1);
									});

									append($$anchor, a_2);
								};

								var alternate_2 = ($$anchor) => {
									var a_3 = root_15$1();

									a_3.__click = goTo;

									var text_2 = child(a_3, true);

									reset(a_3);

									template_effect(() => {
										set_attribute(a_3, 'aria-label', `Страница ${get$3(page).index ?? ''}`);
										set_attribute(a_3, 'data-page', get$3(page).index);
										set_text(text_2, get$3(page).index + 1);
									});

									append($$anchor, a_3);
								};

								if_block(node_13, ($$render) => {
									if (get$3(page).active) $$render(consequent_6); else $$render(alternate_2, false);
								});
							}

							reset(li);
							append($$anchor, li);
						});

						append($$anchor, fragment_6);
					};

					if_block(node_11, ($$render) => {
						if (state().pagination && state().pagination.pages && state().pagination.pages.list) $$render(consequent_7);
					});
				}

				reset(ul);
				reset(nav);
				append($$anchor, nav);
			};

			if_block(node_10, ($$render) => {
				if (state()?.pagination?.pages?.list.length > 1) $$render(consequent_8);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['input', 'change', 'click']);

	const CONST_ID_DUBLICATE_POSTFIX = "__dublicate__";
	const OPT_DEFAULT_PAGE_SIZE = 20,
	  OPT_DEFAULT_PAGE_NUMBER = 0,
	  OPT_DEFAULT_PAGE_RANGE = 6,
	  OPT_DEFAULT_SORT_DIRECTION = 1,
	  OPT_DEFAULT_SEARCH = "",
	  OPT_DEFAULT_RETURN = {},
	  OPT_DEFAULT_COMBINED = false,
	  OPT_DEFAULT_COMBINED_ACTION = "listAndCount",
	  OPT_DEFAULT_COUNT_ACTION = "count",
	  OPT_DEFAULT_LIST_ACTION = "list",
	  OPT_DEFAULT_SORT_FIELD = "_id",
	  OPT_FIELD_NAME_PRE_PROC = "preprocessor";
	const DEFAULT_OPTIONS = {
	  ui: NotTable,
	  links: [],
	  actions: [],
	  endless: false,
	  idField: "_id",
	  getItemId: function (item) {
	    return item._id;
	  }
	};
	let notTable = /*#__PURE__*/function (_EventEmitter) {
	  function notTable(input = {}) {
	    var _this;
	    _classCallCheck(this, notTable);
	    _this = _callSuper(this, notTable);
	    _this.id = "table-" + Math.random();
	    _this.options = {
	      ...DEFAULT_OPTIONS,
	      ...(input.options ? input.options : {})
	    };
	    _this.ui = {};
	    _this.data = {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {}
	    };
	    _this.state = {
	      pagination: {
	        items: {
	          count: 0,
	          from: 0,
	          to: 0
	        },
	        pages: {
	          count: 0,
	          from: 0,
	          to: 0,
	          current: 0,
	          list: []
	        }
	      }
	    };
	    _this.working = {};
	    _this.stores = create(_this.id, {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {},
	      state: _this.state,
	      working: _this.working
	    });
	    _this.stores.working.subscribe(_this.onWorkingUpdate.bind(_this));
	    //полученные из сети
	    _this.stores.raw.subscribe(_this.onRawUpdate.bind(_this));
	    //применены фильтры, сортировки и т.д.
	    _this.stores.filtered.subscribe(_this.onFilteredUpdate.bind(_this));
	    //урезаны до минимального набора, точно соотвествующего табличному формату
	    _this.stores.refined.subscribe(_this.onRefinedUpdate.bind(_this));
	    //словарь с идентификаторами выбранных строк
	    _this.stores.selected.subscribe(_this.onSelectedUpdate.bind(_this));
	    //pagination, items information
	    _this.stores.state.subscribe(_this.onStateUpdate.bind(_this));
	    if (notCommon$1.objHas(input, "data") && Array.isArray(input.data)) {
	      _this.stores.raw.update(function (val) {
	        val = input.data;
	        return val;
	      });
	    }
	    _this.setCombinedActionName(_this.getOptions("interface.combinedAction", OPT_DEFAULT_COMBINED_ACTION));
	    if (notCommon$1.objHas(_this.options, "filter")) {
	      _this.setFilter(_this.options.filter, true);
	    } else {
	      _this.resetFilter();
	    }
	    if (notCommon$1.objHas(_this.options, "pager")) {
	      _this.setPager(_this.options.pager, true);
	    } else {
	      _this.resetPager();
	    }
	    if (notCommon$1.objHas(_this.options, "sorter")) {
	      _this.setSorter(_this.options.sorter, true);
	    } else {
	      _this.resetSorter(true);
	    }
	    if (notCommon$1.objHas(_this.options, "return")) {
	      _this.setReturn(_this.options.return);
	    } else {
	      _this.setReturn();
	    }
	    if (notCommon$1.objHas(_this.options, "search")) {
	      _this.setSearch(_this.options.search, true);
	    } else {
	      _this.setSearch();
	    }
	    _this.render();
	    _this.updateData();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notTable, _EventEmitter);
	  return _createClass(notTable, [{
	    key: "onWorkingUpdate",
	    value: function onWorkingUpdate(val) {
	      this.working = val;
	      return val;
	    }
	  }, {
	    key: "onRawUpdate",
	    value: function onRawUpdate(val) {
	      this.data.raw = val;
	      return val;
	    }
	  }, {
	    key: "onFilteredUpdate",
	    value: function onFilteredUpdate(val) {
	      this.data.filtered = val;
	      this.refineFiltered();
	      return val;
	    }
	  }, {
	    key: "onRefinedUpdate",
	    value: function onRefinedUpdate(val) {
	      this.data.refined = val;
	      this.clearSelected();
	      return val;
	    }
	  }, {
	    key: "onStateUpdate",
	    value: function onStateUpdate(val) {
	      this.state = val;
	      return val;
	    }
	  }, {
	    key: "onSearchChange",
	    value: function onSearchChange(line) {
	      if (line.length > 3) {
	        this.setSearch(line);
	      } else {
	        this.setSearch();
	      }
	    }
	  }, {
	    key: "onSorterChange",
	    value: function onSorterChange(sorter) {
	      if (sorter) {
	        this.setSorter(sorter);
	      } else {
	        this.resetSorter();
	      }
	    }
	  }, {
	    key: "onFilterChange",
	    value: function onFilterChange({
	      filter,
	      actionName
	    }) {
	      if (actionName.indexOf(OPT_DEFAULT_COMBINED_ACTION) === 0) {
	        this.setCombinedActionName(actionName);
	      }
	      if (filter) {
	        this.setFilter(filter);
	      } else {
	        this.resetFilter();
	      }
	    }
	  }, {
	    key: "onSelectedUpdate",
	    value: function onSelectedUpdate(val) {
	      this.data.selected = val;
	    }
	  }, {
	    key: "clearSelected",
	    value: function clearSelected() {
	      this.data.selected = {};
	    }
	  }, {
	    key: "getSelected",
	    value: function getSelected(object = false, store = "refined") {
	      let res = [];
	      for (let id in this.data.selected) {
	        if (this.data.selected[id]) {
	          if (object) {
	            let indx = this.data[store].findIndex(function (item) {
	              return item._id === id;
	            });
	            if (indx > -1) {
	              res.push(this.data[store][indx]);
	            }
	          } else {
	            res.push(id);
	          }
	        }
	      }
	      return res;
	    }
	  }, {
	    key: "getItemId",
	    value: function getItemId(item) {
	      return this.getOptions("getItemId", DEFAULT_OPTIONS.getItemId)(item);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll() {
	      var _this2 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this2.data.filtered.forEach(function (item) {
	          value[_this2.getItemId(item)] = true;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone() {
	      var _this3 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this3.data.filtered.forEach(function (item) {
	          value[_this3.getItemId(item)] = false;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;
	      if (!this.ui.table) {
	        this.ui.table = new this.options.ui({
	          target: this.options.targetEl,
	          props: {
	            filterUI: this.getOptions("filterUI", undefined),
	            id: this.id,
	            helpers: Object.assign({}, this.getHelpers()),
	            fields: this.getOptions("fields"),
	            actions: this.getActions(),
	            links: this.getLinks(),
	            search: "",
	            showSelect: this.getOptions("showSelect"),
	            showSearch: this.getOptions("showSearch"),
	            showSort: this.getOptions("showSort"),
	            idField: this.getOptions("idField"),
	            getItemId: this.getOptions("getItemId"),
	            filter: this.getFilter()
	          }
	        });
	      }
	      this.ui.table.$on("searchChange", function (e) {
	        return _this4.onSearchChange(e.detail);
	      });
	      this.ui.table.$on("sorterChange", function (e) {
	        return _this4.onSorterChange(e.detail);
	      });
	      this.ui.table.$on("filterChange", function (e) {
	        return _this4.onFilterChange(e.detail);
	      });
	      this.ui.table.$on("goToPage", function (e) {
	        return _this4.goToPage(e.detail);
	      });
	      this.ui.table.$on("goToNextPage", function () {
	        return _this4.goToNext();
	      });
	      this.ui.table.$on("goToPrevPage", function () {
	        return _this4.goToPrev();
	      });
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.getOptions("actions", []);
	    }
	  }, {
	    key: "getLinks",
	    value: function getLinks() {
	      return this.getOptions("links", []);
	    }
	  }, {
	    key: "getHelpers",
	    value: function getHelpers() {
	      return this.options.helpers || {};
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking(key, value) {
	      var _this5 = this;
	      this.stores.working.update(function (val) {
	        notPath.set(key, val, _this5.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking(key, def) {
	      let res = notPath.get(key, this.working, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setState",
	    value: function setState(key, value) {
	      var _this6 = this;
	      this.stores.state.update(function (val) {
	        notPath.set(key, val, _this6.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getState",
	    value: function getState(key, def) {
	      let res = notPath.get(key, this.state, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(key, value) {
	      notPath.set(key, this.options, this.getHelpers(), value);
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions(key, def) {
	      let res = notPath.get(key, this.options, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(hash, withoutInvalidation = false) {
	      this.setState("filter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      this.setState("filter", {});
	      return this;
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getState("filter");
	    }
	  }, {
	    key: "setPager",
	    value: function setPager(hash, withoutInvalidation = false) {
	      this.setState("pager", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getDefaultPageNumber",
	    value: function getDefaultPageNumber() {
	      return isNaN(this.getOptions("pager.page")) ? OPT_DEFAULT_PAGE_NUMBER : this.getOptions("pager.page");
	    }
	  }, {
	    key: "getDefaultPageSize",
	    value: function getDefaultPageSize() {
	      return isNaN(this.getOptions("pager.size")) ? OPT_DEFAULT_PAGE_SIZE : this.getOptions("pager.size");
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      this.setState("pager", {
	        size: this.getDefaultPageSize(),
	        page: this.getDefaultPageNumber()
	      });
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getState("pager");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(hash, withoutInvalidation = false) {
	      this.setWorking("sorter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter(withoutInvalidation = false) {
	      let t = {};
	      t[OPT_DEFAULT_SORT_FIELD] = OPT_DEFAULT_SORT_DIRECTION;
	      return this.setSorter(t, withoutInvalidation);
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "getSorterDirection",
	    value: function getSorterDirection() {
	      try {
	        let names = Object.keys(this.getSorter());
	        return this.getSorter()[names[0]];
	      } catch {
	        return OPT_DEFAULT_SORT_DIRECTION;
	      }
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      let search = typeof this.getWorking("search") !== "undefined" && this.getWorking("search") !== null;
	      return search ? this.getWorking("search") : "";
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(line = OPT_DEFAULT_SEARCH, withoutInvalidation = false) {
	      this.setWorking("search", line);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(ret = OPT_DEFAULT_RETURN) {
	      this.setWorking("return", ret);
	      return this;
	    }
	  }, {
	    key: "clearFilteredData",
	    value: function clearFilteredData() {
	      this.stores.filtered.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRawData",
	    value: function clearRawData() {
	      this.stores.raw.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRefinedData",
	    value: function clearRefinedData() {
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "invalidateData",
	    value: function invalidateData() {
	      //clearing filtered and sorted
	      this.clearFilteredData();
	      //in case live loading from server
	      if (this.isLive()) {
	        //clearing loaded data
	        this.clearRawData();
	      }
	      //resset pager anyway
	      this.resetPager();
	    }
	  }, {
	    key: "isLive",
	    value: function isLive() {
	      return this.getOptions("interface") && this.getOptions("interface.factory");
	    }
	  }, {
	    key: "setUpdating",
	    value: function setUpdating() {
	      this.setState("updating", true);
	    }
	  }, {
	    key: "setUpdated",
	    value: function setUpdated() {
	      this.setState("updating", false);
	    }
	  }, {
	    key: "ifUpdating",
	    value: function ifUpdating() {
	      return this.getState("updating");
	    }
	  }, {
	    key: "getDataInterface",
	    value: function getDataInterface() {
	      let factory = this.getOptions("interface.factory");
	      if (typeof factory === "function") {
	        return factory({});
	      } else {
	        return factory;
	      }
	    }
	  }, {
	    key: "getLoadDataActionName",
	    value: function getLoadDataActionName() {
	      return this.getOptions("interface.listAction") ? this.getOptions("interface.listAction") : OPT_DEFAULT_LIST_ACTION;
	    }
	  }, {
	    key: "setCombinedActionName",
	    value: function setCombinedActionName(actionName = OPT_DEFAULT_COUNT_ACTION) {
	      this.setWorking("interface.combinedAction", actionName);
	    }
	  }, {
	    key: "getCombinedActionName",
	    value: function getCombinedActionName() {
	      return this.getWorking("interface.combinedAction") ? this.getWorking("interface.combinedAction") : OPT_DEFAULT_COMBINED_ACTION;
	    }
	  }, {
	    key: "getCountActionName",
	    value: function getCountActionName() {
	      return this.getOptions("interface.countAction") ? this.getOptions("interface.countAction") : OPT_DEFAULT_COUNT_ACTION;
	    }
	  }, {
	    key: "loadData",
	    value: function loadData() {
	      //load from server
	      let query = this.getDataInterface().setFilter(this.getFilter()).setSorter(this.getSorter()).setReturn(this.getReturn()).setSearch(this.getSearch()).setPager(this.getPager()),
	        actionName;
	      if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	        actionName = this.getCombinedActionName();
	      } else {
	        actionName = this.getLoadDataActionName();
	      }
	      return query["$" + actionName]();
	    }
	  }, {
	    key: "goToNext",
	    value: function goToNext() {
	      let next = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") + 1;
	      this.setState("pager.page", Math.min(next, this.getState("pagination.pages.to")));
	      this.updateData();
	    }
	  }, {
	    key: "goToPrev",
	    value: function goToPrev() {
	      let prev = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") - 1;
	      this.setState("pager.page", Math.max(prev, this.getState("pagination.pages.from")));
	      this.updateData();
	    }
	  }, {
	    key: "goToFirst",
	    value: function goToFirst() {
	      this.setState("pager.page", this.getState("pagination.pages.from"));
	      this.updateData();
	    }
	  }, {
	    key: "goToLast",
	    value: function goToLast() {
	      this.setState("pager.page", this.getState("pagination.pages.to"));
	      this.updateData();
	    }
	  }, {
	    key: "goToPage",
	    value: function goToPage(pageNumber) {
	      this.setState("pager.page", pageNumber);
	      this.updateData();
	    }
	  }, {
	    key: "testDataItem",
	    value: function testDataItem(item) {
	      var strValue = this.getSearch().toLowerCase();
	      for (var k in item) {
	        var toComp = item[k].toString().toLowerCase();
	        if (toComp.indexOf(strValue) > -1) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "getRowsCount",
	    value: function getRowsCount() {
	      var _this7 = this;
	      let query = this.getDataInterface().setFilter(this.getFilter());
	      return query["$" + this.getCountActionName()]().then(function (data) {
	        _this7.updatePagination(data.count);
	      }).catch(function (e) {
	        _this7.error(e);
	      });
	    }
	  }, {
	    key: "updatePagination",
	    value: function updatePagination(itemsCount) {
	      var _this8 = this;
	      this.log("update pagination", itemsCount);
	      this.state.pagination.pages.list.splice(0, this.state.pagination.pages.list.length);
	      let itemsFrom = (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER) * this.getPager().size + 1,
	        pagesCount = itemsCount % this.getPager().size ? Math.floor(itemsCount / this.getPager().size) + 1 : Math.round(itemsCount / this.getPager().size),
	        pagesFrom = Math.max(OPT_DEFAULT_PAGE_NUMBER, this.getPager().page - OPT_DEFAULT_PAGE_RANGE),
	        pagesTo = Math.min(pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER), this.getPager().page + OPT_DEFAULT_PAGE_RANGE),
	        list = [],
	        itemsTo = Math.min(itemsFrom + this.getPager().size - 1, itemsCount);
	      for (let t = pagesFrom; t <= pagesTo; t++) {
	        list.push({
	          index: t,
	          active: t === this.getPager().page
	        });
	      }
	      this.stores.state.update(function (val) {
	        _this8.log("update pagination", val);
	        val.pagination.items.count = itemsCount;
	        val.pagination.items.from = itemsFrom;
	        val.pagination.items.to = itemsTo;
	        val.pagination.pages.count = pagesCount;
	        val.pagination.pages.from = pagesFrom;
	        val.pagination.pages.to = pagesTo;
	        val.pagination.pages.current = _this8.getPager().page;
	        val.pagination.pages.list.splice(0, val.pagination.pages.list.length, ...list);
	        return val;
	      });
	    }
	  }, {
	    key: "updateData",
	    value: function updateData() {
	      var _this9 = this;
	      if (this.isLive()) {
	        if (this.ifUpdating()) {
	          return;
	        }
	        if (!this.getOptions("endless", false)) {
	          this.clearRawData();
	        }
	        this.setUpdating();
	        if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	          this.loadData().then(function (data) {
	            let full = notCommon$1.objHas(data, "status") && notCommon$1.objHas(data, "result");
	            _this9.stores.filtered.update(function (val) {
	              if (!_this9.getOptions("endless", false)) {
	                _this9.clearFilteredData();
	              }
	              if (full) {
	                val.push(...data.result.list);
	              } else {
	                if (notCommon$1.objHas(data, "list") && Array.isArray(data.list)) {
	                  val.push(...data.list);
	                } else if (Array.isArray(data)) {
	                  val.push(...data);
	                }
	              }
	              return val;
	            });
	            _this9.setWorking("lastCount", full ? data.result.count : data.count);
	          }).then(function () {
	            _this9.updatePagination(_this9.getWorking("lastCount"));
	          }).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        } else {
	          this.loadData().then(function (data) {
	            _this9.stores.filtered.update(function (val) {
	              val.push(...data);
	              return val;
	            });
	          }).then(this.getRowsCount.bind(this)).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        }
	      } else {
	        //local magic
	        this.setUpdating();
	        this.processData();
	        this.setUpdated();
	      }
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.data;
	    }
	  }, {
	    key: "processData",
	    value: function processData() {
	      var _this0 = this;
	      let thatFilter = this.getFilter();
	      //this.getData('rows').__setPassive;
	      this.log(this.getData());
	      if (typeof thatFilter !== "undefined" && thatFilter !== null && typeof thatFilter.filterSearch !== "undefined" && thatFilter.filterSearch !== null && thatFilter.filterSearch.length > 0) {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this0.data.raw.filter(_this0.testDataItem.bind(_this0)));
	          return val;
	        });
	      } else {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this0.data.raw);
	          return val;
	        });
	      }
	      ////sorter
	      let thatSorter = this.getSorter();
	      if (typeof thatSorter !== "undefined" && thatSorter !== null) {
	        this.stores.filtered.update(function (val) {
	          val.sort(function (item1, item2) {
	            let t1 = notPath.get(thatSorter.sortByField, item1, {}),
	              t2 = notPath.get(thatSorter.sortByField, item2, {});
	            if (isNaN(t1)) {
	              if (typeof t1 !== "undefined" && typeof t2 !== "undefined" && t1.localeCompare) {
	                return t1.localeCompare() * -thatSorter.sortDirection;
	              } else {
	                return 0;
	              }
	            } else {
	              return (t1 < t2 ? 1 : -1) * thatSorter.sortDirection;
	            }
	          });
	          return val;
	        });
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      if (this.options.logger) {
	        this.options.logger.error(...arguments);
	      }
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      if (this.options.logger) {
	        this.options.logger.log(...arguments);
	      }
	    }
	  }, {
	    key: "checkFieldsNames",
	    value: function checkFieldsNames() {
	      const fieldId = this.getOptions("idField");
	      const pathId = ":" + fieldId;
	      let fields = this.getOptions("fields", []);
	      fields.forEach(function (field) {
	        if (pathId === field.path) {
	          field.path = field.path + CONST_ID_DUBLICATE_POSTFIX;
	        }
	      });
	    }
	  }, {
	    key: "readFieldValue",
	    value: function readFieldValue(path, item, helpers) {
	      if (path.indexOf(CONST_ID_DUBLICATE_POSTFIX) > -1) {
	        const fieldId = this.getOptions("idField");
	        const pathId = ":" + fieldId;
	        return notPath.get(pathId, item, helpers);
	      } else {
	        return notPath.get(path, item, helpers);
	      }
	    }
	  }, {
	    key: "refineFiltered",
	    value: function refineFiltered() {
	      var _this1 = this;
	      let result = [];
	      this.checkFieldsNames();
	      this.data.filtered.forEach(function (item, index) {
	        let refined = {};
	        if (_this1.getOptions("idField")) {
	          refined[_this1.getOptions("idField")] = item[_this1.getOptions("idField")];
	        }
	        _this1.getOptions("fields", []).forEach(function (field) {
	          let preprocessed = null,
	            val = _this1.readFieldValue(field.path, item, _this1.getOptions("helpers"));
	          if (notCommon$1.objHas(field, OPT_FIELD_NAME_PRE_PROC)) {
	            try {
	              preprocessed = field[OPT_FIELD_NAME_PRE_PROC](val, item, index);
	            } catch (e) {
	              _this1.error("Error while preprocessing cell value", val, item, index);
	              _this1.error(e);
	            }
	            notPath.set(field.path, refined, preprocessed);
	          } else {
	            notPath.set(field.path, refined, val);
	          }
	        });
	        result.push(refined);
	      });
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length, ...result);
	        return val;
	      });
	    }
	  }, {
	    key: "$destroy",
	    value: function $destroy() {
	      for (let name in this.ui) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        delete this.ui[name];
	      }
	    }
	  }]);
	}(EventEmitter);

	var root_1$6 = from_html(`<!> <!>`, 1);
	var root$7 = from_html(`<!> <!>`, 1);

	function Ui_action_container($$anchor, $$props) {
		push($$props, true);

		//hidden - no loader
		//container - parent container of form
		let success = state(false);

		let error = state(false);

		/**
		 * @typedef {Object} Props
		 * @property {any} [container]
		 * @property {string} [loaderTitle]
		 * @property {boolean} [loaderActive] - state if form loading
		 * @property {string} [loaderSize] - page - whole page
		 * @property {string} [successTitle]
		 * @property {string} [successMessage]
		 * @property {string} [errorTitle]
		 * @property {string} [errorMessage]
		 */
		/** @type {Props} */
		let container = prop($$props, 'container', 19, () => ({})),
			loaderTitle = prop($$props, 'loaderTitle', 15, "Отправка данных на сервер"),
			loaderActive = prop($$props, 'loaderActive', 15, false),
			loaderSize = prop($$props, 'loaderSize', 15, "container"),
			successTitle = prop($$props, 'successTitle', 15, "OK"),
			successMessage = prop($$props, 'successMessage', 15, ""),
			errorTitle = prop($$props, 'errorTitle', 15, "Error"),
			errorMessage = prop($$props, 'errorMessage', 15, "");

		function showSuccess(title, message) {
			set(error, false);
			set(success, true);

			if (message != undefined) {
				successMessage(message);
			}

			if (title != undefined) {
				successTitle(title);
			}
		}

		function showError(title, message) {
			set(success, false);
			set(error, true);

			if (message != undefined) {
				errorMessage(message);
			}

			if (title != undefined) {
				errorTitle(title);
			}
		}

		function setLoading() {
			loaderActive(true);
			set(success, false);
			set(error, false);
		}

		function resetLoading() {
			loaderActive(false);
		}

		function hideAll() {
			loaderActive(false);
			set(success, false);
			set(error, false);
		}

		var $$exports = { showSuccess, showError, setLoading, resetLoading, hideAll };
		var fragment = root$7();
		var node = first_child(fragment);

		Ui_loader(node, {
			get loading() {
				return loaderActive();
			},

			set loading($$value) {
				loaderActive($$value);
			},

			get title() {
				return loaderTitle();
			},

			set title($$value) {
				loaderTitle($$value);
			},

			get size() {
				return loaderSize();
			},

			set size($$value) {
				loaderSize($$value);
			}
		});

		var node_1 = sibling(node, 2);

		Ui_container(node_1, spread_props(container, {
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$6();
				var node_2 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_error($$anchor, {
							get title() {
								return errorTitle();
							},

							set title($$value) {
								errorTitle($$value);
							},

							get message() {
								return errorMessage();
							},

							set message($$value) {
								errorMessage($$value);
							}
						});
					};

					if_block(node_2, ($$render) => {
						if (get$3(error)) $$render(consequent);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_success($$anchor, {
							get title() {
								return successTitle();
							},

							set title($$value) {
								successTitle($$value);
							},

							get message() {
								return successMessage();
							},

							set message($$value) {
								successMessage($$value);
							}
						});
					};

					if_block(node_3, ($$render) => {
						if (get$3(success)) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},

			$$slots: { default: true }
		}));

		append($$anchor, fragment);

		return pop($$exports);
	}

	const DEFAULT_CONTAINER_SELECTOR$2 = ".container";
	var _uiComponent$1 = /*#__PURE__*/new WeakMap();
	var _ui = /*#__PURE__*/new WeakMap();
	let notActionUI = /*#__PURE__*/function (_notBase) {
	  function notActionUI({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data = {},
	    ui = Ui_action_container //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notActionUI);
	    _this = _callSuper(this, notActionUI, [{
	      working: {
	        name: `${name}ActionUI`,
	        ...working
	      },
	      options,
	      data
	    }]);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent$1, null);
	    _classPrivateFieldInitSpec(_this, _ui, null);
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent$1, _this, ui);
	    _this.initUI();
	    return _this;
	  }
	  _inherits(notActionUI, _notBase);
	  return _createClass(notActionUI, [{
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const target = this.getTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_ui, this, new (_classPrivateFieldGet2(_uiComponent$1, this))({
	          target,
	          props: this.getOptions()
	        }));
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_ui, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_ui, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_ui, this)) {
	        _classPrivateFieldGet2(_ui, this).$destroy && _classPrivateFieldGet2(_ui, this).$destroy();
	        _classPrivateFieldGet2(_ui, this).destroy && _classPrivateFieldGet2(_ui, this).destroy();
	        _classPrivateFieldSet2(_ui, this, null);
	      }
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_ui, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_ui, this).showError(status);
	      this.emit("error", status);
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getTargetEl",
	    value: function getTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$2);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("ActionUI parent element is not defined");
	      }
	    }
	  }]);
	}(notBase);

	let notFormUtils$1 = /*#__PURE__*/function () {
	  function notFormUtils() {
	    _classCallCheck(this, notFormUtils);
	  }
	  return _createClass(notFormUtils, null, [{
	    key: "addComponent",
	    value: function addComponent(name, value) {
	      COMPONENTS$1.add(name, value);
	    }
	  }, {
	    key: "addVariants",
	    value: function addVariants(name, value) {
	      VARIANTS$1.add(name, value);
	    }
	  }, {
	    key: "addField",
	    value: function addField(name, field) {
	      FIELDS$1.add(name, field);
	    }
	  }, {
	    key: "actionFieldsInit",
	    value: function actionFieldsInit(fieldName, options, data) {
	      var _this = this;
	      if (Array.isArray(fieldName)) {
	        fieldName.forEach(function (subFieldName) {
	          _this.actionFieldsInit(subFieldName, options, data);
	        });
	      } else {
	        if (!notCommon$1.objHas(options, "fields")) {
	          options.fields = {};
	        }
	        if (!notCommon$1.objHas(options.fields, fieldName)) {
	          options.fields[fieldName] = {};
	        }
	        //copying initial data
	        if (typeof data !== "undefined" && data !== null && typeof data[fieldName] !== "undefined" && data[fieldName] !== null) {
	          options.fields[fieldName].value = data[fieldName];
	        }
	      }
	    }
	  }]);
	}();
	_defineProperty(notFormUtils$1, "validator", null);

	const DEFAULT_FIELD = {
	  label: "",
	  placeholder: "",
	  enabled: true,
	  visible: true,
	  required: true,
	  validated: false,
	  valid: false,
	  errors: false
	};

	/**
	 * Creates field manifest
	 * @param {string} type      name/type of the field
	 * @param {Object} mutation  mutation to manifest from library
	 * @param {Object} VARIANTS  store which contains named lists of field value variants
	 * @param {Object} FIELDS    store which contains named lists of field manifests
	 * @return {Object}          field manifest
	 **/
	function fieldInit(type, mutation = {}, VARIANTS, FIELDS) {
	  let field = {
	    ...DEFAULT_FIELD
	  };
	  //getting field core manifest
	  if (FIELDS.contains(type)) {
	    field = {
	      ...field,
	      ...FIELDS.get(type)
	    };
	  }
	  //adding mutations
	  if (mutation) {
	    field = {
	      ...field,
	      ...mutation
	    };
	  }
	  //adding variants list to field from VARIANTS store
	  if (notCommon$1.objHas(field, "variantsSource") && VARIANTS.contains(field.variantsSource)) {
	    field.variants = VARIANTS.get(field.variantsSource);
	  } else {
	    if (!field.variants || field.variants.length === 0) {
	      field.variants = [];
	    }
	  }
	  return field;
	}

	/**
	 * Initialization of form structure object
	 * @param {object}               form          form structure object
	 * @param {string|Array<string>} fieldName     name of the field type if string, array of strings = subform
	 * @param {Object}               VARIANTS      store which contains named lists of field value variants
	 * @param {Object}               FIELDS        store which contains named lists of field manifests
	 * @param {Object}               formFieldsOptions   form wide options
	 * @returns {Object}                           form structure object
	 **/
	function initFormByField(form = {}, fieldName = [], VARIANTS, FIELDS, formFieldsOptions, data) {
	  if (Array.isArray(fieldName)) {
	    fieldName.forEach(function (subFormFieldName) {
	      return initFormByField(form, subFormFieldName, VARIANTS, FIELDS, formFieldsOptions, data);
	    });
	  } else {
	    let opts = {};
	    if (formFieldsOptions && notCommon$1.objHas(formFieldsOptions, "mutations") && notCommon$1.objHas(formFieldsOptions.mutations, fieldName)) {
	      opts = formFieldsOptions.mutations[fieldName]; //option mutation for field
	    }
	    if (data && notCommon$1.objHas(data, fieldName)) {
	      opts.value = data[fieldName];
	    }
	    form[fieldName] = fieldInit(fieldName, opts, VARIANTS, FIELDS);
	    //if form readonly, marking every field as readonly
	    if (formFieldsOptions && formFieldsOptions.readonly) {
	      form[fieldName].readonly = true;
	    }
	  }
	  return form;
	}

	/**
	 *  Marking field as invalid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFieldInvalid(form, fieldName, value, errors) {
	  form[fieldName].errors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].valid = false;
	  form[fieldName].value = value;
	  return form;
	}

	/**
	 *  Marking field as valid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @return {Object}                        form structure object
	 **/
	function setFieldValid(form, fieldName, value) {
	  form[fieldName].errors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].value = value;
	  for (let fname in form) {
	    if (fname !== fieldName) {
	      if (Array.isArray(form[fname].errors) && form[fname].errors.length === 0) {
	        form[fname].errors = false;
	      }
	      if (form[fname].errors !== false) {
	        break;
	      }
	    }
	  }
	  return form;
	}

	/**
	 * Checks if field has errors
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @returns {boolean}                      true - valid, false -invalid
	 **/
	function isFieldValid(form, fieldName) {
	  return !Array.isArray(form[fieldName].errors);
	}

	/**
	 * Form level validator error in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldInvalid(form, fieldName, errors) {
	  form[fieldName].formErrors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].inputStarted = true;
	  form[fieldName].valid = false;
	  form[fieldName].formLevelError = true;
	  return form;
	}
	/**
	 * Form level validator success in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldValid(form, fieldName) {
	  form[fieldName].formErrors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].formLevelError = false;
	  return form;
	}

	/**
	 * Updates fields and form error labels
	 * @param {Object}           form                  form structure object
	 * @param {Object}           validationStatus      results of validation
	 **/
	function updateFormValidationStatus({
	  form,
	  formErrors,
	  validationStatus
	} /* FormValidationSession.getCompleteResult() */) {
	  if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
	    formErrors.splice(0, formErrors.length, ...validationStatus.form);
	  } else {
	    formErrors.splice(0, formErrors.length);
	  }
	  if (validationStatus.fields) {
	    for (let fieldName in validationStatus.fields) {
	      if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
	        setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
	      } else {
	        setFormFieldValid(form, fieldName);
	      }
	    }
	  }
	}
	function setFieldsVisibility(form, fieldsList, val) {
	  if (Array.isArray(fieldsList)) {
	    Object.keys(form).forEach(function (fieldName) {
	      form[fieldName].visible = fieldsList.includes(fieldName) ? val : !val;
	    });
	    return true;
	  }
	  return false;
	}
	function setFieldValue(form, fieldName, value) {
	  if (notCommon$1.objHas(form, fieldName)) {
	    form[fieldName].value = value;
	    return true;
	  }
	  return false;
	}
	function fieldIsVisibleAndFilled(form, fieldName) {
	  return notCommon$1.objHas(form, fieldName) && form[fieldName].enabled && form[fieldName].visible && typeof form[fieldName].value !== "undefined";
	}
	function collectData(fields, form) {
	  let result = {};
	  fields.flat().forEach(function (fieldName) {
	    if (fieldIsVisibleAndFilled(form, fieldName)) {
	      result[fieldName] = form[fieldName].value;
	    }
	  });
	  return result;
	}
	var FormHelpers = {
	  fieldInit,
	  initFormByField,
	  setFieldInvalid,
	  setFieldValid,
	  isFieldValid,
	  setFormFieldInvalid,
	  setFormFieldValid,
	  updateFormValidationStatus,
	  fieldIsVisibleAndFilled,
	  setFieldsVisibility,
	  setFieldValue,
	  collectData
	};

	var result;
	var hasRequiredResult;

	function requireResult () {
		if (hasRequiredResult) return result;
		hasRequiredResult = 1;
		const emptyFieldsResults = (data) => {
		    return Object.keys(data).reduce((acc, curr) => {
		        acc[curr] = [];
		        return acc;
		    }, {});
		};

		const FIELDS = ["fields", "form"];

		result = class ValidationResult {
		    #clean = true;
		    #result;

		    constructor(result) {
		        this.#result = JSON.parse(JSON.stringify(result));
		        Object.keys(this.#result).forEach((fieldName) => {
		            if (!FIELDS.includes(fieldName)) {
		                delete this.#result[fieldName];
		            }
		        });
		        this.#clean = this.#result.form.errors.length === 0;
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            if (this.isFieldDirty(fieldName)) {
		                this.#clean = false;
		            }
		        }
		    }

		    destroy() {
		        this.#result = undefined;
		    }

		    get clean() {
		        return this.#clean;
		    }

		    static getDefaultResult(data) {
		        return {
		            fields: emptyFieldsResults(data),
		            form: {
		                fields: emptyFieldsResults(data),
		                errors: [],
		                exceptions: [],
		            },
		        };
		    }

		    getReport() {
		        return JSON.parse(JSON.stringify(this.#getCompleteResult()));
		    }

		    getDetailedReport() {
		        if (typeof this.#result === "object") {
		            return JSON.parse(JSON.stringify(this.#result));
		        } else {
		            return undefined;
		        }
		    }

		    isFieldDirty(fieldName) {
		        if (
		            Array.isArray(this.#result.fields[fieldName]) &&
		            this.#result.fields[fieldName].length
		        ) {
		            return true;
		        }
		        if (
		            Array.isArray(this.#result.form.fields[fieldName]) &&
		            this.#result.form.fields[fieldName].length
		        ) {
		            return true;
		        }
		        return false;
		    }

		    getCompleteResultForField(fieldName) {
		        const fieldResult = [];
		        if (Array.isArray(this.#result.fields[fieldName])) {
		            fieldResult.push(...this.#result.fields[fieldName]);
		        }
		        if (Array.isArray(this.#result.form.fields[fieldName])) {
		            fieldResult.push(...this.#result.form.fields[fieldName]);
		        }
		        return fieldResult;
		    }

		    #getCompleteResult() {
		        const resultComplete = {
		            clean: this.#clean,
		            fields: {},
		            form: [],
		        };
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            const errors = this.getCompleteResultForField(fieldName);
		            if (errors.length) {
		                resultComplete.fields[fieldName] = errors;
		            }
		        }
		        resultComplete.form = [...this.#result.form.errors];
		        if (resultComplete.form.length === 0) {
		            delete resultComplete.form;
		        }
		        return resultComplete;
		    }

		    #getFieldsList() {
		        const fields = Object.keys(this.#result.fields);
		        const fieldsInForm = Object.keys(this.#result.form.fields);
		        return [...new Set([...fieldsInForm, ...fields])];
		    }
		};
		return result;
	}

	/**
	*	Template of error.js
	*	For building for specific environment.
	*	Node.js or Browser
	*	@param {string}	env	node|browser in wich env it will be running
	*	@param {string}	url	URL of report collector
	*	@param {string}	key	key to indetificate reporter
	*/

	var error_node;
	var hasRequiredError_node;

	function requireError_node () {
		if (hasRequiredError_node) return error_node;
		hasRequiredError_node = 1;
		/**
		* Error reporting with features, saving browser info, uri and so on.
		* @module not-error/error
		*/
		class notError extends Error {
			constructor(message, options = {}, error = null){
				super(message);
				this.options = options;
				this.adopt(error);
				this.fill();
				this.getTime();
				return this;
			}

			/**
			*	Adopting native error object
			*	@param {Error}	error 	Error object
			*	@return {notError}		chainable
			*/
			adopt(error){
				if(error instanceof Error){
					this.parent = error;
				}
				return this;
			}

			getStack(){
				if(this.parent){
					return this.parent.stack;
				}else {
					return this.stack;
				}
			}

			getDetails(){
				let src = this;
				if(this.parent){
					src = this.parent;
				}
				return {
					columnNumber:    	src.columnNumber,
					fileName:        	src.fileName,
					lineNumber:      	src.lineNumber,
					name:            	src.name,
					message:        	src.message,
					stack:          	src.stack
				};
			}

			/**
			*	Updating this.env.date property
			*	@return  {object}	{timestamp, offset}
			*/
			getTime(){
				let date = new Date();
				this.env.date = {
					timestamp : date.getTime(),
					offset: date.getTimezoneOffset()
				};
				return this.env.date;
			}


			/**
			******************************************************************************************************
			******************************************************************************************************
			***	Node.js Section
			******************************************************************************************************
			******************************************************************************************************
			**/

			/**
			*	Filtering out key by `white` list
			*	@param {object} object hash to be copied according filter `white` list
			*	@param {array} filter array of sting, which represents keys we want to be
			*						copied in resulting object from source
			*	@return {object}		white listed hash
			*/
			filterEnv(object, filter){
				let result = {};
				for(let t of filter){
					if(Object.prototype.hasOwnProperty.call(object, t)){
						result[t] = object[t];
					}
				}
				return result;
			}

			/**
			*	Collecting information specific for Node.js V8
			*	@return {notError}		chainable
			*/
			fill(){
				/**
				*	You want some fields from env but not all, cause there are passwords
				*	from db, api keys and etc
				*/
				this.env = {
					browser: 	false,
					node: 		true,
					versions: Object.assign({}, process.versions),
					vars: 		this.filterEnv(process.env, this.options.whitelist || ['NODE_ENV'])
				};
				return this;
			}


		}


		error_node = notError;
		return error_node;
	}

	var validation_error_node;
	var hasRequiredValidation_error_node;

	function requireValidation_error_node () {
		if (hasRequiredValidation_error_node) return validation_error_node;
		hasRequiredValidation_error_node = 1;
		const notError = requireError_node();


		//reportable
		class notValidationError extends notError{
		  constructor(message, fields = {}, err = null, params = {}){
		    super(message, {fields, params}, err);
		    return this;
		  }

		  /**
		  * Sets hash of fields errors messages for usage in forms
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  setFieldsErrors(messages){
		    this.options.fields = messages;
		  }

		  /**
		  * Returns hash of errors
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  getFieldsErrors(){
		    return this.options.fields;
		  }

		}


		validation_error_node = notValidationError;
		return validation_error_node;
	}

	/**
	 * Test argument type to be 'function'
	 * @param {any}  func    possible function
	 * @return {boolean}     if this is a function
	 **/

	var common;
	var hasRequiredCommon;

	function requireCommon () {
		if (hasRequiredCommon) return common;
		hasRequiredCommon = 1;
		const isFunc = (func) => {
		    return typeof func === "function";
		};

		/**
		 * Returns true if argument is Async function
		 * @param {function} func  to test
		 * @return {boolean}       if this function is constructed as AsyncFunction
		 **/
		const isAsync = (func) => {
		    return func.constructor.name === "AsyncFunction";
		};

		common = async (proc, params) => {
		    if (isFunc(proc)) {
		        if (isAsync(proc)) {
		            return await proc(...params);
		        } else {
		            return proc(...params);
		        }
		    }
		};
		return common;
	}

	var session;
	var hasRequiredSession;

	function requireSession () {
		if (hasRequiredSession) return session;
		hasRequiredSession = 1;
		const ValidationResult = requireResult();
		const notVaildationError = requireValidation_error_node();
		const executeObjectFunction = requireCommon();

		const ValidationSession = async (validators, data) => {
		    const result = ValidationResult.getDefaultResult(data);
		    await validateFields({ validators, data, result });
		    await validateForm({ validators, data, result });
		    return new ValidationResult(result);
		};

		session = ValidationSession;

		const validateFields = async ({ validators, data, result }) => {
		    for (let t in data) {
		        await validateField(t, data[t], validators, result);
		    }
		};

		const validateField = async (fieldName, value, validators, result) => {
		    const fieldValidators = getFieldValidators(fieldName, validators);
		    return await runFieldValidators(fieldName, value, fieldValidators, result);
		};

		const getFieldValidators = (name, validators) => {
		    return validators && validators.fields && validators.fields[name]
		        ? validators.fields[name]
		        : [];
		};

		const runFieldValidators = async (fieldName, value, validators, result) => {
		    for (let validatorRule of validators) {
		        try {
		            const valid = await executeObjectFunction(
		                validatorRule["validator"],
		                [value]
		            );
		            if (!valid) {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        } catch (e) {
		            if (e instanceof notVaildationError || !validatorRule.message) {
		                setFieldError(fieldName, e.message, result);
		            } else {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        }
		    }
		};

		const setFieldError = (fieldName, errorMessage, result) => {
		    if (!result.fields[fieldName].includes(errorMessage)) {
		        result.fields[fieldName].push(errorMessage);
		    }
		};

		const validateForm = async ({ validators, data, result }) => {
		    const formValidators = getFormValidators(validators);
		    await runFormValidators(data, formValidators, result);
		};

		const getFormValidators = (validators) => {
		    return validators && validators.form ? validators.form : [];
		};

		const runFormValidators = async (data, formValidators, result) => {
		    for (let validator of formValidators) {
		        try {
		            await validator(data);
		        } catch (e) {
		            if (e && typeof e.getFieldsErrors === "function") {
		                const formErrors = e.getFieldsErrors();
		                Array.isArray(formErrors.form) &&
		                    addFormErrors(formErrors.form, result);
		                formErrors.fields &&
		                    addFormFieldsErrors(formErrors.fields, result);
		            } else {
		                throw e;
		            }
		        }
		    }
		};

		const addFormErrors = (errors, result) => {
		    errors.forEach((error) => {
		        addFormError(error, result);
		    });
		};

		const addFormError = (errorMessage, result) => {
		    if (!result.form.errors.includes(errorMessage)) {
		        result.form.errors.push(errorMessage);
		    }
		};

		const addFormFieldsErrors = (fieldsErrors, result) => {
		    for (let fieldName in fieldsErrors) {
		        addFormFieldErrors(fieldName, fieldsErrors[fieldName], result);
		    }
		};

		const addFormFieldErrors = (fieldName, errorMessages, result) => {
		    errorMessages.forEach((error) => {
		        addFormFieldError(fieldName, error, result);
		    });
		};

		const addFormFieldError = (fieldName, errorMessage, result) => {
		    if (!Array.isArray(result.form.fields[fieldName])) {
		        result.form.fields[fieldName] = [];
		    }
		    if (!result.form.fields[fieldName].includes(errorMessage)) {
		        result.form.fields[fieldName].push(errorMessage);
		    }
		};
		return session;
	}

	var runner_utils;
	var hasRequiredRunner_utils;

	function requireRunner_utils () {
		if (hasRequiredRunner_utils) return runner_utils;
		hasRequiredRunner_utils = 1;
		const composeFieldsValidators = (data, validatorsLib) => {
		    if (validatorsLib && validatorsLib.fields) {
		        const list = Object.keys(data);
		        const result = {};
		        list.forEach((fieldName) => {
		            if (Array.isArray(validatorsLib.fields[fieldName])) {
		                result[fieldName] = validatorsLib.fields[fieldName];
		            }
		        });
		        return result;
		    } else {
		        return {};
		    }
		};

		const composeFormValidators = (name, validatorsLib) => {
		    if (!validatorsLib) return [];
		    if (validatorsLib.forms && Array.isArray(validatorsLib.forms[name])) {
		        return validatorsLib.forms[name];
		    }
		    if (Array.isArray(validatorsLib.form)) {
		        return validatorsLib.form;
		    }
		    return [];
		};

		runner_utils = {
		    composeFieldsValidators,
		    composeFormValidators,
		};
		return runner_utils;
	}

	var runner;
	var hasRequiredRunner;

	function requireRunner () {
		if (hasRequiredRunner) return runner;
		hasRequiredRunner = 1;
		const {
		    composeFieldsValidators,
		    composeFormValidators,
		} = requireRunner_utils();

		const ValidationSession = requireSession();

		/**
		 * Creates validation runner function from provided validation rules lib
		 * @param {object}     validationLib object containing fields validation rules and form specific rules
		 * @returns {function} (data: object, formName: string)=>Promise<ValidationResult>
		 **/
		const ValidationRunner = (validatorsLib) => {
		    /**
		     * Validation session runner
		     * @param {object} data      object to validate
		     * @param {string} formName
		     * @returns {Promise}
		     **/
		    return (data, formName) => {
		        const validators = {
		            //fields specific validators
		            fields: composeFieldsValidators(data, validatorsLib),
		            //form specific validators
		            form: composeFormValidators(formName, validatorsLib),
		        };
		        return ValidationSession(validators, data);
		    };
		};

		runner = ValidationRunner;
		return runner;
	}

	var builder_utils;
	var hasRequiredBuilder_utils;

	function requireBuilder_utils () {
		if (hasRequiredBuilder_utils) return builder_utils;
		hasRequiredBuilder_utils = 1;
		const augmentFieldsValidators = (fieldValidators, getValidatorEnv) => {
		    return fieldValidators.map((fieldRule) =>
		        augmentFieldValidator(fieldRule, getValidatorEnv)
		    );
		};

		const augmentFieldValidator = (rule, getValidatorEnv) => {
		    if (rule.validator && typeof rule.validator === "function") {
		        const ruleValidator = rule.validator;
		        const result = {
		            ...rule,
		        };
		        delete result.validator;
		        result.validator = (val) => ruleValidator(val, getValidatorEnv());
		        return result;
		    }
		    return rule;
		};

		const augmentFormValidators = (rules, getValidatorEnv) => {
		    return rules.map((rule) => augmentFormValidator(rule, getValidatorEnv));
		};

		const augmentFormValidator = (rule, getValidatorEnv) => {
		    return (val) => rule(val, getValidatorEnv());
		};

		builder_utils = {
		    augmentFieldsValidators,
		    augmentFieldValidator,
		    augmentFormValidators,
		    augmentFormValidator,
		};
		return builder_utils;
	}

	var builder;
	var hasRequiredBuilder;

	function requireBuilder () {
		if (hasRequiredBuilder) return builder;
		hasRequiredBuilder = 1;
		const objHas = (obj, name) => {
		    return Object.prototype.hasOwnProperty.call(obj, name);
		};
		const {
		    augmentFieldsValidators,
		    augmentFormValidators,
		} = requireBuilder_utils();

		/**
		 * @typedef   {object}    notValidationSchema
		 * @property  {object}    [fields]
		 * @property  {array}     [form]
		 * @property  {object}    [forms]
		 */

		/**
		 * returns valid empty validation scheme
		 *
		 * @return {notValidationSchema}
		 */
		const emptyScheme = () => {
		    return {
		        fields: {},
		        forms: {},
		    };
		};
		/**
		 *
		 *
		 * @param {object} validators
		 * @param {function} getValidatorEnv
		 * @return {notValidationSchema}
		 */
		const validationBuilder = (validators, getValidatorEnv) => {
		    if (typeof validators === "undefined" || validators === null) {
		        return emptyScheme();
		    }
		    const augmented = {};
		    if (objHas(validators, "fields")) {
		        augmented.fields = transformFieldsValidators(
		            validators.fields,
		            getValidatorEnv
		        );
		    }
		    if (objHas(validators, "forms")) {
		        augmented.forms = transformFormsValidators(
		            validators.forms,
		            getValidatorEnv
		        );
		    } else {
		        if (objHas(validators, "form")) {
		            augmented.form = augmentFormValidators(
		                validators.form,
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		builder = validationBuilder;

		const transformFieldsValidators = (fields, getValidatorEnv) => {
		    const augmented = {};
		    for (let fieldName in fields) {
		        if (Array.isArray(fields[fieldName])) {
		            augmented[fieldName] = augmentFieldsValidators(
		                fields[fieldName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		const transformFormsValidators = (formsValidators, getValidatorEnv) => {
		    const augmented = {};
		    for (let formName in formsValidators) {
		        if (Array.isArray(formsValidators[formName])) {
		            augmented[formName] = augmentFormValidators(
		                formsValidators[formName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};
		return builder;
	}

	var src;
	var hasRequiredSrc;

	function requireSrc () {
		if (hasRequiredSrc) return src;
		hasRequiredSrc = 1;
		const Session = requireSession();
		const Runner = requireRunner();
		const Builder = requireBuilder();
		const Result = requireResult();

		src = {
		    name: "not-validation",
		    Session,
		    Runner,
		    Builder,
		    Result,
		};
		return src;
	}

	var srcExports = requireSrc();

	var root_4$4 = from_html(`<div><div class="field-label is-normal"><!></div> <div class="field-body"></div></div>`);
	var root_7$1 = from_html(`<!> <!>`, 1);
	var root_6$3 = from_html(`<div></div>`);

	function Field($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [label]
		 * @property {string} [name]
		 * @property {boolean} [readonly]
		 * @property {boolean} [horizontal]
		 * @property {any} [controls]
		 * @property {import('../../../elements/events.types').UIEventInputChangeCallback} onchange
		 * @property {string} [classes] - field style modification
		 * @property {boolean} [addons] - //addons
		 * @property {boolean} [addonsCentered]
		 * @property {boolean} [addonsRight]
		 * @property {boolean} [grouped] - //group flag
		 * @property {boolean} [groupedMultiline]
		 * @property {boolean} [groupedRight]
		 * @property {boolean} [groupedCentered]
		 */
		/** @type {Props} */
		let label = prop($$props, 'label', 3, ""),
			name = prop($$props, 'name', 3, "generic field"),
			readonly = prop($$props, 'readonly', 3, false),
			horizontal = prop($$props, 'horizontal', 3, false),
			controls = prop($$props, 'controls', 19, () => []),
			classes = prop($$props, 'classes', 3, ""),
			addons = prop($$props, 'addons', 3, false),
			addonsCentered = prop($$props, 'addonsCentered', 3, false),
			addonsRight = prop($$props, 'addonsRight', 3, false),
			grouped = prop($$props, 'grouped', 3, false),
			groupedMultiline = prop($$props, 'groupedMultiline', 3, false),
			groupedRight = prop($$props, 'groupedRight', 3, false),
			groupedCentered = prop($$props, 'groupedCentered', 3, false),
			onchange = prop($$props, 'onchange', 3, () => true),
			formFieldPrefix = prop($$props, 'formFieldPrefix', 3, "form-field-");

		let fieldClasses = state("");
		let hidden = state(false);
		let fieldId = state(void 0);

		onMount(() => {
			set(fieldClasses, get$3(fieldClasses) + (" " + classes()));
			set(fieldClasses, get$3(fieldClasses) + (addons() ? " has-addons " : ""));
			set(fieldClasses, get$3(fieldClasses) + (addonsCentered() ? " has-addons-centered " : ""));
			set(fieldClasses, get$3(fieldClasses) + (addonsRight() ? " has-addons-right " : ""));
			set(fieldClasses, get$3(fieldClasses) + (grouped() ? " is-grouped " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedMultiline() ? " is-grouped-multiline " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedRight() ? " is-grouped-right " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedCentered() ? " is-grouped-centered " : ""));

			if (readonly()) {
				controls().forEach((control) => {
					control.readonly = true;
				});
			}

			let notHidden = controls().filter((control) => control.component !== "UIHidden");

			set(hidden, notHidden.length === 0);

			let tmp = controls().map((itm) => itm.component).join("_");

			set(fieldId, `${formFieldPrefix()}${tmp}-${name()}`);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, controls, index$e, ($$anchor, control) => {
					const SvelteComponent = user_derived(() => COMPONENTS$1.get(get$3(control).component));
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					component(node_2, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_3) => {
						SvelteComponent_3($$anchor, spread_props(() => get$3(control), {
							get onchange() {
								return onchange();
							},

							get fieldname() {
								return name();
							}
						}));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				{
					var consequent_1 = ($$anchor) => {
						var div = root_4$4();
						var div_1 = child(div);
						var node_4 = child(div_1);

						{
							let $0 = user_derived(() => label() || controls()[0].label);

							Ui_label(node_4, {
								get for() {
									return get$3(fieldId);
								},

								get label() {
									return get$3($0);
								}
							});
						}

						reset(div_1);

						var div_2 = sibling(div_1, 2);

						each(div_2, 21, controls, index$e, ($$anchor, control) => {
							const SvelteComponent_1 = user_derived(() => COMPONENTS$1.get(get$3(control).component));
							var fragment_4 = comment();
							var node_5 = first_child(fragment_4);

							component(node_5, () => get$3(SvelteComponent_1), ($$anchor, SvelteComponent_1_1) => {
								SvelteComponent_1_1($$anchor, spread_props(() => get$3(control), {
									get onchange() {
										return onchange();
									},

									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_4);
						});

						reset(div_2);
						reset(div);

						template_effect(() => {
							set_class(div, 1, `field is-horizontal ${get$3(fieldClasses) ?? ''} ${get$3(fieldId) ?? ''}`);
							set_attribute(div_2, 'id', get$3(fieldId));
						});

						append($$anchor, div);
					};

					var alternate = ($$anchor) => {
						var div_3 = root_6$3();

						each(div_3, 21, controls, index$e, ($$anchor, control) => {
							const SvelteComponent_2 = user_derived(() => COMPONENTS$1.get(get$3(control).component));
							var fragment_5 = root_7$1();
							var node_6 = first_child(fragment_5);

							Ui_label(node_6, {
								get for() {
									return `form-field-${get$3(control).component ?? ''}-${name() ?? ''}`;
								},

								get label() {
									return get$3(control).label;
								}
							});

							var node_7 = sibling(node_6, 2);

							component(node_7, () => get$3(SvelteComponent_2), ($$anchor, SvelteComponent_2_1) => {
								SvelteComponent_2_1($$anchor, spread_props(() => get$3(control), {
									get onchange() {
										return onchange();
									},

									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_5);
						});

						reset(div_3);
						template_effect(() => set_class(div_3, 1, `field ${get$3(fieldClasses) ?? ''} ${get$3(fieldId) ?? ''}`));
						append($$anchor, div_3);
					};

					if_block(
						node_3,
						($$render) => {
							if (horizontal()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (get$3(hidden)) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$5 = from_html(`<div><span class="title"> </span></div>`);
	var root_2$3 = from_html(`<div class="notification is-success"><h3 class="form-success-message"> </h3></div>`);
	var root_4$3 = from_html(`<h5 class="title is-5"> </h5>`);
	var root_5$3 = from_html(`<h6 class="subtitle is-6"> </h6>`);
	var root_7 = from_html(`<button> </button>`);
	var root_8 = from_html(`<button> </button>`);
	var root_9 = from_html(`<div class="edit-form-error notification is-danger"> </div>`);
	var root_6$2 = from_html(`<div class="buttons is-grouped is-centered"><!> <!></div> <!>`, 1);
	var root_14 = from_html(`<div><!></div>`);
	var root_15 = from_html(`<div class="column notification is-danger"> </div>`);
	var root_11 = from_html(`<div class="columns"></div>`);
	var root_19 = from_html(`<div class="notification is-danger"> </div>`);
	var root_22 = from_html(`<span> </span>`);
	var root_21 = from_html(`<div class="edit-form-error notification is-danger"></div>`);
	var root_23 = from_html(`<button> </button>`);
	var root_24 = from_html(`<button> </button>`);
	var root_20 = from_html(`<!> <div class="buttons is-grouped is-centered"><!> <!></div>`, 1);
	var root_3$4 = from_html(`<!> <!> <!> <!> <!>`, 1);
	var root$6 = from_html(`<div class="form-container"><!> <!></div>`);

	function Form($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let dispatch = createEventDispatcher();

		//validation status
		let formErrors = state(proxy([]));

		let formHasErrors = state(false);
		let fieldsHasErrors = state(false);
		let success = state(false);

		//input data
		//form structure object
		//hidden - no loader
		//container - parent container of form
		//fields list structure
		/**
		 * @typedef {Object} Props
		 * @property {any} [form] - {
		[fieldName: string] => description: object
		}
		 * @property {boolean} [loading] - state if form loading
		 * @property {string} [loader] - page - whole page
		 * @property {any} [fields] - each item is a row
		if item is array, then there few fields in a row
		[
		[name, age],
		[email, telephone]
		bio,
		agreed
		]
		 * @property {string} [SUCCESS_TEXT] - form result labels
		 * @property {string} [WAITING_TEXT]
		 * @property {string} [title] - form labels
		 * @property {string} [description]
		 * @property {boolean} [buttonsFirst] - if you want button on top
		 * @property {boolean} [horizontal] - if form fields should have horizontal layout
		 * @property {any} [submit] - buttons labels and availability
		 * @property {any} [cancel]
		 */
		/** @type {Props} */
		let form = prop($$props, 'form', 31, () => proxy({})),
			loading = prop($$props, 'loading', 15, false),
			loader = prop($$props, 'loader', 3, "container"),
			fields = prop($$props, 'fields', 19, () => []),
			SUCCESS_TEXT = prop($$props, 'SUCCESS_TEXT', 3, "Операция завершена"),
			WAITING_TEXT = prop($$props, 'WAITING_TEXT', 3, "Отправка данных на сервер"),
			title = prop($$props, 'title', 3, ""),
			description = prop($$props, 'description', 3, ""),
			buttonsFirst = prop($$props, 'buttonsFirst', 3, false),
			horizontal = prop($$props, 'horizontal', 3, false),
			submit = prop($$props, 'submit', 19, () => ({ caption: "Отправить", enabled: true })),
			cancel = prop($$props, 'cancel', 19, () => ({ caption: "Назад", enabled: true }));

		let formInvalid = user_derived(() => get$3(formHasErrors) || get$3(fieldsHasErrors));

		function collectData() {
			return FormHelpers.collectData(fields(), form());
		}

		function setFieldInvalid(fieldName, value, errors) {
			form(FormHelpers.setFieldInvalid(form(), fieldName, value, errors));
			set(fieldsHasErrors, true);
		}

		function setFieldValid(fieldName, value) {
			form(FormHelpers.setFieldValid(form(), fieldName, value));
		}

		function isFieldValid(fieldName) {
			return FormHelpers.isFieldValid(form(), fieldName);
		}

		function setFormFieldInvalid(fieldName, errors) {
			form(FormHelpers.setFormFieldInvalid(form(), fieldName, errors));
			dispatch(`field.invalid`, { fieldName });
		}

		function setFormFieldValid(fieldName) {
			form(FormHelpers.setFormFieldValid(form(), fieldName));
			dispatch(`field.valid`, { fieldName });
		}

		function updateFormValidationStatus(
			validationStatus /* FormValidationSession.getCompleteResult() */
		) {
			set(formHasErrors, false);
			set(fieldsHasErrors, false);

			if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
				get$3(formErrors).splice(0, get$3(formErrors).length, ...validationStatus.form);
				set(formHasErrors, true);
			} else {
				get$3(formErrors).splice(0, get$3(formErrors).length);
			}

			set(formErrors, get$3(formErrors), true);

			if (validationStatus.fields) {
				for (let fieldName of Object.keys(form())) {
					if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
						FormHelpers.setFormFieldInvalid(form(), fieldName, validationStatus.fields[fieldName]);
						set(fieldsHasErrors, true);
					} else {
						FormHelpers.setFormFieldValid(form(), fieldName);
					}
				}
			}
		}

		function showSuccess() {
			set(success, true);
		}

		function setLoading() {
			loading(true);
		}

		function resetLoading() {
			loading(false);
		}

		function setFieldsVisibility(fieldsList, val) {
			if (FormHelpers.setFieldsVisibility(form(), fieldsList, val)) {
				form(form());
			}
		}

		function setVisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, true);
		}

		function setInvisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, false);
		}

		function setFieldValue(fieldName, value) {
			if (FormHelpers.setFieldValue(form(), fieldName, value)) {
				onFieldChange({ detail: { field: fieldName, value } });
			}
		}

		function updateField(fieldName, props) {
			form(form()[fieldName] = { ...form()[fieldName], ...props }, true);
			form(form());
		}

		function onFieldChange(ev) {
			let data = ev.detail;

			form(form()[data.field].value = data.value, true);
			form(form());
			dispatch("change", data);
		}

		function submitForm(e) {
			e && e.preventDefault();
			dispatch("submit", collectData());

			return false;
		}

		function rejectForm() {
			dispatch("reject");
		}

		var $$exports = {
			collectData,
			setFieldInvalid,
			setFieldValid,
			isFieldValid,
			setFormFieldInvalid,
			setFormFieldValid,
			updateFormValidationStatus,
			showSuccess,
			setLoading,
			resetLoading,
			setFieldsVisibility,
			setVisibleFields,
			setInvisibleFields,
			setFieldValue,
			updateField
		};

		var div = root$6();
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var div_1 = root_1$5();
				var span = child(div_1);
				var text = child(span, true);

				reset(span);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, 1, `${loader() === 'page' ? 'pageloader' : 'containerloader'} ${loading() ? 'is-active' : ''}`);
					set_text(text, $LOCALE()[WAITING_TEXT()]);
				});

				append($$anchor, div_1);
			};

			if_block(node, ($$render) => {
				if (loader() !== "hidden") $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_2 = root_2$3();
				var h3 = child(div_2);
				var text_1 = child(h3, true);

				reset(h3);
				reset(div_2);
				template_effect(() => set_text(text_1, $LOCALE()[SUCCESS_TEXT()]));
				append($$anchor, div_2);
			};

			var alternate_3 = ($$anchor) => {
				var fragment = root_3$4();
				var node_2 = first_child(fragment);

				{
					var consequent_2 = ($$anchor) => {
						var h5 = root_4$3();
						var text_2 = child(h5, true);

						reset(h5);
						template_effect(() => set_text(text_2, $LOCALE()[title()]));
						append($$anchor, h5);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_2);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_3 = ($$anchor) => {
						var h6 = root_5$3();
						var text_3 = child(h6, true);

						reset(h6);
						template_effect(() => set_text(text_3, $LOCALE()[description()]));
						append($$anchor, h6);
					};

					if_block(node_3, ($$render) => {
						if (description()) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_1 = root_6$2();
						var div_3 = first_child(fragment_1);
						var node_5 = child(div_3);

						{
							var consequent_4 = ($$anchor) => {
								var button = root_7();

								button.__click = rejectForm;

								var text_4 = child(button, true);

								reset(button);

								template_effect(() => {
									set_class(button, 1, `button is-outlined ${cancel().classes ?? ''}`);
									set_text(text_4, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button);
							};

							if_block(node_5, ($$render) => {
								if (cancel().enabled) $$render(consequent_4);
							});
						}

						var node_6 = sibling(node_5, 2);

						{
							var consequent_5 = ($$anchor) => {
								var button_1 = root_8();

								button_1.__click = submitForm;

								var text_5 = child(button_1, true);

								reset(button_1);

								template_effect(() => {
									button_1.disabled = get$3(formInvalid);
									set_class(button_1, 1, `button is-primary is-hovered ${submit().classes ?? ''}`);
									set_text(text_5, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_1);
							};

							if_block(node_6, ($$render) => {
								if (submit().enabled) $$render(consequent_5);
							});
						}

						reset(div_3);

						var node_7 = sibling(div_3, 2);

						{
							var consequent_6 = ($$anchor) => {
								var div_4 = root_9();
								var text_6 = child(div_4, true);

								reset(div_4);
								template_effect(($0) => set_text(text_6, $0), [() => get$3(formErrors).join(", ")]);
								append($$anchor, div_4);
							};

							if_block(node_7, ($$render) => {
								if (get$3(formErrors).length > 0) $$render(consequent_6);
							});
						}

						append($$anchor, fragment_1);
					};

					if_block(node_4, ($$render) => {
						if (buttonsFirst()) $$render(consequent_7);
					});
				}

				var node_8 = sibling(node_4, 2);

				each(node_8, 17, fields, index$e, ($$anchor, field) => {
					var fragment_2 = comment();
					var node_9 = first_child(fragment_2);

					{
						var consequent_10 = ($$anchor) => {
							var div_5 = root_11();

							each(div_5, 21, () => get$3(field), index$e, ($$anchor, subfield) => {
								var fragment_3 = comment();
								var node_10 = first_child(fragment_3);

								{
									var consequent_9 = ($$anchor) => {
										var fragment_4 = comment();
										var node_11 = first_child(fragment_4);

										{
											var consequent_8 = ($$anchor) => {
												var div_6 = root_14();
												var node_12 = child(div_6);

												{
													let $0 = user_derived(() => [form()[get$3(subfield)]]);

													Field(node_12, {
														get controls() {
															return get$3($0);
														},

														get name() {
															return get$3(subfield);
														},

														get horizontal() {
															return horizontal();
														},

														get label() {
															return form()[get$3(subfield)].label;
														},

														$$events: { change: onFieldChange }
													});
												}

												reset(div_6);
												template_effect(() => set_class(div_6, 1, `column ${form()[get$3(subfield)].fieldSize ? 'is-' + form()[get$3(subfield)].fieldSize : ''} `));
												append($$anchor, div_6);
											};

											if_block(node_11, ($$render) => {
												if (form()[get$3(subfield)].visible) $$render(consequent_8);
											});
										}

										append($$anchor, fragment_4);
									};

									var alternate = ($$anchor) => {
										var div_7 = root_15();
										var text_7 = child(div_7);

										reset(div_7);
										template_effect(() => set_text(text_7, `Subfield '${get$3(subfield) ?? ''}' is not registered`));
										append($$anchor, div_7);
									};

									if_block(node_10, ($$render) => {
										if (form()[get$3(subfield)] && form()[get$3(subfield)].component) $$render(consequent_9); else $$render(alternate, false);
									});
								}

								append($$anchor, fragment_3);
							});

							reset(div_5);
							append($$anchor, div_5);
						};

						var alternate_2 = ($$anchor) => {
							var fragment_5 = comment();
							var node_13 = first_child(fragment_5);

							{
								var consequent_12 = ($$anchor) => {
									var fragment_6 = comment();
									var node_14 = first_child(fragment_6);

									{
										var consequent_11 = ($$anchor) => {
											{
												let $0 = user_derived(() => [form()[get$3(field)]]);

												Field($$anchor, {
													get controls() {
														return get$3($0);
													},

													get name() {
														return get$3(field);
													},

													get horizontal() {
														return horizontal();
													},

													get label() {
														return form()[get$3(field)].label;
													},

													$$events: { change: onFieldChange }
												});
											}
										};

										if_block(node_14, ($$render) => {
											if (form()[get$3(field)].visible) $$render(consequent_11);
										});
									}

									append($$anchor, fragment_6);
								};

								var alternate_1 = ($$anchor) => {
									var div_8 = root_19();
									var text_8 = child(div_8);

									reset(div_8);
									template_effect(() => set_text(text_8, `Field '${get$3(field) ?? ''}' is not registered`));
									append($$anchor, div_8);
								};

								if_block(
									node_13,
									($$render) => {
										if (form()[get$3(field)] && form()[get$3(field)].component) $$render(consequent_12); else $$render(alternate_1, false);
									},
									true
								);
							}

							append($$anchor, fragment_5);
						};

						if_block(node_9, ($$render) => {
							if (Array.isArray(get$3(field))) $$render(consequent_10); else $$render(alternate_2, false);
						});
					}

					append($$anchor, fragment_2);
				});

				var node_15 = sibling(node_8, 2);

				{
					var consequent_16 = ($$anchor) => {
						var fragment_8 = root_20();
						var node_16 = first_child(fragment_8);

						{
							var consequent_13 = ($$anchor) => {
								var div_9 = root_21();

								each(div_9, 21, () => get$3(formErrors), index$e, ($$anchor, formError) => {
									var span_1 = root_22();
									var text_9 = child(span_1, true);

									reset(span_1);
									template_effect(() => set_text(text_9, $LOCALE()[get$3(formError)]));
									append($$anchor, span_1);
								});

								reset(div_9);
								append($$anchor, div_9);
							};

							if_block(node_16, ($$render) => {
								if (get$3(formErrors).length > 0) $$render(consequent_13);
							});
						}

						var div_10 = sibling(node_16, 2);
						var node_17 = child(div_10);

						{
							var consequent_14 = ($$anchor) => {
								var button_2 = root_23();

								button_2.__click = rejectForm;

								var text_10 = child(button_2, true);

								reset(button_2);

								template_effect(() => {
									set_class(button_2, 1, `button ${(cancel().classes ? cancel().classes : '') ?? ''}`);
									set_text(text_10, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button_2);
							};

							if_block(node_17, ($$render) => {
								if (cancel().enabled) $$render(consequent_14);
							});
						}

						var node_18 = sibling(node_17, 2);

						{
							var consequent_15 = ($$anchor) => {
								var button_3 = root_24();

								button_3.__click = submitForm;

								var text_11 = child(button_3, true);

								reset(button_3);

								template_effect(() => {
									button_3.disabled = get$3(formInvalid);
									set_class(button_3, 1, `button is-primary is-hovered ${(submit().classes ? submit().classes : '') ?? ''}`);
									set_text(text_11, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_3);
							};

							if_block(node_18, ($$render) => {
								if (submit().enabled) $$render(consequent_15);
							});
						}

						reset(div_10);
						append($$anchor, fragment_8);
					};

					if_block(node_15, ($$render) => {
						if (!buttonsFirst()) $$render(consequent_16);
					});
				}

				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (get$3(success)) $$render(consequent_1); else $$render(alternate_3, false);
			});
		}

		reset(div);
		append($$anchor, div);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	delegate(['click']);

	const DEFAULT_RULES = {
	  notReadonly(v) {
	    return {
	      readonly: !v
	    };
	  },
	  readonly(v) {
	    return {
	      readonly: v
	    };
	  },
	  enable(v) {
	    return {
	      disabled: !v
	    };
	  },
	  disable(v) {
	    return {
	      disabled: v
	    };
	  }
	};
	let notFormRules = /*#__PURE__*/function () {
	  function notFormRules() {
	    _classCallCheck(this, notFormRules);
	  }
	  return _createClass(notFormRules, null, [{
	    key: "add",
	    value: function add(name, func) {
	      if (!notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name)) {
	        _assertClassBrand(notFormRules, this, _RULES)._[name] = func;
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove(name) {
	      if (notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name) && !Object.keys(DEFAULT_RULES).includes(name)) {
	        delete _assertClassBrand(notFormRules, this, _RULES)._[name];
	      }
	    }
	  }, {
	    key: "exec",
	    value: function exec(rule, master, slaves, value, form) {
	      return _assertClassBrand(notFormRules, this, _RULES)._[rule](value, master, slaves, form);
	    }
	  }]);
	}();
	var _RULES = {
	  _: {
	    ...DEFAULT_RULES
	  }
	};

	const DEFAULT_CONTAINER_SELECTOR$1 = ".form";
	const DEFAULT_ACTION_NAME = "default";
	var _uiComponent = /*#__PURE__*/new WeakMap();
	var _validationRunner = /*#__PURE__*/new WeakMap();
	var _form$1 = /*#__PURE__*/new WeakMap();
	var _action = /*#__PURE__*/new WeakMap();
	var _fields = /*#__PURE__*/new WeakMap();
	var _variants = /*#__PURE__*/new WeakMap();
	var _notForm_brand = /*#__PURE__*/new WeakSet();
	let notForm = /*#__PURE__*/function (_notBase) {
	  //variants for UI

	  function notForm({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data: _data = {},
	    ui = Form //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notForm);
	    _this = _callSuper(this, notForm, [{
	      working: {
	        name: `${name}Form`,
	        ...working
	      },
	      options,
	      data: _data
	    }]);
	    _classPrivateMethodInitSpec(_this, _notForm_brand);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent, null);
	    //form validation
	    _classPrivateFieldInitSpec(_this, _validationRunner, null);
	    //ui component
	    _classPrivateFieldInitSpec(_this, _form$1, null);
	    //model.action
	    _classPrivateFieldInitSpec(_this, _action, DEFAULT_ACTION_NAME);
	    //fields schemas
	    _classPrivateFieldInitSpec(_this, _fields, new Lib());
	    //fields of UI
	    //variants sets for select menus and so on
	    _classPrivateFieldInitSpec(_this, _variants, null);
	    _classPrivateFieldSet2(_variants, _this, new Lib(VARIANTS$1.getContent()));
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent, _this, ui);
	    if (notCommon$1.objHas(options, "action")) {
	      _classPrivateFieldSet2(_action, _this, options.action);
	    }
	    _this.initForm();
	    return _this;
	  }
	  _inherits(notForm, _notBase);
	  return _createClass(notForm, [{
	    key: "initForm",
	    value: function initForm() {
	      if (this.getOptions("autoInit", true)) {
	        this.initLibs();
	      }
	      if (this.getOptions("autoRender", true)) {
	        this.initUI();
	      }
	    }
	  }, {
	    key: "initLibs",
	    value: function initLibs() {
	      this.initFields();
	      this.initVariants();
	      this.initValidator();
	    }
	  }, {
	    key: "reInit",
	    value: function reInit() {
	      this.initLibs();
	      this.updateUI();
	      this.resetLoading();
	    }
	  }, {
	    key: "initFields",
	    value: function initFields() {
	      const manifest = this.getFormManifest();
	      if (notCommon$1.objHas(manifest, "fields") && _classPrivateFieldGet2(_fields, this).isEmpty()) {
	        _classPrivateFieldGet2(_fields, this).import(manifest.fields); //all fields available in model manifest
	      }
	    }
	  }, {
	    key: "initVariants",
	    value: function initVariants() {
	      if (this.getOptions("variants")) {
	        _classPrivateFieldGet2(_variants, this).import(this.getOptions("variants"));
	      }
	    }

	    //creating validators runner for this specific form
	  }, {
	    key: "initValidator",
	    value: function initValidator() {
	      _classPrivateFieldSet2(_validationRunner, this, srcExports.Runner(this.getFormValidators()));
	    }
	  }, {
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        const target = this.getFormTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_form$1, this, new (_classPrivateFieldGet2(_uiComponent, this))({
	          target,
	          props
	        }));
	        _assertClassBrand(_notForm_brand, this, _bindUIEvents).call(this);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "updateUI",
	    value: function updateUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        _classPrivateFieldGet2(_form$1, this).$set(props);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "validateForm",
	    value: async function validateForm() {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      try {
	        const validationResult = await _classPrivateFieldGet2(_validationRunner, this).call(this, _classPrivateFieldGet2(_form$1, this).collectData(), this.getFormAction());
	        _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(validationResult.getReport());
	        if (!validationResult.clean) {
	          this.emit("error", validationResult.getReport());
	        }
	      } catch (e) {
	        const report = {
	          form: [UICommon$1.ERROR_DEFAULT, e.message]
	        };
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(report);
	        this.emit("error", report);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "submit",
	    value: function submit(data) {
	      this.emit("submit", data);
	    }
	  }, {
	    key: "reject",
	    value: function reject() {
	      this.emit("reject");
	    }

	    //binding event to actual UI
	  }, {
	    key: "$on",
	    value: function $on() {
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$on(...arguments);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_form$1, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_form$1, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$destroy && _classPrivateFieldGet2(_form$1, this).$destroy();
	        _classPrivateFieldGet2(_form$1, this).destroy && _classPrivateFieldGet2(_form$1, this).destroy();
	        _classPrivateFieldSet2(_form$1, this, null);
	      }
	      _classPrivateFieldSet2(_validationRunner, this, null);
	      _classPrivateFieldSet2(_action, this, null);
	      _classPrivateFieldSet2(_fields, this, null);
	      _classPrivateFieldSet2(_variants, this, null);
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }
	  }, {
	    key: "getFormAction",
	    value: function getFormAction() {
	      return _classPrivateFieldGet2(_action, this);
	    }
	  }, {
	    key: "setFormAction",
	    value: function setFormAction(val) {
	      if (val && val !== _classPrivateFieldGet2(_action, this)) {
	        _classPrivateFieldSet2(_action, this, val);
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).$destroy();
	        this.initForm();
	      }
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_form$1, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(status);
	      this.emit("error", status);
	    }

	    /**
	     * Returns variant by collection name and item id
	     * @param {string}         name  name of the variants collection
	     * @param {string|number}  id    item identificator
	     * @returns {object}             item
	     **/
	  }, {
	    key: "getVariant",
	    value: function getVariant(name, id) {
	      let lib = _classPrivateFieldGet2(_variants, this).get(name);
	      let result = lib.find(function (item) {
	        return item.id === id;
	      });
	      if (result) {
	        return result;
	      }
	      return null;
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$1);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("Form parent element is not defined");
	      }
	    }
	  }, {
	    key: "getFormValidators",
	    value: function getFormValidators() {
	      if (this.getOptions("validators")) {
	        return this.getOptions("validators", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "validators");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormManifest",
	    value: function getFormManifest() {
	      const modelName = this.getModelName();
	      if (modelName && notCommon$1.getApp()) {
	        return notCommon$1.getApp().getInterfaceManifest(modelName);
	      }
	      if (this.getOptions("manifest", undefined)) {
	        return this.getOptions("manifest", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "manifest");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormData",
	    value: function getFormData() {
	      if (this.getData()) {
	        return this.getData();
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "data");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormOptions",
	    value: function getFormOptions() {
	      if (this.getOptions("ui", undefined) || this.getOptions("fields", undefined)) {
	        return {
	          ui: this.getOptions("ui", {}),
	          fields: this.getOptions("fields", {})
	        };
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "options");
	        return {
	          ui: {},
	          fields: {}
	        };
	      }
	    }
	  }, {
	    key: "getFormInjectedProps",
	    value: function getFormInjectedProps() {
	      return this.getOptions("injected", {});
	    }

	    /**
	     * Override empty message
	     **/
	  }, {
	    key: "collectData",
	    value:
	    /**
	     * Form operations
	     **/
	    function collectData() {
	      if (this.getOptions("readonly", false)) {
	        return this.getData();
	      }
	      const data = _classPrivateFieldGet2(_form$1, this).collectData();
	      this.setData({
	        ...data
	      }); //update in inner store
	      return data;
	    }
	  }, {
	    key: "updateField",
	    value: function updateField(fieldName, props) {
	      _classPrivateFieldGet2(_form$1, this).updateField(fieldName, props);
	    }
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        return this.getInterface(name)(data || {});
	      } else {
	        return this.getInterface()(name || {});
	      }
	    }
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = false) {
	      return notCommon$1.getApp().getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getOptions("model");
	    }
	  }]);
	}(notBase);
	function _bindUIEvents() {
	  var _this2 = this;
	  _classPrivateFieldGet2(_form$1, this).$on("change", function () {
	    return _this2.validateForm();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("change", function (ev) {
	    _this2.emit("change", ev.detail);
	    _this2.emit(`change.${ev.detail.field}`, ev.detail.value);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("submit", function (ev) {
	    return _this2.submit(ev.detail);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("reject", function () {
	    return _this2.reject();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("error", function ({
	    detail
	  }) {
	    return _this2.emit("error", detail);
	  });
	  _assertClassBrand(_notForm_brand, this, _bindMasterSlaveEvents).call(this);
	}
	function _bindMasterSlaveEvents() {
	  const masters = this.getOptions("masters", false);
	  if (!masters) {
	    return;
	  }
	  for (let master in masters) {
	    const rules = masters[master];
	    for (let ruleName in rules) {
	      const ruleSlaves = rules[ruleName];
	      _assertClassBrand(_notForm_brand, this, _addMasterSlaveEvents).call(this, ruleName, master, ruleSlaves);
	    }
	  }
	}
	function _addMasterSlaveEvents(rule, master, slaves = []) {
	  var _this3 = this;
	  this.on(`change.${master}`, function (value) {
	    _assertClassBrand(_notForm_brand, _this3, _execSlaveRule).call(_this3, rule, master, slaves, value);
	  });
	  this.emit(`change.${master}`, this.getFormData()[master]);
	}
	function _execSlaveRule(rule, master, slaves, value) {
	  var _this4 = this;
	  const cmd = notFormRules.exec(rule, master, slaves, value, this);
	  slaves.forEach(function (slaveField) {
	    _this4.updateField(slaveField, cmd);
	  });
	}
	function _getFormProps({
	  manifest,
	  //model manifest
	  formOptions = {
	    ui: {},
	    fields: {}
	  },
	  //some options
	  data = null,
	  //initial data for form
	  injectedProps = {}
	}) {
	  const action = _classPrivateFieldGet2(_action, this);
	  if (typeof formOptions === "undefined" || formOptions === null) {
	    formOptions = {
	      ui: {},
	      fields: {}
	    };
	  }
	  const form = FormHelpers.initFormByField(
	  //form seed object
	  {},
	  /*
	  Form structure
	  [
	  //each item is line of form
	  //field - field takes whole line of form
	  //[field1, field2] - few fields in one line
	  nameFirst, nameLast
	  [age, country, language],
	  [email, telephone]
	  ]
	  */
	  manifest.actions[action].fields,
	  //form fields structure
	  _classPrivateFieldGet2(_variants, this),
	  //variants library
	  _classPrivateFieldGet2(_fields, this),
	  //fields library
	  formOptions.fields,
	  //form wide fields options
	  data);
	  return {
	    //if no auto init of form structure, set to loading state
	    loading: !this.getOptions("autoInit", true),
	    title: manifest.actions[action].title,
	    description: manifest.actions[action].description,
	    fields: manifest.actions[action].fields,
	    form,
	    //injecting options to UI from top level input
	    ...formOptions.ui,
	    //form UI options
	    ...injectedProps
	  };
	}
	function _missingOverrideWarning(missing) {
	  this.error(`${missing} for ${this.getWorking("name")} form is not defined`);
	}

	var root$5 = from_html(`<div class="block-container"><div class="form-paper"></div> <!></div>`);

	function Form_set($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [name]
		 * @property {boolean} [showModes]
		 * @property {string} [mode]
		 * @property {any} [forms]
		 */
		/** @type {Props} */
		let name = prop($$props, 'name', 3, 'default-form'),
			showModes = prop($$props, 'showModes', 3, false),
			mode = prop($$props, 'mode', 15, 'default'),
			forms = prop($$props, 'forms', 19, () => []);

		function setMode(val) {
			mode(val);
			dispatch('mode', val);
			updateModesButtons();
		}

		let FORMS_BUTTONS = state(proxy([]));

		function updateModesButtons() {
			set(
				FORMS_BUTTONS,
				forms().filter((form) => {
					return mode() !== form.mode;
				}).map((form) => {
					return {
						title: form.title,
						outlined: true,
						type: 'link',

						action() {
							setMode(form.mode);
						}
					};
				}),
				true
			);
		}

		onMount(() => {
			updateModesButtons();
		});

		var div = root$5();
		var div_1 = child(div);
		var node = sibling(div_1, 2);

		{
			var consequent = ($$anchor) => {
				Ui_buttons($$anchor, {
					centered: true,
					classes: 'mt-4',

					get values() {
						return get$3(FORMS_BUTTONS);
					},

					set values($$value) {
						set(FORMS_BUTTONS, $$value, true);
					}
				});
			};

			if_block(node, ($$render) => {
				if (showModes()) $$render(consequent);
			});
		}

		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', `${name() ?? ''}-form-set`);
			set_attribute(div_1, 'id', `${name() ?? ''}-form-set-container`);
		});

		append($$anchor, div);
		pop();
	}

	const DEFAULT_CONTAINER_SELECTOR = ".form-set";
	const DEFAULT_FORM_SET_NAME = "form-set";
	var _formSetComponent = /*#__PURE__*/new WeakMap();
	var _formComponent = /*#__PURE__*/new WeakMap();
	var _form = /*#__PURE__*/new WeakMap();
	var _frame = /*#__PURE__*/new WeakMap();
	var _notFormSet_brand = /*#__PURE__*/new WeakSet();
	let notFormSet = /*#__PURE__*/function (_notBase) {
	  /*
	  new notFormSet({
	  options:{
	    target: el,
	    forms: [{
	      mode: 'form1',
	      title: 'Form 1',
	      form: formConstructor1 //custom constructors
	    },{
	      mode: 'form2',
	      title: 'Form 2',
	      props: {}             //params to create notForm instance
	    },{
	      mode: 'form3',
	      title: 'Form 3',
	      form: formConstructor3 //custom constructors
	    }]
	  }
	  });
	  */

	  function notFormSet({
	    options = {},
	    formComponent = Form,
	    formSetComponent = Form_set
	  }) {
	    var _this;
	    _classCallCheck(this, notFormSet);
	    _this = _callSuper(this, notFormSet, [{
	      options: {
	        name: DEFAULT_FORM_SET_NAME,
	        mode: "default",
	        showModes: true,
	        ...options
	      }
	    }]);
	    _classPrivateMethodInitSpec(_this, _notFormSet_brand);
	    _classPrivateFieldInitSpec(_this, _formSetComponent, null);
	    _classPrivateFieldInitSpec(_this, _formComponent, null);
	    _classPrivateFieldInitSpec(_this, _form, null);
	    _classPrivateFieldInitSpec(_this, _frame, null);
	    _classPrivateFieldSet2(_formComponent, _this, formComponent);
	    _classPrivateFieldSet2(_formSetComponent, _this, formSetComponent);
	    _this.setFormMode(_this.getOptions("mode"));
	    _this.initUI();
	    return _this;
	  }

	  /**
	   * Initalizing form frame mode, with switchers between modes
	   **/
	  _inherits(notFormSet, _notBase);
	  return _createClass(notFormSet, [{
	    key: "initUI",
	    value: function initUI() {
	      var _this2 = this;
	      const target = this.getFrameTargetEl();
	      while (target.children.length) target.removeChild(target.firstChild);
	      _classPrivateFieldSet2(_frame, this, new (_classPrivateFieldGet2(_formSetComponent, this))({
	        target,
	        props: _assertClassBrand(_notFormSet_brand, this, _getFrameProps).call(this)
	      }));
	      _classPrivateFieldGet2(_frame, this).$on("mode", function (ev) {
	        _this2.setFormMode(ev.detail);
	        _this2.updateForm();
	      });
	      this.updateForm();
	    }
	  }, {
	    key: "setFormMode",
	    value: function setFormMode(name) {
	      if (this.isModeExists(name)) {
	        this.setWorking("mode", name);
	      } else {
	        this.setWorking("mode", this.getFirstMode());
	        this.updateFormModeInUI();
	      }
	    }
	  }, {
	    key: "updateFormModeInUI",
	    value: function updateFormModeInUI() {
	      if (_classPrivateFieldGet2(_frame, this) && this.getWorking("mode") !== null) {
	        _classPrivateFieldGet2(_frame, this).$set({
	          mode: this.getWorking("mode")
	        });
	      }
	    }
	  }, {
	    key: "getFormMode",
	    value: function getFormMode() {
	      return this.getWorking("mode");
	    }
	  }, {
	    key: "updateForm",
	    value: function updateForm() {
	      this.destroyForm();
	      if (this.getWorking("mode") !== null) {
	        this.renderForm();
	      }
	    }
	  }, {
	    key: "renderForm",
	    value: function renderForm() {
	      var _this3 = this;
	      const targetEl = this.getFormTargetEl();
	      const formConfig = this.getFormConfig();
	      if (!(targetEl instanceof HTMLElement && formConfig)) {
	        throw new Error("error while form rendering");
	      }
	      const changeMode = function (mode) {
	        _this3.setFormMode(mode);
	        _this3.updateForm();
	      };
	      if (formConfig.form) {
	        while (targetEl.children.length) targetEl.removeChild(targetEl.firstChild);
	        _classPrivateFieldSet2(_form, this, new formConfig.form({
	          options: {
	            target: targetEl,
	            changeMode
	          }
	        }));
	      } else if (formConfig.props) {
	        _classPrivateFieldSet2(_form, this, new (_classPrivateFieldGet2(_formComponent, this))({
	          target: targetEl,
	          ...formConfig.props,
	          changeMode
	        }));
	      }
	    }
	  }, {
	    key: "getFormConfig",
	    value: function getFormConfig() {
	      var _this4 = this;
	      return this.getOptions("forms").find(function (form) {
	        return form.mode === _this4.getFormMode();
	      });
	    }
	  }, {
	    key: "destroyForm",
	    value: function destroyForm() {
	      const containerEl = this.getFormTargetEl();
	      if (containerEl) {
	        while (containerEl.firstChild) {
	          containerEl.removeChild(containerEl.lastChild);
	        }
	      }
	      if (_classPrivateFieldGet2(_form, this) && _classPrivateFieldGet2(_form, this).$destroy) {
	        _classPrivateFieldGet2(_form, this).$destroy();
	      }
	      _classPrivateFieldSet2(_form, this, null);
	    }
	  }, {
	    key: "destroyFrame",
	    value: function destroyFrame() {
	      if (_classPrivateFieldGet2(_frame, this) && _classPrivateFieldGet2(_frame, this).$destroy) {
	        _classPrivateFieldGet2(_frame, this).$destroy();
	      }
	      _classPrivateFieldSet2(_frame, this, null);
	    }
	  }, {
	    key: "isModeExists",
	    value: function isModeExists(mode) {
	      const forms = this.getOptions("forms", []);
	      return forms.some(function (item) {
	        return item.mode === mode;
	      });
	    }
	  }, {
	    key: "getFirstMode",
	    value: function getFirstMode() {
	      const forms = this.getOptions("forms", []);
	      if (forms.length > 0) {
	        return forms[0].mode;
	      }
	      return null;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      _classPrivateFieldSet2(_formSetComponent, this, null);
	      _classPrivateFieldSet2(_formComponent, this, null);
	      this.destroyForm();
	      this.destroyFrame();
	      this.setData(null);
	      this.setOptions(null);
	      this.setWorking(null);
	    }
	  }, {
	    key: "getFrameTargetEl",
	    value: function getFrameTargetEl() {
	      const target = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR);
	      if (target instanceof HTMLElement) {
	        return target;
	      } else if (typeof target === "string") {
	        return document.querySelector(target);
	      } else {
	        throw new Error("form set target is not HTMLElement or string");
	      }
	    }
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const name = this.getOptions("name", DEFAULT_FORM_SET_NAME);
	      return document.querySelector(`#${name}-form-set-container`);
	    }
	  }]);
	}(notBase);
	function _getFrameProps() {
	  return {
	    showModes: this.getOptions("showModes", true),
	    mode: this.getFormMode(),
	    forms: this.getOptions("forms", []),
	    name: this.getOptions("name", DEFAULT_FORM_SET_NAME)
	  };
	}

	var root_3$3 = from_html(`<li class="is-active"><a aria-current="page"> </a></li>`);
	var root_5$2 = from_html(`<li class="is-plain-crumb"> </li>`);
	var root_6$1 = from_html(`<li><a> </a></li>`);
	var root_1$4 = from_html(`<nav class="breadcrumb" aria-label="breadcrumbs"><ul></ul></nav>`);

	function Ui_breadcrumbs($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [go]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			go = prop($$props, 'go', 3, null);

		function onClick(ev) {
			if (typeof go() === "function") {
				ev.preventDefault();
				go()(ev.currentTarget.dataset.href);

				return false;
			} else {
				return true;
			}
		}

		var nav = root_1$4();
		var ul = child(nav);

		each(ul, 21, items, index$e, ($$anchor, link, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var li = root_3$3();
					var a = child(li);
					var text = child(a, true);

					reset(a);
					reset(li);

					template_effect(() => {
						set_attribute(a, 'href', `${root() ?? ''}${get$3(link).url ?? ''}`);
						set_attribute(a, 'data-href', get$3(link).url);
						set_text(text, $LOCALE()[get$3(link).title]);
					});

					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					{
						var consequent_1 = ($$anchor) => {
							var li_1 = root_5$2();
							var text_1 = child(li_1, true);

							reset(li_1);
							template_effect(() => set_text(text_1, $LOCALE()[get$3(link).title]));
							append($$anchor, li_1);
						};

						var alternate = ($$anchor) => {
							var li_2 = root_6$1();
							var a_1 = child(li_2);

							a_1.__click = onClick;

							var text_2 = child(a_1, true);

							reset(a_1);
							reset(li_2);

							template_effect(() => {
								set_attribute(a_1, 'href', `${root() ?? ''}${get$3(link).url ?? ''}`);
								set_attribute(a_1, 'data-href', get$3(link).url);
								set_text(text_2, $LOCALE()[get$3(link).title]);
							});

							append($$anchor, li_2);
						};

						if_block(
							node_1,
							($$render) => {
								if (get$3(link).url === false) $$render(consequent_1); else $$render(alternate, false);
							},
							true
						);
					}

					append($$anchor, fragment_1);
				};

				if_block(node, ($$render) => {
					if (items().length === index + 1) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		reset(nav);
		append($$anchor, nav);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	let local_ui_props = state(proxy({}));
	let notBreadcrumbs = /*#__PURE__*/function () {
	  function notBreadcrumbs() {
	    _classCallCheck(this, notBreadcrumbs);
	  }
	  return _createClass(notBreadcrumbs, null, [{
	    key: "initUIProps",
	    value: function initUIProps(root, navigate) {
	      set(local_ui_props, {
	        items: this.getBreadcrumbs(),
	        root,
	        go: navigate
	      }, true);
	    }
	  }, {
	    key: "render",
	    value: function render({
	      target,
	      root = "",
	      navigate
	    }) {
	      this.remove();
	      if (notBreadcrumbs.UIConstructor) {
	        this.initUIProps(root, navigate);
	        this.ui = mount(notBreadcrumbs.UIConstructor, {
	          target,
	          props: get$3(local_ui_props)
	        });
	      }
	      return this;
	    }
	  }, {
	    key: "setHead",
	    value: function setHead(head) {
	      this.head.splice(0, this.head.length, ...head);
	      return this;
	    }
	  }, {
	    key: "setTail",
	    value: function setTail(tail) {
	      this.tail.splice(0, this.tail.length, ...tail);
	      return this;
	    }
	  }, {
	    key: "getBreadcrumbs",
	    value: function getBreadcrumbs() {
	      let crumbs = [];
	      crumbs.push(...this.head);
	      crumbs.push(...this.tail);
	      return crumbs;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.ui) {
	        get$3(local_ui_props).items = this.getBreadcrumbs();
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.ui) {
	        umount(this.ui);
	        this.ui = null;
	      }
	      return this;
	    }
	  }]);
	}();
	_defineProperty(notBreadcrumbs, "UIConstructor", null);
	_defineProperty(notBreadcrumbs, "ui", null);
	_defineProperty(notBreadcrumbs, "head", []);
	_defineProperty(notBreadcrumbs, "tail", []);

	notBreadcrumbs.UIConstructor = Ui_breadcrumbs;

	var _Menu;
	let Menu = /*#__PURE__*/function () {
	  function Menu() {
	    _classCallCheck(this, Menu);
	  }
	  return _createClass(Menu, null, [{
	    key: "hide",
	    value: function hide() {}
	  }, {
	    key: "setOptionsAdapter",
	    value: function setOptionsAdapter(optionsAdapter) {
	      if (!this.optionsAdapter && optionsAdapter) {
	        this.optionsAdapter = optionsAdapter;
	      }
	      return this;
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(options) {
	      this.options = {
	        ...this.options,
	        ...options
	      };
	      return this;
	    }
	  }, {
	    key: "isDirectNavigation",
	    value: function isDirectNavigation() {
	      return this.options.directNavigation;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      if (this.optionsAdapter) {
	        return this.optionsAdapter.getOptions(this.options);
	      } else {
	        return this.options;
	      }
	    }
	  }, {
	    key: "initField",
	    value: function initField(list, fields = []) {
	      var _this = this;
	      list.forEach(function (item) {
	        fields.forEach(function (field) {
	          if (!Object.hasOwn(item, field)) {
	            item[field] = _this.DEFAULT[field];
	          }
	        });
	        if (Object.hasOwn(item, "items")) {
	          _this.initField(item.items, fields);
	        }
	      });
	    }
	  }, {
	    key: "sortList",
	    value: function sortList(list) {
	      var _this2 = this;
	      list.sort(function (item1, item2) {
	        if (Object.hasOwn(item1, "items")) {
	          _this2.sortList(item1.items);
	        }
	        if (Object.hasOwn(item2, "items")) {
	          _this2.sortList(item2.items);
	        }
	        if (item1.priority === item2.priority) {
	          return item1.title > item2.title ? 1 : -1;
	        } else {
	          return item1.priority < item2.priority ? 1 : -1;
	        }
	      });
	    }
	  }, {
	    key: "removeDublicates",
	    value: function removeDublicates(sections) {
	      for (let i = 0; i < sections.length; i++) {
	        let priority = sections[i].priority;
	        sections.filter(function (section) {
	          return section.id === sections[i].id;
	        }).forEach(function (item, indx) {
	          if (indx === 0) {
	            return;
	          }
	          if (item.priority < priority) {
	            priority = item.priority;
	          }
	          sections.splice(sections.indexOf(item), 1);
	        });
	        sections[i].priority = priority;
	      }
	      return sections;
	    }
	  }, {
	    key: "prepareData",
	    value: function prepareData() {
	      let items = [];
	      items.push(...this.getOptions().items);
	      let sections = [];
	      sections.push(...this.getOptions().sections);
	      this.initField(sections, ["priority"]);
	      this.removeDublicates(sections);
	      this.initField(items, ["priority", "section", "type"]);
	      this.sortList(sections);
	      sections.push({
	        id: this.DEFAULT.section,
	        title: this.DEFAULT.sectionTitle
	      });
	      this.sortList(items);
	      this.sections = sections;
	      this.items = items;
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.menu) {
	        unmount(this.menu);
	        this.menu = null;
	        clearInterval(this.interval);
	      }
	    }
	  }, {
	    key: "updateIndicator",
	    value: function updateIndicator(sectionId, itemId, state) {
	      this.updateSection(sectionId, function (section) {
	        section.indicator.state = state;
	      });
	      this.updateItem(itemId, function (item) {
	        item.indicator.state = state;
	      });
	    }
	  }, {
	    key: "updateTag",
	    value: function updateTag(sectionId, itemId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = tag;
	      });
	      this.updateItem(itemId, function (item) {
	        item.tag = tag;
	      });
	    }
	  }, {
	    key: "updateSectionTag",
	    value: function updateSectionTag(sectionId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = {
	          ...section.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateItemTag",
	    value: function updateItemTag(itemId, tag) {
	      this.updateItem(itemId, function (item) {
	        item.tag = {
	          ...item.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateSection",
	    value: function updateSection(sectionId, proc) {
	      if (this.sections && sectionId) {
	        for (let section in this.sections) {
	          if (this.sections[section].id !== sectionId) continue;
	          proc(this.sections[section]);
	        }
	        if (this.menu) {
	          this.menu.$set({
	            sections: this.sections
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateSectionItems",
	    value: function updateSectionItems(sectionId, proc) {
	      if (this.sections && sectionId) {
	        let oldList = this.items.filter(function (item) {
	          return item.section === sectionId;
	        });
	        for (let i of oldList) {
	          this.items.splice(this.items.indexOf(i), 1);
	        }
	        this.items.push(...proc(oldList));
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateItem",
	    value: function updateItem(itemId, proc) {
	      if (itemId && this.items) {
	        this.items.forEach(function (item) {
	          if (item.id !== itemId) return;
	          proc(item);
	        });
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "isTouch",
	    value: function isTouch() {
	      return UICommon$1.isMobile(true);
	    }
	  }, {
	    key: "getSectionComponent",
	    value: function getSectionComponent() {}
	  }]);
	}();
	_Menu = Menu;
	_defineProperty(Menu, "MAX_TOUCH_WIDTH", 1023);
	_defineProperty(Menu, "INTERVAL_UPDATE_ACTIVE_ITEM", 200);
	_defineProperty(Menu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  open: false
	});
	/**
	 *
	 * @type {import('./notApp.adapter.js').default | null}
	 * @static
	 * @memberof Menu
	 */
	_defineProperty(Menu, "optionsAdapter", void 0);
	_defineProperty(Menu, "directNavigation", false);
	_defineProperty(Menu, "menu", void 0);
	_defineProperty(Menu, "options", {
	  directNavigation: false,
	  navigate: function (urls) {
	    _Menu.hide();
	    if (!_Menu.isDirectNavigation() && _Menu.optionsAdapter) {
	      const navigate = _Menu.optionsAdapter.getNavigateFunction();
	      if (navigate) {
	        return navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});
	_defineProperty(Menu, "items", []);
	_defineProperty(Menu, "sections", []);
	_defineProperty(Menu, "location", void 0);
	_defineProperty(Menu, "interval", void 0);

	var root$4 = from_html(`<a class="navbar-item"><!> <!></a>`);

	function Ui_brand($$anchor, $$props) {
		/* eslint svelte/no-at-html-tags: 0 */
		/**
		 * @typedef {Object} Props
		 * @property {string} [url]
		 * @property {string} [title]
		 * @property {any} [icon]
		 */
		/** @type {Props} */
		let url = prop($$props, 'url', 3, "/"),
			title = prop($$props, 'title', 3, ""),
			icon = prop($$props, 'icon', 19, () => ({
				src: "https://via.placeholder.com/56x28",
				width: 28,
				height: 56
			}));

		var a = root$4();
		var node = child(a);

		Ui_icon(node, spread_props(icon));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_2 = first_child(fragment);

				html(node_2, () => `<span class="navbar-item-brand-title">${title()}</span>`);
				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		reset(a);
		template_effect(() => set_attribute(a, 'href', url()));
		append($$anchor, a);
	}

	var root$3 = from_html(`<!> <!> <!>`, 1);

	function Ui_item_content($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		var fragment = root$3();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon($$anchor, spread_props(() => $$props.item.icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						const SvelteComponent = user_derived(() => COMPONENTS$1.get($$props.item.component));
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
							SvelteComponent_1($$anchor, spread_props(
								{
									get id() {
										return $$props.item.id;
									}
								},
								() => $$props.item.props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, $LOCALE()[$$props.item.title]));
						append($$anchor, text$1);
					};

					if_block(
						node_1,
						($$render) => {
							if ($$props.item.type === "component" && $$props.item.component && COMPONENTS$1.contains($$props.item.component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if ($$props.item.icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						top: true,
						right: true,
						size: 'small',

						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.tag
				));
			};

			if_block(node_3, ($$render) => {
				if ($$props.item.tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.indicator
				));
			};

			if_block(node_4, ($$render) => {
				if ($$props.item.indicator) $$render(consequent_3);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$2 = from_html(`<hr/>`);
	var root_3$2 = from_html(`<a><!></a>`);
	var root_4$2 = from_html(`<div role="button" tabindex="0"><!></div>`);
	var root_1$3 = from_html(`<!> <!>`, 1);

	function Ui_item($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 * @property {string} [hidden]
		 * @property {string} [classes]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			item = prop($$props, 'item', 19, () => ({})),
			hidden = prop($$props, 'hidden', 3, ""),
			classes = prop($$props, 'classes', 3, "");

		function onClick(event) {
			dispatch("click", { event, element: item() });
		}

		var fragment = root_1$3();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var hr = root_2$2();

				template_effect(() => set_class(hr, 1, `navbar-divider ${hidden() ? `is-hidden-${hidden()}` : ''} `));
				append($$anchor, hr);
			};

			if_block(node, ($$render) => {
				if (item().break) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var a = root_3$2();

				a.__click = onClick;

				var node_2 = child(a);

				Ui_item_content(node_2, {
					get item() {
						return item();
					}
				});

				reset(a);

				template_effect(() => {
					set_class(a, 1, `navbar-item ${hidden() ? `is-hidden-${hidden()}` : ''} ${item().classes ?? ''} ${classes() ?? ''} `);
					set_attribute(a, 'href', `${root() ?? ''}${item().url ?? ''}`);
					set_attribute(a, 'data-href', item().url);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				var div = root_4$2();

				div.__click = onClick;
				div.__keyup = onClick;

				var node_3 = child(div);

				Ui_item_content(node_3, {
					get item() {
						return item();
					}
				});

				reset(div);
				template_effect(() => set_class(div, 1, `navbar-item ${hidden() ? `is-hidden-${hidden()}` : ''} ${item().classes ?? ''} ${classes() ?? ''}`));
				append($$anchor, div);
			};

			if_block(node_1, ($$render) => {
				if (item().url) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_2$1 = from_html(`<div><a href=""><!></a> <div></div></div>`);
	var root_5$1 = from_html(`<a><!></a>`);
	var root_6 = from_html(`<div role="button" tabindex="0"><!></div>`);

	function Ui_section$1($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [section]
		 * @property {any} [items]
		 * @property {string} [hidden]
		 * @property {boolean} [hoverable]
		 * @property {boolean} [arrowless]
		 * @property {boolean} [right]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			section = prop($$props, 'section', 19, () => ({})),
			items = prop($$props, 'items', 19, () => []),
			hidden = prop($$props, 'hidden', 3, ""),
			hoverable = prop($$props, 'hoverable', 3, true),
			arrowless = prop($$props, 'arrowless', 3, false),
			right = prop($$props, 'right', 3, false);

		function onClick(event) {
			dispatch("click", { event, element: section() });
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_2$1();
				var a = child(div);

				a.__click = onClick;

				var node_1 = child(a);

				Ui_item_content(node_1, {
					get item() {
						return section();
					}
				});

				reset(a);

				var div_1 = sibling(a, 2);

				each(div_1, 21, items, (item) => item.id, ($$anchor, item) => {
					Ui_item($$anchor, {
						get root() {
							return root();
						},

						get item() {
							return get$3(item);
						},

						$$events: {
							click($$arg) {
								bubble_event.call(this, $$props, $$arg);
							}
						}
					});
				});

				reset(div_1);
				reset(div);

				template_effect(() => {
					set_class(div, 1, `navbar-item has-dropdown ${hoverable() ? 'is-hoverable' : ''} ${hidden() ? `is-hidden-${hidden()}` : ''} `);
					set_class(a, 1, `navbar-link ${arrowless() ? 'is-arrowless' : ''}`);
					set_class(div_1, 1, `navbar-dropdown ${right() ? 'is-right' : ''}`);
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_2 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var a_1 = root_5$1();

						a_1.__click = onClick;

						var node_3 = child(a_1);

						Ui_item_content(node_3, {
							get item() {
								return section();
							}
						});

						reset(a_1);

						template_effect(() => {
							set_class(a_1, 1, `navbar-item ${hidden() ? `is-hidden-${hidden()}` : ''} `);
							set_attribute(a_1, 'href', `${root() ?? ''}${section().url ?? ''}`);
							set_attribute(a_1, 'data-href', section().url);
						});

						append($$anchor, a_1);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_6();

						div_2.__click = onClick;
						div_2.__keyup = onClick;

						var node_4 = child(div_2);

						Ui_item_content(node_4, {
							get item() {
								return section();
							}
						});

						reset(div_2);
						template_effect(() => set_class(div_2, 1, `navbar-item ${hidden() ? `is-hidden-${hidden()}` : ''} `));
						append($$anchor, div_2);
					};

					if_block(
						node_2,
						($$render) => {
							if (section().url) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	const SideMenuState = writable({
	  open: true
	});

	var root$2 = from_html(`<a href="" role="button" aria-label="menu" aria-expanded="false" data-target="navbar"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a>`);

	function Ui_burger($$anchor, $$props) {
		push($$props, true);

		const COMPONENT_NAME = "top-navbar-burger";
		const dispatch = createEventDispatcher();

		function toggle(e) {
			e.preventDefault();
			closed(!closed());
			dispatch("toggle", { closed: closed() });

			return false;
		}

		function getStandartUpdateEventName() {
			return COMPONENT_NAME + ":update";
		}

		/**
		 * @typedef {Object} Props
		 * @property {any} [events]
		 * @property {any} [register]
		 * @property {boolean} [closed]
		 * @property {any} [onUpdate]
		 */
		/** @type {Props} */
		let events = prop($$props, 'events', 31, () => proxy({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			closed = prop($$props, 'closed', 15, true),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				closed(data.closed);
			});

		onMount(() => {
			if (!notCommon$1.objHas(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		SideMenuState.subscribe((val) => {
			closed(!val.open);

			return val;
		});

		var a = root$2();

		a.__click = toggle;
		template_effect(() => set_class(a, 1, `navbar-burger ${closed() ? '' : 'is-active'}`));
		append($$anchor, a);
		pop();
	}

	delegate(['click']);

	var root_1$2 = from_html(`<div class="navbar-brand"><!> <!> <!> <!></div> <div id="navbar"><div class="navbar-start"></div> <div class="navbar-end"></div></div>`, 1);

	function Ui_top($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [sections] - import { beforeUpdate } from "svelte";
		 * @property {any} [items]
		 * @property {string} [root]
		 * @property {any} [navigate]
		 * @property {boolean} [brand]
		 * @property {boolean} [showBurger]
		 * @property {boolean} [burgerControlsSidemenu]
		 */
		/** @type {Props} */
		let sections = prop($$props, 'sections', 19, () => []),
			items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			navigate = prop($$props, 'navigate', 3, null),
			brand = prop($$props, 'brand', 3, false),
			showBurger = prop($$props, 'showBurger', 3, true),
			burgerControlsSidemenu = prop($$props, 'burgerControlsSidemenu', 3, true);

		let menuClosed = state(true);

		function onClick({ detail }) {
			let { event, element } = detail;

			if (Object.hasOwn(element, "action")) {
				return element.action(event, element);
			}

			event.preventDefault();

			if (typeof navigate() === "function") {
				navigate()({
					full: event.currentTarget.getAttribute("href"),
					short: event.currentTarget.dataset.href
				});
			}

			return false;
		}

		let sectionsItemsCount = {};
		let sectionsItems = {};

		/*
		beforeUpdate(() => {
		    for (let section of sections) {
		        sectionsItems[section.id] = items.filter(
		            (t) => t.section === section.id
		        );
		        sectionsItemsCount[section.id] = items.filter(
		            (t) => t.section === section.id
		        ).length;
		    }
		});
		*/
		function toggleBurger({ detail }) {
			if (burgerControlsSidemenu()) {
				SideMenu.toggle();
			} else {
				dispatch("toggleBurger", detail);
				set(menuClosed, detail.closed, true);
			}
		}

		var fragment = root_1$2();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_brand($$anchor, spread_props(brand));
			};

			if_block(node, ($$render) => {
				if (brand()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		each(node_1, 17, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_2 = comment();
			var node_2 = first_child(fragment_2);

			{
				var consequent_1 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'desktop',

						get item() {
							return get$3(section);
						},

						get root() {
							return root();
						},

						$$events: { click: onClick }
					});
				};

				if_block(node_2, ($$render) => {
					if (get$3(section).showOnTouch) $$render(consequent_1);
				});
			}

			append($$anchor, fragment_2);
		});

		var node_3 = sibling(node_1, 2);

		each(node_3, 17, items, (item) => item.id, ($$anchor, item) => {
			var fragment_4 = comment();
			var node_4 = first_child(fragment_4);

			{
				var consequent_2 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'desktop',

						get item() {
							return get$3(item);
						},

						get root() {
							return root();
						},

						onclick: onClick
					});
				};

				if_block(node_4, ($$render) => {
					if (get$3(item).showOnTouch) $$render(consequent_2);
				});
			}

			append($$anchor, fragment_4);
		});

		var node_5 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_burger($$anchor, { $$events: { toggle: toggleBurger } });
			};

			if_block(node_5, ($$render) => {
				if (showBurger()) $$render(consequent_3);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var div_2 = child(div_1);

		each(div_2, 21, items, index$e, ($$anchor, item) => {
			var fragment_7 = comment();
			var node_6 = first_child(fragment_7);

			{
				var consequent_4 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'touch',

						get item() {
							return get$3(item);
						},

						onclick: onClick
					});
				};

				if_block(node_6, ($$render) => {
					if (get$3(item).place === "start") $$render(consequent_4);
				});
			}

			append($$anchor, fragment_7);
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);

		each(div_3, 21, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_9 = comment();
			var node_7 = first_child(fragment_9);

			{
				var consequent_5 = ($$anchor) => {
					Ui_section$1($$anchor, {
						right: true,

						get hidden() {
							return get$3(section).hidden;
						},

						get root() {
							return root();
						},

						get section() {
							return get$3(section);
						},

						get items() {
							return sectionsItems[get$3(section).id];
						},

						onclick: onClick
					});
				};

				if_block(node_7, ($$render) => {
					if ((sectionsItemsCount[get$3(section).id] || get$3(section).indicator || get$3(section).tag) && get$3(section).place == "end") $$render(consequent_5);
				});
			}

			append($$anchor, fragment_9);
		});

		reset(div_3);
		reset(div_1);
		template_effect(() => set_class(div_1, 1, `navbar-menu ${get$3(menuClosed) ? '' : 'is-active'}`));
		append($$anchor, fragment);
		pop();
	}

	var _notTopMenu;
	const TYPE$1 = "top";
	let MENU_PROPS = state(proxy({}));
	let notTopMenu = /*#__PURE__*/function (_Menu) {
	  function notTopMenu() {
	    _classCallCheck(this, notTopMenu);
	    return _callSuper(this, notTopMenu, arguments);
	  }
	  _inherits(notTopMenu, _Menu);
	  return _createClass(notTopMenu, null, [{
	    key: "initMenuProps",
	    value: function initMenuProps() {
	      set(MENU_PROPS, {
	        brand: this.getOptions().brand,
	        items: this.items,
	        sections: this.sections,
	        root: this.getOptions().root,
	        navigate: this.getOptions().navigate
	      }, true);
	    }
	  }, {
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        this.initMenuProps();
	        let target = document.querySelector(this.getOptions().targetSelector);
	        if (!target) {
	          return;
	        }
	        this.menu = mount(Ui_top, {
	          target,
	          props: this.MENU_PROPS
	        });
	        this.interval = setInterval(this.updateMenuActiveItem.bind(this), notTopMenu.INTERVAL_UPDATE_ACTIVE_ITEM);
	      }
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu(url) {
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " aside.menu a")).forEach(function (item) {
	        if (item.href == url || url.href && url.href.indexOf(item.href) == 0) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu(url);
	        }
	      } else {
	        this.location = url;
	        this.updateMenu(url);
	      }
	    }
	  }, {
	    key: "toggle",
	    value: function toggle() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.toggle("is-active");
	    }
	  }, {
	    key: "hide",
	    value: function hide() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.remove("is-active");
	    }
	  }, {
	    key: "show",
	    value: function show() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.add("is-active");
	    }
	  }, {
	    key: "setBurgerState",
	    value: function setBurgerState(menuClosed) {
	      get$3(MENU_PROPS).menuClosed = menuClosed;
	    }
	  }]);
	}(Menu);
	_notTopMenu = notTopMenu;
	_defineProperty(notTopMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  place: "main"
	});
	_defineProperty(notTopMenu, "options", {
	  brand: false,
	  type: TYPE$1,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE$1}-menu`,
	  root: "/",
	  directNavigation: false,
	  navigate: function (urls) {
	    _notTopMenu.hide();
	    if (!_notTopMenu.isDirectNavigation() && _notTopMenu.app) {
	      let func = _notTopMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	var root_2 = from_html(`<li><a> <!> <!></a></li>`);
	var root_5 = from_html(`<li> <!> <!></li>`);

	function Ui_item_without_children($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			item = prop($$props, 'item', 19, () => ({})),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		function onClick(ev) {
			ev.preventDefault();

			onnavigate()({
				full: ev.target.getAttribute("href"),
				short: ev.target.dataset.href
			});

			return false;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var li = root_2();
				var a = child(li);

				a.__click = onClick;

				var text = child(a);
				var node_1 = sibling(text);

				{
					var consequent = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_1, ($$render) => {
						if (item().tag) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_2, ($$render) => {
						if (item().indicator) $$render(consequent_1);
					});
				}

				reset(a);
				reset(li);

				template_effect(() => {
					set_class(li, 1, clsx(item().classes));
					set_attribute(a, 'href', `${root() ?? ''}${item().url ?? ''}`);
					set_attribute(a, 'data-href', item().url);
					set_text(text, `${$LOCALE()[item().title] ?? ''} `);
				});

				append($$anchor, li);
			};

			var alternate = ($$anchor) => {
				var li_1 = root_5();
				var text_1 = child(li_1);
				var node_3 = sibling(text_1);

				{
					var consequent_3 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_3, ($$render) => {
						if (item().tag) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_4 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_4, ($$render) => {
						if (item().indicator) $$render(consequent_4);
					});
				}

				reset(li_1);

				template_effect(() => {
					set_class(li_1, 1, `is-no-follow-subtitle ${item().classes ?? ''}`);
					set_text(text_1, `${$LOCALE()[item().title] ?? ''} `);
				});

				append($$anchor, li_1);
			};

			if_block(node, ($$render) => {
				if (typeof item().url !== "undefined" && item().url !== false) $$render(consequent_2); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root$1 = from_html(`<span class="icon is-small is-toggle-submenu is-pulled-right" role="button" tabindex="0"><i aria-hidden="true"></i></span>`);

	function Ui_trigger($$anchor, $$props) {
		push($$props, true);

		const CLASS_ICON = { OPENED: "fa-angle-down", CLOSED: "fa-angle-up" };

		/**
		 * @typedef {Object} Props
		 * @property {any} [icon_opened]
		 * @property {any} [icon_closed]
		 * @property {boolean} [closed]    returns if we should apply toggle or if false - reject it and toggle backward
		 */
		/** @type {Props} */
		let icon_opened = prop($$props, 'icon_opened', 19, () => CLASS_ICON.OPENED),
			icon_closed = prop($$props, 'icon_closed', 19, () => CLASS_ICON.CLOSED),
			closed = prop($$props, 'closed', 7),
			ontoggle = prop($$props, 'ontoggle', 3, () => {
				return true;
			});

		function onClick(e) {
			e && e.preventDefault() && e.stopPropagation();
			closed(!closed());

			if (!ontoggle()(closed())) {
				closed(!closed());
			}

			return false;
		}

		var span = root$1();

		span.__click = onClick;
		span.__keyup = onClick;

		var i = child(span);

		reset(span);
		template_effect(() => set_class(i, 1, `fas ${(closed() ? icon_closed() : icon_opened()) ?? ''}`));
		append($$anchor, span);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_4$1 = from_html(`<span class="is-no-link"> </span>`);
	var root = from_html(`<!> <!> <!> <!>`, 1);

	function Ui_item_label($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();
		let item = prop($$props, 'item', 19, () => ({}));
		var fragment = root();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, spread_props(() => item().icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						const SvelteComponent = user_derived(() => COMPONENTS$1.get(item().component));
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
							SvelteComponent_1($$anchor, spread_props(
								{
									get id() {
										return item().id;
									}
								},
								() => item().props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var span = root_4$1();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[item().title]));
						append($$anchor, span);
					};

					if_block(
						node_1,
						($$render) => {
							if (item().type === "component" && item().component && COMPONENTS$1.contains(item().component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (item().icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().tag
				));
			};

			if_block(node_3, ($$render) => {
				if (item().tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().indicator
				));
			};

			if_block(node_4, ($$render) => {
				if (item().indicator) $$render(consequent_3);
			});
		}

		var node_5 = sibling(node_4, 2);

		snippet(node_5, () => $$props.children ?? noop);
		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4 = from_html(`<a class="has-subitems"><!></a>`);
	var root_3$1 = from_html(`<li><!> <!></li>`);
	var root_1$1 = from_html(`<ul></ul>`);

	function Ui_items_1($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {boolean} [closed]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		const createClosedItemsLib = (lst) => {
			const lib = {};

			lst.forEach((itm, index) => lib[index] = itm.closed);

			return lib;
		};

		let closedChildren = proxy(createClosedItemsLib(items()));

		function onClick(ev) {
			ev.preventDefault();

			onnavigate()({
				full: ev.target.getAttribute("href"),
				short: ev.target.dataset.href
			});

			return false;
		}

		var ul = root_1$1();

		each(ul, 21, items, index$e, ($$anchor, item, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent_1 = ($$anchor) => {
					var li = root_3$1();
					var node_1 = child(li);

					{
						var consequent = ($$anchor) => {
							var a = root_4();

							a.__click = onClick;

							var node_2 = child(a);

							Ui_item_label(node_2, {
								get item() {
									return get$3(item);
								},

								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},

										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},

								$$slots: { default: true }
							});

							reset(a);

							template_effect(() => {
								set_attribute(a, 'href', `${root() ?? ''}${get$3(item).url ?? ''}`);
								set_attribute(a, 'data-href', get$3(item).url);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							Ui_item_label($$anchor, {
								get item() {
									return get$3(item);
								},

								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},

										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},

								$$slots: { default: true }
							});
						};

						if_block(node_1, ($$render) => {
							if (typeof get$3(item).url !== "undefined" && get$3(item).url !== false) $$render(consequent); else $$render(alternate, false);
						});
					}

					var node_3 = sibling(node_1, 2);

					Ui_items_1(node_3, {
						get root() {
							return root();
						},

						get items() {
							return get$3(item).items;
						},

						get onnavigate() {
							return onnavigate();
						},

						get closed() {
							return closedChildren[index];
						},

						set closed($$value) {
							closedChildren[index] = $$value;
						}
					});

					reset(li);
					template_effect(() => set_class(li, 1, `is-no-follow-subtitle ${get$3(item).classes ?? ''}`));
					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					Ui_item_without_children($$anchor, {
						get root() {
							return root();
						},

						get item() {
							return get$3(item);
						},

						get onnavigate() {
							return onnavigate();
						}
					});
				};

				if_block(node, ($$render) => {
					if (get$3(item).items && get$3(item).items.length) $$render(consequent_1); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		template_effect(() => set_class(ul, 1, `menu-list ${$$props.closed ? 'is-closed' : ''}`));
		append($$anchor, ul);
		pop();
	}

	delegate(['click']);

	var root_3 = from_html(`<p><!> <!> <!></p>`);
	var root_1 = from_html(`<!> <!>`, 1);

	function Ui_section($$anchor, $$props) {
		push($$props, true);

		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		const [$$stores, $$cleanup] = setup_stores();

		/**
		 * @typedef {Object} Props
		 * @property {any}      section
		 * @property {any}      [items]
		 * @property {string}   [root]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		let sectionItems = user_derived(() => items().filter((item) => $$props.section.id === item.section));
		var fragment = root_1();
		var node = first_child(fragment);

		{
			var consequent_4 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_3 = ($$anchor) => {
						var p = root_3();
						var node_2 = child(p);

						{
							var consequent = ($$anchor) => {
								const SvelteComponent = user_derived(() => COMPONENTS$1.get($$props.section.component));
								var fragment_2 = comment();
								var node_3 = first_child(fragment_2);

								component(node_3, () => get$3(SvelteComponent), ($$anchor, SvelteComponent_1) => {
									SvelteComponent_1($$anchor, spread_props(
										{
											get id() {
												return $$props.section.id;
											}
										},
										() => $$props.section.props
									));
								});

								append($$anchor, fragment_2);
							};

							var alternate = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[$$props.section.title]));
								append($$anchor, text$1);
							};

							if_block(node_2, ($$render) => {
								if ($$props.section.type === "component" && $$props.section.component && COMPONENTS$1.contains($$props.section.component)) $$render(consequent); else $$render(alternate, false);
							});
						}

						var node_4 = sibling(node_2, 2);

						{
							var consequent_1 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.tag
								));
							};

							if_block(node_4, ($$render) => {
								if ($$props.section.tag) $$render(consequent_1);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_2 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.indicator
								));
							};

							if_block(node_5, ($$render) => {
								if ($$props.section.indicator) $$render(consequent_2);
							});
						}

						reset(p);
						template_effect(() => set_class(p, 1, `menu-label ${$$props.section.classes ?? ''}`));
						append($$anchor, p);
					};

					if_block(node_1, ($$render) => {
						if (get$3(sectionItems).length || $$props.section.component || $$props.section.tag || $$props.section.indicator) $$render(consequent_3);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.section) $$render(consequent_4);
			});
		}

		var node_6 = sibling(node, 2);

		{
			var consequent_5 = ($$anchor) => {
				Ui_items_1($$anchor, {
					get root() {
						return root();
					},

					get items() {
						return get$3(sectionItems);
					},

					get onnavigate() {
						return onnavigate();
					}
				});
			};

			if_block(node_6, ($$render) => {
				if (get$3(sectionItems).length) $$render(consequent_5);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_side_menu($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [sections]
		 * @property {any} [navigate = ()=>undefined]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			sections = prop($$props, 'sections', 19, () => []),
			navigate = prop($$props, 'navigate', 3, null);

		function onClick(ev) {
			if (typeof navigate() === "function") {
				navigate()(ev);
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, sections, index$e, ($$anchor, section) => {
			Ui_section($$anchor, {
				get section() {
					return get$3(section);
				},

				get items() {
					return items();
				},

				get root() {
					return root();
				},

				onnavigate: onClick
			});
		});

		append($$anchor, fragment);
		pop();
	}

	var _notSideMenu;
	const TYPE = "side";
	let MENU_UI_PROPS = state(proxy({}));
	let notSideMenu = /*#__PURE__*/function (_Menu) {
	  function notSideMenu() {
	    _classCallCheck(this, notSideMenu);
	    return _callSuper(this, notSideMenu, arguments);
	  }
	  _inherits(notSideMenu, _Menu);
	  return _createClass(notSideMenu, null, [{
	    key: "initMenuUIProps",
	    value: function initMenuUIProps() {
	      set(MENU_UI_PROPS, {
	        items: this.items,
	        sections: this.sections,
	        root: this.getOptions().root,
	        navigate: this.getOptions().navigate
	      }, true);
	    }
	  }, {
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        this.initMenuUIProps();
	        this.createUI();
	      }
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.menu) {
	        unmount(this.menu);
	        this.createUI();
	      }
	    }
	  }, {
	    key: "createUI",
	    value: function createUI() {
	      let target = document.querySelector(this.getOptions().targetSelector);
	      if (!target) {
	        return;
	      }
	      this.menu = mount(Ui_side_menu, {
	        target,
	        props: get$3(MENU_UI_PROPS)
	      });
	      this.initSizeResponse();
	      this.interval = setInterval(this.updateMenuActiveItem.bind(this), this.INTERVAL_UPDATE_ACTIVE_ITEM);
	      this.bindToggle();
	    }
	  }, {
	    key: "itemIsActive",
	    value: function itemIsActive(itemURL) {
	      return (this.location + "/").indexOf(itemURL + "/") > -1;
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu() {
	      var _this = this;
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " a")).forEach(function (item) {
	        if (_this.itemIsActive(item.getAttribute("href"))) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu();
	        }
	      } else {
	        this.location = url;
	        this.updateMenu();
	      }
	    }
	  }, {
	    key: "initSizeResponse",
	    value: function initSizeResponse() {
	      this.nav = document.querySelector("nav.navbar");
	      this.aside = document.querySelector("aside");
	      this.main = document.querySelector("main");
	      this.resizeAsideAndMain(this.aside, this.main, this.nav);
	      this.resizeMain(this.main, this.aside);
	      window.addEventListener("resize", this.resizeMain.bind(this));
	      if (this.isTouch()) {
	        if (this.getOptions().open) {
	          this.show();
	        } else {
	          this.hide();
	        }
	      }
	    }
	  }, {
	    key: "resizeMain",
	    value: function resizeMain() {
	      if (this.isTouch()) {
	        if (this.aside.classList.contains("is-active")) {
	          this.main.style.display = "none";
	        } else {
	          this.main.style.display = "block";
	          this.main.style.marginLeft = "0px";
	        }
	      } else {
	        let rect = this.aside.getBoundingClientRect();
	        this.main.style.display = "block";
	        if (this.main.style.height === "0px") {
	          this.main.style.height = "auto";
	        }
	        this.main.style.marginLeft = rect.width + rect.left + "px";
	      }
	    }
	  }, {
	    key: "resizeAside",
	    value: function resizeAside() {
	      if (this.aside.style.display !== "none") {
	        let rect = this.nav.getBoundingClientRect();
	        this.aside.style.height = window.innerHeight - rect.height + "px";
	        this.aside.style.marginTop = rect.height + "px";
	      }
	    }
	  }, {
	    key: "resizeAsideAndMain",
	    value: function resizeAsideAndMain() {
	      let rect = this.nav.getBoundingClientRect();
	      this.aside.style.height = window.innerHeight - rect.height + "px";

	      //this.aside.style.paddingTop = (rect.height) + 'px';
	      //this.main.style.marginTop = (rect.height) + 'px';
	    }
	  }, {
	    key: "bindToggle",
	    value: function bindToggle() {
	      var _this2 = this;
	      let els = document.querySelectorAll(this.getOptions().toggleSelector);
	      Array.from(els).forEach(function (el) {
	        el.removeEventListener("click", _this2.toggle.bind(_this2));
	        el.addEventListener("click", _this2.toggle.bind(_this2));
	      });
	    }
	  }, {
	    key: "toggle",
	    value: function toggle(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.toggle("is-active");
	        } else {
	          this.aside.classList.toggle("is-closed");
	        }
	        this.resizeMain();
	      }
	      return false;
	    }
	  }, {
	    key: "hide",
	    value: function hide(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.remove("is-active");
	        } else {
	          this.aside.classList.add("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = false;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "show",
	    value: function show(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.add("is-active");
	        } else {
	          this.aside.classList.remove("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = true;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "isOpen",
	    value: function isOpen() {
	      if (this.aside) {
	        if (this.isTouch()) {
	          return this.aside.classList.contains("is-active");
	        } else {
	          return !this.aside.classList.contains("is-closed");
	        }
	      } else {
	        return true;
	      }
	    }
	  }]);
	}(Menu);
	_notSideMenu = notSideMenu;
	_defineProperty(notSideMenu, "nav", void 0);
	_defineProperty(notSideMenu, "main", void 0);
	_defineProperty(notSideMenu, "aside", void 0);
	_defineProperty(notSideMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  open: true,
	  type: "link"
	});
	_defineProperty(notSideMenu, "options", {
	  directNavigation: false,
	  type: TYPE,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE}-menu`,
	  toggleSelector: `.${TYPE}-menu-toggle`,
	  root: "/",
	  open: true,
	  navigate: function (urls) {
	    if (_notSideMenu.isTouch()) {
	      _notSideMenu.hide();
	      _notSideMenu.app && _notSideMenu.app.emit("top-navbar-burger:update", {
	        closed: true
	      });
	    }
	    if (!_notSideMenu.isDirectNavigation() && _notSideMenu.app) {
	      let func = _notSideMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	const DEFAULT_TRASFORMER = function (res) {
	  // @ts-ignore
	  return Object.hasOwn(res, "status") && Object.hasOwn(res, "result") ? res.result : res;
	};

	var create_crud_action_ui_view = (function ({
	  ACTION,
	  TITLE,
	  UIConstructor,
	  dataProvider,
	  goBack
	}) {
	  return /*#__PURE__*/function () {
	    function _class() {
	      _classCallCheck(this, _class);
	    }
	    return _createClass(_class, null, [{
	      key: "run",
	      value: async function run(controller, params) {
	        try {
	          controller.setBreadcrumbs([{
	            title: `Просмотр "${TITLE}"`
	          }]);
	          await controller.preloadVariants(ACTION);
	          if (controller.ui[ACTION]) {
	            return;
	          } else {
	            controller.$destroyUI();
	          }
	          let data = {};
	          if (dataProvider) {
	            if (notCommon$1.isFunc(dataProvider)) {
	              if (notCommon$1.isAsync(dataProvider)) {
	                data = await dataProvider(params);
	              } else {
	                data = dataProvider(params);
	              }
	            } else {
	              data = {
	                ...dataProvider
	              };
	            }
	          }
	          const resultTransformer = controller.getOptions(`${ACTION}.transformer`, DEFAULT_TRASFORMER);
	          controller.ui[ACTION] = new UIConstructor({
	            target: controller.getContainerInnerElement(),
	            props: {
	              params,
	              ...resultTransformer(data)
	            }
	          });
	          controller.emit(`after:render:${ACTION}`);
	          if (goBack && notCommon$1.isFunc(goBack)) {
	            controller.ui[ACTION].on("reject", function () {
	              return goBack();
	            });
	          }
	        } catch (e) {
	          controller.report(e);
	          controller.showErrorMessage(e);
	        }
	      }
	    }]);
	  }();
	});

	const PRELOADABLE = ["create", "update", "list", "delete", "details"];
	let CRUDVariantsPreloader = /*#__PURE__*/function () {
	  function CRUDVariantsPreloader() {
	    _classCallCheck(this, CRUDVariantsPreloader);
	  }
	  return _createClass(CRUDVariantsPreloader, null, [{
	    key: "preload",
	    value: async function preload(controller, type = "list") {
	      try {
	        if (!PRELOADABLE.includes(type)) {
	          return;
	        }
	        let preload = controller.getOptions(`${type}.preload`, {});
	        if (Object.keys(preload).length == 0) {
	          preload = controller.getOptions(`preload`, {});
	        }
	        if (Object.keys(preload).length > 0) {
	          let libProps = Object.keys(preload);
	          let proms = [];
	          libProps.forEach(function (prop) {
	            let modelName = notCommon$1.lowerFirstLetter(preload[prop]);
	            let Model = controller.make[modelName]({});
	            proms.push(Model.$listAll());
	          });
	          let results = await Promise.all(proms);
	          for (let i = 0; i < libProps.length; i++) {
	            const propName = libProps[i];
	            if (results[i].status === "ok" && Array.isArray(results[i].result)) {
	              const resultsList = results[i].result;
	              const variants = resultsList.map(function (item) {
	                return {
	                  id: item._id,
	                  title: item.title
	                };
	              });
	              controller.setOptions(`variants.${type}.${propName}`, variants);
	            }
	          }
	        }
	        controller.log("preload finished");
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const DEFAULT_ACTION = "list";
	let notCRUDRouter = /*#__PURE__*/function () {
	  function notCRUDRouter() {
	    _classCallCheck(this, notCRUDRouter);
	  }
	  return _createClass(notCRUDRouter, null, [{
	    key: "extractActionName",
	    value: function extractActionName(controller, params) {
	      let actionName = DEFAULT_ACTION;
	      if (params.length === 1) {
	        if (params[0] === "create") {
	          actionName = "create";
	        } else if (controller.actionHandlerExists(params[0])) {
	          actionName = params[0];
	        } else {
	          actionName = "details";
	        }
	      } else if (params.length > 1) {
	        if (params[1] === "delete") {
	          actionName = "delete";
	        } else if (params[1] === "update") {
	          actionName = "update";
	        } else {
	          actionName = params[1];
	        }
	      }
	      return actionName;
	    }
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = notCRUDRouter.extractActionName(controller, params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	let CRUDMessage = /*#__PURE__*/function () {
	  function CRUDMessage() {
	    _classCallCheck(this, CRUDMessage);
	  }
	  return _createClass(CRUDMessage, null, [{
	    key: "error",
	    value: function error(controller, title, message) {
	      controller.setUI("__message__", new Ui_error({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }, {
	    key: "success",
	    value: function success(controller, title, message) {
	      controller.setUI("__message__", new Ui_success({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }]);
	}();

	const DEFAULT_BREADCRUMB_TAIL$2 = "Просмотр";

	/**
	 * Generic CRUD action class
	 * @class
	 */
	let CRUDGenericAction = /*#__PURE__*/function () {
	  function CRUDGenericAction() {
	    _classCallCheck(this, CRUDGenericAction);
	  }
	  return _createClass(CRUDGenericAction, null, [{
	    key: "NAVIGATION_DELAY",
	    get: function () {
	      return NAVIGATION_DELAY_DEFAULT;
	    }
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	  }, {
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$2;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL$2,
	        set: 'Просмотр, "{:title}"'
	      };
	    }

	    /**
	     * Returns template of breadcrumbs tail
	     * @param   {string}    name
	     * @returns {string}    template string
	     */
	  }, {
	    key: "getBreadcrumbsTail",
	    value: function getBreadcrumbsTail(name) {
	      if (!this.breadcrumbsTails) {
	        return "";
	      }
	      return notCommon$1.select(this.breadcrumbsTails, name, this.deafultBreadcrumbsTail);
	    }
	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "details";
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {object} UIConstructor    constructor of UI component
	     */
	  }, {
	    key: "UIConstructor",
	    get: function () {
	      return notForm;
	    }
	    /**
	     * @static {function}   TRANSFORMER     response.result transformation function if want to change it's structure
	     */
	  }, {
	    key: "TRANSFORMER",
	    get: function () {
	      return DEFAULT_TRASFORMER;
	    }
	    /**
	     * Returns name of model identificaiton field
	     * @param {object} controller instance of controller
	     * @returns {string}    default id field name is '_id'
	     */
	  }, {
	    key: "getIdField",
	    value: function getIdField(controller) {
	      return controller.getOptions(`${this.ACTION}.idField`, "_id");
	    }
	  }, {
	    key: "loadDataQuery",
	    value: function loadDataQuery(controller, params) {
	      const idField = this.getIdField(controller);
	      return {
	        [idField]: params[0]
	      };
	    }

	    /**
	     * Return Promise of API reponse
	     * @param {object} controller instance of controller
	     * @param {string[]} params     array of strings parsed from URI by router and passed to controller
	     * @returns {Promise}   API response {status:string, result:any, message:string, errors: {[fieldname]:[...errorMessages]}}
	     */
	  }, {
	    key: "loadData",
	    value: async function loadData(controller, params) {
	      const query = this.loadDataQuery(controller, params);
	      const actionName = this.getModelActionName(controller);
	      return await controller.getModel(query)[`$${actionName}`]();
	    }

	    /**
	     * Returns model API action name
	     * @param {object} controller instance of controller
	     * @returns {string}    network interface model action name, for API; default: this.MODEL_ACTION_GET
	     */
	  }, {
	    key: "getModelActionName",
	    value: function getModelActionName(controller) {
	      return controller.getOptions(`${this.ACTION}.actionName`, this.MODEL_ACTION_GET);
	    }

	    /**
	     * Sets breadcrumbs tail, without result details
	     * @param {object} controller instance of controller
	     * @param {string[]} params     list of route params
	     */
	  }, {
	    key: "presetBreadcrumbs",
	    value: function presetBreadcrumbs(controller, params) {
	      controller.setBreadcrumbs([{
	        title: this.getBreadcrumbsTail("preset"),
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response.result);
	    }

	    /**
	     * Sets breadcrumbs tail with response details, aka title of loaded item
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response in wrapper
	     * @param {object} response.result  API response result
	     */
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(controller, params, response) {
	      const title = this.getTitle(controller, params, response);
	      const breadcrumbsTailTemplate = this.getBreadcrumbsTail("set");
	      controller.setBreadcrumbs([{
	        title: breadcrumbsTailTemplate ? notLocale$1.format(breadcrumbsTailTemplate, {
	          title
	        }) : title,
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }

	    /**
	     * Checks response on success
	     * @param {object} response
	     * @param {string} response.status
	     * @returns {boolean}   true if response is bad
	     */
	  }, {
	    key: "isResponseBad",
	    value: function isResponseBad(response) {
	      return !response || response.status !== "ok";
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators(controller) {
	      return controller.getValidators && controller.getValidators() || controller.getOptions("Validators");
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const detailsActionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: detailsActionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          fields: {
	            readonly: true
	          },
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	          injected: controller.getOptions(`${this.ACTION}.injected`, {})
	        },
	        data: this.TRANSFORMER(response.result)
	      };
	    }

	    /**
	     * Returns instance of this action UI component from controller
	     * @param {object} controller   instance of controller
	     * @returns {object}    instance of UI component
	     */
	  }, {
	    key: "getUI",
	    value: function getUI(controller) {
	      return controller.getUI(this.ACTION);
	    }

	    /**
	     * Sets UI of this action in controller
	     * @param {object} controller   instance of controller
	     * @param {object} ui           instance of UI component
	     */
	  }, {
	    key: "setUI",
	    value: function setUI(controller, ui) {
	      controller.setUI(this.ACTION, ui);
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `true`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoading",
	    value: function setUILoading(controller) {
	      this.getUI(controller).$set({
	        loading: true
	      });
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `false`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoaded",
	    value: function setUILoaded(controller) {
	      this.getUI(controller).$set({
	        loading: false
	      });
	    }

	    /**
	     *  Sets via `.$set` method `error` to `message`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @param   {Error} message     error message
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUIError",
	    value: function setUIError(controller, message) {
	      this.getUI(controller).$set({
	        error: message
	      });
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return controller.goBack();
	        });
	      }
	    }

	    /**
	     * Bind event handler named event to UI. Checks different binder notation $on/on
	     * @param {object} controller   instance of controller
	     * @param {string} event        event name
	     * @param {function} callback   callback function on event
	     * @returns
	     */
	  }, {
	    key: "bindUIEvent",
	    value: function bindUIEvent(controller, event, callback) {
	      const ui = this.getUI(controller);
	      if (ui.$on) {
	        return ui.$on(event, callback);
	      }
	      if (ui.on) {
	        return ui.on(event, callback);
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }
	  }, {
	    key: "createUI",
	    value: function createUI(uiComponent, controller, response) {
	      if (notCommon$1.isFunc(uiComponent)) {
	        return mount(uiComponent, this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      } else {
	        return new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      }
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        //eslint-disable-next-line no-unused-vars
	        const uiComponent = this.UIConstructor;
	        //eslint-disable-next-line no-unused-vars
	        const ui = this.createUI();
	        this.setUI(controller);
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "goBackAfterDelay",
	    value: function goBackAfterDelay(controller) {
	      controller.goBack(this.NAVIGATION_DELAY);
	    }
	  }, {
	    key: "goBack",
	    value: function goBack(controller) {
	      controller.goBack(0);
	    }
	  }]);
	}();

	const ACTION$2 = "create";
	const DEFAULT_BREADCRUMB_TAIL$1 = "Создание";
	let CRUDGenericActionCreate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionCreate() {
	    _classCallCheck(this, CRUDGenericActionCreate);
	    return _callSuper(this, CRUDGenericActionCreate, arguments);
	  }
	  _inherits(CRUDGenericActionCreate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionCreate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$1;
	    }
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return undefined;
	    }
	  }, {
	    key: "ACTION",
	    get: function () {
	      return ACTION$2;
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     *
	     * @param {import('../../controller.crud')} controller
	     * @param {any}                         [params]
	     * @returns {import('not-node/src/types').notAppResponse}
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "loadData",
	    value: function loadData(controller, params = {}) {
	      let defData = controller.createDefault();
	      if (defData.getData) {
	        defData = defData.getData();
	      }
	      return {
	        status: "ok",
	        result: defData
	      };
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response);
	    }
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const actionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: actionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(response)
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	let CRUDActionCreate = /*#__PURE__*/function (_CRUDGenericActionCre) {
	  function CRUDActionCreate() {
	    _classCallCheck(this, CRUDActionCreate);
	    return _callSuper(this, CRUDActionCreate, arguments);
	  }
	  _inherits(CRUDActionCreate, _CRUDGenericActionCre);
	  return _createClass(CRUDActionCreate);
	}(CRUDGenericActionCreate);

	/**
	 * Generic CRUD Details action class
	 * @class
	 */
	let CRUDGenericActionRead = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionRead() {
	    _classCallCheck(this, CRUDGenericActionRead);
	    return _callSuper(this, CRUDGenericActionRead, arguments);
	  }
	  _inherits(CRUDGenericActionRead, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionRead, null, [{
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      options.options.ui = {
	        submit: {
	          enabled: false
	        }
	      };
	      return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action details
	 */
	let CRUDActionDetails = /*#__PURE__*/function (_CRUDGenericActionRea) {
	  function CRUDActionDetails() {
	    _classCallCheck(this, CRUDActionDetails);
	    return _callSuper(this, CRUDActionDetails, arguments);
	  }
	  _inherits(CRUDActionDetails, _CRUDGenericActionRea);
	  return _createClass(CRUDActionDetails);
	}(CRUDGenericActionRead);

	const DEFAULT_BREADCRUMB_TAIL = "Редактирование";
	/**
	 * Generic CRUD Update action class
	 * @class
	 */
	let CRUDGenericActionUpdate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionUpdate() {
	    _classCallCheck(this, CRUDGenericActionUpdate);
	    return _callSuper(this, CRUDGenericActionUpdate, arguments);
	  }
	  _inherits(CRUDGenericActionUpdate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionUpdate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get:
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    function () {
	      return DEFAULT_BREADCRUMB_TAIL;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL,
	        set: `${DEFAULT_BREADCRUMB_TAIL}: "{:title}"`
	      };
	    }

	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "update";
	    }

	    /**
	     * @static {string} MODEL_ACTION_GET    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "getRaw";
	    }

	    /**
	     * @static {string} MODEL_ACTION_PUT    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "update";
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: this.MODEL_ACTION_PUT,
	          //will be used to get form fields information from manifest
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          ui: controller.getOptions(`${this.ACTION}.ui`, {}),
	          fields: controller.getOptions(`${this.ACTION}.fields`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(notCommon$1.stripProxy(response.result))
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, [params]);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action update
	 */
	let CRUDActionUpdate = /*#__PURE__*/function (_CRUDGenericActionUpd) {
	  function CRUDActionUpdate() {
	    _classCallCheck(this, CRUDActionUpdate);
	    return _callSuper(this, CRUDActionUpdate, arguments);
	  }
	  _inherits(CRUDActionUpdate, _CRUDGenericActionUpd);
	  return _createClass(CRUDActionUpdate);
	}(CRUDGenericActionUpdate);

	const ACTION$1 = "delete";
	const MODEL_ACTION = "delete";
	let CRUDActionDelete = /*#__PURE__*/function () {
	  function CRUDActionDelete() {
	    _classCallCheck(this, CRUDActionDelete);
	  }
	  return _createClass(CRUDActionDelete, null, [{
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        if (controller.ui[ACTION$1]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION$1] = new notActionUI({
	          name: "CRUDDelete",
	          target: controller.getContainerInnerElement(),
	          options: {
	            loaderActive: true,
	            loaderStyle: "container",
	            loaderTitle: "not-node:crud_delete_action_waiting",
	            container: {
	              id: `crud-delete-action-${params[0]}`
	            }
	          }
	        });
	        controller.setBreadcrumbs([{
	          title: "Удаление",
	          url: controller.getModelActionURL(params[0], ACTION$1)
	        }]);
	        if (confirm("Удалить запись?")) {
	          const deleteActionName = controller.getOptions(`${ACTION$1}.actionName`, MODEL_ACTION);
	          const success = await controller.onActionSubmit(deleteActionName, {
	            _id: params[0]
	          });
	          if (success) {
	            controller.goList();
	          }
	          return;
	        }
	        controller.goList();
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const ACTION = "list";
	let CRUDActionList = /*#__PURE__*/function () {
	  function CRUDActionList() {
	    _classCallCheck(this, CRUDActionList);
	  }
	  return _createClass(CRUDActionList, null, [{
	    key: "tweakActionsList",
	    value: function tweakActionsList(controller, ACTIONS_LIST) {
	      if (controller.getOptions(`${ACTION}.createAction`, true)) {
	        ACTIONS_LIST.push({
	          title: "Создать",
	          action: function () {
	            return controller.goCreate();
	          }
	        });
	      }
	      return ACTIONS_LIST;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../controller.crud').default} controller
	     * @param {string} value
	     * @param {number} [delay=0]
	     * @param {Array<string>} [actions=["details", "update", "delete"]]
	     * @param {Array<object>} [prepend=[]]
	     * @param {Array<object>} [append=[]]
	     * @param {boolean} [onlyIcons=true]
	     * @return {Array<object>}
	     * @memberof CRUDActionList
	     */
	  }, {
	    key: "createActionsButtons",
	    value: function createActionsButtons(controller, value, delay = 0, actions = ["details", "update", "delete"], prepend = [], append = [], onlyIcons = true) {
	      const ACTIONS = {
	        details: {
	          action: function () {
	            return controller.goDetails(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "circle-info"
	          } : {
	            title: "Подробнее"
	          }),
	          size: "small"
	        },
	        update: {
	          action: function () {
	            return controller.goUpdate(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "edit"
	          } : {
	            title: "Изменить"
	          }),
	          color: "warning",
	          size: "small"
	        },
	        delete: {
	          action: function () {
	            return controller.goDelete(value, delay);
	          },
	          color: "danger",
	          ...(onlyIcons ? {
	            icon: "trash"
	          } : {
	            title: "Удалить"
	          }),
	          size: "small",
	          style: "outlined"
	        }
	      };
	      const actionsButtons = [...prepend];
	      if (Array.isArray(actions)) {
	        actions.forEach(function (actionName) {
	          return actionsButtons.push(ACTIONS[actionName]);
	        });
	      }
	      actionsButtons.push(...append);
	      return actionsButtons;
	    }
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        await controller.preloadVariants(ACTION);
	        controller.setBreadcrumbs([{
	          title: "Список",
	          url: controller.getModelURL()
	        }]);
	        if (controller.ui[ACTION]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION] = new notTable(this.tweakUIOptions(CRUDActionList.prepareOptions(controller)));
	        controller.emit(`after:render:${ACTION}`, params, controller.ui[ACTION]);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${ACTION}`, params, e);
	        controller.report(e);
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "prepareOptions",
	    value: function prepareOptions(controller) {
	      const DEFAULT_OPTIONS_TABLE = {
	        interface: controller.getOptions(`${ACTION}.interface`, {
	          combined: true,
	          factory: controller.getInterface()
	        }),
	        fields: undefined,
	        showSelect: undefined,
	        getItemId: undefined,
	        idField: undefined,
	        preload: {},
	        filterUI: controller.getOptions(`${ACTION}.filterUI`),
	        pager: {
	          size: 50,
	          page: 0
	        },
	        sorter: {
	          id: -1
	        },
	        filter: undefined,
	        ui: undefined
	      };
	      //forming actions buttons list
	      let ACTIONS_LIST = [...controller.getOptions(`${ACTION}.actions`, [])];
	      ACTIONS_LIST = this.tweakActionsList(controller, ACTIONS_LIST);
	      //
	      const TABLE_OPTIONS = {
	        options: {
	          targetEl: controller.getContainerInnerElement(),
	          endless: false,
	          actions: ACTIONS_LIST
	        }
	      };
	      Object.keys(DEFAULT_OPTIONS_TABLE).forEach(function (key) {
	        let optVal = controller.getOptions(`${ACTION}.${key}`, DEFAULT_OPTIONS_TABLE[key]);
	        if (typeof optVal !== "undefined") {
	          TABLE_OPTIONS.options[key] = optVal;
	        }
	      });
	      return TABLE_OPTIONS;
	    }
	  }]);
	}();

	var CRUDActions = {
	  create: CRUDActionCreate,
	  details: CRUDActionDetails,
	  update: CRUDActionUpdate,
	  delete: CRUDActionDelete,
	  list: CRUDActionList
	};

	const BREADCRUMBS = [];
	const TITLE_FIELDS_PRIORITY = ["title", "label", "id", "name"];
	const LOADING_SCREEN_UI_NAME = "loading_screen";
	var _actions = /*#__PURE__*/new WeakMap();
	var _router = /*#__PURE__*/new WeakMap();
	var _preloader = /*#__PURE__*/new WeakMap();
	let notCRUD = /*#__PURE__*/function (_notController) {
	  function notCRUD(app, name, {
	    actions,
	    router,
	    preloader
	  } = {
	    actions: undefined,
	    router: undefined,
	    preloader: undefined
	  }) {
	    var _this;
	    _classCallCheck(this, notCRUD);
	    _this = _callSuper(this, notCRUD, [app, `CRUD.${name}`]);
	    _classPrivateFieldInitSpec(_this, _actions, {
	      ...CRUDActions
	    });
	    _classPrivateFieldInitSpec(_this, _router, notCRUDRouter);
	    _classPrivateFieldInitSpec(_this, _preloader, CRUDVariantsPreloader);
	    _defineProperty(_this, "TITLE_FIELDS_PRIORITY", TITLE_FIELDS_PRIORITY);
	    _defineProperty(_this, "TOP_CLASS", ["box"]);
	    _defineProperty(_this, "MAIN_CLASS", ["box"]);
	    _defineProperty(_this, "BOTTOM_CLASS", ["box"]);
	    _defineProperty(_this, "WS_CHECK_INTERVAL", 200);
	    if (actions) {
	      // @ts-ignore
	      _classPrivateFieldSet2(_actions, _this, {
	        ..._classPrivateFieldGet2(_actions, _this),
	        ...actions
	      });
	    }
	    if (router) {
	      _classPrivateFieldSet2(_router, _this, router);
	    }
	    if (preloader) {
	      _classPrivateFieldSet2(_preloader, _this, preloader);
	    }
	    _this.ui = {};
	    _this.els = {};
	    _this.setOptions("names", {
	      module: "",
	      plural: "plural",
	      single: "single"
	    });
	    _this.setOptions("containerSelector", _this.app?.getOptions("crud.containerSelector"));
	    _this.buildFrame();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notCRUD, _notController);
	  return _createClass(notCRUD, [{
	    key: "setValidators",
	    value: function setValidators(validators) {
	      //not-module-name -> [not,module,name]
	      const ModuleNameParts = this.getModuleName().split("-");
	      //[not,module,name] -> ModuleName
	      const ModuleName = (ModuleNameParts[0] === "not" ? ModuleNameParts.splice(1) : ModuleNameParts).map(notCommon$1.capitalizeFirstLetter).join("");
	      const serviceName = `ns${ModuleName}Common`;
	      const CommonModuleService = this.app?.getService(serviceName);
	      this.setWorking("validators", CommonModuleService.augmentValidators(validators));
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators() {
	      return this.getWorking("validators");
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      var _this2 = this;
	      let newHead = [];
	      if (this.getModuleName() && this.getOptions("names.module")) {
	        newHead.push({
	          title: this.getOptions("names.module"),
	          url: false
	        });
	      }
	      newHead.push({
	        title: this.getOptions("names.plural"),
	        url: this.getModelURL()
	      });
	      BREADCRUMBS.splice(0, BREADCRUMBS.length, ...newHead);
	      notBreadcrumbs.setHead(BREADCRUMBS).render({
	        root: "",
	        target: this.els.top,
	        navigate: function (url) {
	          return _this2.app?.getWorking("router").navigate(url);
	        }
	      });
	      this.route(this.getOptions("params"));
	    }
	  }, {
	    key: "startWhenWSClientReady",
	    value: function startWhenWSClientReady() {
	      var _this3 = this;
	      if (this.app?.getWSClient()) {
	        if (this.app?.getWSClient().isConnected()) {
	          this.start();
	        } else {
	          this.app.getWSClient().once("connected", this.startWhenWSClientReady.bind(this));
	        }
	      } else {
	        setTimeout(function () {
	          return _this3.startWhenWSClientReady();
	        }, this.WS_CHECK_INTERVAL);
	      }
	    }
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(tail) {
	      notBreadcrumbs.setTail(tail).update();
	    }
	  }, {
	    key: "backToList",
	    value: function backToList() {
	      this.navigate(this.linkBackToList());
	    }
	  }, {
	    key: "linkBackToList",
	    value: function linkBackToList() {
	      return this.getModelURL();
	    }
	  }, {
	    key: "afterAction",
	    value: function afterAction(action = "list") {
	      let navBack = this.app?.getOptions("crud.navigateBackAfter", []);
	      if (navBack && Array.isArray(navBack) && navBack.indexOf(action) > -1) {
	        window.history.back();
	      } else {
	        this.backToList();
	      }
	    }
	  }, {
	    key: "buildFrame",
	    value: function buildFrame() {
	      var _this4 = this;
	      let el = document.querySelector(this.app?.getOptions("crud.containerSelector", "body"));
	      while (el.firstChild) {
	        el.removeChild(el.firstChild);
	      }
	      this.els.top = document.createElement("div");
	      this.els.top.id = "crud-top";
	      this.getFrameClasses().TOP_CLASS.forEach(function (name) {
	        return _this4.els.top.classList.add(name);
	      });
	      el.appendChild(this.els.top);
	      this.els.main = document.createElement("div");
	      this.els.main.id = "crud-main";
	      this.getFrameClasses().MAIN_CLASS.forEach(function (name) {
	        return _this4.els.main.classList.add(name);
	      });
	      el.appendChild(this.els.main);
	      this.els.bottom = document.createElement("div");
	      this.els.bottom.id = "crud-bottom";
	      this.getFrameClasses().BOTTOM_CLASS.forEach(function (name) {
	        return _this4.els.bottom.classList.add(name);
	      });
	      el.appendChild(this.els.bottom);
	    }
	  }, {
	    key: "getFrameClasses",
	    value: function getFrameClasses() {
	      return {
	        TOP_CLASS: this.TOP_CLASS,
	        MAIN_CLASS: this.MAIN_CLASS,
	        BOTTOM_CLASS: this.BOTTOM_CLASS
	      };
	    }
	  }, {
	    key: "getContainerTopElement",
	    value: function getContainerTopElement() {
	      return this.els.top;
	    }
	  }, {
	    key: "getContainerInnerElement",
	    value: function getContainerInnerElement() {
	      return this.els.main;
	    }
	  }, {
	    key: "getContainerBottomElement",
	    value: function getContainerBottomElement() {
	      return this.els.bottom;
	    }
	  }, {
	    key: "preloadVariants",
	    value: async function preloadVariants(type = "list") {
	      await _classPrivateFieldGet2(_preloader, this).preload(this, type);
	    }
	  }, {
	    key: "getTitleFromLib",
	    value: function getTitleFromLib(propName, id) {
	      const actionName = this.getCurrentAction();
	      this.debug && this.debug("notCRUD.getTitleFromLib is obsolete, use notCRUD.getPreloadedVariantTitle(actionName, propName, id)");
	      return this.getPreloadedVariantTitle(actionName, propName, id);
	    }
	  }, {
	    key: "getPreloadedVariants",
	    value: function getPreloadedVariants(actionName, propName) {
	      return this.getOptions(`variants.${actionName}.${propName}`, []);
	    }
	  }, {
	    key: "getPreloadedVariantTitle",
	    value: function getPreloadedVariantTitle(actionName, propName, id) {
	      const variants = this.getPreloadedVariants(actionName, propName);
	      const item = variants.find(function (item) {
	        return item.id === id;
	      });
	      if (item) {
	        return item.title;
	      } else {
	        return id;
	      }
	    }
	  }, {
	    key: "getItemTitle",
	    value: function getItemTitle(item) {
	      const fieldName = this.TITLE_FIELDS_PRIORITY.find(function (key) {
	        return notCommon$1.objHas(item, key);
	      });
	      if (fieldName) {
	        return item[fieldName];
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "createDefault",
	    value: function createDefault() {
	      return this.getModel({}).toDefault();
	    }
	  }, {
	    key: "route",
	    value: function route(params = []) {
	      try {
	        return _classPrivateFieldGet2(_router, this).route(this, params);
	      } catch (e) {
	        this.report(e);
	        this.showErrorMessage(e);
	      }
	    }
	  }, {
	    key: "actionHandlerExists",
	    value: function actionHandlerExists(actionName) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return true;
	      }
	      if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "runAction",
	    value: function runAction(actionName, params) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return _classPrivateFieldGet2(_actions, this)[actionName].run(this, params);
	      } else if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return this["run" + notCommon$1.capitalizeFirstLetter(actionName)](params);
	      } else {
	        throw new Error(`No such action: ${actionName} in contoller ${this.getWorking("name")}`);
	      }
	    }

	    /**
	     *  Changes location to create page, after delay
	     *  @param {number|string} [delay=0] number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goCreate",
	    value: function goCreate(delay = 0) {
	      this.goAfterDelay(this.getModelActionURL("", "create"), delay);
	    }

	    /**
	     *  Changes location to document details page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDetails",
	    value: function goDetails(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, ""), delay);
	    }

	    /**
	     * Changes location to document update page, after delay
	     * @param {string}          id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goUpdate",
	    value: function goUpdate(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "update"), delay);
	    }

	    /**
	     *  Changes location to document delete page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDelete",
	    value: function goDelete(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "delete"), delay);
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goList",
	    value: function goList(delay = 0) {
	      this.goAfterDelay(this.getModelURL(), delay);
	    }

	    /**
	     *
	     * @param {string} url
	     * @param {number|string} delay
	     */
	  }, {
	    key: "goAfterDelay",
	    value: function goAfterDelay(url, delay = 0) {
	      var _this5 = this;
	      this.navigateWithDelay(url, delay, function () {
	        return _this5.$destroyUI();
	      });
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goBack",
	    value: function goBack(delay = 0) {
	      this.goList(delay);
	    }
	  }, {
	    key: "onActionSubmit",
	    value: async function onActionSubmit(action, item) {
	      let state = true;
	      const actionUI = this.ui[action];
	      if (actionUI) {
	        try {
	          actionUI.setLoading();
	          let result = await this.getModel(item)[`$${action}`]();
	          state = actionUI.processResult(result);
	        } catch (e) {
	          state = actionUI.processResult(e);
	        } finally {
	          actionUI.resetLoading();
	          // eslint-disable-next-line no-unsafe-finally
	          return state;
	        }
	      } else {
	        throw new Error("Action UI doesnt exist");
	      }
	    }
	  }, {
	    key: "$destroyUI",
	    value: function $destroyUI() {
	      for (let name in this.ui) {
	        this.destroyUIByName(name);
	      }
	    }
	  }, {
	    key: "destroyUIByName",
	    value: function destroyUIByName(name) {
	      // @ts-ignore
	      if (Object.hasOwn(this.ui, name)) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        this.ui[name].destroy && this.ui[name].destroy();
	        delete this.ui[name];
	      }
	    }
	  }, {
	    key: "showErrorMessage",
	    value: function showErrorMessage(res) {
	      this.error && this.error(res);
	      this.app && this.app.emit("error", {
	        title: "Произошла ошибка",
	        message: res.message ? res.message : UICommon$1.ERROR_DEFAULT
	      });
	      CRUDMessage.error(this, "Произошла ошибка", res.message ? res.message : UICommon$1.ERROR_DEFAULT);
	    }
	  }, {
	    key: "showSuccessMessage",
	    value: function showSuccessMessage(title, message) {
	      this.app && this.app.emit("success", {
	        title,
	        message
	      });
	      CRUDMessage.success(this, title, message);
	    }
	  }, {
	    key: "setUI",
	    value: function setUI(name, val, singleUI = true) {
	      if (singleUI) {
	        this.$destroyUI();
	      }
	      this.ui[name] = val;
	    }
	  }, {
	    key: "getUI",
	    value: function getUI(name) {
	      return this.ui[name];
	    }
	  }, {
	    key: "getActionUI",
	    value: function getActionUI() {
	      return this.ui[this.getCurrentAction()];
	    }
	  }, {
	    key: "renderLoadingScreen",
	    value: function renderLoadingScreen() {
	      this.setUI(LOADING_SCREEN_UI_NAME, this.createLoaderUI());
	    }
	  }, {
	    key: "removeLoadingScreen",
	    value: function removeLoadingScreen() {
	      this.destroyUIByName(LOADING_SCREEN_UI_NAME);
	    }
	  }, {
	    key: "createLoaderUI",
	    value: function createLoaderUI() {
	      return mount(Ui_loader, {
	        target: this.getContainerInnerElement(),
	        props: {
	          loading: true,
	          title: ""
	        }
	      });
	    }
	  }], [{
	    key: "LABELS",
	    get: function () {
	      return Object.freeze({
	        plural: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_plural`,
	        single: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_single`
	      });
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu(itemCustomProps = {}) {
	      return [{
	        section: this.MODULE_NAME,
	        title: this.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(this.MODULE_NAME)}/${notCommon$1.lowerFirstLetter(this.MODEL_NAME)}`,
	        ...itemCustomProps
	      }];
	    }
	  }]);
	}(notController);
	_defineProperty(notCRUD, "ERROR_DEFAULT", UICommon$1.ERROR_DEFAULT);

	const ROUTE_LIST = "list";
	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDPlainRouter = /*#__PURE__*/function () {
	  function notCRUDPlainRouter() {
	    _classCallCheck(this, notCRUDPlainRouter);
	  }
	  return _createClass(notCRUDPlainRouter, null, [{
	    key: "extractActionName",
	    value:
	    /**
	     * Returns first item from params or throws Error
	     * @param {string[]} params array of strings parsed from URI by route rules
	     * @returns {string}
	     */
	    function extractActionName(params) {
	      if (params.length > 0) {
	        return params[0];
	      }
	      return this.DEFAULT_ROUTE;
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = this.extractActionName(params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();
	_defineProperty(notCRUDPlainRouter, "DEFAULT_ROUTE", ROUTE_LIST);

	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDRouterSwitch = /*#__PURE__*/function () {
	  function notCRUDRouterSwitch() {
	    _classCallCheck(this, notCRUDRouterSwitch);
	  }
	  return _createClass(notCRUDRouterSwitch, null, [{
	    key: "routesVariants",
	    get:
	    /**
	     * Variants of this action
	     */
	    function () {
	      return {
	        /**
	        routeName: Action
	         */
	      };
	    }

	    /**
	     * Returns true if variant name is valid
	     * @param {string} name    name of route variant
	     * @returns {boolean}
	     */
	  }, {
	    key: "isRouteVariantValid",
	    value: function isRouteVariantValid(name) {
	      return name !== "" && notCommon$1.objHas(this.routesVariants, name);
	    }

	    /**
	     * This function returns which of routes variant should be executed
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]}    params  params passed to router
	     * @returns {Promise<string>}    name of route variant
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "determineRoute",
	    value: async function determineRoute(controller, params = []) {
	      return "";
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: async function route(controller, params) {
	      try {
	        const actionName = await this.determineRoute(controller, params);
	        if (this.isRouteVariantValid(actionName)) {
	          controller.setCurrentAction(actionName);
	          const routerAction = this.routesVariants[actionName];
	          if (notCommon$1.isAsync(routerAction.run)) {
	            await routerAction.run(controller, params);
	          } else {
	            routerAction.run(controller, params);
	          }
	        } else {
	          throw new Error(`No such action: ${actionName} in contoller ${controller.getWorking("name")}`);
	        }
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const emptyResult = function () {
	  return {
	    list: [],
	    count: 0,
	    page: 0,
	    pages: 0,
	    skip: 0
	  };
	};
	let notServiceModelSearch = /*#__PURE__*/function () {
	  function notServiceModelSearch(app, modelName) {
	    _classCallCheck(this, notServiceModelSearch);
	    this.modelName = modelName;
	    this.app = app;
	  }
	  return _createClass(notServiceModelSearch, [{
	    key: "destroy",
	    value: function destroy() {
	      delete this.app;
	    }
	  }, {
	    key: "getSearchRouteName",
	    value: function getSearchRouteName() {
	      return "listAndCount";
	    }
	  }, {
	    key: "getDataLoadRouteName",
	    value: function getDataLoadRouteName() {
	      return "get";
	    }
	  }, {
	    key: "transformSearchResult",
	    value: function transformSearchResult(result) {
	      var _this = this;
	      result.list = result.list.map(function (item) {
	        return {
	          _id: item._id,
	          id: item[`${_this.modelName}ID`],
	          title: item.name || item.title || item.label || item.username
	        };
	      });
	      return result;
	    }
	  }, {
	    key: "transformSelectedResult",
	    value: function transformSelectedResult(result) {
	      return {
	        _id: result._id,
	        [`${this.modelName}ID`]: result.id,
	        title: result.title
	      };
	    }
	  }, {
	    key: "searchByTerm",
	    value: async function searchByTerm(term) {
	      try {
	        if (term.value.length > 2) {
	          const model = this.app.getModel(this.modelName);
	          model.setSearch(term.value);
	          const response = await model[`$${this.getSearchRouteName()}`]();
	          if (response.status === "ok") {
	            return this.transformSearchResult(response.result);
	          } else {
	            return emptyResult();
	          }
	        } else {
	          return emptyResult();
	        }
	      } catch {
	        return emptyResult();
	      }
	    }
	  }, {
	    key: "openSelector",
	    value: function openSelector() {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        try {
	          const el = mount(Ui_generic_selector, {
	            target: document.body,
	            props: {}
	          });
	          el.$on("termChange", async function ({
	            detail
	          }) {
	            const results = await _this2.searchByTerm(detail);
	            el.$set({
	              results
	            });
	          });
	          el.$on("next", function () {
	            console.log("next selector results");
	          });
	          el.$on("prev", function () {
	            console.log("prev selector results");
	          });
	          el.$on("reject", function () {
	            unmount(el);
	            reject();
	          });
	          el.$on("resolve", function ({
	            detail
	          }) {
	            unmount(el);
	            resolve(_this2.transformSelectedResult(detail));
	          });
	        } catch (e) {
	          _this2.app.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "loadData",
	    value: async function loadData(_id) {
	      try {
	        if (_id && _id.length > 10) {
	          const model = this.app.getModel(this.modelName, {
	            _id
	          });
	          const response = await model[`$${this.getDataLoadRouteName()}`]();
	          if (response.status === "ok") {
	            return response.result;
	          } else {
	            return null;
	          }
	        } else {
	          return null;
	        }
	      } catch (e) {
	        this.app.error(e);
	        return null;
	      }
	    }
	  }]);
	}();

	//import 'babel-polyfill/dist/polyfill';

	const ncCRUD = notCRUD; //legacy alias

	var Frame = /*#__PURE__*/Object.freeze({
		__proto__: null,
		COMPONENTS: COMPONENTS$1,
		FIELDS: FIELDS$1,
		UIForm: Form,
		VARIANTS: VARIANTS$1,
		createCRUDActionUIView: create_crud_action_ui_view,
		ncCRUD: ncCRUD,
		notAPI: index,
		notApp: notApp,
		notBase: notBase,
		notBreadcrumbs: notBreadcrumbs,
		notCRUD: notCRUD,
		notCRUDRouter: notCRUDRouter,
		notCRUDRouterPlain: notCRUDPlainRouter,
		notCRUDRouterSwitch: notCRUDRouterSwitch,
		notCommon: notCommon$1,
		notController: notController,
		notForm: notForm,
		notFormHelpers: FormHelpers,
		notFormRules: notFormRules,
		notFormSet: notFormSet,
		notFormUtils: notFormUtils$1,
		notInterface: notInterface,
		notPath: notPath,
		notRecord: notRecord,
		notRouter: notRouter$1,
		notServiceModelSearch: notServiceModelSearch,
		notSideMenu: notSideMenu,
		notStores: stores,
		notTable: notTable,
		notTopMenu: notTopMenu
	});

	const Locale = {
	  LOCALE,
	  say,
	  notLocale: notLocale$1
	};
	const UICommon = UICommon$1;
	const {
	  notCommon,
	  COMPONENTS,
	  FIELDS,
	  VARIANTS,
	  notFormUtils
	} = Frame;
	Object.keys(Elements).forEach(function (componentsSetName) {
	  Object.keys(Elements[componentsSetName]).forEach(function (componentName) {
	    notFormUtils$1.addComponent(componentName, Elements[componentsSetName][componentName]);
	  });
	});

	exports.COMPONENTS = COMPONENTS;
	exports.Elements = Elements;
	exports.FIELDS = FIELDS;
	exports.Frame = Frame;
	exports.LOCALE = LOCALE;
	exports.Locale = Locale;
	exports.UICommon = UICommon;
	exports.VARIANTS = VARIANTS;
	exports.notCommon = notCommon;
	exports.notFormUtils = notFormUtils;
	exports.notLocale = notLocale$1;
	exports.say = say;
	exports.svelte = indexClient;

	return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90QnVsbWEuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9lc20tZW52L3RydWUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2hhcmVkL2Vycm9ycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2h5ZHJhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VxdWFsaXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvY2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L3RyYWNpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vdGFzay5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9lcnJvci1oYW5kbGluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2JhdGNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcmVhY3Rpdml0eS9jcmVhdGUtc3Vic2NyaWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYXN5bmMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3NvdXJjZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcHJveHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2VxdWFsaXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9vcGVyYXRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9taXNjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvZXZlbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9yZWNvbmNpbGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS90ZW1wbGF0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZW5kZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9icmFuY2hlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2lmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvZWFjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2h0bWwuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbG90LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc25pcHBldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zdmVsdGUtZWxlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYXR0YWNobWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2hhcmVkL2F0dHJpYnV0ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2NsYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9zdHlsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3Mvc2VsZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9hdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3RpbWluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9sb29wLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy90cmFuc2l0aW9ucy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvaW5wdXQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3Byb3BzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy90aGlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvZXZlbnQtbW9kaWZpZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbGlmZWN5Y2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbWlzYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3N0b3JlL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc3RvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9wcm9wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2luZGV4LWNsaWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2NvbW1vbi5qcyIsIi4uL3NyYy9lbGVtZW50cy9ibG9jay91aS5ibG9jay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuYmxvY2suaW5uZXIudmVydGljYWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Jsb2NrL3VpLmJveC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuY29udGVudC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuY2xpY2thYmxlLmRpdi5zdmVsdGUiLCIuLi9zcmMvbG9jYWxlL3N0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dvbGZ5ODctZXZlbnRlbWl0dGVyL0V2ZW50RW1pdHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtcGF0aC9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXBhdGgvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tbW9uLmpzIiwiLi4vc3JjL2xvY2FsZS9ub3RMb2NhbGUuanMiLCIuLi9zcmMvbG9jYWxlL2luZGV4LmpzIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuYm9vbGVhbi5sYWJlbGVkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW5zLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmNlbnNvcmVkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5sb2FkZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5jbG9zZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnJvdy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5zd2l0Y2guc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN3aXRjaGVycy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuZmllbGQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmNvbnRyb2wuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuc2VsZWN0LmZyb20ubW9kZWwub24uZGVtYW5kLmlubGluZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zZWxlY3QuZnJvbS5tb2RlbC53aXRoLnNlYXJjaC5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5wcm9ncmVzcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zaG93Lm9uZS5mcm9tLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnZhbHVlLnN2ZWx0ZSIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2ZsYWdzL2xlZ2FjeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2Vhc2luZy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2FuaW1hdGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlL3NyYy9TaW1wbGVBdXRvY29tcGxldGUuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuYXV0b2NvbXBsZXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jb2xvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubGFiZWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmNoZWNrYm94LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jaGVja2JveC5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5kYXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5kYXRldGltZS5pbi50ei5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuZW1haWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmhpZGRlbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkudGV4dGFyZWEuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmpzb24uYXJlYS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvbGliLm1qcyIsIi4uL3NyYy9mcmFtZS9MSUIuanMiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS50aXRsZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC91aS5saXN0LmVtcHR5LnBsYWNlaG9sZGVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saW5rL3VpLmxpbmsuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpbmsvdWkubGlua3Muc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5pdGVtLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3VpLmxpc3QuYmxvY2suc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubGlzdC5vZi5tb2RlbHMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5jb2x1bW4uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5jb2x1bW5zLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkuY29udGFpbmVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkuZm9vdGVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkuc2VjdGlvbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmxldmVsLml0ZW0uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5sZXZlbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubnVtYmVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5uYW1lZC5udW1iZXJzLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnBhc3N3b3JkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbWFnZS91aS5pbWFnZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucmFkaW8uYnV0dG9ucy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucmFuZ2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5tdWx0aXBsZS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29uc3QuanMiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc2VsZWN0LmZyb20ubW9kZWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnN3aXRjaC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc3dpdGNoLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRhZy5zZWxlY3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRlbGVwaG9uZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS50YWcudmFsdWUubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5lcnJvcnMubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS51c2VyLmNhcmQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mb250LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC5lcnJvcnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5idXR0b24ud2l0aC50YWcuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mbG9hdGluZy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9mb3JtL3VpLmZvcm0uaW5wdXQudmFsaWRhdGVkLmljb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvZm9ybS91aS5mb3JtLmNvbnRyb2wuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ltYWdlL3VpLmltYWdlcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC9lbmRsZXNzL3VpLmVuZGxlc3MubGlzdC5uYXZpZ2F0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0LnNpbXBsZS5pdGVtLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC91aS5saXN0LnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC9zZWxlY3QvZHRvL2xpc3QuZ3JvdXBzLnVpLnRyZWUuZHRvLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8ubXVsdGlwbGUuYmVoYXZpb3VyLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8uc2luZ2xlLmJlaGF2aW91ci5qcyIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC9kdG8vbGlzdC5ncm91cHMudmFsdWUuZHRvLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L3VpLmxpc3Quc2VsZWN0LndpdGguZ3JvdXBzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC91aS5saXN0LnNlbGVjdC5idXR0b25zLndpdGguZ3JvdXBzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9tb2RhbC91aS5vdmVybGF5LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9tb2RhbC91aS5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbW9kYWwvdWkuZ2VuZXJpYy5zZWxlY3Rvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9icmFuZC91aS5uYXZiYXIuYnJhbmQud3JhcHBlci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9icmFuZC91aS5uYXZiYXIuYnJhbmQuaXRlbS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9icmFuZC91aS5uYXZiYXIuYnJhbmQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vaXRlbS9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLmxpbmsuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vaXRlbS9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLndyYXBwZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vaXRlbS9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLmNvbnRlbnQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vaXRlbS9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLmRldmlkZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vaXRlbS91aS5uYXZiYXIuaXRlbS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9pdGVtL2Ryb3Bkb3duL3VpLm5hdmJhci5pdGVtLmhhcy5kcm9wZG93bi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9pdGVtL2Ryb3Bkb3duL3VpLm5hdmJhci5pdGVtLmhhcy5kcm9wZG93bi5sYWJlbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9pdGVtL2Ryb3Bkb3duL3VpLm5hdmJhci5pdGVtLmhhcy5kcm9wZG93bi5pdGVtcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9pdGVtL3VpLm5hdmJhci5pdGVtLnNlY3Rpb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vaXRlbS91aS5uYXZiYXIuaXRlbS5nZW5lcmljLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9uYXZpZ2F0aW9uL21lbnUvdWkubmF2YmFyLm1lbnUud3JhcHBlci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi9tZW51L3VpLm5hdmJhci5tZW51LnN0YXJ0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9uYXZpZ2F0aW9uL21lbnUvdWkubmF2YmFyLm1lbnUuZW5kLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9uYXZpZ2F0aW9uL21lbnUvdWkubmF2YmFyLm1lbnUuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vdWkubmF2YmFyLmJ1cmdlci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi91aS5uYXZiYXIud3JhcHBlci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbmF2aWdhdGlvbi91aS5uYXZiYXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25hdmlnYXRpb24vdWkubmF2YmFyLmxpbmsuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5tZXNzYWdlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9ub3RpZmljYXRpb24vdWkuZXJyb3Iuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5zdWNjZXNzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9ub3RpZmljYXRpb24vdWkuY29va2llLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9iYXNlLmpzIiwiLi4vc3JjL2ZyYW1lL3JvdXRlci5qcyIsIi4uL3NyYy9mcmFtZS9hcGkvcXVldWUuanMiLCIuLi9zcmMvZnJhbWUvYXBpL29wdGlvbnMuanMiLCIuLi9zcmMvZnJhbWUvYXBpL2Nvbm5lY3Rpb24uanMiLCIuLi9zcmMvZnJhbWUvc3RvcmVzLmpzIiwiLi4vc3JjL2ZyYW1lL29wdGlvbnMuanMiLCIuLi9zcmMvZnJhbWUvaW50ZXJmYWNlLmpzIiwiLi4vc3JjL2ZyYW1lL3JlY29yZC5qcyIsIi4uL3NyYy9mcmFtZS9hcHAuanMiLCIuLi9zcmMvZnJhbWUvY29udHJvbGxlci5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL3N0b3Jlcy5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL2NvbnRyb2xzL3VpLnN3aXRjaC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9jb250cm9scy91aS50YWdzLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL25vdFRhYmxlQ2VsbC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZVJvdy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZS5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2FjdGlvbi91aS5hY3Rpb24uY29udGFpbmVyLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2FjdGlvbi9hY3Rpb24udWkuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL3V0aWxzLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9mb3JtLmhlbHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL3Jlc3VsdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtZXJyb3Ivc3JjL2Vycm9yLm5vZGUuY2pzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC1lcnJvci9zcmMvdmFsaWRhdGlvbi5lcnJvci5ub2RlLmNqcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvY29tbW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9zZXNzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9ydW5uZXIudXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL3J1bm5lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvYnVpbGRlci51dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvYnVpbGRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2ZpZWxkLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0ucnVsZXMuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uc2V0LnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5zZXQuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy91aS5icmVhZGNydW1icy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy9icmVhZGNydW1icy5zdmVsdGUuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vbWVudS5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLmJyYW5kLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLml0ZW0uY29udGVudC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS5pdGVtLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLnNlY3Rpb24uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3N0b3JlLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuYnVyZ2VyLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLnRvcC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC9pbmRleC5zdmVsdGUuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvdWkuaXRlbS53aXRob3V0LmNoaWxkcmVuLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS50cmlnZ2VyLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5pdGVtLmxhYmVsLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5pdGVtcy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvdWkuc2VjdGlvbi5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvdWkuc2lkZS5tZW51LnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS9pbmRleC5zdmVsdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9jb25zdC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2NyZWF0ZS5jcnVkLmFjdGlvbi51aS52aWV3LmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvdmFyaWFudHMucHJlbG9hZGVyLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvcm91dGVyLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvbWVzc2FnZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZ2VuZXJpYy9hY3Rpb24uanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvY3JlYXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9jcmVhdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvcmVhZC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZGV0YWlscy5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZ2VuZXJpYy91cGRhdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL3VwZGF0ZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZGVsZXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9saXN0LmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2NvbnRyb2xsZXIuY3J1ZC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3JvdXRlci5wbGFpbi5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3JvdXRlci5zd2l0Y2guanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9zZWFyY2guc2VydmljZS5qcyIsIi4uL3NyYy9mcmFtZS9pbmRleC5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB0cnVlO1xuIiwiLy8gU3RvcmUgdGhlIHJlZmVyZW5jZXMgdG8gZ2xvYmFscyBpbiBjYXNlIHNvbWVvbmUgdHJpZXMgdG8gbW9ua2V5IHBhdGNoIHRoZXNlLCBjYXVzaW5nIHRoZSBiZWxvd1xuLy8gdG8gZGUtb3B0ICh0aGlzIG9jY3VycyBvZnRlbiB3aGVuIHVzaW5nIHBvcHVsYXIgZXh0ZW5zaW9ucykuXG5leHBvcnQgdmFyIGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydCB2YXIgaW5kZXhfb2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbmV4cG9ydCB2YXIgYXJyYXlfZnJvbSA9IEFycmF5LmZyb207XG5leHBvcnQgdmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXM7XG5leHBvcnQgdmFyIGRlZmluZV9wcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydCB2YXIgZ2V0X2Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZXhwb3J0IHZhciBnZXRfZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbmV4cG9ydCB2YXIgb2JqZWN0X3Byb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5leHBvcnQgdmFyIGFycmF5X3Byb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgZ2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmV4cG9ydCB2YXIgaXNfZXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlPy50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHBhcmFtIHtGdW5jdGlvbn0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbi8qKiBAcGFyYW0ge0FycmF5PCgpID0+IHZvaWQ+fSBhcnIgKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fYWxsKGFycikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdGFycltpXSgpO1xuXHR9XG59XG5cbi8qKlxuICogVE9ETyByZXBsYWNlIHdpdGggUHJvbWlzZS53aXRoUmVzb2x2ZXJzIG9uY2Ugc3VwcG9ydGVkIHdpZGVseSBlbm91Z2hcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZlcnJlZCgpIHtcblx0LyoqIEB0eXBlIHsodmFsdWU6IFQpID0+IHZvaWR9ICovXG5cdHZhciByZXNvbHZlO1xuXG5cdC8qKiBAdHlwZSB7KHJlYXNvbjogYW55KSA9PiB2b2lkfSAqL1xuXHR2YXIgcmVqZWN0O1xuXG5cdC8qKiBAdHlwZSB7UHJvbWlzZTxUPn0gKi9cblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRyZXNvbHZlID0gcmVzO1xuXHRcdHJlamVjdCA9IHJlajtcblx0fSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtWIHwgKCgpID0+IFYpfSBmYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBbbGF6eV1cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFsbGJhY2sodmFsdWUsIGZhbGxiYWNrLCBsYXp5ID0gZmFsc2UpIHtcblx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcblx0XHQ/IGxhenlcblx0XHRcdD8gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoZmFsbGJhY2spKClcblx0XHRcdDogLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spXG5cdFx0OiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBXaGVuIGVuY291bnRlcmluZyBhIHNpdHVhdGlvbiBsaWtlIGBsZXQgW2EsIGIsIGNdID0gJGRlcml2ZWQoYmxhaCgpKWAsXG4gKiB3ZSBuZWVkIHRvIHN0YXNoIGFuIGludGVybWVkaWF0ZSB2YWx1ZSB0aGF0IGBhYCwgYGJgLCBhbmQgYGNgIGRlcml2ZVxuICogZnJvbSwgaW4gY2FzZSBpdCdzIGFuIGl0ZXJhYmxlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheUxpa2U8VD4gfCBJdGVyYWJsZTxUPn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbl1cbiAqIEByZXR1cm5zIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX2FycmF5KHZhbHVlLCBuKSB7XG5cdC8vIHJldHVybiBhcnJheXMgdW5jaGFuZ2VkXG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vIGlmIHZhbHVlIGlzIG5vdCBpdGVyYWJsZSwgb3IgYG5gIGlzIHVuc3BlY2lmaWVkIChpbmRpY2F0ZXMgYSByZXN0XG5cdC8vIGVsZW1lbnQsIHdoaWNoIG1lYW5zIHdlJ3JlIG5vdCBjb25jZXJuZWQgYWJvdXQgdW5ib3VuZGVkIGl0ZXJhYmxlcylcblx0Ly8gY29udmVydCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tYFxuXHRpZiAobiA9PT0gdW5kZWZpbmVkIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSkge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcblx0fVxuXG5cdC8vIG90aGVyd2lzZSwgcG9wdWxhdGUgYW4gYXJyYXkgd2l0aCBgbmAgdmFsdWVzXG5cblx0LyoqIEB0eXBlIHtUW119ICovXG5cdGNvbnN0IGFycmF5ID0gW107XG5cblx0Zm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlKSB7XG5cdFx0YXJyYXkucHVzaChlbGVtZW50KTtcblx0XHRpZiAoYXJyYXkubGVuZ3RoID09PSBuKSBicmVhaztcblx0fVxuXG5cdHJldHVybiBhcnJheTtcbn1cbiIsIi8vIEdlbmVyYWwgZmxhZ3NcbmV4cG9ydCBjb25zdCBERVJJVkVEID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IEVGRkVDVCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBSRU5ERVJfRUZGRUNUID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VGRkVDVCA9IDEgPDwgNDtcbmV4cG9ydCBjb25zdCBCUkFOQ0hfRUZGRUNUID0gMSA8PCA1O1xuZXhwb3J0IGNvbnN0IFJPT1RfRUZGRUNUID0gMSA8PCA2O1xuZXhwb3J0IGNvbnN0IEJPVU5EQVJZX0VGRkVDVCA9IDEgPDwgNztcbmV4cG9ydCBjb25zdCBDTEVBTiA9IDEgPDwgMTA7XG5leHBvcnQgY29uc3QgRElSVFkgPSAxIDw8IDExO1xuZXhwb3J0IGNvbnN0IE1BWUJFX0RJUlRZID0gMSA8PCAxMjtcbmV4cG9ydCBjb25zdCBJTkVSVCA9IDEgPDwgMTM7XG5leHBvcnQgY29uc3QgREVTVFJPWUVEID0gMSA8PCAxNDtcblxuLy8gRmxhZ3MgZXhjbHVzaXZlIHRvIGVmZmVjdHNcbi8qKiBTZXQgb25jZSBhbiBlZmZlY3QgdGhhdCBzaG91bGQgcnVuIHN5bmNocm9ub3VzbHkgaGFzIHJ1biAqL1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9SQU4gPSAxIDw8IDE1O1xuLyoqXG4gKiAnVHJhbnNwYXJlbnQnIGVmZmVjdHMgZG8gbm90IGNyZWF0ZSBhIHRyYW5zaXRpb24gYm91bmRhcnkuXG4gKiBUaGlzIGlzIG9uIGEgYmxvY2sgZWZmZWN0IDk5JSBvZiB0aGUgdGltZSBidXQgbWF5IGFsc28gYmUgb24gYSBicmFuY2ggZWZmZWN0IGlmIGl0cyBwYXJlbnQgYmxvY2sgZWZmZWN0IHdhcyBwcnVuZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9UUkFOU1BBUkVOVCA9IDEgPDwgMTY7XG5leHBvcnQgY29uc3QgRUFHRVJfRUZGRUNUID0gMSA8PCAxNztcbmV4cG9ydCBjb25zdCBIRUFEX0VGRkVDVCA9IDEgPDwgMTg7XG5leHBvcnQgY29uc3QgRUZGRUNUX1BSRVNFUlZFRCA9IDEgPDwgMTk7XG5leHBvcnQgY29uc3QgVVNFUl9FRkZFQ1QgPSAxIDw8IDIwO1xuXG4vLyBGbGFncyBleGNsdXNpdmUgdG8gZGVyaXZlZHNcbmV4cG9ydCBjb25zdCBVTk9XTkVEID0gMSA8PCA4O1xuZXhwb3J0IGNvbnN0IERJU0NPTk5FQ1RFRCA9IDEgPDwgOTtcbi8qKlxuICogVGVsbHMgdGhhdCB3ZSBtYXJrZWQgdGhpcyBkZXJpdmVkIGFuZCBpdHMgcmVhY3Rpb25zIGFzIHZpc2l0ZWQgZHVyaW5nIHRoZSBcIm1hcmsgYXMgKG1heWJlKSBkaXJ0eVwiLXBoYXNlLlxuICogV2lsbCBiZSBsaWZ0ZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiB0aGUgZGVyaXZlZCBhbmQgZHVyaW5nIGNoZWNraW5nIGl0cyBkaXJ0eSBzdGF0ZSAoYm90aCBhcmUgbmVjZXNzYXJ5XG4gKiBiZWNhdXNlIGEgZGVyaXZlZCBtaWdodCBiZSBjaGVja2VkIGJ1dCBub3QgZXhlY3V0ZWQpLlxuICovXG5leHBvcnQgY29uc3QgV0FTX01BUktFRCA9IDEgPDwgMTU7XG5cbi8vIEZsYWdzIHVzZWQgZm9yIGFzeW5jXG5leHBvcnQgY29uc3QgUkVBQ1RJT05fSVNfVVBEQVRJTkcgPSAxIDw8IDIxO1xuZXhwb3J0IGNvbnN0IEFTWU5DID0gMSA8PCAyMjtcblxuZXhwb3J0IGNvbnN0IEVSUk9SX1ZBTFVFID0gMSA8PCAyMztcblxuZXhwb3J0IGNvbnN0IFNUQVRFX1NZTUJPTCA9IFN5bWJvbCgnJHN0YXRlJyk7XG5leHBvcnQgY29uc3QgTEVHQUNZX1BST1BTID0gU3ltYm9sKCdsZWdhY3kgcHJvcHMnKTtcbmV4cG9ydCBjb25zdCBMT0FESU5HX0FUVFJfU1lNQk9MID0gU3ltYm9sKCcnKTtcbmV4cG9ydCBjb25zdCBQUk9YWV9QQVRIX1NZTUJPTCA9IFN5bWJvbCgncHJveHkgcGF0aCcpO1xuXG4vKiogYWxsb3cgdXNlcnMgdG8gaWdub3JlIGFib3J0ZWQgc2lnbmFsIGVycm9ycyBpZiBgcmVhc29uLm5hbWUgPT09ICdTdGFsZVJlYWN0aW9uRXJyb3JgICovXG5leHBvcnQgY29uc3QgU1RBTEVfUkVBQ1RJT04gPSBuZXcgKGNsYXNzIFN0YWxlUmVhY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcblx0bmFtZSA9ICdTdGFsZVJlYWN0aW9uRXJyb3InO1xuXHRtZXNzYWdlID0gJ1RoZSByZWFjdGlvbiB0aGF0IGNhbGxlZCBgZ2V0QWJvcnRTaWduYWwoKWAgd2FzIHJlLXJ1biBvciBkZXN0cm95ZWQnO1xufSkoKTtcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfTk9ERSA9IDE7XG5leHBvcnQgY29uc3QgVEVYVF9OT0RFID0gMztcbmV4cG9ydCBjb25zdCBDT01NRU5UX05PREUgPSA4O1xuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKlxuICogQ2Fubm90IHVzZSBge0ByZW5kZXIgY2hpbGRyZW4oLi4uKX1gIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgYGxldDpgIGRpcmVjdGl2ZXMuIENvbnNpZGVyIHVzaW5nIGEgbmFtZWQgc25pcHBldCBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX2RlZmF1bHRfc25pcHBldCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkX2RlZmF1bHRfc25pcHBldFxcbkNhbm5vdCB1c2UgXFxge0ByZW5kZXIgY2hpbGRyZW4oLi4uKX1cXGAgaWYgdGhlIHBhcmVudCBjb21wb25lbnQgdXNlcyBcXGBsZXQ6XFxgIGRpcmVjdGl2ZXMuIENvbnNpZGVyIHVzaW5nIGEgbmFtZWQgc25pcHBldCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIEEgc25pcHBldCBmdW5jdGlvbiB3YXMgcGFzc2VkIGludmFsaWQgYXJndW1lbnRzLiBTbmlwcGV0cyBzaG91bGQgb25seSBiZSBpbnN0YW50aWF0ZWQgdmlhIGB7QHJlbmRlciAuLi59YFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50cygpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkX3NuaXBwZXRfYXJndW1lbnRzXFxuQSBzbmlwcGV0IGZ1bmN0aW9uIHdhcyBwYXNzZWQgaW52YWxpZCBhcmd1bWVudHMuIFNuaXBwZXRzIHNob3VsZCBvbmx5IGJlIGluc3RhbnRpYXRlZCB2aWEgXFxge0ByZW5kZXIgLi4ufVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldF9hcmd1bWVudHNgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50c2ApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJSguLi4pYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudFxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb250ZXh0IHdhcyBub3Qgc2V0IGluIGEgcGFyZW50IGNvbXBvbmVudFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWlzc2luZ19jb250ZXh0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYG1pc3NpbmdfY29udGV4dFxcbkNvbnRleHQgd2FzIG5vdCBzZXQgaW4gYSBwYXJlbnQgY29tcG9uZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbWlzc2luZ19jb250ZXh0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL21pc3NpbmdfY29udGV4dGApO1xuXHR9XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIHJlbmRlciBhIHNuaXBwZXQgd2l0aG91dCBhIGB7QHJlbmRlcn1gIGJsb2NrLiBUaGlzIHdvdWxkIGNhdXNlIHRoZSBzbmlwcGV0IGNvZGUgdG8gYmUgc3RyaW5naWZpZWQgaW5zdGVhZCBvZiBpdHMgY29udGVudCBiZWluZyByZW5kZXJlZCB0byB0aGUgRE9NLiBUbyBmaXggdGhpcywgY2hhbmdlIGB7c25pcHBldH1gIHRvIGB7QHJlbmRlciBzbmlwcGV0KCl9YC5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnXFxuQXR0ZW1wdGVkIHRvIHJlbmRlciBhIHNuaXBwZXQgd2l0aG91dCBhIFxcYHtAcmVuZGVyfVxcYCBibG9jay4gVGhpcyB3b3VsZCBjYXVzZSB0aGUgc25pcHBldCBjb2RlIHRvIGJlIHN0cmluZ2lmaWVkIGluc3RlYWQgb2YgaXRzIGNvbnRlbnQgYmVpbmcgcmVuZGVyZWQgdG8gdGhlIERPTS4gVG8gZml4IHRoaXMsIGNoYW5nZSBcXGB7c25pcHBldH1cXGAgdG8gXFxge0ByZW5kZXIgc25pcHBldCgpfVxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJWAgaXMgbm90IGEgc3RvcmUgd2l0aCBhIGBzdWJzY3JpYmVgIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0b3JlX2ludmFsaWRfc2hhcGVcXG5cXGAke25hbWV9XFxgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBcXGBzdWJzY3JpYmVcXGAgbWV0aG9kXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdG9yZV9pbnZhbGlkX3NoYXBlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHRoaXNgIHByb3Agb24gYDxzdmVsdGU6ZWxlbWVudD5gIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVcXG5UaGUgXFxgdGhpc1xcYCBwcm9wIG9uIFxcYDxzdmVsdGU6ZWxlbWVudD5cXGAgbXVzdCBiZSBhIHN0cmluZywgaWYgZGVmaW5lZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblx0fVxufSIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbmV4cG9ydCAqICBmcm9tICcuLi9zaGFyZWQvZXJyb3JzLmpzJztcblxuLyoqXG4gKiBDYW5ub3QgY3JlYXRlIGEgYCRkZXJpdmVkKC4uLilgIHdpdGggYW4gYGF3YWl0YCBleHByZXNzaW9uIG91dHNpZGUgb2YgYW4gZWZmZWN0IHRyZWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jX2Rlcml2ZWRfb3JwaGFuKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGFzeW5jX2Rlcml2ZWRfb3JwaGFuXFxuQ2Fubm90IGNyZWF0ZSBhIFxcYCRkZXJpdmVkKC4uLilcXGAgd2l0aCBhbiBcXGBhd2FpdFxcYCBleHByZXNzaW9uIG91dHNpZGUgb2YgYW4gZWZmZWN0IHRyZWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hc3luY19kZXJpdmVkX29ycGhhbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9hc3luY19kZXJpdmVkX29ycGhhbmApO1xuXHR9XG59XG5cbi8qKlxuICogVXNpbmcgYGJpbmQ6dmFsdWVgIHRvZ2V0aGVyIHdpdGggYSBjaGVja2JveCBpbnB1dCBpcyBub3QgYWxsb3dlZC4gVXNlIGBiaW5kOmNoZWNrZWRgIGluc3RlYWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVcXG5Vc2luZyBcXGBiaW5kOnZhbHVlXFxgIHRvZ2V0aGVyIHdpdGggYSBjaGVja2JveCBpbnB1dCBpcyBub3QgYWxsb3dlZC4gVXNlIFxcYGJpbmQ6Y2hlY2tlZFxcYCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogQ29tcG9uZW50ICVjb21wb25lbnQlIGhhcyBhbiBleHBvcnQgbmFtZWQgYCVrZXklYCB0aGF0IGEgY29uc3VtZXIgY29tcG9uZW50IGlzIHRyeWluZyB0byBhY2Nlc3MgdXNpbmcgYGJpbmQ6JWtleSVgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgYGJpbmQ6dGhpc2AgKGUuZy4gYDwlbmFtZSUgYmluZDp0aGlzPXtjb21wb25lbnR9IC8+YCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIGBjb21wb25lbnQuJWtleSVgKVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfaW52YWxpZF9leHBvcnQoY29tcG9uZW50LCBrZXksIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX2ludmFsaWRfZXhwb3J0XFxuQ29tcG9uZW50ICR7Y29tcG9uZW50fSBoYXMgYW4gZXhwb3J0IG5hbWVkIFxcYCR7a2V5fVxcYCB0aGF0IGEgY29uc3VtZXIgY29tcG9uZW50IGlzIHRyeWluZyB0byBhY2Nlc3MgdXNpbmcgXFxgYmluZDoke2tleX1cXGAsIHdoaWNoIGlzIGRpc2FsbG93ZWQuIEluc3RlYWQsIHVzZSBcXGBiaW5kOnRoaXNcXGAgKGUuZy4gXFxgPCR7bmFtZX0gYmluZDp0aGlzPXtjb21wb25lbnR9IC8+XFxgKSBhbmQgdGhlbiBhY2Nlc3MgdGhlIHByb3BlcnR5IG9uIHRoZSBib3VuZCBjb21wb25lbnQgaW5zdGFuY2UgKGUuZy4gXFxgY29tcG9uZW50LiR7a2V5fVxcYClcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9leHBvcnRgKTtcblx0fVxufVxuXG4vKipcbiAqIEEgY29tcG9uZW50IGlzIGF0dGVtcHRpbmcgdG8gYmluZCB0byBhIG5vbi1iaW5kYWJsZSBwcm9wZXJ0eSBgJWtleSVgIGJlbG9uZ2luZyB0byAlY29tcG9uZW50JSAoaS5lLiBgPCVuYW1lJSBiaW5kOiVrZXklPXsuLi59PmApLiBUbyBtYXJrIGEgcHJvcGVydHkgYXMgYmluZGFibGU6IGBsZXQgeyAla2V5JSA9ICRiaW5kYWJsZSgpIH0gPSAkcHJvcHMoKWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX25vdF9iaW5kYWJsZShrZXksIGNvbXBvbmVudCwgbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGJpbmRfbm90X2JpbmRhYmxlXFxuQSBjb21wb25lbnQgaXMgYXR0ZW1wdGluZyB0byBiaW5kIHRvIGEgbm9uLWJpbmRhYmxlIHByb3BlcnR5IFxcYCR7a2V5fVxcYCBiZWxvbmdpbmcgdG8gJHtjb21wb25lbnR9IChpLmUuIFxcYDwke25hbWV9IGJpbmQ6JHtrZXl9PXsuLi59PlxcYCkuIFRvIG1hcmsgYSBwcm9wZXJ0eSBhcyBiaW5kYWJsZTogXFxgbGV0IHsgJHtrZXl9ID0gJGJpbmRhYmxlKCkgfSA9ICRwcm9wcygpXFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9ub3RfYmluZGFibGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9ub3RfYmluZGFibGVgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbGxpbmcgYCVtZXRob2QlYCBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZSAob2YgJWNvbXBvbmVudCUpIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X2FwaV9jaGFuZ2VkKG1ldGhvZCwgY29tcG9uZW50KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY29tcG9uZW50X2FwaV9jaGFuZ2VkXFxuQ2FsbGluZyBcXGAke21ldGhvZH1cXGAgb24gYSBjb21wb25lbnQgaW5zdGFuY2UgKG9mICR7Y29tcG9uZW50fSkgaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9jaGFuZ2VkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIGluc3RhbnRpYXRlICVjb21wb25lbnQlIHdpdGggYG5ldyAlbmFtZSVgLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDUuIElmIHRoaXMgY29tcG9uZW50IGlzIG5vdCB1bmRlciB5b3VyIGNvbnRyb2wsIHNldCB0aGUgYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpYCBjb21waWxlciBvcHRpb24gdG8gYDRgIHRvIGtlZXAgaXQgd29ya2luZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfYXBpX2ludmFsaWRfbmV3KGNvbXBvbmVudCwgbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXdcXG5BdHRlbXB0ZWQgdG8gaW5zdGFudGlhdGUgJHtjb21wb25lbnR9IHdpdGggXFxgbmV3ICR7bmFtZX1cXGAsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNS4gSWYgdGhpcyBjb21wb25lbnQgaXMgbm90IHVuZGVyIHlvdXIgY29udHJvbCwgc2V0IHRoZSBcXGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaVxcYCBjb21waWxlciBvcHRpb24gdG8gXFxgNFxcYCB0byBrZWVwIGl0IHdvcmtpbmcuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGRlcml2ZWQgdmFsdWUgY2Fubm90IHJlZmVyZW5jZSBpdHNlbGYgcmVjdXJzaXZlbHlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGRlcml2ZWRfcmVmZXJlbmNlc19zZWxmXFxuQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGZgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGZgKTtcblx0fVxufVxuXG4vKipcbiAqIEtleWVkIGVhY2ggYmxvY2sgaGFzIGR1cGxpY2F0ZSBrZXkgYCV2YWx1ZSVgIGF0IGluZGV4ZXMgJWElIGFuZCAlYiVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoX2tleV9kdXBsaWNhdGUoYSwgYiwgdmFsdWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlYWNoX2tleV9kdXBsaWNhdGVcXG4ke3ZhbHVlXG5cdFx0XHQ/IGBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IFxcYCR7dmFsdWV9XFxgIGF0IGluZGV4ZXMgJHthfSBhbmQgJHtifWBcblx0XHRcdDogYEtleWVkIGVhY2ggYmxvY2sgaGFzIGR1cGxpY2F0ZSBrZXkgYXQgaW5kZXhlcyAke2F9IGFuZCAke2J9YH1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lYWNoX2tleV9kdXBsaWNhdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWFjaF9rZXlfZHVwbGljYXRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJXJ1bmUlYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IGNsZWFudXAgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdGVhcmRvd24ocnVuZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl90ZWFyZG93blxcblxcYCR7cnVuZX1cXGAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3RlYXJkb3duYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl90ZWFyZG93bmApO1xuXHR9XG59XG5cbi8qKlxuICogRWZmZWN0IGNhbm5vdCBiZSBjcmVhdGVkIGluc2lkZSBhIGAkZGVyaXZlZGAgdmFsdWUgdGhhdCB3YXMgbm90IGl0c2VsZiBjcmVhdGVkIGluc2lkZSBhbiBlZmZlY3RcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZFxcbkVmZmVjdCBjYW5ub3QgYmUgY3JlYXRlZCBpbnNpZGUgYSBcXGAkZGVyaXZlZFxcYCB2YWx1ZSB0aGF0IHdhcyBub3QgaXRzZWxmIGNyZWF0ZWQgaW5zaWRlIGFuIGVmZmVjdFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IChlLmcuIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24pXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X29ycGhhbihydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X29ycGhhblxcblxcYCR7cnVuZX1cXGAgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IChlLmcuIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24pXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3Rfb3JwaGFuYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJGVmZmVjdC5wZW5kaW5nKClgIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IG9yIGRlcml2ZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9wZW5kaW5nX291dHNpZGVfcmVhY3Rpb24oKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X3BlbmRpbmdfb3V0c2lkZV9yZWFjdGlvblxcblxcYCRlZmZlY3QucGVuZGluZygpXFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IG9yIGRlcml2ZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9wZW5kaW5nX291dHNpZGVfcmVhY3Rpb25gKTtcblx0fVxufVxuXG4vKipcbiAqIE1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIHR5cGljYWxseSBpbmRpY2F0ZXMgdGhhdCBhbiBlZmZlY3QgcmVhZHMgYW5kIHdyaXRlcyB0aGUgc2FtZSBwaWVjZSBvZiBzdGF0ZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkXFxuTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgdHlwaWNhbGx5IGluZGljYXRlcyB0aGF0IGFuIGVmZmVjdCByZWFkcyBhbmQgd3JpdGVzIHRoZSBzYW1lIHBpZWNlIG9mIHN0YXRlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3QgdXNlIGBmb3JrKC4uLilgIHVubGVzcyB0aGUgYGV4cGVyaW1lbnRhbC5hc3luY2AgY29tcGlsZXIgb3B0aW9uIGlzIGB0cnVlYFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwZXJpbWVudGFsX2FzeW5jX2ZvcmsoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZXhwZXJpbWVudGFsX2FzeW5jX2ZvcmtcXG5DYW5ub3QgdXNlIFxcYGZvcmsoLi4uKVxcYCB1bmxlc3MgdGhlIFxcYGV4cGVyaW1lbnRhbC5hc3luY1xcYCBjb21waWxlciBvcHRpb24gaXMgXFxgdHJ1ZVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2V4cGVyaW1lbnRhbF9hc3luY19mb3JrYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2V4cGVyaW1lbnRhbF9hc3luY19mb3JrYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3QgdXNlIGBmbHVzaFN5bmNgIGluc2lkZSBhbiBlZmZlY3RcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3N5bmNfaW5fZWZmZWN0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGZsdXNoX3N5bmNfaW5fZWZmZWN0XFxuQ2Fubm90IHVzZSBcXGBmbHVzaFN5bmNcXGAgaW5zaWRlIGFuIGVmZmVjdFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ZsdXNoX3N5bmNfaW5fZWZmZWN0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ZsdXNoX3N5bmNfaW5fZWZmZWN0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3QgY29tbWl0IGEgZm9yayB0aGF0IHdhcyBhbHJlYWR5IGRpc2NhcmRlZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ya19kaXNjYXJkZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZm9ya19kaXNjYXJkZWRcXG5DYW5ub3QgY29tbWl0IGEgZm9yayB0aGF0IHdhcyBhbHJlYWR5IGRpc2NhcmRlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ZvcmtfZGlzY2FyZGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ZvcmtfZGlzY2FyZGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3QgY3JlYXRlIGEgZm9yayBpbnNpZGUgYW4gZWZmZWN0IG9yIHdoZW4gc3RhdGUgY2hhbmdlcyBhcmUgcGVuZGluZ1xuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ya190aW1pbmcoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZm9ya190aW1pbmdcXG5DYW5ub3QgY3JlYXRlIGEgZm9yayBpbnNpZGUgYW4gZWZmZWN0IG9yIHdoZW4gc3RhdGUgY2hhbmdlcyBhcmUgcGVuZGluZ1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ZvcmtfdGltaW5nYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ZvcmtfdGltaW5nYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgZ2V0QWJvcnRTaWduYWwoKWAgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3Qgb3IgZGVyaXZlZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2Fib3J0X3NpZ25hbF9vdXRzaWRlX3JlYWN0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGdldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvblxcblxcYGdldEFib3J0U2lnbmFsKClcXGAgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3Qgb3IgZGVyaXZlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2dldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9nZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb25gKTtcblx0fVxufVxuXG4vKipcbiAqIEZhaWxlZCB0byBoeWRyYXRlIHRoZSBhcHBsaWNhdGlvblxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX2ZhaWxlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBoeWRyYXRpb25fZmFpbGVkXFxuRmFpbGVkIHRvIGh5ZHJhdGUgdGhlIGFwcGxpY2F0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2ZhaWxlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb3VsZCBub3QgYHtAcmVuZGVyfWAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgLiBDb25zaWRlciB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBge0ByZW5kZXIgc25pcHBldD8uKCl9YFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9zbmlwcGV0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWRfc25pcHBldFxcbkNvdWxkIG5vdCBcXGB7QHJlbmRlcn1cXGAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgXFxgbnVsbFxcYCBvciBcXGB1bmRlZmluZWRcXGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIFxcYHtAcmVuZGVyIHNuaXBwZXQ/LigpfVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2Fubm90IGJlIHVzZWQgaW4gcnVuZXMgbW9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9sZWdhY3lfb25seShuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5XFxuXFxgJHtuYW1lfSguLi4pXFxgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3QgZG8gYGJpbmQ6JWtleSU9e3VuZGVmaW5lZH1gIHdoZW4gYCVrZXklYCBoYXMgYSBmYWxsYmFjayB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNfaW52YWxpZF92YWx1ZShrZXkpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBwcm9wc19pbnZhbGlkX3ZhbHVlXFxuQ2Fubm90IGRvIFxcYGJpbmQ6JHtrZXl9PXt1bmRlZmluZWR9XFxgIHdoZW4gXFxgJHtrZXl9XFxgIGhhcyBhIGZhbGxiYWNrIHZhbHVlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfaW52YWxpZF92YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXN0IGVsZW1lbnQgcHJvcGVydGllcyBvZiBgJHByb3BzKClgIHN1Y2ggYXMgYCVwcm9wZXJ0eSVgIGFyZSByZWFkb25seVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19yZXN0X3JlYWRvbmx5KHByb3BlcnR5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfcmVzdF9yZWFkb25seVxcblJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIFxcYCRwcm9wcygpXFxgIHN1Y2ggYXMgXFxgJHtwcm9wZXJ0eX1cXGAgYXJlIHJlYWRvbmx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYCVydW5lJWAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgYC5zdmVsdGVgIGFuZCBgLnN2ZWx0ZS5qcy90c2AgZmlsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBydW5lX291dHNpZGVfc3ZlbHRlXFxuVGhlIFxcYCR7cnVuZX1cXGAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgXFxgLnN2ZWx0ZVxcYCBhbmQgXFxgLnN2ZWx0ZS5qcy90c1xcYCBmaWxlc1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcnVuZV9vdXRzaWRlX3N2ZWx0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogYHNldENvbnRleHRgIG11c3QgYmUgY2FsbGVkIHdoZW4gYSBjb21wb25lbnQgZmlyc3QgaW5pdGlhbGl6ZXMsIG5vdCBpbiBhIHN1YnNlcXVlbnQgZWZmZWN0IG9yIGFmdGVyIGFuIGBhd2FpdGAgZXhwcmVzc2lvblxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzZXRfY29udGV4dF9hZnRlcl9pbml0XFxuXFxgc2V0Q29udGV4dFxcYCBtdXN0IGJlIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGZpcnN0IGluaXRpYWxpemVzLCBub3QgaW4gYSBzdWJzZXF1ZW50IGVmZmVjdCBvciBhZnRlciBhbiBcXGBhd2FpdFxcYCBleHByZXNzaW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zZXRfY29udGV4dF9hZnRlcl9pbml0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBQcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIGAkc3RhdGVgIG9iamVjdHMgbXVzdCBjb250YWluIGB2YWx1ZWAgYW5kIGFsd2F5cyBiZSBgZW51bWVyYWJsZWAsIGBjb25maWd1cmFibGVgIGFuZCBgd3JpdGFibGVgLlxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRcXG5Qcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIFxcYCRzdGF0ZVxcYCBvYmplY3RzIG11c3QgY29udGFpbiBcXGB2YWx1ZVxcYCBhbmQgYWx3YXlzIGJlIFxcYGVudW1lcmFibGVcXGAsIFxcYGNvbmZpZ3VyYWJsZVxcYCBhbmQgXFxgd3JpdGFibGVcXGAuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBzZXQgcHJvdG90eXBlIG9mIGAkc3RhdGVgIG9iamVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Byb3RvdHlwZV9maXhlZFxcbkNhbm5vdCBzZXQgcHJvdG90eXBlIG9mIFxcYCRzdGF0ZVxcYCBvYmplY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJvdG90eXBlX2ZpeGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVcGRhdGluZyBzdGF0ZSBpbnNpZGUgYCRkZXJpdmVkKC4uLilgLCBgJGluc3BlY3QoLi4uKWAgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBgJHN0YXRlYFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfdW5zYWZlX211dGF0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Vuc2FmZV9tdXRhdGlvblxcblVwZGF0aW5nIHN0YXRlIGluc2lkZSBcXGAkZGVyaXZlZCguLi4pXFxgLCBcXGAkaW5zcGVjdCguLi4pXFxgIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgXFxgJHN0YXRlXFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX211dGF0aW9uYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9tdXRhdGlvbmApO1xuXHR9XG59XG5cbi8qKlxuICogQSBgPHN2ZWx0ZTpib3VuZGFyeT5gIGByZXNldGAgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCB3aGlsZSBhbiBlcnJvciBpcyBzdGlsbCBiZWluZyBoYW5kbGVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvcigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdmVsdGVfYm91bmRhcnlfcmVzZXRfb25lcnJvclxcbkEgXFxgPHN2ZWx0ZTpib3VuZGFyeT5cXGAgXFxgcmVzZXRcXGAgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCB3aGlsZSBhbiBlcnJvciBpcyBzdGlsbCBiZWluZyBoYW5kbGVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3JgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3JgKTtcblx0fVxufSIsImV4cG9ydCBjb25zdCBFQUNIX0lURU1fUkVBQ1RJVkUgPSAxO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSU5ERVhfUkVBQ1RJVkUgPSAxIDw8IDE7XG4vKiogU2VlIEVhY2hCbG9jayBpbnRlcmZhY2UgbWV0YWRhdGEuaXNfY29udHJvbGxlZCBmb3IgYW4gZXhwbGFuYXRpb24gd2hhdCB0aGlzIGlzICovXG5leHBvcnQgY29uc3QgRUFDSF9JU19DT05UUk9MTEVEID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVNfQU5JTUFURUQgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgRUFDSF9JVEVNX0lNTVVUQUJMRSA9IDEgPDwgNDtcblxuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0lNTVVUQUJMRSA9IDE7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfUlVORVMgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfVVBEQVRFRCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19CSU5EQUJMRSA9IDEgPDwgMztcbmV4cG9ydCBjb25zdCBQUk9QU19JU19MQVpZX0lOSVRJQUwgPSAxIDw8IDQ7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX0lOID0gMTtcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX09VVCA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX0dMT0JBTCA9IDEgPDwgMjtcblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX0ZSQUdNRU5UID0gMTtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfSU1QT1JUX05PREUgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgVEVNUExBVEVfVVNFX1NWRyA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfTUFUSE1MID0gMSA8PCAzO1xuXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUID0gJ1snO1xuLyoqIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhbiBgezplbHNlfS4uLmAgYmxvY2sgd2FzIHJlbmRlcmVkICovXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUX0VMU0UgPSAnWyEnO1xuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9FTkQgPSAnXSc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VSUk9SID0ge307XG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX0lTX05BTUVTUEFDRUQgPSAxO1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRfUFJFU0VSVkVfQVRUUklCVVRFX0NBU0UgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgRUxFTUVOVF9JU19JTlBVVCA9IDEgPDwgMjtcblxuZXhwb3J0IGNvbnN0IFVOSU5JVElBTElaRUQgPSBTeW1ib2woKTtcblxuLy8gRGV2LXRpbWUgY29tcG9uZW50IHByb3BlcnRpZXNcbmV4cG9ydCBjb25zdCBGSUxFTkFNRSA9IFN5bWJvbCgnZmlsZW5hbWUnKTtcbmV4cG9ydCBjb25zdCBITVIgPSBTeW1ib2woJ2htcicpO1xuXG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX0hUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX01BVEhNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcblxuLy8gd2UgdXNlIGEgbGlzdCBvZiBpZ25vcmFibGUgcnVudGltZSB3YXJuaW5ncyBiZWNhdXNlIG5vdCBldmVyeSBydW50aW1lIHdhcm5pbmdcbi8vIGNhbiBiZSBpZ25vcmVkIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIHZhbGlkYXRpb24gZm9yIHN2ZWx0ZS1pZ25vcmUgaW4gcGxhY2VcbmV4cG9ydCBjb25zdCBJR05PUkFCTEVfUlVOVElNRV9XQVJOSU5HUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhd2FpdF93YXRlcmZhbGwnLFxuXHQnYXdhaXRfcmVhY3Rpdml0eV9sb3NzJyxcblx0J3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlJyxcblx0J2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlJyxcblx0J2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZCcsXG5cdCdoeWRyYXRpb25faHRtbF9jaGFuZ2VkJyxcblx0J293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24nXG5dKTtcblxuLyoqXG4gKiBXaGl0ZXNwYWNlIGluc2lkZSBvbmUgb2YgdGhlc2UgZWxlbWVudHMgd2lsbCBub3QgcmVzdWx0IGluXG4gKiBhIHdoaXRlc3BhY2Ugbm9kZSBiZWluZyBjcmVhdGVkIGluIGFueSBjaXJjdW1zdGFuY2VzLiAoVGhpc1xuICogbGlzdCBpcyBhbG1vc3QgY2VydGFpbmx5IHZlcnkgaW5jb21wbGV0ZSlcbiAqIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgdW51c2VkXG4gKi9cbmV4cG9ydCBjb25zdCBFTEVNRU5UU19XSVRIT1VUX1RFWFQgPSBbJ2F1ZGlvJywgJ2RhdGFsaXN0JywgJ2RsJywgJ29wdGdyb3VwJywgJ3NlbGVjdCcsICd2aWRlbyddO1xuXG5leHBvcnQgY29uc3QgQVRUQUNITUVOVF9LRVkgPSAnQGF0dGFjaCc7XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG52YXIgYm9sZCA9ICdmb250LXdlaWdodDogYm9sZCc7XG52YXIgbm9ybWFsID0gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG4vKipcbiAqIEFzc2lnbm1lbnQgdG8gYCVwcm9wZXJ0eSVgIHByb3BlcnR5ICglbG9jYXRpb24lKSB3aWxsIGV2YWx1YXRlIHRvIHRoZSByaWdodC1oYW5kIHNpZGUsIG5vdCB0aGUgdmFsdWUgb2YgYCVwcm9wZXJ0eSVgIGZvbGxvd2luZyB0aGUgYXNzaWdubWVudC4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbm1lbnRfdmFsdWVfc3RhbGUocHJvcGVydHksIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYXNzaWdubWVudF92YWx1ZV9zdGFsZVxcbiVjQXNzaWdubWVudCB0byBcXGAke3Byb3BlcnR5fVxcYCBwcm9wZXJ0eSAoJHtsb2NhdGlvbn0pIHdpbGwgZXZhbHVhdGUgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSwgbm90IHRoZSB2YWx1ZSBvZiBcXGAke3Byb3BlcnR5fVxcYCBmb2xsb3dpbmcgdGhlIGFzc2lnbm1lbnQuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hc3NpZ25tZW50X3ZhbHVlX3N0YWxlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Fzc2lnbm1lbnRfdmFsdWVfc3RhbGVgKTtcblx0fVxufVxuXG4vKipcbiAqIERldGVjdGVkIHJlYWN0aXZpdHkgbG9zcyB3aGVuIHJlYWRpbmcgYCVuYW1lJWAuIFRoaXMgaGFwcGVucyB3aGVuIHN0YXRlIGlzIHJlYWQgaW4gYW4gYXN5bmMgZnVuY3Rpb24gYWZ0ZXIgYW4gZWFybGllciBgYXdhaXRgXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRfcmVhY3Rpdml0eV9sb3NzKG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBhd2FpdF9yZWFjdGl2aXR5X2xvc3NcXG4lY0RldGVjdGVkIHJlYWN0aXZpdHkgbG9zcyB3aGVuIHJlYWRpbmcgXFxgJHtuYW1lfVxcYC4gVGhpcyBoYXBwZW5zIHdoZW4gc3RhdGUgaXMgcmVhZCBpbiBhbiBhc3luYyBmdW5jdGlvbiBhZnRlciBhbiBlYXJsaWVyIFxcYGF3YWl0XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXdhaXRfcmVhY3Rpdml0eV9sb3NzYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X3JlYWN0aXZpdHlfbG9zc2ApO1xuXHR9XG59XG5cbi8qKlxuICogQW4gYXN5bmMgZGVyaXZlZCwgYCVuYW1lJWAgKCVsb2NhdGlvbiUpIHdhcyBub3QgcmVhZCBpbW1lZGlhdGVseSBhZnRlciBpdCByZXNvbHZlZC4gVGhpcyBvZnRlbiBpbmRpY2F0ZXMgYW4gdW5uZWNlc3Nhcnkgd2F0ZXJmYWxsLCB3aGljaCBjYW4gc2xvdyBkb3duIHlvdXIgYXBwXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdF93YXRlcmZhbGwobmFtZSwgbG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBhd2FpdF93YXRlcmZhbGxcXG4lY0FuIGFzeW5jIGRlcml2ZWQsIFxcYCR7bmFtZX1cXGAgKCR7bG9jYXRpb259KSB3YXMgbm90IHJlYWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFRoaXMgb2Z0ZW4gaW5kaWNhdGVzIGFuIHVubmVjZXNzYXJ5IHdhdGVyZmFsbCwgd2hpY2ggY2FuIHNsb3cgZG93biB5b3VyIGFwcFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X3dhdGVyZmFsbGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF93YXRlcmZhbGxgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlYmluZGluZyVgICglbG9jYXRpb24lKSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZShiaW5kaW5nLCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVcXG4lYyR7bG9jYXRpb25cblx0XHRcdFx0PyBgXFxgJHtiaW5kaW5nfVxcYCAoJHtsb2NhdGlvbn0pIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlgXG5cdFx0XHRcdDogYFxcYCR7YmluZGluZ31cXGAgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eWB9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgLFxuXHRcdFx0Ym9sZCxcblx0XHRcdG5vcm1hbFxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWApO1xuXHR9XG59XG5cbi8qKlxuICogWW91ciBgY29uc29sZS4lbWV0aG9kJWAgY29udGFpbmVkIGAkc3RhdGVgIHByb3hpZXMuIENvbnNpZGVyIHVzaW5nIGAkaW5zcGVjdCguLi4pYCBvciBgJHN0YXRlLnNuYXBzaG90KC4uLilgIGluc3RlYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnNvbGVfbG9nX3N0YXRlKG1ldGhvZCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGNvbnNvbGVfbG9nX3N0YXRlXFxuJWNZb3VyIFxcYGNvbnNvbGUuJHttZXRob2R9XFxgIGNvbnRhaW5lZCBcXGAkc3RhdGVcXGAgcHJveGllcy4gQ29uc2lkZXIgdXNpbmcgXFxgJGluc3BlY3QoLi4uKVxcYCBvciBcXGAkc3RhdGUuc25hcHNob3QoLi4uKVxcYCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29uc29sZV9sb2dfc3RhdGVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29uc29sZV9sb2dfc3RhdGVgKTtcblx0fVxufVxuXG4vKipcbiAqICVoYW5kbGVyJSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBtZWFuIHRvICVzdWdnZXN0aW9uJT9cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3VnZ2VzdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGhhbmRsZXIsIHN1Z2dlc3Rpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBldmVudF9oYW5kbGVyX2ludmFsaWRcXG4lYyR7aGFuZGxlcn0gc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgbWVhbiB0byAke3N1Z2dlc3Rpb259P1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2V2ZW50X2hhbmRsZXJfaW52YWxpZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9ldmVudF9oYW5kbGVyX2ludmFsaWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgJWF0dHJpYnV0ZSVgIGF0dHJpYnV0ZSBvbiBgJWh0bWwlYCBjaGFuZ2VkIGl0cyB2YWx1ZSBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUsIGAldmFsdWUlYCwgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQoYXR0cmlidXRlLCBodG1sLCB2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZFxcbiVjVGhlIFxcYCR7YXR0cmlidXRlfVxcYCBhdHRyaWJ1dGUgb24gXFxgJHtodG1sfVxcYCBjaGFuZ2VkIGl0cyB2YWx1ZSBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUsIFxcYCR7dmFsdWV9XFxgLCB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgYW4gYHtAaHRtbCAuLi59YCBibG9jayAlbG9jYXRpb24lIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25faHRtbF9jaGFuZ2VkKGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRgJWNbc3ZlbHRlXSBoeWRyYXRpb25faHRtbF9jaGFuZ2VkXFxuJWMke2xvY2F0aW9uXG5cdFx0XHRcdD8gYFRoZSB2YWx1ZSBvZiBhbiBcXGB7QGh0bWwgLi4ufVxcYCBibG9jayAke2xvY2F0aW9ufSBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVgXG5cdFx0XHRcdDogJ1RoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZSd9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2h0bWxfY2hhbmdlZGAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9odG1sX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAlbG9jYXRpb24lXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9taXNtYXRjaChsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX21pc21hdGNoXFxuJWMke2xvY2F0aW9uXG5cdFx0XHRcdD8gYEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAke2xvY2F0aW9ufWBcblx0XHRcdFx0OiAnSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXInfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGByZW5kZXJgIGZ1bmN0aW9uIHBhc3NlZCB0byBgY3JlYXRlUmF3U25pcHBldGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlclxcbiVjVGhlIFxcYHJlbmRlclxcYCBmdW5jdGlvbiBwYXNzZWQgdG8gXFxgY3JlYXRlUmF3U25pcHBldFxcYCBzaG91bGQgcmV0dXJuIEhUTUwgZm9yIGEgc2luZ2xlIGVsZW1lbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmApO1xuXHR9XG59XG5cbi8qKlxuICogRGV0ZWN0ZWQgYSBtaWdyYXRlZCBgJDpgIHJlYWN0aXZlIGJsb2NrIGluIGAlZmlsZW5hbWUlYCB0aGF0IGJvdGggYWNjZXNzZXMgYW5kIHVwZGF0ZXMgdGhlIHNhbWUgcmVhY3RpdmUgdmFsdWUuIFRoaXMgbWF5IGNhdXNlIHJlY3Vyc2l2ZSB1cGRhdGVzIHdoZW4gY29udmVydGVkIHRvIGFuIGAkZWZmZWN0YC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9jayhmaWxlbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tcXG4lY0RldGVjdGVkIGEgbWlncmF0ZWQgXFxgJDpcXGAgcmVhY3RpdmUgYmxvY2sgaW4gXFxgJHtmaWxlbmFtZX1cXGAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBcXGAkZWZmZWN0XFxgLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9ja2ApO1xuXHR9XG59XG5cbi8qKlxuICogVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudFxcbiVjVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9kb3VibGVfdW5tb3VudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgKTtcblx0fVxufVxuXG4vKipcbiAqICVwYXJlbnQlIHBhc3NlZCBwcm9wZXJ0eSBgJXByb3AlYCB0byAlY2hpbGQlIHdpdGggYGJpbmQ6YCwgYnV0IGl0cyBwYXJlbnQgY29tcG9uZW50ICVvd25lciUgZGlkIG5vdCBkZWNsYXJlIGAlcHJvcCVgIGFzIGEgYmluZGluZy4gQ29uc2lkZXIgY3JlYXRpbmcgYSBiaW5kaW5nIGJldHdlZW4gJW93bmVyJSBhbmQgJXBhcmVudCUgKGUuZy4gYGJpbmQ6JXByb3AlPXsuLi59YCBpbnN0ZWFkIG9mIGAlcHJvcCU9ey4uLn1gKVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZFxuICogQHBhcmFtIHtzdHJpbmd9IG93bmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nKHBhcmVudCwgcHJvcCwgY2hpbGQsIG93bmVyKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ1xcbiVjJHtwYXJlbnR9IHBhc3NlZCBwcm9wZXJ0eSBcXGAke3Byb3B9XFxgIHRvICR7Y2hpbGR9IHdpdGggXFxgYmluZDpcXGAsIGJ1dCBpdHMgcGFyZW50IGNvbXBvbmVudCAke293bmVyfSBkaWQgbm90IGRlY2xhcmUgXFxgJHtwcm9wfVxcYCBhcyBhIGJpbmRpbmcuIENvbnNpZGVyIGNyZWF0aW5nIGEgYmluZGluZyBiZXR3ZWVuICR7b3duZXJ9IGFuZCAke3BhcmVudH0gKGUuZy4gXFxgYmluZDoke3Byb3B9PXsuLi59XFxgIGluc3RlYWQgb2YgXFxgJHtwcm9wfT17Li4ufVxcYClcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdgKTtcblx0fVxufVxuXG4vKipcbiAqIE11dGF0aW5nIHVuYm91bmQgcHJvcHMgKGAlbmFtZSVgLCBhdCAlbG9jYXRpb24lKSBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgdXNpbmcgYGJpbmQ6JXByb3AlPXsuLi59YCBpbiAlcGFyZW50JSAob3IgdXNpbmcgYSBjYWxsYmFjaykgaW5zdGVhZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKG5hbWUsIGxvY2F0aW9uLCBwcm9wLCBwYXJlbnQpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvblxcbiVjTXV0YXRpbmcgdW5ib3VuZCBwcm9wcyAoXFxgJHtuYW1lfVxcYCwgYXQgJHtsb2NhdGlvbn0pIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBDb25zaWRlciB1c2luZyBcXGBiaW5kOiR7cHJvcH09ey4uLn1cXGAgaW4gJHtwYXJlbnR9IChvciB1c2luZyBhIGNhbGxiYWNrKSBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25gLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25gKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIGEgYDxzZWxlY3QgbXVsdGlwbGU+YCBlbGVtZW50IHNob3VsZCBiZSBhbiBhcnJheSwgYnV0IGl0IHJlY2VpdmVkIGEgbm9uLWFycmF5IHZhbHVlLiBUaGUgc2VsZWN0aW9uIHdpbGwgYmUga2VwdCBhcyBpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHNlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlXFxuJWNUaGUgXFxgdmFsdWVcXGAgcHJvcGVydHkgb2YgYSBcXGA8c2VsZWN0IG11bHRpcGxlPlxcYCBlbGVtZW50IHNob3VsZCBiZSBhbiBhcnJheSwgYnV0IGl0IHJlY2VpdmVkIGEgbm9uLWFycmF5IHZhbHVlLiBUaGUgc2VsZWN0aW9uIHdpbGwgYmUga2VwdCBhcyBpcy5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogUmVhY3RpdmUgYCRzdGF0ZSguLi4pYCBwcm94aWVzIGFuZCB0aGUgdmFsdWVzIHRoZXkgcHJveHkgaGF2ZSBkaWZmZXJlbnQgaWRlbnRpdGllcy4gQmVjYXVzZSBvZiB0aGlzLCBjb21wYXJpc29ucyB3aXRoIGAlb3BlcmF0b3IlYCB3aWxsIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKG9wZXJhdG9yKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hcXG4lY1JlYWN0aXZlIFxcYCRzdGF0ZSguLi4pXFxgIHByb3hpZXMgYW5kIHRoZSB2YWx1ZXMgdGhleSBwcm94eSBoYXZlIGRpZmZlcmVudCBpZGVudGl0aWVzLiBCZWNhdXNlIG9mIHRoaXMsIGNvbXBhcmlzb25zIHdpdGggXFxgJHtvcGVyYXRvcn1cXGAgd2lsbCBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0c1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUcmllZCB0byB1bm1vdW50IGEgc3RhdGUgcHJveHksIHJhdGhlciB0aGFuIGEgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9wcm94eV91bm1vdW50KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHN0YXRlX3Byb3h5X3VubW91bnRcXG4lY1RyaWVkIHRvIHVubW91bnQgYSBzdGF0ZSBwcm94eSwgcmF0aGVyIHRoYW4gYSBjb21wb25lbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm94eV91bm1vdW50YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X3VubW91bnRgKTtcblx0fVxufVxuXG4vKipcbiAqIEEgYDxzdmVsdGU6Ym91bmRhcnk+YCBgcmVzZXRgIGZ1bmN0aW9uIG9ubHkgcmVzZXRzIHRoZSBib3VuZGFyeSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wXFxuJWNBIFxcYDxzdmVsdGU6Ym91bmRhcnk+XFxgIFxcYHJlc2V0XFxgIGZ1bmN0aW9uIG9ubHkgcmVzZXRzIHRoZSBib3VuZGFyeSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfYm91bmRhcnlfcmVzZXRfbm9vcGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfYm91bmRhcnlfcmVzZXRfbm9vcGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGBzbGlkZWAgdHJhbnNpdGlvbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSBmb3IgZWxlbWVudHMgd2l0aCBgZGlzcGxheTogJXZhbHVlJWBcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5KHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5XFxuJWNUaGUgXFxgc2xpZGVcXGAgdHJhbnNpdGlvbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSBmb3IgZWxlbWVudHMgd2l0aCBcXGBkaXNwbGF5OiAke3ZhbHVlfVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3RyYW5zaXRpb25fc2xpZGVfZGlzcGxheWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS90cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXlgKTtcblx0fVxufSIsIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cblxuaW1wb3J0IHsgQ09NTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHtcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX0VSUk9SLFxuXHRIWURSQVRJT05fU1RBUlQsXG5cdEhZRFJBVElPTl9TVEFSVF9FTFNFXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIFVzZSB0aGlzIHZhcmlhYmxlIHRvIGd1YXJkIGV2ZXJ5dGhpbmcgcmVsYXRlZCB0byBoeWRyYXRpb24gY29kZSBzbyBpdCBjYW4gYmUgdHJlZXNoYWtlbiBvdXRcbiAqIGlmIHRoZSB1c2VyIGRvZXNuJ3QgdXNlIHRoZSBgaHlkcmF0ZWAgbWV0aG9kIGFuZCB0aGVzZSBjb2RlIHBhdGhzIGFyZSB0aGVyZWZvcmUgbm90IG5lZWRlZC5cbiAqL1xuZXhwb3J0IGxldCBoeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0aW5nKHZhbHVlKSB7XG5cdGh5ZHJhdGluZyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBub2RlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGh5ZHJhdGVkLiBUaGlzIHN0YXJ0cyBvdXQgYXMgdGhlIGZpcnN0IG5vZGUgaW5zaWRlIHRoZSBvcGVuaW5nXG4gKiA8IS0tWy0tPiBjb21tZW50LCBhbmQgdXBkYXRlcyBlYWNoIHRpbWUgYSBjb21wb25lbnQgY2FsbHMgYCQuY2hpbGQoLi4uKWAgb3IgYCQuc2libGluZyguLi4pYC5cbiAqIFdoZW4gZW50ZXJpbmcgYSBibG9jayAoZS5nLiBgeyNpZiAuLi59YCksIGBoeWRyYXRlX25vZGVgIGlzIHRoZSBibG9jayBvcGVuaW5nIGNvbW1lbnQ7IGJ5IHRoZVxuICogdGltZSB3ZSBsZWF2ZSB0aGUgYmxvY2sgaXQgaXMgdGhlIGNsb3NpbmcgY29tbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBibG9jaydzIGFuY2hvci5cbiAqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9XG4gKi9cbmV4cG9ydCBsZXQgaHlkcmF0ZV9ub2RlO1xuXG4vKiogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0ZV9ub2RlKG5vZGUpIHtcblx0aWYgKG5vZGUgPT09IG51bGwpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdHJldHVybiAoaHlkcmF0ZV9ub2RlID0gbm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX25leHQoKSB7XG5cdHJldHVybiBzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhoeWRyYXRlX25vZGUpKSk7XG59XG5cbi8qKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KG5vZGUpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHQvLyBJZiB0aGUgbm9kZSBoYXMgcmVtYWluaW5nIHNpYmxpbmdzLCBzb21ldGhpbmcgaGFzIGdvbmUgd3Jvbmdcblx0aWYgKGdldF9uZXh0X3NpYmxpbmcoaHlkcmF0ZV9ub2RlKSAhPT0gbnVsbCkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX3RlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRlbXBsYXRlTm9kZSBkb2Vzbid0IGluY2x1ZGUgRG9jdW1lbnRGcmFnbWVudCwgYnV0IGl0J3MgYWN0dWFsbHkgZmluZVxuXHRcdGh5ZHJhdGVfbm9kZSA9IHRlbXBsYXRlLmNvbnRlbnQ7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHQoY291bnQgPSAxKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHR2YXIgaSA9IGNvdW50O1xuXHRcdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0fVxuXG5cdFx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIFNraXBzIG9yIHJlbW92ZXMgKGRlcGVuZGluZyBvbiB7QGxpbmsgcmVtb3ZlfSkgYWxsIG5vZGVzIHN0YXJ0aW5nIGF0IGBoeWRyYXRlX25vZGVgIHVwIHVudGlsIHRoZSBuZXh0IGh5ZHJhdGlvbiBlbmQgY29tbWVudFxuICogQHBhcmFtIHtib29sZWFufSByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNraXBfbm9kZXMocmVtb3ZlID0gdHJ1ZSkge1xuXHR2YXIgZGVwdGggPSAwO1xuXHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcblx0XHRcdHZhciBkYXRhID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSkuZGF0YTtcblxuXHRcdFx0aWYgKGRhdGEgPT09IEhZRFJBVElPTl9FTkQpIHtcblx0XHRcdFx0aWYgKGRlcHRoID09PSAwKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0ZGVwdGggLT0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKSB7XG5cdFx0XHRcdGRlcHRoICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdGlmIChyZW1vdmUpIG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uKG5vZGUpIHtcblx0aWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0cmV0dXJuIC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpLmRhdGE7XG59XG4iLCIvKiogQGltcG9ydCB7IEVxdWFscyB9IGZyb20gJyNjbGllbnQnICovXG5cbi8qKiBAdHlwZSB7RXF1YWxzfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHRoaXMudjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGFcblx0XHQ/IGIgPT0gYlxuXHRcdDogYSAhPT0gYiB8fCAoYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gYVxuICogQHBhcmFtIHt1bmtub3dufSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9PSBiO1xufVxuXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX2VxdWFscyh2YWx1ZSkge1xuXHRyZXR1cm4gIXNhZmVfbm90X2VxdWFsKHZhbHVlLCB0aGlzLnYpO1xufVxuIiwiZXhwb3J0IGxldCBhc3luY19tb2RlX2ZsYWcgPSBmYWxzZTtcbmV4cG9ydCBsZXQgbGVnYWN5X21vZGVfZmxhZyA9IGZhbHNlO1xuZXhwb3J0IGxldCB0cmFjaW5nX21vZGVfZmxhZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX2FzeW5jX21vZGVfZmxhZygpIHtcblx0YXN5bmNfbW9kZV9mbGFnID0gdHJ1ZTtcbn1cblxuLyoqIE9OTFkgVVNFIFRISVMgRFVSSU5HIFRFU1RJTkcgKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlX2FzeW5jX21vZGVfZmxhZygpIHtcblx0YXN5bmNfbW9kZV9mbGFnID0gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVfbGVnYWN5X21vZGVfZmxhZygpIHtcblx0bGVnYWN5X21vZGVfZmxhZyA9IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVfdHJhY2luZ19tb2RlX2ZsYWcoKSB7XG5cdHRyYWNpbmdfbW9kZV9mbGFnID0gdHJ1ZTtcbn1cbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJXRhZyVcIj5gIGlzIGEgdm9pZCBlbGVtZW50IOKAlCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50KHRhZykge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGR5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRcXG4lY1xcYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+XFxgIGlzIGEgdm9pZCBlbGVtZW50IOKAlCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9keW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIOKAlCB0aGUgcmV0dXJuIHZhbHVlIGNvbnRhaW5zIHRoZSBvcmlnaW5hbHM6XG4gKiBcbiAqICVwcm9wZXJ0aWVzJVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbcHJvcGVydGllc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHByb3BlcnRpZXMpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlXFxuJWMke3Byb3BlcnRpZXNcblx0XHRcdFx0PyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBcXGAkc3RhdGUuc25hcHNob3RcXGAg4oCUIHRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgdGhlIG9yaWdpbmFsczpcblxuJHtwcm9wZXJ0aWVzfWBcblx0XHRcdFx0OiAnVmFsdWUgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIOKAlCB0aGUgb3JpZ2luYWwgdmFsdWUgd2FzIHJldHVybmVkJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlYCk7XG5cdH1cbn0iLCIvKiogQGltcG9ydCB7IFNuYXBzaG90IH0gZnJvbSAnLi90eXBlcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9wcm90b3R5cGVfb2YsIGlzX2FycmF5LCBvYmplY3RfcHJvdG90eXBlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qKlxuICogSW4gZGV2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIHByb3BlcnRpZXMgY291bGQgbm90IGJlIGNsb25lZC4gSW4gcHJvZFxuICogd2UgZG9uJ3QgYm90aGVyLCBidXQgd2Uga2VlcCBhIGR1bW15IGFycmF5IGFyb3VuZCBzbyB0aGF0IHRoZVxuICogc2lnbmF0dXJlIHN0YXlzIHRoZSBzYW1lXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IGVtcHR5ID0gW107XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vX3RvanNvbl1cbiAqIEByZXR1cm5zIHtTbmFwc2hvdDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXBzaG90KHZhbHVlLCBza2lwX3dhcm5pbmcgPSBmYWxzZSwgbm9fdG9qc29uID0gZmFsc2UpIHtcblx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblx0XHRjb25zdCBwYXRocyA9IFtdO1xuXG5cdFx0Y29uc3QgY29weSA9IGNsb25lKHZhbHVlLCBuZXcgTWFwKCksICcnLCBwYXRocywgbnVsbCwgbm9fdG9qc29uKTtcblx0XHRpZiAocGF0aHMubGVuZ3RoID09PSAxICYmIHBhdGhzWzBdID09PSAnJykge1xuXHRcdFx0Ly8gdmFsdWUgY291bGQgbm90IGJlIGNsb25lZFxuXHRcdFx0dy5zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZSgpO1xuXHRcdH0gZWxzZSBpZiAocGF0aHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Ly8gc29tZSBwcm9wZXJ0aWVzIGNvdWxkIG5vdCBiZSBjbG9uZWRcblx0XHRcdGNvbnN0IHNsaWNlID0gcGF0aHMubGVuZ3RoID4gMTAgPyBwYXRocy5zbGljZSgwLCA3KSA6IHBhdGhzLnNsaWNlKDAsIDEwKTtcblx0XHRcdGNvbnN0IGV4Y2VzcyA9IHBhdGhzLmxlbmd0aCAtIHNsaWNlLmxlbmd0aDtcblxuXHRcdFx0bGV0IHVuY2xvbmVkID0gc2xpY2UubWFwKChwYXRoKSA9PiBgLSA8dmFsdWU+JHtwYXRofWApLmpvaW4oJ1xcbicpO1xuXHRcdFx0aWYgKGV4Y2VzcyA+IDApIHVuY2xvbmVkICs9IGBcXG4tIC4uLmFuZCAke2V4Y2Vzc30gbW9yZWA7XG5cblx0XHRcdHcuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUodW5jbG9uZWQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb3B5O1xuXHR9XG5cblx0cmV0dXJuIGNsb25lKHZhbHVlLCBuZXcgTWFwKCksICcnLCBlbXB0eSwgbnVsbCwgbm9fdG9qc29uKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtNYXA8VCwgU25hcHNob3Q8VD4+fSBjbG9uZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoc1xuICogQHBhcmFtIHtudWxsIHwgVH0gW29yaWdpbmFsXSBUaGUgb3JpZ2luYWwgdmFsdWUsIGlmIGB2YWx1ZWAgd2FzIHByb2R1Y2VkIGZyb20gYSBgdG9KU09OYCBjYWxsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub190b2pzb25dXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlLCBjbG9uZWQsIHBhdGgsIHBhdGhzLCBvcmlnaW5hbCA9IG51bGwsIG5vX3RvanNvbiA9IGZhbHNlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0dmFyIHVud3JhcHBlZCA9IGNsb25lZC5nZXQodmFsdWUpO1xuXHRcdGlmICh1bndyYXBwZWQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHVud3JhcHBlZDtcblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgcmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChuZXcgTWFwKHZhbHVlKSk7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSByZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKG5ldyBTZXQodmFsdWUpKTtcblxuXHRcdGlmIChpc19hcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhciBjb3B5ID0gLyoqIEB0eXBlIHtTbmFwc2hvdDxhbnk+fSAqLyAoQXJyYXkodmFsdWUubGVuZ3RoKSk7XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdmFsdWVbaV07XG5cdFx0XHRcdGlmIChpIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IGNsb25lKGVsZW1lbnQsIGNsb25lZCwgREVWID8gYCR7cGF0aH1bJHtpfV1gIDogcGF0aCwgcGF0aHMsIG51bGwsIG5vX3RvanNvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fVxuXG5cdFx0aWYgKGdldF9wcm90b3R5cGVfb2YodmFsdWUpID09PSBvYmplY3RfcHJvdG90eXBlKSB7XG5cdFx0XHQvKiogQHR5cGUge1NuYXBzaG90PGFueT59ICovXG5cdFx0XHRjb3B5ID0ge307XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0Y29weVtrZXldID0gY2xvbmUoXG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdHZhbHVlW2tleV0sXG5cdFx0XHRcdFx0Y2xvbmVkLFxuXHRcdFx0XHRcdERFViA/IGAke3BhdGh9LiR7a2V5fWAgOiBwYXRoLFxuXHRcdFx0XHRcdHBhdGhzLFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0bm9fdG9qc29uXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiAoLyoqIEB0eXBlIHtUICYgeyB0b0pTT04/OiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKSA9PT0gJ2Z1bmN0aW9uJyAmJiAhbm9fdG9qc29uKSB7XG5cdFx0XHRyZXR1cm4gY2xvbmUoXG5cdFx0XHRcdC8qKiBAdHlwZSB7VCAmIHsgdG9KU09OKCk6IGFueSB9IH0gKi8gKHZhbHVlKS50b0pTT04oKSxcblx0XHRcdFx0Y2xvbmVkLFxuXHRcdFx0XHRERVYgPyBgJHtwYXRofS50b0pTT04oKWAgOiBwYXRoLFxuXHRcdFx0XHRwYXRocyxcblx0XHRcdFx0Ly8gQXNzb2NpYXRlIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSB0b0pTT04gY2xvbmVcblx0XHRcdFx0dmFsdWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcblx0XHQvLyBjYW4ndCBiZSBjbG9uZWRcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHZhbHVlKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovICh2YWx1ZSk7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRGVyaXZlZCwgUmVhY3Rpb24sIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgc25hcHNob3QgfSBmcm9tICcuLi8uLi9zaGFyZWQvY2xvbmUuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IERFUklWRUQsIEFTWU5DLCBQUk9YWV9QQVRIX1NZTUJPTCwgU1RBVEVfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgZWZmZWN0X3RyYWNraW5nIH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9yZWFjdGlvbiwgdW50cmFjayB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHRyYWNlczogRXJyb3JbXTtcbiAqIH19IFRyYWNlRW50cnlcbiAqL1xuXG4vKiogQHR5cGUge3sgcmVhY3Rpb246IFJlYWN0aW9uIHwgbnVsbCwgZW50cmllczogTWFwPFZhbHVlLCBUcmFjZUVudHJ5PiB9IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgdHJhY2luZ19leHByZXNzaW9ucyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge1RyYWNlRW50cnl9IFtlbnRyeV1cbiAqL1xuZnVuY3Rpb24gbG9nX2VudHJ5KHNpZ25hbCwgZW50cnkpIHtcblx0Y29uc3QgdmFsdWUgPSBzaWduYWwudjtcblxuXHRpZiAodmFsdWUgPT09IFVOSU5JVElBTElaRUQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0eXBlID0gZ2V0X3R5cGUoc2lnbmFsKTtcblx0Y29uc3QgY3VycmVudF9yZWFjdGlvbiA9IC8qKiBAdHlwZSB7UmVhY3Rpb259ICovIChhY3RpdmVfcmVhY3Rpb24pO1xuXHRjb25zdCBkaXJ0eSA9IHNpZ25hbC53diA+IGN1cnJlbnRfcmVhY3Rpb24ud3YgfHwgY3VycmVudF9yZWFjdGlvbi53diA9PT0gMDtcblx0Y29uc3Qgc3R5bGUgPSBkaXJ0eVxuXHRcdD8gJ2NvbG9yOiBDb3JuZmxvd2VyQmx1ZTsgZm9udC13ZWlnaHQ6IGJvbGQnXG5cdFx0OiAnY29sb3I6IGdyZXk7IGZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXG5cdFx0c2lnbmFsLmxhYmVsID8gYCVjJHt0eXBlfSVjICR7c2lnbmFsLmxhYmVsfWAgOiBgJWMke3R5cGV9JWNgLFxuXHRcdHN0eWxlLFxuXHRcdGRpcnR5ID8gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnIDogc3R5bGUsXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBTVEFURV9TWU1CT0wgaW4gdmFsdWVcblx0XHRcdD8gc25hcHNob3QodmFsdWUsIHRydWUpXG5cdFx0XHQ6IHZhbHVlXG5cdCk7XG5cblx0aWYgKHR5cGUgPT09ICckZGVyaXZlZCcpIHtcblx0XHRjb25zdCBkZXBzID0gbmV3IFNldCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmRlcHMpO1xuXHRcdGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcblx0XHRcdGxvZ19lbnRyeShkZXApO1xuXHRcdH1cblx0fVxuXG5cdGlmIChzaWduYWwuY3JlYXRlZCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0Y29uc29sZS5sb2coc2lnbmFsLmNyZWF0ZWQpO1xuXHR9XG5cblx0aWYgKGRpcnR5ICYmIHNpZ25hbC51cGRhdGVkKSB7XG5cdFx0Zm9yIChjb25zdCB1cGRhdGVkIG9mIHNpZ25hbC51cGRhdGVkLnZhbHVlcygpKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5sb2codXBkYXRlZC5lcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGVudHJ5KSB7XG5cdFx0Zm9yICh2YXIgdHJhY2Ugb2YgZW50cnkudHJhY2VzKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5sb2codHJhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEByZXR1cm5zIHsnJHN0YXRlJyB8ICckZGVyaXZlZCcgfCAnc3RvcmUnfVxuICovXG5mdW5jdGlvbiBnZXRfdHlwZShzaWduYWwpIHtcblx0aWYgKChzaWduYWwuZiAmIChERVJJVkVEIHwgQVNZTkMpKSAhPT0gMCkgcmV0dXJuICckZGVyaXZlZCc7XG5cdHJldHVybiBzaWduYWwubGFiZWw/LnN0YXJ0c1dpdGgoJyQnKSA/ICdzdG9yZScgOiAnJHN0YXRlJztcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGxhYmVsXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFjZShsYWJlbCwgZm4pIHtcblx0dmFyIHByZXZpb3VzbHlfdHJhY2luZ19leHByZXNzaW9ucyA9IHRyYWNpbmdfZXhwcmVzc2lvbnM7XG5cblx0dHJ5IHtcblx0XHR0cmFjaW5nX2V4cHJlc3Npb25zID0geyBlbnRyaWVzOiBuZXcgTWFwKCksIHJlYWN0aW9uOiBhY3RpdmVfcmVhY3Rpb24gfTtcblxuXHRcdHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHZhciB2YWx1ZSA9IGZuKCk7XG5cdFx0dmFyIHRpbWUgPSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkudG9GaXhlZCgyKTtcblxuXHRcdHZhciBwcmVmaXggPSB1bnRyYWNrKGxhYmVsKTtcblxuXHRcdGlmICghZWZmZWN0X3RyYWNraW5nKCkpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmxvZyhgJHtwcmVmaXh9ICVjcmFuIG91dHNpZGUgb2YgYW4gZWZmZWN0ICgke3RpbWV9bXMpYCwgJ2NvbG9yOiBncmV5Jyk7XG5cdFx0fSBlbHNlIGlmICh0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuc2l6ZSA9PT0gMCkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUubG9nKGAke3ByZWZpeH0gJWNubyByZWFjdGl2ZSBkZXBlbmRlbmNpZXMgKCR7dGltZX1tcylgLCAnY29sb3I6IGdyZXknKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUuZ3JvdXAoYCR7cHJlZml4fSAlYygke3RpbWV9bXMpYCwgJ2NvbG9yOiBncmV5Jyk7XG5cblx0XHRcdHZhciBlbnRyaWVzID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzO1xuXG5cdFx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdFx0Zm9yIChjb25zdCBbc2lnbmFsLCB0cmFjZXNdIG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRsb2dfZW50cnkoc2lnbmFsLCB0cmFjZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dHJhY2luZ19leHByZXNzaW9ucyA9IG51bGw7XG5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmdyb3VwRW5kKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMgPSBwcmV2aW91c2x5X3RyYWNpbmdfZXhwcmVzc2lvbnM7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAqIEByZXR1cm5zIHtFcnJvciAmIHsgc3RhY2s6IHN0cmluZyB9IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9zdGFjayhsYWJlbCkge1xuXHQvLyBAdHMtaWdub3JlIHN0YWNrVHJhY2VMaW1pdCBkb2Vzbid0IGV4aXN0IGV2ZXJ5d2hlcmVcblx0Y29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRFcnJvci5zdGFja1RyYWNlTGltaXQgPSBJbmZpbml0eTtcblx0bGV0IGVycm9yID0gRXJyb3IoKTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuXG5cdGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2s7XG5cblx0aWYgKCFzdGFjaykgcmV0dXJuIG51bGw7XG5cblx0Y29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG5cdGNvbnN0IG5ld19saW5lcyA9IFsnXFxuJ107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcblx0XHRjb25zdCBwb3NpeGlmaWVkID0gbGluZS5yZXBsYWNlQWxsKCdcXFxcJywgJy8nKTtcblxuXHRcdGlmIChsaW5lID09PSAnRXJyb3InKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAobGluZS5pbmNsdWRlcygndmFsaWRhdGVfZWFjaF9rZXlzJykpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChwb3NpeGlmaWVkLmluY2x1ZGVzKCdzdmVsdGUvc3JjL2ludGVybmFsJykgfHwgcG9zaXhpZmllZC5pbmNsdWRlcygnbm9kZV9tb2R1bGVzLy52aXRlJykpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdG5ld19saW5lcy5wdXNoKGxpbmUpO1xuXHR9XG5cblx0aWYgKG5ld19saW5lcy5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywge1xuXHRcdHZhbHVlOiBuZXdfbGluZXMuam9pbignXFxuJylcblx0fSk7XG5cblx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnbmFtZScsIHtcblx0XHR2YWx1ZTogbGFiZWxcblx0fSk7XG5cblx0cmV0dXJuIC8qKiBAdHlwZSB7RXJyb3IgJiB7IHN0YWNrOiBzdHJpbmcgfX0gKi8gKGVycm9yKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFnKHNvdXJjZSwgbGFiZWwpIHtcblx0c291cmNlLmxhYmVsID0gbGFiZWw7XG5cdHRhZ19wcm94eShzb3VyY2UudiwgbGFiZWwpO1xuXG5cdHJldHVybiBzb3VyY2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWdfcHJveHkodmFsdWUsIGxhYmVsKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0dmFsdWU/LltQUk9YWV9QQVRIX1NZTUJPTF0/LihsYWJlbCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykgcmV0dXJuIGBTeW1ib2woJHt2YWx1ZS5kZXNjcmlwdGlvbn0pYDtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuICc8ZnVuY3Rpb24+Jztcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHJldHVybiAnPG9iamVjdD4nO1xuXHRyZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgRGV2U3RhY2tFbnRyeSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24gfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3VzZXJfZWZmZWN0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQlJBTkNIX0VGRkVDVCwgRUZGRUNUX1JBTiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY29tcG9uZW50X2NvbnRleHQgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29udGV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jb21wb25lbnRfY29udGV4dChjb250ZXh0KSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqIEB0eXBlIHtEZXZTdGFja0VudHJ5IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgZGV2X3N0YWNrID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7RGV2U3RhY2tFbnRyeSB8IG51bGx9IHN0YWNrICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9zdGFjayhzdGFjaykge1xuXHRkZXZfc3RhY2sgPSBzdGFjaztcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgd2l0aCBhIG5ldyBkZXYgc3RhY2sgZW50cnlcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7RGV2U3RhY2tFbnRyeVsndHlwZSddfSB0eXBlIC0gVHlwZSBvZiBibG9jay9jb21wb25lbnRcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnQgLSBDb21wb25lbnQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIC0gTGluZSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gbnVtYmVyXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFthZGRpdGlvbmFsXSAtIEFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBkZXYgc3RhY2sgZW50cnlcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfc3ZlbHRlX21ldGEoY2FsbGJhY2ssIHR5cGUsIGNvbXBvbmVudCwgbGluZSwgY29sdW1uLCBhZGRpdGlvbmFsKSB7XG5cdGNvbnN0IHBhcmVudCA9IGRldl9zdGFjaztcblxuXHRkZXZfc3RhY2sgPSB7XG5cdFx0dHlwZSxcblx0XHRmaWxlOiBjb21wb25lbnRbRklMRU5BTUVdLFxuXHRcdGxpbmUsXG5cdFx0Y29sdW1uLFxuXHRcdHBhcmVudCxcblx0XHQuLi5hZGRpdGlvbmFsXG5cdH07XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcblx0fSBmaW5hbGx5IHtcblx0XHRkZXZfc3RhY2sgPSBwYXJlbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGN1cnJlbnQgY29tcG9uZW50IGNvbnRleHQ6XG4gKiBgYGBodG1sXG4gKiA8IS0tIEFwcC5zdmVsdGUgLS0+XG4gKiA8Rm9vPlxuICogICA8QmFyIC8+IDwhLS0gY29udGV4dCA9PSBGb28uc3ZlbHRlLCBmdW5jdGlvbiA9PSBBcHAuc3ZlbHRlIC0tPlxuICogPC9Gb28+XG4gKiBgYGBcbiAqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfVxuICovXG5leHBvcnQgbGV0IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRbJ2Z1bmN0aW9uJ119IGZuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihmbikge1xuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBmbjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYFtnZXQsIHNldF1gIHBhaXIgb2YgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggY29udGV4dCBpbiBhIHR5cGUtc2FmZSB3YXkuXG4gKlxuICogYGdldGAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBubyBwYXJlbnQgY29tcG9uZW50IGNhbGxlZCBgc2V0YC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHJldHVybnMge1soKSA9PiBULCAoY29udGV4dDogVCkgPT4gVF19XG4gKiBAc2luY2UgNS40MC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuXHRjb25zdCBrZXkgPSB7fTtcblxuXHRyZXR1cm4gW1xuXHRcdCgpID0+IHtcblx0XHRcdGlmICghaGFzQ29udGV4dChrZXkpKSB7XG5cdFx0XHRcdGUubWlzc2luZ19jb250ZXh0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZXRDb250ZXh0KGtleSk7XG5cdFx0fSxcblx0XHQoY29udGV4dCkgPT4gc2V0Q29udGV4dChrZXksIGNvbnRleHQpXG5cdF07XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogW2BjcmVhdGVDb250ZXh0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3N2ZWx0ZSNjcmVhdGVDb250ZXh0KSBpcyBhIHR5cGUtc2FmZSBhbHRlcm5hdGl2ZS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRDb250ZXh0Jyk7XG5cdGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7VH0gKi8gKGNvbnRleHRfbWFwLmdldChrZXkpKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIFtgY3JlYXRlQ29udGV4dGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUjY3JlYXRlQ29udGV4dCkgaXMgYSB0eXBlLXNhZmUgYWx0ZXJuYXRpdmUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdzZXRDb250ZXh0Jyk7XG5cblx0aWYgKGFzeW5jX21vZGVfZmxhZykge1xuXHRcdHZhciBmbGFncyA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZjtcblx0XHR2YXIgdmFsaWQgPVxuXHRcdFx0IWFjdGl2ZV9yZWFjdGlvbiAmJlxuXHRcdFx0KGZsYWdzICYgQlJBTkNIX0VGRkVDVCkgIT09IDAgJiZcblx0XHRcdC8vIHBvcCgpIHJ1bnMgc3luY2hyb25vdXNseSwgc28gdGhpcyBpbmRpY2F0ZXMgd2UncmUgc2V0dGluZyBjb250ZXh0IGFmdGVyIGFuIGF3YWl0XG5cdFx0XHQhKC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KS5pKTtcblxuXHRcdGlmICghdmFsaWQpIHtcblx0XHRcdGUuc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdCgpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnRleHRfbWFwLnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnaGFzQ29udGV4dCcpO1xuXHRyZXR1cm4gY29udGV4dF9tYXAuaGFzKGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRBbGxDb250ZXh0cycpO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge2FueX0gcnVuZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaChwcm9wcywgcnVuZXMgPSBmYWxzZSwgZm4pIHtcblx0Y29tcG9uZW50X2NvbnRleHQgPSB7XG5cdFx0cDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0aTogZmFsc2UsXG5cdFx0YzogbnVsbCxcblx0XHRlOiBudWxsLFxuXHRcdHM6IHByb3BzLFxuXHRcdHg6IG51bGwsXG5cdFx0bDogbGVnYWN5X21vZGVfZmxhZyAmJiAhcnVuZXMgPyB7IHM6IG51bGwsIHU6IG51bGwsICQ6IFtdIH0gOiBudWxsXG5cdH07XG5cblx0aWYgKERFVikge1xuXHRcdC8vIGNvbXBvbmVudCBmdW5jdGlvblxuXHRcdGNvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uID0gZm47XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFRcbiAqIEBwYXJhbSB7VH0gW2NvbXBvbmVudF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wKGNvbXBvbmVudCkge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblx0dmFyIGVmZmVjdHMgPSBjb250ZXh0LmU7XG5cblx0aWYgKGVmZmVjdHMgIT09IG51bGwpIHtcblx0XHRjb250ZXh0LmUgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgZm4gb2YgZWZmZWN0cykge1xuXHRcdFx0Y3JlYXRlX3VzZXJfZWZmZWN0KGZuKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29tcG9uZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb250ZXh0LnggPSBjb21wb25lbnQ7XG5cdH1cblxuXHRjb250ZXh0LmkgPSB0cnVlO1xuXG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dC5wO1xuXG5cdGlmIChERVYpIHtcblx0XHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBjb21wb25lbnRfY29udGV4dD8uZnVuY3Rpb24gPz8gbnVsbDtcblx0fVxuXG5cdHJldHVybiBjb21wb25lbnQgPz8gLyoqIEB0eXBlIHtUfSAqLyAoe30pO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZXMoKSB7XG5cdHJldHVybiAhbGVnYWN5X21vZGVfZmxhZyB8fCAoY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtNYXA8dW5rbm93biwgdW5rbm93bj59XG4gKi9cbmZ1bmN0aW9uIGdldF9vcl9pbml0X2NvbnRleHRfbWFwKG5hbWUpIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gKGNvbXBvbmVudF9jb250ZXh0LmMgPz89IG5ldyBNYXAoZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB8fCB1bmRlZmluZWQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHR9IGNvbXBvbmVudF9jb250ZXh0XG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB7XG5cdGxldCBwYXJlbnQgPSBjb21wb25lbnRfY29udGV4dC5wO1xuXHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgY29udGV4dF9tYXAgPSBwYXJlbnQuYztcblx0XHRpZiAoY29udGV4dF9tYXAgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBjb250ZXh0X21hcDtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnA7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGlzX2ZsdXNoaW5nX3N5bmMgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLyoqIEB0eXBlIHtBcnJheTwoKSA9PiB2b2lkPn0gKi9cbmxldCBtaWNyb190YXNrcyA9IFtdO1xuXG5mdW5jdGlvbiBydW5fbWljcm9fdGFza3MoKSB7XG5cdHZhciB0YXNrcyA9IG1pY3JvX3Rhc2tzO1xuXHRtaWNyb190YXNrcyA9IFtdO1xuXHRydW5fYWxsKHRhc2tzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWV1ZV9taWNyb190YXNrKGZuKSB7XG5cdGlmIChtaWNyb190YXNrcy5sZW5ndGggPT09IDAgJiYgIWlzX2ZsdXNoaW5nX3N5bmMpIHtcblx0XHR2YXIgdGFza3MgPSBtaWNyb190YXNrcztcblx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGZhbHNlLCBhIGZsdXNoU3luYyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUuIERvIF9ub3RfIHJ1biBuZXcgc2NoZWR1bGVkIG1pY3JvdGFza3MgaW4gdGhhdCBjYXNlXG5cdFx0XHQvLyBhcyB0aGUgb3JkZXJpbmcgb2YgbWljcm90YXNrcyB3b3VsZCBiZSBicm9rZW4gYXQgdGhhdCBwb2ludCAtIGNvbnNpZGVyIHRoaXMgY2FzZTpcblx0XHRcdC8vIC0gcXVldWVfbWljcm9fdGFzayBzY2hlZHVsZXMgbWljcm90YXNrIEEgdG8gZmx1c2ggdGFzayBYXG5cdFx0XHQvLyAtIHN5bmNocm9ub3VzbHkgYWZ0ZXIsIGZsdXNoU3luYyBydW5zLCBwcm9jZXNzaW5nIHRhc2sgWFxuXHRcdFx0Ly8gLSBzeW5jaHJvbm91c2x5IGFmdGVyLCBzb21lIG90aGVyIG1pY3JvdGFzayBCIGlzIHNjaGVkdWxlZCwgYnV0IG5vdCB0aHJvdWdoIHF1ZXVlX21pY3JvX3Rhc2sgYnV0IGZvciBleGFtcGxlIGEgUHJvbWlzZS5yZXNvbHZlKCkgaW4gdXNlciBjb2RlXG5cdFx0XHQvLyAtIHN5bmNocm9ub3VzbHkgYWZ0ZXIsIHF1ZXVlX21pY3JvX3Rhc2sgc2NoZWR1bGVzIG1pY3JvdGFzayBDIHRvIGZsdXNoIHRhc2sgWVxuXHRcdFx0Ly8gLSBvbmUgdGljayBsYXRlciwgbWljcm90YXNrIEEgbm93IHJlc29sdmVzLCBmbHVzaGluZyB0YXNrIFkgYmVmb3JlIG1pY3JvdGFzayBCLCB3aGljaCBpcyBpbmNvcnJlY3Rcblx0XHRcdC8vIFRoaXMgaWYgY2hlY2sgcHJldmVudHMgdGhhdCByYWNlIGNvbmRpdGlvbiAodGhhdCByZWFsaXN0aWNhbGx5IHdpbGwgb25seSBoYXBwZW4gaW4gdGVzdHMpXG5cdFx0XHRpZiAodGFza3MgPT09IG1pY3JvX3Rhc2tzKSBydW5fbWljcm9fdGFza3MoKTtcblx0XHR9KTtcblx0fVxuXG5cdG1pY3JvX3Rhc2tzLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgcnVuIGFueSBxdWV1ZWQgdGFza3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF90YXNrcygpIHtcblx0d2hpbGUgKG1pY3JvX3Rhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRydW5fbWljcm9fdGFza3MoKTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBCb3VuZGFyeSB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaXNfZmlyZWZveCB9IGZyb20gJy4vZG9tL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgRVJST1JfVkFMVUUsIEJPVU5EQVJZX0VGRkVDVCwgRUZGRUNUX1JBTiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgZ2V0X2Rlc2NyaXB0b3IgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCwgYWN0aXZlX3JlYWN0aW9uIH0gZnJvbSAnLi9ydW50aW1lLmpzJztcblxuY29uc3QgYWRqdXN0bWVudHMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9lcnJvcihlcnJvcikge1xuXHR2YXIgZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHQvLyBmb3IgdW5vd25lZCBkZXJpdmVkcywgZG9uJ3QgdGhyb3cgdW50aWwgd2UgcmVhZCB0aGUgdmFsdWVcblx0aWYgKGVmZmVjdCA9PT0gbnVsbCkge1xuXHRcdC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGFjdGl2ZV9yZWFjdGlvbikuZiB8PSBFUlJPUl9WQUxVRTtcblx0XHRyZXR1cm4gZXJyb3I7XG5cdH1cblxuXHRpZiAoREVWICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIWFkanVzdG1lbnRzLmhhcyhlcnJvcikpIHtcblx0XHRhZGp1c3RtZW50cy5zZXQoZXJyb3IsIGdldF9hZGp1c3RtZW50cyhlcnJvciwgZWZmZWN0KSk7XG5cdH1cblxuXHRpZiAoKGVmZmVjdC5mICYgRUZGRUNUX1JBTikgPT09IDApIHtcblx0XHQvLyBpZiB0aGUgZXJyb3Igb2NjdXJyZWQgd2hpbGUgY3JlYXRpbmcgdGhpcyBzdWJ0cmVlLCB3ZSBsZXQgaXRcblx0XHQvLyBidWJibGUgdXAgdW50aWwgaXQgaGl0cyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSBpdFxuXHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpID09PSAwKSB7XG5cdFx0XHRpZiAoREVWICYmICFlZmZlY3QucGFyZW50ICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0YXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoZWZmZWN0LmIpLmVycm9yKGVycm9yKTtcblx0fSBlbHNlIHtcblx0XHQvLyBvdGhlcndpc2Ugd2UgYnViYmxlIHVwIHRoZSBlZmZlY3QgdHJlZSBvdXJzZWx2ZXNcblx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGVmZmVjdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdCB8IG51bGx9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBlZmZlY3QpIHtcblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoZWZmZWN0LmIpLmVycm9yKGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0fVxuXG5cdGlmIChERVYgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdGFwcGx5X2FkanVzdG1lbnRzKGVycm9yKTtcblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIEFkZCB1c2VmdWwgaW5mb3JtYXRpb24gdG8gdGhlIGVycm9yIG1lc3NhZ2Uvc3RhY2sgaW4gZGV2ZWxvcG1lbnRcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIGdldF9hZGp1c3RtZW50cyhlcnJvciwgZWZmZWN0KSB7XG5cdGNvbnN0IG1lc3NhZ2VfZGVzY3JpcHRvciA9IGdldF9kZXNjcmlwdG9yKGVycm9yLCAnbWVzc2FnZScpO1xuXG5cdC8vIGlmIHRoZSBtZXNzYWdlIHdhcyBhbHJlYWR5IGNoYW5nZWQgYW5kIGl0J3Mgbm90IGNvbmZpZ3VyYWJsZSB3ZSBjYW4ndCBjaGFuZ2UgaXRcblx0Ly8gb3IgaXQgd2lsbCB0aHJvdyBhIGRpZmZlcmVudCBlcnJvciBzd2FsbG93aW5nIHRoZSBvcmlnaW5hbCBlcnJvclxuXHRpZiAobWVzc2FnZV9kZXNjcmlwdG9yICYmICFtZXNzYWdlX2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlKSByZXR1cm47XG5cblx0dmFyIGluZGVudCA9IGlzX2ZpcmVmb3ggPyAnICAnIDogJ1xcdCc7XG5cdHZhciBjb21wb25lbnRfc3RhY2sgPSBgXFxuJHtpbmRlbnR9aW4gJHtlZmZlY3QuZm4/Lm5hbWUgfHwgJzx1bmtub3duPid9YDtcblx0dmFyIGNvbnRleHQgPSBlZmZlY3QuY3R4O1xuXG5cdHdoaWxlIChjb250ZXh0ICE9PSBudWxsKSB7XG5cdFx0Y29tcG9uZW50X3N0YWNrICs9IGBcXG4ke2luZGVudH1pbiAke2NvbnRleHQuZnVuY3Rpb24/LltGSUxFTkFNRV0uc3BsaXQoJy8nKS5wb3AoKX1gO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0LnA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgKyBgXFxuJHtjb21wb25lbnRfc3RhY2t9XFxuYCxcblx0XHRzdGFjazogZXJyb3Iuc3RhY2tcblx0XHRcdD8uc3BsaXQoJ1xcbicpXG5cdFx0XHQuZmlsdGVyKChsaW5lKSA9PiAhbGluZS5pbmNsdWRlcygnc3ZlbHRlL3NyYy9pbnRlcm5hbCcpKVxuXHRcdFx0LmpvaW4oJ1xcbicpXG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqL1xuZnVuY3Rpb24gYXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpIHtcblx0Y29uc3QgYWRqdXN0ZWQgPSBhZGp1c3RtZW50cy5nZXQoZXJyb3IpO1xuXG5cdGlmIChhZGp1c3RlZCkge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ21lc3NhZ2UnLCB7XG5cdFx0XHR2YWx1ZTogYWRqdXN0ZWQubWVzc2FnZVxuXHRcdH0pO1xuXG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnc3RhY2snLCB7XG5cdFx0XHR2YWx1ZTogYWRqdXN0ZWQuc3RhY2tcblx0XHR9KTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBGb3JrIH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTb3VyY2UsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7XG5cdEJMT0NLX0VGRkVDVCxcblx0QlJBTkNIX0VGRkVDVCxcblx0Q0xFQU4sXG5cdERFU1RST1lFRCxcblx0RElSVFksXG5cdEVGRkVDVCxcblx0QVNZTkMsXG5cdElORVJULFxuXHRSRU5ERVJfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0TUFZQkVfRElSVFksXG5cdERFUklWRUQsXG5cdEJPVU5EQVJZX0VGRkVDVCxcblx0RUFHRVJfRUZGRUNUXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGRlZmVycmVkLCBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0Z2V0LFxuXHRpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbixcblx0aXNfZGlydHksXG5cdGlzX3VwZGF0aW5nX2VmZmVjdCxcblx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHRpY2ssXG5cdHVwZGF0ZV9lZmZlY3Rcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBmbHVzaF90YXNrcywgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL2RvbS90YXNrLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaW52b2tlX2Vycm9yX2JvdW5kYXJ5IH0gZnJvbSAnLi4vZXJyb3ItaGFuZGxpbmcuanMnO1xuaW1wb3J0IHtcblx0Zmx1c2hfZWFnZXJfZWZmZWN0cyxcblx0ZWFnZXJfZWZmZWN0cyxcblx0b2xkX3ZhbHVlcyxcblx0c2V0X2VhZ2VyX2VmZmVjdHMsXG5cdHNvdXJjZSxcblx0dXBkYXRlXG59IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBlYWdlcl9lZmZlY3QsIHVubGlua19lZmZlY3QgfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHBhcmVudDogRWZmZWN0VGFyZ2V0IHwgbnVsbDtcbiAqICAgZWZmZWN0OiBFZmZlY3QgfCBudWxsO1xuICogICBlZmZlY3RzOiBFZmZlY3RbXTtcbiAqICAgcmVuZGVyX2VmZmVjdHM6IEVmZmVjdFtdO1xuICogICBibG9ja19lZmZlY3RzOiBFZmZlY3RbXTtcbiAqIH19IEVmZmVjdFRhcmdldFxuICovXG5cbi8qKiBAdHlwZSB7U2V0PEJhdGNoPn0gKi9cbmNvbnN0IGJhdGNoZXMgPSBuZXcgU2V0KCk7XG5cbi8qKiBAdHlwZSB7QmF0Y2ggfCBudWxsfSAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2JhdGNoID0gbnVsbDtcblxuLyoqXG4gKiBUaGlzIGlzIG5lZWRlZCB0byBhdm9pZCBvdmVyd3JpdGluZyBpbnB1dHMgaW4gbm9uLWFzeW5jIG1vZGVcbiAqIFRPRE8gNi4wIHJlbW92ZSB0aGlzLCBhcyBub24tYXN5bmMgbW9kZSB3aWxsIGdvIGF3YXlcbiAqIEB0eXBlIHtCYXRjaCB8IG51bGx9XG4gKi9cbmV4cG9ydCBsZXQgcHJldmlvdXNfYmF0Y2ggPSBudWxsO1xuXG4vKipcbiAqIFdoZW4gdGltZSB0cmF2ZWxsaW5nIChpLmUuIHdvcmtpbmcgaW4gb25lIGJhdGNoLCB3aGlsZSBvdGhlciBiYXRjaGVzXG4gKiBzdGlsbCBoYXZlIG9uZ29pbmcgd29yayksIHdlIGlnbm9yZSB0aGUgcmVhbCB2YWx1ZXMgb2YgYWZmZWN0ZWRcbiAqIHNpZ25hbHMgaW4gZmF2b3VyIG9mIHRoZWlyIHZhbHVlcyB3aXRoaW4gdGhlIGJhdGNoXG4gKiBAdHlwZSB7TWFwPFZhbHVlLCBhbnk+IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBiYXRjaF92YWx1ZXMgPSBudWxsO1xuXG4vKiogQHR5cGUge0VmZmVjdFtdfSAqL1xubGV0IHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxuLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xubGV0IGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cbmxldCBpc19mbHVzaGluZyA9IGZhbHNlO1xuZXhwb3J0IGxldCBpc19mbHVzaGluZ19zeW5jID0gZmFsc2U7XG5cbmV4cG9ydCBjbGFzcyBCYXRjaCB7XG5cdGNvbW1pdHRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCB2YWx1ZXMgb2YgYW55IHNvdXJjZXMgdGhhdCBhcmUgdXBkYXRlZCBpbiB0aGlzIGJhdGNoXG5cdCAqIFRoZXkga2V5cyBvZiB0aGlzIG1hcCBhcmUgaWRlbnRpY2FsIHRvIGB0aGlzLiNwcmV2aW91c2Bcblx0ICogQHR5cGUge01hcDxTb3VyY2UsIGFueT59XG5cdCAqL1xuXHRjdXJyZW50ID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBUaGUgdmFsdWVzIG9mIGFueSBzb3VyY2VzIHRoYXQgYXJlIHVwZGF0ZWQgaW4gdGhpcyBiYXRjaCBfYmVmb3JlXyB0aG9zZSB1cGRhdGVzIHRvb2sgcGxhY2UuXG5cdCAqIFRoZXkga2V5cyBvZiB0aGlzIG1hcCBhcmUgaWRlbnRpY2FsIHRvIGB0aGlzLiNjdXJyZW50YFxuXHQgKiBAdHlwZSB7TWFwPFNvdXJjZSwgYW55Pn1cblx0ICovXG5cdHByZXZpb3VzID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRoZSBiYXRjaCBpcyBjb21taXR0ZWQgKGFuZCB0aGUgRE9NIGlzIHVwZGF0ZWQpLCB3ZSBuZWVkIHRvIHJlbW92ZSBvbGQgYnJhbmNoZXNcblx0ICogYW5kIGFwcGVuZCBuZXcgb25lcyBieSBjYWxsaW5nIHRoZSBmdW5jdGlvbnMgYWRkZWQgaW5zaWRlIChpZi9lYWNoL2tleS9ldGMpIGJsb2Nrc1xuXHQgKiBAdHlwZSB7U2V0PCgpID0+IHZvaWQ+fVxuXHQgKi9cblx0I2NvbW1pdF9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIElmIGEgZm9yayBpcyBkaXNjYXJkZWQsIHdlIG5lZWQgdG8gZGVzdHJveSBhbnkgZWZmZWN0cyB0aGF0IGFyZSBubyBsb25nZXIgbmVlZGVkXG5cdCAqIEB0eXBlIHtTZXQ8KGJhdGNoOiBCYXRjaCkgPT4gdm9pZD59XG5cdCAqL1xuXHQjZGlzY2FyZF9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgYXN5bmMgZWZmZWN0cyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gZmxpZ2h0XG5cdCAqL1xuXHQjcGVuZGluZyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgYXN5bmMgZWZmZWN0cyB0aGF0IGFyZSBjdXJyZW50bHkgaW4gZmxpZ2h0LCBfbm90XyBpbnNpZGUgYSBwZW5kaW5nIGJvdW5kYXJ5XG5cdCAqL1xuXHQjYmxvY2tpbmdfcGVuZGluZyA9IDA7XG5cblx0LyoqXG5cdCAqIEEgZGVmZXJyZWQgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBiYXRjaCBpcyBjb21taXR0ZWQsIHVzZWQgd2l0aCBgc2V0dGxlZCgpYFxuXHQgKiBUT0RPIHJlcGxhY2Ugd2l0aCBQcm9taXNlLndpdGhSZXNvbHZlcnMgb25jZSBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaFxuXHQgKiBAdHlwZSB7eyBwcm9taXNlOiBQcm9taXNlPHZvaWQ+LCByZXNvbHZlOiAodmFsdWU/OiBhbnkpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZCB9IHwgbnVsbH1cblx0ICovXG5cdCNkZWZlcnJlZCA9IG51bGw7XG5cblx0LyoqXG5cdCAqIERlZmVycmVkIGVmZmVjdHMgKHdoaWNoIHJ1biBhZnRlciBhc3luYyB3b3JrIGhhcyBjb21wbGV0ZWQpIHRoYXQgYXJlIERJUlRZXG5cdCAqIEB0eXBlIHtFZmZlY3RbXX1cblx0ICovXG5cdCNkaXJ0eV9lZmZlY3RzID0gW107XG5cblx0LyoqXG5cdCAqIERlZmVycmVkIGVmZmVjdHMgdGhhdCBhcmUgTUFZQkVfRElSVFlcblx0ICogQHR5cGUge0VmZmVjdFtdfVxuXHQgKi9cblx0I21heWJlX2RpcnR5X2VmZmVjdHMgPSBbXTtcblxuXHQvKipcblx0ICogQSBzZXQgb2YgYnJhbmNoZXMgdGhhdCBzdGlsbCBleGlzdCwgYnV0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhpcyBiYXRjaFxuXHQgKiBpcyBjb21taXR0ZWQg4oCUIHdlIHNraXAgb3ZlciB0aGVzZSBkdXJpbmcgYHByb2Nlc3NgXG5cdCAqIEB0eXBlIHtTZXQ8RWZmZWN0Pn1cblx0ICovXG5cdHNraXBwZWRfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuXHRpc19mb3JrID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWZmZWN0W119IHJvb3RfZWZmZWN0c1xuXHQgKi9cblx0cHJvY2Vzcyhyb290X2VmZmVjdHMpIHtcblx0XHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cblx0XHRwcmV2aW91c19iYXRjaCA9IG51bGw7XG5cblx0XHR0aGlzLmFwcGx5KCk7XG5cblx0XHQvKiogQHR5cGUge0VmZmVjdFRhcmdldH0gKi9cblx0XHR2YXIgdGFyZ2V0ID0ge1xuXHRcdFx0cGFyZW50OiBudWxsLFxuXHRcdFx0ZWZmZWN0OiBudWxsLFxuXHRcdFx0ZWZmZWN0czogW10sXG5cdFx0XHRyZW5kZXJfZWZmZWN0czogW10sXG5cdFx0XHRibG9ja19lZmZlY3RzOiBbXVxuXHRcdH07XG5cblx0XHRmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdF9lZmZlY3RzKSB7XG5cdFx0XHR0aGlzLiN0cmF2ZXJzZV9lZmZlY3RfdHJlZShyb290LCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc19mb3JrKSB7XG5cdFx0XHR0aGlzLiNyZXNvbHZlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2Jsb2NraW5nX3BlbmRpbmcgPiAwIHx8IHRoaXMuaXNfZm9yaykge1xuXHRcdFx0dGhpcy4jZGVmZXJfZWZmZWN0cyh0YXJnZXQuZWZmZWN0cyk7XG5cdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5yZW5kZXJfZWZmZWN0cyk7XG5cdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5ibG9ja19lZmZlY3RzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgc291cmNlcyBhcmUgd3JpdHRlbiB0bywgdGhlbiB3b3JrIG5lZWRzIHRvIGhhcHBlbiBpbiBhIHNlcGFyYXRlIGJhdGNoLCBlbHNlIHByaW9yIHNvdXJjZXMgd291bGQgYmUgbWl4ZWQgd2l0aFxuXHRcdFx0Ly8gbmV3bHkgdXBkYXRlZCBzb3VyY2VzLCB3aGljaCBjb3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3BzIHdoZW4gZWZmZWN0cyBydW4gb3ZlciBhbmQgb3ZlciBhZ2Fpbi5cblx0XHRcdHByZXZpb3VzX2JhdGNoID0gdGhpcztcblx0XHRcdGN1cnJlbnRfYmF0Y2ggPSBudWxsO1xuXG5cdFx0XHRmbHVzaF9xdWV1ZWRfZWZmZWN0cyh0YXJnZXQucmVuZGVyX2VmZmVjdHMpO1xuXHRcdFx0Zmx1c2hfcXVldWVkX2VmZmVjdHModGFyZ2V0LmVmZmVjdHMpO1xuXG5cdFx0XHRwcmV2aW91c19iYXRjaCA9IG51bGw7XG5cblx0XHRcdHRoaXMuI2RlZmVycmVkPy5yZXNvbHZlKCk7XG5cdFx0fVxuXG5cdFx0YmF0Y2hfdmFsdWVzID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmF2ZXJzZSB0aGUgZWZmZWN0IHRyZWUsIGV4ZWN1dGluZyBlZmZlY3RzIG9yIHN0YXNoaW5nXG5cdCAqIHRoZW0gZm9yIGxhdGVyIGV4ZWN1dGlvbiBhcyBhcHByb3ByaWF0ZVxuXHQgKiBAcGFyYW0ge0VmZmVjdH0gcm9vdFxuXHQgKiBAcGFyYW0ge0VmZmVjdFRhcmdldH0gdGFyZ2V0XG5cdCAqL1xuXHQjdHJhdmVyc2VfZWZmZWN0X3RyZWUocm9vdCwgdGFyZ2V0KSB7XG5cdFx0cm9vdC5mIF49IENMRUFOO1xuXG5cdFx0dmFyIGVmZmVjdCA9IHJvb3QuZmlyc3Q7XG5cblx0XHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblx0XHRcdHZhciBpc19icmFuY2ggPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgIT09IDA7XG5cdFx0XHR2YXIgaXNfc2tpcHBhYmxlX2JyYW5jaCA9IGlzX2JyYW5jaCAmJiAoZmxhZ3MgJiBDTEVBTikgIT09IDA7XG5cblx0XHRcdHZhciBza2lwID0gaXNfc2tpcHBhYmxlX2JyYW5jaCB8fCAoZmxhZ3MgJiBJTkVSVCkgIT09IDAgfHwgdGhpcy5za2lwcGVkX2VmZmVjdHMuaGFzKGVmZmVjdCk7XG5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpICE9PSAwICYmIGVmZmVjdC5iPy5pc19wZW5kaW5nKCkpIHtcblx0XHRcdFx0dGFyZ2V0ID0ge1xuXHRcdFx0XHRcdHBhcmVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdGVmZmVjdCxcblx0XHRcdFx0XHRlZmZlY3RzOiBbXSxcblx0XHRcdFx0XHRyZW5kZXJfZWZmZWN0czogW10sXG5cdFx0XHRcdFx0YmxvY2tfZWZmZWN0czogW11cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFza2lwICYmIGVmZmVjdC5mbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoaXNfYnJhbmNoKSB7XG5cdFx0XHRcdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGZsYWdzICYgRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0XHRcdHRhcmdldC5lZmZlY3RzLnB1c2goZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChhc3luY19tb2RlX2ZsYWcgJiYgKGZsYWdzICYgUkVOREVSX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdFx0XHR0YXJnZXQucmVuZGVyX2VmZmVjdHMucHVzaChlZmZlY3QpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzX2RpcnR5KGVmZmVjdCkpIHtcblx0XHRcdFx0XHRpZiAoKGVmZmVjdC5mICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkgdGFyZ2V0LmJsb2NrX2VmZmVjdHMucHVzaChlZmZlY3QpO1xuXHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjaGlsZCA9IGVmZmVjdC5maXJzdDtcblxuXHRcdFx0XHRpZiAoY2hpbGQgIT09IG51bGwpIHtcblx0XHRcdFx0XHRlZmZlY3QgPSBjaGlsZDtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblx0XHRcdGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuXG5cdFx0XHR3aGlsZSAoZWZmZWN0ID09PSBudWxsICYmIHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocGFyZW50ID09PSB0YXJnZXQuZWZmZWN0KSB7XG5cdFx0XHRcdFx0Ly8gVE9ETyByYXRoZXIgdGhhbiB0cmF2ZXJzaW5nIGludG8gcGVuZGluZyBib3VuZGFyaWVzIGFuZCBkZWZlcnJpbmcgdGhlIGVmZmVjdHMsXG5cdFx0XHRcdFx0Ly8gY291bGQgd2UganVzdCBhdHRhY2ggdGhlIGVmZmVjdHMgX3RvXyB0aGUgcGVuZGluZyBib3VuZGFyeSBhbmQgc2NoZWR1bGUgdGhlbVxuXHRcdFx0XHRcdC8vIG9uY2UgdGhlIGJvdW5kYXJ5IGlzIHJlYWR5P1xuXHRcdFx0XHRcdHRoaXMuI2RlZmVyX2VmZmVjdHModGFyZ2V0LmVmZmVjdHMpO1xuXHRcdFx0XHRcdHRoaXMuI2RlZmVyX2VmZmVjdHModGFyZ2V0LnJlbmRlcl9lZmZlY3RzKTtcblx0XHRcdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRhcmdldC5ibG9ja19lZmZlY3RzKTtcblxuXHRcdFx0XHRcdHRhcmdldCA9IC8qKiBAdHlwZSB7RWZmZWN0VGFyZ2V0fSAqLyAodGFyZ2V0LnBhcmVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlZmZlY3QgPSBwYXJlbnQubmV4dDtcblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFZmZlY3RbXX0gZWZmZWN0c1xuXHQgKi9cblx0I2RlZmVyX2VmZmVjdHMoZWZmZWN0cykge1xuXHRcdGZvciAoY29uc3QgZSBvZiBlZmZlY3RzKSB7XG5cdFx0XHRjb25zdCB0YXJnZXQgPSAoZS5mICYgRElSVFkpICE9PSAwID8gdGhpcy4jZGlydHlfZWZmZWN0cyA6IHRoaXMuI21heWJlX2RpcnR5X2VmZmVjdHM7XG5cdFx0XHR0YXJnZXQucHVzaChlKTtcblxuXHRcdFx0Ly8gbWFyayBhcyBjbGVhbiBzbyB0aGV5IGdldCBzY2hlZHVsZWQgaWYgdGhleSBkZXBlbmQgb24gcGVuZGluZyBhc3luYyBzdGF0ZVxuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZSwgQ0xFQU4pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NvY2lhdGUgYSBjaGFuZ2UgdG8gYSBnaXZlbiBzb3VyY2Ugd2l0aCB0aGUgY3VycmVudFxuXHQgKiBiYXRjaCwgbm90aW5nIGl0cyBwcmV2aW91cyBhbmQgY3VycmVudCB2YWx1ZXNcblx0ICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZVxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWVcblx0ICovXG5cdGNhcHR1cmUoc291cmNlLCB2YWx1ZSkge1xuXHRcdGlmICghdGhpcy5wcmV2aW91cy5oYXMoc291cmNlKSkge1xuXHRcdFx0dGhpcy5wcmV2aW91cy5zZXQoc291cmNlLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jdXJyZW50LnNldChzb3VyY2UsIHNvdXJjZS52KTtcblx0XHRiYXRjaF92YWx1ZXM/LnNldChzb3VyY2UsIHNvdXJjZS52KTtcblx0fVxuXG5cdGFjdGl2YXRlKCkge1xuXHRcdGN1cnJlbnRfYmF0Y2ggPSB0aGlzO1xuXHR9XG5cblx0ZGVhY3RpdmF0ZSgpIHtcblx0XHRjdXJyZW50X2JhdGNoID0gbnVsbDtcblx0XHRiYXRjaF92YWx1ZXMgPSBudWxsO1xuXHR9XG5cblx0Zmx1c2goKSB7XG5cdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXG5cdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Zmx1c2hfZWZmZWN0cygpO1xuXG5cdFx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCAmJiBjdXJyZW50X2JhdGNoICE9PSB0aGlzKSB7XG5cdFx0XHRcdC8vIHRoaXMgY2FuIGhhcHBlbiBpZiBhIG5ldyBiYXRjaCB3YXMgY3JlYXRlZCBkdXJpbmcgYGZsdXNoX2VmZmVjdHMoKWBcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy4jcGVuZGluZyA9PT0gMCkge1xuXHRcdFx0dGhpcy5wcm9jZXNzKFtdKTsgLy8gVE9ETyB0aGlzIGZlZWxzIGF3a3dhcmRcblx0XHR9XG5cblx0XHR0aGlzLmRlYWN0aXZhdGUoKTtcblx0fVxuXG5cdGRpc2NhcmQoKSB7XG5cdFx0Zm9yIChjb25zdCBmbiBvZiB0aGlzLiNkaXNjYXJkX2NhbGxiYWNrcykgZm4odGhpcyk7XG5cdFx0dGhpcy4jZGlzY2FyZF9jYWxsYmFja3MuY2xlYXIoKTtcblx0fVxuXG5cdCNyZXNvbHZlKCkge1xuXHRcdGlmICh0aGlzLiNibG9ja2luZ19wZW5kaW5nID09PSAwKSB7XG5cdFx0XHQvLyBhcHBlbmQvcmVtb3ZlIGJyYW5jaGVzXG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIHRoaXMuI2NvbW1pdF9jYWxsYmFja3MpIGZuKCk7XG5cdFx0XHR0aGlzLiNjb21taXRfY2FsbGJhY2tzLmNsZWFyKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmcgPT09IDApIHtcblx0XHRcdHRoaXMuI2NvbW1pdCgpO1xuXHRcdH1cblx0fVxuXG5cdCNjb21taXQoKSB7XG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG90aGVyIHBlbmRpbmcgYmF0Y2hlcywgdGhleSBub3cgbmVlZCB0byBiZSAncmViYXNlZCcg4oCUXG5cdFx0Ly8gaW4gb3RoZXIgd29yZHMsIHdlIHJlLXJ1biBibG9jay9hc3luYyBlZmZlY3RzIHdpdGggdGhlIG5ld2x5XG5cdFx0Ly8gY29tbWl0dGVkIHN0YXRlLCB1bmxlc3MgdGhlIGJhdGNoIGluIHF1ZXN0aW9uIGhhcyBhIG1vcmVcblx0XHQvLyByZWNlbnQgdmFsdWUgZm9yIGEgZ2l2ZW4gc291cmNlXG5cdFx0aWYgKGJhdGNoZXMuc2l6ZSA+IDEpIHtcblx0XHRcdHRoaXMucHJldmlvdXMuY2xlYXIoKTtcblxuXHRcdFx0dmFyIHByZXZpb3VzX2JhdGNoX3ZhbHVlcyA9IGJhdGNoX3ZhbHVlcztcblx0XHRcdHZhciBpc19lYXJsaWVyID0gdHJ1ZTtcblxuXHRcdFx0LyoqIEB0eXBlIHtFZmZlY3RUYXJnZXR9ICovXG5cdFx0XHR2YXIgZHVtbXlfdGFyZ2V0ID0ge1xuXHRcdFx0XHRwYXJlbnQ6IG51bGwsXG5cdFx0XHRcdGVmZmVjdDogbnVsbCxcblx0XHRcdFx0ZWZmZWN0czogW10sXG5cdFx0XHRcdHJlbmRlcl9lZmZlY3RzOiBbXSxcblx0XHRcdFx0YmxvY2tfZWZmZWN0czogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoY29uc3QgYmF0Y2ggb2YgYmF0Y2hlcykge1xuXHRcdFx0XHRpZiAoYmF0Y2ggPT09IHRoaXMpIHtcblx0XHRcdFx0XHRpc19lYXJsaWVyID0gZmFsc2U7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiogQHR5cGUge1NvdXJjZVtdfSAqL1xuXHRcdFx0XHRjb25zdCBzb3VyY2VzID0gW107XG5cblx0XHRcdFx0Zm9yIChjb25zdCBbc291cmNlLCB2YWx1ZV0gb2YgdGhpcy5jdXJyZW50KSB7XG5cdFx0XHRcdFx0aWYgKGJhdGNoLmN1cnJlbnQuaGFzKHNvdXJjZSkpIHtcblx0XHRcdFx0XHRcdGlmIChpc19lYXJsaWVyICYmIHZhbHVlICE9PSBiYXRjaC5jdXJyZW50LmdldChzb3VyY2UpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGJyaW5nIHRoZSB2YWx1ZSB1cCB0byBkYXRlXG5cdFx0XHRcdFx0XHRcdGJhdGNoLmN1cnJlbnQuc2V0KHNvdXJjZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2FtZSB2YWx1ZSBvciBsYXRlciBiYXRjaCBoYXMgbW9yZSByZWNlbnQgdmFsdWUsXG5cdFx0XHRcdFx0XHRcdC8vIG5vIG5lZWQgdG8gcmUtcnVuIHRoZXNlIGVmZmVjdHNcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlLXJ1biBhc3luYy9ibG9jayBlZmZlY3RzIHRoYXQgZGVwZW5kIG9uIGRpc3RpbmN0IHZhbHVlcyBjaGFuZ2VkIGluIGJvdGggYmF0Y2hlc1xuXHRcdFx0XHRjb25zdCBvdGhlcnMgPSBbLi4uYmF0Y2guY3VycmVudC5rZXlzKCldLmZpbHRlcigocykgPT4gIXRoaXMuY3VycmVudC5oYXMocykpO1xuXHRcdFx0XHRpZiAob3RoZXJzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge1NldDxWYWx1ZT59ICovXG5cdFx0XHRcdFx0Y29uc3QgbWFya2VkID0gbmV3IFNldCgpO1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7TWFwPFJlYWN0aW9uLCBib29sZWFuPn0gKi9cblx0XHRcdFx0XHRjb25zdCBjaGVja2VkID0gbmV3IE1hcCgpO1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcblx0XHRcdFx0XHRcdG1hcmtfZWZmZWN0cyhzb3VyY2UsIG90aGVycywgbWFya2VkLCBjaGVja2VkKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50X2JhdGNoID0gYmF0Y2g7XG5cdFx0XHRcdFx0XHRiYXRjaC5hcHBseSgpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IHJvb3Qgb2YgcXVldWVkX3Jvb3RfZWZmZWN0cykge1xuXHRcdFx0XHRcdFx0XHRiYXRjaC4jdHJhdmVyc2VfZWZmZWN0X3RyZWUocm9vdCwgZHVtbXlfdGFyZ2V0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVE9ETyBkbyB3ZSBuZWVkIHRvIGRvIGFueXRoaW5nIHdpdGggYHRhcmdldGA/IGRlZmVyIGJsb2NrIGVmZmVjdHM/XG5cblx0XHRcdFx0XHRcdHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblx0XHRcdFx0XHRcdGJhdGNoLmRlYWN0aXZhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudF9iYXRjaCA9IG51bGw7XG5cdFx0XHRiYXRjaF92YWx1ZXMgPSBwcmV2aW91c19iYXRjaF92YWx1ZXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb21taXR0ZWQgPSB0cnVlO1xuXHRcdGJhdGNoZXMuZGVsZXRlKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYmxvY2tpbmdcblx0ICovXG5cdGluY3JlbWVudChibG9ja2luZykge1xuXHRcdHRoaXMuI3BlbmRpbmcgKz0gMTtcblx0XHRpZiAoYmxvY2tpbmcpIHRoaXMuI2Jsb2NraW5nX3BlbmRpbmcgKz0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGJsb2NraW5nXG5cdCAqL1xuXHRkZWNyZW1lbnQoYmxvY2tpbmcpIHtcblx0XHR0aGlzLiNwZW5kaW5nIC09IDE7XG5cdFx0aWYgKGJsb2NraW5nKSB0aGlzLiNibG9ja2luZ19wZW5kaW5nIC09IDE7XG5cblx0XHR0aGlzLnJldml2ZSgpO1xuXHR9XG5cblx0cmV2aXZlKCkge1xuXHRcdGZvciAoY29uc3QgZSBvZiB0aGlzLiNkaXJ0eV9lZmZlY3RzKSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlLCBESVJUWSk7XG5cdFx0XHRzY2hlZHVsZV9lZmZlY3QoZSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBlIG9mIHRoaXMuI21heWJlX2RpcnR5X2VmZmVjdHMpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGUsIE1BWUJFX0RJUlRZKTtcblx0XHRcdHNjaGVkdWxlX2VmZmVjdChlKTtcblx0XHR9XG5cblx0XHR0aGlzLiNkaXJ0eV9lZmZlY3RzID0gW107XG5cdFx0dGhpcy4jbWF5YmVfZGlydHlfZWZmZWN0cyA9IFtdO1xuXG5cdFx0dGhpcy5mbHVzaCgpO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm4gKi9cblx0b25jb21taXQoZm4pIHtcblx0XHR0aGlzLiNjb21taXRfY2FsbGJhY2tzLmFkZChmbik7XG5cdH1cblxuXHQvKiogQHBhcmFtIHsoYmF0Y2g6IEJhdGNoKSA9PiB2b2lkfSBmbiAqL1xuXHRvbmRpc2NhcmQoZm4pIHtcblx0XHR0aGlzLiNkaXNjYXJkX2NhbGxiYWNrcy5hZGQoZm4pO1xuXHR9XG5cblx0c2V0dGxlZCgpIHtcblx0XHRyZXR1cm4gKHRoaXMuI2RlZmVycmVkID8/PSBkZWZlcnJlZCgpKS5wcm9taXNlO1xuXHR9XG5cblx0c3RhdGljIGVuc3VyZSgpIHtcblx0XHRpZiAoY3VycmVudF9iYXRjaCA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc3QgYmF0Y2ggPSAoY3VycmVudF9iYXRjaCA9IG5ldyBCYXRjaCgpKTtcblx0XHRcdGJhdGNoZXMuYWRkKGN1cnJlbnRfYmF0Y2gpO1xuXG5cdFx0XHRpZiAoIWlzX2ZsdXNoaW5nX3N5bmMpIHtcblx0XHRcdFx0QmF0Y2guZW5xdWV1ZSgoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IGJhdGNoKSB7XG5cdFx0XHRcdFx0XHQvLyBhIGZsdXNoU3luYyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRiYXRjaC5mbHVzaCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY3VycmVudF9iYXRjaDtcblx0fVxuXG5cdC8qKiBAcGFyYW0geygpID0+IHZvaWR9IHRhc2sgKi9cblx0c3RhdGljIGVucXVldWUodGFzaykge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2sodGFzayk7XG5cdH1cblxuXHRhcHBseSgpIHtcblx0XHRpZiAoIWFzeW5jX21vZGVfZmxhZyB8fCBiYXRjaGVzLnNpemUgPT09IDEpIHJldHVybjtcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBiYXRjaGVzLCB3ZSBhcmUgJ3RpbWUgdHJhdmVsbGluZycg4oCUXG5cdFx0Ly8gd2UgbmVlZCB0byBvdmVycmlkZSB2YWx1ZXMgd2l0aCB0aGUgb25lcyBpbiB0aGlzIGJhdGNoLi4uXG5cdFx0YmF0Y2hfdmFsdWVzID0gbmV3IE1hcCh0aGlzLmN1cnJlbnQpO1xuXG5cdFx0Ly8gLi4uYW5kIHVuZG8gY2hhbmdlcyBiZWxvbmdpbmcgdG8gb3RoZXIgYmF0Y2hlc1xuXHRcdGZvciAoY29uc3QgYmF0Y2ggb2YgYmF0Y2hlcykge1xuXHRcdFx0aWYgKGJhdGNoID09PSB0aGlzKSBjb250aW51ZTtcblxuXHRcdFx0Zm9yIChjb25zdCBbc291cmNlLCBwcmV2aW91c10gb2YgYmF0Y2gucHJldmlvdXMpIHtcblx0XHRcdFx0aWYgKCFiYXRjaF92YWx1ZXMuaGFzKHNvdXJjZSkpIHtcblx0XHRcdFx0XHRiYXRjaF92YWx1ZXMuc2V0KHNvdXJjZSwgcHJldmlvdXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBmbHVzaCBhbnkgcGVuZGluZyB1cGRhdGVzLlxuICogUmV0dXJucyB2b2lkIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFtUPXZvaWRdXG4gKiBAcGFyYW0geygoKSA9PiBUKSB8IHVuZGVmaW5lZH0gW2ZuXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcblx0aWYgKGFzeW5jX21vZGVfZmxhZyAmJiBhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0Ly8gV2UgZGlzYWxsb3cgdGhpcyBiZWNhdXNlIGl0IGNyZWF0ZXMgc3VwZXItaGFyZCB0byByZWFzb24gYWJvdXQgc3RhY2sgdHJhY2UgYW5kIGJlY2F1c2UgaXQncyBnZW5lcmFsbHkgYSBiYWQgaWRlYVxuXHRcdGUuZmx1c2hfc3luY19pbl9lZmZlY3QoKTtcblx0fVxuXG5cdHZhciB3YXNfZmx1c2hpbmdfc3luYyA9IGlzX2ZsdXNoaW5nX3N5bmM7XG5cdGlzX2ZsdXNoaW5nX3N5bmMgPSB0cnVlO1xuXG5cdHRyeSB7XG5cdFx0dmFyIHJlc3VsdDtcblxuXHRcdGlmIChmbikge1xuXHRcdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IG51bGwpIHtcblx0XHRcdFx0Zmx1c2hfZWZmZWN0cygpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQgPSBmbigpO1xuXHRcdH1cblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRmbHVzaF90YXNrcygpO1xuXG5cdFx0XHRpZiAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Y3VycmVudF9iYXRjaD8uZmx1c2goKTtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluLCBpbiBjYXNlIHdlIGp1c3QgdXBkYXRlZCBhbiBgJGVmZmVjdC5wZW5kaW5nKClgXG5cdFx0XHRcdGlmIChxdWV1ZWRfcm9vdF9lZmZlY3RzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIHRoaXMgd291bGQgYmUgcmVzZXQgaW4gYGZsdXNoX2VmZmVjdHMoKWAgYnV0IHNpbmNlIHdlIGFyZSBlYXJseSByZXR1cm5pbmcgaGVyZSxcblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHJlc2V0IGl0IGhlcmUgYXMgd2VsbCBpbiBjYXNlIHRoZSBmaXJzdCB0aW1lIHRoZXJlJ3MgMCBxdWV1ZWQgcm9vdCBlZmZlY3RzXG5cdFx0XHRcdFx0bGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gbnVsbDtcblxuXHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge1R9ICovIChyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZsdXNoX2VmZmVjdHMoKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfZmx1c2hpbmdfc3luYyA9IHdhc19mbHVzaGluZ19zeW5jO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGZsdXNoX2VmZmVjdHMoKSB7XG5cdHZhciB3YXNfdXBkYXRpbmdfZWZmZWN0ID0gaXNfdXBkYXRpbmdfZWZmZWN0O1xuXHRpc19mbHVzaGluZyA9IHRydWU7XG5cblx0dHJ5IHtcblx0XHR2YXIgZmx1c2hfY291bnQgPSAwO1xuXHRcdHNldF9pc191cGRhdGluZ19lZmZlY3QodHJ1ZSk7XG5cblx0XHR3aGlsZSAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgYmF0Y2ggPSBCYXRjaC5lbnN1cmUoKTtcblxuXHRcdFx0aWYgKGZsdXNoX2NvdW50KysgPiAxMDAwKSB7XG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHR2YXIgdXBkYXRlcyA9IG5ldyBNYXAoKTtcblxuXHRcdFx0XHRcdGZvciAoY29uc3Qgc291cmNlIG9mIGJhdGNoLmN1cnJlbnQua2V5cygpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtzdGFjaywgdXBkYXRlXSBvZiBzb3VyY2UudXBkYXRlZCA/PyBbXSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZW50cnkgPSB1cGRhdGVzLmdldChzdGFjayk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFlbnRyeSkge1xuXHRcdFx0XHRcdFx0XHRcdGVudHJ5ID0geyBlcnJvcjogdXBkYXRlLmVycm9yLCBjb3VudDogMCB9O1xuXHRcdFx0XHRcdFx0XHRcdHVwZGF0ZXMuc2V0KHN0YWNrLCBlbnRyeSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRlbnRyeS5jb3VudCArPSB1cGRhdGUuY291bnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB1cGRhdGUgb2YgdXBkYXRlcy52YWx1ZXMoKSkge1xuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IodXBkYXRlLmVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmZpbml0ZV9sb29wX2d1YXJkKCk7XG5cdFx0XHR9XG5cblx0XHRcdGJhdGNoLnByb2Nlc3MocXVldWVkX3Jvb3RfZWZmZWN0cyk7XG5cdFx0XHRvbGRfdmFsdWVzLmNsZWFyKCk7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlzX2ZsdXNoaW5nID0gZmFsc2U7XG5cdFx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCh3YXNfdXBkYXRpbmdfZWZmZWN0KTtcblxuXHRcdGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cdH1cbn1cblxuZnVuY3Rpb24gaW5maW5pdGVfbG9vcF9ndWFyZCgpIHtcblx0dHJ5IHtcblx0XHRlLmVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHQvLyBzdGFjayBjb250YWlucyBubyB1c2VmdWwgaW5mb3JtYXRpb24sIHJlcGxhY2UgaXRcblx0XHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywgeyB2YWx1ZTogJycgfSk7XG5cdFx0fVxuXG5cdFx0Ly8gQmVzdCBlZmZvcnQ6IGludm9rZSB0aGUgYm91bmRhcnkgbmVhcmVzdCB0aGUgbW9zdCByZWNlbnRcblx0XHQvLyBlZmZlY3QgYW5kIGhvcGUgdGhhdCBpdCdzIHJlbGV2YW50IHRvIHRoZSBpbmZpbml0ZSBsb29wXG5cdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QpO1xuXHR9XG59XG5cbi8qKiBAdHlwZSB7U2V0PEVmZmVjdD4gfCBudWxsfSAqL1xuZXhwb3J0IGxldCBlYWdlcl9ibG9ja19lZmZlY3RzID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEVmZmVjdD59IGVmZmVjdHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmbHVzaF9xdWV1ZWRfZWZmZWN0cyhlZmZlY3RzKSB7XG5cdHZhciBsZW5ndGggPSBlZmZlY3RzLmxlbmd0aDtcblx0aWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG5cdHZhciBpID0gMDtcblxuXHR3aGlsZSAoaSA8IGxlbmd0aCkge1xuXHRcdHZhciBlZmZlY3QgPSBlZmZlY3RzW2krK107XG5cblx0XHRpZiAoKGVmZmVjdC5mICYgKERFU1RST1lFRCB8IElORVJUKSkgPT09IDAgJiYgaXNfZGlydHkoZWZmZWN0KSkge1xuXHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuXHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXG5cdFx0XHQvLyBFZmZlY3RzIHdpdGggbm8gZGVwZW5kZW5jaWVzIG9yIHRlYXJkb3duIGRvIG5vdCBnZXQgYWRkZWQgdG8gdGhlIGVmZmVjdCB0cmVlLlxuXHRcdFx0Ly8gRGVmZXJyZWQgZWZmZWN0cyAoZS5nLiBgJGVmZmVjdCguLi4pYCkgX2FyZV8gYWRkZWQgdG8gdGhlIHRyZWUgYmVjYXVzZSB3ZVxuXHRcdFx0Ly8gZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1bnRpbCB0aGV5IGFyZSBleGVjdXRlZC4gRG9pbmcgdGhlIGNoZWNrXG5cdFx0XHQvLyBoZXJlIChyYXRoZXIgdGhhbiBpbiBgdXBkYXRlX2VmZmVjdGApIGFsbG93cyB1cyB0byBza2lwIHRoZSB3b3JrIGZvclxuXHRcdFx0Ly8gaW1tZWRpYXRlIGVmZmVjdHMuXG5cdFx0XHRpZiAoZWZmZWN0LmRlcHMgPT09IG51bGwgJiYgZWZmZWN0LmZpcnN0ID09PSBudWxsICYmIGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBpZiB0aGVyZSdzIG5vIHRlYXJkb3duIG9yIGFib3J0IGNvbnRyb2xsZXIgd2UgY29tcGxldGVseSB1bmxpbmtcblx0XHRcdFx0Ly8gdGhlIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRpZiAoZWZmZWN0LnRlYXJkb3duID09PSBudWxsICYmIGVmZmVjdC5hYyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB0aGlzIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRcdHVubGlua19lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3QgaW4gdGhlIGdyYXBoLCBidXQgZnJlZSB1cCBzb21lIG1lbW9yeVxuXHRcdFx0XHRcdGVmZmVjdC5mbiA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdXBkYXRlX2VmZmVjdCgpIGhhcyBhIGZsdXNoU3luYygpIGluIGl0LCB3ZSBtYXkgaGF2ZSBmbHVzaGVkIGFub3RoZXIgZmx1c2hfcXVldWVkX2VmZmVjdHMoKSxcblx0XHRcdC8vIHdoaWNoIGFscmVhZHkgaGFuZGxlZCB0aGlzIGxvZ2ljIGFuZCBkaWQgc2V0IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgdG8gbnVsbC5cblx0XHRcdGlmIChlYWdlcl9ibG9ja19lZmZlY3RzPy5zaXplID4gMCkge1xuXHRcdFx0XHRvbGRfdmFsdWVzLmNsZWFyKCk7XG5cblx0XHRcdFx0Zm9yIChjb25zdCBlIG9mIGVhZ2VyX2Jsb2NrX2VmZmVjdHMpIHtcblx0XHRcdFx0XHQvLyBTa2lwIGVhZ2VyIGVmZmVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiB1bm1vdW50ZWRcblx0XHRcdFx0XHRpZiAoKGUuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpICE9PSAwKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdC8vIFJ1biBlZmZlY3RzIGluIG9yZGVyIGZyb20gYW5jZXN0b3IgdG8gZGVzY2VuZGFudCwgZWxzZSB3ZSBjb3VsZCBydW4gaW50byBudWxscG9pbnRlcnNcblx0XHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdFtdfSAqL1xuXHRcdFx0XHRcdGNvbnN0IG9yZGVyZWRfZWZmZWN0cyA9IFtlXTtcblx0XHRcdFx0XHRsZXQgYW5jZXN0b3IgPSBlLnBhcmVudDtcblx0XHRcdFx0XHR3aGlsZSAoYW5jZXN0b3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmIChlYWdlcl9ibG9ja19lZmZlY3RzLmhhcyhhbmNlc3RvcikpIHtcblx0XHRcdFx0XHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cy5kZWxldGUoYW5jZXN0b3IpO1xuXHRcdFx0XHRcdFx0XHRvcmRlcmVkX2VmZmVjdHMucHVzaChhbmNlc3Rvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gb3JkZXJlZF9lZmZlY3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBlID0gb3JkZXJlZF9lZmZlY3RzW2pdO1xuXHRcdFx0XHRcdFx0Ly8gU2tpcCBlYWdlciBlZmZlY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gdW5tb3VudGVkXG5cdFx0XHRcdFx0XHRpZiAoKGUuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpICE9PSAwKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cy5jbGVhcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGVhZ2VyX2Jsb2NrX2VmZmVjdHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgc2ltaWxhciB0byBgbWFya19yZWFjdGlvbnNgLCBidXQgaXQgb25seSBtYXJrcyBhc3luYy9ibG9jayBlZmZlY3RzXG4gKiBkZXBlbmRpbmcgb24gYHZhbHVlYCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZSBvdGhlciBgc291cmNlc2AsIHNvIHRoYXRcbiAqIHRoZXNlIGVmZmVjdHMgY2FuIHJlLXJ1biBhZnRlciBhbm90aGVyIGJhdGNoIGhhcyBiZWVuIGNvbW1pdHRlZFxuICogQHBhcmFtIHtWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSB7U291cmNlW119IHNvdXJjZXNcbiAqIEBwYXJhbSB7U2V0PFZhbHVlPn0gbWFya2VkXG4gKiBAcGFyYW0ge01hcDxSZWFjdGlvbiwgYm9vbGVhbj59IGNoZWNrZWRcbiAqL1xuZnVuY3Rpb24gbWFya19lZmZlY3RzKHZhbHVlLCBzb3VyY2VzLCBtYXJrZWQsIGNoZWNrZWQpIHtcblx0aWYgKG1hcmtlZC5oYXModmFsdWUpKSByZXR1cm47XG5cdG1hcmtlZC5hZGQodmFsdWUpO1xuXG5cdGlmICh2YWx1ZS5yZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHJlYWN0aW9uIG9mIHZhbHVlLnJlYWN0aW9ucykge1xuXHRcdFx0Y29uc3QgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdFx0XHRpZiAoKGZsYWdzICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdFx0bWFya19lZmZlY3RzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgc291cmNlcywgbWFya2VkLCBjaGVja2VkKTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdChmbGFncyAmIChBU1lOQyB8IEJMT0NLX0VGRkVDVCkpICE9PSAwICYmXG5cdFx0XHRcdChmbGFncyAmIERJUlRZKSA9PT0gMCAmJiAvLyB3ZSBtYXkgaGF2ZSBzY2hlZHVsZWQgdGhpcyBvbmUgYWxyZWFkeVxuXHRcdFx0XHRkZXBlbmRzX29uKHJlYWN0aW9uLCBzb3VyY2VzLCBjaGVja2VkKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBESVJUWSk7XG5cdFx0XHRcdHNjaGVkdWxlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogV2hlbiBjb21taXR0aW5nIGEgZm9yaywgd2UgbmVlZCB0byB0cmlnZ2VyIGVhZ2VyIGVmZmVjdHMgc28gdGhhdFxuICogYW55IGAkc3RhdGUuZWFnZXIoLi4uKWAgZXhwcmVzc2lvbnMgdXBkYXRlIGltbWVkaWF0ZWx5LiBUaGlzXG4gKiBmdW5jdGlvbiBhbGxvd3MgdXMgdG8gZGlzY292ZXIgdGhlbVxuICogQHBhcmFtIHtWYWx1ZX0gdmFsdWVcbiAqIEBwYXJhbSB7U2V0PEVmZmVjdD59IGVmZmVjdHNcbiAqL1xuZnVuY3Rpb24gbWFya19lYWdlcl9lZmZlY3RzKHZhbHVlLCBlZmZlY3RzKSB7XG5cdGlmICh2YWx1ZS5yZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKGNvbnN0IHJlYWN0aW9uIG9mIHZhbHVlLnJlYWN0aW9ucykge1xuXHRcdGNvbnN0IGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRcdGlmICgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0bWFya19lYWdlcl9lZmZlY3RzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgZWZmZWN0cyk7XG5cdFx0fSBlbHNlIGlmICgoZmxhZ3MgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgRElSVFkpO1xuXHRcdFx0ZWZmZWN0cy5hZGQoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uXG4gKiBAcGFyYW0ge1NvdXJjZVtdfSBzb3VyY2VzXG4gKiBAcGFyYW0ge01hcDxSZWFjdGlvbiwgYm9vbGVhbj59IGNoZWNrZWRcbiAqL1xuZnVuY3Rpb24gZGVwZW5kc19vbihyZWFjdGlvbiwgc291cmNlcywgY2hlY2tlZCkge1xuXHRjb25zdCBkZXBlbmRzID0gY2hlY2tlZC5nZXQocmVhY3Rpb24pO1xuXHRpZiAoZGVwZW5kcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZGVwZW5kcztcblxuXHRpZiAocmVhY3Rpb24uZGVwcyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgZGVwIG9mIHJlYWN0aW9uLmRlcHMpIHtcblx0XHRcdGlmIChzb3VyY2VzLmluY2x1ZGVzKGRlcCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgoZGVwLmYgJiBERVJJVkVEKSAhPT0gMCAmJiBkZXBlbmRzX29uKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCksIHNvdXJjZXMsIGNoZWNrZWQpKSB7XG5cdFx0XHRcdGNoZWNrZWQuc2V0KC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCksIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRjaGVja2VkLnNldChyZWFjdGlvbiwgZmFsc2UpO1xuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX2VmZmVjdChzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IChsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBzaWduYWwpO1xuXG5cdHdoaWxlIChlZmZlY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRcdC8vIGlmIHRoZSBlZmZlY3QgaXMgYmVpbmcgc2NoZWR1bGVkIGJlY2F1c2UgYSBwYXJlbnQgKGVhY2gvYXdhaXQvZXRjKSBibG9ja1xuXHRcdC8vIHVwZGF0ZWQgYW4gaW50ZXJuYWwgc291cmNlLCBiYWlsIG91dCBvciB3ZSdsbCBjYXVzZSBhIHNlY29uZCBmbHVzaFxuXHRcdGlmIChpc19mbHVzaGluZyAmJiBlZmZlY3QgPT09IGFjdGl2ZV9lZmZlY3QgJiYgKGZsYWdzICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgoZmxhZ3MgJiAoUk9PVF9FRkZFQ1QgfCBCUkFOQ0hfRUZGRUNUKSkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBDTEVBTikgPT09IDApIHJldHVybjtcblx0XHRcdGVmZmVjdC5mIF49IENMRUFOO1xuXHRcdH1cblx0fVxuXG5cdHF1ZXVlZF9yb290X2VmZmVjdHMucHVzaChlZmZlY3QpO1xufVxuXG4vKiogQHR5cGUge1NvdXJjZTxudW1iZXI+W119ICovXG5sZXQgZWFnZXJfdmVyc2lvbnMgPSBbXTtcblxuZnVuY3Rpb24gZWFnZXJfZmx1c2goKSB7XG5cdHRyeSB7XG5cdFx0Zmx1c2hTeW5jKCgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgdmVyc2lvbiBvZiBlYWdlcl92ZXJzaW9ucykge1xuXHRcdFx0XHR1cGRhdGUodmVyc2lvbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0gZmluYWxseSB7XG5cdFx0ZWFnZXJfdmVyc2lvbnMgPSBbXTtcblx0fVxufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGAkc3RhdGUuZWFnZXIoZm4oKSlgXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWdlcihmbikge1xuXHR2YXIgdmVyc2lvbiA9IHNvdXJjZSgwKTtcblx0dmFyIGluaXRpYWwgPSB0cnVlO1xuXHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1R9ICovICh1bmRlZmluZWQpO1xuXG5cdGdldCh2ZXJzaW9uKTtcblxuXHRlYWdlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChpbml0aWFsKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgdGltZSB0aGlzIHJ1bnMsIHdlIGNyZWF0ZSBhbiBlYWdlciBlZmZlY3Rcblx0XHRcdC8vIHRoYXQgd2lsbCBydW4gZWFnZXJseSB3aGVuZXZlciB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzXG5cdFx0XHR2YXIgcHJldmlvdXNfYmF0Y2hfdmFsdWVzID0gYmF0Y2hfdmFsdWVzO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRiYXRjaF92YWx1ZXMgPSBudWxsO1xuXHRcdFx0XHR2YWx1ZSA9IGZuKCk7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRiYXRjaF92YWx1ZXMgPSBwcmV2aW91c19iYXRjaF92YWx1ZXM7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB0aGUgc2Vjb25kIHRpbWUgdGhpcyBlZmZlY3QgcnVucywgaXQncyB0byBzY2hlZHVsZSBhXG5cdFx0Ly8gYHZlcnNpb25gIHVwZGF0ZS4gc2luY2UgdGhpcyB3aWxsIHJlY3JlYXRlIHRoZSBlZmZlY3QsXG5cdFx0Ly8gd2UgZG9uJ3QgbmVlZCB0byBldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBoZXJlXG5cdFx0aWYgKGVhZ2VyX3ZlcnNpb25zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cXVldWVfbWljcm9fdGFzayhlYWdlcl9mbHVzaCk7XG5cdFx0fVxuXG5cdFx0ZWFnZXJfdmVyc2lvbnMucHVzaCh2ZXJzaW9uKTtcblx0fSk7XG5cblx0aW5pdGlhbCA9IGZhbHNlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgJ2ZvcmsnLCBpbiB3aGljaCBzdGF0ZSBjaGFuZ2VzIGFyZSBldmFsdWF0ZWQgYnV0IG5vdCBhcHBsaWVkIHRvIHRoZSBET00uXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3Igc3BlY3VsYXRpdmVseSBsb2FkaW5nIGRhdGEgKGZvciBleGFtcGxlKSB3aGVuIHlvdSBzdXNwZWN0IHRoYXRcbiAqIHRoZSB1c2VyIGlzIGFib3V0IHRvIHRha2Ugc29tZSBhY3Rpb24uXG4gKlxuICogRnJhbWV3b3JrcyBsaWtlIFN2ZWx0ZUtpdCBjYW4gdXNlIHRoaXMgdG8gcHJlbG9hZCBkYXRhIHdoZW4gdGhlIHVzZXIgdG91Y2hlcyBvclxuICogaG92ZXJzIG92ZXIgYSBsaW5rLCBtYWtpbmcgYW55IHN1YnNlcXVlbnQgbmF2aWdhdGlvbiBmZWVsIGluc3RhbnRhbmVvdXMuXG4gKlxuICogVGhlIGBmbmAgcGFyYW1ldGVyIGlzIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBtb2RpZmllcyBzb21lIHN0YXRlLiBUaGVcbiAqIHN0YXRlIGNoYW5nZXMgd2lsbCBiZSByZXZlcnRlZCBhZnRlciB0aGUgZm9yayBpcyBpbml0aWFsaXNlZCwgdGhlbiByZWFwcGxpZWRcbiAqIGlmIGFuZCB3aGVuIHRoZSBmb3JrIGlzIGV2ZW50dWFsbHkgY29tbWl0dGVkLlxuICpcbiAqIFdoZW4gaXQgYmVjb21lcyBjbGVhciB0aGF0IGEgZm9yayB3aWxsIF9ub3RfIGJlIGNvbW1pdHRlZCAoZS5nLiBiZWNhdXNlIHRoZVxuICogdXNlciBuYXZpZ2F0ZWQgZWxzZXdoZXJlKSwgaXQgbXVzdCBiZSBkaXNjYXJkZWQgdG8gYXZvaWQgbGVha2luZyBtZW1vcnkuXG4gKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge0Zvcmt9XG4gKiBAc2luY2UgNS40MlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yayhmbikge1xuXHRpZiAoIWFzeW5jX21vZGVfZmxhZykge1xuXHRcdGUuZXhwZXJpbWVudGFsX2FzeW5jX2ZvcmsoKTtcblx0fVxuXG5cdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsKSB7XG5cdFx0ZS5mb3JrX3RpbWluZygpO1xuXHR9XG5cblx0dmFyIGJhdGNoID0gQmF0Y2guZW5zdXJlKCk7XG5cdGJhdGNoLmlzX2ZvcmsgPSB0cnVlO1xuXG5cdHZhciBjb21taXR0ZWQgPSBmYWxzZTtcblx0dmFyIHNldHRsZWQgPSBiYXRjaC5zZXR0bGVkKCk7XG5cblx0Zmx1c2hTeW5jKGZuKTtcblxuXHQvLyByZXZlcnQgc3RhdGUgY2hhbmdlc1xuXHRmb3IgKHZhciBbc291cmNlLCB2YWx1ZV0gb2YgYmF0Y2gucHJldmlvdXMpIHtcblx0XHRzb3VyY2UudiA9IHZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRjb21taXQ6IGFzeW5jICgpID0+IHtcblx0XHRcdGlmIChjb21taXR0ZWQpIHtcblx0XHRcdFx0YXdhaXQgc2V0dGxlZDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWJhdGNoZXMuaGFzKGJhdGNoKSkge1xuXHRcdFx0XHRlLmZvcmtfZGlzY2FyZGVkKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbW1pdHRlZCA9IHRydWU7XG5cblx0XHRcdGJhdGNoLmlzX2ZvcmsgPSBmYWxzZTtcblxuXHRcdFx0Ly8gYXBwbHkgY2hhbmdlc1xuXHRcdFx0Zm9yICh2YXIgW3NvdXJjZSwgdmFsdWVdIG9mIGJhdGNoLmN1cnJlbnQpIHtcblx0XHRcdFx0c291cmNlLnYgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdHJpZ2dlciBhbnkgYCRzdGF0ZS5lYWdlciguLi4pYCBleHByZXNzaW9ucyB3aXRoIHRoZSBuZXcgc3RhdGUuXG5cdFx0XHQvLyBlYWdlciBlZmZlY3RzIGRvbid0IGdldCBzY2hlZHVsZWQgbGlrZSBvdGhlciBlZmZlY3RzLCBzbyB3ZVxuXHRcdFx0Ly8gY2FuJ3QganVzdCBlbmNvdW50ZXIgdGhlbSBkdXJpbmcgdHJhdmVyc2FsLCB3ZSBuZWVkIHRvXG5cdFx0XHQvLyBwcm9hY3RpdmVseSBmbHVzaCB0aGVtXG5cdFx0XHQvLyBUT0RPIG1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgaW1wbGVtZW50YXRpb24/XG5cdFx0XHRmbHVzaFN5bmMoKCkgPT4ge1xuXHRcdFx0XHQvKiogQHR5cGUge1NldDxFZmZlY3Q+fSAqL1xuXHRcdFx0XHR2YXIgZWFnZXJfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuXHRcdFx0XHRmb3IgKHZhciBzb3VyY2Ugb2YgYmF0Y2guY3VycmVudC5rZXlzKCkpIHtcblx0XHRcdFx0XHRtYXJrX2VhZ2VyX2VmZmVjdHMoc291cmNlLCBlYWdlcl9lZmZlY3RzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNldF9lYWdlcl9lZmZlY3RzKGVhZ2VyX2VmZmVjdHMpO1xuXHRcdFx0XHRmbHVzaF9lYWdlcl9lZmZlY3RzKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0YmF0Y2gucmV2aXZlKCk7XG5cdFx0XHRhd2FpdCBzZXR0bGVkO1xuXHRcdH0sXG5cdFx0ZGlzY2FyZDogKCkgPT4ge1xuXHRcdFx0aWYgKCFjb21taXR0ZWQgJiYgYmF0Y2hlcy5oYXMoYmF0Y2gpKSB7XG5cdFx0XHRcdGJhdGNoZXMuZGVsZXRlKGJhdGNoKTtcblx0XHRcdFx0YmF0Y2guZGlzY2FyZCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBGb3JjaWJseSByZW1vdmUgYWxsIGN1cnJlbnQgYmF0Y2hlcywgdG8gcHJldmVudCBjcm9zcy10YWxrIGJldHdlZW4gdGVzdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRiYXRjaGVzLmNsZWFyKCk7XG59XG4iLCJpbXBvcnQgeyBnZXQsIHRpY2ssIHVudHJhY2sgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlZmZlY3RfdHJhY2tpbmcsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgaW5jcmVtZW50IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyB0YWcgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2RvbS90YXNrLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgYHN1YnNjcmliZWAgZnVuY3Rpb24gdGhhdCBpbnRlZ3JhdGVzIGV4dGVybmFsIGV2ZW50LWJhc2VkIHN5c3RlbXMgd2l0aCBTdmVsdGUncyByZWFjdGl2aXR5LlxuICogSXQncyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBpbnRlZ3JhdGluZyB3aXRoIHdlYiBBUElzIGxpa2UgYE1lZGlhUXVlcnlgLCBgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJgLCBvciBgV2ViU29ja2V0YC5cbiAqXG4gKiBJZiBgc3Vic2NyaWJlYCBpcyBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCAoaW5jbHVkaW5nIGluZGlyZWN0bHksIGZvciBleGFtcGxlIGluc2lkZSBhIGdldHRlciksXG4gKiB0aGUgYHN0YXJ0YCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGB1cGRhdGVgIGZ1bmN0aW9uLiBXaGVuZXZlciBgdXBkYXRlYCBpcyBjYWxsZWQsIHRoZSBlZmZlY3QgcmUtcnVucy5cbiAqXG4gKiBJZiBgc3RhcnRgIHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBlZmZlY3QgaXMgZGVzdHJveWVkLlxuICpcbiAqIElmIGBzdWJzY3JpYmVgIGlzIGNhbGxlZCBpbiBtdWx0aXBsZSBlZmZlY3RzLCBgc3RhcnRgIHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBhcyBsb25nIGFzIHRoZSBlZmZlY3RzXG4gKiBhcmUgYWN0aXZlLCBhbmQgdGhlIHJldHVybmVkIHRlYXJkb3duIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBjYWxsZWQgd2hlbiBhbGwgZWZmZWN0cyBhcmUgZGVzdHJveWVkLlxuICpcbiAqIEl0J3MgYmVzdCB1bmRlcnN0b29kIHdpdGggYW4gZXhhbXBsZS4gSGVyZSdzIGFuIGltcGxlbWVudGF0aW9uIG9mIFtgTWVkaWFRdWVyeWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUtcmVhY3Rpdml0eSNNZWRpYVF1ZXJ5KTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgY3JlYXRlU3Vic2NyaWJlciB9IGZyb20gJ3N2ZWx0ZS9yZWFjdGl2aXR5JztcbiAqIGltcG9ydCB7IG9uIH0gZnJvbSAnc3ZlbHRlL2V2ZW50cyc7XG4gKlxuICogZXhwb3J0IGNsYXNzIE1lZGlhUXVlcnkge1xuICogXHQjcXVlcnk7XG4gKiBcdCNzdWJzY3JpYmU7XG4gKlxuICogXHRjb25zdHJ1Y3RvcihxdWVyeSkge1xuICogXHRcdHRoaXMuI3F1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoYCgke3F1ZXJ5fSlgKTtcbiAqXG4gKiBcdFx0dGhpcy4jc3Vic2NyaWJlID0gY3JlYXRlU3Vic2NyaWJlcigodXBkYXRlKSA9PiB7XG4gKiBcdFx0XHQvLyB3aGVuIHRoZSBgY2hhbmdlYCBldmVudCBvY2N1cnMsIHJlLXJ1biBhbnkgZWZmZWN0cyB0aGF0IHJlYWQgYHRoaXMuY3VycmVudGBcbiAqIFx0XHRcdGNvbnN0IG9mZiA9IG9uKHRoaXMuI3F1ZXJ5LCAnY2hhbmdlJywgdXBkYXRlKTtcbiAqXG4gKiBcdFx0XHQvLyBzdG9wIGxpc3RlbmluZyB3aGVuIGFsbCB0aGUgZWZmZWN0cyBhcmUgZGVzdHJveWVkXG4gKiBcdFx0XHRyZXR1cm4gKCkgPT4gb2ZmKCk7XG4gKiBcdFx0fSk7XG4gKiBcdH1cbiAqXG4gKiBcdGdldCBjdXJyZW50KCkge1xuICogXHRcdC8vIFRoaXMgbWFrZXMgdGhlIGdldHRlciByZWFjdGl2ZSwgaWYgcmVhZCBpbiBhbiBlZmZlY3RcbiAqIFx0XHR0aGlzLiNzdWJzY3JpYmUoKTtcbiAqXG4gKiBcdFx0Ly8gUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBxdWVyeSwgd2hldGhlciBvciBub3Qgd2UncmUgaW4gYW4gZWZmZWN0XG4gKiBcdFx0cmV0dXJuIHRoaXMuI3F1ZXJ5Lm1hdGNoZXM7XG4gKiBcdH1cbiAqIH1cbiAqIGBgYFxuICogQHBhcmFtIHsodXBkYXRlOiAoKSA9PiB2b2lkKSA9PiAoKCkgPT4gdm9pZCkgfCB2b2lkfSBzdGFydFxuICogQHNpbmNlIDUuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmVyKHN0YXJ0KSB7XG5cdGxldCBzdWJzY3JpYmVycyA9IDA7XG5cdGxldCB2ZXJzaW9uID0gc291cmNlKDApO1xuXHQvKiogQHR5cGUgeygoKSA9PiB2b2lkKSB8IHZvaWR9ICovXG5cdGxldCBzdG9wO1xuXG5cdGlmIChERVYpIHtcblx0XHR0YWcodmVyc2lvbiwgJ2NyZWF0ZVN1YnNjcmliZXIgdmVyc2lvbicpO1xuXHR9XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoZWZmZWN0X3RyYWNraW5nKCkpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdGlmIChzdWJzY3JpYmVycyA9PT0gMCkge1xuXHRcdFx0XHRcdHN0b3AgPSB1bnRyYWNrKCgpID0+IHN0YXJ0KCgpID0+IGluY3JlbWVudCh2ZXJzaW9uKSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3Vic2NyaWJlcnMgKz0gMTtcblxuXHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gT25seSBjb3VudCBkb3duIGFmdGVyIGEgbWljcm90YXNrLCBlbHNlIHdlIHdvdWxkIHJlYWNoIDAgYmVmb3JlIG91ciBvd24gcmVuZGVyIGVmZmVjdCByZXJ1bnMsXG5cdFx0XHRcdFx0XHQvLyBidXQgcmVhY2ggMSBhZ2FpbiB3aGVuIHRoZSB0aWNrIGNhbGxiYWNrIG9mIHRoZSBwcmlvciB0ZWFyZG93biBydW5zLiBUaGF0IHdvdWxkIG1lYW4gd2Vcblx0XHRcdFx0XHRcdC8vIHJlLXN1YmNyaWJlIHVubmVjZXNzYXJpbHkgYW5kIGNyZWF0ZSBhIG1lbW9yeSBsZWFrIGJlY2F1c2UgdGhlIG9sZCBzdWJzY3JpcHRpb24gaXMgbmV2ZXIgY2xlYW5lZCB1cC5cblx0XHRcdFx0XHRcdHN1YnNjcmliZXJzIC09IDE7XG5cblx0XHRcdFx0XHRcdGlmIChzdWJzY3JpYmVycyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRzdG9wPy4oKTtcblx0XHRcdFx0XHRcdFx0c3RvcCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0Ly8gSW5jcmVtZW50IHRoZSB2ZXJzaW9uIHRvIGVuc3VyZSBhbnkgZGVwZW5kZW50IGRlcml2ZWRzIGFyZSBtYXJrZWQgZGlydHkgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIGlzIHBpY2tlZCB1cCBhZ2FpbiBsYXRlci5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgd2UgZGlkbid0IGRvIHRoaXMgdGhlbiB0aGUgY29tcGFyaXNvbiBvZiB3cml0ZSB2ZXJzaW9ucyB3b3VsZCBkZXRlcm1pbmUgdGhhdCB0aGUgZGVyaXZlZCBoYXMgYSBsYXRlciB2ZXJzaW9uIHRoYW5cblx0XHRcdFx0XHRcdFx0Ly8gdGhlIHN1YnNjcmliZXIsIGFuZCBpdCB3b3VsZCBub3QgYmUgcmUtcnVuLlxuXHRcdFx0XHRcdFx0XHRpbmNyZW1lbnQodmVyc2lvbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgU291cmNlLCBUZW1wbGF0ZU5vZGUsIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7XG5cdEJPVU5EQVJZX0VGRkVDVCxcblx0Q09NTUVOVF9OT0RFLFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRFRkZFQ1RfVFJBTlNQQVJFTlRcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX1NUQVJUX0VMU0UgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIHNldF9jb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaGFuZGxlX2Vycm9yLCBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuLi8uLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQge1xuXHRibG9jayxcblx0YnJhbmNoLFxuXHRkZXN0cm95X2VmZmVjdCxcblx0bW92ZV9lZmZlY3QsXG5cdHBhdXNlX2VmZmVjdFxufSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRnZXQsXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0bmV4dCxcblx0c2tpcF9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZVxufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi8uLi9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEJhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBpbnRlcm5hbF9zZXQsIHNvdXJjZSB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyB0YWcgfSBmcm9tICcuLi8uLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpYmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVhY3Rpdml0eS9jcmVhdGUtc3Vic2NyaWJlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdCBvbmVycm9yPzogKGVycm9yOiB1bmtub3duLCByZXNldDogKCkgPT4gdm9pZCkgPT4gdm9pZDtcbiAqICAgZmFpbGVkPzogKGFuY2hvcjogTm9kZSwgZXJyb3I6ICgpID0+IHVua25vd24sIHJlc2V0OiAoKSA9PiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuICogICBwZW5kaW5nPzogKGFuY2hvcjogTm9kZSkgPT4gdm9pZDtcbiAqIH19IEJvdW5kYXJ5UHJvcHNcbiAqL1xuXG52YXIgZmxhZ3MgPSBFRkZFQ1RfVFJBTlNQQVJFTlQgfCBFRkZFQ1RfUFJFU0VSVkVEIHwgQk9VTkRBUllfRUZGRUNUO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0JvdW5kYXJ5UHJvcHN9IHByb3BzXG4gKiBAcGFyYW0geygoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gY2hpbGRyZW5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmRhcnkobm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdG5ldyBCb3VuZGFyeShub2RlLCBwcm9wcywgY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgY2xhc3MgQm91bmRhcnkge1xuXHQvKiogQHR5cGUge0JvdW5kYXJ5IHwgbnVsbH0gKi9cblx0cGFyZW50O1xuXG5cdCNwZW5kaW5nID0gZmFsc2U7XG5cblx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovXG5cdCNhbmNob3I7XG5cblx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHQjaHlkcmF0ZV9vcGVuID0gaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbnVsbDtcblxuXHQvKiogQHR5cGUge0JvdW5kYXJ5UHJvcHN9ICovXG5cdCNwcm9wcztcblxuXHQvKiogQHR5cGUgeygoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gKi9cblx0I2NoaWxkcmVuO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHQjZWZmZWN0O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0I21haW5fZWZmZWN0ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdCNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHQjZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgbnVsbH0gKi9cblx0I29mZnNjcmVlbl9mcmFnbWVudCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHQjcGVuZGluZ19hbmNob3IgPSBudWxsO1xuXG5cdCNsb2NhbF9wZW5kaW5nX2NvdW50ID0gMDtcblx0I3BlbmRpbmdfY291bnQgPSAwO1xuXG5cdCNpc19jcmVhdGluZ19mYWxsYmFjayA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBBIHNvdXJjZSBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgcGVuZGluZyBhc3luYyBkZXJpdmVkcy9leHByZXNzaW9ucy5cblx0ICogT25seSBjcmVhdGVkIGlmIGAkZWZmZWN0LnBlbmRpbmcoKWAgaXMgdXNlZCBpbnNpZGUgdGhlIGJvdW5kYXJ5LFxuXHQgKiBvdGhlcndpc2UgdXBkYXRpbmcgdGhlIHNvdXJjZSByZXN1bHRzIGluIG5lZWRsZXNzIGBCYXRjaC5lbnN1cmUoKWBcblx0ICogY2FsbHMgZm9sbG93ZWQgYnkgbm8tb3AgZmx1c2hlc1xuXHQgKiBAdHlwZSB7U291cmNlPG51bWJlcj4gfCBudWxsfVxuXHQgKi9cblx0I2VmZmVjdF9wZW5kaW5nID0gbnVsbDtcblxuXHQjZWZmZWN0X3BlbmRpbmdfc3Vic2NyaWJlciA9IGNyZWF0ZVN1YnNjcmliZXIoKCkgPT4ge1xuXHRcdHRoaXMuI2VmZmVjdF9wZW5kaW5nID0gc291cmNlKHRoaXMuI2xvY2FsX3BlbmRpbmdfY291bnQpO1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0dGFnKHRoaXMuI2VmZmVjdF9wZW5kaW5nLCAnJGVmZmVjdC5wZW5kaW5nKCknKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0dGhpcy4jZWZmZWN0X3BlbmRpbmcgPSBudWxsO1xuXHRcdH07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuXHQgKiBAcGFyYW0ge0JvdW5kYXJ5UHJvcHN9IHByb3BzXG5cdCAqIEBwYXJhbSB7KChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBjaGlsZHJlblxuXHQgKi9cblx0Y29uc3RydWN0b3Iobm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdFx0dGhpcy4jYW5jaG9yID0gbm9kZTtcblx0XHR0aGlzLiNwcm9wcyA9IHByb3BzO1xuXHRcdHRoaXMuI2NoaWxkcmVuID0gY2hpbGRyZW47XG5cblx0XHR0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuYjtcblxuXHRcdHRoaXMuI3BlbmRpbmcgPSAhIXRoaXMuI3Byb3BzLnBlbmRpbmc7XG5cblx0XHR0aGlzLiNlZmZlY3QgPSBibG9jaygoKSA9PiB7XG5cdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmIgPSB0aGlzO1xuXG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdGNvbnN0IGNvbW1lbnQgPSB0aGlzLiNoeWRyYXRlX29wZW47XG5cdFx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXG5cdFx0XHRcdGNvbnN0IHNlcnZlcl9yZW5kZXJlZF9wZW5kaW5nID1cblx0XHRcdFx0XHQvKiogQHR5cGUge0NvbW1lbnR9ICovIChjb21tZW50KS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoY29tbWVudCkuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0U7XG5cblx0XHRcdFx0aWYgKHNlcnZlcl9yZW5kZXJlZF9wZW5kaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy4jaHlkcmF0ZV9wZW5kaW5nX2NvbnRlbnQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLiNoeWRyYXRlX3Jlc29sdmVkX2NvbnRlbnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHRoaXMuI2dldF9hbmNob3IoKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMuI21haW5fZWZmZWN0ID0gYnJhbmNoKCgpID0+IGNoaWxkcmVuKGFuY2hvcikpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuI3BlbmRpbmdfY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy4jc2hvd19wZW5kaW5nX3NuaXBwZXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0dGhpcy4jcGVuZGluZ19hbmNob3I/LnJlbW92ZSgpO1xuXHRcdFx0fTtcblx0XHR9LCBmbGFncyk7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHR0aGlzLiNhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXHR9XG5cblx0I2h5ZHJhdGVfcmVzb2x2ZWRfY29udGVudCgpIHtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy4jbWFpbl9lZmZlY3QgPSBicmFuY2goKCkgPT4gdGhpcy4jY2hpbGRyZW4odGhpcy4jYW5jaG9yKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHRoaXMuZXJyb3IoZXJyb3IpO1xuXHRcdH1cblxuXHRcdC8vIFNpbmNlIHNlcnZlciByZW5kZXJlZCByZXNvbHZlZCBjb250ZW50LCB3ZSBuZXZlciBzaG93IHBlbmRpbmcgc3RhdGVcblx0XHQvLyBFdmVuIGlmIGNsaWVudC1zaWRlIGFzeW5jIG9wZXJhdGlvbnMgYXJlIHN0aWxsIHJ1bm5pbmcsIHRoZSBjb250ZW50IGlzIGFscmVhZHkgZGlzcGxheWVkXG5cdFx0dGhpcy4jcGVuZGluZyA9IGZhbHNlO1xuXHR9XG5cblx0I2h5ZHJhdGVfcGVuZGluZ19jb250ZW50KCkge1xuXHRcdGNvbnN0IHBlbmRpbmcgPSB0aGlzLiNwcm9wcy5wZW5kaW5nO1xuXHRcdGlmICghcGVuZGluZykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBwZW5kaW5nKHRoaXMuI2FuY2hvcikpO1xuXG5cdFx0QmF0Y2guZW5xdWV1ZSgoKSA9PiB7XG5cdFx0XHR2YXIgYW5jaG9yID0gdGhpcy4jZ2V0X2FuY2hvcigpO1xuXG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IHRoaXMuI3J1bigoKSA9PiB7XG5cdFx0XHRcdEJhdGNoLmVuc3VyZSgpO1xuXHRcdFx0XHRyZXR1cm4gYnJhbmNoKCgpID0+IHRoaXMuI2NoaWxkcmVuKGFuY2hvcikpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLiNwZW5kaW5nX2NvdW50ID4gMCkge1xuXHRcdFx0XHR0aGlzLiNzaG93X3BlbmRpbmdfc25pcHBldCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAodGhpcy4jcGVuZGluZ19lZmZlY3QpLCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQjZ2V0X2FuY2hvcigpIHtcblx0XHR2YXIgYW5jaG9yID0gdGhpcy4jYW5jaG9yO1xuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmcpIHtcblx0XHRcdHRoaXMuI3BlbmRpbmdfYW5jaG9yID0gY3JlYXRlX3RleHQoKTtcblx0XHRcdHRoaXMuI2FuY2hvci5iZWZvcmUodGhpcy4jcGVuZGluZ19hbmNob3IpO1xuXG5cdFx0XHRhbmNob3IgPSB0aGlzLiNwZW5kaW5nX2FuY2hvcjtcblx0XHR9XG5cblx0XHRyZXR1cm4gYW5jaG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlZmZlY3QgZXhpc3RzIGluc2lkZSBhIGJvdW5kYXJ5IHdob3NlIHBlbmRpbmcgc25pcHBldCBpcyBzaG93blxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzX3BlbmRpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuI3BlbmRpbmcgfHwgKCEhdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNfcGVuZGluZygpKTtcblx0fVxuXG5cdGhhc19wZW5kaW5nX3NuaXBwZXQoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy4jcHJvcHMucGVuZGluZztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0geygpID0+IEVmZmVjdCB8IG51bGx9IGZuXG5cdCAqL1xuXHQjcnVuKGZuKSB7XG5cdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdFx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHRcdHZhciBwcmV2aW91c19jdHggPSBjb21wb25lbnRfY29udGV4dDtcblxuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHRoaXMuI2VmZmVjdCk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbih0aGlzLiNlZmZlY3QpO1xuXHRcdHNldF9jb21wb25lbnRfY29udGV4dCh0aGlzLiNlZmZlY3QuY3R4KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4oKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRoYW5kbGVfZXJyb3IoZSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdFx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHByZXZpb3VzX2N0eCk7XG5cdFx0fVxuXHR9XG5cblx0I3Nob3dfcGVuZGluZ19zbmlwcGV0KCkge1xuXHRcdGNvbnN0IHBlbmRpbmcgPSAvKiogQHR5cGUgeyhhbmNob3I6IE5vZGUpID0+IHZvaWR9ICovICh0aGlzLiNwcm9wcy5wZW5kaW5nKTtcblxuXHRcdGlmICh0aGlzLiNtYWluX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50LmFwcGVuZCgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKHRoaXMuI3BlbmRpbmdfYW5jaG9yKSk7XG5cdFx0XHRtb3ZlX2VmZmVjdCh0aGlzLiNtYWluX2VmZmVjdCwgdGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy4jcGVuZGluZ19lZmZlY3QgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuI3BlbmRpbmdfZWZmZWN0ID0gYnJhbmNoKCgpID0+IHBlbmRpbmcodGhpcy4jYW5jaG9yKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHBlbmRpbmcgY291bnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBwZW5kaW5nIHNuaXBwZXQsXG5cdCAqIGlmIGFueSwgc3VjaCB0aGF0IHdlIGNhbiByZXBsYWNlIHRoZSBzbmlwcGV0IHdpdGggY29udGVudCBvbmNlIHdvcmsgaXMgZG9uZVxuXHQgKiBAcGFyYW0gezEgfCAtMX0gZFxuXHQgKi9cblx0I3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpIHtcblx0XHRpZiAoIXRoaXMuaGFzX3BlbmRpbmdfc25pcHBldCgpKSB7XG5cdFx0XHRpZiAodGhpcy5wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQuI3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgaW4gYSBzY29wZSB3aXRoIG5vIHBlbmRpbmcgc25pcHBldFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuI3BlbmRpbmdfY291bnQgKz0gZDtcblxuXHRcdGlmICh0aGlzLiNwZW5kaW5nX2NvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLiNwZW5kaW5nID0gZmFsc2U7XG5cblx0XHRcdGlmICh0aGlzLiNwZW5kaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QodGhpcy4jcGVuZGluZ19lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KSB7XG5cdFx0XHRcdHRoaXMuI2FuY2hvci5iZWZvcmUodGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBzb3VyY2UgdGhhdCBwb3dlcnMgYCRlZmZlY3QucGVuZGluZygpYCBpbnNpZGUgdGhpcyBib3VuZGFyeSxcblx0ICogYW5kIGNvbnRyb2xzIHdoZW4gdGhlIGN1cnJlbnQgYHBlbmRpbmdgIHNuaXBwZXQgKGlmIGFueSkgaXMgcmVtb3ZlZC5cblx0ICogRG8gbm90IGNhbGwgZnJvbSBpbnNpZGUgdGhlIGNsYXNzXG5cdCAqIEBwYXJhbSB7MSB8IC0xfSBkXG5cdCAqL1xuXHR1cGRhdGVfcGVuZGluZ19jb3VudChkKSB7XG5cdFx0dGhpcy4jdXBkYXRlX3BlbmRpbmdfY291bnQoZCk7XG5cblx0XHR0aGlzLiNsb2NhbF9wZW5kaW5nX2NvdW50ICs9IGQ7XG5cblx0XHRpZiAodGhpcy4jZWZmZWN0X3BlbmRpbmcpIHtcblx0XHRcdGludGVybmFsX3NldCh0aGlzLiNlZmZlY3RfcGVuZGluZywgdGhpcy4jbG9jYWxfcGVuZGluZ19jb3VudCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0X2VmZmVjdF9wZW5kaW5nKCkge1xuXHRcdHRoaXMuI2VmZmVjdF9wZW5kaW5nX3N1YnNjcmliZXIoKTtcblx0XHRyZXR1cm4gZ2V0KC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovICh0aGlzLiNlZmZlY3RfcGVuZGluZykpO1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgKi9cblx0ZXJyb3IoZXJyb3IpIHtcblx0XHR2YXIgb25lcnJvciA9IHRoaXMuI3Byb3BzLm9uZXJyb3I7XG5cdFx0bGV0IGZhaWxlZCA9IHRoaXMuI3Byb3BzLmZhaWxlZDtcblxuXHRcdC8vIElmIHdlIGhhdmUgbm90aGluZyB0byBjYXB0dXJlIHRoZSBlcnJvciwgb3IgaWYgd2UgaGl0IGFuIGVycm9yIHdoaWxlXG5cdFx0Ly8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjaywgcmUtdGhyb3cgZm9yIGFub3RoZXIgYm91bmRhcnkgdG8gaGFuZGxlXG5cdFx0aWYgKHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrIHx8ICghb25lcnJvciAmJiAhZmFpbGVkKSkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI21haW5fZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNtYWluX2VmZmVjdCk7XG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmdfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNwZW5kaW5nX2VmZmVjdCk7XG5cdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2ZhaWxlZF9lZmZlY3QpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KHRoaXMuI2ZhaWxlZF9lZmZlY3QpO1xuXHRcdFx0dGhpcy4jZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKHRoaXMuI2h5ZHJhdGVfb3BlbikpO1xuXHRcdFx0bmV4dCgpO1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShza2lwX25vZGVzKCkpO1xuXHRcdH1cblxuXHRcdHZhciBkaWRfcmVzZXQgPSBmYWxzZTtcblx0XHR2YXIgY2FsbGluZ19vbl9lcnJvciA9IGZhbHNlO1xuXG5cdFx0Y29uc3QgcmVzZXQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoZGlkX3Jlc2V0KSB7XG5cdFx0XHRcdHcuc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X25vb3AoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkaWRfcmVzZXQgPSB0cnVlO1xuXG5cdFx0XHRpZiAoY2FsbGluZ19vbl9lcnJvcikge1xuXHRcdFx0XHRlLnN2ZWx0ZV9ib3VuZGFyeV9yZXNldF9vbmVycm9yKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBmYWlsdXJlIGhhcHBlbmVkIHdoaWxlIGZsdXNoaW5nIGVmZmVjdHMsIGN1cnJlbnRfYmF0Y2ggY2FuIGJlIG51bGxcblx0XHRcdEJhdGNoLmVuc3VyZSgpO1xuXG5cdFx0XHR0aGlzLiNsb2NhbF9wZW5kaW5nX2NvdW50ID0gMDtcblxuXHRcdFx0aWYgKHRoaXMuI2ZhaWxlZF9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KHRoaXMuI2ZhaWxlZF9lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiNmYWlsZWRfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGludGVudGlvbmFsbHkgZG8gbm90IHRyeSB0byBmaW5kIHRoZSBuZWFyZXN0IHBlbmRpbmcgYm91bmRhcnkuIElmIHRoaXMgYm91bmRhcnkgaGFzIG9uZSwgd2UnbGwgcmVuZGVyIGl0IG9uIHJlc2V0XG5cdFx0XHQvLyBidXQgaXQgd291bGQgYmUgcmVhbGx5IHdlaXJkIHRvIHNob3cgdGhlIHBhcmVudCdzIGJvdW5kYXJ5IG9uIGEgY2hpbGQgcmVzZXQuXG5cdFx0XHR0aGlzLiNwZW5kaW5nID0gdGhpcy5oYXNfcGVuZGluZ19zbmlwcGV0KCk7XG5cblx0XHRcdHRoaXMuI21haW5fZWZmZWN0ID0gdGhpcy4jcnVuKCgpID0+IHtcblx0XHRcdFx0dGhpcy4jaXNfY3JlYXRpbmdfZmFsbGJhY2sgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIGJyYW5jaCgoKSA9PiB0aGlzLiNjaGlsZHJlbih0aGlzLiNhbmNob3IpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy4jcGVuZGluZ19jb3VudCA+IDApIHtcblx0XHRcdFx0dGhpcy4jc2hvd19wZW5kaW5nX3NuaXBwZXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuI3BlbmRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0XHRjYWxsaW5nX29uX2Vycm9yID0gdHJ1ZTtcblx0XHRcdG9uZXJyb3I/LihlcnJvciwgcmVzZXQpO1xuXHRcdFx0Y2FsbGluZ19vbl9lcnJvciA9IGZhbHNlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIHRoaXMuI2VmZmVjdCAmJiB0aGlzLiNlZmZlY3QucGFyZW50KTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0fVxuXG5cdFx0aWYgKGZhaWxlZCkge1xuXHRcdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRcdHRoaXMuI2ZhaWxlZF9lZmZlY3QgPSB0aGlzLiNydW4oKCkgPT4ge1xuXHRcdFx0XHRcdEJhdGNoLmVuc3VyZSgpO1xuXHRcdFx0XHRcdHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrID0gdHJ1ZTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0ZmFpbGVkKFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuI2FuY2hvcixcblx0XHRcdFx0XHRcdFx0XHQoKSA9PiBlcnJvcixcblx0XHRcdFx0XHRcdFx0XHQoKSA9PiByZXNldFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgLyoqIEB0eXBlIHtFZmZlY3R9ICovICh0aGlzLiNlZmZlY3QucGFyZW50KSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0dGhpcy4jaXNfY3JlYXRpbmdfZmFsbGJhY2sgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYm91bmRhcnkoKSB7XG5cdHJldHVybiAvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5iKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBlbmRpbmcoKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uKCk7XG5cdH1cblxuXHR2YXIgYm91bmRhcnkgPSBhY3RpdmVfZWZmZWN0LmI7XG5cblx0aWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIDA7IC8vIFRPRE8gZXZlbnR1YWxseSB3ZSB3aWxsIG5lZWQgdGhpcyB0byBiZSBnbG9iYWxcblx0fVxuXG5cdHJldHVybiBib3VuZGFyeS5nZXRfZWZmZWN0X3BlbmRpbmcoKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFU1RST1lFRCwgU1RBTEVfUkVBQ1RJT04gfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdGNvbXBvbmVudF9jb250ZXh0LFxuXHRkZXZfc3RhY2ssXG5cdGlzX3J1bmVzLFxuXHRzZXRfY29tcG9uZW50X2NvbnRleHQsXG5cdHNldF9kZXZfc3RhY2tcbn0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBnZXRfYm91bmRhcnkgfSBmcm9tICcuLi9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzJztcbmltcG9ydCB7IGludm9rZV9lcnJvcl9ib3VuZGFyeSB9IGZyb20gJy4uL2Vycm9yLWhhbmRsaW5nLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBCYXRjaCwgY3VycmVudF9iYXRjaCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHtcblx0YXN5bmNfZGVyaXZlZCxcblx0Y3VycmVudF9hc3luY19lZmZlY3QsXG5cdGRlcml2ZWQsXG5cdGRlcml2ZWRfc2FmZV9lcXVhbCxcblx0c2V0X2Zyb21fYXN5bmNfZGVyaXZlZFxufSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IGFib3J0ZWQgfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUsIHNraXBfbm9kZXMgfSBmcm9tICcuLi9kb20vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBhbnk+fSBzeW5jXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IFByb21pc2U8YW55Pj59IGFzeW5jXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFZhbHVlW10pID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYmxvY2tlcnMsIHN5bmMsIGFzeW5jLCBmbikge1xuXHRjb25zdCBkID0gaXNfcnVuZXMoKSA/IGRlcml2ZWQgOiBkZXJpdmVkX3NhZmVfZXF1YWw7XG5cblx0aWYgKGFzeW5jLmxlbmd0aCA9PT0gMCAmJiBibG9ja2Vycy5sZW5ndGggPT09IDApIHtcblx0XHRmbihzeW5jLm1hcChkKSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGJhdGNoID0gY3VycmVudF9iYXRjaDtcblx0dmFyIHBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0dmFyIHJlc3RvcmUgPSBjYXB0dXJlKCk7XG5cblx0ZnVuY3Rpb24gcnVuKCkge1xuXHRcdFByb21pc2UuYWxsKGFzeW5jLm1hcCgoZXhwcmVzc2lvbikgPT4gYXN5bmNfZGVyaXZlZChleHByZXNzaW9uKSkpXG5cdFx0XHQudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRcdHJlc3RvcmUoKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZuKFsuLi5zeW5jLm1hcChkKSwgLi4ucmVzdWx0XSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gaWdub3JlIGVycm9ycyBpbiBibG9ja3MgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcblx0XHRcdFx0XHRpZiAoKHBhcmVudC5mICYgREVTVFJPWUVEKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBwYXJlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhdGNoPy5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgcGFyZW50KTtcblx0XHRcdH0pO1xuXHR9XG5cblx0aWYgKGJsb2NrZXJzLmxlbmd0aCA+IDApIHtcblx0XHRQcm9taXNlLmFsbChibG9ja2VycykudGhlbigoKSA9PiB7XG5cdFx0XHRyZXN0b3JlKCk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBydW4oKTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdGJhdGNoPy5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRydW4oKTtcblx0fVxufVxuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBjdXJyZW50IGVmZmVjdCBjb250ZXh0IHNvIHRoYXQgd2UgY2FuIHJlc3RvcmUgaXQgYWZ0ZXJcbiAqIHNvbWUgYXN5bmNocm9ub3VzIHdvcmsgaGFzIGhhcHBlbmVkIChzbyB0aGF0IGUuZy4gYGF3YWl0IGEgKyBiYFxuICogY2F1c2VzIGBiYCB0byBiZSByZWdpc3RlcmVkIGFzIGEgZGVwZW5kZW5jeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlKCkge1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0dmFyIHByZXZpb3VzX2JhdGNoID0gY3VycmVudF9iYXRjaDtcblxuXHRpZiAoREVWKSB7XG5cdFx0dmFyIHByZXZpb3VzX2Rldl9zdGFjayA9IGRldl9zdGFjaztcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiByZXN0b3JlKGFjdGl2YXRlX2JhdGNoID0gdHJ1ZSkge1xuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0KTtcblx0XHRpZiAoYWN0aXZhdGVfYmF0Y2gpIHByZXZpb3VzX2JhdGNoPy5hY3RpdmF0ZSgpO1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0c2V0X2Zyb21fYXN5bmNfZGVyaXZlZChudWxsKTtcblx0XHRcdHNldF9kZXZfc3RhY2socHJldmlvdXNfZGV2X3N0YWNrKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogV3JhcHMgYW4gYGF3YWl0YCBleHByZXNzaW9uIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgZWZmZWN0IGNvbnRleHQgdGhhdCB3YXNcbiAqIGFjdGl2ZSBiZWZvcmUgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVkIGNhbiBiZSByZWFwcGxpZWQgYWZ0ZXJ3YXJkcyDigJRcbiAqIGBhd2FpdCBhICsgYmAgYmVjb21lcyBgKGF3YWl0ICQuc2F2ZShhKSkoKSArIGJgXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwoKSA9PiBUPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmUocHJvbWlzZSkge1xuXHR2YXIgcmVzdG9yZSA9IGNhcHR1cmUoKTtcblx0dmFyIHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdHJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG59XG5cbi8qKlxuICogUmVzZXQgYGN1cnJlbnRfYXN5bmNfZWZmZWN0YCBhZnRlciB0aGUgYHByb21pc2VgIHJlc29sdmVzLCBzb1xuICogdGhhdCB3ZSBjYW4gZW1pdCBgYXdhaXRfcmVhY3Rpdml0eV9sb3NzYCB3YXJuaW5nc1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZVxuICogQHJldHVybnMge1Byb21pc2U8KCkgPT4gVD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFja19yZWFjdGl2aXR5X2xvc3MocHJvbWlzZSkge1xuXHR2YXIgcHJldmlvdXNfYXN5bmNfZWZmZWN0ID0gY3VycmVudF9hc3luY19lZmZlY3Q7XG5cdHZhciB2YWx1ZSA9IGF3YWl0IHByb21pc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRzZXRfZnJvbV9hc3luY19kZXJpdmVkKHByZXZpb3VzX2FzeW5jX2VmZmVjdCk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xufVxuXG4vKipcbiAqIFVzZWQgaW4gYGZvciBhd2FpdGAgbG9vcHMgaW4gREVWLCBzb1xuICogdGhhdCB3ZSBjYW4gZW1pdCBgYXdhaXRfcmVhY3Rpdml0eV9sb3NzYCB3YXJuaW5nc1xuICogYWZ0ZXIgZWFjaCBgYXN5bmNfaXRlcmF0b3JgIHJlc3VsdCByZXNvbHZlcyBhbmRcbiAqIGFmdGVyIHRoZSBgYXN5bmNfaXRlcmF0b3JgIHJldHVybiByZXNvbHZlcyAoaWYgaXQgcnVucylcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgVFJldHVyblxuICogQHBhcmFtIHtJdGVyYWJsZTxUPiB8IEFzeW5jSXRlcmFibGU8VD59IGl0ZXJhYmxlXG4gKiBAcmV0dXJucyB7QXN5bmNHZW5lcmF0b3I8VCwgVFJldHVybiB8IHVuZGVmaW5lZD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogZm9yX2F3YWl0X3RyYWNrX3JlYWN0aXZpdHlfbG9zcyhpdGVyYWJsZSkge1xuXHQvLyBUaGlzIGlzIGJhc2VkIG9uIHRoZSBhbGdvcml0aG1zIGRlc2NyaWJlZCBpbiBFQ01BLTI2Mjpcblx0Ly8gRm9ySW4vT2ZCb2R5RXZhbHVhdGlvblxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi9tdWx0aXBhZ2UvZWNtYXNjcmlwdC1sYW5ndWFnZS1zdGF0ZW1lbnRzLWFuZC1kZWNsYXJhdGlvbnMuaHRtbCNzZWMtcnVudGltZS1zZW1hbnRpY3MtZm9yaW4tZGl2LW9mYm9keWV2YWx1YXRpb24tbGhzLXN0bXQtaXRlcmF0b3ItbGhza2luZC1sYWJlbHNldFxuXHQvLyBBc3luY0l0ZXJhdG9yQ2xvc2Vcblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvbXVsdGlwYWdlL2Fic3RyYWN0LW9wZXJhdGlvbnMuaHRtbCNzZWMtYXN5bmNpdGVyYXRvcmNsb3NlXG5cblx0LyoqIEB0eXBlIHtBc3luY0l0ZXJhdG9yPFQsIFRSZXR1cm4+fSAqL1xuXHQvLyBAdHMtaWdub3JlXG5cdGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPy4oKSA/PyBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdPy4oKTtcblxuXHRpZiAoaXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhc3luYyBpdGVyYWJsZScpO1xuXHR9XG5cblx0LyoqIFdoZXRoZXIgdGhlIGNvbXBsZXRpb24gb2YgdGhlIGl0ZXJhdG9yIHdhcyBcIm5vcm1hbFwiLCBtZWFuaW5nIGl0IHdhc24ndCBlbmRlZCB2aWEgYGJyZWFrYCBvciBhIHNpbWlsYXIgbWV0aG9kICovXG5cdGxldCBub3JtYWxfY29tcGxldGlvbiA9IGZhbHNlO1xuXHR0cnkge1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSAoYXdhaXQgdHJhY2tfcmVhY3Rpdml0eV9sb3NzKGl0ZXJhdG9yLm5leHQoKSkpKCk7XG5cdFx0XHRpZiAoZG9uZSkge1xuXHRcdFx0XHRub3JtYWxfY29tcGxldGlvbiA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0eWllbGQgdmFsdWU7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdC8vIElmIHRoZSBpdGVyYXRvciBoYWQgYSBub3JtYWwgY29tcGxldGlvbiBhbmQgYHJldHVybmAgaXMgZGVmaW5lZCBvbiB0aGUgaXRlcmF0b3IsIGNhbGwgaXQgYW5kIHJldHVybiB0aGUgdmFsdWVcblx0XHRpZiAobm9ybWFsX2NvbXBsZXRpb24gJiYgaXRlcmF0b3IucmV0dXJuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnNhZmUtZmluYWxseVxuXHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7VFJldHVybn0gKi8gKChhd2FpdCB0cmFja19yZWFjdGl2aXR5X2xvc3MoaXRlcmF0b3IucmV0dXJuKCkpKSgpLnZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2V0X2NvbnRleHQoKSB7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfY29tcG9uZW50X2NvbnRleHQobnVsbCk7XG5cblx0aWYgKERFVikge1xuXHRcdHNldF9mcm9tX2FzeW5jX2Rlcml2ZWQobnVsbCk7XG5cdFx0c2V0X2Rldl9zdGFjayhudWxsKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBhbmNob3JcbiAqIEBwYXJhbSB7KHRhcmdldDogVGVtcGxhdGVOb2RlKSA9PiBQcm9taXNlPHZvaWQ+fSBmblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNfYm9keShhbmNob3IsIGZuKSB7XG5cdHZhciBib3VuZGFyeSA9IGdldF9ib3VuZGFyeSgpO1xuXHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAoY3VycmVudF9iYXRjaCk7XG5cdHZhciBibG9ja2luZyA9ICFib3VuZGFyeS5pc19wZW5kaW5nKCk7XG5cblx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoMSk7XG5cdGJhdGNoLmluY3JlbWVudChibG9ja2luZyk7XG5cblx0dmFyIGFjdGl2ZSA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0dmFyIHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdHZhciBuZXh0X2h5ZHJhdGVfbm9kZSA9IHVuZGVmaW5lZDtcblxuXHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdG5leHRfaHlkcmF0ZV9ub2RlID0gc2tpcF9ub2RlcyhmYWxzZSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdHZhciBwcm9taXNlID0gZm4oYW5jaG9yKTtcblx0fSBmaW5hbGx5IHtcblx0XHRpZiAobmV4dF9oeWRyYXRlX25vZGUpIHtcblx0XHRcdHNldF9oeWRyYXRlX25vZGUobmV4dF9oeWRyYXRlX25vZGUpO1xuXHRcdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0fVxuXHR9XG5cblx0dHJ5IHtcblx0XHRhd2FpdCBwcm9taXNlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmICghYWJvcnRlZChhY3RpdmUpKSB7XG5cdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGFjdGl2ZSk7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KC0xKTtcblx0XHRiYXRjaC5kZWNyZW1lbnQoYmxvY2tpbmcpO1xuXG5cdFx0dW5zZXRfY29udGV4dCgpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTwoKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPj59IHRodW5rc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuKHRodW5rcykge1xuXHRjb25zdCByZXN0b3JlID0gY2FwdHVyZSgpO1xuXG5cdHZhciBib3VuZGFyeSA9IGdldF9ib3VuZGFyeSgpO1xuXHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAoY3VycmVudF9iYXRjaCk7XG5cdHZhciBibG9ja2luZyA9ICFib3VuZGFyeS5pc19wZW5kaW5nKCk7XG5cblx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoMSk7XG5cdGJhdGNoLmluY3JlbWVudChibG9ja2luZyk7XG5cblx0dmFyIGFjdGl2ZSA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0LyoqIEB0eXBlIHtudWxsIHwgeyBlcnJvcjogYW55IH19ICovXG5cdHZhciBlcnJvcmVkID0gbnVsbDtcblxuXHQvKiogQHBhcmFtIHthbnl9IGVycm9yICovXG5cdGNvbnN0IGhhbmRsZV9lcnJvciA9IChlcnJvcikgPT4ge1xuXHRcdGVycm9yZWQgPSB7IGVycm9yIH07IC8vIHdyYXAgaW4gb2JqZWN0IGluIGNhc2UgYSBwcm9taXNlIHJlamVjdHMgd2l0aCBhIGZhbHN5IHZhbHVlXG5cblx0XHRpZiAoIWFib3J0ZWQoYWN0aXZlKSkge1xuXHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBhY3RpdmUpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aHVua3NbMF0oKSkuY2F0Y2goaGFuZGxlX2Vycm9yKTtcblxuXHR2YXIgcHJvbWlzZXMgPSBbcHJvbWlzZV07XG5cblx0Zm9yIChjb25zdCBmbiBvZiB0aHVua3Muc2xpY2UoMSkpIHtcblx0XHRwcm9taXNlID0gcHJvbWlzZVxuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoZXJyb3JlZCkge1xuXHRcdFx0XHRcdHRocm93IGVycm9yZWQuZXJyb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWJvcnRlZChhY3RpdmUpKSB7XG5cdFx0XHRcdFx0dGhyb3cgU1RBTEVfUkVBQ1RJT047XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlc3RvcmUoKTtcblx0XHRcdFx0XHRyZXR1cm4gZm4oKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHQvLyBUT0RPIGRvIHdlIG5lZWQgaXQgaGVyZSBhcyB3ZWxsIGFzIGJlbG93P1xuXHRcdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5jYXRjaChoYW5kbGVfZXJyb3IpXG5cdFx0XHQuZmluYWxseSgoKSA9PiB7XG5cdFx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHRcdH0pO1xuXG5cdFx0cHJvbWlzZXMucHVzaChwcm9taXNlKTtcblx0fVxuXG5cdHByb21pc2Vcblx0XHQvLyB3YWl0IG9uZSBtb3JlIHRpY2ssIHNvIHRoYXQgdGVtcGxhdGUgZWZmZWN0cyBhcmVcblx0XHQvLyBndWFyYW50ZWVkIHRvIHJ1biBiZWZvcmUgYCRlZmZlY3QoLi4uKWBcblx0XHQudGhlbigoKSA9PiBQcm9taXNlLnJlc29sdmUoKSlcblx0XHQuZmluYWxseSgoKSA9PiB7XG5cdFx0XHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgtMSk7XG5cdFx0XHRiYXRjaC5kZWNyZW1lbnQoYmxvY2tpbmcpO1xuXHRcdH0pO1xuXG5cdHJldHVybiBwcm9taXNlcztcbn1cbiIsIi8qKiBAaW1wb3J0IHsgRGVyaXZlZCwgRWZmZWN0LCBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4vYmF0Y2guanMnOyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRFUlJPUl9WQUxVRSxcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdERJUlRZLFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRNQVlCRV9ESVJUWSxcblx0U1RBTEVfUkVBQ1RJT04sXG5cdFVOT1dORUQsXG5cdEFTWU5DLFxuXHRXQVNfTUFSS0VEXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0YWN0aXZlX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHNraXBfcmVhY3Rpb24sXG5cdHVwZGF0ZV9yZWFjdGlvbixcblx0aW5jcmVtZW50X3dyaXRlX3ZlcnNpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRwdXNoX3JlYWN0aW9uX3ZhbHVlLFxuXHRpc19kZXN0cm95aW5nX2VmZmVjdFxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVxdWFscywgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgYXN5bmNfZWZmZWN0LCBkZXN0cm95X2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZWFnZXJfZWZmZWN0cywgaW50ZXJuYWxfc2V0LCBzZXRfZWFnZXJfZWZmZWN0cywgc291cmNlIH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGdldF9zdGFjayB9IGZyb20gJy4uL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZywgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBCb3VuZGFyeSB9IGZyb20gJy4uL2RvbS9ibG9ja3MvYm91bmRhcnkuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYmF0Y2hfdmFsdWVzLCBjdXJyZW50X2JhdGNoIH0gZnJvbSAnLi9iYXRjaC5qcyc7XG5pbXBvcnQgeyB1bnNldF9jb250ZXh0IH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBkZWZlcnJlZCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY3VycmVudF9hc3luY19lZmZlY3QgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtFZmZlY3QgfCBudWxsfSB2ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Zyb21fYXN5bmNfZGVyaXZlZCh2KSB7XG5cdGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gdjtcbn1cblxuZXhwb3J0IGNvbnN0IHJlY2VudF9hc3luY19kZXJpdmVkcyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWQoZm4pIHtcblx0dmFyIGZsYWdzID0gREVSSVZFRCB8IERJUlRZO1xuXHR2YXIgcGFyZW50X2Rlcml2ZWQgPVxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMFxuXHRcdFx0PyAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChhY3RpdmVfcmVhY3Rpb24pXG5cdFx0XHQ6IG51bGw7XG5cblx0aWYgKGFjdGl2ZV9lZmZlY3QgPT09IG51bGwgfHwgKHBhcmVudF9kZXJpdmVkICE9PSBudWxsICYmIChwYXJlbnRfZGVyaXZlZC5mICYgVU5PV05FRCkgIT09IDApKSB7XG5cdFx0ZmxhZ3MgfD0gVU5PV05FRDtcblx0fSBlbHNlIHtcblx0XHQvLyBTaW5jZSBkZXJpdmVkcyBhcmUgZXZhbHVhdGVkIGxhemlseSwgYW55IGVmZmVjdHMgY3JlYXRlZCBpbnNpZGUgdGhlbSBhcmVcblx0XHQvLyBjcmVhdGVkIHRvbyBsYXRlIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXJlbnQgZWZmZWN0IGlzIGFkZGVkIHRvIHRoZSB0cmVlXG5cdFx0YWN0aXZlX2VmZmVjdC5mIHw9IEVGRkVDVF9QUkVTRVJWRUQ7XG5cdH1cblxuXHQvKiogQHR5cGUge0Rlcml2ZWQ8Vj59ICovXG5cdGNvbnN0IHNpZ25hbCA9IHtcblx0XHRjdHg6IGNvbXBvbmVudF9jb250ZXh0LFxuXHRcdGRlcHM6IG51bGwsXG5cdFx0ZWZmZWN0czogbnVsbCxcblx0XHRlcXVhbHMsXG5cdFx0ZjogZmxhZ3MsXG5cdFx0Zm4sXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdHJ2OiAwLFxuXHRcdHY6IC8qKiBAdHlwZSB7Vn0gKi8gKFVOSU5JVElBTElaRUQpLFxuXHRcdHd2OiAwLFxuXHRcdHBhcmVudDogcGFyZW50X2Rlcml2ZWQgPz8gYWN0aXZlX2VmZmVjdCxcblx0XHRhYzogbnVsbFxuXHR9O1xuXG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzaWduYWwuY3JlYXRlZCA9IGdldF9zdGFjaygnY3JlYXRlZCBhdCcpO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWIHwgUHJvbWlzZTxWPn0gZm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbG9jYXRpb25dIElmIHByb3ZpZGVkLCBwcmludCBhIHdhcm5pbmcgaWYgdGhlIHZhbHVlIGlzIG5vdCByZWFkIGltbWVkaWF0ZWx5IGFmdGVyIHVwZGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8U291cmNlPFY+Pn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNfZGVyaXZlZChmbiwgbG9jYXRpb24pIHtcblx0bGV0IHBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdGlmIChwYXJlbnQgPT09IG51bGwpIHtcblx0XHRlLmFzeW5jX2Rlcml2ZWRfb3JwaGFuKCk7XG5cdH1cblxuXHR2YXIgYm91bmRhcnkgPSAvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAocGFyZW50LmIpO1xuXG5cdHZhciBwcm9taXNlID0gLyoqIEB0eXBlIHtQcm9taXNlPFY+fSAqLyAoLyoqIEB0eXBlIHt1bmtub3dufSAqLyAodW5kZWZpbmVkKSk7XG5cdHZhciBzaWduYWwgPSBzb3VyY2UoLyoqIEB0eXBlIHtWfSAqLyAoVU5JTklUSUFMSVpFRCkpO1xuXG5cdC8vIG9ubHkgc3VzcGVuZCBpbiBhc3luYyBkZXJpdmVkcyBjcmVhdGVkIG9uIGluaXRpYWxpc2F0aW9uXG5cdHZhciBzaG91bGRfc3VzcGVuZCA9ICFhY3RpdmVfcmVhY3Rpb247XG5cblx0LyoqIEB0eXBlIHtNYXA8QmF0Y2gsIFJldHVyblR5cGU8dHlwZW9mIGRlZmVycmVkPFY+Pj59ICovXG5cdHZhciBkZWZlcnJlZHMgPSBuZXcgTWFwKCk7XG5cblx0YXN5bmNfZWZmZWN0KCgpID0+IHtcblx0XHRpZiAoREVWKSBjdXJyZW50X2FzeW5jX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0XHQvKiogQHR5cGUge1JldHVyblR5cGU8dHlwZW9mIGRlZmVycmVkPFY+Pn0gKi9cblx0XHR2YXIgZCA9IGRlZmVycmVkKCk7XG5cdFx0cHJvbWlzZSA9IGQucHJvbWlzZTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBJZiB0aGlzIGNvZGUgaXMgY2hhbmdlZCBhdCBzb21lIHBvaW50LCBtYWtlIHN1cmUgdG8gc3RpbGwgYWNjZXNzIHRoZSB0aGVuIHByb3BlcnR5XG5cdFx0XHQvLyBvZiBmbigpIHRvIHJlYWQgYW55IHNpZ25hbHMgaXQgbWlnaHQgYWNjZXNzLCBzbyB0aGF0IHdlIHRyYWNrIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuXHRcdFx0Ly8gV2UgY2FsbCBgdW5zZXRfY29udGV4dGAgdG8gdW5kbyBhbnkgYHNhdmVgIGNhbGxzIHRoYXQgaGFwcGVuIGluc2lkZSBgZm4oKWBcblx0XHRcdFByb21pc2UucmVzb2x2ZShmbigpKVxuXHRcdFx0XHQudGhlbihkLnJlc29sdmUsIGQucmVqZWN0KVxuXHRcdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGJhdGNoID09PSBjdXJyZW50X2JhdGNoICYmIGJhdGNoLmNvbW1pdHRlZCkge1xuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGJhdGNoIHdhcyByZWplY3RlZCBhcyBzdGFsZSwgd2UgbmVlZCB0byBjbGVhbnVwXG5cdFx0XHRcdFx0XHQvLyBhZnRlciBhbnkgYCQuc2F2ZSguLi4pYCBjYWxscyBpbnNpZGUgYGZuKClgXG5cdFx0XHRcdFx0XHRiYXRjaC5kZWFjdGl2YXRlKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dW5zZXRfY29udGV4dCgpO1xuXHRcdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0ZC5yZWplY3QoZXJyb3IpO1xuXHRcdFx0dW5zZXRfY29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGlmIChERVYpIGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gbnVsbDtcblxuXHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblxuXHRcdGlmIChzaG91bGRfc3VzcGVuZCkge1xuXHRcdFx0dmFyIGJsb2NraW5nID0gIWJvdW5kYXJ5LmlzX3BlbmRpbmcoKTtcblxuXHRcdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoMSk7XG5cdFx0XHRiYXRjaC5pbmNyZW1lbnQoYmxvY2tpbmcpO1xuXG5cdFx0XHRkZWZlcnJlZHMuZ2V0KGJhdGNoKT8ucmVqZWN0KFNUQUxFX1JFQUNUSU9OKTtcblx0XHRcdGRlZmVycmVkcy5kZWxldGUoYmF0Y2gpOyAvLyBkZWxldGUgdG8gZW5zdXJlIGNvcnJlY3Qgb3JkZXIgaW4gTWFwIGl0ZXJhdGlvbiBiZWxvd1xuXHRcdFx0ZGVmZXJyZWRzLnNldChiYXRjaCwgZCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHthbnl9IHZhbHVlXG5cdFx0ICogQHBhcmFtIHt1bmtub3dufSBlcnJvclxuXHRcdCAqL1xuXHRcdGNvbnN0IGhhbmRsZXIgPSAodmFsdWUsIGVycm9yID0gdW5kZWZpbmVkKSA9PiB7XG5cdFx0XHRjdXJyZW50X2FzeW5jX2VmZmVjdCA9IG51bGw7XG5cblx0XHRcdGJhdGNoLmFjdGl2YXRlKCk7XG5cblx0XHRcdGlmIChlcnJvcikge1xuXHRcdFx0XHRpZiAoZXJyb3IgIT09IFNUQUxFX1JFQUNUSU9OKSB7XG5cdFx0XHRcdFx0c2lnbmFsLmYgfD0gRVJST1JfVkFMVUU7XG5cblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBlcnJvciBpcyB0aGUgd3JvbmcgdHlwZSwgYnV0IHdlIGRvbid0IGNhcmVcblx0XHRcdFx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICgoc2lnbmFsLmYgJiBFUlJPUl9WQUxVRSkgIT09IDApIHtcblx0XHRcdFx0XHRzaWduYWwuZiBePSBFUlJPUl9WQUxVRTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGludGVybmFsX3NldChzaWduYWwsIHZhbHVlKTtcblxuXHRcdFx0XHQvLyBBbGwgcHJpb3IgYXN5bmMgZGVyaXZlZCBydW5zIGFyZSBub3cgc3RhbGVcblx0XHRcdFx0Zm9yIChjb25zdCBbYiwgZF0gb2YgZGVmZXJyZWRzKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRzLmRlbGV0ZShiKTtcblx0XHRcdFx0XHRpZiAoYiA9PT0gYmF0Y2gpIGJyZWFrO1xuXHRcdFx0XHRcdGQucmVqZWN0KFNUQUxFX1JFQUNUSU9OKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChERVYgJiYgbG9jYXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJlY2VudF9hc3luY19kZXJpdmVkcy5hZGQoc2lnbmFsKTtcblxuXHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHJlY2VudF9hc3luY19kZXJpdmVkcy5oYXMoc2lnbmFsKSkge1xuXHRcdFx0XHRcdFx0XHR3LmF3YWl0X3dhdGVyZmFsbCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHNpZ25hbC5sYWJlbCksIGxvY2F0aW9uKTtcblx0XHRcdFx0XHRcdFx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLmRlbGV0ZShzaWduYWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzaG91bGRfc3VzcGVuZCkge1xuXHRcdFx0XHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgtMSk7XG5cdFx0XHRcdGJhdGNoLmRlY3JlbWVudChibG9ja2luZyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGQucHJvbWlzZS50aGVuKGhhbmRsZXIsIChlKSA9PiBoYW5kbGVyKG51bGwsIGUgfHwgJ3Vua25vd24nKSk7XG5cdH0pO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHRmb3IgKGNvbnN0IGQgb2YgZGVmZXJyZWRzLnZhbHVlcygpKSB7XG5cdFx0XHRkLnJlamVjdChTVEFMRV9SRUFDVElPTik7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoREVWKSB7XG5cdFx0Ly8gYWRkIGEgZmxhZyB0aGF0IGxldHMgdGhpcyBiZSBwcmludGVkIGFzIGEgZGVyaXZlZFxuXHRcdC8vIHdoZW4gdXNpbmcgYCRpbnNwZWN0LnRyYWNlKClgXG5cdFx0c2lnbmFsLmYgfD0gQVNZTkM7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbCkgPT4ge1xuXHRcdC8qKiBAcGFyYW0ge1Byb21pc2U8Vj59IHAgKi9cblx0XHRmdW5jdGlvbiBuZXh0KHApIHtcblx0XHRcdGZ1bmN0aW9uIGdvKCkge1xuXHRcdFx0XHRpZiAocCA9PT0gcHJvbWlzZSkge1xuXHRcdFx0XHRcdGZ1bGZpbChzaWduYWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGlmIHRoZSBlZmZlY3QgcmUtcnVucyBiZWZvcmUgdGhlIGluaXRpYWwgcHJvbWlzZVxuXHRcdFx0XHRcdC8vIHJlc29sdmVzLCBkZWxheSByZXNvbHV0aW9uIHVudGlsIHdlIGhhdmUgYSB2YWx1ZVxuXHRcdFx0XHRcdG5leHQocHJvbWlzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cC50aGVuKGdvLCBnbyk7XG5cdFx0fVxuXG5cdFx0bmV4dChwcm9taXNlKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX2Rlcml2ZWQoZm4pIHtcblx0Y29uc3QgZCA9IGRlcml2ZWQoZm4pO1xuXG5cdGlmICghYXN5bmNfbW9kZV9mbGFnKSBwdXNoX3JlYWN0aW9uX3ZhbHVlKGQpO1xuXG5cdHJldHVybiBkO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGZuXG4gKiBAcmV0dXJucyB7RGVyaXZlZDxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZF9zYWZlX2VxdWFsKGZuKSB7XG5cdGNvbnN0IHNpZ25hbCA9IGRlcml2ZWQoZm4pO1xuXHRzaWduYWwuZXF1YWxzID0gc2FmZV9lcXVhbHM7XG5cdHJldHVybiBzaWduYWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpIHtcblx0dmFyIGVmZmVjdHMgPSBkZXJpdmVkLmVmZmVjdHM7XG5cblx0aWYgKGVmZmVjdHMgIT09IG51bGwpIHtcblx0XHRkZXJpdmVkLmVmZmVjdHMgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKGVmZmVjdHNbaV0pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IHVwZGF0aW5nIGRlcml2ZWRzLCB1c2VkIHRvIGRldGVjdCBpbmZpbml0ZSByZWN1cnNpb25cbiAqIGluIGRldiBtb2RlIGFuZCBwcm92aWRlIGEgbmljZXIgZXJyb3IgdGhhbiAndG9vIG11Y2ggcmVjdXJzaW9uJ1xuICogQHR5cGUge0Rlcml2ZWRbXX1cbiAqL1xubGV0IHN0YWNrID0gW107XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7RWZmZWN0IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSB7XG5cdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmICgocGFyZW50LmYgJiBERVJJVkVEKSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocGFyZW50KTtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZTtcblx0dmFyIHByZXZfYWN0aXZlX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0c2V0X2FjdGl2ZV9lZmZlY3QoZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSk7XG5cblx0aWYgKERFVikge1xuXHRcdGxldCBwcmV2X2VhZ2VyX2VmZmVjdHMgPSBlYWdlcl9lZmZlY3RzO1xuXHRcdHNldF9lYWdlcl9lZmZlY3RzKG5ldyBTZXQoKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzdGFjay5pbmNsdWRlcyhkZXJpdmVkKSkge1xuXHRcdFx0XHRlLmRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YWNrLnB1c2goZGVyaXZlZCk7XG5cblx0XHRcdGRlcml2ZWQuZiAmPSB+V0FTX01BUktFRDtcblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0XHRzZXRfZWFnZXJfZWZmZWN0cyhwcmV2X2VhZ2VyX2VmZmVjdHMpO1xuXHRcdFx0c3RhY2sucG9wKCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHRyeSB7XG5cdFx0XHRkZXJpdmVkLmYgJj0gfldBU19NQVJLRUQ7XG5cdFx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2Rlcml2ZWQoZGVyaXZlZCkge1xuXHR2YXIgdmFsdWUgPSBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCk7XG5cblx0aWYgKCFkZXJpdmVkLmVxdWFscyh2YWx1ZSkpIHtcblx0XHQvLyBUT0RPIGNhbiB3ZSBhdm9pZCBzZXR0aW5nIGBkZXJpdmVkLnZgIHdoZW4gYGJhdGNoX3ZhbHVlcyAhPT0gbnVsbGAsXG5cdFx0Ly8gd2l0aG91dCBjYXVzaW5nIHRoZSB2YWx1ZSB0byBiZSBzdGFsZSBsYXRlcj9cblx0XHRkZXJpdmVkLnYgPSB2YWx1ZTtcblx0XHRkZXJpdmVkLnd2ID0gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKTtcblx0fVxuXG5cdC8vIGRvbid0IG1hcmsgZGVyaXZlZCBjbGVhbiBpZiB3ZSdyZSByZWFkaW5nIGl0IGluc2lkZSBhXG5cdC8vIGNsZWFudXAgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2FjaGUgYSBzdGFsZSB2YWx1ZVxuXHRpZiAoaXNfZGVzdHJveWluZ19lZmZlY3QpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoYmF0Y2hfdmFsdWVzICE9PSBudWxsKSB7XG5cdFx0YmF0Y2hfdmFsdWVzLnNldChkZXJpdmVkLCBkZXJpdmVkLnYpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzdGF0dXMgPVxuXHRcdFx0KHNraXBfcmVhY3Rpb24gfHwgKGRlcml2ZWQuZiAmIFVOT1dORUQpICE9PSAwKSAmJiBkZXJpdmVkLmRlcHMgIT09IG51bGwgPyBNQVlCRV9ESVJUWSA6IENMRUFOO1xuXG5cdFx0c2V0X3NpZ25hbF9zdGF0dXMoZGVyaXZlZCwgc3RhdHVzKTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVudHJhY2tlZF93cml0ZXMsXG5cdGdldCxcblx0c2V0X3VudHJhY2tlZF93cml0ZXMsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0Y3VycmVudF9zb3VyY2VzLFxuXHRpc19kaXJ0eSxcblx0dW50cmFja2luZyxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHB1c2hfcmVhY3Rpb25fdmFsdWVcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlcXVhbHMsIHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQge1xuXHRDTEVBTixcblx0REVSSVZFRCxcblx0RElSVFksXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdEVBR0VSX0VGRkVDVCxcblx0VU5PV05FRCxcblx0TUFZQkVfRElSVFksXG5cdEJMT0NLX0VGRkVDVCxcblx0Uk9PVF9FRkZFQ1QsXG5cdEFTWU5DLFxuXHRXQVNfTUFSS0VEXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcsIHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrLCB0YWdfcHJveHkgfSBmcm9tICcuLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgaXNfcnVuZXMgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEJhdGNoLCBlYWdlcl9ibG9ja19lZmZlY3RzLCBzY2hlZHVsZV9lZmZlY3QgfSBmcm9tICcuL2JhdGNoLmpzJztcbmltcG9ydCB7IHByb3h5IH0gZnJvbSAnLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgZXhlY3V0ZV9kZXJpdmVkIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5cbi8qKiBAdHlwZSB7U2V0PGFueT59ICovXG5leHBvcnQgbGV0IGVhZ2VyX2VmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBAdHlwZSB7TWFwPFNvdXJjZSwgYW55Pn0gKi9cbmV4cG9ydCBjb25zdCBvbGRfdmFsdWVzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9lYWdlcl9lZmZlY3RzKHYpIHtcblx0ZWFnZXJfZWZmZWN0cyA9IHY7XG59XG5cbmxldCBlYWdlcl9lZmZlY3RzX2RlZmVycmVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZWFnZXJfZWZmZWN0c19kZWZlcnJlZCgpIHtcblx0ZWFnZXJfZWZmZWN0c19kZWZlcnJlZCA9IHRydWU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdlxuICogQHBhcmFtIHtFcnJvciB8IG51bGx9IFtzdGFja11cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbi8vIFRPRE8gcmVuYW1lIHRoaXMgdG8gYHN0YXRlYCB0aHJvdWdob3V0IHRoZSBjb2RlYmFzZVxuZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZSh2LCBzdGFjaykge1xuXHQvKiogQHR5cGUge1ZhbHVlfSAqL1xuXHR2YXIgc2lnbmFsID0ge1xuXHRcdGY6IDAsIC8vIFRPRE8gaWRlYWxseSB3ZSBjb3VsZCBza2lwIHRoaXMgYWx0b2dldGhlciwgYnV0IGl0IGNhdXNlcyB0eXBlIGVycm9yc1xuXHRcdHYsXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdGVxdWFscyxcblx0XHRydjogMCxcblx0XHR3djogMFxuXHR9O1xuXG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzaWduYWwuY3JlYXRlZCA9IHN0YWNrID8/IGdldF9zdGFjaygnY3JlYXRlZCBhdCcpO1xuXHRcdHNpZ25hbC51cGRhdGVkID0gbnVsbDtcblx0XHRzaWduYWwuc2V0X2R1cmluZ19lZmZlY3QgPSBmYWxzZTtcblx0XHRzaWduYWwudHJhY2UgPSBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge0Vycm9yIHwgbnVsbH0gW3N0YWNrXVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZSh2LCBzdGFjaykge1xuXHRjb25zdCBzID0gc291cmNlKHYsIHN0YWNrKTtcblxuXHRwdXNoX3JlYWN0aW9uX3ZhbHVlKHMpO1xuXG5cdHJldHVybiBzO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IGluaXRpYWxfdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGFibGVfc291cmNlKGluaXRpYWxfdmFsdWUsIGltbXV0YWJsZSA9IGZhbHNlLCB0cmFja2FibGUgPSB0cnVlKSB7XG5cdGNvbnN0IHMgPSBzb3VyY2UoaW5pdGlhbF92YWx1ZSk7XG5cdGlmICghaW1tdXRhYmxlKSB7XG5cdFx0cy5lcXVhbHMgPSBzYWZlX2VxdWFscztcblx0fVxuXG5cdC8vIGJpbmQgdGhlIHNpZ25hbCB0byB0aGUgY29tcG9uZW50IGNvbnRleHQsIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHQvLyB0cmFjayB1cGRhdGVzIHRvIHRyaWdnZXIgYmVmb3JlVXBkYXRlL2FmdGVyVXBkYXRlIGNhbGxiYWNrc1xuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiB0cmFja2FibGUgJiYgY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCAhPT0gbnVsbCkge1xuXHRcdChjb21wb25lbnRfY29udGV4dC5sLnMgPz89IFtdKS5wdXNoKHMpO1xuXHR9XG5cblx0cmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXV0YXRlKHNvdXJjZSwgdmFsdWUpIHtcblx0c2V0KFxuXHRcdHNvdXJjZSxcblx0XHR1bnRyYWNrKCgpID0+IGdldChzb3VyY2UpKVxuXHQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZF9wcm94eV1cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHNvdXJjZSwgdmFsdWUsIHNob3VsZF9wcm94eSA9IGZhbHNlKSB7XG5cdGlmIChcblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiZcblx0XHQvLyBzaW5jZSB3ZSBhcmUgdW50cmFja2luZyB0aGUgZnVuY3Rpb24gaW5zaWRlIGAkaW5zcGVjdC53aXRoYCB3ZSBuZWVkIHRvIGFkZCB0aGlzIGNoZWNrXG5cdFx0Ly8gdG8gZW5zdXJlIHdlIGVycm9yIGlmIHN0YXRlIGlzIHNldCBpbnNpZGUgYW4gaW5zcGVjdCBlZmZlY3Rcblx0XHQoIXVudHJhY2tpbmcgfHwgKGFjdGl2ZV9yZWFjdGlvbi5mICYgRUFHRVJfRUZGRUNUKSAhPT0gMCkgJiZcblx0XHRpc19ydW5lcygpICYmXG5cdFx0KGFjdGl2ZV9yZWFjdGlvbi5mICYgKERFUklWRUQgfCBCTE9DS19FRkZFQ1QgfCBBU1lOQyB8IEVBR0VSX0VGRkVDVCkpICE9PSAwICYmXG5cdFx0IWN1cnJlbnRfc291cmNlcz8uaW5jbHVkZXMoc291cmNlKVxuXHQpIHtcblx0XHRlLnN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpO1xuXHR9XG5cblx0bGV0IG5ld192YWx1ZSA9IHNob3VsZF9wcm94eSA/IHByb3h5KHZhbHVlKSA6IHZhbHVlO1xuXG5cdGlmIChERVYpIHtcblx0XHR0YWdfcHJveHkobmV3X3ZhbHVlLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNvdXJjZS5sYWJlbCkpO1xuXHR9XG5cblx0cmV0dXJuIGludGVybmFsX3NldChzb3VyY2UsIG5ld192YWx1ZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuYWxfc2V0KHNvdXJjZSwgdmFsdWUpIHtcblx0aWYgKCFzb3VyY2UuZXF1YWxzKHZhbHVlKSkge1xuXHRcdHZhciBvbGRfdmFsdWUgPSBzb3VyY2UudjtcblxuXHRcdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdFx0b2xkX3ZhbHVlcy5zZXQoc291cmNlLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9sZF92YWx1ZXMuc2V0KHNvdXJjZSwgb2xkX3ZhbHVlKTtcblx0XHR9XG5cblx0XHRzb3VyY2UudiA9IHZhbHVlO1xuXG5cdFx0dmFyIGJhdGNoID0gQmF0Y2guZW5zdXJlKCk7XG5cdFx0YmF0Y2guY2FwdHVyZShzb3VyY2UsIG9sZF92YWx1ZSk7XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRpZiAodHJhY2luZ19tb2RlX2ZsYWcgfHwgYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBlcnJvciA9IGdldF9zdGFjaygndXBkYXRlZCBhdCcpO1xuXG5cdFx0XHRcdGlmIChlcnJvciAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHNvdXJjZS51cGRhdGVkID8/PSBuZXcgTWFwKCk7XG5cdFx0XHRcdFx0bGV0IGVudHJ5ID0gc291cmNlLnVwZGF0ZWQuZ2V0KGVycm9yLnN0YWNrKTtcblxuXHRcdFx0XHRcdGlmICghZW50cnkpIHtcblx0XHRcdFx0XHRcdGVudHJ5ID0geyBlcnJvciwgY291bnQ6IDAgfTtcblx0XHRcdFx0XHRcdHNvdXJjZS51cGRhdGVkLnNldChlcnJvci5zdGFjaywgZW50cnkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVudHJ5LmNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGFjdGl2ZV9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdFx0c291cmNlLnNldF9kdXJpbmdfZWZmZWN0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoKHNvdXJjZS5mICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdC8vIGlmIHdlIGFyZSBhc3NpZ25pbmcgdG8gYSBkaXJ0eSBkZXJpdmVkIHdlIHNldCBpdCB0byBjbGVhbi9tYXliZSBkaXJ0eSBidXQgd2UgYWxzbyBlYWdlcmx5IGV4ZWN1dGUgaXQgdG8gdHJhY2sgdGhlIGRlcGVuZGVuY2llc1xuXHRcdFx0aWYgKChzb3VyY2UuZiAmIERJUlRZKSAhPT0gMCkge1xuXHRcdFx0XHRleGVjdXRlX2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc291cmNlKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhzb3VyY2UsIChzb3VyY2UuZiAmIFVOT1dORUQpID09PSAwID8gQ0xFQU4gOiBNQVlCRV9ESVJUWSk7XG5cdFx0fVxuXG5cdFx0c291cmNlLnd2ID0gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKTtcblxuXHRcdG1hcmtfcmVhY3Rpb25zKHNvdXJjZSwgRElSVFkpO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjdXJyZW50IHJlYWN0aW9uIG1pZ2h0IG5vdCBoYXZlIHVwLXRvLWRhdGUgZGVwZW5kZW5jaWVzXG5cdFx0Ly8gd2hpbHN0IGl0J3MgYWN0aXZlbHkgcnVubmluZy4gU28gaW4gdGhlIGNhc2Ugb2YgZW5zdXJpbmcgaXQgcmVnaXN0ZXJzIHRoZSByZWFjdGlvblxuXHRcdC8vIHByb3Blcmx5IGZvciBpdHNlbGYsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBjdXJyZW50IGVmZmVjdCBhY3R1YWxseSBnZXRzXG5cdFx0Ly8gc2NoZWR1bGVkLiBpLmU6IGAkZWZmZWN0KCgpID0+IHgrKylgXG5cdFx0aWYgKFxuXHRcdFx0aXNfcnVuZXMoKSAmJlxuXHRcdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIENMRUFOKSAhPT0gMCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0aWYgKHVudHJhY2tlZF93cml0ZXMgPT09IG51bGwpIHtcblx0XHRcdFx0c2V0X3VudHJhY2tlZF93cml0ZXMoW3NvdXJjZV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dW50cmFja2VkX3dyaXRlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFiYXRjaC5pc19mb3JrICYmIGVhZ2VyX2VmZmVjdHMuc2l6ZSA+IDAgJiYgIWVhZ2VyX2VmZmVjdHNfZGVmZXJyZWQpIHtcblx0XHRcdGZsdXNoX2VhZ2VyX2VmZmVjdHMoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9lYWdlcl9lZmZlY3RzKCkge1xuXHRlYWdlcl9lZmZlY3RzX2RlZmVycmVkID0gZmFsc2U7XG5cblx0Y29uc3QgaW5zcGVjdHMgPSBBcnJheS5mcm9tKGVhZ2VyX2VmZmVjdHMpO1xuXG5cdGZvciAoY29uc3QgZWZmZWN0IG9mIGluc3BlY3RzKSB7XG5cdFx0Ly8gTWFyayBjbGVhbiBpbnNwZWN0LWVmZmVjdHMgYXMgbWF5YmUgZGlydHkgYW5kIHRoZW4gY2hlY2sgdGhlaXIgZGlydGluZXNzXG5cdFx0Ly8gaW5zdGVhZCBvZiBqdXN0IHVwZGF0aW5nIHRoZSBlZmZlY3RzIC0gdGhpcyB3YXkgd2UgYXZvaWQgb3ZlcmZpcmluZy5cblx0XHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pICE9PSAwKSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIE1BWUJFX0RJUlRZKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfZGlydHkoZWZmZWN0KSkge1xuXHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHRcdH1cblx0fVxuXG5cdGVhZ2VyX2VmZmVjdHMuY2xlYXIoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge251bWJlciB8IGJpZ2ludH0gVFxuICogQHBhcmFtIHtTb3VyY2U8VD59IHNvdXJjZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoc291cmNlLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc291cmNlKTtcblx0dmFyIHJlc3VsdCA9IGQgPT09IDEgPyB2YWx1ZSsrIDogdmFsdWUtLTtcblxuXHRzZXQoc291cmNlLCB2YWx1ZSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyIHwgYmlnaW50fSBUXG4gKiBAcGFyYW0ge1NvdXJjZTxUPn0gc291cmNlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmUoc291cmNlLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc291cmNlKTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiBzZXQoc291cmNlLCBkID09PSAxID8gKyt2YWx1ZSA6IC0tdmFsdWUpO1xufVxuXG4vKipcbiAqIFNpbGVudGx5ICh3aXRob3V0IHVzaW5nIGBnZXRgKSBpbmNyZW1lbnQgYSBzb3VyY2VcbiAqIEBwYXJhbSB7U291cmNlPG51bWJlcj59IHNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50KHNvdXJjZSkge1xuXHRzZXQoc291cmNlLCBzb3VyY2UudiArIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBzaG91bGQgYmUgRElSVFkgb3IgTUFZQkVfRElSVFlcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBtYXJrX3JlYWN0aW9ucyhzaWduYWwsIHN0YXR1cykge1xuXHR2YXIgcmVhY3Rpb25zID0gc2lnbmFsLnJlYWN0aW9ucztcblx0aWYgKHJlYWN0aW9ucyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdHZhciBydW5lcyA9IGlzX3J1bmVzKCk7XG5cdHZhciBsZW5ndGggPSByZWFjdGlvbnMubGVuZ3RoO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cdFx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRcdC8vIEluIGxlZ2FjeSBtb2RlLCBza2lwIHRoZSBjdXJyZW50IGVmZmVjdCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0aWYgKCFydW5lcyAmJiByZWFjdGlvbiA9PT0gYWN0aXZlX2VmZmVjdCkgY29udGludWU7XG5cblx0XHQvLyBJbnNwZWN0IGVmZmVjdHMgbmVlZCB0byBydW4gaW1tZWRpYXRlbHksIHNvIHRoYXQgdGhlIHN0YWNrIHRyYWNlIG1ha2VzIHNlbnNlXG5cdFx0aWYgKERFViAmJiAoZmxhZ3MgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRlYWdlcl9lZmZlY3RzLmFkZChyZWFjdGlvbik7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YXIgbm90X2RpcnR5ID0gKGZsYWdzICYgRElSVFkpID09PSAwO1xuXG5cdFx0Ly8gZG9uJ3Qgc2V0IGEgRElSVFkgcmVhY3Rpb24gdG8gTUFZQkVfRElSVFlcblx0XHRpZiAobm90X2RpcnR5KSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgc3RhdHVzKTtcblx0XHR9XG5cblx0XHRpZiAoKGZsYWdzICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBXQVNfTUFSS0VEKSA9PT0gMCkge1xuXHRcdFx0XHRyZWFjdGlvbi5mIHw9IFdBU19NQVJLRUQ7XG5cdFx0XHRcdG1hcmtfcmVhY3Rpb25zKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobm90X2RpcnR5KSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0XHRpZiAoZWFnZXJfYmxvY2tfZWZmZWN0cyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGVhZ2VyX2Jsb2NrX2VmZmVjdHMuYWRkKC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzY2hlZHVsZV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRnZXQsXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVwZGF0ZV92ZXJzaW9uLFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF91cGRhdGVfdmVyc2lvbixcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0YXJyYXlfcHJvdG90eXBlLFxuXHRnZXRfZGVzY3JpcHRvcixcblx0Z2V0X3Byb3RvdHlwZV9vZixcblx0aXNfYXJyYXksXG5cdG9iamVjdF9wcm90b3R5cGVcbn0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdHN0YXRlIGFzIHNvdXJjZSxcblx0c2V0LFxuXHRpbmNyZW1lbnQsXG5cdGZsdXNoX2VhZ2VyX2VmZmVjdHMsXG5cdHNldF9lYWdlcl9lZmZlY3RzX2RlZmVycmVkXG59IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IFBST1hZX1BBVEhfU1lNQk9MLCBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrLCB0YWcgfSBmcm9tICcuL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vLyBUT0RPIG1vdmUgYWxsIHJlZ2V4ZXMgaW50byBzaGFyZWQgbW9kdWxlP1xuY29uc3QgcmVnZXhfaXNfdmFsaWRfaWRlbnRpZmllciA9IC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC87XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHkodmFsdWUpIHtcblx0Ly8gaWYgbm9uLXByb3h5YWJsZSwgb3IgaXMgYWxyZWFkeSBhIHByb3h5LCByZXR1cm4gYHZhbHVlYFxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRjb25zdCBwcm90b3R5cGUgPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblxuXHRpZiAocHJvdG90eXBlICE9PSBvYmplY3RfcHJvdG90eXBlICYmIHByb3RvdHlwZSAhPT0gYXJyYXlfcHJvdG90eXBlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtNYXA8YW55LCBTb3VyY2U8YW55Pj59ICovXG5cdHZhciBzb3VyY2VzID0gbmV3IE1hcCgpO1xuXHR2YXIgaXNfcHJveGllZF9hcnJheSA9IGlzX2FycmF5KHZhbHVlKTtcblx0dmFyIHZlcnNpb24gPSBzb3VyY2UoMCk7XG5cblx0dmFyIHN0YWNrID0gREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnID8gZ2V0X3N0YWNrKCdjcmVhdGVkIGF0JykgOiBudWxsO1xuXHR2YXIgcGFyZW50X3ZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHQvKipcblx0ICogRXhlY3V0ZXMgdGhlIHByb3h5IGluIHRoZSBjb250ZXh0IG9mIHRoZSByZWFjdGlvbiBpdCB3YXMgb3JpZ2luYWxseSBjcmVhdGVkIGluLCBpZiBhbnlcblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHBhcmFtIHsoKSA9PiBUfSBmblxuXHQgKi9cblx0dmFyIHdpdGhfcGFyZW50ID0gKGZuKSA9PiB7XG5cdFx0aWYgKHVwZGF0ZV92ZXJzaW9uID09PSBwYXJlbnRfdmVyc2lvbikge1xuXHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2hpbGQgc291cmNlIGlzIGJlaW5nIGNyZWF0ZWQgYWZ0ZXIgdGhlIGluaXRpYWwgcHJveHkg4oCUXG5cdFx0Ly8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCByZWFjdGlvblxuXHRcdHZhciByZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHR2YXIgdmVyc2lvbiA9IHVwZGF0ZV92ZXJzaW9uO1xuXG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHRzZXRfdXBkYXRlX3ZlcnNpb24ocGFyZW50X3ZlcnNpb24pO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGZuKCk7XG5cblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHJlYWN0aW9uKTtcblx0XHRzZXRfdXBkYXRlX3ZlcnNpb24odmVyc2lvbik7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGlmIChpc19wcm94aWVkX2FycmF5KSB7XG5cdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgdGhlIGxlbmd0aCBzb3VyY2UgZWFnZXJseSB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIG11dGF0aW9ucyB0byB0aGUgYXJyYXkgYXJlIHByb3Blcmx5IHN5bmNlZCB3aXRoIG91ciBwcm94eVxuXHRcdHNvdXJjZXMuc2V0KCdsZW5ndGgnLCBzb3VyY2UoLyoqIEB0eXBlIHthbnlbXX0gKi8gKHZhbHVlKS5sZW5ndGgsIHN0YWNrKSk7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0dmFsdWUgPSAvKiogQHR5cGUge2FueX0gKi8gKGluc3BlY3RhYmxlX2FycmF5KC8qKiBAdHlwZSB7YW55W119ICovICh2YWx1ZSkpKTtcblx0XHR9XG5cdH1cblxuXHQvKiogVXNlZCBpbiBkZXYgZm9yICRpbnNwZWN0LnRyYWNlKCkgKi9cblx0dmFyIHBhdGggPSAnJztcblx0bGV0IHVwZGF0aW5nID0gZmFsc2U7XG5cdC8qKiBAcGFyYW0ge3N0cmluZ30gbmV3X3BhdGggKi9cblx0ZnVuY3Rpb24gdXBkYXRlX3BhdGgobmV3X3BhdGgpIHtcblx0XHRpZiAodXBkYXRpbmcpIHJldHVybjtcblx0XHR1cGRhdGluZyA9IHRydWU7XG5cdFx0cGF0aCA9IG5ld19wYXRoO1xuXG5cdFx0dGFnKHZlcnNpb24sIGAke3BhdGh9IHZlcnNpb25gKTtcblxuXHRcdC8vIHJlbmFtZSBhbGwgY2hpbGQgc291cmNlcyBhbmQgY2hpbGQgcHJveGllc1xuXHRcdGZvciAoY29uc3QgW3Byb3AsIHNvdXJjZV0gb2Ygc291cmNlcykge1xuXHRcdFx0dGFnKHNvdXJjZSwgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHR9XG5cdFx0dXBkYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdHJldHVybiBuZXcgUHJveHkoLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSksIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShfLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHdlIGRpc2FsbG93IG5vbi1iYXNpYyBkZXNjcmlwdG9ycywgYmVjYXVzZSB1bmxlc3MgdGhleSBhcmUgYXBwbGllZCB0byB0aGVcblx0XHRcdFx0Ly8gdGFyZ2V0IG9iamVjdCDigJQgd2hpY2ggd2UgYXZvaWQsIHNvIHRoYXQgc3RhdGUgY2FuIGJlIGZvcmtlZCDigJQgd2Ugd2lsbCBydW5cblx0XHRcdFx0Ly8gYWZvdWwgb2YgdGhlIHZhcmlvdXMgaW52YXJpYW50c1xuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9Qcm94eS9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjaW52YXJpYW50c1xuXHRcdFx0XHRlLnN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkKCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4ge1xuXHRcdFx0XHRcdHZhciBzID0gc291cmNlKGRlc2NyaXB0b3IudmFsdWUsIHN0YWNrKTtcblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0XHRpZiAoREVWICYmIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0dGFnKHMsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldChzLCBkZXNjcmlwdG9yLnZhbHVlLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAocHJvcCBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRjb25zdCBzID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXG5cdFx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdFx0dGFnKHMsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXQocywgVU5JTklUSUFMSVpFRCk7XG5cdFx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHRpZiAocHJvcCA9PT0gU1RBVEVfU1lNQk9MKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERFViAmJiBwcm9wID09PSBQUk9YWV9QQVRIX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdXBkYXRlX3BhdGg7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgZXhpc3RzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIGNyZWF0ZSBhIHNvdXJjZSwgYnV0IG9ubHkgaWYgaXQncyBhbiBvd24gcHJvcGVydHkgYW5kIG5vdCBhIHByb3RvdHlwZSBwcm9wZXJ0eVxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCAmJiAoIWV4aXN0cyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkpIHtcblx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHtcblx0XHRcdFx0XHR2YXIgcCA9IHByb3h5KGV4aXN0cyA/IHRhcmdldFtwcm9wXSA6IFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRcdHZhciBzID0gc291cmNlKHAsIHN0YWNrKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR2YXIgdiA9IGdldChzKTtcblx0XHRcdFx0cmV0dXJuIHYgPT09IFVOSU5JVElBTElaRUQgPyB1bmRlZmluZWQgOiB2O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cdFx0fSxcblxuXHRcdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHRcdGlmIChzKSBkZXNjcmlwdG9yLnZhbHVlID0gZ2V0KHMpO1xuXHRcdFx0fSBlbHNlIGlmIChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBzb3VyY2U/LnY7XG5cblx0XHRcdFx0aWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblx0XHR9LFxuXG5cdFx0aGFzKHRhcmdldCwgcHJvcCkge1xuXHRcdFx0aWYgKHByb3AgPT09IFNUQVRFX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBoYXMgPSAocyAhPT0gdW5kZWZpbmVkICYmIHMudiAhPT0gVU5JTklUSUFMSVpFRCkgfHwgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzICE9PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0dmFyIHAgPSBoYXMgPyBwcm94eSh0YXJnZXRbcHJvcF0pIDogVU5JTklUSUFMSVpFRDtcblx0XHRcdFx0XHRcdHZhciBzID0gc291cmNlKHAsIHN0YWNrKTtcblxuXHRcdFx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdFx0XHR0YWcocywgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdldChzKTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoYXM7XG5cdFx0fSxcblxuXHRcdHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBoYXMgPSBwcm9wIGluIHRhcmdldDtcblxuXHRcdFx0Ly8gdmFyaWFibGUubGVuZ3RoID0gdmFsdWUgLT4gY2xlYXIgYWxsIHNpZ25hbHMgd2l0aCBpbmRleCA+PSB2YWx1ZVxuXHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgcHJvcCA9PT0gJ2xlbmd0aCcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHZhbHVlOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHMpLnY7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHZhciBvdGhlcl9zID0gc291cmNlcy5nZXQoaSArICcnKTtcblx0XHRcdFx0XHRpZiAob3RoZXJfcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZXQob3RoZXJfcywgVU5JTklUSUFMSVpFRCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpIGluIHRhcmdldCkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGl0ZW0gZXhpc3RzIGluIHRoZSBvcmlnaW5hbCwgd2UgbmVlZCB0byBjcmVhdGUgYW4gdW5pbml0aWFsaXplZCBzb3VyY2UsXG5cdFx0XHRcdFx0XHQvLyBlbHNlIGEgbGF0ZXIgcmVhZCBvZiB0aGUgcHJvcGVydHkgd291bGQgcmVzdWx0IGluIGEgc291cmNlIGJlaW5nIGNyZWF0ZWQgd2l0aFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBpdGVtIGF0IHRoYXQgaW5kZXguXG5cdFx0XHRcdFx0XHRvdGhlcl9zID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdFx0XHRzb3VyY2VzLnNldChpICsgJycsIG90aGVyX3MpO1xuXG5cdFx0XHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0XHRcdHRhZyhvdGhlcl9zLCBnZXRfbGFiZWwocGF0aCwgaSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlbid0IHlldCBjcmVhdGVkIGEgc291cmNlIGZvciB0aGlzIHByb3BlcnR5LCB3ZSBuZWVkIHRvIGVuc3VyZVxuXHRcdFx0Ly8gd2UgZG8gc28gb3RoZXJ3aXNlIGlmIHdlIHJlYWQgaXQgbGF0ZXIsIHRoZW4gdGhlIHdyaXRlIHdvbid0IGJlIHRyYWNrZWQgYW5kXG5cdFx0XHQvLyB0aGUgaGV1cmlzdGljcyBvZiBlZmZlY3RzIHdpbGwgYmUgZGlmZmVyZW50IHZzIGlmIHdlIGhhZCByZWFkIHRoZSBwcm94aWVkXG5cdFx0XHQvLyBvYmplY3QgcHJvcGVydHkgYmVmb3JlIHdyaXRpbmcgdG8gdGhhdCBwcm9wZXJ0eS5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpIHtcblx0XHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKHVuZGVmaW5lZCwgc3RhY2spKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZXQocywgcHJveHkodmFsdWUpKTtcblxuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYXMgPSBzLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cblx0XHRcdFx0dmFyIHAgPSB3aXRoX3BhcmVudCgoKSA9PiBwcm94eSh2YWx1ZSkpO1xuXHRcdFx0XHRzZXQocywgcCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgdmFsdWUgYmVmb3JlIHVwZGF0aW5nIGFueSBzaWduYWxzIHNvIHRoYXQgYW55IGxpc3RlbmVycyBnZXQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0aWYgKGRlc2NyaXB0b3I/LnNldCkge1xuXHRcdFx0XHRkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaGFzKSB7XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgbXV0YXRlZCBhbiBhcnJheSBkaXJlY3RseSwgd2UgbWlnaHQgbmVlZCB0b1xuXHRcdFx0XHQvLyBzaWduYWwgdGhhdCBsZW5ndGggaGFzIGFsc28gY2hhbmdlZC4gRG8gaXQgYmVmb3JlIHVwZGF0aW5nIG1ldGFkYXRhXG5cdFx0XHRcdC8vIHRvIGVuc3VyZSB0aGF0IGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSBhcyBhIHJlc3VsdCBvZiBhIG1ldGFkYXRhIHVwZGF0ZVxuXHRcdFx0XHQvLyB3aWxsIG5vdCBjYXVzZSB0aGUgbGVuZ3RoIHRvIGJlIG91dCBvZiBzeW5jLlxuXHRcdFx0XHRpZiAoaXNfcHJveGllZF9hcnJheSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YXIgbHMgPSAvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAoc291cmNlcy5nZXQoJ2xlbmd0aCcpKTtcblx0XHRcdFx0XHR2YXIgbiA9IE51bWJlcihwcm9wKTtcblxuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKG4pICYmIG4gPj0gbHMudikge1xuXHRcdFx0XHRcdFx0c2V0KGxzLCBuICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0dmFyIG93bl9rZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZmlsdGVyKChrZXkpID0+IHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KGtleSk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBba2V5LCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdFx0aWYgKHNvdXJjZS52ICE9PSBVTklOSVRJQUxJWkVEICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHRvd25fa2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG93bl9rZXlzO1xuXHRcdH0sXG5cblx0XHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRcdGUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmcgfCBzeW1ib2x9IHByb3BcbiAqL1xuZnVuY3Rpb24gZ2V0X2xhYmVsKHBhdGgsIHByb3ApIHtcblx0aWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykgcmV0dXJuIGAke3BhdGh9W1N5bWJvbCgke3Byb3AuZGVzY3JpcHRpb24gPz8gJyd9KV1gO1xuXHRpZiAocmVnZXhfaXNfdmFsaWRfaWRlbnRpZmllci50ZXN0KHByb3ApKSByZXR1cm4gYCR7cGF0aH0uJHtwcm9wfWA7XG5cdHJldHVybiAvXlxcZCskLy50ZXN0KHByb3ApID8gYCR7cGF0aH1bJHtwcm9wfV1gIDogYCR7cGF0aH1bJyR7cHJvcH0nXWA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcHJveGllZF92YWx1ZSh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlW1NUQVRFX1NZTUJPTF07XG5cdFx0fVxuXHR9IGNhdGNoIHtcblx0XHQvLyB0aGUgYWJvdmUgaWYgY2hlY2sgY2FuIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpbiBxdWVzdGlvblxuXHRcdC8vIGlzIHRoZSBjb250ZW50V2luZG93IG9mIGFuIGlmcmFtZSBvbiBhbm90aGVyIGRvbWFpbiwgaW4gd2hpY2hcblx0XHQvLyBjYXNlIHdlIHdhbnQgdG8ganVzdCByZXR1cm4gdGhlIHZhbHVlIChiZWNhdXNlIGl0J3MgZGVmaW5pdGVseVxuXHRcdC8vIG5vdCBhIHByb3hpZWQgdmFsdWUpIHNvIHdlIGRvbid0IGJyZWFrIGFueSBKYXZhU2NyaXB0IGludGVyYWN0aW5nXG5cdFx0Ly8gd2l0aCB0aGF0IGlmcmFtZSAoc3VjaCBhcyB2YXJpb3VzIHBheW1lbnQgY29tcGFuaWVzIGNsaWVudCBzaWRlXG5cdFx0Ly8gSmF2YVNjcmlwdCBsaWJyYXJpZXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGVpciBpZnJhbWVzIG9uIHRoZSBzYW1lXG5cdFx0Ly8gZG9tYWluKVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoYSwgYikge1xuXHRyZXR1cm4gT2JqZWN0LmlzKGdldF9wcm94aWVkX3ZhbHVlKGEpLCBnZXRfcHJveGllZF92YWx1ZShiKSk7XG59XG5cbmNvbnN0IEFSUkFZX01VVEFUSU5HX01FVEhPRFMgPSBuZXcgU2V0KFtcblx0J2NvcHlXaXRoaW4nLFxuXHQnZmlsbCcsXG5cdCdwb3AnLFxuXHQncHVzaCcsXG5cdCdyZXZlcnNlJyxcblx0J3NoaWZ0Jyxcblx0J3NvcnQnLFxuXHQnc3BsaWNlJyxcblx0J3Vuc2hpZnQnXG5dKTtcblxuLyoqXG4gKiBXcmFwIGFycmF5IG11dGF0aW5nIG1ldGhvZHMgc28gJGluc3BlY3QgaXMgdHJpZ2dlcmVkIG9ubHkgb25jZSBhbmRcbiAqIHRvIHByZXZlbnQgbG9nZ2luZyBhbiBhcnJheSBpbiBpbnRlcm1lZGlhdGUgc3RhdGUgKGUuZy4gd2l0aCBhbiBlbXB0eSBzbG90KVxuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdGFibGVfYXJyYXkoYXJyYXkpIHtcblx0cmV0dXJuIG5ldyBQcm94eShhcnJheSwge1xuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcblx0XHRcdGlmICghQVJSQVlfTVVUQVRJTkdfTUVUSE9EUy5oYXMoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9wKSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0aGlzIHthbnlbXX1cblx0XHRcdCAqIEBwYXJhbSB7YW55W119IGFyZ3Ncblx0XHRcdCAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0XHRcdHNldF9lYWdlcl9lZmZlY3RzX2RlZmVycmVkKCk7XG5cdFx0XHRcdHZhciByZXN1bHQgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0Zmx1c2hfZWFnZXJfZWZmZWN0cygpO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xufVxuIiwiaW1wb3J0ICogYXMgdyBmcm9tICcuLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfcHJveGllZF92YWx1ZSB9IGZyb20gJy4uL3Byb3h5LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzKCkge1xuXHRjb25zdCBhcnJheV9wcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cdC8vIFRoZSBSRVBMIGVuZHMgdXAgaGVyZSBvdmVyIGFuZCBvdmVyLCBhbmQgdGhpcyBwcmV2ZW50cyBpdCBmcm9tIGFkZGluZyBtb3JlIGFuZCBtb3JlIHBhdGNoZXNcblx0Ly8gb2YgdGhlIHNhbWUga2luZCB0byB0aGUgcHJvdG90eXBlLCB3aGljaCB3b3VsZCBzbG93IGRvd24gZXZlcnl0aGluZyBvdmVyIHRpbWUuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgY2xlYW51cCA9IEFycmF5Ll9fc3ZlbHRlX2NsZWFudXA7XG5cdGlmIChjbGVhbnVwKSB7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cblx0Y29uc3QgeyBpbmRleE9mLCBsYXN0SW5kZXhPZiwgaW5jbHVkZXMgfSA9IGFycmF5X3Byb3RvdHlwZTtcblxuXHRhcnJheV9wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Y29uc3QgaW5kZXggPSBpbmRleE9mLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCk7XG5cblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gZnJvbV9pbmRleCA/PyAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRpZiAoZ2V0X3Byb3hpZWRfdmFsdWUodGhpc1tpXSkgPT09IGl0ZW0pIHtcblx0XHRcdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKCdhcnJheS5pbmRleE9mKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fTtcblxuXHRhcnJheV9wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdC8vIHdlIG5lZWQgdG8gc3BlY2lmeSB0aGlzLmxlbmd0aCAtIDEgYmVjYXVzZSBpdCdzIHByb2JhYmx5IHVzaW5nIHNvbWV0aGluZyBsaWtlXG5cdFx0Ly8gYGFyZ3VtZW50c2AgaW5zaWRlIHNvIHBhc3NpbmcgdW5kZWZpbmVkIGlzIGRpZmZlcmVudCBmcm9tIG5vdCBwYXNzaW5nIGFueXRoaW5nXG5cdFx0Y29uc3QgaW5kZXggPSBsYXN0SW5kZXhPZi5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXggPz8gdGhpcy5sZW5ndGggLSAxKTtcblxuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IChmcm9tX2luZGV4ID8/IHRoaXMubGVuZ3RoIC0gMSk7IGkgKz0gMSkge1xuXHRcdFx0XHRpZiAoZ2V0X3Byb3hpZWRfdmFsdWUodGhpc1tpXSkgPT09IGl0ZW0pIHtcblx0XHRcdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKCdhcnJheS5sYXN0SW5kZXhPZiguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0YXJyYXlfcHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHRjb25zdCBoYXMgPSBpbmNsdWRlcy5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXgpO1xuXG5cdFx0aWYgKCFoYXMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRpZiAoZ2V0X3Byb3hpZWRfdmFsdWUodGhpc1tpXSkgPT09IGl0ZW0pIHtcblx0XHRcdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKCdhcnJheS5pbmNsdWRlcyguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaGFzO1xuXHR9O1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0QXJyYXkuX19zdmVsdGVfY2xlYW51cCA9ICgpID0+IHtcblx0XHRhcnJheV9wcm90b3R5cGUuaW5kZXhPZiA9IGluZGV4T2Y7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmluY2x1ZGVzID0gaW5jbHVkZXM7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVxdWFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmljdF9lcXVhbHMoYSwgYiwgZXF1YWwgPSB0cnVlKSB7XG5cdC8vIHRyeS1jYXRjaCBuZWVkZWQgYmVjYXVzZSB0aGlzIHRyaWVzIHRvIHJlYWQgcHJvcGVydGllcyBvZiBgYWAgYW5kIGBiYCxcblx0Ly8gd2hpY2ggY291bGQgYmUgZGlzYWxsb3dlZCBmb3IgZXhhbXBsZSBpbiBhIHNlY3VyZSBjb250ZXh0XG5cdHRyeSB7XG5cdFx0aWYgKChhID09PSBiKSAhPT0gKGdldF9wcm94aWVkX3ZhbHVlKGEpID09PSBnZXRfcHJveGllZF92YWx1ZShiKSkpIHtcblx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goZXF1YWwgPyAnPT09JyA6ICchPT0nKTtcblx0XHR9XG5cdH0gY2F0Y2gge31cblxuXHRyZXR1cm4gKGEgPT09IGIpID09PSBlcXVhbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXF1YWxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIsIGVxdWFsID0gdHJ1ZSkge1xuXHRpZiAoKGEgPT0gYikgIT09IChnZXRfcHJveGllZF92YWx1ZShhKSA9PSBnZXRfcHJveGllZF92YWx1ZShiKSkpIHtcblx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKGVxdWFsID8gJz09JyA6ICchPScpO1xuXHR9XG5cblx0cmV0dXJuIChhID09IGIpID09PSBlcXVhbDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzIH0gZnJvbSAnLi4vZGV2L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yLCBpc19leHRlbnNpYmxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IFRFWFRfTk9ERSwgRUZGRUNUX1JBTiB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLy8gZXhwb3J0IHRoZXNlIGZvciByZWZlcmVuY2UgaW4gdGhlIGNvbXBpbGVkIGNvZGUsIG1ha2luZyBnbG9iYWwgbmFtZSBkZWR1cGxpY2F0aW9uIHVubmVjZXNzYXJ5XG4vKiogQHR5cGUge1dpbmRvd30gKi9cbmV4cG9ydCB2YXIgJHdpbmRvdztcblxuLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbmV4cG9ydCB2YXIgJGRvY3VtZW50O1xuXG4vKiogQHR5cGUge2Jvb2xlYW59ICovXG5leHBvcnQgdmFyIGlzX2ZpcmVmb3g7XG5cbi8qKiBAdHlwZSB7KCkgPT4gTm9kZSB8IG51bGx9ICovXG52YXIgZmlyc3RfY2hpbGRfZ2V0dGVyO1xuLyoqIEB0eXBlIHsoKSA9PiBOb2RlIHwgbnVsbH0gKi9cbnZhciBuZXh0X3NpYmxpbmdfZ2V0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlc2UgbGF6aWx5IHRvIGF2b2lkIGlzc3VlcyB3aGVuIHVzaW5nIHRoZSBydW50aW1lIGluIGEgc2VydmVyIGNvbnRleHRcbiAqIHdoZXJlIHRoZXNlIGdsb2JhbHMgYXJlIG5vdCBhdmFpbGFibGUgd2hpbGUgYXZvaWRpbmcgYSBzZXBhcmF0ZSBzZXJ2ZXIgZW50cnkgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfb3BlcmF0aW9ucygpIHtcblx0aWYgKCR3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdCR3aW5kb3cgPSB3aW5kb3c7XG5cdCRkb2N1bWVudCA9IGRvY3VtZW50O1xuXHRpc19maXJlZm94ID0gL0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0dmFyIGVsZW1lbnRfcHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG5cdHZhciBub2RlX3Byb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xuXHR2YXIgdGV4dF9wcm90b3R5cGUgPSBUZXh0LnByb3RvdHlwZTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdGZpcnN0X2NoaWxkX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnZmlyc3RDaGlsZCcpLmdldDtcblx0Ly8gQHRzLWlnbm9yZVxuXHRuZXh0X3NpYmxpbmdfZ2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3Iobm9kZV9wcm90b3R5cGUsICduZXh0U2libGluZycpLmdldDtcblxuXHRpZiAoaXNfZXh0ZW5zaWJsZShlbGVtZW50X3Byb3RvdHlwZSkpIHtcblx0XHQvLyB0aGUgZm9sbG93aW5nIGFzc2lnbm1lbnRzIGltcHJvdmUgcGVyZiBvZiBsb29rdXBzIG9uIERPTSBub2Rlc1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsaWNrID0gdW5kZWZpbmVkO1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsYXNzTmFtZSA9IHVuZGVmaW5lZDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19hdHRyaWJ1dGVzID0gbnVsbDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdHlsZSA9IHVuZGVmaW5lZDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19lID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKGlzX2V4dGVuc2libGUodGV4dF9wcm90b3R5cGUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHRfcHJvdG90eXBlLl9fdCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdmVsdGVfbWV0YSA9IG51bGw7XG5cblx0XHRpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV90ZXh0KHZhbHVlID0gJycpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZmlyc3RfY2hpbGQobm9kZSkge1xuXHRyZXR1cm4gZmlyc3RfY2hpbGRfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuLypAX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X25leHRfc2libGluZyhub2RlKSB7XG5cdHJldHVybiBuZXh0X3NpYmxpbmdfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGQobm9kZSwgaXNfdGV4dCkge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBnZXRfZmlyc3RfY2hpbGQobm9kZSk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChoeWRyYXRlX25vZGUpKTtcblxuXHQvLyBDaGlsZCBjYW4gYmUgbnVsbCBpZiB3ZSBoYXZlIGFuIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSBjaGlsZCwgbGlrZSBgPHA+e3RleHR9PC9wPmAsIHdoZXJlIGB0ZXh0YCBpcyBlbXB0eVxuXHRpZiAoY2hpbGQgPT09IG51bGwpIHtcblx0XHRjaGlsZCA9IGh5ZHJhdGVfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fSBlbHNlIGlmIChpc190ZXh0ICYmIGNoaWxkLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0Y2hpbGQ/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZCk7XG5cdHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBUZW1wbGF0ZU5vZGUgfCBUZW1wbGF0ZU5vZGVbXX0gZnJhZ21lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX3RleHRdXG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdF9jaGlsZChmcmFnbWVudCwgaXNfdGV4dCA9IGZhbHNlKSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0Ly8gd2hlbiBub3QgaHlkcmF0aW5nLCBgZnJhZ21lbnRgIGlzIGEgYERvY3VtZW50RnJhZ21lbnRgICh0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYG9wZW5fZnJhZ2ApXG5cdFx0dmFyIGZpcnN0ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGZyYWdtZW50KSkpO1xuXG5cdFx0Ly8gVE9ETyBwcmV2ZW50IHVzZXIgY29tbWVudHMgd2l0aCB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gcHJlc2VydmVDb21tZW50cyBpcyB0cnVlXG5cdFx0aWYgKGZpcnN0IGluc3RhbmNlb2YgQ29tbWVudCAmJiBmaXJzdC5kYXRhID09PSAnJykgcmV0dXJuIGdldF9uZXh0X3NpYmxpbmcoZmlyc3QpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9XG5cblx0Ly8gaWYgYW4ge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHRoZXJlIG1pZ2h0IGJlIG5vXG5cdC8vIHRleHQgbm9kZSB0byBoeWRyYXRlIOKAlCB3ZSBtdXN0IHRoZXJlZm9yZSBjcmVhdGUgb25lXG5cdGlmIChpc190ZXh0ICYmIGh5ZHJhdGVfbm9kZT8ubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblxuXHRcdGh5ZHJhdGVfbm9kZT8uYmVmb3JlKHRleHQpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2libGluZyhub2RlLCBjb3VudCA9IDEsIGlzX3RleHQgPSBmYWxzZSkge1xuXHRsZXQgbmV4dF9zaWJsaW5nID0gaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZTtcblx0dmFyIGxhc3Rfc2libGluZztcblxuXHR3aGlsZSAoY291bnQtLSkge1xuXHRcdGxhc3Rfc2libGluZyA9IG5leHRfc2libGluZztcblx0XHRuZXh0X3NpYmxpbmcgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobmV4dF9zaWJsaW5nKSk7XG5cdH1cblxuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBuZXh0X3NpYmxpbmc7XG5cdH1cblxuXHQvLyBpZiBhIHNpYmxpbmcge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHRoZXJlIG1pZ2h0IGJlIG5vXG5cdC8vIHRleHQgbm9kZSB0byBoeWRyYXRlIOKAlCB3ZSBtdXN0IHRoZXJlZm9yZSBjcmVhdGUgb25lXG5cdGlmIChpc190ZXh0ICYmIG5leHRfc2libGluZz8ubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblx0XHQvLyBJZiB0aGUgbmV4dCBzaWJsaW5nIGlzIGBudWxsYCBhbmQgd2UncmUgaGFuZGxpbmcgdGV4dCB0aGVuIGl0J3MgYmVjYXVzZVxuXHRcdC8vIHRoZSBTU1IgY29udGVudCB3YXMgZW1wdHkgZm9yIHRoZSB0ZXh0LCBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgbmV3IHRleHRcblx0XHQvLyBub2RlIGFuZCBpbnNlcnQgaXQgYWZ0ZXIgdGhlIGxhc3Qgc2libGluZ1xuXHRcdGlmIChuZXh0X3NpYmxpbmcgPT09IG51bGwpIHtcblx0XHRcdGxhc3Rfc2libGluZz8uYWZ0ZXIodGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5leHRfc2libGluZy5iZWZvcmUodGV4dCk7XG5cdFx0fVxuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRzZXRfaHlkcmF0ZV9ub2RlKG5leHRfc2libGluZyk7XG5cdHJldHVybiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHRfc2libGluZyk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfdGV4dF9jb250ZW50KG5vZGUpIHtcblx0bm9kZS50ZXh0Q29udGVudCA9ICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHdlJ3JlIHVwZGF0aW5nIHRoZSBjdXJyZW50IGJsb2NrLCBmb3IgZXhhbXBsZSBgY29uZGl0aW9uYCBpblxuICogYW4gYHsjaWYgY29uZGl0aW9ufWAgYmxvY2sganVzdCBjaGFuZ2VkLiBJbiB0aGlzIGNhc2UsIHRoZSBicmFuY2ggc2hvdWxkIGJlXG4gKiBhcHBlbmRlZCAob3IgcmVtb3ZlZCkgYXQgdGhlIHNhbWUgdGltZSBhcyBvdGhlciB1cGRhdGVzIHdpdGhpbiB0aGVcbiAqIGN1cnJlbnQgYDxzdmVsdGU6Ym91bmRhcnk+YFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkX2RlZmVyX2FwcGVuZCgpIHtcblx0aWYgKCFhc3luY19tb2RlX2ZsYWcpIHJldHVybiBmYWxzZTtcblx0aWYgKGVhZ2VyX2Jsb2NrX2VmZmVjdHMgIT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuXHR2YXIgZmxhZ3MgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmY7XG5cdHJldHVybiAoZmxhZ3MgJiBFRkZFQ1RfUkFOKSAhPT0gMDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2lzXVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9lbGVtZW50KHRhZywgbmFtZXNwYWNlLCBpcykge1xuXHRsZXQgb3B0aW9ucyA9IGlzID8geyBpcyB9IDogdW5kZWZpbmVkO1xuXHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZywgb3B0aW9ucyk7XG5cdH1cblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCgpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9jb21tZW50KGRhdGEgPSAnJykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSA9ICcnKSB7XG5cdGlmIChrZXkuc3RhcnRzV2l0aCgneGxpbms6JykpIHtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywga2V5LCB2YWx1ZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHJldHVybiBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbn1cbiIsImltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjbGVhcl90ZXh0X2NvbnRlbnQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvZm9jdXMoZG9tLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUpIHtcblx0XHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0XHRkb20uYXV0b2ZvY3VzID0gdHJ1ZTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGJvZHkpIHtcblx0XHRcdFx0ZG9tLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY2hpbGQgb2YgYSB0ZXh0YXJlYSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV90ZXh0YXJlYV9jaGlsZChkb20pIHtcblx0aWYgKGh5ZHJhdGluZyAmJiBnZXRfZmlyc3RfY2hpbGQoZG9tKSAhPT0gbnVsbCkge1xuXHRcdGNsZWFyX3RleHRfY29udGVudChkb20pO1xuXHR9XG59XG5cbmxldCBsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKSB7XG5cdGlmICghbGlzdGVuaW5nX3RvX2Zvcm1fcmVzZXQpIHtcblx0XHRsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IHRydWU7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdyZXNldCcsXG5cdFx0XHQoZXZ0KSA9PiB7XG5cdFx0XHRcdC8vIE5lZWRzIHRvIGhhcHBlbiBvbmUgdGljayBsYXRlciBvciBlbHNlIHRoZSBkb20gcHJvcGVydGllcyBvZiB0aGUgZm9ybVxuXHRcdFx0XHQvLyBlbGVtZW50cyBoYXZlIG5vdCB1cGRhdGVkIHRvIHRoZWlyIHJlc2V0IHZhbHVlcyB5ZXRcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBlIG9mIC8qKkB0eXBlIHtIVE1MRm9ybUVsZW1lbnR9ICovIChldnQudGFyZ2V0KS5lbGVtZW50cykge1xuXHRcdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRcdGUuX19vbl9yPy4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8vIEluIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGd1YXJhbnRlZSB3ZSBnZXQgbm90aWNlZCBvZiBpdCAobm8gcG9zc2libGl0eSBvZiBzdG9wUHJvcGFnYXRpb24pXG5cdFx0XHR7IGNhcHR1cmU6IHRydWUgfVxuXHRcdCk7XG5cdH1cbn1cbiIsImltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBhZGRfZm9ybV9yZXNldF9saXN0ZW5lciB9IGZyb20gJy4uL21pc2MuanMnO1xuXG4vKipcbiAqIEZpcmVzIHRoZSBoYW5kbGVyIG9uY2UgaW1tZWRpYXRlbHkgKHVubGVzcyBjb3JyZXNwb25kaW5nIGFyZyBpcyBzZXQgdG8gYGZhbHNlYCksXG4gKiB0aGVuIGxpc3RlbnMgdG8gdGhlIGdpdmVuIGV2ZW50cyB1bnRpbCB0aGUgcmVuZGVyIGVmZmVjdCBjb250ZXh0IGlzIGRlc3Ryb3llZFxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHBhcmFtIHsoZXZlbnQ/OiBFdmVudCkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHthbnl9IGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRzLCBoYW5kbGVyLCBjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHkgPSB0cnVlKSB7XG5cdGlmIChjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHkpIHtcblx0XHRoYW5kbGVyKCk7XG5cdH1cblxuXHRmb3IgKHZhciBuYW1lIG9mIGV2ZW50cykge1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHR9XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoZm4pIHtcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGZuKCk7XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gZXZlbnQsIGFuZCB0aGVuIGluc3RhbnRpYXRlIGEgZ2xvYmFsIGZvcm0gcmVzZXQgbGlzdGVuZXIgaWYgbm90IGFscmVhZHkgZG9uZSxcbiAqIHRvIG5vdGlmeSBhbGwgYmluZGluZ3Mgd2hlbiB0aGUgZm9ybSBpcyByZXNldFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0geyhpc19yZXNldD86IHRydWUpID0+IHZvaWR9IGhhbmRsZXJcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gW29uX3Jlc2V0XVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb25fcmVzZXQgPSBoYW5kbGVyKSB7XG5cdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKCkgPT4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KGhhbmRsZXIpKTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBwcmV2ID0gZWxlbWVudC5fX29uX3I7XG5cdGlmIChwcmV2KSB7XG5cdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBjaGVja2JveCB0aGF0IGNhbiBoYXZlIG11bHRpcGxlIGJpbmRzIChncm91cCAmIGNoZWNrZWQpXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnQuX19vbl9yID0gKCkgPT4ge1xuXHRcdFx0cHJldigpO1xuXHRcdFx0b25fcmVzZXQodHJ1ZSk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiBvbl9yZXNldCh0cnVlKTtcblx0fVxuXG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIENvbXBvbmVudENvbnRleHRMZWdhY3ksIERlcml2ZWQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlLCBUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRpc19kaXJ0eSxcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHR1cGRhdGVfZWZmZWN0LFxuXHRnZXQsXG5cdGlzX2Rlc3Ryb3lpbmdfZWZmZWN0LFxuXHRyZW1vdmVfcmVhY3Rpb25zLFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHR1bnRyYWNraW5nXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0RElSVFksXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFJFTkRFUl9FRkZFQ1QsXG5cdEVGRkVDVCxcblx0REVTVFJPWUVELFxuXHRJTkVSVCxcblx0RUZGRUNUX1JBTixcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0RUZGRUNUX1RSQU5TUEFSRU5ULFxuXHRERVJJVkVELFxuXHRVTk9XTkVELFxuXHRDTEVBTixcblx0RUFHRVJfRUZGRUNULFxuXHRIRUFEX0VGRkVDVCxcblx0TUFZQkVfRElSVFksXG5cdEVGRkVDVF9QUkVTRVJWRUQsXG5cdFNUQUxFX1JFQUNUSU9OLFxuXHRVU0VSX0VGRkVDVCxcblx0QVNZTkNcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24sIGRldl9zdGFjayB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIHNjaGVkdWxlX2VmZmVjdCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4vYXN5bmMuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsnJGVmZmVjdCcgfCAnJGVmZmVjdC5wcmUnIHwgJyRpbnNwZWN0J30gcnVuZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWZmZWN0KHJ1bmUpIHtcblx0aWYgKGFjdGl2ZV9lZmZlY3QgPT09IG51bGwgJiYgYWN0aXZlX3JlYWN0aW9uID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3Rfb3JwaGFuKHJ1bmUpO1xuXHR9XG5cblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBVTk9XTkVEKSAhPT0gMCAmJiBhY3RpdmVfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCk7XG5cdH1cblxuXHRpZiAoaXNfZGVzdHJveWluZ19lZmZlY3QpIHtcblx0XHRlLmVmZmVjdF9pbl90ZWFyZG93bihydW5lKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7RWZmZWN0fSBwYXJlbnRfZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIHB1c2hfZWZmZWN0KGVmZmVjdCwgcGFyZW50X2VmZmVjdCkge1xuXHR2YXIgcGFyZW50X2xhc3QgPSBwYXJlbnRfZWZmZWN0Lmxhc3Q7XG5cdGlmIChwYXJlbnRfbGFzdCA9PT0gbnVsbCkge1xuXHRcdHBhcmVudF9lZmZlY3QubGFzdCA9IHBhcmVudF9lZmZlY3QuZmlyc3QgPSBlZmZlY3Q7XG5cdH0gZWxzZSB7XG5cdFx0cGFyZW50X2xhc3QubmV4dCA9IGVmZmVjdDtcblx0XHRlZmZlY3QucHJldiA9IHBhcmVudF9sYXN0O1xuXHRcdHBhcmVudF9lZmZlY3QubGFzdCA9IGVmZmVjdDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0ge251bGwgfCAoKCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKSl9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHVzaFxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2VmZmVjdCh0eXBlLCBmbiwgc3luYywgcHVzaCA9IHRydWUpIHtcblx0dmFyIHBhcmVudCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIEVuc3VyZSB0aGUgcGFyZW50IGlzIG5ldmVyIGFuIGluc3BlY3QgZWZmZWN0XG5cdFx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiAocGFyZW50LmYgJiBFQUdFUl9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdGlmIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0dHlwZSB8PSBJTkVSVDtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWZmZWN0ID0ge1xuXHRcdGN0eDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0ZGVwczogbnVsbCxcblx0XHRub2Rlc19zdGFydDogbnVsbCxcblx0XHRub2Rlc19lbmQ6IG51bGwsXG5cdFx0ZjogdHlwZSB8IERJUlRZLFxuXHRcdGZpcnN0OiBudWxsLFxuXHRcdGZuLFxuXHRcdGxhc3Q6IG51bGwsXG5cdFx0bmV4dDogbnVsbCxcblx0XHRwYXJlbnQsXG5cdFx0YjogcGFyZW50ICYmIHBhcmVudC5iLFxuXHRcdHByZXY6IG51bGwsXG5cdFx0dGVhcmRvd246IG51bGwsXG5cdFx0dHJhbnNpdGlvbnM6IG51bGwsXG5cdFx0d3Y6IDAsXG5cdFx0YWM6IG51bGxcblx0fTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0fVxuXG5cdGlmIChzeW5jKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdGVmZmVjdC5mIHw9IEVGRkVDVF9SQU47XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGZuICE9PSBudWxsKSB7XG5cdFx0c2NoZWR1bGVfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHRpZiAocHVzaCkge1xuXHRcdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0XHR2YXIgZSA9IGVmZmVjdDtcblxuXHRcdC8vIGlmIGFuIGVmZmVjdCBoYXMgYWxyZWFkeSByYW4gYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBrZXB0IGluIHRoZSB0cmVlXG5cdFx0Ly8gKGJlY2F1c2UgaXQgd29uJ3QgcmUtcnVuLCBoYXMgbm8gRE9NLCBhbmQgaGFzIG5vIHRlYXJkb3duIGV0Yylcblx0XHQvLyB0aGVuIHdlIHNraXAgaXQgYW5kIGdvIHRvIGl0cyBjaGlsZCAoaWYgYW55KVxuXHRcdGlmIChcblx0XHRcdHN5bmMgJiZcblx0XHRcdGUuZGVwcyA9PT0gbnVsbCAmJlxuXHRcdFx0ZS50ZWFyZG93biA9PT0gbnVsbCAmJlxuXHRcdFx0ZS5ub2Rlc19zdGFydCA9PT0gbnVsbCAmJlxuXHRcdFx0ZS5maXJzdCA9PT0gZS5sYXN0ICYmIC8vIGVpdGhlciBgbnVsbGAsIG9yIGEgc2luZ3VsYXIgY2hpbGRcblx0XHRcdChlLmYgJiBFRkZFQ1RfUFJFU0VSVkVEKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0ZSA9IGUuZmlyc3Q7XG5cdFx0XHRpZiAoKHR5cGUgJiBCTE9DS19FRkZFQ1QpICE9PSAwICYmICh0eXBlICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCAmJiBlICE9PSBudWxsKSB7XG5cdFx0XHRcdGUuZiB8PSBFRkZFQ1RfVFJBTlNQQVJFTlQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGUgIT09IG51bGwpIHtcblx0XHRcdGUucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0XHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdHB1c2hfZWZmZWN0KGUsIHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHdlJ3JlIGluIGEgZGVyaXZlZCwgYWRkIHRoZSBlZmZlY3QgdGhlcmUgdG9vXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdFx0XHQoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdFx0XHQodHlwZSAmIFJPT1RfRUZGRUNUKSA9PT0gMFxuXHRcdFx0KSB7XG5cdFx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdFx0KGRlcml2ZWQuZWZmZWN0cyA/Pz0gW10pLnB1c2goZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC50cmFja2luZygpYFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfdHJhY2tpbmcoKSB7XG5cdHJldHVybiBhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmc7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVhcmRvd24oZm4pIHtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNULCBudWxsLCBmYWxzZSk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXHRlZmZlY3QudGVhcmRvd24gPSBmbjtcblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdCguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlcl9lZmZlY3QoZm4pIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckZWZmZWN0Jyk7XG5cblx0aWYgKERFVikge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJyRlZmZlY3QnXG5cdFx0fSk7XG5cdH1cblxuXHQvLyBOb24tbmVzdGVkIGAkZWZmZWN0KC4uLilgIGluIGEgY29tcG9uZW50IHNob3VsZCBiZSBkZWZlcnJlZFxuXHQvLyB1bnRpbCB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWRcblx0dmFyIGZsYWdzID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5mO1xuXHR2YXIgZGVmZXIgPSAhYWN0aXZlX3JlYWN0aW9uICYmIChmbGFncyAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwICYmIChmbGFncyAmIEVGRkVDVF9SQU4pID09PSAwO1xuXG5cdGlmIChkZWZlcikge1xuXHRcdC8vIFRvcC1sZXZlbCBgJGVmZmVjdCguLi4pYCBpbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50IOKAlCBkZWZlciB1bnRpbCBtb3VudFxuXHRcdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdChjb250ZXh0LmUgPz89IFtdKS5wdXNoKGZuKTtcblx0fSBlbHNlIHtcblx0XHQvLyBFdmVyeXRoaW5nIGVsc2Ug4oCUIGNyZWF0ZSBpbW1lZGlhdGVseVxuXHRcdHJldHVybiBjcmVhdGVfdXNlcl9lZmZlY3QoZm4pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3VzZXJfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEVGRkVDVCB8IFVTRVJfRUZGRUNULCBmbiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnByZSguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfcHJlX2VmZmVjdChmbikge1xuXHR2YWxpZGF0ZV9lZmZlY3QoJyRlZmZlY3QucHJlJyk7XG5cdGlmIChERVYpIHtcblx0XHRkZWZpbmVfcHJvcGVydHkoZm4sICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICckZWZmZWN0LnByZSdcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNUIHwgVVNFUl9FRkZFQ1QsIGZuLCB0cnVlKTtcbn1cblxuLyoqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWdlcl9lZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoRUFHRVJfRUZGRUNULCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3Qucm9vdCguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3Rfcm9vdChmbikge1xuXHRCYXRjaC5lbnN1cmUoKTtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChST09UX0VGRkVDVCB8IEVGRkVDVF9QUkVTRVJWRUQsIGZuLCB0cnVlKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdH07XG59XG5cbi8qKlxuICogQW4gZWZmZWN0IHJvb3Qgd2hvc2UgY2hpbGRyZW4gY2FuIHRyYW5zaXRpb24gb3V0XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KG9wdGlvbnM/OiB7IG91dHJvPzogYm9vbGVhbiB9KSA9PiBQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X3Jvb3QoZm4pIHtcblx0QmF0Y2guZW5zdXJlKCk7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUk9PVF9FRkZFQ1QgfCBFRkZFQ1RfUFJFU0VSVkVELCBmbiwgdHJ1ZSk7XG5cblx0cmV0dXJuIChvcHRpb25zID0ge30pID0+IHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbCkgPT4ge1xuXHRcdFx0aWYgKG9wdGlvbnMub3V0cm8pIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0ZnVsZmlsKHVuZGVmaW5lZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0ZnVsZmlsKHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChFRkZFQ1QsIGZuLCBmYWxzZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCQ6IC4uYFxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGRlcHNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9wcmVfZWZmZWN0KGRlcHMsIGZuKSB7XG5cdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdC8qKiBAdHlwZSB7eyBlZmZlY3Q6IG51bGwgfCBFZmZlY3QsIHJhbjogYm9vbGVhbiwgZGVwczogKCkgPT4gYW55IH19ICovXG5cdHZhciB0b2tlbiA9IHsgZWZmZWN0OiBudWxsLCByYW46IGZhbHNlLCBkZXBzIH07XG5cblx0Y29udGV4dC5sLiQucHVzaCh0b2tlbik7XG5cblx0dG9rZW4uZWZmZWN0ID0gcmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0ZGVwcygpO1xuXG5cdFx0Ly8gSWYgdGhpcyBsZWdhY3kgcHJlIGVmZmVjdCBoYXMgYWxyZWFkeSBydW4gYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHJlc2V0LCB0aGVuXG5cdFx0Ly8gYmFpbCBvdXQgdG8gZW11bGF0ZSB0aGUgc2FtZSBiZWhhdmlvci5cblx0XHRpZiAodG9rZW4ucmFuKSByZXR1cm47XG5cblx0XHR0b2tlbi5yYW4gPSB0cnVlO1xuXHRcdHVudHJhY2soZm4pO1xuXHR9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9wcmVfZWZmZWN0X3Jlc2V0KCkge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHQvLyBSdW4gZGlydHkgYCQ6YCBzdGF0ZW1lbnRzXG5cdFx0Zm9yICh2YXIgdG9rZW4gb2YgY29udGV4dC5sLiQpIHtcblx0XHRcdHRva2VuLmRlcHMoKTtcblxuXHRcdFx0dmFyIGVmZmVjdCA9IHRva2VuLmVmZmVjdDtcblxuXHRcdFx0Ly8gSWYgdGhlIGVmZmVjdCBpcyBDTEVBTiwgdGhlbiBtYWtlIGl0IE1BWUJFX0RJUlRZLiBUaGlzIGVuc3VyZXMgd2UgdHJhdmVyc2UgdGhyb3VnaFxuXHRcdFx0Ly8gdGhlIGVmZmVjdHMgZGVwZW5kZW5jaWVzIGFuZCBjb3JyZWN0bHkgZW5zdXJlIGVhY2ggZGVwZW5kZW5jeSBpcyB1cC10by1kYXRlLlxuXHRcdFx0aWYgKChlZmZlY3QuZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIE1BWUJFX0RJUlRZKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzX2RpcnR5KGVmZmVjdCkpIHtcblx0XHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHR0b2tlbi5yYW4gPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luY19lZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoQVNZTkMgfCBFRkZFQ1RfUFJFU0VSVkVELCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcl9lZmZlY3QoZm4sIGZsYWdzID0gMCkge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNUIHwgZmxhZ3MsIGZuLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyguLi5leHByZXNzaW9uczogYW55KSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtBcnJheTwoKSA9PiBhbnk+fSBzeW5jXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IFByb21pc2U8YW55Pj59IGFzeW5jXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8dm9pZD4+fSBibG9ja2Vyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVfZWZmZWN0KGZuLCBzeW5jID0gW10sIGFzeW5jID0gW10sIGJsb2NrZXJzID0gW10pIHtcblx0ZmxhdHRlbihibG9ja2Vycywgc3luYywgYXN5bmMsICh2YWx1ZXMpID0+IHtcblx0XHRjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QsICgpID0+IGZuKC4uLnZhbHVlcy5tYXAoZ2V0KSksIHRydWUpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmxvY2soZm4sIGZsYWdzID0gMCkge1xuXHR2YXIgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChCTE9DS19FRkZFQ1QgfCBmbGFncywgZm4sIHRydWUpO1xuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmRldl9zdGFjayA9IGRldl9zdGFjaztcblx0fVxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBbcHVzaF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaChmbiwgcHVzaCA9IHRydWUpIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoQlJBTkNIX0VGRkVDVCB8IEVGRkVDVF9QUkVTRVJWRUQsIGZuLCB0cnVlLCBwdXNoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpIHtcblx0dmFyIHRlYXJkb3duID0gZWZmZWN0LnRlYXJkb3duO1xuXHRpZiAodGVhcmRvd24gIT09IG51bGwpIHtcblx0XHRjb25zdCBwcmV2aW91c2x5X2Rlc3Ryb3lpbmdfZWZmZWN0ID0gaXNfZGVzdHJveWluZ19lZmZlY3Q7XG5cdFx0Y29uc3QgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHRydWUpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0dHJ5IHtcblx0XHRcdHRlYXJkb3duLmNhbGwobnVsbCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdChwcmV2aW91c2x5X2Rlc3Ryb3lpbmdfZWZmZWN0KTtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtb3ZlX2RvbVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihzaWduYWwsIHJlbW92ZV9kb20gPSBmYWxzZSkge1xuXHR2YXIgZWZmZWN0ID0gc2lnbmFsLmZpcnN0O1xuXHRzaWduYWwuZmlyc3QgPSBzaWduYWwubGFzdCA9IG51bGw7XG5cblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBlZmZlY3QuYWM7XG5cblx0XHRpZiAoY29udHJvbGxlciAhPT0gbnVsbCkge1xuXHRcdFx0d2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHtcblx0XHRcdFx0Y29udHJvbGxlci5hYm9ydChTVEFMRV9SRUFDVElPTik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgbmV4dCA9IGVmZmVjdC5uZXh0O1xuXG5cdFx0aWYgKChlZmZlY3QuZiAmIFJPT1RfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0Ly8gdGhpcyBpcyBub3cgYW4gaW5kZXBlbmRlbnQgcm9vdFxuXHRcdFx0ZWZmZWN0LnBhcmVudCA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCwgcmVtb3ZlX2RvbSk7XG5cdFx0fVxuXG5cdFx0ZWZmZWN0ID0gbmV4dDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4oc2lnbmFsKSB7XG5cdHZhciBlZmZlY3QgPSBzaWduYWwuZmlyc3Q7XG5cblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cdFx0aWYgKChlZmZlY3QuZiAmIEJSQU5DSF9FRkZFQ1QpID09PSAwKSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdH1cblx0XHRlZmZlY3QgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlX2RvbV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveV9lZmZlY3QoZWZmZWN0LCByZW1vdmVfZG9tID0gdHJ1ZSkge1xuXHR2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXG5cdGlmIChcblx0XHQocmVtb3ZlX2RvbSB8fCAoZWZmZWN0LmYgJiBIRUFEX0VGRkVDVCkgIT09IDApICYmXG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ICE9PSBudWxsICYmXG5cdFx0ZWZmZWN0Lm5vZGVzX2VuZCAhPT0gbnVsbFxuXHQpIHtcblx0XHRyZW1vdmVfZWZmZWN0X2RvbShlZmZlY3Qubm9kZXNfc3RhcnQsIC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZWZmZWN0Lm5vZGVzX2VuZCkpO1xuXHRcdHJlbW92ZWQgPSB0cnVlO1xuXHR9XG5cblx0ZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4oZWZmZWN0LCByZW1vdmVfZG9tICYmICFyZW1vdmVkKTtcblx0cmVtb3ZlX3JlYWN0aW9ucyhlZmZlY3QsIDApO1xuXHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIERFU1RST1lFRCk7XG5cblx0dmFyIHRyYW5zaXRpb25zID0gZWZmZWN0LnRyYW5zaXRpb25zO1xuXG5cdGlmICh0cmFuc2l0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiB0cmFuc2l0aW9ucykge1xuXHRcdFx0dHJhbnNpdGlvbi5zdG9wKCk7XG5cdFx0fVxuXHR9XG5cblx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KTtcblxuXHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblxuXHQvLyBJZiB0aGUgcGFyZW50IGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4sIHRoZW4gc2tpcCB0aGlzIHdvcmsgYWx0b2dldGhlclxuXHRpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5maXJzdCAhPT0gbnVsbCkge1xuXHRcdHVubGlua19lZmZlY3QoZWZmZWN0KTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHRlZmZlY3QuY29tcG9uZW50X2Z1bmN0aW9uID0gbnVsbDtcblx0fVxuXG5cdC8vIGBmaXJzdGAgYW5kIGBjaGlsZGAgYXJlIG51bGxlZCBvdXQgaW4gZGVzdHJveV9lZmZlY3RfY2hpbGRyZW5cblx0Ly8gd2UgZG9uJ3QgbnVsbCBvdXQgYHBhcmVudGAgc28gdGhhdCBlcnJvciBwcm9wYWdhdGlvbiBjYW4gd29yayBjb3JyZWN0bHlcblx0ZWZmZWN0Lm5leHQgPVxuXHRcdGVmZmVjdC5wcmV2ID1cblx0XHRlZmZlY3QudGVhcmRvd24gPVxuXHRcdGVmZmVjdC5jdHggPVxuXHRcdGVmZmVjdC5kZXBzID1cblx0XHRlZmZlY3QuZm4gPVxuXHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9XG5cdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9XG5cdFx0ZWZmZWN0LmFjID1cblx0XHRcdG51bGw7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gbm9kZVxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IGVuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX2VmZmVjdF9kb20obm9kZSwgZW5kKSB7XG5cdHdoaWxlIChub2RlICE9PSBudWxsKSB7XG5cdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHRcdHZhciBuZXh0ID0gbm9kZSA9PT0gZW5kID8gbnVsbCA6IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cblx0XHRub2RlLnJlbW92ZSgpO1xuXHRcdG5vZGUgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogRGV0YWNoIGFuIGVmZmVjdCBmcm9tIHRoZSBlZmZlY3QgdHJlZSwgZnJlZWluZyB1cCBtZW1vcnkgYW5kXG4gKiByZWR1Y2luZyB0aGUgYW1vdW50IG9mIHdvcmsgdGhhdCBoYXBwZW5zIG9uIHN1YnNlcXVlbnQgdHJhdmVyc2Fsc1xuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saW5rX2VmZmVjdChlZmZlY3QpIHtcblx0dmFyIHBhcmVudCA9IGVmZmVjdC5wYXJlbnQ7XG5cdHZhciBwcmV2ID0gZWZmZWN0LnByZXY7XG5cdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cblx0aWYgKHByZXYgIT09IG51bGwpIHByZXYubmV4dCA9IG5leHQ7XG5cdGlmIChuZXh0ICE9PSBudWxsKSBuZXh0LnByZXYgPSBwcmV2O1xuXG5cdGlmIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRpZiAocGFyZW50LmZpcnN0ID09PSBlZmZlY3QpIHBhcmVudC5maXJzdCA9IG5leHQ7XG5cdFx0aWYgKHBhcmVudC5sYXN0ID09PSBlZmZlY3QpIHBhcmVudC5sYXN0ID0gcHJldjtcblx0fVxufVxuXG4vKipcbiAqIFdoZW4gYSBibG9jayBlZmZlY3QgaXMgcmVtb3ZlZCwgd2UgZG9uJ3QgaW1tZWRpYXRlbHkgZGVzdHJveSBpdCBvciB5YW5rIGl0XG4gKiBvdXQgb2YgdGhlIERPTSwgYmVjYXVzZSBpdCBtaWdodCBoYXZlIHRyYW5zaXRpb25zLiBJbnN0ZWFkLCB3ZSAncGF1c2UnIGl0LlxuICogSXQgc3RheXMgYXJvdW5kIChpbiBtZW1vcnksIGFuZCBpbiB0aGUgRE9NKSB1bnRpbCBvdXRybyB0cmFuc2l0aW9ucyBoYXZlXG4gKiBjb21wbGV0ZWQsIGFuZCBpZiB0aGUgc3RhdGUgY2hhbmdlIGlzIHJldmVyc2VkIHRoZW4gd2UgX3Jlc3VtZV8gaXQuXG4gKiBBIHBhdXNlZCBlZmZlY3QgZG9lcyBub3QgdXBkYXRlLCBhbmQgdGhlIERPTSBzdWJ0cmVlIGJlY29tZXMgaW5lcnQuXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc3Ryb3ldXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9lZmZlY3QoZWZmZWN0LCBjYWxsYmFjaywgZGVzdHJveSA9IHRydWUpIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblxuXHRwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCB0cnVlKTtcblxuXHRydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCAoKSA9PiB7XG5cdFx0aWYgKGRlc3Ryb3kpIGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zaXRpb25NYW5hZ2VyW119IHRyYW5zaXRpb25zXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCBmbikge1xuXHR2YXIgcmVtYWluaW5nID0gdHJhbnNpdGlvbnMubGVuZ3RoO1xuXHRpZiAocmVtYWluaW5nID4gMCkge1xuXHRcdHZhciBjaGVjayA9ICgpID0+IC0tcmVtYWluaW5nIHx8IGZuKCk7XG5cdFx0Zm9yICh2YXIgdHJhbnNpdGlvbiBvZiB0cmFuc2l0aW9ucykge1xuXHRcdFx0dHJhbnNpdGlvbi5vdXQoY2hlY2spO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmbigpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtUcmFuc2l0aW9uTWFuYWdlcltdfSB0cmFuc2l0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF1c2VfY2hpbGRyZW4oZWZmZWN0LCB0cmFuc2l0aW9ucywgbG9jYWwpIHtcblx0aWYgKChlZmZlY3QuZiAmIElORVJUKSAhPT0gMCkgcmV0dXJuO1xuXHRlZmZlY3QuZiBePSBJTkVSVDtcblxuXHRpZiAoZWZmZWN0LnRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIGVmZmVjdC50cmFuc2l0aW9ucykge1xuXHRcdFx0aWYgKHRyYW5zaXRpb24uaXNfZ2xvYmFsIHx8IGxvY2FsKSB7XG5cdFx0XHRcdHRyYW5zaXRpb25zLnB1c2godHJhbnNpdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGNoaWxkID0gZWZmZWN0LmZpcnN0O1xuXG5cdHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdHZhciBzaWJsaW5nID0gY2hpbGQubmV4dDtcblx0XHR2YXIgdHJhbnNwYXJlbnQgPVxuXHRcdFx0KGNoaWxkLmYgJiBFRkZFQ1RfVFJBTlNQQVJFTlQpICE9PSAwIHx8XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgYnJhbmNoIGVmZmVjdCB3aXRob3V0IGEgYmxvY2sgZWZmZWN0IHBhcmVudCxcblx0XHRcdC8vIGl0IG1lYW5zIHRoZSBwYXJlbnQgYmxvY2sgZWZmZWN0IHdhcyBwcnVuZWQuIEluIHRoYXQgY2FzZSxcblx0XHRcdC8vIHRyYW5zcGFyZW5jeSBpbmZvcm1hdGlvbiB3YXMgdHJhbnNmZXJyZWQgdG8gdGhlIGJyYW5jaCBlZmZlY3QuXG5cdFx0XHQoKGNoaWxkLmYgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMCAmJiAoZWZmZWN0LmYgJiBCTE9DS19FRkZFQ1QpICE9PSAwKTtcblx0XHQvLyBUT0RPIHdlIGRvbid0IG5lZWQgdG8gY2FsbCBwYXVzZV9jaGlsZHJlbiByZWN1cnNpdmVseSB3aXRoIGEgbGlua2VkIGxpc3QgaW4gcGxhY2Vcblx0XHQvLyBpdCdzIHNsaWdodGx5IG1vcmUgaW52b2x2ZWQgdGhvdWdoIGFzIHdlIGhhdmUgdG8gYWNjb3VudCBmb3IgYHRyYW5zcGFyZW50YCBjaGFuZ2luZ1xuXHRcdC8vIHRocm91Z2ggdGhlIHRyZWUuXG5cdFx0cGF1c2VfY2hpbGRyZW4oY2hpbGQsIHRyYW5zaXRpb25zLCB0cmFuc3BhcmVudCA/IGxvY2FsIDogZmFsc2UpO1xuXHRcdGNoaWxkID0gc2libGluZztcblx0fVxufVxuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgcGF1c2VfZWZmZWN0YC4gV2UgY2FsbCB0aGlzIGlmIChmb3IgZXhhbXBsZSlcbiAqIGB4YCBiZWNvbWVzIGZhbHN5IHRoZW4gdHJ1dGh5OiBgeyNpZiB4fS4uLnsvaWZ9YFxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdW1lX2VmZmVjdChlZmZlY3QpIHtcblx0cmVzdW1lX2NoaWxkcmVuKGVmZmVjdCwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICovXG5mdW5jdGlvbiByZXN1bWVfY2hpbGRyZW4oZWZmZWN0LCBsb2NhbCkge1xuXHRpZiAoKGVmZmVjdC5mICYgSU5FUlQpID09PSAwKSByZXR1cm47XG5cdGVmZmVjdC5mIF49IElORVJUO1xuXG5cdC8vIElmIGEgZGVwZW5kZW5jeSBvZiB0aGlzIGVmZmVjdCBjaGFuZ2VkIHdoaWxlIGl0IHdhcyBwYXVzZWQsXG5cdC8vIHNjaGVkdWxlIHRoZSBlZmZlY3QgdG8gdXBkYXRlLiB3ZSBkb24ndCB1c2UgYGlzX2RpcnR5YFxuXHQvLyBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBlYWdlcmx5IHJlY29tcHV0ZSBhIGRlcml2ZWQgbGlrZVxuXHQvLyBgeyNpZiBmb299e2Zvby5iYXIoKX17L2lmfWAgaWYgYGZvb2AgaXMgbm93IGB1bmRlZmluZWRcblx0aWYgKChlZmZlY3QuZiAmIENMRUFOKSA9PT0gMCkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgRElSVFkpO1xuXHRcdHNjaGVkdWxlX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0dmFyIGNoaWxkID0gZWZmZWN0LmZpcnN0O1xuXG5cdHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdHZhciBzaWJsaW5nID0gY2hpbGQubmV4dDtcblx0XHR2YXIgdHJhbnNwYXJlbnQgPSAoY2hpbGQuZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDAgfHwgKGNoaWxkLmYgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMDtcblx0XHQvLyBUT0RPIHdlIGRvbid0IG5lZWQgdG8gY2FsbCByZXN1bWVfY2hpbGRyZW4gcmVjdXJzaXZlbHkgd2l0aCBhIGxpbmtlZCBsaXN0IGluIHBsYWNlXG5cdFx0Ly8gaXQncyBzbGlnaHRseSBtb3JlIGludm9sdmVkIHRob3VnaCBhcyB3ZSBoYXZlIHRvIGFjY291bnQgZm9yIGB0cmFuc3BhcmVudGAgY2hhbmdpbmdcblx0XHQvLyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRcdHJlc3VtZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNwYXJlbnQgPyBsb2NhbCA6IGZhbHNlKTtcblx0XHRjaGlsZCA9IHNpYmxpbmc7XG5cdH1cblxuXHRpZiAoZWZmZWN0LnRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIGVmZmVjdC50cmFuc2l0aW9ucykge1xuXHRcdFx0aWYgKHRyYW5zaXRpb24uaXNfZ2xvYmFsIHx8IGxvY2FsKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24uaW4oKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0ZWQoZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KSkge1xuXHRyZXR1cm4gKGVmZmVjdC5mICYgREVTVFJPWUVEKSAhPT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlX2VmZmVjdChlZmZlY3QsIGZyYWdtZW50KSB7XG5cdHZhciBub2RlID0gZWZmZWN0Lm5vZGVzX3N0YXJ0O1xuXHR2YXIgZW5kID0gZWZmZWN0Lm5vZGVzX2VuZDtcblxuXHR3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0XHR2YXIgbmV4dCA9IG5vZGUgPT09IGVuZCA/IG51bGwgOiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXG5cdFx0ZnJhZ21lbnQuYXBwZW5kKG5vZGUpO1xuXHRcdG5vZGUgPSBuZXh0O1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNpZ25hbCwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9ycywgZ2V0X3Byb3RvdHlwZV9vZiwgaW5kZXhfb2YgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0ZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4sXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuLFxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93blxufSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRESVJUWSxcblx0TUFZQkVfRElSVFksXG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRVTk9XTkVELFxuXHRERVNUUk9ZRUQsXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFNUQVRFX1NZTUJPTCxcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0RElTQ09OTkVDVEVELFxuXHRSRUFDVElPTl9JU19VUERBVElORyxcblx0U1RBTEVfUkVBQ1RJT04sXG5cdEVSUk9SX1ZBTFVFLFxuXHRXQVNfTUFSS0VEXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG9sZF92YWx1ZXMgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQge1xuXHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyxcblx0ZXhlY3V0ZV9kZXJpdmVkLFxuXHRjdXJyZW50X2FzeW5jX2VmZmVjdCxcblx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLFxuXHR1cGRhdGVfZGVyaXZlZFxufSBmcm9tICcuL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IHRyYWNpbmdfZXhwcmVzc2lvbnMsIGdldF9zdGFjayB9IGZyb20gJy4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHtcblx0Y29tcG9uZW50X2NvbnRleHQsXG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0ZGV2X3N0YWNrLFxuXHRpc19ydW5lcyxcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0LFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X3N0YWNrXG59IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGJhdGNoX3ZhbHVlcywgZmx1c2hTeW5jLCBzY2hlZHVsZV9lZmZlY3QgfSBmcm9tICcuL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuaW1wb3J0IHsgaGFuZGxlX2Vycm9yIH0gZnJvbSAnLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGNhcHR1cmVkX3NpZ25hbHMgfSBmcm9tICcuL2xlZ2FjeS5qcyc7XG5pbXBvcnQgeyB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQgfSBmcm9tICcuL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG5leHBvcnQgbGV0IGlzX3VwZGF0aW5nX2VmZmVjdCA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pc191cGRhdGluZ19lZmZlY3QodmFsdWUpIHtcblx0aXNfdXBkYXRpbmdfZWZmZWN0ID0gdmFsdWU7XG59XG5cbmV4cG9ydCBsZXQgaXNfZGVzdHJveWluZ19lZmZlY3QgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodmFsdWUpIHtcblx0aXNfZGVzdHJveWluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuLyoqIEB0eXBlIHtudWxsIHwgUmVhY3Rpb259ICovXG5leHBvcnQgbGV0IGFjdGl2ZV9yZWFjdGlvbiA9IG51bGw7XG5cbmV4cG9ydCBsZXQgdW50cmFja2luZyA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgUmVhY3Rpb259IHJlYWN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2FjdGl2ZV9yZWFjdGlvbihyZWFjdGlvbikge1xuXHRhY3RpdmVfcmVhY3Rpb24gPSByZWFjdGlvbjtcbn1cblxuLyoqIEB0eXBlIHtudWxsIHwgRWZmZWN0fSAqL1xuZXhwb3J0IGxldCBhY3RpdmVfZWZmZWN0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IEVmZmVjdH0gZWZmZWN0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2FjdGl2ZV9lZmZlY3QoZWZmZWN0KSB7XG5cdGFjdGl2ZV9lZmZlY3QgPSBlZmZlY3Q7XG59XG5cbi8qKlxuICogV2hlbiBzb3VyY2VzIGFyZSBjcmVhdGVkIHdpdGhpbiBhIHJlYWN0aW9uLCByZWFkaW5nIGFuZCB3cml0aW5nXG4gKiB0aGVtIHdpdGhpbiB0aGF0IHJlYWN0aW9uIHNob3VsZCBub3QgY2F1c2UgYSByZS1ydW5cbiAqIEB0eXBlIHtudWxsIHwgU291cmNlW119XG4gKi9cbmV4cG9ydCBsZXQgY3VycmVudF9zb3VyY2VzID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7VmFsdWV9IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaF9yZWFjdGlvbl92YWx1ZSh2YWx1ZSkge1xuXHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmICghYXN5bmNfbW9kZV9mbGFnIHx8IChhY3RpdmVfcmVhY3Rpb24uZiAmIERFUklWRUQpICE9PSAwKSkge1xuXHRcdGlmIChjdXJyZW50X3NvdXJjZXMgPT09IG51bGwpIHtcblx0XHRcdGN1cnJlbnRfc291cmNlcyA9IFt2YWx1ZV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRfc291cmNlcy5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZGVwZW5kZW5jaWVzIG9mIHRoZSByZWFjdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBleGVjdXRlZC4gSW4gbWFueSBjYXNlcyxcbiAqIHRoZSBkZXBlbmRlbmNpZXMgYXJlIHVuY2hhbmdlZCBiZXR3ZWVuIHJ1bnMsIGFuZCBzbyB0aGlzIHdpbGwgYmUgYG51bGxgIHVubGVzc1xuICogYW5kIHVudGlsIGEgbmV3IGRlcGVuZGVuY3kgaXMgYWNjZXNzZWQg4oCUIHdlIHRyYWNrIHRoaXMgdmlhIGBza2lwcGVkX2RlcHNgXG4gKiBAdHlwZSB7bnVsbCB8IFZhbHVlW119XG4gKi9cbmxldCBuZXdfZGVwcyA9IG51bGw7XG5cbmxldCBza2lwcGVkX2RlcHMgPSAwO1xuXG4vKipcbiAqIFRyYWNrcyB3cml0ZXMgdGhhdCB0aGUgZWZmZWN0IGl0J3MgZXhlY3V0ZWQgaW4gZG9lc24ndCBsaXN0ZW4gdG8geWV0LFxuICogc28gdGhhdCB0aGUgZGVwZW5kZW5jeSBjYW4gYmUgYWRkZWQgdG8gdGhlIGVmZmVjdCBsYXRlciBvbiBpZiBpdCB0aGVuIHJlYWRzIGl0XG4gKiBAdHlwZSB7bnVsbCB8IFNvdXJjZVtdfVxuICovXG5leHBvcnQgbGV0IHVudHJhY2tlZF93cml0ZXMgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgU291cmNlW119IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3VudHJhY2tlZF93cml0ZXModmFsdWUpIHtcblx0dW50cmFja2VkX3dyaXRlcyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9IFVzZWQgYnkgc291cmNlcyBhbmQgZGVyaXZlZHMgZm9yIGhhbmRsaW5nIHVwZGF0ZXMuXG4gKiBWZXJzaW9uIHN0YXJ0cyBmcm9tIDEgc28gdGhhdCB1bm93bmVkIGRlcml2ZWRzIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBhIGNyZWF0ZWQgZWZmZWN0IGFuZCBhIHJ1biBvbmUgZm9yIHRyYWNpbmdcbiAqKi9cbmV4cG9ydCBsZXQgd3JpdGVfdmVyc2lvbiA9IDE7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBVc2VkIHRvIHZlcnNpb24gZWFjaCByZWFkIG9mIGEgc291cmNlIG9mIGRlcml2ZWQgdG8gYXZvaWQgZHVwbGljYXRpbmcgZGVwZWRlbmNpZXMgaW5zaWRlIGEgcmVhY3Rpb24gKi9cbmxldCByZWFkX3ZlcnNpb24gPSAwO1xuXG5leHBvcnQgbGV0IHVwZGF0ZV92ZXJzaW9uID0gcmVhZF92ZXJzaW9uO1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3VwZGF0ZV92ZXJzaW9uKHZhbHVlKSB7XG5cdHVwZGF0ZV92ZXJzaW9uID0gdmFsdWU7XG59XG5cbi8vIElmIHdlIGFyZSB3b3JraW5nIHdpdGggYSBnZXQoKSBjaGFpbiB0aGF0IGhhcyBubyBhY3RpdmUgY29udGFpbmVyLFxuLy8gdG8gcHJldmVudCBtZW1vcnkgbGVha3MsIHdlIHNraXAgYWRkaW5nIHRoZSByZWFjdGlvbi5cbmV4cG9ydCBsZXQgc2tpcF9yZWFjdGlvbiA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKSB7XG5cdHJldHVybiArK3dyaXRlX3ZlcnNpb247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZGVyaXZlZCBvciBlZmZlY3QgaXMgZGlydHkuXG4gKiBJZiBpdCBpcyBNQVlCRV9ESVJUWSwgd2lsbCBzZXQgdGhlIHN0YXR1cyB0byBDTEVBTlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZGlydHkocmVhY3Rpb24pIHtcblx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRpZiAoKGZsYWdzICYgRElSVFkpICE9PSAwKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoKGZsYWdzICYgTUFZQkVfRElSVFkpICE9PSAwKSB7XG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IHJlYWN0aW9uLmRlcHM7XG5cdFx0dmFyIGlzX3Vub3duZWQgPSAoZmxhZ3MgJiBVTk9XTkVEKSAhPT0gMDtcblxuXHRcdGlmIChmbGFncyAmIERFUklWRUQpIHtcblx0XHRcdHJlYWN0aW9uLmYgJj0gfldBU19NQVJLRUQ7XG5cdFx0fVxuXG5cdFx0aWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHR2YXIgZGVwZW5kZW5jeTtcblx0XHRcdHZhciBpc19kaXNjb25uZWN0ZWQgPSAoZmxhZ3MgJiBESVNDT05ORUNURUQpICE9PSAwO1xuXHRcdFx0dmFyIGlzX3Vub3duZWRfY29ubmVjdGVkID0gaXNfdW5vd25lZCAmJiBhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICFza2lwX3JlYWN0aW9uO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cblx0XHRcdC8vIElmIHdlIGFyZSB3b3JraW5nIHdpdGggYSBkaXNjb25uZWN0ZWQgb3IgYW4gdW5vd25lZCBzaWduYWwgdGhhdCBpcyBub3cgY29ubmVjdGVkIChkdWUgdG8gYW4gYWN0aXZlIGVmZmVjdClcblx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byByZS1jb25uZWN0IHRoZSByZWFjdGlvbiB0byB0aGUgZGVwZW5kZW5jeSwgdW5sZXNzIHRoZSBlZmZlY3QgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcblx0XHRcdC8vICh3aGljaCBjYW4gaGFwcGVuIGlmIHRoZSBkZXJpdmVkIGlzIHJlYWQgYnkgYW4gYXN5bmMgZGVyaXZlZClcblx0XHRcdGlmIChcblx0XHRcdFx0KGlzX2Rpc2Nvbm5lY3RlZCB8fCBpc191bm93bmVkX2Nvbm5lY3RlZCkgJiZcblx0XHRcdFx0KGFjdGl2ZV9lZmZlY3QgPT09IG51bGwgfHwgKGFjdGl2ZV9lZmZlY3QuZiAmIERFU1RST1lFRCkgPT09IDApXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChyZWFjdGlvbik7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuXG5cdFx0XHRcdFx0Ly8gV2UgYWx3YXlzIHJlLWFkZCBhbGwgcmVhY3Rpb25zIChldmVuIGR1cGxpY2F0ZXMpIGlmIHRoZSBkZXJpdmVkIHdhc1xuXHRcdFx0XHRcdC8vIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkLCBob3dldmVyIHdlIGRvbid0IGlmIGl0IHdhcyB1bm93bmVkIGFzIHdlXG5cdFx0XHRcdFx0Ly8gZGUtZHVwbGljYXRlIGRlcGVuZGVuY2llcyBpbiB0aGF0IGNhc2Vcblx0XHRcdFx0XHRpZiAoaXNfZGlzY29ubmVjdGVkIHx8ICFkZXBlbmRlbmN5Py5yZWFjdGlvbnM/LmluY2x1ZGVzKGRlcml2ZWQpKSB7XG5cdFx0XHRcdFx0XHQoZGVwZW5kZW5jeS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKGRlcml2ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc19kaXNjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRkZXJpdmVkLmYgXj0gRElTQ09OTkVDVEVEO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB1bm93bmVkIGRlcml2ZWQgaXMgbm93IGZ1bGx5IGNvbm5lY3RlZCB0byB0aGUgZ3JhcGggYWdhaW4gKGl0J3MgdW5vd25lZCBhbmQgcmVjb25uZWN0ZWQsIGhhcyBhIHBhcmVudFxuXHRcdFx0XHQvLyBhbmQgdGhlIHBhcmVudCBpcyBub3QgdW5vd25lZCksIHRoZW4gd2UgY2FuIG1hcmsgaXQgYXMgY29ubmVjdGVkIGFnYWluLCByZW1vdmluZyB0aGUgbmVlZCBmb3IgdGhlIHVub3duZWRcblx0XHRcdFx0Ly8gZmxhZ1xuXHRcdFx0XHRpZiAoaXNfdW5vd25lZF9jb25uZWN0ZWQgJiYgcGFyZW50ICE9PSBudWxsICYmIChwYXJlbnQuZiAmIFVOT1dORUQpID09PSAwKSB7XG5cdFx0XHRcdFx0ZGVyaXZlZC5mIF49IFVOT1dORUQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG5cblx0XHRcdFx0aWYgKGlzX2RpcnR5KC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcGVuZGVuY3kpKSkge1xuXHRcdFx0XHRcdHVwZGF0ZV9kZXJpdmVkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcGVuZGVuY3kpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkZXBlbmRlbmN5Lnd2ID4gcmVhY3Rpb24ud3YpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVub3duZWQgc2lnbmFscyBzaG91bGQgbmV2ZXIgYmUgbWFya2VkIGFzIGNsZWFuIHVubGVzcyB0aGV5XG5cdFx0Ly8gYXJlIHVzZWQgd2l0aGluIGFuIGFjdGl2ZV9lZmZlY3Qgd2l0aG91dCBza2lwX3JlYWN0aW9uXG5cdFx0aWYgKCFpc191bm93bmVkIHx8IChhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICFza2lwX3JlYWN0aW9uKSkge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIENMRUFOKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyb290XVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oc2lnbmFsLCBlZmZlY3QsIHJvb3QgPSB0cnVlKSB7XG5cdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zID09PSBudWxsKSByZXR1cm47XG5cblx0aWYgKCFhc3luY19tb2RlX2ZsYWcgJiYgY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZWFjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0c2NoZWR1bGVfcG9zc2libGVfZWZmZWN0X3NlbGZfaW52YWxpZGF0aW9uKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgZWZmZWN0LCBmYWxzZSk7XG5cdFx0fSBlbHNlIGlmIChlZmZlY3QgPT09IHJlYWN0aW9uKSB7XG5cdFx0XHRpZiAocm9vdCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgRElSVFkpO1xuXHRcdFx0fSBlbHNlIGlmICgocmVhY3Rpb24uZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXHRcdFx0c2NoZWR1bGVfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdHZhciBwcmV2aW91c19kZXBzID0gbmV3X2RlcHM7XG5cdHZhciBwcmV2aW91c19za2lwcGVkX2RlcHMgPSBza2lwcGVkX2RlcHM7XG5cdHZhciBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID0gdW50cmFja2VkX3dyaXRlcztcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfc2tpcF9yZWFjdGlvbiA9IHNraXBfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19zb3VyY2VzID0gY3VycmVudF9zb3VyY2VzO1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0dmFyIHByZXZpb3VzX3VudHJhY2tpbmcgPSB1bnRyYWNraW5nO1xuXHR2YXIgcHJldmlvdXNfdXBkYXRlX3ZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdG5ld19kZXBzID0gLyoqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX0gKi8gKG51bGwpO1xuXHRza2lwcGVkX2RlcHMgPSAwO1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblx0c2tpcF9yZWFjdGlvbiA9XG5cdFx0KGZsYWdzICYgVU5PV05FRCkgIT09IDAgJiYgKHVudHJhY2tpbmcgfHwgIWlzX3VwZGF0aW5nX2VmZmVjdCB8fCBhY3RpdmVfcmVhY3Rpb24gPT09IG51bGwpO1xuXHRhY3RpdmVfcmVhY3Rpb24gPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDAgPyByZWFjdGlvbiA6IG51bGw7XG5cblx0Y3VycmVudF9zb3VyY2VzID0gbnVsbDtcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHJlYWN0aW9uLmN0eCk7XG5cdHVudHJhY2tpbmcgPSBmYWxzZTtcblx0dXBkYXRlX3ZlcnNpb24gPSArK3JlYWRfdmVyc2lvbjtcblxuXHRpZiAocmVhY3Rpb24uYWMgIT09IG51bGwpIHtcblx0XHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0LyoqIEB0eXBlIHtBYm9ydENvbnRyb2xsZXJ9ICovIChyZWFjdGlvbi5hYykuYWJvcnQoU1RBTEVfUkVBQ1RJT04pO1xuXHRcdH0pO1xuXG5cdFx0cmVhY3Rpb24uYWMgPSBudWxsO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRyZWFjdGlvbi5mIHw9IFJFQUNUSU9OX0lTX1VQREFUSU5HO1xuXHRcdHZhciBmbiA9IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChyZWFjdGlvbi5mbik7XG5cdFx0dmFyIHJlc3VsdCA9IGZuKCk7XG5cdFx0dmFyIGRlcHMgPSByZWFjdGlvbi5kZXBzO1xuXG5cdFx0aWYgKG5ld19kZXBzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblxuXHRcdFx0aWYgKGRlcHMgIT09IG51bGwgJiYgc2tpcHBlZF9kZXBzID4gMCkge1xuXHRcdFx0XHRkZXBzLmxlbmd0aCA9IHNraXBwZWRfZGVwcyArIG5ld19kZXBzLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5ld19kZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGVwc1tza2lwcGVkX2RlcHMgKyBpXSA9IG5ld19kZXBzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWFjdGlvbi5kZXBzID0gZGVwcyA9IG5ld19kZXBzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFza2lwX3JlYWN0aW9uIHx8XG5cdFx0XHRcdC8vIERlcml2ZWRzIHRoYXQgYWxyZWFkeSBoYXZlIHJlYWN0aW9ucyBjYW4gY2xlYW51cCwgc28gd2Ugc3RpbGwgYWRkIHRoZW0gYXMgcmVhY3Rpb25zXG5cdFx0XHRcdCgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcjY2xpZW50JykuRGVyaXZlZH0gKi8gKHJlYWN0aW9uKS5yZWFjdGlvbnMgIT09IG51bGwpXG5cdFx0XHQpIHtcblx0XHRcdFx0Zm9yIChpID0gc2tpcHBlZF9kZXBzOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdChkZXBzW2ldLnJlYWN0aW9ucyA/Pz0gW10pLnB1c2gocmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA8IGRlcHMubGVuZ3RoKSB7XG5cdFx0XHRyZW1vdmVfcmVhY3Rpb25zKHJlYWN0aW9uLCBza2lwcGVkX2RlcHMpO1xuXHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHM7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGFuIGVmZmVjdCBhbmQgd2UgaGF2ZSB1bnRyYWNrZWQgd3JpdGVzLCB0aGVuIHdlIG5lZWQgdG9cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiBhbnkgb2YgdGhvc2UgdW50cmFja2VkIHdyaXRlcyByZXN1bHQgaW4gcmUtaW52YWxpZGF0aW9uXG5cdFx0Ly8gb2YgdGhlIGN1cnJlbnQgZWZmZWN0LCB0aGVuIHRoYXQgaGFwcGVucyBhY2NvcmRpbmdseVxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdHVudHJhY2tlZF93cml0ZXMgIT09IG51bGwgJiZcblx0XHRcdCF1bnRyYWNraW5nICYmXG5cdFx0XHRkZXBzICE9PSBudWxsICYmXG5cdFx0XHQocmVhY3Rpb24uZiAmIChERVJJVkVEIHwgTUFZQkVfRElSVFkgfCBESVJUWSkpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2VbXX0gKi8gKHVudHJhY2tlZF93cml0ZXMpLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbihcblx0XHRcdFx0XHR1bnRyYWNrZWRfd3JpdGVzW2ldLFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgYXJlIHJldHVybmluZyB0byBhbiBwcmV2aW91cyByZWFjdGlvbiB0aGVuXG5cdFx0Ly8gd2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIHJlYWQgdmVyc2lvbiB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIGFueSBkZXBlbmRlbmNpZXMgaW4gdGhpcyByZWFjdGlvbiBhcmVuJ3QgbWFya2VkIHdpdGhcblx0XHQvLyB0aGUgc2FtZSB2ZXJzaW9uXG5cdFx0aWYgKHByZXZpb3VzX3JlYWN0aW9uICE9PSBudWxsICYmIHByZXZpb3VzX3JlYWN0aW9uICE9PSByZWFjdGlvbikge1xuXHRcdFx0cmVhZF92ZXJzaW9uKys7XG5cblx0XHRcdGlmICh1bnRyYWNrZWRfd3JpdGVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cHJldmlvdXNfdW50cmFja2VkX3dyaXRlcyA9IHVudHJhY2tlZF93cml0ZXM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJldmlvdXNfdW50cmFja2VkX3dyaXRlcy5wdXNoKC4uLi8qKiBAdHlwZSB7U291cmNlW119ICovICh1bnRyYWNrZWRfd3JpdGVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBFUlJPUl9WQUxVRSkgIT09IDApIHtcblx0XHRcdHJlYWN0aW9uLmYgXj0gRVJST1JfVkFMVUU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gaGFuZGxlX2Vycm9yKGVycm9yKTtcblx0fSBmaW5hbGx5IHtcblx0XHRyZWFjdGlvbi5mIF49IFJFQUNUSU9OX0lTX1VQREFUSU5HO1xuXHRcdG5ld19kZXBzID0gcHJldmlvdXNfZGVwcztcblx0XHRza2lwcGVkX2RlcHMgPSBwcmV2aW91c19za2lwcGVkX2RlcHM7XG5cdFx0dW50cmFja2VkX3dyaXRlcyA9IHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXM7XG5cdFx0YWN0aXZlX3JlYWN0aW9uID0gcHJldmlvdXNfcmVhY3Rpb247XG5cdFx0c2tpcF9yZWFjdGlvbiA9IHByZXZpb3VzX3NraXBfcmVhY3Rpb247XG5cdFx0Y3VycmVudF9zb3VyY2VzID0gcHJldmlvdXNfc291cmNlcztcblx0XHRzZXRfY29tcG9uZW50X2NvbnRleHQocHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdHVudHJhY2tpbmcgPSBwcmV2aW91c191bnRyYWNraW5nO1xuXHRcdHVwZGF0ZV92ZXJzaW9uID0gcHJldmlvdXNfdXBkYXRlX3ZlcnNpb247XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBkZXBlbmRlbmN5XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9uKHNpZ25hbCwgZGVwZW5kZW5jeSkge1xuXHRsZXQgcmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHR2YXIgaW5kZXggPSBpbmRleF9vZi5jYWxsKHJlYWN0aW9ucywgc2lnbmFsKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR2YXIgbmV3X2xlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGggLSAxO1xuXHRcdFx0aWYgKG5ld19sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3dhcCB3aXRoIGxhc3QgZWxlbWVudCBhbmQgdGhlbiByZW1vdmUuXG5cdFx0XHRcdHJlYWN0aW9uc1tpbmRleF0gPSByZWFjdGlvbnNbbmV3X2xlbmd0aF07XG5cdFx0XHRcdHJlYWN0aW9ucy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBJZiB0aGUgZGVyaXZlZCBoYXMgbm8gcmVhY3Rpb25zLCB0aGVuIHdlIGNhbiBkaXNjb25uZWN0IGl0IGZyb20gdGhlIGdyYXBoLFxuXHQvLyBhbGxvd2luZyBpdCB0byBlaXRoZXIgcmVjb25uZWN0IGluIHRoZSBmdXR1cmUsIG9yIGJlIEdDJ2QgYnkgdGhlIFZNLlxuXHRpZiAoXG5cdFx0cmVhY3Rpb25zID09PSBudWxsICYmXG5cdFx0KGRlcGVuZGVuY3kuZiAmIERFUklWRUQpICE9PSAwICYmXG5cdFx0Ly8gRGVzdHJveWluZyBhIGNoaWxkIGVmZmVjdCB3aGlsZSB1cGRhdGluZyBhIHBhcmVudCBlZmZlY3QgY2FuIGNhdXNlIGEgZGVwZW5kZW5jeSB0byBhcHBlYXJcblx0XHQvLyB0byBiZSB1bnVzZWQsIHdoZW4gaW4gZmFjdCBpdCBpcyB1c2VkIGJ5IHRoZSBjdXJyZW50bHktdXBkYXRpbmcgcGFyZW50LiBDaGVja2luZyBgbmV3X2RlcHNgXG5cdFx0Ly8gYWxsb3dzIHVzIHRvIHNraXAgdGhlIGV4cGVuc2l2ZSB3b3JrIG9mIGRpc2Nvbm5lY3RpbmcgYW5kIGltbWVkaWF0ZWx5IHJlY29ubmVjdGluZyBpdFxuXHRcdChuZXdfZGVwcyA9PT0gbnVsbCB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoZGVwZW5kZW5jeSkpXG5cdCkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGRlcGVuZGVuY3ksIE1BWUJFX0RJUlRZKTtcblx0XHQvLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZGVyaXZlZCB0aGF0IGlzIG93bmVkIGJ5IGFuIGVmZmVjdCwgdGhlbiBtYXJrIGl0IGFzIGJlaW5nXG5cdFx0Ly8gZGlzY29ubmVjdGVkLlxuXHRcdGlmICgoZGVwZW5kZW5jeS5mICYgKFVOT1dORUQgfCBESVNDT05ORUNURUQpKSA9PT0gMCkge1xuXHRcdFx0ZGVwZW5kZW5jeS5mIF49IERJU0NPTk5FQ1RFRDtcblx0XHR9XG5cdFx0Ly8gRGlzY29ubmVjdCBhbnkgcmVhY3Rpb25zIG93bmVkIGJ5IHRoaXMgcmVhY3Rpb25cblx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cygvKiogQHR5cGUge0Rlcml2ZWR9ICoqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdHJlbW92ZV9yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqKi8gKGRlcGVuZGVuY3kpLCAwKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2luZGV4XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbnMoc2lnbmFsLCBzdGFydF9pbmRleCkge1xuXHR2YXIgZGVwZW5kZW5jaWVzID0gc2lnbmFsLmRlcHM7XG5cdGlmIChkZXBlbmRlbmNpZXMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gc3RhcnRfaW5kZXg7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZW1vdmVfcmVhY3Rpb24oc2lnbmFsLCBkZXBlbmRlbmNpZXNbaV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRpZiAoKGZsYWdzICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgd2FzX3VwZGF0aW5nX2VmZmVjdCA9IGlzX3VwZGF0aW5nX2VmZmVjdDtcblxuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xuXHRpc191cGRhdGluZ19lZmZlY3QgPSB0cnVlO1xuXG5cdGlmIChERVYpIHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2ZuID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbik7XG5cdFx0dmFyIHByZXZpb3VzX3N0YWNrID0gLyoqIEB0eXBlIHthbnl9ICovIChkZXZfc3RhY2spO1xuXHRcdC8vIG9ubHkgYmxvY2sgZWZmZWN0cyBoYXZlIGEgZGV2IHN0YWNrLCBrZWVwIHRoZSBjdXJyZW50IG9uZSBvdGhlcndpc2Vcblx0XHRzZXRfZGV2X3N0YWNrKGVmZmVjdC5kZXZfc3RhY2sgPz8gZGV2X3N0YWNrKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKChmbGFncyAmIEJMT0NLX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fVxuXG5cdFx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KTtcblx0XHR2YXIgdGVhcmRvd24gPSB1cGRhdGVfcmVhY3Rpb24oZWZmZWN0KTtcblx0XHRlZmZlY3QudGVhcmRvd24gPSB0eXBlb2YgdGVhcmRvd24gPT09ICdmdW5jdGlvbicgPyB0ZWFyZG93biA6IG51bGw7XG5cdFx0ZWZmZWN0Lnd2ID0gd3JpdGVfdmVyc2lvbjtcblxuXHRcdC8vIEluIERFViwgaW5jcmVtZW50IHZlcnNpb25zIG9mIGFueSBzb3VyY2VzIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgZWZmZWN0LFxuXHRcdC8vIHNvIHRoYXQgdGhleSBhcmUgY29ycmVjdGx5IG1hcmtlZCBhcyBkaXJ0eSB3aGVuIHRoZSBlZmZlY3QgcmUtcnVuc1xuXHRcdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcgJiYgKGVmZmVjdC5mICYgRElSVFkpICE9PSAwICYmIGVmZmVjdC5kZXBzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBkZXAgb2YgZWZmZWN0LmRlcHMpIHtcblx0XHRcdFx0aWYgKGRlcC5zZXRfZHVyaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRcdGRlcC53diA9IGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCk7XG5cdFx0XHRcdFx0ZGVwLnNldF9kdXJpbmdfZWZmZWN0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfdXBkYXRpbmdfZWZmZWN0ID0gd2FzX3VwZGF0aW5nX2VmZmVjdDtcblx0XHRhY3RpdmVfZWZmZWN0ID0gcHJldmlvdXNfZWZmZWN0O1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihwcmV2aW91c19jb21wb25lbnRfZm4pO1xuXHRcdFx0c2V0X2Rldl9zdGFjayhwcmV2aW91c19zdGFjayk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRpY2soKSB7XG5cdGlmIChhc3luY19tb2RlX2ZsYWcpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGYpID0+IHtcblx0XHRcdC8vIFJhY2UgdGhlbSBhZ2FpbnN0IGVhY2ggb3RoZXIgLSBpbiBhbG1vc3QgYWxsIGNhc2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aWxsIGZpcmUgZmlyc3QsXG5cdFx0XHQvLyBidXQgZS5nLiBpbiBjYXNlIHRoZSB3aW5kb3cgaXMgbm90IGZvY3VzZWQgb3IgYSB2aWV3IHRyYW5zaXRpb24gaGFwcGVucywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0XHQvLyB3aWxsIGJlIGRlbGF5ZWQgYW5kIHNldFRpbWVvdXQgaGVscHMgdXMgcmVzb2x2ZSBmYXN0IGVub3VnaCBpbiB0aGF0IGNhc2Vcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBmKCkpO1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiBmKCkpO1xuXHRcdH0pO1xuXHR9XG5cblx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0Ly8gQnkgY2FsbGluZyBmbHVzaFN5bmMgd2UgZ3VhcmFudGVlIHRoYXQgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBhcmUgYXBwbGllZCBhZnRlciBvbmUgdGljay5cblx0Ly8gVE9ETyBsb29rIGludG8gd2hldGhlciB3ZSBjYW4gbWFrZSBmbHVzaGluZyBzdWJzZXF1ZW50IHVwZGF0ZXMgc3luY2hyb25vdXNseSBpbiB0aGUgZnV0dXJlLlxuXHRmbHVzaFN5bmMoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYW55IHN0YXRlIGNoYW5nZXMsIGFuZCBhc3luY2hyb25vdXMgd29yayByZXN1bHRpbmcgZnJvbSB0aGVtLFxuICogaGF2ZSByZXNvbHZlZCBhbmQgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqIEBzaW5jZSA1LjM2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR0bGVkKCkge1xuXHRyZXR1cm4gQmF0Y2guZW5zdXJlKCkuc2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBzaWduYWxcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHNpZ25hbCkge1xuXHR2YXIgZmxhZ3MgPSBzaWduYWwuZjtcblx0dmFyIGlzX2Rlcml2ZWQgPSAoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMDtcblxuXHRjYXB0dXJlZF9zaWduYWxzPy5hZGQoc2lnbmFsKTtcblxuXHQvLyBSZWdpc3RlciB0aGUgZGVwZW5kZW5jeSBvbiB0aGUgY3VycmVudCByZWFjdGlvbiBzaWduYWwuXG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmcpIHtcblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGRlcml2ZWQgdGhhdCBpcyBiZWluZyByZWFkIGluc2lkZSBhbiBfYXN5bmNfIGRlcml2ZWQsXG5cdFx0Ly8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBlZmZlY3Qgd2FzIGFscmVhZHkgZGVzdHJveWVkLiBJbiB0aGlzIGNhc2UsXG5cdFx0Ly8gd2UgZG9uJ3QgYWRkIHRoZSBkZXBlbmRlbmN5LCBiZWNhdXNlIHRoYXQgd291bGQgY3JlYXRlIGEgbWVtb3J5IGxlYWtcblx0XHR2YXIgZGVzdHJveWVkID0gYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAoYWN0aXZlX2VmZmVjdC5mICYgREVTVFJPWUVEKSAhPT0gMDtcblxuXHRcdGlmICghZGVzdHJveWVkICYmICFjdXJyZW50X3NvdXJjZXM/LmluY2x1ZGVzKHNpZ25hbCkpIHtcblx0XHRcdHZhciBkZXBzID0gYWN0aXZlX3JlYWN0aW9uLmRlcHM7XG5cblx0XHRcdGlmICgoYWN0aXZlX3JlYWN0aW9uLmYgJiBSRUFDVElPTl9JU19VUERBVElORykgIT09IDApIHtcblx0XHRcdFx0Ly8gd2UncmUgaW4gdGhlIGVmZmVjdCBpbml0L3VwZGF0ZSBjeWNsZVxuXHRcdFx0XHRpZiAoc2lnbmFsLnJ2IDwgcmVhZF92ZXJzaW9uKSB7XG5cdFx0XHRcdFx0c2lnbmFsLnJ2ID0gcmVhZF92ZXJzaW9uO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHNpZ25hbCBpcyBhY2Nlc3NpbmcgdGhlIHNhbWUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lXG5cdFx0XHRcdFx0Ly8gb3JkZXIgYXMgaXQgZGlkIGxhc3QgdGltZSwgaW5jcmVtZW50IGBza2lwcGVkX2RlcHNgXG5cdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdXBkYXRpbmcgYG5ld19kZXBzYCwgd2hpY2ggY3JlYXRlcyBHQyBjb3N0XG5cdFx0XHRcdFx0aWYgKG5ld19kZXBzID09PSBudWxsICYmIGRlcHMgIT09IG51bGwgJiYgZGVwc1tza2lwcGVkX2RlcHNdID09PSBzaWduYWwpIHtcblx0XHRcdFx0XHRcdHNraXBwZWRfZGVwcysrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobmV3X2RlcHMgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdG5ld19kZXBzID0gW3NpZ25hbF07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghc2tpcF9yZWFjdGlvbiB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoc2lnbmFsKSkge1xuXHRcdFx0XHRcdFx0Ly8gTm9ybWFsbHkgd2UgY2FuIHB1c2ggZHVwbGljYXRlZCBkZXBlbmRlbmNpZXMgdG8gYG5ld19kZXBzYCwgYnV0IGlmIHdlJ3JlIGluc2lkZVxuXHRcdFx0XHRcdFx0Ly8gYW4gdW5vd25lZCBkZXJpdmVkIGJlY2F1c2Ugc2tpcF9yZWFjdGlvbiBpcyB0cnVlLCB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXRcblx0XHRcdFx0XHRcdC8vIHdlIGRvbid0IGhhdmUgZHVwbGljYXRlc1xuXHRcdFx0XHRcdFx0bmV3X2RlcHMucHVzaChzaWduYWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gd2UncmUgYWRkaW5nIGEgZGVwZW5kZW5jeSBvdXRzaWRlIHRoZSBpbml0L3VwZGF0ZSBjeWNsZVxuXHRcdFx0XHQvLyAoaS5lLiBhZnRlciBhbiBgYXdhaXRgKVxuXHRcdFx0XHQoYWN0aXZlX3JlYWN0aW9uLmRlcHMgPz89IFtdKS5wdXNoKHNpZ25hbCk7XG5cblx0XHRcdFx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cblx0XHRcdFx0aWYgKHJlYWN0aW9ucyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHNpZ25hbC5yZWFjdGlvbnMgPSBbYWN0aXZlX3JlYWN0aW9uXTtcblx0XHRcdFx0fSBlbHNlIGlmICghcmVhY3Rpb25zLmluY2x1ZGVzKGFjdGl2ZV9yZWFjdGlvbikpIHtcblx0XHRcdFx0XHRyZWFjdGlvbnMucHVzaChhY3RpdmVfcmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKFxuXHRcdGlzX2Rlcml2ZWQgJiZcblx0XHQvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmRlcHMgPT09IG51bGwgJiZcblx0XHQvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmVmZmVjdHMgPT09IG51bGxcblx0KSB7XG5cdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXHRcdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblxuXHRcdGlmIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgVU5PV05FRCkgPT09IDApIHtcblx0XHRcdC8vIElmIHRoZSBkZXJpdmVkIGlzIG93bmVkIGJ5IGFub3RoZXIgZGVyaXZlZCB0aGVuIG1hcmsgaXQgYXMgdW5vd25lZFxuXHRcdFx0Ly8gYXMgdGhlIGRlcml2ZWQgdmFsdWUgbWlnaHQgaGF2ZSBiZWVuIHJlZmVyZW5jZWQgaW4gYSBkaWZmZXJlbnQgY29udGV4dFxuXHRcdFx0Ly8gc2luY2UgYW5kIHRodXMgaXRzIHBhcmVudCBtaWdodCBub3QgYmUgaXRzIHRydWUgb3duZXIgYW55bW9yZVxuXHRcdFx0ZGVyaXZlZC5mIF49IFVOT1dORUQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdC8vIFRPRE8gcmVpbnN0YXRlIHRoaXMsIGJ1dCBtYWtlIGl0IGFjdHVhbGx5IHdvcmtcblx0XHQvLyBpZiAoY3VycmVudF9hc3luY19lZmZlY3QpIHtcblx0XHQvLyBcdHZhciB0cmFja2luZyA9IChjdXJyZW50X2FzeW5jX2VmZmVjdC5mICYgUkVBQ1RJT05fSVNfVVBEQVRJTkcpICE9PSAwO1xuXHRcdC8vIFx0dmFyIHdhc19yZWFkID0gY3VycmVudF9hc3luY19lZmZlY3QuZGVwcz8uaW5jbHVkZXMoc2lnbmFsKTtcblxuXHRcdC8vIFx0aWYgKCF0cmFja2luZyAmJiAhdW50cmFja2luZyAmJiAhd2FzX3JlYWQpIHtcblx0XHQvLyBcdFx0dy5hd2FpdF9yZWFjdGl2aXR5X2xvc3MoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzaWduYWwubGFiZWwpKTtcblxuXHRcdC8vIFx0XHR2YXIgdHJhY2UgPSBnZXRfc3RhY2soJ3RyYWNlZCBhdCcpO1xuXHRcdC8vIFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdC8vIFx0XHRpZiAodHJhY2UpIGNvbnNvbGUud2Fybih0cmFjZSk7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXG5cdFx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLmRlbGV0ZShzaWduYWwpO1xuXG5cdFx0aWYgKFxuXHRcdFx0dHJhY2luZ19tb2RlX2ZsYWcgJiZcblx0XHRcdCF1bnRyYWNraW5nICYmXG5cdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zICE9PSBudWxsICYmXG5cdFx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiZcblx0XHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMucmVhY3Rpb24gPT09IGFjdGl2ZV9yZWFjdGlvblxuXHRcdCkge1xuXHRcdFx0Ly8gVXNlZCB3aGVuIG1hcHBpbmcgc3RhdGUgYmV0d2VlbiBzcGVjaWFsIGJsb2NrcyBsaWtlIGBlYWNoYFxuXHRcdFx0aWYgKHNpZ25hbC50cmFjZSkge1xuXHRcdFx0XHRzaWduYWwudHJhY2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0cmFjZSA9IGdldF9zdGFjaygndHJhY2VkIGF0Jyk7XG5cblx0XHRcdFx0aWYgKHRyYWNlKSB7XG5cdFx0XHRcdFx0dmFyIGVudHJ5ID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLmdldChzaWduYWwpO1xuXG5cdFx0XHRcdFx0aWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGVudHJ5ID0geyB0cmFjZXM6IFtdIH07XG5cdFx0XHRcdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuc2V0KHNpZ25hbCwgZW50cnkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBsYXN0ID0gZW50cnkudHJhY2VzW2VudHJ5LnRyYWNlcy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdC8vIHRyYWNlcyBjYW4gYmUgZHVwbGljYXRlZCwgZS5nLiBieSBgc25hcHNob3RgIGludm9raW5nIGJvdGhcblx0XHRcdFx0XHQvLyBib3RoIGBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGFuZCBgZ2V0YCB0cmFwcyBhdCBvbmNlXG5cdFx0XHRcdFx0aWYgKHRyYWNlLnN0YWNrICE9PSBsYXN0Py5zdGFjaykge1xuXHRcdFx0XHRcdFx0ZW50cnkudHJhY2VzLnB1c2godHJhY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdGlmIChvbGRfdmFsdWVzLmhhcyhzaWduYWwpKSB7XG5cdFx0XHRyZXR1cm4gb2xkX3ZhbHVlcy5nZXQoc2lnbmFsKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfZGVyaXZlZCkge1xuXHRcdFx0ZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCk7XG5cblx0XHRcdHZhciB2YWx1ZSA9IGRlcml2ZWQudjtcblxuXHRcdFx0Ly8gaWYgdGhlIGRlcml2ZWQgaXMgZGlydHkgYW5kIGhhcyByZWFjdGlvbnMsIG9yIGRlcGVuZHMgb24gdGhlIHZhbHVlcyB0aGF0IGp1c3QgY2hhbmdlZCwgcmUtZXhlY3V0ZVxuXHRcdFx0Ly8gKGEgZGVyaXZlZCBjYW4gYmUgbWF5YmVfZGlydHkgZHVlIHRvIHRoZSBlZmZlY3QgZGVzdHJveSByZW1vdmluZyBpdHMgbGFzdCByZWFjdGlvbilcblx0XHRcdGlmIChcblx0XHRcdFx0KChkZXJpdmVkLmYgJiBDTEVBTikgPT09IDAgJiYgZGVyaXZlZC5yZWFjdGlvbnMgIT09IG51bGwpIHx8XG5cdFx0XHRcdGRlcGVuZHNfb25fb2xkX3ZhbHVlcyhkZXJpdmVkKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHZhbHVlID0gZXhlY3V0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRfdmFsdWVzLnNldChkZXJpdmVkLCB2YWx1ZSk7XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoaXNfZGVyaXZlZCkge1xuXHRcdGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXG5cdFx0aWYgKGJhdGNoX3ZhbHVlcz8uaGFzKGRlcml2ZWQpKSB7XG5cdFx0XHRyZXR1cm4gYmF0Y2hfdmFsdWVzLmdldChkZXJpdmVkKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfZGlydHkoZGVyaXZlZCkpIHtcblx0XHRcdHVwZGF0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChiYXRjaF92YWx1ZXM/LmhhcyhzaWduYWwpKSB7XG5cdFx0cmV0dXJuIGJhdGNoX3ZhbHVlcy5nZXQoc2lnbmFsKTtcblx0fVxuXG5cdGlmICgoc2lnbmFsLmYgJiBFUlJPUl9WQUxVRSkgIT09IDApIHtcblx0XHR0aHJvdyBzaWduYWwudjtcblx0fVxuXG5cdHJldHVybiBzaWduYWwudjtcbn1cblxuLyoqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZCAqL1xuZnVuY3Rpb24gZGVwZW5kc19vbl9vbGRfdmFsdWVzKGRlcml2ZWQpIHtcblx0aWYgKGRlcml2ZWQudiA9PT0gVU5JTklUSUFMSVpFRCkgcmV0dXJuIHRydWU7IC8vIHdlIGRvbid0IGtub3csIHNvIGFzc3VtZSB0aGUgd29yc3Rcblx0aWYgKGRlcml2ZWQuZGVwcyA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG5cdGZvciAoY29uc3QgZGVwIG9mIGRlcml2ZWQuZGVwcykge1xuXHRcdGlmIChvbGRfdmFsdWVzLmhhcyhkZXApKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoKGRlcC5mICYgREVSSVZFRCkgIT09IDAgJiYgZGVwZW5kc19vbl9vbGRfdmFsdWVzKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcCkpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGlrZSBgZ2V0YCwgYnV0IGNoZWNrcyBmb3IgYHVuZGVmaW5lZGAuIFVzZWQgZm9yIGB2YXJgIGRlY2xhcmF0aW9ucyBiZWNhdXNlIHRoZXkgY2FuIGJlIGFjY2Vzc2VkIGJlZm9yZSBiZWluZyBkZWNsYXJlZFxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj4gfCB1bmRlZmluZWR9IHNpZ25hbFxuICogQHJldHVybnMge1YgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX2dldChzaWduYWwpIHtcblx0cmV0dXJuIHNpZ25hbCAmJiBnZXQoc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW5zaWRlIGEgW2AkZGVyaXZlZGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZGVyaXZlZCkgb3IgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpLFxuICogYW55IHN0YXRlIHJlYWQgaW5zaWRlIGBmbmAgd2lsbCBub3QgYmUgdHJlYXRlZCBhcyBhIGRlcGVuZGVuY3kuXG4gKlxuICogYGBgdHNcbiAqICRlZmZlY3QoKCkgPT4ge1xuICogICAvLyB0aGlzIHdpbGwgcnVuIHdoZW4gYGRhdGFgIGNoYW5nZXMsIGJ1dCBub3Qgd2hlbiBgdGltZWAgY2hhbmdlc1xuICogICBzYXZlKGRhdGEsIHtcbiAqICAgICB0aW1lc3RhbXA6IHVudHJhY2soKCkgPT4gdGltZSlcbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW50cmFjayhmbikge1xuXHR2YXIgcHJldmlvdXNfdW50cmFja2luZyA9IHVudHJhY2tpbmc7XG5cdHRyeSB7XG5cdFx0dW50cmFja2luZyA9IHRydWU7XG5cdFx0cmV0dXJuIGZuKCk7XG5cdH0gZmluYWxseSB7XG5cdFx0dW50cmFja2luZyA9IHByZXZpb3VzX3VudHJhY2tpbmc7XG5cdH1cbn1cblxuY29uc3QgU1RBVFVTX01BU0sgPSB+KERJUlRZIHwgTUFZQkVfRElSVFkgfCBDTEVBTik7XG5cbi8qKlxuICogQHBhcmFtIHtTaWduYWx9IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc2lnbmFsX3N0YXR1cyhzaWduYWwsIHN0YXR1cykge1xuXHRzaWduYWwuZiA9IChzaWduYWwuZiAmIFNUQVRVU19NQVNLKSB8IHN0YXR1cztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGtleXNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfZnJvbV9vYmplY3Qob2JqLCBrZXlzKSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICovXG5cdHZhciByZXN1bHQgPSB7fTtcblxuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcblx0XHRcdHJlc3VsdFtrZXldID0gb2JqW2tleV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBQb3NzaWJseSB0cmF2ZXJzZSBhbiBvYmplY3QgYW5kIHJlYWQgYWxsIGl0cyBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVhY3RpdmUgaW4gY2FzZSB0aGlzIGlzIGAkc3RhdGVgLlxuICogRG9lcyBvbmx5IGNoZWNrIGZpcnN0IGxldmVsIG9mIGFuIG9iamVjdCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAoaGV1cmlzdGljIHNob3VsZCBiZSBnb29kIGZvciA5OSUgb2YgYWxsIGNhc2VzKS5cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwX3JlYWRfc3RhdGUodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgIXZhbHVlIHx8IHZhbHVlIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoU1RBVEVfU1lNQk9MIGluIHZhbHVlKSB7XG5cdFx0ZGVlcF9yZWFkKHZhbHVlKTtcblx0fSBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdGNvbnN0IHByb3AgPSB2YWx1ZVtrZXldO1xuXHRcdFx0aWYgKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiBwcm9wICYmIFNUQVRFX1NZTUJPTCBpbiBwcm9wKSB7XG5cdFx0XHRcdGRlZXBfcmVhZChwcm9wKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBEZWVwbHkgdHJhdmVyc2UgYW4gb2JqZWN0IGFuZCByZWFkIGFsbCBpdHMgcHJvcGVydGllc1xuICogc28gdGhhdCB0aGV5J3JlIGFsbCByZWFjdGl2ZSBpbiBjYXNlIHRoaXMgaXMgYCRzdGF0ZWBcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtTZXQ8YW55Pn0gdmlzaXRlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwX3JlYWQodmFsdWUsIHZpc2l0ZWQgPSBuZXcgU2V0KCkpIHtcblx0aWYgKFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2UgRE9NIGVsZW1lbnRzXG5cdFx0ISh2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSAmJlxuXHRcdCF2aXNpdGVkLmhhcyh2YWx1ZSlcblx0KSB7XG5cdFx0dmlzaXRlZC5hZGQodmFsdWUpO1xuXHRcdC8vIFdoZW4gd29ya2luZyB3aXRoIGEgcG9zc2libGUgU3ZlbHRlRGF0ZSwgdGhpc1xuXHRcdC8vIHdpbGwgZW5zdXJlIHdlIGNhcHR1cmUgY2hhbmdlcyB0byBpdC5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHR2YWx1ZS5nZXRUaW1lKCk7XG5cdFx0fVxuXHRcdGZvciAobGV0IGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVlcF9yZWFkKHZhbHVlW2tleV0sIHZpc2l0ZWQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBjb250aW51ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwcm90byA9IGdldF9wcm90b3R5cGVfb2YodmFsdWUpO1xuXHRcdGlmIChcblx0XHRcdHByb3RvICE9PSBPYmplY3QucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gQXJyYXkucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gTWFwLnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IFNldC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBEYXRlLnByb3RvdHlwZVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgZGVzY3JpcHRvcnMgPSBnZXRfZGVzY3JpcHRvcnMocHJvdG8pO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIGRlc2NyaXB0b3JzKSB7XG5cdFx0XHRcdGNvbnN0IGdldCA9IGRlc2NyaXB0b3JzW2tleV0uZ2V0O1xuXHRcdFx0XHRpZiAoZ2V0KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGdldC5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIiwiY29uc3QgcmVnZXhfcmV0dXJuX2NoYXJhY3RlcnMgPSAvXFxyL2c7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goc3RyKSB7XG5cdHN0ciA9IHN0ci5yZXBsYWNlKHJlZ2V4X3JldHVybl9jaGFyYWN0ZXJzLCAnJyk7XG5cdGxldCBoYXNoID0gNTM4MTtcblx0bGV0IGkgPSBzdHIubGVuZ3RoO1xuXG5cdHdoaWxlIChpLS0pIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuXHRyZXR1cm4gKGhhc2ggPj4+IDApLnRvU3RyaW5nKDM2KTtcbn1cblxuY29uc3QgVk9JRF9FTEVNRU5UX05BTUVTID0gW1xuXHQnYXJlYScsXG5cdCdiYXNlJyxcblx0J2JyJyxcblx0J2NvbCcsXG5cdCdjb21tYW5kJyxcblx0J2VtYmVkJyxcblx0J2hyJyxcblx0J2ltZycsXG5cdCdpbnB1dCcsXG5cdCdrZXlnZW4nLFxuXHQnbGluaycsXG5cdCdtZXRhJyxcblx0J3BhcmFtJyxcblx0J3NvdXJjZScsXG5cdCd0cmFjaycsXG5cdCd3YnInXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBuYW1lYCBpcyBvZiBhIHZvaWQgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuXHRyZXR1cm4gVk9JRF9FTEVNRU5UX05BTUVTLmluY2x1ZGVzKG5hbWUpIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyFkb2N0eXBlJztcbn1cblxuY29uc3QgUkVTRVJWRURfV09SRFMgPSBbXG5cdCdhcmd1bWVudHMnLFxuXHQnYXdhaXQnLFxuXHQnYnJlYWsnLFxuXHQnY2FzZScsXG5cdCdjYXRjaCcsXG5cdCdjbGFzcycsXG5cdCdjb25zdCcsXG5cdCdjb250aW51ZScsXG5cdCdkZWJ1Z2dlcicsXG5cdCdkZWZhdWx0Jyxcblx0J2RlbGV0ZScsXG5cdCdkbycsXG5cdCdlbHNlJyxcblx0J2VudW0nLFxuXHQnZXZhbCcsXG5cdCdleHBvcnQnLFxuXHQnZXh0ZW5kcycsXG5cdCdmYWxzZScsXG5cdCdmaW5hbGx5Jyxcblx0J2ZvcicsXG5cdCdmdW5jdGlvbicsXG5cdCdpZicsXG5cdCdpbXBsZW1lbnRzJyxcblx0J2ltcG9ydCcsXG5cdCdpbicsXG5cdCdpbnN0YW5jZW9mJyxcblx0J2ludGVyZmFjZScsXG5cdCdsZXQnLFxuXHQnbmV3Jyxcblx0J251bGwnLFxuXHQncGFja2FnZScsXG5cdCdwcml2YXRlJyxcblx0J3Byb3RlY3RlZCcsXG5cdCdwdWJsaWMnLFxuXHQncmV0dXJuJyxcblx0J3N0YXRpYycsXG5cdCdzdXBlcicsXG5cdCdzd2l0Y2gnLFxuXHQndGhpcycsXG5cdCd0aHJvdycsXG5cdCd0cnVlJyxcblx0J3RyeScsXG5cdCd0eXBlb2YnLFxuXHQndmFyJyxcblx0J3ZvaWQnLFxuXHQnd2hpbGUnLFxuXHQnd2l0aCcsXG5cdCd5aWVsZCdcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYHdvcmRgIGlzIGEgcmVzZXJ2ZWQgSmF2YVNjcmlwdCBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gd29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcmVzZXJ2ZWQod29yZCkge1xuXHRyZXR1cm4gUkVTRVJWRURfV09SRFMuaW5jbHVkZXMod29yZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2NhcHR1cmVfZXZlbnQobmFtZSkge1xuXHRyZXR1cm4gbmFtZS5lbmRzV2l0aCgnY2FwdHVyZScpICYmIG5hbWUgIT09ICdnb3Rwb2ludGVyY2FwdHVyZScgJiYgbmFtZSAhPT0gJ2xvc3Rwb2ludGVyY2FwdHVyZSc7XG59XG5cbi8qKiBMaXN0IG9mIEVsZW1lbnQgZXZlbnRzIHRoYXQgd2lsbCBiZSBkZWxlZ2F0ZWQgKi9cbmNvbnN0IERFTEVHQVRFRF9FVkVOVFMgPSBbXG5cdCdiZWZvcmVpbnB1dCcsXG5cdCdjbGljaycsXG5cdCdjaGFuZ2UnLFxuXHQnZGJsY2xpY2snLFxuXHQnY29udGV4dG1lbnUnLFxuXHQnZm9jdXNpbicsXG5cdCdmb2N1c291dCcsXG5cdCdpbnB1dCcsXG5cdCdrZXlkb3duJyxcblx0J2tleXVwJyxcblx0J21vdXNlZG93bicsXG5cdCdtb3VzZW1vdmUnLFxuXHQnbW91c2VvdXQnLFxuXHQnbW91c2VvdmVyJyxcblx0J21vdXNldXAnLFxuXHQncG9pbnRlcmRvd24nLFxuXHQncG9pbnRlcm1vdmUnLFxuXHQncG9pbnRlcm91dCcsXG5cdCdwb2ludGVyb3ZlcicsXG5cdCdwb2ludGVydXAnLFxuXHQndG91Y2hlbmQnLFxuXHQndG91Y2htb3ZlJyxcblx0J3RvdWNoc3RhcnQnXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBldmVudF9uYW1lYCBpcyBhIGRlbGVnYXRlZCBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbl9kZWxlZ2F0ZV9ldmVudChldmVudF9uYW1lKSB7XG5cdHJldHVybiBERUxFR0FURURfRVZFTlRTLmluY2x1ZGVzKGV2ZW50X25hbWUpO1xufVxuXG4vKipcbiAqIEF0dHJpYnV0ZXMgdGhhdCBhcmUgYm9vbGVhbiwgaS5lLiB0aGV5IGFyZSBwcmVzZW50IG9yIG5vdCBwcmVzZW50LlxuICovXG5jb25zdCBET01fQk9PTEVBTl9BVFRSSUJVVEVTID0gW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FzeW5jJyxcblx0J2F1dG9mb2N1cycsXG5cdCdhdXRvcGxheScsXG5cdCdjaGVja2VkJyxcblx0J2NvbnRyb2xzJyxcblx0J2RlZmF1bHQnLFxuXHQnZGlzYWJsZWQnLFxuXHQnZm9ybW5vdmFsaWRhdGUnLFxuXHQnaW5kZXRlcm1pbmF0ZScsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWFtbGVzcycsXG5cdCdzZWxlY3RlZCcsXG5cdCd3ZWJraXRkaXJlY3RvcnknLFxuXHQnZGVmZXInLFxuXHQnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLFxuXHQnZGlzYWJsZXJlbW90ZXBsYXliYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBib29sZWFuIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Jvb2xlYW5fYXR0cmlidXRlKG5hbWUpIHtcblx0cmV0dXJuIERPTV9CT09MRUFOX0FUVFJJQlVURVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbi8qKlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IHNob3VsZCBiZSBhbGlhc2VkIHRvIHRoZWlyIHByb3BlcnR5IG5hbWVzXG4gKiBiZWNhdXNlIHRoZXkgYmVoYXZlIGRpZmZlcmVudGx5IGJldHdlZW4gc2V0dGluZyB0aGVtIGFzIGFuIGF0dHJpYnV0ZSBhbmRcbiAqIHNldHRpbmcgdGhlbSBhcyBhIHByb3BlcnR5LlxuICovXG5jb25zdCBBVFRSSUJVVEVfQUxJQVNFUyA9IHtcblx0Ly8gbm8gYGNsYXNzOiAnY2xhc3NOYW1lJ2AgYmVjYXVzZSB3ZSBoYW5kbGUgdGhhdCBzZXBhcmF0ZWx5XG5cdGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuXHRpc21hcDogJ2lzTWFwJyxcblx0bm9tb2R1bGU6ICdub01vZHVsZScsXG5cdHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuXHRyZWFkb25seTogJ3JlYWRPbmx5Jyxcblx0ZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcblx0ZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG5cdHNyY29iamVjdDogJ3NyY09iamVjdCcsXG5cdG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcblx0YWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsc2NyZWVuJyxcblx0ZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG5cdGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaydcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZV9hdHRyaWJ1dGUobmFtZSkge1xuXHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRyZXR1cm4gQVRUUklCVVRFX0FMSUFTRVNbbmFtZV0gPz8gbmFtZTtcbn1cblxuY29uc3QgRE9NX1BST1BFUlRJRVMgPSBbXG5cdC4uLkRPTV9CT09MRUFOX0FUVFJJQlVURVMsXG5cdCdmb3JtTm9WYWxpZGF0ZScsXG5cdCdpc01hcCcsXG5cdCdub01vZHVsZScsXG5cdCdwbGF5c0lubGluZScsXG5cdCdyZWFkT25seScsXG5cdCd2YWx1ZScsXG5cdCd2b2x1bWUnLFxuXHQnZGVmYXVsdFZhbHVlJyxcblx0J2RlZmF1bHRDaGVja2VkJyxcblx0J3NyY09iamVjdCcsXG5cdCdub1ZhbGlkYXRlJyxcblx0J2FsbG93RnVsbHNjcmVlbicsXG5cdCdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG5cdCdkaXNhYmxlUmVtb3RlUGxheWJhY2snXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kb21fcHJvcGVydHkobmFtZSkge1xuXHRyZXR1cm4gRE9NX1BST1BFUlRJRVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE5PTl9TVEFUSUNfUFJPUEVSVElFUyA9IFsnYXV0b2ZvY3VzJywgJ211dGVkJywgJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCddO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgY2Fubm90IGJlIHNldCB0aHJvdWdoIHRoZSB0ZW1wbGF0ZVxuICogc3RyaW5nLCBpLmUuIG5lZWRzIHNvbWUga2luZCBvZiBKYXZhU2NyaXB0IGhhbmRsaW5nIHRvIHdvcmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90X2JlX3NldF9zdGF0aWNhbGx5KG5hbWUpIHtcblx0cmV0dXJuIE5PTl9TVEFUSUNfUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBTdWJzZXQgb2YgZGVsZWdhdGVkIGV2ZW50cyB3aGljaCBzaG91bGQgYmUgcGFzc2l2ZSBieSBkZWZhdWx0LlxuICogVGhlc2UgdHdvIGFyZSBhbHJlYWR5IHBhc3NpdmUgdmlhIGJyb3dzZXIgZGVmYXVsdHMgb24gd2luZG93LCBkb2N1bWVudCBhbmQgYm9keS5cbiAqIEJ1dCBzaW5jZVxuICogLSB3ZSdyZSBkZWxlZ2F0aW5nIHRoZW1cbiAqIC0gdGhleSBoYXBwZW4gb2Z0ZW5cbiAqIC0gdGhleSBhcHBseSB0byBtb2JpbGUgd2hpY2ggaXMgZ2VuZXJhbGx5IGxlc3MgcGVyZm9ybWFudFxuICogd2UncmUgbWFya2luZyB0aGVtIGFzIHBhc3NpdmUgYnkgZGVmYXVsdCBmb3Igb3RoZXIgZWxlbWVudHMsIHRvby5cbiAqL1xuY29uc3QgUEFTU0lWRV9FVkVOVFMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIGEgcGFzc2l2ZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Bhc3NpdmVfZXZlbnQobmFtZSkge1xuXHRyZXR1cm4gUEFTU0lWRV9FVkVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IENPTlRFTlRfRURJVEFCTEVfQklORElOR1MgPSBbJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCcsICdpbm5lclRleHQnXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY29udGVudF9lZGl0YWJsZV9iaW5kaW5nKG5hbWUpIHtcblx0cmV0dXJuIENPTlRFTlRfRURJVEFCTEVfQklORElOR1MuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IExPQURfRVJST1JfRUxFTUVOVFMgPSBbXG5cdCdib2R5Jyxcblx0J2VtYmVkJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnbGluaycsXG5cdCdvYmplY3QnLFxuXHQnc2NyaXB0Jyxcblx0J3N0eWxlJyxcblx0J3RyYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBlbWl0cyBgbG9hZGAgYW5kIGBlcnJvcmAgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfbG9hZF9lcnJvcl9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIExPQURfRVJST1JfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFNWR19FTEVNRU5UUyA9IFtcblx0J2FsdEdseXBoJyxcblx0J2FsdEdseXBoRGVmJyxcblx0J2FsdEdseXBoSXRlbScsXG5cdCdhbmltYXRlJyxcblx0J2FuaW1hdGVDb2xvcicsXG5cdCdhbmltYXRlTW90aW9uJyxcblx0J2FuaW1hdGVUcmFuc2Zvcm0nLFxuXHQnY2lyY2xlJyxcblx0J2NsaXBQYXRoJyxcblx0J2NvbG9yLXByb2ZpbGUnLFxuXHQnY3Vyc29yJyxcblx0J2RlZnMnLFxuXHQnZGVzYycsXG5cdCdkaXNjYXJkJyxcblx0J2VsbGlwc2UnLFxuXHQnZmVCbGVuZCcsXG5cdCdmZUNvbG9yTWF0cml4Jyxcblx0J2ZlQ29tcG9uZW50VHJhbnNmZXInLFxuXHQnZmVDb21wb3NpdGUnLFxuXHQnZmVDb252b2x2ZU1hdHJpeCcsXG5cdCdmZURpZmZ1c2VMaWdodGluZycsXG5cdCdmZURpc3BsYWNlbWVudE1hcCcsXG5cdCdmZURpc3RhbnRMaWdodCcsXG5cdCdmZURyb3BTaGFkb3cnLFxuXHQnZmVGbG9vZCcsXG5cdCdmZUZ1bmNBJyxcblx0J2ZlRnVuY0InLFxuXHQnZmVGdW5jRycsXG5cdCdmZUZ1bmNSJyxcblx0J2ZlR2F1c3NpYW5CbHVyJyxcblx0J2ZlSW1hZ2UnLFxuXHQnZmVNZXJnZScsXG5cdCdmZU1lcmdlTm9kZScsXG5cdCdmZU1vcnBob2xvZ3knLFxuXHQnZmVPZmZzZXQnLFxuXHQnZmVQb2ludExpZ2h0Jyxcblx0J2ZlU3BlY3VsYXJMaWdodGluZycsXG5cdCdmZVNwb3RMaWdodCcsXG5cdCdmZVRpbGUnLFxuXHQnZmVUdXJidWxlbmNlJyxcblx0J2ZpbHRlcicsXG5cdCdmb250Jyxcblx0J2ZvbnQtZmFjZScsXG5cdCdmb250LWZhY2UtZm9ybWF0Jyxcblx0J2ZvbnQtZmFjZS1uYW1lJyxcblx0J2ZvbnQtZmFjZS1zcmMnLFxuXHQnZm9udC1mYWNlLXVyaScsXG5cdCdmb3JlaWduT2JqZWN0Jyxcblx0J2cnLFxuXHQnZ2x5cGgnLFxuXHQnZ2x5cGhSZWYnLFxuXHQnaGF0Y2gnLFxuXHQnaGF0Y2hwYXRoJyxcblx0J2hrZXJuJyxcblx0J2ltYWdlJyxcblx0J2xpbmUnLFxuXHQnbGluZWFyR3JhZGllbnQnLFxuXHQnbWFya2VyJyxcblx0J21hc2snLFxuXHQnbWVzaCcsXG5cdCdtZXNoZ3JhZGllbnQnLFxuXHQnbWVzaHBhdGNoJyxcblx0J21lc2hyb3cnLFxuXHQnbWV0YWRhdGEnLFxuXHQnbWlzc2luZy1nbHlwaCcsXG5cdCdtcGF0aCcsXG5cdCdwYXRoJyxcblx0J3BhdHRlcm4nLFxuXHQncG9seWdvbicsXG5cdCdwb2x5bGluZScsXG5cdCdyYWRpYWxHcmFkaWVudCcsXG5cdCdyZWN0Jyxcblx0J3NldCcsXG5cdCdzb2xpZGNvbG9yJyxcblx0J3N0b3AnLFxuXHQnc3ZnJyxcblx0J3N3aXRjaCcsXG5cdCdzeW1ib2wnLFxuXHQndGV4dCcsXG5cdCd0ZXh0UGF0aCcsXG5cdCd0cmVmJyxcblx0J3RzcGFuJyxcblx0J3Vua25vd24nLFxuXHQndXNlJyxcblx0J3ZpZXcnLFxuXHQndmtlcm4nXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19zdmcobmFtZSkge1xuXHRyZXR1cm4gU1ZHX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBNQVRITUxfRUxFTUVOVFMgPSBbXG5cdCdhbm5vdGF0aW9uJyxcblx0J2Fubm90YXRpb24teG1sJyxcblx0J21hY3Rpb24nLFxuXHQnbWF0aCcsXG5cdCdtZXJyb3InLFxuXHQnbWZyYWMnLFxuXHQnbWknLFxuXHQnbW11bHRpc2NyaXB0cycsXG5cdCdtbicsXG5cdCdtbycsXG5cdCdtb3ZlcicsXG5cdCdtcGFkZGVkJyxcblx0J21waGFudG9tJyxcblx0J21wcmVzY3JpcHRzJyxcblx0J21yb290Jyxcblx0J21yb3cnLFxuXHQnbXMnLFxuXHQnbXNwYWNlJyxcblx0J21zcXJ0Jyxcblx0J21zdHlsZScsXG5cdCdtc3ViJyxcblx0J21zdWJzdXAnLFxuXHQnbXN1cCcsXG5cdCdtdGFibGUnLFxuXHQnbXRkJyxcblx0J210ZXh0Jyxcblx0J210cicsXG5cdCdtdW5kZXInLFxuXHQnbXVuZGVyb3ZlcicsXG5cdCdzZW1hbnRpY3MnXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19tYXRobWwobmFtZSkge1xuXHRyZXR1cm4gTUFUSE1MX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBTVEFURV9DUkVBVElPTl9SVU5FUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCckc3RhdGUnLFxuXHQnJHN0YXRlLnJhdycsXG5cdCckZGVyaXZlZCcsXG5cdCckZGVyaXZlZC5ieSdcbl0pO1xuXG5jb25zdCBSVU5FUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdC4uLlNUQVRFX0NSRUFUSU9OX1JVTkVTLFxuXHQnJHN0YXRlLmVhZ2VyJyxcblx0JyRzdGF0ZS5zbmFwc2hvdCcsXG5cdCckcHJvcHMnLFxuXHQnJHByb3BzLmlkJyxcblx0JyRiaW5kYWJsZScsXG5cdCckZWZmZWN0Jyxcblx0JyRlZmZlY3QucHJlJyxcblx0JyRlZmZlY3QudHJhY2tpbmcnLFxuXHQnJGVmZmVjdC5yb290Jyxcblx0JyRlZmZlY3QucGVuZGluZycsXG5cdCckaW5zcGVjdCcsXG5cdCckaW5zcGVjdCgpLndpdGgnLFxuXHQnJGluc3BlY3QudHJhY2UnLFxuXHQnJGhvc3QnXG5dKTtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgUlVORVNbbnVtYmVyXX0gUnVuZU5hbWUgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgUnVuZU5hbWV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19ydW5lKG5hbWUpIHtcblx0cmV0dXJuIFJVTkVTLmluY2x1ZGVzKC8qKiBAdHlwZSB7UnVuZU5hbWV9ICovIChuYW1lKSk7XG59XG5cbi8qKiBAdHlwZWRlZiB7dHlwZW9mIFNUQVRFX0NSRUFUSU9OX1JVTkVTW251bWJlcl19IFN0YXRlQ3JlYXRpb25SdW5lTmFtZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBTdGF0ZUNyZWF0aW9uUnVuZU5hbWV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19zdGF0ZV9jcmVhdGlvbl9ydW5lKG5hbWUpIHtcblx0cmV0dXJuIFNUQVRFX0NSRUFUSU9OX1JVTkVTLmluY2x1ZGVzKC8qKiBAdHlwZSB7U3RhdGVDcmVhdGlvblJ1bmVOYW1lfSAqLyAobmFtZSkpO1xufVxuXG4vKiogTGlzdCBvZiBlbGVtZW50cyB0aGF0IHJlcXVpcmUgcmF3IGNvbnRlbnRzIGFuZCBzaG91bGQgbm90IGhhdmUgU1NSIGNvbW1lbnRzIHB1dCBpbiB0aGVtICovXG5jb25zdCBSQVdfVEVYVF9FTEVNRU5UUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ3RleHRhcmVhJywgJ3NjcmlwdCcsICdzdHlsZScsICd0aXRsZSddKTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcmF3X3RleHRfZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBSQVdfVEVYVF9FTEVNRU5UUy5pbmNsdWRlcygvKiogQHR5cGUge3R5cGVvZiBSQVdfVEVYVF9FTEVNRU5UU1tudW1iZXJdfSAqLyAobmFtZSkpO1xufVxuXG4vKipcbiAqIFByZXZlbnQgZGV2dG9vbHMgdHJ5aW5nIHRvIG1ha2UgYGxvY2F0aW9uYCBhIGNsaWNrYWJsZSBsaW5rIGJ5IGluc2VydGluZyBhIHplcm8td2lkdGggc3BhY2VcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUXG4gKiBAcGFyYW0ge1R9IGxvY2F0aW9uXG4gKiBAcmV0dXJucyB7VH07XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZV9sb2NhdGlvbihsb2NhdGlvbikge1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAobG9jYXRpb24/LnJlcGxhY2UoL1xcLy9nLCAnL1xcdTIwMGInKSk7XG59XG4iLCJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuLyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cbmV4cG9ydCBjb25zdCBhbGxfcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBAdHlwZSB7U2V0PChldmVudHM6IEFycmF5PHN0cmluZz4pID0+IHZvaWQ+fSAqL1xuZXhwb3J0IGNvbnN0IHJvb3RfZXZlbnRfaGFuZGxlcyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBTU1IgYWRkcyBvbmxvYWQgYW5kIG9uZXJyb3IgYXR0cmlidXRlcyB0byBjYXRjaCB0aG9zZSBldmVudHMgYmVmb3JlIHRoZSBoeWRyYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgdGhvc2UgY2FzZXMsIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZXMgYW5kIHJlcGxheXMgdGhlIGV2ZW50cy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGF5X2V2ZW50cyhkb20pIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHRkb20ucmVtb3ZlQXR0cmlidXRlKCdvbmxvYWQnKTtcblx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25lcnJvcicpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGV2ZW50ID0gZG9tLl9fZTtcblx0aWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZG9tLl9fZSA9IHVuZGVmaW5lZDtcblx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoZG9tLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHRcdGRvbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBkb21cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gW2hhbmRsZXJdXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuXHQvKipcblx0ICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuXHQgKi9cblx0ZnVuY3Rpb24gdGFyZ2V0X2hhbmRsZXIoLyoqIEB0eXBlIHtFdmVudH0gKi8gZXZlbnQpIHtcblx0XHRpZiAoIW9wdGlvbnMuY2FwdHVyZSkge1xuXHRcdFx0Ly8gT25seSBjYWxsIGluIHRoZSBidWJibGUgcGhhc2UsIGVsc2UgZGVsZWdhdGVkIGV2ZW50cyB3b3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjYXB0dXJpbmcgZXZlbnRzXG5cdFx0XHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24uY2FsbChkb20sIGV2ZW50KTtcblx0XHR9XG5cdFx0aWYgKCFldmVudC5jYW5jZWxCdWJibGUpIHtcblx0XHRcdHJldHVybiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlcj8uY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaHJvbWUgaGFzIGEgYnVnIHdoZXJlIHBvaW50ZXIgZXZlbnRzIGRvbid0IHdvcmsgd2hlbiBhdHRhY2hlZCB0byBhIERPTSBlbGVtZW50IHRoYXQgaGFzIGJlZW4gY2xvbmVkXG5cdC8vIHdpdGggY2xvbmVOb2RlKCkgYW5kIHRoZSBET00gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFRvIGVuc3VyZSB0aGUgZXZlbnQgd29ya3MsIHdlXG5cdC8vIGRlZmVyIHRoZSBhdHRhY2htZW50IHRpbGwgYWZ0ZXIgaXQncyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudC4gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgZml4ZXNcblx0Ly8gdGhpcyBidWcuIFRoZSBzYW1lIGFwcGxpZXMgdG8gd2hlZWwgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG5cdGlmIChcblx0XHRldmVudF9uYW1lLnN0YXJ0c1dpdGgoJ3BvaW50ZXInKSB8fFxuXHRcdGV2ZW50X25hbWUuc3RhcnRzV2l0aCgndG91Y2gnKSB8fFxuXHRcdGV2ZW50X25hbWUgPT09ICd3aGVlbCdcblx0KSB7XG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldF9oYW5kbGVyO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgaGFuZGxlci4gVXNpbmcgdGhpc1xuICogcmF0aGVyIHRoYW4gYGFkZEV2ZW50TGlzdGVuZXJgIHdpbGwgcHJlc2VydmUgdGhlIGNvcnJlY3Qgb3JkZXIgcmVsYXRpdmUgdG8gaGFuZGxlcnMgYWRkZWQgZGVjbGFyYXRpdmVseVxuICogKHdpdGggYXR0cmlidXRlcyBsaWtlIGBvbmNsaWNrYCksIHdoaWNoIHVzZSBldmVudCBkZWxlZ2F0aW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICogQHBhcmFtIHtBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcblx0dmFyIHRhcmdldF9oYW5kbGVyID0gY3JlYXRlX2V2ZW50KHR5cGUsIGVsZW1lbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gW2hhbmRsZXJdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjYXB0dXJlXVxuICogQHBhcmFtIHtib29sZWFufSBbcGFzc2l2ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlKSB7XG5cdHZhciBvcHRpb25zID0geyBjYXB0dXJlLCBwYXNzaXZlIH07XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdGlmIChcblx0XHRkb20gPT09IGRvY3VtZW50LmJvZHkgfHxcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZG9tID09PSB3aW5kb3cgfHxcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZG9tID09PSBkb2N1bWVudCB8fFxuXHRcdC8vIEZpcmVmb3ggaGFzIHF1aXJreSBiZWhhdmlvciwgaXQgY2FuIGhhcHBlbiB0aGF0IHdlIHN0aWxsIGdldCBcImNhbnBsYXlcIiBldmVudHMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHJlbW92ZWRcblx0XHRkb20gaW5zdGFuY2VvZiBIVE1MTWVkaWFFbGVtZW50XG5cdCkge1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGVnYXRlKGV2ZW50cykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGFsbF9yZWdpc3RlcmVkX2V2ZW50cy5hZGQoZXZlbnRzW2ldKTtcblx0fVxuXG5cdGZvciAodmFyIGZuIG9mIHJvb3RfZXZlbnRfaGFuZGxlcykge1xuXHRcdGZuKGV2ZW50cyk7XG5cdH1cbn1cblxuLy8gdXNlZCB0byBzdG9yZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgcHJvcGFnYXRlZCBldmVudFxuLy8gdG8gcHJldmVudCBnYXJiYWdlIGNvbGxlY3Rpb24gYmV0d2VlbiBtaWNyb3Rhc2tzIGluIEZpcmVmb3hcbi8vIElmIHRoZSBldmVudCBvYmplY3QgaXMgR0NlZCB0b28gZWFybHksIHRoZSBleHBhbmRvIF9fcm9vdCBwcm9wZXJ0eVxuLy8gc2V0IG9uIHRoZSBldmVudCBvYmplY3QgaXMgbG9zdCwgY2F1c2luZyB0aGUgZXZlbnQgZGVsZWdhdGlvblxuLy8gdG8gcHJvY2VzcyB0aGUgZXZlbnQgdHdpY2VcbmxldCBsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPSBudWxsO1xuXG4vKipcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbihldmVudCkge1xuXHR2YXIgaGFuZGxlcl9lbGVtZW50ID0gdGhpcztcblx0dmFyIG93bmVyX2RvY3VtZW50ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoaGFuZGxlcl9lbGVtZW50KS5vd25lckRvY3VtZW50O1xuXHR2YXIgZXZlbnRfbmFtZSA9IGV2ZW50LnR5cGU7XG5cdHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoPy4oKSB8fCBbXTtcblx0dmFyIGN1cnJlbnRfdGFyZ2V0ID0gLyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi8gKHBhdGhbMF0gfHwgZXZlbnQudGFyZ2V0KTtcblxuXHRsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPSBldmVudDtcblxuXHQvLyBjb21wb3NlZFBhdGggY29udGFpbnMgbGlzdCBvZiBub2RlcyB0aGUgZXZlbnQgaGFzIHByb3BhZ2F0ZWQgdGhyb3VnaC5cblx0Ly8gV2UgY2hlY2sgX19yb290IHRvIHNraXAgYWxsIG5vZGVzIGJlbG93IGl0IGluIGNhc2UgdGhpcyBpcyBhXG5cdC8vIHBhcmVudCBvZiB0aGUgX19yb290IG5vZGUsIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZXJlJ3MgbmVzdGVkXG5cdC8vIG1vdW50ZWQgYXBwcy4gSW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudHMgbXVsdGlwbGUgdGltZXMuXG5cdHZhciBwYXRoX2lkeCA9IDA7XG5cblx0Ly8gdGhlIGBsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPT09IGV2ZW50YCBjaGVjayBpcyByZWR1bmRhbnQsIGJ1dFxuXHQvLyB3aXRob3V0IGl0IHRoZSB2YXJpYWJsZSB3aWxsIGJlIERDRSdkIGFuZCB0aGluZ3Mgd2lsbFxuXHQvLyBmYWlsIG15c3RlcmlvdXNseSBpbiBGaXJlZm94XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgaXMgYWRkZWQgYmVsb3dcblx0dmFyIGhhbmRsZWRfYXQgPSBsYXN0X3Byb3BhZ2F0ZWRfZXZlbnQgPT09IGV2ZW50ICYmIGV2ZW50Ll9fcm9vdDtcblxuXHRpZiAoaGFuZGxlZF9hdCkge1xuXHRcdHZhciBhdF9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlZF9hdCk7XG5cdFx0aWYgKFxuXHRcdFx0YXRfaWR4ICE9PSAtMSAmJlxuXHRcdFx0KGhhbmRsZXJfZWxlbWVudCA9PT0gZG9jdW1lbnQgfHwgaGFuZGxlcl9lbGVtZW50ID09PSAvKiogQHR5cGUge2FueX0gKi8gKHdpbmRvdykpXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBvciBhIHdpbmRvdyBsaXN0ZW5lciwgYnV0IHRoZSBldmVudCB3YXMgYWxyZWFkeSBoYW5kbGVkXG5cdFx0XHQvLyAtPiBpZ25vcmUsIGJ1dCBzZXQgaGFuZGxlX2F0IHRvIGRvY3VtZW50L3dpbmRvdyBzbyB0aGF0IHdlJ3JlIHJlc2V0dGluZyB0aGUgZXZlbnRcblx0XHRcdC8vIGNoYWluIGluIGNhc2Ugc29tZW9uZSBtYW51YWxseSBkaXNwYXRjaGVzIHRoZSBzYW1lIGV2ZW50IG9iamVjdCBhZ2Fpbi5cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHNraXBwaW5nIGlmIHRoZSBpbmRleCBpcyBoaWdoZXIsIGJlY2F1c2Vcblx0XHQvLyBzb21lb25lIGNvdWxkIGNyZWF0ZSBhbiBldmVudCBwcm9ncmFtbWF0aWNhbGx5IGFuZCBlbWl0IGl0IG11bHRpcGxlIHRpbWVzLFxuXHRcdC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgdGhlIHdob2xlIHByb3BhZ2F0aW9uIGNoYWluIHByb3Blcmx5IGVhY2ggdGltZS5cblx0XHQvLyAodGhpcyB3aWxsIG9ubHkgYmUgYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtdWx0aXBsZSB0aW1lcyBhbmRcblx0XHQvLyB0aGUgZmFsbGJhY2sgZG9jdW1lbnQgbGlzdGVuZXIgaXNuJ3QgcmVhY2hlZCBpbiBiZXR3ZWVuLCBidXQgdGhhdCdzIHN1cGVyIHJhcmUpXG5cdFx0dmFyIGhhbmRsZXJfaWR4ID0gcGF0aC5pbmRleE9mKGhhbmRsZXJfZWxlbWVudCk7XG5cdFx0aWYgKGhhbmRsZXJfaWR4ID09PSAtMSkge1xuXHRcdFx0Ly8gaGFuZGxlX2lkeCBjYW4gdGhlb3JldGljYWxseSBiZSAtMSAoaGFwcGVuZWQgaW4gc29tZSBKU0RPTSB0ZXN0aW5nIHNjZW5hcmlvcyB3aXRoIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgb2JqZWN0KVxuXHRcdFx0Ly8gc28gZ3VhcmQgYWdhaW5zdCB0aGF0LCB0b28sIGFuZCBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIHdhcyBoYW5kbGVkIGF0IHRoaXMgcG9pbnQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGF0X2lkeCA8PSBoYW5kbGVyX2lkeCkge1xuXHRcdFx0cGF0aF9pZHggPSBhdF9pZHg7XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChwYXRoW3BhdGhfaWR4XSB8fCBldmVudC50YXJnZXQpO1xuXHQvLyB0aGVyZSBjYW4gb25seSBiZSBvbmUgZGVsZWdhdGVkIGV2ZW50IHBlciBlbGVtZW50LCBhbmQgd2UgZWl0aGVyIGFscmVhZHkgaGFuZGxlZCB0aGUgY3VycmVudCB0YXJnZXQsXG5cdC8vIG9yIHRoaXMgaXMgdGhlIHZlcnkgZmlyc3QgdGFyZ2V0IGluIHRoZSBjaGFpbiB3aGljaCBoYXMgYSBub24tZGVsZWdhdGVkIGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGl0J3Mgc2FmZVxuXHQvLyB0byBoYW5kbGUgYSBwb3NzaWJsZSBkZWxlZ2F0ZWQgZXZlbnQgb24gaXQgbGF0ZXIgKHRocm91Z2ggdGhlIHJvb3QgZGVsZWdhdGlvbiBsaXN0ZW5lciBmb3IgZXhhbXBsZSkuXG5cdGlmIChjdXJyZW50X3RhcmdldCA9PT0gaGFuZGxlcl9lbGVtZW50KSByZXR1cm47XG5cblx0Ly8gUHJveHkgY3VycmVudFRhcmdldCB0byBjb3JyZWN0IHRhcmdldFxuXHRkZWZpbmVfcHJvcGVydHkoZXZlbnQsICdjdXJyZW50VGFyZ2V0Jywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudF90YXJnZXQgfHwgb3duZXJfZG9jdW1lbnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGlzIHN0YXJ0ZWQgYmVjYXVzZSBvZiBDaHJvbWl1bSBpc3N1ZSBodHRwczovL2Nocm9tZXN0YXR1cy5jb20vZmVhdHVyZS81MTI4Njk2ODIzNTQ1ODU2LFxuXHQvLyB3aGVyZSByZW1vdmFsIG9yIG1vdmluZyBvZiBvZiB0aGUgRE9NIGNhbiBjYXVzZSBzeW5jIGBibHVyYCBldmVudHMgdG8gZmlyZSwgd2hpY2ggY2FuIGNhdXNlIGxvZ2ljXG5cdC8vIHRvIHJ1biBpbnNpZGUgdGhlIGN1cnJlbnQgYGFjdGl2ZV9yZWFjdGlvbmAsIHdoaWNoIGlzbid0IHdoYXQgd2Ugd2FudCBhdCBhbGwuIEhvd2V2ZXIsIG9uIHJlZmxlY3Rpb24sXG5cdC8vIGl0J3MgcHJvYmFibHkgYmVzdCB0aGF0IGFsbCBldmVudCBoYW5kbGVkIGJ5IFN2ZWx0ZSBoYXZlIHRoaXMgYmVoYXZpb3VyLCBhcyB3ZSBkb24ndCByZWFsbHkgd2FudFxuXHQvLyBhbiBldmVudCBoYW5kbGVyIHRvIHJ1biBpbiB0aGUgY29udGV4dCBvZiBhbm90aGVyIHJlYWN0aW9uIG9yIGVmZmVjdC5cblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cblx0dHJ5IHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bn1cblx0XHQgKi9cblx0XHR2YXIgdGhyb3dfZXJyb3I7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3Vua25vd25bXX1cblx0XHQgKi9cblx0XHR2YXIgb3RoZXJfZXJyb3JzID0gW107XG5cblx0XHR3aGlsZSAoY3VycmVudF90YXJnZXQgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdFx0XHR2YXIgcGFyZW50X2VsZW1lbnQgPVxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5hc3NpZ25lZFNsb3QgfHxcblx0XHRcdFx0Y3VycmVudF90YXJnZXQucGFyZW50Tm9kZSB8fFxuXHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5ob3N0IHx8XG5cdFx0XHRcdG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0dmFyIGRlbGVnYXRlZCA9IGN1cnJlbnRfdGFyZ2V0WydfXycgKyBldmVudF9uYW1lXTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZGVsZWdhdGVkICE9IG51bGwgJiZcblx0XHRcdFx0XHQoISgvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5kaXNhYmxlZCkgfHxcblx0XHRcdFx0XHRcdC8vIERPTSBjb3VsZCd2ZSBiZWVuIHVwZGF0ZWQgYWxyZWFkeSBieSB0aGUgdGltZSB0aGlzIGlzIHJlYWNoZWQsIHNvIHdlIGNoZWNrIHRoaXMgYXMgd2VsbFxuXHRcdFx0XHRcdFx0Ly8gLT4gdGhlIHRhcmdldCBjb3VsZCBub3QgaGF2ZSBiZWVuIGRpc2FibGVkIGJlY2F1c2UgaXQgZW1pdHMgdGhlIGV2ZW50IGluIHRoZSBmaXJzdCBwbGFjZVxuXHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID09PSBjdXJyZW50X3RhcmdldClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGVsZWdhdGVkLmNhbGwoY3VycmVudF90YXJnZXQsIGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKHRocm93X2Vycm9yKSB7XG5cdFx0XHRcdFx0b3RoZXJfZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93X2Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChldmVudC5jYW5jZWxCdWJibGUgfHwgcGFyZW50X2VsZW1lbnQgPT09IGhhbmRsZXJfZWxlbWVudCB8fCBwYXJlbnRfZWxlbWVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGN1cnJlbnRfdGFyZ2V0ID0gcGFyZW50X2VsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRocm93X2Vycm9yKSB7XG5cdFx0XHRmb3IgKGxldCBlcnJvciBvZiBvdGhlcl9lcnJvcnMpIHtcblx0XHRcdFx0Ly8gVGhyb3cgdGhlIHJlc3Qgb2YgdGhlIGVycm9ycywgb25lLWJ5LW9uZSBvbiBhIG1pY3JvdGFza1xuXHRcdFx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgdGhyb3dfZXJyb3I7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgaXMgdXNlZCBhYm92ZVxuXHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHQvLyBAdHMtaWdub3JlIHJlbW92ZSBwcm94eSBvbiBjdXJyZW50VGFyZ2V0XG5cdFx0ZGVsZXRlIGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIEluIGRldiwgd2FybiBpZiBhbiBldmVudCBoYW5kbGVyIGlzIG5vdCBhIGZ1bmN0aW9uLCBhcyBpdCBtZWFucyB0aGVcbiAqIHVzZXIgcHJvYmFibHkgY2FsbGVkIHRoZSBoYW5kbGVyIG9yIGZvcmdvdCB0byBhZGQgYSBgKCkgPT5gXG4gKiBAcGFyYW0geygpID0+IChldmVudDogRXZlbnQsIC4uLmFyZ3M6IGFueSkgPT4gdm9pZH0gdGh1bmtcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7W0V2ZW50LCAuLi5hbnldfSBhcmdzXG4gKiBAcGFyYW0ge2FueX0gY29tcG9uZW50XG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IFtsb2NdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfcGFyZW5zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkoXG5cdHRodW5rLFxuXHRlbGVtZW50LFxuXHRhcmdzLFxuXHRjb21wb25lbnQsXG5cdGxvYyxcblx0aGFzX3NpZGVfZWZmZWN0cyA9IGZhbHNlLFxuXHRyZW1vdmVfcGFyZW5zID0gZmFsc2Vcbikge1xuXHRsZXQgaGFuZGxlcjtcblx0bGV0IGVycm9yO1xuXG5cdHRyeSB7XG5cdFx0aGFuZGxlciA9IHRodW5rKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRlcnJvciA9IGU7XG5cdH1cblxuXHRpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicgJiYgKGhhc19zaWRlX2VmZmVjdHMgfHwgaGFuZGxlciAhPSBudWxsIHx8IGVycm9yKSkge1xuXHRcdGNvbnN0IGZpbGVuYW1lID0gY29tcG9uZW50Py5bRklMRU5BTUVdO1xuXHRcdGNvbnN0IGxvY2F0aW9uID0gbG9jID8gYCBhdCAke2ZpbGVuYW1lfToke2xvY1swXX06JHtsb2NbMV19YCA6IGAgaW4gJHtmaWxlbmFtZX1gO1xuXHRcdGNvbnN0IHBoYXNlID0gYXJnc1swXT8uZXZlbnRQaGFzZSA8IEV2ZW50LkJVQkJMSU5HX1BIQVNFID8gJ2NhcHR1cmUnIDogJyc7XG5cdFx0Y29uc3QgZXZlbnRfbmFtZSA9IGFyZ3NbMF0/LnR5cGUgKyBwaGFzZTtcblx0XHRjb25zdCBkZXNjcmlwdGlvbiA9IGBcXGAke2V2ZW50X25hbWV9XFxgIGhhbmRsZXIke2xvY2F0aW9ufWA7XG5cdFx0Y29uc3Qgc3VnZ2VzdGlvbiA9IHJlbW92ZV9wYXJlbnMgPyAncmVtb3ZlIHRoZSB0cmFpbGluZyBgKClgJyA6ICdhZGQgYSBsZWFkaW5nIGAoKSA9PmAnO1xuXG5cdFx0dy5ldmVudF9oYW5kbGVyX2ludmFsaWQoZGVzY3JpcHRpb24sIHN1Z2dlc3Rpb24pO1xuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0aGFuZGxlcj8uYXBwbHkoZWxlbWVudCwgYXJncyk7XG59XG4iLCIvKiogQHBhcmFtIHtzdHJpbmd9IGh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpIHtcblx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRlbGVtLmlubmVySFRNTCA9IGh0bWwucmVwbGFjZUFsbCgnPCE+JywgJzwhLS0tLT4nKTsgLy8gWEhUTUwgY29tcGxpYW5jZVxuXHRyZXR1cm4gZWxlbS5jb250ZW50O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IFRlbXBsYXRlU3RydWN0dXJlIH0gZnJvbSAnLi90eXBlcycgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQge1xuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRpc19maXJlZm94LFxuXHRjcmVhdGVfZWxlbWVudCxcblx0Y3JlYXRlX2ZyYWdtZW50LFxuXHRjcmVhdGVfY29tbWVudCxcblx0c2V0X2F0dHJpYnV0ZVxufSBmcm9tICcuL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQge1xuXHROQU1FU1BBQ0VfTUFUSE1MLFxuXHROQU1FU1BBQ0VfU1ZHLFxuXHRURU1QTEFURV9GUkFHTUVOVCxcblx0VEVNUExBVEVfVVNFX0lNUE9SVF9OT0RFLFxuXHRURU1QTEFURV9VU0VfTUFUSE1MLFxuXHRURU1QTEFURV9VU0VfU1ZHXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBDT01NRU5UX05PREUsIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUsIFRFWFRfTk9ERSB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gc3RhcnRcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gZW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCkge1xuXHR2YXIgZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblx0aWYgKGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCkge1xuXHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IHN0YXJ0O1xuXHRcdGVmZmVjdC5ub2Rlc19lbmQgPSBlbmQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcmV0dXJucyB7KCkgPT4gTm9kZSB8IE5vZGVbXX1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZnJvbV9odG1sKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHVzZV9pbXBvcnRfbm9kZSA9IChmbGFncyAmIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHtOb2RlfSAqL1xuXHR2YXIgbm9kZTtcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChoYXNfc3RhcnQgPyBjb250ZW50IDogJzwhPicgKyBjb250ZW50KTtcblx0XHRcdGlmICghaXNfZnJhZ21lbnQpIG5vZGUgPSAvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHR1c2VfaW1wb3J0X25vZGUgfHwgaXNfZmlyZWZveCA/IGRvY3VtZW50LmltcG9ydE5vZGUobm9kZSwgdHJ1ZSkgOiBub2RlLmNsb25lTm9kZSh0cnVlKVxuXHRcdCk7XG5cblx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdHZhciBzdGFydCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGNsb25lKSk7XG5cdFx0XHR2YXIgZW5kID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjbG9uZS5sYXN0Q2hpbGQpO1xuXG5cdFx0XHRhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhjbG9uZSwgY2xvbmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geydzdmcnIHwgJ21hdGgnfSBuc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gZnJvbV9uYW1lc3BhY2UoY29udGVudCwgZmxhZ3MsIG5zID0gJ3N2ZycpIHtcblx0LyoqXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBmaXJzdCBpdGVtIGlzIGEgdGV4dC9lbGVtZW50IG5vZGUuIElmIG5vdCwgd2UgbmVlZCB0b1xuXHQgKiBjcmVhdGUgYW4gYWRkaXRpb25hbCBjb21tZW50IG5vZGUgdG8gYWN0IGFzIGBlZmZlY3Qubm9kZXMuc3RhcnRgXG5cdCAqL1xuXHR2YXIgaGFzX3N0YXJ0ID0gIWNvbnRlbnQuc3RhcnRzV2l0aCgnPCE+Jyk7XG5cblx0dmFyIGlzX2ZyYWdtZW50ID0gKGZsYWdzICYgVEVNUExBVEVfRlJBR01FTlQpICE9PSAwO1xuXHR2YXIgd3JhcHBlZCA9IGA8JHtuc30+JHtoYXNfc3RhcnQgPyBjb250ZW50IDogJzwhPicgKyBjb250ZW50fTwvJHtuc30+YDtcblxuXHQvKiogQHR5cGUge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSAqL1xuXHR2YXIgbm9kZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9IC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi8gKGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwod3JhcHBlZCkpO1xuXHRcdFx0dmFyIHJvb3QgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoZnJhZ21lbnQpKTtcblxuXHRcdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHRcdG5vZGUgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdHdoaWxlIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpIHtcblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChyb290KSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2xvbmUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5vZGUuY2xvbmVOb2RlKHRydWUpKTtcblxuXHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQoY2xvbmUpKTtcblx0XHRcdHZhciBlbmQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGNsb25lLmxhc3RDaGlsZCk7XG5cblx0XHRcdGFzc2lnbl9ub2RlcyhzdGFydCwgZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXNzaWduX25vZGVzKGNsb25lLCBjbG9uZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZnJvbV9zdmcoY29udGVudCwgZmxhZ3MpIHtcblx0cmV0dXJuIGZyb21fbmFtZXNwYWNlKGNvbnRlbnQsIGZsYWdzLCAnc3ZnJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tX21hdGhtbChjb250ZW50LCBmbGFncykge1xuXHRyZXR1cm4gZnJvbV9uYW1lc3BhY2UoY29udGVudCwgZmxhZ3MsICdtYXRoJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZVN0cnVjdHVyZVtdfSBzdHJ1Y3R1cmVcbiAqIEBwYXJhbSB7dHlwZW9mIE5BTUVTUEFDRV9TVkcgfCB0eXBlb2YgTkFNRVNQQUNFX01BVEhNTCB8IHVuZGVmaW5lZH0gW25zXVxuICovXG5mdW5jdGlvbiBmcmFnbWVudF9mcm9tX3RyZWUoc3RydWN0dXJlLCBucykge1xuXHR2YXIgZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQoKTtcblxuXHRmb3IgKHZhciBpdGVtIG9mIHN0cnVjdHVyZSkge1xuXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZChjcmVhdGVfdGV4dChpdGVtKSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBpZiBgcHJlc2VydmVDb21tZW50cyA9PT0gdHJ1ZWAsIGNvbW1lbnRzIGFyZSByZXByZXNlbnRlZCBhcyBgWycvLyA8ZGF0YT4nXWBcblx0XHRpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW1bMF1bMF0gPT09ICcvJykge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kKGNyZWF0ZV9jb21tZW50KGl0ZW0gPyBpdGVtWzBdLnNsaWNlKDMpIDogJycpKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnN0IFtuYW1lLCBhdHRyaWJ1dGVzLCAuLi5jaGlsZHJlbl0gPSBpdGVtO1xuXG5cdFx0Y29uc3QgbmFtZXNwYWNlID0gbmFtZSA9PT0gJ3N2ZycgPyBOQU1FU1BBQ0VfU1ZHIDogbmFtZSA9PT0gJ21hdGgnID8gTkFNRVNQQUNFX01BVEhNTCA6IG5zO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBjcmVhdGVfZWxlbWVudChuYW1lLCBuYW1lc3BhY2UsIGF0dHJpYnV0ZXM/LmlzKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRzZXRfYXR0cmlidXRlKGVsZW1lbnQsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0XHR9XG5cblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIHRhcmdldCA9XG5cdFx0XHRcdGVsZW1lbnQudGFnTmFtZSA9PT0gJ1RFTVBMQVRFJ1xuXHRcdFx0XHRcdD8gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyAoZWxlbWVudCkuY29udGVudFxuXHRcdFx0XHRcdDogZWxlbWVudDtcblxuXHRcdFx0dGFyZ2V0LmFwcGVuZChcblx0XHRcdFx0ZnJhZ21lbnRfZnJvbV90cmVlKGNoaWxkcmVuLCBlbGVtZW50LnRhZ05hbWUgPT09ICdmb3JlaWduT2JqZWN0JyA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0ZnJhZ21lbnQuYXBwZW5kKGVsZW1lbnQpO1xuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVTdHJ1Y3R1cmVbXX0gc3RydWN0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tX3RyZWUoc3RydWN0dXJlLCBmbGFncykge1xuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB1c2VfaW1wb3J0X25vZGUgPSAoZmxhZ3MgJiBURU1QTEFURV9VU0VfSU1QT1JUX05PREUpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7Tm9kZX0gKi9cblx0dmFyIG5vZGU7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc3QgbnMgPVxuXHRcdFx0XHQoZmxhZ3MgJiBURU1QTEFURV9VU0VfU1ZHKSAhPT0gMFxuXHRcdFx0XHRcdD8gTkFNRVNQQUNFX1NWR1xuXHRcdFx0XHRcdDogKGZsYWdzICYgVEVNUExBVEVfVVNFX01BVEhNTCkgIT09IDBcblx0XHRcdFx0XHRcdD8gTkFNRVNQQUNFX01BVEhNTFxuXHRcdFx0XHRcdFx0OiB1bmRlZmluZWQ7XG5cblx0XHRcdG5vZGUgPSBmcmFnbWVudF9mcm9tX3RyZWUoc3RydWN0dXJlLCBucyk7XG5cdFx0XHRpZiAoIWlzX2ZyYWdtZW50KSBub2RlID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKTtcblx0XHR9XG5cblx0XHR2YXIgY2xvbmUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKFxuXHRcdFx0dXNlX2ltcG9ydF9ub2RlIHx8IGlzX2ZpcmVmb3ggPyBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpIDogbm9kZS5jbG9uZU5vZGUodHJ1ZSlcblx0XHQpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhfc2NyaXB0KGZuKSB7XG5cdHJldHVybiAoKSA9PiBydW5fc2NyaXB0cyhmbigpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGluZyBhIGRvY3VtZW50IGZyYWdtZW50IGZyb20gSFRNTCB0aGF0IGNvbnRhaW5zIHNjcmlwdCB0YWdzIHdpbGwgbm90IGV4ZWN1dGVcbiAqIHRoZSBzY3JpcHRzLiBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHNjcmlwdCB0YWdzIHdpdGggbmV3IG9uZXMgc28gdGhhdCB0aGV5IGFyZSBleGVjdXRlZC5cbiAqIEBwYXJhbSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlIHwgTm9kZVtdfVxuICovXG5mdW5jdGlvbiBydW5fc2NyaXB0cyhub2RlKSB7XG5cdC8vIHNjcmlwdHMgd2VyZSBTU1InZCwgaW4gd2hpY2ggY2FzZSB0aGV5IHdpbGwgcnVuXG5cdGlmIChoeWRyYXRpbmcpIHJldHVybiBub2RlO1xuXG5cdGNvbnN0IGlzX2ZyYWdtZW50ID0gbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcblx0Y29uc3Qgc2NyaXB0cyA9XG5cdFx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLnRhZ05hbWUgPT09ICdTQ1JJUFQnXG5cdFx0XHQ/IFsvKiogQHR5cGUge0hUTUxTY3JpcHRFbGVtZW50fSAqLyAobm9kZSldXG5cdFx0XHQ6IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0Jyk7XG5cdGNvbnN0IGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0Zm9yIChjb25zdCBzY3JpcHQgb2Ygc2NyaXB0cykge1xuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0Zm9yICh2YXIgYXR0cmlidXRlIG9mIHNjcmlwdC5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRjbG9uZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUudGV4dENvbnRlbnQgPSBzY3JpcHQudGV4dENvbnRlbnQ7XG5cblx0XHQvLyBUaGUgc2NyaXB0IGhhcyBjaGFuZ2VkIC0gaWYgaXQncyBhdCB0aGUgZWRnZXMsIHRoZSBlZmZlY3Qgbm93IHBvaW50cyBhdCBkZWFkIG5vZGVzXG5cdFx0aWYgKGlzX2ZyYWdtZW50ID8gbm9kZS5maXJzdENoaWxkID09PSBzY3JpcHQgOiBub2RlID09PSBzY3JpcHQpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IGNsb25lO1xuXHRcdH1cblx0XHRpZiAoaXNfZnJhZ21lbnQgPyBub2RlLmxhc3RDaGlsZCA9PT0gc2NyaXB0IDogbm9kZSA9PT0gc2NyaXB0KSB7XG5cdFx0XHRlZmZlY3Qubm9kZXNfZW5kID0gY2xvbmU7XG5cdFx0fVxuXG5cdFx0c2NyaXB0LnJlcGxhY2VXaXRoKGNsb25lKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQodmFsdWUgPSAnJykge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHZhciB0ID0gY3JlYXRlX3RleHQodmFsdWUgKyAnJyk7XG5cdFx0YXNzaWduX25vZGVzKHQsIHQpO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0aWYgKG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuXHRcdC8vIGlmIGFuIHtleHByZXNzaW9ufSBpcyBlbXB0eSBkdXJpbmcgU1NSLCB3ZSBuZWVkIHRvIGluc2VydCBhbiBlbXB0eSB0ZXh0IG5vZGVcblx0XHRub2RlLmJlZm9yZSgobm9kZSA9IGNyZWF0ZV90ZXh0KCkpKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKG5vZGUpO1xuXHR9XG5cblx0YXNzaWduX25vZGVzKG5vZGUsIG5vZGUpO1xuXHRyZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7VGVtcGxhdGVOb2RlIHwgRG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG5cdC8vIHdlJ3JlIG5vdCBkZWxlZ2F0aW5nIHRvIGB0ZW1wbGF0ZWAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0fVxuXG5cdHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHR2YXIgc3RhcnQgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKTtcblx0dmFyIGFuY2hvciA9IGNyZWF0ZV90ZXh0KCk7XG5cdGZyYWcuYXBwZW5kKHN0YXJ0LCBhbmNob3IpO1xuXG5cdGFzc2lnbl9ub2RlcyhzdGFydCwgYW5jaG9yKTtcblxuXHRyZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBBc3NpZ24gdGhlIGNyZWF0ZWQgKG9yIGluIGh5ZHJhdGlvbiBtb2RlLCB0cmF2ZXJzZWQpIGRvbSBlbGVtZW50cyB0byB0aGUgY3VycmVudCBibG9ja1xuICogYW5kIGluc2VydCB0aGUgZWxlbWVudHMgaW50byB0aGUgZG9tIChpbiBjbGllbnQgbW9kZSkuXG4gKiBAcGFyYW0ge1RleHQgfCBDb21tZW50IHwgRWxlbWVudH0gYW5jaG9yXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBFbGVtZW50fSBkb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZChhbmNob3IsIGRvbSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGFuY2hvciA9PT0gbnVsbCkge1xuXHRcdC8vIGVkZ2UgY2FzZSDigJQgdm9pZCBgPHN2ZWx0ZTplbGVtZW50PmAgd2l0aCBjb250ZW50XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YW5jaG9yLmJlZm9yZSgvKiogQHR5cGUge05vZGV9ICovIChkb20pKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgKG9yIGh5ZHJhdGUpIGFuIHVuaXF1ZSBVSUQgZm9yIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pZCgpIHtcblx0aWYgKFxuXHRcdGh5ZHJhdGluZyAmJlxuXHRcdGh5ZHJhdGVfbm9kZSAmJlxuXHRcdGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmXG5cdFx0aHlkcmF0ZV9ub2RlLnRleHRDb250ZW50Py5zdGFydHNXaXRoKGAkYClcblx0KSB7XG5cdFx0Y29uc3QgaWQgPSBoeWRyYXRlX25vZGUudGV4dENvbnRlbnQuc3Vic3RyaW5nKDEpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybiBpZDtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyB3YXkgd2UgZW5zdXJlIHRoZSBpZCBpcyB1bmlxdWUgZXZlbiBhY3Jvc3MgU3ZlbHRlIHJ1bnRpbWVzXG5cdCh3aW5kb3cuX19zdmVsdGUgPz89IHt9KS51aWQgPz89IDE7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gYGMke3dpbmRvdy5fX3N2ZWx0ZS51aWQrK31gO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50VHlwZSwgU3ZlbHRlQ29tcG9uZW50LCBNb3VudE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbmRleC5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nLFxuXHRpbml0X29wZXJhdGlvbnNcbn0gZnJvbSAnLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fRU5ELCBIWURSQVRJT05fRVJST1IsIEhZRFJBVElPTl9TVEFSVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHB1c2gsIHBvcCwgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X3Jvb3QgfSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSwgc2V0X2h5ZHJhdGluZyB9IGZyb20gJy4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGFsbF9yZWdpc3RlcmVkX2V2ZW50cyxcblx0aGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uLFxuXHRyb290X2V2ZW50X2hhbmRsZXNcbn0gZnJvbSAnLi9kb20vZWxlbWVudHMvZXZlbnRzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4vZG9tL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGlzX3Bhc3NpdmVfZXZlbnQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBDT01NRU5UX05PREUsIFNUQVRFX1NZTUJPTCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJvdW5kYXJ5IH0gZnJvbSAnLi9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIG5vcm1hbGx5IHRydWUg4oCUIGJsb2NrIGVmZmVjdHMgc2hvdWxkIHJ1biB0aGVpciBpbnRybyB0cmFuc2l0aW9ucyDigJRcbiAqIGJ1dCBpcyBmYWxzZSBkdXJpbmcgaHlkcmF0aW9uICh1bmxlc3MgYG9wdGlvbnMuaW50cm9gIGlzIGB0cnVlYCkgYW5kXG4gKiB3aGVuIGNyZWF0aW5nIHRoZSBjaGlsZHJlbiBvZiBhIGA8c3ZlbHRlOmVsZW1lbnQ+YCB0aGF0IGp1c3QgY2hhbmdlZCB0YWdcbiAqL1xuZXhwb3J0IGxldCBzaG91bGRfaW50cm8gPSB0cnVlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zaG91bGRfaW50cm8odmFsdWUpIHtcblx0c2hvdWxkX2ludHJvID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3RleHQodGV4dCwgdmFsdWUpIHtcblx0Ly8gRm9yIG9iamVjdHMsIHdlIGFwcGx5IHN0cmluZyBjb2VyY2lvbiAod2hpY2ggbWlnaHQgbWFrZSB0aGluZ3MgbGlrZSAkc3RhdGUgYXJyYXkgcmVmZXJlbmNlcyBpbiB0aGUgdGVtcGxhdGUgcmVhY3RpdmUpIGJlZm9yZSBkaWZmaW5nXG5cdHZhciBzdHIgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgKyAnJyA6IHZhbHVlO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlmIChzdHIgIT09ICh0ZXh0Ll9fdCA/Pz0gdGV4dC5ub2RlVmFsdWUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHQuX190ID0gc3RyO1xuXHRcdHRleHQubm9kZVZhbHVlID0gc3RyICsgJyc7XG5cdH1cbn1cblxuLyoqXG4gKiBNb3VudHMgYSBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHRhcmdldCBhbmQgcmV0dXJucyB0aGUgZXhwb3J0cyBhbmQgcG90ZW50aWFsbHkgdGhlIHByb3BzIChpZiBjb21waWxlZCB3aXRoIGBhY2Nlc3NvcnM6IHRydWVgKSBvZiB0aGUgY29tcG9uZW50LlxuICogVHJhbnNpdGlvbnMgd2lsbCBwbGF5IGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIgdW5sZXNzIHRoZSBgaW50cm9gIG9wdGlvbiBpcyBzZXQgdG8gYGZhbHNlYC5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEBwYXJhbSB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHM+PiB8IENvbXBvbmVudDxQcm9wcywgRXhwb3J0cywgYW55Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge01vdW50T3B0aW9uczxQcm9wcz59IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFeHBvcnRzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbW91bnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdHJldHVybiBfbW91bnQoY29tcG9uZW50LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBIeWRyYXRlcyBhIGNvbXBvbmVudCBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCByZXR1cm5zIHRoZSBleHBvcnRzIGFuZCBwb3RlbnRpYWxseSB0aGUgcHJvcHMgKGlmIGNvbXBpbGVkIHdpdGggYGFjY2Vzc29yczogdHJ1ZWApIG9mIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEBwYXJhbSB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHM+PiB8IENvbXBvbmVudDxQcm9wcywgRXhwb3J0cywgYW55Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge3t9IGV4dGVuZHMgUHJvcHMgPyB7XG4gKiBcdFx0dGFyZ2V0OiBEb2N1bWVudCB8IEVsZW1lbnQgfCBTaGFkb3dSb290O1xuICogXHRcdHByb3BzPzogUHJvcHM7XG4gKiBcdFx0ZXZlbnRzPzogUmVjb3JkPHN0cmluZywgKGU6IGFueSkgPT4gYW55PjtcbiAqICBcdGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+O1xuICogXHRcdGludHJvPzogYm9vbGVhbjtcbiAqIFx0XHRyZWNvdmVyPzogYm9vbGVhbjtcbiAqIFx0fSA6IHtcbiAqIFx0XHR0YXJnZXQ6IERvY3VtZW50IHwgRWxlbWVudCB8IFNoYWRvd1Jvb3Q7XG4gKiBcdFx0cHJvcHM6IFByb3BzO1xuICogXHRcdGV2ZW50cz86IFJlY29yZDxzdHJpbmcsIChlOiBhbnkpID0+IGFueT47XG4gKiAgXHRjb250ZXh0PzogTWFwPGFueSwgYW55PjtcbiAqIFx0XHRpbnRybz86IGJvb2xlYW47XG4gKiBcdFx0cmVjb3Zlcj86IGJvb2xlYW47XG4gKiBcdH19IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFeHBvcnRzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZShjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0aW5pdF9vcGVyYXRpb25zKCk7XG5cdG9wdGlvbnMuaW50cm8gPSBvcHRpb25zLmludHJvID8/IGZhbHNlO1xuXHRjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcblx0Y29uc3Qgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblx0Y29uc3QgcHJldmlvdXNfaHlkcmF0ZV9ub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHRhcmdldCkpO1xuXHRcdHdoaWxlIChcblx0XHRcdGFuY2hvciAmJlxuXHRcdFx0KGFuY2hvci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFIHx8IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGFuY2hvcikuZGF0YSAhPT0gSFlEUkFUSU9OX1NUQVJUKVxuXHRcdCkge1xuXHRcdFx0YW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKGFuY2hvcikpO1xuXHRcdH1cblxuXHRcdGlmICghYW5jaG9yKSB7XG5cdFx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdFx0fVxuXG5cdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGFuY2hvcikpO1xuXG5cdFx0Y29uc3QgaW5zdGFuY2UgPSBfbW91bnQoY29tcG9uZW50LCB7IC4uLm9wdGlvbnMsIGFuY2hvciB9KTtcblxuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXG5cdFx0cmV0dXJuIC8qKiAgQHR5cGUge0V4cG9ydHN9ICovIChpbnN0YW5jZSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gcmUtdGhyb3cgU3ZlbHRlIGVycm9ycyAtIHRoZXkgYXJlIGNlcnRhaW5seSBub3QgcmVsYXRlZCB0byBoeWRyYXRpb25cblx0XHRpZiAoXG5cdFx0XHRlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG5cdFx0XHRlcnJvci5tZXNzYWdlLnNwbGl0KCdcXG4nKS5zb21lKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vc3ZlbHRlLmRldi9lLycpKVxuXHRcdCkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHRcdGlmIChlcnJvciAhPT0gSFlEUkFUSU9OX0VSUk9SKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gaHlkcmF0ZTogJywgZXJyb3IpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnJlY292ZXIgPT09IGZhbHNlKSB7XG5cdFx0XHRlLmh5ZHJhdGlvbl9mYWlsZWQoKTtcblx0XHR9XG5cblx0XHQvLyBJZiBhbiBlcnJvciBvY2N1cnJlZCBhYm92ZSwgdGhlIG9wZXJhdGlvbnMgbWlnaHQgbm90IHlldCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0aW5pdF9vcGVyYXRpb25zKCk7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KHRhcmdldCk7XG5cblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRyZXR1cm4gbW91bnQoY29tcG9uZW50LCBvcHRpb25zKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfaHlkcmF0aW5nKHdhc19oeWRyYXRpbmcpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUocHJldmlvdXNfaHlkcmF0ZV9ub2RlKTtcblx0fVxufVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59ICovXG5jb25zdCBkb2N1bWVudF9saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PGFueT4+IHwgQ29tcG9uZW50PGFueT59IENvbXBvbmVudFxuICogQHBhcmFtIHtNb3VudE9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFeHBvcnRzfVxuICovXG5mdW5jdGlvbiBfbW91bnQoQ29tcG9uZW50LCB7IHRhcmdldCwgYW5jaG9yLCBwcm9wcyA9IHt9LCBldmVudHMsIGNvbnRleHQsIGludHJvID0gdHJ1ZSB9KSB7XG5cdGluaXRfb3BlcmF0aW9ucygpO1xuXG5cdC8qKiBAdHlwZSB7U2V0PHN0cmluZz59ICovXG5cdHZhciByZWdpc3RlcmVkX2V2ZW50cyA9IG5ldyBTZXQoKTtcblxuXHQvKiogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHMgKi9cblx0dmFyIGV2ZW50X2hhbmRsZSA9IChldmVudHMpID0+IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGV2ZW50X25hbWUgPSBldmVudHNbaV07XG5cblx0XHRcdGlmIChyZWdpc3RlcmVkX2V2ZW50cy5oYXMoZXZlbnRfbmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0cmVnaXN0ZXJlZF9ldmVudHMuYWRkKGV2ZW50X25hbWUpO1xuXG5cdFx0XHR2YXIgcGFzc2l2ZSA9IGlzX3Bhc3NpdmVfZXZlbnQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gYm90aCB0aGUgY29udGFpbmVyIGFuZCB0aGUgZG9jdW1lbnQuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIGxpc3RlbmVyIGVuc3VyZXMgd2UgY2F0Y2ggZXZlbnRzIGZyb20gd2l0aGluIGluIGNhc2Vcblx0XHRcdC8vIHRoZSBvdXRlciBjb250ZW50IHN0b3BzIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudC5cblx0XHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbiwgeyBwYXNzaXZlIH0pO1xuXG5cdFx0XHR2YXIgbiA9IGRvY3VtZW50X2xpc3RlbmVycy5nZXQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gVGhlIGRvY3VtZW50IGxpc3RlbmVyIGVuc3VyZXMgd2UgY2F0Y2ggZXZlbnRzIHRoYXQgb3JpZ2luYXRlIGZyb20gZWxlbWVudHMgdGhhdCB3ZXJlXG5cdFx0XHRcdC8vIG1hbnVhbGx5IG1vdmVkIG91dHNpZGUgb2YgdGhlIGNvbnRhaW5lciAoZS5nLiB2aWEgbWFudWFsIHBvcnRhbHMpLlxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbiwgeyBwYXNzaXZlIH0pO1xuXHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuc2V0KGV2ZW50X25hbWUsIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCBuICsgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGV2ZW50X2hhbmRsZShhcnJheV9mcm9tKGFsbF9yZWdpc3RlcmVkX2V2ZW50cykpO1xuXHRyb290X2V2ZW50X2hhbmRsZXMuYWRkKGV2ZW50X2hhbmRsZSk7XG5cblx0LyoqIEB0eXBlIHtFeHBvcnRzfSAqL1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIHdpbGwgYmUgZGVmaW5lZCBiZWNhdXNlIHRoZSByZW5kZXIgZWZmZWN0IHJ1bnMgc3luY2hyb25vdXNseVxuXHR2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG5cdHZhciB1bm1vdW50ID0gY29tcG9uZW50X3Jvb3QoKCkgPT4ge1xuXHRcdHZhciBhbmNob3Jfbm9kZSA9IGFuY2hvciA/PyB0YXJnZXQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSk7XG5cblx0XHRib3VuZGFyeShcblx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoYW5jaG9yX25vZGUpLFxuXHRcdFx0e1xuXHRcdFx0XHRwZW5kaW5nOiAoKSA9PiB7fVxuXHRcdFx0fSxcblx0XHRcdChhbmNob3Jfbm9kZSkgPT4ge1xuXHRcdFx0XHRpZiAoY29udGV4dCkge1xuXHRcdFx0XHRcdHB1c2goe30pO1xuXHRcdFx0XHRcdHZhciBjdHggPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHR9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cdFx0XHRcdFx0Y3R4LmMgPSBjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHRcdC8vIFdlIGNhbid0IHNwcmVhZCB0aGUgb2JqZWN0IG9yIGVsc2Ugd2UnZCBsb3NlIHRoZSBzdGF0ZSBwcm94eSBzdHVmZiwgaWYgaXQgaXMgb25lXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChwcm9wcykuJCRldmVudHMgPSBldmVudHM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdFx0YXNzaWduX25vZGVzKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoYW5jaG9yX25vZGUpLCBudWxsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNob3VsZF9pbnRybyA9IGludHJvO1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBwdWJsaWMgdHlwaW5ncyBhcmUgbm90IHdoYXQgdGhlIGFjdHVhbCBmdW5jdGlvbiBsb29rcyBsaWtlXG5cdFx0XHRcdGNvbXBvbmVudCA9IENvbXBvbmVudChhbmNob3Jfbm9kZSwgcHJvcHMpIHx8IHt9O1xuXHRcdFx0XHRzaG91bGRfaW50cm8gPSB0cnVlO1xuXG5cdFx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLm5vZGVzX2VuZCA9IGh5ZHJhdGVfbm9kZTtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGh5ZHJhdGVfbm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHxcblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSAhPT0gSFlEUkFUSU9OX0VORFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHRcdFx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29udGV4dCkge1xuXHRcdFx0XHRcdHBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRmb3IgKHZhciBldmVudF9uYW1lIG9mIHJlZ2lzdGVyZWRfZXZlbnRzKSB7XG5cdFx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbik7XG5cblx0XHRcdFx0dmFyIG4gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGRvY3VtZW50X2xpc3RlbmVycy5nZXQoZXZlbnRfbmFtZSkpO1xuXG5cdFx0XHRcdGlmICgtLW4gPT09IDApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbik7XG5cdFx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLmRlbGV0ZShldmVudF9uYW1lKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuc2V0KGV2ZW50X25hbWUsIG4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJvb3RfZXZlbnRfaGFuZGxlcy5kZWxldGUoZXZlbnRfaGFuZGxlKTtcblxuXHRcdFx0aWYgKGFuY2hvcl9ub2RlICE9PSBhbmNob3IpIHtcblx0XHRcdFx0YW5jaG9yX25vZGUucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQoYW5jaG9yX25vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdG1vdW50ZWRfY29tcG9uZW50cy5zZXQoY29tcG9uZW50LCB1bm1vdW50KTtcblx0cmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2VzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgd2VyZSBtb3VudGVkIG9yIGh5ZHJhdGVkLlxuICogVXNlcyBhIGBXZWFrTWFwYCB0byBhdm9pZCBtZW1vcnkgbGVha3MuXG4gKi9cbmxldCBtb3VudGVkX2NvbXBvbmVudHMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IHRoYXQgd2FzIHByZXZpb3VzbHkgbW91bnRlZCB1c2luZyBgbW91bnRgIG9yIGBoeWRyYXRlYC5cbiAqXG4gKiBTaW5jZSA1LjEzLjAsIGlmIGBvcHRpb25zLm91dHJvYCBpcyBgdHJ1ZWAsIFt0cmFuc2l0aW9uc10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3RyYW5zaXRpb24pIHdpbGwgcGxheSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAqXG4gKiBSZXR1cm5zIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdHJhbnNpdGlvbnMgaGF2ZSBjb21wbGV0ZWQgaWYgYG9wdGlvbnMub3V0cm9gIGlzIHRydWUsIG9yIGltbWVkaWF0ZWx5IG90aGVyd2lzZSAocHJpb3IgdG8gNS4xMy4wLCByZXR1cm5zIGB2b2lkYCkuXG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IG1vdW50LCB1bm1vdW50IH0gZnJvbSAnc3ZlbHRlJztcbiAqIGltcG9ydCBBcHAgZnJvbSAnLi9BcHAuc3ZlbHRlJztcbiAqXG4gKiBjb25zdCBhcHAgPSBtb3VudChBcHAsIHsgdGFyZ2V0OiBkb2N1bWVudC5ib2R5IH0pO1xuICpcbiAqIC8vIGxhdGVyLi4uXG4gKiB1bm1vdW50KGFwcCwgeyBvdXRybzogdHJ1ZSB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7eyBvdXRybz86IGJvb2xlYW4gfX0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdGNvbnN0IGZuID0gbW91bnRlZF9jb21wb25lbnRzLmdldChjb21wb25lbnQpO1xuXG5cdGlmIChmbikge1xuXHRcdG1vdW50ZWRfY29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50KTtcblx0XHRyZXR1cm4gZm4ob3B0aW9ucyk7XG5cdH1cblxuXHRpZiAoREVWKSB7XG5cdFx0aWYgKFNUQVRFX1NZTUJPTCBpbiBjb21wb25lbnQpIHtcblx0XHRcdHcuc3RhdGVfcHJveHlfdW5tb3VudCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcbmltcG9ydCB7XG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdG1vdmVfZWZmZWN0LFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBzaG91bGRfZGVmZXJfYXBwZW5kIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3sgZWZmZWN0OiBFZmZlY3QsIGZyYWdtZW50OiBEb2N1bWVudEZyYWdtZW50IH19IEJyYW5jaFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEtleVxuICovXG5leHBvcnQgY2xhc3MgQnJhbmNoTWFuYWdlciB7XG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqL1xuXHRhbmNob3I7XG5cblx0LyoqIEB0eXBlIHtNYXA8QmF0Y2gsIEtleT59ICovXG5cdCNiYXRjaGVzID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAdHlwZSB7TWFwPEtleSwgRWZmZWN0Pn0gKi9cblx0I29uc2NyZWVuID0gbmV3IE1hcCgpO1xuXG5cdC8qKiBAdHlwZSB7TWFwPEtleSwgQnJhbmNoPn0gKi9cblx0I29mZnNjcmVlbiA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogV2hldGhlciB0byBwYXVzZSAoaS5lLiBvdXRybykgb24gY2hhbmdlLCBvciBkZXN0cm95IGltbWVkaWF0ZWx5LlxuXHQgKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgYDxzdmVsdGU6ZWxlbWVudD5gXG5cdCAqL1xuXHQjdHJhbnNpdGlvbiA9IHRydWU7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBhbmNob3Jcblx0ICogQHBhcmFtIHtib29sZWFufSB0cmFuc2l0aW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihhbmNob3IsIHRyYW5zaXRpb24gPSB0cnVlKSB7XG5cdFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cdFx0dGhpcy4jdHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdH1cblxuXHQjY29tbWl0ID0gKCkgPT4ge1xuXHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblxuXHRcdC8vIGlmIHRoaXMgYmF0Y2ggd2FzIG1hZGUgb2Jzb2xldGUsIGJhaWxcblx0XHRpZiAoIXRoaXMuI2JhdGNoZXMuaGFzKGJhdGNoKSkgcmV0dXJuO1xuXG5cdFx0dmFyIGtleSA9IC8qKiBAdHlwZSB7S2V5fSAqLyAodGhpcy4jYmF0Y2hlcy5nZXQoYmF0Y2gpKTtcblxuXHRcdHZhciBvbnNjcmVlbiA9IHRoaXMuI29uc2NyZWVuLmdldChrZXkpO1xuXG5cdFx0aWYgKG9uc2NyZWVuKSB7XG5cdFx0XHQvLyBlZmZlY3QgaXMgYWxyZWFkeSBpbiB0aGUgRE9NIOKAlCBhYm9ydCBhbnkgY3VycmVudCBvdXRyb1xuXHRcdFx0cmVzdW1lX2VmZmVjdChvbnNjcmVlbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGVmZmVjdCBpcyBjdXJyZW50bHkgb2Zmc2NyZWVuLiBwdXQgaXQgaW4gdGhlIERPTVxuXHRcdFx0dmFyIG9mZnNjcmVlbiA9IHRoaXMuI29mZnNjcmVlbi5nZXQoa2V5KTtcblxuXHRcdFx0aWYgKG9mZnNjcmVlbikge1xuXHRcdFx0XHR0aGlzLiNvbnNjcmVlbi5zZXQoa2V5LCBvZmZzY3JlZW4uZWZmZWN0KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuLmRlbGV0ZShrZXkpO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSB0aGUgYW5jaG9yLi4uXG5cdFx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAob2Zmc2NyZWVuLmZyYWdtZW50Lmxhc3RDaGlsZCkucmVtb3ZlKCk7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGFwcGVuZCB0aGUgZnJhZ21lbnRcblx0XHRcdFx0dGhpcy5hbmNob3IuYmVmb3JlKG9mZnNjcmVlbi5mcmFnbWVudCk7XG5cdFx0XHRcdG9uc2NyZWVuID0gb2Zmc2NyZWVuLmVmZmVjdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IFtiLCBrXSBvZiB0aGlzLiNiYXRjaGVzKSB7XG5cdFx0XHR0aGlzLiNiYXRjaGVzLmRlbGV0ZShiKTtcblxuXHRcdFx0aWYgKGIgPT09IGJhdGNoKSB7XG5cdFx0XHRcdC8vIGtlZXAgdmFsdWVzIGZvciBuZXdlciBiYXRjaGVzXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBvZmZzY3JlZW4gPSB0aGlzLiNvZmZzY3JlZW4uZ2V0KGspO1xuXG5cdFx0XHRpZiAob2Zmc2NyZWVuKSB7XG5cdFx0XHRcdC8vIGZvciBvbGRlciBiYXRjaGVzLCBkZXN0cm95IG9mZnNjcmVlbiBlZmZlY3RzXG5cdFx0XHRcdC8vIGFzIHRoZXkgd2lsbCBuZXZlciBiZSBjb21taXR0ZWRcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3Qob2Zmc2NyZWVuLmVmZmVjdCk7XG5cdFx0XHRcdHRoaXMuI29mZnNjcmVlbi5kZWxldGUoayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gb3V0cm8vZGVzdHJveSBhbGwgb25zY3JlZW4gZWZmZWN0cy4uLlxuXHRcdGZvciAoY29uc3QgW2ssIGVmZmVjdF0gb2YgdGhpcy4jb25zY3JlZW4pIHtcblx0XHRcdC8vIC4uLmV4Y2VwdCB0aGUgb25lIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkXG5cdFx0XHRpZiAoayA9PT0ga2V5KSBjb250aW51ZTtcblxuXHRcdFx0Y29uc3Qgb25fZGVzdHJveSA9ICgpID0+IHtcblx0XHRcdFx0Y29uc3Qga2V5cyA9IEFycmF5LmZyb20odGhpcy4jYmF0Y2hlcy52YWx1ZXMoKSk7XG5cblx0XHRcdFx0aWYgKGtleXMuaW5jbHVkZXMoaykpIHtcblx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3Qgb2Zmc2NyZWVuLCBhcyBhbm90aGVyIGJhdGNoIHdpbGwgbmVlZCBpdFxuXHRcdFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHRtb3ZlX2VmZmVjdChlZmZlY3QsIGZyYWdtZW50KTtcblxuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZChjcmVhdGVfdGV4dCgpKTsgLy8gVE9ETyBjYW4gd2UgYXZvaWQgdGhpcz9cblxuXHRcdFx0XHRcdHRoaXMuI29mZnNjcmVlbi5zZXQoaywgeyBlZmZlY3QsIGZyYWdtZW50IH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLiNvbnNjcmVlbi5kZWxldGUoayk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGhpcy4jdHJhbnNpdGlvbiB8fCAhb25zY3JlZW4pIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCwgb25fZGVzdHJveSwgZmFsc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b25fZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtCYXRjaH0gYmF0Y2hcblx0ICovXG5cdCNkaXNjYXJkID0gKGJhdGNoKSA9PiB7XG5cdFx0dGhpcy4jYmF0Y2hlcy5kZWxldGUoYmF0Y2gpO1xuXG5cdFx0Y29uc3Qga2V5cyA9IEFycmF5LmZyb20odGhpcy4jYmF0Y2hlcy52YWx1ZXMoKSk7XG5cblx0XHRmb3IgKGNvbnN0IFtrLCBicmFuY2hdIG9mIHRoaXMuI29mZnNjcmVlbikge1xuXHRcdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGspKSB7XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGJyYW5jaC5lZmZlY3QpO1xuXHRcdFx0XHR0aGlzLiNvZmZzY3JlZW4uZGVsZXRlKGspO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHthbnl9IGtleVxuXHQgKiBAcGFyYW0ge251bGwgfCAoKHRhcmdldDogVGVtcGxhdGVOb2RlKSA9PiB2b2lkKX0gZm5cblx0ICovXG5cdGVuc3VyZShrZXksIGZuKSB7XG5cdFx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHRcdHZhciBkZWZlciA9IHNob3VsZF9kZWZlcl9hcHBlbmQoKTtcblxuXHRcdGlmIChmbiAmJiAhdGhpcy4jb25zY3JlZW4uaGFzKGtleSkgJiYgIXRoaXMuI29mZnNjcmVlbi5oYXMoa2V5KSkge1xuXHRcdFx0aWYgKGRlZmVyKSB7XG5cdFx0XHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGNyZWF0ZV90ZXh0KCk7XG5cblx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kKHRhcmdldCk7XG5cblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuLnNldChrZXksIHtcblx0XHRcdFx0XHRlZmZlY3Q6IGJyYW5jaCgoKSA9PiBmbih0YXJnZXQpKSxcblx0XHRcdFx0XHRmcmFnbWVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuI29uc2NyZWVuLnNldChcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0YnJhbmNoKCgpID0+IGZuKHRoaXMuYW5jaG9yKSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLiNiYXRjaGVzLnNldChiYXRjaCwga2V5KTtcblxuXHRcdGlmIChkZWZlcikge1xuXHRcdFx0Zm9yIChjb25zdCBbaywgZWZmZWN0XSBvZiB0aGlzLiNvbnNjcmVlbikge1xuXHRcdFx0XHRpZiAoayA9PT0ga2V5KSB7XG5cdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmRlbGV0ZShlZmZlY3QpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJhdGNoLnNraXBwZWRfZWZmZWN0cy5hZGQoZWZmZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGNvbnN0IFtrLCBicmFuY2hdIG9mIHRoaXMuI29mZnNjcmVlbikge1xuXHRcdFx0XHRpZiAoayA9PT0ga2V5KSB7XG5cdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmRlbGV0ZShicmFuY2guZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRiYXRjaC5za2lwcGVkX2VmZmVjdHMuYWRkKGJyYW5jaC5lZmZlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGJhdGNoLm9uY29tbWl0KHRoaXMuI2NvbW1pdCk7XG5cdFx0XHRiYXRjaC5vbmRpc2NhcmQodGhpcy4jZGlzY2FyZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0dGhpcy5hbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuI2NvbW1pdCgpO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRpbmcsXG5cdHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uLFxuXHRza2lwX25vZGVzLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBibG9jayB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlRfRUxTRSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBCcmFuY2hNYW5hZ2VyIH0gZnJvbSAnLi9icmFuY2hlcy5qcyc7XG5cbi8vIFRPRE8gcmVpbnN0YXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC8xNTI1MFxuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geyhicmFuY2g6IChmbjogKGFuY2hvcjogTm9kZSkgPT4gdm9pZCwgZmxhZz86IGJvb2xlYW4pID0+IHZvaWQpID0+IHZvaWR9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbHNlaWZdIFRydWUgaWYgdGhpcyBpcyBhbiBgezplbHNlIGlmIC4uLn1gIGJsb2NrIHJhdGhlciB0aGFuIGFuIGB7I2lmIC4uLn1gLCBhcyB0aGF0IGFmZmVjdHMgd2hpY2ggdHJhbnNpdGlvbnMgYXJlIGNvbnNpZGVyZWQgJ2xvY2FsJ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZl9ibG9jayhub2RlLCBmbiwgZWxzZWlmID0gZmFsc2UpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cdHZhciBmbGFncyA9IGVsc2VpZiA/IEVGRkVDVF9UUkFOU1BBUkVOVCA6IDA7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uLFxuXHQgKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9IGZuXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVfYnJhbmNoKGNvbmRpdGlvbiwgZm4pIHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRjb25zdCBpc19lbHNlID0gcmVhZF9oeWRyYXRpb25faW5zdHJ1Y3Rpb24obm9kZSkgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoY29uZGl0aW9uID09PSBpc19lbHNlKSB7XG5cdFx0XHRcdC8vIEh5ZHJhdGlvbiBtaXNtYXRjaDogcmVtb3ZlIGV2ZXJ5dGhpbmcgaW5zaWRlIHRoZSBhbmNob3IgYW5kIHN0YXJ0IGZyZXNoLlxuXHRcdFx0XHQvLyBUaGlzIGNvdWxkIGhhcHBlbiB3aXRoIGB7I2lmIGJyb3dzZXJ9Li4uey9pZn1gLCBmb3IgZXhhbXBsZVxuXHRcdFx0XHR2YXIgYW5jaG9yID0gc2tpcF9ub2RlcygpO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdFx0YnJhbmNoZXMuYW5jaG9yID0gYW5jaG9yO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRicmFuY2hlcy5lbnN1cmUoY29uZGl0aW9uLCBmbik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJyYW5jaGVzLmVuc3VyZShjb25kaXRpb24sIGZuKTtcblx0fVxuXG5cdGJsb2NrKCgpID0+IHtcblx0XHR2YXIgaGFzX2JyYW5jaCA9IGZhbHNlO1xuXG5cdFx0Zm4oKGZuLCBmbGFnID0gdHJ1ZSkgPT4ge1xuXHRcdFx0aGFzX2JyYW5jaCA9IHRydWU7XG5cdFx0XHR1cGRhdGVfYnJhbmNoKGZsYWcsIGZuKTtcblx0XHR9KTtcblxuXHRcdGlmICghaGFzX2JyYW5jaCkge1xuXHRcdFx0dXBkYXRlX2JyYW5jaChmYWxzZSwgbnVsbCk7XG5cdFx0fVxuXHR9LCBmbGFncyk7XG59XG4iLCIvKiogQGltcG9ydCB7IEVhY2hJdGVtLCBFYWNoU3RhdGUsIEVmZmVjdCwgTWF5YmVTb3VyY2UsIFNvdXJjZSwgVGVtcGxhdGVOb2RlLCBUcmFuc2l0aW9uTWFuYWdlciwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnOyAqL1xuaW1wb3J0IHtcblx0RUFDSF9JTkRFWF9SRUFDVElWRSxcblx0RUFDSF9JU19BTklNQVRFRCxcblx0RUFDSF9JU19DT05UUk9MTEVELFxuXHRFQUNIX0lURU1fSU1NVVRBQkxFLFxuXHRFQUNIX0lURU1fUkVBQ1RJVkUsXG5cdEhZRFJBVElPTl9FTkQsXG5cdEhZRFJBVElPTl9TVEFSVF9FTFNFXG59IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRyZWFkX2h5ZHJhdGlvbl9pbnN0cnVjdGlvbixcblx0c2tpcF9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nLFxuXHRzaG91bGRfZGVmZXJfYXBwZW5kXG59IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnMsXG5cdHBhdXNlX2NoaWxkcmVuLFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgbXV0YWJsZV9zb3VyY2UsIGludGVybmFsX3NldCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tLCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBDT01NRU5UX05PREUsIElORVJUIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCwgZ2V0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlcml2ZWRfc2FmZV9lcXVhbCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9iYXRjaCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vKipcbiAqIFRoZSByb3cgb2YgYSBrZXllZCBlYWNoIGJsb2NrIHRoYXQgaXMgY3VycmVudGx5IHVwZGF0aW5nLiBXZSB0cmFjayB0aGlzXG4gKiBzbyB0aGF0IGBhbmltYXRlOmAgZGlyZWN0aXZlcyBoYXZlIHNvbWV0aGluZyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0b1xuICogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2VhY2hfaXRlbSA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gaXRlbSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2VhY2hfaXRlbShpdGVtKSB7XG5cdGN1cnJlbnRfZWFjaF9pdGVtID0gaXRlbTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gX1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KF8sIGkpIHtcblx0cmV0dXJuIGk7XG59XG5cbi8qKlxuICogUGF1c2UgbXVsdGlwbGUgZWZmZWN0cyBzaW11bHRhbmVvdXNseSwgYW5kIGNvb3JkaW5hdGUgdGhlaXJcbiAqIHN1YnNlcXVlbnQgZGVzdHJ1Y3Rpb24uIFVzZWQgaW4gZWFjaCBibG9ja3NcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbVtdfSBpdGVtc1xuICogQHBhcmFtIHtudWxsIHwgTm9kZX0gY29udHJvbGxlZF9hbmNob3JcbiAqL1xuZnVuY3Rpb24gcGF1c2VfZWZmZWN0cyhzdGF0ZSwgaXRlbXMsIGNvbnRyb2xsZWRfYW5jaG9yKSB7XG5cdHZhciBpdGVtc19tYXAgPSBzdGF0ZS5pdGVtcztcblxuXHQvKiogQHR5cGUge1RyYW5zaXRpb25NYW5hZ2VyW119ICovXG5cdHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRwYXVzZV9jaGlsZHJlbihpdGVtc1tpXS5lLCB0cmFuc2l0aW9ucywgdHJ1ZSk7XG5cdH1cblxuXHR2YXIgaXNfY29udHJvbGxlZCA9IGxlbmd0aCA+IDAgJiYgdHJhbnNpdGlvbnMubGVuZ3RoID09PSAwICYmIGNvbnRyb2xsZWRfYW5jaG9yICE9PSBudWxsO1xuXHQvLyBJZiB3ZSBoYXZlIGEgY29udHJvbGxlZCBhbmNob3IsIGl0IG1lYW5zIHRoYXQgdGhlIGVhY2ggYmxvY2sgaXMgaW5zaWRlIGEgc2luZ2xlXG5cdC8vIERPTSBlbGVtZW50LCBzbyB3ZSBjYW4gYXBwbHkgYSBmYXN0LXBhdGggZm9yIGNsZWFyaW5nIHRoZSBjb250ZW50cyBvZiB0aGUgZWxlbWVudC5cblx0aWYgKGlzX2NvbnRyb2xsZWQpIHtcblx0XHR2YXIgcGFyZW50X25vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChcblx0XHRcdC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGNvbnRyb2xsZWRfYW5jaG9yKS5wYXJlbnROb2RlXG5cdFx0KTtcblx0XHRjbGVhcl90ZXh0X2NvbnRlbnQocGFyZW50X25vZGUpO1xuXHRcdHBhcmVudF9ub2RlLmFwcGVuZCgvKiogQHR5cGUge0VsZW1lbnR9ICovIChjb250cm9sbGVkX2FuY2hvcikpO1xuXHRcdGl0ZW1zX21hcC5jbGVhcigpO1xuXHRcdGxpbmsoc3RhdGUsIGl0ZW1zWzBdLnByZXYsIGl0ZW1zW2xlbmd0aCAtIDFdLm5leHQpO1xuXHR9XG5cblx0cnVuX291dF90cmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgKCkgPT4ge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRpZiAoIWlzX2NvbnRyb2xsZWQpIHtcblx0XHRcdFx0aXRlbXNfbWFwLmRlbGV0ZShpdGVtLmspO1xuXHRcdFx0XHRsaW5rKHN0YXRlLCBpdGVtLnByZXYsIGl0ZW0ubmV4dCk7XG5cdFx0XHR9XG5cdFx0XHRkZXN0cm95X2VmZmVjdChpdGVtLmUsICFpc19jb250cm9sbGVkKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBDb21tZW50fSBub2RlIFRoZSBuZXh0IHNpYmxpbmcgbm9kZSwgb3IgdGhlIHBhcmVudCBub2RlIGlmIHRoaXMgaXMgYSAnY29udHJvbGxlZCcgYmxvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsoKSA9PiBWW119IGdldF9jb2xsZWN0aW9uXG4gKiBAcGFyYW0geyh2YWx1ZTogViwgaW5kZXg6IG51bWJlcikgPT4gYW55fSBnZXRfa2V5XG4gKiBAcGFyYW0geyhhbmNob3I6IE5vZGUsIGl0ZW06IE1heWJlU291cmNlPFY+LCBpbmRleDogTWF5YmVTb3VyY2U8bnVtYmVyPikgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9IGZhbGxiYWNrX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2gobm9kZSwgZmxhZ3MsIGdldF9jb2xsZWN0aW9uLCBnZXRfa2V5LCByZW5kZXJfZm4sIGZhbGxiYWNrX2ZuID0gbnVsbCkge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0VhY2hTdGF0ZX0gKi9cblx0dmFyIHN0YXRlID0geyBmbGFncywgaXRlbXM6IG5ldyBNYXAoKSwgZmlyc3Q6IG51bGwgfTtcblxuXHR2YXIgaXNfY29udHJvbGxlZCA9IChmbGFncyAmIEVBQ0hfSVNfQ09OVFJPTExFRCkgIT09IDA7XG5cblx0aWYgKGlzX2NvbnRyb2xsZWQpIHtcblx0XHR2YXIgcGFyZW50X25vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKTtcblxuXHRcdGFuY2hvciA9IGh5ZHJhdGluZ1xuXHRcdFx0PyBzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7Q29tbWVudCB8IFRleHR9ICovIChnZXRfZmlyc3RfY2hpbGQocGFyZW50X25vZGUpKSlcblx0XHRcdDogcGFyZW50X25vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSk7XG5cdH1cblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBmYWxsYmFjayA9IG51bGw7XG5cblx0dmFyIHdhc19lbXB0eSA9IGZhbHNlO1xuXG5cdC8qKiBAdHlwZSB7TWFwPGFueSwgRWFjaEl0ZW0+fSAqL1xuXHR2YXIgb2Zmc2NyZWVuX2l0ZW1zID0gbmV3IE1hcCgpO1xuXG5cdC8vIFRPRE86IGlkZWFsbHkgd2UgY291bGQgdXNlIGRlcml2ZWQgZm9yIHJ1bmVzIG1vZGUgYnV0IGJlY2F1c2Ugb2YgdGhlIGFiaWxpdHlcblx0Ly8gdG8gdXNlIGEgc3RvcmUgd2hpY2ggY2FuIGJlIG11dGF0ZWQsIHdlIGNhbid0IGRvIHRoYXQgaGVyZSBhcyBtdXRhdGluZyBhIHN0b3JlXG5cdC8vIHdpbGwgc3RpbGwgcmVzdWx0IGluIHRoZSBjb2xsZWN0aW9uIGFycmF5IGJlaW5nIHRoZSBzYW1lIGZyb20gdGhlIHN0b3JlXG5cdHZhciBlYWNoX2FycmF5ID0gZGVyaXZlZF9zYWZlX2VxdWFsKCgpID0+IHtcblx0XHR2YXIgY29sbGVjdGlvbiA9IGdldF9jb2xsZWN0aW9uKCk7XG5cblx0XHRyZXR1cm4gaXNfYXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogY29sbGVjdGlvbiA9PSBudWxsID8gW10gOiBhcnJheV9mcm9tKGNvbGxlY3Rpb24pO1xuXHR9KTtcblxuXHQvKiogQHR5cGUge1ZbXX0gKi9cblx0dmFyIGFycmF5O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWFjaF9lZmZlY3Q7XG5cblx0ZnVuY3Rpb24gY29tbWl0KCkge1xuXHRcdHJlY29uY2lsZShcblx0XHRcdGVhY2hfZWZmZWN0LFxuXHRcdFx0YXJyYXksXG5cdFx0XHRzdGF0ZSxcblx0XHRcdG9mZnNjcmVlbl9pdGVtcyxcblx0XHRcdGFuY2hvcixcblx0XHRcdHJlbmRlcl9mbixcblx0XHRcdGZsYWdzLFxuXHRcdFx0Z2V0X2tleSxcblx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0KTtcblxuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoZmFsbGJhY2spIHtcblx0XHRcdFx0XHRyZXN1bWVfZWZmZWN0KGZhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IGJyYW5jaCgoKSA9PiBmYWxsYmFja19mbihhbmNob3IpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZmFsbGJhY2ssICgpID0+IHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGJsb2NrKCgpID0+IHtcblx0XHQvLyBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgZWZmZWN0IHNvIHRoYXQgd2UgY2FuIHVwZGF0ZSB0aGUgc3RhcnQvZW5kIG5vZGVzIGluIHJlY29uY2lsaWF0aW9uXG5cdFx0ZWFjaF9lZmZlY3QgPz89IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0XHRhcnJheSA9IC8qKiBAdHlwZSB7VltdfSAqLyAoZ2V0KGVhY2hfYXJyYXkpKTtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0aWYgKHdhc19lbXB0eSAmJiBsZW5ndGggPT09IDApIHtcblx0XHRcdC8vIGlnbm9yZSB1cGRhdGVzIGlmIHRoZSBhcnJheSBpcyBlbXB0eSxcblx0XHRcdC8vIGFuZCBpdCBhbHJlYWR5IHdhcyBlbXB0eSBvbiBwcmV2aW91cyBydW5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0d2FzX2VtcHR5ID0gbGVuZ3RoID09PSAwO1xuXG5cdFx0LyoqIGB0cnVlYCBpZiB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdGxldCBtaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0dmFyIGlzX2Vsc2UgPSByZWFkX2h5ZHJhdGlvbl9pbnN0cnVjdGlvbihhbmNob3IpID09PSBIWURSQVRJT05fU1RBUlRfRUxTRTtcblxuXHRcdFx0aWYgKGlzX2Vsc2UgIT09IChsZW5ndGggPT09IDApKSB7XG5cdFx0XHRcdC8vIGh5ZHJhdGlvbiBtaXNtYXRjaCDigJQgcmVtb3ZlIHRoZSBzZXJ2ZXItcmVuZGVyZWQgRE9NIGFuZCBzdGFydCBvdmVyXG5cdFx0XHRcdGFuY2hvciA9IHNraXBfbm9kZXMoKTtcblxuXHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcyBpcyBzZXBhcmF0ZSB0byB0aGUgcHJldmlvdXMgYmxvY2sgYmVjYXVzZSBgaHlkcmF0aW5nYCBtaWdodCBjaGFuZ2Vcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHQvKiogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH0gKi9cblx0XHRcdHZhciBwcmV2ID0gbnVsbDtcblxuXHRcdFx0LyoqIEB0eXBlIHtFYWNoSXRlbX0gKi9cblx0XHRcdHZhciBpdGVtO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSA9PT0gSFlEUkFUSU9OX0VORFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBUaGUgc2VydmVyIHJlbmRlcmVkIGZld2VyIGl0ZW1zIHRoYW4gZXhwZWN0ZWQsXG5cdFx0XHRcdFx0Ly8gc28gYnJlYWsgb3V0IGFuZCBjb250aW51ZSBhcHBlbmRpbmcgbm9uLWh5ZHJhdGVkIGl0ZW1zXG5cdFx0XHRcdFx0YW5jaG9yID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdFx0dmFyIGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0XHRpdGVtID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdHByZXYsXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRyZW5kZXJfZm4sXG5cdFx0XHRcdFx0ZmxhZ3MsXG5cdFx0XHRcdFx0Z2V0X2NvbGxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdFx0c3RhdGUuaXRlbXMuc2V0KGtleSwgaXRlbSk7XG5cblx0XHRcdFx0cHJldiA9IGl0ZW07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBleGNlc3Mgbm9kZXNcblx0XHRcdGlmIChsZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoc2tpcF9ub2RlcygpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSAwICYmIGZhbGxiYWNrX2ZuKSB7XG5cdFx0XHRcdGZhbGxiYWNrID0gYnJhbmNoKCgpID0+IGZhbGxiYWNrX2ZuKGFuY2hvcikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoc2hvdWxkX2RlZmVyX2FwcGVuZCgpKSB7XG5cdFx0XHRcdHZhciBrZXlzID0gbmV3IFNldCgpO1xuXHRcdFx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAoY3VycmVudF9iYXRjaCk7XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdFx0XHRrZXkgPSBnZXRfa2V5KHZhbHVlLCBpKTtcblxuXHRcdFx0XHRcdHZhciBleGlzdGluZyA9IHN0YXRlLml0ZW1zLmdldChrZXkpID8/IG9mZnNjcmVlbl9pdGVtcy5nZXQoa2V5KTtcblxuXHRcdFx0XHRcdGlmIChleGlzdGluZykge1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIGJlZm9yZSByZWNvbmNpbGlhdGlvbiwgdG8gdHJpZ2dlciBhbnkgYXN5bmMgdXBkYXRlc1xuXHRcdFx0XHRcdFx0aWYgKChmbGFncyAmIChFQUNIX0lURU1fUkVBQ1RJVkUgfCBFQUNIX0lOREVYX1JFQUNUSVZFKSkgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0dXBkYXRlX2l0ZW0oZXhpc3RpbmcsIHZhbHVlLCBpLCBmbGFncyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGl0ZW0gPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0XHRcdHJlbmRlcl9mbixcblx0XHRcdFx0XHRcdFx0ZmxhZ3MsXG5cdFx0XHRcdFx0XHRcdGdldF9jb2xsZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRvZmZzY3JlZW5faXRlbXMuc2V0KGtleSwgaXRlbSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0a2V5cy5hZGQoa2V5KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2Ygc3RhdGUuaXRlbXMpIHtcblx0XHRcdFx0XHRpZiAoIWtleXMuaGFzKGtleSkpIHtcblx0XHRcdFx0XHRcdGJhdGNoLnNraXBwZWRfZWZmZWN0cy5hZGQoaXRlbS5lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXRjaC5vbmNvbW1pdChjb21taXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29tbWl0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBjb250aW51ZSBpbiBoeWRyYXRpb24gbW9kZVxuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHdlIG1vdW50IHRoZSBlYWNoIGJsb2NrIGZvciB0aGUgZmlyc3QgdGltZSwgdGhlIGNvbGxlY3Rpb24gd29uJ3QgYmVcblx0XHQvLyBjb25uZWN0ZWQgdG8gdGhpcyBlZmZlY3QgYXMgdGhlIGVmZmVjdCBoYXNuJ3QgZmluaXNoZWQgcnVubmluZyB5ZXQgYW5kIGl0cyBkZXBzXG5cdFx0Ly8gd29uJ3QgYmUgYXNzaWduZWQuIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCB3aGVuIHJlY29uY2lsaW5nIHRoZSBlYWNoIGJsb2NrXG5cdFx0Ly8gdGhhdCBhIG11dGF0aW9uIG9jY3VycmVkIGFuZCBpdCdzIG1hZGUgdGhlIGNvbGxlY3Rpb24gTUFZQkVfRElSVFksIHNvIHJlYWRpbmcgdGhlXG5cdFx0Ly8gY29sbGVjdGlvbiBhZ2FpbiBjYW4gcHJvdmlkZSBjb25zaXN0ZW5jeSB0byB0aGUgcmVhY3RpdmUgZ3JhcGggYWdhaW4gYXMgdGhlIGRlcml2ZWRzXG5cdFx0Ly8gd2lsbCBub3cgYmUgYENMRUFOYC5cblx0XHRnZXQoZWFjaF9hcnJheSk7XG5cdH0pO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGQsIHJlbW92ZSwgb3IgcmVvcmRlciBpdGVtcyBvdXRwdXQgYnkgYW4gZWFjaCBibG9jayBhcyBpdHMgaW5wdXQgY2hhbmdlc1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7RWZmZWN0fSBlYWNoX2VmZmVjdFxuICogQHBhcmFtIHtBcnJheTxWPn0gYXJyYXlcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtNYXA8YW55LCBFYWNoSXRlbT59IG9mZnNjcmVlbl9pdGVtc1xuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudCB8IFRleHR9IGFuY2hvclxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFNvdXJjZTxudW1iZXI+LCBjb2xsZWN0aW9uOiAoKSA9PiBWW10pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geyh2YWx1ZTogViwgaW5kZXg6IG51bWJlcikgPT4gYW55fSBnZXRfa2V5XG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiByZWNvbmNpbGUoXG5cdGVhY2hfZWZmZWN0LFxuXHRhcnJheSxcblx0c3RhdGUsXG5cdG9mZnNjcmVlbl9pdGVtcyxcblx0YW5jaG9yLFxuXHRyZW5kZXJfZm4sXG5cdGZsYWdzLFxuXHRnZXRfa2V5LFxuXHRnZXRfY29sbGVjdGlvblxuKSB7XG5cdHZhciBpc19hbmltYXRlZCA9IChmbGFncyAmIEVBQ0hfSVNfQU5JTUFURUQpICE9PSAwO1xuXHR2YXIgc2hvdWxkX3VwZGF0ZSA9IChmbGFncyAmIChFQUNIX0lURU1fUkVBQ1RJVkUgfCBFQUNIX0lOREVYX1JFQUNUSVZFKSkgIT09IDA7XG5cblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGl0ZW1zID0gc3RhdGUuaXRlbXM7XG5cdHZhciBmaXJzdCA9IHN0YXRlLmZpcnN0O1xuXHR2YXIgY3VycmVudCA9IGZpcnN0O1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHNlZW47XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdHZhciBwcmV2ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge3VuZGVmaW5lZCB8IFNldDxFYWNoSXRlbT59ICovXG5cdHZhciB0b19hbmltYXRlO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtW119ICovXG5cdHZhciBzdGFzaGVkID0gW107XG5cblx0LyoqIEB0eXBlIHtWfSAqL1xuXHR2YXIgdmFsdWU7XG5cblx0LyoqIEB0eXBlIHthbnl9ICovXG5cdHZhciBrZXk7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGl0ZW07XG5cblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdHZhciBpO1xuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0aXRlbSA9IGl0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGl0ZW0uYT8ubWVhc3VyZSgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5hZGQoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRrZXkgPSBnZXRfa2V5KHZhbHVlLCBpKTtcblxuXHRcdGl0ZW0gPSBpdGVtcy5nZXQoa2V5KTtcblxuXHRcdGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBwZW5kaW5nID0gb2Zmc2NyZWVuX2l0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRpZiAocGVuZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9mZnNjcmVlbl9pdGVtcy5kZWxldGUoa2V5KTtcblx0XHRcdFx0aXRlbXMuc2V0KGtleSwgcGVuZGluZyk7XG5cblx0XHRcdFx0dmFyIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0IDogY3VycmVudDtcblxuXHRcdFx0XHRsaW5rKHN0YXRlLCBwcmV2LCBwZW5kaW5nKTtcblx0XHRcdFx0bGluayhzdGF0ZSwgcGVuZGluZywgbmV4dCk7XG5cblx0XHRcdFx0bW92ZShwZW5kaW5nLCBuZXh0LCBhbmNob3IpO1xuXHRcdFx0XHRwcmV2ID0gcGVuZGluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSBjdXJyZW50ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjdXJyZW50LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdFx0XHRcdHByZXYgPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRjaGlsZF9hbmNob3IsXG5cdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0cHJldixcblx0XHRcdFx0XHRwcmV2ID09PSBudWxsID8gc3RhdGUuZmlyc3QgOiBwcmV2Lm5leHQsXG5cdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1zLnNldChrZXksIHByZXYpO1xuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdGN1cnJlbnQgPSBwcmV2Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkX3VwZGF0ZSkge1xuXHRcdFx0dXBkYXRlX2l0ZW0oaXRlbSwgdmFsdWUsIGksIGZsYWdzKTtcblx0XHR9XG5cblx0XHRpZiAoKGl0ZW0uZS5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0XHRyZXN1bWVfZWZmZWN0KGl0ZW0uZSk7XG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0aXRlbS5hPy51bmZpeCgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5kZWxldGUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gIT09IGN1cnJlbnQpIHtcblx0XHRcdGlmIChzZWVuICE9PSB1bmRlZmluZWQgJiYgc2Vlbi5oYXMoaXRlbSkpIHtcblx0XHRcdFx0aWYgKG1hdGNoZWQubGVuZ3RoIDwgc3Rhc2hlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGxhdGVyIGl0ZW1zIHRvIHRoZSBmcm9udFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHN0YXNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGo7XG5cblx0XHRcdFx0XHRwcmV2ID0gc3RhcnQucHJldjtcblxuXHRcdFx0XHRcdHZhciBhID0gbWF0Y2hlZFswXTtcblx0XHRcdFx0XHR2YXIgYiA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRtb3ZlKG1hdGNoZWRbal0sIHN0YXJ0LCBhbmNob3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzdGFzaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRzZWVuLmRlbGV0ZShzdGFzaGVkW2pdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBhLnByZXYsIGIubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgYSk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYiwgc3RhcnQpO1xuXG5cdFx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHByZXYgPSBiO1xuXHRcdFx0XHRcdGkgLT0gMTtcblxuXHRcdFx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdFx0XHRzdGFzaGVkID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBlYXJsaWVyIGl0ZW1zIHRvIHRoZSBiYWNrXG5cdFx0XHRcdFx0c2Vlbi5kZWxldGUoaXRlbSk7XG5cdFx0XHRcdFx0bW92ZShpdGVtLCBjdXJyZW50LCBhbmNob3IpO1xuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0sIHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuayAhPT0ga2V5KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0IGFuZCBhbiBpdGVtIGhhcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGluZXJ0LFxuXHRcdFx0XHQvLyBza2lwIG92ZXIgYWRkaW5nIGl0IHRvIG91ciBzZWVuIFNldCBhcyB0aGUgaXRlbSBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcblx0XHRcdFx0aWYgKChjdXJyZW50LmUuZiAmIElORVJUKSA9PT0gMCkge1xuXHRcdFx0XHRcdChzZWVuID8/PSBuZXcgU2V0KCkpLmFkZChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFzaGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtID0gY3VycmVudDtcblx0XHR9XG5cblx0XHRtYXRjaGVkLnB1c2goaXRlbSk7XG5cdFx0cHJldiA9IGl0ZW07XG5cdFx0Y3VycmVudCA9IGl0ZW0ubmV4dDtcblx0fVxuXG5cdGlmIChjdXJyZW50ICE9PSBudWxsIHx8IHNlZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciB0b19kZXN0cm95ID0gc2VlbiA9PT0gdW5kZWZpbmVkID8gW10gOiBhcnJheV9mcm9tKHNlZW4pO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0LCB0aGVuIGluZXJ0IGVmZmVjdHMgYXJlIGN1cnJlbnRseSBvdXRyb2luZyBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWRcblx0XHRcdGlmICgoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0dG9fZGVzdHJveS5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdHJveV9sZW5ndGggPSB0b19kZXN0cm95Lmxlbmd0aDtcblxuXHRcdGlmIChkZXN0cm95X2xlbmd0aCA+IDApIHtcblx0XHRcdHZhciBjb250cm9sbGVkX2FuY2hvciA9IChmbGFncyAmIEVBQ0hfSVNfQ09OVFJPTExFRCkgIT09IDAgJiYgbGVuZ3RoID09PSAwID8gYW5jaG9yIDogbnVsbDtcblxuXHRcdFx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZXN0cm95X2xlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dG9fZGVzdHJveVtpXS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8uZml4KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGF1c2VfZWZmZWN0cyhzdGF0ZSwgdG9fZGVzdHJveSwgY29udHJvbGxlZF9hbmNob3IpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKHRvX2FuaW1hdGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0Zm9yIChpdGVtIG9mIHRvX2FuaW1hdGUpIHtcblx0XHRcdFx0aXRlbS5hPy5hcHBseSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZWFjaF9lZmZlY3QuZmlyc3QgPSBzdGF0ZS5maXJzdCAmJiBzdGF0ZS5maXJzdC5lO1xuXHRlYWNoX2VmZmVjdC5sYXN0ID0gcHJldiAmJiBwcmV2LmU7XG5cblx0Zm9yICh2YXIgdW51c2VkIG9mIG9mZnNjcmVlbl9pdGVtcy52YWx1ZXMoKSkge1xuXHRcdGRlc3Ryb3lfZWZmZWN0KHVudXNlZC5lKTtcblx0fVxuXG5cdG9mZnNjcmVlbl9pdGVtcy5jbGVhcigpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaEl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZV9pdGVtKGl0ZW0sIHZhbHVlLCBpbmRleCwgdHlwZSkge1xuXHRpZiAoKHR5cGUgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwKSB7XG5cdFx0aW50ZXJuYWxfc2V0KGl0ZW0udiwgdmFsdWUpO1xuXHR9XG5cblx0aWYgKCh0eXBlICYgRUFDSF9JTkRFWF9SRUFDVElWRSkgIT09IDApIHtcblx0XHRpbnRlcm5hbF9zZXQoLyoqIEB0eXBlIHtWYWx1ZTxudW1iZXI+fSAqLyAoaXRlbS5pKSwgaW5kZXgpO1xuXHR9IGVsc2Uge1xuXHRcdGl0ZW0uaSA9IGluZGV4O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Tm9kZSB8IG51bGx9IGFuY2hvclxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7dW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogViB8IFNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFZhbHVlPG51bWJlcj4sIGNvbGxlY3Rpb246ICgpID0+IFZbXSkgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbZGVmZXJyZWRdXG4gKiBAcmV0dXJucyB7RWFjaEl0ZW19XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9pdGVtKFxuXHRhbmNob3IsXG5cdHN0YXRlLFxuXHRwcmV2LFxuXHRuZXh0LFxuXHR2YWx1ZSxcblx0a2V5LFxuXHRpbmRleCxcblx0cmVuZGVyX2ZuLFxuXHRmbGFncyxcblx0Z2V0X2NvbGxlY3Rpb24sXG5cdGRlZmVycmVkXG4pIHtcblx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHR2YXIgcmVhY3RpdmUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwO1xuXHR2YXIgbXV0YWJsZSA9IChmbGFncyAmIEVBQ0hfSVRFTV9JTU1VVEFCTEUpID09PSAwO1xuXG5cdHZhciB2ID0gcmVhY3RpdmUgPyAobXV0YWJsZSA/IG11dGFibGVfc291cmNlKHZhbHVlLCBmYWxzZSwgZmFsc2UpIDogc291cmNlKHZhbHVlKSkgOiB2YWx1ZTtcblx0dmFyIGkgPSAoZmxhZ3MgJiBFQUNIX0lOREVYX1JFQUNUSVZFKSA9PT0gMCA/IGluZGV4IDogc291cmNlKGluZGV4KTtcblxuXHRpZiAoREVWICYmIHJlYWN0aXZlKSB7XG5cdFx0Ly8gRm9yIHRyYWNpbmcgcHVycG9zZXMsIHdlIG5lZWQgdG8gbGluayB0aGUgc291cmNlIHNpZ25hbCB3ZSBjcmVhdGUgd2l0aCB0aGVcblx0XHQvLyBjb2xsZWN0aW9uICsgaW5kZXggc28gdGhhdCB0cmFjaW5nIHdvcmtzIGFzIGludGVuZGVkXG5cdFx0LyoqIEB0eXBlIHtWYWx1ZX0gKi8gKHYpLnRyYWNlID0gKCkgPT4ge1xuXHRcdFx0dmFyIGNvbGxlY3Rpb25faW5kZXggPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyBpbmRleCA6IGkudjtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRnZXRfY29sbGVjdGlvbigpW2NvbGxlY3Rpb25faW5kZXhdO1xuXHRcdH07XG5cdH1cblxuXHQvKiogQHR5cGUge0VhY2hJdGVtfSAqL1xuXHR2YXIgaXRlbSA9IHtcblx0XHRpLFxuXHRcdHYsXG5cdFx0azoga2V5LFxuXHRcdGE6IG51bGwsXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGU6IG51bGwsXG5cdFx0cHJldixcblx0XHRuZXh0XG5cdH07XG5cblx0Y3VycmVudF9lYWNoX2l0ZW0gPSBpdGVtO1xuXG5cdHRyeSB7XG5cdFx0aWYgKGFuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kKChhbmNob3IgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0fVxuXG5cdFx0aXRlbS5lID0gYnJhbmNoKCgpID0+IHJlbmRlcl9mbigvKiogQHR5cGUge05vZGV9ICovIChhbmNob3IpLCB2LCBpLCBnZXRfY29sbGVjdGlvbiksIGh5ZHJhdGluZyk7XG5cblx0XHRpdGVtLmUucHJldiA9IHByZXYgJiYgcHJldi5lO1xuXHRcdGl0ZW0uZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cblx0XHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKCFkZWZlcnJlZCkge1xuXHRcdFx0XHRzdGF0ZS5maXJzdCA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZXYubmV4dCA9IGl0ZW07XG5cdFx0XHRwcmV2LmUubmV4dCA9IGl0ZW0uZTtcblx0XHR9XG5cblx0XHRpZiAobmV4dCAhPT0gbnVsbCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gaXRlbTtcblx0XHRcdG5leHQuZS5wcmV2ID0gaXRlbS5lO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9IGZpbmFsbHkge1xuXHRcdGN1cnJlbnRfZWFjaF9pdGVtID0gcHJldmlvdXNfZWFjaF9pdGVtO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoSXRlbX0gaXRlbVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7VGV4dCB8IEVsZW1lbnQgfCBDb21tZW50fSBhbmNob3JcbiAqL1xuZnVuY3Rpb24gbW92ZShpdGVtLCBuZXh0LCBhbmNob3IpIHtcblx0dmFyIGVuZCA9IGl0ZW0ubmV4dCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaXRlbS5uZXh0LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdHZhciBkZXN0ID0gbmV4dCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblx0dmFyIG5vZGUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGl0ZW0uZS5ub2Rlc19zdGFydCk7XG5cblx0d2hpbGUgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZW5kKSB7XG5cdFx0dmFyIG5leHRfbm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0ZGVzdC5iZWZvcmUobm9kZSk7XG5cdFx0bm9kZSA9IG5leHRfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IHByZXZcbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKi9cbmZ1bmN0aW9uIGxpbmsoc3RhdGUsIHByZXYsIG5leHQpIHtcblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHRzdGF0ZS5maXJzdCA9IG5leHQ7XG5cdH0gZWxzZSB7XG5cdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHRwcmV2LmUubmV4dCA9IG5leHQgJiYgbmV4dC5lO1xuXHR9XG5cblx0aWYgKG5leHQgIT09IG51bGwpIHtcblx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdG5leHQuZS5wcmV2ID0gcHJldiAmJiBwcmV2LmU7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRklMRU5BTUUsIEhZRFJBVElPTl9FUlJPUiB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyByZW1vdmVfZWZmZWN0X2RvbSwgdGVtcGxhdGVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4uL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBoYXNoLCBzYW5pdGl6ZV9sb2NhdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBnZXRfZmlyc3RfY2hpbGQsIGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IENPTU1FTlRfTk9ERSB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gc2VydmVyX2hhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBjaGVja19oYXNoKGVsZW1lbnQsIHNlcnZlcl9oYXNoLCB2YWx1ZSkge1xuXHRpZiAoIXNlcnZlcl9oYXNoIHx8IHNlcnZlcl9oYXNoID09PSBoYXNoKFN0cmluZyh2YWx1ZSA/PyAnJykpKSByZXR1cm47XG5cblx0bGV0IGxvY2F0aW9uO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgbG9jID0gZWxlbWVudC5fX3N2ZWx0ZV9tZXRhPy5sb2M7XG5cdGlmIChsb2MpIHtcblx0XHRsb2NhdGlvbiA9IGBuZWFyICR7bG9jLmZpbGV9OiR7bG9jLmxpbmV9OiR7bG9jLmNvbHVtbn1gO1xuXHR9IGVsc2UgaWYgKGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbj8uW0ZJTEVOQU1FXSkge1xuXHRcdGxvY2F0aW9uID0gYGluICR7ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uW0ZJTEVOQU1FXX1gO1xuXHR9XG5cblx0dy5oeWRyYXRpb25faHRtbF9jaGFuZ2VkKHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50IHwgVGV4dCB8IENvbW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N2Z11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hdGhtbF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbChub2RlLCBnZXRfdmFsdWUsIHN2ZyA9IGZhbHNlLCBtYXRobWwgPSBmYWxzZSwgc2tpcF93YXJuaW5nID0gZmFsc2UpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0dmFyIHZhbHVlID0gJyc7XG5cblx0dGVtcGxhdGVfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHRcdGlmICh2YWx1ZSA9PT0gKHZhbHVlID0gZ2V0X3ZhbHVlKCkgPz8gJycpKSB7XG5cdFx0XHRpZiAoaHlkcmF0aW5nKSBoeWRyYXRlX25leHQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoZWZmZWN0Lm5vZGVzX3N0YXJ0ICE9PSBudWxsKSB7XG5cdFx0XHRyZW1vdmVfZWZmZWN0X2RvbShlZmZlY3Qubm9kZXNfc3RhcnQsIC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZWZmZWN0Lm5vZGVzX2VuZCkpO1xuXHRcdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID0gZWZmZWN0Lm5vZGVzX2VuZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbHVlID09PSAnJykgcmV0dXJuO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0Ly8gV2UncmUgZGVsaWJlcmF0ZWx5IG5vdCB0cnlpbmcgdG8gcmVwYWlyIG1pc21hdGNoZXMgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCxcblx0XHRcdC8vIGFzIGl0J3MgY29zdGx5IGFuZCBlcnJvci1wcm9uZSAoYW5kIGl0J3MgYW4gZWRnZSBjYXNlIHRvIGhhdmUgYSBtaXNtYXRjaCBhbnl3YXkpXG5cdFx0XHR2YXIgaGFzaCA9IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YTtcblx0XHRcdHZhciBuZXh0ID0gaHlkcmF0ZV9uZXh0KCk7XG5cdFx0XHR2YXIgbGFzdCA9IG5leHQ7XG5cblx0XHRcdHdoaWxlIChcblx0XHRcdFx0bmV4dCAhPT0gbnVsbCAmJlxuXHRcdFx0XHQobmV4dC5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFIHx8IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5leHQpLmRhdGEgIT09ICcnKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGxhc3QgPSBuZXh0O1xuXHRcdFx0XHRuZXh0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5leHQpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5leHQgPT09IG51bGwpIHtcblx0XHRcdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoREVWICYmICFza2lwX3dhcm5pbmcpIHtcblx0XHRcdFx0Y2hlY2tfaGFzaCgvKiogQHR5cGUge0VsZW1lbnR9ICovIChuZXh0LnBhcmVudE5vZGUpLCBoYXNoLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIGxhc3QpO1xuXHRcdFx0YW5jaG9yID0gc2V0X2h5ZHJhdGVfbm9kZShuZXh0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaHRtbCA9IHZhbHVlICsgJyc7XG5cdFx0aWYgKHN2ZykgaHRtbCA9IGA8c3ZnPiR7aHRtbH08L3N2Zz5gO1xuXHRcdGVsc2UgaWYgKG1hdGhtbCkgaHRtbCA9IGA8bWF0aD4ke2h0bWx9PC9tYXRoPmA7XG5cblx0XHQvLyBEb24ndCB1c2UgY3JlYXRlX2ZyYWdtZW50X3dpdGhfc2NyaXB0X2Zyb21faHRtbCBoZXJlIGJlY2F1c2UgdGhhdCB3b3VsZCBtZWFuIHNjcmlwdCB0YWdzIGFyZSBleGVjdXRlZC5cblx0XHQvLyBAaHRtbCBpcyBiYXNpY2FsbHkgYC5pbm5lckhUTUwgPSAuLi5gIGFuZCB0aGF0IGRvZXNuJ3QgZXhlY3V0ZSBzY3JpcHRzIGVpdGhlciBkdWUgdG8gc2VjdXJpdHkgcmVhc29ucy5cblx0XHQvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnQgfCBFbGVtZW50fSAqL1xuXHRcdHZhciBub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKTtcblxuXHRcdGlmIChzdmcgfHwgbWF0aG1sKSB7XG5cdFx0XHRub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKTtcblx0XHR9XG5cblx0XHRhc3NpZ25fbm9kZXMoXG5cdFx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSksXG5cdFx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5vZGUubGFzdENoaWxkKVxuXHRcdCk7XG5cblx0XHRpZiAoc3ZnIHx8IG1hdGhtbCkge1xuXHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChub2RlKSkge1xuXHRcdFx0XHRhbmNob3IuYmVmb3JlKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmNob3IuYmVmb3JlKG5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG4iLCJpbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtDb21tZW50fSBhbmNob3JcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHNsb3RfcHJvcHNcbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBDb21tZW50KSA9PiB2b2lkKX0gZmFsbGJhY2tfZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsb3QoYW5jaG9yLCAkJHByb3BzLCBuYW1lLCBzbG90X3Byb3BzLCBmYWxsYmFja19mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgc2xvdF9mbiA9ICQkcHJvcHMuJCRzbG90cz8uW25hbWVdO1xuXHQvLyBJbnRlcm9wOiBDYW4gdXNlIHNuaXBwZXRzIHRvIGZpbGwgc2xvdHNcblx0dmFyIGlzX2ludGVyb3AgPSBmYWxzZTtcblx0aWYgKHNsb3RfZm4gPT09IHRydWUpIHtcblx0XHRzbG90X2ZuID0gJCRwcm9wc1tuYW1lID09PSAnZGVmYXVsdCcgPyAnY2hpbGRyZW4nIDogbmFtZV07XG5cdFx0aXNfaW50ZXJvcCA9IHRydWU7XG5cdH1cblxuXHRpZiAoc2xvdF9mbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGZhbGxiYWNrX2ZuICE9PSBudWxsKSB7XG5cdFx0XHRmYWxsYmFja19mbihhbmNob3IpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRzbG90X2ZuKGFuY2hvciwgaXNfaW50ZXJvcCA/ICgpID0+IHNsb3RfcHJvcHMgOiBzbG90X3Byb3BzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJvcHNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX3Nsb3RzKHByb3BzKSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59ICovXG5cdGNvbnN0IHNhbml0aXplZCA9IHt9O1xuXHRpZiAocHJvcHMuY2hpbGRyZW4pIHNhbml0aXplZC5kZWZhdWx0ID0gdHJ1ZTtcblx0Zm9yIChjb25zdCBrZXkgaW4gcHJvcHMuJCRzbG90cykge1xuXHRcdHNhbml0aXplZFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gc2FuaXRpemVkO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBTbmlwcGV0IH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCwgRUxFTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgYmxvY2ssIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvblxufSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4uL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGdldF9maXJzdF9jaGlsZCwgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92YWxpZGF0ZS5qcyc7XG5pbXBvcnQgeyBCcmFuY2hNYW5hZ2VyIH0gZnJvbSAnLi9icmFuY2hlcy5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gU25pcHBldEZuXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBTbmlwcGV0Rm4gfCBudWxsIHwgdW5kZWZpbmVkfSBnZXRfc25pcHBldFxuICogQHBhcmFtIHsoKCkgPT4gYW55KVtdfSBhcmdzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuaXBwZXQobm9kZSwgZ2V0X3NuaXBwZXQsIC4uLmFyZ3MpIHtcblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGNvbnN0IHNuaXBwZXQgPSBnZXRfc25pcHBldCgpID8/IG51bGw7XG5cblx0XHRpZiAoREVWICYmIHNuaXBwZXQgPT0gbnVsbCkge1xuXHRcdFx0ZS5pbnZhbGlkX3NuaXBwZXQoKTtcblx0XHR9XG5cblx0XHRicmFuY2hlcy5lbnN1cmUoc25pcHBldCwgc25pcHBldCAmJiAoKGFuY2hvcikgPT4gc25pcHBldChhbmNob3IsIC4uLmFyZ3MpKSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG59XG5cbi8qKlxuICogSW4gZGV2ZWxvcG1lbnQsIHdyYXAgdGhlIHNuaXBwZXQgZnVuY3Rpb24gc28gdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbiwgYW5kIHNvIHRoYXQgdGhlXG4gKiBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0IGlzIHNldCBmb3Igb3duZXJzaGlwIGNoZWNrc1xuICogQHBhcmFtIHthbnl9IGNvbXBvbmVudFxuICogQHBhcmFtIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBfc25pcHBldChjb21wb25lbnQsIGZuKSB7XG5cdGNvbnN0IHNuaXBwZXQgPSAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIG5vZGUsIC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oY29tcG9uZW50KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4obm9kZSwgLi4uYXJncyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24ocHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uKTtcblx0XHR9XG5cdH07XG5cblx0cHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvbihzbmlwcGV0KTtcblxuXHRyZXR1cm4gc25pcHBldDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzbmlwcGV0IHByb2dyYW1tYXRpY2FsbHlcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdfSBQYXJhbXNcbiAqIEBwYXJhbSB7KC4uLnBhcmFtczogR2V0dGVyczxQYXJhbXM+KSA9PiB7XG4gKiAgIHJlbmRlcjogKCkgPT4gc3RyaW5nXG4gKiAgIHNldHVwPzogKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHZvaWQgfCAoKCkgPT4gdm9pZClcbiAqIH19IGZuXG4gKiBAcmV0dXJucyB7U25pcHBldDxQYXJhbXM+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3U25pcHBldChmbikge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB0eXBlcyBhcmUgYSBsaWVcblx0cmV0dXJuICgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gYW5jaG9yLCAvKiogQHR5cGUge0dldHRlcnM8UGFyYW1zPn0gKi8gLi4ucGFyYW1zKSA9PiB7XG5cdFx0dmFyIHNuaXBwZXQgPSBmbiguLi5wYXJhbXMpO1xuXG5cdFx0LyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuXHRcdHZhciBlbGVtZW50O1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0ZWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSk7XG5cdFx0XHRoeWRyYXRlX25leHQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGh0bWwgPSBzbmlwcGV0LnJlbmRlcigpLnRyaW0oKTtcblx0XHRcdHZhciBmcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaHRtbCk7XG5cdFx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGZyYWdtZW50KSk7XG5cblx0XHRcdGlmIChERVYgJiYgKGdldF9uZXh0X3NpYmxpbmcoZWxlbWVudCkgIT09IG51bGwgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSkge1xuXHRcdFx0XHR3LmludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gc25pcHBldC5zZXR1cD8uKGVsZW1lbnQpO1xuXHRcdGFzc2lnbl9ub2RlcyhlbGVtZW50LCBlbGVtZW50KTtcblxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0ZWFyZG93bihyZXN1bHQpO1xuXHRcdH1cblx0fTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlLCBEb20gfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgYmxvY2sgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgQnJhbmNoTWFuYWdlciB9IGZyb20gJy4vYnJhbmNoZXMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBQXG4gKiBAdGVtcGxhdGUgeyhwcm9wczogUCkgPT4gdm9pZH0gQ1xuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gQ30gZ2V0X2NvbXBvbmVudFxuICogQHBhcmFtIHsoYW5jaG9yOiBUZW1wbGF0ZU5vZGUsIGNvbXBvbmVudDogQykgPT4gRG9tIHwgdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudChub2RlLCBnZXRfY29tcG9uZW50LCByZW5kZXJfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIobm9kZSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdHZhciBjb21wb25lbnQgPSBnZXRfY29tcG9uZW50KCkgPz8gbnVsbDtcblx0XHRicmFuY2hlcy5lbnN1cmUoY29tcG9uZW50LCBjb21wb25lbnQgJiYgKCh0YXJnZXQpID0+IHJlbmRlcl9mbih0YXJnZXQsIGNvbXBvbmVudCkpKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRklMRU5BTUUsIE5BTUVTUEFDRV9TVkcgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX3RleHQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgYmxvY2ssIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNldF9zaG91bGRfaW50cm8gfSBmcm9tICcuLi8uLi9yZW5kZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9lYWNoX2l0ZW0sIHNldF9jdXJyZW50X2VhY2hfaXRlbSB9IGZyb20gJy4vZWFjaC5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgZGV2X3N0YWNrIH0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCwgRUxFTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgaXNfcmF3X3RleHRfZWxlbWVudCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IEJyYW5jaE1hbmFnZXIgfSBmcm9tICcuL2JyYW5jaGVzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0NvbW1lbnQgfCBFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gZ2V0X3RhZ1xuICogQHBhcmFtIHtib29sZWFufSBpc19zdmdcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgKChlbGVtZW50OiBFbGVtZW50LCBhbmNob3I6IE5vZGUgfCBudWxsKSA9PiB2b2lkKX0gcmVuZGVyX2ZuLFxuICogQHBhcmFtIHt1bmRlZmluZWQgfCAoKCkgPT4gc3RyaW5nKX0gZ2V0X25hbWVzcGFjZVxuICogQHBhcmFtIHt1bmRlZmluZWQgfCBbbnVtYmVyLCBudW1iZXJdfSBsb2NhdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50KG5vZGUsIGdldF90YWcsIGlzX3N2ZywgcmVuZGVyX2ZuLCBnZXRfbmFtZXNwYWNlLCBsb2NhdGlvbikge1xuXHRsZXQgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgZmlsZW5hbWUgPSBERVYgJiYgbG9jYXRpb24gJiYgY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uW0ZJTEVOQU1FXTtcblxuXHQvKiogQHR5cGUge251bGwgfCBFbGVtZW50fSAqL1xuXHR2YXIgZWxlbWVudCA9IG51bGw7XG5cblx0aWYgKGh5ZHJhdGluZyAmJiBoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuXHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZSk7XG5cblx0LyoqXG5cdCAqIFRoZSBrZXllZCBgeyNlYWNoIC4uLn1gIGl0ZW0gYmxvY2ssIGlmIGFueSwgdGhhdCB0aGlzIGVsZW1lbnQgaXMgaW5zaWRlLlxuXHQgKiBXZSB0cmFjayB0aGlzIHNvIHdlIGNhbiBzZXQgaXQgd2hlbiBjaGFuZ2luZyB0aGUgZWxlbWVudCwgYWxsb3dpbmcgYW55XG5cdCAqIGBhbmltYXRlOmAgZGlyZWN0aXZlIHRvIGJpbmQgaXRzZWxmIHRvIHRoZSBjb3JyZWN0IGJsb2NrXG5cdCAqL1xuXHR2YXIgZWFjaF9pdGVtX2Jsb2NrID0gY3VycmVudF9lYWNoX2l0ZW07XG5cblx0dmFyIGJyYW5jaGVzID0gbmV3IEJyYW5jaE1hbmFnZXIoYW5jaG9yLCBmYWxzZSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGNvbnN0IG5leHRfdGFnID0gZ2V0X3RhZygpIHx8IG51bGw7XG5cdFx0dmFyIG5zID0gZ2V0X25hbWVzcGFjZSA/IGdldF9uYW1lc3BhY2UoKSA6IGlzX3N2ZyB8fCBuZXh0X3RhZyA9PT0gJ3N2ZycgPyBOQU1FU1BBQ0VfU1ZHIDogbnVsbDtcblxuXHRcdGlmIChuZXh0X3RhZyA9PT0gbnVsbCkge1xuXHRcdFx0YnJhbmNoZXMuZW5zdXJlKG51bGwsIG51bGwpO1xuXHRcdFx0c2V0X3Nob3VsZF9pbnRybyh0cnVlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRicmFuY2hlcy5lbnN1cmUobmV4dF90YWcsIChhbmNob3IpID0+IHtcblx0XHRcdC8vIFNlZSBleHBsYW5hdGlvbiBvZiBgZWFjaF9pdGVtX2Jsb2NrYCBhYm92ZVxuXHRcdFx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHRcdFx0c2V0X2N1cnJlbnRfZWFjaF9pdGVtKGVhY2hfaXRlbV9ibG9jayk7XG5cblx0XHRcdGlmIChuZXh0X3RhZykge1xuXHRcdFx0XHRlbGVtZW50ID0gaHlkcmF0aW5nXG5cdFx0XHRcdFx0PyAvKiogQHR5cGUge0VsZW1lbnR9ICovIChlbGVtZW50KVxuXHRcdFx0XHRcdDogbnNcblx0XHRcdFx0XHRcdD8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCBuZXh0X3RhZylcblx0XHRcdFx0XHRcdDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuZXh0X3RhZyk7XG5cblx0XHRcdFx0aWYgKERFViAmJiBsb2NhdGlvbikge1xuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG5cdFx0XHRcdFx0XHRwYXJlbnQ6IGRldl9zdGFjayxcblx0XHRcdFx0XHRcdGxvYzoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiBmaWxlbmFtZSxcblx0XHRcdFx0XHRcdFx0bGluZTogbG9jYXRpb25bMF0sXG5cdFx0XHRcdFx0XHRcdGNvbHVtbjogbG9jYXRpb25bMV1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJfZm4pIHtcblx0XHRcdFx0XHRpZiAoaHlkcmF0aW5nICYmIGlzX3Jhd190ZXh0X2VsZW1lbnQobmV4dF90YWcpKSB7XG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IGh5ZHJhdGlvbiBnbGl0Y2hlc1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJykpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIGh5ZHJhdGluZywgdXNlIHRoZSBleGlzdGluZyBzc3IgY29tbWVudCBhcyB0aGUgYW5jaG9yIHNvIHRoYXQgdGhlXG5cdFx0XHRcdFx0Ly8gaW5uZXIgb3BlbiBhbmQgY2xvc2UgbWV0aG9kcyBjYW4gcGljayB1cCB0aGUgZXhpc3Rpbmcgbm9kZXMgY29ycmVjdGx5XG5cdFx0XHRcdFx0dmFyIGNoaWxkX2FuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHRcdFx0XHRoeWRyYXRpbmcgPyBnZXRfZmlyc3RfY2hpbGQoZWxlbWVudCkgOiBlbGVtZW50LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZF9hbmNob3IgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGNoaWxkX2FuY2hvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYGNoaWxkX2FuY2hvcmAgaXMgdW5kZWZpbmVkIGlmIHRoaXMgaXMgYSB2b2lkIGVsZW1lbnQsIGJ1dCB3ZSBzdGlsbFxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gY2FsbCBgcmVuZGVyX2ZuYCBpbiBvcmRlciB0byBydW4gYWN0aW9ucyBldGMuIElmIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gY29udGFpbnMgY2hpbGRyZW4sIGl0J3MgYSB1c2VyIGVycm9yICh3aGljaCBpcyB3YXJuZWQgb24gZWxzZXdoZXJlKVxuXHRcdFx0XHRcdC8vIGFuZCB0aGUgRE9NIHdpbGwgYmUgc2lsZW50bHkgZGlzY2FyZGVkXG5cdFx0XHRcdFx0cmVuZGVyX2ZuKGVsZW1lbnQsIGNoaWxkX2FuY2hvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3ZSBkbyB0aGlzIGFmdGVyIGNhbGxpbmcgYHJlbmRlcl9mbmAgc28gdGhhdCBjaGlsZCBlZmZlY3RzIGRvbid0IG92ZXJyaWRlIGBub2Rlcy5lbmRgXG5cdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gZWxlbWVudDtcblxuXHRcdFx0XHRhbmNob3IuYmVmb3JlKGVsZW1lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRfY3VycmVudF9lYWNoX2l0ZW0ocHJldmlvdXNfZWFjaF9pdGVtKTtcblxuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyByZXZlcnQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYWZ0ZXIgdGhlIGVmZmVjdCBoYXMgYmVlbiBjcmVhdGVkXG5cdFx0c2V0X3Nob3VsZF9pbnRybyh0cnVlKTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRpZiAobmV4dF90YWcpIHtcblx0XHRcdFx0Ly8gaWYgd2UncmUgaW4gdGhpcyBjYWxsYmFjayBiZWNhdXNlIHdlJ3JlIHJlLXJ1bm5pbmcgdGhlIGVmZmVjdCxcblx0XHRcdFx0Ly8gZGlzYWJsZSBpbnRyb3MgKHVubGVzcyBubyBlbGVtZW50IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQpXG5cdFx0XHRcdHNldF9zaG91bGRfaW50cm8oZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdHNldF9zaG91bGRfaW50cm8odHJ1ZSk7XG5cdH0pO1xuXG5cdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIGVmZmVjdCwgZGVzdHJveV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuXG4vLyBUT0RPIGluIDYuMCBvciA3LjAsIHdoZW4gd2UgcmVtb3ZlIGxlZ2FjeSBtb2RlLCB3ZSBjYW4gc2ltcGxpZnkgdGhpcyBieVxuLy8gZ2V0dGluZyByaWQgb2YgdGhlIGJsb2NrL2JyYW5jaCBzdHVmZiBhbmQganVzdCBsZXR0aW5nIHRoZSBlZmZlY3QgcmlwLlxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC8xNTk2MlxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiAobm9kZTogRWxlbWVudCkgPT4gdm9pZH0gZ2V0X2ZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2gobm9kZSwgZ2V0X2ZuKSB7XG5cdC8qKiBAdHlwZSB7ZmFsc2UgfCB1bmRlZmluZWQgfCAoKG5vZGU6IEVsZW1lbnQpID0+IHZvaWQpfSAqL1xuXHR2YXIgZm4gPSB1bmRlZmluZWQ7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0aWYgKGZuICE9PSAoZm4gPSBnZXRfZm4oKSkpIHtcblx0XHRcdGlmIChlKSB7XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGUpO1xuXHRcdFx0XHRlID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdGUgPSBicmFuY2goKCkgPT4ge1xuXHRcdFx0XHRcdGVmZmVjdCgoKSA9PiAvKiogQHR5cGUgeyhub2RlOiBFbGVtZW50KSA9PiB2b2lkfSAqLyAoZm4pKG5vZGUpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IHsgZXNjYXBlX2h0bWwgfSBmcm9tICcuLi8uLi9lc2NhcGluZy5qcyc7XG5pbXBvcnQgeyBjbHN4IGFzIF9jbHN4IH0gZnJvbSAnY2xzeCc7XG5cbi8qKlxuICogYDxkaXYgdHJhbnNsYXRlPXtmYWxzZX0+YCBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYDxkaXYgdHJhbnNsYXRlPVwibm9cIj5gIGFuZCBfbm90X1xuICogYDxkaXYgdHJhbnNsYXRlPVwiZmFsc2VcIj5gLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIGA8ZGl2IHRyYW5zbGF0ZT1cInllc1wiPmAuIFRoZXJlXG4gKiBtYXkgYmUgb3RoZXIgb2RkIGNhc2VzIHRoYXQgbmVlZCB0byBiZSBhZGRlZCB0byB0aGlzIGxpc3QgaW4gZnV0dXJlXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTWFwPGFueSwgc3RyaW5nPj59XG4gKi9cbmNvbnN0IHJlcGxhY2VtZW50cyA9IHtcblx0dHJhbnNsYXRlOiBuZXcgTWFwKFtcblx0XHRbdHJ1ZSwgJ3llcyddLFxuXHRcdFtmYWxzZSwgJ25vJ11cblx0XSlcbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc19ib29sZWFuXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUsIGlzX2Jvb2xlYW4gPSBmYWxzZSkge1xuXHQvLyBhdHRyaWJ1dGUgaGlkZGVuIGZvciB2YWx1ZXMgb3RoZXIgdGhhbiBcInVudGlsLWZvdW5kXCIgYmVoYXZlcyBsaWtlIGEgYm9vbGVhbiBhdHRyaWJ1dGVcblx0aWYgKG5hbWUgPT09ICdoaWRkZW4nICYmIHZhbHVlICE9PSAndW50aWwtZm91bmQnKSB7XG5cdFx0aXNfYm9vbGVhbiA9IHRydWU7XG5cdH1cblx0aWYgKHZhbHVlID09IG51bGwgfHwgKCF2YWx1ZSAmJiBpc19ib29sZWFuKSkgcmV0dXJuICcnO1xuXHRjb25zdCBub3JtYWxpemVkID0gKG5hbWUgaW4gcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1tuYW1lXS5nZXQodmFsdWUpKSB8fCB2YWx1ZTtcblx0Y29uc3QgYXNzaWdubWVudCA9IGlzX2Jvb2xlYW4gPyAnJyA6IGA9XCIke2VzY2FwZV9odG1sKG5vcm1hbGl6ZWQsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKipcbiAqIFNtYWxsIHdyYXBwZXIgYXJvdW5kIGNsc3ggdG8gcHJlc2VydmUgU3ZlbHRlJ3MgKHdlaXJkKSBoYW5kbGluZyBvZiBmYWxzeSB2YWx1ZXMuXG4gKiBUT0RPIFN2ZWx0ZSA2IHJldmlzaXQgdGhpcywgYW5kIGxpa2VseSB0dXJuIGFsbCBmYWxzeSB2YWx1ZXMgaW50byB0aGUgZW1wdHkgc3RyaW5nICh3aGF0IGNsc3ggYWxzbyBkb2VzKVxuICogQHBhcmFtICB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xzeCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBfY2xzeCh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlID8/ICcnO1xuXHR9XG59XG5cbmNvbnN0IHdoaXRlc3BhY2UgPSBbLi4uJyBcXHRcXG5cXHJcXGZcXHUwMGEwXFx1MDAwYlxcdWZlZmYnXTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW2hhc2hdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSBbZGlyZWN0aXZlc11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fY2xhc3ModmFsdWUsIGhhc2gsIGRpcmVjdGl2ZXMpIHtcblx0dmFyIGNsYXNzbmFtZSA9IHZhbHVlID09IG51bGwgPyAnJyA6ICcnICsgdmFsdWU7XG5cblx0aWYgKGhhc2gpIHtcblx0XHRjbGFzc25hbWUgPSBjbGFzc25hbWUgPyBjbGFzc25hbWUgKyAnICcgKyBoYXNoIDogaGFzaDtcblx0fVxuXG5cdGlmIChkaXJlY3RpdmVzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGRpcmVjdGl2ZXMpIHtcblx0XHRcdGlmIChkaXJlY3RpdmVzW2tleV0pIHtcblx0XHRcdFx0Y2xhc3NuYW1lID0gY2xhc3NuYW1lID8gY2xhc3NuYW1lICsgJyAnICsga2V5IDoga2V5O1xuXHRcdFx0fSBlbHNlIGlmIChjbGFzc25hbWUubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuXHRcdFx0XHR2YXIgYSA9IDA7XG5cblx0XHRcdFx0d2hpbGUgKChhID0gY2xhc3NuYW1lLmluZGV4T2Yoa2V5LCBhKSkgPj0gMCkge1xuXHRcdFx0XHRcdHZhciBiID0gYSArIGxlbjtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdChhID09PSAwIHx8IHdoaXRlc3BhY2UuaW5jbHVkZXMoY2xhc3NuYW1lW2EgLSAxXSkpICYmXG5cdFx0XHRcdFx0XHQoYiA9PT0gY2xhc3NuYW1lLmxlbmd0aCB8fCB3aGl0ZXNwYWNlLmluY2x1ZGVzKGNsYXNzbmFtZVtiXSkpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjbGFzc25hbWUgPSAoYSA9PT0gMCA/ICcnIDogY2xhc3NuYW1lLnN1YnN0cmluZygwLCBhKSkgKyBjbGFzc25hbWUuc3Vic3RyaW5nKGIgKyAxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNsYXNzbmFtZSA9PT0gJycgPyBudWxsIDogY2xhc3NuYW1lO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsYW55Pn0gc3R5bGVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGltcG9ydGFudFxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHN0eWxlcywgaW1wb3J0YW50ID0gZmFsc2UpIHtcblx0dmFyIHNlcGFyYXRvciA9IGltcG9ydGFudCA/ICcgIWltcG9ydGFudDsnIDogJzsnO1xuXHR2YXIgY3NzID0gJyc7XG5cblx0Zm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuXHRcdHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuXHRcdGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJykge1xuXHRcdFx0Y3NzICs9ICcgJyArIGtleSArICc6ICcgKyB2YWx1ZSArIHNlcGFyYXRvcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3NzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b19jc3NfbmFtZShuYW1lKSB7XG5cdGlmIChuYW1lWzBdICE9PSAnLScgfHwgbmFtZVsxXSAhPT0gJy0nKSB7XG5cdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRyZXR1cm4gbmFtZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55PiB8IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+XX0gW3N0eWxlc11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fc3R5bGUodmFsdWUsIHN0eWxlcykge1xuXHRpZiAoc3R5bGVzKSB7XG5cdFx0dmFyIG5ld19zdHlsZSA9ICcnO1xuXG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLGFueT4gfCB1bmRlZmluZWR9ICovXG5cdFx0dmFyIG5vcm1hbF9zdHlsZXM7XG5cblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsYW55PiB8IHVuZGVmaW5lZH0gKi9cblx0XHR2YXIgaW1wb3J0YW50X3N0eWxlcztcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcblx0XHRcdG5vcm1hbF9zdHlsZXMgPSBzdHlsZXNbMF07XG5cdFx0XHRpbXBvcnRhbnRfc3R5bGVzID0gc3R5bGVzWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxfc3R5bGVzID0gc3R5bGVzO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpXG5cdFx0XHRcdC5yZXBsYWNlQWxsKC9cXHMqXFwvXFwqLio/XFwqXFwvXFxzKi9nLCAnJylcblx0XHRcdFx0LnRyaW0oKTtcblxuXHRcdFx0LyoqIEB0eXBlIHtib29sZWFuIHwgJ1wiJyB8IFwiJ1wifSAqL1xuXHRcdFx0dmFyIGluX3N0ciA9IGZhbHNlO1xuXHRcdFx0dmFyIGluX2FwbyA9IDA7XG5cdFx0XHR2YXIgaW5fY29tbWVudCA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgcmVzZXJ2ZWRfbmFtZXMgPSBbXTtcblxuXHRcdFx0aWYgKG5vcm1hbF9zdHlsZXMpIHtcblx0XHRcdFx0cmVzZXJ2ZWRfbmFtZXMucHVzaCguLi5PYmplY3Qua2V5cyhub3JtYWxfc3R5bGVzKS5tYXAodG9fY3NzX25hbWUpKTtcblx0XHRcdH1cblx0XHRcdGlmIChpbXBvcnRhbnRfc3R5bGVzKSB7XG5cdFx0XHRcdHJlc2VydmVkX25hbWVzLnB1c2goLi4uT2JqZWN0LmtleXMoaW1wb3J0YW50X3N0eWxlcykubWFwKHRvX2Nzc19uYW1lKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydF9pbmRleCA9IDA7XG5cdFx0XHR2YXIgbmFtZV9pbmRleCA9IC0xO1xuXG5cdFx0XHRjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gdmFsdWVbaV07XG5cblx0XHRcdFx0aWYgKGluX2NvbW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoYyA9PT0gJy8nICYmIHZhbHVlW2kgLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0XHRpbl9jb21tZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGluX3N0cikge1xuXHRcdFx0XHRcdGlmIChpbl9zdHIgPT09IGMpIHtcblx0XHRcdFx0XHRcdGluX3N0ciA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnLycgJiYgdmFsdWVbaSArIDFdID09PSAnKicpIHtcblx0XHRcdFx0XHRpbl9jb21tZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSB7XG5cdFx0XHRcdFx0aW5fc3RyID0gYztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnKCcpIHtcblx0XHRcdFx0XHRpbl9hcG8rKztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnKScpIHtcblx0XHRcdFx0XHRpbl9hcG8tLTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaW5fY29tbWVudCAmJiBpbl9zdHIgPT09IGZhbHNlICYmIGluX2FwbyA9PT0gMCkge1xuXHRcdFx0XHRcdGlmIChjID09PSAnOicgJiYgbmFtZV9pbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdG5hbWVfaW5kZXggPSBpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJzsnIHx8IGkgPT09IGxlbiAtIDEpIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lX2luZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbmFtZSA9IHRvX2Nzc19uYW1lKHZhbHVlLnN1YnN0cmluZyhzdGFydF9pbmRleCwgbmFtZV9pbmRleCkudHJpbSgpKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXJlc2VydmVkX25hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGMgIT09ICc7Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaSkudHJpbSgpO1xuXHRcdFx0XHRcdFx0XHRcdG5ld19zdHlsZSArPSAnICcgKyBwcm9wZXJ0eSArICc7Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydF9pbmRleCA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0bmFtZV9pbmRleCA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub3JtYWxfc3R5bGVzKSB7XG5cdFx0XHRuZXdfc3R5bGUgKz0gYXBwZW5kX3N0eWxlcyhub3JtYWxfc3R5bGVzKTtcblx0XHR9XG5cblx0XHRpZiAoaW1wb3J0YW50X3N0eWxlcykge1xuXHRcdFx0bmV3X3N0eWxlICs9IGFwcGVuZF9zdHlsZXMoaW1wb3J0YW50X3N0eWxlcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0bmV3X3N0eWxlID0gbmV3X3N0eWxlLnRyaW0oKTtcblx0XHRyZXR1cm4gbmV3X3N0eWxlID09PSAnJyA/IG51bGwgOiBuZXdfc3R5bGU7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBTdHJpbmcodmFsdWUpO1xufVxuIiwiaW1wb3J0IHsgdG9fY2xhc3MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudW1iZXJ9IGlzX2h0bWxcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW3ByZXZfY2xhc3Nlc11cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW25leHRfY2xhc3Nlc11cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jbGFzcyhkb20sIGlzX2h0bWwsIHZhbHVlLCBoYXNoLCBwcmV2X2NsYXNzZXMsIG5leHRfY2xhc3Nlcykge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdHZhciBwcmV2ID0gZG9tLl9fY2xhc3NOYW1lO1xuXG5cdGlmIChcblx0XHRoeWRyYXRpbmcgfHxcblx0XHRwcmV2ICE9PSB2YWx1ZSB8fFxuXHRcdHByZXYgPT09IHVuZGVmaW5lZCAvLyBmb3IgZWRnZSBjYXNlIG9mIGBjbGFzcz17dW5kZWZpbmVkfWBcblx0KSB7XG5cdFx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoLCBuZXh0X2NsYXNzZXMpO1xuXG5cdFx0aWYgKCFoeWRyYXRpbmcgfHwgbmV4dF9jbGFzc19uYW1lICE9PSBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpKSB7XG5cdFx0XHQvLyBSZW1vdmluZyB0aGUgYXR0cmlidXRlIHdoZW4gdGhlIHZhbHVlIGlzIG9ubHkgYW4gZW1wdHkgc3RyaW5nIGNhdXNlc1xuXHRcdFx0Ly8gcGVyZm9ybWFuY2UgaXNzdWVzIHZzIHNpbXBseSBtYWtpbmcgdGhlIGNsYXNzTmFtZSBhbiBlbXB0eSBzdHJpbmcuIFNvXG5cdFx0XHQvLyB3ZSBzaG91bGQgb25seSByZW1vdmUgdGhlIGNsYXNzIGlmIHRoZSB2YWx1ZSBpcyBudWxsaXNoXG5cdFx0XHQvLyBhbmQgdGhlcmUgbm8gaGFzaC9kaXJlY3RpdmVzIDpcblx0XHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT0gbnVsbCkge1xuXHRcdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdFx0fSBlbHNlIGlmIChpc19odG1sKSB7XG5cdFx0XHRcdGRvbS5jbGFzc05hbWUgPSBuZXh0X2NsYXNzX25hbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IHZhbHVlO1xuXHR9IGVsc2UgaWYgKG5leHRfY2xhc3NlcyAmJiBwcmV2X2NsYXNzZXMgIT09IG5leHRfY2xhc3Nlcykge1xuXHRcdGZvciAodmFyIGtleSBpbiBuZXh0X2NsYXNzZXMpIHtcblx0XHRcdHZhciBpc19wcmVzZW50ID0gISFuZXh0X2NsYXNzZXNba2V5XTtcblxuXHRcdFx0aWYgKHByZXZfY2xhc3NlcyA9PSBudWxsIHx8IGlzX3ByZXNlbnQgIT09ICEhcHJldl9jbGFzc2VzW2tleV0pIHtcblx0XHRcdFx0ZG9tLmNsYXNzTGlzdC50b2dnbGUoa2V5LCBpc19wcmVzZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV4dF9jbGFzc2VzO1xufVxuIiwiaW1wb3J0IHsgdG9fc3R5bGUgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gZG9tXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gbmV4dFxuICogQHBhcmFtIHtzdHJpbmd9IFtwcmlvcml0eV1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlX3N0eWxlcyhkb20sIHByZXYgPSB7fSwgbmV4dCwgcHJpb3JpdHkpIHtcblx0Zm9yICh2YXIga2V5IGluIG5leHQpIHtcblx0XHR2YXIgdmFsdWUgPSBuZXh0W2tleV07XG5cblx0XHRpZiAocHJldltrZXldICE9PSB2YWx1ZSkge1xuXHRcdFx0aWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9tLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIHByaW9yaXR5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IGRvbVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgW1JlY29yZDxzdHJpbmcsIGFueT4sIFJlY29yZDxzdHJpbmcsIGFueT5dfSBbcHJldl9zdHlsZXNdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCBbUmVjb3JkPHN0cmluZywgYW55PiwgUmVjb3JkPHN0cmluZywgYW55Pl19IFtuZXh0X3N0eWxlc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdHlsZShkb20sIHZhbHVlLCBwcmV2X3N0eWxlcywgbmV4dF9zdHlsZXMpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgcHJldiA9IGRvbS5fX3N0eWxlO1xuXG5cdGlmIChoeWRyYXRpbmcgfHwgcHJldiAhPT0gdmFsdWUpIHtcblx0XHR2YXIgbmV4dF9zdHlsZV9hdHRyID0gdG9fc3R5bGUodmFsdWUsIG5leHRfc3R5bGVzKTtcblxuXHRcdGlmICghaHlkcmF0aW5nIHx8IG5leHRfc3R5bGVfYXR0ciAhPT0gZG9tLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuXHRcdFx0aWYgKG5leHRfc3R5bGVfYXR0ciA9PSBudWxsKSB7XG5cdFx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG5leHRfc3R5bGVfYXR0cjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZG9tLl9fc3R5bGUgPSB2YWx1ZTtcblx0fSBlbHNlIGlmIChuZXh0X3N0eWxlcykge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG5leHRfc3R5bGVzKSkge1xuXHRcdFx0dXBkYXRlX3N0eWxlcyhkb20sIHByZXZfc3R5bGVzPy5bMF0sIG5leHRfc3R5bGVzWzBdKTtcblx0XHRcdHVwZGF0ZV9zdHlsZXMoZG9tLCBwcmV2X3N0eWxlcz8uWzFdLCBuZXh0X3N0eWxlc1sxXSwgJ2ltcG9ydGFudCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cGRhdGVfc3R5bGVzKGRvbSwgcHJldl9zdHlsZXMsIG5leHRfc3R5bGVzKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV4dF9zdHlsZXM7XG59XG4iLCJpbXBvcnQgeyBlZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGlzX2FycmF5IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGN1cnJlbnRfYmF0Y2gsIHByZXZpb3VzX2JhdGNoIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoaXMgaXMgYSBtdWx0aXBsZSBzZWxlY3QpXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1vdW50aW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nID0gZmFsc2UpIHtcblx0aWYgKHNlbGVjdC5tdWx0aXBsZSkge1xuXHRcdC8vIElmIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBrZWVwIHRoZSBzZWxlY3Rpb24gYXMgaXNcblx0XHRpZiAodmFsdWUgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm90IGFuIGFycmF5LCB3YXJuIGFuZCBrZWVwIHRoZSBzZWxlY3Rpb24gYXMgaXNcblx0XHRpZiAoIWlzX2FycmF5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHcuc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWUoKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG5cdFx0Zm9yICh2YXIgb3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmNsdWRlcyhnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbikpO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdGZvciAob3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0dmFyIG9wdGlvbl92YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUob3B0aW9uKTtcblx0XHRpZiAoaXMob3B0aW9uX3ZhbHVlLCB2YWx1ZSkpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgaWYgYHZhbHVlYCBpcyBnaXZlbixcbiAqIGFuZCB0aGVuIHNldHMgdXAgYSBtdXRhdGlvbiBvYnNlcnZlciB0byBzeW5jIHRoZVxuICogY3VycmVudCBzZWxlY3Rpb24gdG8gdGhlIGRvbSB3aGVuIGl0IGNoYW5nZXMuIFN1Y2hcbiAqIGNoYW5nZXMgY291bGQgZm9yIGV4YW1wbGUgb2NjdXIgd2hlbiBvcHRpb25zIGFyZVxuICogaW5zaWRlIGFuIGAjZWFjaGAgYmxvY2suXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfc2VsZWN0KHNlbGVjdCkge1xuXHR2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCBzZWxlY3QuX192YWx1ZSk7XG5cdFx0Ly8gRGVsaWJlcmF0ZWx5IGRvbid0IHVwZGF0ZSB0aGUgcG90ZW50aWFsIGJpbmRpbmcgdmFsdWUsXG5cdFx0Ly8gdGhlIG1vZGVsIHNob3VsZCBiZSBwcmVzZXJ2ZWQgdW5sZXNzIGV4cGxpY2l0bHkgY2hhbmdlZFxuXHR9KTtcblxuXHRvYnNlcnZlci5vYnNlcnZlKHNlbGVjdCwge1xuXHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCBjaGFuZ2VzXG5cdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdHN1YnRyZWU6IHRydWUsIC8vIGJlY2F1c2Ugb2YgPG9wdGdyb3VwPlxuXHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCB2YWx1ZSBhdHRyaWJ1dGUgY2hhbmdlc1xuXHRcdC8vIChkb2Vzbid0IGdldCBub3RpZmllZCBvZiBzZWxlY3QgdmFsdWUgY2hhbmdlcyxcblx0XHQvLyBiZWNhdXNlIHRoYXQgcHJvcGVydHkgaXMgbm90IHJlZmxlY3RlZCBhcyBhbiBhdHRyaWJ1dGUpXG5cdFx0YXR0cmlidXRlczogdHJ1ZSxcblx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFsndmFsdWUnXVxuXHR9KTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfc2VsZWN0X3ZhbHVlKHNlbGVjdCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGJhdGNoZXMgPSBuZXcgV2Vha1NldCgpO1xuXHR2YXIgbW91bnRpbmcgPSB0cnVlO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoc2VsZWN0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHF1ZXJ5ID0gaXNfcmVzZXQgPyAnW3NlbGVjdGVkXScgOiAnOmNoZWNrZWQnO1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bn0gKi9cblx0XHR2YXIgdmFsdWU7XG5cblx0XHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0XHR2YWx1ZSA9IFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZ2V0X29wdGlvbl92YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9XG5cdFx0XHRcdHNlbGVjdC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSA/P1xuXHRcdFx0XHQvLyB3aWxsIGZhbGwgYmFjayB0byBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uIGlmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZFxuXHRcdFx0XHRzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uOm5vdChbZGlzYWJsZWRdKScpO1xuXHRcdFx0dmFsdWUgPSBzZWxlY3RlZF9vcHRpb24gJiYgZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSk7XG5cblx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0YmF0Y2hlcy5hZGQoY3VycmVudF9iYXRjaCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBOZWVkcyB0byBiZSBhbiBlZmZlY3QsIG5vdCBhIHJlbmRlcl9lZmZlY3QsIHNvIHRoYXQgaW4gY2FzZSBvZiBlYWNoIGxvb3BzIHRoZSBsb2dpYyBydW5zIGFmdGVyIHRoZSBlYWNoIGJsb2NrIGhhcyB1cGRhdGVkXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHRpZiAoc2VsZWN0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG5cdFx0XHQvLyB3ZSBuZWVkIGJvdGgsIGJlY2F1c2UgaW4gbm9uLWFzeW5jIG1vZGUsIHJlbmRlciBlZmZlY3RzIHJ1biBiZWZvcmUgcHJldmlvdXNfYmF0Y2ggaXMgc2V0XG5cdFx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAocHJldmlvdXNfYmF0Y2ggPz8gY3VycmVudF9iYXRjaCk7XG5cblx0XHRcdC8vIERvbid0IHVwZGF0ZSB0aGUgPHNlbGVjdD4gaWYgaXQgaXMgZm9jdXNlZC4gV2UgY2FuIGdldCBoZXJlIGlmLCBmb3IgZXhhbXBsZSxcblx0XHRcdC8vIGFuIHVwZGF0ZSBpcyBkZWZlcnJlZCBiZWNhdXNlIG9mIGFzeW5jIHdvcmsgZGVwZW5kaW5nIG9uIHRoZSBzZWxlY3Q6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gPHNlbGVjdCBiaW5kOnZhbHVlPXtzZWxlY3RlZH0+Li4uPC9zZWxlY3Q+XG5cdFx0XHQvLyA8cD57YXdhaXQgZmluZChzZWxlY3RlZCl9PC9wPlxuXHRcdFx0aWYgKGJhdGNoZXMuaGFzKGJhdGNoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZyk7XG5cblx0XHQvLyBNb3VudGluZyBhbmQgdmFsdWUgdW5kZWZpbmVkIC0+IHRha2Ugc2VsZWN0aW9uIGZyb20gZG9tXG5cdFx0aWYgKG1vdW50aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpO1xuXHRcdFx0aWYgKHNlbGVjdGVkX29wdGlvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUoc2VsZWN0ZWRfb3B0aW9uKTtcblx0XHRcdFx0c2V0KHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c2VsZWN0Ll9fdmFsdWUgPSB2YWx1ZTtcblx0XHRtb3VudGluZyA9IGZhbHNlO1xuXHR9KTtcblxuXHRpbml0X3NlbGVjdChzZWxlY3QpO1xufVxuXG4vKiogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gb3B0aW9uICovXG5mdW5jdGlvbiBnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbikge1xuXHQvLyBfX3ZhbHVlIG9ubHkgZXhpc3RzIGlmIHRoZSA8b3B0aW9uPiBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGVcblx0aWYgKCdfX3ZhbHVlJyBpbiBvcHRpb24pIHtcblx0XHRyZXR1cm4gb3B0aW9uLl9fdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG9wdGlvbi52YWx1ZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBoeWRyYXRpbmcsIHNldF9oeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3JzLCBnZXRfcHJvdG90eXBlX29mIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ldmVudCwgZGVsZWdhdGUgfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgeyBhZGRfZm9ybV9yZXNldF9saXN0ZW5lciwgYXV0b2ZvY3VzIH0gZnJvbSAnLi9taXNjLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgTE9BRElOR19BVFRSX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IGlzX2NhcHR1cmVfZXZlbnQsIGNhbl9kZWxlZ2F0ZV9ldmVudCwgbm9ybWFsaXplX2F0dHJpYnV0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0Z2V0LFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGF0dGFjaCB9IGZyb20gJy4vYXR0YWNobWVudHMuanMnO1xuaW1wb3J0IHsgY2xzeCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IHNldF9jbGFzcyB9IGZyb20gJy4vY2xhc3MuanMnO1xuaW1wb3J0IHsgc2V0X3N0eWxlIH0gZnJvbSAnLi9zdHlsZS5qcyc7XG5pbXBvcnQgeyBBVFRBQ0hNRU5UX0tFWSwgTkFNRVNQQUNFX0hUTUwsIFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYmxvY2ssIGJyYW5jaCwgZGVzdHJveV9lZmZlY3QsIGVmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBpbml0X3NlbGVjdCwgc2VsZWN0X29wdGlvbiB9IGZyb20gJy4vYmluZGluZ3Mvc2VsZWN0LmpzJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2FzeW5jLmpzJztcblxuZXhwb3J0IGNvbnN0IENMQVNTID0gU3ltYm9sKCdjbGFzcycpO1xuZXhwb3J0IGNvbnN0IFNUWUxFID0gU3ltYm9sKCdzdHlsZScpO1xuXG5jb25zdCBJU19DVVNUT01fRUxFTUVOVCA9IFN5bWJvbCgnaXMgY3VzdG9tIGVsZW1lbnQnKTtcbmNvbnN0IElTX0hUTUwgPSBTeW1ib2woJ2lzIGh0bWwnKTtcblxuLyoqXG4gKiBUaGUgdmFsdWUvY2hlY2tlZCBhdHRyaWJ1dGUgaW4gdGhlIHRlbXBsYXRlIGFjdHVhbGx5IGNvcnJlc3BvbmRzIHRvIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHksIHNvIHdlIG5lZWRcbiAqIHRvIHJlbW92ZSBpdCB1cG9uIGh5ZHJhdGlvbiB0byBhdm9pZCBhIGJ1ZyB3aGVuIHNvbWVvbmUgcmVzZXRzIHRoZSBmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfaW5wdXRfZGVmYXVsdHMoaW5wdXQpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHR2YXIgYWxyZWFkeV9yZW1vdmVkID0gZmFsc2U7XG5cblx0Ly8gV2UgdHJ5IGFuZCByZW1vdmUgdGhlIGRlZmF1bHQgYXR0cmlidXRlcyBsYXRlciwgcmF0aGVyIHRoYW4gc3luYyBkdXJpbmcgaHlkcmF0aW9uLlxuXHQvLyBEb2luZyBpdCBzeW5jIGR1cmluZyBoeWRyYXRpb24gaGFzIGEgbmVnYXRpdmUgaW1wYWN0IG9uIHBlcmZvcm1hbmNlLCBidXQgZGVmZXJyaW5nIHRoZVxuXHQvLyB3b3JrIGluIGFuIGlkbGUgdGFzayBhbGxldmlhdGVzIHRoaXMgZ3JlYXRseS4gSWYgYSBmb3JtIHJlc2V0IGV2ZW50IGNvbWVzIGluIGJlZm9yZVxuXHQvLyB0aGUgaWRsZSBjYWxsYmFjaywgdGhlbiB3ZSBlbnN1cmUgdGhlIGlucHV0IGRlZmF1bHRzIGFyZSBjbGVhcmVkIGp1c3QgYmVmb3JlLlxuXHR2YXIgcmVtb3ZlX2RlZmF1bHRzID0gKCkgPT4ge1xuXHRcdGlmIChhbHJlYWR5X3JlbW92ZWQpIHJldHVybjtcblx0XHRhbHJlYWR5X3JlbW92ZWQgPSB0cnVlO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBhdHRyaWJ1dGVzIGJ1dCBwcmVzZXJ2ZSB0aGUgdmFsdWVzXG5cdFx0aWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gaW5wdXQudmFsdWU7XG5cdFx0XHRzZXRfYXR0cmlidXRlKGlucHV0LCAndmFsdWUnLCBudWxsKTtcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG5cdFx0XHR2YXIgY2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG5cdFx0XHRzZXRfYXR0cmlidXRlKGlucHV0LCAnY2hlY2tlZCcsIG51bGwpO1xuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IGNoZWNrZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0aW5wdXQuX19vbl9yID0gcmVtb3ZlX2RlZmF1bHRzO1xuXHRxdWV1ZV9taWNyb190YXNrKHJlbW92ZV9kZWZhdWx0cyk7XG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHR2YXIgYXR0cmlidXRlcyA9IGdldF9hdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXG5cdGlmIChcblx0XHRhdHRyaWJ1dGVzLnZhbHVlID09PVxuXHRcdFx0KGF0dHJpYnV0ZXMudmFsdWUgPVxuXHRcdFx0XHQvLyB0cmVhdCBudWxsIGFuZCB1bmRlZmluZWQgdGhlIHNhbWUgZm9yIHRoZSBpbml0aWFsIHZhbHVlXG5cdFx0XHRcdHZhbHVlID8/IHVuZGVmaW5lZCkgfHxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0Ly8gYHByb2dyZXNzYCBlbGVtZW50cyBhbHdheXMgbmVlZCB0aGVpciB2YWx1ZSBzZXQgd2hlbiBpdCdzIGAwYFxuXHRcdChlbGVtZW50LnZhbHVlID09PSB2YWx1ZSAmJiAodmFsdWUgIT09IDAgfHwgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ1BST0dSRVNTJykpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC52YWx1ZSA9IHZhbHVlID8/ICcnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2hlY2tlZChlbGVtZW50LCBjaGVja2VkKSB7XG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMuY2hlY2tlZCA9PT1cblx0XHQoYXR0cmlidXRlcy5jaGVja2VkID1cblx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdGNoZWNrZWQgPz8gdW5kZWZpbmVkKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgb24gYW4gYG9wdGlvbmAgZWxlbWVudC5cbiAqIE5vdCBzZXQgdGhyb3VnaCB0aGUgcHJvcGVydHkgYmVjYXVzZSB0aGF0IGRvZXNuJ3QgcmVmbGVjdCB0byB0aGUgRE9NLFxuICogd2hpY2ggbWVhbnMgaXQgd291bGRuJ3QgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gYSBmb3JtIGlzIHJlc2V0LlxuICogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NlbGVjdGVkKGVsZW1lbnQsIHNlbGVjdGVkKSB7XG5cdGlmIChzZWxlY3RlZCkge1xuXHRcdC8vIFRoZSBzZWxlY3RlZCBvcHRpb24gY291bGQndmUgY2hhbmdlZCB2aWEgdXNlciBzZWxlY3Rpb24sIGFuZFxuXHRcdC8vIHNldHRpbmcgdGhlIHZhbHVlIHdpdGhvdXQgdGhpcyBjaGVjayB3b3VsZCBzZXQgaXQgYmFjay5cblx0XHRpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnJyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZGVmYXVsdCBjaGVja2VkIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgY2hlY2tlZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVmYXVsdF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG5cdGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuXHRlbGVtZW50LmNoZWNrZWQgPSBleGlzdGluZ192YWx1ZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IHZhbHVlIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgdmFsdWUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X3ZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG5cdGNvbnN0IGV4aXN0aW5nX3ZhbHVlID0gZWxlbWVudC52YWx1ZTtcblx0ZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcblx0ZWxlbWVudC52YWx1ZSA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlLCBza2lwX3dhcm5pbmcpIHtcblx0dmFyIGF0dHJpYnV0ZXMgPSBnZXRfYXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YXR0cmlidXRlc1thdHRyaWJ1dGVdID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblxuXHRcdGlmIChcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyYycgfHxcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgfHxcblx0XHRcdChhdHRyaWJ1dGUgPT09ICdocmVmJyAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSAnTElOSycpXG5cdFx0KSB7XG5cdFx0XHRpZiAoIXNraXBfd2FybmluZykge1xuXHRcdFx0XHRjaGVja19zcmNfaW5fZGV2X2h5ZHJhdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlID8/ICcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgcmVzZXQgdGhlc2UgYXR0cmlidXRlcywgdGhleSB3b3VsZCByZXN1bHQgaW4gYW5vdGhlciBuZXR3b3JrIHJlcXVlc3QsIHdoaWNoIHdlIHdhbnQgdG8gYXZvaWQuXG5cdFx0XHQvLyBXZSBhc3N1bWUgdGhleSBhcmUgdGhlIHNhbWUgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBhcyBjaGVja2luZyBpZiB0aGV5IGFyZSBlcXVhbCBpcyBleHBlbnNpdmVcblx0XHRcdC8vICh3ZSBjYW4ndCBqdXN0IGNvbXBhcmUgdGhlIHN0cmluZ3MgYXMgdGhleSBjYW4gYmUgZGlmZmVyZW50IGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIgYnV0IHJlc3VsdCBpbiB0aGVcblx0XHRcdC8vIHNhbWUgdXJsLCBzbyB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBoaWRkZW4gYW5jaG9yIGVsZW1lbnRzIHRvIGNvbXBhcmUgdGhlbSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWUpKSByZXR1cm47XG5cblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ2xvYWRpbmcnKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnRbTE9BRElOR19BVFRSX1NZTUJPTF0gPSB2YWx1ZTtcblx0fVxuXG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIGdldF9zZXR0ZXJzKGVsZW1lbnQpLmluY2x1ZGVzKGF0dHJpYnV0ZSkpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZWxlbWVudFthdHRyaWJ1dGVdID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfeGxpbmtfYXR0cmlidXRlKGRvbSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRkb20uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHQvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNldHRpbmcgY3VzdG9tIGVsZW1lbnQgcHJvcHMsIHdoaWNoIGNhblxuXHQvLyBpbnZva2UgbGlmZWN5Y2xlIG1ldGhvZHMgb24gb3RoZXIgY3VzdG9tIGVsZW1lbnRzLCBkb2VzIG5vdCBhbHNvXG5cdC8vIGFzc29jaWF0ZSB0aG9zZSBsaWZlY3ljbGUgbWV0aG9kcyB3aXRoIHRoZSBjdXJyZW50IGFjdGl2ZSByZWFjdGlvblxuXHQvLyBvciBlZmZlY3Rcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHQvLyBJZiB3ZSdyZSBoeWRyYXRpbmcgYnV0IHRoZSBjdXN0b20gZWxlbWVudCBpcyBmcm9tIFN2ZWx0ZSwgYW5kIGl0IGFscmVhZHkgc2NhZmZvbGRlZCxcblx0Ly8gdGhlbiBpdCBtaWdodCBydW4gYmxvY2sgbG9naWMgaW4gaHlkcmF0aW9uIG1vZGUsIHdoaWNoIHdlIGhhdmUgdG8gcHJldmVudC5cblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0fVxuXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXG5cdHRyeSB7XG5cdFx0aWYgKFxuXHRcdFx0Ly8gYHN0eWxlYCBzaG91bGQgdXNlIGBzZXRfYXR0cmlidXRlYCByYXRoZXIgdGhhbiB0aGUgc2V0dGVyXG5cdFx0XHRwcm9wICE9PSAnc3R5bGUnICYmXG5cdFx0XHQvLyBEb24ndCBjb21wdXRlIHNldHRlcnMgZm9yIGN1c3RvbSBlbGVtZW50cyB3aGlsZSB0aGV5IGFyZW4ndCByZWdpc3RlcmVkIHlldCxcblx0XHRcdC8vIGJlY2F1c2UgZHVyaW5nIHRoZWlyIHVwZ3JhZGUvaW5zdGFudGlhdGlvbiB0aGV5IG1pZ2h0IGFkZCBtb3JlIHNldHRlcnMuXG5cdFx0XHQvLyBJbnN0ZWFkLCBmYWxsIGJhY2sgdG8gYSBzaW1wbGUgXCJhbiBvYmplY3QsIHRoZW4gc2V0IGFzIHByb3BlcnR5XCIgaGV1cmlzdGljLlxuXHRcdFx0KHNldHRlcnNfY2FjaGUuaGFzKG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpIHx8IG5vZGUubm9kZU5hbWUpIHx8XG5cdFx0XHQvLyBjdXN0b21FbGVtZW50cyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBicm93c2VyIGV4dGVuc2lvbiBjb250ZXh0c1xuXHRcdFx0IWN1c3RvbUVsZW1lbnRzIHx8XG5cdFx0XHRjdXN0b21FbGVtZW50cy5nZXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdD8gZ2V0X3NldHRlcnMobm9kZSkuaW5jbHVkZXMocHJvcClcblx0XHRcdFx0OiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0bm9kZVtwcm9wXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBXZSBkaWQgZ2V0dGVycyBldGMgY2hlY2tzIGFscmVhZHksIHN0cmluZ2lmeSBiZWZvcmUgcGFzc2luZyB0byBzZXRfYXR0cmlidXRlXG5cdFx0XHQvLyB0byBlbnN1cmUgaXQgZG9lc24ndCBpbnZva2UgdGhlIHNhbWUgbG9naWMgYWdhaW4sIGFuZCBwb3RlbnRpYWxseSBwb3B1bGF0aW5nXG5cdFx0XHQvLyB0aGUgc2V0dGVycyBjYWNoZSB0b28gZWFybHkuXG5cdFx0XHRzZXRfYXR0cmlidXRlKG5vZGUsIHByb3AsIHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSkpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFNwcmVhZHMgYXR0cmlidXRlcyBvbnRvIGEgRE9NIGVsZW1lbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnRseSBzZXQgYXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT4gfCB1bmRlZmluZWR9IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gbmV4dCBOZXcgYXR0cmlidXRlcyAtIHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Nob3VsZF9yZW1vdmVfZGVmYXVsdHNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMoXG5cdGVsZW1lbnQsXG5cdHByZXYsXG5cdG5leHQsXG5cdGNzc19oYXNoLFxuXHRzaG91bGRfcmVtb3ZlX2RlZmF1bHRzID0gZmFsc2UsXG5cdHNraXBfd2FybmluZyA9IGZhbHNlXG4pIHtcblx0aWYgKGh5ZHJhdGluZyAmJiBzaG91bGRfcmVtb3ZlX2RlZmF1bHRzICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuXHRcdHZhciBpbnB1dCA9IC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi8gKGVsZW1lbnQpO1xuXHRcdHZhciBhdHRyaWJ1dGUgPSBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnID8gJ2RlZmF1bHRDaGVja2VkJyA6ICdkZWZhdWx0VmFsdWUnO1xuXG5cdFx0aWYgKCEoYXR0cmlidXRlIGluIG5leHQpKSB7XG5cdFx0XHRyZW1vdmVfaW5wdXRfZGVmYXVsdHMoaW5wdXQpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0dmFyIGlzX2N1c3RvbV9lbGVtZW50ID0gYXR0cmlidXRlc1tJU19DVVNUT01fRUxFTUVOVF07XG5cdHZhciBwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZSA9ICFhdHRyaWJ1dGVzW0lTX0hUTUxdO1xuXG5cdC8vIElmIHdlJ3JlIGh5ZHJhdGluZyBidXQgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGZyb20gU3ZlbHRlLCBhbmQgaXQgYWxyZWFkeSBzY2FmZm9sZGVkLFxuXHQvLyB0aGVuIGl0IG1pZ2h0IHJ1biBibG9jayBsb2dpYyBpbiBoeWRyYXRpb24gbW9kZSwgd2hpY2ggd2UgaGF2ZSB0byBwcmV2ZW50LlxuXHRsZXQgaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50ID0gaHlkcmF0aW5nICYmIGlzX2N1c3RvbV9lbGVtZW50O1xuXHRpZiAoaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50KSB7XG5cdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdH1cblxuXHR2YXIgY3VycmVudCA9IHByZXYgfHwge307XG5cdHZhciBpc19vcHRpb25fZWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09QVElPTic7XG5cblx0Zm9yICh2YXIga2V5IGluIHByZXYpIHtcblx0XHRpZiAoIShrZXkgaW4gbmV4dCkpIHtcblx0XHRcdG5leHRba2V5XSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5leHQuY2xhc3MpIHtcblx0XHRuZXh0LmNsYXNzID0gY2xzeChuZXh0LmNsYXNzKTtcblx0fSBlbHNlIGlmIChjc3NfaGFzaCB8fCBuZXh0W0NMQVNTXSkge1xuXHRcdG5leHQuY2xhc3MgPSBudWxsOyAvKiBmb3JjZSBjYWxsIHRvIHNldF9jbGFzcygpICovXG5cdH1cblxuXHRpZiAobmV4dFtTVFlMRV0pIHtcblx0XHRuZXh0LnN0eWxlID8/PSBudWxsOyAvKiBmb3JjZSBjYWxsIHRvIHNldF9zdHlsZSgpICovXG5cdH1cblxuXHR2YXIgc2V0dGVycyA9IGdldF9zZXR0ZXJzKGVsZW1lbnQpO1xuXG5cdC8vIHNpbmNlIGtleSBpcyBjYXB0dXJlZCB3ZSB1c2UgY29uc3Rcblx0Zm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuXHRcdC8vIGxldCBpbnN0ZWFkIG9mIHZhciBiZWNhdXNlIHJlZmVyZW5jZWQgaW4gYSBjbG9zdXJlXG5cdFx0bGV0IHZhbHVlID0gbmV4dFtrZXldO1xuXG5cdFx0Ly8gVXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gZG8gdGhpcyBmb3IgdGhlIGluaXRpYWwgdmFsdWUsIHRvbywgZXZlbiBpZiBpdCdzIHVuZGVmaW5lZCxcblx0XHQvLyBhbmQgdGhpcyB3b3VsZG4ndCBiZSByZWFjaGVkIGluIGNhc2Ugb2YgdW5kZWZpbmVkIGJlY2F1c2Ugb2YgdGhlIGVxdWFsaXR5IGNoZWNrIGJlbG93XG5cdFx0aWYgKGlzX29wdGlvbl9lbGVtZW50ICYmIGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHQvLyBUaGUgPG9wdGlvbj4gZWxlbWVudCBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHJlbW92aW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgbWVhbnNcblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHRleHQgY29udGVudCBvZiB0aGUgb3B0aW9uIGVsZW1lbnQsIGFuZCBzZXR0aW5nIHRoZSB2YWx1ZVxuXHRcdFx0Ly8gdG8gbnVsbCBvciB1bmRlZmluZWQgbWVhbnMgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgc3RyaW5nIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIuXG5cdFx0XHQvLyBUbyBhbGlnbiB3aXRoIGhvdyB3ZSBoYW5kbGUgdGhpcyBjYXNlIGluIG5vbi1zcHJlYWQtc2NlbmFyaW9zLCB0aGlzIGxvZ2ljIGlzIG5lZWRlZC5cblx0XHRcdC8vIFRoZXJlJ3MgYSBzdXBlci1lZGdlLWNhc2UgYnVnIGhlcmUgdGhhdCBpcyBsZWZ0IGluIGluIGZhdm9yIG9mIHNtYWxsZXIgY29kZSBzaXplOlxuXHRcdFx0Ly8gQmVjYXVzZSBvZiB0aGUgXCJzZXQgbWlzc2luZyBwcm9wcyB0byBudWxsXCIgbG9naWMgYWJvdmUsIHdlIGNhbid0IGRpZmZlcmVudGlhdGVcblx0XHRcdC8vIGJldHdlZW4gYSBtaXNzaW5nIHZhbHVlIGFuZCBhbiBleHBsaWNpdGx5IHNldCB2YWx1ZSBvZiBudWxsIG9yIHVuZGVmaW5lZC4gVGhhdCBtZWFuc1xuXHRcdFx0Ly8gdGhhdCBvbmNlIHNldCwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvZiBhbiA8b3B0aW9uPiBlbGVtZW50IGNhbid0IGJlIHJlbW92ZWQuIFRoaXMgaXNcblx0XHRcdC8vIGEgdmVyeSByYXJlIGVkZ2UgY2FzZSwgYW5kIHJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgYWx0b2dldGhlciBpc24ndCBwb3NzaWJsZSBlaXRoZXJcblx0XHRcdC8vIGZvciB0aGUgPG9wdGlvbiB2YWx1ZT17dW5kZWZpbmVkfT4gY2FzZSwgc28gd2UncmUgbm90IGxvc2luZyBhbnkgZnVuY3Rpb25hbGl0eSBoZXJlLlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQuX192YWx1ZSA9ICcnO1xuXHRcdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG5cdFx0XHR2YXIgaXNfaHRtbCA9IGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cdFx0XHRzZXRfY2xhc3MoZWxlbWVudCwgaXNfaHRtbCwgdmFsdWUsIGNzc19oYXNoLCBwcmV2Py5bQ0xBU1NdLCBuZXh0W0NMQVNTXSk7XG5cdFx0XHRjdXJyZW50W2tleV0gPSB2YWx1ZTtcblx0XHRcdGN1cnJlbnRbQ0xBU1NdID0gbmV4dFtDTEFTU107XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRzZXRfc3R5bGUoZWxlbWVudCwgdmFsdWUsIHByZXY/LltTVFlMRV0sIG5leHRbU1RZTEVdKTtcblx0XHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y3VycmVudFtTVFlMRV0gPSBuZXh0W1NUWUxFXTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciBwcmV2X3ZhbHVlID0gY3VycmVudFtrZXldO1xuXG5cdFx0Ly8gU2tpcCBpZiB2YWx1ZSBpcyB1bmNoYW5nZWQsIHVubGVzcyBpdCdzIGB1bmRlZmluZWRgIGFuZCB0aGUgZWxlbWVudCBzdGlsbCBoYXMgdGhlIGF0dHJpYnV0ZVxuXHRcdGlmICh2YWx1ZSA9PT0gcHJldl92YWx1ZSAmJiAhKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXG5cdFx0dmFyIHByZWZpeCA9IGtleVswXSArIGtleVsxXTsgLy8gdGhpcyBpcyBmYXN0ZXIgdGhhbiBrZXkuc2xpY2UoMCwgMilcblx0XHRpZiAocHJlZml4ID09PSAnJCQnKSBjb250aW51ZTtcblxuXHRcdGlmIChwcmVmaXggPT09ICdvbicpIHtcblx0XHRcdC8qKiBAdHlwZSB7eyBjYXB0dXJlPzogdHJ1ZSB9fSAqL1xuXHRcdFx0Y29uc3Qgb3B0cyA9IHt9O1xuXHRcdFx0Y29uc3QgZXZlbnRfaGFuZGxlX2tleSA9ICckJCcgKyBrZXk7XG5cdFx0XHRsZXQgZXZlbnRfbmFtZSA9IGtleS5zbGljZSgyKTtcblx0XHRcdHZhciBkZWxlZ2F0ZWQgPSBjYW5fZGVsZWdhdGVfZXZlbnQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChpc19jYXB0dXJlX2V2ZW50KGV2ZW50X25hbWUpKSB7XG5cdFx0XHRcdGV2ZW50X25hbWUgPSBldmVudF9uYW1lLnNsaWNlKDAsIC03KTtcblx0XHRcdFx0b3B0cy5jYXB0dXJlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZWxlZ2F0ZWQgJiYgcHJldl92YWx1ZSkge1xuXHRcdFx0XHQvLyBMaXN0ZW5pbmcgdG8gc2FtZSBldmVudCBidXQgZGlmZmVyZW50IGhhbmRsZXIgLT4gb3VyIGhhbmRsZSBmdW5jdGlvbiBiZWxvdyB0YWtlcyBjYXJlIG9mIHRoaXNcblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSB0byByZW1vdmUgYW5kIGFkZCBsaXN0ZW5lcnMgaW4gdGhpcyBjYXNlLCBpdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgZXZlbnQgaXMgXCJzd2FsbG93ZWRcIlxuXHRcdFx0XHQvLyAodGhlIGJyb3dzZXIgc2VlbXMgdG8gbm90IGtub3cgeWV0IHRoYXQgYSBuZXcgb25lIGV4aXN0cyBub3cpIGFuZCBkb2Vzbid0IHJlYWNoIHRoZSBoYW5kbGVyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzExOTAzXG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgY3VycmVudFtldmVudF9oYW5kbGVfa2V5XSwgb3B0cyk7XG5cdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIWRlbGVnYXRlZCkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIEB0aGlzIHthbnl9XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKGV2dCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFtrZXldLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGVsZW1lbnQsIGhhbmRsZSwgb3B0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVsZWdhdGUoW2V2ZW50X25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W2BfXyR7ZXZlbnRfbmFtZX1gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0Ly8gYXZvaWQgdXNpbmcgdGhlIHNldHRlclxuXHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2F1dG9mb2N1cycpIHtcblx0XHRcdGF1dG9mb2N1cygvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCksIEJvb2xlYW4odmFsdWUpKTtcblx0XHR9IGVsc2UgaWYgKCFpc19jdXN0b21fZWxlbWVudCAmJiAoa2V5ID09PSAnX192YWx1ZScgfHwgKGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSAhPSBudWxsKSkpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgV2UncmUgbm90IHJ1bm5pbmcgdGhpcyBmb3IgY3VzdG9tIGVsZW1lbnRzIGJlY2F1c2UgX192YWx1ZSBpcyBhY3R1YWxseVxuXHRcdFx0Ly8gaG93IExpdCBzdG9yZXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gdGhlIGVsZW1lbnQsIGFuZCBtZXNzaW5nIHdpdGggdGhhdCB3b3VsZCBicmVhayB0aGluZ3MuXG5cdFx0XHRlbGVtZW50LnZhbHVlID0gZWxlbWVudC5fX3ZhbHVlID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzZWxlY3RlZCcgJiYgaXNfb3B0aW9uX2VsZW1lbnQpIHtcblx0XHRcdHNldF9zZWxlY3RlZCgvKiogQHR5cGUge0hUTUxPcHRpb25FbGVtZW50fSAqLyAoZWxlbWVudCksIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5hbWUgPSBrZXk7XG5cdFx0XHRpZiAoIXByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlKSB7XG5cdFx0XHRcdG5hbWUgPSBub3JtYWxpemVfYXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXNfZGVmYXVsdCA9IG5hbWUgPT09ICdkZWZhdWx0VmFsdWUnIHx8IG5hbWUgPT09ICdkZWZhdWx0Q2hlY2tlZCc7XG5cblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFpc19jdXN0b21fZWxlbWVudCAmJiAhaXNfZGVmYXVsdCkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuXG5cdFx0XHRcdGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJykge1xuXHRcdFx0XHRcdC8vIHJlbW92aW5nIHZhbHVlL2NoZWNrZWQgYWxzbyByZW1vdmVzIGRlZmF1bHRWYWx1ZS9kZWZhdWx0Q2hlY2tlZCDigJQgcHJlc2VydmVcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovIChlbGVtZW50KTtcblx0XHRcdFx0XHRjb25zdCB1c2VfZGVmYXVsdCA9IHByZXYgPT09IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdFZhbHVlO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdFZhbHVlID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRpbnB1dC52YWx1ZSA9IGlucHV0Ll9fdmFsdWUgPSB1c2VfZGVmYXVsdCA/IHByZXZpb3VzIDogbnVsbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdENoZWNrZWQ7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0aW5wdXQuY2hlY2tlZCA9IHVzZV9kZWZhdWx0ID8gcHJldmlvdXMgOiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aXNfZGVmYXVsdCB8fFxuXHRcdFx0XHQoc2V0dGVycy5pbmNsdWRlcyhuYW1lKSAmJiAoaXNfY3VzdG9tX2VsZW1lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdC8vIHJlbW92ZSBpdCBmcm9tIGF0dHJpYnV0ZXMncyBjYWNoZVxuXHRcdFx0XHRpZiAobmFtZSBpbiBhdHRyaWJ1dGVzKSBhdHRyaWJ1dGVzW25hbWVdID0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHNldF9hdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUsIHNraXBfd2FybmluZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzX2h5ZHJhdGluZ19jdXN0b21fZWxlbWVudCkge1xuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KC4uLmV4cHJlc3Npb25zOiBhbnkpID0+IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59IGZuXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IGFueT59IHN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+Pn0gYXN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZTx2b2lkPj59IGJsb2NrZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Nzc19oYXNoXVxuICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkX3JlbW92ZV9kZWZhdWx0c11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZV9lZmZlY3QoXG5cdGVsZW1lbnQsXG5cdGZuLFxuXHRzeW5jID0gW10sXG5cdGFzeW5jID0gW10sXG5cdGJsb2NrZXJzID0gW10sXG5cdGNzc19oYXNoLFxuXHRzaG91bGRfcmVtb3ZlX2RlZmF1bHRzID0gZmFsc2UsXG5cdHNraXBfd2FybmluZyA9IGZhbHNlXG4pIHtcblx0ZmxhdHRlbihibG9ja2Vycywgc3luYywgYXN5bmMsICh2YWx1ZXMpID0+IHtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT4gfCB1bmRlZmluZWR9ICovXG5cdFx0dmFyIHByZXYgPSB1bmRlZmluZWQ7XG5cblx0XHQvKiogQHR5cGUge1JlY29yZDxzeW1ib2wsIEVmZmVjdD59ICovXG5cdFx0dmFyIGVmZmVjdHMgPSB7fTtcblxuXHRcdHZhciBpc19zZWxlY3QgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJztcblx0XHR2YXIgaW5pdGVkID0gZmFsc2U7XG5cblx0XHRibG9jaygoKSA9PiB7XG5cdFx0XHR2YXIgbmV4dCA9IGZuKC4uLnZhbHVlcy5tYXAoZ2V0KSk7XG5cdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59ICovXG5cdFx0XHR2YXIgY3VycmVudCA9IHNldF9hdHRyaWJ1dGVzKFxuXHRcdFx0XHRlbGVtZW50LFxuXHRcdFx0XHRwcmV2LFxuXHRcdFx0XHRuZXh0LFxuXHRcdFx0XHRjc3NfaGFzaCxcblx0XHRcdFx0c2hvdWxkX3JlbW92ZV9kZWZhdWx0cyxcblx0XHRcdFx0c2tpcF93YXJuaW5nXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAoaW5pdGVkICYmIGlzX3NlbGVjdCAmJiAndmFsdWUnIGluIG5leHQpIHtcblx0XHRcdFx0c2VsZWN0X29wdGlvbigvKiogQHR5cGUge0hUTUxTZWxlY3RFbGVtZW50fSAqLyAoZWxlbWVudCksIG5leHQudmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGxldCBzeW1ib2wgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlZmZlY3RzKSkge1xuXHRcdFx0XHRpZiAoIW5leHRbc3ltYm9sXSkgZGVzdHJveV9lZmZlY3QoZWZmZWN0c1tzeW1ib2xdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgc3ltYm9sIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobmV4dCkpIHtcblx0XHRcdFx0dmFyIG4gPSBuZXh0W3N5bWJvbF07XG5cblx0XHRcdFx0aWYgKHN5bWJvbC5kZXNjcmlwdGlvbiA9PT0gQVRUQUNITUVOVF9LRVkgJiYgKCFwcmV2IHx8IG4gIT09IHByZXZbc3ltYm9sXSkpIHtcblx0XHRcdFx0XHRpZiAoZWZmZWN0c1tzeW1ib2xdKSBkZXN0cm95X2VmZmVjdChlZmZlY3RzW3N5bWJvbF0pO1xuXHRcdFx0XHRcdGVmZmVjdHNbc3ltYm9sXSA9IGJyYW5jaCgoKSA9PiBhdHRhY2goZWxlbWVudCwgKCkgPT4gbikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudFtzeW1ib2xdID0gbjtcblx0XHRcdH1cblxuXHRcdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0fSk7XG5cblx0XHRpZiAoaXNfc2VsZWN0KSB7XG5cdFx0XHR2YXIgc2VsZWN0ID0gLyoqIEB0eXBlIHtIVE1MU2VsZWN0RWxlbWVudH0gKi8gKGVsZW1lbnQpO1xuXG5cdFx0XHRlZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHRzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBhbnk+fSAqLyAocHJldikudmFsdWUsIHRydWUpO1xuXHRcdFx0XHRpbml0X3NlbGVjdChzZWxlY3QpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aW5pdGVkID0gdHJ1ZTtcblx0fSk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRfYXR0cmlidXRlcyhlbGVtZW50KSB7XG5cdHJldHVybiAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+fSAqKi8gKFxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50Ll9fYXR0cmlidXRlcyA/Pz0ge1xuXHRcdFx0W0lTX0NVU1RPTV9FTEVNRU5UXTogZWxlbWVudC5ub2RlTmFtZS5pbmNsdWRlcygnLScpLFxuXHRcdFx0W0lTX0hUTUxdOiBlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gTkFNRVNQQUNFX0hUTUxcblx0XHR9XG5cdCk7XG59XG5cbi8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nW10+fSAqL1xudmFyIHNldHRlcnNfY2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgKi9cbmZ1bmN0aW9uIGdldF9zZXR0ZXJzKGVsZW1lbnQpIHtcblx0dmFyIGNhY2hlX2tleSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpcycpIHx8IGVsZW1lbnQubm9kZU5hbWU7XG5cdHZhciBzZXR0ZXJzID0gc2V0dGVyc19jYWNoZS5nZXQoY2FjaGVfa2V5KTtcblx0aWYgKHNldHRlcnMpIHJldHVybiBzZXR0ZXJzO1xuXHRzZXR0ZXJzX2NhY2hlLnNldChjYWNoZV9rZXksIChzZXR0ZXJzID0gW10pKTtcblxuXHR2YXIgZGVzY3JpcHRvcnM7XG5cdHZhciBwcm90byA9IGVsZW1lbnQ7IC8vIEluIHRoZSBjYXNlIG9mIGN1c3RvbSBlbGVtZW50cyB0aGVyZSBtaWdodCBiZSBzZXR0ZXJzIG9uIHRoZSBpbnN0YW5jZVxuXHR2YXIgZWxlbWVudF9wcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG5cdC8vIFN0b3AgYXQgRWxlbWVudCwgZnJvbSB0aGVyZSBvbiB0aGVyZSdzIG9ubHkgdW5uZWNlc3Nhcnkgc2V0dGVycyB3ZSdyZSBub3QgaW50ZXJlc3RlZCBpblxuXHQvLyBEbyBub3QgdXNlIGNvbnRydWN0b3IubmFtZSBoZXJlIGFzIHRoYXQncyB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlciBlbnZpcm9ubWVudHNcblx0d2hpbGUgKGVsZW1lbnRfcHJvdG8gIT09IHByb3RvKSB7XG5cdFx0ZGVzY3JpcHRvcnMgPSBnZXRfZGVzY3JpcHRvcnMocHJvdG8pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGRlc2NyaXB0b3JzKSB7XG5cdFx0XHRpZiAoZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcblx0XHRcdFx0c2V0dGVycy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHByb3RvKTtcblx0fVxuXG5cdHJldHVybiBzZXR0ZXJzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tfc3JjX2luX2Rldl9oeWRyYXRpb24oZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRpZiAoIURFVikgcmV0dXJuO1xuXHRpZiAoYXR0cmlidXRlID09PSAnc3Jjc2V0JyAmJiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnQsIHZhbHVlKSkgcmV0dXJuO1xuXHRpZiAoc3JjX3VybF9lcXVhbChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpID8/ICcnLCB2YWx1ZSkpIHJldHVybjtcblxuXHR3Lmh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZChcblx0XHRhdHRyaWJ1dGUsXG5cdFx0ZWxlbWVudC5vdXRlckhUTUwucmVwbGFjZShlbGVtZW50LmlubmVySFRNTCwgZWxlbWVudC5pbm5lckhUTUwgJiYgJy4uLicpLFxuXHRcdFN0cmluZyh2YWx1ZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcblx0aWYgKGVsZW1lbnRfc3JjID09PSB1cmwpIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gbmV3IFVSTChlbGVtZW50X3NyYywgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZiA9PT0gbmV3IFVSTCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWY7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0ICovXG5mdW5jdGlvbiBzcGxpdF9zcmNzZXQoc3Jjc2V0KSB7XG5cdHJldHVybiBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYykgPT4gc3JjLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU291cmNlRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnQsIHNyY3NldCkge1xuXHR2YXIgZWxlbWVudF91cmxzID0gc3BsaXRfc3Jjc2V0KGVsZW1lbnQuc3Jjc2V0KTtcblx0dmFyIHVybHMgPSBzcGxpdF9zcmNzZXQoc3Jjc2V0KTtcblxuXHRyZXR1cm4gKFxuXHRcdHVybHMubGVuZ3RoID09PSBlbGVtZW50X3VybHMubGVuZ3RoICYmXG5cdFx0dXJscy5ldmVyeShcblx0XHRcdChbdXJsLCB3aWR0aF0sIGkpID0+XG5cdFx0XHRcdHdpZHRoID09PSBlbGVtZW50X3VybHNbaV1bMV0gJiZcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGJvdGggd2F5cyBiZWNhdXNlIFZpdGUgd2lsbCBjcmVhdGUgYW4gYSBmdWxsIFVSTCB3aXRoXG5cdFx0XHRcdC8vIGBuZXcgVVJMKGFzc2V0LCBpbXBvcnQubWV0YS51cmwpLmhyZWZgIGZvciB0aGUgY2xpZW50IHdoZW4gYGJhc2U6ICcuLydgLCBhbmQgdGhlXG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTHMgaW5zaWRlIHNyY3NldCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgVVJMcyBieVxuXHRcdFx0XHQvLyBicm93c2VycyAoaW4gY29udHJhc3QgdG8gaW1nLnNyYykuIFRoaXMgbWVhbnMgYm90aCBTU1IgYW5kIERPTSBjb2RlIGNvdWxkXG5cdFx0XHRcdC8vIGNvbnRhaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMcy5cblx0XHRcdFx0KHNyY191cmxfZXF1YWwoZWxlbWVudF91cmxzW2ldWzBdLCB1cmwpIHx8IHNyY191cmxfZXF1YWwodXJsLCBlbGVtZW50X3VybHNbaV1bMF0pKVxuXHRcdClcblx0KTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgUmFmIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBCUk9XU0VSIH0gZnJvbSAnZXNtLWVudic7XG5cbmNvbnN0IG5vdyA9IEJST1dTRVIgPyAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA6ICgpID0+IERhdGUubm93KCk7XG5cbi8qKiBAdHlwZSB7UmFmfSAqL1xuZXhwb3J0IGNvbnN0IHJhZiA9IHtcblx0Ly8gZG9uJ3QgYWNjZXNzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBlYWdlcmx5IG91dHNpZGUgbWV0aG9kXG5cdC8vIHRoaXMgYWxsb3dzIGJhc2ljIHRlc3Rpbmcgb2YgdXNlciBjb2RlIHdpdGhvdXQgSlNET01cblx0Ly8gYnVuZGVyIHdpbGwgZXZhbCBhbmQgcmVtb3ZlIHRlcm5hcnkgd2hlbiB0aGUgdXNlcidzIGFwcCBpcyBidWlsdFxuXHR0aWNrOiAvKiogQHBhcmFtIHthbnl9IF8gKi8gKF8pID0+IChCUk9XU0VSID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogbm9vcCkoXyksXG5cdG5vdzogKCkgPT4gbm93KCksXG5cdHRhc2tzOiBuZXcgU2V0KClcbn07XG4iLCIvKiogQGltcG9ydCB7IFRhc2tDYWxsYmFjaywgVGFzaywgVGFza0VudHJ5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJhZiB9IGZyb20gJy4vdGltaW5nLmpzJztcblxuLy8gVE9ETyBtb3ZlIHRoaXMgaW50byB0aW1pbmcuanMgd2hlcmUgaXQgcHJvYmFibHkgYmVsb25nc1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBydW5fdGFza3MoKSB7XG5cdC8vIHVzZSBgcmFmLm5vdygpYCBpbnN0ZWFkIG9mIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjayBhcmd1bWVudCwgYmVjYXVzZVxuXHQvLyBvdGhlcndpc2UgdGhpbmdzIGNhbiBnZXQgd29ua3kgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzE0NTQxXG5cdGNvbnN0IG5vdyA9IHJhZi5ub3coKTtcblxuXHRyYWYudGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdGlmICghdGFzay5jKG5vdykpIHtcblx0XHRcdHJhZi50YXNrcy5kZWxldGUodGFzayk7XG5cdFx0XHR0YXNrLmYoKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSAhPT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICogQHBhcmFtIHtUYXNrQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7VGFza31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUYXNrRW50cnl9ICovXG5cdGxldCB0YXNrO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSA9PT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHByb21pc2U6IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG5cdFx0XHRyYWYudGFza3MuYWRkKCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KSk7XG5cdFx0fSksXG5cdFx0YWJvcnQoKSB7XG5cdFx0XHRyYWYudGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdH1cblx0fTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQW5pbWF0ZUZuLCBBbmltYXRpb24sIEFuaW1hdGlvbkNvbmZpZywgRWFjaEl0ZW0sIEVmZmVjdCwgVHJhbnNpdGlvbkZuLCBUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBub29wLCBpc19mdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBlZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbixcblx0dW50cmFja1xufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuLi8uLi9sb29wLmpzJztcbmltcG9ydCB7IHNob3VsZF9pbnRybyB9IGZyb20gJy4uLy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSB9IGZyb20gJy4uL2Jsb2Nrcy9lYWNoLmpzJztcbmltcG9ydCB7IFRSQU5TSVRJT05fR0xPQkFMLCBUUkFOU0lUSU9OX0lOLCBUUkFOU0lUSU9OX09VVCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBCTE9DS19FRkZFQ1QsIEVGRkVDVF9SQU4sIEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7J2ludHJvc3RhcnQnIHwgJ2ludHJvZW5kJyB8ICdvdXRyb3N0YXJ0JyB8ICdvdXRyb2VuZCd9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaF9ldmVudChlbGVtZW50LCB0eXBlKSB7XG5cdHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlKSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJvcGVydHkgdG8gdGhlIGNhbWVsLWNhc2UgZm9ybWF0IGV4cGVjdGVkIGJ5IEVsZW1lbnQuYW5pbWF0ZSgpLCBLZXlmcmFtZUVmZmVjdCgpLCBhbmQgS2V5ZnJhbWVFZmZlY3Quc2V0S2V5ZnJhbWVzKCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNzc19wcm9wZXJ0eV90b19jYW1lbGNhc2Uoc3R5bGUpIHtcblx0Ly8gaW4gY29tcGxpYW5jZSB3aXRoIHNwZWNcblx0aWYgKHN0eWxlID09PSAnZmxvYXQnKSByZXR1cm4gJ2Nzc0Zsb2F0Jztcblx0aWYgKHN0eWxlID09PSAnb2Zmc2V0JykgcmV0dXJuICdjc3NPZmZzZXQnO1xuXG5cdC8vIGRvIG5vdCByZW5hbWUgY3VzdG9tIEBwcm9wZXJ0aWVzXG5cdGlmIChzdHlsZS5zdGFydHNXaXRoKCctLScpKSByZXR1cm4gc3R5bGU7XG5cblx0Y29uc3QgcGFydHMgPSBzdHlsZS5zcGxpdCgnLScpO1xuXHRpZiAocGFydHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydHNbMF07XG5cdHJldHVybiAoXG5cdFx0cGFydHNbMF0gK1xuXHRcdHBhcnRzXG5cdFx0XHQuc2xpY2UoMSlcblx0XHRcdC5tYXAoLyoqIEBwYXJhbSB7YW55fSB3b3JkICovICh3b3JkKSA9PiB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuXHRcdFx0LmpvaW4oJycpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1xuICogQHJldHVybnMge0tleWZyYW1lfVxuICovXG5mdW5jdGlvbiBjc3NfdG9fa2V5ZnJhbWUoY3NzKSB7XG5cdC8qKiBAdHlwZSB7S2V5ZnJhbWV9ICovXG5cdGNvbnN0IGtleWZyYW1lID0ge307XG5cdGNvbnN0IHBhcnRzID0gY3NzLnNwbGl0KCc7Jyk7XG5cdGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuXHRcdGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdID0gcGFydC5zcGxpdCgnOicpO1xuXHRcdGlmICghcHJvcGVydHkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG5cblx0XHRjb25zdCBmb3JtYXR0ZWRfcHJvcGVydHkgPSBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHByb3BlcnR5LnRyaW0oKSk7XG5cdFx0a2V5ZnJhbWVbZm9ybWF0dGVkX3Byb3BlcnR5XSA9IHZhbHVlLnRyaW0oKTtcblx0fVxuXHRyZXR1cm4ga2V5ZnJhbWU7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdCAqL1xuY29uc3QgbGluZWFyID0gKHQpID0+IHQ7XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBrZXllZCBgeyNlYWNoIC4uLn1gIGJsb2NrcyAoYXMgYCQuYW5pbWF0aW9uKC4uLilgKS4gVGhpcyBjcmVhdGVzIGFuIGFuaW1hdGlvbiBtYW5hZ2VyXG4gKiBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIGJsb2NrLCBzbyB0aGF0IG1vdmVzIGNhbiBiZSBhbmltYXRlZCBmb2xsb3dpbmcgcmVjb25jaWxpYXRpb24uXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IEFuaW1hdGVGbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuaW1hdGlvbihlbGVtZW50LCBnZXRfZm4sIGdldF9wYXJhbXMpIHtcblx0dmFyIGl0ZW0gPSAvKiogQHR5cGUge0VhY2hJdGVtfSAqLyAoY3VycmVudF9lYWNoX2l0ZW0pO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIGZyb207XG5cblx0LyoqIEB0eXBlIHtET01SZWN0fSAqL1xuXHR2YXIgdG87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBhbmltYXRpb247XG5cblx0LyoqIEB0eXBlIHtudWxsIHwgeyBwb3NpdGlvbjogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgdHJhbnNmb3JtOiBzdHJpbmcgfX0gKi9cblx0dmFyIG9yaWdpbmFsX3N0eWxlcyA9IG51bGw7XG5cblx0aXRlbS5hID8/PSB7XG5cdFx0ZWxlbWVudCxcblx0XHRtZWFzdXJlKCkge1xuXHRcdFx0ZnJvbSA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9LFxuXHRcdGFwcGx5KCkge1xuXHRcdFx0YW5pbWF0aW9uPy5hYm9ydCgpO1xuXG5cdFx0XHR0byA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRmcm9tLmxlZnQgIT09IHRvLmxlZnQgfHxcblx0XHRcdFx0ZnJvbS5yaWdodCAhPT0gdG8ucmlnaHQgfHxcblx0XHRcdFx0ZnJvbS50b3AgIT09IHRvLnRvcCB8fFxuXHRcdFx0XHRmcm9tLmJvdHRvbSAhPT0gdG8uYm90dG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IGdldF9mbigpKHRoaXMuZWxlbWVudCwgeyBmcm9tLCB0byB9LCBnZXRfcGFyYW1zPy4oKSk7XG5cblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSh0aGlzLmVsZW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCwgMSwgKCkgPT4ge1xuXHRcdFx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblx0XHRcdFx0XHRhbmltYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zml4KCkge1xuXHRcdFx0Ly8gSWYgYW4gYW5pbWF0aW9uIGlzIGFscmVhZHkgcnVubmluZywgdHJhbnNmb3JtaW5nIHRoZSBlbGVtZW50IGlzIGxpa2VseSB0byBmYWlsLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgc3R5bGVzIGFwcGxpZWQgYnkgdGhlIGFuaW1hdGlvbiB0YWtlIHByZWNlZGVuY2UuIEluIHRoZSBjYXNlIG9mIGNyb3NzZmFkZSxcblx0XHRcdC8vIHRoYXQgbWVhbnMgdGhlIGB0cmFuc2xhdGUoLi4uKWAgb2YgdGhlIGNyb3NzZmFkZSB0cmFuc2l0aW9uIG92ZXJydWxlcyB0aGUgYHRyYW5zbGF0ZSguLi4pYFxuXHRcdFx0Ly8gd2Ugd291bGQgYXBwbHkgYmVsb3csIGxlYWRpbmcgdG8gdGhlIGVsZW1lbnQganVtcGluZyBzb21ld2hlcmUgdG8gdGhlIHRvcCBsZWZ0LlxuXHRcdFx0aWYgKGVsZW1lbnQuZ2V0QW5pbWF0aW9ucygpLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0byBkZXN0cnVjdHVyZSB0aGVzZSB0byBnZXQgZml4ZWQgdmFsdWVzIC0gdGhlIG9iamVjdCBpdHNlbGYgaGFzIGdldHRlcnMsXG5cdFx0XHQvLyBhbmQgY2hhbmdpbmcgdGhlIHN0eWxlIHRvICdhYnNvbHV0ZScgY2FuIGZvciBleGFtcGxlIGluZmx1ZW5jZSB0aGUgd2lkdGguXG5cdFx0XHR2YXIgeyBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGU7XG5cblx0XHRcdFx0b3JpZ2luYWxfc3R5bGVzID0ge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBzdHlsZS5wb3NpdGlvbixcblx0XHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG5cdFx0XHRcdFx0dHJhbnNmb3JtOiBzdHlsZS50cmFuc2Zvcm1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0dmFyIHRvID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8IGZyb20udG9wICE9PSB0by50b3ApIHtcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2Zyb20ubGVmdCAtIHRvLmxlZnR9cHgsICR7ZnJvbS50b3AgLSB0by50b3B9cHgpYDtcblx0XHRcdFx0XHRzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPyBgJHtzdHlsZS50cmFuc2Zvcm19ICR7dHJhbnNmb3JtfWAgOiB0cmFuc2Zvcm07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuZml4KCkge1xuXHRcdFx0aWYgKG9yaWdpbmFsX3N0eWxlcykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdHN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxfc3R5bGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IG9yaWdpbmFsX3N0eWxlcy53aWR0aDtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxfc3R5bGVzLmhlaWdodDtcblx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gb3JpZ2luYWxfc3R5bGVzLnRyYW5zZm9ybTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gaW4gdGhlIGNhc2Ugb2YgYSBgPHN2ZWx0ZTplbGVtZW50PmAsIGl0J3MgcG9zc2libGUgZm9yIGAkLmFuaW1hdGlvbiguLi4pYCB0byBiZSBjYWxsZWRcblx0Ly8gd2hlbiBhbiBhbmltYXRpb24gbWFuYWdlciBhbHJlYWR5IGV4aXN0cywgaWYgdGhlIHRhZyBjaGFuZ2VzLiBpbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG9cblx0Ly8gc3dhcCBvdXQgdGhlIGVsZW1lbnQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgbWFuYWdlciwgaW4gY2FzZSBpdCBoYXBwZW5lZCBhdCB0aGUgc2FtZVxuXHQvLyBtb21lbnQgYXMgYSByZWNvbmNpbGlhdGlvblxuXHRpdGVtLmEuZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBibG9jayBlZmZlY3RzIGFzIGAkLnRyYW5zaXRpb24oLi4uKWAuIFRoaXMgY3JlYXRlcyBhIHRyYW5zaXRpb24gbWFuYWdlciBhbmRcbiAqIGF0dGFjaGVzIGl0IHRvIHRoZSBjdXJyZW50IGVmZmVjdCDigJQgbGF0ZXIsIGluc2lkZSBgcGF1c2VfZWZmZWN0YCBhbmQgYHJlc3VtZV9lZmZlY3RgLCB3ZVxuICogdXNlIHRoaXMgdG8gY3JlYXRlIGBpbnRyb2AgYW5kIGBvdXRyb2AgdHJhbnNpdGlvbnMuXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IFRyYW5zaXRpb25GbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbihmbGFncywgZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpc19pbnRybyA9IChmbGFncyAmIFRSQU5TSVRJT05fSU4pICE9PSAwO1xuXHR2YXIgaXNfb3V0cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX09VVCkgIT09IDA7XG5cdHZhciBpc19ib3RoID0gaXNfaW50cm8gJiYgaXNfb3V0cm87XG5cdHZhciBpc19nbG9iYWwgPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0dMT0JBTCkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHsnaW4nIHwgJ291dCcgfCAnYm90aCd9ICovXG5cdHZhciBkaXJlY3Rpb24gPSBpc19ib3RoID8gJ2JvdGgnIDogaXNfaW50cm8gPyAnaW4nIDogJ291dCc7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGN1cnJlbnRfb3B0aW9ucztcblxuXHR2YXIgaW5lcnQgPSBlbGVtZW50LmluZXJ0O1xuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBvdmVyZmxvdyBzdHlsZSwgc3Rhc2hlZCBzbyB3ZSBjYW4gcmV2ZXJ0IGNoYW5nZXMgZHVyaW5nIHRoZSB0cmFuc2l0aW9uXG5cdCAqIHRoYXQgYXJlIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSA8MTggYnVnXG5cdCAqIFRPRE8gNi4wIHJlbW92ZSB0aGlzLCBpZiBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgaGF2ZSBkaWVkIG91dCBlbm91Z2hcblx0ICovXG5cdHZhciBvdmVyZmxvdyA9IGVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBpbnRybztcblxuXHQvKiogQHR5cGUge0FuaW1hdGlvbiB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIG91dHJvO1xuXG5cdGZ1bmN0aW9uIGdldF9vcHRpb25zKCkge1xuXHRcdHJldHVybiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0Ly8gSWYgYSB0cmFuc2l0aW9uIGlzIHN0aWxsIG9uZ29pbmcsIHdlIHVzZSB0aGUgZXhpc3Rpbmcgb3B0aW9ucyByYXRoZXIgdGhhbiBnZW5lcmF0aW5nXG5cdFx0XHQvLyBuZXcgb25lcy4gVGhpcyBlbnN1cmVzIHRoYXQgcmV2ZXJzaWJsZSB0cmFuc2l0aW9ucyByZXZlcnNlIHNtb290aGx5LCByYXRoZXIgdGhhblxuXHRcdFx0Ly8ganVtcGluZyB0byBhIG5ldyBzcG90IGJlY2F1c2UgKGZvciBleGFtcGxlKSBhIGRpZmZlcmVudCBgZHVyYXRpb25gIHdhcyB1c2VkXG5cdFx0XHRyZXR1cm4gKGN1cnJlbnRfb3B0aW9ucyA/Pz0gZ2V0X2ZuKCkoZWxlbWVudCwgZ2V0X3BhcmFtcz8uKCkgPz8gLyoqIEB0eXBlIHtQfSAqLyAoe30pLCB7XG5cdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0fSkpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcn0gKi9cblx0dmFyIHRyYW5zaXRpb24gPSB7XG5cdFx0aXNfZ2xvYmFsLFxuXHRcdGluKCkge1xuXHRcdFx0ZWxlbWVudC5pbmVydCA9IGluZXJ0O1xuXG5cdFx0XHRpZiAoIWlzX2ludHJvKSB7XG5cdFx0XHRcdG91dHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRvdXRybz8ucmVzZXQ/LigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNfb3V0cm8pIHtcblx0XHRcdFx0Ly8gaWYgd2UgaW50cm8gdGhlbiBvdXRybyB0aGVuIGludHJvIGFnYWluLCB3ZSB3YW50IHRvIGFib3J0IHRoZSBmaXJzdCBpbnRybyxcblx0XHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiaWRpcmVjdGlvbmFsIHRyYW5zaXRpb25cblx0XHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdpbnRyb3N0YXJ0Jyk7XG5cblx0XHRcdGludHJvID0gYW5pbWF0ZShlbGVtZW50LCBnZXRfb3B0aW9ucygpLCBvdXRybywgMSwgKCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnaW50cm9lbmQnKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgd2UgY2FuY2VsIHRoZSBhbmltYXRpb24gdG8gcHJldmVudCBsZWFraW5nXG5cdFx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRpbnRybyA9IGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG91dChmbikge1xuXHRcdFx0aWYgKCFpc19vdXRybykge1xuXHRcdFx0XHRmbj8uKCk7XG5cdFx0XHRcdGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtZW50LmluZXJ0ID0gdHJ1ZTtcblxuXHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ291dHJvc3RhcnQnKTtcblxuXHRcdFx0b3V0cm8gPSBhbmltYXRlKGVsZW1lbnQsIGdldF9vcHRpb25zKCksIGludHJvLCAwLCAoKSA9PiB7XG5cdFx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdvdXRyb2VuZCcpO1xuXHRcdFx0XHRmbj8uKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdHN0b3A6ICgpID0+IHtcblx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0b3V0cm8/LmFib3J0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBlID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHQoZS50cmFuc2l0aW9ucyA/Pz0gW10pLnB1c2godHJhbnNpdGlvbik7XG5cblx0Ly8gaWYgdGhpcyBpcyBhIGxvY2FsIHRyYW5zaXRpb24sIHdlIG9ubHkgd2FudCB0byBydW4gaXQgaWYgdGhlIHBhcmVudCAoYnJhbmNoKSBlZmZlY3Qnc1xuXHQvLyBwYXJlbnQgKGJsb2NrKSBlZmZlY3QgaXMgd2hlcmUgdGhlIHN0YXRlIGNoYW5nZSBoYXBwZW5lZC4gd2UgY2FuIGRldGVybWluZSB0aGF0IGJ5XG5cdC8vIGxvb2tpbmcgYXQgd2hldGhlciB0aGUgYmxvY2sgZWZmZWN0IGlzIGN1cnJlbnRseSBpbml0aWFsaXppbmdcblx0aWYgKGlzX2ludHJvICYmIHNob3VsZF9pbnRybykge1xuXHRcdHZhciBydW4gPSBpc19nbG9iYWw7XG5cblx0XHRpZiAoIXJ1bikge1xuXHRcdFx0dmFyIGJsb2NrID0gLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqLyAoZS5wYXJlbnQpO1xuXG5cdFx0XHQvLyBza2lwIG92ZXIgdHJhbnNwYXJlbnQgYmxvY2tzIChlLmcuIHNuaXBwZXRzLCBlbHNlLWlmIGJsb2Nrcylcblx0XHRcdHdoaWxlIChibG9jayAmJiAoYmxvY2suZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDApIHtcblx0XHRcdFx0d2hpbGUgKChibG9jayA9IGJsb2NrLnBhcmVudCkpIHtcblx0XHRcdFx0XHRpZiAoKGJsb2NrLmYgJiBCTE9DS19FRkZFQ1QpICE9PSAwKSBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRydW4gPSAhYmxvY2sgfHwgKGJsb2NrLmYgJiBFRkZFQ1RfUkFOKSAhPT0gMDtcblx0XHR9XG5cblx0XHRpZiAocnVuKSB7XG5cdFx0XHRlZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHR1bnRyYWNrKCgpID0+IHRyYW5zaXRpb24uaW4oKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhbiBlbGVtZW50LCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKX0gb3B0aW9uc1xuICogQHBhcmFtIHtBbmltYXRpb24gfCB1bmRlZmluZWR9IGNvdW50ZXJwYXJ0IFRoZSBjb3JyZXNwb25kaW5nIGludHJvL291dHJvIHRvIHRoaXMgb3V0cm8vaW50cm9cbiAqIEBwYXJhbSB7bnVtYmVyfSB0MiBUaGUgdGFyZ2V0IGB0YCB2YWx1ZSDigJQgYDFgIGZvciBpbnRybywgYDBgIGZvciBvdXRyb1xuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IG9uX2ZpbmlzaCBDYWxsZWQgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRpbmcgdGhlIGFuaW1hdGlvblxuICogQHJldHVybnMge0FuaW1hdGlvbn1cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBvcHRpb25zLCBjb3VudGVycGFydCwgdDIsIG9uX2ZpbmlzaCkge1xuXHR2YXIgaXNfaW50cm8gPSB0MiA9PT0gMTtcblxuXHRpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucykpIHtcblx0XHQvLyBJbiB0aGUgY2FzZSBvZiBhIGRlZmVycmVkIHRyYW5zaXRpb24gKHN1Y2ggYXMgYGNyb3NzZmFkZWApLCBgb3B0aW9uYCB3aWxsIGJlXG5cdFx0Ly8gYSBmdW5jdGlvbiByYXRoZXIgdGhhbiBhbiBgQW5pbWF0aW9uQ29uZmlnYC4gV2UgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb25cblx0XHQvLyBvbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZC4uLlxuXHRcdC8qKiBAdHlwZSB7QW5pbWF0aW9ufSAqL1xuXHRcdHZhciBhO1xuXHRcdHZhciBhYm9ydGVkID0gZmFsc2U7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmIChhYm9ydGVkKSByZXR1cm47XG5cdFx0XHR2YXIgbyA9IG9wdGlvbnMoeyBkaXJlY3Rpb246IGlzX2ludHJvID8gJ2luJyA6ICdvdXQnIH0pO1xuXHRcdFx0YSA9IGFuaW1hdGUoZWxlbWVudCwgbywgY291bnRlcnBhcnQsIHQyLCBvbl9maW5pc2gpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gLi4uYnV0IHdlIHdhbnQgdG8gZG8gc28gd2l0aG91dCB1c2luZyBgYXN5bmNgL2Bhd2FpdGAgZXZlcnl3aGVyZSwgc29cblx0XHQvLyB3ZSByZXR1cm4gYSBmYWNhZGUgdGhhdCBhbGxvd3MgZXZlcnl0aGluZyB0byByZW1haW4gc3luY2hyb25vdXNcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWJvcnQ6ICgpID0+IHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdGE/LmFib3J0KCk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVhY3RpdmF0ZTogKCkgPT4gYS5kZWFjdGl2YXRlKCksXG5cdFx0XHRyZXNldDogKCkgPT4gYS5yZXNldCgpLFxuXHRcdFx0dDogKCkgPT4gYS50KClcblx0XHR9O1xuXHR9XG5cblx0Y291bnRlcnBhcnQ/LmRlYWN0aXZhdGUoKTtcblxuXHRpZiAoIW9wdGlvbnM/LmR1cmF0aW9uKSB7XG5cdFx0b25fZmluaXNoKCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWJvcnQ6IG5vb3AsXG5cdFx0XHRkZWFjdGl2YXRlOiBub29wLFxuXHRcdFx0cmVzZXQ6IG5vb3AsXG5cdFx0XHR0OiAoKSA9PiB0MlxuXHRcdH07XG5cdH1cblxuXHRjb25zdCB7IGRlbGF5ID0gMCwgY3NzLCB0aWNrLCBlYXNpbmcgPSBsaW5lYXIgfSA9IG9wdGlvbnM7XG5cblx0dmFyIGtleWZyYW1lcyA9IFtdO1xuXG5cdGlmIChpc19pbnRybyAmJiBjb3VudGVycGFydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRpY2spIHtcblx0XHRcdHRpY2soMCwgMSk7IC8vIFRPRE8gcHV0IGluIG5lc3RlZCBlZmZlY3QsIHRvIGF2b2lkIGludGVybGVhdmVkIHJlYWRzL3dyaXRlcz9cblx0XHR9XG5cblx0XHRpZiAoY3NzKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gY3NzX3RvX2tleWZyYW1lKGNzcygwLCAxKSk7XG5cdFx0XHRrZXlmcmFtZXMucHVzaChzdHlsZXMsIHN0eWxlcyk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGdldF90ID0gKCkgPT4gMSAtIHQyO1xuXG5cdC8vIGNyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiB0aGF0IGxhc3RzIGFzIGxvbmcgYXMgdGhlIGRlbGF5IChidXQgd2l0aCB3aGF0ZXZlciBkZXZ0b29sc1xuXHQvLyBtdWx0aXBsaWVyIGlzIGluIGVmZmVjdCkuIGluIHRoZSBjb21tb24gY2FzZSB0aGF0IGl0IGlzIGAwYCwgd2Uga2VlcCBpdCBhbnl3YXkgc28gdGhhdFxuXHQvLyB0aGUgQ1NTIGtleWZyYW1lcyBhcmVuJ3QgY3JlYXRlZCB1bnRpbCB0aGUgRE9NIGlzIHVwZGF0ZWRcblx0Ly9cblx0Ly8gZmlsbCBmb3J3YXJkcyB0byBwcmV2ZW50IHRoZSBlbGVtZW50IGZyb20gcmVuZGVyaW5nIHdpdGhvdXQgc3R5bGVzIGFwcGxpZWRcblx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzE0NzMyXG5cdHZhciBhbmltYXRpb24gPSBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCB7IGR1cmF0aW9uOiBkZWxheSwgZmlsbDogJ2ZvcndhcmRzJyB9KTtcblxuXHRhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG5cdFx0Ly8gcmVtb3ZlIGR1bW15IGFuaW1hdGlvbiBmcm9tIHRoZSBzdGFjayB0byBwcmV2ZW50IGNvbmZsaWN0IHdpdGggbWFpbiBhbmltYXRpb25cblx0XHRhbmltYXRpb24uY2FuY2VsKCk7XG5cblx0XHQvLyBmb3IgYmlkaXJlY3Rpb25hbCB0cmFuc2l0aW9ucywgd2Ugc3RhcnQgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbixcblx0XHQvLyByYXRoZXIgdGhhbiBkb2luZyBhIGZ1bGwgaW50cm8vb3V0cm9cblx0XHR2YXIgdDEgPSBjb3VudGVycGFydD8udCgpID8/IDEgLSB0Mjtcblx0XHRjb3VudGVycGFydD8uYWJvcnQoKTtcblxuXHRcdHZhciBkZWx0YSA9IHQyIC0gdDE7XG5cdFx0dmFyIGR1cmF0aW9uID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvcHRpb25zLmR1cmF0aW9uKSAqIE1hdGguYWJzKGRlbHRhKTtcblx0XHR2YXIga2V5ZnJhbWVzID0gW107XG5cblx0XHRpZiAoZHVyYXRpb24gPiAwKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBDU1MgaW5jbHVkZXMgYG92ZXJmbG93OiBoaWRkZW5gLCBpbiB3aGljaCBjYXNlIHdlIG5lZWQgdG9cblx0XHRcdCAqIGFkZCBpdCBhcyBhbiBpbmxpbmUgc3R5bGUgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgPDE4IGJ1Z1xuXHRcdFx0ICogVE9ETyA2LjAgcmVtb3ZlIHRoaXMsIGlmIHBvc3NpYmxlXG5cdFx0XHQgKi9cblx0XHRcdHZhciBuZWVkc19vdmVyZmxvd19oaWRkZW4gPSBmYWxzZTtcblxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHR2YXIgbiA9IE1hdGguY2VpbChkdXJhdGlvbiAvICgxMDAwIC8gNjApKTsgLy8gYG5gIG11c3QgYmUgYW4gaW50ZWdlciwgb3Igd2UgcmlzayBtaXNzaW5nIHRoZSBgdDJgIHZhbHVlXG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSB0MSArIGRlbHRhICogZWFzaW5nKGkgLyBuKTtcblx0XHRcdFx0XHR2YXIgc3R5bGVzID0gY3NzX3RvX2tleWZyYW1lKGNzcyh0LCAxIC0gdCkpO1xuXHRcdFx0XHRcdGtleWZyYW1lcy5wdXNoKHN0eWxlcyk7XG5cblx0XHRcdFx0XHRuZWVkc19vdmVyZmxvd19oaWRkZW4gfHw9IHN0eWxlcy5vdmVyZmxvdyA9PT0gJ2hpZGRlbic7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lZWRzX292ZXJmbG93X2hpZGRlbikge1xuXHRcdFx0XHQvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblx0XHRcdH1cblxuXHRcdFx0Z2V0X3QgPSAoKSA9PiB7XG5cdFx0XHRcdHZhciB0aW1lID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcblx0XHRcdFx0XHQvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqLyAoYW5pbWF0aW9uKS5jdXJyZW50VGltZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHJldHVybiB0MSArIGRlbHRhICogZWFzaW5nKHRpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGljaykge1xuXHRcdFx0XHRsb29wKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ3J1bm5pbmcnKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR2YXIgdCA9IGdldF90KCk7XG5cdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbiwgZmlsbDogJ2ZvcndhcmRzJyB9KTtcblxuXHRcdGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcblx0XHRcdGdldF90ID0gKCkgPT4gdDI7XG5cdFx0XHR0aWNrPy4odDIsIDEgLSB0Mik7XG5cdFx0XHRvbl9maW5pc2goKTtcblx0XHR9O1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0YWJvcnQ6ICgpID0+IHtcblx0XHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdFx0YW5pbWF0aW9uLmNhbmNlbCgpO1xuXHRcdFx0XHQvLyBUaGlzIHByZXZlbnRzIG1lbW9yeSBsZWFrcyBpbiBDaHJvbWl1bVxuXHRcdFx0XHRhbmltYXRpb24uZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0Ly8gVGhpcyBwcmV2ZW50cyBvbmZpbmlzaCB0byBiZSBsYXVuY2hlZCBhZnRlciBjYW5jZWwoKSxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGhhcHBlbiBpbiBzb21lIHJhcmUgY2FzZXNcblx0XHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzEzNjgxXG5cdFx0XHRcdGFuaW1hdGlvbi5vbmZpbmlzaCA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWFjdGl2YXRlOiAoKSA9PiB7XG5cdFx0XHRvbl9maW5pc2ggPSBub29wO1xuXHRcdH0sXG5cdFx0cmVzZXQ6ICgpID0+IHtcblx0XHRcdGlmICh0MiA9PT0gMCkge1xuXHRcdFx0XHR0aWNrPy4oMSwgMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0OiAoKSA9PiBnZXRfdCgpXG5cdH07XG59XG4iLCIvKiogQGltcG9ydCB7IEJhdGNoIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudCB9IGZyb20gJy4vc2hhcmVkLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uLy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHRpY2ssIHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGlzX3J1bmVzIH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2JhdGNoLCBwcmV2aW91c19iYXRjaCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfdmFsdWUoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBiYXRjaGVzID0gbmV3IFdlYWtTZXQoKTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnaW5wdXQnLCBhc3luYyAoaXNfcmVzZXQpID0+IHtcblx0XHRpZiAoREVWICYmIGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKTtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge2FueX0gKi9cblx0XHR2YXIgdmFsdWUgPSBpc19yZXNldCA/IGlucHV0LmRlZmF1bHRWYWx1ZSA6IGlucHV0LnZhbHVlO1xuXHRcdHZhbHVlID0gaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIodmFsdWUpIDogdmFsdWU7XG5cdFx0c2V0KHZhbHVlKTtcblxuXHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSBudWxsKSB7XG5cdFx0XHRiYXRjaGVzLmFkZChjdXJyZW50X2JhdGNoKTtcblx0XHR9XG5cblx0XHQvLyBCZWNhdXNlIGB7I2VhY2ggLi4ufWAgYmxvY2tzIHdvcmsgYnkgdXBkYXRpbmcgc291cmNlcyBpbnNpZGUgdGhlIGZsdXNoLFxuXHRcdC8vIHdlIG5lZWQgdG8gd2FpdCBhIHRpY2sgYmVmb3JlIGNoZWNraW5nIHRvIHNlZSBpZiB3ZSBzaG91bGQgZm9yY2libHlcblx0XHQvLyB1cGRhdGUgdGhlIGlucHV0IGFuZCByZXNldCB0aGUgc2VsZWN0aW9uIHN0YXRlXG5cdFx0YXdhaXQgdGljaygpO1xuXG5cdFx0Ly8gUmVzcGVjdCBhbnkgdmFsaWRhdGlvbiBpbiBhY2Nlc3NvcnNcblx0XHRpZiAodmFsdWUgIT09ICh2YWx1ZSA9IGdldCgpKSkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG5cdFx0XHR2YXIgZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGlucHV0LnZhbHVlLmxlbmd0aDtcblxuXHRcdFx0Ly8gdGhlIHZhbHVlIGlzIGNvZXJjZWQgb24gYXNzaWdubWVudFxuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZSA/PyAnJztcblxuXHRcdFx0Ly8gUmVzdG9yZSBzZWxlY3Rpb25cblx0XHRcdGlmIChlbmQgIT09IG51bGwpIHtcblx0XHRcdFx0dmFyIG5ld19sZW5ndGggPSBpbnB1dC52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdC8vIElmIGN1cnNvciB3YXMgYXQgZW5kIGFuZCBuZXcgaW5wdXQgaXMgbG9uZ2VyLCBtb3ZlIGN1cnNvciB0byBuZXcgZW5kXG5cdFx0XHRcdGlmIChzdGFydCA9PT0gZW5kICYmIGVuZCA9PT0gbGVuZ3RoICYmIG5ld19sZW5ndGggPiBsZW5ndGgpIHtcblx0XHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25TdGFydCA9IG5ld19sZW5ndGg7XG5cdFx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uRW5kID0gbmV3X2xlbmd0aDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRcdGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgbmV3X2xlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHQoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRWYWx1ZSAhPT0gaW5wdXQudmFsdWUpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdFZhbHVlIGlzIHNldCwgdGhlbiB2YWx1ZSA9PSBkZWZhdWx0VmFsdWVcblx0XHQvLyBUT0RPIFN2ZWx0ZSA2OiByZW1vdmUgaW5wdXQudmFsdWUgY2hlY2sgYW5kIHNldCB0byBlbXB0eSBzdHJpbmc/XG5cdFx0KHVudHJhY2soZ2V0KSA9PSBudWxsICYmIGlucHV0LnZhbHVlKVxuXHQpIHtcblx0XHRzZXQoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIoaW5wdXQudmFsdWUpIDogaW5wdXQudmFsdWUpO1xuXG5cdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IG51bGwpIHtcblx0XHRcdGJhdGNoZXMuYWRkKGN1cnJlbnRfYmF0Y2gpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChERVYgJiYgaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLmJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0aWYgKGlucHV0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG5cdFx0XHQvLyB3ZSBuZWVkIGJvdGgsIGJlY2F1c2UgaW4gbm9uLWFzeW5jIG1vZGUsIHJlbmRlciBlZmZlY3RzIHJ1biBiZWZvcmUgcHJldmlvdXNfYmF0Y2ggaXMgc2V0XG5cdFx0XHR2YXIgYmF0Y2ggPSAvKiogQHR5cGUge0JhdGNofSAqLyAocHJldmlvdXNfYmF0Y2ggPz8gY3VycmVudF9iYXRjaCk7XG5cblx0XHRcdC8vIE5ldmVyIHJld3JpdGUgdGhlIGNvbnRlbnRzIG9mIGEgZm9jdXNlZCBpbnB1dC4gV2UgY2FuIGdldCBoZXJlIGlmLCBmb3IgZXhhbXBsZSxcblx0XHRcdC8vIGFuIHVwZGF0ZSBpcyBkZWZlcnJlZCBiZWNhdXNlIG9mIGFzeW5jIHdvcmsgZGVwZW5kaW5nIG9uIHRoZSBpbnB1dDpcblx0XHRcdC8vXG5cdFx0XHQvLyA8aW5wdXQgYmluZDp2YWx1ZT17cXVlcnl9PlxuXHRcdFx0Ly8gPHA+e2F3YWl0IGZpbmQocXVlcnkpfTwvcD5cblx0XHRcdGlmIChiYXRjaGVzLmhhcyhiYXRjaCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSAmJiB2YWx1ZSA9PT0gdG9fbnVtYmVyKGlucHV0LnZhbHVlKSkge1xuXHRcdFx0Ly8gaGFuZGxlcyAwIHZzIDAwIGNhc2UgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy85OTU5KVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC50eXBlID09PSAnZGF0ZScgJiYgIXZhbHVlICYmICFpbnB1dC52YWx1ZSkge1xuXHRcdFx0Ly8gSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIHRlbXBvcmFyaWx5IGludmFsaWQgZGF0ZSBpcyBzZXQgKHdoaWxlIHR5cGluZywgZm9yIGV4YW1wbGUgd2l0aCBhIGxlYWRpbmcgMCBmb3IgdGhlIGRheSlcblx0XHRcdC8vIGFuZCBwcmV2ZW50cyB0aGlzIHN0YXRlIGZyb20gY2xlYXJpbmcgdGhlIG90aGVyIHBhcnRzIG9mIHRoZSBkYXRlIGlucHV0IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNzg5Nylcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBzZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpZiBpdCdzIHRoZSBzYW1lIHRvIGFsbG93XG5cdFx0Ly8gbWlubGVuZ3RoIHRvIHdvcmsgcHJvcGVybHlcblx0XHRpZiAodmFsdWUgIT09IGlucHV0LnZhbHVlKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB2YWx1ZSBpcyBjb2VyY2VkIG9uIGFzc2lnbm1lbnRcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWUgPz8gJyc7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqIEB0eXBlIHtTZXQ8SFRNTElucHV0RWxlbWVudFtdPn0gKi9cbmNvbnN0IHBlbmRpbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGlucHV0c1xuICogQHBhcmFtIHtudWxsIHwgW251bWJlcl19IGdyb3VwX2luZGV4XG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2dyb3VwKGlucHV0cywgZ3JvdXBfaW5kZXgsIGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgaXNfY2hlY2tib3ggPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94Jztcblx0dmFyIGJpbmRpbmdfZ3JvdXAgPSBpbnB1dHM7XG5cblx0Ly8gbmVlZHMgdG8gYmUgbGV0IG9yIHJlbGF0ZWQgY29kZSBpc24ndCB0cmVlc2hha2VuIG91dCBpZiBpdCdzIGFsd2F5cyBmYWxzZVxuXHRsZXQgaHlkcmF0aW9uX21pc21hdGNoID0gZmFsc2U7XG5cblx0aWYgKGdyb3VwX2luZGV4ICE9PSBudWxsKSB7XG5cdFx0Zm9yICh2YXIgaW5kZXggb2YgZ3JvdXBfaW5kZXgpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGJpbmRpbmdfZ3JvdXAgPSBiaW5kaW5nX2dyb3VwW2luZGV4XSA/Pz0gW107XG5cdFx0fVxuXHR9XG5cblx0YmluZGluZ19ncm91cC5wdXNoKGlucHV0KTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KFxuXHRcdGlucHV0LFxuXHRcdCdjaGFuZ2UnLFxuXHRcdCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0Ll9fdmFsdWU7XG5cblx0XHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGJpbmRpbmdfZ3JvdXAsIHZhbHVlLCBpbnB1dC5jaGVja2VkKTtcblx0XHRcdH1cblxuXHRcdFx0c2V0KHZhbHVlKTtcblx0XHR9LFxuXHRcdC8vIFRPRE8gYmV0dGVyIGRlZmF1bHQgdmFsdWUgaGFuZGxpbmdcblx0XHQoKSA9PiBzZXQoaXNfY2hlY2tib3ggPyBbXSA6IG51bGwpXG5cdCk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsIHRoZW4gdXNlIHRoZSB1cGRhdGUgdmFsdWVcblx0XHQvLyBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdGlmIChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdENoZWNrZWQgIT09IGlucHV0LmNoZWNrZWQpIHtcblx0XHRcdGh5ZHJhdGlvbl9taXNtYXRjaCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IFtdO1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IHZhbHVlLmluY2x1ZGVzKGlucHV0Ll9fdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRpbnB1dC5jaGVja2VkID0gaXMoaW5wdXQuX192YWx1ZSwgdmFsdWUpO1xuXHRcdH1cblx0fSk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdHZhciBpbmRleCA9IGJpbmRpbmdfZ3JvdXAuaW5kZXhPZihpbnB1dCk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRiaW5kaW5nX2dyb3VwLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoIXBlbmRpbmcuaGFzKGJpbmRpbmdfZ3JvdXApKSB7XG5cdFx0cGVuZGluZy5hZGQoYmluZGluZ19ncm91cCk7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdC8vIG5lY2Vzc2FyeSB0byBtYWludGFpbiBiaW5kaW5nIGdyb3VwIG9yZGVyIGluIGFsbCBpbnNlcnRpb24gc2NlbmFyaW9zXG5cdFx0XHRiaW5kaW5nX2dyb3VwLnNvcnQoKGEsIGIpID0+IChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpID09PSA0ID8gLTEgOiAxKSk7XG5cdFx0XHRwZW5kaW5nLmRlbGV0ZShiaW5kaW5nX2dyb3VwKTtcblx0XHR9KTtcblx0fVxuXG5cdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpb25fbWlzbWF0Y2gpIHtcblx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoYmluZGluZ19ncm91cCwgdmFsdWUsIGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGh5ZHJhdGlvbl9pbnB1dCA9IGJpbmRpbmdfZ3JvdXAuZmluZCgoaW5wdXQpID0+IGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdHZhbHVlID0gaHlkcmF0aW9uX2lucHV0Py5fX3ZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXQodmFsdWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9jaGVja2VkKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gaXNfcmVzZXQgPyBpbnB1dC5kZWZhdWx0Q2hlY2tlZCA6IGlucHV0LmNoZWNrZWQ7XG5cdFx0c2V0KHZhbHVlKTtcblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0KGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0Q2hlY2tlZCAhPT0gaW5wdXQuY2hlY2tlZCkgfHxcblx0XHQvLyBJZiBkZWZhdWx0Q2hlY2tlZCBpcyBzZXQsIHRoZW4gY2hlY2tlZCA9PSBkZWZhdWx0Q2hlY2tlZFxuXHRcdHVudHJhY2soZ2V0KSA9PSBudWxsXG5cdCkge1xuXHRcdHNldChpbnB1dC5jaGVja2VkKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXHRcdGlucHV0LmNoZWNrZWQgPSBCb29sZWFuKHZhbHVlKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7QXJyYXk8SFRNTElucHV0RWxlbWVudD59IGdyb3VwXG4gKiBAcGFyYW0ge1Z9IF9fdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZFxuICogQHJldHVybnMge1ZbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0LyoqIEB0eXBlIHtTZXQ8Vj59ICovXG5cdHZhciB2YWx1ZSA9IG5ldyBTZXQoKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSB7XG5cdHZhciB0eXBlID0gaW5wdXQudHlwZTtcblx0cmV0dXJuIHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IEZpbGVMaXN0IHwgbnVsbH0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogRmlsZUxpc3QgfCBudWxsKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZmlsZXMoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0c2V0KGlucHV0LmZpbGVzKTtcblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlZCB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdGh5ZHJhdGluZyAmJlxuXHRcdGlucHV0LmZpbGVzXG5cdCkge1xuXHRcdHNldChpbnB1dC5maWxlcyk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpbnB1dC5maWxlcyA9IGdldCgpO1xuXHR9KTtcbn1cbiIsImltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBNYWtlcyBhbiBgZXhwb3J0YGVkIChub24tcHJvcCkgdmFyaWFibGUgYXZhaWxhYmxlIG9uIHRoZSBgJCRwcm9wc2Agb2JqZWN0XG4gKiBzbyB0aGF0IGNvbnN1bWVycyBjYW4gZG8gYGJpbmQ6eGAgb24gdGhlIGNvbXBvbmVudC5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9wcm9wKHByb3BzLCBwcm9wLCB2YWx1ZSkge1xuXHR2YXIgZGVzYyA9IGdldF9kZXNjcmlwdG9yKHByb3BzLCBwcm9wKTtcblxuXHRpZiAoZGVzYyAmJiBkZXNjLnNldCkge1xuXHRcdHByb3BzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0cHJvcHNbcHJvcF0gPSBudWxsO1xuXHRcdH0pO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBlZmZlY3QsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uLy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uLy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBib3VuZF92YWx1ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50X29yX2NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzX2JvdW5kX3RoaXMoYm91bmRfdmFsdWUsIGVsZW1lbnRfb3JfY29tcG9uZW50KSB7XG5cdHJldHVybiAoXG5cdFx0Ym91bmRfdmFsdWUgPT09IGVsZW1lbnRfb3JfY29tcG9uZW50IHx8IGJvdW5kX3ZhbHVlPy5bU1RBVEVfU1lNQk9MXSA9PT0gZWxlbWVudF9vcl9jb21wb25lbnRcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZWxlbWVudF9vcl9jb21wb25lbnRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duLCAuLi5wYXJ0czogdW5rbm93bltdKSA9PiB2b2lkfSB1cGRhdGVcbiAqIEBwYXJhbSB7KC4uLnBhcnRzOiB1bmtub3duW10pID0+IHVua25vd259IGdldF92YWx1ZVxuICogQHBhcmFtIHsoKSA9PiB1bmtub3duW119IFtnZXRfcGFydHNdIFNldCBpZiB0aGUgdGhpcyBiaW5kaW5nIGlzIHVzZWQgaW5zaWRlIGFuIGVhY2ggYmxvY2ssXG4gKiBcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybnMgYWxsIHRoZSBwYXJ0cyBvZiB0aGUgZWFjaCBibG9jayBjb250ZXh0IHRoYXQgYXJlIHVzZWQgaW4gdGhlIGV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF90aGlzKGVsZW1lbnRfb3JfY29tcG9uZW50ID0ge30sIHVwZGF0ZSwgZ2V0X3ZhbHVlLCBnZXRfcGFydHMpIHtcblx0ZWZmZWN0KCgpID0+IHtcblx0XHQvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblx0XHR2YXIgb2xkX3BhcnRzO1xuXG5cdFx0LyoqIEB0eXBlIHt1bmtub3duW119ICovXG5cdFx0dmFyIHBhcnRzO1xuXG5cdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvbGRfcGFydHMgPSBwYXJ0cztcblx0XHRcdC8vIFdlIG9ubHkgdHJhY2sgY2hhbmdlcyB0byB0aGUgcGFydHMsIG5vdCB0aGUgdmFsdWUgaXRzZWxmIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcnVucy5cblx0XHRcdHBhcnRzID0gZ2V0X3BhcnRzPy4oKSB8fCBbXTtcblxuXHRcdFx0dW50cmFjaygoKSA9PiB7XG5cdFx0XHRcdGlmIChlbGVtZW50X29yX2NvbXBvbmVudCAhPT0gZ2V0X3ZhbHVlKC4uLnBhcnRzKSkge1xuXHRcdFx0XHRcdHVwZGF0ZShlbGVtZW50X29yX2NvbXBvbmVudCwgLi4ucGFydHMpO1xuXHRcdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gZWZmZWN0IHJlcnVuIChjYXVzZTogZWFjaCBibG9jayBjb250ZXh0IGNoYW5nZXMpLCB0aGVuIG51bGxmaXkgdGhlIGJpbmRpbmcgYXRcblx0XHRcdFx0XHQvLyB0aGUgcHJldmlvdXMgcG9zaXRpb24gaWYgaXQgaXNuJ3QgYWxyZWFkeSB0YWtlbiBvdmVyIGJ5IGEgZGlmZmVyZW50IGVmZmVjdC5cblx0XHRcdFx0XHRpZiAob2xkX3BhcnRzICYmIGlzX2JvdW5kX3RoaXMoZ2V0X3ZhbHVlKC4uLm9sZF9wYXJ0cyksIGVsZW1lbnRfb3JfY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKG51bGwsIC4uLm9sZF9wYXJ0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHQvLyBXZSBjYW5ub3QgdXNlIGVmZmVjdHMgaW4gdGhlIHRlYXJkb3duIHBoYXNlLCB3ZSB3ZSB1c2UgYSBtaWNyb3Rhc2sgaW5zdGVhZC5cblx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRpZiAocGFydHMgJiYgaXNfYm91bmRfdGhpcyhnZXRfdmFsdWUoLi4ucGFydHMpLCBlbGVtZW50X29yX2NvbXBvbmVudCkpIHtcblx0XHRcdFx0XHR1cGRhdGUobnVsbCwgLi4ucGFydHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudF9vcl9jb21wb25lbnQ7XG59XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJfcHJlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBvbiB9IGZyb20gJy4uL2VsZW1lbnRzL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGB0cnVzdGVkYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Zm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHNlbGZgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxmKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Zm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHN0b3BQcm9wYWdhdGlvbmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBvbmNlYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuXHR2YXIgcmFuID0gZmFsc2U7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBwcmV2ZW50RGVmYXVsdGAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgcGFzc2l2ZWAgZXZlbnQgbW9kaWZpZXIsIGltcGxlbWVudGVkIGFzIGFuIGFjdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7W2V2ZW50OiBzdHJpbmcsIGhhbmRsZXI6ICgpID0+IEV2ZW50TGlzdGVuZXJdfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXNzaXZlKG5vZGUsIFtldmVudCwgaGFuZGxlcl0pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRyZXR1cm4gb24obm9kZSwgZXZlbnQsIGhhbmRsZXIoKSA/PyBub29wLCB7XG5cdFx0XHRwYXNzaXZlOiB0cnVlXG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgbm9ucGFzc2l2ZWAgZXZlbnQgbW9kaWZpZXIsIGltcGxlbWVudGVkIGFzIGFuIGFjdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7W2V2ZW50OiBzdHJpbmcsIGhhbmRsZXI6ICgpID0+IEV2ZW50TGlzdGVuZXJdfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25wYXNzaXZlKG5vZGUsIFtldmVudCwgaGFuZGxlcl0pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRyZXR1cm4gb24obm9kZSwgZXZlbnQsIGhhbmRsZXIoKSA/PyBub29wLCB7XG5cdFx0XHRwYXNzaXZlOiBmYWxzZVxuXHRcdH0pO1xuXHR9KTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBydW4sIHJ1bl9hbGwgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGRlcml2ZWQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IHVzZXJfcHJlX2VmZmVjdCwgdXNlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGVlcF9yZWFkX3N0YXRlLCBnZXQsIHVudHJhY2sgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBMZWdhY3ktbW9kZSBvbmx5OiBDYWxsIGBvbk1vdW50YCBjYWxsYmFja3MgYW5kIHNldCB1cCBgYmVmb3JlVXBkYXRlYC9gYWZ0ZXJVcGRhdGVgIGVmZmVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoaW1tdXRhYmxlID0gZmFsc2UpIHtcblx0Y29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHRjb25zdCBjYWxsYmFja3MgPSBjb250ZXh0LmwudTtcblx0aWYgKCFjYWxsYmFja3MpIHJldHVybjtcblxuXHRsZXQgcHJvcHMgPSAoKSA9PiBkZWVwX3JlYWRfc3RhdGUoY29udGV4dC5zKTtcblxuXHRpZiAoaW1tdXRhYmxlKSB7XG5cdFx0bGV0IHZlcnNpb24gPSAwO1xuXHRcdGxldCBwcmV2ID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pO1xuXG5cdFx0Ly8gSW4gbGVnYWN5IGltbXV0YWJsZSBtb2RlLCBiZWZvcmUvYWZ0ZXJVcGRhdGUgb25seSBmaXJlIGlmIHRoZSBvYmplY3QgaWRlbnRpdHkgb2YgYSBwcm9wIGNoYW5nZXNcblx0XHRjb25zdCBkID0gZGVyaXZlZCgoKSA9PiB7XG5cdFx0XHRsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgcHJvcHMgPSBjb250ZXh0LnM7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHNba2V5XSAhPT0gcHJldltrZXldKSB7XG5cdFx0XHRcdFx0cHJldltrZXldID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNoYW5nZWQpIHZlcnNpb24rKztcblx0XHRcdHJldHVybiB2ZXJzaW9uO1xuXHRcdH0pO1xuXG5cdFx0cHJvcHMgPSAoKSA9PiBnZXQoZCk7XG5cdH1cblxuXHQvLyBiZWZvcmVVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5iLmxlbmd0aCkge1xuXHRcdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcyk7XG5cdFx0XHRydW5fYWxsKGNhbGxiYWNrcy5iKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIG9uTW91bnQgKG11c3QgcnVuIGJlZm9yZSBhZnRlclVwZGF0ZSlcblx0dXNlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGNvbnN0IGZucyA9IHVudHJhY2soKCkgPT4gY2FsbGJhY2tzLm0ubWFwKHJ1bikpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuXHRcdFx0XHRpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Zm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdC8vIGFmdGVyVXBkYXRlXG5cdGlmIChjYWxsYmFja3MuYS5sZW5ndGgpIHtcblx0XHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcyk7XG5cdFx0XHRydW5fYWxsKGNhbGxiYWNrcy5hKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEludm9rZSB0aGUgZ2V0dGVyIG9mIGFsbCBzaWduYWxzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBvbmVudFxuICogc28gdGhleSBjYW4gYmUgcmVnaXN0ZXJlZCB0byB0aGUgZWZmZWN0IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluLlxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSBjb250ZXh0XG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZV9hbGwoY29udGV4dCwgcHJvcHMpIHtcblx0aWYgKGNvbnRleHQubC5zKSB7XG5cdFx0Zm9yIChjb25zdCBzaWduYWwgb2YgY29udGV4dC5sLnMpIGdldChzaWduYWwpO1xuXHR9XG5cblx0cHJvcHMoKTtcbn1cbiIsImltcG9ydCB7IHNldCwgc291cmNlIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIFVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgaW1wb3J0cyBtYXkgYmUgcmVhY3RpdmUgaW4gbGVnYWN5IG1vZGUuIEluIHRoYXQgY2FzZSxcbiAqIHRoZXkgc2hvdWxkIGJlIHVzaW5nIGByZWFjdGl2ZV9pbXBvcnRgIGFzIHBhcnQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWN0aXZlX2ltcG9ydChmbikge1xuXHR2YXIgcyA9IHNvdXJjZSgwKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRzZXQocywgZ2V0KHMpICsgMSk7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXQocyk7XG5cdFx0XHRyZXR1cm4gZm4oKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHRoaXMge2FueX1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICQkcHJvcHNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZV9ldmVudCgkJHByb3BzLCBldmVudCkge1xuXHR2YXIgZXZlbnRzID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbltdIHwgRnVuY3Rpb24+fSAqLyAoJCRwcm9wcy4kJGV2ZW50cyk/Lltcblx0XHRldmVudC50eXBlXG5cdF07XG5cblx0dmFyIGNhbGxiYWNrcyA9IGlzX2FycmF5KGV2ZW50cykgPyBldmVudHMuc2xpY2UoKSA6IGV2ZW50cyA9PSBudWxsID8gW10gOiBbZXZlbnRzXTtcblxuXHRmb3IgKHZhciBmbiBvZiBjYWxsYmFja3MpIHtcblx0XHQvLyBQcmVzZXJ2ZSBcInRoaXNcIiBjb250ZXh0XG5cdFx0Zm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNpbXVsYXRlIGAkb25gIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIHdoZW4gYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpID09PSA0YFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRfY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9sZWdhY3lfZXZlbnRfbGlzdGVuZXIoJCRwcm9wcywgZXZlbnRfbmFtZSwgZXZlbnRfY2FsbGJhY2spIHtcblx0JCRwcm9wcy4kJGV2ZW50cyB8fD0ge307XG5cdCQkcHJvcHMuJCRldmVudHNbZXZlbnRfbmFtZV0gfHw9IFtdO1xuXHQkJHByb3BzLiQkZXZlbnRzW2V2ZW50X25hbWVdLnB1c2goZXZlbnRfY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFVzZWQgdG8gc2ltdWxhdGUgYCRzZXRgIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIHdoZW4gYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpID09PSA0YC5cbiAqIE5lZWRzIGNvbXBvbmVudCBhY2Nlc3NvcnMgc28gdGhhdCBpdCBjYW4gY2FsbCB0aGUgc2V0dGVyIG9mIHRoZSBwcm9wLiBUaGVyZWZvcmUgZG9lc24ndFxuICogd29yayBmb3IgdXBkYXRpbmcgcHJvcHMgaW4gYCQkcHJvcHNgIG9yIGAkJHJlc3RQcm9wc2AuXG4gKiBAdGhpcyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRuZXdfcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9sZWdhY3lfcHJvcHMoJCRuZXdfcHJvcHMpIHtcblx0Zm9yICh2YXIga2V5IGluICQkbmV3X3Byb3BzKSB7XG5cdFx0aWYgKGtleSBpbiB0aGlzKSB7XG5cdFx0XHR0aGlzW2tleV0gPSAkJG5ld19wcm9wc1trZXldO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJy4vcHVibGljJyAqL1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL2luZGV4LWNsaWVudC5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vaW50ZXJuYWwvc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcGFyYW0geyh2YWx1ZTogVCkgPT4gdm9pZH0gcnVuXG4gKiBAcGFyYW0geyh2YWx1ZTogVCkgPT4gdm9pZH0gW2ludmFsaWRhdGVdXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgcnVuLCBpbnZhbGlkYXRlKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHJ1bih1bmRlZmluZWQpO1xuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGlmIChpbnZhbGlkYXRlKSBpbnZhbGlkYXRlKHVuZGVmaW5lZCk7XG5cblx0XHRyZXR1cm4gbm9vcDtcblx0fVxuXG5cdC8vIFN2ZWx0ZSBzdG9yZSB0YWtlcyBhIHByaXZhdGUgc2Vjb25kIGFyZ3VtZW50XG5cdC8vIFN0YXJ0U3RvcE5vdGlmaWVyIGNvdWxkIG11dGF0ZSBzdGF0ZSwgYW5kIHdlIHdhbnQgdG8gc2lsZW5jZSB0aGUgY29ycmVzcG9uZGluZyB2YWxpZGF0aW9uIGVycm9yXG5cdGNvbnN0IHVuc3ViID0gdW50cmFjaygoKSA9PlxuXHRcdHN0b3JlLnN1YnNjcmliZShcblx0XHRcdHJ1bixcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGludmFsaWRhdGVcblx0XHQpXG5cdCk7XG5cblx0Ly8gQWxzbyBzdXBwb3J0IFJ4SlNcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCB0aGlzIGluIHRoZSB0eXBlcz9cblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSwgU3RhcnRTdG9wTm90aWZpZXIsIFN1YnNjcmliZXIsIFVuc3Vic2NyaWJlciwgVXBkYXRlciwgV3JpdGFibGUgfSBmcm9tICcuLi9wdWJsaWMuanMnICovXG4vKiogQGltcG9ydCB7IFN0b3JlcywgU3RvcmVzVmFsdWVzLCBTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGUgfSBmcm9tICcuLi9wcml2YXRlLmpzJyAqL1xuaW1wb3J0IHsgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBzYWZlX25vdF9lcXVhbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPGFueT4gfCBhbnk+fVxuICovXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtXcml0YWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcblx0LyoqIEB0eXBlIHtVbnN1YnNjcmliZXIgfCBudWxsfSAqL1xuXHRsZXQgc3RvcCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtTZXQ8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuXHRcdGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRpZiAoc3RvcCkge1xuXHRcdFx0XHQvLyBzdG9yZSBpcyByZWFkeVxuXHRcdFx0XHRjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuXHRcdFx0XHRcdHN1YnNjcmliZXJbMV0oKTtcblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLnB1c2goc3Vic2NyaWJlciwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5fcXVldWUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGRhdGVyPFQ+fSBmblxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuXHRcdHNldChmbigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N1YnNjcmliZXI8VD59IHJ1blxuXHQgKiBAcGFyYW0geygpID0+IHZvaWR9IFtpbnZhbGlkYXRlXVxuXHQgKiBAcmV0dXJucyB7VW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge1N1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPn0gKi9cblx0XHRjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG5cdFx0c3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG5cdFx0XHRzdG9wID0gc3RhcnQoc2V0LCB1cGRhdGUpIHx8IG5vb3A7XG5cdFx0fVxuXHRcdHJ1bigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cdFx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG5cdFx0XHRcdHN0b3AoKTtcblx0XHRcdFx0c3RvcCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBAdGVtcGxhdGUge1N0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IFVwZGF0ZXI8VD4pID0+IHZvaWQpID0+IFVuc3Vic2NyaWJlciB8IHZvaWR9IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFN0b3Jlc1ZhbHVlczxTPikgPT4gVH0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbi8qKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcblx0Y29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcblx0LyoqIEB0eXBlIHtBcnJheTxSZWFkYWJsZTxhbnk+Pn0gKi9cblx0Y29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlID8gW3N0b3Jlc10gOiBzdG9yZXM7XG5cdGlmICghc3RvcmVzX2FycmF5LmV2ZXJ5KEJvb2xlYW4pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkKCkgZXhwZWN0cyBzdG9yZXMgYXMgaW5wdXQsIGdvdCBhIGZhbHN5IHZhbHVlJyk7XG5cdH1cblx0Y29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG5cdHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0LCB1cGRhdGUpID0+IHtcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7VFtdfSAqL1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdGxldCBwZW5kaW5nID0gMDtcblx0XHRsZXQgY2xlYW51cCA9IG5vb3A7XG5cdFx0Y29uc3Qgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmIChwZW5kaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0LCB1cGRhdGUpO1xuXHRcdFx0aWYgKGF1dG8pIHtcblx0XHRcdFx0c2V0KHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbnVwID0gdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJyA/IHJlc3VsdCA6IG5vb3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+XG5cdFx0XHRzdWJzY3JpYmVfdG9fc3RvcmUoXG5cdFx0XHRcdHN0b3JlLFxuXHRcdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRwZW5kaW5nICY9IH4oMSA8PCBpKTtcblx0XHRcdFx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0c3luYygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHBlbmRpbmcgfD0gMSA8PCBpO1xuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRzeW5jKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcblx0XHRcdC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcblx0XHRcdC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdG9yZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUgZGVyaXZlZCBmcm9tIHRoZSBvbGQgb25lIHRoYXQgaXMgcmVhZGFibGUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UmVhZGFibGU8VD59IHN0b3JlICAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGkgc3VzcGVjdCB0aGUgYmluZCBpcyB1bm5lY2Vzc2FyeVxuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLmJpbmQoc3RvcmUpXG5cdH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZyb20gYSBzdG9yZSBieSBzdWJzY3JpYmluZyBhbmQgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmluZy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHZhbHVlO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBTdG9yZVJlZmVyZW5jZXNDb250YWluZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBTdG9yZSB9IGZyb20gJyNzaGFyZWQnICovXG5pbXBvcnQgeyBzdWJzY3JpYmVfdG9fc3RvcmUgfSBmcm9tICcuLi8uLi8uLi9zdG9yZS91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXQgYXMgZ2V0X3N0b3JlIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmUvc2hhcmVkL2luZGV4LmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgbm9vcCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG11dGFibGVfc291cmNlLCBzZXQgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHByb3AgY3VycmVudGx5IGJlaW5nIHJlYWQgaXMgYSBzdG9yZSBiaW5kaW5nLCBhcyBpblxuICogYDxDaGlsZCBiaW5kOng9eyR5fSAvPmAuIElmIGl0IGlzLCB3ZSB0cmVhdCB0aGUgcHJvcCBhcyBtdXRhYmxlIGV2ZW4gaW5cbiAqIHJ1bmVzIG1vZGUsIGFuZCBza2lwIGBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAgdmFsaWRhdGlvblxuICovXG5sZXQgaXNfc3RvcmVfYmluZGluZyA9IGZhbHNlO1xuXG5sZXQgSVNfVU5NT1VOVEVEID0gU3ltYm9sKCk7XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIHN0b3JlLiBJZiB0aGUgc3RvcmUgaXNuJ3Qgc3Vic2NyaWJlZCB0byB5ZXQsIGl0IHdpbGwgY3JlYXRlIGEgcHJveHlcbiAqIHNpZ25hbCB0aGF0IHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZSBzdG9yZSBpcy4gVGhlIHN0b3JlIHJlZmVyZW5jZXMgY29udGFpbmVyIGlzIG5lZWRlZCB0b1xuICogdHJhY2sgcmVhc3NpZ25tZW50cyB0byBzdG9yZXMgYW5kIHRvIHRyYWNrIHRoZSBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0LlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfZ2V0KHN0b3JlLCBzdG9yZV9uYW1lLCBzdG9yZXMpIHtcblx0Y29uc3QgZW50cnkgPSAoc3RvcmVzW3N0b3JlX25hbWVdID8/PSB7XG5cdFx0c3RvcmU6IG51bGwsXG5cdFx0c291cmNlOiBtdXRhYmxlX3NvdXJjZSh1bmRlZmluZWQpLFxuXHRcdHVuc3Vic2NyaWJlOiBub29wXG5cdH0pO1xuXG5cdGlmIChERVYpIHtcblx0XHRlbnRyeS5zb3VyY2UubGFiZWwgPSBzdG9yZV9uYW1lO1xuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCB0aGF0IHNldHVwIHRoaXMgaXMgYWxyZWFkeSB1bm1vdW50ZWQgd2UgZG9uJ3Qgd2FudCB0byByZWdpc3RlciBhIHN1YnNjcmlwdGlvblxuXHRpZiAoZW50cnkuc3RvcmUgIT09IHN0b3JlICYmICEoSVNfVU5NT1VOVEVEIGluIHN0b3JlcykpIHtcblx0XHRlbnRyeS51bnN1YnNjcmliZSgpO1xuXHRcdGVudHJ5LnN0b3JlID0gc3RvcmUgPz8gbnVsbDtcblxuXHRcdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0XHRlbnRyeS5zb3VyY2UudiA9IHVuZGVmaW5lZDsgLy8gc2VlIHN5bmNocm9ub3VzIGNhbGxiYWNrIGNvbW1lbnQgYmVsb3dcblx0XHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gbm9vcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrID0gdHJ1ZTtcblxuXHRcdFx0ZW50cnkudW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVfdG9fc3RvcmUoc3RvcmUsICh2KSA9PiB7XG5cdFx0XHRcdGlmIChpc19zeW5jaHJvbm91c19jYWxsYmFjaykge1xuXHRcdFx0XHRcdC8vIElmIHRoZSBmaXJzdCB1cGRhdGVzIHRvIHRoZSBzdG9yZSB2YWx1ZSAocG9zc2libHkgbXVsdGlwbGUgb2YgdGhlbSkgYXJlIHN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHQvLyBpbnNpZGUgYSBkZXJpdmVkLCB3ZSB3aWxsIGhpdCB0aGUgYHN0YXRlX3Vuc2FmZV9tdXRhdGlvbmAgZXJyb3IgaWYgd2UgYHNldGAgdGhlIHZhbHVlXG5cdFx0XHRcdFx0ZW50cnkuc291cmNlLnYgPSB2O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldChlbnRyeS5zb3VyY2UsIHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aXNfc3luY2hyb25vdXNfY2FsbGJhY2sgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IHRoYXQgc2V0dXAgdGhpcyBzdG9yZXMgaXMgYWxyZWFkeSB1bm1vdW50ZWQgdGhlIHNvdXJjZSB3aWxsIGJlIG91dCBvZiBzeW5jXG5cdC8vIHNvIHdlIGp1c3QgdXNlIHRoZSBgZ2V0YCBmb3IgdGhlIHN0b3JlcywgbGVzcyBwZXJmb3JtYW50IGJ1dCBpdCBhdm9pZHMgdG8gY3JlYXRlIGEgbWVtb3J5IGxlYWtcblx0Ly8gYW5kIGl0IHdpbGwga2VlcCB0aGUgdmFsdWUgY29uc2lzdGVudFxuXHRpZiAoc3RvcmUgJiYgSVNfVU5NT1VOVEVEIGluIHN0b3Jlcykge1xuXHRcdHJldHVybiBnZXRfc3RvcmUoc3RvcmUpO1xuXHR9XG5cblx0cmV0dXJuIGdldChlbnRyeS5zb3VyY2UpO1xufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBpZiBpdCdzIG5vdCB0aGUgc2FtZSBhcyB0aGUgb25lIGluIHRoZSBzdG9yZSByZWZlcmVuY2VzIGNvbnRhaW5lci5cbiAqIFdlIG5lZWQgdGhpcyBpbiBhZGRpdGlvbiB0byBgc3RvcmVfZ2V0YCBiZWNhdXNlIHNvbWVvbmUgY291bGQgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGJ1dFxuICogdGhlbiBuZXZlciBzdWJzY3JpYmUgdG8gdGhlIG5ldyBvbmUgKGlmIGFueSksIGNhdXNpbmcgdGhlIHN1YnNjcmlwdGlvbiB0byBzdGF5IG9wZW4gd3JvbmdmdWxseS5cbiAqIEBwYXJhbSB7U3RvcmU8YW55PiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICogQHBhcmFtIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9IHN0b3Jlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfdW5zdWIoc3RvcmUsIHN0b3JlX25hbWUsIHN0b3Jlcykge1xuXHQvKiogQHR5cGUge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lclsnJ10gfCB1bmRlZmluZWR9ICovXG5cdGxldCBlbnRyeSA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblxuXHRpZiAoZW50cnkgJiYgZW50cnkuc3RvcmUgIT09IHN0b3JlKSB7XG5cdFx0Ly8gRG9uJ3QgcmVzZXQgc3RvcmUgeWV0LCBzbyB0aGF0IHN0b3JlX2dldCBhYm92ZSBjYW4gcmVzdWJzY3JpYmUgdG8gbmV3IHN0b3JlIGlmIG5lY2Vzc2FyeVxuXHRcdGVudHJ5LnVuc3Vic2NyaWJlKCk7XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUgPSBub29wO1xuXHR9XG5cblx0cmV0dXJuIHN0b3JlO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG5ldyB2YWx1ZSBvZiBhIHN0b3JlIGFuZCByZXR1cm5zIHRoYXQgdmFsdWUuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTdG9yZTxWPn0gc3RvcmVcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfc2V0KHN0b3JlLCB2YWx1ZSkge1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9IHN0b3Jlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVfc3RvcmUoc3RvcmVzLCBzdG9yZV9uYW1lKSB7XG5cdHZhciBlbnRyeSA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblx0aWYgKGVudHJ5LnN0b3JlICE9PSBudWxsKSB7XG5cdFx0c3RvcmVfc2V0KGVudHJ5LnN0b3JlLCBlbnRyeS5zb3VyY2Uudik7XG5cdH1cbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZXMgZnJvbSBhbGwgYXV0by1zdWJzY3JpYmVkIHN0b3JlcyBvbiBkZXN0cm95XG4gKiBAcmV0dXJucyB7W1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lciwgKCk9PnZvaWRdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBfc3RvcmVzKCkge1xuXHQvKiogQHR5cGUge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gKi9cblx0Y29uc3Qgc3RvcmVzID0ge307XG5cblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0XHRmb3IgKHZhciBzdG9yZV9uYW1lIGluIHN0b3Jlcykge1xuXHRcdFx0XHRjb25zdCByZWYgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cdFx0XHRcdHJlZi51bnN1YnNjcmliZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lX3Byb3BlcnR5KHN0b3JlcywgSVNfVU5NT1VOVEVELCB7XG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR2YWx1ZTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gW3N0b3JlcywgY2xlYW51cF07XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIHN0b3JlIHdpdGggYSBuZXcgdmFsdWUuXG4gKiBAcGFyYW0ge1N0b3JlPFY+fSBzdG9yZSAgdGhlIHN0b3JlIHRvIHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IGV4cHJlc3Npb24gIHRoZSBleHByZXNzaW9uIHRoYXQgbXV0YXRlcyB0aGUgc3RvcmVcbiAqIEBwYXJhbSB7Vn0gbmV3X3ZhbHVlICB0aGUgbmV3IHN0b3JlIHZhbHVlXG4gKiBAdGVtcGxhdGUgVlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfbXV0YXRlKHN0b3JlLCBleHByZXNzaW9uLCBuZXdfdmFsdWUpIHtcblx0c3RvcmUuc2V0KG5ld192YWx1ZSk7XG5cdHJldHVybiBleHByZXNzaW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmU8bnVtYmVyPn0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdG9yZV92YWx1ZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zdG9yZShzdG9yZSwgc3RvcmVfdmFsdWUsIGQgPSAxKSB7XG5cdHN0b3JlLnNldChzdG9yZV92YWx1ZSArIGQpO1xuXHRyZXR1cm4gc3RvcmVfdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0b3JlX3ZhbHVlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3ByZV9zdG9yZShzdG9yZSwgc3RvcmVfdmFsdWUsIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gc3RvcmVfdmFsdWUgKyBkO1xuXHRzdG9yZS5zZXQodmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBwcm9wIGdldHRlcnMgdG8gY29tbXVuaWNhdGUgdGhhdCB0aGUgcHJvcCBpcyBhIHN0b3JlIGJpbmRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtfc3RvcmVfYmluZGluZygpIHtcblx0aXNfc3RvcmVfYmluZGluZyA9IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHR1cGxlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgYGZuKClgIHJlYWRzIGEgcHJvcCB0aGF0IGlzIGEgc3RvcmUgYmluZGluZy5cbiAqIFVzZWQgdG8gcHJldmVudCBgYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgIHZhbGlkYXRpb24gZmFsc2UgcG9zaXRpdmVzIGFuZFxuICogZW5zdXJlIHRoYXQgdGhlc2UgcHJvcHMgYXJlIHRyZWF0ZWQgYXMgbXV0YWJsZSBldmVuIGluIHJ1bmVzIG1vZGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7W1QsIGJvb2xlYW5dfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZV9zdG9yZV9iaW5kaW5nKGZuKSB7XG5cdHZhciBwcmV2aW91c19pc19zdG9yZV9iaW5kaW5nID0gaXNfc3RvcmVfYmluZGluZztcblxuXHR0cnkge1xuXHRcdGlzX3N0b3JlX2JpbmRpbmcgPSBmYWxzZTtcblx0XHRyZXR1cm4gW2ZuKCksIGlzX3N0b3JlX2JpbmRpbmddO1xuXHR9IGZpbmFsbHkge1xuXHRcdGlzX3N0b3JlX2JpbmRpbmcgPSBwcmV2aW91c19pc19zdG9yZV9iaW5kaW5nO1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgU291cmNlIH0gZnJvbSAnLi90eXBlcy5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0UFJPUFNfSVNfQklOREFCTEUsXG5cdFBST1BTX0lTX0lNTVVUQUJMRSxcblx0UFJPUFNfSVNfTEFaWV9JTklUSUFMLFxuXHRQUk9QU19JU19SVU5FUyxcblx0UFJPUFNfSVNfVVBEQVRFRFxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHNldCwgc291cmNlLCB1cGRhdGUgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCwgZGVyaXZlZF9zYWZlX2VxdWFsIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRnZXQsXG5cdGlzX2Rlc3Ryb3lpbmdfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0dW50cmFja1xufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFU1RST1lFRCwgTEVHQUNZX1BST1BTLCBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBwcm94eSB9IGZyb20gJy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGNhcHR1cmVfc3RvcmVfYmluZGluZyB9IGZyb20gJy4vc3RvcmUuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygodmFsdWU/OiBudW1iZXIpID0+IG51bWJlcil9IGZuXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKTtcblx0Zm4odmFsdWUgKyBkKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKSArIGQ7XG5cdGZuKHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciByZXN0IHByb3BzIChpLmUuIGBjb25zdCB7IHgsIC4uLnJlc3QgfSA9ICRwcm9wcygpYCkuXG4gKiBJcyBwYXNzZWQgdGhlIGZ1bGwgYCQkcHJvcHNgIG9iamVjdCBhbmQgZXhjbHVkZXMgdGhlIG5hbWVkIHByb3BzLlxuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgbmFtZT86IHN0cmluZyB9Pn19XG4gKi9cbmNvbnN0IHJlc3RfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5wcm9wc19yZXN0X3JlYWRvbmx5KGAke3RhcmdldC5uYW1lfS4ke1N0cmluZyhrZXkpfWApO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUsIG5hbWUpIHtcblx0cmV0dXJuIG5ldyBQcm94eShcblx0XHRERVYgPyB7IHByb3BzLCBleGNsdWRlLCBuYW1lLCBvdGhlcjoge30sIHRvX3Byb3h5OiBbXSB9IDogeyBwcm9wcywgZXhjbHVkZSB9LFxuXHRcdHJlc3RfcHJvcHNfaGFuZGxlclxuXHQpO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciBsZWdhY3kgJCRyZXN0UHJvcHMgYW5kICQkcHJvcHNcbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4sIGV4Y2x1ZGU6IEFycmF5PHN0cmluZyB8IHN5bWJvbD4sIHNwZWNpYWw6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj4sIHZlcnNpb246IFNvdXJjZTxudW1iZXI+LCBwYXJlbnRfZWZmZWN0OiBFZmZlY3QgfT59fVxuICovXG5jb25zdCBsZWdhY3lfcmVzdF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGdldCh0YXJnZXQudmVyc2lvbik7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQuc3BlY2lhbCA/IHRhcmdldC5zcGVjaWFsW2tleV0oKSA6IHRhcmdldC5wcm9wc1trZXldO1xuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG5cdFx0aWYgKCEoa2V5IGluIHRhcmdldC5zcGVjaWFsKSkge1xuXHRcdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHRhcmdldC5wYXJlbnRfZWZmZWN0KTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgcHJvcHMgdGhhdCBjYW4gdGVtcG9yYXJpbHkgZ2V0IG91dCBvZiBzeW5jIHdpdGggdGhlIHBhcmVudFxuXHRcdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj59ICovXG5cdFx0XHRcdHRhcmdldC5zcGVjaWFsW2tleV0gPSBwcm9wKFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGdldCBba2V5XSgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wc1trZXldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovIChrZXkpLFxuXHRcdFx0XHRcdFBST1BTX0lTX1VQREFURURcblx0XHRcdFx0KTtcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGFyZ2V0LnNwZWNpYWxba2V5XSh2YWx1ZSk7XG5cdFx0dXBkYXRlKHRhcmdldC52ZXJzaW9uKTsgLy8gJCRwcm9wcyBpcyBjb2Fyc2UtZ3JhaW5lZDogd2hlbiAkJHByb3BzLnggaXMgdXBkYXRlZCwgdXNhZ2VzIG9mICQkcHJvcHMueSBldGMgYXJlIGFsc28gcmVydW5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuXHRcdC8vIFN2ZWx0ZSA0IGFsbG93ZWQgZm9yIGRlbGV0aW9ucyBvbiAkJHJlc3RQcm9wc1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gdHJ1ZTtcblx0XHR0YXJnZXQuZXhjbHVkZS5wdXNoKGtleSk7XG5cdFx0dXBkYXRlKHRhcmdldC52ZXJzaW9uKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0aGFzKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5wcm9wcztcblx0fSxcblx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRyZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldC5wcm9wcykuZmlsdGVyKChrZXkpID0+ICF0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKTtcblx0fVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gZXhjbHVkZVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3Jlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUpIHtcblx0cmV0dXJuIG5ldyBQcm94eShcblx0XHR7XG5cdFx0XHRwcm9wcyxcblx0XHRcdGV4Y2x1ZGUsXG5cdFx0XHRzcGVjaWFsOiB7fSxcblx0XHRcdHZlcnNpb246IHNvdXJjZSgwKSxcblx0XHRcdC8vIFRPRE8gdGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gdHJhY2sgY29tcG9uZW50XG5cdFx0XHQvLyBkZXN0cnVjdGlvbiBpbnNpZGUgYHByb3BgLCBiZWNhdXNlIG9mIGBiaW5kOnRoaXNgLCBidXQgaXRcblx0XHRcdC8vIHNlZW1zIGxpa2VseSB0aGF0IHdlIGNhbiBzaW1wbGlmeSBgYmluZDp0aGlzYCBpbnN0ZWFkXG5cdFx0XHRwYXJlbnRfZWZmZWN0OiAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpXG5cdFx0fSxcblx0XHRsZWdhY3lfcmVzdF9wcm9wc19oYW5kbGVyXG5cdCk7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHNwcmVhZCBwcm9wcy4gSGFuZGxlcyB0aGUgaW5jb21pbmcgYXJyYXkgb2YgcHJvcHNcbiAqIHRoYXQgbG9va3MgbGlrZSBgKCkgPT4geyBkeW5hbWljOiBwcm9wcyB9LCB7IHN0YXRpYzogcHJvcCB9LCAuLmAgYW5kIHdyYXBzXG4gKiB0aGVtIHNvIHRoYXQgdGhlIHdob2xlIHRoaW5nIGlzIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGFzIHRoZSBgJCRwcm9wc2AgYXJndW1lbnQuXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IEFycmF5PFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+IHwgKCgpID0+IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+KT4gfT59fVxuICovXG5jb25zdCBzcHJlYWRfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsICYmIGtleSBpbiBwKSByZXR1cm4gcFtrZXldO1xuXHRcdH1cblx0fSxcblx0c2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGNvbnN0IGRlc2MgPSBnZXRfZGVzY3JpcHRvcihwLCBrZXkpO1xuXHRcdFx0aWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcblx0XHRcdFx0ZGVzYy5zZXQodmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwgJiYga2V5IGluIHApIHtcblx0XHRcdFx0Y29uc3QgZGVzY3JpcHRvciA9IGdldF9kZXNjcmlwdG9yKHAsIGtleSk7XG5cdFx0XHRcdGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgYSBcIk5vbi1jb25maWd1cmFiaWxpdHkgUmVwb3J0IEVycm9yXCI6IFRoZSB0YXJnZXQgaXMgYW4gYXJyYXksIGl0IGRvZXNcblx0XHRcdFx0XHQvLyBub3QgYWN0dWFsbHkgY29udGFpbiB0aGlzIHByb3BlcnR5LiBJZiBpdCBpcyBub3cgZGVzY3JpYmVkIGFzIG5vbi1jb25maWd1cmFibGUsXG5cdFx0XHRcdFx0Ly8gdGhlIHByb3h5IHRocm93cyBhIHZhbGlkYXRpb24gZXJyb3IuIFNldHRpbmcgaXQgdG8gdHJ1ZSBhdm9pZHMgdGhhdC5cblx0XHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHQvLyBUbyBwcmV2ZW50IGEgZmFsc2UgcG9zaXRpdmUgYGlzX2VudHJ5X3Byb3BzYCBpbiB0aGUgYHByb3BgIGZ1bmN0aW9uXG5cdFx0aWYgKGtleSA9PT0gU1RBVEVfU1lNQk9MIHx8IGtleSA9PT0gTEVHQUNZX1BST1BTKSByZXR1cm4gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBwIG9mIHRhcmdldC5wcm9wcykge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHAgIT0gbnVsbCAmJiBrZXkgaW4gcCkgcmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nIHwgc3ltYm9sPn0gKi9cblx0XHRjb25zdCBrZXlzID0gW107XG5cblx0XHRmb3IgKGxldCBwIG9mIHRhcmdldC5wcm9wcykge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKCFwKSBjb250aW51ZTtcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gcCkge1xuXHRcdFx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkga2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocCkpIHtcblx0XHRcdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBrZXlzO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCAoKCkgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPn0gcHJvcHNcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWRfcHJvcHMoLi4ucHJvcHMpIHtcblx0cmV0dXJuIG5ldyBQcm94eSh7IHByb3BzIH0sIHNwcmVhZF9wcm9wc19oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBzeW5jaHJvbml6aW5nIGEgcG9zc2libHkgYm91bmQgcHJvcCB3aXRoIHRoZSBpbm5lciBjb21wb25lbnQgc3RhdGUuXG4gKiBJdCBpcyB1c2VkIHdoZW5ldmVyIHRoZSBjb21waWxlciBzZWVzIHRoYXQgdGhlIGNvbXBvbmVudCB3cml0ZXMgdG8gdGhlIHByb3AsIG9yIHdoZW4gaXQgaGFzIGEgZGVmYXVsdCBwcm9wX3ZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7ViB8ICgoKSA9PiBWKX0gW2ZhbGxiYWNrXVxuICogQHJldHVybnMgeygoKSA9PiBWIHwgKChhcmc6IFYpID0+IFYpIHwgKChhcmc6IFYsIG11dGF0aW9uOiBib29sZWFuKSA9PiBWKSl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wKHByb3BzLCBrZXksIGZsYWdzLCBmYWxsYmFjaykge1xuXHR2YXIgcnVuZXMgPSAhbGVnYWN5X21vZGVfZmxhZyB8fCAoZmxhZ3MgJiBQUk9QU19JU19SVU5FUykgIT09IDA7XG5cdHZhciBiaW5kYWJsZSA9IChmbGFncyAmIFBST1BTX0lTX0JJTkRBQkxFKSAhPT0gMDtcblx0dmFyIGxhenkgPSAoZmxhZ3MgJiBQUk9QU19JU19MQVpZX0lOSVRJQUwpICE9PSAwO1xuXG5cdHZhciBmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKGZhbGxiYWNrKTtcblx0dmFyIGZhbGxiYWNrX2RpcnR5ID0gdHJ1ZTtcblxuXHR2YXIgZ2V0X2ZhbGxiYWNrID0gKCkgPT4ge1xuXHRcdGlmIChmYWxsYmFja19kaXJ0eSkge1xuXHRcdFx0ZmFsbGJhY2tfZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSBsYXp5XG5cdFx0XHRcdD8gdW50cmFjaygvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykpXG5cdFx0XHRcdDogLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxsYmFja192YWx1ZTtcblx0fTtcblxuXHQvKiogQHR5cGUgeygodjogVikgPT4gdm9pZCkgfCB1bmRlZmluZWR9ICovXG5cdHZhciBzZXR0ZXI7XG5cblx0aWYgKGJpbmRhYmxlKSB7XG5cdFx0Ly8gQ2FuIGJlIHRoZSBjYXNlIHdoZW4gc29tZW9uZSBkb2VzIGBtb3VudChDb21wb25lbnQsIHByb3BzKWAgd2l0aCBgbGV0IHByb3BzID0gJHN0YXRlKHsuLi59KWBcblx0XHQvLyBvciBgY3JlYXRlQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50LCBwcm9wcylgXG5cdFx0dmFyIGlzX2VudHJ5X3Byb3BzID0gU1RBVEVfU1lNQk9MIGluIHByb3BzIHx8IExFR0FDWV9QUk9QUyBpbiBwcm9wcztcblxuXHRcdHNldHRlciA9XG5cdFx0XHRnZXRfZGVzY3JpcHRvcihwcm9wcywga2V5KT8uc2V0ID8/XG5cdFx0XHQoaXNfZW50cnlfcHJvcHMgJiYga2V5IGluIHByb3BzID8gKHYpID0+IChwcm9wc1trZXldID0gdikgOiB1bmRlZmluZWQpO1xuXHR9XG5cblx0dmFyIGluaXRpYWxfdmFsdWU7XG5cdHZhciBpc19zdG9yZV9zdWIgPSBmYWxzZTtcblxuXHRpZiAoYmluZGFibGUpIHtcblx0XHRbaW5pdGlhbF92YWx1ZSwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZygoKSA9PiAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKSk7XG5cdH0gZWxzZSB7XG5cdFx0aW5pdGlhbF92YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pO1xuXHR9XG5cblx0aWYgKGluaXRpYWxfdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBmYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aW5pdGlhbF92YWx1ZSA9IGdldF9mYWxsYmFjaygpO1xuXG5cdFx0aWYgKHNldHRlcikge1xuXHRcdFx0aWYgKHJ1bmVzKSBlLnByb3BzX2ludmFsaWRfdmFsdWUoa2V5KTtcblx0XHRcdHNldHRlcihpbml0aWFsX3ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHQvKiogQHR5cGUgeygpID0+IFZ9ICovXG5cdHZhciBnZXR0ZXI7XG5cblx0aWYgKHJ1bmVzKSB7XG5cdFx0Z2V0dGVyID0gKCkgPT4ge1xuXHRcdFx0dmFyIHZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSk7XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGdldF9mYWxsYmFjaygpO1xuXHRcdFx0ZmFsbGJhY2tfZGlydHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Z2V0dGVyID0gKCkgPT4ge1xuXHRcdFx0dmFyIHZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSk7XG5cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIGluIGxlZ2FjeSBtb2RlLCB3ZSBkb24ndCByZXZlcnQgdG8gdGhlIGZhbGxiYWNrIHZhbHVlXG5cdFx0XHRcdC8vIGlmIHRoZSBwcm9wIGdvZXMgZnJvbSBkZWZpbmVkIHRvIHVuZGVmaW5lZC4gVGhlIGVhc2llc3Rcblx0XHRcdFx0Ly8gd2F5IHRvIG1vZGVsIHRoaXMgaXMgdG8gbWFrZSB0aGUgZmFsbGJhY2sgdW5kZWZpbmVkXG5cdFx0XHRcdC8vIGFzIHNvb24gYXMgdGhlIHByb3AgaGFzIGEgdmFsdWVcblx0XHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovICh1bmRlZmluZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGZhbGxiYWNrX3ZhbHVlIDogdmFsdWU7XG5cdFx0fTtcblx0fVxuXG5cdC8vIHByb3AgaXMgbmV2ZXIgd3JpdHRlbiB0byDigJQgd2Ugb25seSBuZWVkIGEgZ2V0dGVyXG5cdGlmIChydW5lcyAmJiAoZmxhZ3MgJiBQUk9QU19JU19VUERBVEVEKSA9PT0gMCkge1xuXHRcdHJldHVybiBnZXR0ZXI7XG5cdH1cblxuXHQvLyBwcm9wIGlzIHdyaXR0ZW4gdG8sIGJ1dCB0aGUgcGFyZW50IGNvbXBvbmVudCBoYWQgYGJpbmQ6Zm9vYCB3aGljaFxuXHQvLyBtZWFucyB3ZSBjYW4ganVzdCBjYWxsIGAkJHByb3BzLmZvbyA9IHZhbHVlYCBkaXJlY3RseVxuXHRpZiAoc2V0dGVyKSB7XG5cdFx0dmFyIGxlZ2FjeV9wYXJlbnQgPSBwcm9wcy4kJGxlZ2FjeTtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoXG5cdFx0XHRmdW5jdGlvbiAoLyoqIEB0eXBlIHtWfSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHQvLyBXZSBkb24ndCB3YW50IHRvIG5vdGlmeSBpZiB0aGUgdmFsdWUgd2FzIG11dGF0ZWQgYW5kIHRoZSBwYXJlbnQgaXMgaW4gcnVuZXMgbW9kZS5cblx0XHRcdFx0XHQvLyBJbiB0aGF0IGNhc2UgdGhlIHN0YXRlIHByb3h5IChpZiBpdCBleGlzdHMpIHNob3VsZCB0YWtlIGNhcmUgb2YgdGhlIG5vdGlmaWNhdGlvbi5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcGFyZW50IGlzIG5vdCBpbiBydW5lcyBtb2RlLCB3ZSBuZWVkIHRvIG5vdGlmeSBvbiBtdXRhdGlvbiwgdG9vLCB0aGF0IHRoZSBwcm9wXG5cdFx0XHRcdFx0Ly8gaGFzIGNoYW5nZWQgYmVjYXVzZSB0aGUgcGFyZW50IHdpbGwgbm90IGJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjaGFuZ2Ugb3RoZXJ3aXNlLlxuXHRcdFx0XHRcdGlmICghcnVuZXMgfHwgIW11dGF0aW9uIHx8IGxlZ2FjeV9wYXJlbnQgfHwgaXNfc3RvcmVfc3ViKSB7XG5cdFx0XHRcdFx0XHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAoc2V0dGVyKShtdXRhdGlvbiA/IGdldHRlcigpIDogdmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBnZXR0ZXIoKTtcblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0Ly8gRWl0aGVyIHByb3AgaXMgd3JpdHRlbiB0bywgYnV0IHRoZXJlJ3Mgbm8gYmluZGluZywgd2hpY2ggbWVhbnMgd2Vcblx0Ly8gY3JlYXRlIGEgZGVyaXZlZCB0aGF0IHdlIGNhbiB3cml0ZSB0byBsb2NhbGx5LlxuXHQvLyBPciB3ZSBhcmUgaW4gbGVnYWN5IG1vZGUgd2hlcmUgd2UgYWx3YXlzIGNyZWF0ZSBhIGRlcml2ZWQgdG8gcmVwbGljYXRlIHRoYXRcblx0Ly8gU3ZlbHRlIDQgZGlkIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgd2hlbiBhIHByaW1pdGl2ZSB2YWx1ZSB3YXMgdXBkYXRlZCB0byB0aGUgc2FtZSB2YWx1ZS5cblx0dmFyIG92ZXJyaWRkZW4gPSBmYWxzZTtcblxuXHR2YXIgZCA9ICgoZmxhZ3MgJiBQUk9QU19JU19JTU1VVEFCTEUpICE9PSAwID8gZGVyaXZlZCA6IGRlcml2ZWRfc2FmZV9lcXVhbCkoKCkgPT4ge1xuXHRcdG92ZXJyaWRkZW4gPSBmYWxzZTtcblx0XHRyZXR1cm4gZ2V0dGVyKCk7XG5cdH0pO1xuXG5cdGlmIChERVYpIHtcblx0XHRkLmxhYmVsID0ga2V5O1xuXHR9XG5cblx0Ly8gQ2FwdHVyZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBpdCdzIGJpbmRhYmxlXG5cdGlmIChiaW5kYWJsZSkgZ2V0KGQpO1xuXG5cdHZhciBwYXJlbnRfZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHRyZXR1cm4gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoXG5cdFx0ZnVuY3Rpb24gKC8qKiBAdHlwZSB7YW55fSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnN0IG5ld192YWx1ZSA9IG11dGF0aW9uID8gZ2V0KGQpIDogcnVuZXMgJiYgYmluZGFibGUgPyBwcm94eSh2YWx1ZSkgOiB2YWx1ZTtcblxuXHRcdFx0XHRzZXQoZCwgbmV3X3ZhbHVlKTtcblx0XHRcdFx0b3ZlcnJpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGZhbGxiYWNrX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIOKAlCBhdm9pZCByZWNhbGN1bGF0aW5nIHRoZSBkZXJpdmVkIGlmIHdlJ3JlIGluIGFcblx0XHRcdC8vIHRlYXJkb3duIGZ1bmN0aW9uIGFuZCB0aGUgcHJvcCB3YXMgb3ZlcnJpZGRlbiBsb2NhbGx5LCBvciB0aGVcblx0XHRcdC8vIGNvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQgKHRoaXMgbGF0dGVyIHBhcnQgaXMgbmVjZXNzYXJ5XG5cdFx0XHQvLyBiZWNhdXNlIGBiaW5kOnRoaXNgIGNhbiByZWFkIHByb3BzIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzXG5cdFx0XHQvLyBiZWVuIGRlc3Ryb3llZC4gVE9ETyBzaW1wbGlmeSBgYmluZDp0aGlzYFxuXHRcdFx0aWYgKChpc19kZXN0cm95aW5nX2VmZmVjdCAmJiBvdmVycmlkZGVuKSB8fCAocGFyZW50X2VmZmVjdC5mICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gZC52O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2V0KGQpO1xuXHRcdH1cblx0KTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vaW5kZXguanMnICovXG4vKiogQGltcG9ydCB7IE5vdEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlcy5qcycgKi9cbmltcG9ydCB7IGFjdGl2ZV9yZWFjdGlvbiwgdW50cmFjayB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyB1c2VyX2VmZmVjdCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcgfSBmcm9tICcuL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuaWYgKERFVikge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcblx0ICovXG5cdGZ1bmN0aW9uIHRocm93X3J1bmVfZXJyb3IocnVuZSkge1xuXHRcdGlmICghKHJ1bmUgaW4gZ2xvYmFsVGhpcykpIHtcblx0XHRcdC8vIFRPRE8gaWYgcGVvcGxlIHN0YXJ0IGFkanVzdGluZyB0aGUgXCJ0aGlzIGNhbiBjb250YWluIHJ1bmVzXCIgY29uZmlnIHRocm91Z2ggdi1wLXMgbW9yZSwgYWRqdXN0IHRoaXMgbWVzc2FnZVxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWU7IC8vIGxldCdzIGhvcGUgbm9vbmUgbW9kaWZpZXMgdGhpcyBnbG9iYWwsIGJ1dCBiZWx0cyBhbmQgYnJhY2VzXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgcnVuZSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZS5ydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6ICh2KSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvd19ydW5lX2Vycm9yKCckc3RhdGUnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGVmZmVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckZGVyaXZlZCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckaW5zcGVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckcHJvcHMnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGJpbmRhYmxlJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBbYEFib3J0U2lnbmFsYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsKSB0aGF0IGFib3J0cyB3aGVuIHRoZSBjdXJyZW50IFtkZXJpdmVkXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtlZmZlY3RdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSByZS1ydW5zIG9yIGlzIGRlc3Ryb3llZC5cbiAqXG4gKiBNdXN0IGJlIGNhbGxlZCB3aGlsZSBhIGRlcml2ZWQgb3IgZWZmZWN0IGlzIHJ1bm5pbmcuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0PlxuICogXHRpbXBvcnQgeyBnZXRBYm9ydFNpZ25hbCB9IGZyb20gJ3N2ZWx0ZSc7XG4gKlxuICogXHRsZXQgeyBpZCB9ID0gJHByb3BzKCk7XG4gKlxuICogXHRhc3luYyBmdW5jdGlvbiBnZXREYXRhKGlkKSB7XG4gKiBcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2l0ZW1zLyR7aWR9YCwge1xuICogXHRcdFx0c2lnbmFsOiBnZXRBYm9ydFNpZ25hbCgpXG4gKiBcdFx0fSk7XG4gKlxuICogXHRcdHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gKiBcdH1cbiAqXG4gKiBcdGNvbnN0IGRhdGEgPSAkZGVyaXZlZChhd2FpdCBnZXREYXRhKGlkKSk7XG4gKiA8L3NjcmlwdD5cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWwoKSB7XG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gPT09IG51bGwpIHtcblx0XHRlLmdldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbigpO1xuXHR9XG5cblx0cmV0dXJuIChhY3RpdmVfcmVhY3Rpb24uYWMgPz89IG5ldyBBYm9ydENvbnRyb2xsZXIoKSkuc2lnbmFsO1xufVxuXG4vKipcbiAqIGBvbk1vdW50YCwgbGlrZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCksIHNjaGVkdWxlcyBhIGZ1bmN0aW9uIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogVW5saWtlIGAkZWZmZWN0YCwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9ubHkgcnVucyBvbmNlLlxuICpcbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSBfaW5zaWRlXyB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLFxuICogaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZnVuY3Rpb25zIGRvIG5vdCBydW4gZHVyaW5nIFtzZXJ2ZXItc2lkZSByZW5kZXJpbmddKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUtc2VydmVyI3JlbmRlcikuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPE5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdvbk1vdW50Jyk7XG5cdH1cblxuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiBjb21wb25lbnRfY29udGV4dC5sICE9PSBudWxsKSB7XG5cdFx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5tLnB1c2goZm4pO1xuXHR9IGVsc2Uge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdGNvbnN0IGNsZWFudXAgPSB1bnRyYWNrKGZuKTtcblx0XHRcdGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi8gKGNsZWFudXApO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uRGVzdHJveScpO1xuXHR9XG5cblx0b25Nb3VudCgoKSA9PiAoKSA9PiB1bnRyYWNrKGZuKSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge2FueX1wYXJhbXNfMFxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL2xlZ2FjeS1vbiNDb21wb25lbnQtZXZlbnRzKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBudWxsOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgY2FsbGJhY2sgcHJvcHMgYW5kL29yIHRoZSBgJGhvc3QoKWAgcnVuZSBpbnN0ZWFkIOKAlCBzZWUgW21pZ3JhdGlvbiBndWlkZV0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3Y1LW1pZ3JhdGlvbi1ndWlkZSNFdmVudC1jaGFuZ2VzLUNvbXBvbmVudC1ldmVudHMpXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcCA9IGFueV1cbiAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdjcmVhdGVFdmVudERpc3BhdGNoZXInKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gW2RldGFpbF1cblx0ICogQHBhcmFtIFtvcHRpb25zXVxuXHQgKi9cblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpID0+IHtcblx0XHRjb25zdCBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uIHwgRnVuY3Rpb25bXT59ICovIChcblx0XHRcdGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC5zLiQkZXZlbnRzXG5cdFx0KT8uWy8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSldO1xuXG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogW2V2ZW50c107XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGNyZWF0ZV9jdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCBvcHRpb25zKTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLy8gVE9ETyBtYXJrIGJlZm9yZVVwZGF0ZSBhbmQgYWZ0ZXJVcGRhdGUgYXMgZGVwcmVjYXRlZCBpbiBTdmVsdGUgNlxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0LnByZWAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0LnByZWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0IyRlZmZlY3QucHJlKSBpbnN0ZWFkXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KCdiZWZvcmVVcGRhdGUnKTtcblx0fVxuXG5cdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkuYi5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0YCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCkgaW5zdGVhZFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYWZ0ZXJVcGRhdGUnKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfbGVnYWN5X29ubHkoJ2FmdGVyVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmEucHVzaChmbik7XG59XG5cbi8qKlxuICogTGVnYWN5LW1vZGU6IEluaXQgY2FsbGJhY2tzIG9iamVjdCBmb3Igb25Nb3VudC9iZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29udGV4dCkge1xuXHR2YXIgbCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbnRleHQpLmw7XG5cdHJldHVybiAobC51ID8/PSB7IGE6IFtdLCBiOiBbXSwgbTogW10gfSk7XG59XG5cbmV4cG9ydCB7IGZsdXNoU3luYywgZm9yayB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuZXhwb3J0IHtcblx0Y3JlYXRlQ29udGV4dCxcblx0Z2V0Q29udGV4dCxcblx0Z2V0QWxsQ29udGV4dHMsXG5cdGhhc0NvbnRleHQsXG5cdHNldENvbnRleHRcbn0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5leHBvcnQgeyBoeWRyYXRlLCBtb3VudCwgdW5tb3VudCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyc7XG5leHBvcnQgeyB0aWNrLCB1bnRyYWNrLCBzZXR0bGVkIH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5leHBvcnQgeyBjcmVhdGVSYXdTbmlwcGV0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbiIsIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc1LjQzLjInO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzUnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0KCh3aW5kb3cuX19zdmVsdGUgPz89IHt9KS52ID8/PSBuZXcgU2V0KCkpLmFkZChQVUJMSUNfVkVSU0lPTik7XG59XG4iLCJjb25zdCBpbnB1dFZhbHVlc0V4dHJhY3RvcnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBjaGVja2JveDogKGlucEVsLCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKGRlZmF1bHRWYWx1ZSwgXCJjaGVja2VkXCIpICYmXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKGRlZmF1bHRWYWx1ZSwgXCJ1bmNoZWNrZWRcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wRWwuY2hlY2tlZFxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNoZWNrZWRcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZS51bmNoZWNrZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKGlucEVsLCBcInZhbHVlXCIpICYmXG4gICAgICAgICAgICB0eXBlb2YgaW5wRWwudmFsdWUgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wRWwuY2hlY2tlZCA/IGlucEVsLnZhbHVlIDogZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wRWwuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGNvbW1vbiB0byBVSSBmdW5jdGlvbnMgYW5kIHByb3BlcnRpZXNcbiAqXG4gKiBAY2xhc3MgVUlDb21tb25cbiAqL1xuY2xhc3MgVUlDb21tb24ge1xuICAgIHN0YXRpYyBDTEVBUl9NQUNSTyA9IFwiX19DTEVBUl9fXCI7XG4gICAgc3RhdGljIEVSUk9SX0RFRkFVTFQgPSBcItCn0YLQviDQv9C+0YjQu9C+INC90LUg0YLQsNC6LlwiO1xuICAgIHN0YXRpYyBERUZBVUxUX1JFRElSRUNUX1RJTUVPVVQgPSAzMDAwO1xuICAgIHN0YXRpYyBDTEFTU19PSyA9IFwiaXMtc3VjY2Vzc1wiO1xuICAgIHN0YXRpYyBDTEFTU19FUlIgPSBcImlzLWRhbmdlclwiO1xuICAgIHN0YXRpYyBTQ1JPTExfRElTQUJMRVJfQ0xBU1MgPSBcInJlbW92ZS1zY3JvbGxcIjtcbiAgICBzdGF0aWMgRklMTEVSID0gXCJfXCI7XG5cbiAgICBzdGF0aWMgU0NST0xMX09QVElPTlMgPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYmVoYXZpb3I6IFwic21vb3RoXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXQgaW5wdXRWYWx1ZXNFeHRyYWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZXNFeHRyYWN0b3JzO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHRyYWN0VmFsdWVGcm9tSW5wdXQoaW5wRWwsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWlucEVsKSByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihVSUNvbW1vbi5pbnB1dFZhbHVlc0V4dHJhY3RvcnMsIGlucEVsLnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVUlDb21tb24uaW5wdXRWYWx1ZXNFeHRyYWN0b3JzW2lucEVsLnR5cGVdKFxuICAgICAgICAgICAgICAgIGlucEVsLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wRWwudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBmaWVsZCAgICBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4vZXZlbnRzLnR5cGVzJykuVUlFdmVudElucHV0Q2hhbmdlQ2FsbGJhY2t9ICAgIG9uY2hhbmdlXG4gICAgICogQHBhcmFtIHthbnl9ICAgICAgICAgW2RlZmF1bHRWYWx1ZT11bmRlZmluZWRdXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgW2FkZGl0aW9uYWwgPSB7fV1cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4vZXZlbnRzLnR5cGVzJykuVUlFdmVudENhbGxiYWNrfVxuICAgICAqIEBtZW1iZXJvZiBVSUNvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBvbklucHV0KGZpZWxkLCBvbmNoYW5nZSwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkLCBhZGRpdGlvbmFsID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbmNoYW5nZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHR5cGVvZiBldmVudD8ucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50Py5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBVSUNvbW1vbi5leHRyYWN0VmFsdWVGcm9tSW5wdXQoXG4gICAgICAgICAgICAgICAgZXZlbnQ/LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIG9uY2hhbmdlKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgICAqIEBtZW1iZXJvZiBVSUNvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBpc0VudGVyRXZlbnQoZSkge1xuICAgICAgICByZXR1cm4gZS5rZXkgPT09IFwiRW50ZXJcIiAmJiAhZS5hbHRLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5zaGlmdEtleTtcbiAgICB9XG5cbiAgICBzdGF0aWMgb25seU9uRW50ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoVUlDb21tb24uaXNFbnRlckV2ZW50KGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgTU9CSUxFX1dJRFRIX0JSRUFLX1BPSU5UID0gNzYwO1xuXG4gICAgc3RhdGljIGlzTW9iaWxlKCkge1xuICAgICAgICBjb25zdCB0ZXN0TW9iaWxlID0gd2luZG93Lm1hdGNoTWVkaWEgfHwgd2luZG93Lm1zTWF0Y2hNZWRpYTtcbiAgICAgICAgaWYgKHRlc3RNb2JpbGUpIHtcbiAgICAgICAgICAgIGxldCB0ZXN0UXVlcnkgPSBcIihwb2ludGVyOmNvYXJzZSlcIjtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4X3dpZHRoID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5NT0JJTEVfV0lEVEhfQlJFQUtfUE9JTlRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRlc3RRdWVyeSA9IGBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogJHttYXhfd2lkdGh9cHgpYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXN0TW9iaWxlKHRlc3RRdWVyeSkubWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZUJvZHlTY3JvbGwoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh0aGlzLlNDUk9MTF9ESVNBQkxFUl9DTEFTUyk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc3RvcmVCb2R5U2Nyb2xsKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5TQ1JPTExfRElTQUJMRVJfQ0xBU1MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZWZvcm1hdHMgaW5wdXQgZnJvbSBhbnkgc3RyaW5nIHRvIHN0cmljdCBwaG9uZSBmb3JtYXRcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgIHZhbCAgICBmcmVlIHN0eWxlIHBob25lIG51bWJlclxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gICAgW2ZpbGxlcj1VSUNvbW1vbi5GSUxMRVJdICAgIGZyZWUgc3R5bGUgcGhvbmUgbnVtYmVyXG4gICAgICogIEByZXR1cm5zIHtzdHJpbmd9ICAgICAgICAgIHBob25lIG51bWJlclxuICAgICAqKi9cbiAgICBzdGF0aWMgZm9ybWF0UGhvbmUodmFsLCBmaWxsZXIgPSB0aGlzLkZJTExFUikge1xuICAgICAgICAvL3N0YXJ0aW5nIGZyb20gMTEgZGlnaXRzIGluIHBob25lIG51bWJlclxuICAgICAgICBjb25zdCBzbG90cyA9IFsxLCAyLCAyLCAyLCAzLCAzLCAzLCA0LCA0LCA1LCA1XTtcbiAgICAgICAgbGV0IGRpZ2l0cyA9IHZhbC5yZXBsYWNlKC9cXEQvZywgXCJcIik7XG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG1vcmUsIG1vdmUgdGhlbSB0byBjb3VudHJ5IGNvZGUgc2xvdFxuICAgICAgICBpZiAoZGlnaXRzLmxlbmd0aCA+IDExKSB7XG4gICAgICAgICAgICBsZXQgZCA9IGRpZ2l0cy5sZW5ndGggLSAxMTtcbiAgICAgICAgICAgIHdoaWxlIChkID4gMCkge1xuICAgICAgICAgICAgICAgIGQtLTtcbiAgICAgICAgICAgICAgICBzbG90cy51bnNoaWZ0KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFjayA9IFtcIlwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIlwiXTtcbiAgICAgICAgQXJyYXkuZnJvbShkaWdpdHMpLmZvckVhY2goKGRpZ2l0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNsb3QgPSBzbG90c1tpbmRleF07XG4gICAgICAgICAgICBzdGFja1tzbG90IC0gMV0gPSBzdGFja1tzbG90IC0gMV0gKyBkaWdpdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vY3JlYXRpbmcgbWFwIG9mIHBhcnRzIGxlbmd0aHNcbiAgICAgICAgY29uc3QgbGVucyA9IHNsb3RzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFjY1tjdXJyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGFjY1tjdXJyXSA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY1tjdXJyXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvL2ZpbGwgZW1wdHkgcG9zaXRpb25zIHdpdGggZmlsbGVyIChfKVxuICAgICAgICBmb3IgKGxldCB0IGluIHN0YWNrKSB7XG4gICAgICAgICAgICBsZXQgZGlmID0gbGVuc1twYXJzZUludCh0KSArIDFdIC0gc3RhY2tbdF0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGRpZiA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFja1t0XSA9IHN0YWNrW3RdICsgZmlsbGVyO1xuICAgICAgICAgICAgICAgIGRpZi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgKyR7c3RhY2tbMF19ICgke3N0YWNrWzFdfSkgJHtzdGFja1syXX0tJHtzdGFja1szXX0tJHtzdGFja1s0XX1gO1xuICAgIH1cblxuICAgIHN0YXRpYyBNT05FWV9TSUdOID0gXCImIzgzODE7XCI7XG5cbiAgICBzdGF0aWMgc2V0TW9uZXlTaWduKHZhbCkge1xuICAgICAgICB0aGlzLk1PTkVZX1NJR04gPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcHJpY2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIFVJQ29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIGZvcm1hdFByaWNlKHByaWNlKSB7XG4gICAgICAgIGxldCBtYWpvciA9IE1hdGguZmxvb3IocHJpY2UgLyAxMDApLFxuICAgICAgICAgICAgbWlub3IgPSBwcmljZSAlIDEwMDtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuTU9ORVlfU0lHTn0ke21ham9yLnRvU3RyaW5nKCl9LiR7bWlub3IudG9TdHJpbmcoKX1gO1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JtYXRMb2NhbGVEYXRldGltZShkdCwgb3B0cyA9IHsgZGF0ZTogdHJ1ZSwgdGltZTogdHJ1ZSB9KSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBkdC50b0xvY2FsZURhdGVTdHJpbmcod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBkdC50b0xvY2FsZVRpbWVTdHJpbmcod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSk7XG4gICAgICAgIGlmIChvcHRzLmRhdGUgJiYgb3B0cy50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7ZGF0ZX0gJHt0aW1lfWA7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5kYXRlICYmICFvcHRzLnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdHJ5Rm9ybWF0TG9jYWxlRGF0ZVRpbWUodmFsdWUsIG9wdHMgPSB7IGRhdGU6IHRydWUsIHRpbWU6IHRydWUgfSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFVJQ29tbW9uLmZvcm1hdExvY2FsZURhdGV0aW1lKGR0LCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFVJQ29tbW9uLmZvcm1hdExvY2FsZURhdGV0aW1lKHZhbHVlLCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGZvcm1hdFRpbWVzdGFtcCh0aW1lc3RhbXAsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IG9mZnNldExvY2FsID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICBsZXQgZGVsdGFPZmZzZXQgPSAob2Zmc2V0TG9jYWwgLSBvZmZzZXQpICogNjAgKiAxMDAwO1xuICAgICAgICBsZXQgbG9jYWxEYXRlVGltZSA9IG5ldyBEYXRlKHBhcnNlSW50KHRpbWVzdGFtcCkgLSBkZWx0YU9mZnNldCk7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGVUaW1lLnRvTG9jYWxlU3RyaW5nKHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHN0YXRpYyBUSU1FID0ge1xuICAgICAgICBTRUNPTkRTOiBbXCLRgdC10LrRg9C90LTRg1wiLCBcItGB0LXQutGD0L3QtNGLXCIsIFwi0YHQtdC60YPQvdC0XCJdLFxuICAgICAgICBNSU5VVEVTOiBbXCLQvNC40L3Rg9GC0YNcIiwgXCLQvNC40L3Rg9GC0YtcIiwgXCLQvNC40L3Rg9GCXCJdLFxuICAgICAgICBIT1VSUzogW1wi0YfQsNGBXCIsIFwi0YfQsNGB0LBcIiwgXCLRh9Cw0YHQvtCyXCJdLFxuICAgIH07XG5cbiAgICBzdGF0aWMgZGVjbE9mTnVtKG4sIHRleHRfZm9ybXMpIHtcbiAgICAgICAgbiA9IE1hdGguYWJzKG4pICUgMTAwO1xuICAgICAgICBsZXQgbjEgPSBuICUgMTA7XG4gICAgICAgIGlmIChuID4gMTAgJiYgbiA8IDIwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dF9mb3Jtc1syXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjEgPiAxICYmIG4xIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRfZm9ybXNbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4xID09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0X2Zvcm1zWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0X2Zvcm1zWzJdO1xuICAgIH1cblxuICAgIHN0YXRpYyBodW1hbml6ZWRUaW1lRGlmZihkYXRlIC8qIHVuaXggdGltZSAqLykge1xuICAgICAgICBsZXQgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgbGV0IHNlYyA9IE1hdGgucm91bmQoKGN1cnJlbnRUaW1lIC0gZGF0ZSkgLyAxMDAwKTtcbiAgICAgICAgbGV0IHVuaXQ7XG4gICAgICAgIGlmIChzZWMgPCA2MCkge1xuICAgICAgICAgICAgdW5pdCA9IHRoaXMuZGVjbE9mTnVtKHNlYywgdGhpcy5USU1FLlNFQ09ORFMpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3NlY30gJHt1bml0fSDQvdCw0LfQsNC0YDtcbiAgICAgICAgfSBlbHNlIGlmIChzZWMgPCAzNjAwKSB7XG4gICAgICAgICAgICBsZXQgbWluID0gTWF0aC5mbG9vcihzZWMgLyA2MCk7XG4gICAgICAgICAgICB1bml0ID0gdGhpcy5kZWNsT2ZOdW0obWluLCB0aGlzLlRJTUUuTUlOVVRFUyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7bWlufSAke3VuaXR9INC90LDQt9Cw0LRgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihzZWMgLyAoNjAgKiA2MCkpO1xuICAgICAgICAgICAgdW5pdCA9IHRoaXMuZGVjbE9mTnVtKGhvdXJzLCB0aGlzLlRJTUUuSE9VUlMpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2hvdXJzfSAke3VuaXR9INC90LDQt9Cw0LRgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHN0eWxlc09iamVjdFRvU3RyaW5nKHN0eWxlcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpXG4gICAgICAgICAgICAgICAgLm1hcCgocHJvcCkgPT4gYCR7cHJvcH06ICR7c3R5bGVzLnByb3B9O2ApXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzdHJpbmdPck51bWJlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBcIm51bWJlclwiXS5pbmRleE9mKHR5cGVvZiB2YWwpID4gLTE7XG4gICAgfVxuXG4gICAgc3RhdGljIHN0cmluZ3NPZk51bWJlcnMobGlzdCkge1xuICAgICAgICByZXR1cm4gbGlzdC5ldmVyeSh0aGlzLnN0cmluZ09yTnVtYmVyKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVJQ29tbW9uO1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgY2hpbGRyZW4sIC4uLm90aGVycyB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImJsb2NrIHtjbGFzc2VzfVwiIHsuLi5vdGhlcnN9PlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIGltcG9ydCBVSUJsb2NrIGZyb20gXCIuL3VpLmJsb2NrLnN2ZWx0ZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2sgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSAwLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgREVGQVVMVF9DTEFTU0VTX0lOTkVSID0gXCJibG9jay1pbm5lci12ZXJ0aWNhbFwiO1xuXG4gICAgbGV0IGNsYXNzZXNJbm5lciA9ICRzdGF0ZShERUZBVUxUX0NMQVNTRVNfSU5ORVIpO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNsYXNzZXNJbm5lciA9IGBibG9jay1pbm5lci12ZXJ0aWNhbCAke2NsYXNzZXN9YDtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uS2V5VXAgPVxuICAgICAgICBvbmtleXVwID8/IChvbmNsaWNrID8gVUlDb21tb24ub25seU9uRW50ZXIob25jbGljaykgOiB1bmRlZmluZWQpO1xuPC9zY3JpcHQ+XG5cbjxVSUJsb2NrXG4gICAge2lkfVxuICAgIGNsYXNzPXtjbGFzc2VzSW5uZXJ9XG4gICAge29uY2xpY2t9XG4gICAgb25rZXl1cD17b25LZXlVcH1cbiAgICB7cm9sZX1cbiAgICB7dGFiSW5kZXh9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9VSUJsb2NrPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleD0wXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrID0gKCkgPT4gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25rZXl1cF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gMCxcbiAgICAgICAgb25jbGljayA9ICgpID0+IHRydWUsXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IG9uS2V5VXAgPVxuICAgICAgICBvbmtleXVwID8/IChvbmNsaWNrID8gVUlDb21tb24ub25seU9uRW50ZXIob25jbGljaykgOiB1bmRlZmluZWQpO1xuPC9zY3JpcHQ+XG5cbjxkaXYge2lkfSBjbGFzcz1cImJveCB7Y2xhc3Nlc30gXCIge29uY2xpY2t9IG9ua2V5dXA9e29uS2V5VXB9IHtyb2xlfSB7dGFiSW5kZXh9PlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleD0wXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrID0gKCkgPT4gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25rZXl1cF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gMCxcbiAgICAgICAgb25jbGljayA9ICgpID0+IHRydWUsXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IG9uS2V5VXAgPVxuICAgICAgICBvbmtleXVwID8/IChvbmNsaWNrID8gVUlDb21tb24ub25seU9uRW50ZXIob25jbGljaykgOiB1bmRlZmluZWQpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICB7aWR9XG4gICAgY2xhc3M9XCJjb250ZW50IHtjbGFzc2VzfVwiXG4gICAge29uY2xpY2t9XG4gICAgb25rZXl1cD17b25LZXlVcH1cbiAgICB7cm9sZX1cbiAgICB7dGFiSW5kZXh9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7XG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlLFxuICAgICAgICBjbGljayA9IHRydWUsXG4gICAgICAgIGVudGVyID0gdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBtb3VzZUV2ZW50ID0gKGUpID0+IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9O1xuXG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IChlKSA9PiB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGUgJiYgZS5rZXkgPT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgIH07XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPXtjbGFzc2VzfVxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIHRhYmluZGV4PVwiMFwiXG4gICAgb25rZXl1cD17ZW50ZXIgPyBrZXlib2FyZEV2ZW50IDogdW5kZWZpbmVkfVxuICAgIG9uY2xpY2s9e2NsaWNrID8gbW91c2VFdmVudCA6IHVuZGVmaW5lZH1cbiAgICB7Li4ub3RoZXJzfVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuKCl9XG48L2Rpdj5cbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5mdW5jdGlvbiBpbml0RGljdCh0YXJnZXQgPSB7fSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCguLi5hcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbGUoKSB7XG4gICAgLy9jb25zdCB7IHN1YnNjcmliZSwgc2V0LCB1cGRhdGUgfSA9IHdyaXRhYmxlKGluaXREaWN0KCkpO1xuICAgIGNvbnN0IG5ld0xvY2FsZSA9IHdyaXRhYmxlKGluaXREaWN0KCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZTogbmV3TG9jYWxlLnN1YnNjcmliZSxcbiAgICAgICAgdXBkYXRlOiBuZXdMb2NhbGUudXBkYXRlLFxuICAgICAgICBzZXQ6ICh2YWwpID0+IHtcbiAgICAgICAgICAgIG5ld0xvY2FsZS5zZXQoaW5pdERpY3QodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiBuZXdMb2NhbGUuc2V0KGluaXREaWN0KCkpLFxuICAgIH07XG59XG5cbmNvbnN0IExPQ0FMRSA9IGNyZWF0ZUxvY2FsZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBMT0NBTEU7XG4iLCIvKiFcbiAqIEV2ZW50RW1pdHRlciB2NS4yLjkgLSBnaXQuaW8vZWVcbiAqIFVubGljZW5zZSAtIGh0dHA6Ly91bmxpY2Vuc2Uub3JnL1xuICogT2xpdmVyIENhbGR3ZWxsIC0gaHR0cHM6Ly9vbGkubWUudWsvXG4gKiBAcHJlc2VydmVcbiAqL1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cy5cbiAgICAgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgRXZlbnRFbWl0dGVyIE1hbmFnZXMgZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGVtaXR0aW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XG5cbiAgICAvLyBTaG9ydGN1dHMgdG8gaW1wcm92ZSBzcGVlZCBhbmQgc2l6ZVxuICAgIHZhciBwcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG4gICAgdmFyIG9yaWdpbmFsR2xvYmFsVmFsdWUgPSBleHBvcnRzLkV2ZW50RW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBpbiBpdHMgc3RvcmFnZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gbG9vayBmb3IuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyLCAtMSBpZiBub3QgZm91bmRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgYSBtZXRob2Qgd2hpbGUga2VlcGluZyB0aGUgY29udGV4dCBjb3JyZWN0LCB0byBhbGxvdyBmb3Igb3ZlcndyaXRpbmcgb2YgdGFyZ2V0IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgYWxpYXNlZCBtZXRob2RcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbGlhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhbGlhc0Nsb3N1cmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFdpbGwgaW5pdGlhbGlzZSB0aGUgZXZlbnQgb2JqZWN0IGFuZCBsaXN0ZW5lciBhcnJheXMgaWYgcmVxdWlyZWQuXG4gICAgICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxuICAgICAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcHJvdG8uZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAvLyBSZXR1cm4gYSBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGV2ZW50cyBpZlxuICAgICAgICAvLyB0aGUgc2VsZWN0b3IgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtrZXldID0gZXZlbnRzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbGlzdCBvZiBsaXN0ZW5lciBvYmplY3RzIGFuZCBmbGF0dGVucyBpdCBpbnRvIGEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBsaXN0ZW5lcnMgUmF3IGxpc3RlbmVyIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb25bXX0gSnVzdCB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHByb3RvLmZsYXR0ZW5MaXN0ZW5lcnMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgICAgICB2YXIgZmxhdExpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGF0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzW2ldLmxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGF0TGlzdGVuZXJzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSByZXF1ZXN0ZWQgbGlzdGVuZXJzIHZpYSBnZXRMaXN0ZW5lcnMgYnV0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgcmVzdWx0cyBpbnNpZGUgYW4gb2JqZWN0LiBUaGlzIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlIGJ1dCBvdGhlcnMgbWF5IGZpbmQgaXQgdXNlZnVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IGluIGFuIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcm90by5nZXRMaXN0ZW5lcnNBc09iamVjdCA9IGZ1bmN0aW9uIGdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIHJlc3BvbnNlW2V2dF0gPSBsaXN0ZW5lcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UgfHwgbGlzdGVuZXJzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkTGlzdGVuZXIgKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgfHwgbGlzdGVuZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRMaXN0ZW5lcihsaXN0ZW5lci5saXN0ZW5lcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxuICAgICAqIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgY2FsbGVkLlxuICAgICAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcklzV3JhcHBlZCA/IGxpc3RlbmVyIDoge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYWRkTGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgaXRzIGZpcnN0IGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNhbGxpbmcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkT25jZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZ0LCB7XG4gICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBhZGRPbmNlTGlzdGVuZXIuXG4gICAgICovXG4gICAgcHJvdG8ub25jZSA9IGFsaWFzKCdhZGRPbmNlTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYW4gZXZlbnQgbmFtZS4gVGhpcyBpcyByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSByZWdleCB0byBhZGQgYSBsaXN0ZW5lciB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gSWYgeW91IGRvbid0IGRvIHRoaXMgdGhlbiBob3cgZG8geW91IGV4cGVjdCBpdCB0byBrbm93IHdoYXQgZXZlbnQgdG8gYWRkIHRvPyBTaG91bGQgaXQganVzdCBhZGQgdG8gZXZlcnkgcG9zc2libGUgbWF0Y2ggZm9yIGEgcmVnZXg/IE5vLiBUaGF0IGlzIHNjYXJ5IGFuZCBiYWQuXG4gICAgICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50KGV2dCkge1xuICAgICAgICB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlcyBkZWZpbmVFdmVudCB0byBkZWZpbmUgbXVsdGlwbGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZXZ0cyBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkZWZpbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uZGVmaW5lRXZlbnRzID0gZnVuY3Rpb24gZGVmaW5lRXZlbnRzKGV2dHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZUV2ZW50KGV2dHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFdoZW4gcGFzc2VkIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lLCBpdCB3aWxsIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgcmVtb3ZlTGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcm90by5vZmYgPSBhbGlhcygncmVtb3ZlTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IGNhbiBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy4gWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIGFkZCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKiBZZWFoLCB0aGlzIGZ1bmN0aW9uIGRvZXMgcXVpdGUgYSBiaXQuIFRoYXQncyBwcm9iYWJseSBhIGJhZCB0aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKGZhbHNlLCBldnQsIGxpc3RlbmVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IGNhbiByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSByZW1vdmVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyh0cnVlLCBldnQsIGxpc3RlbmVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVkaXRzIGxpc3RlbmVycyBpbiBidWxrLiBUaGUgYWRkTGlzdGVuZXJzIGFuZCByZW1vdmVMaXN0ZW5lcnMgbWV0aG9kcyBib3RoIHVzZSB0aGlzIHRvIGRvIHRoZWlyIGpvYi4gWW91IHNob3VsZCByZWFsbHkgdXNlIHRob3NlIGluc3RlYWQsIHRoaXMgaXMgYSBsaXR0bGUgbG93ZXIgbGV2ZWwuXG4gICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgKHRydWUpIG9yIGFkZGVkIChmYWxzZSkuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQvcmVtb3ZlZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYW5pcHVsYXRlIHRoZSBsaXN0ZW5lcnMgb2YgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgVHJ1ZSBpZiB5b3Ugd2FudCB0byByZW1vdmUgbGlzdGVuZXJzLCBmYWxzZSBpZiB5b3Ugd2FudCB0byBhZGQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQvcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLm1hbmlwdWxhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBtYW5pcHVsYXRlTGlzdGVuZXJzKHJlbW92ZSwgZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIHNpbmdsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyO1xuICAgICAgICB2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xuXG4gICAgICAgIC8vIElmIGV2dCBpcyBhbiBvYmplY3QgdGhlbiBwYXNzIGVhY2ggb2YgaXRzIHByb3BlcnRpZXMgdG8gdGhpcyBtZXRob2RcbiAgICAgICAgaWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgZm9yIChpIGluIGV2dCkge1xuICAgICAgICAgICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkgJiYgKHZhbHVlID0gZXZ0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXNzIGJhY2sgdG8gdGhlIG11bHRpcGxlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICAgICAgICAvLyBBbmQgbGlzdGVuZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgbGlzdGVuZXJzXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgaXQgYW5kIHBhc3MgZWFjaCBvbmUgdG8gdGhlIG11bHRpcGxlIG1ldGhvZFxuICAgICAgICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbiBldmVudCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIFRoYXQgbWVhbnMgZXZlcnkgZXZlbnQgd2lsbCBiZSBlbXB0aWVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVnZXggdG8gcmVtb3ZlIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gW2V2dF0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLiBXaWxsIHJlbW92ZSBmcm9tIGV2ZXJ5IGV2ZW50IGlmIG5vdCBwYXNzZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChldnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZXZ0O1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZiBldnRcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tldnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgZm9yIChrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIGFsbCBldmVudHNcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXG4gICAgICpcbiAgICAgKiBBZGRlZCB0byBtaXJyb3IgdGhlIG5vZGUgQVBJLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUFsbExpc3RlbmVycyA9IGFsaWFzKCdyZW1vdmVFdmVudCcpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgb2YgeW91ciBjaG9pY2UuXG4gICAgICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAgICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxuICAgICAqIEJlY2F1c2UgaXQgdXNlcyBgYXBwbHlgLCB5b3VyIGFycmF5IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBpZiB5b3Ugd3JvdGUgdGhlbSBvdXQgc2VwYXJhdGVseS5cbiAgICAgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnNNYXAgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBsaXN0ZW5lcnM7XG4gICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciByZXNwb25zZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnNNYXApIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcFtrZXldLnNsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgc2hhbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGxpc3RlbmVyLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdGhpcy5fZ2V0T25jZVJldHVyblZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgZW1pdEV2ZW50XG4gICAgICovXG4gICAgcHJvdG8udHJpZ2dlciA9IGFsaWFzKCdlbWl0RXZlbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cbiAgICAgKiBBcyB3aXRoIGVtaXRFdmVudCwgeW91IGNhbiBwYXNzIGEgcmVnZXggaW4gcGxhY2Ugb2YgdGhlIGV2ZW50IG5hbWUgdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4qfSBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWYgYVxuICAgICAqIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGUgb25lIHNldCBoZXJlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gY2hlY2sgZm9yIHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5zZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBzZXRPbmNlUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb25jZVJldHVyblZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZlxuICAgICAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqIGF1dG9tYXRpY2FsbHkuIEl0IHdpbGwgcmV0dXJuIHRydWUgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLl9nZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBfZ2V0T25jZVJldHVyblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnX29uY2VSZXR1cm5WYWx1ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25jZVJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgZXZlbnRzIG9iamVjdCBhbmQgY3JlYXRlcyBvbmUgaWYgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgZ2xvYmFsIHtAbGluayBFdmVudEVtaXR0ZXJ9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTm9uIGNvbmZsaWN0aW5nIEV2ZW50RW1pdHRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gb3JpZ2luYWxHbG9iYWxWYWx1ZTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIHRoZSBjbGFzcyBlaXRoZXIgdmlhIEFNRCwgQ29tbW9uSlMgb3IgdGhlIGdsb2JhbCBvYmplY3RcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuICAgIH1cbn0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzIHx8IHt9KSk7XG4iLCIvKlxuXHQ6cHJvcGVydHkuc3ViMS5mdW5jKCkuZnVuY1Byb3Bcblx0ID0gcmV0dXJuIGZ1bmNQcm9wIG9mIGZ1bmN0aW9uIHJlc3VsdCBvZiBzdWIxIHByb3BlcnR5IG9mIHByb3BlcnR5IG9mIG9iamVjdFxuXHQ6ezo6aGVscGVyVmFsfS5zdWJcblx0ID0gcmV0dXJuIHN1YiBwcm9wZXJ0eSBvZiBvYmplY3QgcHJvcGVydHkgd2l0aCBuYW1lIHJldHJpZXZlZCBmcm9tIGhlbHBlclZhbCBwcm9wZXJ0eSBvZiBoZWxwZXJzIG9iamVjdFxuXHQ6ezo6aGVscGVyRnVuYygpfS5zdWJcblx0PSByZXR1cm4gc3ViIHByb3BlcnR5IG9mIG9iamVjdCBwcm9wZXJ0eSB3aXRoIG5hbWUgcmV0cmlldmVkIGZyb20gaGVscGVyVmFsIGZ1bmN0aW9uIHJlc3VsdCBvZiBoZWxwZXJzIG9iamVjdC5cblx0aWYgaGVscGVyc0Z1bnggcmV0dXJuICdjYXInIHRoZW4gc291cmNlIHBhdGggYmVjb21lcyA6Y2FyLnN1YlxuXG4qL1xuXG5jb25zdCBTVUJfUEFUSF9TVEFSVCA9IFwie1wiLFxuICAgIFNVQl9QQVRIX0VORCA9IFwifVwiLFxuICAgIFBBVEhfU1BMSVQgPSBcIi5cIixcbiAgICBQQVRIX1NUQVJUX09CSkVDVCA9IFwiOlwiLFxuICAgIFBBVEhfU1RBUlRfSEVMUEVSUyA9IFwiOjpcIixcbiAgICBGVU5DVElPTl9NQVJLRVIgPSBcIigpXCIsXG4gICAgTUFYX0RFRVAgPSAxMDtcblxuLyoqXG4gKiBTZXQgb2YgdG9vbHMgdG8gdXNlIG5vdFBhdGggcHJvcGVydHkgYWNjZXNzIG5vdGF0aW9uXG4gKiA6IGlzIGZvciBpdGVtXG4gKiA6OiBpcyBmb3IgaGVscGVyc1xuICoge30gc3VicGF0aFxuICogLiBwYXRoIHNwbGl0dGVyXG4gKiAoKSBmdW5jdGlvbiBhbmQgc2hvdWxkIGJlIGV4ZWN1dGVkIHdpdGggcGFyYW1zIChpdGVtLCBoZWxwZXIgfCB1bmRlZmluZWQpXG4gKiBzdWItcGF0aHMgd2lsbCBiZSBwYXJzZWQgYW5kIHJlcGxhY2VkIGJ5IHJlc3VsdHMgaW4gc291cmNlIHBhdGhcbiAqL1xuY2xhc3Mgbm90UGF0aCB7XG4gICAgc3RhdGljIGdldCBTVUJfUEFUSF9TVEFSVCgpIHtcbiAgICAgICAgcmV0dXJuIFNVQl9QQVRIX1NUQVJUO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFNVQl9QQVRIX0VORCgpIHtcbiAgICAgICAgcmV0dXJuIFNVQl9QQVRIX0VORDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBQQVRIX1NQTElUKCkge1xuICAgICAgICByZXR1cm4gUEFUSF9TUExJVDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBQQVRIX1NUQVJUX09CSkVDVCgpIHtcbiAgICAgICAgcmV0dXJuIFBBVEhfU1RBUlRfT0JKRUNUO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFBBVEhfU1RBUlRfSEVMUEVSUygpIHtcbiAgICAgICAgcmV0dXJuIFBBVEhfU1RBUlRfSEVMUEVSUztcbiAgICB9XG4gICAgc3RhdGljIGdldCBGVU5DVElPTl9NQVJLRVIoKSB7XG4gICAgICAgIHJldHVybiBGVU5DVElPTl9NQVJLRVI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTUFYX0RFRVAoKSB7XG4gICAgICAgIHJldHVybiBNQVhfREVFUDtcbiAgICB9XG5cbiAgICAvKlxuXHRcdGlucHV0ICc6ezo6aGVscGVyVmFsfS5zdWInXG5cdFx0cmV0dXJuIDo6aGVscGVyVmFsXG5cdCovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IHN1YnBhdGggaW4gcGF0aFxuICAgICAqIGlmIHN1YnBhdGggbm90IGNsb3NlZCB3aWxsIHJldHVybiBpdCBhbnl3YXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIGluIHN0cmluZyBub3RhdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSBzdWJwYXRoIG9yIG51bGwgaWYgbm8gc3ViIHBhdGggd2VyZSBmb3VuZFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5kTmV4dFN1YlBhdGgocGF0aCkge1xuICAgICAgICBsZXQgc3ViUGF0aCA9IFwiXCIsXG4gICAgICAgICAgICBmaW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09IFNVQl9QQVRIX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgZmluZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3ViUGF0aCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoW2ldID09PSBTVUJfUEFUSF9FTkQgJiYgZmluZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViUGF0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXRoICs9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kID8gc3ViUGF0aCA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzdWItcGF0aCBpbiBwYXJlbnQgcGF0aCBieSBwYXJzZWQgdmVyc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWIgc3ViIHBhdGggdG8gcmVwbGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJzZWQgcGFyc2VkIHN1YiBwYXRoXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBwYXJzZWQgcGF0aFxuICAgICAqL1xuXG4gICAgc3RhdGljIHJlcGxhY2VTdWJQYXRoKHBhdGgsIHN1YiwgcGFyc2VkKSB7XG4gICAgICAgIGxldCBzdWJmID0gU1VCX1BBVEhfU1RBUlQgKyBzdWIgKyBTVUJfUEFUSF9FTkQsXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKHBhdGguaW5kZXhPZihzdWJmKSA+IC0xICYmIGkgPCBNQVhfREVFUCkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShzdWJmLCBwYXJzZWQpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBwYXRoIHdoaWxlIHRoZXJlIGFueSBzdWItcGF0aHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCByYXcgdW5wYXJzZWQgcGF0aFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVscGVycyBoZWxwZXJzXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBwYXJzZWQgcGF0aFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVN1YnMocGF0aCwgaXRlbSwgaGVscGVycykge1xuICAgICAgICBsZXQgc3ViUGF0aCA9IHRoaXMuZmluZE5leHRTdWJQYXRoKHBhdGgpLFxuICAgICAgICAgICAgc3ViUGF0aFBhcnNlZCxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoc3ViUGF0aCkge1xuICAgICAgICAgICAgc3ViUGF0aFBhcnNlZCA9IHRoaXMuZ2V0VmFsdWVCeVBhdGgoXG4gICAgICAgICAgICAgICAgc3ViUGF0aC5pbmRleE9mKFBBVEhfU1RBUlRfSEVMUEVSUykgPiAtMSA/IGhlbHBlcnMgOiBpdGVtLFxuICAgICAgICAgICAgICAgIHN1YlBhdGgsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBoZWxwZXJzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGF0aCA9IHRoaXMucmVwbGFjZVN1YlBhdGgocGF0aCwgc3ViUGF0aCwgc3ViUGF0aFBhcnNlZCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA+IE1BWF9ERUVQKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJQYXRoID0gdGhpcy5maW5kTmV4dFN1YlBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtoZWxwZXJzXSBoZWxwZXJzIG9iamVjdFxuICAgICAqL1xuXG4gICAgc3RhdGljIGdldChwYXRoLCBpdGVtLCBoZWxwZXJzID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgY2FzZSBQQVRIX1NUQVJUX09CSkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIGNhc2UgUEFUSF9TVEFSVF9IRUxQRVJTOlxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSB0aGlzLnBhcnNlU3VicyhwYXRoLCBpdGVtLCBoZWxwZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVCeVBhdGgoXG4gICAgICAgICAgICBwYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9IRUxQRVJTKSA+IC0xID8gaGVscGVycyA6IGl0ZW0sXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGhlbHBlcnNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgaGVscGVycyAgICAgICAgIGhlbHBlcnMgb2JqZWN0IGlmIDQgYXJndW1lbnRzIG9yIGF0dHJWYWx1ZSBpZiBvbmx5IDMgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0ge2FueX0gICAgIFthdHRyVmFsdWVdICAgICB2YWx1ZSB3ZSB3YW50IHRvIGFzc2lnblxuICAgICAqL1xuXG4gICAgc3RhdGljIHNldChwYXRoLCBpdGVtLCBoZWxwZXJzLCBhdHRyVmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGhlbHBlcnM7XG4gICAgICAgICAgICBoZWxwZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJQYXRoID0gdGhpcy5maW5kTmV4dFN1YlBhdGgocGF0aCksXG4gICAgICAgICAgICBzdWJQYXRoUGFyc2VkLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChzdWJQYXRoKSB7XG4gICAgICAgICAgICBzdWJQYXRoUGFyc2VkID0gdGhpcy5nZXRWYWx1ZUJ5UGF0aChcbiAgICAgICAgICAgICAgICBzdWJQYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9IRUxQRVJTKSA+IC0xID8gaGVscGVycyA6IGl0ZW0sXG4gICAgICAgICAgICAgICAgc3ViUGF0aCxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIGhlbHBlcnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5yZXBsYWNlU3ViUGF0aChwYXRoLCBzdWJQYXRoLCBzdWJQYXRoUGFyc2VkKTtcbiAgICAgICAgICAgIGlmIChpID4gTUFYX0RFRVApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlBhdGggPSB0aGlzLmZpbmROZXh0U3ViUGF0aChwYXRoKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFZhbHVlQnlQYXRoKGl0ZW0sIHBhdGgsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGl0ZW0uaXNSZWNvcmQgJiZcbiAgICAgICAgICAgIHRoaXMubm9ybWlsaXplUGF0aChwYXRoKS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICBpdGVtLl9faXNBY3RpdmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpdGVtLnRyaWdnZXIoXCJjaGFuZ2VcIiwgaXRlbSwgcGF0aCwgYXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0YXJnZXQgcHJvcGVydHkgdG8gbnVsbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWxwZXJzIGhlbHBlcnMgb2JqZWN0XG4gICAgICovXG5cbiAgICBzdGF0aWMgdW5zZXQocGF0aCwgaXRlbSwgaGVscGVycykge1xuICAgICAgICB0aGlzLnNldChwYXRoLCBpdGVtLCBoZWxwZXJzLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgc3RlcCBrZXksIHRyYW5zZm9ybXMgaXQgdG8gZW5kLWZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RlcCBub3QgcGFyc2VkIHN0ZXAga2V5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gaXRlbSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVscGVyIGhlbHBlcnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bWJlcn0gcGFyc2VkIHN0ZXAga2V5XG4gICAgICovXG5cbiAgICBzdGF0aWMgcGFyc2VQYXRoU3RlcChzdGVwLCBpdGVtLCBoZWxwZXIpIHtcbiAgICAgICAgbGV0IHJTdGVwID0gbnVsbDtcbiAgICAgICAgaWYgKHN0ZXAuaW5kZXhPZihQQVRIX1NUQVJUX0hFTFBFUlMpID09PSAwICYmIGhlbHBlcikge1xuICAgICAgICAgICAgclN0ZXAgPSBzdGVwLnJlcGxhY2UoUEFUSF9TVEFSVF9IRUxQRVJTLCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChyU3RlcC5pbmRleE9mKEZVTkNUSU9OX01BUktFUikgPT09IHJTdGVwLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICByU3RlcCA9IHJTdGVwLnJlcGxhY2UoRlVOQ1RJT05fTUFSS0VSLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlbHBlciwgclN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJbclN0ZXBdKGl0ZW0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyW3JTdGVwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGVwLmluZGV4T2YoUEFUSF9TVEFSVF9PQkpFQ1QpID09PSAwICYmIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByU3RlcCA9IHN0ZXAucmVwbGFjZShQQVRIX1NUQVJUX09CSkVDVCwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJTdGVwLmluZGV4T2YoRlVOQ1RJT05fTUFSS0VSKSA9PT0gclN0ZXAubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgICAgICByU3RlcCA9IHJTdGVwLnJlcGxhY2UoRlVOQ1RJT05fTUFSS0VSLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpdGVtLCByU3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtW3JTdGVwXShpdGVtLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bclN0ZXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9XG5cbiAgICAvLzo6ZmllbGROYW1lLnJlc3VsdFxuICAgIC8ve31cbiAgICAvL3tmaWVsZE5hbWU6ICd0YXJnZXRSZWNvcmRGaWVsZCd9XG4gICAgLy8vL1sndGFyZ2V0UmVjb3JkRmllbGQnLCAncmVzdWx0J11cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHBhdGggd2l0aCBzdWIgcGF0aHMgdG8gcGF0aCB3aXRob3V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHBhdGggcGF0aCB0byB0YXJnZXQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWxwZXIgaGVscGVyIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2FycmF5fSBwYXJzZWQgcGF0aFxuICAgICAqKi9cbiAgICBzdGF0aWMgcGFyc2VQYXRoKHBhdGgsIGl0ZW0sIGhlbHBlcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFBBVEhfU1BMSVQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0aFtpXSA9IHRoaXMucGFyc2VQYXRoU3RlcChwYXRoW2ldLCBpdGVtLCBoZWxwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgcGF0aCBmcm9tIHN0cmluZyBub3RhdGlvbiB0byBhcnJheSBvZiBrZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHBhdGggIGlucHV0IHBhdGgsIGlmIGFycmF5IGRvZXMgbm90aGluZ1xuICAgICAqIEByZXR1cm4ge2FycmF5fSBwYXRoIGluIGFycmF5IG5vdGF0aW9uXG4gICAgICovXG5cbiAgICBzdGF0aWMgbm9ybWlsaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChwYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9PQkpFQ1QpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKFBBVEhfU1RBUlRfT0JKRUNULCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoLnNwbGl0KFBBVEhfU1BMSVQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblx0XHRzbWFsbCA9IFtcInRvZG9cIl0sXG5cdFx0YmlnID0gW1widG9kb1wiLCBcImxlbmd0aFwiXVxuXHRcdHJldHVybiB0cnVlO1xuXG5cdCovXG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGlmIGZpcnN0IHBhdGggaW5jbHVkZXMgc2Vjb25kLCBjb21wYXJlZCBmcm9tIHN0YXJ0LFxuICAgICAqIG5vIGZsb2F0aW5nIHN0YXJ0IHBvc2l0aW9uIGluc2lkZSBbJ2pvaW4nLCAnbWUnXSwgWydtZSddXG4gICAgICogd2lsbCByZXN1bHQgaW4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBiaWcgd2hlcmUgd2Ugd2lsbCBzZWFyY2hcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBzbWFsbCB3aGF0IHdlIHdpbGwgc2VhcmNoXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gaWYgd2Ugc3VjY2VlZFxuICAgICAqL1xuXG4gICAgc3RhdGljIGlmRnVsbFN1YlBhdGgoYmlnLCBzbWFsbCkge1xuICAgICAgICBpZiAoYmlnLmxlbmd0aCA8IHNtYWxsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgc21hbGwubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGlmIChzbWFsbFt0XSAhPT0gYmlnW3RdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRlciB0aHJvdWdoIHRoaXJkIG9iamVjdFxuICAgICAqIFBhdGggaXMgcGFyc2VkLCBubyBldmVudCB0cmlnZ2VyaW5nIGZvciBub3RSZWNvcmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IG9iamVjdCB0byBiZSB1c2VkIGFzIGdldHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBhdHRyUGF0aCBwYXRoIHRvIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gc3VwcG9ydGluZyBkYXRhXG4gICAgICogQHBhcmFtIHtoZWxwZXJzfSBvYmplY3QgIHN1cHBvcnRpbmcgaGVscGVyc1xuICAgICAqL1xuXG4gICAgc3RhdGljIGdldFZhbHVlQnlQYXRoKG9iamVjdCwgYXR0clBhdGgsIGl0ZW0sIGhlbHBlcnMpIHtcbiAgICAgICAgYXR0clBhdGggPSB0aGlzLm5vcm1pbGl6ZVBhdGgoYXR0clBhdGgpO1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSBhdHRyUGF0aC5zaGlmdCgpLFxuICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGF0dHJOYW1lLmluZGV4T2YoRlVOQ1RJT05fTUFSS0VSKSA+IC0xO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyTmFtZS5yZXBsYWNlKEZVTkNUSU9OX01BUktFUiwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iamVjdCA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqZWN0W2F0dHJOYW1lXSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgb2JqZWN0W2F0dHJOYW1lXSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxldCBuZXdPYmogPSBpc0Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyBvYmplY3RbYXR0ck5hbWVdKHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcnMsXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogb2JqZWN0W2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVCeVBhdGgobmV3T2JqLCBhdHRyUGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIHRocm91Z2ggdGhpcmQgb2JqZWN0XG4gICAgICogUGF0aCBpcyBwYXJzZWQsIG5vIGV2ZW50IHRyaWdnZXJpbmcgZm9yIG5vdFJlY29yZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3Qgb2JqZWN0IHRvIGJlIG1vZGlmaWVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IGF0dHJQYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FueX0gYXR0clZhbHVlICB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cblxuICAgIHN0YXRpYyBzZXRWYWx1ZUJ5UGF0aChvYmplY3QsIGF0dHJQYXRoLCBhdHRyVmFsdWUpIHtcbiAgICAgICAgYXR0clBhdGggPSB0aGlzLm5vcm1pbGl6ZVBhdGgoYXR0clBhdGgpO1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSBhdHRyUGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAoYXR0clBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbYXR0ck5hbWVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlQnlQYXRoKG9iamVjdFthdHRyTmFtZV0sIGF0dHJQYXRoLCBhdHRyVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0W2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpvaW5zIHBhc3NlZCBpbiBzdHJpbmdzIHdpdGggUEFUSF9TUExJVFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmd1bWVudHMgcGF0aCB0byBiZSBnbHVlZFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gY29tcG9zaXRlIHBhdGhcbiAgICAgKi9cblxuICAgIHN0YXRpYyBqb2luKCkge1xuICAgICAgICBsZXQgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmdzLmpvaW4oUEFUSF9TUExJVCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdFBhdGg7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL2luZGV4LmpzJyk7XG4iLCIvLyBAdHMtaWdub3JlXG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcblxuLypcbmh0dHBzOi8vZ2l0aHViLmNvbS9UZWhTaHJpa2UvaXMtbWVyZ2VhYmxlLW9iamVjdFxuXG5JbmNsdWRlZCBmb3IgY29udmluaWVuY2Ugb25seS4gQWxsIHJpZ2h0cyBiZWxvbmdzIHRvIHRoZWlyIGF1dGhvcnMgYW5kIGV0Yy5cbnN0YXJ0IG9mIG15IGNvZGUgbWFya2VkLlxuXG4qL1xuXG5sZXQgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpICYmICFpc1NwZWNpYWwodmFsdWUpO1xufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcbiAgICB2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgc3RyaW5nVmFsdWUgPT09IFwiW29iamVjdCBSZWdFeHBdXCIgfHxcbiAgICAgICAgc3RyaW5nVmFsdWUgPT09IFwiW29iamVjdCBEYXRlXVwiIHx8XG4gICAgICAgIGlzUmVhY3RFbGVtZW50KHZhbHVlKVxuICAgICk7XG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG4vKlxuaHR0cHM6Ly9naXRodWIuY29tL0t5bGVBTWF0aGV3cy9kZWVwbWVyZ2VcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxMiBOaWNob2xhcyBGaXNoZXJcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge307XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICBjb25zdCBjbG9uZSA9ICFvcHRpb25zQXJndW1lbnQgfHwgb3B0aW9uc0FyZ3VtZW50LmNsb25lICE9PSBmYWxzZTtcblxuICAgIHJldHVybiBjbG9uZSAmJiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSlcbiAgICAgICAgPyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9uc0FyZ3VtZW50KVxuICAgICAgICA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgcmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHt9O1xuICAgIGlmIChpc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc0FyZ3VtZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkgfHwgIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgICAgICAgICAgc291cmNlW2tleV0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc0FyZ3VtZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGRlZXBtZXJnZShcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSxcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgICAgICBvcHRpb25zQXJndW1lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgY29uc3Qgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zQXJndW1lbnQgfHwge1xuICAgICAgICBhcnJheU1lcmdlOiBkZWZhdWx0QXJyYXlNZXJnZSxcbiAgICB9O1xuICAgIGNvbnN0IHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG4gICAgaWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG4gICAgICAgIHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG4gICAgICAgIGNvbnN0IGFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG4gICAgICAgIHJldHVybiBhcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICB9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH0sIHt9KTtcbn07XG5cbi8qKlxuICogIENvbGxlY3Rpb24gb2YgY29tbW9uIGZ1bmN0aW9uc1xuICogIEBjbGFzc1xuICovXG5jbGFzcyBub3RDb21tb24ge1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtPYmplY3R9IFtNQU5BR0VSPW51bGxdICBhcHBsaWNhdGlvbiBtYW5hZ2VyLCBpbiBzb21lIGNhc2VzIHVzZWQgdG8gY29udHJvbCBpbml0aWFsaXphdGlvbiByb3V0aW5lXG4gICAgICovXG4gICAgc3RhdGljIE1BTkFHRVIgPSBudWxsO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtzdHJpbmd9IFtMT0c9XCJjb25zb2xlXCJdICBsb2dnZXIsIHdpbmRvd1tMT0ddXG4gICAgICovXG4gICAgc3RhdGljIExPRyA9IFwiY29uc29sZVwiO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtmdW5jdGlvbn0gZGVlcE1lcmdlICBmdW5jdGlvbiB0byBwZXJmb3JtIGRlZXAgbWVyZ2VzIG9mIG9iamVjdHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVlcE1lcmdlID0gZGVlcG1lcmdlO1xuXG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge2Z1bmN0aW9ufSBpc0Vycm9yICBmdW5jdGlvbiB0byBwZXJmb3JtIG9iamVjdCB0ZXN0LCBpZiBpdCdzIGFuIGVycm9yIG9iamVjdCBvciBub3RcbiAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBlICAgb2JqZWN0IHRvIHRlc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcihlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChPYmplY3QuaGFzT3duKGUsIFwic3RhdHVzXCIpICYmIGUuc3RhdHVzID09PSBcImVycm9yXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIFRaX09GRlNFVCA9IChuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MCkgKiAtMTtcbiAgICBzdGF0aWMgREVWX0VOViA9IFwicHJvZHVjdGlvblwiO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzdGF0aWMgRU5WX1RZUEUgPSB3aW5kb3cuTk9UX0VOVl9UWVBFID8/IG5vdENvbW1vbi5ERVZfRU5WO1xuICAgIHN0YXRpYyBOT09QID0gKCkgPT4ge307XG5cbiAgICBzdGF0aWMgbXV0ZSgpIHtcbiAgICAgICAgbm90Q29tbW9uLkVOVl9UWVBFID0gXCJwcm9kdWN0aW9uXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhZChuKSB7XG4gICAgICAgIHJldHVybiBuIDwgMTAgPyBcIjBcIiArIG4gOiBuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0b2RheSBEYXRlIG9iamVjdCB3aXRob3V0IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzXG4gICAgICogIEByZXR1cm4ge251bWJlcn0gIGN1cnJlbnQgZGF0ZSB3aXRoIDAwOjAwOjAwIGluIG1zIG9mIHVuaXggdGltZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUb2RheURhdGUoKSB7XG4gICAgICAgIGxldCB0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwgdC5nZXRNb250aCgpLCB0LmdldERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBmaWVsZCBvZiBuYW1lXG4gICAgICogICBAcGFyYW0gICB7b2JqZWN0fSAgICBvYmogICAgc29tZSBvYmplY3RcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgICBuYW1lICBmaWVsZCBuYW1lXG4gICAgICogIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgIGlmIG9iamVjdCBjb250YWlucyBmaWVsZCB3aXRoIG5hbWVcbiAgICAgKiovXG4gICAgc3RhdGljIG9iakhhcyhvYmosIG5hbWUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bihvYmosIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvYmplY3QgdG8gc2VjdXJlIGl0IGZyb20gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iaiAgICAgb3JpZ2luYWwgb2JqZWN0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBjb3B5IG9mIG9iamVjdFxuICAgICAqKi9cbiAgICBzdGF0aWMgY29weU9iaihvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG9iamVjdCB0byBzZWN1cmUgaXQgZnJvbSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgb2JqICAgICBvcmlnaW5hbCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIGNvcHkgb2Ygb2JqZWN0XG4gICAgICoqL1xuICAgIHN0YXRpYyBwYXJ0Q29weU9iaihvYmosIGxpc3QpIHtcbiAgICAgICAgbGV0IHBhcnRPYmogPSBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoY3VycikpIHtcbiAgICAgICAgICAgICAgICBwcmV2W2N1cnJdID0gb2JqW2N1cnJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFydE9iaikpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21wYXJlVHdvQXJyYXlzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgICAgICAgICAgYS5ldmVyeSgoZWxlbWVudCwgaW5kZXgpID0+IGVsZW1lbnQgPT09IGJbaW5kZXhdKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgYXJndW1lbnQgdHlwZSB0byBiZSAnZnVuY3Rpb24nXG4gICAgICogQHBhcmFtIHthbnl9ICBmdW5jICAgIHBvc3NpYmxlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgIGlmIHRoaXMgaXMgYSBmdW5jdGlvblxuICAgICAqKi9cbiAgICBzdGF0aWMgaXNGdW5jKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFyZ3VtZW50IGlzIEFzeW5jIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgIGlmIHRoaXMgZnVuY3Rpb24gaXMgY29uc3RydWN0ZWQgYXMgQXN5bmNGdW5jdGlvblxuICAgICAqKi9cbiAgICBzdGF0aWMgaXNBc3luYyhmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQXN5bmNGdW5jdGlvblwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFeGVjdXRlcyBtZXRob2Qgb2Ygb2JqZWN0IGluIGFwcHJvcHJpYXRlIHdheSBpbnNpZGUgUHJvbWlzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iaiAgICAgb3JpZ2luYWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZSAgICBtZXRob2QgbmFtZSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gICAgIHBhcmFtcyAgYXJyYXkgb2YgcGFyYW1zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgcmVzdWx0cyBvZiBtZXRob2QgZXhlY3V0aW9uXG4gICAgICoqL1xuICAgIHN0YXRpYyBhc3luYyBleGVjdXRlT2JqZWN0RnVuY3Rpb24ob2JqLCBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcHJvYyA9IG5vdFBhdGguZ2V0KFwiOlwiICsgbmFtZSwgb2JqKTtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKHByb2MpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0FzeW5jKHByb2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2MoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgRXhlY3V0ZXMgbWV0aG9kIG9mIG9iamVjdCBpbiBhcHJvcHJpYXRlIHdheSBpbnNpZGUgUHJvbWlzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIGZyb20gICAgIG9yaWdpbmFsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHRvICAgIG1ldGhvZCBuYW1lIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgbGlzdCAgYXJyYXkgb2YgcGFyYW1zXG4gICAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICByZXN1bHRzIG9mIG1ldGhvZCBleGVjdXRpb25cbiAgICAgKiovXG4gICAgc3RhdGljIG1hcEJpbmQoZnJvbSwgdG8sIGxpc3QpIHtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb21baXRlbV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRvW2l0ZW1dID0gZnJvbVtpdGVtXS5iaW5kKGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDbGFzcyhmbikge1xuICAgICAgICByZXR1cm4gL15cXHMqY2xhc3MvLnRlc3QoZm4udG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGRldGVjdFR5cGUodGVzdGllKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVzdGllICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGVzdGllO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0NsYXNzKHRlc3RpZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjbGFzc1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy/Qn9GA0L7QstC10YDQutCwINGP0LLQu9GP0LXRgtGB0Y8g0LvQuCDQv9C10YDQtdC80LXQvdC90LDRjyDQvNCw0YHRgdC40LLQvtC8XG4gICAgc3RhdGljIGlzQXJyYXkoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIiAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvY2FsSXNvRGF0ZShkYXRlKSB7XG4gICAgICAgIGRhdGUgPSBkYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBsb2NhbElzb1N0cmluZyA9XG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldE1vbnRoKCkgKyAxKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0RGF0ZSgpKSArXG4gICAgICAgICAgICBcIlRcIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0SG91cnMoKSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldE1pbnV0ZXMoKSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldFNlY29uZHMoKSk7XG4gICAgICAgIHJldHVybiBsb2NhbElzb1N0cmluZztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VG9kYXkoKSB7XG4gICAgICAgIGxldCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBkYXRlID1cbiAgICAgICAgICAgIHRvZGF5LmdldEZ1bGxZZWFyKCkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZCh0b2RheS5nZXRNb250aCgpICsgMSkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZCh0b2RheS5nZXREYXRlKCkpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYmFja2xvZyA9IFtdO1xuXG4gICAgc3RhdGljIGJhY2tsb2dBZGQobXNnLCB0eXBlID0gXCJsb2dcIikge1xuICAgICAgICBpZiAobm90Q29tbW9uLmdldChcImJhY2tsb2dcIikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nLnB1c2goeyBtc2csIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZHVtcEJhY2tsb2coKSB7XG4gICAgICAgIHdoaWxlIChub3RDb21tb24uYmFja2xvZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByb3cgPSBub3RDb21tb24uYmFja2xvZy5zaGlmdCgpO1xuICAgICAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddW3Jvdy50eXBlXSguLi5yb3cubXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBsb2dNc2coKSB7XG4gICAgICAgIGxldCBub3cgPSBub3RDb21tb24ubG9jYWxJc29EYXRlKCk7XG5cbiAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddLmxvZyhgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFtgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50c10sIFwibG9nXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2coKSB7XG4gICAgICAgIG5vdENvbW1vbi5sb2dNc2coLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTG9nZ2VyKHByZWZpeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9nOiBub3RDb21tb24uZ2VuTG9nTXNnKHByZWZpeCksXG4gICAgICAgICAgICBlcnJvcjogbm90Q29tbW9uLmdlbkxvZ0Vycm9yKHByZWZpeCksXG4gICAgICAgICAgICBkZWJ1Zzogbm90Q29tbW9uLmdlbkxvZ0RlYnVnKHByZWZpeCksXG4gICAgICAgICAgICByZXBvcnQ6IG5vdENvbW1vbi5yZXBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy/Qk9C10L3QtdGA0LDRhtC40Y8g0LzQtdGC0L7QtNCwINCy0YvQstC+0LTQsCDRgdC+0L7QsdGJ0LXQvdC40Lkg0LIg0LrQvtC90YHQvtC70Ywg0YEg0YPQutCw0LfQsNC90LjQtdC8INC/0YDQtdGE0LjQutGB0LAuXG4gICAgc3RhdGljIGdlbkxvZ01zZyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vbm90IGFycm93IGJjIG9mIGFyZ3VtZW50cyBzcGVjaWFsIHZhciBpcyBub3QgYXZhaWxhYmxlIGluIGFycm93IGZ1bmN0aW9uc1xuICAgICAgICAgICAgbGV0IG5vdyA9IG5vdENvbW1vbi5sb2NhbElzb0RhdGUoKTtcblxuICAgICAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddLmxvZyhgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFxuICAgICAgICAgICAgICAgIFtgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzXSxcbiAgICAgICAgICAgICAgICBcImxvZ1wiXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqINCe0L/RgNC10LTQtdC70Y/QtdGCINGP0LLQu9GP0LXRgtGB0Y8g0LvQuCDQvtC60YDRg9C20LXQvdC40LUg0L7QutGA0YPQttC10L3QuNC10Lwg0YDQsNC30YDQsNCx0L7RgtC60LhcbiAgICAgKiBAcmV0dXJucyAge2Jvb2xlYW59IHRydWUg0LXRgdC70Lgg0Y3RgtC+INC30LDQv9GD0YnQtdC90L4g0LIg0L7QutGA0YPQttC10L3QuNC4INGA0LDQt9GA0LDQsdC+0YLQutC4XG4gICAgICoqL1xuICAgIHN0YXRpYyBpc0RldigpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5FTlZfVFlQRSA9PT0gbm90Q29tbW9uLkRFVl9FTlY7XG4gICAgfVxuXG4gICAgc3RhdGljIGRlYnVnKCkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRGV2KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24ubG9nTXNnKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLk5PT1A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2VuTG9nRGVidWcocHJlZml4KSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNEZXYoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZW5Mb2dNc2cocHJlZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24uTk9PUDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBlcnJvcigpIHtcbiAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy/QpNGD0L3QutGG0LjRjyDQstGL0LLQvtC00LAg0YHQvtC+0LHRidC10L3QuNGPINC+0LEg0L7RiNC40LHQutC1XG4gICAgc3RhdGljIGxvZ0Vycm9yKCkge1xuICAgICAgICBsZXQgbm93ID0gbm90Q29tbW9uLmxvY2FsSXNvRGF0ZSgpO1xuXG4gICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5lcnJvcihgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFtgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50c10sIFwiZXJyb3JcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGdlbkxvZ0Vycm9yKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9kbyBub3QgY2hhbmdlIHRvIGFycm93IGZ1bmN0aW9uLCBiYyBvZiBhcmd1bWVudHNcbiAgICAgICAgICAgIGxldCBub3cgPSBub3RDb21tb24ubG9jYWxJc29EYXRlKCk7XG5cbiAgICAgICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5lcnJvcihgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFxuICAgICAgICAgICAgICAgIFtgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzXSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIHJlcG9ydChlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uZ2V0QXBwKCkpIHtcbiAgICAgICAgICAgIGxldCByZXBvcnRlciA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRTZXJ2aWNlKFwibnNFcnJvclJlcG9ydGVyXCIpO1xuICAgICAgICAgICAgaWYgKHJlcG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZXIucmVwb3J0KGUpLmNhdGNoKG5vdENvbW1vbi5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5vdENvbW1vbi5nZXQoXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmVycm9yKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdHJhY2UoKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLmdldChcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi50cmFjZSguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHRyaW1CYWNrc2xhc2goc3RyKSB7XG4gICAgICAgIGlmIChzdHIuaW5kZXhPZihcIi9cIikgPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBCdWlsZHMgVVJMIHdpdGggc3RydWN0dXJlIGxpa2UgcHJlZml4L21vZHVsZS9tb2RlbC9pZC9hY3Rpb25cbiAgICAgKiBJZiBzb21lIHBhcnQgYWJzZW50IG9yIHNldCB0byBmYWxzZSBpdCB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gcmVzdWx0XG4gICAgICogIEBwYXJhbSB7b2JqZWN0fSB1cmxQYXJ0c1xuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLnByZWZpeD0nJ11cbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFt1cmxQYXJ0cy5tb2R1bGU9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMubW9kZWw9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMuaWQ9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMuYWN0aW9uPScnXVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9ICB1cmwgcGF0aFxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFVSTChcbiAgICAgICAgeyBwcmVmaXgsIG1vZHVsZSwgbW9kZWwsIGlkLCBhY3Rpb24gfSA9IHtcbiAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgIG1vZHVsZTogXCJcIixcbiAgICAgICAgICAgIG1vZGVsOiBcIlwiLFxuICAgICAgICAgICAgaWQ6IFwiXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiXCIsXG4gICAgICAgIH1cbiAgICApIHtcbiAgICAgICAgbGV0IHVybCA9IFtcIi9cIl07XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChwcmVmaXgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgICAgdXJsLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5vdENvbW1vbi50cmltQmFja3NsYXNoKG1vZHVsZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChtb2RlbCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChpZCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2goYWN0aW9uKSkpO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHVybC5maWx0ZXIoKGVsKSA9PiBlbCAhPT0gXCJcIik7XG4gICAgICAgIHJldHVybiB1cmwuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvL2csIFwiL1wiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb3dlckZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdHJMZW5ndGhDYXAoc3RyLCBNQVhfVElUTEVfTEVOR1RIID0gNTAsIFBPU1RfRklYID0gXCIuLi5cIikge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiBzdHIubGVuZ3RoID4gTUFYX1RJVExFX0xFTkdUSCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgTUFYX1RJVExFX0xFTkdUSCkgKyBQT1NUX0ZJWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZXNjYXBlSHRtbCh1bnNhZmUpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIHN0YXJ0QXBwKHN0YXJ0ZXIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgc3RhcnRlcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEFwcCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXQoXCJhcHBcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4dGVuZEFwcENvbmZpZyhjb25mLCBjb25mMikge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmRlZXBNZXJnZShjb25mLCBjb25mMik7XG4gICAgfVxuXG4gICAgc3RhdGljIGFic29yYk1vZHVsZSgpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRDb25mLCAvL2FwcCBvcHRpb25zXG4gICAgICAgICAgICBtb2QsIC8vbW9kdWxlIG9wdGlvbnNcbiAgICAgICAgICAgIHRhcmdldHMgPSB7fTsgLy92YXJpb3VzIGNvbGxlY3Rpb25zXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHRhcmdldHMgPSB7IC4uLmFyZ3VtZW50c1swXSB9O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1swXSwgXCJkZWZhdWx0Q29uZlwiKSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mID0gYXJndW1lbnRzWzBdLmRlZmF1bHRDb25mO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRzLmRlZmF1bHRDb25mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1swXSwgXCJtb2RcIikpIHtcbiAgICAgICAgICAgICAgICBtb2QgPSBhcmd1bWVudHNbMF0ubW9kO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRzLm1vZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5sb2coXG4gICAgICAgICAgICAgICAgXCJXQVJOSU5HOiBhYnNvcmJNb2R1bGUgZm9ybWF0IG9ic29sZXRlZCwgdXNlIG9iamVjdCB7ZGVmYXVsdENvbmYsIG1vZCwgc2VydmljZXMsIHVpcywgd3NjLCBldGN9XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWZhdWx0Q29uZiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIG1vZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRhcmdldHMuc2VydmljZXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnVpcyA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMud2NzID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbW9kKSB7XG4gICAgICAgICAgICAvL2FkZCBtYW5pZmVzdCB0byBvdGhlclxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibWFuaWZlc3RcIikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mID0gbm90Q29tbW9uLmV4dGVuZEFwcENvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENvbmYsXG4gICAgICAgICAgICAgICAgICAgIG1vZC5tYW5pZmVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vdENvbW1vbi5nZXQoYGFic29yYi4ke3Byb3B9YCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24odGFyZ2V0cywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFdBUk5JTkc6IG5vIGFjY2FtdWxhdG9yIG9iamVjdCBwcm92aWRlZCBmb3IgJyR7cHJvcH0nIGNvbGxlY3Rpb25gXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5nZXQoYGFic29yYi4ke3Byb3B9YCkodGFyZ2V0c1twcm9wXSwgbW9kW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5pbmRleE9mKFwibmNcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGRlZmF1bHRDb25mLCBcImNvbnRyb2xsZXJzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mLmNvbnRyb2xsZXJzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mLmNvbnRyb2xsZXJzW3Byb3BdID0gbW9kW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2luIGNhc2Ugb2Ygc29tZSBvdGhlciBzdHVmZiBwcmVzZW50ZWQsIGlzb2xhdGluZyBpdCBpbiBzcGVjaWFsIHZhclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24od2luZG93LCBcIm5vdEVudlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5ub3RFbnYgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5ub3RFbnZbcHJvcF0gPSBtb2RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25mO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZpbmVJZk5vdEV4aXN0cyhvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVnaXN0cnkgPSB7fTtcblxuICAgIHN0YXRpYyByZWdpc3RlcihrZXksIHZhbCkge1xuICAgICAgICBub3RDb21tb24ucmVnaXN0cnlba2V5XSA9IHZhbDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0KGtleSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3QuaGFzT3duKG5vdENvbW1vbi5yZWdpc3RyeSwga2V5KVxuICAgICAgICAgICAgPyBub3RDb21tb24ucmVnaXN0cnlba2V5XVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGl0ZW0gaW5zaWRlIGFycmF5IGZyb20gb2xkX2luZGV4IHRvIG5ld19pbmRleFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9sZF9pbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdfaW5kZXhcbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIG1vdmVJdGVtKGFycmF5LCBvbGRfaW5kZXgsIG5ld19pbmRleCkge1xuICAgICAgICBjb25zdCBpblJhbmdlID0gKG51bSkgPT4gbnVtIDwgYXJyYXkubGVuZ3RoICYmIG51bSA+IC0xO1xuICAgICAgICBpZiAoaW5SYW5nZShuZXdfaW5kZXgpICYmIGluUmFuZ2Uob2xkX2luZGV4KSkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKG5ld19pbmRleCwgMCwgYXJyYXkuc3BsaWNlKG9sZF9pbmRleCwgMSlbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHN0cmlwUHJveHkob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG9iai5pc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBBcnJheS5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihvYmosIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbdF0gPSBub3RDb21tb24uc3RyaXBQcm94eShvYmpbdF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIHBpcGUoZGF0YSAvKiBmZWVkIGRhdGEgKi8sIGZ1bmNzIC8qIGZ1bmN0aW9ucyBhcnJheSAqLykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBmb3IgKGxldCBmdW5jIG9mIGZ1bmNzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKHJlc3VsdCB8fCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBUEkodHlwZSkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldE1hbmFnZXIoKT8uZ2V0QVBJKHR5cGUpID8/IG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldE1hbmFnZXIodikge1xuICAgICAgICBub3RDb21tb24uTUFOQUdFUiA9IHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLk1BTkFHRVI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyB3YWl0KHNlYykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXMsIHNlYyAqIDEwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVnaXN0ZXJXaWRnZXRFdmVudHMoZXZlbnRzKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uZ2V0QXBwKCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmdldEFwcCgpLm9uKGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbmF2aWdhdGUodXJsKSB7XG4gICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKSAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLmdldEFwcCgpLmdldFdvcmtpbmcoXCJyb3V0ZXJcIikubmF2aWdhdGUodXJsKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0KHZhcmlhbnRzU2V0LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHZhcmlhbnRzU2V0ICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFyaWFudHNTZXQgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyh2YXJpYW50c1NldCwgdmFsdWUpICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFyaWFudHNTZXRbdmFsdWVdICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB2YXJpYW50c1NldFt2YWx1ZV0gIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudHNTZXRbdmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWJzb3JiU2VydmljZXModGFyZ2V0LCBzcmMpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IHNlcnYgaW4gc3JjKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0YXJnZXQsIHNlcnYpKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKGBzZXJ2aWNlcyBwcm9wZXJ0eSBkdXBsaWNhdGlvbiAke3NlcnZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbc2Vydl0gPSBzcmNbc2Vydl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZFdTQ2xpZW50KHdjcywgd3NjTmFtZSwgd3NjT3B0aW9ucykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIU9iamVjdC5oYXNPd24od2NzLCB3c2NOYW1lKSkge1xuICAgICAgICB3Y3Nbd3NjTmFtZV0gPSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uOiB7fSxcbiAgICAgICAgICAgIHJvdXRlcjoge1xuICAgICAgICAgICAgICAgIHJvdXRlczoge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2VuZ2VyOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHRhcmdldCA9IHdjc1t3c2NOYW1lXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucywgXCJyb3V0ZXJcIikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLnJvdXRlciwgXCJyb3V0ZXNcIikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdXRlVHlwZSBpbiB3c2NPcHRpb25zLnJvdXRlci5yb3V0ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldC5yb3V0ZXIucm91dGVzLCByb3V0ZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yb3V0ZXIucm91dGVzW3JvdXRlVHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQucm91dGVyLnJvdXRlc1tyb3V0ZVR5cGVdLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLndzY09wdGlvbnMucm91dGVyLnJvdXRlc1tyb3V0ZVR5cGVdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLCBcIm1lc3NlbmdlclwiKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldC5tZXNzZW5nZXIsIHsgLi4ud3NjT3B0aW9ucy5tZXNzZW5nZXIgfSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLCBcImNvbm5lY3Rpb25cIikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQuY29ubmVjdGlvbiwgeyAuLi53c2NPcHRpb25zLmNvbm5lY3Rpb24gfSk7XG4gICAgfVxuICAgIGZvciAobGV0IHQgb2YgW1wibmFtZVwiLCBcImdldFRva2VuXCIsIFwibG9nZ2VyXCIsIFwiaWRlbnRpdHlcIiwgXCJjcmVkZW50aWFsc1wiXSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHdzY09wdGlvbnMsIHQpKSB7XG4gICAgICAgICAgICB0YXJnZXRbdF0gPSB3c2NPcHRpb25zW3RdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhYnNvcmJXU0ModGFyZ2V0LCBzcmMpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IHdzQ2xpZW50TmFtZSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGV4dGVuZFdTQ2xpZW50KHRhcmdldCwgd3NDbGllbnROYW1lLCBzcmNbd3NDbGllbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFic29yYlVJcyh0YXJnZXQsIHNyYykge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgdWkgaW4gc3JjKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0YXJnZXQsIHVpKSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5sb2dFcnJvcihgdWlzIHByb3BlcnR5IGR1cGxpY2F0aW9uICR7dWl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbdWldID0gc3JjW3VpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWJzb3JiRmllbGRzKHRhcmdldCwgc3JjKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCB1aSBpbiBzcmMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRhcmdldCwgdWkpKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKGBmaWVsZHMgcHJvcGVydHkgZHVwbGljYXRpb24gJHt1aX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFt1aV0gPSBzcmNbdWldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ub3RDb21tb24ucmVnaXN0ZXIoXCJhYnNvcmIud3NjXCIsIGFic29yYldTQyk7XG5ub3RDb21tb24ucmVnaXN0ZXIoXCJhYnNvcmIuc2VydmljZXNcIiwgYWJzb3JiU2VydmljZXMpO1xubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLnVpc1wiLCBhYnNvcmJVSXMpO1xubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLnVpc1wiLCBhYnNvcmJGaWVsZHMpO1xuXG5leHBvcnQgZGVmYXVsdCBub3RDb21tb247XG4iLCIvKipcbiAqIFB1cnBvc2Ugb2YgdGhpcyBMb2NhbGUgb2JqZWN0IGlzIHRoYXQgaXQgd2lsbCBob2xkIGxpYnJhcnkgb2YgbG9jYWxpemF0aW9uXG4gKiB0ZW1wbGF0ZXMgYW5kIHByb3ZpZGUgYmFzaWMgbG9jYWxpemF0aW9uIHNlcnZpY2UgdG8gb3RoZXIgbW9kdWxlc1xuICoqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJ3b2xmeTg3LWV2ZW50ZW1pdHRlclwiO1xuXG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9mcmFtZS9jb21tb24uanNcIjtcbmltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG5pbXBvcnQgTE9DQUxFIGZyb20gXCIuL3N0b3JlXCI7XG5cbi8qKlxuICogc3RyaW5ncyBsb2NhbGl6YXRpb24gYW5kIGZvcm1hdGluZyBtb2RlbFxuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdExvY2FsZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGljdCA9IHt9OyAvL2RpY3Rpb25hcnkgb2YgcGhyYXNlc1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSB7fTsgLy9hZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgYW5kIGNvbnN0YW50c1xuICAgICAgICBsZXQgZGljdCA9IHRoaXMucmVzdG9yZUZyb21TdG9yYWdlKCk7XG4gICAgICAgIGlmIChkaWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldChkaWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmluZyBmb3JtYXQgc2hvdWxkIGNvbXBseSBub3RQYXRoIHN0YW5kYXJ0LlxuICAgICAqIHtwYXRoX3RvX2FjY2Vzc30gLSBpc1xuICAgICAqIDogLSBpcyB1c2VkIHRvIGFjY2VzcyB0byBwYXJhbXNcbiAgICAgKiA6OiAtIGlzIHVzZWQgdG8gYWNjZXNzIHRvIGhlbHBlcnNcbiAgICAgKiBXZWxjb21lLCB7OndoZXJlfSEgLSB3aWxsIHJlcGxhY2Ugezp3aGVyZX0gd2l0aCBjb250ZW50IG9mIHBhcmFtcy53aGVyZVxuICAgICAqIFdlbGNvbWUsIHs6OndoZXJlfSEgLSB3aWxsIHJlcGxhY2Ugezp3aGVyZX0gd2l0aCBjb250ZW50IG9mIHRoaXMuaGVscGVycy53aGVyZVxuICAgICAqICgpIC0gYWZ0ZXIgcGF0aCBpcyB0byBpbnZva2UgZnVuY3Rpb24gb2YgdGFyZ2V0IG9iamVjdFxuICAgICAqIFdlbGNvbWUsIHs6OndoZXJlKCl9ISAtIHdpbGwgdHJ5IHRvIGV4ZWMgdGhpcy5oZWxwZXJzLndoZXJlKHBhcmFtcywgdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSAgICB7c3RyaW5nfSAgc3RyICAgICAgICAgbG9jYWxpemVkIHN0cmluZyB0ZW1wbGF0ZSB3aXRoIG1hcmsgdG8gaW5jbHVkZSBkYXRhXG4gICAgICogQHBhcmFtICAgIHtvYmplY3R9ICBwYXJhbXMgICAgICBwYXJhbXMgdG8gdXNlIGluIHN0cmluZ1xuICAgICAqIEByZXR1cm5zICB7c3RyaW5nfSAgICAgICAgICAgICAgbG9jYWxpemVkIHZlcnNpb24gb2Ygc3RyaW5nIHdpdGhcbiAgICAgKi9cbiAgICBmb3JtYXQoc3RyLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5vdFBhdGgucGFyc2VTdWJzKHN0ciwgcGFyYW1zLCB0aGlzLmhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBsb2NhbGl6ZWQgdmVyc2lvbiBvZiBzdHJpbmcgd2l0aCBpbmplY3RlZCBkYXRhIGZyb20gcHJvdmlkZWQgb2JqZWN0XG4gICAgICogbWF5IGFsc28gdXNlIExvY2FsZS5oZWxwZXJzIGFzIHNvdXJjZSBvZiBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgcGhyYXNlICAgIG5hbWUgb2Ygc3RyaW5nIHRvIGxvY2FsaXplXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgcGFyYW1zICAgIG9iamVjdCB3aXRoIGRhdGEgdG8gaW5qZWN0IGluIHBocmFzZSB0ZW1wbGF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBsb2NhbGl6ZWQgc3RyaW5nIHdpdGggaW5qZWN0ZWQgZGF0YVxuICAgICAqL1xuICAgIHNheShwaHJhc2UsIHBhcmFtcyA9IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLmRpY3QsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wbCA9IHRoaXMuZGljdFtwaHJhc2VdLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXQodG1wbCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0bXBsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9jYWxlIHBocmFzZTogJHtwaHJhc2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5kZWJ1ZyhlKTtcbiAgICAgICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIG5ldyBkaWN0aW9uYXJ5LiB0cmlnZ2VycyBldmVudCAnY2hhbmdlJ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgZGljdCAgICAgIHZvY2FidWxhcnkgb2YgcGhyYXNlcyBhbmQgdGVtcGxhdGVzXG4gICAgICoqL1xuICAgIHNldChkaWN0KSB7XG4gICAgICAgIExPQ0FMRS5zZXQoZGljdCk7XG4gICAgICAgIHRoaXMuc2F2ZVRvU3RvcmFnZShkaWN0KTtcbiAgICAgICAgdGhpcy5kaWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgeyAuLi5kaWN0IH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gICAgfVxuXG4gICAgc2F2ZVRvU3RvcmFnZShkaWN0KSB7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiZGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkaWN0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmRlYnVnKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdG9yZUZyb21TdG9yYWdlKCkge1xuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgc3RyID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiZGljdGlvbmFyeVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWN0ID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGljdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5kZWJ1ZyhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd3JpdGFibGUgc3RvcmUgb2YgcGhyYXNlc1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gIHdyaXRhYmxlIHN0b3JlXG4gICAgICovXG4gICAgdm9jYWJ1bGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIExPQ0FMRTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBub3RMb2NhbGUoKTtcbiIsImltcG9ydCBMT0NBTEUgZnJvbSBcIi4vc3RvcmUuanNcIjtcbmltcG9ydCBub3RMb2NhbGUgZnJvbSBcIi4vbm90TG9jYWxlLmpzXCI7XG5jb25zdCBzYXkgPSBub3RMb2NhbGUuc2F5LmJpbmQobm90TG9jYWxlKTtcblxuZXhwb3J0IHsgTE9DQUxFLCBzYXksIG5vdExvY2FsZSB9O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkID0gXCJ0YWdJZFwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyB0YWcsIGFzIHRhZy17aWR9OntldmVudE5hbWV9LCBleC4gdGFnLXRhZ0lkOnVwZGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0aXRsZSA9IFwidGFnXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NvbG9yID0gXCJpbmZvXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxtYSBjb2xvclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaXplID0gXCJub3JtYWxcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbWEgc2l6ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtwYWRkaW5nID0gXCJub3JtYWxcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSBvZiBsZWZ0L3JpZ2h0IHBhZGRpbmdzIChzbWFsbCA9IDAuNWVtLCBub3JtYWwgPSAxZW0sIGJpZyA9IDEuNWVtLCBsYXJnZSA9IDJlbSksIGNsYXNzIG5hbWVzIGlzIGlzLXBhZGRlZC17cGFkZGluZ31cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbYm9sZCA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSBzdHlsaW5nXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JpZ2h0ID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSByaWdodCwgdG8gc2VlIGF0IHdvcmsgbG9vayBleGFtcGxlcyBvZiBFbGVtZW50cy5JY29ucy5VSUljb25CdXR0b25XaXRoVGFnXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xlZnQgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSBsZWZ0LCB0byBzZWUgYXQgd29yayBsb29rIGV4YW1wbGVzIG9mIEVsZW1lbnRzLkljb25zLlVJSWNvbkJ1dHRvbldpdGhUYWdcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbdG9wID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgcG9zaXRpb25pbmcgb24gdGhlIHRvcCwgdG8gc2VlIGF0IHdvcmsgbG9vayBleGFtcGxlcyBvZiBFbGVtZW50cy5JY29ucy5VSUljb25CdXR0b25XaXRoVGFnXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2JvdHRvbSA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSBib3R0b20sIHRvIHNlZSBhdCB3b3JrIGxvb2sgZXhhbXBsZXMgb2YgRWxlbWVudHMuSWNvbnMuVUlJY29uQnV0dG9uV2l0aFRhZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzcyAgPSBcIlwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbCBjc3MgY2xhc3NlcyBsaXN0XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2V2ZW50cyA9IHt9XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCBvZiBldmVudHMge25hbWU6Y2FsbGJhY2t9XG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3JlZ2lzdGVyID0gbm90Q29tbW9uLnJlZ2lzdGVyV2lkZ2V0RXZlbnRzXSAgICAgcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25VcGRhdGUgPSAoZGF0YSkgPT4gdGl0bGUgPSBkYXRhLnRpdGxlO11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbYWN0aW9uXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrL29ua2V5ZG93biBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFt2YXJzID0ge31dICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcyB2YXJzIGxpc3RcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInRhZ0lkXCIsXG4gICAgICAgIHRpdGxlID0gXCJ0YWdcIixcbiAgICAgICAgY29sb3IgPSBcImluZm9cIixcbiAgICAgICAgc2l6ZSA9IFwibm9ybWFsXCIsXG4gICAgICAgIHBhZGRpbmcgPSBcIm5vcm1hbFwiLFxuICAgICAgICBib2xkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxlZnQgPSBmYWxzZSxcbiAgICAgICAgdG9wID0gZmFsc2UsXG4gICAgICAgIGJvdHRvbSA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGV2ZW50cyA9IHt9LFxuICAgICAgICByZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50cy5iaW5kKG5vdENvbW1vbiksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwidGl0bGVcIikpIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgdmFycyA9IHt9LFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSBcIjBcIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgc2lkZWQgPSAkZGVyaXZlZChyaWdodCB8fCBsZWZ0IHx8IHRvcCB8fCBib3R0b20pO1xuXG4gICAgbGV0IGhDZW50ZXJlZCA9ICRkZXJpdmVkKCFyaWdodCAmJiAhbGVmdCAmJiBzaWRlZCk7XG4gICAgbGV0IHZDZW50ZXJlZCA9ICRkZXJpdmVkKCFib3R0b20gJiYgIXRvcCAmJiBzaWRlZCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGB0YWctJHtpZH06dXBkYXRlYDtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGV2ZW50cywgZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpXSA9IG9uVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyKGV2ZW50cyk7XG4gICAgfSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3R5bGUgPSBPYmplY3Qua2V5cygkc3RhdGUuc25hcHNob3QodmFycykpXG4gICAgICAgICAgICAubWFwKCh2YXJOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3Zhck5hbWV9OiAke3ZhcnNbdmFyTmFtZV19O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiB0aXRsZX1cbiAgICA8c3BhblxuICAgICAgICB7cm9sZX1cbiAgICAgICAge3RhYkluZGV4fVxuICAgICAgICBvbmtleWRvd249e2FjdGlvbiA/IGFjdGlvbiA6IHVuZGVmaW5lZH1cbiAgICAgICAgb25jbGljaz17YWN0aW9uID8gYWN0aW9uIDogdW5kZWZpbmVkfVxuICAgICAgICBpZD1cInRhZy17aWR9XCJcbiAgICAgICAgY2xhc3M9XCJcbiAgdGFnXG4gIHtwYWRkaW5nICE9PSAnbm9ybWFsJyA/IGBpcy1wYWRkZWQtJHtwYWRkaW5nfWAgOiAnJ31cbiAgaXMte3NpemV9XG4gIGlzLXtjb2xvcn0gIFxuICB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jbGlja2FibGU9e2FjdGlvbn1cbiAgICAgICAgY2xhc3M6aGFzLXRleHQtd2VpZ2h0LWJvbGQ9e2JvbGR9XG4gICAgICAgIGNsYXNzOmlzLXZlcnRpY2FsLWNlbnRlcmVkPXt2Q2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLWhvcml6b250YWwtY2VudGVyZWQ9e2hDZW50ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtc2lkZWQ9e3NpZGVkfVxuICAgICAgICBjbGFzczppcy1zaWRlZC1yaWdodD17cmlnaHR9XG4gICAgICAgIGNsYXNzOmlzLXNpZGVkLWxlZnQ9e2xlZnR9XG4gICAgICAgIGNsYXNzOmlzLXNpZGVkLXRvcD17dG9wfVxuICAgICAgICBjbGFzczppcy1zaWRlZC1ib3R0b209e2JvdHRvbX1cbiAgICAgICAge3N0eWxlfT57JExPQ0FMRVt0aXRsZV19PC9zcGFuXG4gICAgPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuL3VpLnRhZy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19UUlVFID0gXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19GQUxTRSA9IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZCA9IGZhbHNlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBMQ19UUlVFID0gXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCIsXG4gICAgICAgIExDX0ZBTFNFID0gXCJub3Qtbm9kZTpib29sZWFuc19mYWxzZVwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBGQUxTRV9WQUxVRSA9IHtcbiAgICAgICAgdGl0bGU6IExDX0ZBTFNFLFxuICAgICAgICBjb2xvcjogaW52ZXJ0ZWQgPyBcInN1Y2Nlc3NcIiA6IFwiZGFuZ2VyXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IFRSVUVfVkFMVUUgPSB7XG4gICAgICAgIHRpdGxlOiBMQ19UUlVFLFxuICAgICAgICBjb2xvcjogaW52ZXJ0ZWQgPyBcImRhbmdlclwiIDogXCJzdWNjZXNzXCIsXG4gICAgfTtcblxuICAgIC8vaWYgaW52ZXJ0ZWQgPT09IHRydWUsIGludmVydHMgdmFsdWVcbiAgICBsZXQgdGFnVmFsdWUgPSAkZGVyaXZlZCh2YWx1ZSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRSk7XG48L3NjcmlwdD5cblxuPFVJVGFnIHsuLi50YWdWYWx1ZX0gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4vdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHZhbHVlLCBsYWJlbCwgaW52ZXJ0ZWQgPSBmYWxzZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHNwYW4gY2xhc3M9XCJsYWJlbFwiPnskTE9DQUxFW2xhYmVsXX06IDxVSUJvb2xlYW4ge3ZhbHVlfSB7aW52ZXJ0ZWR9IC8+PC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4vdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgdmFsdWVzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2ludmVydGVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICBbY29tcG9uZW50Q29uc3RydWN0b3IgPSBVSUJvb2xlYW5dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2l0ZW1SZW5kZXJlcl0gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN1cHBsaWVkIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIGNvbXBvbmVudENvbnN0cnVjdG9yXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICBjb21wb25lbnRDb25zdHJ1Y3RvcjogSXRlbUNvbnN0cnVjdG9yID0gVUlCb29sZWFuLFxuICAgICAgICBpdGVtUmVuZGVyZXIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IF92YWx1ZXMgPSAkc3RhdGUoW10pO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgX3ZhbHVlcyA9IFt7IHZhbHVlOiB2YWx1ZXMgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmV2ZXJ5KChpdG0pID0+IHR5cGVvZiBpdG0gPT09IFwiYm9vbGVhblwiKSkge1xuICAgICAgICAgICAgICAgIF92YWx1ZXMgPSB2YWx1ZXMubWFwKChpdG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0bSB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzID0gWy4uLnZhbHVlc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG57I2lmIF92YWx1ZXMubGVuZ3RofVxuICAgIHsjZWFjaCBfdmFsdWVzIGFzIGl0ZW0sIGluZGV4fVxuICAgICAgICB7I2lmIGl0ZW1SZW5kZXJlcn1cbiAgICAgICAgICAgIHtAcmVuZGVyIGl0ZW1SZW5kZXJlcihpdGVtLCBpbmRleCl9XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxJdGVtQ29uc3RydWN0b3Igey4uLml0ZW19IGludmVydGVkPXtpbnZlcnRlZCB8fCBpdGVtLmludmVydGVkfSAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXRvb2x0aXAvZGlzdC9jc3MvYnVsbWEtdG9vbHRpcC5taW4uY3NzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtoaWRkZW4gPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtzaG93YWJsZSA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2NvcGlhYmxlID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY29weUljb24gPSAnY29weSddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Nob3dJY29uID0gJ2V5ZSddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2hpZGVJY29uID0gJ2V5ZS1zbGFzaCddXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW21heExlbmd0aCA9IDIwXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaGFkb3dDbGFzcyA9IFwiaGFzLWJhY2tncm91bmQtcHJpbWFyeS05MFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFt0b29sdGlwID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdG9vbHRpcFRUTCA9IDIwMDBdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Rvb2x0aXBUZXh0ID0gXCLQodC60L7Qv9C40YDQvtCy0LDQvdC+INCyINCx0YPRhNC10YBcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdG9vbHRpcENsYXNzID0gXCJoYXMtdG9vbHRpcC1pbmZvXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3ZhbHVlID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25lcnJvcl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaGlkZGVuID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICBzaG93YWJsZSA9IHRydWUsXG4gICAgICAgIGNvcGlhYmxlID0gdHJ1ZSxcbiAgICAgICAgY29weUljb24gPSBcImNvcHlcIixcbiAgICAgICAgc2hvd0ljb24gPSBcImV5ZVwiLFxuICAgICAgICBoaWRlSWNvbiA9IFwiZXllLXNsYXNoXCIsXG4gICAgICAgIG1heExlbmd0aCA9IDIwLFxuICAgICAgICBzaGFkb3dDbGFzcyA9IFwiaGFzLWJhY2tncm91bmQtcHJpbWFyeS05MFwiLFxuICAgICAgICB0b29sdGlwID0gdHJ1ZSxcbiAgICAgICAgdG9vbHRpcFRUTCA9IDIwMDAsXG4gICAgICAgIHRvb2x0aXBUZXh0ID0gXCLQodC60L7Qv9C40YDQvtCy0LDQvdC+INCyINCx0YPRhNC10YBcIixcbiAgICAgICAgdG9vbHRpcENsYXNzID0gXCJoYXMtdG9vbHRpcC1pbmZvXCIsXG4gICAgICAgIHZhbHVlID0gXCJcIixcbiAgICAgICAgb25lcnJvcixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVWaWV3KCkge1xuICAgICAgICBoaWRkZW4gPSAhaGlkZGVuO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50Q29waWVkID0gJHN0YXRlKGZhbHNlKSxcbiAgICAgICAgdG9vbHRpcEFjdGl2ZSA9ICRkZXJpdmVkKHRvb2x0aXAgJiYgY29udGVudENvcGllZCksXG4gICAgICAgIHRvb2x0aXBUYXJnZXQgPSAkc3RhdGUoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvcHlDb250ZW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q29waWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0b29sdGlwVGFyZ2V0LmRhdGFzZXQudG9vbHRpcCA9IHRvb2x0aXBUZXh0O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Q29waWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUYXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10b29sdGlwXCIpO1xuICAgICAgICAgICAgICAgIH0sIHRvb2x0aXBUVEwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG9uZXJyb3IgJiYgb25lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzcGFuXG4gICAgY2xhc3M9eyhoaWRkZW4gPyBcImlzLWNlbnNvcmVkIFwiICsgc2hhZG93Q2xhc3MgOiBcIlwiKSArXG4gICAgICAgIFwiIGlzLXZlcnRpY2FsLW1pZGRsZSBcIn1cbiAgICBzdHlsZT17YGRpc3BsYXk6aW5saW5lLWJsb2NrOyB3aWR0aDogJHttYXhMZW5ndGh9cmVtOyBoZWlnaHQ6IHZhcigtLWJ1bG1hLXNpemUtbWVkaXVtKTsgb3ZlcmZsb3cteDpoaWRkZW47YH1cbiAgICA+e2hpZGRlbiA/IFwiXCIgOiB2YWx1ZX08L3NwYW5cbj5cbnsjaWYgY29waWFibGV9XG4gICAgPHNwYW5cbiAgICAgICAgYmluZDp0aGlzPXt0b29sdGlwVGFyZ2V0fVxuICAgICAgICBvbmNsaWNrPXtjb3B5Q29udGVudH1cbiAgICAgICAgb25rZXlkb3duPXtjb3B5Q29udGVudH1cbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIGNsYXNzPXtcImljb24gaXMtc21hbGwgaXMtcmlnaHQgaXMtY2xpY2thYmxlIFwiICtcbiAgICAgICAgICAgICh0b29sdGlwQWN0aXZlID8gYCAke3Rvb2x0aXBDbGFzc30gYCA6IFwiXCIpICtcbiAgICAgICAgICAgIFwiIGlzLXZlcnRpY2FsLW1pZGRsZVwifT48aSBjbGFzcz1cImZhcyBmYS17Y29weUljb259XCI+PC9pPjwvc3BhblxuICAgID5cbnsvaWZ9XG57I2lmIHNob3dhYmxlfVxuICAgIDxzcGFuXG4gICAgICAgIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1yaWdodCBpcy1jbGlja2FibGUgaXMtdmVydGljYWwtbWlkZGxlXCJcbiAgICAgICAgb25jbGljaz17dG9nZ2xlVmlld31cbiAgICAgICAgb25rZXlkb3duPXt0b2dnbGVWaWV3fVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCI+PGkgY2xhc3M9XCJmYXMgZmEte2hpZGRlbiA/IHNob3dJY29uIDogaGlkZUljb259XCI+PC9pPjwvc3BhblxuICAgID5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZCA9IFwidGFnSWRcIl0gLSBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyBpbmRpY2F0b3JcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc3RhdGUgPSBcImxpZ2h0XCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NpemUgPSBcIm5vcm1hbFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtsYWJlbHMgPSB7YmxhY2ssIGRhcmssIGxpZ2h0LCB3aGl0ZSwgcHJpbWFyeSwgbGluaywgaW5mbywgc3VjY2Vzcywgd2FybmluZywgZGFuZ2VyfV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgPSBcIm1heC0xXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3BhZGRpbmcgPSBcIm5vcm1hbFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtib2xkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JpZ2h0ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xlZnQgPSBsZWZ0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFt0b3AgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbYm90dG9tID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW2V2ZW50cyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtyZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50c10gLSByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtvblVwZGF0ZSA9IChkYXRhKSA9PiBjdXJyZW50U3RhdGUgPSBkYXRhLnN0YXRlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwidGFnSWRcIixcbiAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSA9ICRiaW5kYWJsZShcImxpZ2h0XCIpLFxuICAgICAgICBzaXplID0gXCJub3JtYWxcIixcbiAgICAgICAgbGFiZWxzID0ge1xuICAgICAgICAgICAgYmxhY2s6IFwiYmxhY2tcIixcbiAgICAgICAgICAgIGRhcms6IFwiZGFya1wiLFxuICAgICAgICAgICAgbGlnaHQ6IFwibGlnaHRcIixcbiAgICAgICAgICAgIHdoaXRlOiBcIndoaXRlXCIsXG4gICAgICAgICAgICBwcmltYXJ5OiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGxpbms6IFwibGlua1wiLFxuICAgICAgICAgICAgaW5mbzogXCJpbmZvXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHdhcm5pbmc6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgZGFuZ2VyOiBcImRhbmdlclwiLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwibXgtMVwiLFxuICAgICAgICBwYWRkaW5nID0gXCJub3JtYWxcIixcbiAgICAgICAgYm9sZCA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgICAgICBsZWZ0ID0gZmFsc2UsXG4gICAgICAgIHRvcCA9IGZhbHNlLFxuICAgICAgICBib3R0b20gPSBmYWxzZSxcbiAgICAgICAgZXZlbnRzID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMuYmluZChub3RDb21tb24pLFxuICAgICAgICBvblVwZGF0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkYXRhLCBcInN0YXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZGF0YS5zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGBpbmRpY2F0b3ItJHtpZH06dXBkYXRlYDtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGV2ZW50cywgZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpXSA9IG9uVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyKGV2ZW50cyk7XG4gICAgfSk7XG5cbiAgICBsZXQgc2lkZWQgPSAkZGVyaXZlZChyaWdodCB8fCBsZWZ0IHx8IHRvcCB8fCBib3R0b20pO1xuPC9zY3JpcHQ+XG5cbjxzcGFuXG4gICAgY2xhc3M9XCJ0YWcgaXMte3NpemV9IHtwYWRkaW5nICE9PSAnbm9ybWFsJ1xuICAgICAgICA/IGBpcy1wYWRkZWQtJHtwYWRkaW5nfWBcbiAgICAgICAgOiAnJ30gaXMte2N1cnJlbnRTdGF0ZX0ge2NsYXNzZXN9XCJcbiAgICBjbGFzczpoYXMtdGV4dC13ZWlnaHQtYm9sZD17Ym9sZH1cbiAgICBjbGFzczppcy1zaWRlZD17c2lkZWR9XG4gICAgY2xhc3M6aXMtc2lkZWQtcmlnaHQ9e3JpZ2h0fVxuICAgIGNsYXNzOmlzLXNpZGVkLWxlZnQ9e2xlZnR9XG4gICAgY2xhc3M6aXMtc2lkZWQtdG9wPXt0b3B9XG4gICAgY2xhc3M6aXMtc2lkZWQtYm90dG9tPXtib3R0b219PntsYWJlbHNbY3VycmVudFN0YXRlXX08L3NwYW5cbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFwiYnVsbWEtcGFnZWxvYWRlclwiO1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIGltcG9ydCB7IG9uRGVzdHJveSwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8vaGlkZGVuIC0gbm8gbG9hZGVyXG4gICAgLy9jb250YWluZXIgLSBwYXJlbnQgY29udGFpbmVyIG9mIGZvcm1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xvYWRpbmcgPSBmYWxzZV0gICAgICAgc3RhdGUgaWYgZm9ybSBsb2FkaW5nXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NpemUgPSAnY29udGFpbmVyJ10gICAgKHBhZ2UsIGNvbnRhaW5lciwgaGlkZGVuKVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0aXRsZSA9ICdXYWl0aW5nLi4uJ10gIExDIHN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0dGxdICAgICAgICAgICAgICAgICAgIHRpbWUgdG8gbGl2ZSwgd2lsbCBiZSBjbG9zZWQgYWZ0ZXIgdHRsIG1zXG4gICAgICogQHByb3BlcnR5IHtzbmlwcGV0fSAgW2NoaWxkcmVuXSAgICAgICAgICAgICAgc25pcHBldHMgbWF5IGJlIHByb3ZpZGVkXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgc2l6ZSA9IFwiY29udGFpbmVyXCIsXG4gICAgICAgIHRpdGxlID0gXCJXYWl0aW5nLi4uXCIsXG4gICAgICAgIHR0bCxcbiAgICAgICAgb25yZWplY3QsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCB0dGxUaW1lcjtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAodHRsKSB7XG4gICAgICAgICAgICB0dGxUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvbnJlamVjdCgpO1xuICAgICAgICAgICAgfSwgdHRsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgaWYgKHR0bFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodHRsVGltZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBzaXplICE9PSBcImhpZGRlblwifVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9e3NpemUgPT09IFwicGFnZVwiID8gXCJwYWdlbG9hZGVyXCIgOiBcImNvbnRhaW5lcmxvYWRlclwifVxuICAgICAgICBjbGFzczppcy1hY3RpdmU9e2xvYWRpbmd9XG4gICAgPlxuICAgICAgICB7I2lmIGNoaWxkcmVufVxuICAgICAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRpdGxlXCI+eyRMT0NBTEVbdGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBsZXQgeyB2YWx1ZSwgdGl0bGUsIHNlbGVjdGVkIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48b3B0aW9uIHt2YWx1ZX0ge3NlbGVjdGVkfT57JExPQ0FMRVt0aXRsZV19PC9vcHRpb24+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlTZWxlY3RPcHRpb24gZnJvbSBcIi4vdWkuc2VsZWN0Lm9wdGlvbi5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW3ZhcmlhbnRzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXIgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtlbXB0eVZhbHVlRW5hYmxlZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSAgW2VtcHR5VmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtlbXB0eVZhbHVlVGl0bGUgPSBcIm5vLXNlbGVjdGlvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBlbXB0eVZhbHVlVGl0bGUgPSBcIm5vLXNlbGVjdGlvblwiLFxuICAgICAgICBlbXB0eVZhbHVlRW5hYmxlZCA9IHRydWUsXG4gICAgICAgIGVtcHR5VmFsdWUgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInNlbGVjdFwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgc2VsZWN0ZWRWYXJpYW50cyA9ICRzdGF0ZShbXSk7XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3RlZFZhcmlhbnRzKHZhcmlhbnQpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gdmFyaWFudC5pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT25DbGVhck1hY3JvKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gVUlDb21tb24uQ0xFQVJfTUFDUk8pIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbHJlYWR5UHJvY2Vzc2VkKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5jb21wYXJlVHdvQXJyYXlzKHZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25JbnB1dChldikge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBldi5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYWxyZWFkeVByb2Nlc3NlZChkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrT25DbGVhck1hY3JvKGRhdGEudmFsdWUpO1xuICAgICAgICBvbmNoYW5nZShkYXRhKTtcbiAgICB9XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2VsZWN0ZWRWYXJpYW50cyA9IEFycmF5LmlzQXJyYXkodmFyaWFudHMpXG4gICAgICAgICAgICA/IHZhcmlhbnRzLmZpbHRlcihmaWx0ZXJTZWxlY3RlZFZhcmlhbnRzKVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAocmVhZG9ubHkpIHJldHVybjtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGVtcHR5VmFsdWVFbmFibGVkICYmIHZhcmlhbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFyaWFudHNbMF0uaWQ7XG4gICAgICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFyaWFudHNbMF0uaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIHsjaWYgdmFsdWV9XG4gICAgICAgIHsjZWFjaCBzZWxlY3RlZFZhcmlhbnRzIGFzIHNlbGVjdGVkVmFyaWFudH1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXItMlwiPnskTE9DQUxFW3NlbGVjdGVkVmFyaWFudC50aXRsZV19PC9zcGFuPlxuICAgICAgICB7L2VhY2h9XG4gICAgezplbHNlIGlmIGVtcHR5VmFsdWVFbmFibGVkfVxuICAgICAgICA8c3BhbiBjbGFzcz1cIm1yLTJcIj57JExPQ0FMRVtlbXB0eVZhbHVlVGl0bGVdfTwvc3Bhbj5cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJzZWxlY3Qge2xvYWRpbmcgPyBgaXMtbG9hZGluZ2AgOiAnJ30ge3NpemVcbiAgICAgICAgICAgID8gYGlzLSR7c2l6ZX1gXG4gICAgICAgICAgICA6ICcnfSB7Y29sb3IgPyBgaXMtJHtjb2xvcn1gIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICBpZD1cImZvcm0tZmllbGQtc2VsZWN0LXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIG9uaW5wdXQ9e29uSW5wdXR9XG4gICAgICAgICAgICBvbmJsdXI9e29uSW5wdXR9XG4gICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHtzaXplfVxuICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgPlxuICAgICAgICAgICAgeyNpZiBlbXB0eVZhbHVlRW5hYmxlZH1cbiAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb24gdmFsdWU9e2VtcHR5VmFsdWV9IHRpdGxlPXtlbXB0eVZhbHVlVGl0bGV9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNlYWNoIHZhcmlhbnRzIGFzIHZhcmlhbnQgKHZhcmlhbnQuaWQpfVxuICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFyaWFudC5pZH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e3ZhbHVlID09IHZhcmlhbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPXt2YXJpYW50LnRpdGxlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmFpc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dGxpbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdW5kZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHlsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ljb25dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2lkZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbYWN0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgbGlnaHQgPSBmYWxzZSxcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlLFxuICAgICAgICByYWlzZWQgPSBmYWxzZSxcbiAgICAgICAgb3V0bGluZWQgPSBmYWxzZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcm91bmRlZCA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICBzdGF0ZSA9IFwiXCIsXG4gICAgICAgIHR5cGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBzdHlsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaWNvbiA9IGZhbHNlLFxuICAgICAgICBpY29uU2lkZSA9IFwicmlnaHRcIixcbiAgICAgICAgb25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIG9uY2xpY2sgJiYgb25jbGljayh7IGV2ZW50LCB2YWx1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24oZXZlbnQsIHZhbHVlKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvblxuICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAge2Rpc2FibGVkfVxuICAgIHR5cGU9e3R5cGUgPyB0eXBlIDogXCJcIn1cbiAgICB7c3R5bGV9XG4gICAgY2xhc3M9XCJcbiAgYnV0dG9uXG4gIHtjbGFzc2VzfVxuICB7c3RhdGUgPyBgaXMtJHtzdGF0ZX1gIDogJyd9XG4gIHtpbnZlcnRlZCA/IGBpcy1pbnZlcnRlZGAgOiAnJ31cbiAge291dGxpbmVkID8gYGlzLW91dGxpbmVkYCA6ICcnfVxuICB7cmFpc2VkID8gYGlzLXJhaXNlZGAgOiAnJ31cbiAge3JvdW5kZWQgPyBgaXMtcm91bmRlZGAgOiAnJ31cbiAge2xpZ2h0ID8gYGlzLWxpZ2h0YCA6ICcnfVxuICB7bG9hZGluZyA/IGBpcy1sb2FkaW5nYCA6ICcnfVxuICB7Y29sb3IgPyBgaXMtJHtjb2xvcn1gIDogJyd9XG4gIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XG4gIFwiXG4+XG4gICAgeyNpZiBjaGlsZHJlbn17QHJlbmRlciBjaGlsZHJlbigpfXs6ZWxzZSBpZiBpY29ufVxuICAgICAgICB7I2lmIGljb25TaWRlID09PSBcImxlZnRcIn1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiXG4gICAgICAgICAgICAgICAgPjxpIGNsYXNzPVwiZmFzIGZhLXtpY29ufSB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiPjwvaT48L3NwYW5cbiAgICAgICAgICAgID5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiB0aXRsZX1cbiAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW3RpdGxlXX08L3NwYW4+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgaWNvblNpZGUgPT09IFwicmlnaHRcIn1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiXG4gICAgICAgICAgICAgICAgPjxpIGNsYXNzPVwiZmFzIGZhLXtpY29ufSB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiPjwvaT48L3NwYW5cbiAgICAgICAgICAgID5cbiAgICAgICAgey9pZn1cbiAgICB7OmVsc2V9XG4gICAgICAgIHskTE9DQUxFW3RpdGxlXX1cbiAgICB7L2lmfVxuPC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthcmlhTGFiZWwgPSBcImRlbGV0ZSBidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhaXNlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdXRsaW5lZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3VuZGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHlsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBhcmlhTGFiZWwgPSBcImRlbGV0ZSBidXR0b25cIixcbiAgICAgICAgbGlnaHQgPSBmYWxzZSxcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlLFxuICAgICAgICByYWlzZWQgPSBmYWxzZSxcbiAgICAgICAgb3V0bGluZWQgPSBmYWxzZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcm91bmRlZCA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICBzdGF0ZSA9IFwiXCIsXG4gICAgICAgIGNvbG9yID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIHN0eWxlID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIG9uY2xpY2sgJiYgb25jbGljayh7IGV2ZW50LCB2YWx1ZSB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvblxuICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbH1cbiAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgIHtkaXNhYmxlZH1cbiAgICB7c3R5bGV9XG4gICAgY2xhc3M9XCJcbiAgZGVsZXRlXG4gIHtjbGFzc2VzfSAgXG4gIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XG4gIFwiXG4+PC9idXR0b24+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi91aS5idXR0b24uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXk8b2JqZWN0Pn0gW3ZhbHVlcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NlbnRlcmVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLkNvbXBvbmVudH0gW2J1dHRvbkNvbXBvbmVudCA9IFVJQnV0dG9uXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50SW5wdXRDaGFuZ2VDYWxsYmFja30gW2FjdGlvbiA9ICgpPT50cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50Q2FsbGJhY2t9IFtvbmNsaWNrID0gKCk9PnRydWVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBjZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGJ1dHRvbkNvbXBvbmVudDogU3ZlbHRlQ29tcG9uZW50ID0gVUlCdXR0b24sXG4gICAgICAgIGFjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IF92YWx1ZXMgPSAkc3RhdGUoW10pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIF92YWx1ZXMgPSB2YWx1ZXMubWFwKChpdG0pID0+IHtcbiAgICAgICAgICAgIGlmIChpc05hTihpdG0uaWQpKSB7XG4gICAgICAgICAgICAgICAgaXRtLmlkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdG07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cImJ1dHRvbnMgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIlxuICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4+XG4gICAgeyNlYWNoIF92YWx1ZXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnQge2FjdGlvbn0ge29uY2xpY2t9IHsuLi5pdGVtfSBiaW5kOnZhbHVlPXtpdGVtLnZhbHVlfSAvPlxuICAgIHsvZWFjaH1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsZWZ0XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY2VudGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbcmlnaHRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgbGVmdCA9IFtdLCBjZW50ZXIgPSBbXSwgcmlnaHQgPSBbXSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNvbHVtbnMge2NsYXNzZXN9XCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17bGVmdH0+PC9VSUJ1dHRvbnM+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17Y2VudGVyfSBjZW50ZXJlZD17dHJ1ZX0+PC9VSUJ1dHRvbnM+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17cmlnaHR9IHJpZ2h0PXt0cnVlfT48L1VJQnV0dG9ucz5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi91aS5idXR0b24uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGlnaHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWlzZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0bGluZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcm91bmRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ljb25dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2lkZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbdWlPZmZdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3VpT25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2FjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBsaWdodCA9IGZhbHNlLFxuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHJhaXNlZCA9IGZhbHNlLFxuICAgICAgICBvdXRsaW5lZCA9IGZhbHNlLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICByb3VuZGVkID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHN0YXRlOiBhY3RpdmVTdGF0ZSA9IFwiXCIsXG4gICAgICAgIHR5cGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGljb24gPSBmYWxzZSxcbiAgICAgICAgaWNvblNpZGUgPSBcInJpZ2h0XCIsXG4gICAgICAgIHVpT2ZmID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHVpT24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7fSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB7fSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHNlbGVjdGVkID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgY2hpbGRQcm9wcyA9ICRzdGF0ZSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBsaWdodCxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgcmFpc2VkLFxuICAgICAgICBvdXRsaW5lZCxcbiAgICAgICAgaW52ZXJ0ZWQsXG4gICAgICAgIHJvdW5kZWQsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMsXG4gICAgICAgIGljb24sXG4gICAgICAgIGljb25TaWRlLFxuICAgICAgICB2YWx1ZSxcbiAgICB9KTtcblxuICAgIGxldCB1aUVsZW1lbnQgPSAkc3RhdGUoKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBzZWxlY3RlZCA9IGFjdGlvbihldmVudCwgdmFsdWUsIHNlbGVjdGVkKTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgb25jbGljayh7IHZhbHVlLCBzZWxlY3RlZCB9KTtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVVJKCkge1xuICAgICAgICBpZiAodWlFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wc0NoYW5nZXMgPSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gdWlPbih2YWx1ZSwgc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgOiB1aU9mZih2YWx1ZSwgc2VsZWN0ZWQpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHNDaGFuZ2VzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFByb3BzW2tleV0gPSBwcm9wc0NoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGRQcm9wcyA9IGNoaWxkUHJvcHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RlZCAhPT0gXCJ1bmRlZmluZWRcIikgdXBkYXRlVUkoKTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48VUlCdXR0b25cbiAgICBiaW5kOnRoaXM9e3VpRWxlbWVudH1cbiAgICB7Li4uY2hpbGRQcm9wc31cbiAgICBzdGF0ZT17YWN0aXZlU3RhdGV9XG4gICAgb25jbGljaz17b25DbGlja31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlCdXR0b25Td2l0Y2ggZnJvbSBcIi4vdWkuYnV0dG9uLnN3aXRjaC5zdmVsdGVcIjtcblxuICAgIGNvbnN0IHVpcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlSXRlbVVJKGl0ZW0pIHtcbiAgICAgICAgdWlzW2l0ZW0uaWRdLnVwZGF0ZVVJKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdEFjdGlvbiA9IChldiwgdmFsdWUsIHNlbGVjdGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50T2ZTZWxlY3RlZCA9IGNvdW50U2VsZWN0ZWQoKTtcbiAgICAgICAgaWYgKGNvdW50T2ZTZWxlY3RlZCA9PT0gbWluICYmIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50T2ZTZWxlY3RlZCA9PT0gbWF4ICYmIHNlbGVjdGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhPZkN1cnJlbnQgPSBfdmFsdWVzLmZpbmRJbmRleCgoaXRtKSA9PiBpdG0udmFsdWUgPT09IHZhbHVlKTtcbiAgICAgICAgbGV0IG5ld1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIGlmIChpbmRleE9mQ3VycmVudCA+IC0xKSB7XG4gICAgICAgICAgICBuZXdTZWxlY3RlZCA9ICFuZXdTZWxlY3RlZDtcbiAgICAgICAgICAgIGNvbnN0IGNudCA9IGNvdW50U2VsZWN0ZWQoKSArIChuZXdTZWxlY3RlZCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAobWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNudCA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RVcFRvTWluKGNudCwgaW5kZXhPZkN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXgpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4IDwgY250KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VsZWN0RG93blRvTWluKGNudCwgaW5kZXhPZkN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGFkZFRvSGlzdG9yeShpbmRleE9mQ3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3U2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NlbGVjdGVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8b2JqZWN0Pn0gW3ZhbHVlc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjZW50ZXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5Db21wb25lbnR9ICAgICAgW2J1dHRvbkNvbXBvbmVudCA9IFVJQnV0dG9uU3dpdGNoXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtidXR0b25Qcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFthY3Rpb24gPSAoZXZlbnQsIHZhbHVlLCBzZWxlY3RlZCkgPT4gYm9vbGVhbl0gIGZpcmVzIG9uIGJ1dHRvbiBzd2l0Y2ggY2xpY2ssIHJldHVybnMgbmV3IHN0YXRlIG9mIHNlbGVjdGVkXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluID0gMF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21heCA9IDEwMF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGNlbnRlcmVkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgYnV0dG9uQ29tcG9uZW50ID0gVUlCdXR0b25Td2l0Y2gsXG4gICAgICAgIGJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIGFjdGlvbiA9IGRlZmF1bHRBY3Rpb24sXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIG1heCA9IDEwMCxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBzZWxlY3RIaXN0b3J5ID0gW107XG4gICAgbGV0IF92YWx1ZXMgPSAkc3RhdGUodmFsdWVzKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgICB2YWx1ZXMgPSAkc3RhdGUuc25hcHNob3QoX3ZhbHVlcyk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdmFsdWVzLmZpbHRlcigoaXRtKSA9PiBpdG0uc2VsZWN0ZWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZElkcyA9IHNlbGVjdGVkLm1hcCgoaXRtKSA9PiBpdG0uaWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gc2VsZWN0ZWRJZHMubGVuZ3RoO1xuICAgICAgICBvbmNoYW5nZSAmJlxuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZElkcyxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZENvdW50LFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdEFsbCgpIHtcbiAgICAgICAgX3ZhbHVlcy5mb3JFYWNoKChpdG0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBfdmFsdWVzW2luZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVJdGVtVUkoaXRtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGRlc2VsZWN0QWxsKCkge1xuICAgICAgICBfdmFsdWVzLmZvckVhY2goKGl0bSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIF92YWx1ZXNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB1cGRhdGVJdGVtVUkoaXRtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ291bnQgPSBjb3VudFNlbGVjdGVkKCk7XG4gICAgICAgIGlmIChtaW4gJiYgc2VsZWN0ZWRDb3VudCA8IG1pbikge1xuICAgICAgICAgICAgc2VsZWN0VXBUb01pbihzZWxlY3RlZENvdW50LCAtMSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBhZGRUb0hpc3RvcnkoaWQpIHtcbiAgICAgICAgaWYgKHNlbGVjdEhpc3RvcnkuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICBzZWxlY3RIaXN0b3J5LnNwbGljZShzZWxlY3RIaXN0b3J5LmluZGV4T2YoaWQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RIaXN0b3J5LnB1c2goaWQpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBjb3VudFNlbGVjdGVkKCkge1xuICAgICAgICBjb25zdCBjb3VudE9mU2VsZWN0ZWQgPSBfdmFsdWVzLmZpbHRlcigoYnRuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYnRuLnNlbGVjdGVkO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3VudE9mU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUZpcnN0U3VpdGVkKHRvVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBfdmFsdWVzLmZpbmRJbmRleCgoaXRtKSA9PiAhdG9WYWx1ZSA9PSBpdG0uc2VsZWN0ZWQpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgX3ZhbHVlc1tpbmRleF0uc2VsZWN0ZWQgPSB0b1ZhbHVlO1xuICAgICAgICAgICAgdXBkYXRlSXRlbVVJKF92YWx1ZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGFkZFRvSGlzdG9yeShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2VsZWN0VXBUb01pbihjbnQsIGluZGV4T2ZDdXJyZW50KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IG1pbiAtIGNudDtcbiAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgaW4gX3ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHQgPT09IGluZGV4T2ZDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV92YWx1ZXNbdF0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzW3RdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtVUkoX3ZhbHVlc1t0XSk7XG4gICAgICAgICAgICAgICAgYWRkVG9IaXN0b3J5KHQpO1xuICAgICAgICAgICAgICAgIGRlbHRhLS07XG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZGVzZWxlY3REb3duVG9NaW4oY250LCBpbmRleE9mQ3VycmVudCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjbnQgLSBtYXg7XG4gICAgICAgIGlmICghZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IGluIF92YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSBpbmRleE9mQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF92YWx1ZXNbdF0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzW3RdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbVVJKF92YWx1ZXNbdF0pO1xuICAgICAgICAgICAgICAgIGRlbHRhLS07XG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gdXBkYXRlVUkoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHVpcykuZm9yRWFjaCgoaXRlbUlkKSA9PiB7XG4gICAgICAgICAgICBpZiAodWlzW2l0ZW1JZF0pIHtcbiAgICAgICAgICAgICAgICB1aXNbaXRlbUlkXS51cGRhdGVVSSAmJiB1aXNbaXRlbUlkXS51cGRhdGVVSSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwiYnV0dG9ucyBoYXMtYWRkb25zIHtjZW50ZXJlZCA/ICdpcy1jZW50ZXJlZCcgOiAnJ30ge3JpZ2h0XG4gICAgICAgID8gJ2lzLXJpZ2h0J1xuICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuPlxuICAgIHsjZWFjaCBfdmFsdWVzIGFzIGl0ZW0sIGluZGV4IChpdGVtLmlkKX1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBidXR0b25Db21wb25lbnR9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnRcbiAgICAgICAgICAgIGJpbmQ6dGhpcz17dWlzW2l0ZW0uaWRdfVxuICAgICAgICAgICAge2FjdGlvbn1cbiAgICAgICAgICAgIHsuLi5pdGVtfVxuICAgICAgICAgICAgey4uLmJ1dHRvblByb3BzfVxuICAgICAgICAgICAge29uY2xpY2t9XG4gICAgICAgICAgICBiaW5kOnNlbGVjdGVkPXtfdmFsdWVzW2luZGV4XS5zZWxlY3RlZH1cbiAgICAgICAgICAgIG9uY2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgLz5cbiAgICB7L2VhY2h9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgbGV0IHtcbiAgICAgICAgZ3JvdXBlZCA9IGZhbHNlLFxuICAgICAgICBhZGRvbnMgPSBmYWxzZSxcbiAgICAgICAgbXVsdGlsaW5lID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJmaWVsZCB7Y2xhc3Nlc31cIlxuICAgIGNsYXNzOmhhcy1hZGRvbnM9e2FkZG9uc31cbiAgICBjbGFzczppcy1ncm91cGVkPXtncm91cGVkfVxuICAgIGNsYXNzOmlzLW11bHRpbGluZT17bXVsdGlsaW5lfVxuICAgIHsuLi5vdGhlcnN9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3M9JyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaGFzSWNvbnNMZWZ0PWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hhc0ljb25zUmlnaHQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBoYXNJY29uc0xlZnQgPSBmYWxzZSxcbiAgICAgICAgaGFzSWNvbnNSaWdodCA9IGZhbHNlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxwXG4gICAgY2xhc3M9XCJjb250cm9sIHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6aGFzLWljb25zLWxlZnQ9e2hhc0ljb25zTGVmdH1cbiAgICBjbGFzczpoYXMtaWNvbnMtcmlnaHQ9e2hhc0ljb25zUmlnaHR9XG4gICAgey4uLm90aGVyc31cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L3A+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuICAgIGltcG9ydCBVSVNlbGVjdCBmcm9tIFwiLi4vaW5wdXQvdWkuc2VsZWN0LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFVJQnV0dG9ucywgVUlCdXR0b24gfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUZpZWxkIGZyb20gXCIuLi9pbnB1dC91aS5maWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuXG4gICAgY29uc3QgREVGQVVMVF9BUElfTU9ERUxfR0VUVEVSID0gKFxuICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgIGFjdGlvbkZpbHRlcixcbiAgICAgICAgYWN0aW9uU29ydGVyLFxuICAgICAgICBhY3Rpb25QYWdlcixcbiAgICAgICAgYWN0aW9uU2VhcmNoXG4gICAgKSA9PiB7XG4gICAgICAgIHJldHVybiBub3RDb21tb25cbiAgICAgICAgICAgIC5nZXRBcHAoKVxuICAgICAgICAgICAgLmdldE1vZGVsKG1vZGVsTmFtZSlcbiAgICAgICAgICAgIC5zZXRGaWx0ZXIoYWN0aW9uRmlsdGVyKVxuICAgICAgICAgICAgLnNldFNvcnRlcihhY3Rpb25Tb3J0ZXIpXG4gICAgICAgICAgICAuc2V0UGFnZXIoYWN0aW9uUGFnZXIpXG4gICAgICAgICAgICAuc2V0U2VhcmNoKGFjdGlvblNlYXJjaCk7XG4gICAgfTtcblxuICAgIGNvbnN0IERFRkFVTFRfQVBJX1JFUVVFU1QgPSAoYXBpTW9kZWwsIGFjdGlvbk5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFwaU1vZGVsW2AkYCArIGFjdGlvbk5hbWVdKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCBvZiBzZWxlY3RlZCB2YXJpYW50XG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgW3ZhcmlhbnRzID0gW11dICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0IG9mIHZhcmlhbnRzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xvYWRlZCA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIHdlIGFscmVhZHkgbG9hZGVkIHZhcmlhbnRzIGZyb20gc2VydmVyIHZpYSBBUElcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcGxhY2Vob2xkZXIgPSBcImVtcHR5IHNlbGVjdCBpdGVtXCJdICAgICAgICAgcGxhY2Vob2xkZXIgdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbZmllbGRuYW1lID0gXCJzZWxlY3RGcm9tTW9kZWxcIl0gICAgICAgICAgICAgdGhpcyBpbnB1dCBmaWVsZG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbbW9kZWxOYW1lID0gXCJcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBJIG1vZGVsTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFthY3Rpb25OYW1lID0gXCJcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICBBUEkgYWN0aW9uTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFthY3Rpb25GaWx0ZXIgPSB7fV0gICAgICAgICAgICAgICAgICAgICAgICAgQVBJIGZpbHRlcmluZyBydWxlc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFthY3Rpb25Tb3J0ZXIgPSB7fV0gICAgICAgICAgICAgICAgICAgICAgICAgQVBJIHNvcnRpbmcgcnVsZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYWN0aW9uUGFnZXIgPSB7fV0gICAgICAgICAgICAgICAgICAgICAgICAgIEFQSSBwYWdlciBzdGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFthY3Rpb25TZWFyY2ggPSB1bmRlZmluZWRdICAgICAgICAgICAgICAgICAgQVBJIHNlYXJjaCBzdHJpbmdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbb3B0aW9uSWQgPSBcIjpfaWRcIl0gICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudCBvYmplY3QgaWQgZmllbGQgbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtvcHRpb25UaXRsZSA9IFwiOnRpdGxlXCJdICAgICAgICAgICAgICAgICAgICB2YXJpYW50IG9iamVjdCB0aXRsZSBmaWVsZCBuYW1lXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JlcXVpcmVkID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCBpcyByZXF1aXJlZFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtyZWFkb25seSA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgaXMgcmVhb25seVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtzaXplXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG93IG1hbnkgdmFyaWFudHMgd291bGQgYmUgdmlzaWJsZSBhdCBvbmNlLCBkZWZhdWx0OiAxXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3ZhbGlkID0gdHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCBpcyB2YWxpZFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbnJlamVjdCA9ICgpID0+IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgb24gcmVqZWN0IG9mIHNlbGVjdGlvbiBwcm9jZXNzXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ucmVzb2x2ZSA9ICgpID0+IHRydWVdICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayBvbiByZXNvbHZlIG9mIHNlbGVjdGlvbiBwcm9jZXNzXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uZXJyb3IgPSAoKSA9PiB0cnVlXSAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayBvbiBlcnJvclxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgbG9hZGVkID0gZmFsc2UsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJlbXB0eSBzZWxlY3QgaXRlbVwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInNlbGVjdEZyb21Nb2RlbFwiLFxuICAgICAgICBtb2RlbE5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25OYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uRmlsdGVyID0ge30sXG4gICAgICAgIGFjdGlvblNvcnRlciA9IHt9LFxuICAgICAgICBhY3Rpb25QYWdlciA9IHt9LFxuICAgICAgICBhY3Rpb25TZWFyY2ggPSB1bmRlZmluZWQsXG4gICAgICAgIGFwaU1vZGVsR2V0dGVyID0gREVGQVVMVF9BUElfTU9ERUxfR0VUVEVSLFxuICAgICAgICBhcGlSZXF1ZXN0ID0gREVGQVVMVF9BUElfUkVRVUVTVCxcbiAgICAgICAgb3B0aW9uSWQgPSBcIjpfaWRcIixcbiAgICAgICAgb3B0aW9uVGl0bGUgPSBcIjp0aXRsZVwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIG9ucmVqZWN0ID0gKCkgPT4gZmFsc2UsXG4gICAgICAgIG9ucmVzb2x2ZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB0cnVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFyZ3VtZW50c1NldFByb3ZpZGVkKCkge1xuICAgICAgICByZXR1cm4gbW9kZWxOYW1lICYmIGFjdGlvbk5hbWUgJiYgYWN0aW9uRmlsdGVyO1xuICAgIH1cblxuICAgIGxldCBkaXNhYmxlZCA9ICRkZXJpdmVkKCFsb2FkZWQpO1xuICAgIGxldCBjb21wb25lbnRTdGF0ZSA9ICRzdGF0ZShcImhpZGRlblwiKTtcbiAgICBsZXQgcmVzdWx0c0xpc3QgPSBbXTtcblxuICAgIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYXJndW1lbnRzU2V0UHJvdmlkZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGFwaU1vZGVsR2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uU29ydGVyLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25QYWdlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uU2VhcmNoXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9uZXJyb3IocmVzcG9uc2UuZXJyb3JzIHx8IFtyZXNwb25zZS5tZXNzYWdlXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNMaXN0ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhcmlhbnRzID0gcmVzdWx0c0xpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm90UGF0aC5nZXQob3B0aW9uSWQsIGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5vdFBhdGguZ2V0KG9wdGlvblRpdGxlLCBpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzb2x2ZWRWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIG9uTW9kZWxDaGFuZ2VkKHsgdmFsdWU6IHNlbGVjdGVkVmFsdWUgfSkge1xuICAgICAgICBpZiAocmVzdWx0c0xpc3QubGVuZ3RoID4gdmFyaWFudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gcmVzdWx0c0xpc3QuZmluZChcbiAgICAgICAgICAgICAgICAoaXRlbSkgPT4gbm90UGF0aC5nZXQob3B0aW9uSWQsIGl0ZW0pID09IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gaXRlbS5pZCA9PSBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IEFDVElPTlMgPSB7XG4gICAgICAgIGFkZDoge1xuICAgICAgICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgaWNvbjogXCJwbHVzXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RhdGUgPSBcInNob3dcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgIGljb246IFwiY2hlY2tcIixcbiAgICAgICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGFjdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgb25yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICRzdGF0ZS5zbmFwc2hvdChyZXNvbHZlZFZhbHVlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDoge1xuICAgICAgICAgICAgaWNvbjogXCJ4bWFya1wiLFxuICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RhdGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIG9ucmVqZWN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG48L3NjcmlwdD5cblxueyNpZiBjb21wb25lbnRTdGF0ZSA9PT0gXCJoaWRkZW5cIn1cbiAgICA8VUlCdXR0b24gey4uLkFDVElPTlMuYWRkfT48L1VJQnV0dG9uPlxuezplbHNlIGlmIGNvbXBvbmVudFN0YXRlID09IFwic2hvd1wifVxuICAgIDxVSUZpZWxkIGFkZG9ucz17dHJ1ZX0+XG4gICAgICAgIDxVSUNvbnRyb2w+XG4gICAgICAgICAgICA8VUlTZWxlY3RcbiAgICAgICAgICAgICAgICB7dmFsdWV9XG4gICAgICAgICAgICAgICAge3ZhcmlhbnRzfVxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHtzaXplfVxuICAgICAgICAgICAgICAgIHtjb2xvcn1cbiAgICAgICAgICAgICAgICB7dmFsaWR9XG4gICAgICAgICAgICAgICAgb25jaGFuZ2U9e29uTW9kZWxDaGFuZ2VkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9VSUNvbnRyb2w+XG4gICAgICAgIDxVSUNvbnRyb2w+XG4gICAgICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17W0FDVElPTlMucmVzb2x2ZSwgQUNUSU9OUy5yZWplY3RdfT48L1VJQnV0dG9ucz5cbiAgICAgICAgPC9VSUNvbnRyb2w+XG4gICAgPC9VSUZpZWxkPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGNvbnN0IERFRkFVTFRfU0VSVklDRV9HRVRURVIgPSAoc2VydmljZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFzZXJ2aWNlTmFtZSkgdGhyb3cgbmV3IEVycm9yKFwic2VydmljZU5hbWUgaXMgbm90IHNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudW1iZXJ9ICAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWNvbiA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtmaWVsZG5hbWUgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc2VydmljZU5hbWUgPSAnJ10gLSBTZXQgdGhpcywgYXMgbnNbTW9kZWxOYW1lXSwgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgaW4gbm90QXBwXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2QgPSBcIm9wZW5TZWxlY3RvclwiXSAtIFNldCB0aGlzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NlcnZpY2VMb2FkRGF0YU1ldGhvZCA9IFwibG9hZERhdGFcIl0gLSBTZXQgdGhpc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFttb2RlbERhdGEgPSBudWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtsb2FkaW5nID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3NlbGVjdGVkTW9kZWxUaXRsZUZvcm1hdHRlciA9IChkYXRhKSA9PiBkYXRhLl9pZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbc2VydmljZUdldHRlciA9IChzZXJ2aWNlTmFtZSk9Pm5vdENvbW1vbi5nZXRBcHAoKS5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbbG9hZGluZ0xhYmVsID0gXCJub3Qtbm9kZTpsb2FkaW5nX2xhYmVsXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lzRW1wdHlMYWJlbCA9IFwibm90LW5vZGU6ZmllbGRfdmFsdWVfaXNfZW1wdHlfcGxhY2Vob2xkZXJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2UgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtvcGVuU2VsZWN0b3JCdXR0b25Qcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtyZXNldEJ1dHRvblByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2VtcHR5QnV0dG9uUHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbdmFsdWVCdXR0b25Qcm9wcyA9IHt9XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICBpY29uID0gXCJzZWFyY2hcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJcIixcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgc2VydmljZU5hbWUgPSBcIlwiLFxuICAgICAgICBzZXJ2aWNlT3BlblNlbGVjdG9yTWV0aG9kID0gXCJvcGVuU2VsZWN0b3JcIixcbiAgICAgICAgc2VydmljZUxvYWREYXRhTWV0aG9kID0gXCJsb2FkRGF0YVwiLFxuICAgICAgICBtb2RlbERhdGEgPSAkYmluZGFibGUobnVsbCksXG4gICAgICAgIGxvYWRpbmcgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXIgPSAoZGF0YSkgPT4gYCR7ZGF0YS5faWR9YCxcbiAgICAgICAgc2VydmljZUdldHRlciA9IERFRkFVTFRfU0VSVklDRV9HRVRURVIsXG4gICAgICAgIGxvYWRpbmdMYWJlbCA9IFwibm90LW5vZGU6bG9hZGluZ19sYWJlbFwiLFxuICAgICAgICBpc0VtcHR5TGFiZWwgPSBcIm5vdC1ub2RlOmZpZWxkX3ZhbHVlX2lzX2VtcHR5X3BsYWNlaG9sZGVyXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb3BlblNlbGVjdG9yQnV0dG9uUHJvcHMgPSB7fSxcbiAgICAgICAgcmVzZXRCdXR0b25Qcm9wcyA9IHt9LFxuICAgICAgICBlbXB0eUJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIHZhbHVlQnV0dG9uUHJvcHMgPSB7fSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvcGVuTW9kZWxTZWFyY2hBbmRTZWxlY3QoKSB7XG4gICAgICAgIGlmICghc2VydmljZU9wZW5TZWxlY3Rvck1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VydmljZU9wZW5TZWxlY3Rvck1ldGhvZCBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSBzZXJ2aWNlR2V0dGVyKHNlcnZpY2VOYW1lKTtcbiAgICAgICAgc2VydmljZVtzZXJ2aWNlT3BlblNlbGVjdG9yTWV0aG9kXSgpXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQuX2lkO1xuICAgICAgICAgICAgICAgIG1vZGVsRGF0YSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFNlbGVjdGVkTW9kZWwoKSB7XG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBtb2RlbERhdGEgPSBudWxsO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNb2RlbERhdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIW1vZGVsRGF0YSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1vZGVsRGF0YSA9IGF3YWl0IGdldFNlcnZpY2UoKVtzZXJ2aWNlTG9hZERhdGFNZXRob2RdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBsb2FkTW9kZWxEYXRhKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBBVkFJTEFCTEVfQlVUVE9OUyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBhY3Rpb246IG9wZW5Nb2RlbFNlYXJjaEFuZFNlbGVjdCxcbiAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICBjb2xvcjogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgICAuLi5vcGVuU2VsZWN0b3JCdXR0b25Qcm9wcyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICBhY3Rpb246IHJlc2V0U2VsZWN0ZWRNb2RlbCxcbiAgICAgICAgICAgIGljb246IFwidGltZXNcIixcbiAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgLi4ucmVzZXRCdXR0b25Qcm9wcyxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZ2V0TW9kZWxCdXR0b24oKSB7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvYWRpbmdMYWJlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHJlYWRvbmx5LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG9wZW5Nb2RlbFNlYXJjaEFuZFNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkTW9kZWxUaXRsZUZvcm1hdHRlcihtb2RlbERhdGEpLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZUJ1dHRvblByb3BzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXNFbXB0eUxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAuLi5lbXB0eUJ1dHRvblByb3BzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgVklTSUJMRV9CVVRUT05TID0gJHN0YXRlKFtdKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIFZJU0lCTEVfQlVUVE9OUyA9IFtcbiAgICAgICAgICAgICAgICBnZXRNb2RlbEJ1dHRvbigpLFxuICAgICAgICAgICAgICAgIC4uLihyZWFkb25seSA/IFtdIDogQVZBSUxBQkxFX0JVVFRPTlMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZJU0lCTEVfQlVUVE9OUyA9IFtcbiAgICAgICAgICAgICAgICBnZXRNb2RlbEJ1dHRvbigpLFxuICAgICAgICAgICAgICAgIC4uLihyZWFkb25seSA/IFtdIDogW0FWQUlMQUJMRV9CVVRUT05TWzBdXSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPFVJQ29udHJvbD5cbiAgICA8VUlCdXR0b25zIHZhbHVlcz17VklTSUJMRV9CVVRUT05TfSBjbGFzcz17XCJpcy1uby1mbGV4LXdyYXBcIn0+PC9VSUJ1dHRvbnM+XG48L1VJQ29udHJvbD5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFttYXggPSAxMDBdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NvbG9yID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc2l6ZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gXCJcIl1cbiAgICAgKiovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtYXggPSAxMDAsXG4gICAgICAgIGNvbG9yID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHByb2dyZXNzXG4gICAgY2xhc3M9XCJcbiAgcHJvZ3Jlc3NcbiAge2NsYXNzZXN9XG4gIHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ31cbiAge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIlxuICAgIHt2YWx1ZX1cbiAgICB7bWF4fT57dmFsdWV9JTwvcHJvZ3Jlc3Ncbj5cbiIsIjxzY3JpcHQ+XG4gICAgY29uc3QgZGVmYXVsdEZpbHRlciA9ICh2YWx1ZSkgPT4gdmFsdWVbaWRGaWVsZE5hbWVdID09PSBpZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSAgICBpZCAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgb2YgYWN0aXZlIGl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICAgICAgICAgIFt2YWx1ZXMgPSBbXV0gICAgICAgICAgICAgICBsaXN0IG9mIGl0ZW1zXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICAgICBVSUNvbXBvbmVudCAgICAgICAgICAgICAgICAgY29tcG9uZW50IHRvIHNob3cgYWN0aXZlIGl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIGNvbXBvbmVudCAgICAgICAgICAgICAgICAgICBzbmlwcGV0IHRvIHNob3cgYWN0aXZlIGl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIFVJUGxhY2Vob2xkZXIgICAgICAgICAgICAgICBwbGFjZWhvbGRlciBpZiBhY3RpdmUgaXMgdW5zZXRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIHBsYWNlaG9sZGVyICAgICAgICAgICAgICAgICBzbmlwcGV0IHRvIHNob3cgcGxhY2Vob2xkZXJcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgICAgIFtwbGFjZWhvbGRlclByb3BzID0ge31dICAgICBwbGFjZWhvbGRlciBwcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICAgICAgW2FjdGl2ZSA9IHt9XSAgICAgICAgICAgICAgIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICAgICAgICAgIFtpZEZpZWxkTmFtZSA9IFwiX2lkXCJdICAgICAgIG5hbWUgb2YgaXRlbSBwcm9wZXJ0eSB1c2VkIGFzIGlkZW50aWZpY2F0b3JcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIFtmaWx0ZXIgPSAodmFsdWUpID0+IHZhbHVlW2lkRmllbGROYW1lXSA9PT0gaWRdIGZpbHRlcmluZyBmdW5jdGlvbiB0byBzZWxlY3QgYWN0aXZlIGl0ZW0uIGRlZmF1bHQgaXMgdG8gc2VhcmNoIGZvciBpdGVtIHdpdGggc2VsZWN0ZWQgaWRcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBhY3RpdmUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBpZEZpZWxkTmFtZSA9IFwiX2lkXCIsXG4gICAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICAgIFVJQ29tcG9uZW50LFxuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIFVJUGxhY2Vob2xkZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBwbGFjZWhvbGRlclByb3BzLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBhY3RpdmUgPVxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggJiYgdHlwZW9mIGlkICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyB2YWx1ZXMuZmluZChmaWx0ZXIgfHwgZGVmYXVsdEZpbHRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG57I2lmIGFjdGl2ZX1cbiAgICB7I2lmIGNvbXBvbmVudH1cbiAgICAgICAge0ByZW5kZXIgY29tcG9uZW50KGFjdGl2ZSl9XG4gICAgezplbHNlIGlmIFVJQ29tcG9uZW50fVxuICAgICAgICA8VUlDb21wb25lbnQgey4uLmFjdGl2ZX0gLz5cbiAgICB7L2lmfVxuezplbHNlIGlmIFVJUGxhY2Vob2xkZXJ9XG4gICAgeyNpZiBwbGFjZWhvbGRlcn1cbiAgICAgICAge0ByZW5kZXIgcGxhY2Vob2xkZXIocGxhY2Vob2xkZXJQcm9wcyl9XG4gICAgezplbHNlIGlmIFVJUGxhY2Vob2xkZXJ9XG4gICAgICAgIDxVSVBsYWNlaG9sZGVyIHsuLi5wbGFjZWhvbGRlclByb3BzfSAvPlxuICAgIHsvaWZ9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlUYWcgZnJvbSBcIi4vdWkudGFnLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWQgPSBcInRhZ2dlZFZhbHVlSWRcIl0gLSBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyB0YWdcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgW2FjdGlvbnMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbYWN0aW9uc0dyb3VwQ29udHJ1Y3RvciA9IFVJQnV0dG9uc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbYWN0aW9uc0dyb3VwUHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInRhZ2dlZFZhbHVlSWRcIixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgYWN0aW9uc0dyb3VwQ29udHJ1Y3RvcjogQWN0aW9uc0dyb3VwQ29udHJ1Y3RvciA9IFVJQnV0dG9ucyxcbiAgICAgICAgYWN0aW9uc0dyb3VwUHJvcHMgPSB7fSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInRhZ3MgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIiB7aWR9PlxuICAgIHsjaWYgdGl0bGV9PFVJVGFnIHsuLi50aXRsZX0gLz57L2lmfVxuICAgIHsjaWYgdmFsdWV9PFVJVGFnIHsuLi52YWx1ZX0gLz57L2lmfVxuPC9kaXY+XG57I2lmICFyZWFkb25seSAmJiBhY3Rpb25zICYmIGFjdGlvbnMubGVuZ3RofVxuICAgIDxBY3Rpb25zR3JvdXBDb250cnVjdG9yIHZhbHVlcz17YWN0aW9uc30gey4uLmFjdGlvbnNHcm91cFByb3BzfSAvPlxuey9pZn1cbiIsImltcG9ydCB7IGVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi9pbmRleC5qcyc7XG5cbmVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnKCk7XG4iLCIvKlxuQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbFxuRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Vhc2VzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuXHRyZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbih0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuXHRjb25zdCBhID0gNC4wIC8gMTEuMDtcblx0Y29uc3QgYiA9IDguMCAvIDExLjA7XG5cdGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuXHRjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuXHRjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG5cdGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0cmV0dXJuIHQgPCBhXG5cdFx0PyA3LjU2MjUgKiB0MlxuXHRcdDogdCA8IGJcblx0XHRcdD8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjRcblx0XHRcdDogdCA8IGNcblx0XHRcdFx0PyBjYSAqIHQyIC0gY2IgKiB0ICsgY2Ncblx0XHRcdFx0OiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKSA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcblx0cmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW4odCkge1xuXHRyZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNVxuXHRcdD8gMC41ICogTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcblx0XHQ6IDAuNSAqXG5cdFx0XHRcdE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG5cdFx0XHRcdE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcblx0XHRcdFx0MS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcblx0XHQ/IHRcblx0XHQ6IHQgPCAwLjVcblx0XHRcdD8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuXHRcdFx0OiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luKHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCA/IHQgOiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb091dCh0KSB7XG5cdHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcblx0dCAvPSAwLjU7XG5cdGlmICh0IDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0O1xuXHR0LS07XG5cdHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW4odCkge1xuXHRyZXR1cm4gdCAqIHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkT3V0KHQpIHtcblx0cmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gKzguMCAqIE1hdGgucG93KHQsIDQuMCkgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuXHRyZXR1cm4gTWF0aC5wb3codCwgNC4wKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0T3V0KHQpIHtcblx0cmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludEluT3V0KHQpIHtcblx0aWYgKCh0ICo9IDIpIDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRJbih0KSB7XG5cdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcblx0cmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcblx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lSW4odCkge1xuXHRjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuXHRpZiAoTWF0aC5hYnModikgPCAxZS0xNCkgcmV0dXJuIDE7XG5cdGVsc2UgcmV0dXJuIDEgLSB2O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZU91dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG4iLCIvKiogQGltcG9ydCB7IEZsaXBQYXJhbXMsIEFuaW1hdGlvbkNvbmZpZyB9IGZyb20gJy4vcHVibGljLmpzJyAqL1xuaW1wb3J0IHsgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXguanMnO1xuXG4vKipcbiAqIFRoZSBmbGlwIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBhbmQgYW5pbWF0ZXMgYmV0d2VlbiB0aGVtLCB0cmFuc2xhdGluZyB0aGUgeCBhbmQgeSB2YWx1ZXMuXG4gKiBgZmxpcGAgc3RhbmRzIGZvciBbRmlyc3QsIExhc3QsIEludmVydCwgUGxheV0oaHR0cHM6Ly9hZXJvdHdpc3QuY29tL2Jsb2cvZmxpcC15b3VyLWFuaW1hdGlvbnMvKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7eyBmcm9tOiBET01SZWN0OyB0bzogRE9NUmVjdCB9fSBmcm9tVG9cbiAqIEBwYXJhbSB7RmxpcFBhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxpcChub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyA9IHt9KSB7XG5cdHZhciB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAoZCkgPT4gTWF0aC5zcXJ0KGQpICogMTIwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gcGFyYW1zO1xuXG5cdHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cblx0Ly8gZmluZCB0aGUgdHJhbnNmb3JtIG9yaWdpbiwgZXhwcmVzc2VkIGFzIGEgcGFpciBvZiB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxXG5cdHZhciB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHR2YXIgW294LCBveV0gPSBzdHlsZS50cmFuc2Zvcm1PcmlnaW4uc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdCk7XG5cdG94IC89IG5vZGUuY2xpZW50V2lkdGg7XG5cdG95IC89IG5vZGUuY2xpZW50SGVpZ2h0O1xuXG5cdC8vIGNhbGN1bGF0ZSBlZmZlY3Qgb2YgcGFyZW50IHRyYW5zZm9ybXMgYW5kIHpvb21cblx0dmFyIHpvb20gPSBnZXRfem9vbShub2RlKTsgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12aWV3cG9ydC8jZWZmZWN0aXZlLXpvb21cblx0dmFyIHN4ID0gbm9kZS5jbGllbnRXaWR0aCAvIHRvLndpZHRoIC8gem9vbTtcblx0dmFyIHN5ID0gbm9kZS5jbGllbnRIZWlnaHQgLyB0by5oZWlnaHQgLyB6b29tO1xuXG5cdC8vIGZpbmQgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm0gb3JpZ2luXG5cdHZhciBmeCA9IGZyb20ubGVmdCArIGZyb20ud2lkdGggKiBveDtcblx0dmFyIGZ5ID0gZnJvbS50b3AgKyBmcm9tLmhlaWdodCAqIG95O1xuXG5cdC8vIGZpbmQgdGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgdHJhbnNmb3JtIG9yaWdpblxuXHR2YXIgdHggPSB0by5sZWZ0ICsgdG8ud2lkdGggKiBveDtcblx0dmFyIHR5ID0gdG8udG9wICsgdG8uaGVpZ2h0ICogb3k7XG5cblx0Ly8gZmluZCB0aGUgdHJhbnNsYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSB0cmFuc2Zvcm1cblx0dmFyIGR4ID0gKGZ4IC0gdHgpICogc3g7XG5cdHZhciBkeSA9IChmeSAtIHR5KSAqIHN5O1xuXG5cdC8vIGZpbmQgdGhlIHJlbGF0aXZlIHNjYWxlIGF0IHRoZSBzdGFydCBvZiB0aGUgdHJhbnNmb3JtXG5cdHZhciBkc3ggPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG5cdHZhciBkc3kgPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcblxuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uOiB0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicgPyBkdXJhdGlvbihNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKSA6IGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0LCB1KSA9PiB7XG5cdFx0XHR2YXIgeCA9IHUgKiBkeDtcblx0XHRcdHZhciB5ID0gdSAqIGR5O1xuXHRcdFx0dmFyIHN4ID0gdCArIHUgKiBkc3g7XG5cdFx0XHR2YXIgc3kgPSB0ICsgdSAqIGRzeTtcblxuXHRcdFx0cmV0dXJuIGB0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpIHNjYWxlKCR7c3h9LCAke3N5fSk7YDtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldF96b29tKGVsZW1lbnQpIHtcblx0aWYgKCdjdXJyZW50Q1NTWm9vbScgaW4gZWxlbWVudCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKGVsZW1lbnQuY3VycmVudENTU1pvb20pO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50IHwgbnVsbH0gKi9cblx0dmFyIGN1cnJlbnQgPSBlbGVtZW50O1xuXHR2YXIgem9vbSA9IDE7XG5cblx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHR6b29tICo9ICtnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnQpLnpvb207XG5cdFx0Y3VycmVudCA9IC8qKiBAdHlwZSB7RWxlbWVudCB8IG51bGx9ICovIChjdXJyZW50LnBhcmVudEVsZW1lbnQpO1xuXHR9XG5cblx0cmV0dXJuIHpvb207XG59XG4iLCIvKiogQGltcG9ydCB7IEJsdXJQYXJhbXMsIENyb3NzZmFkZVBhcmFtcywgRHJhd1BhcmFtcywgRmFkZVBhcmFtcywgRmx5UGFyYW1zLCBTY2FsZVBhcmFtcywgU2xpZGVQYXJhbXMsIFRyYW5zaXRpb25Db25maWcgfSBmcm9tICcuL3B1YmxpYycgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC93YXJuaW5ncy5qcyc7XG5cbi8qKiBAcGFyYW0ge251bWJlcn0geCAqL1xuY29uc3QgbGluZWFyID0gKHgpID0+IHg7XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdCAqL1xuZnVuY3Rpb24gY3ViaWNfb3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGN1YmljX2luX291dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gNC4wICogdCAqIHQgKiB0IDogMC41ICogTWF0aC5wb3coMi4wICogdCAtIDIuMCwgMy4wKSArIDEuMDtcbn1cblxuLyoqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1tudW1iZXIsIHN0cmluZ119XG4gKi9cbmZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG5cdGNvbnN0IHNwbGl0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCgvXlxccyooLT9bXFxkLl0rKShbXlxcc10qKVxccyokLyk7XG5cdHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSksICdweCddO1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIGEgYGJsdXJgIGZpbHRlciBhbG9uZ3NpZGUgYW4gZWxlbWVudCdzIG9wYWNpdHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0JsdXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsdXIoXG5cdG5vZGUsXG5cdHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfaW5fb3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IGYgPSBzdHlsZS5maWx0ZXIgPT09ICdub25lJyA/ICcnIDogc3R5bGUuZmlsdGVyO1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0Y29uc3QgW3ZhbHVlLCB1bml0XSA9IHNwbGl0X2Nzc191bml0KGFtb3VudCk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX07IGZpbHRlcjogJHtmfSBibHVyKCR7dSAqIHZhbHVlfSR7dW5pdH0pO2Bcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IGZyb20gMCB0byB0aGUgY3VycmVudCBvcGFjaXR5IGZvciBgaW5gIHRyYW5zaXRpb25zIGFuZCBmcm9tIHRoZSBjdXJyZW50IG9wYWNpdHkgdG8gMCBmb3IgYG91dGAgdHJhbnNpdGlvbnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0ZhZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIgfSA9IHt9KSB7XG5cdGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0KSA9PiBgb3BhY2l0eTogJHt0ICogb31gXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIHggYW5kIHkgcG9zaXRpb25zIGFuZCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50LiBgaW5gIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWVzLCBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgZWxlbWVudCdzIGRlZmF1bHQgdmFsdWVzLiBgb3V0YCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcyB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtGbHlQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZseShcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19vdXQsIHggPSAwLCB5ID0gMCwgb3BhY2l0eSA9IDAgfSA9IHt9XG4pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0Y29uc3QgW3hfdmFsdWUsIHhfdW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh4KTtcblx0Y29uc3QgW3lfdmFsdWUsIHlfdW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHhfdmFsdWV9JHt4X3VuaXR9LCAkeygxIC0gdCkgKiB5X3ZhbHVlfSR7eV91bml0fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fWBcblx0fTtcbn1cblxudmFyIHNsaWRlX3dhcm5pbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBTbGlkZXMgYW4gZWxlbWVudCBpbiBhbmQgb3V0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtTbGlkZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19vdXQsIGF4aXMgPSAneScgfSA9IHt9KSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuXHRpZiAoREVWICYmICFzbGlkZV93YXJuaW5nICYmIC8oY29udGVudHN8aW5saW5lfHRhYmxlKS8udGVzdChzdHlsZS5kaXNwbGF5KSkge1xuXHRcdHNsaWRlX3dhcm5pbmcgPSB0cnVlO1xuXHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gKHNsaWRlX3dhcm5pbmcgPSBmYWxzZSkpO1xuXHRcdHcudHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5KHN0eWxlLmRpc3BsYXkpO1xuXHR9XG5cblx0Y29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCBwcmltYXJ5X3Byb3BlcnR5ID0gYXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXHRjb25zdCBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtwcmltYXJ5X3Byb3BlcnR5XSk7XG5cdGNvbnN0IHNlY29uZGFyeV9wcm9wZXJ0aWVzID0gYXhpcyA9PT0gJ3knID8gWyd0b3AnLCAnYm90dG9tJ10gOiBbJ2xlZnQnLCAncmlnaHQnXTtcblx0Y29uc3QgY2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXMgPSBzZWNvbmRhcnlfcHJvcGVydGllcy5tYXAoXG5cdFx0KGUpID0+IC8qKiBAdHlwZSB7J0xlZnQnIHwgJ1JpZ2h0JyB8ICdUb3AnIHwgJ0JvdHRvbSd9ICovIChgJHtlWzBdLnRvVXBwZXJDYXNlKCl9JHtlLnNsaWNlKDEpfWApXG5cdCk7XG5cdGNvbnN0IHBhZGRpbmdfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG5cdGNvbnN0IHBhZGRpbmdfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuXHRjb25zdCBtYXJnaW5fc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BtYXJnaW4ke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfWBdKTtcblx0Y29uc3QgbWFyZ2luX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuXHRjb25zdCBib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KFxuXHRcdHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfVdpZHRoYF1cblx0KTtcblx0Y29uc3QgYm9yZGVyX3dpZHRoX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoXG5cdFx0c3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19V2lkdGhgXVxuXHQpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0KSA9PlxuXHRcdFx0J292ZXJmbG93OiBoaWRkZW47JyArXG5cdFx0XHRgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG5cdFx0XHRgJHtwcmltYXJ5X3Byb3BlcnR5fTogJHt0ICogcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZX1weDtgICtcblx0XHRcdGBwYWRkaW5nLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBwYWRkaW5nX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX06ICR7dCAqIHBhZGRpbmdfZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfTogJHt0ICogbWFyZ2luX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogbWFyZ2luX2VuZF92YWx1ZX1weDtgICtcblx0XHRcdGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWluLSR7cHJpbWFyeV9wcm9wZXJ0eX06IDBgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIG9wYWNpdHkgYW5kIHNjYWxlIG9mIGFuIGVsZW1lbnQuIGBpbmAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBwcm92aWRlZCB2YWx1ZXMsIHBhc3NlZCBhcyBwYXJhbWV0ZXJzLCB0byBhbiBlbGVtZW50J3MgY3VycmVudCAoZGVmYXVsdCkgdmFsdWVzLiBgb3V0YCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gYW4gZWxlbWVudCdzIGRlZmF1bHQgdmFsdWVzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge1NjYWxlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19vdXQsIHN0YXJ0ID0gMCwgb3BhY2l0eSA9IDAgfSA9IHt9XG4pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRjb25zdCBzZCA9IDEgLSBzdGFydDtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSBzZCAqIHV9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9XG5cdFx0YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBzdHJva2Ugb2YgYW4gU1ZHIGVsZW1lbnQsIGxpa2UgYSBzbmFrZSBpbiBhIHR1YmUuIGBpbmAgdHJhbnNpdGlvbnMgYmVnaW4gd2l0aCB0aGUgcGF0aCBpbnZpc2libGUgYW5kIGRyYXcgdGhlIHBhdGggdG8gdGhlIHNjcmVlbiBvdmVyIHRpbWUuIGBvdXRgIHRyYW5zaXRpb25zIHN0YXJ0IGluIGEgdmlzaWJsZSBzdGF0ZSBhbmQgZ3JhZHVhbGx5IGVyYXNlIHRoZSBwYXRoLiBgZHJhd2Agb25seSB3b3JrcyB3aXRoIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGBnZXRUb3RhbExlbmd0aGAgbWV0aG9kLCBsaWtlIGA8cGF0aD5gIGFuZCBgPHBvbHlsaW5lPmAuXG4gKlxuICogQHBhcmFtIHtTVkdFbGVtZW50ICYgeyBnZXRUb3RhbExlbmd0aCgpOiBudW1iZXIgfX0gbm9kZVxuICogQHBhcmFtIHtEcmF3UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljX2luX291dCB9ID0ge30pIHtcblx0bGV0IGxlbiA9IG5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoc3R5bGUuc3Ryb2tlTGluZWNhcCAhPT0gJ2J1dHQnKSB7XG5cdFx0bGVuICs9IHBhcnNlSW50KHN0eWxlLnN0cm9rZVdpZHRoKTtcblx0fVxuXHRpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdXJhdGlvbiA9IDgwMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF8sIHUpID0+IGBcblx0XHRcdHN0cm9rZS1kYXNoYXJyYXk6ICR7bGVufTtcblx0XHRcdHN0cm9rZS1kYXNob2Zmc2V0OiAke3UgKiBsZW59O1xuXHRcdGBcblx0fTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFNcbiAqIEBwYXJhbSB7VH0gdGFyXG4gKiBAcGFyYW0ge1N9IHNyY1xuICogQHJldHVybnMge1QgJiBTfVxuICovXG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRmb3IgKGNvbnN0IGsgaW4gc3JjKSB0YXJba10gPSBzcmNba107XG5cdHJldHVybiAvKiogQHR5cGUge1QgJiBTfSAqLyAodGFyKTtcbn1cblxuLyoqXG4gKiBUaGUgYGNyb3NzZmFkZWAgZnVuY3Rpb24gY3JlYXRlcyBhIHBhaXIgb2YgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgY2FsbGVkIGBzZW5kYCBhbmQgYHJlY2VpdmVgLiBXaGVuIGFuIGVsZW1lbnQgaXMgJ3NlbnQnLCBpdCBsb29rcyBmb3IgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgYmVpbmcgJ3JlY2VpdmVkJywgYW5kIGdlbmVyYXRlcyBhIHRyYW5zaXRpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSBlbGVtZW50IHRvIGl0cyBjb3VudGVycGFydCdzIHBvc2l0aW9uIGFuZCBmYWRlcyBpdCBvdXQuIFdoZW4gYW4gZWxlbWVudCBpcyAncmVjZWl2ZWQnLCB0aGUgcmV2ZXJzZSBoYXBwZW5zLiBJZiB0aGVyZSBpcyBubyBjb3VudGVycGFydCwgdGhlIGBmYWxsYmFja2AgdHJhbnNpdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7Q3Jvc3NmYWRlUGFyYW1zICYge1xuICogXHRmYWxsYmFjaz86IChub2RlOiBFbGVtZW50LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcywgaW50cm86IGJvb2xlYW4pID0+IFRyYW5zaXRpb25Db25maWc7XG4gKiB9fSBwYXJhbXNcbiAqIEByZXR1cm5zIHtbKG5vZGU6IGFueSwgcGFyYW1zOiBDcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBUcmFuc2l0aW9uQ29uZmlnLCAobm9kZTogYW55LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IFRyYW5zaXRpb25Db25maWddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NmYWRlKHsgZmFsbGJhY2ssIC4uLmRlZmF1bHRzIH0pIHtcblx0LyoqIEB0eXBlIHtNYXA8YW55LCBFbGVtZW50Pn0gKi9cblx0Y29uc3QgdG9fcmVjZWl2ZSA9IG5ldyBNYXAoKTtcblx0LyoqIEB0eXBlIHtNYXA8YW55LCBFbGVtZW50Pn0gKi9cblx0Y29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBmcm9tX25vZGVcblx0ICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG5cdCAqIEBwYXJhbSB7Q3Jvc3NmYWRlUGFyYW1zfSBwYXJhbXNcblx0ICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbV9ub2RlLCBub2RlLCBwYXJhbXMpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IC8qKiBAcGFyYW0ge251bWJlcn0gZCAqLyAoZCkgPT4gTWF0aC5zcXJ0KGQpICogMzAsXG5cdFx0XHRlYXNpbmcgPSBjdWJpY19vdXRcblx0XHR9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuXHRcdGNvbnN0IGZyb20gPSBmcm9tX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcblx0XHRjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuXHRcdGNvbnN0IGR3ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuXHRcdGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG5cdFx0Y29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdFx0Y29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRcdHJldHVybiB7XG5cdFx0XHRkZWxheSxcblx0XHRcdGR1cmF0aW9uOiB0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nLFxuXHRcdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0ICAgb3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHQgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcblx0XHRcdCAgIHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwke3UgKiBkeX1weCkgc2NhbGUoJHt0ICsgKDEgLSB0KSAqIGR3fSwgJHtcblx0XHRcdFx0XHRcdHQgKyAoMSAtIHQpICogZGhcblx0XHRcdFx0XHR9KTtcblx0XHQgICBgXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBpdGVtc1xuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBjb3VudGVycGFydHNcblx0ICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuXHQgKiBAcmV0dXJucyB7KG5vZGU6IGFueSwgcGFyYW1zOiBDcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBUcmFuc2l0aW9uQ29uZmlnfVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBpbXByb3ZlIHR5cGluZ3MgKGFyZSB0aGUgcHVibGljIHR5cGVzIHdyb25nPylcblx0XHRyZXR1cm4gKG5vZGUsIHBhcmFtcykgPT4ge1xuXHRcdFx0aXRlbXMuc2V0KHBhcmFtcy5rZXksIG5vZGUpO1xuXHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0aWYgKGNvdW50ZXJwYXJ0cy5oYXMocGFyYW1zLmtleSkpIHtcblx0XHRcdFx0XHRjb25zdCBvdGhlcl9ub2RlID0gY291bnRlcnBhcnRzLmdldChwYXJhbXMua2V5KTtcblx0XHRcdFx0XHRjb3VudGVycGFydHMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRcdHJldHVybiBjcm9zc2ZhZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAob3RoZXJfbm9kZSksIG5vZGUsIHBhcmFtcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcblx0XHRcdFx0Ly8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG5cdFx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cblx0XHRcdFx0aXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRyZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFt0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSwgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKV07XG59XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBmbGlwIH0gZnJvbSBcInN2ZWx0ZS9hbmltYXRlXCJcbiAgaW1wb3J0IHsgZmFkZSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiXG4gIGltcG9ydCB7YWZ0ZXJVcGRhdGV9IGZyb20gJ3N2ZWx0ZSdcblxuICAvLyB0aGUgbGlzdCBvZiBpdGVtcyAgdGhlIHVzZXIgY2FuIHNlbGVjdCBmcm9tXG4gIGV4cG9ydCBsZXQgaXRlbXMgPSBbXVxuXG4gIC8qKlxuICAgKiBmdW5jdGlvbiB0byB1c2UgdG8gZ2V0IGFsbCBpdGVtcyAoYWx0ZXJuYXRpdmUgdG8gcHJvdmlkaW5nIGl0ZW1zKVxuICAgKiBAdHlwZSB7Ym9vbGVhbnxmdW5jdGlvbn1cbiAgICovXG4gIGV4cG9ydCBsZXQgc2VhcmNoRnVuY3Rpb24gPSBmYWxzZVxuXG4gIC8vIGZpZWxkIG9mIGVhY2ggaXRlbSB0aGF0J3MgdXNlZCBmb3IgdGhlIGxhYmVscyBpbiB0aGUgbGlzdFxuICBleHBvcnQgbGV0IGxhYmVsRmllbGROYW1lID0gdW5kZWZpbmVkXG4gIGV4cG9ydCBsZXQga2V5d29yZHNGaWVsZE5hbWUgPSBsYWJlbEZpZWxkTmFtZVxuICBleHBvcnQgbGV0IHZhbHVlRmllbGROYW1lID0gdW5kZWZpbmVkXG5cbiAgZXhwb3J0IGxldCBsYWJlbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBsYWJlbEZpZWxkTmFtZSA/IGl0ZW1bbGFiZWxGaWVsZE5hbWVdIDogaXRlbVxuICB9XG5cbiAgZXhwb3J0IGxldCBrZXl3b3Jkc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBrZXl3b3Jkc0ZpZWxkTmFtZSA/IGl0ZW1ba2V5d29yZHNGaWVsZE5hbWVdIDogbGFiZWxGdW5jdGlvbihpdGVtKVxuICB9XG5cbiAgZXhwb3J0IGxldCB2YWx1ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0sIGZvcmNlU2luZ2xlID0gZmFsc2UpIHtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuICAgIGlmICghbXVsdGlwbGUgfHwgZm9yY2VTaW5nbGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZUZpZWxkTmFtZSA/IGl0ZW1bdmFsdWVGaWVsZE5hbWVdIDogaXRlbVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbS5tYXAoKGkpID0+ICh2YWx1ZUZpZWxkTmFtZSA/IGlbdmFsdWVGaWVsZE5hbWVdIDogaSkpXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0IGxldCBrZXl3b3Jkc0NsZWFuRnVuY3Rpb24gPSBmdW5jdGlvbiAoa2V5d29yZHMpIHtcbiAgICByZXR1cm4ga2V5d29yZHNcbiAgfVxuXG4gIGV4cG9ydCBsZXQgdGV4dENsZWFuRnVuY3Rpb24gPSBmdW5jdGlvbiAodXNlckVudGVyZWRUZXh0KSB7XG4gICAgcmV0dXJuIHVzZXJFbnRlcmVkVGV4dFxuICB9XG5cbiAgLy8gZXZlbnRzXG4gIGV4cG9ydCBsZXQgYmVmb3JlQ2hhbmdlID0gZnVuY3Rpb24gKG9sZFNlbGVjdGVkSXRlbSwgbmV3U2VsZWN0ZWRJdGVtKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBleHBvcnQgbGV0IG9uQ2hhbmdlID0gZnVuY3Rpb24gKG5ld1NlbGVjdGVkSXRlbSkge31cbiAgZXhwb3J0IGxldCBvbkZvY3VzID0gZnVuY3Rpb24gKCkge31cbiAgZXhwb3J0IGxldCBvbkJsdXIgPSBmdW5jdGlvbiAoKSB7fVxuICBleHBvcnQgbGV0IG9uQ3JlYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25DcmVhdGU6IFwiICsgdGV4dClcbiAgICB9XG4gIH1cblxuICAvLyBCZWhhdmlvdXIgcHJvcGVydGllc1xuICBleHBvcnQgbGV0IHNlbGVjdEZpcnN0SWZFbXB0eSA9IGZhbHNlXG4gIGV4cG9ydCBsZXQgbWluQ2hhcmFjdGVyc1RvU2VhcmNoID0gMVxuICBleHBvcnQgbGV0IG1heEl0ZW1zVG9TaG93SW5MaXN0ID0gMFxuICBleHBvcnQgbGV0IG11bHRpcGxlID0gZmFsc2VcbiAgZXhwb3J0IGxldCBjcmVhdGUgPSBmYWxzZVxuXG4gIC8vIGlnbm9yZXMgdGhlIGFjY2VudHMgd2hlbiBtYXRjaGluZyBpdGVtc1xuICBleHBvcnQgbGV0IGlnbm9yZUFjY2VudHMgPSB0cnVlXG5cbiAgLy8gYWxsIHRoZSBpbnB1dCBrZXl3b3JkcyBzaG91bGQgYmUgbWF0Y2hlZCBpbiB0aGUgaXRlbSBrZXl3b3Jkc1xuICBleHBvcnQgbGV0IG1hdGNoQWxsS2V5d29yZHMgPSB0cnVlXG5cbiAgLy8gc29ydHMgdGhlIGl0ZW1zIGJ5IHRoZSBudW1iZXIgb2YgbWF0Y2hpbmsga2V5d29yZHNcbiAgZXhwb3J0IGxldCBzb3J0QnlNYXRjaGVkS2V5d29yZHMgPSBmYWxzZVxuXG4gIC8vIGFsbG93IHVzZXJzIHRvIHVzZSBhIGN1c3RvbSBpdGVtIGZpbHRlciBmdW5jdGlvblxuICBleHBvcnQgbGV0IGl0ZW1GaWx0ZXJGdW5jdGlvbiA9IHVuZGVmaW5lZFxuXG4gIC8vIGFsbG93IHVzZXJzIHRvIHVzZSBhIGN1c3RvbSBpdGVtIHNvcnQgZnVuY3Rpb25cbiAgZXhwb3J0IGxldCBpdGVtU29ydEZ1bmN0aW9uID0gdW5kZWZpbmVkXG5cbiAgLy8gZG8gbm90IGFsbG93IHJlLXNlbGVjdGlvbiBhZnRlciBpbml0aWFsIHNlbGVjdGlvblxuICBleHBvcnQgbGV0IGxvY2sgPSBmYWxzZVxuXG4gIC8vIGRlbGF5IHRvIHdhaXQgYWZ0ZXIgYSBrZXlwcmVzcyB0byBzZWFyY2ggZm9yIG5ldyBpdGVtc1xuICBleHBvcnQgbGV0IGRlbGF5ID0gMFxuXG4gIC8vIHRydWUgdG8gcGVyZm9ybSBsb2NhbCBmaWx0ZXJpbmcgb2YgaXRlbXMsIGV2ZW4gaWYgc2VhcmNoRnVuY3Rpb24gaXMgcHJvdmlkZWRcbiAgZXhwb3J0IGxldCBsb2NhbEZpbHRlcmluZyA9IHRydWVcblxuICAvLyB0cnVlIHRvIHBlcmZvcm0gbG9jYWwgc29ydHlpbmcgb2YgaXRlbXNcbiAgZXhwb3J0IGxldCBsb2NhbFNvcnRpbmcgPSB0cnVlXG5cbiAgLy8gdHJ1ZSB0byBjbGVhbiB0aGUgdXNlciBlbnRlcmVkIHRleHQgKHJlbW92ZXMgc3BhY2VzKVxuICBleHBvcnQgbGV0IGNsZWFuVXNlclRleHQgPSB0cnVlXG5cbiAgLy8gdHJ1ZSB0byBsb3dlcmNhc2UgdGhlIGtleXdvcmRzIGRlcml2ZWQgZnJvbSBlYWNoIGl0ZW0gKGxvd2VyY2FzZSlcbiAgZXhwb3J0IGxldCBsb3dlcmNhc2VLZXl3b3JkcyA9IHRydWVcblxuICAvLyB0cnVlIHRvIGNsb3NlIHRoZSBkcm9wZG93biB3aGVuIHRoZSBjb21wb25lbnQgbG9zZXMgZm9jdXNcbiAgZXhwb3J0IGxldCBjbG9zZU9uQmx1ciA9IGZhbHNlXG5cbiAgLy8gdHJ1ZSB0byBhbGxvdyBzZWxlY3Rpb24gcmVvcmRlcmluZyBieSBkcmFnIGFuZCBkcm9wLCBuZWVkcyBtdWx0aXBsZSB0byB0cnVlXG4gIGV4cG9ydCBsZXQgb3JkZXJhYmxlU2VsZWN0aW9uID0gZmFsc2VcblxuICAvLyBVSSBwcm9wZXJ0aWVzXG5cbiAgLy8gb3B0aW9uIHRvIGhpZGUgdGhlIGRyb3Bkb3duIGFycm93XG4gIGV4cG9ydCBsZXQgaGlkZUFycm93ID0gZmFsc2VcblxuICAvLyBvcHRpb24gdG8gc2hvdyBjbGVhciBzZWxlY3Rpb24gYnV0dG9uXG4gIGV4cG9ydCBsZXQgc2hvd0NsZWFyID0gZmFsc2VcblxuICAvLyB0ZXh0IHRvIHVzZSBmb3IgY2xlYXJcbiAgZXhwb3J0IGxldCBjbGVhclRleHQgPSBcIiYjMTAwMDY7XCJcblxuICAvLyBvcHRpb24gdG8gc2hvdyBsb2FkaW5nIGluZGljYXRvciB3aGVuIHRoZSBhc3luYyBmdW5jdGlvbiBpcyBleGVjdXRlZFxuICBleHBvcnQgbGV0IHNob3dMb2FkaW5nSW5kaWNhdG9yID0gZmFsc2VcblxuICAvLyB0ZXh0IGRpc3BsYXllZCB3aGVuIG5vIGl0ZW1zIG1hdGNoIHRoZSBpbnB1dCB0ZXh0XG4gIGV4cG9ydCBsZXQgbm9SZXN1bHRzVGV4dCA9IFwiTm8gcmVzdWx0cyBmb3VuZFwiXG5cbiAgLy8gdGV4dCBkaXNwbGF5ZWQgd2hlbiBhc3luYyBkYXRhIGlzIGJlaW5nIGxvYWRlZFxuICBleHBvcnQgbGV0IGxvYWRpbmdUZXh0ID0gXCJMb2FkaW5nIHJlc3VsdHMuLi5cIlxuXG4gIC8vIHRleHQgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgdGV4dCBtYXRjaGVzIGEgbG90IG9mIGl0ZW1zIGFuZCB3ZSBjYW4gbm90IGRpc3BsYXkgdGhlbSBhbGwgaW4gdGhlIGRyb3Bkb3duXG4gIGV4cG9ydCBsZXQgbW9yZUl0ZW1zVGV4dCA9IFwiaXRlbXMgbm90IHNob3duXCJcblxuICAvLyB0ZXh0IGRpc3BsYXllZCB3aGVuIGFzeW5jIGRhdGEgaXMgYmVpbmcgbG9hZGVkXG4gIGV4cG9ydCBsZXQgY3JlYXRlVGV4dCA9IFwiTm90IGZvdW5kLCBhZGQgYW55d2F5P1wiXG5cbiAgLy8gdGhlIHRleHQgZGlzcGxheWVkIHdoZW4gbm8gb3B0aW9uIGlzIHNlbGVjdGVkXG4gIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXIgPSB1bmRlZmluZWRcblxuICAvLyBhcHBseSBhIGNsYXNzTmFtZSB0byB0aGUgY29udHJvbFxuICBleHBvcnQgbGV0IGNsYXNzTmFtZSA9IHVuZGVmaW5lZFxuXG4gIC8vIEhUTUwgaW5wdXQgVUkgcHJvcGVydGllc1xuICAvLyBhcHBseSBhIGNsYXNzTmFtZSB0byB0aGUgaW5wdXQgY29udHJvbFxuICBleHBvcnQgbGV0IGlucHV0Q2xhc3NOYW1lID0gdW5kZWZpbmVkXG4gIC8vIGFwcGx5IGEgaWQgdG8gdGhlIGlucHV0IGNvbnRyb2xcbiAgZXhwb3J0IGxldCBpbnB1dElkID0gdW5kZWZpbmVkXG4gIC8vIGdlbmVyYXRlIGFuIEhUTUwgaW5wdXQgd2l0aCB0aGlzIG5hbWVcbiAgZXhwb3J0IGxldCBuYW1lID0gdW5kZWZpbmVkXG4gIC8vIGdlbmVyYXRlIGEgPHNlbGVjdD4gdGFnIHRoYXQgaG9sZHMgdGhlIHZhbHVlXG4gIGV4cG9ydCBsZXQgc2VsZWN0TmFtZSA9IHVuZGVmaW5lZFxuICAvLyBhcHBseSBhIGlkIHRvIHRoZSA8c2VsZWN0PlxuICBleHBvcnQgbGV0IHNlbGVjdElkID0gdW5kZWZpbmVkXG4gIC8vIGFkZCB0aGUgdGl0bGUgdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZFxuICAvLyBlbmFibGUgdGhlIGh0bWw1IGF1dG9jb21wbGV0aW9uIHRvIHRoZSBIVE1MIGlucHV0XG4gIGV4cG9ydCBsZXQgaHRtbDVhdXRvY29tcGxldGUgPSB1bmRlZmluZWRcbiAgLy8gZW5hYmxlIHRoZSBodG1sNSBhdXRvY29tcGxldGlvbiB2YWx1ZVxuICBleHBvcnQgbGV0IGF1dG9jb21wbGV0ZU9mZlZhbHVlID0gXCJvZmZcIlxuICAvLyBtYWtlIHRoZSBpbnB1dCByZWFkb25seVxuICBleHBvcnQgbGV0IHJlYWRvbmx5ID0gdW5kZWZpbmVkXG4gIC8vIGFwcGx5IGEgY2xhc3NOYW1lIHRvIHRoZSBkcm9wZG93biBkaXZcbiAgZXhwb3J0IGxldCBkcm9wZG93bkNsYXNzTmFtZSA9IHVuZGVmaW5lZFxuICAvLyBhZGRzIHRoZSBkaXNhYmxlZCB0YWcgdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlXG4gIC8vIHJlbW92ZSB0aGUgYXV0b2NvbXBsZXRlLWlucHV0IGNsYXNzIG9mIHRoZSBpbnB1dFxuICBleHBvcnQgbGV0IG5vSW5wdXRTdHlsZXMgPSBmYWxzZVxuICAvLyBhZGRzIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCByZXF1aXJlZCA9IG51bGxcblxuICBleHBvcnQgbGV0IGRlYnVnID0gZmFsc2VcblxuICAvLyBhZGQgdGFiaW5kZXggc3VwcG9ydCBmb3IgdGhlIGlucHV0XG4gIC8vIHNldCBzdGFuZGFyZCB0byAwOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XG4gIGV4cG9ydCBsZXQgdGFiaW5kZXggPSAwXG5cbiAgLy8gLS0tIFB1YmxpYyBTdGF0ZSAtLS0tXG5cbiAgLy8gc2VsZWN0ZWQgaXRlbSBzdGF0ZVxuICBleHBvcnQgbGV0IHNlbGVjdGVkSXRlbSA9IG11bHRpcGxlID8gW10gOiB1bmRlZmluZWRcbiAgZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZFxuICBleHBvcnQgbGV0IGhpZ2hsaWdodGVkSXRlbSA9IHVuZGVmaW5lZFxuXG4gIC8vIC0tLSBJbnRlcm5hbCBTdGF0ZSAtLS0tXG4gIGNvbnN0IHVuaXF1ZUlkID0gXCJzYXV0b2NvbXBsZXRlLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMClcblxuICAvLyBIVE1MIGVsZW1lbnRzXG4gIGxldCBpbnB1dFxuICBsZXQgbGlzdFxuICBsZXQgaW5wdXRDb250YWluZXJcblxuICAvLyBVSSBzdGF0ZVxuICBsZXQgb3BlbmVkID0gZmFsc2VcbiAgbGV0IGxvYWRpbmcgPSBmYWxzZVxuICBsZXQgaGlnaGxpZ2h0SW5kZXggPSAtMVxuICBleHBvcnQgbGV0IHRleHQgPSB1bmRlZmluZWRcbiAgbGV0IGZpbHRlcmVkVGV4dExlbmd0aCA9IDBcblxuICAvLyB2aWV3IG1vZGVsXG4gIGxldCBmaWx0ZXJlZExpc3RJdGVtc1xuICBsZXQgbGlzdEl0ZW1zID0gW11cblxuICAvLyByZXF1ZXN0cy9yZXNwb25zZXMgY291bnRlcnNcbiAgbGV0IGxhc3RSZXF1ZXN0SWQgPSAwXG4gIGxldCBsYXN0UmVzcG9uc2VJZCA9IDBcblxuICAvLyBvdGhlciBzdGF0ZVxuICBsZXQgaW5wdXREZWxheVRpbWVvdXRcblxuICBsZXQgc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUgPSBmYWxzZTtcblxuICAvLyAtLS0gTGlmZWN5Y2xlIGV2ZW50cyAtLS1cblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYoc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUpIHtcbiAgICAgIHNldFNjcm9sbEF3YXJlTGlzdFBvc2l0aW9uKClcbiAgICB9XG4gICAgc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUgPSBmYWxzZVxuICB9KVxuXG4gIC8vIC0tLSBGdW5jdGlvbnMgLS0tXG5cbiAgZnVuY3Rpb24gc2FmZUZ1bmN0aW9uKHRoZUZ1bmN0aW9uLCBhcmd1bWVudCkge1xuICAgIGlmICh0eXBlb2YgdGhlRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5vdCBhIGZ1bmN0aW9uOiBcIiArIHRoZUZ1bmN0aW9uICsgXCIsIGFyZ3VtZW50OiBcIiArIGFyZ3VtZW50KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBsZXQgcmVzdWx0XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoZUZ1bmN0aW9uKGFyZ3VtZW50KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRXJyb3IgZXhlY3V0aW5nIEF1dG9jb21wbGV0ZSBmdW5jdGlvbiBvbiB2YWx1ZTogXCIgKyBhcmd1bWVudCArIFwiIGZ1bmN0aW9uOiBcIiArIHRoZUZ1bmN0aW9uXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVTdHJpbmdGdW5jdGlvbih0aGVGdW5jdGlvbiwgYXJndW1lbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gc2FmZUZ1bmN0aW9uKHRoZUZ1bmN0aW9uLCBhcmd1bWVudClcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgfHwgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBcIlwiXG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQudG9TdHJpbmcoKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlTGFiZWxGdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJsYWJlbEZ1bmN0aW9uOiBcIiArIGxhYmVsRnVuY3Rpb24pO1xuICAgIC8vIGNvbnNvbGUubG9nKFwic2FmZUxhYmVsRnVuY3Rpb24sIGl0ZW06IFwiICsgaXRlbSk7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdGdW5jdGlvbihsYWJlbEZ1bmN0aW9uLCBpdGVtKVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZUtleXdvcmRzRnVuY3Rpb24oaXRlbSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwic2FmZUtleXdvcmRzRnVuY3Rpb25cIik7XG4gICAgY29uc3Qga2V5d29yZHMgPSBzYWZlU3RyaW5nRnVuY3Rpb24oa2V5d29yZHNGdW5jdGlvbiwgaXRlbSlcbiAgICBsZXQgcmVzdWx0ID0gc2FmZVN0cmluZ0Z1bmN0aW9uKGtleXdvcmRzQ2xlYW5GdW5jdGlvbiwga2V5d29yZHMpXG4gICAgcmVzdWx0ID0gbG93ZXJjYXNlS2V5d29yZHMgPyByZXN1bHQudG9Mb3dlckNhc2UoKS50cmltKCkgOiByZXN1bHRcbiAgICBpZiAoaWdub3JlQWNjZW50cykge1xuICAgICAgcmVzdWx0ID0gcmVtb3ZlQWNjZW50cyhyZXN1bHQpXG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RlZCBrZXl3b3JkczogJ1wiICsgcmVzdWx0ICsgXCInIGZyb20gaXRlbTogXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3RJdGVtcygpIHtcbiAgICBsZXQgdGltZXJJZFxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgdGltZXJJZCA9IGBBdXRvY29tcGxldGUgcHJlcGFyZSBsaXN0ICR7aW5wdXRJZCA/IGAoaWQ6ICR7aW5wdXRJZH0pYCA6IFwiXCJ9YFxuICAgICAgY29uc29sZS50aW1lKHRpbWVySWQpXG4gICAgICBjb25zb2xlLmxvZyhcIlByZXBhcmUgaXRlbXMgdG8gc2VhcmNoXCIpXG4gICAgICBjb25zb2xlLmxvZyhcIml0ZW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSlcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJBdXRvY29tcGxldGUgaXRlbXMgLyBzZWFyY2ggZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYXJyYXkgYnV0XCIsIGl0ZW1zKVxuICAgICAgaXRlbXMgPSBbXVxuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aCA9IGl0ZW1zID8gaXRlbXMubGVuZ3RoIDogMFxuICAgIGxpc3RJdGVtcyA9IG5ldyBBcnJheShsZW5ndGgpXG5cbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbSA9IGdldExpc3RJdGVtKGl0ZW0pXG4gICAgICAgIGlmIChsaXN0SXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmRlZmluZWQgaXRlbSBmb3I6IFwiLCBpdGVtKVxuICAgICAgICB9XG4gICAgICAgIGxpc3RJdGVtc1tpXSA9IGxpc3RJdGVtXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGxpc3RJdGVtcy5sZW5ndGggKyBcIiBpdGVtcyB0byBzZWFyY2hcIilcbiAgICAgIGNvbnNvbGUudGltZUVuZCh0aW1lcklkKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpc3RJdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8ga2V5d29yZHMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGl0ZW1cbiAgICAgIGtleXdvcmRzOiBsb2NhbEZpbHRlcmluZyA/IHNhZmVLZXl3b3Jkc0Z1bmN0aW9uKGl0ZW0pIDogW10sXG4gICAgICAvLyBpdGVtIGxhYmVsXG4gICAgICBsYWJlbDogc2FmZUxhYmVsRnVuY3Rpb24oaXRlbSksXG4gICAgICAvLyBzdG9yZSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpYWwgaXRlbVxuICAgICAgaXRlbTogaXRlbSxcbiAgICB9XG4gIH1cblxuICAvLyAtLSBSZWFjdGl2aXR5IC0tXG4gICQ6IGl0ZW1zLCBzZWFyY2hGdW5jdGlvbiB8fCBwcmVwYXJlTGlzdEl0ZW1zKClcblxuICBmdW5jdGlvbiBvblNlbGVjdGVkSXRlbUNoYW5nZWQoKSB7XG4gICAgdmFsdWUgPSB2YWx1ZUZ1bmN0aW9uKHNlbGVjdGVkSXRlbSlcbiAgICBpZiAoc2VsZWN0ZWRJdGVtICYmICFtdWx0aXBsZSkge1xuICAgICAgdGV4dCA9IHNhZmVMYWJlbEZ1bmN0aW9uKHNlbGVjdGVkSXRlbSlcbiAgICB9XG5cbiAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgIG9uQ2hhbmdlKHNlbGVjdGVkSXRlbSlcbiAgfVxuXG4gICQ6IHNlbGVjdGVkSXRlbSwgb25TZWxlY3RlZEl0ZW1DaGFuZ2VkKClcblxuICAkOiBoaWdobGlnaHRlZEl0ZW0gPVxuICAgIGZpbHRlcmVkTGlzdEl0ZW1zICYmXG4gICAgaGlnaGxpZ2h0SW5kZXggJiZcbiAgICBoaWdobGlnaHRJbmRleCA+PSAwICYmXG4gICAgaGlnaGxpZ2h0SW5kZXggPCBmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGhcbiAgICAgID8gZmlsdGVyZWRMaXN0SXRlbXNbaGlnaGxpZ2h0SW5kZXhdLml0ZW1cbiAgICAgIDogbnVsbFxuXG4gICQ6IHNob3dMaXN0ID0gb3BlbmVkICYmICgoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkgfHwgZmlsdGVyZWRUZXh0TGVuZ3RoID4gMClcblxuICAkOiBoYXNTZWxlY3Rpb24gPVxuICAgIChtdWx0aXBsZSAmJiBzZWxlY3RlZEl0ZW0gJiYgc2VsZWN0ZWRJdGVtLmxlbmd0aCA+IDApIHx8ICghbXVsdGlwbGUgJiYgc2VsZWN0ZWRJdGVtKVxuXG4gICQ6IGNsZWFyYWJsZSA9IHNob3dDbGVhciB8fCAoKGxvY2sgfHwgbXVsdGlwbGUpICYmIGhhc1NlbGVjdGlvbilcblxuICAkOiBsb2NrZWQgPSBsb2NrICYmIGhhc1NlbGVjdGlvblxuXG4gIGZ1bmN0aW9uIHByZXBhcmVVc2VyRW50ZXJlZFRleHQodXNlckVudGVyZWRUZXh0KSB7XG4gICAgaWYgKHVzZXJFbnRlcmVkVGV4dCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJFbnRlcmVkVGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG5cbiAgICBpZiAoIWNsZWFuVXNlclRleHQpIHtcbiAgICAgIHJldHVybiB1c2VyRW50ZXJlZFRleHRcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0RmlsdGVyZWQgPSB1c2VyRW50ZXJlZFRleHQucmVwbGFjZSgvWyYvXFxcXCMsKygpJH4lLidcIjoqPzw+e31dL2csIFwiIFwiKS50cmltKClcblxuICAgIGNvbnN0IGNsZWFuVXNlckVudGVyZWRUZXh0ID0gc2FmZVN0cmluZ0Z1bmN0aW9uKHRleHRDbGVhbkZ1bmN0aW9uLCB0ZXh0RmlsdGVyZWQpXG4gICAgY29uc3QgdGV4dFRyaW1tZWQgPSBsb3dlcmNhc2VLZXl3b3Jkc1xuICAgICAgPyBjbGVhblVzZXJFbnRlcmVkVGV4dC50b0xvd2VyQ2FzZSgpLnRyaW0oKVxuICAgICAgOiBjbGVhblVzZXJFbnRlcmVkVGV4dC50cmltKClcblxuICAgIHJldHVybiB0ZXh0VHJpbW1lZFxuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyT2ZNYXRjaGVzKGxpc3RJdGVtLCBzZWFyY2hXb3Jkcykge1xuICAgIGlmICghbGlzdEl0ZW0pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgY29uc3QgaXRlbUtleXdvcmRzID0gbGlzdEl0ZW0ua2V5d29yZHNcblxuICAgIGxldCBtYXRjaGVzID0gMFxuICAgIHNlYXJjaFdvcmRzLmZvckVhY2goKHNlYXJjaFdvcmQpID0+IHtcbiAgICAgIGlmIChpdGVtS2V5d29yZHMuaW5jbHVkZXMoc2VhcmNoV29yZCkpIHtcbiAgICAgICAgbWF0Y2hlcysrXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgbGV0IHRpbWVySWRcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIHRpbWVySWQgPSBgQXV0b2NvbXBsZXRlIHNlYXJjaCAke2lucHV0SWQgPyBgKGlkOiAke2lucHV0SWR9KWAgOiBcIlwifWBcbiAgICAgIGNvbnNvbGUudGltZSh0aW1lcklkKVxuICAgICAgY29uc29sZS5sb2coXCJTZWFyY2hpbmcgdXNlciBlbnRlcmVkIHRleHQ6ICdcIiArIHRleHQgKyBcIidcIilcbiAgICB9XG5cbiAgICBsZXQgdGV4dEZpbHRlcmVkID0gcHJlcGFyZVVzZXJFbnRlcmVkVGV4dCh0ZXh0KVxuICAgIGlmIChtaW5DaGFyYWN0ZXJzVG9TZWFyY2ggPiAxICYmIHRleHRGaWx0ZXJlZC5sZW5ndGggPCBtaW5DaGFyYWN0ZXJzVG9TZWFyY2gpIHtcbiAgICAgIHRleHRGaWx0ZXJlZCA9IFwiXCJcbiAgICB9XG4gICAgZmlsdGVyZWRUZXh0TGVuZ3RoID0gdGV4dEZpbHRlcmVkLmxlbmd0aFxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNoYW5nZWQgdXNlciBlbnRlcmVkIHRleHQgJ1wiICsgdGV4dCArIFwiJyBpbnRvICdcIiArIHRleHRGaWx0ZXJlZCArIFwiJ1wiKVxuICAgIH1cblxuICAgIC8vIGlmIG5vIHNlYXJjaCB0ZXh0IGxvYWQgYWxsIGl0ZW1zXG4gICAgaWYgKHRleHRGaWx0ZXJlZCA9PT0gXCJcIikge1xuICAgICAgaWYgKHNlYXJjaEZ1bmN0aW9uKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byByZXJ1biB0aGUgc2VhcmNoXG4gICAgICAgIGl0ZW1zID0gW11cbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIGVudGVyZWQgdGV4dCBpcyBlbXB0eSBjbGVhciBsaXN0IG9mIGl0ZW1zXCIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBlbnRlcmVkIHRleHQgaXMgZW1wdHkgc2V0IHRoZSBsaXN0IG9mIGl0ZW1zIHRvIGFsbCBpdGVtc1wiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VJZk1pbkNoYXJzVG9TZWFyY2hSZWFjaGVkKCkpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS50aW1lRW5kKHRpbWVySWQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZWFyY2hGdW5jdGlvbikge1xuICAgICAgLy8gaW50ZXJuYWwgc2VhcmNoXG4gICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXh0ZXJuYWwgc2VhcmNoIHdoaWNoIHByb3ZpZGVzIGl0ZW1zXG4gICAgICBsYXN0UmVxdWVzdElkID0gbGFzdFJlcXVlc3RJZCArIDFcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0SWQgPSBsYXN0UmVxdWVzdElkXG4gICAgICBsb2FkaW5nID0gdHJ1ZVxuXG4gICAgICAvLyBzZWFyY2hGdW5jdGlvbiBpcyBhIGdlbmVyYXRvclxuICAgICAgaWYgKHNlYXJjaEZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc2VhcmNoRnVuY3Rpb24odGV4dEZpbHRlcmVkLCBtYXhJdGVtc1RvU2hvd0luTGlzdCkpIHtcbiAgICAgICAgICAvLyBhIGNodW5rIG9mIGFuIG9sZCByZXNwb25zZTogdGhyb3cgaXQgYXdheVxuICAgICAgICAgIGlmIChjdXJyZW50UmVxdWVzdElkIDwgbGFzdFJlc3BvbnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGEgY2h1bmsgZm9yIGEgbmV3IHJlc3BvbnNlOiByZXNldCB0aGUgaXRlbSBsaXN0XG4gICAgICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0SWQgPiBsYXN0UmVzcG9uc2VJZCkge1xuICAgICAgICAgICAgaXRlbXMgPSBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3RSZXNwb25zZUlkID0gY3VycmVudFJlcXVlc3RJZFxuICAgICAgICAgIGl0ZW1zID0gWy4uLml0ZW1zLCAuLi5jaHVua11cbiAgICAgICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXJlIHdhcyBub3RoaW5nIGluIHRoZSBjaHVua1xuICAgICAgICBpZiAobGFzdFJlc3BvbnNlSWQgPCBjdXJyZW50UmVxdWVzdElkKSB7XG4gICAgICAgICAgbGFzdFJlc3BvbnNlSWQgPSBjdXJyZW50UmVxdWVzdElkXG4gICAgICAgICAgaXRlbXMgPSBbXVxuICAgICAgICAgIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlYXJjaEZ1bmN0aW9uIGlzIGEgcmVndWxhciBmdW5jdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzZWFyY2hGdW5jdGlvbih0ZXh0RmlsdGVyZWQsIG1heEl0ZW1zVG9TaG93SW5MaXN0KVxuXG4gICAgICAgIC8vIElmIGEgcmVzcG9uc2UgdG8gYSBuZXdlciByZXF1ZXN0IGhhcyBiZWVuIHJlY2VpdmVkXG4gICAgICAgIC8vIHdoaWxlIHJlc3BvbnNlcyB0byB0aGlzIHJlcXVlc3Qgd2VyZSBiZWluZyBsb2FkZWQsXG4gICAgICAgIC8vIHRoZW4gd2UgY2FuIGp1c3QgdGhyb3cgYXdheSB0aGlzIG91dGRhdGVkIHJlc3VsdHMuXG4gICAgICAgIGlmIChjdXJyZW50UmVxdWVzdElkIDwgbGFzdFJlc3BvbnNlSWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RSZXNwb25zZUlkID0gY3VycmVudFJlcXVlc3RJZFxuICAgICAgICBpdGVtcyA9IHJlc3VsdFxuICAgICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICAgIH1cblxuICAgICAgbG9hZGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQodGltZXJJZClcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VhcmNoIGZvdW5kIFwiICsgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoICsgXCIgaXRlbXNcIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0SXRlbUZpbHRlckZ1bmN0aW9uKGxpc3RJdGVtLCBzZWFyY2hXb3Jkcykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBudW1iZXJPZk1hdGNoZXMobGlzdEl0ZW0sIHNlYXJjaFdvcmRzKVxuICAgIGlmIChtYXRjaEFsbEtleXdvcmRzKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyA+PSBzZWFyY2hXb3Jkcy5sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hdGNoZXMgPiAwXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEl0ZW1Tb3J0RnVuY3Rpb24ob2JqMSwgb2JqMiwgc2VhcmNoV29yZHMpIHtcbiAgICByZXR1cm4gbnVtYmVyT2ZNYXRjaGVzKG9iajIsIHNlYXJjaFdvcmRzKSAtIG51bWJlck9mTWF0Y2hlcyhvYmoxLCBzZWFyY2hXb3JkcylcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKSB7XG4gICAgLy8gY2xlYW5zLCBmaWx0ZXJzLCBvcmRlcnMsIGFuZCBoaWdobGlnaHRzIHRoZSBsaXN0IGl0ZW1zXG4gICAgcHJlcGFyZUxpc3RJdGVtcygpXG5cbiAgICBjb25zdCB0ZXh0RmlsdGVyZWRXaXRob3V0QWNjZW50cyA9IGlnbm9yZUFjY2VudHMgPyByZW1vdmVBY2NlbnRzKHRleHRGaWx0ZXJlZCkgOiB0ZXh0RmlsdGVyZWRcbiAgICBjb25zdCBzZWFyY2hXb3JkcyA9IHRleHRGaWx0ZXJlZFdpdGhvdXRBY2NlbnRzLnNwbGl0KC9cXHMrL2cpLmZpbHRlcigod29yZCkgPT4gd29yZCAhPT0gXCJcIilcblxuICAgIC8vIGxvY2FsIHNlYXJjaFxuICAgIGxldCB0ZW1wZmlsdGVyZWRMaXN0SXRlbXNcbiAgICBpZiAobG9jYWxGaWx0ZXJpbmcpIHtcbiAgICAgIGlmIChpdGVtRmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgICBpdGVtRmlsdGVyRnVuY3Rpb24oaXRlbS5pdGVtLCBzZWFyY2hXb3JkcylcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgICBkZWZhdWx0SXRlbUZpbHRlckZ1bmN0aW9uKGl0ZW0sIHNlYXJjaFdvcmRzKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhbFNvcnRpbmcpIHtcbiAgICAgICAgaWYgKGl0ZW1Tb3J0RnVuY3Rpb24pIHtcbiAgICAgICAgICB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMgPSB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMuc29ydCgoaXRlbTEsIGl0ZW0yKSA9PlxuICAgICAgICAgICAgaXRlbVNvcnRGdW5jdGlvbihpdGVtMS5pdGVtLCBpdGVtMi5pdGVtLCBzZWFyY2hXb3JkcylcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNvcnRCeU1hdGNoZWRLZXl3b3Jkcykge1xuICAgICAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gdGVtcGZpbHRlcmVkTGlzdEl0ZW1zLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT5cbiAgICAgICAgICAgICAgZGVmYXVsdEl0ZW1Tb3J0RnVuY3Rpb24oaXRlbTEsIGl0ZW0yLCBzZWFyY2hXb3JkcylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgfVxuXG4gICAgY29uc3QgaGxmaWx0ZXIgPSBoaWdobGlnaHRGaWx0ZXIoc2VhcmNoV29yZHMsIFwibGFiZWxcIilcbiAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IHRlbXBmaWx0ZXJlZExpc3RJdGVtcy5tYXAoaGxmaWx0ZXIpXG4gICAgY2xvc2VJZk1pbkNoYXJzVG9TZWFyY2hSZWFjaGVkKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gJDogdGV4dCwgc2VhcmNoKCk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXJDcmVhdGUoY3JlYXRlZEl0ZW0pIHtcbiAgICBsZXQgbGlzdEl0ZW1cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY3JlYXRlZEl0ZW1cIiwgY3JlYXRlZEl0ZW0pXG4gICAgfVxuICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY3JlYXRlZEl0ZW0pIHtcbiAgICAgIHByZXBhcmVMaXN0SXRlbXMoKVxuICAgICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICAgIGxldCBpbmRleCA9IGZpbmRJdGVtSW5kZXgoY3JlYXRlZEl0ZW0sIGZpbHRlcmVkTGlzdEl0ZW1zKVxuXG4gICAgICAvLyBpZiB0aGUgaXRlbXMgYXJyYXkgd2FzIG5vdCB1cGRhdGVkLCBhZGQgdGhlIGNyZWF0ZWQgaXRlbSBtYW51YWxseVxuICAgICAgaWYgKGluZGV4IDw9IDApIHtcbiAgICAgICAgaXRlbXMgPSBbY3JlYXRlZEl0ZW1dXG4gICAgICAgIHByZXBhcmVMaXN0SXRlbXMoKVxuICAgICAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgICAgICBpbmRleCA9IDBcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaGlnaGxpZ2h0SW5kZXggPSBpbmRleFxuICAgICAgICBsaXN0SXRlbSA9IGZpbHRlcmVkTGlzdEl0ZW1zW2hpZ2hsaWdodEluZGV4XVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdEl0ZW1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdExpc3RJdGVtKGxpc3RJdGVtKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNlbGVjdExpc3RJdGVtXCIsIGxpc3RJdGVtKVxuICAgIH1cbiAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGxpc3RJdGVtICYmIGNyZWF0ZSkge1xuICAgICAgLy8gYWxsb3cgdW5kZWZpbmVkIGl0ZW1zIGlmIGNyZWF0ZSBpcyBlbmFibGVkXG4gICAgICBjb25zdCBjcmVhdGVkSXRlbSA9IG9uQ3JlYXRlKHRleHQpXG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNyZWF0ZWRJdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlZEl0ZW0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY3JlYXRlZEl0ZW0udGhlbigobmV3SXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBuZXdJdGVtKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gYWZ0ZXJDcmVhdGUobmV3SXRlbSlcbiAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBuZXdMaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdExpc3RJdGVtKG5ld0xpc3RJdGVtKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RJdGVtID0gYWZ0ZXJDcmVhdGUoY3JlYXRlZEl0ZW0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGxpc3RJdGVtKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYGxpc3RJdGVtIGlzIHVuZGVmaW5lZC4gQ2FuIG5vdCBzZWxlY3QuYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgbmV3U2VsZWN0ZWRJdGVtID0gbGlzdEl0ZW0uaXRlbVxuICAgIGlmIChiZWZvcmVDaGFuZ2Uoc2VsZWN0ZWRJdGVtLCBuZXdTZWxlY3RlZEl0ZW0pKSB7XG4gICAgICAvLyBzaW1wbGUgc2VsZWN0aW9uXG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IHVuZGVmaW5lZCAvLyB0cmlnZ2VycyBjaGFuZ2UgZXZlbiBpZiB0aGUgdGhlIHNhbWUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICBzZWxlY3RlZEl0ZW0gPSBuZXdTZWxlY3RlZEl0ZW1cbiAgICAgIH1cbiAgICAgIC8vIGZpcnN0IHNlbGVjdGlvbiBvZiBtdWx0aXBsZSBvbmVzXG4gICAgICBlbHNlIGlmICghc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IFtuZXdTZWxlY3RlZEl0ZW1dXG4gICAgICB9XG4gICAgICAvLyBzZWxlY3Rpbmcgc29tZXRoaW5nIGFscmVhZHkgc2VsZWN0ZWQgPT4gdW5zZWxlY3QgaXRcbiAgICAgIGVsc2UgaWYgKHNlbGVjdGVkSXRlbS5pbmNsdWRlcyhuZXdTZWxlY3RlZEl0ZW0pKSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbS5maWx0ZXIoKGkpID0+IGkgIT09IG5ld1NlbGVjdGVkSXRlbSlcbiAgICAgIH1cbiAgICAgIC8vIGFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIHNlbGVjdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IFsuLi5zZWxlY3RlZEl0ZW0sIG5ld1NlbGVjdGVkSXRlbV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEl0ZW0oKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNlbGVjdEl0ZW1cIiwgaGlnaGxpZ2h0SW5kZXgpXG4gICAgfVxuICAgIGNvbnN0IGxpc3RJdGVtID0gZmlsdGVyZWRMaXN0SXRlbXNbaGlnaGxpZ2h0SW5kZXhdXG4gICAgaWYgKHNlbGVjdExpc3RJdGVtKGxpc3RJdGVtKSkge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0TGlzdEl0ZW0gdHJ1ZSwgY2xvc2luZ1wiKVxuICAgICAgfVxuICAgICAgY2xvc2UoKVxuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIHRleHQgPSBcIlwiXG4gICAgICAgIGlucHV0LmZvY3VzKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0TGlzdEl0ZW0gZmFsc2UsIG5vdCBjbG9zaW5nXCIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXAoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInVwXCIpXG4gICAgfVxuXG4gICAgb3BlbigpXG4gICAgaWYgKGhpZ2hsaWdodEluZGV4ID4gMCkge1xuICAgICAgaGlnaGxpZ2h0SW5kZXgtLVxuICAgIH1cblxuICAgIGhpZ2hsaWdodCgpXG4gIH1cblxuICBmdW5jdGlvbiBkb3duKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJkb3duXCIpXG4gICAgfVxuXG4gICAgb3BlbigpXG4gICAgaWYgKGhpZ2hsaWdodEluZGV4IDwgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgaGlnaGxpZ2h0SW5kZXgrK1xuICAgIH1cblxuICAgIGhpZ2hsaWdodCgpXG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHQoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImhpZ2hsaWdodFwiKVxuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5ID0gXCIuc2VsZWN0ZWRcIlxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJTZWFjaGluZyBET00gZWxlbWVudDogXCIgKyBxdWVyeSArIFwiIGluIFwiICsgbGlzdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICovXG4gICAgY29uc3QgZWwgPSBsaXN0ICYmIGxpc3QucXVlcnlTZWxlY3RvcihxdWVyeSlcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmICh0eXBlb2YgZWwuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2Nyb2xsaW5nIHNlbGVjdGVkIGl0ZW0gaW50byB2aWV3XCIpXG4gICAgICAgIH1cbiAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpXG4gICAgICB9IGVsc2UgaWYgKGVsLnNjcm9sbEludG9WaWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTY3JvbGxpbmcgc2VsZWN0ZWQgaXRlbSBpbnRvIHZpZXdcIilcbiAgICAgICAgfVxuICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIkNvdWxkIG5vdCBzY3JvbGwgc2VsZWN0ZWQgaXRlbSBpbnRvIHZpZXcsIHNjcm9sbEludG9WaWV3SWZOZWVkZWQgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJTZWxlY3RlZCBpdGVtIG5vdCBmb3VuZCB0byBzY3JvbGwgaW50byB2aWV3XCIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uTGlzdEl0ZW1DbGlja1wiKVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RMaXN0SXRlbShsaXN0SXRlbSkpIHtcbiAgICAgIGNsb3NlKClcbiAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICB0ZXh0ID0gXCJcIlxuICAgICAgICBpbnB1dC5mb2N1cygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25Eb2N1bWVudENsaWNrXCIpXG4gICAgfVxuICAgIGlmIChlLmNvbXBvc2VkUGF0aCgpLnNvbWUoKHBhdGgpID0+IHBhdGguY2xhc3NMaXN0ICYmIHBhdGguY2xhc3NMaXN0LmNvbnRhaW5zKHVuaXF1ZUlkKSkpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uRG9jdW1lbnRDbGljayBpbnNpZGVcIilcbiAgICAgIH1cbiAgICAgIC8vIHJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuKCk7XG4gICAgICBoaWdobGlnaHQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkRvY3VtZW50Q2xpY2sgb3V0c2lkZVwiKVxuICAgICAgfVxuICAgICAgY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uS2V5RG93blwiKVxuICAgIH1cblxuICAgIGxldCBrZXkgPSBlLmtleVxuICAgIGlmIChrZXkgPT09IFwiVGFiXCIgJiYgZS5zaGlmdEtleSkga2V5ID0gXCJTaGlmdFRhYlwiXG4gICAgY29uc3QgZm5tYXAgPSB7XG4gICAgICBUYWI6IG9wZW5lZCA/IGNsb3NlIDogbnVsbCxcbiAgICAgIFNoaWZ0VGFiOiBvcGVuZWQgPyBjbG9zZSA6IG51bGwsXG4gICAgICBBcnJvd0Rvd246IGRvd24uYmluZCh0aGlzKSxcbiAgICAgIEFycm93VXA6IHVwLmJpbmQodGhpcyksXG4gICAgICBFc2NhcGU6IG9uRXNjLmJpbmQodGhpcyksXG4gICAgICBCYWNrc3BhY2U6IG11bHRpcGxlICYmIGhhc1NlbGVjdGlvbiAmJiAhdGV4dCA/IG9uQmFja3NwYWNlLmJpbmQodGhpcykgOiBudWxsLFxuICAgIH1cbiAgICBjb25zdCBmbiA9IGZubWFwW2tleV1cbiAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZuKGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uS2V5UHJlc3NcIilcbiAgICB9XG5cbiAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgb25FbnRlcihlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW50ZXIoZSkge1xuICAgIGlmIChvcGVuZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgc2VsZWN0SXRlbSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25JbnB1dChlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uSW5wdXRcIilcbiAgICB9XG5cbiAgICB0ZXh0ID0gZS50YXJnZXQudmFsdWVcbiAgICBpZiAoaW5wdXREZWxheVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnB1dERlbGF5VGltZW91dClcbiAgICB9XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGlucHV0RGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChwcm9jZXNzSW5wdXQsIGRlbGF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzSW5wdXQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2VsZWN0SXRlbSh0YWcpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidW5zZWxlY3RJdGVtXCIsIHRhZylcbiAgICB9XG4gICAgc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtLmZpbHRlcigoaSkgPT4gaSAhPT0gdGFnKVxuICAgIGlucHV0LmZvY3VzKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbnB1dCgpIHtcbiAgICBpZiAoc2VhcmNoKCkpIHtcbiAgICAgIGhpZ2hsaWdodEluZGV4ID0gMFxuICAgICAgb3BlbigpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25JbnB1dENsaWNrKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbklucHV0Q2xpY2tcIilcbiAgICB9XG4gICAgcmVzZXRMaXN0VG9BbGxJdGVtc0FuZE9wZW4oKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Fc2MoZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkVzY1wiKVxuICAgIH1cblxuICAgIC8vaWYgKHRleHQpIHJldHVybiBjbGVhcigpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICBpbnB1dC5mb2N1cygpXG4gICAgICBjbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CYWNrc3BhY2UoZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkJhY2tzcGFjZVwiKVxuICAgIH1cblxuICAgIHVuc2VsZWN0SXRlbShzZWxlY3RlZEl0ZW1bc2VsZWN0ZWRJdGVtLmxlbmd0aCAtIDFdKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2N1c0ludGVybmFsKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkZvY3VzXCIpXG4gICAgfVxuXG4gICAgb25Gb2N1cygpXG5cbiAgICByZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlbigpXG4gIH1cblxuICBmdW5jdGlvbiBvbkJsdXJJbnRlcm5hbCgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25CbHVyXCIpXG4gICAgfVxuXG4gICAgaWYgKGNsb3NlT25CbHVyKSB7XG4gICAgICBjbG9zZSgpXG4gICAgfVxuXG4gICAgb25CbHVyKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJyZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlblwiKVxuICAgIH1cblxuICAgIGlmIChzZWFyY2hGdW5jdGlvbiAmJiAhbGlzdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgc2VhcmNoKClcbiAgICB9IGVsc2UgaWYgKCF0ZXh0KSB7XG4gICAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgIH1cblxuICAgIG9wZW4oKVxuXG4gICAgLy8gZmluZCBzZWxlY3RlZCBpdGVtXG4gICAgaWYgKHNlbGVjdGVkSXRlbSkge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VhcmNoaW5nIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtOiBcIiArIEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkSXRlbSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gZmluZEl0ZW1JbmRleChzZWxlY3RlZEl0ZW0sIGZpbHRlcmVkTGlzdEl0ZW1zKVxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaGlnaGxpZ2h0SW5kZXggPSBpbmRleFxuICAgICAgICBoaWdobGlnaHQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJdGVtSW5kZXgoaXRlbSwgaXRlbXMpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmluZGluZyBpbmRleCBmb3IgaXRlbVwiLCBpdGVtKVxuICAgIH1cbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpc3RJdGVtID0gaXRlbXNbaV1cbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbGlzdEl0ZW0pIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGxpc3RJdGVtICR7aX0gaXMgdW5kZWZpbmVkLiBTa2lwcGluZy5gKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJdGVtIFwiICsgaSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGxpc3RJdGVtKSlcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtID09PSBsaXN0SXRlbS5pdGVtKSB7XG4gICAgICAgIGluZGV4ID0gaVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBpbmRleCBmb3IgaXRlbTogXCIgKyBpbmRleClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vdCBmb3VuZCBpbmRleCBmb3IgaXRlbTogXCIgKyBpdGVtKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXhcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9wZW5cIilcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgc2VhcmNoIHRleHQgaGFzIG1vcmUgdGhhbiB0aGUgbWluIGNoYXJzIHJlcXVpcmVkXG4gICAgaWYgKGxvY2tlZCB8fCBub3RFbm91Z2hTZWFyY2hUZXh0KCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFBvc2l0aW9uT25OZXh0VXBkYXRlID0gdHJ1ZVxuXG4gICAgb3BlbmVkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImNsb3NlXCIpXG4gICAgfVxuICAgIG9wZW5lZCA9IGZhbHNlXG4gICAgbG9hZGluZyA9IGZhbHNlXG5cbiAgICBpZiAoIXRleHQgJiYgc2VsZWN0Rmlyc3RJZkVtcHR5KSB7XG4gICAgICBoaWdobGlnaHRJbmRleCA9IDBcbiAgICAgIHNlbGVjdEl0ZW0oKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdEVub3VnaFNlYXJjaFRleHQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG1pbkNoYXJhY3RlcnNUb1NlYXJjaCA+IDAgJiZcbiAgICAgIGZpbHRlcmVkVGV4dExlbmd0aCA8IG1pbkNoYXJhY3RlcnNUb1NlYXJjaCAmJlxuICAgICAgLy8gV2hlbiBubyBzZWFyY2hGdW5jdGlvbiBpcyBkZWZpbmVkLCB0aGUgbWVudSBzaG91bGQgYWx3YXlzIG9wZW4gd2hlbiB0aGUgaW5wdXQgaXMgZm9jdXNlZFxuICAgICAgKHNlYXJjaEZ1bmN0aW9uIHx8IGZpbHRlcmVkVGV4dExlbmd0aCA+IDApXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VJZk1pbkNoYXJzVG9TZWFyY2hSZWFjaGVkKCkge1xuICAgIGlmIChub3RFbm91Z2hTZWFyY2hUZXh0KCkpIHtcbiAgICAgIGNsb3NlKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImNsZWFyXCIpXG4gICAgfVxuXG4gICAgdGV4dCA9IFwiXCJcbiAgICBzZWxlY3RlZEl0ZW0gPSBtdWx0aXBsZSA/IFtdIDogdW5kZWZpbmVkXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlucHV0LmZvY3VzKClcbiAgICB9KVxuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodEZpbHRlcihrZXl3b3JkcywgZmllbGQpIHtcbiAgICByZXR1cm4gKGl0ZW0pID0+IHtcbiAgICAgIGxldCBsYWJlbCA9IGl0ZW1bZmllbGRdXG5cbiAgICAgIGNvbnN0IG5ld0l0ZW0gPSBPYmplY3QuYXNzaWduKHsgaGlnaGxpZ2h0ZWQ6IHVuZGVmaW5lZCB9LCBpdGVtKVxuICAgICAgbmV3SXRlbS5oaWdobGlnaHRlZCA9IGxhYmVsXG5cbiAgICAgIGNvbnN0IGxhYmVsTG93ZXJjYXNlID0gbGFiZWwudG9Mb3dlckNhc2UoKVxuICAgICAgY29uc3QgbGFiZWxMb3dlcmNhc2VOb0FjID0gaWdub3JlQWNjZW50cyA/IHJlbW92ZUFjY2VudHMobGFiZWxMb3dlcmNhc2UpIDogbGFiZWxMb3dlcmNhc2VcblxuICAgICAgaWYgKGtleXdvcmRzICYmIGtleXdvcmRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5d29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQga2V5d29yZCA9IGtleXdvcmRzW2ldXG4gICAgICAgICAgaWYgKGlnbm9yZUFjY2VudHMpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSByZW1vdmVBY2NlbnRzKGtleXdvcmQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleXdvcmRMZW4gPSBrZXl3b3JkLmxlbmd0aFxuXG4gICAgICAgICAgbGV0IHBvczEgPSAwXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zMSA9IGxhYmVsTG93ZXJjYXNlTm9BYy5pbmRleE9mKGtleXdvcmQsIHBvczEpXG4gICAgICAgICAgICBpZiAocG9zMSA+PSAwKSB7XG4gICAgICAgICAgICAgIGxldCBwb3MyID0gcG9zMSArIGtleXdvcmRMZW5cbiAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goW3BvczEsIHBvczJdKVxuICAgICAgICAgICAgICBwb3MxID0gcG9zMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKHBvczEgIT09IC0xKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qga2V5d29yZFBhdHRlcm5zID0gbmV3IFNldCgpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBwb3NpdGlvbnNbaV1cbiAgICAgICAgICAgIGNvbnN0IHBvczEgPSBwYWlyWzBdXG4gICAgICAgICAgICBjb25zdCBwb3MyID0gcGFpclsxXVxuXG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkUGF0dGVybiA9IGxhYmVsTG93ZXJjYXNlLnN1YnN0cmluZyhwb3MxLCBwb3MyKVxuICAgICAgICAgICAga2V5d29yZFBhdHRlcm5zLmFkZChrZXl3b3JkUGF0dGVybilcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQga2V5d29yZFBhdHRlcm4gb2Yga2V5d29yZFBhdHRlcm5zKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBwc3Q6IHdvcmthcm9uZCBmb3Igd3JvbmcgcmVwbGFjZW1lbnQgPGI+IHRhZ3NcbiAgICAgICAgICAgIGlmIChrZXl3b3JkUGF0dGVybiA9PT0gXCJiXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoXCIoXCIgKyBrZXl3b3JkUGF0dGVybiArIFwiKVwiLCBcImlnXCIpXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0hpZ2hsaWdodGVkID0gbmV3SXRlbS5oaWdobGlnaHRlZC5yZXBsYWNlKHJlZywgXCI8Yj4kMTwvYj5cIilcbiAgICAgICAgICAgIG5ld0l0ZW0uaGlnaGxpZ2h0ZWQgPSBuZXdIaWdobGlnaHRlZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SXRlbVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFjY2VudHMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoXCJORkRcIikucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29uZmlybWVkKGxpc3RJdGVtKSB7XG4gICAgaWYgKCFzZWxlY3RlZEl0ZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZEl0ZW0uaW5jbHVkZXMobGlzdEl0ZW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaXN0SXRlbSA9PT0gc2VsZWN0ZWRJdGVtXG4gICAgfVxuICB9XG5cbiAgbGV0IGRyYWdnaW5nT3ZlciA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gZHJhZ3N0YXJ0KGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwic291cmNlXCIsIGluZGV4KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdvdmVyKGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGRyYWdnaW5nT3ZlciA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhZ2xlYXZlKGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGRyYWdnaW5nT3ZlciA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJvcChldmVudCwgaW5kZXgpIHtcbiAgICBpZiAob3JkZXJhYmxlU2VsZWN0aW9uKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBkcmFnZ2luZ092ZXIgPSBmYWxzZVxuICAgICAgbGV0IGZyb20gPSBwYXJzZUludChldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInNvdXJjZVwiKSlcbiAgICAgIGxldCB0byA9IGluZGV4XG4gICAgICBpZiAoZnJvbSAhPSB0bykge1xuICAgICAgICBtb3ZlU2VsZWN0ZWRJdGVtKGZyb20sIHRvKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVTZWxlY3RlZEl0ZW0oZnJvbSwgdG8pIHtcbiAgICBsZXQgbmV3U2VsZWN0aW9uID0gWy4uLnNlbGVjdGVkSXRlbV1cbiAgICBpZiAoZnJvbSA8IHRvKSB7XG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKHRvICsgMSwgMCwgbmV3U2VsZWN0aW9uW2Zyb21dKVxuICAgICAgbmV3U2VsZWN0aW9uLnNwbGljZShmcm9tLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKHRvLCAwLCBuZXdTZWxlY3Rpb25bZnJvbV0pXG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKGZyb20gKyAxLCAxKVxuICAgIH1cbiAgICBzZWxlY3RlZEl0ZW0gPSBuZXdTZWxlY3Rpb25cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbEF3YXJlTGlzdFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgaGVpZ2h0OiB2aWV3UG9ydEhlaWdodCB9ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0XG4gICAgY29uc3QgeyBib3R0b206IGlucHV0QnV0dG9tLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH0gPSBpbnB1dENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHsgaGVpZ2h0OiBsaXN0SGVpZ2h0IH0gPSBsaXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICBpZiAoaW5wdXRCdXR0b20gKyBsaXN0SGVpZ2h0ID4gdmlld1BvcnRIZWlnaHQpIHtcbiAgICAgIGxpc3Quc3R5bGUudG9wID0gYC0ke2lucHV0SGVpZ2h0ICsgbGlzdEhlaWdodH1weGBcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zdHlsZS50b3AgPSBcIjBweFwiXG4gICAgfVxuICB9XG48L3NjcmlwdD5cbjxkaXZcbiAgY2xhc3M9XCJ7Y2xhc3NOYW1lID8gY2xhc3NOYW1lIDogJyd9IGF1dG9jb21wbGV0ZSBzZWxlY3QgaXMtZnVsbHdpZHRoIHt1bmlxdWVJZH1cIlxuICBjbGFzczpoaWRlLWFycm93PXtoaWRlQXJyb3cgfHwgIWl0ZW1zLmxlbmd0aH1cbiAgY2xhc3M6aXMtbXVsdGlwbGU9e211bHRpcGxlfVxuICBjbGFzczpzaG93LWNsZWFyPXtjbGVhcmFibGV9XG4gIGNsYXNzOmlzLWxvYWRpbmc9e3Nob3dMb2FkaW5nSW5kaWNhdG9yICYmIGxvYWRpbmd9XG4+XG4gIDxzZWxlY3QgbmFtZT17c2VsZWN0TmFtZX0gaWQ9e3NlbGVjdElkfSB7bXVsdGlwbGV9PlxuICAgIHsjaWYgIW11bHRpcGxlICYmIGhhc1NlbGVjdGlvbn1cbiAgICAgIDxvcHRpb24gdmFsdWU9e3ZhbHVlRnVuY3Rpb24oc2VsZWN0ZWRJdGVtLCB0cnVlKX0gc2VsZWN0ZWQ+XG4gICAgICAgIHtzYWZlTGFiZWxGdW5jdGlvbihzZWxlY3RlZEl0ZW0pfVxuICAgICAgPC9vcHRpb24+XG4gICAgezplbHNlIGlmIG11bHRpcGxlICYmIGhhc1NlbGVjdGlvbn1cbiAgICAgIHsjZWFjaCBzZWxlY3RlZEl0ZW0gYXMgaX1cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT17dmFsdWVGdW5jdGlvbihpLCB0cnVlKX0gc2VsZWN0ZWQ+XG4gICAgICAgICAge3NhZmVMYWJlbEZ1bmN0aW9uKGkpfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuICA8L3NlbGVjdD5cbiAgPGRpdiBjbGFzcz1cImlucHV0LWNvbnRhaW5lclwiIGJpbmQ6dGhpcz17aW5wdXRDb250YWluZXJ9PlxuICAgIHsjaWYgbXVsdGlwbGUgJiYgaGFzU2VsZWN0aW9ufVxuICAgICAgeyNlYWNoIHNlbGVjdGVkSXRlbSBhcyB0YWdJdGVtLCBpICh2YWx1ZUZ1bmN0aW9uKHRhZ0l0ZW0sIHRydWUpKX1cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGRyYWdnYWJsZT17dHJ1ZX1cbiAgICAgICAgICBhbmltYXRlOmZsaXA9e3sgZHVyYXRpb246IDIwMCB9fVxuICAgICAgICAgIHRyYW5zaXRpb246ZmFkZT17eyBkdXJhdGlvbjogMjAwIH19XG4gICAgICAgICAgb246ZHJhZ3N0YXJ0PXsoZXZlbnQpID0+IGRyYWdzdGFydChldmVudCwgaSl9XG4gICAgICAgICAgb246ZHJhZ292ZXI9eyhldmVudCkgPT4gZHJhZ292ZXIoZXZlbnQsIGkpfVxuICAgICAgICAgIG9uOmRyYWdsZWF2ZT17KGV2ZW50KSA9PiBkcmFnbGVhdmUoZXZlbnQsIGkpfVxuICAgICAgICAgIG9uOmRyb3A9eyhldmVudCkgPT4gZHJvcChldmVudCwgaSl9XG4gICAgICAgICAgY2xhc3M6aXMtYWN0aXZlPXtkcmFnZ2luZ092ZXIgPT09IGl9XG4gICAgICAgID5cbiAgICAgICAgICA8c2xvdCBuYW1lPVwidGFnXCIgbGFiZWw9e3NhZmVMYWJlbEZ1bmN0aW9uKHRhZ0l0ZW0pfSBpdGVtPXt0YWdJdGVtfSB7dW5zZWxlY3RJdGVtfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWdzIGhhcy1hZGRvbnNcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWdcIj57c2FmZUxhYmVsRnVuY3Rpb24odGFnSXRlbSl9PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFnIGlzLWRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e3Vuc2VsZWN0SXRlbSh0YWdJdGVtKX1cbiAgICAgICAgICAgICAgICBvbjprZXlwcmVzc3xwcmV2ZW50RGVmYXVsdD17KGUpID0+IHtlLmtleSA9PSBcIkVudGVyXCIgJiYgdW5zZWxlY3RJdGVtKHRhZ0l0ZW0pfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2VhY2h9XG4gICAgey9pZn1cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIGNsYXNzPVwie2lucHV0Q2xhc3NOYW1lID8gaW5wdXRDbGFzc05hbWUgOiAnJ30ge25vSW5wdXRTdHlsZXNcbiAgICAgICAgPyAnJ1xuICAgICAgICA6ICdpbnB1dCBhdXRvY29tcGxldGUtaW5wdXQnfVwiXG4gICAgICBpZD17aW5wdXRJZCA/IGlucHV0SWQgOiBcIlwifVxuICAgICAgYXV0b2NvbXBsZXRlPXtodG1sNWF1dG9jb21wbGV0ZSA/IFwib25cIiA6IGF1dG9jb21wbGV0ZU9mZlZhbHVlfVxuICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAge25hbWV9XG4gICAgICB7ZGlzYWJsZWR9XG4gICAgICB7cmVxdWlyZWR9XG4gICAgICB7dGl0bGV9XG4gICAgICByZWFkb25seT17cmVhZG9ubHkgfHwgbG9ja2VkfVxuICAgICAge3RhYmluZGV4fVxuICAgICAgYmluZDp0aGlzPXtpbnB1dH1cbiAgICAgIGJpbmQ6dmFsdWU9e3RleHR9XG4gICAgICBvbjppbnB1dD17b25JbnB1dH1cbiAgICAgIG9uOmZvY3VzPXtvbkZvY3VzSW50ZXJuYWx9XG4gICAgICBvbjpibHVyPXtvbkJsdXJJbnRlcm5hbH1cbiAgICAgIG9uOmtleWRvd249e29uS2V5RG93bn1cbiAgICAgIG9uOmNsaWNrPXtvbklucHV0Q2xpY2t9XG4gICAgICBvbjprZXlwcmVzcz17b25LZXlQcmVzc31cbiAgICAgIG9uOmRyYWdvdmVyPXsoZXZlbnQpID0+IGRyYWdvdmVyKGV2ZW50LCBzZWxlY3RlZEl0ZW0ubGVuZ3RoIC0gMSl9XG4gICAgICBvbjpkcm9wPXsoZXZlbnQpID0+IGRyb3AoZXZlbnQsIHNlbGVjdGVkSXRlbS5sZW5ndGggLSAxKX1cbiAgICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICAvPlxuICAgIHsjaWYgY2xlYXJhYmxlfVxuICAgICAgPHNwYW5cbiAgICAgICAgb246Y2xpY2s9e2NsZWFyfVxuICAgICAgICBvbjprZXlwcmVzcz17KGUpID0+IHtlLmtleSA9PSBcIkVudGVyXCIgJiYgY2xlYXIoKX19XG4gICAgICAgIGNsYXNzPVwiYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvblwiXG4gICAgICAgID57QGh0bWwgY2xlYXJUZXh0fTwvc3Bhbj5cbiAgICB7L2lmfVxuICA8L2Rpdj5cbiAgPGRpdlxuICAgIGNsYXNzPVwie2Ryb3Bkb3duQ2xhc3NOYW1lID8gZHJvcGRvd25DbGFzc05hbWUgOiAnJ30gYXV0b2NvbXBsZXRlLWxpc3Qge3Nob3dMaXN0ID8gJycgOiAnaGlkZGVuJ31cbiAgICBpcy1mdWxsd2lkdGhcIlxuICAgIGJpbmQ6dGhpcz17bGlzdH1cbiAgPlxuICAgIHsjaWYgZmlsdGVyZWRMaXN0SXRlbXMgJiYgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoID4gMH1cbiAgICAgIDxzbG90IG5hbWU9XCJkcm9wZG93bi1oZWFkZXJcIiBuYkl0ZW1zPXtmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGh9IHttYXhJdGVtc1RvU2hvd0luTGlzdH0gLz5cblxuICAgICAgeyNlYWNoIGZpbHRlcmVkTGlzdEl0ZW1zIGFzIGxpc3RJdGVtLCBpfVxuICAgICAgICB7I2lmIGxpc3RJdGVtICYmIChtYXhJdGVtc1RvU2hvd0luTGlzdCA8PSAwIHx8IGkgPCBtYXhJdGVtc1RvU2hvd0luTGlzdCl9XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtXCJcbiAgICAgICAgICAgIGNsYXNzOnNlbGVjdGVkPXtpID09PSBoaWdobGlnaHRJbmRleH1cbiAgICAgICAgICAgIGNsYXNzOmNvbmZpcm1lZD17aXNDb25maXJtZWQobGlzdEl0ZW0uaXRlbSl9XG4gICAgICAgICAgICBvbjpjbGljaz17KCkgPT4gb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKX1cbiAgICAgICAgICAgIG9uOmtleXByZXNzPXsoZSkgPT4ge2Uua2V5ID09IFwiRW50ZXJcIiAmJiBvbkxpc3RJdGVtQ2xpY2sobGlzdEl0ZW0pfX1cbiAgICAgICAgICAgIG9uOnBvaW50ZXJlbnRlcj17KCkgPT4ge1xuICAgICAgICAgICAgICBoaWdobGlnaHRJbmRleCA9IGlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNsb3RcbiAgICAgICAgICAgICAgbmFtZT1cIml0ZW1cIlxuICAgICAgICAgICAgICBpdGVtPXtsaXN0SXRlbS5pdGVtfVxuICAgICAgICAgICAgICBsYWJlbD17bGlzdEl0ZW0uaGlnaGxpZ2h0ZWQgPyBsaXN0SXRlbS5oaWdobGlnaHRlZCA6IGxpc3RJdGVtLmxhYmVsfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7I2lmIGxpc3RJdGVtLmhpZ2hsaWdodGVkfVxuICAgICAgICAgICAgICAgIHtAaHRtbCBsaXN0SXRlbS5oaWdobGlnaHRlZH1cbiAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHtAaHRtbCBsaXN0SXRlbS5sYWJlbH1cbiAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICAgIHsvZWFjaH1cblxuICAgICAgPHNsb3QgbmFtZT1cImRyb3Bkb3duLWZvb3RlclwiIG5iSXRlbXM9e2ZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aH0ge21heEl0ZW1zVG9TaG93SW5MaXN0fT5cbiAgICAgICAgeyNpZiBtYXhJdGVtc1RvU2hvd0luTGlzdCA+IDAgJiYgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoID4gbWF4SXRlbXNUb1Nob3dJbkxpc3R9XG4gICAgICAgICAgeyNpZiBtb3JlSXRlbXNUZXh0fVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbm8tcmVzdWx0c1wiPlxuICAgICAgICAgICAgICAuLi57ZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoIC0gbWF4SXRlbXNUb1Nob3dJbkxpc3R9XG4gICAgICAgICAgICAgIHttb3JlSXRlbXNUZXh0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgey9pZn1cbiAgICAgICAgey9pZn1cbiAgICAgIDwvc2xvdD5cbiAgICB7OmVsc2UgaWYgbG9hZGluZyAmJiBsb2FkaW5nVGV4dH1cbiAgICAgIDxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtLWxvYWRpbmdcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxvYWRpbmdcIiB7bG9hZGluZ1RleHR9Pntsb2FkaW5nVGV4dH08L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICB7OmVsc2UgaWYgY3JlYXRlfVxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tY3JlYXRlXCJcbiAgICAgICAgb246Y2xpY2s9e3NlbGVjdEl0ZW19XG4gICAgICAgIG9uOmtleXByZXNzPXsoZSkgPT4ge2Uua2V5ID09IFwiRW50ZXJcIiAmJiBzZWxlY3RJdGVtKCl9fVxuICAgICAgPlxuICAgICAgICA8c2xvdCBuYW1lPVwiY3JlYXRlXCIge2NyZWF0ZVRleHR9PntjcmVhdGVUZXh0fTwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIHs6ZWxzZSBpZiBub1Jlc3VsdHNUZXh0fVxuICAgICAgPGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbm8tcmVzdWx0c1wiPlxuICAgICAgICA8c2xvdCBuYW1lPVwibm8tcmVzdWx0c1wiIHtub1Jlc3VsdHNUZXh0fT57bm9SZXN1bHRzVGV4dH08L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICA8L2Rpdj5cbjwvZGl2PlxuXG48c3ZlbHRlOndpbmRvdyBvbjpjbGljaz17b25Eb2N1bWVudENsaWNrfSBvbjpzY3JvbGw9eygpID0+IHNldFBvc2l0aW9uT25OZXh0VXBkYXRlID0gdHJ1ZX0gLz5cblxuPHN0eWxlPlxuICAuYXV0b2NvbXBsZXRlIHtcbiAgICBtaW4td2lkdGg6IDIwMHB4O1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgaGVpZ2h0OiAyLjI1ZW07XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlOm5vdCguaGlkZS1hcnJvdyk6bm90KC5pcy1sb2FkaW5nKTo6YWZ0ZXIge1xuICAgIGJvcmRlcjogM3B4IHNvbGlkO1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICBib3JkZXItcmlnaHQ6IDA7XG4gICAgYm9yZGVyLXRvcDogMDtcbiAgICBjb250ZW50OiBcIiBcIjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBoZWlnaHQ6IDAuNjI1ZW07XG4gICAgbWFyZ2luLXRvcDogLTAuNDM3NWVtO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDUwJTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG4gICAgd2lkdGg6IDAuNjI1ZW07XG4gICAgYm9yZGVyLWNvbG9yOiAjMzI3M2RjO1xuICAgIHJpZ2h0OiAxLjEyNWVtO1xuICAgIHotaW5kZXg6IDQ7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLnNob3ctY2xlYXI6bm90KC5oaWRlLWFycm93KTo6YWZ0ZXIge1xuICAgIHJpZ2h0OiAyLjNlbTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUgKiB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBmb250OiBpbmhlcml0O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBwYWRkaW5nOiA1cHggMTFweDtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGU6bm90KC5oaWRlLWFycm93KSAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyZW07XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS5zaG93LWNsZWFyOm5vdCguaGlkZS1hcnJvdykgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgcGFkZGluZy1yaWdodDogMy4yZW07XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS5oaWRlLWFycm93LnNob3ctY2xlYXIgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgcGFkZGluZy1yaWdodDogMmVtO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS1saXN0IHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIHotaW5kZXg6IDk5O1xuICAgIHBhZGRpbmc6IDEwcHggMDtcbiAgICB0b3A6IDBweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTUgKiAoMXJlbSArIDEwcHgpICsgMTVweCk7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0OmVtcHR5IHtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBjb2xvcjogIzMzMztcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS5jb25maXJtZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM3ODlmZWQ7XG4gICAgY29sb3I6ICNmZmY7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0uc2VsZWN0ZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMyZTY5ZTI7XG4gICAgY29sb3I6ICNmZmY7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbm8tcmVzdWx0cyB7XG4gICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgY29sb3I6ICM5OTk7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tY3JlYXRlIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1sb2FkaW5nIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUtbGlzdC5oaWRkZW4ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuc2hvdy1jbGVhciAuYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvbiB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDAuMWVtO1xuICAgIHBhZGRpbmc6IDAuM2VtIDAuNmVtO1xuICAgIHRvcDogNTAlO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIHotaW5kZXg6IDQ7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlOm5vdCguc2hvdy1jbGVhcikgLmF1dG9jb21wbGV0ZS1jbGVhci1idXR0b24ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlIHNlbGVjdCB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuaXMtbXVsdGlwbGUgLmlucHV0LWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDJweCByZ2JhKDEwLCAxMCwgMTAsIDAuMSk7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNiNWI1YjU7XG4gICAgcGFkZGluZy1sZWZ0OiAwLjRlbTtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwLjRlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAudGFnIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbi10b3A6IDAuNWVtO1xuICAgIG1hcmdpbi1ib3R0b206IDAuM2VtO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAudGFnLmlzLWRlbGV0ZSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAudGFncyB7XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjNlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGZsZXg6IDEgMSA1MHB4O1xuICAgIG1pbi13aWR0aDogM2VtO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3gtc2hhZG93OiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRleHRmaWVsZFwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHNpemUgPSBcIm5vcm1hbFwiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtdGV4dGZpZWxkLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBBdXRvQ29tcGxldGUgZnJvbSBcInNpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlXCI7XG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJVGV4dGZpZWxkSW5wdXQgZnJvbSBcIi4vdWkudGV4dGZpZWxkLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKipcbiAgICAgKiBNb3JlIHByb3BlcnRpZXMgYXQgaHR0cHM6Ly9naXRodWIuY29tL3BzdGFub2V2L3NpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlI3Byb3BlcnRpZXNcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXIgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZSA9ICdhdXRvY29tcGxldGUnXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIC8vZ2VuZXJpYyBpbnB1dCBwcm9wc1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiYXV0b2NvbXBsZXRlXCIsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHJlcXVpcmVkID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UodmFsKSB7XG4gICAgICAgIGlmIChvbmNoYW5nZSkge1xuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsKSxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBkaXNhYmxlZH1cbiAgICA8VUlUZXh0ZmllbGRJbnB1dFxuICAgICAgICB2YWx1ZT17dmFsdWUgPyB2YWx1ZS50aXRsZSA6IFwiXCJ9XG4gICAgICAgIHtmaWVsZG5hbWV9XG4gICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuezplbHNlIGlmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZSA/ICh2YWx1ZT8udGl0bGUgPz8gXCJcIikgOiBcIlwifTwvcD5cbns6ZWxzZX1cbiAgICA8QXV0b0NvbXBsZXRlXG4gICAgICAgIGJpbmQ6c2VsZWN0ZWRJdGVtPXt2YWx1ZX1cbiAgICAgICAge29uQ2hhbmdlfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHt2YWxpZH1cbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCB7IFVJQ29tbW9uIH0gZnJvbSBcIi4uLy4uXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY29sb3JcIixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxpbnB1dFxuICAgIGlkPVwiZm9ybS1maWVsZC1jb2xvci17ZmllbGRuYW1lfVwiXG4gICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgdHlwZT1cImNvbG9yXCJcbiAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgYmluZDp2YWx1ZVxuICAgIHtpbnZhbGlkfVxuICAgIHtyZXF1aXJlZH1cbiAgICB7cmVhZG9ubHl9XG4gICAge2Rpc2FibGVkfVxuICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICB7Li4ub3RoZXJzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZm9yXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbD0nbGFiZWwnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZm9yOiBmb3JJZCxcbiAgICAgICAgbGFiZWwgPSBcImxhYmVsXCIsXG4gICAgICAgIGNsYXNzOiBsYWJlbENsYXNzID0gXCJcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxsYWJlbCBjbGFzcz1cImxhYmVsIHtsYWJlbENsYXNzfVwiIGZvcj17Zm9ySWR9PlxuICAgIHsjaWYgY2hpbGRyZW59XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuKCl9XG4gICAgezplbHNlfXtsYWJlbCA/ICRMT0NBTEVbbGFiZWxdIDogXCJcIn17L2lmfVxuPC9sYWJlbD5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQGNvbXBvbmVudFxuICAgICAqIGNoZWNrYm94IHdpdGggdHJ1ZSBvciBmYWxzZSB2YWx1ZXNcbiAgICAgKiovXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbiAgICBpbXBvcnQgVUlMYWJlbCBmcm9tIFwiLi91aS5sYWJlbC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCb29sZWFuIGZyb20gXCIuLi92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbGFiZWwgPSBcImNoZWNrYm94XCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY2hlY2tib3hcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgbGFiZWxDbGFzcyA9IFwiY2hlY2tib3hcIixcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uY2hhbmdlXCIsIFwib25pbnB1dFwiXSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IGlkID0gYGZvcm0tZmllbGQtY2hlY2tib3gtJHtmaWVsZG5hbWV9YDtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KFxuICAgICAgICAgICAgZmllbGRuYW1lLFxuICAgICAgICAgICAgb3RoZXJzLm9uY2hhbmdlLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiBvdGhlcnM/LmlkLFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZWFjdE9uLmZvckVhY2goKGV2ZW50TmFtZSkgPT4gKG9wdGlvbmFsUHJvcHNbZXZlbnROYW1lXSA9IG9uaW5wdXQpKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPFVJTGFiZWwgY2xhc3M9e2xhYmVsQ2xhc3N9IHtkaXNhYmxlZH0gZm9yPXtpZH0+XG4gICAgeyNpZiByZWFkb25seX1cbiAgICAgICAgPFVJQm9vbGVhbiBMQ19UUlVFPXtsYWJlbH0gTENfRkFMU0U9e2xhYmVsfSB7dmFsdWV9IC8+XG4gICAgezplbHNlfVxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHtpZH1cbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc2VzfVxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIGJpbmQ6Y2hlY2tlZD17dmFsdWV9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgICAgIHskTE9DQUxFW2xhYmVsXX1cbiAgICB7L2lmfVxuPC9VSUxhYmVsPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlDaGVja2JveElucHV0IGZyb20gXCIuL3VpLmNoZWNrYm94LnN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY2hlY2tib3gtbGlzdFwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbmNoYW5nZShkYXRhLCBldiwgYWRkaXRpb25hbCkge1xuICAgICAgICBpZiAoIWFkZGl0aW9uYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKGFkZGl0aW9uYWwuaWQpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChhZGRpdGlvbmFsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhhZGRpdGlvbmFsLmlkKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnNwbGljZSh2YWx1ZS5pbmRleE9mKGFkZGl0aW9uYWwuaWQpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdGhlcnM/Lm9uY2hhbmdlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXYsXG4gICAgICAgICAgICBhZGRpdGlvbmFsXG4gICAgICAgICk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjZWFjaCB2YXJpYW50cyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICA8VUlDaGVja2JveElucHV0XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIHsuLi5pdGVtfVxuICAgICAgICBmaWVsZG5hbWU9e2Ake2ZpZWxkbmFtZX0tJHtpdGVtLmlkfWB9XG4gICAgICAgIHZhbHVlPXt2YWx1ZS5pbmNsdWRlcyhpdGVtLmlkKX1cbiAgICAgICAge29uY2hhbmdlfVxuICAgIC8+XG57L2VhY2h9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKG5ldyBEYXRlKCkpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHBhdHRlcm4gPSBcImR7NH0tZHsyfS1kezJ9XCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoXCJUXCIpID4gMCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdChcIlRcIilbMF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+XG4gICAgICAgIDx0aW1lIGRhdGV0aW1lPXt2YWx1ZX0+e1VJQ29tbW9uLnRyeUZvcm1hdExvY2FsZURhdGVUaW1lKHZhbHVlKX08L3RpbWU+XG4gICAgPC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtZGF0ZS17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJkYXRlXCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHtwYXR0ZXJufVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTXNGcm9tRGF0ZShpc29EYXRlLCBtYXJrQXNaVUxVID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGlzb0RhdGUuc3BsaXQoXCIuXCIpWzBdICsgKG1hcmtBc1pVTFUgPyBcIlwiIDogXCJaXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlY0Zyb21EYXRlKGlzb0RhdGUsIG1hcmtBc1pVTFUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNvRGF0ZS5zbGljZSgwLCBpc29EYXRlLmxhc3RJbmRleE9mKFwiOlwiKSkgKyAobWFya0FzWlVMVSA/IFwiXCIgOiBcIlpcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGlmdERhdGV0aW1lKGlzb0RhdGUsIHNoaWZ0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlVXRjID0gbmV3IERhdGUobWFya0FzWlVMVShpc29EYXRlKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc2hpZnQgKiAtNjAwMDA7XG4gICAgICAgICAgICBpZiAoZGF0ZUlzVmFsaWQoZGF0ZVV0YyArIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZVV0YyArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXNvRGF0ZSA9IG5ld0RhdGUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlU2VjRnJvbURhdGUoXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU1zRnJvbURhdGUobmV3SXNvRGF0ZSwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtBc1pVTFUoZGF0ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gZGF0ZVN0cmluZyAmJiBkYXRlU3RyaW5nLmF0KC0xKSAhPT0gXCJaXCJcbiAgICAgICAgICAgID8gZGF0ZVN0cmluZyArIFwiWlwiXG4gICAgICAgICAgICA6IGRhdGVTdHJpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5SZWFkYWJsZShpc29EYXRlKSB7XG4gICAgICAgIHJldHVybiBVSUNvbW1vbi50cnlGb3JtYXRMb2NhbGVEYXRlVGltZShpc29EYXRlKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZpZWxkbmFtZSA9IFwiZGF0ZXRpbWVJblRaXCIsXG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFxuICAgICAgICAgICAgcmVtb3ZlU2VjRnJvbURhdGUocmVtb3ZlTXNGcm9tRGF0ZShuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpKVxuICAgICAgICApLFxuICAgICAgICB0aW1lem9uZU9mZnNldCA9IDAsXG4gICAgICAgIGh1bWFuID0gdHJ1ZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHJlcXVpcmVkID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBzaGlmdGVkVmFsdWUgPSAkc3RhdGUoKSxcbiAgICAgICAgcHJldlNoaWZ0ZWRWYWx1ZTtcblxuICAgIGNvbnN0IHNldFNoaWZ0ZWQgPSAodmFsKSA9PiB7XG4gICAgICAgIGlmIChkYXRlSXNWYWxpZCh2YWwpKSB7XG4gICAgICAgICAgICBwcmV2U2hpZnRlZFZhbHVlID0gc2hpZnRlZFZhbHVlO1xuICAgICAgICAgICAgc2hpZnRlZFZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc2V0U2hpZnRlZFZhbHVlID0gKCkgPT4ge1xuICAgICAgICBzaGlmdGVkVmFsdWUgPSBwcmV2U2hpZnRlZFZhbHVlO1xuICAgIH07XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgc2V0U2hpZnRlZChzaGlmdERhdGV0aW1lKHZhbHVlLCB0aW1lem9uZU9mZnNldCkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZGF0ZUlzVmFsaWQgPSAoZGF0ZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgY2hhbmdlZCA9ICgpID0+XG4gICAgICAgIHZhbHVlICE9PSBzaGlmdERhdGV0aW1lKHNoaWZ0ZWRWYWx1ZSwgLXRpbWV6b25lT2Zmc2V0LCB0cnVlKTtcblxuICAgIGNvbnN0IGRpc3BhdGNoQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBzZXRTaGlmdGVkKHNoaWZ0ZWRWYWx1ZSk7XG4gICAgICAgIHZhbHVlID0gbWFya0FzWlVMVShzaGlmdERhdGV0aW1lKHNoaWZ0ZWRWYWx1ZSwgLXRpbWV6b25lT2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGV2KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV2LmN1cnJlbnRUYXJnZXQudmFsdWUgJiZcbiAgICAgICAgICAgIHNoaWZ0ZWRWYWx1ZSAmJlxuICAgICAgICAgICAgZGF0ZUlzVmFsaWQoc2hpZnRlZFZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKCkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaENoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNldFNoaWZ0ZWRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG48L3NjcmlwdD5cblxueyNpZiBzaGlmdGVkVmFsdWV9XG4gICAgeyNpZiByZWFkb25seX1cbiAgICAgICAgPHA+e2h1bWFuUmVhZGFibGUoc2hpZnRlZFZhbHVlKX08L3A+XG4gICAgezplbHNlfVxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIGlkPVwiZm9ybS1maWVsZC1kYXRldGltZS1pbi10aW1lem9uZS17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBjbGFzcz1cImlucHV0IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgICAgICB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIlxuICAgICAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICAgICAgYmluZDp2YWx1ZT17c2hpZnRlZFZhbHVlfVxuICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIG9uY2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uYmx1cj17b25DaGFuZ2V9XG4gICAgICAgICAgICBvbmlucHV0PXtvbkNoYW5nZX1cbiAgICAgICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAvPlxuICAgIHsvaWZ9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJlbWFpbFwiLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuXG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtZW1haWwte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwiZW1haWxcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiaGlkZGVuXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxpbnB1dFxuICAgIGlkPVwiZm9ybS1maWVsZC1oaWRkZW4te2ZpZWxkbmFtZX1cIlxuICAgIHR5cGU9XCJoaWRkZW5cIlxuICAgIGJpbmQ6dmFsdWVcbiAgICB7cmVxdWlyZWR9XG4gICAge3JlYWRvbmx5fVxuICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICB7b3RoZXJzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwidGV4dGFyZWFcIixcbiAgICAgICAgcm93cyA9IDEwLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFjdE9uID0gW1wib25ibHVyXCJdLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuXG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICByZWFjdE9uLmZvckVhY2goKGV2ZW50TmFtZSkgPT4gKG9wdGlvbmFsUHJvcHNbZXZlbnROYW1lXSA9IG9uaW5wdXQpKTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDx0ZXh0YXJlYVxuICAgICAgICBpZD1cImZvcm0tZmllbGQtdGV4dGFyZWEte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cInRleHRhcmVhIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAge3Jvd3N9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgPjwvdGV4dGFyZWE+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRleHRhcmVhIGZyb20gXCIuL3VpLnRleHRhcmVhLnN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIGZpZWxkbmFtZSA9IFwianNvbmFyZWFcIixcbiAgICAgICAgdmFsaWQgPSAkYmluZGFibGUodHJ1ZSksXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25lcnJvciA9ICgpID0+IHt9LFxuICAgICAgICByZWFjdE9uID0gW1wib25ibHVyXCJdLFxuICAgICAgICBjb2xvclZhbGlkID0gXCJzdWNjZXNzXCIsXG4gICAgICAgIGNvbG9ySW52YWxpZCA9IFwiZGFuZ2VyXCIsXG4gICAgICAgIHZhbGlkYXRpb25EZWxheSA9IDEwMDAsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBfdmFsdWUgPSAkc3RhdGUoXCJ7fVwiKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3ZhbHVlID0gSlNPTi5zdHJpbmdpZnkoJHN0YXRlLnNuYXBzaG90KHZhbHVlKSwgbnVsbCwgNCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgX3ZhbHVlID0gXCJ7fVwiO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgZGVsYXllZFZhbGlkYXRpb247XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSh2YWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWwpO1xuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBvbmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxheWVkT25DaGFuZ2UoZGF0YSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiB2YWwgfSA9IGRhdGE7XG4gICAgICAgIGlmIChkZWxheWVkVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlbGF5ZWRWYWxpZGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxheWVkVmFsaWRhdGlvbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgb25DaGFuZ2UodmFsKTtcbiAgICAgICAgfSwgdmFsaWRhdGlvbkRlbGF5KTtcbiAgICB9XG5cbiAgICBsZXQgY29sb3IgPSAkZGVyaXZlZCh2YWxpZCA/IGNvbG9yVmFsaWQgOiBjb2xvckludmFsaWQpO1xuPC9zY3JpcHQ+XG5cbjxVSVRleHRhcmVhXG4gICAgYmluZDp2YWx1ZT17X3ZhbHVlfVxuICAgIHtmaWVsZG5hbWV9XG4gICAgb25jaGFuZ2U9e2RlbGF5ZWRPbkNoYW5nZX1cbiAgICB7cmVhY3RPbn1cbiAgICB7dmFsaWR9XG4gICAge2NvbG9yfVxuICAgIHsuLi5vdGhlcnN9XG4vPlxuIiwiY2xhc3MgTGliIHtcbiAgICAjbGliID0ge307XG5cbiAgICBjb25zdHJ1Y3RvcihzZWVkTGliKSB7XG4gICAgICAgIGlmIChzZWVkTGliIGluc3RhbmNlb2YgTGliKSB7XG4gICAgICAgICAgICB0aGlzLmltcG9ydChzZWVkTGliLmdldENvbnRlbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbXMge3N0cmluZ30gIG1vZGUgd2hhdCB0byBkbyBpZiBlbGVtZW50IGV4aXN0cyBbcmVwbGFjZXxhZGR8c2tpcF1cbiAgICAgKi9cbiAgICBhZGQobmFtZSwgY29tcCwgbW9kZSA9IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsaWJbbmFtZV0gPSBjb21wO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImFkZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbGliW25hbWVdID0gT2JqZWN0LmFzc2lnbih0aGlzLiNsaWJbbmFtZV0sIGNvbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbGliW25hbWVdID0gY29tcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNsaWJbbmFtZV07XG4gICAgfVxuXG4gICAgY29udGFpbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bih0aGlzLiNsaWIsIG5hbWUpO1xuICAgIH1cblxuICAgIGltcG9ydChidWxrLCBtb2RlID0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgZm9yIChsZXQgZiBpbiBidWxrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChmLCBidWxrW2ZdLCBtb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiNsaWIpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBnZXRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy4jbGliLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGliO1xuIiwiLypcbiAqINCR0LjQsdC70LjQvtGC0LXQutCwIFVJINC60L7QvdGB0YLRgNGD0LrRgtC+0YDQvtCyXG4gKi9cblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IExpYiBmcm9tIFwiLi9saWIubWpzXCI7XG5cbmNvbnN0IENPTVBPTkVOVFMgPSBuZXcgTGliKCk7XG5jb25zdCBGSUVMRFMgPSBuZXcgTGliKCk7XG5jb25zdCBWQVJJQU5UUyA9IG5ldyBMaWIoKTtcblxuZXhwb3J0IHsgQ09NUE9ORU5UUywgRklFTERTLCBWQVJJQU5UUyB9O1xuIiwiPHNjcmlwdD5cbiAgICAvKiBlc2xpbnQgc3ZlbHRlL25vLWF0LWh0bWwtdGFnczogMCAqL1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZCA9IGB0aXRsZS0ke01hdGgucmFuZG9tKCl9YF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdGl0bGUgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc3VidGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3NpemUgPSAxXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtzdWJzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtzcGFjZWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbYWxpZ24gPSAnbGVmdCddXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gYHRpdGxlLSR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIHN1YnRpdGxlLFxuICAgICAgICBzaXplID0gMSxcbiAgICAgICAgc3Vic2l6ZSxcbiAgICAgICAgc3BhY2VkID0gZmFsc2UsXG4gICAgICAgIGFsaWduID0gXCJsZWZ0XCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZXhwb3J0IGNvbnN0IHNjcm9sbFRvVG9wID0gKG9wdGlvbnMgPSBVSUNvbW1vbi5TQ1JPTExfT1BUSU9OUykgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKS5zY3JvbGxJbnRvVmlldyhvcHRpb25zKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9O1xuXG4gICAgbGV0IHNpemUyID0gJGRlcml2ZWQoXG4gICAgICAgIHN1YnNpemUgPyBzdWJzaXplIDogcGFyc2VJbnQoc2l6ZSkgPCA2ID8gcGFyc2VJbnQoc2l6ZSkgKyAxIDogc2l6ZVxuICAgICk7XG5cbiAgICBsZXQgc3BhY2VkU3R5bGUgPSAkZGVyaXZlZChzcGFjZWQgPyBcImhhcy10ZXh0LWp1c3RpZmllZFwiIDogXCJcIik7XG5cbiAgICBsZXQgcmVzdWx0VGl0bGUgPSAkZGVyaXZlZChcbiAgICAgICAgYDxoJHtzaXplfSBpZD1cIiR7aWR9XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiAke2FsaWdufTtcIiBjbGFzcz1cInRpdGxlICR7c3BhY2VkU3R5bGV9IGlzLSR7c2l6ZX1cIj4keyRMT0NBTEVbdGl0bGVdfTwvaCR7c2l6ZX0+YFxuICAgICk7XG4gICAgbGV0IHJlc3VsdFN1YnRpdGxlID0gJGRlcml2ZWQoXG4gICAgICAgIGA8aCR7c2l6ZTJ9IGlkPVwiJHtpZH1cIiBzdHlsZT1cInRleHQtYWxpZ246ICR7YWxpZ259O1wiIGNsYXNzPVwic3VidGl0bGUgaXMtJHtzaXplMn1cIj4keyRMT0NBTEVbc3VidGl0bGVdfTwvaCR7c2l6ZTJ9PmBcbiAgICApO1xuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGV9XG4gICAge0BodG1sIHJlc3VsdFRpdGxlfVxuey9pZn1cblxueyNpZiBzdWJ0aXRsZX1cbiAgICB7QGh0bWwgcmVzdWx0U3VidGl0bGV9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSAgICBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0aXRsZSA9IFwibm90LW5vZGU6ZW1wdHlfbGlzdF9wbGFjZWhvbGRlclwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtzaXplID0gNF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbYWxpZ24gPSAnY2VudGVyJ11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIFByb3BzXG4gICAgICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIm5vdC1ub2RlOmVtcHR5X2xpc3RfcGxhY2Vob2xkZXJcIixcbiAgICAgICAgc2l6ZSA9IDQsXG4gICAgICAgIGFsaWduID0gXCJjZW50ZXJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxVSVRpdGxlIHt0aXRsZX0ge3NpemV9IHthbGlnbn0gey4uLm90aGVyc30gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSAtIGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2hyZWZdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGRvd25sb2FkXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YXJnZXRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHJlbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpZ2h0XSAtIHZpc3VhbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmFpc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dGxpbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdW5kZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnV0dG9uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl0gLSBpY29uc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICB1cmwgPSBcIlwiLFxuICAgICAgICBocmVmID0gXCJcIixcbiAgICAgICAgZG93bmxvYWQsXG4gICAgICAgIHRhcmdldCA9IFwiX2JsYW5rXCIsXG4gICAgICAgIHJlbCxcbiAgICAgICAgbGlnaHQgPSBmYWxzZSxcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlLFxuICAgICAgICByYWlzZWQgPSBmYWxzZSxcbiAgICAgICAgb3V0bGluZWQgPSBmYWxzZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcm91bmRlZCA9IGZhbHNlLFxuICAgICAgICBidXR0b24gPSB0cnVlLFxuICAgICAgICBzdGF0ZTogYWN0aXZlU3RhdGUgPSBcIlwiLFxuICAgICAgICB0eXBlID0gXCJcIixcbiAgICAgICAgY29sb3IgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBpY29uLFxuICAgICAgICBpY29uU2lkZSA9IFwicmlnaHRcIixcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IHNpZGVJY29uKCl9XG4gICAgPHNwYW4gY2xhc3M9XCJpY29uXCJcbiAgICAgICAgPjxpIGNsYXNzPVwiZmFzIGZhLXtpY29ufSB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiPjwvaT48L3NwYW5cbiAgICA+XG57L3NuaXBwZXR9XG5cbjxhXG4gICAgb25jbGljaz17YWN0aW9uIHx8IG9uY2xpY2t9XG4gICAgaHJlZj17dXJsIHx8IGhyZWZ9XG4gICAge3RhcmdldH1cbiAgICB7ZG93bmxvYWR9XG4gICAge3JlbH1cbiAgICBjbGFzcz1cIntjbGFzc2VzfSB7YWN0aXZlU3RhdGUgPyBgaXMtJHthY3RpdmVTdGF0ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgOiAnJ30ge3R5cGUgPyBgaXMtJHt0eXBlfWAgOiAnJ30ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIlxuICAgIGNsYXNzOmJ1dHRvblxuICAgIGNsYXNzOmlzLWxpZ2h0PXtsaWdodH1cbiAgICBjbGFzczppcy1pbnZlcnRlZD17aW52ZXJ0ZWR9XG4gICAgY2xhc3M6aXMtb3V0bGluZWQ9e291dGxpbmVkfVxuICAgIGNsYXNzOmlzLXJhaXNlZD17cmFpc2VkfVxuICAgIGNsYXNzOmlzLXJvdW5kZWQ9e3JvdW5kZWR9XG4gICAgY2xhc3M6aXMtbG9hZGluZz17bG9hZGluZ31cbj5cbiAgICB7I2lmIGljb259XG4gICAgICAgIHsjaWYgaWNvblNpZGUgPT09IFwibGVmdFwifXtAcmVuZGVyIHNpZGVJY29uKCl9ey9pZn1cbiAgICAgICAgeyNpZiB0aXRsZX08c3Bhbj57JExPQ0FMRVt0aXRsZV19PC9zcGFuPnsvaWZ9XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJyaWdodFwifXtAcmVuZGVyIHNpZGVJY29uKCl9ey9pZn1cbiAgICB7OmVsc2V9eyRMT0NBTEVbdGl0bGVdfXtAcmVuZGVyIGNoaWxkcmVuPy4oKX17L2lmfVxuPC9hPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMaW5rIGZyb20gXCIuL3VpLmxpbmsuc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgW3ZhbHVlcz1bXV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzZXM9JyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2VudGVyZWQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbam9pbmVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2l0ZW1zUHJvcHMgPSB7fV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgam9pbmVkID0gdHJ1ZSxcbiAgICAgICAgaXRlbXNQcm9wcyA9IHt9LFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgbGlzdExpbmtzKCl9XG4gICAgeyNlYWNoIHZhbHVlcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgPFVJTGluayB7Li4uaXRlbX0gey4uLml0ZW1zUHJvcHN9IC8+XG4gICAgey9lYWNofVxuey9zbmlwcGV0fVxuXG57I2lmIGpvaW5lZH1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiZmllbGQgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICA+XG4gICAgICAgIDxwIGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAge0ByZW5kZXIgbGlzdExpbmtzKCl9XG4gICAgICAgIDwvcD5cbiAgICA8L2Rpdj5cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiYnV0dG9ucyB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICA+XG4gICAgICAgIHtAcmVuZGVyIGxpc3RMaW5rcygpfVxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpbmtzIGZyb20gXCIuLi9saW5rL3VpLmxpbmtzLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNsaWNrYWJsZURpdiBmcm9tIFwiLi4vYmxvY2svdWkuY2xpY2thYmxlLmRpdi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgaW5kZXhcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R9IHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBkZXNjcmlwdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IFthY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpbmtzID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpc3RBY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpc3RMaW5rcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbW1vbkNsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBbaW1hZ2UgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gdmFsdWUgLSB2YWx1ZSBvZiBpdGVtLCB3aWxsIGJlIHBhc3NlZCB0byBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bWJlcn0gW2luZGV4ID0gLTFdIC0gaW5kZXggaW4gYXJyYXkgMC1sZW5ndGhcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmaXJzdCA9IGZhbHNlXSAtIGlmIGZpcnN0XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGFzdCA9IGZhbHNlXSAtIGlmIGxhc3RcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlXSAtIGN1c3RvbWl6YXRpb25cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbWFnZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW2ltYWdlQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja1RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrRGVzY3JpcHRpb25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja0NvbnRlbnRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgICBsaW5rcyA9IFtdLFxuICAgICAgICBsaXN0QWN0aW9ucyA9IFtdLFxuICAgICAgICBsaXN0TGlua3MgPSBbXSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjb21tb25DbGFzcyA9IFwiXCIsXG4gICAgICAgIGltYWdlID0gXCJcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGZpcnN0ID0gZmFsc2UsXG4gICAgICAgIGxhc3QgPSBmYWxzZSxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50OiBVSUxpc3RJdGVtQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgdGl0bGVSZW5kZXJlcixcbiAgICAgICAgdGl0bGVDb21wb25lbnQ6IFVJVGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA2IH0sXG4gICAgICAgIGRlc2NyaXB0aW9uUmVuZGVyZXIsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50OiBVSURlc2NyaXB0aW9uQ29tcG9uZW50LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGltYWdlUmVuZGVyZXIsXG4gICAgICAgIGltYWdlQ29tcG9uZW50OiBVSUltYWdlQ29tcG9uZW50LFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIG9uY2xpY2tJbWFnZSxcbiAgICAgICAgb25jbGlja0NvbnRlbnQsXG4gICAgICAgIG9uY2xpY2tUaXRsZSxcbiAgICAgICAgb25jbGlja0Rlc2NyaXB0aW9uLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgIG9uY2xpY2sgJiYgb25jbGljayh2YWx1ZSk7XG4gICAgfVxuXG4gICAgbGV0IGFsbEFjdGlvbnMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBhbGxMaW5rcyA9ICRzdGF0ZShbXSk7XG5cbiAgICBjb25zdCBjYWxsYmFja1RlbXBsYXRlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgYWxsQWN0aW9ucyA9IFsuLi5hY3Rpb25zLCAuLi5saXN0QWN0aW9uc10ubWFwKChidG4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmJ0bixcbiAgICAgICAgICAgICAgICBpZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBidG4uYWN0aW9uID8gKCkgPT4gYnRuLmFjdGlvbih2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBhbGxMaW5rcyA9IFsuLi5saW5rcywgLi4ubGlzdExpbmtzXS5tYXAoKGxpbmssIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsaW5rLmlkID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbGluaztcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwYXJhbXNTZXQgPSB7IHRpdGxlLCBkZXNjcmlwdGlvbiwgaW1hZ2UsIHZhbHVlLCBpbmRleCB9O1xuXG4gICAgY29uc3QgY2xpY2thYmxlSXRlbUVsZW1lbnRBdHRyaWJ1dGVzID0ge1xuICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICB0YWJpbmRleDogXCIwXCIsXG4gICAgICAgIG9uY2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgIG9ua2V5dXA6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLmtleSA9PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGFkZGl0aW9uYWxFbGVtZW50QXR0cmlidXRlcyA9IG9uY2xpY2tcbiAgICAgICAgPyBjbGlja2FibGVJdGVtRWxlbWVudEF0dHJpYnV0ZXNcbiAgICAgICAgOiB7fTtcblxuICAgIGxldCBpbWFnZVByb3BzID0gJHN0YXRlKHt9KTtcbiAgICBsZXQgdGl0bGVQcm9wcyA9ICRzdGF0ZSh7fSk7XG4gICAgbGV0IGRlc2NyaXB0aW9uUHJvcHMgPSAkc3RhdGUoe30pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGltYWdlUHJvcHMgPSB7IC4uLmltYWdlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWFnZVByb3BzID0geyBpbWFnZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGl0bGVQcm9wcyA9IHsgLi4udGl0bGUgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlUHJvcHMgPSB7IHRpdGxlIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvblByb3BzID0geyAuLi5kZXNjcmlwdGlvbiB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25Qcm9wcyA9IHsgZGVzY3JpcHRpb24gfTtcbiAgICAgICAgfVxuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjc25pcHBldCBpdGVtQ29udGVudCgpfVxuICAgIHsjaWYgdGl0bGVSZW5kZXJlcn1cbiAgICAgICAge0ByZW5kZXIgdGl0bGVSZW5kZXJlcihwYXJhbXNTZXQpfVxuICAgIHs6ZWxzZSBpZiB0aXRsZX1cbiAgICAgICAgPFVJQ2xpY2thYmxlRGl2XG4gICAgICAgICAgICBjbGFzcz1cImxpc3QtaXRlbS10aXRsZVwiXG4gICAgICAgICAgICBjYWxsYmFjaz17Y2FsbGJhY2tUZW1wbGF0ZShvbmNsaWNrVGl0bGUpfVxuICAgICAgICA+XG4gICAgICAgICAgICB7I2lmIFVJVGl0bGVDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgPFVJVGl0bGVDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgey4uLnRpdGxlUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHsuLi50aXRsZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgICAgICB7b25jaGFuZ2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHs6ZWxzZX17dGl0bGV9ey9pZn1cbiAgICAgICAgPC9VSUNsaWNrYWJsZURpdj5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBkZXNjcmlwdGlvblJlbmRlcmVyfVxuICAgICAgICB7QHJlbmRlciBkZXNjcmlwdGlvblJlbmRlcmVyKHBhcmFtc1NldCl9XG4gICAgezplbHNlIGlmIGRlc2NyaXB0aW9ufVxuICAgICAgICA8VUlDbGlja2FibGVEaXZcbiAgICAgICAgICAgIGNsYXNzPVwibGlzdC1pdGVtLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgIGNhbGxiYWNrPXtjYWxsYmFja1RlbXBsYXRlKG9uY2xpY2tEZXNjcmlwdGlvbil9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgVUlEZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICA8VUlEZXNjcmlwdGlvbkNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICB7Li4uZGVzY3JpcHRpb25Qcm9wc31cbiAgICAgICAgICAgICAgICAgICAgey4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHtvbmNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAge29uY2xpY2t9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHs6ZWxzZX17ZGVzY3JpcHRpb259ey9pZn1cbiAgICAgICAgPC9VSUNsaWNrYWJsZURpdj5cbiAgICB7L2lmfVxuey9zbmlwcGV0fVxuXG48ZGl2XG4gICAgey4uLmFkZGl0aW9uYWxFbGVtZW50QXR0cmlidXRlc31cbiAgICBjbGFzczppcy1jbGlja2FibGU9e29uY2xpY2t9XG4gICAgY2xhc3M6bGlzdC1pdGVtLWxhc3Q9e2xhc3R9XG4gICAgY2xhc3M6bGlzdC1pdGVtLWZpcnN0PXtmaXJzdH1cbiAgICBjbGFzczpsaXN0LWl0ZW0tb2RkPXtpbmRleCAlIDIgPT09IDF9XG4gICAgY2xhc3M6bGlzdC1pdGVtLWV2ZW49e2luZGV4ICUgMiA9PT0gMH1cbiAgICBjbGFzcz1cImxpc3QtaXRlbSB7Y2xhc3Nlc30ge2NvbW1vbkNsYXNzfSB7YGxpc3QtaXRlbS1hdC0ke2luZGV4fWB9XCJcbj5cbiAgICB7I2lmIGltYWdlfVxuICAgICAgICB7I2lmIGltYWdlUmVuZGVyZXJ9XG4gICAgICAgICAgICB7QHJlbmRlciBpbWFnZVJlbmRlcmVyKHBhcmFtc1NldCl9XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxVSUNsaWNrYWJsZURpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwibGlzdC1pdGVtLWltYWdlXCJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaz17Y2FsbGJhY2tUZW1wbGF0ZShvbmNsaWNrSW1hZ2UpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsjaWYgVUlJbWFnZUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgPFVJSW1hZ2VDb21wb25lbnQgey4uLmltYWdlUHJvcHN9IC8+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVwiaW1hZ2UgaXMtNjR4NjRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlzLXJvdW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17aW1hZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PXt0aXRsZSA/IHRpdGxlPy50aXRsZSB8fCB0aXRsZSA6IGltYWdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9maWd1cmU+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvVUlDbGlja2FibGVEaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgey9pZn1cblxuICAgIHsjaWYgVUlMaXN0SXRlbUNvbnRlbnRDb21wb25lbnR9XG4gICAgICAgIDxVSUxpc3RJdGVtQ29udGVudENvbXBvbmVudCB7Li4ubGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHN9PlxuICAgICAgICAgICAge0ByZW5kZXIgaXRlbUNvbnRlbnQoKX1cbiAgICAgICAgPC9VSUxpc3RJdGVtQ29udGVudENvbXBvbmVudD5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxVSUNsaWNrYWJsZURpdlxuICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0tY29udGVudFwiXG4gICAgICAgICAgICBjYWxsYmFjaz17Y2FsbGJhY2tUZW1wbGF0ZShvbmNsaWNrQ29udGVudCl9XG4gICAgICAgID5cbiAgICAgICAgICAgIHtAcmVuZGVyIGl0ZW1Db250ZW50KCl9PC9VSUNsaWNrYWJsZURpdlxuICAgICAgICA+XG4gICAgey9pZn1cblxuICAgIHsjaWYgKGFsbEFjdGlvbnMgJiYgYWxsQWN0aW9ucy5sZW5ndGgpIHx8IChhbGxMaW5rcyAmJiBhbGxMaW5rcy5sZW5ndGgpfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdC1pdGVtLWNvbnRyb2xzXCI+XG4gICAgICAgICAgICB7I2lmIGFsbEFjdGlvbnMgJiYgYWxsQWN0aW9ucy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e2FsbEFjdGlvbnN9IHJpZ2h0PXt0cnVlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgYWxsTGlua3MgJiYgYWxsTGlua3MubGVuZ3RofVxuICAgICAgICAgICAgICAgIDxVSUxpbmtzIHZhbHVlcz17YWxsTGlua3N9IHJpZ2h0PXt0cnVlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMaXN0SXRlbSBmcm9tIFwiLi91aS5saXN0Lml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZEZpZWxkTmFtZSA9IFwiaWRcIl1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICBbaXRlbXMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICBbYWN0aW9ucyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIFtsaW5rcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpdGVtQ2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtsaXN0SXRlbUNvbnRlbnRDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2xpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2xpc3RJdGVtUmVuZGVyZXJdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2xpc3RJdGVtQ29tcG9uZW50ID0gVUlMaXN0SXRlbV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbbGlzdEl0ZW1Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZVJlbmRlcmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW3RpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDYgfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25SZW5kZXJlcl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25Db21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW1hZ2VSZW5kZXJlcl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBpbWFnZUNvbXBvbmVudFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtpbWFnZUNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tDb250ZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrRGVzY3JpcHRpb25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja1RpdGxlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZEZpZWxkTmFtZSA9IFwiaWRcIixcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgICBsaW5rcyA9IFtdLFxuICAgICAgICBpdGVtQ2xhc3MgPSBcIlwiLFxuICAgICAgICBsaXN0SXRlbUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIGxpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RJdGVtUmVuZGVyZXIsXG4gICAgICAgIGxpc3RJdGVtQ29tcG9uZW50OiBVSUxpc3RJdGVtQ29tcG9uZW50ID0gVUlMaXN0SXRlbSxcbiAgICAgICAgbGlzdEl0ZW1Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICB0aXRsZVJlbmRlcmVyLFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDYgfSxcbiAgICAgICAgZGVzY3JpcHRpb25SZW5kZXJlcixcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnQsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgaW1hZ2VSZW5kZXJlcixcbiAgICAgICAgaW1hZ2VDb21wb25lbnQsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25jbGlja0NvbnRlbnQsXG4gICAgICAgIG9uY2xpY2tEZXNjcmlwdGlvbixcbiAgICAgICAgb25jbGlja0ltYWdlLFxuICAgICAgICBvbmNsaWNrVGl0bGUsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXN9XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0sIGluZGV4IChpdGVtW2lkRmllbGROYW1lXSl9XG4gICAgICAgIHsjaWYgbGlzdEl0ZW1SZW5kZXJlcn1cbiAgICAgICAgICAgIHtAcmVuZGVyIGxpc3RJdGVtUmVuZGVyZXIoaXRlbSwgaW5kZXgpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8VUlMaXN0SXRlbUNvbXBvbmVudFxuICAgICAgICAgICAgICAgIHsuLi5saXN0SXRlbUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHtsaXN0SXRlbUNvbnRlbnRDb21wb25lbnR9XG4gICAgICAgICAgICAgICAge2xpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHt0aXRsZVJlbmRlcmVyfVxuICAgICAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb25SZW5kZXJlcn1cbiAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgICAgICAgICAgICAge2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAge2ltYWdlUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5pdGVtc1tpbmRleF19XG4gICAgICAgICAgICAgICAgbGlzdEFjdGlvbnM9e2FjdGlvbnN9XG4gICAgICAgICAgICAgICAgbGlzdExpbmtzPXtsaW5rc31cbiAgICAgICAgICAgICAgICB2YWx1ZT17aXRlbXNbaW5kZXhdLnZhbHVlfVxuICAgICAgICAgICAgICAgIGNvbW1vbkNsYXNzPXtpdGVtQ2xhc3N9XG4gICAgICAgICAgICAgICAge2luZGV4fVxuICAgICAgICAgICAgICAgIGZpcnN0PXtpbmRleCA9PT0gMH1cbiAgICAgICAgICAgICAgICBsYXN0PXtpbmRleCA9PT0gaXRlbXMubGVuZ3RoIC0gMX1cbiAgICAgICAgICAgICAgICB7b25jbGlja31cbiAgICAgICAgICAgICAgICB7b25jbGlja0NvbnRlbnR9XG4gICAgICAgICAgICAgICAge29uY2xpY2tEZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICB7b25jbGlja0ltYWdlfVxuICAgICAgICAgICAgICAgIHtvbmNsaWNrVGl0bGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxpc3RFbXB0eVBsYWNlaG9sZGVyIGZyb20gXCIuL3VpLmxpc3QuZW1wdHkucGxhY2Vob2xkZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlzdEl0ZW0gZnJvbSBcIi4vdWkubGlzdC5pdGVtLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpc3RCbG9jayBmcm9tIFwiLi91aS5saXN0LmJsb2NrLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuXG4gICAgLy9jdXN0b21pemF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IFtpdGVtcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IFthY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpbmtzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWN0aW9uc1Zpc2libGUgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpdGVtc0hvdmVyYWJsZSA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJmbG93RWxsaXBzaXMgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtoaWRkZW5JbWFnZXMgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2l0ZW1DbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVtTGVuZ3RoXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZEZpZWxkTmFtZSA9ICdpZCddXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2VtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50ID0gVUlMaXN0RW1wdHlQbGFjZWhvbGRlcl0gLSBlbXB0eVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtsaXN0SXRlbUNvbXBvbmVudCA9IFVJTGlzdEl0ZW1dIC0gaXRlbVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbbGlzdEl0ZW1Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdIC0gaXRlbSBwYXJ0c1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdGl0bGVDb21wb25lbnRQcm9wcyA9IHtzaXplOiA2fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25Db21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2ltYWdlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbaW1hZ2VDb21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNoYW5nZV0gICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXSAgICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrQ29udGVudF0gICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrRGVzY3JpcHRpb25dICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrSW1hZ2VdICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrVGl0bGVdICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgYWN0aW9uc1Zpc2libGUgPSBmYWxzZSxcbiAgICAgICAgaXRlbXNIb3ZlcmFibGUgPSBmYWxzZSxcbiAgICAgICAgb3ZlcmZsb3dFbGxpcHNpcyA9IGZhbHNlLFxuICAgICAgICBoaWRkZW5JbWFnZXMgPSBmYWxzZSxcbiAgICAgICAgaXRlbUNsYXNzID0gXCJcIixcbiAgICAgICAgaXRlbUxlbmd0aCxcbiAgICAgICAgaWRGaWVsZE5hbWUgPSBcImlkXCIsXG4gICAgICAgIGVtcHR5TGlzdFJlbmRlcmVyLFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudDpcbiAgICAgICAgICAgIFVJRW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnQgPSBVSUxpc3RFbXB0eVBsYWNlaG9sZGVyLFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RJdGVtQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdEl0ZW1SZW5kZXJlcixcbiAgICAgICAgbGlzdEl0ZW1Db21wb25lbnQgPSBVSUxpc3RJdGVtLFxuICAgICAgICBsaXN0SXRlbUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIHRpdGxlUmVuZGVyZXIsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50ID0gVUlUaXRsZSxcbiAgICAgICAgdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNiB9LFxuICAgICAgICBkZXNjcmlwdGlvblJlbmRlcmVyLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBpbWFnZVJlbmRlcmVyLFxuICAgICAgICBpbWFnZUNvbXBvbmVudCxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBvbmNoYW5nZSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25jbGlja0NvbnRlbnQsXG4gICAgICAgIG9uY2xpY2tEZXNjcmlwdGlvbixcbiAgICAgICAgb25jbGlja0ltYWdlLFxuICAgICAgICBvbmNsaWNrVGl0bGUsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXMubGVuZ3RofVxuICAgIDxkaXZcbiAgICAgICAgc3R5bGU9e2l0ZW1MZW5ndGggPyBgLS1sZW5ndGg6ICR7aXRlbUxlbmd0aH07YCA6IFwiXCJ9XG4gICAgICAgIGNsYXNzPVwibGlzdCB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczpoYXMtdmlzaWJsZS1wb2ludGVyLWNvbnRyb2xzPXthY3Rpb25zVmlzaWJsZX1cbiAgICAgICAgY2xhc3M6aGFzLWhvdmVyYWJsZS1saXN0LWl0ZW1zPXtpdGVtc0hvdmVyYWJsZX1cbiAgICAgICAgY2xhc3M6aGFzLW92ZXJmbG93LWVsbGlwc2lzPXtvdmVyZmxvd0VsbGlwc2lzfVxuICAgICAgICBjbGFzczpoYXMtaGlkZGVuLWltYWdlcz17aGlkZGVuSW1hZ2VzfVxuICAgID5cbiAgICAgICAgPFVJTGlzdEJsb2NrXG4gICAgICAgICAgICB7aXRlbXN9XG4gICAgICAgICAgICB7aXRlbUNsYXNzfVxuICAgICAgICAgICAge2xpc3RJdGVtQ29udGVudENvbXBvbmVudH1cbiAgICAgICAgICAgIHtsaXN0SXRlbUNvbnRlbnRDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtsaXN0SXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAge2xpc3RJdGVtQ29tcG9uZW50fVxuICAgICAgICAgICAge2xpc3RJdGVtQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7aWRGaWVsZE5hbWV9XG4gICAgICAgICAgICB7dGl0bGVSZW5kZXJlcn1cbiAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2Rlc2NyaXB0aW9uUmVuZGVyZXJ9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtpbWFnZVJlbmRlcmVyfVxuICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7YWN0aW9uc31cbiAgICAgICAgICAgIHtsaW5rc31cbiAgICAgICAgICAgIHtvbmNoYW5nZX1cbiAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAge29uY2xpY2tDb250ZW50fVxuICAgICAgICAgICAge29uY2xpY2tEZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIHtvbmNsaWNrSW1hZ2V9XG4gICAgICAgICAgICB7b25jbGlja1RpdGxlfVxuICAgICAgICAvPlxuICAgIDwvZGl2PlxuezplbHNlIGlmIGVtcHR5TGlzdFJlbmRlcmVyfVxuICAgIHtAcmVuZGVyIGVtcHR5TGlzdFJlbmRlcmVyKGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHMpfVxuezplbHNlfVxuICAgIDxVSUVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50IHsuLi5lbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzfSAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi9mcmFtZS9MSUIuanNcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb24uanNcIjtcbiAgICBpbXBvcnQgVUlMaXN0IGZyb20gXCIuLi9saXN0L3VpLmxpc3Quc3ZlbHRlXCI7XG5cbiAgICAvL2ZpZWxkIHByb3BzXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lucHV0U3RhcnRlZF0gLSBzdmVsdGUtaWdub3JlIHVudXNlZC1leHBvcnQtbGV0XG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211bHRpcGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZF0gLSB2YWxpZGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Vycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtRXJyb3JzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zvcm1MZXZlbEVycm9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbW9kZWxOYW1lXSAtIG1vZGVsIGJpbmRpbmdzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpb25OYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uRmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uU29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uUGFnZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25TZWFyY2hdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25JZF0gLSBwcmVzZW50YXRpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvblRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JVSV0gLSBzZWxlY3RvciBVSSB0byBhZGQgbmV3IGl0ZW0gdG8gbGlzdFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VsZWN0b3JVSVByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaXRlbVVJXSAtIGxpc3QgaXRlbSBVSSB0byBwcmVzZW50IGluIHJlYWRvbmx5IG9yIGVkaXRhYmxlIHZhcmlhbnRzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtVUlQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RyYW5zZm9ybVZhbHVlSXRlbVRvTGlzdEl0ZW1dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gW10sXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWxlY3RGcm9tTW9kZWxcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBtdWx0aXBsZSA9IGZhbHNlLFxuICAgICAgICBzaXplID0gOCxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBtb2RlbE5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25OYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uRmlsdGVyID0ge30sXG4gICAgICAgIGFjdGlvblNvcnRlciA9IHt9LFxuICAgICAgICBhY3Rpb25QYWdlciA9IHt9LFxuICAgICAgICBhY3Rpb25TZWFyY2ggPSB1bmRlZmluZWQsXG4gICAgICAgIG9wdGlvbklkID0gXCI6X2lkXCIsXG4gICAgICAgIG9wdGlvblRpdGxlID0gXCI6dGl0bGVcIixcbiAgICAgICAgc2VsZWN0b3JVSSA9IFwiVUlTZWxlY3RGcm9tTW9kZWxPbkRlbWFuZElubGluZVwiLFxuICAgICAgICBzZWxlY3RvclVJUHJvcHMgPSB7fSxcbiAgICAgICAgaXRlbVVJID0gXCJVSUxpc3RJdGVtXCIsXG4gICAgICAgIGl0ZW1VSVByb3BzID0ge30sXG4gICAgICAgIHRyYW5zZm9ybVZhbHVlSXRlbVRvTGlzdEl0ZW0gPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGl0ZW1zID0gJHN0YXRlKFtdKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWx1ZVRvSXRlbXMgPSAodmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwubWFwKHRyYW5zZm9ybVZhbHVlSXRlbVRvTGlzdEl0ZW0pIDogW107XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFkZEl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoJHN0YXRlLnNuYXBzaG90KHZhbHVlKSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUucHVzaChpdGVtKTtcblxuICAgICAgICBpdGVtcyA9IHRyYW5zZm9ybVZhbHVlVG9JdGVtcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0SXRlbUluZGV4SW5WYWx1ZSA9IChsaXN0SXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUuZmluZEluZGV4KCh2YWx1ZUl0ZW0pID0+IHZhbHVlSXRlbS5pZCA9PT0gbGlzdEl0ZW0uaWQpO1xuICAgIH07XG5cbiAgICBjb25zdCBBQ1RJT05TID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb24obGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBnZXRJdGVtSW5kZXhJblZhbHVlKGxpc3RJdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsQ29weSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5tb3ZlSXRlbSh2YWxDb3B5LCBpdGVtSW5kZXgsIGl0ZW1JbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbENvcHk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdHJhbnNmb3JtVmFsdWVUb0l0ZW1zKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICBpY29uOiBcImFycm93LXVwXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJub3JtYWxcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAobGlzdEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSW5kZXggPSBnZXRJdGVtSW5kZXhJblZhbHVlKGxpc3RJdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsQ29weSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5tb3ZlSXRlbSh2YWxDb3B5LCBpdGVtSW5kZXgsIGl0ZW1JbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbENvcHk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdHJhbnNmb3JtVmFsdWVUb0l0ZW1zKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICBpY29uOiBcImFycm93LWRvd25cIixcbiAgICAgICAgICAgIGNvbG9yOiBcIm5vcm1hbFwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246IChsaXN0SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IGdldEl0ZW1JbmRleEluVmFsdWUobGlzdEl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zcGxpY2UoaXRlbUluZGV4LCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IHRyYW5zZm9ybVZhbHVlVG9JdGVtcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICAgICAgaWNvbjogXCJ0cmFzaFwiLFxuICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgIH0sXG4gICAgXTtcbjwvc2NyaXB0PlxuXG48VUlMaXN0XG4gICAgbGlzdEl0ZW1Db21wb25lbnQ9e0NPTVBPTkVOVFMuZ2V0KGl0ZW1VSSl9XG4gICAgey4uLml0ZW1VSVByb3BzfVxuICAgIHtpdGVtc31cbiAgICBhY3Rpb25zPXtBQ1RJT05TfVxuLz5cbnsjaWYgIXJlYWRvbmx5fVxuICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoc2VsZWN0b3JVSSl9XG4gICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICB7Li4uc2VsZWN0b3JVSVByb3BzfVxuICAgICAgICB7bW9kZWxOYW1lfVxuICAgICAgICB7YWN0aW9uTmFtZX1cbiAgICAgICAge2FjdGlvbkZpbHRlcn1cbiAgICAgICAge2FjdGlvblNvcnRlcn1cbiAgICAgICAge2FjdGlvblBhZ2VyfVxuICAgICAgICB7YWN0aW9uU2VhcmNofVxuICAgICAgICB7b3B0aW9uSWR9XG4gICAgICAgIHtvcHRpb25UaXRsZX1cbiAgICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIG11bHRpcGxlPXtmYWxzZX1cbiAgICAgICAge3ZhbGlkfVxuICAgICAgICBvbnJlc29sdmU9eyhlKSA9PiBhZGRJdGVtKGUudmFsdWUpfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbmFycm93PWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBzaXplXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBzaXplLFxuICAgICAgICBuYXJyb3cgPSBmYWxzZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJjb2x1bW4ge2NsYXNzZXN9IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCJcbiAgICBjbGFzczppcy1uYXJyb3c9e25hcnJvd31cbiAgICB7Li4ub3RoZXJzfVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLCBjaGlsZHJlbiwgLi4ub3RoZXJzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiY29sdW1ucyB7Y2xhc3Nlc31cIiB7Li4ub3RoZXJzfT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGUgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleD0wXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dpZGVzY3JlZW49ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZnVsbGhkPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21heERlc2t0b3A9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbWF4V2lkZXNjcmVlbj1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmbHVpZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IFwiMFwiLFxuICAgICAgICB3aWRlc2NyZWVuID0gZmFsc2UsXG4gICAgICAgIGZ1bGxoZCA9IGZhbHNlLFxuICAgICAgICBtYXhEZXNrdG9wID0gZmFsc2UsXG4gICAgICAgIG1heFdpZGVzY3JlZW4gPSBmYWxzZSxcbiAgICAgICAgZmx1aWQgPSBmYWxzZSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICB7aWR9XG4gICAge3RpdGxlfVxuICAgIGNsYXNzPVwiY29udGFpbmVyIHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6aXMtd2lkZXNjcmVlbj17d2lkZXNjcmVlbn1cbiAgICBjbGFzczppcy1mdWxsaGQ9e2Z1bGxoZH1cbiAgICBjbGFzczppcy1tYXgtZGVza3RvcD17bWF4RGVza3RvcH1cbiAgICBjbGFzczppcy1tYXgtd2lkZXNjcmVlbj17bWF4V2lkZXNjcmVlbn1cbiAgICBjbGFzczppcy1mbHVpZD17Zmx1aWR9XG4gICAge29uY2xpY2t9XG4gICAge29ua2V5dXB9XG4gICAge3JvbGV9XG4gICAge3RhYkluZGV4fVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBpZCA9IFwiXCIsIGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgY2hpbGRyZW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxmb290ZXIge2lkfSBjbGFzcz1cImZvb3RlciB7Y2xhc3Nlc30gXCI+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9mb290ZXI+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZCA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YWJJbmRleCA9IDBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IFwiMFwiLFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHNlY3Rpb24ge2lkfSBjbGFzcz1cInNlY3Rpb24ge2NsYXNzZXN9XCIge29uY2xpY2t9IHtvbmtleXVwfSB7cm9sZX0ge3RhYkluZGV4fT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L3NlY3Rpb24+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YWddXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgdGFnID0gXCJkaXZcIiwgY2hpbGRyZW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6ZWxlbWVudCB0aGlzPXt0YWd9PlxuICAgIHsjaWYgY2hpbGRyZW59e0ByZW5kZXIgY2hpbGRyZW4/LigpfXs6ZWxzZX08IS0tIG9wdGlvbmFsIGZhbGxiYWNrIC0tPnsvaWZ9XG48L3N2ZWx0ZTplbGVtZW50PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbbGVmdF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW3JpZ2h0XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBsZWZ0LCByaWdodCB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPG5hdiBjbGFzcz1cImxldmVsXCI+XG4gICAgPCEtLSBMZWZ0IHNpZGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImxldmVsLWxlZnRcIj5cbiAgICAgICAge0ByZW5kZXIgbGVmdD8uKCl9XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIFJpZ2h0IHNpZGUgLS0+XG4gICAgPGRpdiBjbGFzcz1cImxldmVsLXJpZ2h0XCI+XG4gICAgICAgIHtAcmVuZGVyIHJpZ2h0Py4oKX1cbiAgICA8L2Rpdj5cbjwvbmF2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoMCksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCIwLjBcIixcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbWF4ID0gMTAwLFxuICAgICAgICBzdGVwID0gMSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJudW1iZXJcIixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLW51bWJlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHttaW59XG4gICAgICAgIHttYXh9XG4gICAgICAgIHtzdGVwfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIGltcG9ydCB7IFVJQ29sdW1ucywgVUlDb2x1bW4gfSBmcm9tIFwiLi4vbGF5b3V0XCI7XG4gICAgaW1wb3J0IHsgVUlCdXR0b24gfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG4gICAgaW1wb3J0IFVJTnVtYmVyIGZyb20gXCIuL3VpLm51bWJlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUZXh0ZmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSVRpdGxlIH0gZnJvbSBcIi4uL3ZhcmlvdXNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZmllbGRuYW1lID0gXCJudW1iZXJzX2xpc3RcIixcbiAgICAgICAgdmFsdWUgPSB7fSxcbiAgICAgICAgZGVmYXVsdEl0ZW1UaXRsZSA9IFwiXCIsXG4gICAgICAgIGRlZmF1bHRJdGVtVmFsdWUgPSAwLFxuICAgICAgICBsYWJlbCA9IFwibmFtZWQgbnVtYmVycyBsaXN0XCIsXG4gICAgICAgIGxhYmVsU2l6ZSA9IDUsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJuZXcgaXRlbVwiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGNyZWF0ZU5ld1ZhbCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBkZWZhdWx0SXRlbVRpdGxlLFxuICAgICAgICAgICAgbnVtYmVyOiBkZWZhdWx0SXRlbVZhbHVlLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBsZXQgbmV3VmFsID0gJHN0YXRlKGNyZWF0ZU5ld1ZhbCgpKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybU9iamVjdFRvTGlzdCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IG5hbWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgbnVtYmVyOiB2YWx1ZVtuYW1lXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBsZXQgbGlzdCA9ICRzdGF0ZSh0cmFuc2Zvcm1PYmplY3RUb0xpc3QoKSk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModmFsdWUsIGlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2lkXTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBsaXN0ID0gdHJhbnNmb3JtT2JqZWN0VG9MaXN0KCk7XG4gICAgICAgICAgICBvbmNoYW5nZSh7IHZhbHVlLCBmaWVsZDogZmllbGRuYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKCkge1xuICAgICAgICBjb25zdCBpZCA9IG5ld1ZhbC5pZC50cmltKCk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KG5ld1ZhbC5udW1iZXIpO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IFwiXCIgJiYgIWlzTmFOKG51bWJlcikgJiYgIW5vdENvbW1vbi5vYmpIYXModmFsdWUsIGlkKSkge1xuICAgICAgICAgICAgdmFsdWVbaWRdID0gbnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QgPSB0cmFuc2Zvcm1PYmplY3RUb0xpc3QoKTtcbiAgICAgICAgb25jaGFuZ2UoeyB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSwgZmllbGQ6IGZpZWxkbmFtZSB9KTtcbiAgICAgICAgbmV3VmFsID0gY3JlYXRlTmV3VmFsKCk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSVRpdGxlIHRpdGxlPXtsYWJlbH0gc2l6ZT17bGFiZWxTaXplfSAvPlxueyNlYWNoIGxpc3QgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgPFVJQ29sdW1ucyBjbGFzcz17Y2xhc3Nlc30ge2Rpc2FibGVkfT5cbiAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy02XCI+XG4gICAgICAgICAgICB7aXRlbS50aXRsZX1cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy00XCI+XG4gICAgICAgICAgICB7aXRlbS5udW1iZXJ9XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgICAgIHsjaWYgIXJlYWRvbmx5fVxuICAgICAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy0yXCI+XG4gICAgICAgICAgICAgICAgPFVJQnV0dG9uIGljb249e1wibWludXNcIn0gYWN0aW9uPXsoKSA9PiByZW1vdmUoaXRlbS5pZCl9IC8+XG4gICAgICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICB7L2lmfVxuICAgIDwvVUlDb2x1bW5zPlxuey9lYWNofVxueyNpZiAhcmVhZG9ubHl9XG4gICAgPFVJQ29sdW1ucyBjbGFzcz17Y2xhc3Nlc30+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtNlwiPlxuICAgICAgICAgICAgPFVJVGV4dGZpZWxkXG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17bmV3VmFsLmlkfVxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICByZXF1aXJlZD17ZmFsc2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTRcIj5cbiAgICAgICAgICAgIDxVSU51bWJlciBiaW5kOnZhbHVlPXtuZXdWYWwubnVtYmVyfSAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTJcIj5cbiAgICAgICAgICAgIDxVSUJ1dHRvbiBpY29uPXtcInBsdXNcIn0gYWN0aW9uPXsoKSA9PiBhZGQoKX0gLz5cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICA8L1VJQ29sdW1ucz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInBhc3N3b3JkXCIsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG48aW5wdXRcbiAgICBpZD1cImZvcm0tZmllbGQtcGFzc3dvcmQte2ZpZWxkbmFtZX1cIlxuICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgbmFtZT17ZmllbGRuYW1lfVxuICAgIGJpbmQ6dmFsdWVcbiAgICB7aW52YWxpZH1cbiAgICB7cmVxdWlyZWR9XG4gICAge3JlYWRvbmx5fVxuICAgIHtkaXNhYmxlZH1cbiAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgey4uLm90aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxGdWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaW1hZ2VcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWx0XVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29ycz0nYW5vbnltb3VzJ11cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemUgPSA2NF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnRhaW5lZD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb3ZlcmVkPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50YWJsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHVybEZ1bGwsXG4gICAgICAgIHVybCxcbiAgICAgICAgaW1hZ2UsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBhbHQsXG4gICAgICAgIGNvcnMgPSBcImFub255bW91c1wiLFxuICAgICAgICBzaXplID0gNjQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNvbnRhaW5lZCA9IGZhbHNlLFxuICAgICAgICBjb3ZlcmVkID0gZmFsc2UsXG4gICAgICAgIHBvaW50YWJsZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNsaWNrID0gdW5kZWZpbmVkLFxuICAgICAgICBvbmtleXVwID0gdW5kZWZpbmVkLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgaW1hZ2VGaWd1cmUoKX1cbiAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeV9ub19ub25pbnRlcmFjdGl2ZV9lbGVtZW50X2ludGVyYWN0aW9ucyAtLT5cbiAgICA8ZmlndXJlXG4gICAgICAgIGNsYXNzPVwiaW1hZ2Uge2NsYXNzZXN9IHshd2lkdGggJiYgIWhlaWdodFxuICAgICAgICAgICAgPyBpc05hTihzaXplKVxuICAgICAgICAgICAgICAgID8gYGlzLSR7c2l6ZX1gXG4gICAgICAgICAgICAgICAgOiBgaXMtJHtzaXplfXgke3NpemV9YFxuICAgICAgICAgICAgOiAnJ31cIlxuICAgICAgICBjbGFzczppcy1jb250YWluZWQ9e2NvbnRhaW5lZH1cbiAgICAgICAgY2xhc3M6aXMtY292ZXJlZD17Y292ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtY2xpY2thYmxlPXsob25jbGljayAmJiBwb2ludGFibGUgIT09IGZhbHNlKSB8fCBwb2ludGFibGV9XG4gICAgICAgIHN0eWxlPXsod2lkdGggPyBgd2lkdGg6ICR7d2lkdGh9O2AgOiBcIlwiKSArXG4gICAgICAgICAgICAoaGVpZ2h0ID8gYGhlaWdodDogJHtoZWlnaHR9O2AgOiBcIlwiKX1cbiAgICA+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAge29ua2V5dXB9XG4gICAgICAgICAgICBjbGFzcz1cIlwiXG4gICAgICAgICAgICBhbHQ9e2FsdCB8fCB0aXRsZX1cbiAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgIHNyYz17dXJsIHx8IGltYWdlfVxuICAgICAgICAgICAgY3Jvc3NPcmlnaW49e2NvcnN9XG4gICAgICAgIC8+XG4gICAgPC9maWd1cmU+XG57L3NuaXBwZXR9XG5cbnsjaWYgdXJsRnVsbH1cbiAgICA8YSBocmVmPXt1cmxGdWxsfSB0aXRsZT17dGl0bGUgfHwgYWx0fSB7b25jbGlja30+XG4gICAgICAgIHtAcmVuZGVyIGltYWdlRmlndXJlKCl9XG4gICAgPC9hPlxuezplbHNlfVxuICAgIHtAcmVuZGVyIGltYWdlRmlndXJlKCl9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL2xpc3QvdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG5cbiAgICAvL1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhcmlhbnRzXSAtIFtcbmFycmF5IG9mIGdyb3Vwc1xue1xuaWQ6bnVtYmVyLFxudGl0bGU6c3RyaW5nfG9iamVjdCxcbmltYWdlOnN0cmluZ3xvYmplY3QsXG52YXJpYW50cyA9IFtcbmFycmF5IG9mIHZhbHVlcyB2YXJpYW50cyBpbiBncm91cFxue1xuaWQ6bnVtYmVyLFxudGl0bGU6c3RyaW5nfG9iamVjdCxcbmRlc2NyaXB0aW9uOnN0cmluZ3xvYmplY3QsXG5pbWFnZTpzdHJpbmd8b2JqZWN0LFxudmFsdWU6b2JqZWN0XG59XVxufVxuXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZSAtIG11bHRpcGxlICYmIG11bHRpcGxlIGluIGdyb3VwXG57XG5hcnJheSBvZiBhcnJheXMgb2Ygc2VsZWN0ZWQgdmFsdWVzIGluIGdyb3VwXG5pZiBubyBzZWxlY3Rpb24gZ3JvdXAgc2hvdWxkIGJlIGVtcHR5IGFycmF5XG5bZ3JvdXBJZF06IFsuLi52YXJpYW50c0lkXVxufVxubXVsdGlwbGUgJiYgb25lIGluIGdyb3VwXG57XG5bZ3JvdXBJZF06IHZhcmlhbnRJZFxufVxub25seSBvbmUgKG5vdCBtdWx0aXBsZSAmJiBvbmUgaW4gZ3JvdXApXG57XG5ncm91cDogZ3JvdXBJZFxudmFsdWU6IHZhcmlhbnRJZFxufVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBpbWFnZVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYnV0dG9uUHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0aXRsZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpbWFnZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtkZXNjcmlwdGlvbkNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdENvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0VUlJdGVtXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdWlPbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3VpT2ZmXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcInJhZGlvLWJ1dHRvbnNcIixcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgYnV0dG9uUHJvcHMgPSB7fSxcbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCA9IFVJQnV0dG9ucyxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0Q29tcG9uZW50ID0gVUlMaXN0LFxuICAgICAgICBsaXN0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgcmV0dXJuVmFyaWFudCA9IGZhbHNlLFxuICAgICAgICBnZXRVSUl0ZW0gPSAodmFsdWVJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzQnV0dG9ucy5maW5kKChidG5WYWwpID0+IGJ0blZhbC52YWx1ZSA9PT0gdmFsdWVJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIFVJSXRlbUhhc1ZhbHVlID0gKGl0ZW0sIHZhbCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgPT0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBnZXREZWZhdWx0SXRlbVN1YmxpbWUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudHNbMF0udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVpT24gPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5jb2xvciA9IFwic3VjY2Vzc1wiO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIHVpT2ZmID0gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY29sb3IgPSBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaW5pdFZhcmlhbnRzQnV0dG9uKCk7XG4gICAgICAgIHNlbGVjdERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIGxldCB2YXJpYW50c0J1dHRvbnMgPSBbXSxcbiAgICAgICAgbGlzdEl0ZW1zID0gJHN0YXRlKFtdKTtcblxuICAgIGZ1bmN0aW9uIGluaXRWYXJpYW50c0J1dHRvbigpIHtcbiAgICAgICAgdmFyaWFudHNCdXR0b25zID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5idXR0b25Qcm9wcywgLi4udmFyaWFudCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdEl0ZW1zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7IHZhbHVlczogdmFyaWFudHNCdXR0b25zIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGNvbnN0IGdldEN1cnJlbnRWYXJpYW50ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSAkc3RhdGUuc25hcHNob3QodmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFyaWFudHMuZmluZCgodmEpID0+IHZhLnZhbHVlID09PSB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgbGV0IHVpID0ge1xuICAgICAgICAgICAgb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICAvL1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB1aS5vZmYgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdGVkVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHVpLm9uID0gc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHNlbGVjdGVkVmFsdWU7XG4gICAgICAgIHVwZGF0ZVVJKHVpKTtcbiAgICAgICAgLy9cbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiByZXR1cm5WYXJpYW50ID8gZ2V0Q3VycmVudFZhcmlhbnQoKSA6ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vXG4gICAgZnVuY3Rpb24gdXBkYXRlVUkoY2hhbmdlcykge1xuICAgICAgICBmb3IgKGxldCB0IGluIHZhcmlhbnRzQnV0dG9ucykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaGFuZ2VzLm9mZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIFVJSXRlbUhhc1ZhbHVlKHZhcmlhbnRzQnV0dG9uc1t0XSwgY2hhbmdlcy5vZmYpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXJpYW50c0J1dHRvbnNbdF0gPSB1aU9mZih2YXJpYW50c0J1dHRvbnNbdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBjaGFuZ2VzLm9uICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgVUlJdGVtSGFzVmFsdWUodmFyaWFudHNCdXR0b25zW3RdLCBjaGFuZ2VzLm9uKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFudHNCdXR0b25zW3RdID0gdWlPbih2YXJpYW50c0J1dHRvbnNbdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpc3RJdGVtc1swXS5kZXNjcmlwdGlvbi52YWx1ZXMgPSB2YXJpYW50c0J1dHRvbnM7XG4gICAgfVxuICAgIC8vXG4gICAgZnVuY3Rpb24gc2VsZWN0RGVmYXVsdCgpIHtcbiAgICAgICAgaWYgKHZhcmlhbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZWYWx1ZSA9IGdldERlZmF1bHRJdGVtU3VibGltZSgpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZShkZWZWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVVJKHsgb246IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gJGRlcml2ZWQobGlzdENvbXBvbmVudCk7XG48L3NjcmlwdD5cblxuPFN2ZWx0ZUNvbXBvbmVudFxuICAgIHsuLi5saXN0Q29tcG9uZW50UHJvcHN9XG4gICAgaXRlbXM9e2xpc3RJdGVtc31cbiAgICB7dGl0bGVDb21wb25lbnR9XG4gICAge3RpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAge2Rlc2NyaXB0aW9uQ29tcG9uZW50fVxuICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHM9e3tcbiAgICAgICAgLi4uZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyxcbiAgICAgICAgYWN0aW9uKGV2ZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9fVxuICAgIHtpbWFnZUNvbXBvbmVudH1cbiAgICB7aW1hZ2VDb21wb25lbnRQcm9wc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgxMCksXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIG1heCA9IDEwMCxcbiAgICAgICAgc3RlcCA9IDEsXG4gICAgICAgIHRpY2ttYXJrcyA9IGZhbHNlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwicmFuZ2VcIixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG5cbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuXG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZX08L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC1yYW5nZS17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQgYmlnLW51bWJlciBzbGlkZXIgaGFzLW91dHB1dCB7c2l6ZVxuICAgICAgICAgICAgPyBgaXMtJHtzaXplfWBcbiAgICAgICAgICAgIDogJyd9IHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ30gIHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJyYW5nZVwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAge21pbn1cbiAgICAgICAge21heH1cbiAgICAgICAge3N0ZXB9XG4gICAgICAgIGxpc3Q9XCJmb3JtLWZpZWxkLXJhbmdlLXtmaWVsZG5hbWV9LXRpY2ttYXJrc1wiXG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbiAgICA8b3V0cHV0IGZvcj1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX1cIj57dmFsdWV9PC9vdXRwdXQ+XG4gICAgeyNpZiBBcnJheS5pc0FycmF5KHRpY2ttYXJrcykgJiYgdGlja21hcmtzLmxlbmd0aH1cbiAgICAgICAgPGRhdGFsaXN0IGlkPVwiZm9ybS1maWVsZC1yYW5nZS17ZmllbGRuYW1lfS10aWNrbWFya3NcIj5cbiAgICAgICAgICAgIHsjZWFjaCB0aWNrbWFya3MgYXMgdGlja21hcmt9XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17dGlja21hcmsudmFsdWV9IGxhYmVsPXt0aWNrbWFyay5sYWJlbH0+PC9vcHRpb24+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGF0YWxpc3Q+XG4gICAgey9pZn1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlTZWxlY3RPcHRpb24gZnJvbSBcIi4vdWkuc2VsZWN0Lm9wdGlvbi5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWUgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbdmFyaWFudHMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbZW1wdHlWYWx1ZUVuYWJsZWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bWJlcn0gIFtlbXB0eVZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW1wdHlWYWx1ZVRpdGxlID0gXCJuby1zZWxlY3Rpb25cIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZT1cInNlbGVjdC1tdWx0aXBsZVwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seSA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcm93cyA9IDhdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlID0gKHt2YWx1ZTphcnJheSBvZiBzdHJpbmd8bnVtYmVyLCBmaWVsZDpzdHJpbmcsIHZhcmlhbnRzOmFycmF5IG9mIG9iamVjdH0pPT50cnVlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9IFtdLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGVtcHR5VmFsdWVUaXRsZSA9IFwibm8tc2VsZWN0aW9uXCIsXG4gICAgICAgIGVtcHR5VmFsdWVFbmFibGVkID0gdHJ1ZSxcbiAgICAgICAgZW1wdHlWYWx1ZSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWxlY3QtbXVsdGlwbGVcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICByb3dzID0gOCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBsYXN0VmFsdWUgPSAkc3RhdGUuc25hcHNob3QodmFsdWUpO1xuXG4gICAgZnVuY3Rpb24gaXNDbGVhclZhbHVlTWFjcm8ocGxhaW5WYWx1ZSkge1xuICAgICAgICByZXR1cm4gcGxhaW5WYWx1ZS5pbmNsdWRlcyhVSUNvbW1vbi5DTEVBUl9NQUNSTyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25zVmFsdWVzKGV2KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGV2LnNlbGVjdGVkT3B0aW9ucykubWFwKChlbCkgPT5cbiAgICAgICAgICAgIHR5cGVvZiBlbC5fX3ZhbHVlICE9PSBcInVuZGVmaW5lZFwiID8gZWwuX192YWx1ZSA6IGVsLnZhbHVlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RW1wdHlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbXB0eVZhbHVlID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IFVJQ29tbW9uLkNMRUFSX01BQ1JPXG4gICAgICAgICAgICA6IGVtcHR5VmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWRUb1ZhcmlhbnQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQuaWQgPT0gaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlSWRzVG9WYXJpYW50cygpIHtcbiAgICAgICAgY29uc3QgZXYgPSBnZXRFbXB0eVZhbHVlKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gZXYpLm1hcChpZFRvVmFyaWFudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25JbnB1dChldikge1xuICAgICAgICBsZXQgc2VsZWN0ZWRJZHMgPSBnZXRTZWxlY3RlZE9wdGlvbnNWYWx1ZXMoZXYuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGlmIChpc0NsZWFyVmFsdWVNYWNybyhzZWxlY3RlZElkcykpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSWRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzZWxlY3RlZElkcztcbiAgICAgICAgdmFsdWUgPSBzZWxlY3RlZElkcztcbiAgICAgICAgaWYgKG5vdENvbW1vbi5jb21wYXJlVHdvQXJyYXlzKG5ld1ZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YXJpYW50czogdmFsdWVJZHNUb1ZhcmlhbnRzKCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBzZWxlY3RlZFZhcmlhbnRzID0gJGRlcml2ZWQoXG4gICAgICAgIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVJZHNUb1ZhcmlhbnRzKHZhbHVlKSA6IFtdXG4gICAgKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBsZXQgVUlfQ0xBU1NFUyA9ICRkZXJpdmVkKFxuICAgICAgICBbc2l6ZSwgY29sb3JdXG4gICAgICAgICAgICAuZmlsdGVyKCh2YWwpID0+IHZhbClcbiAgICAgICAgICAgIC5tYXAoKHZhbCkgPT4gYGlzLSR7dmFsfWApXG4gICAgICAgICAgICAuam9pbihcIiBcIilcbiAgICApO1xuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgeyNpZiB2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGh9XG4gICAgICAgIHsjZWFjaCBzZWxlY3RlZFZhcmlhbnRzIGFzIHNlbGVjdGVkVmFyaWFudH1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXItMlwiPnskTE9DQUxFW3NlbGVjdGVkVmFyaWFudC50aXRsZV19PC9zcGFuPlxuICAgICAgICB7L2VhY2h9XG4gICAgezplbHNlIGlmIGVtcHR5VmFsdWVFbmFibGVkfVxuICAgICAgICA8c3BhbiBjbGFzcz1cIm1yLTJcIj57JExPQ0FMRVtlbXB0eVZhbHVlVGl0bGVdfTwvc3Bhbj5cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIDxkaXYgY2xhc3M9XCJzZWxlY3QgaXMtbXVsdGlwbGUge1VJX0NMQVNTRVN9IHtjbGFzc2VzfSBcIj5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgbXVsdGlwbGU9XCJ0cnVlXCJcbiAgICAgICAgICAgIGlkPVwiZm9ybS1maWVsZC1zZWxlY3Qte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICAgICAgb25pbnB1dD17b25JbnB1dH1cbiAgICAgICAgICAgIG9uY2hhbmdlPXtvbklucHV0fVxuICAgICAgICAgICAgb25ibHVyPXtvbklucHV0fVxuICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICBzaXplPXtyb3dzfVxuICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgPlxuICAgICAgICAgICAgeyNpZiBlbXB0eVZhbHVlRW5hYmxlZH1cbiAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3R5cGVvZiBlbXB0eVZhbHVlID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFVJQ29tbW9uLkNMRUFSX01BQ1JPXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVtcHR5VmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlPXtlbXB0eVZhbHVlVGl0bGV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2VhY2ggdmFyaWFudHMgYXMgdmFyaWFudCAodmFyaWFudC5pZCl9XG4gICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uIHZhbHVlPXt2YXJpYW50LmlkfSB0aXRsZT17dmFyaWFudC50aXRsZX0gLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiY29uc3QgREVGQVVMVF9TVEFUVVNfU1VDQ0VTUyA9IFwib2tcIjtcbmNvbnN0IERFRkFVTFRfU1RBVFVTX0VSUk9SID0gXCJlcnJvclwiO1xuXG5jb25zdCBOQVZJR0FUSU9OX0RFTEFZX1NIT1JUID0gNTAwO1xuY29uc3QgTkFWSUdBVElPTl9ERUxBWV9OT1JNQUwgPSAxNTAwO1xuY29uc3QgTkFWSUdBVElPTl9ERUxBWV9MT05HID0gNTAwMDtcblxuY29uc3QgTkFWSUdBVElPTl9ERUxBWVMgPSB7XG4gICAgU0hPUlQ6IE5BVklHQVRJT05fREVMQVlfU0hPUlQsXG4gICAgTk9STUFMOiBOQVZJR0FUSU9OX0RFTEFZX05PUk1BTCxcbiAgICBMT05HOiBOQVZJR0FUSU9OX0RFTEFZX0xPTkcsXG59O1xuXG5jb25zdCBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQgPSBOQVZJR0FUSU9OX0RFTEFZX05PUk1BTDtcblxuZXhwb3J0IHtcbiAgICBERUZBVUxUX1NUQVRVU19TVUNDRVNTLFxuICAgIERFRkFVTFRfU1RBVFVTX0VSUk9SLFxuICAgIE5BVklHQVRJT05fREVMQVlfREVGQVVMVCxcbiAgICBOQVZJR0FUSU9OX0RFTEFZUyxcbn07XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG4gICAgaW1wb3J0IFVJU2VsZWN0IGZyb20gXCIuL3VpLnNlbGVjdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcbiAgICBpbXBvcnQgeyBERUZBVUxUX1NUQVRVU19TVUNDRVNTIH0gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbnN0XCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgY29uc3QgREVGQVVMVF9BUElfTU9ERUxfR0VUVEVSID0gKFxuICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgIGFjdGlvbkZpbHRlcixcbiAgICAgICAgYWN0aW9uU29ydGVyLFxuICAgICAgICBhY3Rpb25QYWdlcixcbiAgICAgICAgYWN0aW9uU2VhcmNoXG4gICAgKSA9PiB7XG4gICAgICAgIHJldHVybiBub3RDb21tb25cbiAgICAgICAgICAgIC5nZXRBcHAoKVxuICAgICAgICAgICAgLmdldE1vZGVsKG1vZGVsTmFtZSlcbiAgICAgICAgICAgIC5zZXRGaWx0ZXIoYWN0aW9uRmlsdGVyKVxuICAgICAgICAgICAgLnNldFNvcnRlcihhY3Rpb25Tb3J0ZXIpXG4gICAgICAgICAgICAuc2V0UGFnZXIoYWN0aW9uUGFnZXIpXG4gICAgICAgICAgICAuc2V0U2VhcmNoKGFjdGlvblNlYXJjaCk7XG4gICAgfTtcblxuICAgIGNvbnN0IERFRkFVTFRfQVBJX1JFUVVFU1QgPSAoYXBpTW9kZWwsIGFjdGlvbk5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFwaU1vZGVsW2AkYCArIGFjdGlvbk5hbWVdKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2VtcHR5VmFsdWVUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2VtcHR5VmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZW1wdHlWYWx1ZUVuYWJsZWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RlbE5hbWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpb25OYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uRmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uU29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uUGFnZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25TZWFyY2hdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25JZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvblRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JldHVyblZhcmlhbnRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlID0gKHt2YWx1ZTphcnJheSBvZiBzdHJpbmd8bnVtYmVyLCBmaWVsZDpzdHJpbmcsIHZhcmlhbnRzOmFycmF5IG9mIG9iamVjdH0pPT50cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmVycm9yID0gKG1lc3NhZ2U6c3RyaW5nKTp2b2lkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbW9kZWxOYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbkZpbHRlciA9IHt9LFxuICAgICAgICBhY3Rpb25Tb3J0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uUGFnZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU2VhcmNoID0gdW5kZWZpbmVkLFxuICAgICAgICBvcHRpb25JZCA9IFwiOl9pZFwiLFxuICAgICAgICBvcHRpb25UaXRsZSA9IFwiOnRpdGxlXCIsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIGFwaU1vZGVsR2V0dGVyID0gREVGQVVMVF9BUElfTU9ERUxfR0VUVEVSLFxuICAgICAgICBhcGlSZXF1ZXN0ID0gREVGQVVMVF9BUElfUkVRVUVTVCxcbiAgICAgICAgcmV0dXJuVmFyaWFudCA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25lcnJvciA9ICgpID0+IHt9LFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBhcmd1bWVudHNTZXRQcm92aWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsTmFtZSAmJiBhY3Rpb25OYW1lICYmIGFjdGlvbkZpbHRlcjtcbiAgICB9XG5cbiAgICBsZXQgbG9hZGVkID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgdmFyaWFudHMgPSAkc3RhdGUoW10pO1xuICAgIGxldCByZXN1bHRzTGlzdCA9IFtdO1xuICAgIGxldCB1aURpc2FibGVkID0gJGRlcml2ZWQoZGlzYWJsZWQgfHwgIWxvYWRlZCk7XG5cbiAgICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1NldFByb3ZpZGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdChcbiAgICAgICAgICAgICAgICBhcGlNb2RlbEdldHRlcihcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblNvcnRlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uUGFnZXIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblNlYXJjaFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvbmVycm9yKHJlc3BvbnNlLmVycm9ycyB8fCBbcmVzcG9uc2UubWVzc2FnZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzTGlzdCA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB2YXJpYW50cyA9IHJlc3VsdHNMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vdFBhdGguZ2V0KG9wdGlvbklkLCBpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBub3RQYXRoLmdldChvcHRpb25UaXRsZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICBpZiAocmV0dXJuVmFyaWFudCkge1xuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhcmlhbnRzLmZpbmQoKGl0bSkgPT4gaXRtLmlkID09PSBkYXRhLnZhbHVlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25jaGFuZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPFVJU2VsZWN0XG4gICAge3ZhbHVlfVxuICAgIHt2YXJpYW50c31cbiAgICBjbGFzcz17Y2xhc3Nlc31cbiAgICBkaXNhYmxlZD17dWlEaXNhYmxlZH1cbiAgICBvbmNoYW5nZT17b25DaGFuZ2V9XG4gICAgbG9hZGluZz17IWxvYWRlZH1cbiAgICB7Li4ub3RoZXJzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFwiYnVsbWEtc3dpdGNoXCI7XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG4gICAgaW1wb3J0IFVJQm9vbGVhbiBmcm9tIFwiLi4vdmFyaW91cy91aS5ib29sZWFuLnN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIGxhYmVsID0gXCJcIixcbiAgICAgICAgaGlkZUxhYmVsID0gZmFsc2UsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJzd2l0Y2hcIixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uYmx1clwiLCBcIm9uaW5wdXRcIl0sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIHJlYWN0T24uZm9yRWFjaCgoZXZlbnROYW1lKSA9PiAob3B0aW9uYWxQcm9wc1tldmVudE5hbWVdID0gb25pbnB1dCkpO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxVSUJvb2xlYW4gTENfVFJVRT17bGFiZWx9IExDX0ZBTFNFPXtsYWJlbH0ge3ZhbHVlfSAvPlxuezplbHNlfVxuICAgIHsjaWYgIWxhYmVsICYmICFoaWRlTGFiZWx9XG4gICAgICAgIDxVSUJvb2xlYW4gdmFsdWU9e2ZhbHNlfSAvPlxuICAgIHsvaWZ9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC1zd2l0Y2gte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cInN3aXRjaCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOmNoZWNrZWQ9e3ZhbHVlfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG4gICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIiBmb3I9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfVwiPlxuICAgICAgICB7I2lmICFoaWRlTGFiZWx9XG4gICAgICAgICAgICB7I2lmIGxhYmVsfVxuICAgICAgICAgICAgICAgIHskTE9DQUxFW2xhYmVsXX1cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8VUlCb29sZWFuIHZhbHVlPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvaWZ9XG4gICAgPC9sYWJlbD5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxhYmVsIGZyb20gXCIuL3VpLmxhYmVsLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICBpbXBvcnQgXCJidWxtYS1zd2l0Y2hcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoW10pLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInN3aXRjaFwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWN0T24gPSBbXCJvbmJsdXJcIiwgXCJvbmlucHV0XCJdLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCIgaXMtcm91bmRlZCBcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBhZGRJZCh2YXJJZCkge1xuICAgICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKHZhcklkKSkge1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YXJJZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtSWQodmFySWQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKHZhcklkKSkge1xuICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHZhbHVlLmluZGV4T2YodmFySWQpLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShldmVudERhdGEsIGV2KSB7XG4gICAgICAgIGNvbnN0IHZhcklkID0gZXYudGFyZ2V0LmlkLnNwbGl0KFwiLXZhcmlhbnQtXCIpLmF0KC0xKTtcbiAgICAgICAgZXYudGFyZ2V0LmNoZWNrZWQgPyBhZGRJZCh2YXJJZCkgOiByZW1JZCh2YXJJZCk7XG4gICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLFxuICAgICAgICB9O1xuICAgICAgICBvbmNoYW5nZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuXG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvbkNoYW5nZSk7XG4gICAgICAgIHJlYWN0T24uZm9yRWFjaCgoZXZlbnROYW1lKSA9PiAob3B0aW9uYWxQcm9wc1tldmVudE5hbWVdID0gb25pbnB1dCkpO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIHsjaWYgdmFsdWV9XG4gICAgICAgIHt2YXJpYW50c1xuICAgICAgICAgICAgLmZpbHRlcigodmFyaWFudCkgPT4gdmFsdWUuaW5jbHVkZXModmFyaWFudC5pZCkpXG4gICAgICAgICAgICAubWFwKCh2YXJpYW50KSA9PiB2YXJpYW50LnRpdGxlKVxuICAgICAgICAgICAgLmpvaW4oXCIsIFwiKX1cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50ICh2YXJpYW50LmlkKX1cbiAgICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1saXN0LWl0ZW1cIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzd2l0Y2gge2NsYXNzZXN9IHt2YXJpYW50LnR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyBgaXMtJHt2YXJpYW50LnR5cGV9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnfVwiXG4gICAgICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfS12YXJpYW50LXt2YXJpYW50LmlkfVwiXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17dmFsdWUuaW5jbHVkZXModmFyaWFudC5pZCl9XG4gICAgICAgICAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAgICAgIHtpbnZhbGlkfVxuICAgICAgICAgICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX0tdmFyaWFudC17dmFyaWFudC5pZH1cIlxuICAgICAgICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX0tdmFyaWFudC17dmFyaWFudC5pZH1cIlxuICAgICAgICAgICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPFVJTGFiZWxcbiAgICAgICAgICAgICAgICBjbGFzcz1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICBmb3I9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfS12YXJpYW50LXt2YXJpYW50LmlkfVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e3ZhcmlhbnQudGl0bGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2VhY2h9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IHsgVUlDb2x1bW4sIFVJQ29sdW1ucyB9IGZyb20gXCIuLi9sYXlvdXRcIjtcbiAgICBpbXBvcnQgVUlTZWxlY3RPcHRpb24gZnJvbSBcIi4vdWkuc2VsZWN0Lm9wdGlvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b24uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBjbGVhclZhbHVlRnJvbURlYWRWYXJpYW50cygpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW0xDX0FERCA9IFwibm90LW5vZGU6YWRkX2xhYmVsXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19TRUxFQ1RfRlJPTV9MSVNUID0gXCJub3Qtbm9kZTpzZWxlY3RfZnJvbV9saXN0X2xhYmVsXCJdXG4gICAgICogQHByb3BlcnR5IHthcnJheTxzdHJpbmd8bnVtYmVyPn0gW3ZhbHVlXSAtIGxpc3Qgb2YgaXRlbSBpZHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5PG9iamVjdD59IFt2YXJpYW50c11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZSA9ICd0YWcnXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5ID0gZmFsc2VdIC0gZXhwb3J0IGxldCByZXF1aXJlZCA9IHRydWU7XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtiZWZvcmVBZGRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2dldEl0ZW1JZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZ2V0SXRlbVRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtnZXRJdGVtVHlwZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbYnVpbGRJdGVtXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBMQ19BREQgPSBcIm5vdC1ub2RlOmFkZF9sYWJlbFwiLFxuICAgICAgICBMQ19TRUxFQ1RfRlJPTV9MSVNUID0gXCJub3Qtbm9kZTpzZWxlY3RfZnJvbV9saXN0X2xhYmVsXCIsXG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFtdKSxcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJ0YWdcIixcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBiZWZvcmVBZGQgPSAoLyp2YXJpYW50LCB2YXJpYW50cyovKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SXRlbUlkID0gKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50LmlkO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtVGl0bGUgPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnQudGl0bGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGdldEl0ZW1UeXBlID0gKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50Py50eXBlID8/IFwiaW5mb1wiO1xuICAgICAgICB9LFxuICAgICAgICBidWlsZEl0ZW0gPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogZ2V0SXRlbUlkKHZhcmlhbnQpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRJdGVtVGl0bGUodmFyaWFudCksXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0SXRlbVR5cGUodmFyaWFudCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIHZhcmlhbnRJZFRvVmFyaWFudChpZCkge1xuICAgICAgICByZXR1cm4gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gZ2V0SXRlbUlkKHZhcmlhbnQpID09IGlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGlkID0gZS5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaWQ7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgICAgIHZhbHVlLnNwbGljZSh2YWx1ZS5pbmRleE9mKGlkKSwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBpZCA9IGUuY3VycmVudFRhcmdldC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3RcIikudmFsdWU7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50SWRUb1ZhcmlhbnQoaWQpO1xuICAgICAgICBpZiAoIXZhcmlhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJlZm9yZUFkZCh2YXJpYW50LCB2YXJpYW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgJiYgdmFsdWUuaW5kZXhPZihpZCkgPT09IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGlkKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhclZhbHVlRnJvbURlYWRWYXJpYW50cygpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5maWx0ZXIodmFyaWFudElkVG9WYXJpYW50KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qXG5pdGVtID0ge1xuICBpZCwgICAgICAgIC8vdW5pcXVlXG4gIHRpdGxlLCAgICAgLy9zb21lIHRleHRcbiAgdHlwZSAgICAgICAvL2ZvciBjb2xvcmluZyBpdGVtcywgdXN1YWwgaHRtbCB0ZW1wbGF0ZSBuYW1lcyBkYW5nZXIsIHN1Y2Nlc3MsIGV0Y1xufVxuKi9cbiAgICBsZXQgaXRlbXMgPSAkZGVyaXZlZChcbiAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIC5tYXAodmFyaWFudElkVG9WYXJpYW50KVxuICAgICAgICAgICAgLmZpbHRlcigodmFyaWFudCkgPT4gdmFyaWFudClcbiAgICAgICAgICAgIC5tYXAoYnVpbGRJdGVtKVxuICAgICk7XG48L3NjcmlwdD5cblxuPFVJQ29sdW1ucyBjbGFzcz17Y2xhc3Nlc30+XG4gICAgPFVJQ29sdW1uPlxuICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm14LTEgdGFnIGlzLXtpdGVtLnR5cGV9XCJcbiAgICAgICAgICAgICAgICA+eyRMT0NBTEVbaXRlbS50aXRsZV19XG4gICAgICAgICAgICAgICAgeyNpZiAhcmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJkZWxldGUgYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtaWQ9e2l0ZW0uaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImRlbGV0ZSBpcy1zbWFsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtyZW1vdmV9XG4gICAgICAgICAgICAgICAgICAgID48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC9VSUNvbHVtbj5cblxuICAgIHsjaWYgIXJlYWRvbmx5fVxuICAgICAgICA8VUlDb2x1bW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VsZWN0IGlzLXNtYWxsXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdD5cbiAgICAgICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17LTF9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtMQ19TRUxFQ1RfRlJPTV9MSVNUfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7I2VhY2ggdmFyaWFudHMgYXMgdmFyaWFudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YXJpYW50LmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXt2YXJpYW50LnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8VUlCdXR0b25cbiAgICAgICAgICAgICAgICBjb2xvcj17XCJwcmltYXJ5XCJ9XG4gICAgICAgICAgICAgICAgc2l6ZT17XCJzbWFsbFwifVxuICAgICAgICAgICAgICAgIGFjdGlvbj17YWRkfVxuICAgICAgICAgICAgICAgIHRpdGxlPXtMQ19BRER9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgIHsvaWZ9XG48L1VJQ29sdW1ucz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiKzcgOTg3IDY1NC0zMi0xMFwiLFxuICAgICAgICBwYXR0ZXJuID0gXCJcXFxcK1swLTldezEsM31cXFxccytbMC05XXszfVxcXFxzK1swLTldezN9LVswLTldezJ9LVswLTldezJ9XCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwidGVsZXBob25lXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtdGVsZXBob25lLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cInRlbFwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7cGF0dGVybn1cbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFVJQ29udHJvbCB9IGZyb20gXCIuLi9pbnB1dFwiO1xuICAgIGltcG9ydCBVSUZpZWxkIGZyb20gXCIuLi9pbnB1dC91aS5maWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUYWdWYWx1ZSBmcm9tIFwiLi91aS50YWcudmFsdWUuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSAgICBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIHZhbHVlcyA9IFtdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2dyb3VwZWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFttdWx0aWxpbmUgPSB0cnVlXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgICBQcm9wc1xuICAgICAqL1xuICAgIGxldCB7IHZhbHVlcyA9IFtdLCBncm91cGVkID0gdHJ1ZSwgbXVsdGlsaW5lID0gdHJ1ZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiB2YWx1ZXMubGVuZ3RofVxuICAgIDxVSUZpZWxkIHtncm91cGVkfSB7bXVsdGlsaW5lfT5cbiAgICAgICAgeyNlYWNoIHZhbHVlcyBhcyB0YWdWYWx1ZVByb3BzfVxuICAgICAgICAgICAgPFVJQ29udHJvbD5cbiAgICAgICAgICAgICAgICA8VUlUYWdWYWx1ZSB7Li4udGFnVmFsdWVQcm9wc30gLz5cbiAgICAgICAgICAgIDwvVUlDb250cm9sPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC9VSUZpZWxkPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheTxzdHJpbmc+fSAgW2Vycm9ycyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3cgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZCA9ICdlcnJvcnMtbGlzdCddXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgICBzaG93ID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaWQgPSBcImVycm9ycy1saXN0XCIsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgQXJyYXkuaXNBcnJheShlcnJvcnMpICYmIGVycm9ycy5sZW5ndGh9XG4gICAgPHAgY2xhc3M9XCJoZWxwIHtjbGFzc2VzfVwiIHtpZH0+XG4gICAgICAgIHsjaWYgc2hvd31cbiAgICAgICAgICAgIHsjZWFjaCBlcnJvcnMgYXMgZXJyb3IsIGluZGV4fVxuICAgICAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW2Vycm9yXX08L3NwYW4+e2luZGV4IDwgZXJyb3JzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgPyBcIiwgXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwifVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7OmVsc2V9Jm5ic3A7ey9pZn1cbiAgICA8L3A+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuICAgIGltcG9ydCB7IFVJQ29udGVudCB9IGZyb20gXCIuLi9ibG9ja1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICAgICAgW2lkID0gXCJ1c2VyQ2FyZFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbaW1hZ2UgPSBcImh0dHBzOi8vYnVsbWEuaW8vaW1hZ2VzL3BsYWNlaG9sZGVycy8zMngzMi5wbmdcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICAgICAgW3VzZXJuYW1lID0gXCJKb2huIERvZVwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbcm9sZSA9IFwiYWRtaW5cIl1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2V2ZW50cyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHNdIC0gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW29uVXBkYXRlID0gKGRhdGEpPT4ge3VzZXJuYW1lPWRhdGEudXNlcm5hbWU7IHJvbGUgPSBkYXRhLnJvbGU7fV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInVzZXJDYXJkXCIsXG4gICAgICAgIGltYWdlID0gXCJodHRwczovL2J1bG1hLmlvL2ltYWdlcy9wbGFjZWhvbGRlcnMvMzJ4MzIucG5nXCIsXG4gICAgICAgIHVzZXJuYW1lID0gXCJKb2huIERvZVwiLFxuICAgICAgICByb2xlID0gXCJhZG1pblwiLFxuICAgICAgICBldmVudHMgPSB7fSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMuYmluZChub3RDb21tb24pLFxuICAgICAgICBvblVwZGF0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkYXRhLCBcInVzZXJuYW1lXCIpKSB7XG4gICAgICAgICAgICAgICAgdXNlcm5hbWUgPSBkYXRhLnVzZXJuYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkYXRhLCBcInJvbGVcIikpIHtcbiAgICAgICAgICAgICAgICByb2xlID0gZGF0YS5yb2xlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBnZXRDb21wSWQoKSB7XG4gICAgICAgIHJldHVybiBgdXNlcmNhcmQtJHtpZH1gO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke2dldENvbXBJZCgpfTp1cGRhdGVgO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oZXZlbnRzLCBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpKSkge1xuICAgICAgICAgICAgZXZlbnRzW2dldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCldID0gb25VcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXIoZXZlbnRzKTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48YXJ0aWNsZSBpZD17Z2V0Q29tcElkKCl9IGNsYXNzPVwibWVkaWFcIj5cbiAgICA8ZmlndXJlIGNsYXNzPVwibWVkaWEtbGVmdFwiPlxuICAgICAgICA8cCBjbGFzcz1cImltYWdlIGlzLTMyeDMyXCI+XG4gICAgICAgICAgICA8aW1nIHNyYz17aW1hZ2V9IGFsdD17dXNlcm5hbWV9IC8+XG4gICAgICAgIDwvcD5cbiAgICA8L2ZpZ3VyZT5cbiAgICA8ZGl2IGNsYXNzPVwibWVkaWEtY29udGVudFwiPlxuICAgICAgICA8VUlDb250ZW50PlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgPHN0cm9uZz57dXNlcm5hbWV9PC9zdHJvbmc+XG4gICAgICAgICAgICAgICAgPHNtYWxsPkA8L3NtYWxsPlxuICAgICAgICAgICAgICAgIDxzdHJvbmc+e3JvbGV9PC9zdHJvbmc+XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgIDwvVUlDb250ZW50PlxuICAgIDwvZGl2PlxuPC9hcnRpY2xlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udCA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpZGUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50YWJsZSA9IGZhbHNlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGZvbnQgPSBcIlwiLFxuICAgICAgICBzaWRlID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIHBvaW50YWJsZSA9IGZhbHNlLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIHRpdGxlfVxuICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10ZXh0IHtwb2ludGFibGUgPyAnaXMtY2xpY2thYmxlJyA6ICcnfVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb24ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj5cbiAgICAgICAgICAgIDxpXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpcy10aXRsZS1pY29uIGZhc1xuICAgICAgZmEte2ZvbnR9XG4gICAgICB7c2l6ZSA9PSAnbWVkaXVtJyA/ICdmYS1sZycgOiAnJ31cbiAgICAgIHtzaXplID09ICdsYXJnZScgPyAnZmEtMngnIDogJyd9XG4gICAgICBcIlxuICAgICAgICAgICAgPjwvaT5cbiAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW3RpdGxlXX08L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG57OmVsc2V9XG4gICAgPHNwYW5cbiAgICAgICAgY2xhc3M9XCJcbiAgICAgICAge3BvaW50YWJsZSA/ICdpcy1jbGlja2FibGUnIDogJyd9XG4gICAgICAgIHtzaWRlID8gYGlzLSR7c2lkZX1gIDogJyd9XG4gICAgICAgIGljb24ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge3NpemUgPT0gJ21lZGl1bScgPyAnZmEtbGcnIDogJyd9XG57c2l6ZSA9PSAnbGFyZ2UnID8gJ2ZhLTJ4JyA6ICcnfVwiXG4gICAgPlxuICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS17Zm9udH1cIj48L2k+XG4gICAgPC9zcGFuPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGV4dGZpZWxkIGZyb20gXCIuLi9pbnB1dC91aS50ZXh0ZmllbGQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVUlDb2x1bW4sIFVJQ29sdW1ucyB9IGZyb20gXCIuLi9sYXlvdXRcIjtcbiAgICBpbXBvcnQgVUlJY29uRm9udCBmcm9tIFwiLi4vaWNvbi91aS5pY29uLmZvbnQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udHJvbCBmcm9tIFwiLi4vaW5wdXQvdWkuY29udHJvbC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlGaWVsZCBmcm9tIFwiLi4vaW5wdXQvdWkuZmllbGQuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtwbGFjZWhvbGRlciA9ICdub3Qtbm9kZTpmaWVsZF9zZWFyY2hfcGxhY2Vob2xkZXInXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0ZXJtID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2ZpZWxkbmFtZSA9ICdzZWFyY2hUZXJtSW5wdXQnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpY29uID0gJ3NlYXJjaCddXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBwbGFjZWhvbGRlciA9IFwibm90LW5vZGU6ZmllbGRfc2VhcmNoX3BsYWNlaG9sZGVyXCIsXG4gICAgICAgIHRlcm0gPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic2VhcmNoVGVybUlucHV0XCIsXG4gICAgICAgIGljb24gPSBcInNlYXJjaFwiLFxuICAgICAgICBpY29uU2lkZSA9IFwibGVmdFwiLFxuICAgICAgICBzaXplID0gXCJub3JtYWxcIixcbiAgICAgICAgcmVxdWlyZWQgPSBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGhhc0ljb25zTGVmdCA9ICRkZXJpdmVkKGljb24gJiYgaWNvblNpZGUgPT09IFwibGVmdFwiKTtcbiAgICBsZXQgaGFzSWNvbnNSaWdodCA9ICRkZXJpdmVkKGljb24gJiYgaWNvblNpZGUgPT09IFwicmlnaHRcIik7XG48L3NjcmlwdD5cblxuPFVJQ29sdW1ucyByb2xlPVwibm9uZVwiPlxuICAgIDxVSUNvbHVtbiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8VUlGaWVsZD5cbiAgICAgICAgICAgIDxVSUNvbnRyb2wge2hhc0ljb25zTGVmdH0ge2hhc0ljb25zUmlnaHR9PlxuICAgICAgICAgICAgICAgIDxVSVRleHRmaWVsZFxuICAgICAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXt0ZXJtfVxuICAgICAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIHtmaWVsZG5hbWV9XG4gICAgICAgICAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICAgICAge3NpemV9XG4gICAgICAgICAgICAgICAgICAgIHJvbGU9e1wic2VhcmNoYm94XCJ9XG4gICAgICAgICAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7I2lmIGljb259XG4gICAgICAgICAgICAgICAgICAgIDxVSUljb25Gb250IGZvbnQ9e2ljb259IHNpZGU9e2ljb25TaWRlfSAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L1VJQ29udHJvbD5cbiAgICAgICAgPC9VSUZpZWxkPlxuICAgIDwvVUlDb2x1bW4+XG48L1VJQ29sdW1ucz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IEVycm9yc0xpc3QgZnJvbSBcIi4uL3ZhcmlvdXMvdWkuZXJyb3JzLmxpc3Quc3ZlbHRlXCI7XG5cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwiZ2VuZXJpYy1maWVsZFwiLFxuICAgICAgICBpbnB1dFN0YXJ0ZWQsXG4gICAgICAgIHZhbGlkYXRlZCxcbiAgICAgICAgdmFsaWQsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZm9ybUVycm9ycyxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBhbGxFcnJvcnMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBzaG93RXJyb3JzID0gJHN0YXRlKHRydWUpO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFsbEVycm9ycyA9IFtcbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGVycm9ycykgPyBlcnJvcnMgOiBbXSksXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShmb3JtRXJyb3JzKSA/IGZvcm1FcnJvcnMgOiBbXSksXG4gICAgICAgIF07XG4gICAgICAgIHNob3dFcnJvcnMgPSBpbnB1dFN0YXJ0ZWQgJiYgdmFsaWRhdGVkICYmICF2YWxpZDtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48RXJyb3JzTGlzdCBzaG93PXtzaG93RXJyb3JzfSBlcnJvcnM9e2FsbEVycm9yc30gY2xhc3M9e2NsYXNzZXN9IHtpZH0gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUYWcgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZVwiO1xuXG4gICAgbGV0IHsgYnV0dG9uID0ge30sIHRhZyA9IHt9LCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHZhcnMgPSAkc3RhdGUoe30pO1xuXG4gICAgbGV0IHRhZ1Bvc2l0aW9uID0ge1xuICAgICAgICBsZWZ0OiAhIWxlZnQsXG4gICAgICAgIHJpZ2h0OiAhIXJpZ2h0LFxuICAgICAgICB0b3A6ICEhdG9wLFxuICAgICAgICBib3R0b206ICEhYm90dG9tLFxuICAgIH07XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHZhcnNbYC0tc2lkaW5nLWxlZnQtc2l6ZWBdID0gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHZhcnNbXCItLXNpZGluZy1yaWdodC1zaXplXCJdID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgdmFyc1tcIi0tc2lkaW5nLXRvcC1zaXplXCJdID0gdG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3R0b20pIHtcbiAgICAgICAgICAgIHZhcnNbXCItLXNpZGluZy1ib3R0b20tc2l6ZVwiXSA9IGJvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICB2YXJzID0gdmFycztcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48c3BhbiBjbGFzcz1cImlzLXRhZy1jb250YWluZXJcIj5cbiAgICA8VUlCdXR0b24gey4uLmJ1dHRvbn0gLz5cbiAgICA8VUlUYWcgey4uLnRhZ30ge3ZhcnN9IHsuLi50YWdQb3NpdGlvbn0gLz5cbjwvc3Bhbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b24uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdHJpZ2dlcl0gLSBleHBvcnQgbGV0IGRpcmVjdGlvbiA9ICdsZWZ0JzsgIC8vbGVmdC9yaWdodC90b3AvYm90dG9tL2Fyb3VuZFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0cmlnZ2VyID0ge1xuICAgICAgICAgICAgdGl0bGU6IFwiQ2xpY2sgbWUhXCIsXG4gICAgICAgICAgICBpY29uOiBcInBsdXNcIixcbiAgICAgICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIHNpemU6IFwibWVkaXVtXCIsXG4gICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB0b3AgPSBcIjJlbVwiLFxuICAgICAgICBsZWZ0ID0gXCIyZW1cIixcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBwb3NpdGlvblN0eWxlID0gJHN0YXRlKFwiXCIpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHBvc2l0aW9uU3R5bGUgPSBcIlwiO1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0eWxlICs9IGB0b3A6ICR7dG9wfTtgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0eWxlICs9IGBsZWZ0OiAke2xlZnR9O2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0eWxlICs9IGByaWdodDogJHtyaWdodH07YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm90dG9tKSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0eWxlICs9IGBib3R0b206ICR7Ym90dG9tfTtgO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImlzLWFic29sdXRlIHtjbGFzc2VzfVwiIHN0eWxlPXtwb3NpdGlvblN0eWxlfT5cbiAgICA8VUlCdXR0b24gey4uLnRyaWdnZXJ9IC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyogZXNsaW50IHN2ZWx0ZS9uby1hdC1odG1sLXRhZ3M6IDAgKi9cblxuICAgIGltcG9ydCBVSUljb25Gb250IGZyb20gXCIuL3VpLmljb24uZm9udC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZSA9IFwiXCJdIC0gZm9udCBpY29uIHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplID0gXCJcIl0gIC0gZm9udCBpY29uIHNpemVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnQgPSBcIlwiXSAtIGZvbnQgaWNvbiBuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdmcgPSBcIlwiXSAtIHN2ZyBpY29uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzcmMgPSBcIlwiXSAtIGltYWdlIGljb25cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IHdpZHRoXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSBoZWlnaHRcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgZm9udCA9IFwiXCIsXG4gICAgICAgIHN2ZyA9IFwiXCIsXG4gICAgICAgIHNyYyA9IFwiXCIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgZm9udH1cbiAgICA8VUlJY29uRm9udCB7Zm9udH0ge3NpemV9IHt0aXRsZX0+PC9VSUljb25Gb250PlxuezplbHNlIGlmIHN2Z31cbiAgICA8c3BhbiBjbGFzcz1cImljb25cIj57QGh0bWwgc3ZnfTwvc3Bhbj5cbns6ZWxzZSBpZiBzcmN9XG4gICAgPGZpZ3VyZSBjbGFzcz1cImltYWdlIHt3aWR0aCAmJiBoZWlnaHQgPyBgaXMtJHt3aWR0aH14JHtoZWlnaHR9YCA6ICcnfSBcIj5cbiAgICAgICAgPGltZyB7c3JjfSB7dGl0bGV9IGFsdD17dGl0bGV9IHt3aWR0aH0ge2hlaWdodH0gLz5cbiAgICA8L2ZpZ3VyZT5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFVJSWNvbkZvbnQgfSBmcm9tIFwiLi4vaWNvblwiO1xuXG4gICAgbGV0IHsgdmFsaWRhdGVkLCB2YWxpZCwgc2lkZSA9IFwicmlnaHRcIiwgc2l6ZSA9IFwic21hbGxcIiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiB2YWxpZGF0ZWQgPT09IHRydWV9XG4gICAgPFVJSWNvbkZvbnQgZm9udD17dmFsaWQgPyBcImNoZWNrXCIgOiBcImV4Y2xhbWF0aW9uLXRyaWFuZ2xlXCJ9IHtzaWRlfSB7c2l6ZX0gLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUZvcm1JbnB1dFZhbGlkYXRlZEljb24gZnJvbSBcIi4vdWkuZm9ybS5pbnB1dC52YWxpZGF0ZWQuaWNvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUljb25Gb250IH0gZnJvbSBcIi4uL2ljb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gIFVJSW5wdXRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGR0eXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZpZWxkbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lUHJlZml4ID0gXCJmb3JtLWZpZWxkLVwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ljb25TaWRlID0gJ2xlZnQnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpemU9ICdzbWFsbCddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkYXRlZCA9IGZhbHNlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcmVhZG9ubHksXG4gICAgICAgIFVJSW5wdXQsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmaWVsZHR5cGUsXG4gICAgICAgIGZpZWxkbmFtZSxcbiAgICAgICAgZmllbGRuYW1lUHJlZml4ID0gXCJmb3JtLWZpZWxkLVwiLFxuICAgICAgICBpY29uLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFVJSW5wdXQge2ZpZWxkdHlwZX0ge2ZpZWxkbmFtZX0ge3ZhbGlkfSB7cmVhZG9ubHl9IGJpbmQ6dmFsdWUgey4uLm90aGVyc30gLz5cbjwhLS0gZWRpdCBVSSByZW5kZXJlciAtLT5cbnsjaWYgaWNvbn1cbiAgICA8VUlJY29uRm9udCBmb250PXtpY29ufSBzaWRlPXtpY29uU2lkZX0gc2l6ZT17aWNvblNpemV9IC8+XG57L2lmfVxueyNpZiAhcmVhZG9ubHl9XG4gICAgPCEtLSB2YWxpZGF0ZWQgYW5kIHZhbGlkIHNob3VsZCBiZSBjcmVhdGVkIGJ5ICRzdGF0ZSgpIC0tPlxuICAgIDxVSUZvcm1JbnB1dFZhbGlkYXRlZEljb24ge3ZhbGlkYXRlZH0ge3ZhbGlkfT48L1VJRm9ybUlucHV0VmFsaWRhdGVkSWNvbj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxhYmVsIGZyb20gXCIuLi9pbnB1dC91aS5sYWJlbC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgSW5wdXRFcnJvcnMgZnJvbSBcIi4vdWkuZm9ybS5pbnB1dC5lcnJvcnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJRm9ybUlucHV0IGZyb20gXCIuL3VpLmZvcm0uaW5wdXQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udHJvbCBmcm9tIFwiLi4vaW5wdXQvdWkuY29udHJvbC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW5wdXRTdGFydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGRuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZpZWxkdHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ljb25TaWRlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpemVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vZXZlbnRzLnR5cGVzJykuVUlFdmVudElucHV0Q2hhbmdlQ2FsbGJhY2t9IFtvbmNoYW5nZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZGF0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZXJyb3JzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zvcm1FcnJvcnNdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBVSUlucHV0LFxuICAgICAgICBpbnB1dFN0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGxhYmVsVmVydGljYWwgPSB0cnVlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkdHlwZSxcbiAgICAgICAgZmllbGRuYW1lLFxuICAgICAgICBmaWVsZG5hbWVQcmVmaXggPSBcImZvcm0tZmllbGQtXCIsXG4gICAgICAgIGljb24gPSBcIlwiLFxuICAgICAgICBpY29uU2lkZSA9IFwibGVmdFwiLFxuICAgICAgICBpY29uU2l6ZSA9IFwic21hbGxcIixcbiAgICAgICAgcmVxdWlyZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICB2YWxpZGF0ZWQgPSBmYWxzZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmVycm9yID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgZm9ybUVycm9ycyA9IFtdLFxuICAgICAgICBlcnJvcnMgPSBbXSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGljb25DbGFzc2VzID0gJGRlcml2ZWQoXG4gICAgICAgIChpY29uID8gXCIgaGFzLWljb25zLWxlZnQgXCIgOiBcIlwiKSArIFwiIGhhcy1pY29ucy1yaWdodCBcIlxuICAgICk7XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IGNvbnRyb2woKX1cbiAgICA8VUlDb250cm9sIGNsYXNzPXtpY29uQ2xhc3Nlc30+XG4gICAgICAgIDxVSUZvcm1JbnB1dFxuICAgICAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICAgICAge1VJSW5wdXR9XG4gICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICB7ZmllbGR0eXBlfVxuICAgICAgICAgICAge2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIHtmaWVsZG5hbWVQcmVmaXh9XG4gICAgICAgICAgICB7aWNvbn1cbiAgICAgICAgICAgIHtpY29uU2lkZX1cbiAgICAgICAgICAgIHtpY29uU2l6ZX1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIHtpbnB1dFN0YXJ0ZWR9XG4gICAgICAgICAgICB7dmFsaWRhdGVkfVxuICAgICAgICAgICAge3ZhbGlkfVxuICAgICAgICAgICAge29uY2hhbmdlfVxuICAgICAgICAgICAge29uZXJyb3J9XG4gICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAvPlxuICAgIDwvVUlDb250cm9sPlxuey9zbmlwcGV0fVxuXG57I2lmIGxhYmVsfVxuICAgIHsjaWYgbGFiZWxWZXJ0aWNhbH1cbiAgICAgICAgPFVJTGFiZWxcbiAgICAgICAgICAgIGNsYXNzPXtmaWVsZHR5cGV9XG4gICAgICAgICAgICBmb3I9XCJ7ZmllbGRuYW1lUHJlZml4fXtmaWVsZHR5cGV9LXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgLz5cbiAgICAgICAge0ByZW5kZXIgY29udHJvbCgpfVxuICAgIHs6ZWxzZX1cbiAgICAgICAgPFVJTGFiZWxcbiAgICAgICAgICAgIGNsYXNzPXtmaWVsZHR5cGV9XG4gICAgICAgICAgICBmb3I9XCJ7ZmllbGRuYW1lUHJlZml4fXtmaWVsZHR5cGV9LXtmaWVsZG5hbWV9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAge2xhYmVsfToge0ByZW5kZXIgY29udHJvbCgpfVxuICAgICAgICA8L1VJTGFiZWw+XG4gICAgey9pZn1cbns6ZWxzZX1cbiAgICB7QHJlbmRlciBjb250cm9sKCl9XG57L2lmfVxuXG48SW5wdXRFcnJvcnNcbiAgICB7aW5wdXRTdGFydGVkfVxuICAgIHt2YWxpZGF0ZWR9XG4gICAge3ZhbGlkfVxuICAgIHtlcnJvcnN9XG4gICAge2Zvcm1FcnJvcnN9XG4gICAgaWQ9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4vdWkuaW1hZ2Uuc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyB2YWx1ZXMgPSBbXSwgLi4ub3ZlcnJpZGUgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjZWFjaCB2YWx1ZXMgYXMgaXRlbSAoaXRlbS51cmwpfVxuICAgIDxVSUltYWdlIHsuLi5pdGVtfSB7Li4ub3ZlcnJpZGV9IC8+XG57L2VhY2h9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFVJQnV0dG9uc1JvdyB9IGZyb20gXCIuLi8uLi9idXR0b25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3BhZ2VdICAgICAgICAgICAgICAgIC0gY3VycmVudCBwYWdlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3BhZ2VzXSAgICAgICAgICAgICAgIC0gdG90YWwgY291bnQgb2YgcGFnZXNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbYnV0dG9uc1Jvd0NvbXBvbmVudCA9IFVJQnV0dG9uc1Jvd10gLSBidXR0b25zIHJvdyB1aSBzdmVsdGUgY29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2J1dHRvbnNSb3dDb21wb25lbnRQcm9wc10gICAtIGJ1dHRvbnMgcm93IGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2J1dHRvblByZXZQcm9wc10gICAtIHByZXYgYnV0dG9uIHVpIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2J1dHRvblByb2dyZXNzUHJvcHNdICAgLSBjZW50ZXIvcHJvZ3Jlc3MgYnV0dG9uIHVpIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2J1dHRvbk5leHRQcm9wc10gICAtIG5leHQgYnV0dG9uIHVpIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ubmV4dF0gICAgICAgICAgICAtIGNhbGxiYWNrIG9uIG5leHRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25wcmV2XSAgICAgICAgICAgIC0gY2FsbGJhY2sgb24gcHJldlxuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbcHJvZ3Jlc3NUaXRsZVN0YXJ0ID0gJyddICAtIHByZWZpeCBvZiBwcm9ncmVzcyBidXR0b24gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkgICAge3N0cmluZ30gICAgW3Byb2dyZXNzVGl0bGVEZWxpbWl0ZXIgPSAnIC8gJ10gIC0gdGV4dCB0aGF0IGJyZWFrcyBudW1iZXJzIG9mIGN1cnJlbnQgcGFnZSBhbmQgdG90YWwgY291bnQgb2YgcGFnZXNcbiAgICAgKiBAcHJvcGVydHkgICAge3N0cmluZ30gICAgW3Byb2dyZXNzVGl0bGVFbmQgPSAnJ10gIC0gc3VmZml4IG9mIHByb2dyZXNzIGJ1dHRvbiB0aXRsZVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBwYWdlID0gMCxcbiAgICAgICAgcGFnZXMgPSAwLFxuICAgICAgICBidXR0b25zUm93Q29tcG9uZW50OiBVSUJ1dHRvbnNSb3dDb21wb25lbnQgPSBVSUJ1dHRvbnNSb3csXG4gICAgICAgIGJ1dHRvbnNSb3dDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBidXR0b25QcmV2UHJvcHMgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCJub3Qtbm9kZTpsaXN0X25hdmlnYXRpb25fcHJldl9idXR0b25fbGFiZWxcIixcbiAgICAgICAgfSxcbiAgICAgICAgYnV0dG9uUHJvZ3Jlc3NQcm9wcyA9IHt9LFxuICAgICAgICBidXR0b25OZXh0UHJvcHMgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCJub3Qtbm9kZTpsaXN0X25hdmlnYXRpb25fbmV4dF9idXR0b25fbGFiZWxcIixcbiAgICAgICAgfSxcbiAgICAgICAgLy90aGlzIGlzIHBsYWNlaG9sZGVycyBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3NlcyBvbmx5LCBgcGFnZWAgc2hvdWxkIGJlIG1vZGlmaWVkIG91dHNpZGUgaW4gb25wcmV2L29ubmV4dCBjYWxsYmFja3NcbiAgICAgICAgb25wcmV2ID0gKCkgPT4ge1xuICAgICAgICAgICAgcGFnZSA+IDAgJiYgcGFnZS0tO1xuICAgICAgICB9LFxuICAgICAgICBvbm5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBwYWdlIDwgcGFnZXMgLSAxICYmIHBhZ2UrKztcbiAgICAgICAgfSxcbiAgICAgICAgcHJvZ3Jlc3NUaXRsZVN0YXJ0ID0gXCJcIixcbiAgICAgICAgcHJvZ3Jlc3NUaXRsZURlbGltaXRlciA9IFwiIC8gXCIsXG4gICAgICAgIHByb2dyZXNzVGl0bGVFbmQgPSBcIlwiLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBjdXJyZW50UGFnZSA9ICRkZXJpdmVkKHBhZ2UgKyAxKTtcbjwvc2NyaXB0PlxuXG57I2lmIHBhZ2VzID4gMH1cbiAgICA8VUlCdXR0b25zUm93Q29tcG9uZW50XG4gICAgICAgIHsuLi5idXR0b25zUm93Q29tcG9uZW50UHJvcHN9XG4gICAgICAgIGxlZnQ9e2N1cnJlbnRQYWdlID4gMVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uYnV0dG9uUHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogb25wcmV2LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXX1cbiAgICAgICAgY2VudGVyPXtwYWdlcyA+IDFcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmJ1dHRvblByb2dyZXNzUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGAke3Byb2dyZXNzVGl0bGVTdGFydH0ke2N1cnJlbnRQYWdlfSR7cHJvZ3Jlc3NUaXRsZURlbGltaXRlcn0ke3BhZ2VzfSR7cHJvZ3Jlc3NUaXRsZUVuZH1gLFxuICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXX1cbiAgICAgICAgcmlnaHQ9e2N1cnJlbnRQYWdlIDwgcGFnZXNcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmJ1dHRvbk5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG9ubmV4dCxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogW119XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUJveCBmcm9tIFwiLi4vLi4vYmxvY2svdWkuYm94LnN2ZWx0ZVwiO1xuXG4gICAgbGV0IHsgdGl0bGUsIGlkLCBfaWQsIG9uY2xpY2sgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gY2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9uY2xpY2soe1xuICAgICAgICAgICAgX2lkLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG48L3NjcmlwdD5cblxuPFVJQm94IG9uY2xpY2s9e2NsaWNrfSBvbmtleXVwPXtjbGlja30gY2xhc3M9XCJsaXN0LWl0ZW0tc2VsZWN0YWJsZVwiPlxuICAgIDxzcGFuPnt0aXRsZX08L3NwYW4+XG48L1VJQm94PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlFbmRsZXNzTGlzdFNpbXBsZUl0ZW0gZnJvbSBcIi4vdWkuZW5kbGVzcy5saXN0LnNpbXBsZS5pdGVtLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUVuZGxlc3NMaXN0RW1wdHlQbGFjZWhvbGRlciBmcm9tIFwiLi4vdWkubGlzdC5lbXB0eS5wbGFjZWhvbGRlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlFbmRsZXNzTGlzdE5hdmlnYXRpb24gZnJvbSBcIi4vdWkuZW5kbGVzcy5saXN0Lm5hdmlnYXRpb24uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVUlCbG9jayB9IGZyb20gXCIuLi8uLi9ibG9ja1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2RhdGFdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdFNpbXBsZUl0ZW1dIC0gbGlzdCBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudCA9IFVJRW5kbGVzc0xpc3RFbXB0eVBsYWNlaG9sZGVyXSAtIGlmIGxpc3QgaXMgZW1wdHlcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2VtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0TmF2aWdhdGlvbkNvbXBvbmVudCA9IFVJRW5kbGVzc0xpc3ROYXZpZ2F0aW9uXSAtIHByZXYgYW5kIG5leHQgYmxvY2tcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3ROYXZpZ2F0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgZGF0YSA9ICRiaW5kYWJsZSh7XG4gICAgICAgICAgICBsaXN0OiBbXSxcbiAgICAgICAgICAgIHNraXA6IDAsXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIHBhZ2U6IDAsXG4gICAgICAgICAgICBwYWdlczogMCxcbiAgICAgICAgfSksXG4gICAgICAgIGl0ZW1Db21wb25lbnQ6IFVJSXRlbUNvbXBvbmVudCA9IFVJRW5kbGVzc0xpc3RTaW1wbGVJdGVtLFxuICAgICAgICBpdGVtQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICAgICAgICBVSUVtcHR5TGlzdFBsYWNlaG9sZGVyID0gVUlFbmRsZXNzTGlzdEVtcHR5UGxhY2Vob2xkZXIsXG4gICAgICAgIGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb25Db21wb25lbnQ6XG4gICAgICAgICAgICBVSU5hdmlnYXRpb25Db21wb25lbnQgPSBVSUVuZGxlc3NMaXN0TmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBvbnNlbGVjdCxcbiAgICAgICAgb25wcmV2LFxuICAgICAgICBvbm5leHQsXG4gICAgICAgIGl0ZW1SZW5kZXJlcixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFVJQmxvY2sgY2xhc3M9e2NsYXNzZXN9PlxuICAgIHsjaWYgZGF0YT8ubGlzdD8ubGVuZ3RofVxuICAgICAgICB7I2VhY2ggZGF0YS5saXN0IGFzIGl0ZW0sIGluZGV4IChpdGVtLmlkKX1cbiAgICAgICAgICAgIHsjaWYgaXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAgICAgIHtAcmVuZGVyIGl0ZW1SZW5kZXJlcihpdGVtLCBpbmRleCl9XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPFVJSXRlbUNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtvbnNlbGVjdH1cbiAgICAgICAgICAgICAgICAgICAgey4uLml0ZW1Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgey4uLml0ZW19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICB7OmVsc2V9XG4gICAgICAgIDxVSUVtcHR5TGlzdFBsYWNlaG9sZGVyIHsuLi5lbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzfSAvPlxuICAgIHsvaWZ9XG48L1VJQmxvY2s+XG48VUlOYXZpZ2F0aW9uQ29tcG9uZW50XG4gICAgey4uLmxpc3ROYXZpZ2F0aW9uQ29tcG9uZW50UHJvcHN9XG4gICAgYmluZDpwYWdlPXtkYXRhLnBhZ2V9XG4gICAgYmluZDpwYWdlcz17ZGF0YS5wYWdlc31cbiAgICBiaW5kOnNraXA9e2RhdGEuc2tpcH1cbiAgICBiaW5kOmNvdW50PXtkYXRhLmNvdW50fVxuICAgIHtvbnByZXZ9XG4gICAge29ubmV4dH1cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvL1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL3VpLmxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4uLy4uL2ltYWdlL3VpLmltYWdlLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICAgICAgW2ZpZWxkbmFtZSA9IFwibGlzdC1zZWxlY3RcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgW211bHRpcGxlID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB3YW50IG5vdCBvbmUgdmFyaWFudCBzZWxlY3RlZFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICBbYXRMZWFzdE9uZSA9IHRydWVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vIGVtcHR5IHJlc3VsdFxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8aW1wb3J0KCcuL3R5cGVzLmpzJykuVmFyaWFudHM+fSBbdmFyaWFudHMgPSBbXV0gICAgICAgICAgIHZhcmlhbnRzIHRvIHNlbGVjdCBmcm9tXG4gICAgICogQHByb3BlcnR5IHthcnJheTxvYmplY3Q+fSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWy4uLnNlbGVjdGVkSXRlbXNWYWx1ZXNdXG4gICAgICogQHByb3BlcnR5IHthcnJheTxzdHJpbmd8bnVtYmVyPn0gW3NlbGVjdGVkVmFyaWFudHNJZHMgPSBbXV0gICAgICAgICAgICAgICAgICAgICAgWy4uLnNlbGVjdGVkSXRlbXNJZHNdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFt0aXRsZUNvbXBvbmVudFByb3BzPSB7IHNpemU6IDUgfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2ltYWdlQ29tcG9uZW50ID0gVUlJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2ltYWdlQ29tcG9uZW50UHJvcHM9IHsgY292ZXJlZDogdHJ1ZSB9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbbGlzdENvbXBvbmVudCA9IFVJTGlzdF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2xpc3RDb21wb25lbnRQcm9wcyA9IHthY3Rpb25zVmlzaWJsZTogdHJ1ZX1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtzdWJsaW1lVmFsdWUgPSAodmFsdWUpID0+IHZhbHVlLmlkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdXBkYXRlVmFyaWFudCA9ICh2YWx1ZUlkLCBwcm9wcywgdG9nZ2xlVGl0bGUpID0+IHZvaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtnZXRJdGVtSW5kZXggPSAoaXRlbXMsIHZhbHVlSWQpID0+IG51bWJlcl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldEl0ZW0gPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiBvYmplY3RdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtnZXRJdGVtVmFsdWUgPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiBvYmplY3RdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtnZXREZWZhdWx0SXRlbVN1YmxpbWUgPSAoaXRlbXMpID0+IHN0cmluZ11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3VwZGF0ZVZhcmlhbnQgPSAoaXRlbXMsIHZhbHVlSWQsIHByb3BzLCB0b2dnbGVUaXRsZSkgPT4gdm9pZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3VpT24gPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB2b2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdWlPZmYgPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB2b2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbZXh0ZW5kVmFyaWFudFRvSXRlbUxpc3QgPSAoaXRlbSkgPT4gb2JqZWN0XVxuICAgICAqL1xuICAgIGxldCBpdGVtcyA9ICRzdGF0ZShbXSk7XG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0XCIsXG4gICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlLFxuICAgICAgICB2YXJpYW50cyA9IFtdLCAvL3ZhcmlhbnRzIHRvIHNlbGVjdCBmcm9tXG4gICAgICAgIHZhbHVlID0gW10sIC8vc2VsZWN0ZWQgb2JqZWN0c1xuICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzID0gW10sIC8vb25seSBpZHMgb2Ygc2VsZWN0ZWQgdmFyaWFudHNcbiAgICAgICAgdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNSB9LFxuICAgICAgICBpbWFnZUNvbXBvbmVudCA9IFVJSW1hZ2UsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7IGNvdmVyZWQ6IHRydWUgfSxcbiAgICAgICAgbGlzdENvbXBvbmVudDogVUlMaXN0Q29tcG9uZW50ID0gVUlMaXN0LFxuICAgICAgICBsaXN0Q29tcG9uZW50UHJvcHMgPSB7IGFjdGlvbnNWaXNpYmxlOiB0cnVlIH0sXG4gICAgICAgIHN1YmxpbWVWYWx1ZSA9ICh2YWx1ZSkgPT4gdmFsdWUuaWQsIC8vb2JqZWN0IC0+IGlkXG4gICAgICAgIGdldEl0ZW1JbmRleCA9IChpdGVtcywgdmFsdWVJZCkgPT5cbiAgICAgICAgICAgIGl0ZW1zLmZpbmRJbmRleCgodmFsKSA9PiB2YWwudmFsdWUuaWQgPT09IHZhbHVlSWQpLFxuICAgICAgICBnZXRJdGVtID0gKGl0ZW1zLCB7IHZhbHVlSWQgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJdGVtSW5kZXgoaXRlbXMsIHZhbHVlSWQpO1xuICAgICAgICAgICAgLy9yZXR1cm5zIHZhcmlhbnRzIGJ5IGl0cyBpZFxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTFcbiAgICAgICAgICAgICAgICA/IGl0ZW1zLmZpbmQoKGJ0blZhbCkgPT4gYnRuVmFsLnZhbHVlLmlkID09PSB2YWx1ZUlkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtVmFsdWUgPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB7XG4gICAgICAgICAgICAvLyByZXR1cm5zIHZhcmlhbnQncyB2YWx1ZSBieSBpZCBvZiB2YXJpYW50XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0SXRlbShpdGVtcywgeyB2YWx1ZUlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBnZXREZWZhdWx0SXRlbVN1YmxpbWUgPSAoaXRlbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPyBpdGVtc1swXS5pZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlVmFyaWFudCA9IChpdGVtcywgdmFsdWVJZCwgaXRlbVByb3BzLCBidXR0b25Qcm9wcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJdGVtSW5kZXgoaXRlbXMsIHZhbHVlSWQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGl0ZW1Qcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbXNbaW5kZXhdW2tleV0gPSBpdGVtUHJvcHNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoaXRlbXNbaW5kZXhdLmFjdGlvbnMpICYmXG4gICAgICAgICAgICAgICAgaXRlbXNbaW5kZXhdLmFjdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhidXR0b25Qcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2luZGV4XS5hY3Rpb25zWzBdW2tleV0gPSBidXR0b25Qcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1aU9uID0gKGl0ZW1zLCB7IHZhbHVlSWQgfSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlVmFyaWFudChcbiAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiaGFzLWJhY2tncm91bmQtc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCIsIGNvbG9yOiBcInN1Y2Nlc3NcIiB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB1aU9mZiA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVZhcmlhbnQoXG4gICAgICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICAgICAgdmFsdWVJZCxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcIlwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogXCJub3Qtbm9kZTpib29sZWFuc19mYWxzZVwiLCBjb2xvcjogXCJkYW5nZXJcIiB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmRWYXJpYW50VG9JdGVtTGlzdCA9IChpdG0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHsgLi4uaXRtIH07XG4gICAgICAgICAgICByZXMuYWN0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIm5vdC1ub2RlOmJvb2xlYW5zX2ZhbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB0b2dnbGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBvbmNoYW5nZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGl0ZW1zID0gdmFyaWFudHMubWFwKGV4dGVuZFZhcmlhbnRUb0l0ZW1MaXN0KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoYXRMZWFzdE9uZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVpID0gdXBkYXRlU2VsZWN0ZWQoaXRlbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVUkodWkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdERlZmF1bHQoKTtcbiAgICB9KTtcbiAgICAvL1xuICAgIGZ1bmN0aW9uIGNvdW50T2ZTZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gc2VsZWN0ZWRWYXJpYW50c0lkcy5sZW5ndGggOiAwO1xuICAgIH1cblxuICAgIGNvbnN0IG5vdExhc3RPbmUgPSAoKSA9PiAhKGF0TGVhc3RPbmUgJiYgY291bnRPZlNlbGVjdGVkKCkgPT09IDEpO1xuICAgIC8vXG4gICAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWQoZGV0YWlsKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlSWQgPSBzdWJsaW1lVmFsdWUoZGV0YWlsKTtcbiAgICAgICAgbGV0IHVpID0ge1xuICAgICAgICAgICAgb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICAvL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZWN0ZWRWYXJpYW50c0lkcykpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhcmlhbnRzSWRzLmluY2x1ZGVzKHZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdExhc3RPbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuaW5kZXhPZih2YWx1ZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdWkub2ZmID0geyB2YWx1ZUlkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzLnB1c2godmFsdWVJZCk7XG4gICAgICAgICAgICAgICAgdWkub24gPSB7IHZhbHVlSWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdExlYXN0T25lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFZhcmlhbnRzSWRzLmluY2x1ZGVzKHZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudE9mU2VsZWN0ZWQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLm9mZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkOiBzZWxlY3RlZFZhcmlhbnRzSWRzLnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1aS5vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSBbdmFsdWVJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYXJpYW50c0lkcy5pbmNsdWRlcyh2YWx1ZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5vZmYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuaW5kZXhPZih2YWx1ZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1aS5vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMucHVzaCh2YWx1ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdWk7XG4gICAgfVxuICAgIC8vXG4gICAgZnVuY3Rpb24gdG9nZ2xlKGRldGFpbCkge1xuICAgICAgICBsZXQgdWkgPSB1cGRhdGVTZWxlY3RlZChkZXRhaWwpO1xuICAgICAgICB1cGRhdGVVSSh1aSk7XG4gICAgICAgIC8vXG4gICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIC8vXG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSxcbiAgICAgICAgICAgIGlkczogJHN0YXRlLnNuYXBzaG90KHNlbGVjdGVkVmFyaWFudHNJZHMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVVSShjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm9mZikge1xuICAgICAgICAgICAgdWlPZmYoaXRlbXMsIGNoYW5nZXMub2ZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5vbikge1xuICAgICAgICAgICAgdWlPbihpdGVtcywgY2hhbmdlcy5vbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG5ld1ZhbCA9IFtdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VsZWN0ZWRWYXJpYW50c0lkcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzZWxlY3RlZFZhcmlhbnRzSWRzKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IHNlbGVjdGVkVmFyaWFudHNJZHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWwpID0+IHR5cGVvZiB2YWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgLm1hcCgodmFsdWVJZCkgPT5cbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbVZhbHVlKGl0ZW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBuZXdWYWw7XG4gICAgfVxuICAgIC8vXG4gICAgZnVuY3Rpb24gc2VsZWN0RGVmYXVsdCgpIHtcbiAgICAgICAgaWYgKGF0TGVhc3RPbmUgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmVmFsdWVJZCA9IGdldERlZmF1bHRJdGVtU3VibGltZShpdGVtcyk7XG4gICAgICAgICAgICBpZiAoZGVmVmFsdWVJZCkge1xuICAgICAgICAgICAgICAgIHRvZ2dsZSh7IGlkOiBkZWZWYWx1ZUlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSUxpc3RDb21wb25lbnRcbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgey4uLm90aGVyc31cbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIHtpdGVtc31cbi8+XG4iLCJpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2Ygc3RhdGljIG1ldGhvZHMgdG8gd29yayB3aXRoIFNlbGVjdG9yR3JvdXBzIG9iamVjdHNcbiAqXG4gKiBAY2xhc3MgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICovXG5jbGFzcyBMaXN0R3JvdXBzVUlUcmVlRFRPIHtcbiAgICBzdGF0aWMgVUlfUFJPUFNfREVMVEFfT04gPSB7XG4gICAgICAgIGNsYXNzOiBcImhhcy1iYWNrZ3JvdW5kLXN1Y2Nlc3NcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIFVJX1BST1BTX0RFTFRBX09GRiA9IHtcbiAgICAgICAgY2xhc3M6IFwiXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBVSV9QUk9QU19ERUxUQV9PTl9BQ1RJT04gPSB7XG4gICAgICAgIHRpdGxlOiBcIm5vdC1ub2RlOmJvb2xlYW5zX3RydWVcIixcbiAgICAgICAgY29sb3I6IFwic3VjY2Vzc1wiLFxuICAgIH07XG5cbiAgICBzdGF0aWMgVUlfUFJPUFNfREVMVEFfT0ZGX0FDVElPTiA9IHtcbiAgICAgICAgdGl0bGU6IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIixcbiAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGl0bGUgZmllbGQgZnJvbSBvYmplY3QgYXMgc3RyaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgdmFsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICB2YWwudGl0bGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydEdyb3VwVGl0bGUoeyB0aXRsZSB9KSB7XG4gICAgICAgIHJldHVybiB0aXRsZTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGltYWdlIGZpZWxkIGZyb20gb2JqZWN0IGFzIHN0cmluZ1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gIHZhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgdmFsLmltYWdlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG5cbiAgICBzdGF0aWMgY29udmVydEdyb3VwSW1hZ2UoeyBpbWFnZSB9KSB7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdmFyaWFudCBvYmplY3QgdG8gc2VsZWN0b3IgaXRlbSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50fSB2YXJpYW50XG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9ySXRlbX1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0VmFyaWFudCh2YXJpYW50LCBncm91cElkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdmFyaWFudC5pZCxcbiAgICAgICAgICAgIHRpdGxlOiB2YXJpYW50LnRpdGxlLFxuICAgICAgICAgICAgdmFsdWU6IHsgdmFsdWVJZDogdmFyaWFudC5pZCwgZ3JvdXBJZCB9LCAvL3doYXQgd2Ugd2lsbCBzdWJsaW1lXG4gICAgICAgIH07XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudHNHcm91cH0gZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0VmFyaWFudHNHcm91cChncm91cCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGdyb3VwLmlkLFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMuY29udmVydEdyb3VwVGl0bGUoZ3JvdXApLFxuICAgICAgICAgICAgaW1hZ2U6IHRoaXMuY29udmVydEdyb3VwSW1hZ2UoZ3JvdXApLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGdyb3VwLnZhcmlhbnRzLm1hcCgoaXRtKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnRWYXJpYW50KGl0bSwgZ3JvdXAuaWQpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudHNHcm91cHN9IHZhcmlhbnRzXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkU2VsZWN0b3JJdGVtc0Zyb21WYXJpYW50cyh2YXJpYW50cykge1xuICAgICAgICByZXR1cm4gdmFyaWFudHMubWFwKChpdG0pID0+IHRoaXMuY29udmVydFZhcmlhbnRzR3JvdXAoaXRtKSk7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyB7Z3JvdXA6IG51bWJlciwgaWQ6IG51bWJlcn0gYXMgU2VsZWN0ZWRWYXJpYW50IHR5cGUge2dyb3VwSWQ6IHN0cmluZ3xudW1iZXIsIHZhbHVlSWQ6IHN0cmluZ3xudW1iZXJ9XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSAgIHtvYmplY3R9IHZhbHVlXG4gICAgICogQHJldHVybiAge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3RlZFZhcmlhbnR9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgc3VibGltZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cElkOiB2YWx1ZS5ncm91cCB8fCB2YWx1ZS5ncm91cElkLFxuICAgICAgICAgICAgdmFsdWVJZDogdmFsdWUuaWQgfHwgdmFsdWUudmFsdWVJZCxcbiAgICAgICAgfTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmRleCBvZiBncm91cCBpbiBhcnJheSBieSBncm91cElkIG9yIHVuZGVmaW5lZCBpZiBpdHMgbm90IGZvdW5kXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9IHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3Rvckdyb3VwSW5kZXgoc2VsZWN0b3JHcm91cHNJdGVtcywgZ3JvdXBJZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHNlbGVjdG9yR3JvdXBzSXRlbXMuZmluZEluZGV4KFxuICAgICAgICAgICAgKGdyb3VwKSA9PiBncm91cC5pZCA9PT0gZ3JvdXBJZFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGluZGV4IDogdW5kZWZpbmVkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3VwfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yR3JvdXAoc2VsZWN0b3JHcm91cHNJdGVtcywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yR3JvdXBzSXRlbXNbaW5kZXhdO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3VwfSBncm91cFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0b3JHcm91cEhhc1ZhcmlhbnRzKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBncm91cCAmJlxuICAgICAgICAgICAgZ3JvdXAuZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ3JvdXAuZGVzY3JpcHRpb24udmFsdWVzKVxuICAgICAgICApO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cH0gZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi90eXBlcy5qc1wiKS5TZWxlY3Rvckl0ZW1zfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yR3JvdXBWYXJpYW50cyhncm91cCkge1xuICAgICAgICByZXR1cm4gZ3JvdXAuZGVzY3JpcHRpb24udmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGFyYXRpb24gZnVuY3Rpb24sICh2YWw6IFNlbGVjdG9ySXRlbSk9PmJvb2xlYW4sXG4gICAgICogd2hpY2ggY2hlY2tzIGlmIHZhbCBoYXMgc3BlY2lmaWVkIHZhcmlhbnRJZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlZhcmlhbnRJZH0gdmFyaWFudElkXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVNlbGVjdG9yR3JvdXBWYWx1ZUlkV2l0aCh2YXJpYW50SWQpIHtcbiAgICAgICAgcmV0dXJuICh2YWwpID0+IHZhbD8udmFsdWU/LnZhbHVlSWQgPT09IHZhcmlhbnRJZDtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmRleCBvZiBpdGVtIGluIGdyb3VwIGJ5IGdyb3VwSW5kZXggYW5kIGl0ZW0gdmFsdWVJZCBvciB1bmRlZmluZWQgaWYgaXRzIG5vdCBmb3VuZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4XG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSB2YWx1ZUlkXG4gICAgICogQHJldHVybnMge251bWJlcnx1bmRlZmluZWR9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3JJdGVtSW5kZXgoc2VsZWN0b3JHcm91cHNJdGVtcywgZ3JvdXBJbmRleCwgdmFsdWVJZCkge1xuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBncm91cEluZGV4KTtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yR3JvdXBIYXNWYXJpYW50cyhncm91cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwVmFyaWFudHMoZ3JvdXApLmZpbmRJbmRleChcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZVNlbGVjdG9yR3JvdXBWYWx1ZUlkV2l0aCh2YWx1ZUlkKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaXRlbUluZGV4ID4gLTEgPyBpdGVtSW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMge2dyb3VwSW5kZXg6IG51bWJlciwgaXRlbUluZGV4OiBudW1iZXJ9IG9yIHVuZGVmaW5lZCBmcm9tIFZhcmlhbnRzR3JvdXBzIGJ5IGdyb3VwSWQsIHZhbHVlSWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlZhcmlhbnRJZH0gZ3JvdXBJZFxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlZhcmlhbnRJZH0gdmFsdWVJZFxuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSW5kZXhlcyB8IHVuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3Rvckl0ZW1JbmRleGVzKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGdyb3VwSWQsIHZhbHVlSWQpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cEluZGV4KFxuICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtcyxcbiAgICAgICAgICAgIGdyb3VwSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IC0xIHx8IHR5cGVvZiBncm91cEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHRoaXMuZ2V0U2VsZWN0b3JJdGVtSW5kZXgoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIHZhbHVlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEgfHwgdHlwZW9mIGl0ZW1JbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIGl0ZW1JbmRleCxcbiAgICAgICAgfTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gICBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuSXRlbUlkc30gICAgICAgaXRlbUlkc1xuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckl0ZW19XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3JJdGVtKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGl0ZW1JZHMpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuSXRlbUluZGV4ZXMgfCB1bmRlZmluZWR9ICovXG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdG9ySXRlbUluZGV4ZXMoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgaXRlbUlkcy5ncm91cElkLFxuICAgICAgICAgICAgaXRlbUlkcy52YWx1ZUlkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbmRleGVzKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cChcbiAgICAgICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgICAgIGluZGV4ZXMuZ3JvdXBJbmRleFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rvckdyb3VwSGFzVmFyaWFudHMoZ3JvdXApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwVmFyaWFudHMgPSB0aGlzLmdldFNlbGVjdG9yR3JvdXBWYXJpYW50cyhncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBWYXJpYW50c1tpbmRleGVzLml0ZW1JbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3RlZFZhcmlhbnQgfCB1bmRlZmluZWR9XG4gICAgICogQG1lbWJlcm9mIFVJTGlzdFNlbGVjdFdpdGhHcm91cHNCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdFNlbGVjdG9ySXRlbVN1YmxpbWUoc2VsZWN0b3JHcm91cHNJdGVtcykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zICYmXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvckdyb3VwSGFzVmFyaWFudHMoc2VsZWN0b3JHcm91cHNJdGVtc1swXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cElkID0gc2VsZWN0b3JHcm91cHNJdGVtc1swXS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlSWQgPVxuICAgICAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXNbMF0uZGVzY3JpcHRpb24udmFsdWVzWzBdPy52YWx1ZT8udmFsdWVJZDtcbiAgICAgICAgICAgIGlmIChVSUNvbW1vbi5zdHJpbmdzT2ZOdW1iZXJzKFtncm91cElkLCB2YWx1ZUlkXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBzZWxlY3RvciBpdGVtc1xuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuSXRlbUlkc30gaXRlbUlkc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtUHJvcHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWN0aW9uc1VJUHJvcHNcbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICogQG1lbWJlcm9mIFVJTGlzdFNlbGVjdFdpdGhHcm91cHNCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlU2VsZWN0b3JJdGVtKFxuICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICBpdGVtSWRzLFxuICAgICAgICBpdGVtUHJvcHMsXG4gICAgICAgIGFjdGlvbnNVSVByb3BzXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdG9ySXRlbUluZGV4ZXMoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgaXRlbUlkcy5ncm91cElkLFxuICAgICAgICAgICAgaXRlbUlkcy52YWx1ZUlkXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGl0ZW1Qcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zW2luZGV4ZXMuZ3JvdXBJbmRleF0uZGVzY3JpcHRpb24udmFsdWVzW1xuICAgICAgICAgICAgICAgIGluZGV4ZXMuaXRlbUluZGV4XG4gICAgICAgICAgICBdW2tleV0gPSBpdGVtUHJvcHNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtc1tpbmRleGVzLmdyb3VwSW5kZXhdLmRlc2NyaXB0aW9uLnZhbHVlc1tcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5pdGVtSW5kZXhcbiAgICAgICAgICAgICAgICBdLmFjdGlvbnNcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXNbaW5kZXhlcy5ncm91cEluZGV4XS5kZXNjcmlwdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgaW5kZXhlcy5pdGVtSW5kZXhcbiAgICAgICAgICAgIF0uYWN0aW9ucy5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1aVByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zW2luZGV4ZXMuZ3JvdXBJbmRleF0uZGVzY3JpcHRpb24udmFsdWVzW1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLml0ZW1JbmRleFxuICAgICAgICAgICAgICAgIF1bMF1ba2V5XSA9IGFjdGlvbnNVSVByb3BzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuSXRlbUlkc30gICBpdGVtSWRzXG4gICAgICogQG1lbWJlcm9mIFVJTGlzdFNlbGVjdFdpdGhHcm91cHNCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgdWlPbihzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBpdGVtSWRzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0b3JJdGVtKFxuICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtcyxcbiAgICAgICAgICAgIGl0ZW1JZHMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5VSV9QUk9QU19ERUxUQV9PTixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IC4uLnRoaXMuVUlfUFJPUFNfREVMVEFfT05fQUNUSU9OIH1cbiAgICAgICAgKTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLkl0ZW1JZHN9ICAgaXRlbUlkc1xuICAgICAqIEBtZW1iZXJvZiBVSUxpc3RTZWxlY3RXaXRoR3JvdXBzQmVoYXZpb3VyXG4gICAgICovXG4gICAgc3RhdGljIHVpT2ZmKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGl0ZW1JZHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rvckl0ZW0oXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgaXRlbUlkcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLlVJX1BST1BTX0RFTFRBX09GRixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IC4uLnRoaXMuVUlfUFJPUFNfREVMVEFfT0ZGX0FDVElPTiB9XG4gICAgICAgICk7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIHN0YXRpYyBzeW5jVUlXaXRoVmFsdWUoc2VsZWN0b3JHcm91cHMsIGl0ZW1JblZhbHVlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2Ygc2VsZWN0b3JHcm91cHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwVmFyaWFudHMoZ3JvdXApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXAuaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUluVmFsdWUoaXRlbUlkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51aU9uKHNlbGVjdG9yR3JvdXBzLCBpdGVtSWRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpT2ZmKHNlbGVjdG9yR3JvdXBzLCBpdGVtSWRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yR3JvdXBzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlzdEdyb3Vwc1VJVHJlZURUTztcbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbmNsYXNzIExpc3RHcm91cHNWYWx1ZURUT011bHRpcGxlQmVoYXZpb3VyIHtcbiAgICBzdGF0aWMgY291bnRJdGVtc0luVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh2YWx1ZSkucmVkdWNlKChhLCBiKSA9PiAoYSArPSBiLmxlbmd0aCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModmFsdWUpLmV2ZXJ5KHRoaXMuZ3JvdXBJdGVtc0lzVmFsaWQpXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIHN0YXRpYyBncm91cEl0ZW1zSXNWYWxpZChncm91cEl0ZW1zKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShncm91cEl0ZW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cEl0ZW1zLmV2ZXJ5KChpdG0pID0+IFVJQ29tbW9uLnN0cmluZ09yTnVtYmVyKGl0bSkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpdGVtSW5WYWx1ZSh2YWx1ZSwgaXRlbSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgT2JqZWN0Lmhhc093bih2YWx1ZSwgaXRlbS5ncm91cElkKSAmJlxuICAgICAgICAgICAgdmFsdWVbaXRlbS5ncm91cElkXS5pbmNsdWRlcyhpdGVtLnZhbHVlSWQpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsZWFyRnJvbUVtcHR5R3JvdXBzKHZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwSXNFbXB0eSh2YWx1ZVtrZXldKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ3JvdXBJc0VtcHR5KGdyb3VwKSB7XG4gICAgICAgIGlmIChncm91cCAmJiBBcnJheS5pc0FycmF5KGdyb3VwKSkge1xuICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBncm91cElzRnVsbCh2YWx1ZUdyb3VwLCB2YXJpYW50c0dyb3VwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUdyb3VwLmxlbmd0aCA9PT0gdmFyaWFudHNHcm91cD8udmFyaWFudHM/Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlSXRlbUZyb21WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5hdExlYXN0T25lICYmIHRoaXMuY291bnRJdGVtc0luVmFsdWUodmFsdWUpID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVbaXRlbS5ncm91cElkXS5zcGxpY2UoXG4gICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLmluZGV4T2YoaXRlbS52YWx1ZUlkKSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbGVhckZyb21FbXB0eUdyb3Vwcyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuTGlzdEdyb3Vwc09wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1ZhbHVlRFRPTXVsdGlwbGVCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSXRlbVRvVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub25seU9uZVBlckdyb3VwKSB7XG4gICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdID0gW2l0ZW0udmFsdWVJZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlW2l0ZW0uZ3JvdXBJZF0gfHwgIUFycmF5LmlzQXJyYXkodmFsdWVbaXRlbS5ncm91cElkXSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdID0gW2l0ZW0udmFsdWVJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWVbaXRlbS5ncm91cElkXS5pbmNsdWRlcyhpdGVtLnZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0ucHVzaChpdGVtLnZhbHVlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3RBbGwodmFyaWFudHMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhcmlhbnRzLmZvckVhY2goKHZhcmlhbnRzR3JvdXApID0+IHtcbiAgICAgICAgICAgIHZhcmlhbnRzR3JvdXAudmFyaWFudHMuZm9yRWFjaCgodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSXRlbVRvVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkOiB2YXJpYW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogdmFyaWFudHNHcm91cC5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdE5vbmUodmFyaWFudHMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKChncm91cElkKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbZ3JvdXBJZF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3RBbGxJbkdyb3VwKHZhcmlhbnRzLCB2YWx1ZSwgZ3JvdXBJZCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIVVJQ29tbW9uLnN0cmluZ09yTnVtYmVyKGdyb3VwSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFudHNHcm91cCA9IHZhcmlhbnRzLmZpbmQoKGl0bSkgPT4gaXRtLmlkID09IGdyb3VwSWQpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdmFyaWFudHNHcm91cCB8fFxuICAgICAgICAgICAgIXZhcmlhbnRzR3JvdXAudmFyaWFudHMgfHxcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhcmlhbnRzR3JvdXAudmFyaWFudHMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhbnRzR3JvdXAudmFyaWFudHMuZm9yRWFjaCgodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtVG9WYWx1ZSh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgdmFsdWVJZDogdmFyaWFudC5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0Tm9uZUluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh2YWx1ZVtncm91cElkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2dyb3VwSWRdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHZhbHVlQXNWYXJpYW50cyh2YWx1ZSwgdmFyaWFudHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIHZhcmlhbnRzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5ncm91cElzRW1wdHkoZ3JvdXAuaWQpKSByZXR1cm47XG4gICAgICAgICAgICBncm91cC52YXJpYW50cy5mb3JFYWNoKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JblZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBncm91cC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHZhcmlhbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtncm91cC5pZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZ3JvdXAuaWRdLnB1c2godmFyaWFudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZ3JvdXAuaWRdID0gW3ZhcmlhbnRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlzdEdyb3Vwc1ZhbHVlRFRPTXVsdGlwbGVCZWhhdmlvdXI7XG4iLCJpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi5qc1wiO1xuXG5jbGFzcyBMaXN0R3JvdXBzVmFsdWVEVE9TaW5nbGVCZWhhdmlvdXIge1xuICAgIHN0YXRpYyBjb3VudEl0ZW1zSW5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgICAgIFVJQ29tbW9uLnN0cmluZ3NPZk51bWJlcnMoW3ZhbHVlLnZhbHVlSWQsIHZhbHVlLmdyb3VwSWRdKVxuICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgc3RhdGljIGluaXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiZcbiAgICAgICAgICAgIFVJQ29tbW9uLnN0cmluZ3NPZk51bWJlcnMoW3ZhbHVlLnZhbHVlSWQsIHZhbHVlLmdyb3VwSWRdKVxuICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgOiB7IHZhbHVlSWQ6IHVuZGVmaW5lZCwgZ3JvdXBJZDogdW5kZWZpbmVkIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGl0ZW1JblZhbHVlKHZhbHVlLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKHZhbHVlLCBcImdyb3VwSWRcIikgJiZcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24odmFsdWUsIFwidmFsdWVJZFwiKSAmJlxuICAgICAgICAgICAgVUlDb21tb24uc3RyaW5nc09mTnVtYmVycyhbdmFsdWUudmFsdWVJZCwgdmFsdWUuZ3JvdXBJZF0pICYmXG4gICAgICAgICAgICB2YWx1ZS5ncm91cElkID09IGl0ZW0uZ3JvdXBJZCAmJlxuICAgICAgICAgICAgdmFsdWUudmFsdWVJZCA9PSBpdGVtLnZhbHVlSWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5MaXN0R3JvdXBzT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVmFsdWVEVE9TaW5nbGVCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlSXRlbUZyb21WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuYXRMZWFzdE9uZSkge1xuICAgICAgICAgICAgdmFsdWVbaXRlbS5ncm91cElkXS5zcGxpY2UoXG4gICAgICAgICAgICAgICAgdmFsdWVbaXRlbS5ncm91cElkXS5pbmRleE9mKGl0ZW0udmFsdWVJZCksXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBhZGRJdGVtVG9WYWx1ZSh2YWx1ZSwgaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5pdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUudmFsdWVJZCA9IGl0ZW0udmFsdWVJZDtcbiAgICAgICAgdmFsdWUuZ3JvdXBJZCA9IGl0ZW0uZ3JvdXBJZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgdmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cykge1xuICAgICAgICBpZiAodGhpcy5jb3VudEl0ZW1zSW5WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50c1xuICAgICAgICAgICAgICAgIC5maW5kKChncm91cCkgPT4gZ3JvdXAuaWQgPT09IHZhbHVlLmdyb3VwSWQpXG4gICAgICAgICAgICAgICAgLnZhcmlhbnRzLmZpbmQoKHZhcmlhbnQpID0+IHZhcmlhbnQuaWQgPT09IHZhbHVlLnZhbHVlSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBzVmFsdWVEVE9TaW5nbGVCZWhhdmlvdXI7XG4iLCJpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi5qc1wiO1xuXG5pbXBvcnQgTGlzdEdyb3Vwc1ZhbHVlRFRPTXVsdGlwbGVCZWhhdmlvdXIgZnJvbSBcIi4vbGlzdC5ncm91cHMudmFsdWUuZHRvLm11bHRpcGxlLmJlaGF2aW91ci5qc1wiO1xuaW1wb3J0IExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91ciBmcm9tIFwiLi9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8uc2luZ2xlLmJlaGF2aW91ci5qc1wiO1xuXG5jbGFzcyBMaXN0R3JvdXBzVmFsdWVEVE8ge1xuICAgIHN0YXRpYyBiZWhhdmlvdXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5tdWx0aXBsZVxuICAgICAgICAgICAgPyBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91clxuICAgICAgICAgICAgOiBMaXN0R3JvdXBzVmFsdWVEVE9TaW5nbGVCZWhhdmlvdXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGluaXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuaW5pdFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3VyKG9wdGlvbnMpLml0ZW1JblZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdGVkVmFsdWVzfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAgICogQHBhcmFtIHtMaXN0R3JvdXBzT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVmFsdWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9nZ2xlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLml0ZW1JblZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSXRlbVRvVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZUl0ZW1Gcm9tVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvdXIob3B0aW9ucykucmVtb3ZlSXRlbUZyb21WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFkZEl0ZW1Ub1ZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3VyKG9wdGlvbnMpLmFkZEl0ZW1Ub1ZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0QWxsKHZhcmlhbnRzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5zZWxlY3RBbGwodmFyaWFudHMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0Tm9uZSh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuc2VsZWN0Tm9uZSh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3RBbGxJbkdyb3VwKHZhcmlhbnRzLCB2YWx1ZSwgZ3JvdXBJZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5zZWxlY3RBbGxJbkdyb3VwKFxuICAgICAgICAgICAgdmFyaWFudHMsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdE5vbmVJbkdyb3VwKHZhcmlhbnRzLCB2YWx1ZSwgZ3JvdXBJZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5zZWxlY3ROb25lSW5Hcm91cChcbiAgICAgICAgICAgIHZhcmlhbnRzLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyB2YWx1ZUFzVmFyaWFudHModmFsdWUsIHZhcmlhbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW91cihvcHRpb25zKS52YWx1ZUFzVmFyaWFudHModmFsdWUsIHZhcmlhbnRzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cHNWYWx1ZURUTztcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8vXG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgTGlzdEdyb3Vwc1VJVHJlZURUTyBmcm9tIFwiLi9kdG8vbGlzdC5ncm91cHMudWkudHJlZS5kdG8uanNcIjtcbiAgICBpbXBvcnQgTGlzdEdyb3Vwc1ZhbHVlRFRPIGZyb20gXCIuL2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8uanNcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgICAgIFtmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0XCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCBuYW1lXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtvbmNoYW5nZV0gIGNhbGxiYWNrIG9uIHZhbHVlIGNoYW5nZSBldmVudFxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8aW1wb3J0KCcuL3R5cGVzLmpzJykuVmFyaWFudHNHcm91cHM+fSAgIFt2YXJpYW50cyA9IFtdXSAgICAgICAgICAgdmFyaWFudHMgdG8gc2VsZWN0IGZyb21cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PGltcG9ydCgnLi90eXBlcy5qcycpLlNlbGVjdGVkVmFsdWVzfSAgW3ZhcmlhbnRzU2VsZWN0ZWRdIC0gbXVsdGlwbGUgJiYgbXVsdGlwbGUgaW4gZ3JvdXBcbiAgICAgKiBAcHJvcGVydHkge2FycmF5PGltcG9ydCgnLi90eXBlcy5qcycpLlNlbGVjdGVkVmFyaWFudHN9ICB2YWx1ZSAtIHtbZ3JvdXBJZF06IFsuLi52YWx1ZXNPZlNlbGVjdGVkSXRlbXNdfVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbYmVoYXZpb3VyVUkgPSBMaXN0R3JvdXBzVUlUcmVlRFRPXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbYmVoYXZpb3VyVmFsdWUgPSBMaXN0R3JvdXBzVmFsdWVEVE9dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgICAgIFttdWx0aXBsZSA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgd2FudCBub3Qgb25lIHZhcmlhbnQgc2VsZWN0ZWRcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgW29ubHlPbmVQZXJHcm91cCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgICAgIFthdExlYXN0T25lID0gdHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gZW1wdHkgcmVzdWx0XG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFt0aXRsZUNvbXBvbmVudFByb3BzPSB7IHNpemU6IDUgfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2ltYWdlQ29tcG9uZW50ID0gVUlJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2ltYWdlQ29tcG9uZW50UHJvcHM9IHsgY292ZXJlZDogdHJ1ZSB9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbZGVzY3JpcHRpb25Db21wb25lbnQgPSBVSUJ1dHRvbnNdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtsaXN0Q29tcG9uZW50ID0gVUlMaXN0XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbbGlzdENvbXBvbmVudFByb3BzID0ge31dXG4gICAgICovXG5cbiAgICBsZXQgc2VsZWN0b3JHcm91cHMgPSAkc3RhdGUoW10pO1xuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0LXRhZ3NcIixcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgdmFyaWFudHNTZWxlY3RlZCA9IHt9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYmVoYXZpb3VyVUkgPSBMaXN0R3JvdXBzVUlUcmVlRFRPLFxuICAgICAgICBiZWhhdmlvdXJWYWx1ZSA9IExpc3RHcm91cHNWYWx1ZURUTyxcbiAgICAgICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAgICAgb25seU9uZVBlckdyb3VwID0gdHJ1ZSxcbiAgICAgICAgYXRMZWFzdE9uZSA9IHRydWUsXG5cbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCA9IFVJQnV0dG9ucyxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0Q29tcG9uZW50OiBVSUxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVVJKCkge1xuICAgICAgICBzZWxlY3Rvckdyb3VwcyA9IGJlaGF2aW91clVJLnN5bmNVSVdpdGhWYWx1ZShcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzLFxuICAgICAgICAgICAgKGl0ZW1JZHMpID0+XG4gICAgICAgICAgICAgICAgYmVoYXZpb3VyVmFsdWUuaXRlbUluVmFsdWUodmFsdWUsIGl0ZW1JZHMsIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBzZWxlY3Rvckdyb3VwcyA9IGJlaGF2aW91clVJLmJ1aWxkU2VsZWN0b3JJdGVtc0Zyb21WYXJpYW50cyh2YXJpYW50cyk7XG4gICAgICAgIHZhbHVlID0gYmVoYXZpb3VyVmFsdWUuaW5pdFZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgIH0pO1xuXG4gICAgZXhwb3J0IGNvbnN0IHZhbHVlQXNWYXJpYW50cyA9ICgpID0+XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnZhbHVlQXNWYXJpYW50cyh2YWx1ZSwgdmFyaWFudHMpO1xuXG4gICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgdmFyaWFudHNTZWxlY3RlZCA9IHZhbHVlQXNWYXJpYW50cygpO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBjb25zdCB0b2dnbGVJdGVtID0gKGl0ZW1WYWx1ZSkgPT4ge1xuICAgICAgICBiZWhhdmlvdXJWYWx1ZS50b2dnbGUodmFsdWUsIGl0ZW1WYWx1ZSwge1xuICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGVVSSgpO1xuXG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxVSUxpc3RDb21wb25lbnRcbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcz17e1xuICAgICAgICBhY3Rpb24oZXZlbnQsIGl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlSXRlbShpdGVtVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAuLi5kZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzLFxuICAgIH19XG4gICAge2ltYWdlQ29tcG9uZW50fVxuICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgIGl0ZW1zPXtzZWxlY3Rvckdyb3Vwc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvL1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL3VpLmxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uLy4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4uLy4uL2ltYWdlL3VpLmltYWdlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uLy4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnNTd2l0Y2hlcnMgZnJvbSBcIi4uLy4uL2J1dHRvbi91aS5idXR0b25zLnN3aXRjaGVycy5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBMaXN0R3JvdXBzVUlUcmVlRFRPIGZyb20gXCIuL2R0by9saXN0Lmdyb3Vwcy51aS50cmVlLmR0by5qc1wiO1xuICAgIGltcG9ydCBMaXN0R3JvdXBzVmFsdWVEVE8gZnJvbSBcIi4vZHRvL2xpc3QuZ3JvdXBzLnZhbHVlLmR0by5qc1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdICBjYWxsYmFjayBvbiB2YWx1ZSBjaGFuZ2UgZXZlbnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZT1cImxpc3Qtc2VsZWN0LXRhZ3NcIl1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vdHlwZXMnKS5WYXJpYW50c0dyb3Vwc30gW3ZhcmlhbnRzID0gW11dIC1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vdHlwZXMnKS5TZWxlY3RlZFZhbHVlc30gW3ZhcmlhbnRzU2VsZWN0ZWQgPSB7fV0gLSBtdWx0aXBsZSAmJiBtdWx0aXBsZSBpbiBncm91cFxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi90eXBlcycpLlNlbGVjdGVkVmFyaWFudHN9IFt2YWx1ZSA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYmVoYXZpb3VyVUkgPSBMaXN0R3JvdXBzVUlUcmVlRFRPXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYmVoYXZpb3VyVmFsdWUgPSBMaXN0R3JvdXBzVmFsdWVEVE9dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlwbGUgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29ubHlPbmVQZXJHcm91cCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYXRMZWFzdE9uZSA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW3RpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDV9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbWFnZUNvbXBvbmVudCA9IFVJSW1hZ2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zU3dpdGNoZXJzXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtsaXN0Q29tcG9uZW50ID0gVUlMaXN0XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbbGlzdENvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbYWN0aW9uc0xpc3Q9W1wic2VsZWN0QWxsXCIsIFwic2VsZWN0Tm9uZVwiXV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0LXRhZ3NcIixcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgdmFyaWFudHNTZWxlY3RlZCA9IHt9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLy9iZWhhdmlvdXIgbWFuYWdlcnNcbiAgICAgICAgYmVoYXZpb3VyVUkgPSBMaXN0R3JvdXBzVUlUcmVlRFRPLFxuICAgICAgICBiZWhhdmlvdXJWYWx1ZSA9IExpc3RHcm91cHNWYWx1ZURUTyxcbiAgICAgICAgLy9iZWhhdmlvdXIgb3B0aW9uc1xuICAgICAgICBtdWx0aXBsZSA9IHRydWUsXG4gICAgICAgIG9ubHlPbmVQZXJHcm91cCA9IHRydWUsXG4gICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlLFxuICAgICAgICAvL2NvbW9wbmVudHMsIHJlbmRlcmVycyBhbmQgcHJvcHMgZm9yIHRoZW1cbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCA9IFVJQnV0dG9uc1N3aXRjaGVycyxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0Q29tcG9uZW50OiBVSUxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBhY3Rpb25zTGlzdCA9IFtcInNlbGVjdEFsbFwiLCBcInNlbGVjdE5vbmVcIl0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgLy9cblxuICAgIGNvbnN0IEFWQUlMQUJMRV9BQ1RJT05TID0ge1xuICAgICAgICBzZWxlY3RBbGw6IHtcbiAgICAgICAgICAgIHRpdGxlOiBcItCS0YvQsdGA0LDRgtGMINCy0YHQtVwiLFxuICAgICAgICAgICAgY29sb3I6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgYWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0Tm9uZToge1xuICAgICAgICAgICAgdGl0bGU6IFwi0KHQvdGP0YLRjCDQstGL0LTQtdC70LXQvdC40LUg0YHQviDQstGB0LXRhVwiLFxuICAgICAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Tm9uZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgbGV0IEFDVElPTlMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBzZWxlY3Rvckdyb3VwcyA9ICRzdGF0ZShbXSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVVSSgpIHtcbiAgICAgICAgc2VsZWN0b3JHcm91cHMgPSBiZWhhdmlvdXJVSS5zeW5jVUlXaXRoVmFsdWUoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3VwcyxcbiAgICAgICAgICAgIChpdGVtSWRzKSA9PlxuICAgICAgICAgICAgICAgIGJlaGF2aW91clZhbHVlLml0ZW1JblZhbHVlKHZhbHVlLCBpdGVtSWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBleHBvcnQgY29uc3QgdmFsdWVBc1ZhcmlhbnRzID0gKCkgPT5cbiAgICAgICAgYmVoYXZpb3VyVmFsdWUudmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cyk7XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0gdmFsdWVBc1ZhcmlhbnRzKCk7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGFjdGlvbnNMaXN0LmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oQVZBSUxBQkxFX0FDVElPTlMsIG5hbWUpXG4gICAgICAgICAgICAgICAgPyBBQ1RJT05TLnB1c2goQVZBSUxBQkxFX0FDVElPTlNbbmFtZV0pXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIEFDVElPTlMgPSBBQ1RJT05TO1xuICAgICAgICBzZWxlY3Rvckdyb3VwcyA9IGJlaGF2aW91clVJLmJ1aWxkU2VsZWN0b3JJdGVtc0Zyb21WYXJpYW50cyh2YXJpYW50cyk7XG4gICAgICAgIHZhbHVlID0gYmVoYXZpb3VyVmFsdWUuaW5pdFZhbHVlKHZhbHVlLCB7IG11bHRpcGxlIH0pO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgIH0pO1xuXG4gICAgZXhwb3J0IGNvbnN0IHNlbGVjdEFsbCA9ICgpID0+IHtcbiAgICAgICAgYmVoYXZpb3VyVmFsdWUuc2VsZWN0QWxsKHZhcmlhbnRzLCB2YWx1ZSwge1xuICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3Qgc2VsZWN0Tm9uZSA9ICgpID0+IHtcbiAgICAgICAgYmVoYXZpb3VyVmFsdWUuc2VsZWN0Tm9uZSh2YXJpYW50cywgdmFsdWUsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHNlbGVjdEFsbEluR3JvdXAgPSAoZ3JvdXBJZCkgPT4ge1xuICAgICAgICBiZWhhdmlvdXJWYWx1ZS5zZWxlY3RBbGxJbkdyb3VwKHZhcmlhbnRzLCB2YWx1ZSwgZ3JvdXBJZCwge1xuICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3Qgc2VsZWN0Tm9uZUluR3JvdXAgPSAoZ3JvdXBJZCkgPT4ge1xuICAgICAgICBiZWhhdmlvdXIuc2VsZWN0Tm9uZUluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCB0b2dnbGVJdGVtID0gKGl0ZW1WYWx1ZSkgPT4ge1xuICAgICAgICBiZWhhdmlvdXJWYWx1ZS50b2dnbGUodmFsdWUsIGl0ZW1WYWx1ZSwge1xuICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICB9KTtcblxuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfTtcbjwvc2NyaXB0PlxuXG48VUlCdXR0b25zIHZhbHVlcz17QUNUSU9OU30gY2VudGVyZWQ9e3RydWV9IC8+XG5cbjxVSUxpc3RDb21wb25lbnRcbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcz17e1xuICAgICAgICBhY3Rpb24oZXZlbnQsIGl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlSXRlbShpdGVtVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAuLi5kZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzLFxuICAgIH19XG4gICAge2ltYWdlQ29tcG9uZW50fVxuICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgIGl0ZW1zPXtzZWxlY3Rvckdyb3Vwc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50LCBvbkRlc3Ryb3kgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUJ1dHRvbkNsb3NlIH0gZnJvbSBcIi4uL2J1dHRvblwiO1xuXG4gICAgbGV0IG92ZXJmbG93U2F2ZSA9ICRzdGF0ZShcIlwiKTtcblxuICAgIGNvbnN0IGRlZmF1bHRDbG9zZUJ1dHRvblByb3BzID0ge1xuICAgICAgICBjbGFzczogXCJpcy1hYnNvbHV0ZSBpcy1zaWRlZC1yaWdodCBpcy1zaWRlZC10b3BcIixcbiAgICAgICAgc3R5bGU6IFwiLS1zaWRpbmctcmlnaHQtc2l6ZTogMnJlbTsgLS1zaWRpbmctdG9wLXNpemU6IDJyZW1cIixcbiAgICAgICAgc2l6ZTogXCJub3JtYWxcIixcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbY2xvc2VCdXR0b24gPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbY2xvc2VCdXR0b25Qcm9wcyA9IGRlZmF1bHRDbG9zZUJ1dHRvblByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtzaG93ID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbY2xvc2VPbkNsaWNrID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbbGF5ZXIgPSAxXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3pJbmRleFN0ZXAgPSAxMDAwXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlID0gJ2J1dHRvbiddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3RhYkluZGV4ID0gJ2J1dHRvbiddXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xvc2VCdXR0b24gPSBmYWxzZSxcbiAgICAgICAgY2xvc2VCdXR0b25Qcm9wcyA9IGRlZmF1bHRDbG9zZUJ1dHRvblByb3BzLFxuICAgICAgICBzaG93ID0gdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrID0gdHJ1ZSxcbiAgICAgICAgbGF5ZXIgPSAxLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBvbnJlamVjdCA9ICgpID0+IGZhbHNlLFxuICAgICAgICB6SW5kZXhTdGVwID0gMTAwMCxcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gXCIwXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb3ZlcmxheUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKGNsb3NlT25DbGljaykge1xuICAgICAgICAgICAgY2xvc2VPdmVybGF5KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VCdXR0b25DbGljaygpIHtcbiAgICAgICAgcmVqZWN0T3ZlcmxheSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlT3ZlcmxheShlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLm9yaWdpbmFsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5vcmlnaW5hbFRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImlzLW92ZXJsYXlcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0T3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3RPdmVybGF5KGRhdGEgPSB7fSkge1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgICAgIG9ucmVqZWN0KGRhdGEpO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBvdmVyZmxvd1NhdmUgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3dTYXZlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3dTYXZlO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjaWYgc2hvd31cbiAgICA8ZGl2XG4gICAgICAgIHRyYW5zaXRpb246ZmFkZVxuICAgICAgICBjbGFzcz1cImlzLW92ZXJsYXkgbm90LW92ZXJsYXkge2NsYXNzZXN9XCJcbiAgICAgICAgb25jbGljaz17b3ZlcmxheUNsaWNrfVxuICAgICAgICBvbmtleXVwPXtvdmVybGF5Q2xpY2t9XG4gICAgICAgIHtyb2xlfVxuICAgICAgICB7dGFiSW5kZXh9XG4gICAgICAgIHN0eWxlPVwiei1pbmRleDoge3pJbmRleFN0ZXAgKiBsYXllcn07XCJcbiAgICA+XG4gICAgICAgIHsjaWYgY2xvc2VCdXR0b259XG4gICAgICAgICAgICA8VUlCdXR0b25DbG9zZSB7Li4uY2xvc2VCdXR0b25Qcm9wc30gb25jbGljaz17Y2xvc2VCdXR0b25DbGlja30gLz5cbiAgICAgICAgey9pZn1cbiAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJT3ZlcmxheSBmcm9tIFwiLi91aS5vdmVybGF5LnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQm94IGZyb20gXCIuLi9ibG9jay91aS5ib3guc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udGVudCBmcm9tIFwiLi4vYmxvY2svdWkuY29udGVudC5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnNSb3cgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnJvdy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUxvYWRlciB9IGZyb20gXCIuLi92YXJpb3VzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYnV0dG9uc1Bvc2l0aW9uID0gXCJib3R0b21cIl0gICAgICAgICAgIHRvcCwgdG9wT2ZDb250ZW50LCBib3R0b21cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmdWxsc2NyZWVuID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2xvc2VCdXR0b24gPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcHBseUJ1dHRvbiA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGl0bGVTaXplID0gMl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGU9IFwiTW9kYWwgd2luZG93XCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdWJ0aXRsZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvdmVybGF5Q2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYnV0dG9uc0NsYXNzID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW1dBSVRJTkdfVEVYVCA9IFwi0J7QsdGA0LDQsdC+0YLQutCwXCJdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgYnV0dG9uc1Bvc2l0aW9uID0gXCJib3R0b21cIixcbiAgICAgICAgZnVsbHNjcmVlbiA9IGZhbHNlLFxuICAgICAgICBjbG9zZUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICBhcHBseUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICB0aXRsZVNpemUgPSAyLFxuICAgICAgICBzaG93ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgdGl0bGUgPSBcIk1vZGFsIHdpbmRvd1wiLFxuICAgICAgICBzdWJ0aXRsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb3ZlcmxheUNsYXNzOiBvdmVybGF5Q2xhc3MgPSBcIlwiLFxuICAgICAgICBidXR0b25zQ2xhc3M6IGJ1dHRvbnNDbGFzcyA9IFwiXCIsXG4gICAgICAgIFdBSVRJTkdfVEVYVCA9IFwi0J7QsdGA0LDQsdC+0YLQutCwXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgYnV0dG9ucyhtb3JlQ2xhc3Nlc3MgPSBcIlwiKX1cbiAgICA8VUlCdXR0b25zUm93XG4gICAgICAgIGNsYXNzPXtidXR0b25zQ2xhc3MgfHwgbW9yZUNsYXNzZXNzfVxuICAgICAgICBsZWZ0PXtjbG9zZUJ1dHRvbiA/IFtjbG9zZUJ1dHRvbl0gOiBbXX1cbiAgICAgICAgcmlnaHQ9e2FwcGx5QnV0dG9uID8gW2FwcGx5QnV0dG9uXSA6IFtdfVxuICAgIC8+XG57L3NuaXBwZXR9XG5cbjxVSU92ZXJsYXkge3Nob3d9IGNsb3NlT25DbGljaz17ZmFsc2V9IGNsb3NlQnV0dG9uPXtmYWxzZX0gY2xhc3M9e292ZXJsYXlDbGFzc30+XG4gICAgPFVJQm94IGNsYXNzPXtgJHtjbGFzc2VzfSAke2Z1bGxzY3JlZW4gPyBcImlzLWZ1bGxzY3JlZW5cIiA6IFwiXCJ9YH0+XG4gICAgICAgIHsjaWYgYnV0dG9uc1Bvc2l0aW9uID09PSBcInRvcFwifVxuICAgICAgICAgICAge0ByZW5kZXIgYnV0dG9ucyhcIlwiKX1cbiAgICAgICAgey9pZn1cbiAgICAgICAgPFVJVGl0bGUgc2l6ZT17dGl0bGVTaXplfSB7dGl0bGV9IHtzdWJ0aXRsZX0gLz5cbiAgICAgICAgPFVJQ29udGVudD5cbiAgICAgICAgICAgIDxVSUxvYWRlciBzaXplPVwicGFnZVwiIHtsb2FkaW5nfSB0aXRsZT17V0FJVElOR19URVhUfSAvPlxuXG4gICAgICAgICAgICB7I2lmIGJ1dHRvbnNQb3NpdGlvbiA9PT0gXCJ0b3BPZkNvbnRlbnRcIn1cbiAgICAgICAgICAgICAgICB7QHJlbmRlciBidXR0b25zKFwiXCIpfVxuICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXG4gICAgICAgICAgICB7I2lmIGJ1dHRvbnNQb3NpdGlvbiA9PT0gXCJib3R0b21cIn1cbiAgICAgICAgICAgICAgICB7QHJlbmRlciBidXR0b25zKGBpcy1tb2JpbGUgJHtmdWxsc2NyZWVuID8gXCJpcy1mb290ZXJcIiA6IFwiXCJ9YCl9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L1VJQ29udGVudD5cbiAgICA8L1VJQm94PlxuPC9VSU92ZXJsYXk+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlPdmVybGF5IGZyb20gXCIuL3VpLm92ZXJsYXkuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUVuZGxlc3NMaXN0IH0gZnJvbSBcIi4uL2xpc3QvZW5kbGVzc1wiO1xuICAgIGltcG9ydCBVSVNpbXBsZVNlYXJjaElucHV0IGZyb20gXCIuLi92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVUlCb3gsIFVJQmxvY2sgfSBmcm9tIFwiLi4vYmxvY2tcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmICAgICB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSAgICB7Ym9vbGVhbn0gICBbc2hvd11cbiAgICAgKiBAcHJvcGVydHkgICAge2Jvb2xlYW59ICAgW3Nob3dTZWFyY2ggPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbdGVybV1cbiAgICAgKiBAcHJvcGVydHkgICAgeyhmdWxsc2NyZWVufHdpZGV8bm9ybWFsfG5hcnJvdyl9IFtzaXplXSAgIDEwMHZ3LCA3NXZ3LCA1MHZ3LCAyNXZ3XG4gICAgICogQHByb3BlcnR5ICAgIHthbnl9ICAgICAgIFtpbnB1dENvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkgICAge29iamVjdH0gICAgW2lucHV0Q29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5ICAgIHthbnl9ICAgICAgIFtvdXRwdXRDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5ICAgIHtvYmplY3R9ICAgIFtvdXRwdXRDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkgICAge29iamVjdH0gICAgW2J1dHRvbnNQcm9wcyA9IHsgY2VudGVyZWQ6IHRydWUsIGNsYXNzOiBcIm10LTVcIix9XVxuICAgICAqIEBwcm9wZXJ0eSAgICB7b2JqZWN0fSAgICBbcmVzdWx0c11cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29ucHJldl1cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29ubmV4dF1cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29uY2hhbmdlXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7ZnVuY3Rpb259ICBbb25yZWplY3RdXG4gICAgICogQHByb3BlcnR5ICAgIHtmdW5jdGlvbn0gIFtvbnJlc29sdmVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHNob3cgPSB0cnVlLFxuICAgICAgICBzaG93U2VhcmNoID0gdHJ1ZSxcbiAgICAgICAgdGVybSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgc2l6ZSA9IFwibmFycm93XCIsXG4gICAgICAgIGlucHV0Q29tcG9uZW50OiBVSUlucHV0Q29tcG9uZW50ID0gVUlTaW1wbGVTZWFyY2hJbnB1dCxcbiAgICAgICAgaW5wdXRDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBvdXRwdXRDb21wb25lbnQ6IFVJT3V0cHV0Q29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdCxcbiAgICAgICAgb3V0cHV0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgYnV0dG9uc1Byb3BzID0ge1xuICAgICAgICAgICAgY2VudGVyZWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzczogXCJtdC01XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdEJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIHJlc3VsdHMgPSAkYmluZGFibGUoeyBsaXN0OiBbXSwgcGFnZTogMCwgcGFnZXM6IDAsIHNraXA6IDAsIGNvdW50OiAwIH0pLFxuICAgICAgICBvbmNoYW5nZSxcbiAgICAgICAgb25wcmV2LFxuICAgICAgICBvbm5leHQsXG4gICAgICAgIG9ucmVzb2x2ZSxcbiAgICAgICAgb25yZWplY3QsXG4gICAgICAgIGl0ZW1SZW5kZXJlcixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogJExPQ0FMRVtcIm5vdC1ub2RlOmJ1dHRvbl9jYW5jZWxfbGFiZWxcIl0sXG4gICAgICAgICAgICBhY3Rpb246IG9ucmVqZWN0LFxuICAgICAgICAgICAgLi4ucmVqZWN0QnV0dG9uUHJvcHMsXG4gICAgICAgIH0sXG4gICAgXTtcbjwvc2NyaXB0PlxuXG48VUlPdmVybGF5IHtvbnJlamVjdH0ge3Nob3d9IGNsb3NlT25DbGljaz17dHJ1ZX0gY2xvc2VCdXR0b249e2ZhbHNlfT5cbiAgICA8VUlCb3ggY2xhc3M9XCJtb2RhbC1zZWxlY3RvciB7c2l6ZX1cIj5cbiAgICAgICAgeyNpZiBzaG93U2VhcmNofVxuICAgICAgICAgICAgPFVJSW5wdXRDb21wb25lbnQge29uY2hhbmdlfSBiaW5kOnRlcm0gey4uLmlucHV0Q29tcG9uZW50UHJvcHN9IC8+XG4gICAgICAgIHsvaWZ9XG5cbiAgICAgICAgPFVJT3V0cHV0Q29tcG9uZW50XG4gICAgICAgICAgICBiaW5kOmRhdGE9e3Jlc3VsdHN9XG4gICAgICAgICAgICB7b25wcmV2fVxuICAgICAgICAgICAge29ubmV4dH1cbiAgICAgICAgICAgIG9uc2VsZWN0PXtvbnJlc29sdmV9XG4gICAgICAgICAgICBjbGFzcz1cImhhcy1oZWlnaHQtdXAtdG8tNjAgb3ZlcmZsb3ctc2Nyb2xsXCJcbiAgICAgICAgICAgIHsuLi5vdXRwdXRDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtpdGVtUmVuZGVyZXJ9XG4gICAgICAgIC8+XG5cbiAgICAgICAgPFVJQnV0dG9ucyB7Li4uYnV0dG9uc1Byb3BzfSB2YWx1ZXM9e2J1dHRvbnN9IC8+XG4gICAgPC9VSUJveD5cbjwvVUlPdmVybGF5PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGNsYXNzUHJlZml4ID0gXCJuYXZiYXItYnJhbmRcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLi4ub3RoZXJcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz17W2NsYXNzUHJlZml4LCBjbGFzc2VzXS5qb2luKFwiIFwiKX0gey4uLm90aGVyfT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyogZXNsaW50IHN2ZWx0ZS9uby1hdC1odG1sLXRhZ3M6IDAgKi9cbiAgICBpbXBvcnQgVUlJY29uIGZyb20gXCIuLi8uLi9pY29uL3VpLmljb24uc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaWNvbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdXJsID0gXCIvXCIsXG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgaWNvbiA9IHtcbiAgICAgICAgICAgIHNyYzogXCJodHRwczovL3BsYWNlaG9sZC5jby81Nng1Ni5wbmdcIixcbiAgICAgICAgICAgIHdpZHRoOiA1NixcbiAgICAgICAgICAgIGhlaWdodDogNTYsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzUHJlZml4ID0gXCJuYXZiYXItaXRlbVwiLFxuICAgICAgICB0aXRsZUNsYXNzID0gXCJuYXZiYXItaXRlbS1icmFuZC10aXRsZVwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxhIGNsYXNzPXtbY2xhc3NQcmVmaXgsIGNsYXNzZXNdLmpvaW4oXCIgXCIpfSBocmVmPXt1cmx9IGFyaWEtbGFiZWw9XCJicmFuZFwiPlxuICAgIHsjaWYgaWNvbn1cbiAgICAgICAgPFVJSWNvbiB7Li4uaWNvbn0gLz5cbiAgICB7L2lmfVxuICAgIHsjaWYgdGl0bGV9XG4gICAgICAgIDxzcGFuIGNsYXNzPXt0aXRsZUNsYXNzfT57dGl0bGV9PC9zcGFuPlxuICAgIHsvaWZ9XG48L2E+XG4iLCI8c2NyaXB0PlxuICAgIC8qIGVzbGludCBzdmVsdGUvbm8tYXQtaHRtbC10YWdzOiAwICovXG4gICAgaW1wb3J0IFVJTmF2YmFyQnJhbmRXcmFwcGVyIGZyb20gXCIuL3VpLm5hdmJhci5icmFuZC53cmFwcGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhckJyYW5kSXRlbSBmcm9tIFwiLi91aS5uYXZiYXIuYnJhbmQuaXRlbS5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IGJyYW5kICAgICAgICAgICAgIGJyYW5kIGRhdGEgb2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2NoaWxkcmVuXSAgICAgIGFkZGl0aW9uYWwgbm9kZXMgc25pcHBldHMsIGZvciBvcHRpb25hbCBidXJnZXJcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgYnJhbmQsIGNoaWxkcmVuIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlOYXZiYXJCcmFuZFdyYXBwZXI+XG4gICAgPFVJTmF2YmFyQnJhbmRJdGVtIHsuLi5icmFuZH0+PC9VSU5hdmJhckJyYW5kSXRlbT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L1VJTmF2YmFyQnJhbmRXcmFwcGVyPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMaW5rIGZyb20gXCIuLi8uLi8uLi9saW5rL3VpLmxpbmsuc3ZlbHRlXCI7XG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3NQcmVmaXggPSBcIm5hdmJhci1pdGVtXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhcmdldCA9IFwiX3NlbGZcIixcbiAgICAgICAgLi4ub3RoZXJcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFVJTGluayBjbGFzcz17W2NsYXNzUHJlZml4LCBjbGFzc2VzXS5qb2luKFwiIFwiKX0ge3RhcmdldH0gey4uLm90aGVyfVxuICAgID57QHJlbmRlciBjaGlsZHJlbj8uKCl9PC9VSUxpbmtcbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3NQcmVmaXggPSBcIm5hdmJhci1pdGVtXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2hpZGRlbiA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleCA9IDBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2sgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3NQcmVmaXggPSBcIm5hdmJhci1pdGVtXCIsXG4gICAgICAgIGhpZGRlbiA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gMCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIC4uLm90aGVyXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIHtpZH1cbiAgICBjbGFzcz17W2NsYXNzUHJlZml4LCBoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiBcIlwiLCBjbGFzc2VzXS5qb2luKFxuICAgICAgICBcIiBcIlxuICAgICl9XG4gICAge29uY2xpY2t9XG4gICAgb25rZXl1cD17b25LZXlVcH1cbiAgICB7cm9sZX1cbiAgICB7dGFiSW5kZXh9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi8uLi8uLi9sb2NhbGVcIjtcblxuICAgIGltcG9ydCBVSUljb24gZnJvbSBcIi4uLy4uLy4uL2ljb24vdWkuaWNvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUYWcgZnJvbSBcIi4uLy4uLy4uL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUluZGljYXRvciBmcm9tIFwiLi4vLi4vLi4vdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1lL0xJQi5qc1wiO1xuICAgIGxldCB7IGl0ZW0sIGNoaWxkcmVuIH0gPSAkcHJvcHMoKTtcblxuICAgIC8qXG4gIHN0cmluZyB0aXRsZVxuICBvYmplY3QgaWNvbjtcbiAgb2JqZWN0IHRhZztcbiAgc3RyaW5nIHR5cGU7XG4gIENsYXNzIGNvbXBvbmVudDtcbiAgb2JqZWN0IGluZGljYXRvcjtcbiAgb2JqZWN0IG9wdGlvbnM7XG4gICovXG48L3NjcmlwdD5cblxueyNpZiBpdGVtfVxuICAgIHsjaWYgaXRlbS5pY29ufVxuICAgICAgICA8VUlJY29uIHsuLi5pdGVtLmljb259IC8+XG4gICAgezplbHNlIGlmIGl0ZW0udHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiBpdGVtLmNvbXBvbmVudCAmJiBDT01QT05FTlRTLmNvbnRhaW5zKGl0ZW0uY29tcG9uZW50KX1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBDT01QT05FTlRTLmdldChpdGVtLmNvbXBvbmVudCl9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnQgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnByb3BzfSAvPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgeyRMT0NBTEVbaXRlbS50aXRsZV19XG4gICAgey9pZn1cblxuICAgIHsjaWYgaXRlbS50YWd9XG4gICAgICAgIDxVSVRhZyB0b3A9e3RydWV9IHJpZ2h0PXt0cnVlfSBzaXplPVwic21hbGxcIiBpZD17aXRlbS5pZH0gey4uLml0ZW0udGFnfVxuICAgICAgICA+PC9VSVRhZz5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBpdGVtLmluZGljYXRvcn1cbiAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG4gICAgey9pZn1cbns6ZWxzZX1cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBsZXQgeyBjbGFzc1ByZWZpeCA9IFwibmF2YmFyLWRpdmlkZXJcIiwgaGlkZGVuIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48aHIgY2xhc3M9XCJ7Y2xhc3NQcmVmaXh9IHtoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiAnJ31cIiAvPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlOYXZiYXJJdGVtTGluayBmcm9tIFwiLi9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLmxpbmsuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFySXRlbVdyYXBwZXIgZnJvbSBcIi4vcHJpbWl0aXZlcy91aS5uYXZiYXIuaXRlbS53cmFwcGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhckl0ZW1Db250ZW50IGZyb20gXCIuL3ByaW1pdGl2ZXMvdWkubmF2YmFyLml0ZW0uY29udGVudC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJJdGVtRGV2aWRlciBmcm9tIFwiLi9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLmRldmlkZXIuc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyBjbGFzczogY2xhc3NlcyA9IFwiXCIsIGl0ZW0sIGNoaWxkcmVuLCAuLi5vdGhlciB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtLmJyZWFrfVxuICAgIDxVSU5hdmJhckl0ZW1EZXZpZGVyIHsuLi5pdGVtfT48L1VJTmF2YmFySXRlbURldmlkZXI+XG57OmVsc2UgaWYgdHlwZW9mIGl0ZW0uaHJlZiA9PT0gXCJzdHJpbmdcIn1cbiAgICA8VUlOYXZiYXJJdGVtTGluayBidXR0b249e2ZhbHNlfSB7Li4uaXRlbX1cbiAgICAgICAgPntAcmVuZGVyIGNoaWxkcmVuPy4oKX08L1VJTmF2YmFySXRlbUxpbmtcbiAgICA+XG57OmVsc2V9XG4gICAgPFVJTmF2YmFySXRlbVdyYXBwZXIge2l0ZW19PlxuICAgICAgICA8VUlOYXZiYXJJdGVtQ29udGVudCB7aXRlbX0+PC9VSU5hdmJhckl0ZW1Db250ZW50PlxuICAgIDwvVUlOYXZiYXJJdGVtV3JhcHBlcj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQsIGhhc0NvbnRleHQsIGdldENvbnRleHQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBsZXQge1xuICAgICAgICBob3ZlcmFibGUgPSB0cnVlLFxuICAgICAgICBkcm9wVXAgPSBmYWxzZSxcbiAgICAgICAgYm94ZWQgPSBmYWxzZSxcbiAgICAgICAgcm9vdCA9IFwiL1wiLFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgaXRlbXMsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmIChoYXNDb250ZXh0KFwicm9vdFwiKSkge1xuICAgICAgICAgICAgcm9vdCA9IGdldENvbnRleHQoXCJyb290XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDb250ZXh0KFwib25jbGlja1wiKSkge1xuICAgICAgICAgICAgb25jbGljayA9IGdldENvbnRleHQoXCJvbmNsaWNrXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtIGhhcy1kcm9wZG93blwiIGNsYXNzOmlzLWhvdmVyYWJsZT17aG92ZXJhYmxlfT5cbiAgICB7QHJlbmRlciBsYWJlbD8uKHsgcm9vdCwgb25jbGljayB9KX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWRyb3Bkb3duXCJcbiAgICAgICAgY2xhc3M6aXMtYm94ZWQ9e2JveGVkfVxuICAgICAgICBjbGFzczpoYXMtZHJvcGRvd24tdXA9e2Ryb3BVcH1cbiAgICA+XG4gICAgICAgIHtAcmVuZGVyIGl0ZW1zPy4oeyByb290LCBvbmNsaWNrIH0pfVxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU5hdmJhckl0ZW1Db250ZW50IGZyb20gXCIuLi9wcmltaXRpdmVzL3VpLm5hdmJhci5pdGVtLmNvbnRlbnQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFySXRlbUdlbmVyaWMgZnJvbSBcIi4uL3VpLm5hdmJhci5pdGVtLmdlbmVyaWMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgbGV0IHsgaXRlbSwgbGFiZWwsIC4uLm90aGVycyB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiAhb3RoZXJzLmFycm93bGVzc31cbiAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeV9taXNzaW5nX2F0dHJpYnV0ZSAtLT5cbiAgICA8YSBjbGFzcz1cIm5hdmJhci1saW5rXCI+eyRMT0NBTEVbaXRlbS50aXRsZSB8fCBsYWJlbF19PC9hPlxuezplbHNlIGlmIHR5cGVvZiBsYWJlbCA9PT0gXCJzdHJpbmdcIn1cbiAgICA8VUlOYXZiYXJJdGVtQ29udGVudCB7Li4ub3RoZXJzfT57bGFiZWx9PC9VSU5hdmJhckl0ZW1Db250ZW50PlxuezplbHNlIGlmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwifVxuICAgIDxVSU5hdmJhckl0ZW1HZW5lcmljIHtpdGVtfT48L1VJTmF2YmFySXRlbUdlbmVyaWM+XG57OmVsc2UgaWYgdHlwZW9mIGxhYmVsID09PSBcImZ1bmN0aW9uXCJ9XG4gICAge0ByZW5kZXIgbGFiZWw/LigpfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTmF2YmFySXRlbSBmcm9tIFwiLi4vdWkubmF2YmFyLml0ZW0uc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyBpdGVtcywgcm9vdCwgb25jbGljaywgY2hpbGRyZW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXMgJiYgaXRlbXMubGVuZ3RofVxuICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgPFVJTmF2YmFySXRlbSB7aXRlbX0+PC9VSU5hdmJhckl0ZW0+XG4gICAgey9lYWNofVxuezplbHNlfVxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBOYXZiYXJJdGVtSGFzRHJvcGRvd24gZnJvbSBcIi4vZHJvcGRvd24vdWkubmF2YmFyLml0ZW0uaGFzLmRyb3Bkb3duLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBOYXZiYXJJdGVtSGFzRHJvcGRvd25MYWJlbCBmcm9tIFwiLi9kcm9wZG93bi91aS5uYXZiYXIuaXRlbS5oYXMuZHJvcGRvd24ubGFiZWwuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IE5hdmJhckl0ZW1IYXNEcm9wZG93bkl0ZW1zIGZyb20gXCIuL2Ryb3Bkb3duL3VpLm5hdmJhci5pdGVtLmhhcy5kcm9wZG93bi5pdGVtcy5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtoaWRkZW5dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaG92ZXJhYmxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Fycm93bGVzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgcm9vdCA9IFwiXCIsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7fSxcbiAgICAgICAgaXRlbSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIGhpZGRlbiA9IFwiXCIsXG4gICAgICAgIGhvdmVyYWJsZSA9IHRydWUsXG4gICAgICAgIGFycm93bGVzcyA9IGZhbHNlLFxuICAgICAgICBkcm9wVXAgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgYm94ZWQgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtICYmIE9iamVjdC5oYXNPd24oaXRlbSwgXCJpdGVtc1wiKSAmJiBBcnJheS5pc0FycmF5KGl0ZW0uaXRlbXMpICYmIGl0ZW0uaXRlbXMubGVuZ3RofVxuICAgIDxOYXZiYXJJdGVtSGFzRHJvcGRvd25cbiAgICAgICAge2hvdmVyYWJsZX1cbiAgICAgICAge2hpZGRlbn1cbiAgICAgICAge2Fycm93bGVzc31cbiAgICAgICAge2Ryb3BVcH1cbiAgICAgICAge2JveGVkfVxuICAgICAgICB7cm9vdH1cbiAgICAgICAge29uY2xpY2t9XG4gICAgPlxuICAgICAgICB7QGRlYnVnIGl0ZW19XG4gICAgICAgIHsjc25pcHBldCBsYWJlbChwcm9wcyl9PE5hdmJhckl0ZW1IYXNEcm9wZG93bkxhYmVsXG4gICAgICAgICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgICAgICAgIGl0ZW09e3sgLi4uaXRlbSwgaXRlbXM6IG51bGwgfX1cbiAgICAgICAgICAgID48L05hdmJhckl0ZW1IYXNEcm9wZG93bkxhYmVsPnsvc25pcHBldH1cbiAgICAgICAgeyNzbmlwcGV0IGl0ZW1zKHByb3BzKX08TmF2YmFySXRlbUhhc0Ryb3Bkb3duSXRlbXNcbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgaXRlbXM9e2l0ZW0uaXRlbXN9XG4gICAgICAgICAgICA+PC9OYXZiYXJJdGVtSGFzRHJvcGRvd25JdGVtcz57L3NuaXBwZXR9XG4gICAgPC9OYXZiYXJJdGVtSGFzRHJvcGRvd24+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlOYXZiYXJJdGVtIGZyb20gXCIuL3VpLm5hdmJhci5pdGVtLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhckl0ZW1TZWN0aW9uIGZyb20gXCIuL3VpLm5hdmJhci5pdGVtLnNlY3Rpb24uc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyBpdGVtLCAuLi5vdGhlcnMgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgT2JqZWN0Lmhhc093bihpdGVtLCBcIml0ZW1zXCIpICYmIEFycmF5LmlzQXJyYXkoaXRlbS5pdGVtcykgJiYgaXRlbS5pdGVtcy5sZW5ndGh9XG4gICAgPFVJTmF2YmFySXRlbVNlY3Rpb24gcmVuZGVyZXI9e1VJTmF2YmFySXRlbX0ge2l0ZW19IHsuLi5vdGhlcnN9XG4gICAgPjwvVUlOYXZiYXJJdGVtU2VjdGlvbj5cbns6ZWxzZX1cbiAgICA8VUlOYXZiYXJJdGVtIHtpdGVtfSB7Li4ub3RoZXJzfT48L1VJTmF2YmFySXRlbT5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7XG4gICAgICAgIGlkLFxuICAgICAgICBhY3RpdmUsXG4gICAgICAgIGNsYXNzUHJlZml4ID0gXCJuYXZiYXItbWVudVwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAuLi5vdGhlclxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBjbGFzc0F0dHIgPSAkZGVyaXZlZChbY2xhc3NQcmVmaXgsIGNsYXNzZXNdLmpvaW4oXCIgXCIpKTtcbjwvc2NyaXB0PlxuXG48ZGl2IHtpZH0gY2xhc3M9e2NsYXNzQXR0cn0gY2xhc3M6aXMtYWN0aXZlPXthY3RpdmV9IHsuLi5vdGhlcn0+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgY2hpbGRyZW4sIC4uLm90aGVyIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtcIm5hdmJhci1zdGFydCBcIiArIGNsYXNzZXN9IHsuLi5vdGhlcn0+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgY2hpbGRyZW4sIC4uLm90aGVyIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtcIm5hdmJhci1lbmQgXCIgKyBjbGFzc2VzfSB7Li4ub3RoZXJ9PlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50LCBnZXRDb250ZXh0LCBoYXNDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJTmF2YmFySXRlbUdlbmVyaWMgZnJvbSBcIi4uL2l0ZW0vdWkubmF2YmFyLml0ZW0uZ2VuZXJpYy5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSU5hdmJhck1lbnVXcmFwcGVyIGZyb20gXCIuL3VpLm5hdmJhci5tZW51LndyYXBwZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFyTWVudVN0YXJ0IGZyb20gXCIuL3VpLm5hdmJhci5tZW51LnN0YXJ0LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhck1lbnVFbmQgZnJvbSBcIi4vdWkubmF2YmFyLm1lbnUuZW5kLnN2ZWx0ZVwiO1xuXG4gICAgbGV0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgc2VjdGlvbnMgPSBbXSxcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLi4ub3RoZXJcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgc2VjdGlvbnNJdGVtc0NvdW50ID0ge307XG4gICAgbGV0IHNlY3Rpb25zSXRlbXMgPSB7fTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAoaGFzQ29udGV4dChcIm5hdmJhcklkXCIpKSB7XG4gICAgICAgICAgICBpZCA9IGdldENvbnRleHQoXCJuYXZiYXJJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29udGV4dChcInJvb3RcIikpIHtcbiAgICAgICAgICAgIHJvb3QgPSBnZXRDb250ZXh0KFwicm9vdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29udGV4dChcIm9uY2xpY2tcIikpIHtcbiAgICAgICAgICAgIG9uY2xpY2sgPSBnZXRDb250ZXh0KFwib25jbGlja1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zSXRlbXNbc2VjdGlvbi5pZF0gPSBpdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHQpID0+IHQuc2VjdGlvbiA9PT0gc2VjdGlvbi5pZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlY3Rpb25zSXRlbXNDb3VudFtzZWN0aW9uLmlkXSA9IGl0ZW1zLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodCkgPT4gdC5zZWN0aW9uID09PSBzZWN0aW9uLmlkXG4gICAgICAgICAgICApLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGxhY2VJcyh0YXJnZXRQbGFjZXMsIHRoaXNQbGFjZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXRQbGFjZXMpICYmIHRhcmdldFBsYWNlcy5pbmNsdWRlcyh0aGlzUGxhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRQbGFjZXMgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHRhcmdldFBsYWNlcyA9PT0gdGhpc1BsYWNlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlOYXZiYXJNZW51V3JhcHBlciB7aWR9IHthY3RpdmV9PlxuICAgIDxVSU5hdmJhck1lbnVTdGFydD5cbiAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICAgICAgeyNpZiBwbGFjZUlzKGl0ZW0ucGxhY2UsIFwic3RhcnRcIil9XG4gICAgICAgICAgICAgICAgPFVJTmF2YmFySXRlbUdlbmVyaWMgaGlkZGVuPVwidG91Y2hcIiB7cm9vdH0ge2l0ZW19IHtvbmNsaWNrfVxuICAgICAgICAgICAgICAgID48L1VJTmF2YmFySXRlbUdlbmVyaWM+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG4gICAgPC9VSU5hdmJhck1lbnVTdGFydD5cbiAgICA8VUlOYXZiYXJNZW51RW5kPlxuICAgICAgICB7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbiAoc2VjdGlvbi5pZCl9XG4gICAgICAgICAgICB7I2lmIHBsYWNlSXMoc2VjdGlvbi5wbGFjZSwgXCJlbmRcIil9XG4gICAgICAgICAgICAgICAge0Bjb25zdCBzZWN0aW9uSXNOb3RFbXB0eSA9XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25zSXRlbXNDb3VudFtzZWN0aW9uLmlkXSB8fFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmluZGljYXRvciB8fFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmhyZWYgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi50YWd9XG4gICAgICAgICAgICAgICAgeyNpZiBzZWN0aW9uSXNOb3RFbXB0eX1cbiAgICAgICAgICAgICAgICAgICAgPFVJTmF2YmFySXRlbUdlbmVyaWMgaGlkZGVuPVwidG91Y2hcIiB7cm9vdH0ge2l0ZW19IHtvbmNsaWNrfVxuICAgICAgICAgICAgICAgICAgICA+PC9VSU5hdmJhckl0ZW1HZW5lcmljPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG4gICAgPC9VSU5hdmJhck1lbnVFbmQ+XG48L1VJTmF2YmFyTWVudVdyYXBwZXI+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGdldENvbnRleHQsIGhhc0NvbnRleHQsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgY2xhc3NQcmVmaXggPSBcIm5hdmJhci1idXJnZXJcIixcbiAgICAgICAgYXJpYUxhYmVsID0gXCJtZW51XCIsXG4gICAgICAgIGFyaWFFeHBhbmRlZCA9IFwiZmFsc2VcIixcbiAgICAgICAgZGF0YVRhcmdldCA9IFwibmF2YmFyQmFzaWNFeGFtcGxlXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2tcIik7XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmIChoYXNDb250ZXh0KFwibmF2YmFySWRcIikpIHtcbiAgICAgICAgICAgIGRhdGFUYXJnZXQgPSBnZXRDb250ZXh0KFwibmF2YmFySWRcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeV9taXNzaW5nX2F0dHJpYnV0ZSAtLT5cbjxhXG4gICAgY2xhc3M9e1tjbGFzc1ByZWZpeCwgY2xhc3Nlc10uam9pbihcIiBcIil9XG4gICAgY2xhc3M6aXMtYWN0aXZlPXthY3RpdmV9XG4gICAge3JvbGV9XG4gICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICAgIGFyaWEtZXhwYW5kZWQ9e2FyaWFFeHBhbmRlZH1cbiAgICBkYXRhLXRhcmdldD17ZGF0YVRhcmdldH1cbiAgICB7b25jbGlja31cbj5cbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG48L2E+XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7XG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2xhc3NQcmVmaXggPSBcIm5hdmJhclwiLFxuICAgICAgICByb2xlID0gXCJuYXZpZ2F0aW9uXCIsXG4gICAgICAgIGFyaWFMYWJlbCA9IFwibWFpbiBuYXZpZ2F0aW9uXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAuLi5vdGhlclxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48bmF2XG4gICAgY2xhc3M9e1tjbGFzc1ByZWZpeCwgY2xhc3Nlc10uam9pbihcIiBcIil9XG4gICAge3JvbGV9XG4gICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICAgIHsuLi5vdGhlcn1cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L25hdj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCwgc2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSU5hdmJhckJyYW5kIGZyb20gXCIuL2JyYW5kL3VpLm5hdmJhci5icmFuZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJCdXJnZXIgZnJvbSBcIi4vdWkubmF2YmFyLmJ1cmdlci5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSU5hdmJhck1lbnUgZnJvbSBcIi4vbWVudS91aS5uYXZiYXIubWVudS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJXcmFwcGVyIGZyb20gXCIuL3VpLm5hdmJhci53cmFwcGVyLnN2ZWx0ZVwiO1xuXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIm5hdmJhclwiLFxuICAgICAgICBhY3RpdmUgPSBmYWxzZSxcbiAgICAgICAgc2VjdGlvbnMgPSBbXSxcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgcm9vdCA9IFwiXCIsXG4gICAgICAgIG5hdmlnYXRlID0gbnVsbCxcbiAgICAgICAgYnJhbmQsXG4gICAgICAgIGJ1cmdlcixcbiAgICAgICAgYnVyZ2VyQ29udHJvbHNTaWRlbWVudSA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jbGljayA9ICgpID0+IHt9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBzZXRDb250ZXh0KFwicm9vdFwiLCByb290KTtcbiAgICAgICAgc2V0Q29udGV4dChcIm5hdmlnYXRlXCIsIG5hdmlnYXRlKTtcbiAgICAgICAgc2V0Q29udGV4dChcImJ1cmdlckNvbnRyb2xzU2lkZW1lbnVcIiwgYnVyZ2VyQ29udHJvbHNTaWRlbWVudSk7XG4gICAgICAgIHNldENvbnRleHQoXCJuYXZiYXJJZFwiLCBpZCk7XG4gICAgICAgIHNldENvbnRleHQoXCJvbmNsaWNrXCIsIG9uY2xpY2spO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25CdXJnZXJDbGljaygpIHtcbiAgICAgICAgYWN0aXZlID0gIWFjdGl2ZTtcbiAgICB9XG48L3NjcmlwdD5cblxuPFVJTmF2YmFyV3JhcHBlciBjbGFzcz17Y2xhc3Nlc30+XG4gICAgeyNpZiBicmFuZH1cbiAgICAgICAgPFVJTmF2YmFyQnJhbmQge2JyYW5kfVxuICAgICAgICAgICAgPjxVSU5hdmJhckJ1cmdlciB7YWN0aXZlfSBvbmNsaWNrPXtvbkJ1cmdlckNsaWNrfT48L1VJTmF2YmFyQnVyZ2VyPlxuICAgICAgICA8L1VJTmF2YmFyQnJhbmQ+XG4gICAgezplbHNlfVxuICAgICAgICA8VUlOYXZiYXJCdXJnZXIge2FjdGl2ZX0gb25jbGljaz17b25CdXJnZXJDbGlja30+PC9VSU5hdmJhckJ1cmdlcj5cbiAgICB7L2lmfVxuICAgIDxVSU5hdmJhck1lbnUge2FjdGl2ZX0ge3NlY3Rpb25zfSB7aXRlbXN9PjwvVUlOYXZiYXJNZW51PlxuPC9VSU5hdmJhcldyYXBwZXI+XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7XG4gICAgICAgIGNsYXNzUHJlZml4ID0gXCJuYXZiYXItbGlua1wiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgLi4ub3RoZXJcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGFcbiAgICBjbGFzcz17W2NsYXNzUHJlZml4LCBjbGFzc2VzXS5qb2luKFwiIFwiKX1cbiAgICBjbGFzczppcy1zZWxlY3RlZD17c2VsZWN0ZWR9XG4gICAgey4uLm90aGVyfT57QHJlbmRlciBjaGlsZHJlbj8uKCl9PC9hXG4+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICB0aXRsZVNuaXAsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VTbmlwLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNvbG9yLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48YXJ0aWNsZSBjbGFzcz1cIm1lc3NhZ2Uge2NsYXNzZXN9IHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ31cIj5cbiAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1oZWFkZXJcIj5cbiAgICAgICAgeyNpZiB0aXRsZVNuaXB9XG4gICAgICAgICAgICB7QHJlbmRlciB0aXRsZVNuaXAodGl0bGUpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8cD57JExPQ0FMRVt0aXRsZV19PC9wPlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLWJvZHlcIj5cbiAgICAgICAgeyNpZiBtZXNzYWdlU25pcH1cbiAgICAgICAgICAgIHtAcmVuZGVyIG1lc3NhZ2VTbmlwKG1lc3NhZ2UpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8cD57JExPQ0FMRVttZXNzYWdlXX08L3A+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG48L2FydGljbGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU1lc3NhZ2UgZnJvbSBcIi4vdWkubWVzc2FnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBVSUNvbW1vbi5DTEFTU19FUlIsIC4uLnByb3BzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlNZXNzYWdlIHsuLi5wcm9wc30gY2xhc3M9e2NsYXNzZXN9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU1lc3NhZ2UgZnJvbSBcIi4vdWkubWVzc2FnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBVSUNvbW1vbi5DTEFTU19PSywgLi4ucHJvcHMgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxVSU1lc3NhZ2Ugey4uLnByb3BzfSBjbGFzcz17Y2xhc3Nlc30gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttZXNzYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWdyZWVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHNob3cgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBtZXNzYWdlID0gXCLQlNC70Y8g0YPQu9GD0YfRiNC10L3QuNGPINGA0LDQsdC+0YLRiyDRgdCw0LnRgtCwINC4INC10LPQviDQstC30LDQuNC80L7QtNC10LnRgdGC0LLQuNGPINGBINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C80Lgg0LzRiyDQuNGB0L/QvtC70YzQt9GD0LXQvCDRhNCw0LnQu9GLIGNvb2tpZS4g0J/RgNC+0LTQvtC70LbQsNGPINGA0LDQsdC+0YLRgyDRgSDRgdCw0LnRgtC+0LwsINCS0Ysg0YDQsNC30YDQtdGI0LDQtdGC0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LUgY29va2llLdGE0LDQudC70L7Qsi4g0JLRiyDQstGB0LXQs9C00LAg0LzQvtC20LXRgtC1INC+0YLQutC70Y7Rh9C40YLRjCDRhNCw0LnQu9GLIGNvb2tpZSDQsiDQvdCw0YHRgtGA0L7QudC60LDRhSDQktCw0YjQtdCz0L4g0LHRgNCw0YPQt9C10YDQsC5cIixcbiAgICAgICAgYWdyZWUgPSBcItCl0L7RgNC+0YjQvlwiLFxuICAgICAgICBjb29sZG93biA9IDMxNTM2MDAwMDAwLFxuICAgICAgICBsc0tleSA9IFwiY29va2llX2RhdGVcIixcbiAgICAgICAgaWQgPSBcImNvb2tpZV9ub3RpZmljYXRpb25cIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgbGV0IGNvb2tpZURhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsc0tleSk7XG4gICAgICAgIGlmICghY29va2llRGF0ZSB8fCArY29va2llRGF0ZSArIGNvb2xkb3duIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFjY2VwdCgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obHNLZXksIERhdGUubm93KCkpO1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgc2hvd31cbiAgICA8ZGl2IHtpZH0+XG4gICAgICAgIDxwPnskTE9DQUxFW21lc3NhZ2VdfTwvcD5cbiAgICAgICAgPFVJQnV0dG9uIG9uY2xpY2s9e2FjY2VwdH0gY29sb3I9XCJzdWNjZXNzXCIgY2xhc3M9XCJjb29raWVfYWNjZXB0XCJcbiAgICAgICAgICAgID57JExPQ0FMRVthZ3JlZV19PC9VSUJ1dHRvblxuICAgICAgICA+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiLy9ibG9jayBlbGVtZW50c1xuaW1wb3J0ICogYXMgQmxvY2tzIGZyb20gXCIuL2Jsb2NrXCI7XG5leHBvcnQgeyBCbG9ja3MgfTtcblxuLy9nZW5lcmFsIGVsZW1lbnRzXG5pbXBvcnQgKiBhcyBWYXJpb3VzIGZyb20gXCIuL3ZhcmlvdXNcIjtcbmV4cG9ydCB7IFZhcmlvdXMgfTtcblxuLy9cbmltcG9ydCAqIGFzIEJ1dHRvbnMgZnJvbSBcIi4vYnV0dG9uXCI7XG5leHBvcnQgeyBCdXR0b25zIH07XG5cbi8vZm9ybSBlbGVtZW50c1xuaW1wb3J0ICogYXMgRm9ybXMgZnJvbSBcIi4vZm9ybVwiO1xuZXhwb3J0IHsgRm9ybXMgfTtcblxuLy9pY29ucyB2YXJpYW50c1xuaW1wb3J0ICogYXMgSWNvbnMgZnJvbSBcIi4vaWNvblwiO1xuZXhwb3J0IHsgSWNvbnMgfTtcblxuLy9pbWFnZXMgdWlcbmltcG9ydCAqIGFzIEltYWdlcyBmcm9tIFwiLi9pbWFnZVwiO1xuZXhwb3J0IHsgSW1hZ2VzIH07XG5cbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi9pbnB1dFwiO1xuZXhwb3J0IHsgSW5wdXRzIH07XG5cbmltcG9ydCAqIGFzIExheW91dHMgZnJvbSBcIi4vbGF5b3V0XCI7XG5leHBvcnQgeyBMYXlvdXRzIH07XG5cbmltcG9ydCAqIGFzIExpbmtzIGZyb20gXCIuL2xpbmtcIjtcbmV4cG9ydCB7IExpbmtzIH07XG5cbmltcG9ydCAqIGFzIExpc3RzIGZyb20gXCIuL2xpc3RcIjtcbmV4cG9ydCB7IExpc3RzIH07XG5cbmltcG9ydCAqIGFzIE1vZGFscyBmcm9tIFwiLi9tb2RhbFwiO1xuZXhwb3J0IHsgTW9kYWxzIH07XG5cbmltcG9ydCAqIGFzIE5hdmlnYXRpb25zIGZyb20gXCIuL25hdmlnYXRpb25cIjtcbmV4cG9ydCB7IE5hdmlnYXRpb25zIH07XG5cbmltcG9ydCAqIGFzIE5vdGlmaWNhdGlvbnMgZnJvbSBcIi4vbm90aWZpY2F0aW9uXCI7XG5leHBvcnQgeyBOb3RpZmljYXRpb25zIH07XG5cbmltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi9jb21tb25cIjtcbmV4cG9ydCB7IFVJQ29tbW9uIH07XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJ3b2xmeTg3LWV2ZW50ZW1pdHRlclwiO1xuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbmNvbnN0IE1FVEFfTUVUSE9EX0lOSVQgPSBTeW1ib2woXCJpbml0XCIpLFxuICAgIE1FVEFfREFUQSA9IFN5bWJvbChcImRhdGFcIiksXG4gICAgTUVUQV9XT1JLSU5HID0gU3ltYm9sKFwid29ya2luZ1wiKSxcbiAgICBNRVRBX09QVElPTlMgPSBTeW1ib2woXCJvcHRpb25zXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBub3RCYXNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzW01FVEFfREFUQV0gPSB7fTtcbiAgICAgICAgdGhpc1tNRVRBX1dPUktJTkddID0ge307XG4gICAgICAgIHRoaXNbTUVUQV9PUFRJT05TXSA9IHt9O1xuICAgICAgICB0aGlzW01FVEFfTUVUSE9EX0lOSVRdKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgW01FVEFfTUVUSE9EX0lOSVRdKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGlucHV0LCBcImRhdGFcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaW5wdXQsIFwid29ya2luZ1wiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKGlucHV0LndvcmtpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpbnB1dCwgXCJvcHRpb25zXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoaW5wdXQub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZyA9IG5vdENvbW1vbi5nZW5Mb2dNc2codGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKSk7XG4gICAgICAgIHRoaXMuaW5mbyA9IHRoaXMubG9nO1xuICAgICAgICB0aGlzLmRlYnVnID0gbm90Q29tbW9uLmdlbkxvZ0RlYnVnKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgICAgICB0aGlzLmVycm9yID0gbm90Q29tbW9uLmdlbkxvZ0Vycm9yKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgIH1cblxuICAgIHNldENvbW1vbih3aGF0LCBhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8qIHNldCBjb2xsZWN0aW9uICovXG4gICAgICAgICAgICAgICAgd2hhdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAvKiBzZXQgY29sbGVjdGlvbiBlbGVtZW50ICovXG4gICAgICAgICAgICAgICAgbm90UGF0aC5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gLyogcGF0aCAqLyxcbiAgICAgICAgICAgICAgICAgICAgd2hhdCAvKiBjb2xsZWN0aW9uICovLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgLyogaGVscGVycyAqLyxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSAvKiB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldENvbW1vbih3aGF0LCBhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIGlmIHdlIHdhbnQgZ2V0IGRhdGEgYnkgcGF0aCAqL1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KGFyZ3NbMF0sIHdoYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaWYgd2Ugd2FudCBnZXQgZGF0YSBieSBwYXRoIHdpdGggZGVmYXVsdCB2YWx1ZSAqL1xuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IG5vdFBhdGguZ2V0KGFyZ3NbMF0sIHdoYXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBubyBkYXRhLCByZXR1cm4gZGVmYXVsdCB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBkYXRhLCByZXR1cm4gaXQgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiByZXR1cm4gZnVsbCBjb2xsZWN0aW9uICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIENPUkUgT0JKRUNUXG4gICAgICBEQVRBIC0gaW5mb3JtYXRpb25cbiAgICAgIE9QVElPTlMgLSBob3cgdG8gd29ya1xuICAgICAgV09SS0lORyAtIHRlbXBvcmFyaWx5IGdlbmVyYXRlZCBpbiBwcm9jY2Vzc1xuICAqL1xuXG4gICAgc2V0RGF0YSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbTUVUQV9EQVRBXSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29tbW9uKHRoaXMuZ2V0RGF0YSgpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9EQVRBXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzZXRPcHRpb25zKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpc1tNRVRBX09QVElPTlNdID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21tb24odGhpcy5nZXRPcHRpb25zKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9PUFRJT05TXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzZXRXb3JraW5nKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpc1tNRVRBX1dPUktJTkddID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21tb24odGhpcy5nZXRXb3JraW5nKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9XT1JLSU5HXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXBvcnQoZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLnJlcG9ydCkge1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEFwcCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgfVxufVxuIiwiaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuXG5pbXBvcnQgeyBOQVZJR0FUSU9OX0RFTEFZUywgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUIH0gZnJvbSBcIi4vY29uc3QuanNcIjtcblxuY29uc3QgT1BUX01PREVfSElTVE9SWSA9IFN5bWJvbChcImhpc3RvcnlcIiksXG4gICAgT1BUX01PREVfSEFTSCA9IFN5bWJvbChcImhhc2hcIiksXG4gICAgT1BUX0RFRkFVTFRfQ0hFQ0tfSU5URVJWQUwgPSA1MDtcblxuY2xhc3Mgbm90Um91dGVyIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgaG9zdCA9IFwiXCI7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICByb3V0ZXM6IFtdLFxuICAgICAgICAgICAgICAgIG1vZGU6IE9QVF9NT0RFX0hJU1RPUlksXG4gICAgICAgICAgICAgICAgcm9vdDogXCIvXCIsIC8vYWx3YXlzIGluIHNsYXNoZXMgL3VzZXIvLCAvLCAvaW5wdXQvLiBhbmQgbm8gL3VzZXIgb3IgaW5wdXQvbGV2ZWxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVsYXlzOiBOQVZJR0FUSU9OX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBkZWxheV9kZWZhdWx0OiBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9iamVjdCB3aXRoIG5hbWVkIGRlbGF5c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbGF5c1xuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgc2V0RGVsYXlzKGRlbGF5cykge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJkZWxheXNcIiwgZGVsYXlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgbmF2aWdhdGlvbiBkZWxheSwgcHJvdmlkZWQgYXMgbmFtZSBvZiBvbmUgb2YgYGRlbGF5c2Agb3IgaW4gbnVtYmVyIGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRlbGF5XG4gICAgICogQHJldHVybnMge25vdFJvdXRlcn1cbiAgICAgKi9cbiAgICBzZXREZWZhdWx0TmF2aWdhdGlvbkRlbGF5KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImRlbGF5X2RlZmF1bHRcIiwgdGhpcy5kZWxheUFzTXMoZGVsYXkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgb2YgbXMsIGlmIG5vdCBzZXQgcmV0dXJucyBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoYGRlbGF5X2RlZmF1bHRgLCBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFbnN1cmVzIHRoYXQgZGVsYXkgaXMgaW4gbXMsIGlmIGl0cyBwcm92aWRlZCBhcyBuYW1lIG9mIGFsaWFzLCBzZWFyY2hlcyBmb3IgaXQgYW5kIHJldHVybnMsIGlmIG5vdCBmb3VuZCAtIHJldHVybnMgd29ya2luZyBkZWZhdWx0X2RlbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZWxheSAgICBuYW1lIG9mIGRlbGF5IGFsaWFzIG9yIG51bWJlciBvZiBtc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9ICAgICAgICAgICAgICAgZGVsYXkgaW4gbXNcbiAgICAgKi9cbiAgICBkZWxheUFzTXMoZGVsYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJzdHJpbmdcIiAmJiBkZWxheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgYGRlbGF5cy4ke2RlbGF5fWAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICB1cmwgICAgIHdlIGdvIHRvIHVybFxuICAgICAqICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9ICAgICAgIGRlbGF5ICAgbmFtZSBvZiBkZWxheSBhbGlhcyBvciBudW1iZXIgb2YgbXNcbiAgICAgKiAgQHJldHVybnMge05vZGVKUy5UaW1lb3V0fSAgICAgICAgICAgIHRpbWVvdXQgaWRlbnRpZmljYXRvclxuICAgICAqL1xuICAgIG5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksIGRvQmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHR5cGVvZiBkb0JlZm9yZSA9PT0gXCJmdW5jdGlvblwiICYmIGRvQmVmb3JlKCk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlKHVybCk7XG4gICAgICAgIH0sIHRoaXMuZGVsYXlBc01zKGRlbGF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIGJyb3dzZXIgSGlzdG9yeSBBUElcbiAgICAgKi9cbiAgICBoaXN0b3J5KCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlXCIsIE9QVF9NT0RFX0hJU1RPUlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBoYXNoIHBhcnQgYXMgY29udGFpbmVyIGZvciBsb2NhdGlvbiBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVcIiwgT1BUX01PREVfSEFTSCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm9vdCBzaG91bGQgc3RhcnQgYW5kIGVuZCB3aXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RcbiAgICAgKiBAcmV0dXJucyB7bm90Um91dGVyfVxuICAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcInJvb3RcIixcbiAgICAgICAgICAgIHJvb3QgJiYgcm9vdCAhPT0gXCIvXCIgPyBcIi9cIiArIHRoaXMuY2xlYXJTbGFzaGVzKHJvb3QpICsgXCIvXCIgOiBcIi9cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbGVhciBmaXJzdCBhbmQgbGFzdCBzbGFzaGVzIGZyb20gc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsZWFyU2xhc2hlcyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG5cbiAgICBhZGQocmUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSByZTtcbiAgICAgICAgICAgIHJlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVsZSA9IHtcbiAgICAgICAgICAgIHJlOiByZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKS5wdXNoKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhZGRMaXN0KGxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgdCBpbiBsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0LCBsaXN0W3RdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmUocGFyYW0pIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBpID0gMCwgcjtcbiAgICAgICAgICAgIGkgPCB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikubGVuZ3RoLFxuICAgICAgICAgICAgKHIgPSB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIilbaV0pO1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHIuaGFuZGxlciA9PT0gcGFyYW0gfHwgci5yZSA9PT0gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoe1xuICAgICAgICAgICAgcm91dGVzOiBbXSxcbiAgICAgICAgICAgIG1vZGU6IE9QVF9NT0RFX0hJU1RPUlksXG4gICAgICAgICAgICByb290OiBcIi9cIixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJpbml0aWFsaXplZFwiKTtcbiAgICB9XG5cbiAgICBzZXRJbml0aWFsaXplZCh2YWwgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFdvcmtpbmcoXCJpbml0aWFsaXplZFwiLCB2YWwpO1xuICAgIH1cblxuICAgIGdldEZyYWdtZW50KCkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSA9PT0gT1BUX01PREVfSElTVE9SWSkge1xuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuY2xlYXJTbGFzaGVzKFxuICAgICAgICAgICAgICAgIGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcPyguKikkLywgXCJcIik7XG4gICAgICAgICAgICBmcmFnbWVudCA9XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSAhPSBcIi9cIlxuICAgICAgICAgICAgICAgICAgICA/IGZyYWdtZW50LnJlcGxhY2UodGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBmcmFnbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghd2luZG93KSByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJTbGFzaGVzKGZyYWdtZW50KTtcbiAgICB9XG5cbiAgICBjaGVja0xvY2F0aW9uKCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0V29ya2luZyhcImN1cnJlbnRcIiksXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IGZyYWdtZW50IHx8ICFpbml0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJjdXJyZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2soZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsaXplZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhyZWZDbGljaygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpO1xuICAgIH1cblxuICAgIGxpc3Rlbihsb29wSW50ZXJ2YWwgPSBPUFRfREVGQVVMVF9DSEVDS19JTlRFUlZBTCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJjdXJyZW50XCIsIFwibm90SW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5nZXRXb3JraW5nKFwiaW50ZXJ2YWxcIikpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcImludGVydmFsXCIsXG4gICAgICAgICAgICBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrTG9jYXRpb24uYmluZCh0aGlzKSwgbG9vcEludGVydmFsKVxuICAgICAgICApO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuaHJlZkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjaGVjayhmKSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IGYgfHwgdGhpcy5nZXRGcmFnbWVudCgpLFxuICAgICAgICAgICAgZmFpbEJhY2sgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhdGggPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpICsgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLnJlLFxuICAgICAgICAgICAgICAgIGZ1bGxSRSA9IHRoaXMuY2xlYXJTbGFzaGVzKGRlY29kZVVSSShwYXRoKSksXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmcmFnbWVudC5tYXRjaChmdWxsUkUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsUkUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZmFpbEJhY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLmhhbmRsZXIuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3QgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJvdXRlXCIsIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbEJhY2spIHtcbiAgICAgICAgICAgIGZhaWxCYWNrLnJvdXRlLmhhbmRsZXIuYXBwbHkodGhpcy5ob3N0IHx8IHt9LCBmYWlsQmFjay5tYXRjaCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJvdXRlXCIsIGZhaWxCYWNrLnJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmcmVzaGVzIHBhZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCB0aW1lIHRvIHdhaXQgaW4gbXNcbiAgICAgKi9cbiAgICByZWZyZXNoKHRpbWVvdXQgPSAwKSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlZnJlc2goKSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrKHRoaXMuZ2V0V29ya2luZyhcImN1cnJlbnRcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBsb2NhdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbmF2aWdhdGUocGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aCA/IHBhdGggOiBcIlwiO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIikpIHtcbiAgICAgICAgICAgIGNhc2UgT1BUX01PREVfSElTVE9SWToge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdXRlID0gdGhpcy5nZXRGdWxsUm91dGUocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JvdXRlID09PSB0aGlzLmxhc3RSb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RSb3V0ZSA9IG5ld1JvdXRlO1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBcIlwiLCB0aGlzLmxhc3RSb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUFRfTU9ERV9IQVNIOiB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIyguKikkLywgXCJcIikgKyBcIiNcIiArIHBhdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHJldHVybnMgYXBwIHJvb3QgKyBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEZ1bGxSb3V0ZShwYXRoID0gXCJcIikge1xuICAgICAgICBwYXRoID0gdGhpcy5jbGVhclNsYXNoZXMocGF0aCk7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpO1xuICAgICAgICBpZiAocm9vdCAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2Yocm9vdC5zdWJzdHJpbmcoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgcGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSArIHRoaXMuY2xlYXJTbGFzaGVzKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGxpbmtzIHdpdGggbi1ocmVmIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxIVE1MQW5jaG9yRWxlbWVudD59XG4gICAgICovXG4gICAgZ2V0QWxsTGlua3MoKSB7XG4gICAgICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiYVwiKTtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhbGxFbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDAsIGF0dHMgPSBhbGxFbGVtZW50c1tqXS5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaSA8IG47XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0c1tpXS5ub2RlTmFtZS5pbmRleE9mKFwibi1ocmVmXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhbGxFbGVtZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXJvdXRlIGFsbCBsaW5rcyhhbmNob3IgdGFncykgd2l0aCBuLWhyZWYgYXR0cmlidXRlLlxuICAgICAqIERpc2FibGUgbmF2aWdhdGlvbiB0byBocmVmLlxuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgcmVSb3V0ZUV4aXN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldEFsbExpbmtzKCk7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbGlzdC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdGhpcy5pbml0UmVyb3V0aW5nKGxpc3RbdF0sIGxpc3RbdF0uZ2V0QXR0cmlidXRlKFwibi1ocmVmXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBgZWxgIGlzIG5vdCBpbml0aWFsaXplZCwgYWRkcyBvbmNsaWNrIGxpc3RlbmVyIHRvIG5hdmlnYXRlIHRvIGBsaW5rYCBsb2NhdGlvbi5cbiAgICAgKiBEaXNhYmxlcyBkZWZhdWx0IG5hdmlnYXRpb24gdG8gaHJlZi5cbiAgICAgKiBAcGFyYW0ge0hUTUxBbmNob3JFbGVtZW50fSAgIGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBsaW5rXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBpbml0UmVyb3V0aW5nKGVsLCBsaW5rKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFlbC5ub3RSb3V0ZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbGV0IGZ1bGxMaW5rID0gdGhpcy5nZXRGdWxsUm91dGUobGluayk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGZ1bGxMaW5rKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlKGxpbmspO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZWwubm90Um91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IG5vdFJvdXRlcigpO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vYmFzZS5qc1wiO1xuXG5jb25zdCBMT0dfUFJFRklYID0gXCJBUElRdWVlXCI7XG5cbmNsYXNzIG5vdEFQSVF1ZXVlIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgc3RhdGljIFFVRVVFX0NIRUNLX0lOVEVSVkFMID0gMTAwO1xuXG4gICAgc3RhdGljIE1BWF9CVVNZX1RJTUUgPSAzMDA7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSA/IG9wdGlvbnMubmFtZSA6IExPR19QUkVGSVgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgIHRoaXMuY2hlY2tRdWV1ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdGhpcy5RVUVVRV9DSEVDS19JTlRFUlZBTFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNoZWNrUXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkgJiYgIXRoaXMuaXNCdXN5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnVzeSgpXG4gICAgICAgICAgICAgICAgLnJ1bk5leHQoKVxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0RnJlZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RnJlZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQnVzeSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuYWZ0ZXJFbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZnRlckVtcHR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkVG9RdWV1ZSh0YXNrKSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICB9XG5cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMucXVldWUubWFwKChhY3Rpb24pID0+IGFjdGlvbi50aXRsZSkuam9pbihcIiwgXCIpO1xuICAgICAgICB0aGlzLmRlYnVnICYmIHRoaXMuZGVidWcoYHRhc2tzIFske2xpc3R9XWApO1xuICAgICAgICBsZXQgdGFzayA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFub3RDb21tb24uaXNGdW5jKHRhc2suYWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwi0JIg0LfQsNC00LDQvdC40Lgg0L3QtdGCINC40YHQv9C+0LvQvdC40LzQvtC5INGH0LDRgdGC0LgsIGFjdGlvbiDQvdC1INGE0YPQvdC60YbQuNGPXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhc2sudGl0bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub3RDb21tb24uaXNGdW5jKHRhc2sucmVzb2x2ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcItCSINC30LDQtNCw0L3QuNC4INC90LXRgiDQstC+0LfQstGA0LDRgtC90L7QuSDRh9Cw0YHRgtC4LCByZXNvbHZlINC90LUg0YTRg9C90LrRhtC40Y9cIixcbiAgICAgICAgICAgICAgICAgICAgdGFzay50aXRsZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5hY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFzay5hY3Rpb24oKS50aGVuKHRhc2sucmVzb2x2ZSk7XG4gICAgfVxuXG4gICAgaXNCdXN5KCkge1xuICAgICAgICBsZXQgYnVzeSA9ICEhdGhpcy5idXN5LFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIGlmIChidXN5ICYmIHRoaXMuYnVzeVNpbmNlID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aGlzLmJ1c3lTaW5jZSA+IG5vdEFQSVF1ZXVlLk1BWF9CVVNZX1RJTUUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZyZWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QnVzeSgpIHtcbiAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXN5U2luY2UgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0RnJlZSgpIHtcbiAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDQmNGB0L/QvtC70L3QuNGC0LXQu9GMINC30LDQv9GA0L7RgdC+0LJcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgYWN0aW9uICAgICAg0LTQvtC70LbQvdCwINCy0L7Qt9Cy0YDQsNGJ0LDRgtGMIFByb21pc2VcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgW2FmdGVyRW1wdHkgPSB1bmRlZmluZWRdICDQsdGD0LTQtdGCINCy0YvQv9C+0LvQvdC10L3QsCDQutC+0LPQtNCwINC+0YfRg9GA0YPQtNGMINC+0L/Rg9GB0YLQtdC10YIg0Lgg0LHRg9C00LXRgiDRgdCy0L7QsdC+0LTQvdCwLiDQv9C+0LvQtdC30L3QsCDQv9GA0Lgg0L/QsNGH0LrQtSDQvtC00L3QvtGC0LjQv9C90YvRhSDQt9Cw0LTQsNC90LjQuVxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBbdGl0bGUgPSAnJ10gICAgb3B0aW9uYWwgdGl0bGUgb2YgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zICAgIHtQcm9taXNlfSAgICDRgNC10LfRg9C70YzRgtCw0YIg0YTRg9C90LrRhtC40LhcbiAgICAgKiovXG4gICAgcnVuKGFjdGlvbiwgYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZCwgdGl0bGUgPSBcIlwiKSB7XG4gICAgICAgIGlmIChhZnRlckVtcHR5ICYmIHR5cGVvZiB0aGlzLmFmdGVyRW1wdHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IGFmdGVyRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb1F1ZXVlKHsgYWN0aW9uLCByZXNvbHZlLCB0aXRsZSB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3Rpb25Jc1F1ZXVlZCh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5zb21lKChxdWV1ZWQpID0+IHF1ZXVlZC50aXRsZSA9PSB0aXRsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAgIHtmdW5jdGlvbn0gICBhY3Rpb24gICAgICDQtNC+0LvQttC90LAg0LLQvtC30LLRgNCw0YnQsNGC0YwgUHJvbWlzZVxuICAgICAqIEBwYXJhbSAgICAgIHtmdW5jdGlvbn0gICBbYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZF0gINCx0YPQtNC10YIg0LLRi9C/0L7Qu9C90LXQvdCwINC60L7Qs9C00LAg0L7Rh9GD0YDRg9C00Ywg0L7Qv9GD0YHRgtC10LXRgiDQuCDQsdGD0LTQtdGCINGB0LLQvtCx0L7QtNC90LAuINC/0L7Qu9C10LfQvdCwINC/0YDQuCDQv9Cw0YfQutC1INC+0LTQvdC+0YLQuNC/0L3Ri9GFINC30LDQtNCw0L3QuNC5XG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIFt0aXRsZSA9ICcnXSAgICBvcHRpb25hbCB0aXRsZSBvZiByZXF1ZXN0XG4gICAgICogQHJldHVybiAgICB7UHJvbWlzZX1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QVBJUXVldWVcbiAgICAgKi9cbiAgICBydW5JZk5vdFF1ZXVlZChhY3Rpb24sIGFmdGVyRW1wdHkgPSB1bmRlZmluZWQsIHRpdGxlID0gXCJcIikge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25Jc1F1ZXVlZCh0aXRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bihhY3Rpb24sIGFmdGVyRW1wdHksIHRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QVBJUXVldWU7XG4iLCJsZXQgbm90QVBJT3B0aW9ucyA9IHtcbiAgICBycHM6IDUwLFxuICAgIHByb3RvY29sOiAnaHR0cCcsXG4gICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgcG9ydDogOTAwMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbm90QVBJT3B0aW9ucztcbiIsImltcG9ydCBub3RCYXNlIGZyb20gJy4uL2Jhc2UuanMnO1xuY29uc3QgTE9HX1BSRUZJWCA9ICdBUElDb25uZWN0aW9uJztcblxuY2xhc3Mgbm90QVBJQ29ubmVjdGlvbiBleHRlbmRzIG5vdEJhc2V7XG4gICAgc3RhdGljIGludDtcbiAgICBzdGF0aWMgb25saW5lO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZT9vcHRpb25zLm5hbWU6TE9HX1BSRUZJWFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMuaW50ID0gd2luZG93LnNldEludGVydmFsKHRoaXMuY2hlY2suYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaW50KTtcbiAgICB9XG5cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuXG4gICAgaXNPbmxpbmUoKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lO1xuICAgIH1cblxuICAgIGNoZWNrKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXMuaXNPbmxpbmUoKTtcbiAgICAgICAgaWYgKHRoaXMub25saW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbmxpbmUgIT09IHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25saW5lID0gdDtcbiAgICB9XG5cbiAgICBjaGFuZ2VTdGF0ZShvbmxpbmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAob25saW5lKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ29ubGluZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEFQSUNvbm5lY3Rpb247XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbmNvbnN0IEFMTCA9IHt9O1xuXG5mdW5jdGlvbiBleGlzdChrZXkpIHtcbiAgICByZXR1cm4gbm90Q29tbW9uLm9iakhhcyhBTEwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoZXhpc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gQUxMW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKFxuICAgIGtleSxcbiAgICBwcm9wcyA9IHtcbiAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgZmlsdGVyZWQ6IFtdLFxuICAgICAgICBzZWxlY3RlZDoge30sXG4gICAgfVxuKSB7XG4gICAgaWYgKCFleGlzdChrZXkpKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgQUxMW2tleV0gPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgQUxMW2tleV1bbmFtZV0gPSB3cml0YWJsZShwcm9wc1tuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0b3JlJ3MgcHJvcHMgd2Fzbid0IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQUxMW2tleV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBvYmplY3QgdGhhdCBpcyBmYWtlIFN0b3JlXG4gKiBTb21lIHRpbWUgdGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBpbml0aWFsaXplIGxvY2FsIHZhcixcbiAqIGJlZm9yZSB5b3UgY291bGQgZ2V0IGFjdHVhbCBTdG9yZXMgZnJvbSBjZW50cmFsIHN0b3JhZ2UgYnkgaXRzIElEXG4gKlx0QHBhcmFtcyB7bWl4ZWR9IHZhbCBcdGRhdGEgb2YgdHlwZSB0aGF0IGlzIGFjdHVhbCBzdG9yYWdlIHdpbGwgY29udGFpblxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBmYWtlKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShmKSB7XG4gICAgICAgICAgICBmKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHt9LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSwgZ2V0LCBmYWtlIH07XG4iLCJjb25zdFxuICAgIC8vaW50ZXJmYWNlXG4gICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSA9IFsnX2lkJywgJ2lkJywgJ0lEJ10sXG4gICAgREVGQVVMVF9GSUxURVIgPSB7fSxcbiAgICBERUZBVUxUX1NFQVJDSCA9ICcnLFxuICAgIERFRkFVTFRfUkVUVVJOID0ge30sXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUiA9IDEsXG4gICAgREVGQVVMVF9QQUdFX1NJWkUgPSAxMCxcbiAgICAvL3JlY29yZFxuICAgIE1FVEFfSU5URVJGQUNFID0gU3ltYm9sKCdpbnRlcmZhY2UnKSxcbiAgICBNRVRBX01BUF9UT19JTlRFUkZBQ0UgPSBbXG4gICAgICAgICdnZXRBY3Rpb25zQ291bnQnLFxuICAgICAgICAnZ2V0QWN0aW9ucycsXG4gICAgICAgICdzZXRGaW5kQnknLFxuICAgICAgICAncmVzZXRGaWx0ZXInLFxuICAgICAgICAnc2V0RmlsdGVyJyxcbiAgICAgICAgJ2dldEZpbHRlcicsXG4gICAgICAgICdzZXRTb3J0ZXInLFxuICAgICAgICAnZ2V0U29ydGVyJyxcbiAgICAgICAgJ3Jlc2V0U29ydGVyJyxcbiAgICAgICAgJ3NldFBhZ2VOdW1iZXInLFxuICAgICAgICAnc2V0UGFnZVNpemUnLFxuICAgICAgICAnc2V0UGFnZXInLFxuICAgICAgICAnc2V0UmV0dXJuJyxcbiAgICAgICAgJ3NldFNlYXJjaCcsXG4gICAgICAgICdnZXRTZWFyY2gnLFxuICAgICAgICAncmVzZXRTZWFyY2gnLFxuICAgICAgICAncmVzZXRQYWdlcicsXG4gICAgICAgICdnZXRQYWdlcicsXG4gICAgICAgICdhZGRGb3JtRmllbGRUeXBlJyxcbiAgICAgICAgJ2FkZEZvcm1GaWVsZCcsXG4gICAgICAgICdnZXRGaWVsZFR5cGVzJyxcbiAgICAgICAgJ2dldEFjdGlvbkZvcm1GaWVsZHMnXG4gICAgXSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVggPSAnJCc7XG5cbmV4cG9ydCB7XG4gICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSxcbiAgICBERUZBVUxUX0ZJTFRFUixcbiAgICBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgIERFRkFVTFRfUEFHRV9TSVpFLFxuICAgIERFRkFVTFRfU0VBUkNILFxuICAgIERFRkFVTFRfUkVUVVJOLFxuICAgIE1FVEFfSU5URVJGQUNFLFxuICAgIE1FVEFfTUFQX1RPX0lOVEVSRkFDRSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVhcbn07XG4iLCJpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5cbmNvbnN0IE9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFkgPSBbXCJfaWRcIiwgXCJpZFwiLCBcIklEXCJdLFxuICAgIERFRkFVTFRfRklMVEVSID0ge30sXG4gICAgREVGQVVMVF9TRUFSQ0ggPSBcIlwiLFxuICAgIERFRkFVTFRfUkVUVVJOID0ge30sXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUiA9IDAsXG4gICAgREVGQVVMVF9QQUdFX1NJWkUgPSAxMCxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVggPSBcIiRcIixcbiAgICBERUZBVUxUX1dTX1JPVVRFX0FDVElPTl9TUExJVFRFUiA9IFwiLy9cIjtcblxuY2xhc3Mgbm90SW50ZXJmYWNlIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgY29uc3RydWN0b3IobWFuaWZlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6XG4gICAgICAgICAgICAgICAgICAgIFwibmV0d29yayBpbnRlcmZhY2UgZm9yOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChtYW5pZmVzdC5tb2RlbCA/IG1hbmlmZXN0Lm1vZGVsIDogXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogREVGQVVMVF9GSUxURVIsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBERUZBVUxUX1NFQVJDSCxcbiAgICAgICAgICAgICAgICByZXR1cm46IERFRkFVTFRfUkVUVVJOLFxuICAgICAgICAgICAgICAgIHBhZ2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IERFRkFVTFRfUEFHRV9TSVpFLFxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgICAgdGhpcy5pbml0QWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbml0QWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QWN0aW9uc0NvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMuZ2V0QWN0aW9ucygpO1xuICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uTmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdEFjdGlvbihhY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyh0aGlzLCBERUZBVUxUX0FDVElPTl9QUkVGSVggKyBhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgdGhpc1tERUZBVUxUX0FDVElPTl9QUkVGSVggKyBhY3Rpb25OYW1lXSA9IChcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgZmlsZVVwbG9hZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICApID0+XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlVXBsb2FkLFxuICAgICAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0SFRUUChcbiAgICAgICAgcmVjb3JkLFxuICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgICAgZmlsZVVwbG9hZCA9IGZhbHNlLFxuICAgICAgICBmaWxlc1xuICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0ZURhdGEgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIHJlY29yZC5nZXREYXRhICYmIHR5cGVvZiByZWNvcmQuZ2V0RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVjb3JkLmdldERhdGEoKVxuICAgICAgICAgICAgICAgICAgICA6IHJlY29yZCxcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IHRoaXMuZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gdGhpcy5jb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtc0VuY29kZWQgPSB0aGlzLmVuY29kZVJlcXVlc3QocmVxdWVzdFBhcmFtcyksXG4gICAgICAgICAgICAgICAgLy9pZCA9IHRoaXMuZ2V0SUQoY29tcG9zaXRlRGF0YSwgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgYXBpU2VydmVyVVJMID0gdGhpcy5nZXRTZXJ2ZXJVUkwoKSxcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmdldFVSTChjb21wb3NpdGVEYXRhLCBhY3Rpb25EYXRhLCBhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgICBpZiAoZmlsZVVwbG9hZCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZ2V0VVJMKHBhcmFtcywgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQoXCJmaWxlXCIsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBmZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBbXCJPUFRJT05TXCIsIFwiR0VUXCJdLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICkgPT09IC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGFjdGlvbkRhdGEubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmdldERhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlY29yZC5nZXREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWNvcmQuZ2V0RGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gYWN0aW9uRGF0YS5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYXBpU2VydmVyVVJMICsgdXJsICsgcmVxdWVzdFBhcmFtc0VuY29kZWQsIG9wdHMpLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvcihlKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0V1MocmVjb3JkLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IHRoaXMuZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gdGhpcy5jb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBXUyA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXU0NsaWVudCgpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZU5hbWUgPSB0aGlzLmdldFdTUmVxdWVzdE5hbWUoYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcywgcmVjb3JkLmdldERhdGEoKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcInR5cGVcIikgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgYWN0aW9uRGF0YS50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgYWN0aW9uRGF0YS50eXBlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEudHlwZSAhPT0gXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBXUy5tZXNzYWdlKGFjdGlvbkRhdGEudHlwZSwgbWVzc2FnZU5hbWUsIHBheWxvYWQpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UucGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBXUy5yZXF1ZXN0KG1lc3NhZ2VOYW1lLCBwYXlsb2FkKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLnBheWxvYWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uZXJyb3IoZSk7XG4gICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdCgpIHtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSB0aGlzLmdldEFjdGlvbkRhdGEoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdFRyYW5zcG9ydChhY3Rpb25EYXRhKSkge1xuICAgICAgICAgICAgY2FzZSBcIndzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFdTKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RIVFRQKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZmxpbmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3c0lzVXAoYWN0aW9uRGF0YSkge1xuICAgICAgICBpZiAoYWN0aW9uRGF0YS53cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwid3NDbGllbnRcIikgJiZcbiAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLndzQ2xpZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0V1NDbGllbnQoYWN0aW9uRGF0YS53c0NsaWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaWVudCA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXU0NsaWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3RUcmFuc3BvcnQoYWN0aW9uRGF0YSkge1xuICAgICAgICBpZiAodGhpcy53c0lzVXAoYWN0aW9uRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIndzXCI7IC8vZm9yIHdzL3dzc1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwibWV0aG9kXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwXCI7IC8vZm9yIGh0dHAvaHR0cHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vZm9yIG9mZmxpbmVcbiAgICB9XG5cbiAgICBnZXRNb2RlbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzICYmIHRoaXMubWFuaWZlc3QgPyB0aGlzLm1hbmlmZXN0Lm1vZGVsIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25EYXRhKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9ucygpICYmIHRoaXMuZ2V0QWN0aW9ucygpW2FjdGlvbk5hbWVdXG4gICAgICAgICAgICA/IHRoaXMuZ2V0QWN0aW9ucygpW2FjdGlvbk5hbWVdXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3Rpb25zKCkgPyBPYmplY3Qua2V5cyh0aGlzLmdldEFjdGlvbnMoKSkubGVuZ3RoIDogMDtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdCAmJiB0aGlzLm1hbmlmZXN0LmFjdGlvbnNcbiAgICAgICAgICAgID8gdGhpcy5tYW5pZmVzdC5hY3Rpb25zXG4gICAgICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIHBhcnNlUGFyYW1zKHN0YXJ0LCBlbmQsIGxpbmUsIHJlY29yZCkge1xuICAgICAgICBsZXQgZmllbGROYW1lID0gXCJcIjtcbiAgICAgICAgbGV0IGxlbiA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxpbmUuaW5kZXhPZihzdGFydCkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGluZCA9IGxpbmUuaW5kZXhPZihzdGFydCk7XG4gICAgICAgICAgICBsZXQgc3RhcnRTbGljZSA9IGluZCArIGxlbjtcbiAgICAgICAgICAgIGxldCBlbmRTbGljZSA9IGxpbmUuaW5kZXhPZihlbmQpO1xuICAgICAgICAgICAgaWYgKGluZCA+IGVuZFNsaWNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBsaW5lLnNsaWNlKHN0YXJ0U2xpY2UsIGVuZFNsaWNlKTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT0gXCJcIikgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxvZyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICAgICAgICBzdGFydCArIGZpZWxkTmFtZSArIGVuZCxcbiAgICAgICAgICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGROYW1lLCByZWNvcmQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBmaWVsZE5hbWUgKyBlbmQsXG4gICAgICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGROYW1lLCByZWNvcmQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIHBhcnNlTGluZShsaW5lLCByZWNvcmQsIGFjdGlvbk5hbWUpIHtcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShcIjptb2RlbE5hbWVcIiwgdGhpcy5tYW5pZmVzdC5tb2RlbCk7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCI6YWN0aW9uTmFtZVwiLCBhY3Rpb25OYW1lKTtcbiAgICAgICAgbGluZSA9IHRoaXMucGFyc2VQYXJhbXMoXCI6cmVjb3JkW1wiLCBcIl1cIiwgbGluZSwgcmVjb3JkKTtcbiAgICAgICAgbGluZSA9IHRoaXMucGFyc2VQYXJhbXMoXCI6XCIsIFwiP1wiLCBsaW5lLCByZWNvcmQpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICBnZXRVUkwocmVjb3JkLCBhY3Rpb25EYXRhLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIHZhciBsaW5lID1cbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKHRoaXMubWFuaWZlc3QudXJsLCByZWNvcmQsIGFjdGlvbk5hbWUpICtcbiAgICAgICAgICAgIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwicG9zdEZpeFwiKVxuICAgICAgICAgICAgICAgID8gdGhpcy5wYXJzZUxpbmUoYWN0aW9uRGF0YS5wb3N0Rml4LCByZWNvcmQsIGFjdGlvbk5hbWUpXG4gICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgZ2V0U2VydmVyVVJMKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpXG4gICAgICAgICAgICA/IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRPcHRpb25zKFwiYXBpLnNlcnZlci51cmxcIiwgXCJcIilcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICB9XG5cbiAgICBnZXRXU1JlcXVlc3ROYW1lKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5tYW5pZmVzdC5tb2RlbDtcbiAgICAgICAgcmV0dXJuIGAke21vZGVsTmFtZX0ke0RFRkFVTFRfV1NfUk9VVEVfQUNUSU9OX1NQTElUVEVSfSR7YWN0aW9uTmFtZX1gO1xuICAgIH1cblxuICAgIGVuY29kZVJlcXVlc3QoZGF0YSkge1xuICAgICAgICBsZXQgcCA9IFwiP1wiO1xuICAgICAgICBmb3IgKGxldCB0IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVt0XSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhW3RdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcCArPVxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodCkgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbdF0uY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoZGF0YVt0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFbdF1cbiAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgIFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZm9yIHRlc3QgcHVycG9zZSBvbmx5LCBzcGVjaWFsIHRlc3Qgc2VydmVyIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdFwiKSkge1xuICAgICAgICAgICAgcCArPSBcIiZ0ZXN0PTFcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJ0ZXN0LnNlc3Npb25cIikpIHtcbiAgICAgICAgICAgICAgICBwICs9IFwiJnNlc3Npb249XCIgKyB0aGlzLmdldE9wdGlvbnMoXCJ0ZXN0LnNlc3Npb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdC5zZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgcCArPSBcIiZyb2xlPVwiICsgdGhpcy5nZXRPcHRpb25zKFwidGVzdC5yb2xlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGNvbGxlY3RSZXF1ZXN0RGF0YShhY3Rpb25EYXRhKSB7XG4gICAgICAgIGxldCByZXF1ZXN0RGF0YSA9IHt9O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwiZGF0YVwiKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhY3Rpb25EYXRhLmRhdGEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25EYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVByb3ZpZGVyTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgIFwiZ2V0XCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbkRhdGEuZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzW2RhdGFQcm92aWRlck5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW2RhdGFQcm92aWRlck5hbWVdID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzW2RhdGFQcm92aWRlck5hbWVdKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNvcnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJldHVyblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5pbmRleE9mKGFjdGlvbkRhdGEuZGF0YVtpXSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1thY3Rpb25EYXRhLmRhdGFbaV1dID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEgPSBPYmplY3QuYXNzaWduKHJlcXVlc3REYXRhLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdERhdGE7XG4gICAgfVxuXG4gICAgZ2V0SUQocmVjb3JkLCBhY3Rpb25EYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHRJZCxcbiAgICAgICAgICAgIGxpc3QgPSBPUFRfREVGQVVMVF9JTkRFWF9GSUVMRF9OQU1FX1BSSU9SSVRZLFxuICAgICAgICAgICAgcHJlZml4ZXMgPSBbXCJcIiwgdGhpcy5tYW5pZmVzdC5tb2RlbF07XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwiaW5kZXhcIikgJiYgYWN0aW9uRGF0YS5pbmRleCkge1xuICAgICAgICAgICAgbGlzdCA9IFthY3Rpb25EYXRhLmluZGV4XS5jb25jYXQoXG4gICAgICAgICAgICAgICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcmUgb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgbGlzdCkge1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHJlY29yZCwgcHJlICsgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SWQgPSByZWNvcmRbcHJlICsgdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0SWQ7XG4gICAgfVxuXG4gICAgc2V0RmluZEJ5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRGaWx0ZXIob2JqKTtcbiAgICB9XG5cbiAgICBzZXRGaWx0ZXIoZmlsdGVyRGF0YSA9IERFRkFVTFRfRklMVEVSKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImZpbHRlclwiLCBmaWx0ZXJEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEZpbHRlcigpO1xuICAgIH1cblxuICAgIGdldEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImZpbHRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRTZWFyY2goc2VhcmNoRGF0YSA9IERFRkFVTFRfU0VBUkNIKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInNlYXJjaFwiLCBzZWFyY2hEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRTZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFNlYXJjaCgpO1xuICAgIH1cblxuICAgIGdldFNlYXJjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNlYXJjaFwiKTtcbiAgICB9XG5cbiAgICBzZXRTb3J0ZXIoc29ydGVyRGF0YSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzb3J0ZXJcIiwgc29ydGVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0U29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3J0ZXIoe30pO1xuICAgIH1cblxuICAgIGdldFNvcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNvcnRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRSZXR1cm4ocmV0dXJuRGF0YSA9IERFRkFVTFRfUkVUVVJOKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJldHVyblwiLCByZXR1cm5EYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRSZXR1cm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFJldHVybih7fSk7XG4gICAgfVxuXG4gICAgZ2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicmV0dXJuXCIpO1xuICAgIH1cblxuICAgIHNldFBhZ2VOdW1iZXIocGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlci5wYWdlXCIsIHBhZ2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRQYWdlU2l6ZShwYWdlU2l6ZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlci5zaXplXCIsIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9wYWdlU2l6ZSA9IERFRkFVTFRfUEFHRV9TSVpFLCBwYWdlTnVtYmVyID0gREVGQVVMVF9QQUdFX05VTUJFUlxuICAgIHNldFBhZ2VyKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYXJndW1lbnRzLmxlbmd0aCA8IDIgfHxcbiAgICAgICAgICAgICAgICBpc05hTihhcmd1bWVudHNbMF0pIHx8XG4gICAgICAgICAgICAgICAgaXNOYU4oYXJndW1lbnRzWzFdKSkgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFyZ3VtZW50c1swXSwgXCJwYWdlXCIpICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFyZ3VtZW50c1swXSwgXCJzaXplXCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcGFnZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlclwiLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogcGFnZXIuc2l6ZSB8fCBERUZBVUxUX1BBR0VfU0laRSxcbiAgICAgICAgICAgICAgICBwYWdlOiBwYWdlci5wYWdlIHx8IERFRkFVTFRfUEFHRV9OVU1CRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICFpc05hTihhcmd1bWVudHNbMF0pICYmXG4gICAgICAgICAgICAhaXNOYU4oYXJndW1lbnRzWzFdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcInBhZ2VyXCIsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBhcmd1bWVudHNbMF0gfHwgREVGQVVMVF9QQUdFX1NJWkUsXG4gICAgICAgICAgICAgICAgcGFnZTogYXJndW1lbnRzWzFdIHx8IERFRkFVTFRfUEFHRV9OVU1CRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlcigpO1xuICAgIH1cblxuICAgIGdldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicGFnZXJcIik7XG4gICAgfVxuXG4gICAgZ2V0UmVjb3JkKCkge1xuICAgICAgICB0aGlzLmdldERhdGEoKTtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0QXNQbGFpbk9iamVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmlmZXN0IHx8ICF0aGlzLm1hbmlmZXN0LmZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLm1hbmlmZXN0LmZpZWxkcykpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRoaXMubWFuaWZlc3QuZmllbGRzW2ZpZWxkTmFtZV0sIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMubWFuaWZlc3QuZmllbGRzW2ZpZWxkTmFtZV0uZGVmYXVsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gWy4uLmRlZmF1bHRWYWx1ZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0geyAuLi5kZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEludGVyZmFjZTtcbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbmltcG9ydCB7XG4gICAgTUVUQV9JTlRFUkZBQ0UsXG4gICAgTUVUQV9NQVBfVE9fSU5URVJGQUNFLFxuICAgIERFRkFVTFRfQUNUSU9OX1BSRUZJWCxcbn0gZnJvbSBcIi4vb3B0aW9uc1wiO1xuXG5pbXBvcnQgbm90SW50ZXJmYWNlIGZyb20gXCIuL2ludGVyZmFjZVwiO1xuXG5jbGFzcyBub3RSZWNvcmQgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihtYW5pZmVzdCwgaXRlbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgaXRlbSA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09IFwib2JqZWN0XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmlzUHJveHkpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvcihcInRoaXMgaXMgUHJveHkgaXRlbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIChpdGVtLmlzUmVjb3JkIHx8IGl0ZW0uaXNQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKG1hbmlmZXN0LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE9wdGlvbnMoe30pO1xuICAgICAgICB0aGlzW01FVEFfSU5URVJGQUNFXSA9IG5ldyBub3RJbnRlcmZhY2UobWFuaWZlc3QsIHt9KTtcbiAgICAgICAgdGhpcy5zZXREYXRhKGl0ZW0pO1xuICAgICAgICB0aGlzLmludGVyZmFjZVVwKCk7XG4gICAgICAgIHRoaXMubWFwVG9JbnRlcmZhY2UoKTtcbiAgICAgICAgdGhpcy5tYXBUb01ldGhvZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9EZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKHRoaXNbTUVUQV9JTlRFUkZBQ0VdLmdldERlZmF1bHRBc1BsYWluT2JqZWN0KCkpO1xuICAgIH1cblxuICAgIG1hcFRvSW50ZXJmYWNlKCkge1xuICAgICAgICBsZXQgcmVjID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgdCBvZiBNRVRBX01BUF9UT19JTlRFUkZBQ0UpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzW01FVEFfSU5URVJGQUNFXVt0XSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW01FVEFfSU5URVJGQUNFXVt0XSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gcmVjW01FVEFfSU5URVJGQUNFXVt0XSguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzID09IHJlY1tNRVRBX0lOVEVSRkFDRV0gPyByZWMgOiByZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcFRvTWV0aG9kcygpIHtcbiAgICAgICAgbGV0IG1hbmlmZXN0ID0gdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3QsXG4gICAgICAgICAgICBhcHAgPSBub3RDb21tb24uZ2V0QXBwKCksXG4gICAgICAgICAgICBtZXRob2RzID0ge307XG4gICAgICAgIGlmIChtYW5pZmVzdC5tZXRob2RzKSB7XG4gICAgICAgICAgICBtZXRob2RzID0gbWFuaWZlc3QubWV0aG9kcztcbiAgICAgICAgfSBlbHNlIGlmIChhcHApIHtcbiAgICAgICAgICAgIG1ldGhvZHMgPSBhcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJtb2RlbHNcIiwgdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3QubW9kZWxdLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihtZXRob2RzLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RdID0gbWV0aG9kc1t0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVDb2xsZWN0aW9uKG1hbmlmZXN0LCBpdGVtcykge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobmV3IG5vdFJlY29yZChtYW5pZmVzdCwgaXRlbXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnRlcmZhY2VVcCgpIHtcbiAgICAgICAgaWYgKHRoaXNbTUVUQV9JTlRFUkZBQ0VdLmdldEFjdGlvbnNDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzW01FVEFfSU5URVJGQUNFXS5nZXRBY3Rpb25zKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblVwKGksIGFjdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVXAoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRoaXMsIFtERUZBVUxUX0FDVElPTl9QUkVGSVggKyBpbmRleF0pKSB7XG4gICAgICAgICAgICB0aGlzW0RFRkFVTFRfQUNUSU9OX1BSRUZJWCArIGluZGV4XSA9ICguLi5wYXJhbXMpID0+XG4gICAgICAgICAgICAgICAgdGhpc1tNRVRBX0lOVEVSRkFDRV0ucmVxdWVzdCh0aGlzLCBpbmRleCwgLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAtPiAncGF0aC50by5rZXknLCB2YWx1ZU9mS2V5XG4gIDwtIG9rLCB3aXRoIG9uZSBvbkNoYW5nZSBldmVudCB0cmlnZ2VyZWRcbiAgKi9cblxuICAgIHNldEF0dHIoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qXG4gIC0+XG4gIHtcbiAgICAna2V5UGF0aCc6IHZhbHVlLFxuICAgICdrZXkuc3ViUGF0aCc6IHZhbHVlMixcbiAgICAna2V5UGF0aC4wLnRpdGxlJzogdmFsdWUzXG4gIH1cbiAgPC0gb2ssIHdpdGggYnVuY2ggb2Ygb25DaGFuZ2UgZXZlbnRzIHRyaWdnZXJlZFxuICAqL1xuICAgIHNldEF0dHJzKG9iamVjdFBhcnQpIHtcbiAgICAgICAgLy9ub3RDb21tb24ubG9nKCdzZXRBdHRycycsIG9iamVjdFBhcnQsIE9iamVjdC5rZXlzKG9iamVjdFBhcnQpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2JqZWN0UGFydCAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdFBhcnQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFBhcnQpLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXRoIGluIG9iamVjdFBhcnQpIHtcbiAgICAgICAgICAgICAgICAvL25vdENvbW1vbi5sb2coJ3NldEF0dHJzIG9uZSB0byBnbycsIHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cihwYXRoLCBvYmplY3RQYXJ0W3BhdGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gIC0+ICdwYXRoVG9LZXknXG4gIDwtIHZhbHVlMVxuICAqL1xuICAgIGdldEF0dHIod2hhdCwgcGxhaW4gPSBmYWxzZSkge1xuICAgICAgICBsZXQgcHJ4ID0gdGhpcy5nZXREYXRhKHdoYXQsIHt9KTtcbiAgICAgICAgaWYgKHBsYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLnN0cmlwUHJveHkocHJ4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcng7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAtPiBbJ3BhdGhUb0tleScsICdwYXRoLnRvLmtleScsICdzaW1wbGVLZXknLC4uLl1cbiAgPC0gW3ZhbHVlMSwgdmFsdWUyLCB2YWx1ZTMsLi4uXVxuICAqL1xuICAgIGdldEF0dHJzKHdoYXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAod2hhdCAmJiB3aGF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBhdGggb2Ygd2hhdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2V0QXR0cihwYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRNYW5pZmVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXNbTUVUQV9JTlRFUkZBQ0VdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZXREYXRhKGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFJlY29yZDtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90UmVjb3JkIGZyb20gXCIuL3JlY29yZC5qc1wiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IG5vdFJvdXRlciBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW09QVF9DT05UUk9MTEVSX1BSRUZJWCA9IFwibmNcIl0gY29udHJvbGxlciBuYW1lcyBwcmVmaXggbmMgYWthIE5vdENvbnRyb2xsZXJcbiAqL1xuY29uc3QgT1BUX0NPTlRST0xMRVJfUFJFRklYID0gXCJuY1wiO1xuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW09QVF9SRUNPUkRfUFJFRklYID0gXCJuclwiXSByZWNvcmQgbmFtZXMgcHJlZml4IG5yIGFrYSBOb3RSZWNvcmRcbiAqL1xuY29uc3QgT1BUX1JFQ09SRF9QUkVGSVggPSBcIm5yXCI7XG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSBbREVGQVVMVF9XU19DTElFTlRfTkFNRSA9IFwibWFpblwiXSBkZWZhdWx0IG5hbWUgb2YgV1MgY2xpZW50XG4gKi9cbmNvbnN0IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBcIm1haW5cIjtcblxuLyoqXG4gKiBDbGFzcyBvZiBhcHBsaWNhdGlvblxuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdEFwcCBleHRlbmRzIG5vdEJhc2Uge1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtmdW5jdGlvbn0gREVGQVVMVF9XU19DTElFTlRfTkFNRSAgZnVuY3Rpb24gdG8gcGVyZm9ybSBkZWVwIG1lcmdlcyBvZiBvYmplY3RzXG4gICAgICovXG4gICAgc3RhdGljIERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBERUZBVUxUX1dTX0NMSUVOVF9OQU1FO1xuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAgICAgICAgIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jb250cm9sbGVycyAgY29udHJvbGxlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG9wdGlvbnMubWFuaWZlc3RVUkwgVVJMIG9mIG5ldHdvcmsgbWFuaWZlc3Qgd2l0aCBhbGwgYXZhaWxhYmxlIG1vZGVscy9hY3Rpb25zL2ZpZWxkcyByZXF1ZXN0cyBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGludGVyZmFjZXM6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJzOiBub3RDb21tb24ub2JqSGFzKG9wdGlvbnMsIFwiY29udHJvbGxlcnNcIilcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmNvbnRyb2xsZXJzXG4gICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICAgICAgaW5pdENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgdWlzOiB7fSxcbiAgICAgICAgICAgICAgICB3c2M6IHt9LFxuICAgICAgICAgICAgICAgIHdzczoge30sXG4gICAgICAgICAgICAgICAgc2VydmljZXM6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzPy5sb2cgJiYgdGhpcy5sb2coXCJzdGFydCBhcHBcIik7XG4gICAgICAgIG5vdENvbW1vbi5yZWdpc3RlcihcImFwcFwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0TWFuaWZlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYXBwbGljYXRpb24gYWNjb3JkaW5nIHRvIG5ldHdvcmsgbWFuaWZlc3QsIHdoaWNoIGlzIHJldHJpZXZlZCBmcm9tIHNlcnZlclxuICAgICAqL1xuICAgIGluaXRNYW5pZmVzdCgpIHtcbiAgICAgICAgbm90Q29tbW9uXG4gICAgICAgICAgICAuZ2V0SlNPTih0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFVSTFwiKSlcbiAgICAgICAgICAgIC50aGVuKChtYW5pZmVzdCkgPT4gdGhpcy5zZXRJbnRlcmZhY2VNYW5pZmVzdChtYW5pZmVzdCkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IG5vdENvbW1vbi5yZXBvcnQoZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uZSBwYWdlIHJvdXRpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBpbml0Um91dGVyKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJyb3V0ZXJcIiwgbm90Um91dGVyKTtcbiAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVyXCIpLnNldFJvb3QodGhpcy5nZXRPcHRpb25zKFwicm91dGVyLnJvb3RcIikpO1xuICAgICAgICBub3RSb3V0ZXIucmVSb3V0ZUV4aXN0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFsbCB0aGUgcm91dGVzIGhhbmRsZXJzIGFuZCBwdXNoZXMgdGhlbSBpbnRvIHJvdXRlclxuICAgICAqL1xuICAgIGV4ZWNSb3V0ZXIoKSB7XG4gICAgICAgIHZhciByb3V0aWVJbnB1dCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuZ2V0T3B0aW9ucyhcInJvdXRlci5tYW5pZmVzdFwiKS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHJvdXRlQmxvY2sgPSB0aGlzLmdldE9wdGlvbnMoXCJyb3V0ZXIubWFuaWZlc3RcIilbdF0sXG4gICAgICAgICAgICAgICAgcGF0aHMgPSByb3V0ZUJsb2NrLnBhdGhzLFxuICAgICAgICAgICAgICAgIHNjaGVtZXMgPSByb3V0ZUJsb2NrLnNjaGVtZXMsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IHJvdXRlQmxvY2suY29udHJvbGxlcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0aFNjaGVtZSA9XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtZXMgJiYgQXJyYXkuaXNBcnJheShzY2hlbWVzKSAmJiBzY2hlbWVzLmxlbmd0aCA+IGlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2NoZW1lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICByb3V0aWVJbnB1dFtwYXRoc1tpXV0gPSB0aGlzLmJpbmRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBwYXRoU2NoZW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXJcIikuYWRkTGlzdChyb3V0aWVJbnB1dCkubGlzdGVuKCk7IC8vLm5hdmlnYXRlKHRoaXMuZ2V0T3B0aW9ucygncm91dGVyLmluZGV4JykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaW50ZXJmYWNlIG1hbmlmZXN0IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgbWFuaWZlc3QgICAgaW50ZXJmYWNlIG1hbmlmZXN0XG4gICAgICovXG4gICAgc2V0SW50ZXJmYWNlTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShtYW5pZmVzdCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIsIG1hbmlmZXN0KTtcbiAgICAgICAgdGhpcy5pbml0Um91dGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBjb25zdHJ1Y3RvciBvZiBpbnRlcmZhY2UgbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG1vZGVsTmFtZSAgIG1vZGVsIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICBpbnRlcmZhY2UgbW9kZWwgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2VNYW5pZmVzdChtb2RlbE5hbWUpIHtcbiAgICAgICAgaWYgKG1vZGVsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIpW21vZGVsTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlTWFuaWZlc3RcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGluZyBBcHBsaWNhdGlvbiwgcmVsb2FkcyBpbnRlcmZhY2VzLCBpbml0IGNvbnRyb2xsZXIgbGF1bmNoZWQsIHN0YXJ0IGFnYWluXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvL9C90YPQttC90L4g0LjQvdC40YbQuNCw0LvQuNC30LjRgNC+0LLQsNGC0YxcbiAgICAgICAgLy/QvNC+0LTQtdC70Lgg0L/QvtC70YPRh9C10L3QvdGL0LzQuCDQuNC90YLQtdGA0YTQtdC50YHQsNC80LhcbiAgICAgICAgdGhpcy51cGRhdGVJbnRlcmZhY2VzKCk7XG4gICAgICAgIC8v0LjQvdC40YbQuNC70LjRhtC40YDQvtCy0LDRgtGMINC4INC30LDQv9GD0YHRgtC40YLRjCDQutC+0L3RgtGA0L7Qu9C70LXRgCDQuNC90LjRhtC40LDQu9C40LfQsNGG0LjQuFxuICAgICAgICB0aGlzLmluaXRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRBcHAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvbiBvZiBzZXJ2aWNlcywgc3RhcnR1cCBvZiByb3V0aW5nXG4gICAgICovXG4gICAgc3RhcnRBcHAoKSB7XG4gICAgICAgIHRoaXMuaW5pdFNlcnZpY2VzKCk7XG4gICAgICAgIC8v0YHQvtC30LTQsNGC0Ywg0LrQvtC90YLRgNC+0LvQu9C10YDRi1xuICAgICAgICAvL9GA0L7Rg9GC0LXRgCDQuCDQv9GA0LjQstGP0LfQsNGC0Ywg0Log0L3QtdC80YMg0LrQvtC90YLRgNC+0LvQu9C10YDRi1xuICAgICAgICB0aGlzLmV4ZWNSb3V0ZXIoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJTdGFydGVkXCIsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXJOYW1lIGNvbnRyb2xsZXIgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb250cm9sbGVyUGF0aFNjaGVtZVxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZnVuY3Rpb24gY3JlYXRlcyBuZXcgY29udHJvbGxlciBpbnN0YW5jZSBhbmQgcGFzcyBpbiBub3RBcHAgaW5zdGFuY2UsIGFyZ3VtZW50cyBmcm9tIHJvdXRlciBwYXJzZXIgYW5kIHBhdGhTY2hlbWVcbiAgICAgKi9cbiAgICBiaW5kQ29udHJvbGxlcihjb250cm9sbGVyTmFtZSwgY29udHJvbGxlclBhdGhTY2hlbWUpIHtcbiAgICAgICAgbGV0IGFwcCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXcgY29udHJvbGxlck5hbWUoYXBwLCBhcmd1bWVudHMsIGNvbnRyb2xsZXJQYXRoU2NoZW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyAnaW5pdGlhbGl6YXRpb24nIGNvbnRyb2xsZXIgd2hpY2ggaXMgcnVucyBvbmNlLFxuICAgICAqIHRvIHBlcmZvcm0gY3VzdG9tIGluaXRpYWxpemF0aW9ucyByb3V0aW5lcyBieSBhcHBsaWNhdGlvbiBjb2RlXG4gICAgICovXG4gICAgaW5pdENvbnRyb2xsZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXRPcHRpb25zKFwiaW5pdENvbnRyb2xsZXJcIikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBpbml0Q29udHJvbGxlciA9IHRoaXMuZ2V0T3B0aW9ucyhcImluaXRDb250cm9sbGVyXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiaW5pdENvbnRyb2xsZXJcIiwgbmV3IGluaXRDb250cm9sbGVyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd29ya2luZyBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gd29ya2luZyBjb250cm9sbGVyXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJjdXJyZW50Q29udHJvbGxlclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95ZXMgd29ya2luZyBjb250cm9sbGVyIHRoZW4gc2V0cyBwcm92aWRlZCBhcyB3b3JraW5nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGN0cmwgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG5vdEFwcCBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDb250cm9sbGVyKGN0cmwpIHtcbiAgICAgICAgbGV0IG9sZEN0cmwgPSB0aGlzLmdldEN1cnJlbnRDb250cm9sbGVyKCk7XG4gICAgICAgIGlmIChvbGRDdHJsICYmIG9sZEN0cmwuZGVzdHJveSkge1xuICAgICAgICAgICAgb2xkQ3RybC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiY3VycmVudENvbnRyb2xsZXJcIiwgY3RybCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYXJyb3cgZnVuY3Rpb246IChtb2RlbEluaXREYXRhID0ge30pID0+IG5vdFJlY29yZFxuICAgICAqIEZhY3RvcnkgdGhhdCBjcmVhdGVzIG5vdFJlY29yZCBpbnN0YW5jZXMgd2l0aCBiaW5kZWRcbiAgICAgKiByZWNvcmRNYW5pZmVzdCBhbmQgcHJvdmlkZWQgZGF0YSB0byBpbml0aWFsaXplIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRNYW5pZmVzdFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgICAqIEBtZW1iZXJvZiBub3RBcHBcbiAgICAgKi9cbiAgICBjcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkocmVjb3JkTWFuaWZlc3QpIHtcbiAgICAgICAgcmV0dXJuIChyZWNvcmREYXRhKSA9PiBuZXcgbm90UmVjb3JkKHJlY29yZE1hbmlmZXN0LCByZWNvcmREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgaW50ZXJmYWNlcywgcmVjcmVhdGVzIGFsbCBhY2NvcmRpbmcgdG8gT3B0aW9ucy5pbnRlcmFmYWNlTWFuaWZlc3RcbiAgICAgKi9cbiAgICB1cGRhdGVJbnRlcmZhY2VzKCkge1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJmYWNlcygpO1xuICAgICAgICBsZXQgbWFuaWZlc3RzID0gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlTWFuaWZlc3RcIik7XG4gICAgICAgIGlmIChtYW5pZmVzdHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gbWFuaWZlc3RzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY29yZE1hbmlmZXN0ID0gbWFuaWZlc3RzW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRNZXRob2RzID0gdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wibW9kZWxzXCIsIG5hbWVdLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAge31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZWNvcmRNYW5pZmVzdC5tZXRob2RzID0gcmVjb3JkTWV0aG9kcztcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lSW50ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkocmVjb3JkTWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJmYWNlKG5hbWUsIG5hbWVJbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgaW50ZXJmYWNlIG5hbWUgKG1vZGVsTmFtZSkgdG8gc3RhbmRhcnRpemllZCBwcmVmaXhNb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBpbnRlcmZhY2UgbW9kZWwgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIG5vdCByZWNvcmQgbmFtZVxuICAgICAqL1xuICAgIGdldFJlY29yZE5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gT1BUX1JFQ09SRF9QUkVGSVggKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGNvbnRyb2xsZXIgbmFtZSAoY29udHJvbGxlck5hbWUpIHRvIHN0YW5kYXJ0aXppZWQgcHJlZml4Q29udHJvbGxlck5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb250cm9sbGVyIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICBub3QgY29udHJvbGxlciBuYW1lXG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlck5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gT1BUX0NPTlRST0xMRVJfUFJFRklYICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG5hbWVkIGludGVyZmFjZSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGVsRmFjdG9yeVxuICAgICAqIEByZXR1cm4ge25vdEFwcH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QXBwXG4gICAgICovXG4gICAgc2V0SW50ZXJmYWNlKG5hbWUsIG1vZGVsRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGBpbnRlcmZhY2VzLiR7bmFtZX1gLCBtb2RlbEZhY3RvcnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIG5ldHdvcmsgaW50ZXJmYWNlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFsbCBuZXR3b3JrIGluc3RlcmZhY2VzXG4gICAgICovXG4gICAgZ2V0SW50ZXJmYWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZXNcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbnRlcmZhY2VzIGxpc3QgY2xlYXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjbGVhckludGVyZmFjZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImludGVyZmFjZXNcIiwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFdlYlNvY2tldHMgY2xpZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPURFRkFVTFRfV1NfQ0xJRU5UX05BTUVdIG5hbWUgb2YgY2xpZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHdzYyAgbm90V1NDbGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2V0V1NDbGllbnQobmFtZSA9IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUsIHdzYykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGB3c2MuJHtuYW1lfWAsIHdzYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3ZWIgc29ja2V0cyBjbGllbnQgaW5zdGFuY2UgYnkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1ERUZBVUxUX1dTX0NMSUVOVF9OQU1FXVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGluc3RhbmNlIG9mIG5vdFdTQ2xpZW50XG4gICAgICovXG4gICAgZ2V0V1NDbGllbnQobmFtZSA9IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhgd3NjLiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIG5ldHdvcmsgaW50ZXJmYWNlIGNsYXNzIGluaXRpYWxpemF0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIG5ldHdvcmsgaW50ZXJmYWNlXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBpbnRlcmZhY2UgY2xhc3MgaW5pdGlhbGl6YXRvclxuICAgICAqL1xuICAgIGdldEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZXMoKVtuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldHdvcmsgaW50ZXJmYWNlIChtb2RlbCkgaW5pdGlhbGl6ZWQgd2l0aCBwcm92aWRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgaW50ZXJmYWNlKG1vZGVsTmFtZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGE9e31dICAgIG1vZGVsIGRhdGFcbiAgICAgKiBAcmV0dXJucyBuZXR3b3JrIGludGVyZmFjZSBpbml0aWFsaXplcyB3aXRoIHByb3ZpZGVkIGRhdGFcbiAgICAgKi9cbiAgICBnZXRNb2RlbChuYW1lLCBkYXRhID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJmYWNlKG5hbWUpKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VydmljZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gdmFsIHNlcnZpY2VcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlKG5hbWUsIHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGBzZXJ2aWNlcy4ke25hbWV9YCwgdmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gICAgICogQHJldHVybnMge29iamVjdHxmdW5jdGlvbn0gc2VydmljZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2UobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKGBzZXJ2aWNlcy4ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHByb3ZpZGVkIHNlcnZpY2VzXG4gICAgICovXG4gICAgaW5pdFNlcnZpY2VzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwic2VydmljZXNcIikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlcnZOYW1lIGluIHRoaXMuZ2V0T3B0aW9ucyhcInNlcnZpY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcnYgPSB0aGlzLmdldE9wdGlvbnMoYHNlcnZpY2VzLiR7c2Vydk5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZUeXBlID0gbm90Q29tbW9uLmRldGVjdFR5cGUoc2Vydik7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VydlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZXJ2aWNlKHNlcnZOYW1lLCBuZXcgc2Vydih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VydmljZShzZXJ2TmFtZSwgc2Vydik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXM/LmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBTZXJ2aWNlICgke3NlcnZOYW1lfSkgaW5pdCBlcnJvcmAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kdWxlIGRlZGljYXRlZCBvcHRpb25zIHJlYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lICAgbW9kdWxlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByZWFkZXIgb2JqZWN0IHtnZXQocGF0aFRvVmFsdWUsIGRlZmF1bHRWYWx1ZSl9XG4gICAgICovXG4gICAgZ2V0Q29uZmlnUmVhZGVyRm9yTW9kdWxlKG1vZHVsZU5hbWUgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IG1vZENvbmZQYXRoID0gW1wibW9kdWxlc1wiLCBtb2R1bGVOYW1lXS5qb2luKFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogKHN1YlBhdGgsIGZhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlBhdGggJiYgdHlwZW9mIHN1YlBhdGggPT0gXCJzdHJpbmdcIiAmJiBzdWJQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgW21vZENvbmZQYXRoLCBzdWJQYXRoXS5qb2luKFwiLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhtb2RDb25mUGF0aCwgZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtb2R1bGUgZGVkaWNhdGVkIG9wdGlvbnMgcmVhZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2R1bGVOYW1lPScnXSAgIG1vZHVsZSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVhZGVyIG9iamVjdCB7Z2V0KHBhdGhUb1ZhbHVlLCBkZWZhdWx0VmFsdWUpfVxuICAgICAqL1xuICAgIG1vZHVsZUNvbmZpZyhtb2R1bGVOYW1lID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWdSZWFkZXJGb3JNb2R1bGUobW9kdWxlTmFtZSk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgbm90QXBwO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IE5BVklHQVRJT05fREVMQVlfREVGQVVMVCB9IGZyb20gXCIuL2NvbnN0LmpzXCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUgPSBcImRlZmF1bHRcIl0gICAgICBkZWZhdWx0IGFjdGlvbiBuYW1lXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FID0gXCJkZWZhdWx0XCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCJtYWluLmNvbnRlbnRcIl0gIHNlbGVjdG9yIG9mIGNvbnRhaW5lciBIVE1MXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFxuICovXG5jb25zdCBPUFRfREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIm1haW4uY29udGVudFwiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX1BMVVJBTF9OQU1FID0gXCJNb2RlbHNcIl0gIGRlZmF1bHQgcGx1cmFsIG5hbWUgb2YgZW50aXRpZXNcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfUExVUkFMX05BTUUgPSBcIk1vZGVsc1wiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX1NJTkdMRV9OQU1FID0gXCJNb2RlbFwiXSAgZGVmYXVsdCBzaW5nbGUgbmFtZSBvZiBlbnRpdGllc1xuICovXG5jb25zdCBPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSA9IFwiTW9kZWxcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gIFtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRT1cIm1haW5cIl0gIGRlZmF1bHQgbW9kdWxlIG5hbWVcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfTU9EVUxFX05BTUUgPSBcIm1haW5cIjtcblxuLyoqXG4gKiBAY29uc3Qge2Jvb2xlYW59ICBbT1BUX0RFRkFVTFRfQVVUT19OQU1FID0gdHJ1ZV0gIGlmIHNob291bGQgYmUgdXNlZCBhdXRvIG5hbWUgZ2VuZXJhdG9yXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX0FVVE9fTkFNRSA9IHRydWU7XG5cbi8qKlxuICogIEJhc2ljIGNsYXNzIGZvciB1c2VyIGNvbnRyb2xsZXJcbiAqICBAZXh0ZW5kcyBub3RCYXNlXG4gKi9cbmNsYXNzIG5vdENvbnRyb2xsZXIgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7bnVtYmVyfSBQQVJBTVNfTEVOR1RIICBudW1iZXIgb2YgcGFyYW1zIGluIFVSTCBwYXRoXG4gICAgICovXG4gICAgc3RhdGljIFBBUkFNU19MRU5HVEggPSAyO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtzdHJpbmd9IE1PRFVMRV9OQU1FICBuYW1lIG9mIG1vZHVsZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9EVUxFX05BTUUoKSB7XG4gICAgICAgIHJldHVybiBPUFRfREVGQVVMVF9NT0RVTEVfTkFNRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfTkFNRSAgbmFtZSBvZiBtb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfTkFNRSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTW9kZWxOYW1lXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBMQUJFTFMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbHVyYWw6IGAke09QVF9ERUZBVUxUX01PRFVMRV9OQU1FfTptb2RlbF9sYWJlbF9wbHVyYWxgLFxuICAgICAgICAgICAgc2luZ2xlOiBgJHtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRX06bW9kZWxfbGFiZWxfc2luZ2xlYCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlICAgIHtvYmplY3R8bnVsbH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIGVscztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlICAgIHtvYmplY3R8bnVsbH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIG1ha2U7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSAgICB7bnVsbHxpbXBvcnQoJy4vYXBwLmpzJykuZGVmYXVsdH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIGFwcDtcbiAgICAvKipcbiAgICAgKiAgQGNsYXNzXG4gICAgICogIEBwYXJhbSB7aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9IGFwcFxuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgIG5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5hcHAuc2V0Q3VycmVudENvbnRyb2xsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcmVhZHk6IGZhbHNlLFxuICAgICAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICAgICAgbGliczoge30sXG4gICAgICAgICAgICBoZWxwZXJzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHt9KTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IE9QVF9ERUZBVUxUX01PRFVMRV9OQU1FLFxuICAgICAgICAgICAgY29udGFpbmVyU2VsZWN0b3I6IE9QVF9ERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUixcbiAgICAgICAgICAgIHByZWZpeDogYXBwLmdldE9wdGlvbnMoXCJwYXRocy5tb2R1bGVcIiksXG4gICAgICAgICAgICBuYW1lczoge1xuICAgICAgICAgICAgICAgIHBsdXJhbDogT1BUX0RFRkFVTFRfUExVUkFMX05BTUUsXG4gICAgICAgICAgICAgICAgc2luZ2xlOiBPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFVSTFByZWZpeChhcHAuZ2V0T3B0aW9ucyhcInJvdXRlci5yb290XCIpKTtcbiAgICAgICAgLypcbiAgICAgINGB0YDQsNC30YMg0LTQtdC70LDQtdC8INC00L7RgdGC0YPQv9C90YvQvNC4INC80L7QtNC10LvQuCBub3RSZWNvcmQg0LjQtyBuY2BDb250cm9sbGVyTmFtZWAg0LHRg9C00YPRgiDQtNC+0YHRgtGD0L/QvdGLINC60LDQuiB0aGlzLm5yYE1vZGVsTmFtZWBcbiAgICAqL1xuICAgICAgICBsZXQgaW50ZXJmYWNlcyA9IGFwcC5nZXRJbnRlcmZhY2VzKCk7XG4gICAgICAgIHRoaXMubWFrZSA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0IGluIGludGVyZmFjZXMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGludGVyZmFjZXMsIHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlW3RdID0gaW50ZXJmYWNlc1t0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCB1aU5hbWUgaW4gdGhpcy51aSkge1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXS5kZXN0cm95ICYmIHRoaXMudWlbdWlOYW1lXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51aVt1aU5hbWVdLiRkZXN0cm95ICYmIHRoaXMudWlbdWlOYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVscyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1ha2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgY3VycmVudCBub3RBcHBcbiAgICAgKiAgQHJldHVybiB7aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZ2V0QXBwKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIGRlZmF1bHQgY29udHJvbGxlciBtb2RlbFxuICAgICAqICBAcGFyYW0ge2ltcG9ydCgnLi9yZWNvcmQuanMnKX0gIG1vZGVsICBub3RSZWNvcmQgaW50ZXJmYWNlIG9iamVjdFxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVsXCIsIG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIElmIHplcm8gb3Igb25lIGFyZ3VtZW50IHByb3ZpZGVkIHRoaXMgbW9kZWxOYW1lIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiAgSWYgdHdvIHByb3ZpZGVkIGFuZCBmaXJzdCBpcyBhIHN0cmluZyB0aGFuIGluc3RhbmNlIG9mIG5hbWUgd2lsbCBiZSByZXR1cm5lZCBpbml0aWFsaXplZCB3aXRoIHNlY29uZCBvYmplY3QgcGFyYW0gb3IgZW1wdHkgb2JqZWN0XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICBbbmFtZV0gICAgbW9kZWxOYW1lIG9mIGluc3RhbmNlIHRvIHJldHVybiBvciBpbml0aWFsIGRhdGEgZm9yIGluc3RhbmNlXG4gICAgICogIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICBbZGF0YV0gICAgbW9kZWwgZGF0YVxuICAgICAqICBAcmV0dXJuIHtpbXBvcnQoJy4vcmVjb3JkLmpzJykuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBnZXRNb2RlbChuYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgaW50ID0gdGhpcy5nZXRJbnRlcmZhY2UobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50ICYmIGludChkYXRhIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGludCA9IHRoaXMuZ2V0SW50ZXJmYWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ICYmIGludChuYW1lIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbGxlciBpbnRlcmZhY2UgaWYgbmFtZSBpcyBub3Qgc3BlY2lmaWVkIG9yIGludGVyZmFjZSBvZiBzcGVjaWZpZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1cIlwiXVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2UobmFtZSA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwPy5nZXRJbnRlcmZhY2UobmFtZSB8fCB0aGlzLmdldE1vZGVsTmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBjdXJyZW50IG1vZGVsIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vZGVsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm1vZGVsTmFtZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgZGVmYXVsdCBjb250cm9sbGVyIG1vZGVsIG5hbWVcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICBtb2RlbE5hbWUgIG5vdFJlY29yZCBpbnRlcmZhY2Ugb2JqZWN0XG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9XG4gICAgICovXG4gICAgc2V0TW9kZWxOYW1lKG1vZGVsTmFtZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlbE5hbWVcIiwgbm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIobW9kZWxOYW1lKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGN1cnJlbnQgbW9kZWwgcHJpbWFyeSBJRCBmaWVsZCBuYW1lXG4gICAgICogIEByZXR1cm4ge2ltcG9ydCgnLi9yZWNvcmQuanMnKX1cbiAgICAgKi9cbiAgICBnZXRNb2RlbElERmllbGROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibW9kZWxJREZpZWxkTmFtZVwiLCBcIl9pZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBjdXJyZW50IG1vZGVsIHByaW1hcnkgSUQgZmllbGQgbmFtZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsSURGaWVsZE5hbWUodmFsID0gXCJfaWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKFwibW9kZWxJREZpZWxkTmFtZVwiLCB2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBNYXJrcyB0aGlzIGNvbnRyb2xsZXIgYXMgcmVhZHlcbiAgICAgKiAgZW1pdHMgXCJyZWFkeVwiL1wiYnVzeVwiIGV2ZW50c1xuICAgICAqICBAcGFyYW0ge0Jvb2xlYW59ICB2YWwgIHRydWUvZmFsc2VcbiAgICAgKi9cbiAgICBzZXRSZWFkeSh2YWwgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJlYWR5XCIsIHZhbCk7XG4gICAgICAgIHZhbCA/IHRoaXMuZW1pdChcInJlYWR5XCIpIDogdGhpcy5lbWl0KFwiYnVzeVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBtb2R1bGUgVVJMIHByZWZpeFxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmFsIFVSTCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldFVSTFByZWZpeCh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidXJsUHJlZml4XCIsIHZhbCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXV0b05hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIHVybCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiAge3N0cmluZ30gcHJlZml4XG4gICAgICovXG4gICAgZ2V0VVJMUHJlZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwidXJsUHJlZml4XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIG1vZHVsZSBuYW1lXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgbmFtZSBvZiB0aGUgbW9kdWxlXG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRNb2R1bGVOYW1lKHZhbCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJtb2R1bGVOYW1lXCIsIG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHZhbCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1dG9OYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBtb2R1bGUgbmFtZVxuICAgICAqICBAcmV0dXJuICB7c3RyaW5nfSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldE1vZHVsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJtb2R1bGVOYW1lXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kdWxlIHBhdGggcHJlZml4XG4gICAgICogIEByZXR1cm4ge3N0cmluZ30gIHBhdGggdG8gbW9kdWxlIGRpclxuICAgICAqL1xuICAgIGdldE1vZHVsZVByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRPcHRpb25zKFwicGF0aHMubW9kdWxlc1wiKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICBdLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kZWwgVVJMIHdpdGggVVJMIHByZWZpeFxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9ICB1cmwgcGF0aFxuICAgICAqL1xuICAgIGdldE1vZGVsVVJMKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhpcyBtb2RlbCBhY3Rpb24gVVJMIHdpdGggVVJMIHByZWZpeFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBpZCAgICAgICBzb21lIGlkZW50aWZpY2F0b3Igb2YgbW9kZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgYWN0aW9uICAgYWN0aW9uIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfSAgdXJsIHBhdGhcbiAgICAgKi9cbiAgICBnZXRNb2RlbEFjdGlvblVSTChpZCwgYWN0aW9uID0gXCJcIikge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHVybCBmcm9tIHZhbHVlIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIHZhbFxuICAgICAqKi9cbiAgICBidWlsZFVSTCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5idWlsZFVSTCh2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBVcGRhdGVzIHdvcmtpbmcgbmFtZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfSB0aGlzXG4gICAgICovXG4gICAgdXBkYXRlQXV0b05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvTmFtZVwiLCBPUFRfREVGQVVMVF9BVVRPX05BTUUpKSB7XG4gICAgICAgICAgICAvL3RoaXMuc2V0V29ya2luZygnbmFtZScsIHRoaXMuZ2V0TW9kZWxVUkwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgb2JqZWN0IG5hbWVcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBuYW1lIG9mIHRoZSBvYmplY3RcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldE5hbWUodmFsKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm5hbWVcIiwgdmFsKTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwiYXV0b05hbWVcIiwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgR2V0cyBvYmplY3QgbmFtZVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFByZWxvYWQgcmVjb3JkcyBmcm9tIHNlcnZlciwgdXNpbmcgbGlzdEFsbCBtZXRob2QsXG4gICAgICogIHJldHVybnMgUHJvbWlzZVxuICAgICAqICBAcGFyYW0ge29iamVjdH0gIGxpc3QgIG1hcCBvZiBwcmVsb2FkZWQgcmVjb3Jkc1xuICAgICAqICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHByZWxvYWRMaWIobGlzdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcImxvYWRpbmdcIiwgW10pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLnB1c2gobGlzdFt0XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVtsaXN0W3RdXSh7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC4kbGlzdEFsbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRPcHRpb25zKFwibGlic1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJsaWJzXCIsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwibGlic1wiKVt0XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmluZGV4T2YobGlzdFt0XSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ya2luZyhcImxvYWRpbmdcIikuaW5kZXhPZihsaXN0W3RdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0V29ya2luZyhcImxvYWRpbmdcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbWl0cyBhZnRlclJlbmRlciBldmVudFxuICAgICAqL1xuICAgIG9uQWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImFmdGVyUmVuZGVyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBUcmFuc2Zvcm0gcm91dGUgbmFtZSBpbiBhY3Rpb24gbmFtZVxuICAgICAqICBAcGFyYW0ge1N0cmluZ30gICBuYW1lIHRyYW5mb3JtIGFjdGlvbiBuYW1lXG4gICAgICogIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBY3Rpb25OYW1lKG5hbWUgPSBPUFRfREVGQVVMVF9BQ1RJT05fTkFNRSkge1xuICAgICAgICByZXR1cm4gXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEdldCBkZWZhdWx0IGNvbnRyb2xsZXIgYWN0aW9uIG5hbWVcbiAgICAgKiAgQHJldHVybiB7U3RyaW5nfSBkZWZhdWx0IGFjdGlvbiBmcm9tIG9wdGlvbnNcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0QWN0aW9uTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9uTmFtZShcbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImRlZmF1bHRBY3Rpb25cIiwgT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJvdXRlIHBhcmFtcyBpbnRvIHNwZWNpZmljIHJ1bltSb3V0ZV9uYW1lXSBmdW5jdGlvblxuICAgICAqICBAcGFyYW0ge2FycmF5fSAgIHBhcmFtcyAgIGNvbnRyb2xsZXIgaW5wdXQgcGFyYW1zXG4gICAgICogIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICByb3V0ZShwYXJhbXMpIHtcbiAgICAgICAgbGV0IFtyb3V0ZXJOYW1lLCAuLi5zdWJQYXJhbXNdID0gcGFyYW1zLFxuICAgICAgICAgICAgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0QWN0aW9uTmFtZShcbiAgICAgICAgICAgICAgICByb3V0ZXJOYW1lID8gcm91dGVyTmFtZSA6IE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FXG4gICAgICAgICAgICApO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbYWN0aW9uTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgdGhpc1thY3Rpb25OYW1lXShzdWJQYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbdGhpcy5nZXREZWZhdWx0QWN0aW9uTmFtZSgpXSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50QWN0aW9uKHRoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKSk7XG4gICAgICAgICAgICB0aGlzW3RoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKV0oc3ViUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudEFjdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKFwiTm8gYWN0aW9uIGluIHJvdXRlclwiLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3b3JraW5nIGFjdGlvblxuICAgICAqIEBwYXJhbXMge3N0cmluZ30gYWN0aW9uTmFtZSBjdXJyZW50IGFjdGlvbiBuYW1lXG4gICAgICovXG4gICAgc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImFjdGlvblwiLCBhY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdvcmtpbmcgYWN0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3VycmVudCBhY3Rpb24gbmFtZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRBY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJhY3Rpb25cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRBcHBPcHRpb25zKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBtb2R1bGUgb3B0aW9uc1xuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgW21vZHVsZU5hbWVdICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBvcHRpb25zIHJlcXVlc3RlZFxuICAgICAqICBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cbiAgICBnZXRNb2R1bGVPcHRpb25zKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcCgpLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgW1wibW9kdWxlc1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIHNlcnZpY2VzXG4gICAgICogIEBwYXJhbSAge3N0cmluZ30gICBtb2R1bGVOYW1lICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBzZXJ2aWNlcyByZXF1ZXN0ZWRcbiAgICAgKiAgQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgZ2V0U2VydmljZXMobW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJzZXJ2aWNlc1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIGNvbXBvbmVudHNcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgIG1vZHVsZU5hbWUgICAgbmFtZSBvZiB0aGUgbW9kdWxlIHdoaWNoIGNvbXBvbmVudHMgcmVxdWVzdGVkXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuICAgIGdldENvbXBvbmVudHMobW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJjb21wb25lbnRzXCIsIG1vZHVsZU5hbWUgfHwgdGhpcy5nZXRNb2R1bGVOYW1lKCldLmpvaW4oXCIuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmcmVzaGVzIGN1cnJlbnQgVVJMLCByZS1ydW4gYWxsIGFjdGlvblxuICAgICAqICBAcGFyYW0ge251bWJlcn0gdGltZW91dCB0aW1lIHRvIHdhaXQgaW4gbXNcbiAgICAgKi9cbiAgICByZWZyZXNoKHRpbWVvdXQgPSAwKSB7XG4gICAgICAgIHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpLnJlZnJlc2godGltZW91dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwYXRoIHBhdHRlcm4gZm9yIHJvdXRlclxuICAgICAqIEBwYXJhbXMge251bWJlcn0gWzBdIHBhcmFtc0NvdW50ICAgbnVtYmVyIG9mIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIHBhdHRlcm4gZm9yIGNvbnRyb2xsZXIgc3VwcG9ydGVkIHVybFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb250cm9sbGVyUm91dGUocGFyYW1zQ291bnQgPSAwKSB7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGlmICh0aGlzLk1PRFVMRV9OQU1FICYmIHRoaXMuTU9EVUxFX05BTUUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHRoaXMuTU9EVUxFX05BTUUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5NT0RFTF9OQU1FICYmIHRoaXMuTU9ERUxfTkFNRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIodGhpcy5NT0RFTF9OQU1FKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IFtwYXRoLmpvaW4oXCIvXCIpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCIvKFteL10rKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGF0aCBwYXR0ZXJucyBmb3Igcm91dGVyXG4gICAgICogQHBhcmFtcyB7bnVtYmVyfSBbMF0gcGFyYW1zRGVlcCAgIGhvdyBtYW55IHBhdGhzIHdpdGggcGFyYW1zIGluIHRoZSBlbmRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gIHBhdHRlcm5zIGZvciBjb250cm9sbGVyIHN1cHBvcnRlZCB1cmwgaW4gb3JkZXIgb2Ygc2ltcGxpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29udHJvbGxlclJvdXRlcyhwYXJhbXNEZWVwID0gMCkge1xuICAgICAgICBsZXQgcm91dGVzID0gW3RoaXMuZ2V0Q29udHJvbGxlclJvdXRlKDApXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXNEZWVwOyBpKyspIHtcbiAgICAgICAgICAgIHJvdXRlcy51bnNoaWZ0KHRoaXMuZ2V0Q29udHJvbGxlclJvdXRlKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJvdXRlciBydWxlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJvdXRlciBydWxlIHtwYXRoczpTdHJpbmdbXSwgY29udHJvbGxlcjpub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoczogdGhpcy5nZXRDb250cm9sbGVyUm91dGVzKHRoaXMuUEFSQU1TX0xFTkdUSCksXG4gICAgICAgICAgICBjb250cm9sbGVyOiB0aGlzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQXBwbGljYXRpb24gcm91dGVyXG4gICAgICogQHJldHVybnMge2ltcG9ydCgnLi9yb3V0ZXIuanMnKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIGdldFJvdXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgbG9jYXRpb24gdG8gYHVybGAgYWZ0ZXIgYGRlbGF5YCBtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICAgZGVsYXkgICBudW1iZXIgaW4gbXMgb3IgbmFtZSBvZiBkZWxheVxuICAgICAqL1xuICAgIG5hdmlnYXRlV2l0aERlbGF5KFxuICAgICAgICB1cmwsXG4gICAgICAgIGRlbGF5ID0gTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxULFxuICAgICAgICBkb0JlZm9yZSA9ICgpID0+IHt9XG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvdXRlcigpLm5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksIGRvQmVmb3JlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGxvY2F0aW9uIHRvIGB1cmxgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIG5hdmlnYXRlKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZSh1cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBOYXZpZ2F0aW5nIHRvIHRoaXMgY29udHJvbGxlciBtYWluIG1vZGVsIGBhY3Rpb25gIHdpdGggcHJvdmlkZWQgYGlkYCxcbiAgICAgKiAgZW1wdHkgYGlkYCB3aWxsIGJlIGRyb3BwZWQgZnJvbSByZXN1bHRpbmcgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZUFjdGlvbihpZCwgYWN0aW9uID0gXCJcIiwgZGVsYXkgPSAwLCBkb0JlZm9yZSA9ICgpID0+IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlTW9kdWxlQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICB0aGlzLmdldE1vZGVsTmFtZSgpLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE5hdmlnYXRpbmcgdG8gdGhpcyBjb250cm9sbGVyIG1vZHVsZSBtb2RlbCBvZiBgbW9kZWxOYW1lYCBgYWN0aW9uYCB3aXRoIHByb3ZpZGVkIGBpZGAsXG4gICAgICogIGVtcHR5IGBpZGAgd2lsbCBiZSBkcm9wcGVkIGZyb20gcmVzdWx0aW5nIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uPVwiXCJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSAgICAgICAgICAgIGRlbGF5IGluIG1zIGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gIFtkb0JlZm9yZV0gICAgICB3aWxsIGV4ZWN1dGVkIG9ubHkgaWYgZGVsYXllZCBhZnRlciBkZWxheSBidXQgYmVmb3JlIG5hdmlnYXRlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIG5hdmlnYXRlTW9kZWxBY3Rpb24oXG4gICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGlvbiA9IFwiXCIsXG4gICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgZG9CZWZvcmUgPSAoKSA9PiB7fVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE5hdmlnYXRpbmcgdG8gYG1vZHVsZU5hbWVgIGBtb2RlbE5hbWVgIGBhY3Rpb25gIHdpdGggcHJvdmlkZWQgYGlkYCxcbiAgICAgKiAgZW1wdHkgYGlkYCB3aWxsIGJlIGRyb3BwZWQgZnJvbSByZXN1bHRpbmcgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICBpZCxcbiAgICAgICAgYWN0aW9uID0gXCJcIixcbiAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICBkb0JlZm9yZSA9ICgpID0+IHt9XG4gICAgKSB7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVyKCkubmF2aWdhdGVXaXRoRGVsYXkoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiB0aGlzLmdldFVSTFByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICAgICAgZG9CZWZvcmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZShcbiAgICAgICAgICAgICAgICBub3RDb21tb24uYnVpbGRVUkwoe1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHRoaXMuZ2V0VVJMUHJlZml4KCksXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWVudSBpdGVtIGZyb20gY2hpbGQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge25vdENvbnRyb2xsZXJ9IGNoaWxkQ29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5OYXZpZ2F0aW9uSXRlbT59XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29tbW9uTWVudShjaGlsZENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHNlY3Rpb246IGNoaWxkQ29uc3RydWN0b3IuTU9EVUxFX05BTUUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGlsZENvbnN0cnVjdG9yLkxBQkVMUy5wbHVyYWwsXG4gICAgICAgICAgICAgICAgdXJsOiBgLyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb25zdHJ1Y3Rvci5NT0RVTEVfTkFNRVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgKX0vJHtub3RDb21tb24ubG93ZXJGaXJzdExldHRlcihjaGlsZENvbnN0cnVjdG9yLk1PREVMX05BTUUpfWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNZW51KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q29udHJvbGxlcjtcbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBBTEwgPSB7fTtcblxuZnVuY3Rpb24gZXhpc3Qoa2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd24oQUxMLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGV4aXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIEFMTFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShcbiAgICBrZXksXG4gICAgcHJvcHMgPSB7XG4gICAgICAgIHJhdzogW10sXG4gICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgIH1cbikge1xuICAgIGlmICghZXhpc3Qoa2V5KSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIEFMTFtrZXldID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFMTFtrZXldW25hbWVdID0gd3JpdGFibGUocHJvcHNbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdG9yZSdzIHByb3BzIHdhc24ndCBzcGVjaWZpZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFMTFtrZXldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgb2JqZWN0IHRoYXQgaXMgZmFrZSBTdG9yZVxuICogU29tZSB0aW1lIHRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBsb2NhbCB2YXIsXG4gKiBiZWZvcmUgeW91IGNvdWxkIGdldCBhY3R1YWwgU3RvcmVzIGZyb20gY2VudHJhbCBzdG9yYWdlIGJ5IGl0cyBJRFxuICpcdEBwYXJhbXMge21peGVkfSB2YWwgXHRkYXRhIG9mIHR5cGUgdGhhdCBpcyBhY3R1YWwgc3RvcmFnZSB3aWxsIGNvbnRhaW5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmFrZSh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZikge1xuICAgICAgICAgICAgZih2YWwpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7fSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGUsIGdldCwgZmFrZSB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0ICdidWxtYS1zd2l0Y2gnO1xuXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHlsaW5nXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgaWQgPSAnJyxcbiAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgIGZpZWxkbmFtZSA9ICdzd2l0Y2gnLFxuICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICBzdHlsaW5nID0gXCIgaXMtcm91bmRlZCBpcy1zdWNjZXNzIFwiXG4gIH0gPSAkcHJvcHMoKTtcblxuZnVuY3Rpb24gb25JbnB1dChldil7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICB2YWx1ZTogZXYudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcgPyBldi50YXJnZXQuY2hlY2tlZDpldi50YXJnZXQudmFsdWVcbiAgICB9O1xuICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCBkYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuPC9zY3JpcHQ+XG5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICBjbGFzcz1cInN3aXRjaCB7c3R5bGluZ31cIlxuICBpZD1cImVkaXQtdGFibGUtcm93LWNlbGwtaW5saW5lLXN3aXRjaC17ZmllbGRuYW1lfS17aWR9XCJcbiAgYmluZDpjaGVja2VkPXt2YWx1ZX1cbiAgbmFtZT1cIntmaWVsZG5hbWV9XCJcbiAge3JlYWRvbmx5fSB7ZGlzYWJsZWR9XG4gIG9uaW5wdXQ9e29uSW5wdXR9XG4gIC8+XG48bGFiZWwgY2xhc3M9XCJsYWJlbFwiIGZvcj1cImVkaXQtdGFibGUtcm93LWNlbGwtaW5saW5lLXN3aXRjaC17ZmllbGRuYW1lfS17aWR9XCI+PC9sYWJlbD5cbiIsIjxzY3JpcHQ+XG4gICAgLypcbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcbiAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG4qL1xuICAgIFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge2FueX0gW3ZhbHVlc10gLSBpdGVtID0ge1xuaWQsICAgICAgICAvL3VuaXF1ZVxudGl0bGUsICAgICAvL3NvbWUgdGV4dFxudmFsdWUsICAgICAgLy9mb3IgZG91YmxlIHRhZ3NcbmNvbG9yICAgICAgIC8vY29sb3Jpbmdcbn1cbiAgICovXG5cbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgbGV0IHsgdmFsdWVzID0gW10gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjZWFjaCB2YWx1ZXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgeyNpZiBPYmplY3QuaGFzT3duKGl0ZW0sIFwidmFsdWVcIil9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJteC0xIHRhZ3MgaGFzLWFkZG9uc1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWdcIj57aXRlbS50aXRsZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRhZyBpcy17aXRlbS5jb2xvcn0ge2l0ZW0uY3VzdG9tQ2xhc3Nlc31cIj5cbiAgICAgICAgICAgICAgICB7I2lmIGl0ZW0udXJsfVxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPXtpdGVtLnVybH0gY2xhc3M9e2l0ZW0udXJsQ3VzdG9tQ2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgID57aXRlbS52YWx1ZX08L2FcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAge2l0ZW0udmFsdWV9XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgezplbHNlfVxuICAgICAgICA8c3BhbiBjbGFzcz1cIm14LTEgdGFnIGlzLXtpdGVtLmNvbG9yfSB7aXRlbS5jdXN0b21DbGFzc2VzfVwiPlxuICAgICAgICAgICAgeyNpZiBpdGVtLnVybH1cbiAgICAgICAgICAgICAgICA8YSBocmVmPXtpdGVtLnVybH0gY2xhc3M9e2l0ZW0udXJsQ3VzdG9tQ2xhc3Nlc30+e2l0ZW0udGl0bGV9PC9hXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHtpdGVtLnRpdGxlfVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9zcGFuPlxuICAgIHsvaWZ9XG57L2VhY2h9XG5cbjxzdHlsZT5cbiAgICAudGFnczpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgbGV0IHRpdGxlID0gJHN0YXRlKFwiXCIpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGQudHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsIFwidGl0bGVQYXRoXCIpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBub3RQYXRoLmdldChmaWVsZC50aXRsZVBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBPYmplY3QuaGFzT3duKGZpZWxkLCBcInRpdGxlQ29tcG9zZXJcIikgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZmllbGQudGl0bGVDb21wb3NlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGZpZWxkLnRpdGxlQ29tcG9zZXIoaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gbm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlua3MgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xpbmsvdWkubGlua3Muc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2VzIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9pbWFnZS91aS5pbWFnZXMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQm9vbGVhbnMgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuYm9vbGVhbnMuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVGFibGVTd2l0Y2ggZnJvbSBcIi4vY29udHJvbHMvdWkuc3dpdGNoLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBUYWJsZVRhZ3MgZnJvbSBcIi4vY29udHJvbHMvdWkudGFncy5zdmVsdGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIGdldEl0ZW1JZCA9IChpdGVtKSA9PiBpdGVtLl9pZCxcbiAgICAgICAgZmllbGQgPSB7fSxcbiAgICAgICAgaXRlbSA9IHt9LFxuICAgICAgICBoZWxwZXJzID0ge31cbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHRkXG4gICAgY2xhc3M9eyhmaWVsZC5oaWRlT25Nb2JpbGUgPyBcIiBpcy1oaWRkZW4tdG91Y2ggXCIgOiBcIlwiKSArXG4gICAgICAgIChmaWVsZC5jbGFzc2VzID8gYCAke2ZpZWxkLmNsYXNzZXN9IGAgOiBcIlwiKX1cbiAgICB7dGl0bGV9XG4+XG4gICAgeyNpZiBmaWVsZC50eXBlID09PSBcImxpbmtcIn1cbiAgICAgICAgPFVJTGlua3MgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJidXR0b25cIn1cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcImltYWdlXCJ9XG4gICAgICAgIDxVSUltYWdlcyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcImJvb2xlYW5cIn1cbiAgICAgICAgPFVJQm9vbGVhbnMgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJ0YWdcIn1cbiAgICAgICAgPFRhYmxlVGFncyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcInN3aXRjaFwifVxuICAgICAgICA8VGFibGVTd2l0Y2hcbiAgICAgICAgICAgIGlkPXtnZXRJdGVtSWQoaXRlbSl9XG4gICAgICAgICAgICBmaWVsZG5hbWU9e2ZpZWxkLnBhdGh9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgdmFsdWU9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfVxuICAgICAgICAgICAgcmVhZG9ubHk9e2ZpZWxkLnJlYWRvbmx5fVxuICAgICAgICAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC5jb21wb25lbnR9XG4gICAgICAgIDxmaWVsZC5jb21wb25lbnRcbiAgICAgICAgICAgIGlkPXtnZXRJdGVtSWQoaXRlbSl9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgZmllbGRuYW1lPXtmaWVsZC5wYXRofVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfVxuICAgICAgICAgICAgcmVhZG9ubHk9e2ZpZWxkLnJlYWRvbmx5fVxuICAgICAgICAgICAgdmFsdWU9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfVxuICAgICAgICAgICAgey4uLmZpZWxkLm9wdGlvbnN9XG4gICAgICAgIC8+XG4gICAgezplbHNlIGlmIGZpZWxkICYmIHR5cGVvZiBmaWVsZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNOYU4oZmllbGQubWF4TGVuZ3RoKSAmJiBmaWVsZC5tYXhMZW5ndGh9XG4gICAgICAgIHtub3RDb21tb24uc3RyTGVuZ3RoQ2FwKFxuICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyksXG4gICAgICAgICAgICBmaWVsZC5tYXhMZW5ndGhcbiAgICAgICAgKX1cbiAgICB7OmVsc2V9XG4gICAgICAgIHskTE9DQUxFW25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpXX1cbiAgICB7L2lmfVxuPC90ZD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBVSVRhYmxlQ2VsbCBmcm9tICcuL25vdFRhYmxlQ2VsbC5zdmVsdGUnO1xuICBpbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSAnLi9zdG9yZXMuanMnO1xuICBcbiAgaW1wb3J0IHtvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXJ9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGxldCBpdGVtSWQgPSAkc3RhdGUoKSwgc2VsZWN0ZWRMaXN0O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgICAgaXRlbUlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgc2VsZWN0ZWRMaXN0ID0gU3RvcmVzLmdldChpZCkuc2VsZWN0ZWQ7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBpZFxuICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbaGVscGVyc11cbiAgICogQHByb3BlcnR5IHthbnl9IFtmaWVsZHNdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dTZWxlY3RdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbUlkXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgaWQsXG4gICAgICBpdGVtID0ge30sXG4gICAgICBoZWxwZXJzID0ge30sXG4gICAgICBmaWVsZHMgPSBbXSxcbiAgICAgIHNob3dTZWxlY3QgPSBmYWxzZSxcbiAgICAgIGdldEl0ZW1JZCA9ICgpPT57fVxuICB9ID0gJHByb3BzKCk7XG5cbiAgZnVuY3Rpb24gb25Sb3dTZWxlY3QoZSl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNwYXRjaCgncm93U2VsZWN0Q2hhbmdlJywge1xuICAgICAgICAgIGlkOiAgICAgICBpdGVtSWQsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICRzZWxlY3RlZExpc3RbaXRlbUlkXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG48L3NjcmlwdD5cblxuPHRyPlxuICB7I2lmIHNob3dTZWxlY3QgJiYgJHNlbGVjdGVkTGlzdCB9XG4gIDx0ZD5cbiAgICA8aW5wdXQgaWQ9XCJ0YWJsZS1yb3ctc2VsZWN0LXtnZXRJdGVtSWQoaXRlbSl9XCIgdHlwZT1cImNoZWNrYm94XCIgZGF0YS1pZD1cIntnZXRJdGVtSWQoaXRlbSl9XCIgYmluZDpjaGVja2VkPXskc2VsZWN0ZWRMaXN0W2l0ZW1JZF19IHBsYWNlaG9sZGVyPVwiXCIgbmFtZT1cInJvd19zZWxlY3RlZF97Z2V0SXRlbUlkKGl0ZW0pfVwiIG9uY2hhbmdlPXtvblJvd1NlbGVjdH0gLz5cbiAgPC90ZD5cbiAgey9pZn1cbiAgeyNlYWNoIGZpZWxkcyBhcyBmaWVsZCB9XG4gIDxVSVRhYmxlQ2VsbCB7ZmllbGR9IHtoZWxwZXJzfSB7aXRlbX0ge2dldEl0ZW1JZH0gLz5cbiAgey9lYWNofVxuPC90cj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0ICogYXMgU3RvcmVzIGZyb20gXCIuL3N0b3Jlcy5qc1wiO1xuXG4gICAgaW1wb3J0IFVJVGFibGVSb3cgZnJvbSBcIi4vbm90VGFibGVSb3cuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUxpbmtzIH0gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xpbmtcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbnMgfSBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvYnV0dG9uXCI7XG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLmZvbnQuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBpZFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaWx0ZXJVSVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaGVscGVyc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZmllbGRzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VsZWN0ZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaW5rc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93U2VhcmNoXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dTZWxlY3RdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2VsZWN0QWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbUlkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCxcbiAgICAgICAgZmlsdGVyVUksXG4gICAgICAgIGhlbHBlcnMgPSB7fSxcbiAgICAgICAgc3RhdGUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWx0ZXIgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBzb3J0ZXIgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWVsZHMgPSBbXSxcbiAgICAgICAgc2VsZWN0ZWQgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBpdGVtcyA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgc2VhcmNoID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBzaG93U2VhcmNoID0gdHJ1ZSxcbiAgICAgICAgc2hvd1NlbGVjdCA9IHRydWUsXG4gICAgICAgIHNlbGVjdEFsbCA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIGdldEl0ZW1JZCA9IChpdGVtKSA9PiBpdGVtLl9pZCxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHNob3dTZWxlY3QpIHtcbiAgICAgICAgICAgIFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgU3RvcmVzLmdldChpZCkucmVmaW5lZC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpdGVtcyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHNob3dTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtSWQgaW4gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcy5zb21lKChpdGVtKSA9PiBnZXRJdGVtSWQoaXRlbSkgPT09IGl0ZW1JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFtpdGVtSWRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHNlbGVjdGVkLCBpdGVtSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbaXRlbUlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBTdG9yZXMuZ2V0KGlkKS5zdGF0ZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uU2VhcmNoSW5wdXQoZXYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZXYuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBkaXNwYXRjaChcInNlYXJjaENoYW5nZVwiLCBkYXRhKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblNlYXJjaENoYW5nZSh7IGRldGFpbCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChcInNlYXJjaENoYW5nZVwiLCBkZXRhaWwpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRmlsdGVyQ2hhbmdlKHsgZGV0YWlsIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKFwiZmlsdGVyQ2hhbmdlXCIsIGRldGFpbCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29QcmV2KCkge1xuICAgICAgICBkaXNwYXRjaChcImdvVG9QcmV2UGFnZVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb05leHQoKSB7XG4gICAgICAgIGRpc3BhdGNoKFwiZ29Ub05leHRQYWdlXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvVG8oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBlbCA9IGUudGFyZ2V0O1xuICAgICAgICBkaXNwYXRjaChcImdvVG9QYWdlXCIsIHBhcnNlSW50KGVsLmRhdGFzZXQucGFnZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TZWxlY3RBbGwoKSB7XG4gICAgICAgIFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkLnVwZGF0ZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtnZXRJdGVtSWQoaXRlbSldID0gc2VsZWN0QWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRmllbGRIZWFkQ2xpY2soZmllbGQpIHtcbiAgICAgICAgY29uc3QgcHJvcFBhdGggPSBmaWVsZC5wYXRoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oc29ydGVyLCBwcm9wUGF0aCkpIHtcbiAgICAgICAgICAgIHNvcnRlcltwcm9wUGF0aF0gPSBwYXJzZUludChzb3J0ZXJbcHJvcFBhdGhdKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydGVyID0ge1xuICAgICAgICAgICAgICAgIFtwcm9wUGF0aF06IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKFwic29ydGVyQ2hhbmdlXCIsIHNvcnRlcik7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgbGlua3MubGVuZ3RofVxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZCBpcy1ncm91cGVkXCI+XG4gICAgICAgIDxVSUxpbmtzIHZhbHVlcz17bGlua3N9IC8+XG4gICAgPC9kaXY+XG57L2lmfVxueyNpZiBhY3Rpb25zLmxlbmd0aH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZFwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17YWN0aW9uc30gLz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG57I2lmIHNob3dTZWFyY2h9XG4gICAgeyNpZiBmaWx0ZXJVSX1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBmaWx0ZXJVSX1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICAgICAgYmluZDpmaWx0ZXJcbiAgICAgICAgICAgIG9uOmNoYW5nZT17b25GaWx0ZXJDaGFuZ2V9XG4gICAgICAgICAgICBvbjpzZWFyY2hDaGFuZ2U9e29uU2VhcmNoQ2hhbmdlfVxuICAgICAgICAvPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cItCf0L7QuNGB0LpcIlxuICAgICAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtzZWFyY2h9XG4gICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9e29uU2VhcmNoSW5wdXR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuey9pZn1cbjx0YWJsZSBjbGFzcz1cInRhYmxlXCI+XG4gICAgPHRoZWFkPlxuICAgICAgICA8dHI+XG4gICAgICAgICAgICB7I2lmIHNob3dTZWxlY3R9XG4gICAgICAgICAgICAgICAgPHRoXG4gICAgICAgICAgICAgICAgICAgID48aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cInRhYmxlLXJvdy1zZWxlY3QtcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e3NlbGVjdEFsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyb3dfc2VsZWN0ZWRfYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2hhbmdlPXtvblNlbGVjdEFsbH1cbiAgICAgICAgICAgICAgICAgICAgLz48L3RoXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCBmaWVsZHMgYXMgZmllbGR9XG4gICAgICAgICAgICAgICAge0Bjb25zdCBwcm9wUGF0aCA9IGZpZWxkLnBhdGguc3Vic3RyaW5nKDEpfVxuICAgICAgICAgICAgICAgIDx0aFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz17KGZpZWxkLmhpZGVPbk1vYmlsZSA/IFwiIGlzLWhpZGRlbi10b3VjaFwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZpZWxkLnNvcnRhYmxlID8gXCIgaXMtY2xpY2thYmxlXCIgOiBcIlwiKX1cbiAgICAgICAgICAgICAgICAgICAgb25jbGljaz17b25GaWVsZEhlYWRDbGljayhmaWVsZCl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGZpZWxkLnNvcnRhYmxlICYmIE9iamVjdC5oYXNPd24oc29ydGVyLCBwcm9wUGF0aCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VUlJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udD17c29ydGVyW3Byb3BQYXRoXSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInNvcnQtdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwic29ydC1kb3duXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2ZpZWxkLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50YWJsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHskTE9DQUxFW2ZpZWxkLnRpdGxlXX1cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5PlxuICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5faWQpfVxuICAgICAgICAgICAgPFVJVGFibGVSb3dcbiAgICAgICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICAgICAge2l0ZW19XG4gICAgICAgICAgICAgICAge2ZpZWxkc31cbiAgICAgICAgICAgICAgICB7aGVscGVyc31cbiAgICAgICAgICAgICAgICB7c2hvd1NlbGVjdH1cbiAgICAgICAgICAgICAgICB7Z2V0SXRlbUlkfVxuICAgICAgICAgICAgICAgIG9uOnJvd1NlbGVjdENoYW5nZVxuICAgICAgICAgICAgLz5cbiAgICAgICAgey9lYWNofVxuICAgIDwvdGJvZHk+XG48L3RhYmxlPlxueyNpZiBzdGF0ZT8ucGFnaW5hdGlvbj8ucGFnZXM/Lmxpc3QubGVuZ3RoID4gMX1cbiAgICA8bmF2IGNsYXNzPVwicGFnaW5hdGlvbiBpcy1jZW50ZXJlZFwiIGFyaWEtbGFiZWw9XCJwYWdpbmF0aW9uXCI+XG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XCJwYWdpbmF0aW9uLXByZXZpb3VzXCIgb25jbGljaz17Z29QcmV2fT7QndCw0LfQsNC0PC9hPlxuICAgICAgICA8YSBocmVmIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgb25jbGljaz17Z29OZXh0fT7QktC/0LXRgNC10LQ8L2E+XG4gICAgICAgIDx1bCBjbGFzcz1cInBhZ2luYXRpb24tbGlzdFwiPlxuICAgICAgICAgICAgeyNpZiBzdGF0ZS5wYWdpbmF0aW9uICYmIHN0YXRlLnBhZ2luYXRpb24ucGFnZXMgJiYgc3RhdGUucGFnaW5hdGlvbi5wYWdlcy5saXN0fVxuICAgICAgICAgICAgICAgIHsjZWFjaCBzdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QgYXMgcGFnZX1cbiAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBwYWdlLmFjdGl2ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1saW5rIGlzLWN1cnJlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwi0KHRgtGA0LDQvdC40YbQsCB7cGFnZS5pbmRleH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWN1cnJlbnQ9XCJwYWdlXCI+e3BhZ2UuaW5kZXggKyAxfTwvYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cItCh0YLRgNCw0L3QuNGG0LAge3BhZ2UuaW5kZXh9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1wYWdlPXtwYWdlLmluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtnb1RvfT57cGFnZS5pbmRleCArIDF9PC9hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3VsPlxuICAgIDwvbmF2Plxuey9pZn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIndvbGZ5ODctZXZlbnRlbWl0dGVyXCI7XG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vbi5qc1wiO1xuXG5pbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSBcIi4vc3RvcmVzLmpzXCI7XG5pbXBvcnQgVUlUYWJsZSBmcm9tIFwiLi9ub3RUYWJsZS5zdmVsdGVcIjtcblxuY29uc3QgQ09OU1RfSURfRFVCTElDQVRFX1BPU1RGSVggPSBcIl9fZHVibGljYXRlX19cIjtcblxuY29uc3QgT1BUX0RFRkFVTFRfUEFHRV9TSVpFID0gMjAsXG4gICAgT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVIgPSAwLFxuICAgIE9QVF9ERUZBVUxUX1BBR0VfUkFOR0UgPSA2LFxuICAgIE9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OID0gMSxcbiAgICBPUFRfREVGQVVMVF9TRUFSQ0ggPSBcIlwiLFxuICAgIE9QVF9ERUZBVUxUX1JFVFVSTiA9IHt9LFxuICAgIE9QVF9ERUZBVUxUX0NPTUJJTkVEID0gZmFsc2UsXG4gICAgT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OID0gXCJsaXN0QW5kQ291bnRcIixcbiAgICBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT04gPSBcImNvdW50XCIsXG4gICAgT1BUX0RFRkFVTFRfTElTVF9BQ1RJT04gPSBcImxpc3RcIixcbiAgICBPUFRfREVGQVVMVF9TT1JUX0ZJRUxEID0gXCJfaWRcIixcbiAgICBPUFRfRklFTERfTkFNRV9QUkVfUFJPQyA9IFwicHJlcHJvY2Vzc29yXCI7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1aTogVUlUYWJsZSxcbiAgICBsaW5rczogW10sXG4gICAgYWN0aW9uczogW10sXG4gICAgZW5kbGVzczogZmFsc2UsXG4gICAgaWRGaWVsZDogXCJfaWRcIixcbiAgICBnZXRJdGVtSWQ6IChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLl9pZDtcbiAgICB9LFxufTtcblxuY2xhc3Mgbm90VGFibGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IFwidGFibGUtXCIgKyBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX09QVElPTlMsXG4gICAgICAgICAgICAuLi4oaW5wdXQub3B0aW9ucyA/IGlucHV0Lm9wdGlvbnMgOiB7fSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgICAgIHJlZmluZWQ6IFtdLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2luZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuc3RvcmVzID0gU3RvcmVzLmNyZWF0ZSh0aGlzLmlkLCB7XG4gICAgICAgICAgICByYXc6IFtdLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IFtdLFxuICAgICAgICAgICAgcmVmaW5lZDogW10sXG4gICAgICAgICAgICBzZWxlY3RlZDoge30sXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHdvcmtpbmc6IHRoaXMud29ya2luZyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdG9yZXMud29ya2luZy5zdWJzY3JpYmUodGhpcy5vbldvcmtpbmdVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0L/QvtC70YPRh9C10L3QvdGL0LUg0LjQtyDRgdC10YLQuFxuICAgICAgICB0aGlzLnN0b3Jlcy5yYXcuc3Vic2NyaWJlKHRoaXMub25SYXdVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0L/RgNC40LzQtdC90LXQvdGLINGE0LjQu9GM0YLRgNGLLCDRgdC+0YDRgtC40YDQvtCy0LrQuCDQuCDRgi7QtC5cbiAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQuc3Vic2NyaWJlKHRoaXMub25GaWx0ZXJlZFVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy/Rg9GA0LXQt9Cw0L3RiyDQtNC+INC80LjQvdC40LzQsNC70YzQvdC+0LPQviDQvdCw0LHQvtGA0LAsINGC0L7Rh9C90L4g0YHQvtC+0YLQstC10YHRgtCy0YPRjtGJ0LXQs9C+INGC0LDQsdC70LjRh9C90L7QvNGDINGE0L7RgNC80LDRgtGDXG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQuc3Vic2NyaWJlKHRoaXMub25SZWZpbmVkVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL9GB0LvQvtCy0LDRgNGMINGBINC40LTQtdC90YLQuNGE0LjQutCw0YLQvtGA0LDQvNC4INCy0YvQsdGA0LDQvdC90YvRhSDRgdGC0YDQvtC6XG4gICAgICAgIHRoaXMuc3RvcmVzLnNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLm9uU2VsZWN0ZWRVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vcGFnaW5hdGlvbiwgaXRlbXMgaW5mb3JtYXRpb25cbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUuc3Vic2NyaWJlKHRoaXMub25TdGF0ZVVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhpbnB1dCwgXCJkYXRhXCIpICYmIEFycmF5LmlzQXJyYXkoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLnJhdy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbCA9IGlucHV0LmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDb21iaW5lZEFjdGlvbk5hbWUoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIixcbiAgICAgICAgICAgICAgICBPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT05cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwiZmlsdGVyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpbHRlcih0aGlzLm9wdGlvbnMuZmlsdGVyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwicGFnZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZXIodGhpcy5vcHRpb25zLnBhZ2VyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHRoaXMub3B0aW9ucywgXCJzb3J0ZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ydGVyKHRoaXMub3B0aW9ucy5zb3J0ZXIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNvcnRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwicmV0dXJuXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJldHVybih0aGlzLm9wdGlvbnMucmV0dXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5vcHRpb25zLCBcInNlYXJjaFwiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2godGhpcy5vcHRpb25zLnNlYXJjaCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvbldvcmtpbmdVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblJhd1VwZGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5kYXRhLnJhdyA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvbkZpbHRlcmVkVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRhdGEuZmlsdGVyZWQgPSB2YWw7XG4gICAgICAgIHRoaXMucmVmaW5lRmlsdGVyZWQoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblJlZmluZWRVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5yZWZpbmVkID0gdmFsO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblN0YXRlVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIG9uU2VhcmNoQ2hhbmdlKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2gobGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Tb3J0ZXJDaGFuZ2Uoc29ydGVyKSB7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ydGVyKHNvcnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U29ydGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkZpbHRlckNoYW5nZSh7IGZpbHRlciwgYWN0aW9uTmFtZSB9KSB7XG4gICAgICAgIGlmIChhY3Rpb25OYW1lLmluZGV4T2YoT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21iaW5lZEFjdGlvbk5hbWUoYWN0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2VsZWN0ZWRVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZWxlY3RlZCA9IHZhbDtcbiAgICB9XG5cbiAgICBjbGVhclNlbGVjdGVkKCkge1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0ZWQgPSB7fTtcbiAgICB9XG5cbiAgICBnZXRTZWxlY3RlZChvYmplY3QgPSBmYWxzZSwgc3RvcmUgPSBcInJlZmluZWRcIikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuZGF0YS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5zZWxlY3RlZFtpZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmR4ID0gdGhpcy5kYXRhW3N0b3JlXS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5faWQgPT09IGlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuZGF0YVtzdG9yZV1baW5keF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGdldEl0ZW1JZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJnZXRJdGVtSWRcIiwgREVGQVVMVF9PUFRJT05TLmdldEl0ZW1JZCkoaXRlbSk7XG4gICAgfVxuXG4gICAgc2VsZWN0QWxsKCkge1xuICAgICAgICB0aGlzLnN0b3Jlcy5zZWxlY3RlZC51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ge307XG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlsdGVyZWQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlW3RoaXMuZ2V0SXRlbUlkKGl0ZW0pXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZWN0Tm9uZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc2VsZWN0ZWQudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0aGlzLmdldEl0ZW1JZChpdGVtKV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy51aS50YWJsZSkge1xuICAgICAgICAgICAgdGhpcy51aS50YWJsZSA9IG5ldyB0aGlzLm9wdGlvbnMudWkoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldEVsLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclVJOiB0aGlzLmdldE9wdGlvbnMoXCJmaWx0ZXJVSVwiLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRIZWxwZXJzKCkpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogdGhpcy5nZXRBY3Rpb25zKCksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzOiB0aGlzLmdldExpbmtzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlbGVjdDogdGhpcy5nZXRPcHRpb25zKFwic2hvd1NlbGVjdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlYXJjaDogdGhpcy5nZXRPcHRpb25zKFwic2hvd1NlYXJjaFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NvcnQ6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dTb3J0XCIpLFxuICAgICAgICAgICAgICAgICAgICBpZEZpZWxkOiB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpLFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtSWQ6IHRoaXMuZ2V0T3B0aW9ucyhcImdldEl0ZW1JZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmdldEZpbHRlcigpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcInNlYXJjaENoYW5nZVwiLCAoZSkgPT4gdGhpcy5vblNlYXJjaENoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcInNvcnRlckNoYW5nZVwiLCAoZSkgPT4gdGhpcy5vblNvcnRlckNoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImZpbHRlckNoYW5nZVwiLCAoZSkgPT4gdGhpcy5vbkZpbHRlckNoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImdvVG9QYWdlXCIsIChlKSA9PiB0aGlzLmdvVG9QYWdlKGUuZGV0YWlsKSk7XG4gICAgICAgIHRoaXMudWkudGFibGUuJG9uKFwiZ29Ub05leHRQYWdlXCIsICgpID0+IHRoaXMuZ29Ub05leHQoKSk7XG4gICAgICAgIHRoaXMudWkudGFibGUuJG9uKFwiZ29Ub1ByZXZQYWdlXCIsICgpID0+IHRoaXMuZ29Ub1ByZXYoKSk7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImFjdGlvbnNcIiwgW10pO1xuICAgIH1cblxuICAgIGdldExpbmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibGlua3NcIiwgW10pO1xuICAgIH1cblxuICAgIGdldEhlbHBlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaGVscGVycyB8fCB7fTtcbiAgICB9XG5cbiAgICBzZXRXb3JraW5nKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMud29ya2luZy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgbm90UGF0aC5zZXQoa2V5LCB2YWwsIHRoaXMuZ2V0SGVscGVycygpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V29ya2luZyhrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLndvcmtpbmcsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFN0YXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIG5vdFBhdGguc2V0KGtleSwgdmFsLCB0aGlzLmdldEhlbHBlcnMoKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFN0YXRlKGtleSwgZGVmKSB7XG4gICAgICAgIGxldCByZXMgPSBub3RQYXRoLmdldChrZXksIHRoaXMuc3RhdGUsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldE9wdGlvbnMoa2V5LCB2YWx1ZSkge1xuICAgICAgICBub3RQYXRoLnNldChrZXksIHRoaXMub3B0aW9ucywgdGhpcy5nZXRIZWxwZXJzKCksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucyhrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEZpbHRlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImZpbHRlclwiLCBoYXNoKTtcbiAgICAgICAgaWYgKHdpdGhvdXRJbnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0RmlsdGVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwiZmlsdGVyXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZShcImZpbHRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRQYWdlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInBhZ2VyXCIsIGhhc2gpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRQYWdlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gaXNOYU4odGhpcy5nZXRPcHRpb25zKFwicGFnZXIucGFnZVwiKSlcbiAgICAgICAgICAgID8gT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVJcbiAgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25zKFwicGFnZXIucGFnZVwiKTtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0UGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiBpc05hTih0aGlzLmdldE9wdGlvbnMoXCJwYWdlci5zaXplXCIpKVxuICAgICAgICAgICAgPyBPUFRfREVGQVVMVF9QQUdFX1NJWkVcbiAgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25zKFwicGFnZXIuc2l6ZVwiKTtcbiAgICB9XG5cbiAgICByZXNldFBhZ2VyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXJcIiwge1xuICAgICAgICAgICAgc2l6ZTogdGhpcy5nZXREZWZhdWx0UGFnZVNpemUoKSxcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0UGFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKFwicGFnZXJcIik7XG4gICAgfVxuXG4gICAgc2V0U29ydGVyKGhhc2gsIHdpdGhvdXRJbnZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzb3J0ZXJcIiwgaGFzaCk7XG4gICAgICAgIGlmICh3aXRob3V0SW52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludmFsaWRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFNvcnRlcih3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHQgPSB7fTtcbiAgICAgICAgdFtPUFRfREVGQVVMVF9TT1JUX0ZJRUxEXSA9IE9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3J0ZXIodCwgd2l0aG91dEludmFsaWRhdGlvbik7XG4gICAgfVxuXG4gICAgZ2V0U29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwic29ydGVyXCIpO1xuICAgIH1cblxuICAgIGdldFNvcnRlckRpcmVjdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0U29ydGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVyKClbbmFtZXNbMF1dO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBPUFRfREVGQVVMVF9TT1JUX0RJUkVDVElPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNlYXJjaCgpIHtcbiAgICAgICAgbGV0IHNlYXJjaCA9XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5nZXRXb3JraW5nKFwic2VhcmNoXCIpICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIikgIT09IG51bGw7XG4gICAgICAgIHJldHVybiBzZWFyY2ggPyB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIikgOiBcIlwiO1xuICAgIH1cblxuICAgIHNldFNlYXJjaChsaW5lID0gT1BUX0RFRkFVTFRfU0VBUkNILCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwic2VhcmNoXCIsIGxpbmUpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicmV0dXJuXCIpO1xuICAgIH1cblxuICAgIHNldFJldHVybihyZXQgPSBPUFRfREVGQVVMVF9SRVRVUk4pIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicmV0dXJuXCIsIHJldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyRmlsdGVyZWREYXRhKCkge1xuICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyUmF3RGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMucmF3LnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXJSZWZpbmVkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMucmVmaW5lZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGludmFsaWRhdGVEYXRhKCkge1xuICAgICAgICAvL2NsZWFyaW5nIGZpbHRlcmVkIGFuZCBzb3J0ZWRcbiAgICAgICAgdGhpcy5jbGVhckZpbHRlcmVkRGF0YSgpO1xuICAgICAgICAvL2luIGNhc2UgbGl2ZSBsb2FkaW5nIGZyb20gc2VydmVyXG4gICAgICAgIGlmICh0aGlzLmlzTGl2ZSgpKSB7XG4gICAgICAgICAgICAvL2NsZWFyaW5nIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICB0aGlzLmNsZWFyUmF3RGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVzc2V0IHBhZ2VyIGFueXdheVxuICAgICAgICB0aGlzLnJlc2V0UGFnZXIoKTtcbiAgICB9XG5cbiAgICBpc0xpdmUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2VcIikgJiYgdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmZhY3RvcnlcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXRVcGRhdGluZygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInVwZGF0aW5nXCIsIHRydWUpO1xuICAgIH1cblxuICAgIHNldFVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJ1cGRhdGluZ1wiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWZVcGRhdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoXCJ1cGRhdGluZ1wiKTtcbiAgICB9XG5cbiAgICBnZXREYXRhSW50ZXJmYWNlKCkge1xuICAgICAgICBsZXQgZmFjdG9yeSA9IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5mYWN0b3J5XCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkoe30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMb2FkRGF0YUFjdGlvbk5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UubGlzdEFjdGlvblwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UubGlzdEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9MSVNUX0FDVElPTjtcbiAgICB9XG5cbiAgICBzZXRDb21iaW5lZEFjdGlvbk5hbWUoYWN0aW9uTmFtZSA9IE9QVF9ERUZBVUxUX0NPVU5UX0FDVElPTikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIiwgYWN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgZ2V0Q29tYmluZWRBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwiaW50ZXJmYWNlLmNvbWJpbmVkQWN0aW9uXCIpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZS5jb21iaW5lZEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT047XG4gICAgfVxuXG4gICAgZ2V0Q291bnRBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvdW50QWN0aW9uXCIpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5jb3VudEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT047XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKSB7XG4gICAgICAgIC8vbG9hZCBmcm9tIHNlcnZlclxuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmdldERhdGFJbnRlcmZhY2UoKVxuICAgICAgICAgICAgICAgIC5zZXRGaWx0ZXIodGhpcy5nZXRGaWx0ZXIoKSlcbiAgICAgICAgICAgICAgICAuc2V0U29ydGVyKHRoaXMuZ2V0U29ydGVyKCkpXG4gICAgICAgICAgICAgICAgLnNldFJldHVybih0aGlzLmdldFJldHVybigpKVxuICAgICAgICAgICAgICAgIC5zZXRTZWFyY2godGhpcy5nZXRTZWFyY2goKSlcbiAgICAgICAgICAgICAgICAuc2V0UGFnZXIodGhpcy5nZXRQYWdlcigpKSxcbiAgICAgICAgICAgIGFjdGlvbk5hbWU7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UuY29tYmluZWRcIiwgT1BUX0RFRkFVTFRfQ09NQklORUQpKSB7XG4gICAgICAgICAgICBhY3Rpb25OYW1lID0gdGhpcy5nZXRDb21iaW5lZEFjdGlvbk5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbk5hbWUgPSB0aGlzLmdldExvYWREYXRhQWN0aW9uTmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeVtcIiRcIiArIGFjdGlvbk5hbWVdKCk7XG4gICAgfVxuXG4gICAgZ29Ub05leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaXNOYU4odGhpcy5nZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIikpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKVxuICAgICAgICAgICAgOiB0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSArIDE7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICBcInBhZ2VyLnBhZ2VcIixcbiAgICAgICAgICAgIE1hdGgubWluKG5leHQsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLnRvXCIpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICB9XG5cbiAgICBnb1RvUHJldigpIHtcbiAgICAgICAgbGV0IHByZXYgPSBpc05hTih0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSlcbiAgICAgICAgICAgID8gdGhpcy5nZXREZWZhdWx0UGFnZU51bWJlcigpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0U3RhdGUoXCJwYWdlci5wYWdlXCIpIC0gMTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgIFwicGFnZXIucGFnZVwiLFxuICAgICAgICAgICAgTWF0aC5tYXgocHJldiwgdGhpcy5nZXRTdGF0ZShcInBhZ2luYXRpb24ucGFnZXMuZnJvbVwiKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub0ZpcnN0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCB0aGlzLmdldFN0YXRlKFwicGFnaW5hdGlvbi5wYWdlcy5mcm9tXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub0xhc3QoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJwYWdlci5wYWdlXCIsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLnRvXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub1BhZ2UocGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCBwYWdlTnVtYmVyKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgdGVzdERhdGFJdGVtKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gdGhpcy5nZXRTZWFyY2goKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKHZhciBrIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciB0b0NvbXAgPSBpdGVtW2tdLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0b0NvbXAuaW5kZXhPZihzdHJWYWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRSb3dzQ291bnQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZ2V0RGF0YUludGVyZmFjZSgpLnNldEZpbHRlcih0aGlzLmdldEZpbHRlcigpKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5W1wiJFwiICsgdGhpcy5nZXRDb3VudEFjdGlvbk5hbWUoKV0oKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oZGF0YS5jb3VudCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhZ2luYXRpb24oaXRlbXNDb3VudCkge1xuICAgICAgICB0aGlzLmxvZyhcInVwZGF0ZSBwYWdpbmF0aW9uXCIsIGl0ZW1zQ291bnQpO1xuICAgICAgICB0aGlzLnN0YXRlLnBhZ2luYXRpb24ucGFnZXMubGlzdC5zcGxpY2UoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGxldCBpdGVtc0Zyb20gPVxuICAgICAgICAgICAgICAgICh0aGlzLmdldFBhZ2VyKCkucGFnZSAtIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSKSAqXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5zaXplICtcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgcGFnZXNDb3VudCA9XG4gICAgICAgICAgICAgICAgaXRlbXNDb3VudCAlIHRoaXMuZ2V0UGFnZXIoKS5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcihpdGVtc0NvdW50IC8gdGhpcy5nZXRQYWdlcigpLnNpemUpICsgMVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucm91bmQoaXRlbXNDb3VudCAvIHRoaXMuZ2V0UGFnZXIoKS5zaXplKSxcbiAgICAgICAgICAgIHBhZ2VzRnJvbSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5wYWdlIC0gT1BUX0RFRkFVTFRfUEFHRV9SQU5HRVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHBhZ2VzVG8gPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBwYWdlc0NvdW50IC0gKDEgLSBPUFRfREVGQVVMVF9QQUdFX05VTUJFUiksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRQYWdlcigpLnBhZ2UgKyBPUFRfREVGQVVMVF9QQUdFX1JBTkdFXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICAgICAgaXRlbXNUbyA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIGl0ZW1zRnJvbSArIHRoaXMuZ2V0UGFnZXIoKS5zaXplIC0gMSxcbiAgICAgICAgICAgICAgICBpdGVtc0NvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCB0ID0gcGFnZXNGcm9tOyB0IDw9IHBhZ2VzVG87IHQrKykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogdCxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IHQgPT09IHRoaXMuZ2V0UGFnZXIoKS5wYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3Jlcy5zdGF0ZS51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ1cGRhdGUgcGFnaW5hdGlvblwiLCB2YWwpO1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24uaXRlbXMuY291bnQgPSBpdGVtc0NvdW50O1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24uaXRlbXMuZnJvbSA9IGl0ZW1zRnJvbTtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLml0ZW1zLnRvID0gaXRlbXNUbztcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmNvdW50ID0gcGFnZXNDb3VudDtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmZyb20gPSBwYWdlc0Zyb207XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy50byA9IHBhZ2VzVG87XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5jdXJyZW50ID0gdGhpcy5nZXRQYWdlcigpLnBhZ2U7XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5saXN0LnNwbGljZShcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgICAgIC4uLmxpc3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVEYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWZVcGRhdGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldE9wdGlvbnMoXCJlbmRsZXNzXCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSYXdEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFVwZGF0aW5nKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvbWJpbmVkXCIsIE9QVF9ERUZBVUxUX0NPTUJJTkVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bGwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgXCJzdGF0dXNcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGRhdGEsIFwicmVzdWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0T3B0aW9ucyhcImVuZGxlc3NcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGaWx0ZXJlZERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnB1c2goLi4uZGF0YS5yZXN1bHQubGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhkYXRhLCBcImxpc3RcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS5saXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEubGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnB1c2goLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFzdENvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbCA/IGRhdGEucmVzdWx0LmNvdW50IDogZGF0YS5jb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uKHRoaXMuZ2V0V29ya2luZyhcImxhc3RDb3VudFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aGlzLmVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0VXBkYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRSb3dzQ291bnQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHRoaXMuZXJyb3IuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5zZXRVcGRhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9sb2NhbCBtYWdpY1xuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGluZygpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgdGhhdEZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyKCk7XG4gICAgICAgIC8vdGhpcy5nZXREYXRhKCdyb3dzJykuX19zZXRQYXNzaXZlO1xuICAgICAgICB0aGlzLmxvZyh0aGlzLmdldERhdGEoKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGF0RmlsdGVyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhhdEZpbHRlci5maWx0ZXJTZWFyY2ggIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHRoYXRGaWx0ZXIuZmlsdGVyU2VhcmNoICE9PSBudWxsICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyLmZpbHRlclNlYXJjaC5sZW5ndGggPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICB2YWwubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmRhdGEucmF3LmZpbHRlcih0aGlzLnRlc3REYXRhSXRlbS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgsIC4uLnRoaXMuZGF0YS5yYXcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLy8vc29ydGVyXG4gICAgICAgIGxldCB0aGF0U29ydGVyID0gdGhpcy5nZXRTb3J0ZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGF0U29ydGVyICE9PSBcInVuZGVmaW5lZFwiICYmIHRoYXRTb3J0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdDEgPSBub3RQYXRoLmdldCh0aGF0U29ydGVyLnNvcnRCeUZpZWxkLCBpdGVtMSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBub3RQYXRoLmdldCh0aGF0U29ydGVyLnNvcnRCeUZpZWxkLCBpdGVtMiwge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHQxICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHQyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEubG9jYWxlQ29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEubG9jYWxlQ29tcGFyZSgpICogLXRoYXRTb3J0ZXIuc29ydERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0MSA8IHQyID8gMSA6IC0xKSAqIHRoYXRTb3J0ZXIuc29ydERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvZ2dlci5lcnJvciguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvZ2dlci5sb2coLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrRmllbGRzTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpO1xuICAgICAgICBjb25zdCBwYXRoSWQgPSBcIjpcIiArIGZpZWxkSWQ7XG4gICAgICAgIGxldCBmaWVsZHMgPSB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwgW10pO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXRoSWQgPT09IGZpZWxkLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5wYXRoID0gZmllbGQucGF0aCArIENPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWFkRmllbGRWYWx1ZShwYXRoLCBpdGVtLCBoZWxwZXJzKSB7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoQ09OU1RfSURfRFVCTElDQVRFX1BPU1RGSVgpID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpO1xuICAgICAgICAgICAgY29uc3QgcGF0aElkID0gXCI6XCIgKyBmaWVsZElkO1xuICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KHBhdGhJZCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90UGF0aC5nZXQocGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZpbmVGaWx0ZXJlZCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrRmllbGRzTmFtZXMoKTtcbiAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImlkRmllbGRcIikpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW3RoaXMuZ2V0T3B0aW9ucyhcImlkRmllbGRcIildID1cbiAgICAgICAgICAgICAgICAgICAgaXRlbVt0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiLCBbXSkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlcHJvY2Vzc2VkID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkRmllbGRWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwiaGVscGVyc1wiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGZpZWxkLCBPUFRfRklFTERfTkFNRV9QUkVfUFJPQykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXByb2Nlc3NlZCA9IGZpZWxkW09QVF9GSUVMRF9OQU1FX1BSRV9QUk9DXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVycm9yIHdoaWxlIHByZXByb2Nlc3NpbmcgY2VsbCB2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub3RQYXRoLnNldChmaWVsZC5wYXRoLCByZWZpbmVkLCBwcmVwcm9jZXNzZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdFBhdGguc2V0KGZpZWxkLnBhdGgsIHJlZmluZWQsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5zcGxpY2UoMCwgdmFsLmxlbmd0aCwgLi4ucmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMudWkpIHtcbiAgICAgICAgICAgIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3kgJiYgdGhpcy51aVtuYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudWlbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFRhYmxlO1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMb2FkZXIgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkubG9hZGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbnRhaW5lciBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvbGF5b3V0L3VpLmNvbnRhaW5lci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOb3RpZmljYXRpb25FcnJvciBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLmVycm9yLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5vdGlmaWNhdGlvblN1Y2Nlc3MgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5zdWNjZXNzLnN2ZWx0ZVwiO1xuXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuXG4gICAgbGV0IHN1Y2Nlc3MgPSAkc3RhdGUoZmFsc2UpO1xuXG4gICAgbGV0IGVycm9yID0gJHN0YXRlKGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY29udGFpbmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGVyQWN0aXZlXSAtIHN0YXRlIGlmIGZvcm0gbG9hZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyU2l6ZV0gLSBwYWdlIC0gd2hvbGUgcGFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VjY2Vzc1RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VjY2Vzc01lc3NhZ2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvclRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JNZXNzYWdlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjb250YWluZXIgPSB7fSxcbiAgICAgICAgbG9hZGVyVGl0bGUgPSAkYmluZGFibGUoXCLQntGC0L/RgNCw0LLQutCwINC00LDQvdC90YvRhSDQvdCwINGB0LXRgNCy0LXRgFwiKSxcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbG9hZGVyU2l6ZSA9ICRiaW5kYWJsZShcImNvbnRhaW5lclwiKSxcbiAgICAgICAgc3VjY2Vzc1RpdGxlID0gJGJpbmRhYmxlKFwiT0tcIiksXG4gICAgICAgIHN1Y2Nlc3NNZXNzYWdlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBlcnJvclRpdGxlID0gJGJpbmRhYmxlKFwiRXJyb3JcIiksXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2hvd1N1Y2Nlc3ModGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChtZXNzYWdlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VjY2Vzc01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NUaXRsZSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dFcnJvcih0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yVGl0bGUgPSB0aXRsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRMb2FkaW5nKCkge1xuICAgICAgICBsb2FkZXJBY3RpdmUgPSB0cnVlO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGhpZGVBbGwoKSB7XG4gICAgICAgIGxvYWRlckFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSUxvYWRlclxuICAgIGJpbmQ6bG9hZGluZz17bG9hZGVyQWN0aXZlfVxuICAgIGJpbmQ6dGl0bGU9e2xvYWRlclRpdGxlfVxuICAgIGJpbmQ6c2l6ZT17bG9hZGVyU2l6ZX1cbi8+XG48VUlDb250YWluZXIgey4uLmNvbnRhaW5lcn0+XG4gICAgeyNpZiBlcnJvcn1cbiAgICAgICAgPFVJTm90aWZpY2F0aW9uRXJyb3JcbiAgICAgICAgICAgIGJpbmQ6dGl0bGU9e2Vycm9yVGl0bGV9XG4gICAgICAgICAgICBiaW5kOm1lc3NhZ2U9e2Vycm9yTWVzc2FnZX1cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuICAgIHsjaWYgc3VjY2Vzc31cbiAgICAgICAgPFVJTm90aWZpY2F0aW9uU3VjY2Vzc1xuICAgICAgICAgICAgYmluZDp0aXRsZT17c3VjY2Vzc1RpdGxlfVxuICAgICAgICAgICAgYmluZDptZXNzYWdlPXtzdWNjZXNzTWVzc2FnZX1cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuPC9VSUNvbnRhaW5lcj5cbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuLi8uLi9iYXNlXCI7XG5cbmltcG9ydCBVSUFjdGlvbkNvbnRhaW5lciBmcm9tIFwiLi91aS5hY3Rpb24uY29udGFpbmVyLnN2ZWx0ZVwiO1xuY29uc3QgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIi5jb250YWluZXJcIjtcbmltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vY29uc3RcIjtcblxuY2xhc3Mgbm90QWN0aW9uVUkgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvL1VJIHJlbmRlcmVyIGNvbXBvbmVudCBjbGFzcyBjb25zdHJ1Y3RvclxuICAgICN1aUNvbXBvbmVudCA9IG51bGw7XG4gICAgI3VpID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgICAgbmFtZSA9IFwiRGVmYXVsdFwiLFxuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIHdvcmtpbmcgPSB7fSxcbiAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICB1aSA9IFVJQWN0aW9uQ29udGFpbmVyLCAvL2RlZmF1bHQgVUlcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtuYW1lfUFjdGlvblVJYCxcbiAgICAgICAgICAgICAgICAuLi53b3JraW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdWlDb21wb25lbnQgPSB1aTtcbiAgICAgICAgdGhpcy5pbml0VUkoKTtcbiAgICB9XG5cbiAgICBpbml0VUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldEVsKCk7XG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0LmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQodGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy4jdWkgPSBuZXcgdGhpcy4jdWlDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wczogdGhpcy5nZXRPcHRpb25zKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMuI3VpLnNldExvYWRpbmcoKTtcbiAgICB9XG5cbiAgICByZXNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRlZFwiKTtcbiAgICAgICAgdGhpcy4jdWkucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI3VpKSB7XG4gICAgICAgICAgICB0aGlzLiN1aS4kZGVzdHJveSAmJiB0aGlzLiN1aS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jdWkuZGVzdHJveSAmJiB0aGlzLiN1aS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiN1aSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG51bGwpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YShudWxsKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gREVGQVVMVF9TVEFUVVNfU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtU3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1FcnJvcnMocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgRm9ybSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAqKi9cbiAgICBzZXRGb3JtU3VjY2VzcygpIHtcbiAgICAgICAgdGhpcy4jdWkuc2hvd1N1Y2Nlc3MoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtRXJyb3JzKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBmb3JtOiBbXSxcbiAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgc3RhdHVzLmZvcm0ucHVzaChyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiYgT2JqZWN0LmtleXMocmVzdWx0LmVycm9ycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdHVzLmZpZWxkcyA9IHsgLi4ucmVzdWx0LmVycm9ycyB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VpLnNob3dFcnJvcihzdGF0dXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIC8qKipcbiAgICAgKiBSZWRlZmluYWJsZSBnZXR0ZXJzXG4gICAgICoqL1xuICAgIGdldFRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuZ2V0T3B0aW9ucyhcInRhcmdldFwiLCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUik7XG4gICAgICAgIGlmICh0YXJnZXRFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0RWw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldEVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3Rpb25VSSBwYXJlbnQgZWxlbWVudCBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QWN0aW9uVUk7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb25cIjtcblxuaW1wb3J0IHsgRklFTERTLCBDT01QT05FTlRTLCBWQVJJQU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcblxuY2xhc3Mgbm90Rm9ybVV0aWxzIHtcbiAgICBzdGF0aWMgdmFsaWRhdG9yID0gbnVsbDtcblxuICAgIHN0YXRpYyBhZGRDb21wb25lbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgQ09NUE9ORU5UUy5hZGQobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRWYXJpYW50cyhuYW1lLCB2YWx1ZSkge1xuICAgICAgICBWQVJJQU5UUy5hZGQobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRGaWVsZChuYW1lLCBmaWVsZCkge1xuICAgICAgICBGSUVMRFMuYWRkKG5hbWUsIGZpZWxkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWN0aW9uRmllbGRzSW5pdChmaWVsZE5hbWUsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZmllbGROYW1lLmZvckVhY2goKHN1YkZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uRmllbGRzSW5pdChzdWJGaWVsZE5hbWUsIG9wdGlvbnMsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5vdENvbW1vbi5vYmpIYXMob3B0aW9ucywgXCJmaWVsZHNcIikpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub3RDb21tb24ub2JqSGFzKG9wdGlvbnMuZmllbGRzLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZHNbZmllbGROYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb3B5aW5nIGluaXRpYWwgZGF0YVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgZGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhW2ZpZWxkTmFtZV0gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gIT09IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzW2ZpZWxkTmFtZV0udmFsdWUgPSBkYXRhW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEZvcm1VdGlscztcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG5jb25zdCBERUZBVUxUX0ZJRUxEID0ge1xuICAgIGxhYmVsOiBcIlwiLFxuICAgIHBsYWNlaG9sZGVyOiBcIlwiLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgdmlzaWJsZTogdHJ1ZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB2YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHZhbGlkOiBmYWxzZSxcbiAgICBlcnJvcnM6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGZpZWxkIG1hbmlmZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgICAgIG5hbWUvdHlwZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBtdXRhdGlvbiAgbXV0YXRpb24gdG8gbWFuaWZlc3QgZnJvbSBsaWJyYXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gVkFSSUFOVFMgIHN0b3JlIHdoaWNoIGNvbnRhaW5zIG5hbWVkIGxpc3RzIG9mIGZpZWxkIHZhbHVlIHZhcmlhbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gRklFTERTICAgIHN0b3JlIHdoaWNoIGNvbnRhaW5zIG5hbWVkIGxpc3RzIG9mIGZpZWxkIG1hbmlmZXN0c1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBmaWVsZCBtYW5pZmVzdFxuICoqL1xuZnVuY3Rpb24gZmllbGRJbml0KHR5cGUsIG11dGF0aW9uID0ge30sIFZBUklBTlRTLCBGSUVMRFMpIHtcbiAgICBsZXQgZmllbGQgPSB7IC4uLkRFRkFVTFRfRklFTEQgfTtcbiAgICAvL2dldHRpbmcgZmllbGQgY29yZSBtYW5pZmVzdFxuICAgIGlmIChGSUVMRFMuY29udGFpbnModHlwZSkpIHtcbiAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIC4uLkZJRUxEUy5nZXQodHlwZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYWRkaW5nIG11dGF0aW9uc1xuICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgLi4ubXV0YXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYWRkaW5nIHZhcmlhbnRzIGxpc3QgdG8gZmllbGQgZnJvbSBWQVJJQU5UUyBzdG9yZVxuICAgIGlmIChcbiAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmaWVsZCwgXCJ2YXJpYW50c1NvdXJjZVwiKSAmJlxuICAgICAgICBWQVJJQU5UUy5jb250YWlucyhmaWVsZC52YXJpYW50c1NvdXJjZSlcbiAgICApIHtcbiAgICAgICAgZmllbGQudmFyaWFudHMgPSBWQVJJQU5UUy5nZXQoZmllbGQudmFyaWFudHNTb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmllbGQudmFyaWFudHMgfHwgZmllbGQudmFyaWFudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC52YXJpYW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBvZiBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkIHR5cGUgaWYgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzID0gc3ViZm9ybVxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgVkFSSUFOVFMgICAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCB2YWx1ZSB2YXJpYW50c1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgRklFTERTICAgICAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCBtYW5pZmVzdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zICAgZm9ybSB3aWRlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBpbml0Rm9ybUJ5RmllbGQoXG4gICAgZm9ybSA9IHt9LFxuICAgIGZpZWxkTmFtZSA9IFtdLFxuICAgIFZBUklBTlRTLFxuICAgIEZJRUxEUyxcbiAgICBmb3JtRmllbGRzT3B0aW9ucyxcbiAgICBkYXRhXG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZE5hbWUpKSB7XG4gICAgICAgIGZpZWxkTmFtZS5mb3JFYWNoKChzdWJGb3JtRmllbGROYW1lKSA9PlxuICAgICAgICAgICAgaW5pdEZvcm1CeUZpZWxkKFxuICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgc3ViRm9ybUZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBWQVJJQU5UUyxcbiAgICAgICAgICAgICAgICBGSUVMRFMsXG4gICAgICAgICAgICAgICAgZm9ybUZpZWxkc09wdGlvbnMsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBvcHRzID0ge307XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGZvcm1GaWVsZHNPcHRpb25zLCBcIm11dGF0aW9uc1wiKSAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmb3JtRmllbGRzT3B0aW9ucy5tdXRhdGlvbnMsIGZpZWxkTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRzID0gZm9ybUZpZWxkc09wdGlvbnMubXV0YXRpb25zW2ZpZWxkTmFtZV07IC8vb3B0aW9uIG11dGF0aW9uIGZvciBmaWVsZFxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICYmIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgb3B0cy52YWx1ZSA9IGRhdGFbZmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtW2ZpZWxkTmFtZV0gPSBmaWVsZEluaXQoZmllbGROYW1lLCBvcHRzLCBWQVJJQU5UUywgRklFTERTKTtcbiAgICAgICAgLy9pZiBmb3JtIHJlYWRvbmx5LCBtYXJraW5nIGV2ZXJ5IGZpZWxkIGFzIHJlYWRvbmx5XG4gICAgICAgIGlmIChmb3JtRmllbGRzT3B0aW9ucyAmJiBmb3JtRmllbGRzT3B0aW9ucy5yZWFkb25seSkge1xuICAgICAgICAgICAgZm9ybVtmaWVsZE5hbWVdLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiAgTWFya2luZyBmaWVsZCBhcyBpbnZhbGlkIGJ5IG93biB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgZmllbGROYW1lICAgICBuYW1lIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIHthbnl9ICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgIHZhbHVlIG9mIGZpZWxkXG4gKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgIGVycm9ycyAgICAgICAgbGlzdCBvZiBlcnJvcnNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpIHtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzID0gWy4uLmVycm9yc107XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGZvcm07XG59XG5cbi8qKlxuICogIE1hcmtpbmcgZmllbGQgYXMgdmFsaWQgYnkgb3duIHZhbGlkYXRvclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcGFyYW0ge2FueX0gICAgICAgICAgICAgIHZhbHVlICAgICAgICAgdmFsdWUgb2YgZmllbGRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIGZvcm1bZmllbGROYW1lXS5lcnJvcnMgPSBmYWxzZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsaWRhdGVkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsaWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgZm9yIChsZXQgZm5hbWUgaW4gZm9ybSkge1xuICAgICAgICBpZiAoZm5hbWUgIT09IGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZm9ybVtmbmFtZV0uZXJyb3JzKSAmJlxuICAgICAgICAgICAgICAgIGZvcm1bZm5hbWVdLmVycm9ycy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvcm1bZm5hbWVdLmVycm9ycyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1bZm5hbWVdLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgZmllbGQgaGFzIGVycm9yc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAtIHZhbGlkLCBmYWxzZSAtaW52YWxpZFxuICoqL1xuZnVuY3Rpb24gaXNGaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzKTtcbn1cblxuLyoqXG4gKiBGb3JtIGxldmVsIHZhbGlkYXRvciBlcnJvciBpbiB0aGlzIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgZXJyb3JzICAgICAgICBsaXN0IG9mIGVycm9yc1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICoqL1xuZnVuY3Rpb24gc2V0Rm9ybUZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIGVycm9ycykge1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtRXJyb3JzID0gWy4uLmVycm9yc107XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmlucHV0U3RhcnRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmZvcm1MZXZlbEVycm9yID0gdHJ1ZTtcbiAgICByZXR1cm4gZm9ybTtcbn1cbi8qKlxuICogRm9ybSBsZXZlbCB2YWxpZGF0b3Igc3VjY2VzcyBpbiB0aGlzIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSkge1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtRXJyb3JzID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZm9ybUxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGZpZWxkcyBhbmQgZm9ybSBlcnJvciBsYWJlbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzICAgICAgcmVzdWx0cyBvZiB2YWxpZGF0aW9uXG4gKiovXG5mdW5jdGlvbiB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyhcbiAgICB7XG4gICAgICAgIGZvcm0sXG4gICAgICAgIGZvcm1FcnJvcnMsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0dXMsXG4gICAgfSAvKiBGb3JtVmFsaWRhdGlvblNlc3Npb24uZ2V0Q29tcGxldGVSZXN1bHQoKSAqL1xuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5mb3JtKSAmJiB2YWxpZGF0aW9uU3RhdHVzLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoLCAuLi52YWxpZGF0aW9uU3RhdHVzLmZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRpb25TdGF0dXMuZmllbGRzKSB7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXSkgJiZcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUZpZWxkSW52YWxpZChcbiAgICAgICAgICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0RmllbGRzVmlzaWJpbGl0eShmb3JtLCBmaWVsZHNMaXN0LCB2YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHNMaXN0KSkge1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtKS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGZvcm1bZmllbGROYW1lXS52aXNpYmxlID0gZmllbGRzTGlzdC5pbmNsdWRlcyhmaWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgPyB2YWxcbiAgICAgICAgICAgICAgICA6ICF2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXRGaWVsZFZhbHVlKGZvcm0sIGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobm90Q29tbW9uLm9iakhhcyhmb3JtLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaWVsZElzVmlzaWJsZUFuZEZpbGxlZChmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBub3RDb21tb24ub2JqSGFzKGZvcm0sIGZpZWxkTmFtZSkgJiZcbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdLmVuYWJsZWQgJiZcbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdLnZpc2libGUgJiZcbiAgICAgICAgdHlwZW9mIGZvcm1bZmllbGROYW1lXS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3REYXRhKGZpZWxkcywgZm9ybSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmaWVsZHMuZmxhdCgpLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoZmllbGRJc1Zpc2libGVBbmRGaWxsZWQoZm9ybSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBmb3JtW2ZpZWxkTmFtZV0udmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZmllbGRJbml0LFxuICAgIGluaXRGb3JtQnlGaWVsZCxcbiAgICBzZXRGaWVsZEludmFsaWQsXG4gICAgc2V0RmllbGRWYWxpZCxcbiAgICBpc0ZpZWxkVmFsaWQsXG4gICAgc2V0Rm9ybUZpZWxkSW52YWxpZCxcbiAgICBzZXRGb3JtRmllbGRWYWxpZCxcbiAgICB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyxcbiAgICBmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCxcbiAgICBzZXRGaWVsZHNWaXNpYmlsaXR5LFxuICAgIHNldEZpZWxkVmFsdWUsXG4gICAgY29sbGVjdERhdGEsXG59O1xuIiwiY29uc3QgZW1wdHlGaWVsZHNSZXN1bHRzID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgYWNjW2N1cnJdID0gW107XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcblxuY29uc3QgRklFTERTID0gW1wiZmllbGRzXCIsIFwiZm9ybVwiXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICAjY2xlYW4gPSB0cnVlO1xuICAgICNyZXN1bHQ7XG5cbiAgICBjb25zdHJ1Y3RvcihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy4jcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy4jcmVzdWx0KS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghRklFTERTLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4jcmVzdWx0W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjbGVhbiA9IHRoaXMuI3Jlc3VsdC5mb3JtLmVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNnZXRGaWVsZHNMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpZWxkRGlydHkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiNyZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IGNsZWFuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2xlYW47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldERlZmF1bHRSZXN1bHQoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRzOiBlbXB0eUZpZWxkc1Jlc3VsdHMoZGF0YSksXG4gICAgICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBlbXB0eUZpZWxkc1Jlc3VsdHMoZGF0YSksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0UmVwb3J0KCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLiNnZXRDb21wbGV0ZVJlc3VsdCgpKSk7XG4gICAgfVxuXG4gICAgZ2V0RGV0YWlsZWRSZXBvcnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLiNyZXN1bHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0ZpZWxkRGlydHkoZmllbGROYW1lKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKSAmJlxuICAgICAgICAgICAgdGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICB0aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXS5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Q29tcGxldGVSZXN1bHRGb3JGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgY29uc3QgZmllbGRSZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgZmllbGRSZXN1bHQucHVzaCguLi50aGlzLiNyZXN1bHQuZmllbGRzW2ZpZWxkTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgZmllbGRSZXN1bHQucHVzaCguLi50aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkUmVzdWx0O1xuICAgIH1cblxuICAgICNnZXRDb21wbGV0ZVJlc3VsdCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0Q29tcGxldGUgPSB7XG4gICAgICAgICAgICBjbGVhbjogdGhpcy4jY2xlYW4sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICAgICAgZm9ybTogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNnZXRGaWVsZHNMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmdldENvbXBsZXRlUmVzdWx0Rm9yRmllbGQoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q29tcGxldGUuZmllbGRzW2ZpZWxkTmFtZV0gPSBlcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Q29tcGxldGUuZm9ybSA9IFsuLi50aGlzLiNyZXN1bHQuZm9ybS5lcnJvcnNdO1xuICAgICAgICBpZiAocmVzdWx0Q29tcGxldGUuZm9ybS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRDb21wbGV0ZS5mb3JtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRDb21wbGV0ZTtcbiAgICB9XG5cbiAgICAjZ2V0RmllbGRzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXModGhpcy4jcmVzdWx0LmZpZWxkcyk7XG4gICAgICAgIGNvbnN0IGZpZWxkc0luRm9ybSA9IE9iamVjdC5rZXlzKHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkcyk7XG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChbLi4uZmllbGRzSW5Gb3JtLCAuLi5maWVsZHNdKV07XG4gICAgfVxufTtcbiIsIi8qKlxuKlx0VGVtcGxhdGUgb2YgZXJyb3IuanNcbipcdEZvciBidWlsZGluZyBmb3Igc3BlY2lmaWMgZW52aXJvbm1lbnQuXG4qXHROb2RlLmpzIG9yIEJyb3dzZXJcbipcdEBwYXJhbSB7c3RyaW5nfVx0ZW52XHRub2RlfGJyb3dzZXIgaW4gd2ljaCBlbnYgaXQgd2lsbCBiZSBydW5uaW5nXG4qXHRAcGFyYW0ge3N0cmluZ31cdHVybFx0VVJMIG9mIHJlcG9ydCBjb2xsZWN0b3JcbipcdEBwYXJhbSB7c3RyaW5nfVx0a2V5XHRrZXkgdG8gaW5kZXRpZmljYXRlIHJlcG9ydGVyXG4qL1xuLyoqXG4qIEVycm9yIHJlcG9ydGluZyB3aXRoIGZlYXR1cmVzLCBzYXZpbmcgYnJvd3NlciBpbmZvLCB1cmkgYW5kIHNvIG9uLlxuKiBAbW9kdWxlIG5vdC1lcnJvci9lcnJvclxuKi9cbmNsYXNzIG5vdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zID0ge30sIGVycm9yID0gbnVsbCl7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmFkb3B0KGVycm9yKTtcblx0XHR0aGlzLmZpbGwoKTtcblx0XHR0aGlzLmdldFRpbWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQqXHRBZG9wdGluZyBuYXRpdmUgZXJyb3Igb2JqZWN0XG5cdCpcdEBwYXJhbSB7RXJyb3J9XHRlcnJvciBcdEVycm9yIG9iamVjdFxuXHQqXHRAcmV0dXJuIHtub3RFcnJvcn1cdFx0Y2hhaW5hYmxlXG5cdCovXG5cdGFkb3B0KGVycm9yKXtcblx0XHRpZihlcnJvciBpbnN0YW5jZW9mIEVycm9yKXtcblx0XHRcdHRoaXMucGFyZW50ID0gZXJyb3I7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Z2V0U3RhY2soKXtcblx0XHRpZih0aGlzLnBhcmVudCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuc3RhY2s7XG5cdFx0fWVsc2V7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFjaztcblx0XHR9XG5cdH1cblxuXHRnZXREZXRhaWxzKCl7XG5cdFx0bGV0IHNyYyA9IHRoaXM7XG5cdFx0aWYodGhpcy5wYXJlbnQpe1xuXHRcdFx0c3JjID0gdGhpcy5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRjb2x1bW5OdW1iZXI6ICAgIFx0c3JjLmNvbHVtbk51bWJlcixcblx0XHRcdGZpbGVOYW1lOiAgICAgICAgXHRzcmMuZmlsZU5hbWUsXG5cdFx0XHRsaW5lTnVtYmVyOiAgICAgIFx0c3JjLmxpbmVOdW1iZXIsXG5cdFx0XHRuYW1lOiAgICAgICAgICAgIFx0c3JjLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiAgICAgICAgXHRzcmMubWVzc2FnZSxcblx0XHRcdHN0YWNrOiAgICAgICAgICBcdHNyYy5zdGFja1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0Klx0VXBkYXRpbmcgdGhpcy5lbnYuZGF0ZSBwcm9wZXJ0eVxuXHQqXHRAcmV0dXJuICB7b2JqZWN0fVx0e3RpbWVzdGFtcCwgb2Zmc2V0fVxuXHQqL1xuXHRnZXRUaW1lKCl7XG5cdFx0bGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdHRoaXMuZW52LmRhdGUgPSB7XG5cdFx0XHR0aW1lc3RhbXAgOiBkYXRlLmdldFRpbWUoKSxcblx0XHRcdG9mZnNldDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5lbnYuZGF0ZTtcblx0fVxuXG5cblx0LyoqXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KioqXHROb2RlLmpzIFNlY3Rpb25cblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKi9cblxuXHQvKipcblx0Klx0RmlsdGVyaW5nIG91dCBrZXkgYnkgYHdoaXRlYCBsaXN0XG5cdCpcdEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgaGFzaCB0byBiZSBjb3BpZWQgYWNjb3JkaW5nIGZpbHRlciBgd2hpdGVgIGxpc3Rcblx0Klx0QHBhcmFtIHthcnJheX0gZmlsdGVyIGFycmF5IG9mIHN0aW5nLCB3aGljaCByZXByZXNlbnRzIGtleXMgd2Ugd2FudCB0byBiZVxuXHQqXHRcdFx0XHRcdFx0Y29waWVkIGluIHJlc3VsdGluZyBvYmplY3QgZnJvbSBzb3VyY2Vcblx0Klx0QHJldHVybiB7b2JqZWN0fVx0XHR3aGl0ZSBsaXN0ZWQgaGFzaFxuXHQqL1xuXHRmaWx0ZXJFbnYob2JqZWN0LCBmaWx0ZXIpe1xuXHRcdGxldCByZXN1bHQgPSB7fTtcblx0XHRmb3IobGV0IHQgb2YgZmlsdGVyKXtcblx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHQpKXtcblx0XHRcdFx0cmVzdWx0W3RdID0gb2JqZWN0W3RdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCpcdENvbGxlY3RpbmcgaW5mb3JtYXRpb24gc3BlY2lmaWMgZm9yIE5vZGUuanMgVjhcblx0Klx0QHJldHVybiB7bm90RXJyb3J9XHRcdGNoYWluYWJsZVxuXHQqL1xuXHRmaWxsKCl7XG5cdFx0LyoqXG5cdFx0Klx0WW91IHdhbnQgc29tZSBmaWVsZHMgZnJvbSBlbnYgYnV0IG5vdCBhbGwsIGNhdXNlIHRoZXJlIGFyZSBwYXNzd29yZHNcblx0XHQqXHRmcm9tIGRiLCBhcGkga2V5cyBhbmQgZXRjXG5cdFx0Ki9cblx0XHR0aGlzLmVudiA9IHtcblx0XHRcdGJyb3dzZXI6IFx0ZmFsc2UsXG5cdFx0XHRub2RlOiBcdFx0dHJ1ZSxcblx0XHRcdHZlcnNpb25zOiBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLnZlcnNpb25zKSxcblx0XHRcdHZhcnM6IFx0XHR0aGlzLmZpbHRlckVudihwcm9jZXNzLmVudiwgdGhpcy5vcHRpb25zLndoaXRlbGlzdCB8fCBbJ05PREVfRU5WJ10pXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdEVycm9yO1xuXG4iLCJcbmNvbnN0IG5vdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci5ub2RlLmNqcycpO1xuXG5cbi8vcmVwb3J0YWJsZVxuY2xhc3Mgbm90VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgbm90RXJyb3J7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpZWxkcyA9IHt9LCBlcnIgPSBudWxsLCBwYXJhbXMgPSB7fSl7XG4gICAgc3VwZXIobWVzc2FnZSwge2ZpZWxkcywgcGFyYW1zfSwgZXJyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAqIFNldHMgaGFzaCBvZiBmaWVsZHMgZXJyb3JzIG1lc3NhZ2VzIGZvciB1c2FnZSBpbiBmb3Jtc1xuICAqXHRAcmV0dXJuIHtPYmplY3R9XHRoYXNoIG9mIGZpZWxkLT5lcnJvcnMgW2tleTpzdHJpbmddOiBBcnJheTxzdHJpbmc+XG4gICoqL1xuICBzZXRGaWVsZHNFcnJvcnMobWVzc2FnZXMpe1xuICAgIHRoaXMub3B0aW9ucy5maWVsZHMgPSBtZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAqIFJldHVybnMgaGFzaCBvZiBlcnJvcnNcbiAgKlx0QHJldHVybiB7T2JqZWN0fVx0aGFzaCBvZiBmaWVsZC0+ZXJyb3JzIFtrZXk6c3RyaW5nXTogQXJyYXk8c3RyaW5nPlxuICAqKi9cbiAgZ2V0RmllbGRzRXJyb3JzKCl7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWVsZHM7XG4gIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gbm90VmFsaWRhdGlvbkVycm9yO1xuXG4iLCIvKipcbiAqIFRlc3QgYXJndW1lbnQgdHlwZSB0byBiZSAnZnVuY3Rpb24nXG4gKiBAcGFyYW0ge2FueX0gIGZ1bmMgICAgcG9zc2libGUgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICBpZiB0aGlzIGlzIGEgZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGlzRnVuYyA9IChmdW5jKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhcmd1bWVudCBpcyBBc3luYyBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgaWYgdGhpcyBmdW5jdGlvbiBpcyBjb25zdHJ1Y3RlZCBhcyBBc3luY0Z1bmN0aW9uXG4gKiovXG5jb25zdCBpc0FzeW5jID0gKGZ1bmMpID0+IHtcbiAgICByZXR1cm4gZnVuYy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jRnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHByb2MsIHBhcmFtcykgPT4ge1xuICAgIGlmIChpc0Z1bmMocHJvYykpIHtcbiAgICAgICAgaWYgKGlzQXN5bmMocHJvYykpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jKC4uLnBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvYyguLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImNvbnN0IFZhbGlkYXRpb25SZXN1bHQgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5jb25zdCBub3RWYWlsZGF0aW9uRXJyb3IgPSByZXF1aXJlKFwibm90LWVycm9yL3NyYy92YWxpZGF0aW9uLmVycm9yLm5vZGUuY2pzXCIpO1xuY29uc3QgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG5jb25zdCBWYWxpZGF0aW9uU2Vzc2lvbiA9IGFzeW5jICh2YWxpZGF0b3JzLCBkYXRhKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gVmFsaWRhdGlvblJlc3VsdC5nZXREZWZhdWx0UmVzdWx0KGRhdGEpO1xuICAgIGF3YWl0IHZhbGlkYXRlRmllbGRzKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pO1xuICAgIGF3YWl0IHZhbGlkYXRlRm9ybSh7IHZhbGlkYXRvcnMsIGRhdGEsIHJlc3VsdCB9KTtcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRpb25SZXN1bHQocmVzdWx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblNlc3Npb247XG5cbmNvbnN0IHZhbGlkYXRlRmllbGRzID0gYXN5bmMgKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pID0+IHtcbiAgICBmb3IgKGxldCB0IGluIGRhdGEpIHtcbiAgICAgICAgYXdhaXQgdmFsaWRhdGVGaWVsZCh0LCBkYXRhW3RdLCB2YWxpZGF0b3JzLCByZXN1bHQpO1xuICAgIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGROYW1lLCB2YWx1ZSwgdmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgY29uc3QgZmllbGRWYWxpZGF0b3JzID0gZ2V0RmllbGRWYWxpZGF0b3JzKGZpZWxkTmFtZSwgdmFsaWRhdG9ycyk7XG4gICAgcmV0dXJuIGF3YWl0IHJ1bkZpZWxkVmFsaWRhdG9ycyhmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFZhbGlkYXRvcnMsIHJlc3VsdCk7XG59O1xuXG5jb25zdCBnZXRGaWVsZFZhbGlkYXRvcnMgPSAobmFtZSwgdmFsaWRhdG9ycykgPT4ge1xuICAgIHJldHVybiB2YWxpZGF0b3JzICYmIHZhbGlkYXRvcnMuZmllbGRzICYmIHZhbGlkYXRvcnMuZmllbGRzW25hbWVdXG4gICAgICAgID8gdmFsaWRhdG9ycy5maWVsZHNbbmFtZV1cbiAgICAgICAgOiBbXTtcbn07XG5cbmNvbnN0IHJ1bkZpZWxkVmFsaWRhdG9ycyA9IGFzeW5jIChmaWVsZE5hbWUsIHZhbHVlLCB2YWxpZGF0b3JzLCByZXN1bHQpID0+IHtcbiAgICBmb3IgKGxldCB2YWxpZGF0b3JSdWxlIG9mIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gYXdhaXQgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvclJ1bGVbXCJ2YWxpZGF0b3JcIl0sXG4gICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzZXRGaWVsZEVycm9yKGZpZWxkTmFtZSwgdmFsaWRhdG9yUnVsZS5tZXNzYWdlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIG5vdFZhaWxkYXRpb25FcnJvciB8fCAhdmFsaWRhdG9yUnVsZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIHZhbGlkYXRvclJ1bGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHNldEZpZWxkRXJyb3IgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZUZvcm0gPSBhc3luYyAoeyB2YWxpZGF0b3JzLCBkYXRhLCByZXN1bHQgfSkgPT4ge1xuICAgIGNvbnN0IGZvcm1WYWxpZGF0b3JzID0gZ2V0Rm9ybVZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgYXdhaXQgcnVuRm9ybVZhbGlkYXRvcnMoZGF0YSwgZm9ybVZhbGlkYXRvcnMsIHJlc3VsdCk7XG59O1xuXG5jb25zdCBnZXRGb3JtVmFsaWRhdG9ycyA9ICh2YWxpZGF0b3JzKSA9PiB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnMgJiYgdmFsaWRhdG9ycy5mb3JtID8gdmFsaWRhdG9ycy5mb3JtIDogW107XG59O1xuXG5jb25zdCBydW5Gb3JtVmFsaWRhdG9ycyA9IGFzeW5jIChkYXRhLCBmb3JtVmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgdmFsaWRhdG9yIG9mIGZvcm1WYWxpZGF0b3JzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB2YWxpZGF0b3IoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmIHR5cGVvZiBlLmdldEZpZWxkc0Vycm9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IGUuZ2V0RmllbGRzRXJyb3JzKCk7XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShmb3JtRXJyb3JzLmZvcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1FcnJvcnMoZm9ybUVycm9ycy5mb3JtLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMuZmllbGRzICYmXG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1GaWVsZHNFcnJvcnMoZm9ybUVycm9ycy5maWVsZHMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRXJyb3JzID0gKGVycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgZXJyb3JzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFkZEZvcm1FcnJvcihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGFkZEZvcm1FcnJvciA9IChlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmZvcm0uZXJyb3JzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRzRXJyb3JzID0gKGZpZWxkc0Vycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgZmllbGROYW1lIGluIGZpZWxkc0Vycm9ycykge1xuICAgICAgICBhZGRGb3JtRmllbGRFcnJvcnMoZmllbGROYW1lLCBmaWVsZHNFcnJvcnNbZmllbGROYW1lXSwgcmVzdWx0KTtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRFcnJvcnMgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2VzLCByZXN1bHQpID0+IHtcbiAgICBlcnJvck1lc3NhZ2VzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFkZEZvcm1GaWVsZEVycm9yKGZpZWxkTmFtZSwgZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRFcnJvciA9IChmaWVsZE5hbWUsIGVycm9yTWVzc2FnZSwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICByZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0ucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgIH1cbn07XG4iLCJjb25zdCBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyA9IChkYXRhLCB2YWxpZGF0b3JzTGliKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRvcnNMaWIgJiYgdmFsaWRhdG9yc0xpYi5maWVsZHMpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRvcnNMaWIuZmllbGRzW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSB2YWxpZGF0b3JzTGliLmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcblxuY29uc3QgY29tcG9zZUZvcm1WYWxpZGF0b3JzID0gKG5hbWUsIHZhbGlkYXRvcnNMaWIpID0+IHtcbiAgICBpZiAoIXZhbGlkYXRvcnNMaWIpIHJldHVybiBbXTtcbiAgICBpZiAodmFsaWRhdG9yc0xpYi5mb3JtcyAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnNMaWIuZm9ybXNbbmFtZV0pKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzTGliLmZvcm1zW25hbWVdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzTGliLmZvcm0pKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzTGliLmZvcm07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXBvc2VGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGNvbXBvc2VGb3JtVmFsaWRhdG9ycyxcbn07XG4iLCJjb25zdCB7XG4gICAgY29tcG9zZUZpZWxkc1ZhbGlkYXRvcnMsXG4gICAgY29tcG9zZUZvcm1WYWxpZGF0b3JzLFxufSA9IHJlcXVpcmUoXCIuL3J1bm5lci51dGlscy5qc1wiKTtcblxuY29uc3QgVmFsaWRhdGlvblNlc3Npb24gPSByZXF1aXJlKFwiLi9zZXNzaW9uLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgdmFsaWRhdGlvbiBydW5uZXIgZnVuY3Rpb24gZnJvbSBwcm92aWRlZCB2YWxpZGF0aW9uIHJ1bGVzIGxpYlxuICogQHBhcmFtIHtvYmplY3R9ICAgICB2YWxpZGF0aW9uTGliIG9iamVjdCBjb250YWluaW5nIGZpZWxkcyB2YWxpZGF0aW9uIHJ1bGVzIGFuZCBmb3JtIHNwZWNpZmljIHJ1bGVzXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IChkYXRhOiBvYmplY3QsIGZvcm1OYW1lOiBzdHJpbmcpPT5Qcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+XG4gKiovXG5jb25zdCBWYWxpZGF0aW9uUnVubmVyID0gKHZhbGlkYXRvcnNMaWIpID0+IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0aW9uIHNlc3Npb24gcnVubmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgICAgICBvYmplY3QgdG8gdmFsaWRhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybU5hbWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiovXG4gICAgcmV0dXJuIChkYXRhLCBmb3JtTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0ge1xuICAgICAgICAgICAgLy9maWVsZHMgc3BlY2lmaWMgdmFsaWRhdG9yc1xuICAgICAgICAgICAgZmllbGRzOiBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyhkYXRhLCB2YWxpZGF0b3JzTGliKSxcbiAgICAgICAgICAgIC8vZm9ybSBzcGVjaWZpYyB2YWxpZGF0b3JzXG4gICAgICAgICAgICBmb3JtOiBjb21wb3NlRm9ybVZhbGlkYXRvcnMoZm9ybU5hbWUsIHZhbGlkYXRvcnNMaWIpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblNlc3Npb24odmFsaWRhdG9ycywgZGF0YSk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblJ1bm5lcjtcbiIsImNvbnN0IGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzID0gKGZpZWxkVmFsaWRhdG9ycywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuIGZpZWxkVmFsaWRhdG9ycy5tYXAoKGZpZWxkUnVsZSkgPT5cbiAgICAgICAgYXVnbWVudEZpZWxkVmFsaWRhdG9yKGZpZWxkUnVsZSwgZ2V0VmFsaWRhdG9yRW52KVxuICAgICk7XG59O1xuXG5jb25zdCBhdWdtZW50RmllbGRWYWxpZGF0b3IgPSAocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgaWYgKHJ1bGUudmFsaWRhdG9yICYmIHR5cGVvZiBydWxlLnZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVWYWxpZGF0b3IgPSBydWxlLnZhbGlkYXRvcjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLi4ucnVsZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC52YWxpZGF0b3I7XG4gICAgICAgIHJlc3VsdC52YWxpZGF0b3IgPSAodmFsKSA9PiBydWxlVmFsaWRhdG9yKHZhbCwgZ2V0VmFsaWRhdG9yRW52KCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmNvbnN0IGF1Z21lbnRGb3JtVmFsaWRhdG9ycyA9IChydWxlcywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuIHJ1bGVzLm1hcCgocnVsZSkgPT4gYXVnbWVudEZvcm1WYWxpZGF0b3IocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSk7XG59O1xuXG5jb25zdCBhdWdtZW50Rm9ybVZhbGlkYXRvciA9IChydWxlLCBnZXRWYWxpZGF0b3JFbnYpID0+IHtcbiAgICByZXR1cm4gKHZhbCkgPT4gcnVsZSh2YWwsIGdldFZhbGlkYXRvckVudigpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGF1Z21lbnRGaWVsZFZhbGlkYXRvcixcbiAgICBhdWdtZW50Rm9ybVZhbGlkYXRvcnMsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3IsXG59O1xuIiwiY29uc3Qgb2JqSGFzID0gKG9iaiwgbmFtZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBuYW1lKTtcbn07XG5jb25zdCB7XG4gICAgYXVnbWVudEZpZWxkc1ZhbGlkYXRvcnMsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3JzLFxufSA9IHJlcXVpcmUoXCIuL2J1aWxkZXIudXRpbHNcIik7XG5cbi8qKlxuICogQHR5cGVkZWYgICB7b2JqZWN0fSAgICBub3RWYWxpZGF0aW9uU2NoZW1hXG4gKiBAcHJvcGVydHkgIHtvYmplY3R9ICAgIFtmaWVsZHNdXG4gKiBAcHJvcGVydHkgIHthcnJheX0gICAgIFtmb3JtXVxuICogQHByb3BlcnR5ICB7b2JqZWN0fSAgICBbZm9ybXNdXG4gKi9cblxuLyoqXG4gKiByZXR1cm5zIHZhbGlkIGVtcHR5IHZhbGlkYXRpb24gc2NoZW1lXG4gKlxuICogQHJldHVybiB7bm90VmFsaWRhdGlvblNjaGVtYX1cbiAqL1xuY29uc3QgZW1wdHlTY2hlbWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgZm9ybXM6IHt9LFxuICAgIH07XG59O1xuLyoqXG4gKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWxpZGF0b3JzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRWYWxpZGF0b3JFbnZcbiAqIEByZXR1cm4ge25vdFZhbGlkYXRpb25TY2hlbWF9XG4gKi9cbmNvbnN0IHZhbGlkYXRpb25CdWlsZGVyID0gKHZhbGlkYXRvcnMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9ycyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWxpZGF0b3JzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVNjaGVtZSgpO1xuICAgIH1cbiAgICBjb25zdCBhdWdtZW50ZWQgPSB7fTtcbiAgICBpZiAob2JqSGFzKHZhbGlkYXRvcnMsIFwiZmllbGRzXCIpKSB7XG4gICAgICAgIGF1Z21lbnRlZC5maWVsZHMgPSB0cmFuc2Zvcm1GaWVsZHNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgdmFsaWRhdG9ycy5maWVsZHMsXG4gICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9iakhhcyh2YWxpZGF0b3JzLCBcImZvcm1zXCIpKSB7XG4gICAgICAgIGF1Z21lbnRlZC5mb3JtcyA9IHRyYW5zZm9ybUZvcm1zVmFsaWRhdG9ycyhcbiAgICAgICAgICAgIHZhbGlkYXRvcnMuZm9ybXMsXG4gICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2JqSGFzKHZhbGlkYXRvcnMsIFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgYXVnbWVudGVkLmZvcm0gPSBhdWdtZW50Rm9ybVZhbGlkYXRvcnMoXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5mb3JtLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0aW9uQnVpbGRlcjtcblxuY29uc3QgdHJhbnNmb3JtRmllbGRzVmFsaWRhdG9ycyA9IChmaWVsZHMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGNvbnN0IGF1Z21lbnRlZCA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICBhdWdtZW50ZWRbZmllbGROYW1lXSA9IGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcblxuY29uc3QgdHJhbnNmb3JtRm9ybXNWYWxpZGF0b3JzID0gKGZvcm1zVmFsaWRhdG9ycywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgY29uc3QgYXVnbWVudGVkID0ge307XG4gICAgZm9yIChsZXQgZm9ybU5hbWUgaW4gZm9ybXNWYWxpZGF0b3JzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1zVmFsaWRhdG9yc1tmb3JtTmFtZV0pKSB7XG4gICAgICAgICAgICBhdWdtZW50ZWRbZm9ybU5hbWVdID0gYXVnbWVudEZvcm1WYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIGZvcm1zVmFsaWRhdG9yc1tmb3JtTmFtZV0sXG4gICAgICAgICAgICAgICAgZ2V0VmFsaWRhdG9yRW52XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdWdtZW50ZWQ7XG59O1xuIiwiY29uc3QgU2Vzc2lvbiA9IHJlcXVpcmUoXCIuL3Nlc3Npb25cIik7XG5jb25zdCBSdW5uZXIgPSByZXF1aXJlKFwiLi9ydW5uZXJcIik7XG5jb25zdCBCdWlsZGVyID0gcmVxdWlyZShcIi4vYnVpbGRlclwiKTtcbmNvbnN0IFJlc3VsdCA9IHJlcXVpcmUoXCIuL3Jlc3VsdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmFtZTogXCJub3QtdmFsaWRhdGlvblwiLFxuICAgIFNlc3Npb24sXG4gICAgUnVubmVyLFxuICAgIEJ1aWxkZXIsXG4gICAgUmVzdWx0LFxufTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2lucHV0L3VpLmxhYmVsLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xhYmVsXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtob3Jpem9udGFsXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY29udHJvbHNdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uLy4uL2VsZW1lbnRzL2V2ZW50cy50eXBlcycpLlVJRXZlbnRJbnB1dENoYW5nZUNhbGxiYWNrfSBvbmNoYW5nZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlc10gLSBmaWVsZCBzdHlsZSBtb2RpZmljYXRpb25cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNdIC0gLy9hZGRvbnNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNDZW50ZXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNSaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cGVkXSAtIC8vZ3JvdXAgZmxhZ1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRNdWx0aWxpbmVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXBlZFJpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRDZW50ZXJlZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgbGFiZWwgPSBcIlwiLFxuICAgICAgICBuYW1lID0gXCJnZW5lcmljIGZpZWxkXCIsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGhvcml6b250YWwgPSBmYWxzZSxcbiAgICAgICAgY29udHJvbHMgPSBbXSxcbiAgICAgICAgY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGFkZG9ucyA9IGZhbHNlLFxuICAgICAgICBhZGRvbnNDZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICBhZGRvbnNSaWdodCA9IGZhbHNlLFxuICAgICAgICBncm91cGVkID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRNdWx0aWxpbmUgPSBmYWxzZSxcbiAgICAgICAgZ3JvdXBlZFJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRDZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIGZvcm1GaWVsZFByZWZpeCA9IFwiZm9ybS1maWVsZC1cIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgZmllbGRDbGFzc2VzID0gJHN0YXRlKFwiXCIpO1xuICAgIGxldCBoaWRkZW4gPSAkc3RhdGUoZmFsc2UpO1xuICAgIGxldCBmaWVsZElkID0gJHN0YXRlKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IFwiIFwiICsgY2xhc3NlcztcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9ucyA/IFwiIGhhcy1hZGRvbnMgXCIgOiBcIlwiO1xuICAgICAgICBmaWVsZENsYXNzZXMgKz0gYWRkb25zQ2VudGVyZWQgPyBcIiBoYXMtYWRkb25zLWNlbnRlcmVkIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9uc1JpZ2h0ID8gXCIgaGFzLWFkZG9ucy1yaWdodCBcIiA6IFwiXCI7XG5cbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWQgPyBcIiBpcy1ncm91cGVkIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWRNdWx0aWxpbmUgPyBcIiBpcy1ncm91cGVkLW11bHRpbGluZSBcIiA6IFwiXCI7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBncm91cGVkUmlnaHQgPyBcIiBpcy1ncm91cGVkLXJpZ2h0IFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWRDZW50ZXJlZCA/IFwiIGlzLWdyb3VwZWQtY2VudGVyZWQgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICAgICAgY29udHJvbHMuZm9yRWFjaCgoY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm90SGlkZGVuID0gY29udHJvbHMuZmlsdGVyKFxuICAgICAgICAgICAgKGNvbnRyb2wpID0+IGNvbnRyb2wuY29tcG9uZW50ICE9PSBcIlVJSGlkZGVuXCJcbiAgICAgICAgKTtcbiAgICAgICAgaGlkZGVuID0gbm90SGlkZGVuLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgbGV0IHRtcCA9IGNvbnRyb2xzLm1hcCgoaXRtKSA9PiBpdG0uY29tcG9uZW50KS5qb2luKFwiX1wiKTtcbiAgICAgICAgZmllbGRJZCA9IGAke2Zvcm1GaWVsZFByZWZpeH0ke3RtcH0tJHtuYW1lfWA7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBoaWRkZW59XG4gICAgeyNlYWNoIGNvbnRyb2xzIGFzIGNvbnRyb2x9XG4gICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoY29udHJvbC5jb21wb25lbnQpfVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50IHsuLi5jb250cm9sfSB7b25jaGFuZ2V9IGZpZWxkbmFtZT17bmFtZX0gLz5cbiAgICB7L2VhY2h9XG57OmVsc2UgaWYgaG9yaXpvbnRhbH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtaG9yaXpvbnRhbCB7ZmllbGRDbGFzc2VzfSB7ZmllbGRJZH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkLWxhYmVsIGlzLW5vcm1hbFwiPlxuICAgICAgICAgICAgPFVJTGFiZWwgZm9yPXtmaWVsZElkfSBsYWJlbD17bGFiZWwgfHwgY29udHJvbHNbMF0ubGFiZWx9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQtYm9keVwiIGlkPXtmaWVsZElkfT5cbiAgICAgICAgICAgIHsjZWFjaCBjb250cm9scyBhcyBjb250cm9sfVxuICAgICAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50XzEgPSBDT01QT05FTlRTLmdldChjb250cm9sLmNvbXBvbmVudCl9XG4gICAgICAgICAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudF8xIHsuLi5jb250cm9sfSB7b25jaGFuZ2V9IGZpZWxkbmFtZT17bmFtZX0gLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG57OmVsc2V9XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkIHtmaWVsZENsYXNzZXN9IHtmaWVsZElkfVwiPlxuICAgICAgICB7I2VhY2ggY29udHJvbHMgYXMgY29udHJvbH1cbiAgICAgICAgICAgIDxVSUxhYmVsXG4gICAgICAgICAgICAgICAgZm9yPVwiZm9ybS1maWVsZC17Y29udHJvbC5jb21wb25lbnR9LXtuYW1lfVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e2NvbnRyb2wubGFiZWx9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnRfMiA9IENPTVBPTkVOVFMuZ2V0KGNvbnRyb2wuY29tcG9uZW50KX1cbiAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnRfMiB7Li4uY29udHJvbH0ge29uY2hhbmdlfSBmaWVsZG5hbWU9e25hbWV9IC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXBhZ2Vsb2FkZXJcIjtcbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vbG9jYWxlXCI7XG5cbiAgICBpbXBvcnQgVUlGaWVsZCBmcm9tIFwiLi9maWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgRm9ybUhlbHBlcnMgZnJvbSBcIi4vZm9ybS5oZWxwZXJzLmpzXCI7XG5cbiAgICAvL3ZhbGlkYXRpb24gc3RhdHVzXG4gICAgbGV0IGZvcm1FcnJvcnMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBmb3JtSGFzRXJyb3JzID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgZmllbGRzSGFzRXJyb3JzID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgc3VjY2VzcyA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgICAvL2lucHV0IGRhdGFcbiAgICAvL2Zvcm0gc3RydWN0dXJlIG9iamVjdFxuXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuXG4gICAgLy9maWVsZHMgbGlzdCBzdHJ1Y3R1cmVcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtmb3JtXSAtIHtcbltmaWVsZE5hbWU6IHN0cmluZ10gPT4gZGVzY3JpcHRpb246IG9iamVjdFxufVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddIC0gc3RhdGUgaWYgZm9ybSBsb2FkaW5nXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2FkZXJdIC0gcGFnZSAtIHdob2xlIHBhZ2VcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ZpZWxkc10gLSBlYWNoIGl0ZW0gaXMgYSByb3dcbmlmIGl0ZW0gaXMgYXJyYXksIHRoZW4gdGhlcmUgZmV3IGZpZWxkcyBpbiBhIHJvd1xuW1xuW25hbWUsIGFnZV0sXG5bZW1haWwsIHRlbGVwaG9uZV1cbmJpbyxcbmFncmVlZFxuXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbU1VDQ0VTU19URVhUXSAtIGZvcm0gcmVzdWx0IGxhYmVsc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbV0FJVElOR19URVhUXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdIC0gZm9ybSBsYWJlbHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1dHRvbnNGaXJzdF0gLSBpZiB5b3Ugd2FudCBidXR0b24gb24gdG9wXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaG9yaXpvbnRhbF0gLSBpZiBmb3JtIGZpZWxkcyBzaG91bGQgaGF2ZSBob3Jpem9udGFsIGxheW91dFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc3VibWl0XSAtIGJ1dHRvbnMgbGFiZWxzIGFuZCBhdmFpbGFiaWxpdHlcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2NhbmNlbF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZm9ybSA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIGxvYWRpbmcgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBsb2FkZXIgPSBcImNvbnRhaW5lclwiLFxuICAgICAgICBmaWVsZHMgPSBbXSxcbiAgICAgICAgU1VDQ0VTU19URVhUID0gXCLQntC/0LXRgNCw0YbQuNGPINC30LDQstC10YDRiNC10L3QsFwiLFxuICAgICAgICBXQUlUSU5HX1RFWFQgPSBcItCe0YLQv9GA0LDQstC60LAg0LTQsNC90L3Ri9GFINC90LAg0YHQtdGA0LLQtdGAXCIsXG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb24gPSBcIlwiLFxuICAgICAgICBidXR0b25zRmlyc3QgPSBmYWxzZSxcbiAgICAgICAgaG9yaXpvbnRhbCA9IGZhbHNlLFxuICAgICAgICBzdWJtaXQgPSB7XG4gICAgICAgICAgICBjYXB0aW9uOiBcItCe0YLQv9GA0LDQstC40YLRjFwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsID0ge1xuICAgICAgICAgICAgY2FwdGlvbjogXCLQndCw0LfQsNC0XCIsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBmb3JtSW52YWxpZCA9ICRkZXJpdmVkKGZvcm1IYXNFcnJvcnMgfHwgZmllbGRzSGFzRXJyb3JzKTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1IZWxwZXJzLmNvbGxlY3REYXRhKGZpZWxkcywgZm9ybSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEZpZWxkSW52YWxpZChmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpO1xuICAgICAgICBmaWVsZHNIYXNFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZFZhbGlkKGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRmllbGRWYWxpZChmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1IZWxwZXJzLmlzRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGb3JtRmllbGRJbnZhbGlkKGZpZWxkTmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIGZvcm0gPSBGb3JtSGVscGVycy5zZXRGb3JtRmllbGRJbnZhbGlkKGZvcm0sIGZpZWxkTmFtZSwgZXJyb3JzKTtcbiAgICAgICAgZGlzcGF0Y2goYGZpZWxkLmludmFsaWRgLCB7XG4gICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGb3JtRmllbGRWYWxpZChmaWVsZE5hbWUpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgIGRpc3BhdGNoKGBmaWVsZC52YWxpZGAsIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKFxuICAgICAgICB2YWxpZGF0aW9uU3RhdHVzIC8qIEZvcm1WYWxpZGF0aW9uU2Vzc2lvbi5nZXRDb21wbGV0ZVJlc3VsdCgpICovXG4gICAgKSB7XG4gICAgICAgIGZvcm1IYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgZmllbGRzSGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5mb3JtKSAmJlxuICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5mb3JtLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoLCAuLi52YWxpZGF0aW9uU3RhdHVzLmZvcm0pO1xuICAgICAgICAgICAgZm9ybUhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtRXJyb3JzLnNwbGljZSgwLCBmb3JtRXJyb3JzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybUVycm9ycyA9IGZvcm1FcnJvcnM7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICAgICAgZm9yIChsZXQgZmllbGROYW1lIG9mIE9iamVjdC5rZXlzKGZvcm0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZEludmFsaWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNIYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dTdWNjZXNzKCkge1xuICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNWaXNpYmlsaXR5KGZpZWxkc0xpc3QsIHZhbCkge1xuICAgICAgICBpZiAoRm9ybUhlbHBlcnMuc2V0RmllbGRzVmlzaWJpbGl0eShmb3JtLCBmaWVsZHNMaXN0LCB2YWwpKSB7XG4gICAgICAgICAgICBmb3JtID0gZm9ybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRWaXNpYmxlRmllbGRzKGZpZWxkc0xpc3QpIHtcbiAgICAgICAgc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0SW52aXNpYmxlRmllbGRzKGZpZWxkc0xpc3QpIHtcbiAgICAgICAgc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEZpZWxkVmFsdWUoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoRm9ybUhlbHBlcnMuc2V0RmllbGRWYWx1ZShmb3JtLCBmaWVsZE5hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgb25GaWVsZENoYW5nZSh7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGaWVsZChmaWVsZE5hbWUsIHByb3BzKSB7XG4gICAgICAgIGZvcm1bZmllbGROYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLmZvcm1bZmllbGROYW1lXSxcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtID0gZm9ybTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkZpZWxkQ2hhbmdlKGV2KSB7XG4gICAgICAgIGxldCBkYXRhID0gZXYuZGV0YWlsO1xuICAgICAgICBmb3JtW2RhdGEuZmllbGRdLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgZm9ybSA9IGZvcm07XG4gICAgICAgIGRpc3BhdGNoKFwiY2hhbmdlXCIsIGRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1Ym1pdEZvcm0oZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2goXCJzdWJtaXRcIiwgY29sbGVjdERhdGEoKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3RGb3JtKCkge1xuICAgICAgICBkaXNwYXRjaChcInJlamVjdFwiKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImZvcm0tY29udGFpbmVyXCI+XG4gICAgeyNpZiBsb2FkZXIgIT09IFwiaGlkZGVuXCJ9XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwie2xvYWRlciA9PT0gJ3BhZ2UnXG4gICAgICAgICAgICAgICAgPyAncGFnZWxvYWRlcidcbiAgICAgICAgICAgICAgICA6ICdjb250YWluZXJsb2FkZXInfSB7bG9hZGluZyA/ICdpcy1hY3RpdmUnIDogJyd9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPnskTE9DQUxFW1dBSVRJTkdfVEVYVF19PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBzdWNjZXNzfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uIGlzLXN1Y2Nlc3NcIj5cbiAgICAgICAgICAgIDxoMyBjbGFzcz1cImZvcm0tc3VjY2Vzcy1tZXNzYWdlXCI+eyRMT0NBTEVbU1VDQ0VTU19URVhUXX08L2gzPlxuICAgICAgICA8L2Rpdj5cbiAgICB7OmVsc2V9XG4gICAgICAgIHsjaWYgdGl0bGV9XG4gICAgICAgICAgICA8aDUgY2xhc3M9XCJ0aXRsZSBpcy01XCI+eyRMT0NBTEVbdGl0bGVdfTwvaDU+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8aDYgY2xhc3M9XCJzdWJ0aXRsZSBpcy02XCI+eyRMT0NBTEVbZGVzY3JpcHRpb25dfTwvaDY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgYnV0dG9uc0ZpcnN0fVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaXMtZ3JvdXBlZCBpcy1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgIHsjaWYgY2FuY2VsLmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIGlzLW91dGxpbmVkIHtjYW5jZWwuY2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17cmVqZWN0Rm9ybX0+eyRMT0NBTEVbY2FuY2VsLmNhcHRpb25dfTwvYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsjaWYgc3VibWl0LmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3N1Ym1pdEZvcm19XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Zm9ybUludmFsaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1wcmltYXJ5IGlzLWhvdmVyZWQge3N1Ym1pdC5jbGFzc2VzfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+eyRMT0NBTEVbc3VibWl0LmNhcHRpb25dfTwvYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsjaWYgZm9ybUVycm9ycy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlZGl0LWZvcm0tZXJyb3Igbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICB7Zm9ybUVycm9ycy5qb2luKFwiLCBcIil9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2lmfVxuXG4gICAgICAgIHsjZWFjaCBmaWVsZHMgYXMgZmllbGR9XG4gICAgICAgICAgICB7I2lmIEFycmF5LmlzQXJyYXkoZmllbGQpfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBmaWVsZCBhcyBzdWJmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtzdWJmaWVsZF0gJiYgZm9ybVtzdWJmaWVsZF0uY29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtzdWJmaWVsZF0udmlzaWJsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4ge2Zvcm1bc3ViZmllbGRdLmZpZWxkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2lzLScgKyBmb3JtW3N1YmZpZWxkXS5maWVsZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VUlGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzPXtbZm9ybVtzdWJmaWVsZF1dfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17b25GaWVsZENoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtzdWJmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aG9yaXpvbnRhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17Zm9ybVtzdWJmaWVsZF0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJmaWVsZCAne3N1YmZpZWxkfScgaXMgbm90IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHs6ZWxzZSBpZiBmb3JtW2ZpZWxkXSAmJiBmb3JtW2ZpZWxkXS5jb21wb25lbnR9XG4gICAgICAgICAgICAgICAgeyNpZiBmb3JtW2ZpZWxkXS52aXNpYmxlfVxuICAgICAgICAgICAgICAgICAgICA8VUlGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbHM9e1tmb3JtW2ZpZWxkXV19XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uRmllbGRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtob3Jpem9udGFsfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2Zvcm1bZmllbGRdLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbiBpcy1kYW5nZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgRmllbGQgJ3tmaWVsZH0nIGlzIG5vdCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG5cbiAgICAgICAgeyNpZiAhYnV0dG9uc0ZpcnN0fVxuICAgICAgICAgICAgeyNpZiBmb3JtRXJyb3JzLmxlbmd0aCA+IDB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVkaXQtZm9ybS1lcnJvciBub3RpZmljYXRpb24gaXMtZGFuZ2VyXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBmb3JtRXJyb3JzIGFzIGZvcm1FcnJvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW2Zvcm1FcnJvcl19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaXMtZ3JvdXBlZCBpcy1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgIHsjaWYgY2FuY2VsLmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIHtjYW5jZWwuY2xhc3NlcyA/IGNhbmNlbC5jbGFzc2VzIDogJyd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3JlamVjdEZvcm19PnskTE9DQUxFW2NhbmNlbC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7I2lmIHN1Ym1pdC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtzdWJtaXRGb3JtfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Zvcm1JbnZhbGlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBpcy1ob3ZlcmVkIHtzdWJtaXQuY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3VibWl0LmNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfVwiPnskTE9DQUxFW3N1Ym1pdC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIHsvaWZ9XG48L2Rpdj5cbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG5jb25zdCBERUZBVUxUX1JVTEVTID0ge1xuICAgIG5vdFJlYWRvbmx5KHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWRvbmx5OiAhdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWRvbmx5KHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWRvbmx5OiB2LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW5hYmxlKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiAhdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRpc2FibGUodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHYsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIG5vdEZvcm1SdWxlcyB7XG4gICAgc3RhdGljICNSVUxFUyA9IHsgLi4uREVGQVVMVF9SVUxFUyB9O1xuXG4gICAgc3RhdGljIGFkZChuYW1lLCBmdW5jKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyh0aGlzLiNSVUxFUywgbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuI1JVTEVTW25hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUobmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKHRoaXMuI1JVTEVTLCBuYW1lKSAmJlxuICAgICAgICAgICAgIU9iamVjdC5rZXlzKERFRkFVTFRfUlVMRVMpLmluY2x1ZGVzKG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuI1JVTEVTW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGV4ZWMocnVsZSwgbWFzdGVyLCBzbGF2ZXMsIHZhbHVlLCBmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNSVUxFU1tydWxlXSh2YWx1ZSwgbWFzdGVyLCBzbGF2ZXMsIGZvcm0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJub3QtdmFsaWRhdGlvblwiO1xuXG5pbXBvcnQgeyBWQVJJQU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbmltcG9ydCBMaWIgZnJvbSBcIi4uLy4uL2xpYi5tanNcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4uLy4uL2Jhc2VcIjtcblxuaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9jb21tb24uanNcIjtcbmltcG9ydCBGb3JtSGVscGVycyBmcm9tIFwiLi9mb3JtLmhlbHBlcnMuanNcIjtcbmltcG9ydCBVSUZvcm1Db21wb25lbnQgZnJvbSBcIi4vZm9ybS5zdmVsdGVcIjtcbmltcG9ydCBub3RGb3JtUnVsZXMgZnJvbSBcIi4vZm9ybS5ydWxlcy5qc1wiO1xuXG5pbXBvcnQgeyBERUZBVUxUX1NUQVRVU19TVUNDRVNTIH0gZnJvbSBcIi4uLy4uL2NvbnN0XCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCIuZm9ybVwiO1xuY29uc3QgREVGQVVMVF9BQ1RJT05fTkFNRSA9IFwiZGVmYXVsdFwiO1xuXG5jbGFzcyBub3RGb3JtIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgLy9VSSByZW5kZXJlciBjb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAjdWlDb21wb25lbnQgPSBudWxsO1xuICAgIC8vZm9ybSB2YWxpZGF0aW9uXG4gICAgI3ZhbGlkYXRpb25SdW5uZXIgPSBudWxsO1xuICAgIC8vdWkgY29tcG9uZW50XG4gICAgI2Zvcm0gPSBudWxsO1xuICAgIC8vbW9kZWwuYWN0aW9uXG4gICAgI2FjdGlvbiA9IERFRkFVTFRfQUNUSU9OX05BTUU7XG4gICAgLy9maWVsZHMgc2NoZW1hc1xuICAgICNmaWVsZHMgPSBuZXcgTGliKCk7IC8vZmllbGRzIG9mIFVJXG4gICAgLy92YXJpYW50cyBzZXRzIGZvciBzZWxlY3QgbWVudXMgYW5kIHNvIG9uXG4gICAgI3ZhcmlhbnRzID0gbnVsbDsgLy92YXJpYW50cyBmb3IgVUlcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgICAgbmFtZSA9IFwiRGVmYXVsdFwiLFxuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIHdvcmtpbmcgPSB7fSxcbiAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICB1aSA9IFVJRm9ybUNvbXBvbmVudCwgLy9kZWZhdWx0IFVJXG4gICAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7bmFtZX1Gb3JtYCxcbiAgICAgICAgICAgICAgICAuLi53b3JraW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdmFyaWFudHMgPSBuZXcgTGliKFZBUklBTlRTLmdldENvbnRlbnQoKSk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VpQ29tcG9uZW50ID0gdWk7XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKG9wdGlvbnMsIFwiYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB0aGlzLiNhY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRGb3JtKCk7XG4gICAgfVxuXG4gICAgaW5pdEZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvSW5pdFwiLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5pbml0TGlicygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvUmVuZGVyXCIsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRVSSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdExpYnMoKSB7XG4gICAgICAgIHRoaXMuaW5pdEZpZWxkcygpO1xuICAgICAgICB0aGlzLmluaXRWYXJpYW50cygpO1xuICAgICAgICB0aGlzLmluaXRWYWxpZGF0b3IoKTtcbiAgICB9XG5cbiAgICByZUluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdExpYnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIGluaXRGaWVsZHMoKSB7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gdGhpcy5nZXRGb3JtTWFuaWZlc3QoKTtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXMobWFuaWZlc3QsIFwiZmllbGRzXCIpICYmIHRoaXMuI2ZpZWxkcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZpZWxkcy5pbXBvcnQobWFuaWZlc3QuZmllbGRzKTsgLy9hbGwgZmllbGRzIGF2YWlsYWJsZSBpbiBtb2RlbCBtYW5pZmVzdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFZhcmlhbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidmFyaWFudHNcIikpIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhcmlhbnRzLmltcG9ydCh0aGlzLmdldE9wdGlvbnMoXCJ2YXJpYW50c1wiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NyZWF0aW5nIHZhbGlkYXRvcnMgcnVubmVyIGZvciB0aGlzIHNwZWNpZmljIGZvcm1cbiAgICBpbml0VmFsaWRhdG9yKCkge1xuICAgICAgICB0aGlzLiN2YWxpZGF0aW9uUnVubmVyID0gUnVubmVyKHRoaXMuZ2V0Rm9ybVZhbGlkYXRvcnMoKSk7XG4gICAgfVxuXG4gICAgaW5pdFVJKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLiNnZXRGb3JtUHJvcHMoe1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0OiB0aGlzLmdldEZvcm1NYW5pZmVzdCgpLFxuICAgICAgICAgICAgICAgIGZvcm1PcHRpb25zOiB0aGlzLmdldEZvcm1PcHRpb25zKCksXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRGb3JtRGF0YSgpLFxuICAgICAgICAgICAgICAgIGluamVjdGVkUHJvcHM6IHRoaXMuZ2V0Rm9ybUluamVjdGVkUHJvcHMoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRGb3JtVGFyZ2V0RWwoKTtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtID0gbmV3IHRoaXMuI3VpQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI2JpbmRVSUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm0oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVVJKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLiNnZXRGb3JtUHJvcHMoe1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0OiB0aGlzLmdldEZvcm1NYW5pZmVzdCgpLFxuICAgICAgICAgICAgICAgIGZvcm1PcHRpb25zOiB0aGlzLmdldEZvcm1PcHRpb25zKCksXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRGb3JtRGF0YSgpLFxuICAgICAgICAgICAgICAgIGluamVjdGVkUHJvcHM6IHRoaXMuZ2V0Rm9ybUluamVjdGVkUHJvcHMoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jZm9ybS4kc2V0KHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVGb3JtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAjYmluZFVJRXZlbnRzKCkge1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcImNoYW5nZVwiLCAoKSA9PiB0aGlzLnZhbGlkYXRlRm9ybSgpKTtcbiAgICAgICAgdGhpcy4jZm9ybS4kb24oXCJjaGFuZ2VcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgZXYuZGV0YWlsKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChgY2hhbmdlLiR7ZXYuZGV0YWlsLmZpZWxkfWAsIGV2LmRldGFpbC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcInN1Ym1pdFwiLCAoZXYpID0+IHRoaXMuc3VibWl0KGV2LmRldGFpbCkpO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcInJlamVjdFwiLCAoKSA9PiB0aGlzLnJlamVjdCgpKTtcbiAgICAgICAgdGhpcy4jZm9ybS4kb24oXCJlcnJvclwiLCAoeyBkZXRhaWwgfSkgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZGV0YWlsKSk7XG4gICAgICAgIHRoaXMuI2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cygpO1xuICAgIH1cblxuICAgICNiaW5kTWFzdGVyU2xhdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IG1hc3RlcnMgPSB0aGlzLmdldE9wdGlvbnMoXCJtYXN0ZXJzXCIsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFtYXN0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbWFzdGVyIGluIG1hc3RlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gbWFzdGVyc1ttYXN0ZXJdO1xuICAgICAgICAgICAgZm9yIChsZXQgcnVsZU5hbWUgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlU2xhdmVzID0gcnVsZXNbcnVsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2FkZE1hc3RlclNsYXZlRXZlbnRzKHJ1bGVOYW1lLCBtYXN0ZXIsIHJ1bGVTbGF2ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgI2FkZE1hc3RlclNsYXZlRXZlbnRzKHJ1bGUsIG1hc3Rlciwgc2xhdmVzID0gW10pIHtcbiAgICAgICAgdGhpcy5vbihgY2hhbmdlLiR7bWFzdGVyfWAsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZXhlY1NsYXZlUnVsZShydWxlLCBtYXN0ZXIsIHNsYXZlcywgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KGBjaGFuZ2UuJHttYXN0ZXJ9YCwgdGhpcy5nZXRGb3JtRGF0YSgpW21hc3Rlcl0pO1xuICAgIH1cblxuICAgICNleGVjU2xhdmVSdWxlKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbWQgPSBub3RGb3JtUnVsZXMuZXhlYyhydWxlLCBtYXN0ZXIsIHNsYXZlcywgdmFsdWUsIHRoaXMpO1xuICAgICAgICBzbGF2ZXMuZm9yRWFjaCgoc2xhdmVGaWVsZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaWVsZChzbGF2ZUZpZWxkLCBjbWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJyZWFkb25seVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuI3ZhbGlkYXRpb25SdW5uZXIoXG4gICAgICAgICAgICAgICAgdGhpcy4jZm9ybS5jb2xsZWN0RGF0YSgpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9ybUFjdGlvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy4jZm9ybS51cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyh2YWxpZGF0aW9uUmVzdWx0LmdldFJlcG9ydCgpKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5jbGVhbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHZhbGlkYXRpb25SZXN1bHQuZ2V0UmVwb3J0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSB7XG4gICAgICAgICAgICAgICAgZm9ybTogW1VJQ29tbW9uLkVSUk9SX0RFRkFVTFQsIGUubWVzc2FnZV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy4jZm9ybSAmJiB0aGlzLiNmb3JtLnVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKHJlcG9ydCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCByZXBvcnQpO1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1Ym1pdChkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInN1Ym1pdFwiLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInJlamVjdFwiKTtcbiAgICB9XG5cbiAgICAvL2JpbmRpbmcgZXZlbnQgdG8gYWN0dWFsIFVJXG4gICAgJG9uKCkge1xuICAgICAgICBpZiAodGhpcy4jZm9ybSkge1xuICAgICAgICAgICAgdGhpcy4jZm9ybS4kb24oLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMuI2Zvcm0uc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG9hZGVkXCIpO1xuICAgICAgICB0aGlzLiNmb3JtLnJlc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgICAgIGlmICh0aGlzLiNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLiRkZXN0cm95ICYmIHRoaXMuI2Zvcm0uJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0uZGVzdHJveSAmJiB0aGlzLiNmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3ZhbGlkYXRpb25SdW5uZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLiNmaWVsZHMgPSBudWxsO1xuICAgICAgICB0aGlzLiN2YXJpYW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgfVxuXG4gICAgI2dldEZvcm1Qcm9wcyh7XG4gICAgICAgIG1hbmlmZXN0LCAvL21vZGVsIG1hbmlmZXN0XG4gICAgICAgIGZvcm1PcHRpb25zID0ge1xuICAgICAgICAgICAgdWk6IHt9LFxuICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgfSwgLy9zb21lIG9wdGlvbnNcbiAgICAgICAgZGF0YSA9IG51bGwsIC8vaW5pdGlhbCBkYXRhIGZvciBmb3JtXG4gICAgICAgIGluamVjdGVkUHJvcHMgPSB7fSxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuI2FjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtT3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBmb3JtT3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdWk6IHt9LFxuICAgICAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybSA9IEZvcm1IZWxwZXJzLmluaXRGb3JtQnlGaWVsZChcbiAgICAgICAgICAgIC8vZm9ybSBzZWVkIG9iamVjdFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAvKlxuICAgICAgRm9ybSBzdHJ1Y3R1cmVcbiAgICAgIFtcbiAgICAgICAgLy9lYWNoIGl0ZW0gaXMgbGluZSBvZiBmb3JtXG4gICAgICAgIC8vZmllbGQgLSBmaWVsZCB0YWtlcyB3aG9sZSBsaW5lIG9mIGZvcm1cbiAgICAgICAgLy9bZmllbGQxLCBmaWVsZDJdIC0gZmV3IGZpZWxkcyBpbiBvbmUgbGluZVxuICAgICAgICBuYW1lRmlyc3QsIG5hbWVMYXN0XG4gICAgICAgIFthZ2UsIGNvdW50cnksIGxhbmd1YWdlXSxcbiAgICAgICAgW2VtYWlsLCB0ZWxlcGhvbmVdXG4gICAgICBdXG4gICAgICAqL1xuICAgICAgICAgICAgbWFuaWZlc3QuYWN0aW9uc1thY3Rpb25dLmZpZWxkcywgLy9mb3JtIGZpZWxkcyBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHRoaXMuI3ZhcmlhbnRzLCAvL3ZhcmlhbnRzIGxpYnJhcnlcbiAgICAgICAgICAgIHRoaXMuI2ZpZWxkcywgLy9maWVsZHMgbGlicmFyeVxuICAgICAgICAgICAgZm9ybU9wdGlvbnMuZmllbGRzLCAvL2Zvcm0gd2lkZSBmaWVsZHMgb3B0aW9uc1xuICAgICAgICAgICAgZGF0YVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvL2lmIG5vIGF1dG8gaW5pdCBvZiBmb3JtIHN0cnVjdHVyZSwgc2V0IHRvIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIGxvYWRpbmc6ICF0aGlzLmdldE9wdGlvbnMoXCJhdXRvSW5pdFwiLCB0cnVlKSxcbiAgICAgICAgICAgIHRpdGxlOiBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0udGl0bGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbWFuaWZlc3QuYWN0aW9uc1thY3Rpb25dLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZmllbGRzOiBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0uZmllbGRzLFxuICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgIC8vaW5qZWN0aW5nIG9wdGlvbnMgdG8gVUkgZnJvbSB0b3AgbGV2ZWwgaW5wdXRcbiAgICAgICAgICAgIC4uLmZvcm1PcHRpb25zLnVpLCAvL2Zvcm0gVUkgb3B0aW9uc1xuICAgICAgICAgICAgLi4uaW5qZWN0ZWRQcm9wcyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKTtcbiAgICB9XG5cbiAgICBnZXRGb3JtQWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWN0aW9uO1xuICAgIH1cblxuICAgIHNldEZvcm1BY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgJiYgdmFsICE9PSB0aGlzLiNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuI2FjdGlvbiA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gJiYgdGhpcy4jZm9ybS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbml0Rm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc1Jlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9ybVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtRXJyb3JzKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgIEZvcm0gdmFsaWRhdGlvbiByZXN1bHRcbiAgICAgKiovXG4gICAgc2V0Rm9ybVN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuI2Zvcm0uc2hvd1N1Y2Nlc3MoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtRXJyb3JzKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwicmVhZG9ubHlcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgZm9ybTogW10sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN0YXR1cy5mb3JtLnB1c2gocmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmIE9iamVjdC5rZXlzKHJlc3VsdC5lcnJvcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXR1cy5maWVsZHMgPSB7IC4uLnJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmb3JtLnVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YXJpYW50IGJ5IGNvbGxlY3Rpb24gbmFtZSBhbmQgaXRlbSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgIG5hbWUgIG5hbWUgb2YgdGhlIHZhcmlhbnRzIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9ICBpZCAgICBpdGVtIGlkZW50aWZpY2F0b3JcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICAgICAgICAgICBpdGVtXG4gICAgICoqL1xuICAgIGdldFZhcmlhbnQobmFtZSwgaWQpIHtcbiAgICAgICAgbGV0IGxpYiA9IHRoaXMuI3ZhcmlhbnRzLmdldChuYW1lKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGxpYi5maW5kKChpdGVtKSA9PiBpdGVtLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqKlxuICAgICAqIFJlZGVmaW5hYmxlIGdldHRlcnNcbiAgICAgKiovXG5cbiAgICBnZXRGb3JtVGFyZ2V0RWwoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5nZXRPcHRpb25zKFwidGFyZ2V0XCIsIERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SKTtcbiAgICAgICAgaWYgKHRhcmdldEVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRFbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0RWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldEVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvcm0gcGFyZW50IGVsZW1lbnQgaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtVmFsaWRhdG9ycygpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInZhbGlkYXRvcnNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJ2YWxpZGF0b3JzXCIsIHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI21pc3NpbmdPdmVycmlkZVdhcm5pbmcoXCJ2YWxpZGF0b3JzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rm9ybU1hbmlmZXN0KCkge1xuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLmdldE1vZGVsTmFtZSgpO1xuICAgICAgICBpZiAobW9kZWxOYW1lICYmIG5vdENvbW1vbi5nZXRBcHAoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRJbnRlcmZhY2VNYW5pZmVzdChtb2RlbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFwiLCB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibWFuaWZlc3RcIiwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcIm1hbmlmZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rm9ybURhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldERhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcImRhdGFcIik7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtT3B0aW9ucygpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwidWlcIiwgdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwiZmllbGRzXCIsIHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVpOiB0aGlzLmdldE9wdGlvbnMoXCJ1aVwiLCB7fSksXG4gICAgICAgICAgICAgICAgZmllbGRzOiB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwge30pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI21pc3NpbmdPdmVycmlkZVdhcm5pbmcoXCJvcHRpb25zXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1aToge30sXG4gICAgICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtSW5qZWN0ZWRQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImluamVjdGVkXCIsIHt9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBlbXB0eSBtZXNzYWdlXG4gICAgICoqL1xuICAgICNtaXNzaW5nT3ZlcnJpZGVXYXJuaW5nKG1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgIGAke21pc3Npbmd9IGZvciAke3RoaXMuZ2V0V29ya2luZyhcIm5hbWVcIil9IGZvcm0gaXMgbm90IGRlZmluZWRgXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybSBvcGVyYXRpb25zXG4gICAgICoqL1xuICAgIGNvbGxlY3REYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwicmVhZG9ubHlcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuI2Zvcm0uY29sbGVjdERhdGEoKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHsgLi4uZGF0YSB9KTsgLy91cGRhdGUgaW4gaW5uZXIgc3RvcmVcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdXBkYXRlRmllbGQoZmllbGROYW1lLCBwcm9wcykge1xuICAgICAgICB0aGlzLiNmb3JtLnVwZGF0ZUZpZWxkKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIGdldE1vZGVsKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmZhY2UobmFtZSkoZGF0YSB8fCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmZhY2UoKShuYW1lIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEludGVyZmFjZShuYW1lID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRJbnRlcmZhY2UobmFtZSB8fCB0aGlzLmdldE1vZGVsTmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBjdXJyZW50IG1vZGVsIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vZGVsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcIm1vZGVsXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Rm9ybTtcbiIsIjxzY3JpcHQ+XG5cbiAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGUnO1xuXG4gIGltcG9ydCB7XG4gICAgICBjcmVhdGVFdmVudERpc3BhdGNoZXIsXG4gICAgICBvbk1vdW50XG4gIH0gZnJvbSAnc3ZlbHRlJztcblxuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dNb2Rlc11cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RlXVxuICAgKiBAcHJvcGVydHkge2FueX0gW2Zvcm1zXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0LWZvcm0nLFxuICAgICAgc2hvd01vZGVzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJGJpbmRhYmxlKCdkZWZhdWx0JyksXG4gICAgICBmb3JtcyA9IFtdXG4gIH0gPSAkcHJvcHMoKTtcblxuICBmdW5jdGlvbiBzZXRNb2RlKHZhbCkge1xuICAgICAgbW9kZSA9IHZhbDtcbiAgICAgIGRpc3BhdGNoKCdtb2RlJywgdmFsKTtcbiAgICAgIHVwZGF0ZU1vZGVzQnV0dG9ucygpO1xuICB9XG5cbiAgbGV0IEZPUk1TX0JVVFRPTlMgPSAkc3RhdGUoW10pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1vZGVzQnV0dG9ucygpIHtcbiAgICAgIEZPUk1TX0JVVFRPTlMgPSBmb3Jtcy5maWx0ZXIoZm9ybSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChtb2RlICE9PSBmb3JtLm1vZGUpO1xuICAgICAgfSkubWFwKGZvcm0gPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRpdGxlOiBmb3JtLnRpdGxlLFxuICAgICAgICAgICAgICBvdXRsaW5lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzZXRNb2RlKGZvcm0ubW9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICAgIHVwZGF0ZU1vZGVzQnV0dG9ucygpO1xuICB9KTtcblxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJibG9jay1jb250YWluZXJcIiBpZD1cIntuYW1lfS1mb3JtLXNldFwiPlxuICA8ZGl2IGNsYXNzPVwiZm9ybS1wYXBlclwiICBpZD1cIntuYW1lfS1mb3JtLXNldC1jb250YWluZXJcIj48L2Rpdj5cbiAgeyNpZiBzaG93TW9kZXN9XG4gIDxVSUJ1dHRvbnMgY2VudGVyZWQ9e3RydWV9IGJpbmQ6dmFsdWVzPXtGT1JNU19CVVRUT05TfSBjbGFzc2VzPSdtdC00JyAvPlxuICB7L2lmfVxuPC9kaXY+XG4iLCJpbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vLi4vYmFzZVwiO1xuXG5pbXBvcnQgVUlGb3JtU2V0Q29tcG9uZW50IGZyb20gXCIuL2Zvcm0uc2V0LnN2ZWx0ZVwiO1xuaW1wb3J0IFVJRm9ybUNvbXBvbmVudCBmcm9tIFwiLi9mb3JtLnN2ZWx0ZVwiO1xuXG5jb25zdCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUiA9IFwiLmZvcm0tc2V0XCI7XG5jb25zdCBERUZBVUxUX0ZPUk1fU0VUX05BTUUgPSBcImZvcm0tc2V0XCI7XG5cbmNsYXNzIG5vdEZvcm1TZXQgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAjZm9ybVNldENvbXBvbmVudCA9IG51bGw7XG4gICAgI2Zvcm1Db21wb25lbnQgPSBudWxsO1xuXG4gICAgI2Zvcm0gPSBudWxsO1xuICAgICNmcmFtZSA9IG51bGw7XG5cbiAgICAvKlxuICBuZXcgbm90Rm9ybVNldCh7XG4gICAgb3B0aW9uczp7XG4gICAgICB0YXJnZXQ6IGVsLFxuICAgICAgZm9ybXM6IFt7XG4gICAgICAgIG1vZGU6ICdmb3JtMScsXG4gICAgICAgIHRpdGxlOiAnRm9ybSAxJyxcbiAgICAgICAgZm9ybTogZm9ybUNvbnN0cnVjdG9yMSAvL2N1c3RvbSBjb25zdHJ1Y3RvcnNcbiAgICAgIH0se1xuICAgICAgICBtb2RlOiAnZm9ybTInLFxuICAgICAgICB0aXRsZTogJ0Zvcm0gMicsXG4gICAgICAgIHByb3BzOiB7fSAgICAgICAgICAgICAvL3BhcmFtcyB0byBjcmVhdGUgbm90Rm9ybSBpbnN0YW5jZVxuICAgICAgfSx7XG4gICAgICAgIG1vZGU6ICdmb3JtMycsXG4gICAgICAgIHRpdGxlOiAnRm9ybSAzJyxcbiAgICAgICAgZm9ybTogZm9ybUNvbnN0cnVjdG9yMyAvL2N1c3RvbSBjb25zdHJ1Y3RvcnNcbiAgICAgIH1dXG4gICAgfVxuICB9KTtcbiAgKi9cblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgb3B0aW9ucyA9IHt9LFxuICAgICAgICBmb3JtQ29tcG9uZW50ID0gVUlGb3JtQ29tcG9uZW50LFxuICAgICAgICBmb3JtU2V0Q29tcG9uZW50ID0gVUlGb3JtU2V0Q29tcG9uZW50LFxuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IERFRkFVTFRfRk9STV9TRVRfTkFNRSxcbiAgICAgICAgICAgICAgICBtb2RlOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICBzaG93TW9kZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmb3JtQ29tcG9uZW50ID0gZm9ybUNvbXBvbmVudDtcbiAgICAgICAgdGhpcy4jZm9ybVNldENvbXBvbmVudCA9IGZvcm1TZXRDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuc2V0Rm9ybU1vZGUodGhpcy5nZXRPcHRpb25zKFwibW9kZVwiKSk7XG4gICAgICAgIHRoaXMuaW5pdFVJKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGFsaXppbmcgZm9ybSBmcmFtZSBtb2RlLCB3aXRoIHN3aXRjaGVycyBiZXR3ZWVuIG1vZGVzXG4gICAgICoqL1xuICAgIGluaXRVSSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRGcmFtZVRhcmdldEVsKCk7XG4gICAgICAgIHdoaWxlICh0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoKSB0YXJnZXQucmVtb3ZlQ2hpbGQodGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICB0aGlzLiNmcmFtZSA9IG5ldyB0aGlzLiNmb3JtU2V0Q29tcG9uZW50KHtcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BzOiB0aGlzLiNnZXRGcmFtZVByb3BzKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmcmFtZS4kb24oXCJtb2RlXCIsIChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtTW9kZShldi5kZXRhaWwpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvcm0oKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtTW9kZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTW9kZUV4aXN0cyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwibW9kZVwiLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVcIiwgdGhpcy5nZXRGaXJzdE1vZGUoKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1Nb2RlSW5VSSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlRm9ybU1vZGVJblVJKCkge1xuICAgICAgICBpZiAodGhpcy4jZnJhbWUgJiYgdGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jZnJhbWUuJHNldCh7IG1vZGU6IHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIikgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIik7XG4gICAgfVxuXG4gICAgdXBkYXRlRm9ybSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95Rm9ybSgpO1xuICAgICAgICBpZiAodGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJGb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJGb3JtKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuZ2V0Rm9ybVRhcmdldEVsKCk7XG4gICAgICAgIGNvbnN0IGZvcm1Db25maWcgPSB0aGlzLmdldEZvcm1Db25maWcoKTtcbiAgICAgICAgaWYgKCEodGFyZ2V0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBmb3JtQ29uZmlnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXJyb3Igd2hpbGUgZm9ybSByZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlTW9kZSA9IChtb2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1Nb2RlKG1vZGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmb3JtQ29uZmlnLmZvcm0pIHtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXRFbC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2hpbGQodGFyZ2V0RWwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtID0gbmV3IGZvcm1Db25maWcuZm9ybSh7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogeyB0YXJnZXQ6IHRhcmdldEVsLCBjaGFuZ2VNb2RlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtQ29uZmlnLnByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLiNmb3JtID0gbmV3IHRoaXMuI2Zvcm1Db21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0RWwsXG4gICAgICAgICAgICAgICAgLi4uZm9ybUNvbmZpZy5wcm9wcyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VNb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiZm9ybXNcIikuZmluZChcbiAgICAgICAgICAgIChmb3JtKSA9PiBmb3JtLm1vZGUgPT09IHRoaXMuZ2V0Rm9ybU1vZGUoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRlc3Ryb3lGb3JtKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJFbCA9IHRoaXMuZ2V0Rm9ybVRhcmdldEVsKCk7XG4gICAgICAgIGlmIChjb250YWluZXJFbCkge1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5lckVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbC5yZW1vdmVDaGlsZChjb250YWluZXJFbC5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNmb3JtICYmIHRoaXMuI2Zvcm0uJGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0uJGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmb3JtID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95RnJhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNmcmFtZSAmJiB0aGlzLiNmcmFtZS4kZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy4jZnJhbWUuJGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmcmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaXNNb2RlRXhpc3RzKG1vZGUpIHtcbiAgICAgICAgY29uc3QgZm9ybXMgPSB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiLCBbXSk7XG4gICAgICAgIHJldHVybiBmb3Jtcy5zb21lKChpdGVtKSA9PiBpdGVtLm1vZGUgPT09IG1vZGUpO1xuICAgIH1cblxuICAgIGdldEZpcnN0TW9kZSgpIHtcbiAgICAgICAgY29uc3QgZm9ybXMgPSB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiLCBbXSk7XG4gICAgICAgIGlmIChmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybXNbMF0ubW9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiNmb3JtU2V0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZm9ybUNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVzdHJveUZvcm0oKTtcbiAgICAgICAgdGhpcy5kZXN0cm95RnJhbWUoKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKG51bGwpO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhudWxsKTtcbiAgICB9XG5cbiAgICBnZXRGcmFtZVRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldE9wdGlvbnMoXCJ0YXJnZXRcIiwgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IpO1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm0gc2V0IHRhcmdldCBpcyBub3QgSFRNTEVsZW1lbnQgb3Igc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rm9ybVRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRPcHRpb25zKFwibmFtZVwiLCBERUZBVUxUX0ZPUk1fU0VUX05BTUUpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7bmFtZX0tZm9ybS1zZXQtY29udGFpbmVyYCk7XG4gICAgfVxuXG4gICAgI2dldEZyYW1lUHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaG93TW9kZXM6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dNb2Rlc1wiLCB0cnVlKSxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMuZ2V0Rm9ybU1vZGUoKSxcbiAgICAgICAgICAgIGZvcm1zOiB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiLCBbXSksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lXCIsIERFRkFVTFRfRk9STV9TRVRfTkFNRSksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RGb3JtU2V0O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vbG9jYWxlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ29dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHJvb3QgPSBcIlwiLCBpdGVtcyA9IFtdLCBnbyA9IG51bGwgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldikge1xuICAgICAgICBpZiAodHlwZW9mIGdvID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbyhldi5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaHJlZik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48bmF2IGNsYXNzPVwiYnJlYWRjcnVtYlwiIGFyaWEtbGFiZWw9XCJicmVhZGNydW1ic1wiPlxuICAgIDx1bD5cbiAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGxpbmssIGluZGV4fVxuICAgICAgICAgICAgeyNpZiBpdGVtcy5sZW5ndGggPT09IGluZGV4ICsgMX1cbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJpcy1hY3RpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCJ7cm9vdH17bGluay51cmx9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtaHJlZj17bGluay51cmx9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWN1cnJlbnQ9XCJwYWdlXCI+eyRMT0NBTEVbbGluay50aXRsZV19PC9hXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgezplbHNlIGlmIGxpbmsudXJsID09PSBmYWxzZX1cbiAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJpcy1wbGFpbi1jcnVtYlwiPnskTE9DQUxFW2xpbmsudGl0bGVdfTwvbGk+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIntyb290fXtsaW5rLnVybH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1ocmVmPXtsaW5rLnVybH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9PnskTE9DQUxFW2xpbmsudGl0bGVdfTwvYVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L3VsPlxuPC9uYXY+XG4iLCJpbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxubGV0IGxvY2FsX3VpX3Byb3BzID0gJHN0YXRlKHt9KTtcblxuY2xhc3Mgbm90QnJlYWRjcnVtYnMge1xuICAgIHN0YXRpYyBVSUNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICBzdGF0aWMgdWkgPSBudWxsO1xuICAgIHN0YXRpYyBoZWFkID0gW107XG4gICAgc3RhdGljIHRhaWwgPSBbXTtcblxuICAgIHN0YXRpYyBpbml0VUlQcm9wcyhyb290LCBuYXZpZ2F0ZSkge1xuICAgICAgICBsb2NhbF91aV9wcm9wcyA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmdldEJyZWFkY3J1bWJzKCksXG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgZ286IG5hdmlnYXRlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyByZW5kZXIoeyB0YXJnZXQsIHJvb3QgPSBcIlwiLCBuYXZpZ2F0ZSB9KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIGlmIChub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRVSVByb3BzKHJvb3QsIG5hdmlnYXRlKTtcbiAgICAgICAgICAgIHRoaXMudWkgPSBtb3VudChub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHByb3BzOiBsb2NhbF91aV9wcm9wcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRIZWFkKGhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkLnNwbGljZSgwLCB0aGlzLmhlYWQubGVuZ3RoLCAuLi5oZWFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFRhaWwodGFpbCkge1xuICAgICAgICB0aGlzLnRhaWwuc3BsaWNlKDAsIHRoaXMudGFpbC5sZW5ndGgsIC4uLnRhaWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QnJlYWRjcnVtYnMoKSB7XG4gICAgICAgIGxldCBjcnVtYnMgPSBbXTtcbiAgICAgICAgY3J1bWJzLnB1c2goLi4udGhpcy5oZWFkKTtcbiAgICAgICAgY3J1bWJzLnB1c2goLi4udGhpcy50YWlsKTtcbiAgICAgICAgcmV0dXJuIGNydW1icztcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy51aSkge1xuICAgICAgICAgICAgbG9jYWxfdWlfcHJvcHMuaXRlbXMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy51aSkge1xuICAgICAgICAgICAgdW1vdW50KHRoaXMudWkpO1xuICAgICAgICAgICAgdGhpcy51aSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RCcmVhZGNydW1icztcbiIsImltcG9ydCBVSUJyZWFkY3J1bWJzIGZyb20gXCIuL3VpLmJyZWFkY3J1bWJzLnN2ZWx0ZVwiO1xuaW1wb3J0IG5vdEJyZWFkY3J1bWJzIGZyb20gXCIuL2JyZWFkY3J1bWJzLnN2ZWx0ZS5qc1wiO1xuXG5ub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yID0gVUlCcmVhZGNydW1icztcblxuZXhwb3J0IGRlZmF1bHQgbm90QnJlYWRjcnVtYnM7XG4iLCJpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IHsgdW5tb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY2xhc3MgTWVudSB7XG4gICAgc3RhdGljIE1BWF9UT1VDSF9XSURUSCA9IDEwMjM7XG4gICAgc3RhdGljIElOVEVSVkFMX1VQREFURV9BQ1RJVkVfSVRFTSA9IDIwMDtcblxuICAgIHN0YXRpYyBERUZBVUxUID0ge1xuICAgICAgICBzZWN0aW9uOiBcImFueVwiLFxuICAgICAgICBzZWN0aW9uVGl0bGU6IFwi0JzQtdC90Y5cIixcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIC8vbGluaywgYnV0dG9uLCBkcm9wZG93biwgY29tcG9uZW50XG4gICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi9ub3RBcHAuYWRhcHRlci5qcycpLmRlZmF1bHQgfCBudWxsfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgTWVudVxuICAgICAqL1xuICAgIHN0YXRpYyBvcHRpb25zQWRhcHRlcjtcbiAgICBzdGF0aWMgZGlyZWN0TmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgIHN0YXRpYyBtZW51O1xuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICBkaXJlY3ROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgbmF2aWdhdGU6ICh1cmxzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RpcmVjdE5hdmlnYXRpb24oKSAmJiB0aGlzLm9wdGlvbnNBZGFwdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF2aWdhdGUgPSB0aGlzLm9wdGlvbnNBZGFwdGVyLmdldE5hdmlnYXRlRnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAobmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRlKHVybHMuc2hvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmFzc2lnbih1cmxzLmZ1bGwpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBzdGF0aWMgaGlkZSgpIHt9XG5cbiAgICBzdGF0aWMgaXRlbXMgPSBbXTtcbiAgICBzdGF0aWMgc2VjdGlvbnMgPSBbXTtcbiAgICBzdGF0aWMgbG9jYXRpb247XG4gICAgc3RhdGljIGludGVydmFsO1xuXG4gICAgc3RhdGljIHNldE9wdGlvbnNBZGFwdGVyKG9wdGlvbnNBZGFwdGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zQWRhcHRlciAmJiBvcHRpb25zQWRhcHRlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQWRhcHRlciA9IG9wdGlvbnNBZGFwdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzRGlyZWN0TmF2aWdhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kaXJlY3ROYXZpZ2F0aW9uO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRPcHRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zQWRhcHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc0FkYXB0ZXIuZ2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0RmllbGQobGlzdCwgZmllbGRzID0gW10pIHtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oaXRlbSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bZmllbGRdID0gdGhpcy5ERUZBVUxUW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGl0ZW0sIFwiaXRlbXNcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRGaWVsZChpdGVtLml0ZW1zLCBmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc29ydExpc3QobGlzdCkge1xuICAgICAgICBsaXN0LnNvcnQoKGl0ZW0xLCBpdGVtMikgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaXRlbTEsIFwiaXRlbXNcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRMaXN0KGl0ZW0xLml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGl0ZW0yLCBcIml0ZW1zXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0TGlzdChpdGVtMi5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbTEucHJpb3JpdHkgPT09IGl0ZW0yLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0xLnRpdGxlID4gaXRlbTIudGl0bGUgPyAxIDogLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtMS5wcmlvcml0eSA8IGl0ZW0yLnByaW9yaXR5ID8gMSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlRHVibGljYXRlcyhzZWN0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBzZWN0aW9uc1tpXS5wcmlvcml0eTtcbiAgICAgICAgICAgIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbi5pZCA9PT0gc2VjdGlvbnNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoaXRlbSwgaW5keCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5keCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gaXRlbS5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucy5zcGxpY2Uoc2VjdGlvbnMuaW5kZXhPZihpdGVtKSwgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9uc1tpXS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWN0aW9ucztcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlcGFyZURhdGEoKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICBpdGVtcy5wdXNoKC4uLnRoaXMuZ2V0T3B0aW9ucygpLml0ZW1zKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIHNlY3Rpb25zLnB1c2goLi4udGhpcy5nZXRPcHRpb25zKCkuc2VjdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuaW5pdEZpZWxkKHNlY3Rpb25zLCBbXCJwcmlvcml0eVwiXSk7XG4gICAgICAgIHRoaXMucmVtb3ZlRHVibGljYXRlcyhzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5pdEZpZWxkKGl0ZW1zLCBbXCJwcmlvcml0eVwiLCBcInNlY3Rpb25cIiwgXCJ0eXBlXCJdKTtcbiAgICAgICAgdGhpcy5zb3J0TGlzdChzZWN0aW9ucyk7XG5cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBpZDogdGhpcy5ERUZBVUxULnNlY3Rpb24sXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5ERUZBVUxULnNlY3Rpb25UaXRsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ydExpc3QoaXRlbXMpO1xuXG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHVubW91bnQodGhpcy5tZW51KTtcbiAgICAgICAgICAgIHRoaXMubWVudSA9IG51bGw7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZUluZGljYXRvcihzZWN0aW9uSWQsIGl0ZW1JZCwgc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWN0aW9uKHNlY3Rpb25JZCwgKHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNlY3Rpb24uaW5kaWNhdG9yLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUl0ZW0oaXRlbUlkLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5pbmRpY2F0b3Iuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVRhZyhzZWN0aW9uSWQsIGl0ZW1JZCwgdGFnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbihzZWN0aW9uSWQsIChzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZWN0aW9uLnRhZyA9IHRhZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbShpdGVtSWQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnRhZyA9IHRhZztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVNlY3Rpb25UYWcoc2VjdGlvbklkLCB0YWcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWN0aW9uKHNlY3Rpb25JZCwgKHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNlY3Rpb24udGFnID0geyAuLi5zZWN0aW9uLnRhZywgLi4udGFnIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVJdGVtVGFnKGl0ZW1JZCwgdGFnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbShpdGVtSWQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnRhZyA9IHsgLi4uaXRlbS50YWcsIC4uLnRhZyB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlU2VjdGlvbihzZWN0aW9uSWQsIHByb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMgJiYgc2VjdGlvbklkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWN0aW9uIGluIHRoaXMuc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uc1tzZWN0aW9uXS5pZCAhPT0gc2VjdGlvbklkKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBwcm9jKHRoaXMuc2VjdGlvbnNbc2VjdGlvbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudS4kc2V0KHsgc2VjdGlvbnM6IHRoaXMuc2VjdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlU2VjdGlvbkl0ZW1zKHNlY3Rpb25JZCwgcHJvYykge1xuICAgICAgICBpZiAodGhpcy5zZWN0aW9ucyAmJiBzZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGxldCBvbGRMaXN0ID0gdGhpcy5pdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKGl0ZW0pID0+IGl0ZW0uc2VjdGlvbiA9PT0gc2VjdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBvbGRMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGkpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaCguLi5wcm9jKG9sZExpc3QpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuJHNldCh7IGl0ZW1zOiB0aGlzLml0ZW1zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZUl0ZW0oaXRlbUlkLCBwcm9jKSB7XG4gICAgICAgIGlmIChpdGVtSWQgJiYgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IGl0ZW1JZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHByb2MoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuJHNldCh7IGl0ZW1zOiB0aGlzLml0ZW1zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVG91Y2goKSB7XG4gICAgICAgIHJldHVybiBVSUNvbW1vbi5pc01vYmlsZSh0cnVlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U2VjdGlvbkNvbXBvbmVudCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lbnU7XG4iLCI8c2NyaXB0PlxuICAgIC8qIGVzbGludCBzdmVsdGUvbm8tYXQtaHRtbC10YWdzOiAwICovXG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ljb25dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHVybCA9IFwiL1wiLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGljb24gPSB7XG4gICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzU2eDI4XCIsXG4gICAgICAgICAgICB3aWR0aDogMjgsXG4gICAgICAgICAgICBoZWlnaHQ6IDU2LFxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48YSBjbGFzcz1cIm5hdmJhci1pdGVtXCIgaHJlZj17dXJsfT5cbiAgICA8VUlJY29uIHsuLi5pY29ufSAvPlxuICAgIHsjaWYgdGl0bGV9XG4gICAgICAgIHtAaHRtbCBgPHNwYW4gY2xhc3M9XCJuYXZiYXItaXRlbS1icmFuZC10aXRsZVwiPiR7dGl0bGV9PC9zcGFuPmB9XG4gICAgey9pZn1cbjwvYT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRhZyBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS50YWcuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uLy4uL0xJQi5qc1wiO1xuICAgIGxldCB7IGl0ZW0gfSA9ICRwcm9wcygpO1xuXG4gICAgLypcbiAgc3RyaW5nIHRpdGxlXG4gIG9iamVjdCBpY29uO1xuICBvYmplY3QgdGFnO1xuICBzdHJpbmcgdHlwZTtcbiAgQ2xhc3MgY29tcG9uZW50O1xuICBvYmplY3QgaW5kaWNhdG9yO1xuICBvYmplY3Qgb3B0aW9ucztcbiAgKi9cbjwvc2NyaXB0PlxuXG57I2lmIGl0ZW0uaWNvbn1cbiAgICA8VUlJY29uIHsuLi5pdGVtLmljb259IC8+XG57OmVsc2UgaWYgaXRlbS50eXBlID09PSBcImNvbXBvbmVudFwiICYmIGl0ZW0uY29tcG9uZW50ICYmIENPTVBPTkVOVFMuY29udGFpbnMoaXRlbS5jb21wb25lbnQpfVxuICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoaXRlbS5jb21wb25lbnQpfVxuICAgIDxTdmVsdGVDb21wb25lbnQgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnByb3BzfSAvPlxuezplbHNlfVxuICAgIHskTE9DQUxFW2l0ZW0udGl0bGVdfVxuey9pZn1cblxueyNpZiBpdGVtLnRhZ31cbiAgICA8VUlUYWcgdG9wPXt0cnVlfSByaWdodD17dHJ1ZX0gc2l6ZT1cInNtYWxsXCIgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ31cbiAgICA+PC9VSVRhZz5cbnsvaWZ9XG5cbnsjaWYgaXRlbS5pbmRpY2F0b3J9XG4gICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBVSUl0ZW1Db250ZW50IGZyb20gXCIuL3VpLml0ZW0uY29udGVudC5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtoaWRkZW5dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc2VzXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyByb290ID0gXCJcIiwgaXRlbSA9IHt9LCBoaWRkZW4gPSBcIlwiLCBjbGFzc2VzID0gXCJcIiB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoKFwiY2xpY2tcIiwgeyBldmVudCwgZWxlbWVudDogaXRlbSB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBpdGVtLmJyZWFrfVxuICAgIDxociBjbGFzcz1cIm5hdmJhci1kaXZpZGVyIHtoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiAnJ30gXCIgLz5cbnsvaWZ9XG5cbnsjaWYgaXRlbS51cmx9XG4gICAgPGFcbiAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuXG4gICAgICAgICAgICA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YFxuICAgICAgICAgICAgOiAnJ30ge2l0ZW0uY2xhc3Nlc30ge2NsYXNzZXN9IFwiXG4gICAgICAgIGhyZWY9XCJ7cm9vdH17aXRlbS51cmx9XCJcbiAgICAgICAgZGF0YS1ocmVmPXtpdGVtLnVybH1cbiAgICA+XG4gICAgICAgIDxVSUl0ZW1Db250ZW50IHtpdGVtfSAvPlxuICAgIDwvYT5cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIG9ua2V5dXA9e29uQ2xpY2t9XG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW0ge2hpZGRlblxuICAgICAgICAgICAgPyBgaXMtaGlkZGVuLSR7aGlkZGVufWBcbiAgICAgICAgICAgIDogJyd9IHtpdGVtLmNsYXNzZXN9IHtjbGFzc2VzfVwiXG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgID5cbiAgICAgICAgPFVJSXRlbUNvbnRlbnQge2l0ZW19IC8+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBVSUl0ZW1Db250ZW50IGZyb20gXCIuL3VpLml0ZW0uY29udGVudC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJdGVtIGZyb20gXCIuL3VpLml0ZW0uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2hpZGRlbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtob3ZlcmFibGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYXJyb3dsZXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JpZ2h0XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICByb290ID0gXCJcIixcbiAgICAgICAgc2VjdGlvbiA9IHt9LFxuICAgICAgICBpdGVtcyA9IFtdLFxuICAgICAgICBoaWRkZW4gPSBcIlwiLFxuICAgICAgICBob3ZlcmFibGUgPSB0cnVlLFxuICAgICAgICBhcnJvd2xlc3MgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoKFwiY2xpY2tcIiwgeyBldmVudCwgZWxlbWVudDogc2VjdGlvbiB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBpdGVtcy5sZW5ndGh9XG4gICAgPGRpdlxuICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtIGhhcy1kcm9wZG93biB7aG92ZXJhYmxlXG4gICAgICAgICAgICA/ICdpcy1ob3ZlcmFibGUnXG4gICAgICAgICAgICA6ICcnfSB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiXG4gICAgPlxuICAgICAgICA8YVxuICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgICAgIGNsYXNzPVwibmF2YmFyLWxpbmsge2Fycm93bGVzcyA/ICdpcy1hcnJvd2xlc3MnIDogJyd9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPFVJSXRlbUNvbnRlbnQgaXRlbT17c2VjdGlvbn0gLz5cbiAgICAgICAgPC9hPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWRyb3Bkb3duIHtyaWdodCA/ICdpcy1yaWdodCcgOiAnJ31cIj5cbiAgICAgICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgICAgICAgICA8VUlJdGVtIHtyb290fSB7aXRlbX0gb246Y2xpY2sgLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG57OmVsc2UgaWYgc2VjdGlvbi51cmx9XG4gICAgPGFcbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiXG4gICAgICAgIGhyZWY9XCJ7cm9vdH17c2VjdGlvbi51cmx9XCJcbiAgICAgICAgZGF0YS1ocmVmPXtzZWN0aW9uLnVybH1cbiAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICA+XG4gICAgICAgIDxVSUl0ZW1Db250ZW50IGl0ZW09e3NlY3Rpb259IC8+XG4gICAgPC9hPlxuezplbHNlfVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiXG4gICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIG9ua2V5dXA9e29uQ2xpY2t9XG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgID5cbiAgICAgICAgPFVJSXRlbUNvbnRlbnQgaXRlbT17c2VjdGlvbn0gLz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblxuY29uc3QgU2lkZU1lbnVTdGF0ZSA9IHdyaXRhYmxlKHtcbiAgICBvcGVuOiB0cnVlLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNpZGVNZW51U3RhdGU7XG4iLCI8c2NyaXB0PlxuICAgIGNvbnN0IENPTVBPTkVOVF9OQU1FID0gXCJ0b3AtbmF2YmFyLWJ1cmdlclwiO1xuXG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBTaWRlTWVudVN0b3JlIGZyb20gXCIuLi9zaWRlL3N0b3JlXCI7XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5cblxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjbG9zZWQgPSAhY2xvc2VkO1xuICAgICAgICBkaXNwYXRjaChcInRvZ2dsZVwiLCB7XG4gICAgICAgICAgICBjbG9zZWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBDT01QT05FTlRfTkFNRSArIFwiOnVwZGF0ZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtldmVudHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtyZWdpc3Rlcl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbG9zZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtvblVwZGF0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZXZlbnRzID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMuYmluZChub3RDb21tb24pLFxuICAgICAgICBjbG9zZWQgPSAkYmluZGFibGUodHJ1ZSksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNsb3NlZCA9IGRhdGEuY2xvc2VkO1xuICAgICAgICB9XG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyhldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuXG4gICAgU2lkZU1lbnVTdG9yZS5zdWJzY3JpYmUoKHZhbCkgPT4ge1xuICAgICAgICBjbG9zZWQgPSAhdmFsLm9wZW47XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPGFcbiAgICBocmVmXG4gICAgb25jbGljaz17dG9nZ2xlfVxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIGNsYXNzPVwibmF2YmFyLWJ1cmdlciB7Y2xvc2VkID8gJycgOiAnaXMtYWN0aXZlJ31cIlxuICAgIGFyaWEtbGFiZWw9XCJtZW51XCJcbiAgICBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIlxuICAgIGRhdGEtdGFyZ2V0PVwibmF2YmFyXCJcbj5cbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbjwvYT5cbiIsIjwhLS0gQG1pZ3JhdGlvbi10YXNrIEVycm9yIHdoaWxlIG1pZ3JhdGluZyBTdmVsdGUgY29kZTogQ2FuJ3QgbWlncmF0ZSBjb2RlIHdpdGggYmVmb3JlVXBkYXRlLiBQbGVhc2UgbWlncmF0ZSBieSBoYW5kLiAtLT5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQnJhbmQgZnJvbSBcIi4vdWkuYnJhbmQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFySXRlbSBmcm9tIFwiLi91aS5pdGVtLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhclNlY3Rpb24gZnJvbSBcIi4vdWkuc2VjdGlvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJCdXJnZXIgZnJvbSBcIi4vdWkuYnVyZ2VyLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlY3Rpb25zXSAtIGltcG9ydCB7IGJlZm9yZVVwZGF0ZSB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW25hdmlnYXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2JyYW5kXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dCdXJnZXJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnVyZ2VyQ29udHJvbHNTaWRlbWVudV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgc2VjdGlvbnMgPSBbXSxcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgcm9vdCA9IFwiXCIsXG4gICAgICAgIG5hdmlnYXRlID0gbnVsbCxcbiAgICAgICAgYnJhbmQgPSBmYWxzZSxcbiAgICAgICAgc2hvd0J1cmdlciA9IHRydWUsXG4gICAgICAgIGJ1cmdlckNvbnRyb2xzU2lkZW1lbnUgPSB0cnVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBtZW51Q2xvc2VkID0gJHN0YXRlKHRydWUpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayh7IGRldGFpbCB9KSB7XG4gICAgICAgIGxldCB7IGV2ZW50LCBlbGVtZW50IH0gPSBkZXRhaWw7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGVsZW1lbnQsIFwiYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hY3Rpb24oZXZlbnQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbmF2aWdhdGUoe1xuICAgICAgICAgICAgICAgIGZ1bGw6IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICAgICAgICBzaG9ydDogZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0LmhyZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHNlY3Rpb25zSXRlbXNDb3VudCA9IHt9O1xuICAgIGxldCBzZWN0aW9uc0l0ZW1zID0ge307XG4gICAgLypcbiAgICBiZWZvcmVVcGRhdGUoKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgICAgICBzZWN0aW9uc0l0ZW1zW3NlY3Rpb24uaWRdID0gaXRlbXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh0KSA9PiB0LnNlY3Rpb24gPT09IHNlY3Rpb24uaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWN0aW9uc0l0ZW1zQ291bnRbc2VjdGlvbi5pZF0gPSBpdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHQpID0+IHQuc2VjdGlvbiA9PT0gc2VjdGlvbi5pZFxuICAgICAgICAgICAgKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9KTtcbiovXG4gICAgZnVuY3Rpb24gdG9nZ2xlQnVyZ2VyKHsgZGV0YWlsIH0pIHtcbiAgICAgICAgaWYgKGJ1cmdlckNvbnRyb2xzU2lkZW1lbnUpIHtcbiAgICAgICAgICAgIFNpZGVNZW51LnRvZ2dsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2goXCJ0b2dnbGVCdXJnZXJcIiwgZGV0YWlsKTtcbiAgICAgICAgICAgIG1lbnVDbG9zZWQgPSBkZXRhaWwuY2xvc2VkO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJuYXZiYXItYnJhbmRcIj5cbiAgICB7I2lmIGJyYW5kfVxuICAgICAgICA8VUlCcmFuZCB7Li4uYnJhbmR9IC8+XG4gICAgey9pZn1cbiAgICB7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbiAoc2VjdGlvbi5pZCl9XG4gICAgICAgIHsjaWYgc2VjdGlvbi5zaG93T25Ub3VjaH1cbiAgICAgICAgICAgIDxVSU5hdmJhckl0ZW1cbiAgICAgICAgICAgICAgICBoaWRkZW49XCJkZXNrdG9wXCJcbiAgICAgICAgICAgICAgICBpdGVtPXtzZWN0aW9ufVxuICAgICAgICAgICAgICAgIHtyb290fVxuICAgICAgICAgICAgICAgIG9uOmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICB7I2lmIGl0ZW0uc2hvd09uVG91Y2h9XG4gICAgICAgICAgICA8VUlOYXZiYXJJdGVtIGhpZGRlbj1cImRlc2t0b3BcIiB7aXRlbX0ge3Jvb3R9IG9uY2xpY2s9e29uQ2xpY2t9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuICAgIHsjaWYgc2hvd0J1cmdlcn1cbiAgICAgICAgPFVJTmF2YmFyQnVyZ2VyIG9uOnRvZ2dsZT17dG9nZ2xlQnVyZ2VyfSAvPlxuICAgIHsvaWZ9XG48L2Rpdj5cbjxkaXYgaWQ9XCJuYXZiYXJcIiBjbGFzcz1cIm5hdmJhci1tZW51IHttZW51Q2xvc2VkID8gJycgOiAnaXMtYWN0aXZlJ31cIj5cbiAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLXN0YXJ0XCI+XG4gICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtfVxuICAgICAgICAgICAgeyNpZiBpdGVtLnBsYWNlID09PSBcInN0YXJ0XCJ9XG4gICAgICAgICAgICAgICAgPFVJTmF2YmFySXRlbSBoaWRkZW49XCJ0b3VjaFwiIHtpdGVtfSBvbmNsaWNrPXtvbkNsaWNrfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItZW5kXCI+XG4gICAgICAgIHsjZWFjaCBzZWN0aW9ucyBhcyBzZWN0aW9uIChzZWN0aW9uLmlkKX1cbiAgICAgICAgICAgIHsjaWYgKHNlY3Rpb25zSXRlbXNDb3VudFtzZWN0aW9uLmlkXSB8fCBzZWN0aW9uLmluZGljYXRvciB8fCBzZWN0aW9uLnRhZykgJiYgc2VjdGlvbi5wbGFjZSA9PSBcImVuZFwifVxuICAgICAgICAgICAgICAgIDxVSU5hdmJhclNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbj17c2VjdGlvbi5oaWRkZW59XG4gICAgICAgICAgICAgICAgICAgIHtyb290fVxuICAgICAgICAgICAgICAgICAgICB7c2VjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgaXRlbXM9e3NlY3Rpb25zSXRlbXNbc2VjdGlvbi5pZF19XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwiaW1wb3J0IE1lbnUgZnJvbSBcIi4uL21lbnUuanNcIjtcbmltcG9ydCBVSU5hdmJhciBmcm9tIFwiLi91aS50b3Auc3ZlbHRlXCI7XG5pbXBvcnQgeyBtb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgVFlQRSA9IFwidG9wXCI7XG5cbmxldCBNRU5VX1BST1BTID0gJHN0YXRlKHt9KTtcblxuY2xhc3Mgbm90VG9wTWVudSBleHRlbmRzIE1lbnUge1xuICAgIHN0YXRpYyBERUZBVUxUID0ge1xuICAgICAgICBzZWN0aW9uOiBcImFueVwiLFxuICAgICAgICBzZWN0aW9uVGl0bGU6IFwi0JzQtdC90Y5cIixcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIC8vbGluaywgYnV0dG9uLCBkcm9wZG93biwgY29tcG9uZW50XG4gICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICBwbGFjZTogXCJtYWluXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICBicmFuZDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFRZUEUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc2VjdGlvbnM6IFtdLFxuICAgICAgICB0YXJnZXRTZWxlY3RvcjogYCMke1RZUEV9LW1lbnVgLFxuICAgICAgICByb290OiBcIi9cIixcbiAgICAgICAgZGlyZWN0TmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgIG5hdmlnYXRlOiAodXJscykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXJlY3ROYXZpZ2F0aW9uKCkgJiYgdGhpcy5hcHApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuYXBwLmdldFdvcmtpbmcoXCJyb3V0ZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMubmF2aWdhdGUodXJscy5zaG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uYXNzaWduKHVybHMuZnVsbCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHN0YXRpYyBpbml0TWVudVByb3BzKCkge1xuICAgICAgICBNRU5VX1BST1BTID0ge1xuICAgICAgICAgICAgYnJhbmQ6IHRoaXMuZ2V0T3B0aW9ucygpLmJyYW5kLFxuICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICBzZWN0aW9uczogdGhpcy5zZWN0aW9ucyxcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMuZ2V0T3B0aW9ucygpLnJvb3QsXG4gICAgICAgICAgICBuYXZpZ2F0ZTogdGhpcy5nZXRPcHRpb25zKCkubmF2aWdhdGUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbmRlcihhcHApIHtcbiAgICAgICAgaWYgKGFwcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBcHAoYXBwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGlmICghdGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRNZW51UHJvcHMoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lbnUgPSBtb3VudChVSU5hdmJhciwge1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wczogdGhpcy5NRU5VX1BST1BTLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51QWN0aXZlSXRlbS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIG5vdFRvcE1lbnUuSU5URVJWQUxfVVBEQVRFX0FDVElWRV9JVEVNXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZU1lbnUodXJsKSB7XG4gICAgICAgIEFycmF5LmZyb20oXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yICsgXCIgYXNpZGUubWVudSBhXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXRlbS5ocmVmID09IHVybCB8fFxuICAgICAgICAgICAgICAgICh1cmwuaHJlZiAmJiB1cmwuaHJlZi5pbmRleE9mKGl0ZW0uaHJlZikgPT0gMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlTWVudUFjdGl2ZUl0ZW0oKSB7XG4gICAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGxhc3RMb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIGlmIChsYXN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh1cmwgIT09IGxhc3RMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51KHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51KHVybCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdG9nZ2xlKCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWFjdGl2ZVwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaGlkZSgpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIHNob3coKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRCdXJnZXJTdGF0ZShtZW51Q2xvc2VkKSB7XG4gICAgICAgIE1FTlVfUFJPUFMubWVudUNsb3NlZCA9IG1lbnVDbG9zZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RUb3BNZW51O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW0gPSB7fSwgb25uYXZpZ2F0ZSA9ICgpID0+IHt9IH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25uYXZpZ2F0ZSh7XG4gICAgICAgICAgICBmdWxsOiBldi50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICAgIHNob3J0OiBldi50YXJnZXQuZGF0YXNldC5ocmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHR5cGVvZiBpdGVtLnVybCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVtLnVybCAhPT0gZmFsc2V9XG4gICAgPGxpIGNsYXNzPXtpdGVtLmNsYXNzZXN9PlxuICAgICAgICA8YSBocmVmPVwie3Jvb3R9e2l0ZW0udXJsfVwiIGRhdGEtaHJlZj17aXRlbS51cmx9IG9uY2xpY2s9e29uQ2xpY2t9PlxuICAgICAgICAgICAgeyRMT0NBTEVbaXRlbS50aXRsZV19XG4gICAgICAgICAgICB7I2lmIGl0ZW0udGFnfVxuICAgICAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0udGFnfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgaXRlbS5pbmRpY2F0b3J9XG4gICAgICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2E+XG4gICAgPC9saT5cbns6ZWxzZX1cbiAgICA8bGkgY2xhc3M9XCJpcy1uby1mb2xsb3ctc3VidGl0bGUge2l0ZW0uY2xhc3Nlc31cIj5cbiAgICAgICAgeyRMT0NBTEVbaXRlbS50aXRsZV19XG4gICAgICAgIHsjaWYgaXRlbS50YWd9XG4gICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ30gLz5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiBpdGVtLmluZGljYXRvcn1cbiAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0uaW5kaWNhdG9yfSAvPlxuICAgICAgICB7L2lmfVxuICAgIDwvbGk+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBjb25zdCBDTEFTU19JQ09OID0ge1xuICAgICAgICBPUEVORUQ6IFwiZmEtYW5nbGUtZG93blwiLFxuICAgICAgICBDTE9TRUQ6IFwiZmEtYW5nbGUtdXBcIixcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ljb25fb3BlbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaWNvbl9jbG9zZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2xvc2VkXSAgICByZXR1cm5zIGlmIHdlIHNob3VsZCBhcHBseSB0b2dnbGUgb3IgaWYgZmFsc2UgLSByZWplY3QgaXQgYW5kIHRvZ2dsZSBiYWNrd2FyZFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpY29uX29wZW5lZCA9IENMQVNTX0lDT04uT1BFTkVELFxuICAgICAgICBpY29uX2Nsb3NlZCA9IENMQVNTX0lDT04uQ0xPU0VELFxuICAgICAgICBjbG9zZWQsXG4gICAgICAgIG9udG9nZ2xlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNsb3NlZCA9ICFjbG9zZWQ7XG4gICAgICAgIGlmICghb250b2dnbGUoY2xvc2VkKSkge1xuICAgICAgICAgICAgY2xvc2VkID0gIWNsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzcGFuXG4gICAgY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLXRvZ2dsZS1zdWJtZW51IGlzLXB1bGxlZC1yaWdodFwiXG4gICAgb25jbGljaz17b25DbGlja31cbiAgICBvbmtleXVwPXtvbkNsaWNrfVxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIHRhYmluZGV4PVwiMFwiXG4+XG4gICAgPGkgY2xhc3M9XCJmYXMge2Nsb3NlZCA/IGljb25fY2xvc2VkIDogaWNvbl9vcGVuZWR9XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuPC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLmZvbnQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUYWcgZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IENPTVBPTkVOVFMgfSBmcm9tIFwiLi4vLi4vLi4vTElCLmpzXCI7XG4gICAgbGV0IHsgaXRlbSA9IHt9LCBjaGlsZHJlbiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtLmljb259XG4gICAgPFVJSWNvbiB7Li4uaXRlbS5pY29ufSAvPlxuezplbHNlIGlmIGl0ZW0udHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiBpdGVtLmNvbXBvbmVudCAmJiBDT01QT05FTlRTLmNvbnRhaW5zKGl0ZW0uY29tcG9uZW50KX1cbiAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IENPTVBPTkVOVFMuZ2V0KGl0ZW0uY29tcG9uZW50KX1cbiAgICA8U3ZlbHRlQ29tcG9uZW50IGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5wcm9wc30gLz5cbns6ZWxzZX1cbiAgICA8c3BhbiBjbGFzcz1cImlzLW5vLWxpbmtcIj57JExPQ0FMRVtpdGVtLnRpdGxlXX08L3NwYW4+XG57L2lmfVxueyNpZiBpdGVtLnRhZ31cbiAgICA8VUlUYWcgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ30gLz5cbnsvaWZ9XG57I2lmIGl0ZW0uaW5kaWNhdG9yfVxuICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0uaW5kaWNhdG9yfSAvPlxuey9pZn1cbntAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVpX2l0ZW1zIGZyb20gXCIuL3VpLml0ZW1zLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJU2lkZU1lbnVJdGVtV2l0aG91dENoaWxkcmVuIGZyb20gXCIuL3VpLml0ZW0ud2l0aG91dC5jaGlsZHJlbi5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVNpZGVNZW51VHJpZ2dlciBmcm9tIFwiLi91aS50cmlnZ2VyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVNpZGVNZW51SXRlbUxhYmVsIGZyb20gXCIuL3VpLml0ZW0ubGFiZWwuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nsb3NlZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25uYXZpZ2F0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW1zID0gW10sIGNsb3NlZCwgb25uYXZpZ2F0ZSA9ICgpID0+IHt9IH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGNyZWF0ZUNsb3NlZEl0ZW1zTGliID0gKGxzdCkgPT4ge1xuICAgICAgICBjb25zdCBsaWIgPSB7fTtcbiAgICAgICAgbHN0LmZvckVhY2goKGl0bSwgaW5kZXgpID0+IChsaWJbaW5kZXhdID0gaXRtLmNsb3NlZCkpO1xuICAgICAgICByZXR1cm4gbGliO1xuICAgIH07XG5cbiAgICBsZXQgY2xvc2VkQ2hpbGRyZW4gPSAkc3RhdGUoY3JlYXRlQ2xvc2VkSXRlbXNMaWIoaXRlbXMpKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25uYXZpZ2F0ZSh7XG4gICAgICAgICAgICBmdWxsOiBldi50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICAgIHNob3J0OiBldi50YXJnZXQuZGF0YXNldC5ocmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48dWwgY2xhc3M9XCJtZW51LWxpc3Qge2Nsb3NlZCA/ICdpcy1jbG9zZWQnIDogJyd9XCI+XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0sIGluZGV4fVxuICAgICAgICB7I2lmIGl0ZW0uaXRlbXMgJiYgaXRlbS5pdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJpcy1uby1mb2xsb3ctc3VidGl0bGUge2l0ZW0uY2xhc3Nlc31cIj5cbiAgICAgICAgICAgICAgICB7I2lmIHR5cGVvZiBpdGVtLnVybCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVtLnVybCAhPT0gZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwie3Jvb3R9e2l0ZW0udXJsfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWhyZWY9e2l0ZW0udXJsfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaGFzLXN1Yml0ZW1zXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFVJU2lkZU1lbnVJdGVtTGFiZWwge2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51VHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNsb3NlZD17Y2xvc2VkQ2hpbGRyZW5baW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L1VJU2lkZU1lbnVJdGVtTGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51SXRlbUxhYmVsIHtpdGVtfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51VHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmQ6Y2xvc2VkPXtjbG9zZWRDaGlsZHJlbltpbmRleF19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L1VJU2lkZU1lbnVJdGVtTGFiZWw+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8VWlfaXRlbXNcbiAgICAgICAgICAgICAgICAgICAge3Jvb3R9XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zPXtpdGVtLml0ZW1zfVxuICAgICAgICAgICAgICAgICAgICBiaW5kOmNsb3NlZD17Y2xvc2VkQ2hpbGRyZW5baW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICB7b25uYXZpZ2F0ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPFVJU2lkZU1lbnVJdGVtV2l0aG91dENoaWxkcmVuIHtyb290fSB7aXRlbX0ge29ubmF2aWdhdGV9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuPC91bD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUluZGljYXRvciBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJU2lkZU1lbnVJdGVtcyBmcm9tIFwiLi91aS5pdGVtcy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uLy4uL0xJQi5qc1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBzZWN0aW9uXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbm5hdmlnYXRlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBzZWN0aW9uLCBpdGVtcyA9IFtdLCByb290ID0gXCJcIiwgb25uYXZpZ2F0ZSA9ICgpID0+IHt9IH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBzZWN0aW9uSXRlbXMgPSAkZGVyaXZlZChcbiAgICAgICAgaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBzZWN0aW9uLmlkID09PSBpdGVtLnNlY3Rpb24pXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I2lmIHNlY3Rpb259XG4gICAgeyNpZiBzZWN0aW9uSXRlbXMubGVuZ3RoIHx8IHNlY3Rpb24uY29tcG9uZW50IHx8IHNlY3Rpb24udGFnIHx8IHNlY3Rpb24uaW5kaWNhdG9yfVxuICAgICAgICA8cCBjbGFzcz1cIm1lbnUtbGFiZWwge3NlY3Rpb24uY2xhc3Nlc31cIj5cbiAgICAgICAgICAgIHsjaWYgc2VjdGlvbi50eXBlID09PSBcImNvbXBvbmVudFwiICYmIHNlY3Rpb24uY29tcG9uZW50ICYmIENPTVBPTkVOVFMuY29udGFpbnMoc2VjdGlvbi5jb21wb25lbnQpfVxuICAgICAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoc2VjdGlvbi5jb21wb25lbnQpfVxuICAgICAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnQgaWQ9e3NlY3Rpb24uaWR9IHsuLi5zZWN0aW9uLnByb3BzfSAvPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHskTE9DQUxFW3NlY3Rpb24udGl0bGVdfVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgc2VjdGlvbi50YWd9XG4gICAgICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtzZWN0aW9uLmlkfSB7Li4uc2VjdGlvbi50YWd9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNpZiBzZWN0aW9uLmluZGljYXRvcn1cbiAgICAgICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e3NlY3Rpb24uaWR9IHsuLi5zZWN0aW9uLmluZGljYXRvcn0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvcD5cbiAgICB7L2lmfVxuey9pZn1cbnsjaWYgc2VjdGlvbkl0ZW1zLmxlbmd0aH1cbiAgICA8VUlTaWRlTWVudUl0ZW1zIHtyb290fSBpdGVtcz17c2VjdGlvbkl0ZW1zfSB7b25uYXZpZ2F0ZX0gLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSVNpZGVNZW51U2VjdGlvbiBmcm9tIFwiLi91aS5zZWN0aW9uLnN2ZWx0ZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzZWN0aW9uc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW25hdmlnYXRlID0gKCk9PnVuZGVmaW5lZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW1zID0gW10sIHNlY3Rpb25zID0gW10sIG5hdmlnYXRlID0gbnVsbCB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbmF2aWdhdGUoZXYpO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjZWFjaCBzZWN0aW9ucyBhcyBzZWN0aW9ufVxuICAgIDxVSVNpZGVNZW51U2VjdGlvbiB7c2VjdGlvbn0ge2l0ZW1zfSB7cm9vdH0gb25uYXZpZ2F0ZT17b25DbGlja30gLz5cbnsvZWFjaH1cbiIsImltcG9ydCBNZW51IGZyb20gXCIuLi9tZW51LmpzXCI7XG5pbXBvcnQgVUlTaWRlTWVudSBmcm9tIFwiLi91aS5zaWRlLm1lbnUuc3ZlbHRlXCI7XG5cbmltcG9ydCBTaWRlTWVudVN0YXRlIGZyb20gXCIuL3N0b3JlLmpzXCI7XG5pbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgVFlQRSA9IFwic2lkZVwiO1xuXG5sZXQgTUVOVV9VSV9QUk9QUyA9ICRzdGF0ZSh7fSk7XG5cbmNsYXNzIG5vdFNpZGVNZW51IGV4dGVuZHMgTWVudSB7XG4gICAgc3RhdGljIG5hdjtcbiAgICBzdGF0aWMgbWFpbjtcbiAgICBzdGF0aWMgYXNpZGU7XG5cbiAgICBzdGF0aWMgREVGQVVMVCA9IHtcbiAgICAgICAgc2VjdGlvbjogXCJhbnlcIixcbiAgICAgICAgc2VjdGlvblRpdGxlOiBcItCc0LXQvdGOXCIsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIG9wdGlvbnMgPSB7XG4gICAgICAgIGRpcmVjdE5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICB0eXBlOiBUWVBFLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHNlY3Rpb25zOiBbXSxcbiAgICAgICAgdGFyZ2V0U2VsZWN0b3I6IGAjJHtUWVBFfS1tZW51YCxcbiAgICAgICAgdG9nZ2xlU2VsZWN0b3I6IGAuJHtUWVBFfS1tZW51LXRvZ2dsZWAsXG4gICAgICAgIHJvb3Q6IFwiL1wiLFxuICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0ZTogKHVybHMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLmVtaXQoXCJ0b3AtbmF2YmFyLWJ1cmdlcjp1cGRhdGVcIiwgeyBjbG9zZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXJlY3ROYXZpZ2F0aW9uKCkgJiYgdGhpcy5hcHApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuYXBwLmdldFdvcmtpbmcoXCJyb3V0ZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMubmF2aWdhdGUodXJscy5zaG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uYXNzaWduKHVybHMuZnVsbCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHN0YXRpYyBpbml0TWVudVVJUHJvcHMoKSB7XG4gICAgICAgIE1FTlVfVUlfUFJPUFMgPSB7XG4gICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLnNlY3Rpb25zLFxuICAgICAgICAgICAgcm9vdDogdGhpcy5nZXRPcHRpb25zKCkucm9vdCxcbiAgICAgICAgICAgIG5hdmlnYXRlOiB0aGlzLmdldE9wdGlvbnMoKS5uYXZpZ2F0ZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVuZGVyKGFwcCkge1xuICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFwcChhcHApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZURhdGEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdE1lbnVVSVByb3BzKCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICB1bm1vdW50KHRoaXMubWVudSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVUkoKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lbnUgPSBtb3VudChVSVNpZGVNZW51LCB7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wczogTUVOVV9VSV9QUk9QUyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5pdFNpemVSZXNwb25zZSgpO1xuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudUFjdGl2ZUl0ZW0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHRoaXMuSU5URVJWQUxfVVBEQVRFX0FDVElWRV9JVEVNXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYmluZFRvZ2dsZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpdGVtSXNBY3RpdmUoaXRlbVVSTCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG9jYXRpb24gKyBcIi9cIikuaW5kZXhPZihpdGVtVVJMICsgXCIvXCIpID4gLTE7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZU1lbnUoKSB7XG4gICAgICAgIEFycmF5LmZyb20oXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yICsgXCIgYVwiKVxuICAgICAgICApLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1Jc0FjdGl2ZShpdGVtLmdldEF0dHJpYnV0ZShcImhyZWZcIikpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVNZW51QWN0aXZlSXRlbSgpIHtcbiAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgbGFzdExvY2F0aW9uID0gdGhpcy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKGxhc3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKHVybCAhPT0gbGFzdExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0U2l6ZVJlc3BvbnNlKCkge1xuICAgICAgICB0aGlzLm5hdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJuYXYubmF2YmFyXCIpO1xuICAgICAgICB0aGlzLmFzaWRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImFzaWRlXCIpO1xuICAgICAgICB0aGlzLm1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWFpblwiKTtcbiAgICAgICAgdGhpcy5yZXNpemVBc2lkZUFuZE1haW4odGhpcy5hc2lkZSwgdGhpcy5tYWluLCB0aGlzLm5hdik7XG4gICAgICAgIHRoaXMucmVzaXplTWFpbih0aGlzLm1haW4sIHRoaXMuYXNpZGUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZU1haW4uYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucygpLm9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzaXplTWFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hc2lkZS5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMuYXNpZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4uc3R5bGUuaGVpZ2h0ID09PSBcIjBweFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLm1hcmdpbkxlZnQgPSByZWN0LndpZHRoICsgcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2l6ZUFzaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5hc2lkZS5zdHlsZS5kaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLm5hdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuYXNpZGUuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gcmVjdC5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmFzaWRlLnN0eWxlLm1hcmdpblRvcCA9IHJlY3QuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2l6ZUFzaWRlQW5kTWFpbigpIHtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLm5hdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5hc2lkZS5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSByZWN0LmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgLy90aGlzLmFzaWRlLnN0eWxlLnBhZGRpbmdUb3AgPSAocmVjdC5oZWlnaHQpICsgJ3B4JztcbiAgICAgICAgLy90aGlzLm1haW4uc3R5bGUubWFyZ2luVG9wID0gKHJlY3QuaGVpZ2h0KSArICdweCc7XG4gICAgfVxuXG4gICAgc3RhdGljIGJpbmRUb2dnbGUoKSB7XG4gICAgICAgIGxldCBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZ2V0T3B0aW9ucygpLnRvZ2dsZVNlbGVjdG9yKTtcbiAgICAgICAgQXJyYXkuZnJvbShlbHMpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB0b2dnbGUoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNpemVNYWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBoaWRlKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LmFkZChcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaXplTWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIFNpZGVNZW51U3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBzaG93KGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC5hZGQoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LnJlbW92ZShcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaXplTWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIFNpZGVNZW51U3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzaWRlLmNsYXNzTGlzdC5jb250YWlucyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmFzaWRlLmNsYXNzTGlzdC5jb250YWlucyhcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RTaWRlTWVudTtcbiIsImNvbnN0IERFRkFVTFRfVFJBU0ZPUk1FUiA9IChyZXMpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd24ocmVzLCBcInN0YXR1c1wiKSAmJiBPYmplY3QuaGFzT3duKHJlcywgXCJyZXN1bHRcIilcbiAgICAgICAgPyByZXMucmVzdWx0XG4gICAgICAgIDogcmVzO1xufTtcblxuZXhwb3J0IHsgREVGQVVMVF9UUkFTRk9STUVSIH07XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IERFRkFVTFRfVFJBU0ZPUk1FUiB9IGZyb20gXCIuL2NvbnN0XCI7XG5leHBvcnQgZGVmYXVsdCAoeyBBQ1RJT04sIFRJVExFLCBVSUNvbnN0cnVjdG9yLCBkYXRhUHJvdmlkZXIsIGdvQmFjayB9KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzIHtcbiAgICAgICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBg0J/RgNC+0YHQvNC+0YLRgCBcIiR7VElUTEV9XCJgLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKEFDVElPTik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudWlbQUNUSU9OXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhkYXRhUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzQXN5bmMoZGF0YVByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBkYXRhUHJvdmlkZXIocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFQcm92aWRlcihwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHsgLi4uZGF0YVByb3ZpZGVyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0VHJhbnNmb3JtZXIgPSBjb250cm9sbGVyLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIGAke0FDVElPTn0udHJhbnNmb3JtZXJgLFxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX1RSQVNGT1JNRVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXSA9IG5ldyBVSUNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogeyBwYXJhbXMsIC4uLnJlc3VsdFRyYW5zZm9ybWVyKGRhdGEpIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBhZnRlcjpyZW5kZXI6JHtBQ1RJT059YCk7XG4gICAgICAgICAgICAgICAgaWYgKGdvQmFjayAmJiBub3RDb21tb24uaXNGdW5jKGdvQmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dLm9uKFwicmVqZWN0XCIsICgpID0+IGdvQmFjaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuY29uc3QgUFJFTE9BREFCTEUgPSBbXCJjcmVhdGVcIiwgXCJ1cGRhdGVcIiwgXCJsaXN0XCIsIFwiZGVsZXRlXCIsIFwiZGV0YWlsc1wiXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1JVRFZhcmlhbnRzUHJlbG9hZGVyIHtcbiAgICBzdGF0aWMgYXN5bmMgcHJlbG9hZChjb250cm9sbGVyLCB0eXBlID0gXCJsaXN0XCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghUFJFTE9BREFCTEUuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJlbG9hZCA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0eXBlfS5wcmVsb2FkYCwge30pO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByZWxvYWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZCA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgcHJlbG9hZGAsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwcmVsb2FkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpYlByb3BzID0gT2JqZWN0LmtleXMocHJlbG9hZCk7XG4gICAgICAgICAgICAgICAgbGV0IHByb21zID0gW107XG4gICAgICAgICAgICAgICAgbGliUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW9kZWxOYW1lID0gbm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIocHJlbG9hZFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBNb2RlbCA9IGNvbnRyb2xsZXIubWFrZVttb2RlbE5hbWVdKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaChNb2RlbC4kbGlzdEFsbCgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21zKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpYlByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gbGliUHJvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0uc3RhdHVzID09PSBcIm9rXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocmVzdWx0c1tpXS5yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0c0xpc3QgPSByZXN1bHRzW2ldLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRzID0gcmVzdWx0c0xpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHZhcmlhbnRzLiR7dHlwZX0uJHtwcm9wTmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5sb2coXCJwcmVsb2FkIGZpbmlzaGVkXCIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImNvbnN0IERFRkFVTFRfQUNUSU9OID0gXCJsaXN0XCI7XG5cbmNsYXNzIG5vdENSVURSb3V0ZXIge1xuICAgIHN0YXRpYyBleHRyYWN0QWN0aW9uTmFtZShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IGFjdGlvbk5hbWUgPSBERUZBVUxUX0FDVElPTjtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbMF0gPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJjcmVhdGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5hY3Rpb25IYW5kbGVyRXhpc3RzKHBhcmFtc1swXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gcGFyYW1zWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJkZXRhaWxzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbMV0gPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJkZWxldGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zWzFdID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IFwidXBkYXRlXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBwYXJhbXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbk5hbWU7XG4gICAgfVxuXG4gICAgc3RhdGljIHJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IG5vdENSVURSb3V0ZXIuZXh0cmFjdEFjdGlvbk5hbWUoXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNldEN1cnJlbnRBY3Rpb24oYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5ydW5BY3Rpb24oYWN0aW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVURSb3V0ZXI7XG4iLCJpbXBvcnQgeyBVSVN1Y2Nlc3MsIFVJRXJyb3IgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHMvbm90aWZpY2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENSVURNZXNzYWdlIHtcbiAgICBzdGF0aWMgZXJyb3IoY29udHJvbGxlciwgdGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRVSShcbiAgICAgICAgICAgIFwiX19tZXNzYWdlX19cIixcbiAgICAgICAgICAgIG5ldyBVSUVycm9yKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHsgdGl0bGUsIG1lc3NhZ2UgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHN1Y2Nlc3MoY29udHJvbGxlciwgdGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRVSShcbiAgICAgICAgICAgIFwiX19tZXNzYWdlX19cIixcbiAgICAgICAgICAgIG5ldyBVSVN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBwcm9wczogeyB0aXRsZSwgbWVzc2FnZSB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBub3RMb2NhbGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmltcG9ydCB7IG5vdEZvcm0gfSBmcm9tIFwiLi4vLi4vLi4vY29tcG9uZW50c1wiO1xuaW1wb3J0IHsgREVGQVVMVF9UUkFTRk9STUVSIH0gZnJvbSBcIi4uLy4uL2NvbnN0XCI7XG5pbXBvcnQgeyBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQgfSBmcm9tIFwiLi4vLi4vLi4vY29uc3RcIjtcbmltcG9ydCB7IG1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCA9IFwi0J/RgNC+0YHQvNC+0YLRgFwiO1xuXG4vKipcbiAqIEdlbmVyaWMgQ1JVRCBhY3Rpb24gY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvbiB7XG4gICAgc3RhdGljIGdldCBOQVZJR0FUSU9OX0RFTEFZKCkge1xuICAgICAgICByZXR1cm4gTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGJyZWFkY3J1bWJzIHRhaWwgdGVtcGxhdGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGRlYWZ1bHRCcmVhZGNydW1ic1RhaWwoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWJhcmFyeSBvZiBicmVhZGNydW1icyB0YWlscyBzdHJpbmdzIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBicmVhZGNydW1ic1RhaWxzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlc2V0OiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCxcbiAgICAgICAgICAgIHNldDogJ9Cf0YDQvtGB0LzQvtGC0YAsIFwiezp0aXRsZX1cIicsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZW1wbGF0ZSBvZiBicmVhZGNydW1icyB0YWlsXG4gICAgICogQHBhcmFtICAge3N0cmluZ30gICAgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIHRlbXBsYXRlIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCcmVhZGNydW1ic1RhaWwobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnJlYWRjcnVtYnNUYWlscykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5zZWxlY3QoXG4gICAgICAgICAgICB0aGlzLmJyZWFkY3J1bWJzVGFpbHMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGhpcy5kZWFmdWx0QnJlYWRjcnVtYnNUYWlsXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gQUNUSU9OIHRoaXMgY29udHJvbGxlciBhY3Rpb24gbmFtZSwgdXNlZCBpbiBVUklcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEFDVElPTigpIHtcbiAgICAgICAgcmV0dXJuIFwiZGV0YWlsc1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTiAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9HRVQoKSB7XG4gICAgICAgIHJldHVybiBcImdldFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX1BVVCgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2V0XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7b2JqZWN0fSBVSUNvbnN0cnVjdG9yICAgIGNvbnN0cnVjdG9yIG9mIFVJIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgVUlDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIG5vdEZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge2Z1bmN0aW9ufSAgIFRSQU5TRk9STUVSICAgICByZXNwb25zZS5yZXN1bHQgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gaWYgd2FudCB0byBjaGFuZ2UgaXQncyBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRSQU5TRk9STUVSKCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9UUkFTRk9STUVSO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hbWUgb2YgbW9kZWwgaWRlbnRpZmljYWl0b24gZmllbGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gICAgZGVmYXVsdCBpZCBmaWVsZCBuYW1lIGlzICdfaWQnXG4gICAgICovXG4gICAgc3RhdGljIGdldElkRmllbGQoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5pZEZpZWxkYCwgXCJfaWRcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvYWREYXRhUXVlcnkoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGlkRmllbGQgPSB0aGlzLmdldElkRmllbGQoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiB7IFtpZEZpZWxkXTogcGFyYW1zWzBdIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFByb21pc2Ugb2YgQVBJIHJlcG9uc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBhcnJheSBvZiBzdHJpbmdzIHBhcnNlZCBmcm9tIFVSSSBieSByb3V0ZXIgYW5kIHBhc3NlZCB0byBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9ICAgQVBJIHJlc3BvbnNlIHtzdGF0dXM6c3RyaW5nLCByZXN1bHQ6YW55LCBtZXNzYWdlOnN0cmluZywgZXJyb3JzOiB7W2ZpZWxkbmFtZV06Wy4uLmVycm9yTWVzc2FnZXNdfX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgbG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5sb2FkRGF0YVF1ZXJ5KGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNvbnRyb2xsZXIuZ2V0TW9kZWwocXVlcnkpW2AkJHthY3Rpb25OYW1lfWBdKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtb2RlbCBBUEkgYWN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gICAgbmV0d29yayBpbnRlcmZhY2UgbW9kZWwgYWN0aW9uIG5hbWUsIGZvciBBUEk7IGRlZmF1bHQ6IHRoaXMuTU9ERUxfQUNUSU9OX0dFVFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNb2RlbEFjdGlvbk5hbWUoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5nZXRPcHRpb25zKFxuICAgICAgICAgICAgYCR7dGhpcy5BQ1RJT059LmFjdGlvbk5hbWVgLFxuICAgICAgICAgICAgdGhpcy5NT0RFTF9BQ1RJT05fR0VUXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBicmVhZGNydW1icyB0YWlsLCB3aXRob3V0IHJlc3VsdCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcHJlc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0QnJlYWRjcnVtYnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmdldEJyZWFkY3J1bWJzVGFpbChcInByZXNldFwiKSxcbiAgICAgICAgICAgICAgICB1cmw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxBY3Rpb25VUkwocGFyYW1zWzBdLCBmYWxzZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VGl0bGUoY29udG9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBjb250b2xsZXIuZ2V0SXRlbVRpdGxlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBicmVhZGNydW1icyB0YWlsIHdpdGggcmVzcG9uc2UgZGV0YWlscywgYWthIHRpdGxlIG9mIGxvYWRlZCBpdGVtXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAgICAgQVBJIHJlc3BvbnNlIGluIHdyYXBwZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UucmVzdWx0ICBBUEkgcmVzcG9uc2UgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIHNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICBjb25zdCBicmVhZGNydW1ic1RhaWxUZW1wbGF0ZSA9IHRoaXMuZ2V0QnJlYWRjcnVtYnNUYWlsKFwic2V0XCIpO1xuICAgICAgICBjb250cm9sbGVyLnNldEJyZWFkY3J1bWJzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogYnJlYWRjcnVtYnNUYWlsVGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBub3RMb2NhbGUuZm9ybWF0KGJyZWFkY3J1bWJzVGFpbFRlbXBsYXRlLCB7IHRpdGxlIH0pXG4gICAgICAgICAgICAgICAgICAgIDogdGl0bGUsXG4gICAgICAgICAgICAgICAgdXJsOiBjb250cm9sbGVyLmdldE1vZGVsQWN0aW9uVVJMKHBhcmFtc1swXSwgZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHJlc3BvbnNlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgdHJ1ZSBpZiByZXNwb25zZSBpcyBiYWRcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNSZXNwb25zZUJhZChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnN0YXR1cyAhPT0gXCJva1wiO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRWYWxpZGF0b3JzKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjb250cm9sbGVyLmdldFZhbGlkYXRvcnMgJiYgY29udHJvbGxlci5nZXRWYWxpZGF0b3JzKCkpIHx8XG4gICAgICAgICAgICBjb250cm9sbGVyLmdldE9wdGlvbnMoXCJWYWxpZGF0b3JzXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvYmplY3Qgd2l0aCBhbGwgb3B0aW9ucyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSBVSSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgICAgIEFQSSByZXBvbnNlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgIHVpIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIHByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZGV0YWlsc0FjdGlvbk5hbWUgPSB0aGlzLmdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgbW9kZWw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBkZXRhaWxzQWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtjb250cm9sbGVyLmdldE5hbWUoKX0uJHt0aGlzLkFDVElPTn1Gb3JtYCxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB0aGlzLmdldFZhbGlkYXRvcnMoY29udHJvbGxlciksXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgdmFyaWFudHMuJHt0aGlzLkFDVElPTn1gLCB7fSksXG4gICAgICAgICAgICAgICAgbWFzdGVyczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5tYXN0ZXJzYCwge30pLFxuICAgICAgICAgICAgICAgIGluamVjdGVkOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059LmluamVjdGVkYCwge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuVFJBTlNGT1JNRVIocmVzcG9uc2UucmVzdWx0KSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoaXMgYWN0aW9uIFVJIGNvbXBvbmVudCBmcm9tIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICBpbnN0YW5jZSBvZiBVSSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VUkoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5nZXRVSSh0aGlzLkFDVElPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBVSSBvZiB0aGlzIGFjdGlvbiBpbiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVpICAgICAgICAgICBpbnN0YW5jZSBvZiBVSSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VUkoY29udHJvbGxlciwgdWkpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRVSSh0aGlzLkFDVElPTiwgdWkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIHZpYSBgLiRzZXRgIG1ldGhvZCBgbG9hZGluZ2AgdG8gYHRydWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQG1lbWJlcm9mIENSVURHZW5lcmljQWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHNldFVJTG9hZGluZyhjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0VUkoY29udHJvbGxlcikuJHNldCh7IGxvYWRpbmc6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgdmlhIGAuJHNldGAgbWV0aG9kIGBsb2FkaW5nYCB0byBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQG1lbWJlcm9mIENSVURHZW5lcmljQWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHNldFVJTG9hZGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5nZXRVSShjb250cm9sbGVyKS4kc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgdmlhIGAuJHNldGAgbWV0aG9kIGBlcnJvcmAgdG8gYG1lc3NhZ2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQHBhcmFtICAge0Vycm9yfSBtZXNzYWdlICAgICBlcnJvciBtZXNzYWdlXG4gICAgICogQG1lbWJlcm9mIENSVURHZW5lcmljQWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHNldFVJRXJyb3IoY29udHJvbGxlciwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmdldFVJKGNvbnRyb2xsZXIpLiRzZXQoeyBlcnJvcjogbWVzc2FnZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBldmVudHMgdG8gYWN0aW9uIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAgICAgQVBJIHJlc3BvbnNlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIuZ29CYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInJlamVjdFwiLCAoKSA9PiBjb250cm9sbGVyLmdvQmFjaygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnQgaGFuZGxlciBuYW1lZCBldmVudCB0byBVSS4gQ2hlY2tzIGRpZmZlcmVudCBiaW5kZXIgbm90YXRpb24gJG9uL29uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50ICAgICAgICBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBjYWxsYmFjayBmdW5jdGlvbiBvbiBldmVudFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB1aSA9IHRoaXMuZ2V0VUkoY29udHJvbGxlcik7XG4gICAgICAgIGlmICh1aS4kb24pIHtcbiAgICAgICAgICAgIHJldHVybiB1aS4kb24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkub24pIHtcbiAgICAgICAgICAgIHJldHVybiB1aS5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ1ZSwgaWYgVUkgb2YgdGhpcyBhY3Rpb24gYWxyZWFkeSBleGlzdHMsXG4gICAgICogZmFsc2UsIGlmIFVJIG9mIHRoaXMgYWN0aW9uIHdhc24ndCBleGlzdGVkIGFuZCBvdGhlciBVSXMgd2VyZSBkZXN0b3J5ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICB0cnVlIGlmIFVJIG9mIHRoaXMgYWN0aW9uIGV4aXN0cywgZmFsc2UgaWYgVUkgb2Ygb3RoZXIgd2FzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHN0YXRpYyBpc1VJUmVuZGVyZWQoY29udHJvbGxlcikge1xuICAgICAgICBpZiAodGhpcy5nZXRVSShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIHR3ZWFrVUlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVVJKHVpQ29tcG9uZW50LCBjb250cm9sbGVyLCByZXNwb25zZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyh1aUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3VudChcbiAgICAgICAgICAgICAgICB1aUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1aUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybWluZyBhY3Rpb24gcHJlcGFyYXRpb24gYW5kIHJlbmRlcnMgVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgc3RhcnRpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYmVmb3JlOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2lmIFVJIGZvciB0aGlzIGFjdGlvbiBleGlzdHMgZXhpdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVSVJlbmRlcmVkKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pbmRpY2F0aW5nIHRoYXQgd2UgYXJlIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgICAgIC8vcHJlbG9hZGluZyBmb3JtIHZhcmlhbnRzXG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnByZWxvYWRWYXJpYW50cyh0aGlzLkFDVElPTik7XG4gICAgICAgICAgICAvL3NldHRpbmcgaW5pdGlhbCBzdGF0ZSBvZiBicmVhZGNydW1icyB0YWlsXG4gICAgICAgICAgICB0aGlzLnByZXNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2xvYWRpbmcgZGF0YVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmxvYWREYXRhKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZSBpZiByZXNwb25zZSBpcyAnYmFkJ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNwb25zZUJhZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRpbmcgYnJlYWRjcnVtYnMgdGFpbCB3aXRoIG1vcmUgZGV0YWlscyBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLnNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9jcmVhdGluZyBhY3Rpb24gVUkgY29tcG9uZW50XG4gICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgdWlDb21wb25lbnQgPSB0aGlzLlVJQ29uc3RydWN0b3I7XG4gICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgdWkgPSB0aGlzLmNyZWF0ZVVJKCk7XG4gICAgICAgICAgICB0aGlzLnNldFVJKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgLy9iaW5kIGV2ZW50cyB0byBVSVxuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSByZWFkeVxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBhZnRlcjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pbmZvcm1pbmcgYWJvdXQgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGV4Y2VwdGlvbjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIGUpO1xuICAgICAgICAgICAgLy9yZXBvcnRpbmcgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ29CYWNrQWZ0ZXJEZWxheShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ29CYWNrKHRoaXMuTkFWSUdBVElPTl9ERUxBWSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdvQmFjayhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ29CYWNrKDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREdlbmVyaWNBY3Rpb247XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb24gZnJvbSBcIi4vYWN0aW9uXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmNvbnN0IEFDVElPTiA9IFwiY3JlYXRlXCI7XG5jb25zdCBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCA9IFwi0KHQvtC30LTQsNC90LjQtVwiO1xuXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IGRlYWZ1bHRCcmVhZGNydW1ic1RhaWwoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IGJyZWFkY3J1bWJzVGFpbHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBBQ1RJT04oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX0dFVCgpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTiAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9QVVQoKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vY29udHJvbGxlci5jcnVkJyl9IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge2FueX0gICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFtc11cbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KCdub3Qtbm9kZS9zcmMvdHlwZXMnKS5ub3RBcHBSZXNwb25zZX1cbiAgICAgKi9cbiAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBsb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgZGVmRGF0YSA9IGNvbnRyb2xsZXIuY3JlYXRlRGVmYXVsdCgpO1xuICAgICAgICBpZiAoZGVmRGF0YS5nZXREYXRhKSB7XG4gICAgICAgICAgICBkZWZEYXRhID0gZGVmRGF0YS5nZXREYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgICAgICAgcmVzdWx0OiBkZWZEYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRUaXRsZShjb250b2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRvbGxlci5nZXRJdGVtVGl0bGUocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgbW9kZWw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IGAke2NvbnRyb2xsZXIuZ2V0TmFtZSgpfS4ke3RoaXMuQUNUSU9OfUZvcm1gLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IHRoaXMuZ2V0VmFsaWRhdG9ycyhjb250cm9sbGVyKSxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogY29udHJvbGxlci5nZXRPcHRpb25zKGB2YXJpYW50cy4ke3RoaXMuQUNUSU9OfWAsIHt9KSxcbiAgICAgICAgICAgICAgICBtYXN0ZXJzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059Lm1hc3RlcnNgLCB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogdGhpcy5UUkFOU0ZPUk1FUihyZXNwb25zZSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgZXZlbnRzIHRvIGFjdGlvbiBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Jlc3BvbnNlXSAgICAgQVBJIHJlc3BvbnNlXG4gICAgICovXG4gICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdGF0aWMgYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5nb0JhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwicmVqZWN0XCIsICgpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5nb0JhY2soY29udHJvbGxlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5vbkFjdGlvblN1Ym1pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnQoY29udHJvbGxlciwgXCJzdWJtaXRcIiwgYXN5bmMgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQodGhpcy5BQ1RJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5sb2FkRGF0YVF1ZXJ5KGNvbnRyb2xsZXIsIHBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLmV2LmRldGFpbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvQmFja0FmdGVyRGVsYXkoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENSVURHZW5lcmljQWN0aW9uQ3JlYXRlO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uQ3JlYXRlIGZyb20gXCIuL2dlbmVyaWMvY3JlYXRlXCI7XG5cbmNsYXNzIENSVURBY3Rpb25DcmVhdGUgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSB7fVxuXG5leHBvcnQgZGVmYXVsdCBDUlVEQWN0aW9uQ3JlYXRlO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uIGZyb20gXCIuL2FjdGlvblwiO1xuXG4vKipcbiAqIEdlbmVyaWMgQ1JVRCBEZXRhaWxzIGFjdGlvbiBjbGFzc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIENSVURHZW5lcmljQWN0aW9uUmVhZCBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICBzdGF0aWMgdHdlYWtVSU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLm9wdGlvbnMudWkgPSB7XG4gICAgICAgICAgICBzdWJtaXQ6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1pbmcgYWN0aW9uIHByZXBhcmF0aW9uIGFuZCByZW5kZXJzIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHN0YXJ0aW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGJlZm9yZTpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9pZiBVSSBmb3IgdGhpcyBhY3Rpb24gZXhpc3RzIGV4aXRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVUlSZW5kZXJlZChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaW5kaWNhdGluZyB0aGF0IHdlIGFyZSB3b3JraW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgICAgICAvL3ByZWxvYWRpbmcgZm9ybSB2YXJpYW50c1xuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHModGhpcy5BQ1RJT04pO1xuICAgICAgICAgICAgLy9zZXR0aW5nIGluaXRpYWwgc3RhdGUgb2YgYnJlYWRjcnVtYnMgdGFpbFxuICAgICAgICAgICAgdGhpcy5wcmVzZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9sb2FkaW5nIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5sb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2UgaWYgcmVzcG9uc2UgaXMgJ2JhZCdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2VCYWQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0aW5nIGJyZWFkY3J1bWJzIHRhaWwgd2l0aCBtb3JlIGRldGFpbHMgZnJvbSByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5zZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vY3JlYXRpbmcgYWN0aW9uIFVJIGNvbXBvbmVudFxuICAgICAgICAgICAgY29uc3QgdWlDb21wb25lbnQgPSB0aGlzLlVJQ29uc3RydWN0b3I7XG4gICAgICAgICAgICB0aGlzLnNldFVJKFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgbmV3IHVpQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vYmluZCBldmVudHMgdG8gVUlcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgcmVhZHlcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYWZ0ZXI6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCBlKTtcbiAgICAgICAgICAgIC8vcmVwb3J0aW5nIGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUlVER2VuZXJpY0FjdGlvblJlYWQ7XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb25SZWFkIGZyb20gXCIuL2dlbmVyaWMvcmVhZFwiO1xuXG4vKipcbiAqIENSVUQgYWN0aW9uIGRldGFpbHNcbiAqL1xuY2xhc3MgQ1JVREFjdGlvbkRldGFpbHMgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvblJlYWQge31cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREFjdGlvbkRldGFpbHM7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmltcG9ydCBDUlVER2VuZXJpY0FjdGlvbiBmcm9tIFwiLi9hY3Rpb25cIjtcblxuY29uc3QgREVGQVVMVF9CUkVBRENSVU1CX1RBSUwgPSBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDQvdC40LVcIjtcbi8qKlxuICogR2VuZXJpYyBDUlVEIFVwZGF0ZSBhY3Rpb24gY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGJyZWFkY3J1bWJzIHRhaWwgdGVtcGxhdGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGRlYWZ1bHRCcmVhZGNydW1ic1RhaWwoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWJhcmFyeSBvZiBicmVhZGNydW1icyB0YWlscyBzdHJpbmdzIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBicmVhZGNydW1ic1RhaWxzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlc2V0OiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCxcbiAgICAgICAgICAgIHNldDogYCR7REVGQVVMVF9CUkVBRENSVU1CX1RBSUx9OiBcIns6dGl0bGV9XCJgLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gQUNUSU9OIHRoaXMgY29udHJvbGxlciBhY3Rpb24gbmFtZSwgdXNlZCBpbiBVUklcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEFDVElPTigpIHtcbiAgICAgICAgcmV0dXJuIFwidXBkYXRlXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT05fR0VUICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX0dFVCgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2V0UmF3XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT05fUFVUICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX1BVVCgpIHtcbiAgICAgICAgcmV0dXJuIFwidXBkYXRlXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvYmplY3Qgd2l0aCBhbGwgb3B0aW9ucyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSBVSSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgICAgIEFQSSByZXBvbnNlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgIHVpIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIHByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgbW9kZWw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLk1PREVMX0FDVElPTl9QVVQsIC8vd2lsbCBiZSB1c2VkIHRvIGdldCBmb3JtIGZpZWxkcyBpbmZvcm1hdGlvbiBmcm9tIG1hbmlmZXN0XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7Y29udHJvbGxlci5nZXROYW1lKCl9LiR7dGhpcy5BQ1RJT059Rm9ybWAsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogdGhpcy5nZXRWYWxpZGF0b3JzKGNvbnRyb2xsZXIpLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYHZhcmlhbnRzLiR7dGhpcy5BQ1RJT059YCwge30pLFxuICAgICAgICAgICAgICAgIHVpOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059LnVpYCwge30pLFxuICAgICAgICAgICAgICAgIGZpZWxkczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5maWVsZHNgLCB7fSksXG4gICAgICAgICAgICAgICAgbWFzdGVyczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5tYXN0ZXJzYCwge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuVFJBTlNGT1JNRVIobm90Q29tbW9uLnN0cmlwUHJveHkocmVzcG9uc2UucmVzdWx0KSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgZXZlbnRzIHRvIGFjdGlvbiBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Jlc3BvbnNlXSAgICAgQVBJIHJlc3BvbnNlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIuZ29CYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInJlamVjdFwiLCAoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZ29CYWNrKGNvbnRyb2xsZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwic3VibWl0XCIsIGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KHRoaXMuQUNUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMubG9hZERhdGFRdWVyeShjb250cm9sbGVyLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi5ldi5kZXRhaWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb0JhY2tBZnRlckRlbGF5KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ1ZSwgaWYgVUkgb2YgdGhpcyBhY3Rpb24gYWxyZWFkeSBleGlzdHMsXG4gICAgICogZmFsc2UsIGlmIFVJIG9mIHRoaXMgYWN0aW9uIHdhc24ndCBleGlzdGVkIGFuZCBvdGhlciBVSXMgd2VyZSBkZXN0b3J5ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICB0cnVlIGlmIFVJIG9mIHRoaXMgYWN0aW9uIGV4aXN0cywgZmFsc2UgaWYgVUkgb2Ygb3RoZXIgd2FzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHN0YXRpYyBpc1VJUmVuZGVyZWQoY29udHJvbGxlcikge1xuICAgICAgICBpZiAodGhpcy5nZXRVSShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybWluZyBhY3Rpb24gcHJlcGFyYXRpb24gYW5kIHJlbmRlcnMgVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgc3RhcnRpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYmVmb3JlOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIFtwYXJhbXNdKTtcbiAgICAgICAgICAgIC8vaWYgVUkgZm9yIHRoaXMgYWN0aW9uIGV4aXN0cyBleGl0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VJUmVuZGVyZWQoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2luZGljYXRpbmcgdGhhdCB3ZSBhcmUgd29ya2luZ1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICAgICAgLy9wcmVsb2FkaW5nIGZvcm0gdmFyaWFudHNcbiAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKHRoaXMuQUNUSU9OKTtcbiAgICAgICAgICAgIC8vc2V0dGluZyBpbml0aWFsIHN0YXRlIG9mIGJyZWFkY3J1bWJzIHRhaWxcbiAgICAgICAgICAgIHRoaXMucHJlc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vbG9hZGluZyBkYXRhXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlIGlmIHJlc3BvbnNlIGlzICdiYWQnXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jlc3BvbnNlQmFkKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cGRhdGluZyBicmVhZGNydW1icyB0YWlsIHdpdGggbW9yZSBkZXRhaWxzIGZyb20gcmVzcG9uc2VcbiAgICAgICAgICAgIHRoaXMuc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2NyZWF0aW5nIGFjdGlvbiBVSSBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbnN0IHVpQ29tcG9uZW50ID0gdGhpcy5VSUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy5zZXRVSShcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgIG5ldyB1aUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50d2Vha1VJT3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL2JpbmQgZXZlbnRzIHRvIFVJXG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHJlYWR5XG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGFmdGVyOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCBlKTtcbiAgICAgICAgICAgIC8vcmVwb3J0aW5nIGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZTtcbiIsImltcG9ydCBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSBmcm9tIFwiLi9nZW5lcmljL3VwZGF0ZVwiO1xuXG4vKipcbiAqIENSVUQgYWN0aW9uIHVwZGF0ZVxuICovXG5jbGFzcyBDUlVEQWN0aW9uVXBkYXRlIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGUge31cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREFjdGlvblVwZGF0ZTtcbiIsImltcG9ydCBub3RBY3Rpb25VSSBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9hY3Rpb24vYWN0aW9uLnVpLmpzXCI7XG5cbmNvbnN0IEFDVElPTiA9IFwiZGVsZXRlXCI7XG5jb25zdCBNT0RFTF9BQ1RJT04gPSBcImRlbGV0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUlVEQWN0aW9uRGVsZXRlIHtcbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudWlbQUNUSU9OXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXSA9IG5ldyBub3RBY3Rpb25VSSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDUlVERGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZXJTdHlsZTogXCJjb250YWluZXJcIixcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyVGl0bGU6IFwibm90LW5vZGU6Y3J1ZF9kZWxldGVfYWN0aW9uX3dhaXRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogYGNydWQtZGVsZXRlLWFjdGlvbi0ke3BhcmFtc1swXX1gLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCLQo9C00LDQu9C10L3QuNC1XCIsXG4gICAgICAgICAgICAgICAgICAgIHVybDogY29udHJvbGxlci5nZXRNb2RlbEFjdGlvblVSTChwYXJhbXNbMF0sIEFDVElPTiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINC30LDQv9C40YHRjD9cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVBY3Rpb25OYW1lID0gY29udHJvbGxlci5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICBgJHtBQ1RJT059LmFjdGlvbk5hbWVgLFxuICAgICAgICAgICAgICAgICAgICBNT0RFTF9BQ1RJT05cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVBY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IHBhcmFtc1swXSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5nb0xpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5nb0xpc3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBub3RUYWJsZSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzXCI7XG5cbmNvbnN0IEFDVElPTiA9IFwibGlzdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUlVEQWN0aW9uTGlzdCB7XG4gICAgc3RhdGljIHR3ZWFrQWN0aW9uc0xpc3QoY29udHJvbGxlciwgQUNUSU9OU19MSVNUKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7QUNUSU9OfS5jcmVhdGVBY3Rpb25gLCB0cnVlKSkge1xuICAgICAgICAgICAgQUNUSU9OU19MSVNULnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCh0L7Qt9C00LDRgtGMXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBjb250cm9sbGVyLmdvQ3JlYXRlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUNUSU9OU19MSVNUO1xuICAgIH1cblxuICAgIHN0YXRpYyB0d2Vha1VJT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvbnRyb2xsZXIuY3J1ZCcpLmRlZmF1bHR9IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbYWN0aW9ucz1bXCJkZXRhaWxzXCIsIFwidXBkYXRlXCIsIFwiZGVsZXRlXCJdXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gW3ByZXBlbmQ9W11dXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBbYXBwZW5kPVtdXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29ubHlJY29ucz10cnVlXVxuICAgICAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59XG4gICAgICogQG1lbWJlcm9mIENSVURBY3Rpb25MaXN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFjdGlvbnNCdXR0b25zKFxuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICBhY3Rpb25zID0gW1wiZGV0YWlsc1wiLCBcInVwZGF0ZVwiLCBcImRlbGV0ZVwiXSxcbiAgICAgICAgcHJlcGVuZCA9IFtdLFxuICAgICAgICBhcHBlbmQgPSBbXSxcbiAgICAgICAgb25seUljb25zID0gdHJ1ZVxuICAgICkge1xuICAgICAgICBjb25zdCBBQ1RJT05TID0ge1xuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb0RldGFpbHModmFsdWUsIGRlbGF5KSxcbiAgICAgICAgICAgICAgICAuLi4ob25seUljb25zXG4gICAgICAgICAgICAgICAgICAgID8geyBpY29uOiBcImNpcmNsZS1pbmZvXCIgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgdGl0bGU6IFwi0J/QvtC00YDQvtCx0L3QtdC1XCIgfSksXG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb1VwZGF0ZSh2YWx1ZSwgZGVsYXkpLFxuICAgICAgICAgICAgICAgIC4uLihvbmx5SWNvbnMgPyB7IGljb246IFwiZWRpdFwiIH0gOiB7IHRpdGxlOiBcItCY0LfQvNC10L3QuNGC0YxcIiB9KSxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb0RlbGV0ZSh2YWx1ZSwgZGVsYXkpLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgICAgIC4uLihvbmx5SWNvbnMgPyB7IGljb246IFwidHJhc2hcIiB9IDogeyB0aXRsZTogXCLQo9C00LDQu9C40YLRjFwiIH0pLFxuICAgICAgICAgICAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJvdXRsaW5lZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0aW9uc0J1dHRvbnMgPSBbLi4ucHJlcGVuZF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XG4gICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goKGFjdGlvbk5hbWUpID0+XG4gICAgICAgICAgICAgICAgYWN0aW9uc0J1dHRvbnMucHVzaChBQ1RJT05TW2FjdGlvbk5hbWVdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zQnV0dG9ucy5wdXNoKC4uLmFwcGVuZCk7XG4gICAgICAgIHJldHVybiBhY3Rpb25zQnV0dG9ucztcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmRpY2F0aW5nIHRoYXQgd2UgYXJlIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4oKTtcblxuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHMoQUNUSU9OKTtcblxuICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCLQodC/0LjRgdC+0LpcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjb250cm9sbGVyLmdldE1vZGVsVVJMKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci51aVtBQ1RJT05dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dID0gbmV3IG5vdFRhYmxlKFxuICAgICAgICAgICAgICAgIHRoaXMudHdlYWtVSU9wdGlvbnMoQ1JVREFjdGlvbkxpc3QucHJlcGFyZU9wdGlvbnMoY29udHJvbGxlcikpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoXG4gICAgICAgICAgICAgICAgYGFmdGVyOnJlbmRlcjoke0FDVElPTn1gLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnVpW0FDVElPTl1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7QUNUSU9OfWAsIHBhcmFtcywgZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlT3B0aW9ucyhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IERFRkFVTFRfT1BUSU9OU19UQUJMRSA9IHtcbiAgICAgICAgICAgIGludGVyZmFjZTogY29udHJvbGxlci5nZXRPcHRpb25zKGAke0FDVElPTn0uaW50ZXJmYWNlYCwge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZhY3Rvcnk6IGNvbnRyb2xsZXIuZ2V0SW50ZXJmYWNlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZpZWxkczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2hvd1NlbGVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ2V0SXRlbUlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpZEZpZWxkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVsb2FkOiB7fSxcbiAgICAgICAgICAgIGZpbHRlclVJOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7QUNUSU9OfS5maWx0ZXJVSWApLFxuICAgICAgICAgICAgcGFnZXI6IHsgc2l6ZTogNTAsIHBhZ2U6IDAgfSxcbiAgICAgICAgICAgIHNvcnRlcjoge1xuICAgICAgICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVpOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vZm9ybWluZyBhY3Rpb25zIGJ1dHRvbnMgbGlzdFxuICAgICAgICBsZXQgQUNUSU9OU19MSVNUID0gWy4uLmNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHtBQ1RJT059LmFjdGlvbnNgLCBbXSldO1xuICAgICAgICBBQ1RJT05TX0xJU1QgPSB0aGlzLnR3ZWFrQWN0aW9uc0xpc3QoY29udHJvbGxlciwgQUNUSU9OU19MSVNUKTtcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgVEFCTEVfT1BUSU9OUyA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBlbmRsZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBBQ1RJT05TX0xJU1QsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhERUZBVUxUX09QVElPTlNfVEFCTEUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IG9wdFZhbCA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBgJHtBQ1RJT059LiR7a2V5fWAsXG4gICAgICAgICAgICAgICAgREVGQVVMVF9PUFRJT05TX1RBQkxFW2tleV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdFZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIFRBQkxFX09QVElPTlMub3B0aW9uc1trZXldID0gb3B0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRBQkxFX09QVElPTlM7XG4gICAgfVxufVxuIiwiaW1wb3J0IENSVURBY3Rpb25DcmVhdGUgZnJvbSBcIi4vY3JlYXRlXCI7XG5pbXBvcnQgQ1JVREFjdGlvbkRldGFpbHMgZnJvbSBcIi4vZGV0YWlsc1wiO1xuaW1wb3J0IENSVURBY3Rpb25VcGRhdGUgZnJvbSBcIi4vdXBkYXRlXCI7XG5pbXBvcnQgQ1JVREFjdGlvbkRlbGV0ZSBmcm9tIFwiLi9kZWxldGVcIjtcbmltcG9ydCBDUlVEQWN0aW9uTGlzdCBmcm9tIFwiLi9saXN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGU6IENSVURBY3Rpb25DcmVhdGUsXG4gICAgZGV0YWlsczogQ1JVREFjdGlvbkRldGFpbHMsXG4gICAgdXBkYXRlOiBDUlVEQWN0aW9uVXBkYXRlLFxuICAgIGRlbGV0ZTogQ1JVREFjdGlvbkRlbGV0ZSxcbiAgICBsaXN0OiBDUlVEQWN0aW9uTGlzdCxcbn07XG4iLCJpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uL2VsZW1lbnRzL2NvbW1vblwiO1xuXG5pbXBvcnQgbm90QnJlYWRjcnVtYnMgZnJvbSBcIi4uL2NvbXBvbmVudHMvYnJlYWRjcnVtYnNcIjtcblxuaW1wb3J0IFVJTG9hZGVyIGZyb20gXCIuLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmxvYWRlci5zdmVsdGVcIjtcblxuaW1wb3J0IG5vdENvbnRyb2xsZXIgZnJvbSBcIi4uL2NvbnRyb2xsZXJcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG5pbXBvcnQgQ1JVRFZhcmlhbnRzUHJlbG9hZGVyIGZyb20gXCIuL3ZhcmlhbnRzLnByZWxvYWRlci5qc1wiO1xuaW1wb3J0IENSVURSb3V0ZXIgZnJvbSBcIi4vcm91dGVyLmpzXCI7XG5pbXBvcnQgQ1JVRE1lc3NhZ2UgZnJvbSBcIi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IENSVURBY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmltcG9ydCB7IG1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBCUkVBRENSVU1CUyA9IFtdO1xuY29uc3QgVElUTEVfRklFTERTX1BSSU9SSVRZID0gW1widGl0bGVcIiwgXCJsYWJlbFwiLCBcImlkXCIsIFwibmFtZVwiXTtcblxuY29uc3QgTE9BRElOR19TQ1JFRU5fVUlfTkFNRSA9IFwibG9hZGluZ19zY3JlZW5cIjtcblxuY2xhc3Mgbm90Q1JVRCBleHRlbmRzIG5vdENvbnRyb2xsZXIge1xuICAgICNhY3Rpb25zID0geyAuLi5DUlVEQWN0aW9ucyB9O1xuICAgICNyb3V0ZXIgPSBDUlVEUm91dGVyO1xuICAgICNwcmVsb2FkZXIgPSBDUlVEVmFyaWFudHNQcmVsb2FkZXI7XG5cbiAgICBUSVRMRV9GSUVMRFNfUFJJT1JJVFkgPSBUSVRMRV9GSUVMRFNfUFJJT1JJVFk7XG5cbiAgICBzdGF0aWMgRVJST1JfREVGQVVMVCA9IFVJQ29tbW9uLkVSUk9SX0RFRkFVTFQ7XG5cbiAgICBUT1BfQ0xBU1MgPSBbXCJib3hcIl07XG4gICAgTUFJTl9DTEFTUyA9IFtcImJveFwiXTtcbiAgICBCT1RUT01fQ0xBU1MgPSBbXCJib3hcIl07XG5cbiAgICBXU19DSEVDS19JTlRFUlZBTCA9IDIwMDtcblxuICAgIHN0YXRpYyBnZXQgTEFCRUxTKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBwbHVyYWw6IGAke3RoaXMuTU9EVUxFX05BTUV9OiR7dGhpcy5NT0RFTF9OQU1FfV9sYWJlbF9wbHVyYWxgLFxuICAgICAgICAgICAgc2luZ2xlOiBgJHt0aGlzLk1PRFVMRV9OQU1FfToke3RoaXMuTU9ERUxfTkFNRX1fbGFiZWxfc2luZ2xlYCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1lbnUoaXRlbUN1c3RvbVByb3BzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uOiB0aGlzLk1PRFVMRV9OQU1FLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLkxBQkVMUy5wbHVyYWwsXG4gICAgICAgICAgICAgICAgdXJsOiBgLyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX05BTUVcbiAgICAgICAgICAgICAgICApfS8ke25vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHRoaXMuTU9ERUxfTkFNRSl9YCxcbiAgICAgICAgICAgICAgICAuLi5pdGVtQ3VzdG9tUHJvcHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBhcHAsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHsgYWN0aW9ucywgcm91dGVyLCBwcmVsb2FkZXIgfSA9IHtcbiAgICAgICAgICAgIGFjdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJvdXRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlbG9hZGVyOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICApIHtcbiAgICAgICAgc3VwZXIoYXBwLCBgQ1JVRC4ke25hbWV9YCk7XG4gICAgICAgIGlmIChhY3Rpb25zKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLiNhY3Rpb25zID0geyAuLi50aGlzLiNhY3Rpb25zLCAuLi5hY3Rpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlcikge1xuICAgICAgICAgICAgdGhpcy4jcm91dGVyID0gcm91dGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVsb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3ByZWxvYWRlciA9IHByZWxvYWRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpID0ge307XG4gICAgICAgIHRoaXMuZWxzID0ge307XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcIm5hbWVzXCIsIHtcbiAgICAgICAgICAgIG1vZHVsZTogXCJcIixcbiAgICAgICAgICAgIHBsdXJhbDogXCJwbHVyYWxcIixcbiAgICAgICAgICAgIHNpbmdsZTogXCJzaW5nbGVcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcbiAgICAgICAgICAgIFwiY29udGFpbmVyU2VsZWN0b3JcIixcbiAgICAgICAgICAgIHRoaXMuYXBwPy5nZXRPcHRpb25zKFwiY3J1ZC5jb250YWluZXJTZWxlY3RvclwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmJ1aWxkRnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIC8vbm90LW1vZHVsZS1uYW1lIC0+IFtub3QsbW9kdWxlLG5hbWVdXG4gICAgICAgIGNvbnN0IE1vZHVsZU5hbWVQYXJ0cyA9IHRoaXMuZ2V0TW9kdWxlTmFtZSgpLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgLy9bbm90LG1vZHVsZSxuYW1lXSAtPiBNb2R1bGVOYW1lXG4gICAgICAgIGNvbnN0IE1vZHVsZU5hbWUgPSAoXG4gICAgICAgICAgICBNb2R1bGVOYW1lUGFydHNbMF0gPT09IFwibm90XCJcbiAgICAgICAgICAgICAgICA/IE1vZHVsZU5hbWVQYXJ0cy5zcGxpY2UoMSlcbiAgICAgICAgICAgICAgICA6IE1vZHVsZU5hbWVQYXJ0c1xuICAgICAgICApXG4gICAgICAgICAgICAubWFwKG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIpXG4gICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgY29uc3Qgc2VydmljZU5hbWUgPSBgbnMke01vZHVsZU5hbWV9Q29tbW9uYDtcbiAgICAgICAgY29uc3QgQ29tbW9uTW9kdWxlU2VydmljZSA9IHRoaXMuYXBwPy5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgXCJ2YWxpZGF0b3JzXCIsXG4gICAgICAgICAgICBDb21tb25Nb2R1bGVTZXJ2aWNlLmF1Z21lbnRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0VmFsaWRhdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInZhbGlkYXRvcnNcIik7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGxldCBuZXdIZWFkID0gW107XG4gICAgICAgIGlmICh0aGlzLmdldE1vZHVsZU5hbWUoKSAmJiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lcy5tb2R1bGVcIikpIHtcbiAgICAgICAgICAgIG5ld0hlYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuZ2V0T3B0aW9ucyhcIm5hbWVzLm1vZHVsZVwiKSxcbiAgICAgICAgICAgICAgICB1cmw6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SGVhZC5wdXNoKHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lcy5wbHVyYWxcIiksXG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0TW9kZWxVUkwoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIEJSRUFEQ1JVTUJTLnNwbGljZSgwLCBCUkVBRENSVU1CUy5sZW5ndGgsIC4uLm5ld0hlYWQpO1xuICAgICAgICBub3RCcmVhZGNydW1icy5zZXRIZWFkKEJSRUFEQ1JVTUJTKS5yZW5kZXIoe1xuICAgICAgICAgICAgcm9vdDogXCJcIixcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5lbHMudG9wLFxuICAgICAgICAgICAgbmF2aWdhdGU6ICh1cmwpID0+IHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpLm5hdmlnYXRlKHVybCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvdXRlKHRoaXMuZ2V0T3B0aW9ucyhcInBhcmFtc1wiKSk7XG4gICAgfVxuXG4gICAgc3RhcnRXaGVuV1NDbGllbnRSZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwPy5nZXRXU0NsaWVudCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHA/LmdldFdTQ2xpZW50KCkuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBcbiAgICAgICAgICAgICAgICAgICAgLmdldFdTQ2xpZW50KClcbiAgICAgICAgICAgICAgICAgICAgLm9uY2UoXCJjb25uZWN0ZWRcIiwgdGhpcy5zdGFydFdoZW5XU0NsaWVudFJlYWR5LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnN0YXJ0V2hlbldTQ2xpZW50UmVhZHkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLldTX0NIRUNLX0lOVEVSVkFMXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QnJlYWRjcnVtYnModGFpbCkge1xuICAgICAgICBub3RCcmVhZGNydW1icy5zZXRUYWlsKHRhaWwpLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGJhY2tUb0xpc3QoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5saW5rQmFja1RvTGlzdCgpKTtcbiAgICB9XG5cbiAgICBsaW5rQmFja1RvTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWxVUkwoKTtcbiAgICB9XG5cbiAgICBhZnRlckFjdGlvbihhY3Rpb24gPSBcImxpc3RcIikge1xuICAgICAgICBsZXQgbmF2QmFjayA9IHRoaXMuYXBwPy5nZXRPcHRpb25zKFwiY3J1ZC5uYXZpZ2F0ZUJhY2tBZnRlclwiLCBbXSk7XG4gICAgICAgIGlmIChuYXZCYWNrICYmIEFycmF5LmlzQXJyYXkobmF2QmFjaykgJiYgbmF2QmFjay5pbmRleE9mKGFjdGlvbikgPiAtMSkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYWNrVG9MaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBidWlsZEZyYW1lKCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgdGhpcy5hcHA/LmdldE9wdGlvbnMoXCJjcnVkLmNvbnRhaW5lclNlbGVjdG9yXCIsIFwiYm9keVwiKVxuICAgICAgICApO1xuICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbHMudG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbHMudG9wLmlkID0gXCJjcnVkLXRvcFwiO1xuICAgICAgICB0aGlzLmdldEZyYW1lQ2xhc3NlcygpLlRPUF9DTEFTUy5mb3JFYWNoKChuYW1lKSA9PlxuICAgICAgICAgICAgdGhpcy5lbHMudG9wLmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5lbHMudG9wKTtcbiAgICAgICAgdGhpcy5lbHMubWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWxzLm1haW4uaWQgPSBcImNydWQtbWFpblwiO1xuICAgICAgICB0aGlzLmdldEZyYW1lQ2xhc3NlcygpLk1BSU5fQ0xBU1MuZm9yRWFjaCgobmFtZSkgPT5cbiAgICAgICAgICAgIHRoaXMuZWxzLm1haW4uY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICApO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmVscy5tYWluKTtcbiAgICAgICAgdGhpcy5lbHMuYm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbHMuYm90dG9tLmlkID0gXCJjcnVkLWJvdHRvbVwiO1xuICAgICAgICB0aGlzLmdldEZyYW1lQ2xhc3NlcygpLkJPVFRPTV9DTEFTUy5mb3JFYWNoKChuYW1lKSA9PlxuICAgICAgICAgICAgdGhpcy5lbHMuYm90dG9tLmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5lbHMuYm90dG9tKTtcbiAgICB9XG5cbiAgICBnZXRGcmFtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUT1BfQ0xBU1M6IHRoaXMuVE9QX0NMQVNTLFxuICAgICAgICAgICAgTUFJTl9DTEFTUzogdGhpcy5NQUlOX0NMQVNTLFxuICAgICAgICAgICAgQk9UVE9NX0NMQVNTOiB0aGlzLkJPVFRPTV9DTEFTUyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXRDb250YWluZXJUb3BFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHMudG9wO1xuICAgIH1cblxuICAgIGdldENvbnRhaW5lcklubmVyRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxzLm1haW47XG4gICAgfVxuXG4gICAgZ2V0Q29udGFpbmVyQm90dG9tRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxzLmJvdHRvbTtcbiAgICB9XG5cbiAgICBhc3luYyBwcmVsb2FkVmFyaWFudHModHlwZSA9IFwibGlzdFwiKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3ByZWxvYWRlci5wcmVsb2FkKHRoaXMsIHR5cGUpO1xuICAgIH1cblxuICAgIGdldFRpdGxlRnJvbUxpYihwcm9wTmFtZSwgaWQpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0Q3VycmVudEFjdGlvbigpO1xuICAgICAgICB0aGlzLmRlYnVnICYmXG4gICAgICAgICAgICB0aGlzLmRlYnVnKFxuICAgICAgICAgICAgICAgIFwibm90Q1JVRC5nZXRUaXRsZUZyb21MaWIgaXMgb2Jzb2xldGUsIHVzZSBub3RDUlVELmdldFByZWxvYWRlZFZhcmlhbnRUaXRsZShhY3Rpb25OYW1lLCBwcm9wTmFtZSwgaWQpXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByZWxvYWRlZFZhcmlhbnRUaXRsZShhY3Rpb25OYW1lLCBwcm9wTmFtZSwgaWQpO1xuICAgIH1cblxuICAgIGdldFByZWxvYWRlZFZhcmlhbnRzKGFjdGlvbk5hbWUsIHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoYHZhcmlhbnRzLiR7YWN0aW9uTmFtZX0uJHtwcm9wTmFtZX1gLCBbXSk7XG4gICAgfVxuXG4gICAgZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlKGFjdGlvbk5hbWUsIHByb3BOYW1lLCBpZCkge1xuICAgICAgICBjb25zdCB2YXJpYW50cyA9IHRoaXMuZ2V0UHJlbG9hZGVkVmFyaWFudHMoYWN0aW9uTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICBjb25zdCBpdGVtID0gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udGl0bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJdGVtVGl0bGUoaXRlbSkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLlRJVExFX0ZJRUxEU19QUklPUklUWS5maW5kKChrZXkpID0+XG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGl0ZW0sIGtleSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bZmllbGROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwoe30pLnRvRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJvdXRlKHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcm91dGVyLnJvdXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0KGUpO1xuICAgICAgICAgICAgdGhpcy5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uSGFuZGxlckV4aXN0cyhhY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLiNhY3Rpb25zKS5pbmNsdWRlcyhhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIHRoaXNbXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoYWN0aW9uTmFtZSldID09PVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJ1bkFjdGlvbihhY3Rpb25OYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuI2FjdGlvbnMpLmluY2x1ZGVzKGFjdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYWN0aW9uc1thY3Rpb25OYW1lXS5ydW4odGhpcywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzW1wicnVuXCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbk5hbWUpXSA9PT1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wicnVuXCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbk5hbWUpXShcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE5vIHN1Y2ggYWN0aW9uOiAke2FjdGlvbk5hbWV9IGluIGNvbnRvbGxlciAke3RoaXMuZ2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBjcmVhdGUgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbZGVsYXk9MF0gbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb0NyZWF0ZShkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChcIlwiLCBcImNyZWF0ZVwiKSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50IGRldGFpbHMgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgaWQgICAgICAgICAgdGFyZ2V0IGRvY3VtZW50IGlkXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gIFtkZWxheT0wXSAgIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29EZXRhaWxzKGlkLCBkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChpZCwgXCJcIiksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50IHVwZGF0ZSBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBpZCAgICAgICAgICB0YXJnZXQgZG9jdW1lbnQgaWRcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgW2RlbGF5PTBdICAgbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb1VwZGF0ZShpZCwgZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29BZnRlckRlbGF5KHRoaXMuZ2V0TW9kZWxBY3Rpb25VUkwoaWQsIFwidXBkYXRlXCIpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENoYW5nZXMgbG9jYXRpb24gdG8gZG9jdW1lbnQgZGVsZXRlIHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgIGlkICAgICAgICAgIHRhcmdldCBkb2N1bWVudCBpZFxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvRGVsZXRlKGlkLCBkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChpZCwgXCJkZWxldGVcIiksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudHMgbGlzdCBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvTGlzdChkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbFVSTCgpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBkZWxheVxuICAgICAqL1xuICAgIGdvQWZ0ZXJEZWxheSh1cmwsIGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksICgpID0+IHRoaXMuJGRlc3Ryb3lVSSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudHMgbGlzdCBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvQmFjayhkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0xpc3QoZGVsYXkpO1xuICAgIH1cblxuICAgIGFzeW5jIG9uQWN0aW9uU3VibWl0KGFjdGlvbiwgaXRlbSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBhY3Rpb25VSSA9IHRoaXMudWlbYWN0aW9uXTtcbiAgICAgICAgaWYgKGFjdGlvblVJKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFjdGlvblVJLnNldExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRNb2RlbChpdGVtKVtgJCR7YWN0aW9ufWBdKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBhY3Rpb25VSS5wcm9jZXNzUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBhY3Rpb25VSS5wcm9jZXNzUmVzdWx0KGUpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhY3Rpb25VSS5yZXNldExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWZpbmFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3Rpb24gVUkgZG9lc250IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJGRlc3Ryb3lVSSgpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnVpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lVSUJ5TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3lVSUJ5TmFtZShuYW1lKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odGhpcy51aSwgbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3kgJiYgdGhpcy51aVtuYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy51aVtuYW1lXS5kZXN0cm95ICYmIHRoaXMudWlbbmFtZV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudWlbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaG93RXJyb3JNZXNzYWdlKHJlcykge1xuICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IocmVzKTtcbiAgICAgICAgdGhpcy5hcHAgJiZcbiAgICAgICAgICAgIHRoaXMuYXBwLmVtaXQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwi0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlcy5tZXNzYWdlID8gcmVzLm1lc3NhZ2UgOiBVSUNvbW1vbi5FUlJPUl9ERUZBVUxULFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIENSVURNZXNzYWdlLmVycm9yKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIFwi0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsFwiLFxuICAgICAgICAgICAgcmVzLm1lc3NhZ2UgPyByZXMubWVzc2FnZSA6IFVJQ29tbW9uLkVSUk9SX0RFRkFVTFRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzaG93U3VjY2Vzc01lc3NhZ2UodGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5hcHAgJiYgdGhpcy5hcHAuZW1pdChcInN1Y2Nlc3NcIiwgeyB0aXRsZSwgbWVzc2FnZSB9KTtcbiAgICAgICAgQ1JVRE1lc3NhZ2Uuc3VjY2Vzcyh0aGlzLCB0aXRsZSwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgc2V0VUkobmFtZSwgdmFsLCBzaW5nbGVVSSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHNpbmdsZVVJKSB7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95VUkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpW25hbWVdID0gdmFsO1xuICAgIH1cblxuICAgIGdldFVJKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWlbbmFtZV07XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uVUkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpW3RoaXMuZ2V0Q3VycmVudEFjdGlvbigpXTtcbiAgICB9XG5cbiAgICByZW5kZXJMb2FkaW5nU2NyZWVuKCkge1xuICAgICAgICB0aGlzLnNldFVJKExPQURJTkdfU0NSRUVOX1VJX05BTUUsIHRoaXMuY3JlYXRlTG9hZGVyVUkoKSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlTG9hZGluZ1NjcmVlbigpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95VUlCeU5hbWUoTE9BRElOR19TQ1JFRU5fVUlfTkFNRSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTG9hZGVyVUkoKSB7XG4gICAgICAgIHJldHVybiBtb3VudChVSUxvYWRlciwge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RDUlVEO1xuIiwiY29uc3QgUk9VVEVfTElTVCA9IFwibGlzdFwiO1xuLyoqXG4gKiBSdW5zIGNvbnRyb2xsZXIgYWN0aW9uIGJ5IG5hbWUgdGhhdCBnZXRzIGZyb20gVVJJIHBhcmFtc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdENSVURQbGFpblJvdXRlciB7XG4gICAgc3RhdGljIERFRkFVTFRfUk9VVEUgPSBST1VURV9MSVNUO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaXRlbSBmcm9tIHBhcmFtcyBvciB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgYXJyYXkgb2Ygc3RyaW5ncyBwYXJzZWQgZnJvbSBVUkkgYnkgcm91dGUgcnVsZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBleHRyYWN0QWN0aW9uTmFtZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLkRFRkFVTFRfUk9VVEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBjb250cm9sbGVyIGFjdGlvbiBvciB0aHJvd3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIG5vdENvbnRyb2xsZXIgZGVzY2VuZGFudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyByb3V0ZShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmV4dHJhY3RBY3Rpb25OYW1lKHBhcmFtcyk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNldEN1cnJlbnRBY3Rpb24oYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5ydW5BY3Rpb24oYWN0aW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVURQbGFpblJvdXRlcjtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4vKipcbiAqIFJ1bnMgY29udHJvbGxlciBhY3Rpb24gYnkgbmFtZSB0aGF0IGdldHMgZnJvbSBVUkkgcGFyYW1zXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3Mgbm90Q1JVRFJvdXRlclN3aXRjaCB7XG4gICAgLyoqXG4gICAgICogVmFyaWFudHMgb2YgdGhpcyBhY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJvdXRlc1ZhcmlhbnRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICByb3V0ZU5hbWU6IEFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHZhcmlhbnQgbmFtZSBpcyB2YWxpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgIG5hbWUgb2Ygcm91dGUgdmFyaWFudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1JvdXRlVmFyaWFudFZhbGlkKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgIT09IFwiXCIgJiYgbm90Q29tbW9uLm9iakhhcyh0aGlzLnJvdXRlc1ZhcmlhbnRzLCBuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgd2hpY2ggb2Ygcm91dGVzIHZhcmlhbnQgc2hvdWxkIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBub3RDb250cm9sbGVyIGRlc2NlbmRhbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSAgICBwYXJhbXMgIHBhcmFtcyBwYXNzZWQgdG8gcm91dGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gICAgbmFtZSBvZiByb3V0ZSB2YXJpYW50XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGFzeW5jIGRldGVybWluZVJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgY29udHJvbGxlciBhY3Rpb24gb3IgdGhyb3dzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBub3RDb250cm9sbGVyIGRlc2NlbmRhbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcm91dGUoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gYXdhaXQgdGhpcy5kZXRlcm1pbmVSb3V0ZShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSb3V0ZVZhcmlhbnRWYWxpZChhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJBY3Rpb24gPSB0aGlzLnJvdXRlc1ZhcmlhbnRzW2FjdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNBc3luYyhyb3V0ZXJBY3Rpb24ucnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZXJBY3Rpb24ucnVuKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyQWN0aW9uLnJ1bihjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgTm8gc3VjaCBhY3Rpb246ICR7YWN0aW9uTmFtZX0gaW4gY29udG9sbGVyICR7Y29udHJvbGxlci5nZXRXb3JraW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVURSb3V0ZXJTd2l0Y2g7XG4iLCJpbXBvcnQgVUlHZW5lcmljU2VsZWN0b3IgZnJvbSBcIi4uLy4uL2VsZW1lbnRzL21vZGFsL3VpLmdlbmVyaWMuc2VsZWN0b3Iuc3ZlbHRlXCI7XG5pbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgZW1wdHlSZXN1bHQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGlzdDogW10sXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBwYWdlOiAwLFxuICAgICAgICBwYWdlczogMCxcbiAgICAgICAgc2tpcDogMCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgbm90U2VydmljZU1vZGVsU2VhcmNoIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIG1vZGVsTmFtZSkge1xuICAgICAgICB0aGlzLm1vZGVsTmFtZSA9IG1vZGVsTmFtZTtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwO1xuICAgIH1cblxuICAgIGdldFNlYXJjaFJvdXRlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwibGlzdEFuZENvdW50XCI7XG4gICAgfVxuXG4gICAgZ2V0RGF0YUxvYWRSb3V0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcImdldFwiO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybVNlYXJjaFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0Lmxpc3QgPSByZXN1bHQubGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2lkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgICAgICBpZDogaXRlbVtgJHt0aGlzLm1vZGVsTmFtZX1JRGBdLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLm5hbWUgfHwgaXRlbS50aXRsZSB8fCBpdGVtLmxhYmVsIHx8IGl0ZW0udXNlcm5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1TZWxlY3RlZFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pZDogcmVzdWx0Ll9pZCxcbiAgICAgICAgICAgIFtgJHt0aGlzLm1vZGVsTmFtZX1JRGBdOiByZXN1bHQuaWQsXG4gICAgICAgICAgICB0aXRsZTogcmVzdWx0LnRpdGxlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHNlYXJjaEJ5VGVybSh0ZXJtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGVybS52YWx1ZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmFwcC5nZXRNb2RlbCh0aGlzLm1vZGVsTmFtZSk7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2V0U2VhcmNoKHRlcm0udmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWxbYCQke3RoaXMuZ2V0U2VhcmNoUm91dGVOYW1lKCl9YF0oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBcIm9rXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU2VhcmNoUmVzdWx0KHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5TZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBtb3VudChVSUdlbmVyaWNTZWxlY3Rvciwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbC4kb24oXCJ0ZXJtQ2hhbmdlXCIsIGFzeW5jICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlYXJjaEJ5VGVybShkZXRhaWwpO1xuICAgICAgICAgICAgICAgICAgICBlbC4kc2V0KHsgcmVzdWx0cyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVsLiRvbihcIm5leHRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5leHQgc2VsZWN0b3IgcmVzdWx0c1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVsLiRvbihcInByZXZcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInByZXYgc2VsZWN0b3IgcmVzdWx0c1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVsLiRvbihcInJlamVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbC4kb24oXCJyZXNvbHZlXCIsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMudHJhbnNmb3JtU2VsZWN0ZWRSZXN1bHQoZGV0YWlsKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkRGF0YShfaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfaWQgJiYgX2lkLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmFwcC5nZXRNb2RlbCh0aGlzLm1vZGVsTmFtZSwgeyBfaWQgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbFtcbiAgICAgICAgICAgICAgICAgICAgYCQke3RoaXMuZ2V0RGF0YUxvYWRSb3V0ZU5hbWUoKX1gXG4gICAgICAgICAgICAgICAgXSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFwib2tcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL2ltcG9ydCAnYmFiZWwtcG9seWZpbGwvZGlzdC9wb2x5ZmlsbCc7XG5cbi8qXG4gIENvbW1vbiBmdW5jdGlvbnNcbiovXG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKlxuICBmcmFtZXdvcmsgd2lkZSBwYXJzZXIgZm9yIGRhdGEgYWNjZXNzXG4qL1xuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbmltcG9ydCBub3RSb3V0ZXIgZnJvbSBcIi4vcm91dGVyLmpzXCI7XG5cbmltcG9ydCAqIGFzIG5vdEFQSSBmcm9tIFwiLi9hcGlcIjtcbmltcG9ydCAqIGFzIG5vdFN0b3JlcyBmcm9tIFwiLi9zdG9yZXNcIjtcbi8qXG4gIGJhc2ljIGV2ZW50IGhhbmRsZXJzIGFuZCBjb3JlIGRhdGEgbW9kaWZpZXJzXG4qL1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuXG5pbXBvcnQgeyBDT01QT05FTlRTLCBGSUVMRFMsIFZBUklBTlRTIH0gZnJvbSBcIi4vTElCLmpzXCI7XG4vKlxuICBhcHBsaWNhdGlvbiBtYWluIGluZnJhc3RydWN0dXJlIHNldHRlclxuKi9cbmltcG9ydCBub3RBcHAgZnJvbSBcIi4vYXBwLmpzXCI7XG4vKlxuICB1c2VyIGNvbnRyb2xsZXJzXG4qL1xuaW1wb3J0IG5vdENvbnRyb2xsZXIgZnJvbSBcIi4vY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IG5vdFJlY29yZCBmcm9tIFwiLi9yZWNvcmQuanNcIjsgLy8gIHdyYXBwZXIgZm9yIGRhdGEgd2l0aCBzZXJ2ZXIgbGl2ZSBpbnRlcmFjdGlvbnNcbmltcG9ydCBub3RJbnRlcmZhY2UgZnJvbSBcIi4vaW50ZXJmYWNlLmpzXCI7IC8vICB3cmFwcGVyIGZvciBkYXRhIHdpdGggc2VydmVyIGxpdmUgaW50ZXJhY3Rpb25zXG5cbmltcG9ydCB7XG4gICAgbm90VGFibGUsXG4gICAgVUlGb3JtLFxuICAgIG5vdEZvcm0sXG4gICAgbm90Rm9ybVNldCxcbiAgICBub3RGb3JtUnVsZXMsXG4gICAgbm90Rm9ybVV0aWxzLFxuICAgIG5vdEZvcm1IZWxwZXJzLFxuICAgIG5vdEJyZWFkY3J1bWJzLFxuICAgIG5vdFRvcE1lbnUsXG4gICAgbm90U2lkZU1lbnUsXG59IGZyb20gXCIuL2NvbXBvbmVudHNcIjtcblxuaW1wb3J0IGNyZWF0ZUNSVURBY3Rpb25VSVZpZXcgZnJvbSBcIi4vY3J1ZC9jcmVhdGUuY3J1ZC5hY3Rpb24udWkudmlldy5qc1wiO1xuaW1wb3J0IG5vdENSVUQgZnJvbSBcIi4vY3J1ZC9jb250cm9sbGVyLmNydWQuanNcIjtcbmltcG9ydCBub3RDUlVEUm91dGVyIGZyb20gXCIuL2NydWQvcm91dGVyLmpzXCI7XG5pbXBvcnQgbm90Q1JVRFJvdXRlclBsYWluIGZyb20gXCIuL2NydWQvcm91dGVyLnBsYWluLmpzXCI7XG5pbXBvcnQgbm90Q1JVRFJvdXRlclN3aXRjaCBmcm9tIFwiLi9jcnVkL3JvdXRlci5zd2l0Y2guanNcIjtcbmltcG9ydCBub3RTZXJ2aWNlTW9kZWxTZWFyY2ggZnJvbSBcIi4vY3J1ZC9zZWFyY2guc2VydmljZS5qc1wiO1xuXG5jb25zdCBuY0NSVUQgPSBub3RDUlVEOyAvL2xlZ2FjeSBhbGlhc1xuXG5leHBvcnQge1xuICAgIENPTVBPTkVOVFMsXG4gICAgRklFTERTLFxuICAgIFVJRm9ybSxcbiAgICBWQVJJQU5UUyxcbiAgICBuY0NSVUQsXG4gICAgY3JlYXRlQ1JVREFjdGlvblVJVmlldyxcbiAgICBub3RBUEksXG4gICAgbm90QXBwLFxuICAgIG5vdEJhc2UsXG4gICAgbm90QnJlYWRjcnVtYnMsXG4gICAgbm90Q1JVRCxcbiAgICBub3RDb21tb24sXG4gICAgbm90Q29udHJvbGxlcixcbiAgICBub3RGb3JtLFxuICAgIG5vdEZvcm1TZXQsXG4gICAgbm90Rm9ybVV0aWxzLFxuICAgIG5vdEZvcm1IZWxwZXJzLFxuICAgIG5vdEZvcm1SdWxlcyxcbiAgICBub3RJbnRlcmZhY2UsXG4gICAgbm90UGF0aCxcbiAgICBub3RSZWNvcmQsXG4gICAgbm90Um91dGVyLFxuICAgIG5vdENSVURSb3V0ZXIsXG4gICAgbm90Q1JVRFJvdXRlclBsYWluLFxuICAgIG5vdENSVURSb3V0ZXJTd2l0Y2gsXG4gICAgbm90U2VydmljZU1vZGVsU2VhcmNoLFxuICAgIG5vdFNpZGVNZW51LFxuICAgIG5vdFN0b3JlcyxcbiAgICBub3RUYWJsZSxcbiAgICBub3RUb3BNZW51LFxufTtcbiIsImltcG9ydCBcIi4vc2Nzcy9zdHlsZS5zY3NzXCI7XG5cbmltcG9ydCAqIGFzIHN2ZWx0ZSBmcm9tIFwic3ZlbHRlXCI7XG5cbmltcG9ydCAqIGFzIEVsZW1lbnRzIGZyb20gXCIuL2VsZW1lbnRzXCI7XG5cbmltcG9ydCAqIGFzIEZyYW1lIGZyb20gXCIuL2ZyYW1lXCI7XG5cbmltcG9ydCB7IExPQ0FMRSwgc2F5LCBub3RMb2NhbGUgfSBmcm9tIFwiLi9sb2NhbGVcIjtcblxuY29uc3QgTG9jYWxlID0geyBMT0NBTEUsIHNheSwgbm90TG9jYWxlIH07XG5jb25zdCBVSUNvbW1vbiA9IEVsZW1lbnRzLlVJQ29tbW9uO1xuXG5jb25zdCB7IG5vdENvbW1vbiwgQ09NUE9ORU5UUywgRklFTERTLCBWQVJJQU5UUywgbm90Rm9ybVV0aWxzIH0gPSBGcmFtZTtcblxuT2JqZWN0LmtleXMoRWxlbWVudHMpLmZvckVhY2goKGNvbXBvbmVudHNTZXROYW1lKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoRWxlbWVudHNbY29tcG9uZW50c1NldE5hbWVdKS5mb3JFYWNoKChjb21wb25lbnROYW1lKSA9PiB7XG4gICAgICAgIEZyYW1lLm5vdEZvcm1VdGlscy5hZGRDb21wb25lbnQoXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgRWxlbWVudHNbY29tcG9uZW50c1NldE5hbWVdW2NvbXBvbmVudE5hbWVdXG4gICAgICAgICk7XG4gICAgfSk7XG59KTtcblxuZXhwb3J0IHtcbiAgICBzdmVsdGUsXG4gICAgLy9VSVxuICAgIEVsZW1lbnRzLFxuICAgIFVJQ29tbW9uLFxuICAgIC8vYXBwbGljYXRpb24gZnJhbWV3b3JrXG4gICAgRnJhbWUsXG4gICAgLy9zaG9ydHMgZm9yIGNvbW1vbiBlbGVtZW50c1xuICAgIG5vdENvbW1vbixcbiAgICBub3RGb3JtVXRpbHMsXG4gICAgQ09NUE9ORU5UUyxcbiAgICBGSUVMRFMsXG4gICAgVkFSSUFOVFMsXG4gICAgLy9sb2NhbGl6YXRpb25cbiAgICBMb2NhbGUsXG4gICAgTE9DQUxFLFxuICAgIHNheSxcbiAgICBub3RMb2NhbGUsXG59O1xuIl0sIm5hbWVzIjpbImJvbGQiLCJub3JtYWwiLCJ3Lmh5ZHJhdGlvbl9taXNtYXRjaCIsIncuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUiLCJlLm1pc3NpbmdfY29udGV4dCIsImUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50IiwiZS5lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkIiwiZS5leHBlcmltZW50YWxfYXN5bmNfZm9yayIsImUuZm9ya190aW1pbmciLCJlLmZvcmtfZGlzY2FyZGVkIiwiZ2V0Iiwidy5zdmVsdGVfYm91bmRhcnlfcmVzZXRfbm9vcCIsImUuc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3IiLCJlLmFzeW5jX2Rlcml2ZWRfb3JwaGFuIiwiZS5kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZiIsImUuc3RhdGVfdW5zYWZlX211dGF0aW9uIiwic291cmNlIiwiZS5zdGF0ZV9kZXNjcmlwdG9yc19maXhlZCIsImUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkIiwidy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCIsImUuZWZmZWN0X29ycGhhbiIsImUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCIsImUuZWZmZWN0X2luX3RlYXJkb3duIiwiZS5oeWRyYXRpb25fZmFpbGVkIiwidy5zdGF0ZV9wcm94eV91bm1vdW50Iiwidy5saWZlY3ljbGVfZG91YmxlX3VubW91bnQiLCJpbmRleCIsIncuaHlkcmF0aW9uX2h0bWxfY2hhbmdlZCIsImUuaW52YWxpZF9zbmlwcGV0Iiwidy5pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlciIsImNsc3giLCJfY2xzeCIsIncuc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWUiLCJ3Lmh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZCIsImxpbmVhciIsImUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlIiwiZ2V0X3N0b3JlIiwiZS5wcm9wc19yZXN0X3JlYWRvbmx5IiwiZS5wcm9wc19pbnZhbGlkX3ZhbHVlIiwiZS5ydW5lX291dHNpZGVfc3ZlbHRlIiwiZS5nZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb24iLCJlLmxpZmVjeWNsZV9sZWdhY3lfb25seSIsImlucHV0VmFsdWVzRXh0cmFjdG9ycyIsIk9iamVjdCIsImZyZWV6ZSIsImNoZWNrYm94IiwiaW5wRWwiLCJkZWZhdWx0VmFsdWUiLCJ1bmRlZmluZWQiLCJoYXNPd24iLCJjaGVja2VkIiwidW5jaGVja2VkIiwidmFsdWUiLCJVSUNvbW1vbiIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsImV4dHJhY3RWYWx1ZUZyb21JbnB1dCIsInR5cGUiLCJvbklucHV0IiwiZmllbGQiLCJvbmNoYW5nZSIsImFkZGl0aW9uYWwiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiY3VycmVudFRhcmdldCIsImlzRW50ZXJFdmVudCIsImUiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJvbmx5T25FbnRlciIsImNhbGxiYWNrIiwiaXNNb2JpbGUiLCJ0ZXN0TW9iaWxlIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIm1zTWF0Y2hNZWRpYSIsInRlc3RRdWVyeSIsImFyZ3VtZW50cyIsImxlbmd0aCIsIm1heF93aWR0aCIsIk1PQklMRV9XSURUSF9CUkVBS19QT0lOVCIsIm1hdGNoZXMiLCJyZW1vdmVCb2R5U2Nyb2xsIiwiZG9jdW1lbnQiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiU0NST0xMX0RJU0FCTEVSX0NMQVNTIiwicmVzdG9yZUJvZHlTY3JvbGwiLCJyZW1vdmUiLCJmb3JtYXRQaG9uZSIsInZhbCIsImZpbGxlciIsIkZJTExFUiIsInNsb3RzIiwiZGlnaXRzIiwicmVwbGFjZSIsImQiLCJ1bnNoaWZ0Iiwic3RhY2siLCJBcnJheSIsImZyb20iLCJmb3JFYWNoIiwiZGlnaXQiLCJzbG90IiwibGVucyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ0IiwiZGlmIiwicGFyc2VJbnQiLCJzZXRNb25leVNpZ24iLCJNT05FWV9TSUdOIiwiZm9ybWF0UHJpY2UiLCJwcmljZSIsIm1ham9yIiwiTWF0aCIsImZsb29yIiwibWlub3IiLCJ0b1N0cmluZyIsImZvcm1hdExvY2FsZURhdGV0aW1lIiwiZHQiLCJvcHRzIiwiZGF0ZSIsInRpbWUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsInRvTG9jYWxlVGltZVN0cmluZyIsInRyeUZvcm1hdExvY2FsZURhdGVUaW1lIiwiRGF0ZSIsImZvcm1hdFRpbWVzdGFtcCIsInRpbWVzdGFtcCIsIm9mZnNldCIsIm9mZnNldExvY2FsIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJkZWx0YU9mZnNldCIsImxvY2FsRGF0ZVRpbWUiLCJ0b0xvY2FsZVN0cmluZyIsImRlY2xPZk51bSIsIm4iLCJ0ZXh0X2Zvcm1zIiwiYWJzIiwibjEiLCJodW1hbml6ZWRUaW1lRGlmZiIsImN1cnJlbnRUaW1lIiwiZ2V0VGltZSIsInNlYyIsInJvdW5kIiwidW5pdCIsIlRJTUUiLCJTRUNPTkRTIiwibWluIiwiTUlOVVRFUyIsImhvdXJzIiwiSE9VUlMiLCJzdHlsZXNPYmplY3RUb1N0cmluZyIsInN0eWxlcyIsImtleXMiLCJtYXAiLCJwcm9wIiwiam9pbiIsInN0cmluZ09yTnVtYmVyIiwiaW5kZXhPZiIsInN0cmluZ3NPZk51bWJlcnMiLCJsaXN0IiwiZXZlcnkiLCJfZGVmaW5lUHJvcGVydHkiLCJ0b3AiLCJiZWhhdmlvciIsIiQucmVzdF9wcm9wcyIsIiQuYXR0cmlidXRlX2VmZmVjdCIsIiQudXNlcl9lZmZlY3QiLCIkLnNldCIsImluaXREaWN0IiwidGFyZ2V0IiwiaGFuZGxlciIsIlJlZmxlY3QiLCJQcm94eSIsImNyZWF0ZUxvY2FsZSIsIm5ld0xvY2FsZSIsIndyaXRhYmxlIiwic3Vic2NyaWJlIiwidXBkYXRlIiwic2V0IiwicmVzZXQiLCJMT0NBTEUiLCJ0aGlzIiwic3JjIiwibm90UGF0aCIsInJlcXVpcmUkJDAiLCJpc01lcmdlYWJsZU9iamVjdCIsImlzTm9uTnVsbE9iamVjdCIsImlzU3BlY2lhbCIsInN0cmluZ1ZhbHVlIiwicHJvdG90eXBlIiwiY2FsbCIsImlzUmVhY3RFbGVtZW50IiwiY2FuVXNlU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiJCR0eXBlb2YiLCJlbXB0eVRhcmdldCIsImlzQXJyYXkiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsIm9wdGlvbnNBcmd1bWVudCIsImNsb25lIiwiZGVlcG1lcmdlIiwiZGVmYXVsdEFycmF5TWVyZ2UiLCJjb25jYXQiLCJlbGVtZW50IiwibWVyZ2VPYmplY3QiLCJkZXN0aW5hdGlvbiIsInNvdXJjZUlzQXJyYXkiLCJ0YXJnZXRJc0FycmF5Iiwib3B0aW9ucyIsImFycmF5TWVyZ2UiLCJzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoIiwiYWxsIiwiZGVlcG1lcmdlQWxsIiwiYXJyYXkiLCJFcnJvciIsInByZXYiLCJuZXh0Iiwibm90Q29tbW9uIiwiaXNFcnJvciIsInN0YXR1cyIsIm11dGUiLCJFTlZfVFlQRSIsInBhZCIsImdldFRvZGF5RGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwib2JqSGFzIiwib2JqIiwibmFtZSIsImNvcHlPYmoiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJwYXJ0Q29weU9iaiIsInBhcnRPYmoiLCJpbmNsdWRlcyIsImNvbXBhcmVUd29BcnJheXMiLCJhIiwiYiIsImlzRnVuYyIsImZ1bmMiLCJpc0FzeW5jIiwiY29uc3RydWN0b3IiLCJleGVjdXRlT2JqZWN0RnVuY3Rpb24iLCJwYXJhbXMiLCJwcm9jIiwibWFwQmluZCIsInRvIiwiaXRlbSIsImJpbmQiLCJpc0NsYXNzIiwiZm4iLCJ0ZXN0IiwiZGV0ZWN0VHlwZSIsInRlc3RpZSIsImRhdGEiLCJsb2NhbElzb0RhdGUiLCJsb2NhbElzb1N0cmluZyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRUb2RheSIsInRvZGF5IiwiYmFja2xvZ0FkZCIsIm1zZyIsImJhY2tsb2ciLCJwdXNoIiwiZHVtcEJhY2tsb2ciLCJyb3ciLCJzaGlmdCIsIkxPRyIsImxvZ01zZyIsIm5vdyIsImxvZyIsImNyZWF0ZUxvZ2dlciIsInByZWZpeCIsImdlbkxvZ01zZyIsImVycm9yIiwiZ2VuTG9nRXJyb3IiLCJkZWJ1ZyIsImdlbkxvZ0RlYnVnIiwicmVwb3J0IiwiaXNEZXYiLCJERVZfRU5WIiwiTk9PUCIsImxvZ0Vycm9yIiwiZ2V0QXBwIiwicmVwb3J0ZXIiLCJnZXRTZXJ2aWNlIiwiY2F0Y2giLCJ0cmFjZSIsInRyaW1CYWNrc2xhc2giLCJzdHIiLCJzdWJzdHJpbmciLCJidWlsZFVSTCIsIm1vZHVsZSIsIm1vZGVsIiwiaWQiLCJhY3Rpb24iLCJ1cmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmaWx0ZXIiLCJlbCIsImNhcGl0YWxpemVGaXJzdExldHRlciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJsb3dlckZpcnN0TGV0dGVyIiwic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJzdHJMZW5ndGhDYXAiLCJNQVhfVElUTEVfTEVOR1RIIiwiUE9TVF9GSVgiLCJzdWJzdHIiLCJlc2NhcGVIdG1sIiwidW5zYWZlIiwic3RhcnRBcHAiLCJzdGFydGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV4dGVuZEFwcENvbmZpZyIsImNvbmYiLCJjb25mMiIsImRlZXBNZXJnZSIsImFic29yYk1vZHVsZSIsImRlZmF1bHRDb25mIiwibW9kIiwidGFyZ2V0cyIsImhhc093blByb3BlcnR5Iiwic2VydmljZXMiLCJ1aXMiLCJ3Y3MiLCJtYW5pZmVzdCIsImNvbnRyb2xsZXJzIiwibm90RW52IiwiZGVmaW5lSWZOb3RFeGlzdHMiLCJyZWdpc3RlciIsInJlZ2lzdHJ5IiwibW92ZUl0ZW0iLCJvbGRfaW5kZXgiLCJuZXdfaW5kZXgiLCJpblJhbmdlIiwibnVtIiwic3BsaWNlIiwic3RyaXBQcm94eSIsImlzUHJveHkiLCJhc3NpZ24iLCJwaXBlIiwiZnVuY3MiLCJyZXN1bHQiLCJnZXRBUEkiLCJnZXRNYW5hZ2VyIiwic2V0TWFuYWdlciIsInYiLCJNQU5BR0VSIiwiZ2V0SlNPTiIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsIndhaXQiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsInJlZ2lzdGVyV2lkZ2V0RXZlbnRzIiwiZXZlbnRzIiwiZXZlbnROYW1lIiwib24iLCJuYXZpZ2F0ZSIsImdldFdvcmtpbmciLCJzZWxlY3QiLCJ2YXJpYW50c1NldCIsImRlZiIsIl9ub3RDb21tb24iLCJOT1RfRU5WX1RZUEUiLCJhYnNvcmJTZXJ2aWNlcyIsInNlcnYiLCJleHRlbmRXU0NsaWVudCIsIndzY05hbWUiLCJ3c2NPcHRpb25zIiwiY29ubmVjdGlvbiIsInJvdXRlciIsInJvdXRlcyIsIm1lc3NlbmdlciIsInJvdXRlVHlwZSIsImFic29yYldTQyIsIndzQ2xpZW50TmFtZSIsImFic29yYlVJcyIsInVpIiwiYWJzb3JiRmllbGRzIiwibm90TG9jYWxlIiwiX0V2ZW50RW1pdHRlciIsIl90aGlzIiwiX2NhbGxTdXBlciIsImRpY3QiLCJoZWxwZXJzIiwicmVzdG9yZUZyb21TdG9yYWdlIiwiX2luaGVyaXRzIiwiZm9ybWF0IiwicGFyc2VTdWJzIiwic2F5IiwicGhyYXNlIiwidG1wbCIsInNhdmVUb1N0b3JhZ2UiLCJlbWl0IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImdldEl0ZW0iLCJ2b2NhYnVsYXJ5IiwiRXZlbnRFbWl0dGVyIiwiJC5wcm9wIiwiJC5kZXJpdmVkIiwiJC5zbmFwc2hvdCIsIiQuc2V0X3RleHQiLCJVSUJvb2xlYW4iLCIkLnN0YXRlIiwiJC5wcm94eSIsIiQuZWFjaCIsIiQuZ2V0IiwiJC5zbmlwcGV0IiwiJC5iaW5kX3RoaXMiLCIkLnNldF9jbGFzcyIsIiQudGVtcGxhdGVfZWZmZWN0IiwiJC5jbHN4IiwiVUlCdXR0b24iLCJVSUJ1dHRvblN3aXRjaCIsIiQuc3ByZWFkX3Byb3BzIiwiVUlCdXR0b25zIiwiJC5tdXRhYmxlX3NvdXJjZSIsInRleHQiLCIkLm11dGF0ZSIsIiQuZXZlbnQiLCIkLndpbmRvdyIsIiQudW50cmFjayIsIiQucHJldmVudERlZmF1bHQiLCIkLmFuaW1hdGlvbiIsIiQudHJhbnNpdGlvbiIsIlVJQ2hlY2tib3hJbnB1dCIsIiQuYmluZF92YWx1ZSIsIkxpYiIsInNlZWRMaWIiLCJfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyIsIl9saWIiLCJpbXBvcnQiLCJnZXRDb250ZW50IiwiY29tcCIsIm1vZGUiLCJjb250YWlucyIsIl9jbGFzc1ByaXZhdGVGaWVsZEdldCIsImJ1bGsiLCJmIiwiaXNFbXB0eSIsIkNPTVBPTkVOVFMiLCJGSUVMRFMiLCJWQVJJQU5UUyIsIiQuc2V0X2F0dHJpYnV0ZSIsIlVJTGluayIsIlVJVGl0bGUiLCJVSUxpc3RJdGVtIiwiVUlMaXN0RW1wdHlQbGFjZWhvbGRlciIsIiQuc2V0X3N0eWxlIiwiVUlJbWFnZSIsIlVJTGlzdCIsIkRFRkFVTFRfU1RBVFVTX1NVQ0NFU1MiLCJOQVZJR0FUSU9OX0RFTEFZX1NIT1JUIiwiTkFWSUdBVElPTl9ERUxBWV9OT1JNQUwiLCJOQVZJR0FUSU9OX0RFTEFZX0xPTkciLCJOQVZJR0FUSU9OX0RFTEFZUyIsIlNIT1JUIiwiTk9STUFMIiwiTE9ORyIsIk5BVklHQVRJT05fREVMQVlfREVGQVVMVCIsIlVJQnV0dG9uc1JvdyIsIiQudXBkYXRlX3Byb3AiLCJVSUVuZGxlc3NMaXN0U2ltcGxlSXRlbSIsIlVJRW5kbGVzc0xpc3RFbXB0eVBsYWNlaG9sZGVyIiwiVUlFbmRsZXNzTGlzdE5hdmlnYXRpb24iLCJMaXN0R3JvdXBzVUlUcmVlRFRPIiwiY29udmVydEdyb3VwVGl0bGUiLCJ0aXRsZSIsImNvbnZlcnRHcm91cEltYWdlIiwiaW1hZ2UiLCJjb252ZXJ0VmFyaWFudCIsInZhcmlhbnQiLCJncm91cElkIiwidmFsdWVJZCIsImNvbnZlcnRWYXJpYW50c0dyb3VwIiwiZ3JvdXAiLCJkZXNjcmlwdGlvbiIsInZhbHVlcyIsInZhcmlhbnRzIiwiaXRtIiwiYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzIiwiX3RoaXMyIiwic3VibGltZVZhbHVlIiwiZ2V0U2VsZWN0b3JHcm91cEluZGV4Iiwic2VsZWN0b3JHcm91cHNJdGVtcyIsImZpbmRJbmRleCIsImdldFNlbGVjdG9yR3JvdXAiLCJzZWxlY3Rvckdyb3VwSGFzVmFyaWFudHMiLCJnZXRTZWxlY3Rvckdyb3VwVmFyaWFudHMiLCJjb21wYXJlU2VsZWN0b3JHcm91cFZhbHVlSWRXaXRoIiwidmFyaWFudElkIiwiZ2V0U2VsZWN0b3JJdGVtSW5kZXgiLCJncm91cEluZGV4IiwiaXRlbUluZGV4IiwiZ2V0U2VsZWN0b3JJdGVtSW5kZXhlcyIsImdldFNlbGVjdG9ySXRlbSIsIml0ZW1JZHMiLCJpbmRleGVzIiwiZ3JvdXBWYXJpYW50cyIsImdldERlZmF1bHRTZWxlY3Rvckl0ZW1TdWJsaW1lIiwidXBkYXRlU2VsZWN0b3JJdGVtIiwiaXRlbVByb3BzIiwiYWN0aW9uc1VJUHJvcHMiLCJhY3Rpb25zIiwidWlQcm9wcyIsInVpT24iLCJVSV9QUk9QU19ERUxUQV9PTiIsIlVJX1BST1BTX0RFTFRBX09OX0FDVElPTiIsInVpT2ZmIiwiVUlfUFJPUFNfREVMVEFfT0ZGIiwiVUlfUFJPUFNfREVMVEFfT0ZGX0FDVElPTiIsInN5bmNVSVdpdGhWYWx1ZSIsInNlbGVjdG9yR3JvdXBzIiwiaXRlbUluVmFsdWUiLCJpdGVtcyIsImNsYXNzIiwiY29sb3IiLCJMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91ciIsImNvdW50SXRlbXNJblZhbHVlIiwiaW5pdFZhbHVlIiwiZ3JvdXBJdGVtc0lzVmFsaWQiLCJncm91cEl0ZW1zIiwiY2xlYXJGcm9tRW1wdHlHcm91cHMiLCJncm91cElzRW1wdHkiLCJncm91cElzRnVsbCIsInZhbHVlR3JvdXAiLCJ2YXJpYW50c0dyb3VwIiwicmVtb3ZlSXRlbUZyb21WYWx1ZSIsImF0TGVhc3RPbmUiLCJhZGRJdGVtVG9WYWx1ZSIsIm9ubHlPbmVQZXJHcm91cCIsInNlbGVjdEFsbCIsInNlbGVjdE5vbmUiLCJzZWxlY3RBbGxJbkdyb3VwIiwiX3RoaXMzIiwiZmluZCIsInNlbGVjdE5vbmVJbkdyb3VwIiwidmFsdWVBc1ZhcmlhbnRzIiwiX3RoaXM0IiwiTGlzdEdyb3Vwc1ZhbHVlRFRPU2luZ2xlQmVoYXZpb3VyIiwiTGlzdEdyb3Vwc1ZhbHVlRFRPIiwiYmVoYXZpb3VyIiwibXVsdGlwbGUiLCJ0b2dnbGUiLCJVSUJ1dHRvbnNTd2l0Y2hlcnMiLCJVSUJ1dHRvbkNsb3NlIiwiVUlTaW1wbGVTZWFyY2hJbnB1dCIsIlVJRW5kbGVzc0xpc3QiLCIkLm5vb3AiLCJVSU5hdmJhckl0ZW0iLCJNRVRBX01FVEhPRF9JTklUIiwiTUVUQV9EQVRBIiwiTUVUQV9XT1JLSU5HIiwiTUVUQV9PUFRJT05TIiwibm90QmFzZSIsImlucHV0IiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJzZXREYXRhIiwic2V0V29ya2luZyIsIndvcmtpbmciLCJzZXRPcHRpb25zIiwiaW5mbyIsInNldENvbW1vbiIsIndoYXQiLCJhcmdzIiwiZ2V0Q29tbW9uIiwiZ2V0RGF0YSIsImdldE9wdGlvbnMiLCJkZXN0cm95IiwicmVtb3ZlRXZlbnQiLCJPUFRfTU9ERV9ISVNUT1JZIiwiT1BUX01PREVfSEFTSCIsIk9QVF9ERUZBVUxUX0NIRUNLX0lOVEVSVkFMIiwibm90Um91dGVyIiwiX25vdEJhc2UiLCJyb290IiwiaW5pdGlhbGl6ZWQiLCJkZWxheXMiLCJkZWxheV9kZWZhdWx0Iiwic2V0RGVsYXlzIiwic2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSIsImRlbGF5IiwiZGVsYXlBc01zIiwiZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSIsIm5hdmlnYXRlV2l0aERlbGF5IiwiZG9CZWZvcmUiLCJoaXN0b3J5IiwiaGFzaCIsInNldFJvb3QiLCJjbGVhclNsYXNoZXMiLCJwYXRoIiwicmUiLCJydWxlIiwiYWRkTGlzdCIsInBhcmFtIiwiaSIsInIiLCJmbHVzaCIsImlzSW5pdGlhbGl6ZWQiLCJzZXRJbml0aWFsaXplZCIsImdldEZyYWdtZW50IiwiZnJhZ21lbnQiLCJsb2NhdGlvbiIsImRlY29kZVVSSSIsInBhdGhuYW1lIiwic2VhcmNoIiwibWF0Y2giLCJocmVmIiwiY2hlY2tMb2NhdGlvbiIsImN1cnJlbnQiLCJpbml0IiwiY2hlY2siLCJocmVmQ2xpY2siLCJnZXRSb290IiwibGlzdGVuIiwibG9vcEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiZmFpbEJhY2siLCJmdWxsUkUiLCJyb3V0ZSIsImFwcGx5IiwiaG9zdCIsInJlZnJlc2giLCJ0aW1lb3V0IiwibmV3Um91dGUiLCJnZXRGdWxsUm91dGUiLCJsYXN0Um91dGUiLCJwdXNoU3RhdGUiLCJnZXRBbGxMaW5rcyIsImFsbEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImoiLCJhdHRzIiwiYXR0cmlidXRlcyIsIm5vZGVOYW1lIiwicmVSb3V0ZUV4aXN0ZWQiLCJpbml0UmVyb3V0aW5nIiwiZ2V0QXR0cmlidXRlIiwibGluayIsIm5vdFJvdXRlckluaXRpYWxpemVkIiwiZnVsbExpbmsiLCJzZXRBdHRyaWJ1dGUiLCJMT0dfUFJFRklYIiwibm90QVBJUXVldWUiLCJidXN5IiwicXVldWUiLCJidXN5U2luY2UiLCJhZnRlckVtcHR5Iiwic3RhcnQiLCJzdG9wIiwiaW50ZXJ2YWwiLCJjaGVja1F1ZXVlIiwiUVVFVUVfQ0hFQ0tfSU5URVJWQUwiLCJpc0J1c3kiLCJzZXRCdXN5IiwicnVuTmV4dCIsInNldEZyZWUiLCJhZGRUb1F1ZXVlIiwidGFzayIsInJlc29sdmUiLCJNQVhfQlVTWV9USU1FIiwicnVuIiwicmVqZWN0IiwiYWN0aW9uSXNRdWV1ZWQiLCJzb21lIiwicXVldWVkIiwicnVuSWZOb3RRdWV1ZWQiLCJub3RBUElPcHRpb25zIiwicnBzIiwicHJvdG9jb2wiLCJwb3J0Iiwibm90QVBJQ29ubmVjdGlvbiIsIm9ubGluZSIsImludCIsInBhdXNlIiwicmVzdW1lIiwiaXNPbmxpbmUiLCJvbkxpbmUiLCJjaGFuZ2VTdGF0ZSIsIkFMTCIsImV4aXN0IiwiY3JlYXRlIiwicHJvcHMiLCJyYXciLCJmaWx0ZXJlZCIsInNlbGVjdGVkIiwiZmFrZSIsIk1FVEFfSU5URVJGQUNFIiwiTUVUQV9NQVBfVE9fSU5URVJGQUNFIiwiREVGQVVMVF9BQ1RJT05fUFJFRklYIiwiT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSIsIkRFRkFVTFRfRklMVEVSIiwiREVGQVVMVF9TRUFSQ0giLCJERUZBVUxUX1JFVFVSTiIsIkRFRkFVTFRfUEFHRV9OVU1CRVIiLCJERUZBVUxUX1BBR0VfU0laRSIsIkRFRkFVTFRfV1NfUk9VVEVfQUNUSU9OX1NQTElUVEVSIiwibm90SW50ZXJmYWNlIiwicmV0dXJuIiwicGFnZXIiLCJzaXplIiwicGFnZSIsImluaXRBY3Rpb25zIiwiZ2V0QWN0aW9uc0NvdW50IiwiZ2V0QWN0aW9ucyIsImFjdGlvbk5hbWUiLCJpbml0QWN0aW9uIiwiaGVhZGVycyIsImZpbGVVcGxvYWQiLCJmaWxlcyIsInJlcXVlc3QiLCJyZXF1ZXN0SFRUUCIsInJlY29yZCIsImNvbXBvc2l0ZURhdGEiLCJhY3Rpb25EYXRhIiwiZ2V0QWN0aW9uRGF0YSIsInJlcXVlc3RQYXJhbXMiLCJjb2xsZWN0UmVxdWVzdERhdGEiLCJyZXF1ZXN0UGFyYW1zRW5jb2RlZCIsImVuY29kZVJlcXVlc3QiLCJhcGlTZXJ2ZXJVUkwiLCJnZXRTZXJ2ZXJVUkwiLCJnZXRVUkwiLCJmZCIsIkZvcm1EYXRhIiwiYXBwZW5kIiwibWV0aG9kIiwiQWNjZXB0IiwicmVxdWVzdFdTIiwiV1MiLCJnZXRXU0NsaWVudCIsIm1lc3NhZ2VOYW1lIiwiZ2V0V1NSZXF1ZXN0TmFtZSIsInBheWxvYWQiLCJtZXNzYWdlIiwic2VsZWN0VHJhbnNwb3J0Iiwid3NJc1VwIiwid3MiLCJjbGllbnQiLCJ3c0NsaWVudCIsImdldE1vZGVsTmFtZSIsInBhcnNlUGFyYW1zIiwiZW5kIiwibGluZSIsImZpZWxkTmFtZSIsImxlbiIsImluZCIsInN0YXJ0U2xpY2UiLCJlbmRTbGljZSIsInBhcnNlTGluZSIsInBvc3RGaXgiLCJtb2RlbE5hbWUiLCJwIiwicmVxdWVzdERhdGEiLCJkYXRhUHJvdmlkZXJOYW1lIiwiZ2V0SUQiLCJyZXN1bHRJZCIsInByZWZpeGVzIiwicHJlIiwic2V0RmluZEJ5Iiwic2V0RmlsdGVyIiwiZmlsdGVyRGF0YSIsInJlc2V0RmlsdGVyIiwiZ2V0RmlsdGVyIiwic2V0U2VhcmNoIiwic2VhcmNoRGF0YSIsInJlc2V0U2VhcmNoIiwiZ2V0U2VhcmNoIiwic2V0U29ydGVyIiwic29ydGVyRGF0YSIsInJlc2V0U29ydGVyIiwiZ2V0U29ydGVyIiwic2V0UmV0dXJuIiwicmV0dXJuRGF0YSIsInJlc2V0UmV0dXJuIiwiZ2V0UmV0dXJuIiwic2V0UGFnZU51bWJlciIsInBhZ2VOdW1iZXIiLCJzZXRQYWdlU2l6ZSIsInBhZ2VTaXplIiwic2V0UGFnZXIiLCJpc05hTiIsInJlc2V0UGFnZXIiLCJnZXRQYWdlciIsImdldFJlY29yZCIsImdldERlZmF1bHRBc1BsYWluT2JqZWN0IiwiZmllbGRzIiwiZGVmYXVsdCIsIm5vdFJlY29yZCIsImlzUmVjb3JkIiwiaXNQcm9wZXJ0eSIsImNyZWF0ZUNvbGxlY3Rpb24iLCJpbnRlcmZhY2VVcCIsIm1hcFRvSW50ZXJmYWNlIiwibWFwVG9NZXRob2RzIiwidG9EZWZhdWx0IiwicmVjIiwiYXBwIiwibWV0aG9kcyIsImNvbGxlY3Rpb24iLCJhY3Rpb25VcCIsInNldEF0dHIiLCJzZXRBdHRycyIsIm9iamVjdFBhcnQiLCJnZXRBdHRyIiwicGxhaW4iLCJwcngiLCJnZXRBdHRycyIsImdldE1hbmlmZXN0IiwiT1BUX0NPTlRST0xMRVJfUFJFRklYIiwiT1BUX1JFQ09SRF9QUkVGSVgiLCJERUZBVUxUX1dTX0NMSUVOVF9OQU1FIiwibm90QXBwIiwiaW50ZXJmYWNlcyIsImluaXRDb250cm9sbGVyIiwiY3VycmVudENvbnRyb2xsZXIiLCJ3c2MiLCJ3c3MiLCJpbml0TWFuaWZlc3QiLCJzZXRJbnRlcmZhY2VNYW5pZmVzdCIsImluaXRSb3V0ZXIiLCJleGVjUm91dGVyIiwicm91dGllSW5wdXQiLCJyb3V0ZUJsb2NrIiwicGF0aHMiLCJzY2hlbWVzIiwiY29udHJvbGxlciIsInBhdGhTY2hlbWUiLCJiaW5kQ29udHJvbGxlciIsImdldEludGVyZmFjZU1hbmlmZXN0IiwidXBkYXRlSW50ZXJmYWNlcyIsImluaXRTZXJ2aWNlcyIsImNvbnRyb2xsZXJOYW1lIiwiY29udHJvbGxlclBhdGhTY2hlbWUiLCJnZXRDdXJyZW50Q29udHJvbGxlciIsInNldEN1cnJlbnRDb250cm9sbGVyIiwiY3RybCIsIm9sZEN0cmwiLCJjcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkiLCJyZWNvcmRNYW5pZmVzdCIsInJlY29yZERhdGEiLCJjbGVhckludGVyZmFjZXMiLCJtYW5pZmVzdHMiLCJyZWNvcmRNZXRob2RzIiwibmFtZUludCIsInNldEludGVyZmFjZSIsImdldFJlY29yZE5hbWUiLCJnZXRDb250cm9sbGVyTmFtZSIsIm1vZGVsRmFjdG9yeSIsImdldEludGVyZmFjZXMiLCJzZXRXU0NsaWVudCIsImdldEludGVyZmFjZSIsImdldE1vZGVsIiwic2V0U2VydmljZSIsInNlcnZOYW1lIiwic2VydlR5cGUiLCJnZXRDb25maWdSZWFkZXJGb3JNb2R1bGUiLCJtb2R1bGVOYW1lIiwibW9kQ29uZlBhdGgiLCJzdWJQYXRoIiwiZmFsbGJhY2siLCJtb2R1bGVDb25maWciLCJPUFRfREVGQVVMVF9BQ1RJT05fTkFNRSIsIk9QVF9ERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUiIsIk9QVF9ERUZBVUxUX1BMVVJBTF9OQU1FIiwiT1BUX0RFRkFVTFRfU0lOR0xFX05BTUUiLCJPUFRfREVGQVVMVF9NT0RVTEVfTkFNRSIsIk9QVF9ERUZBVUxUX0FVVE9fTkFNRSIsIm5vdENvbnRyb2xsZXIiLCJyZWFkeSIsInZpZXdzIiwibGlicyIsImVscyIsImNvbnRhaW5lclNlbGVjdG9yIiwibmFtZXMiLCJwbHVyYWwiLCJzaW5nbGUiLCJzZXRVUkxQcmVmaXgiLCJtYWtlIiwidWlOYW1lIiwiJGRlc3Ryb3kiLCJzZXRNb2RlbCIsInNldE1vZGVsTmFtZSIsImdldE1vZGVsSURGaWVsZE5hbWUiLCJzZXRNb2RlbElERmllbGROYW1lIiwic2V0UmVhZHkiLCJ1cGRhdGVBdXRvTmFtZSIsImdldFVSTFByZWZpeCIsInNldE1vZHVsZU5hbWUiLCJnZXRNb2R1bGVOYW1lIiwiZ2V0TW9kdWxlUHJlZml4IiwiZ2V0TW9kZWxVUkwiLCJnZXRNb2RlbEFjdGlvblVSTCIsInNldE5hbWUiLCJnZXROYW1lIiwicHJlbG9hZExpYiIsIiRsaXN0QWxsIiwiZXJyIiwib25BZnRlclJlbmRlciIsImdldEFjdGlvbk5hbWUiLCJnZXREZWZhdWx0QWN0aW9uTmFtZSIsInJvdXRlck5hbWUiLCJzdWJQYXJhbXMiLCJzZXRDdXJyZW50QWN0aW9uIiwiZ2V0Q3VycmVudEFjdGlvbiIsImdldEFwcE9wdGlvbnMiLCJnZXRNb2R1bGVPcHRpb25zIiwiZ2V0U2VydmljZXMiLCJnZXRDb21wb25lbnRzIiwiZ2V0Um91dGVyIiwibmF2aWdhdGVBY3Rpb24iLCJuYXZpZ2F0ZU1vZHVsZUFjdGlvbiIsIm5hdmlnYXRlTW9kZWxBY3Rpb24iLCJnZXRDb250cm9sbGVyUm91dGUiLCJwYXJhbXNDb3VudCIsIk1PRFVMRV9OQU1FIiwiTU9ERUxfTkFNRSIsImdldENvbnRyb2xsZXJSb3V0ZXMiLCJwYXJhbXNEZWVwIiwiZ2V0Um91dGVzIiwiUEFSQU1TX0xFTkdUSCIsImdldENvbW1vbk1lbnUiLCJjaGlsZENvbnN0cnVjdG9yIiwic2VjdGlvbiIsIkxBQkVMUyIsImdldE1lbnUiLCJTdG9yZXMuZ2V0IiwiJC5iaW5kX2NoZWNrZWQiLCIkLnN0b3JlX211dGF0ZSIsIkNPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYIiwiT1BUX0RFRkFVTFRfUEFHRV9TSVpFIiwiT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVIiLCJPUFRfREVGQVVMVF9QQUdFX1JBTkdFIiwiT1BUX0RFRkFVTFRfU09SVF9ESVJFQ1RJT04iLCJPUFRfREVGQVVMVF9TRUFSQ0giLCJPUFRfREVGQVVMVF9SRVRVUk4iLCJPUFRfREVGQVVMVF9DT01CSU5FRCIsIk9QVF9ERUZBVUxUX0NPTUJJTkVEX0FDVElPTiIsIk9QVF9ERUZBVUxUX0NPVU5UX0FDVElPTiIsIk9QVF9ERUZBVUxUX0xJU1RfQUNUSU9OIiwiT1BUX0RFRkFVTFRfU09SVF9GSUVMRCIsIk9QVF9GSUVMRF9OQU1FX1BSRV9QUk9DIiwiREVGQVVMVF9PUFRJT05TIiwiVUlUYWJsZSIsImxpbmtzIiwiZW5kbGVzcyIsImlkRmllbGQiLCJnZXRJdGVtSWQiLCJfaWQiLCJub3RUYWJsZSIsInJhbmRvbSIsInJlZmluZWQiLCJzdGF0ZSIsInBhZ2luYXRpb24iLCJjb3VudCIsInBhZ2VzIiwic3RvcmVzIiwiU3RvcmVzIiwib25Xb3JraW5nVXBkYXRlIiwib25SYXdVcGRhdGUiLCJvbkZpbHRlcmVkVXBkYXRlIiwib25SZWZpbmVkVXBkYXRlIiwib25TZWxlY3RlZFVwZGF0ZSIsIm9uU3RhdGVVcGRhdGUiLCJzZXRDb21iaW5lZEFjdGlvbk5hbWUiLCJzb3J0ZXIiLCJyZW5kZXIiLCJ1cGRhdGVEYXRhIiwicmVmaW5lRmlsdGVyZWQiLCJjbGVhclNlbGVjdGVkIiwib25TZWFyY2hDaGFuZ2UiLCJvblNvcnRlckNoYW5nZSIsIm9uRmlsdGVyQ2hhbmdlIiwiZ2V0U2VsZWN0ZWQiLCJvYmplY3QiLCJzdG9yZSIsImluZHgiLCJ0YWJsZSIsInRhcmdldEVsIiwiZmlsdGVyVUkiLCJnZXRIZWxwZXJzIiwiZ2V0TGlua3MiLCJzaG93U2VsZWN0Iiwic2hvd1NlYXJjaCIsInNob3dTb3J0IiwiJG9uIiwiZGV0YWlsIiwiZ29Ub1BhZ2UiLCJnb1RvTmV4dCIsImdvVG9QcmV2IiwiX3RoaXM1Iiwic2V0U3RhdGUiLCJfdGhpczYiLCJnZXRTdGF0ZSIsIndpdGhvdXRJbnZhbGlkYXRpb24iLCJpbnZhbGlkYXRlRGF0YSIsImdldERlZmF1bHRQYWdlTnVtYmVyIiwiZ2V0RGVmYXVsdFBhZ2VTaXplIiwiZ2V0U29ydGVyRGlyZWN0aW9uIiwicmV0IiwiY2xlYXJGaWx0ZXJlZERhdGEiLCJjbGVhclJhd0RhdGEiLCJjbGVhclJlZmluZWREYXRhIiwiaXNMaXZlIiwic2V0VXBkYXRpbmciLCJzZXRVcGRhdGVkIiwiaWZVcGRhdGluZyIsImdldERhdGFJbnRlcmZhY2UiLCJmYWN0b3J5IiwiZ2V0TG9hZERhdGFBY3Rpb25OYW1lIiwiZ2V0Q29tYmluZWRBY3Rpb25OYW1lIiwiZ2V0Q291bnRBY3Rpb25OYW1lIiwibG9hZERhdGEiLCJxdWVyeSIsIm1heCIsImdvVG9GaXJzdCIsImdvVG9MYXN0IiwidGVzdERhdGFJdGVtIiwic3RyVmFsdWUiLCJrIiwidG9Db21wIiwiZ2V0Um93c0NvdW50IiwiX3RoaXM3IiwidXBkYXRlUGFnaW5hdGlvbiIsIml0ZW1zQ291bnQiLCJfdGhpczgiLCJpdGVtc0Zyb20iLCJwYWdlc0NvdW50IiwicGFnZXNGcm9tIiwicGFnZXNUbyIsIml0ZW1zVG8iLCJhY3RpdmUiLCJfdGhpczkiLCJmdWxsIiwicHJvY2Vzc0RhdGEiLCJfdGhpczAiLCJ0aGF0RmlsdGVyIiwiZmlsdGVyU2VhcmNoIiwidGhhdFNvcnRlciIsInNvcnQiLCJpdGVtMSIsIml0ZW0yIiwidDEiLCJzb3J0QnlGaWVsZCIsInQyIiwibG9jYWxlQ29tcGFyZSIsInNvcnREaXJlY3Rpb24iLCJsb2dnZXIiLCJjaGVja0ZpZWxkc05hbWVzIiwiZmllbGRJZCIsInBhdGhJZCIsInJlYWRGaWVsZFZhbHVlIiwiX3RoaXMxIiwicHJlcHJvY2Vzc2VkIiwiREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IiLCJfdWlDb21wb25lbnQiLCJXZWFrTWFwIiwiX3VpIiwibm90QWN0aW9uVUkiLCJVSUFjdGlvbkNvbnRhaW5lciIsIl9jbGFzc1ByaXZhdGVGaWVsZFNldCIsImluaXRVSSIsImdldFRhcmdldEVsIiwiY2hpbGRyZW4iLCJyZW1vdmVDaGlsZCIsImZpcnN0Q2hpbGQiLCJzZXRMb2FkaW5nIiwicmVzZXRMb2FkaW5nIiwicHJvY2Vzc1Jlc3VsdCIsInNldEZvcm1TdWNjZXNzIiwic2V0Rm9ybUVycm9ycyIsInNob3dTdWNjZXNzIiwiZm9ybSIsImVycm9ycyIsInNob3dFcnJvciIsIkhUTUxFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIm5vdEZvcm1VdGlscyIsImFkZENvbXBvbmVudCIsImFkZFZhcmlhbnRzIiwiYWRkRmllbGQiLCJhY3Rpb25GaWVsZHNJbml0Iiwic3ViRmllbGROYW1lIiwiREVGQVVMVF9GSUVMRCIsImxhYmVsIiwicGxhY2Vob2xkZXIiLCJlbmFibGVkIiwidmlzaWJsZSIsInJlcXVpcmVkIiwidmFsaWRhdGVkIiwidmFsaWQiLCJmaWVsZEluaXQiLCJtdXRhdGlvbiIsInZhcmlhbnRzU291cmNlIiwiaW5pdEZvcm1CeUZpZWxkIiwiZm9ybUZpZWxkc09wdGlvbnMiLCJzdWJGb3JtRmllbGROYW1lIiwibXV0YXRpb25zIiwicmVhZG9ubHkiLCJzZXRGaWVsZEludmFsaWQiLCJzZXRGaWVsZFZhbGlkIiwiZm5hbWUiLCJpc0ZpZWxkVmFsaWQiLCJzZXRGb3JtRmllbGRJbnZhbGlkIiwiZm9ybUVycm9ycyIsImlucHV0U3RhcnRlZCIsImZvcm1MZXZlbEVycm9yIiwic2V0Rm9ybUZpZWxkVmFsaWQiLCJ1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyIsInZhbGlkYXRpb25TdGF0dXMiLCJzZXRGaWVsZHNWaXNpYmlsaXR5IiwiZmllbGRzTGlzdCIsInNldEZpZWxkVmFsdWUiLCJmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCIsImNvbGxlY3REYXRhIiwiZmxhdCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsIkRFRkFVTFRfUlVMRVMiLCJub3RSZWFkb25seSIsImVuYWJsZSIsImRpc2FibGVkIiwiZGlzYWJsZSIsIm5vdEZvcm1SdWxlcyIsIl9hc3NlcnRDbGFzc0JyYW5kIiwiX1JVTEVTIiwiXyIsImV4ZWMiLCJtYXN0ZXIiLCJzbGF2ZXMiLCJERUZBVUxUX0FDVElPTl9OQU1FIiwiX3ZhbGlkYXRpb25SdW5uZXIiLCJfZm9ybSIsIl9hY3Rpb24iLCJfZmllbGRzIiwiX3ZhcmlhbnRzIiwiX25vdEZvcm1fYnJhbmQiLCJXZWFrU2V0Iiwibm90Rm9ybSIsIlVJRm9ybUNvbXBvbmVudCIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsImluaXRGb3JtIiwiaW5pdExpYnMiLCJpbml0RmllbGRzIiwiaW5pdFZhcmlhbnRzIiwiaW5pdFZhbGlkYXRvciIsInJlSW5pdCIsInVwZGF0ZVVJIiwiZ2V0Rm9ybU1hbmlmZXN0IiwiUnVubmVyIiwiZ2V0Rm9ybVZhbGlkYXRvcnMiLCJfZ2V0Rm9ybVByb3BzIiwiZm9ybU9wdGlvbnMiLCJnZXRGb3JtT3B0aW9ucyIsImdldEZvcm1EYXRhIiwiaW5qZWN0ZWRQcm9wcyIsImdldEZvcm1JbmplY3RlZFByb3BzIiwiZ2V0Rm9ybVRhcmdldEVsIiwiX2JpbmRVSUV2ZW50cyIsInZhbGlkYXRlRm9ybSIsIiRzZXQiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiZ2V0Rm9ybUFjdGlvbiIsImdldFJlcG9ydCIsImNsZWFuIiwiRVJST1JfREVGQVVMVCIsInN1Ym1pdCIsInNldEZvcm1BY3Rpb24iLCJnZXRWYXJpYW50IiwibGliIiwiX21pc3NpbmdPdmVycmlkZVdhcm5pbmciLCJ1cGRhdGVGaWVsZCIsImV2IiwiX2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cyIsIm1hc3RlcnMiLCJydWxlcyIsInJ1bGVOYW1lIiwicnVsZVNsYXZlcyIsIl9hZGRNYXN0ZXJTbGF2ZUV2ZW50cyIsIl9leGVjU2xhdmVSdWxlIiwiY21kIiwic2xhdmVGaWVsZCIsIkZvcm1IZWxwZXJzIiwibG9hZGluZyIsIm1pc3NpbmciLCJERUZBVUxUX0ZPUk1fU0VUX05BTUUiLCJfZm9ybVNldENvbXBvbmVudCIsIl9mb3JtQ29tcG9uZW50IiwiX2ZyYW1lIiwiX25vdEZvcm1TZXRfYnJhbmQiLCJub3RGb3JtU2V0IiwiZm9ybUNvbXBvbmVudCIsImZvcm1TZXRDb21wb25lbnQiLCJVSUZvcm1TZXRDb21wb25lbnQiLCJzaG93TW9kZXMiLCJzZXRGb3JtTW9kZSIsImdldEZyYW1lVGFyZ2V0RWwiLCJfZ2V0RnJhbWVQcm9wcyIsInVwZGF0ZUZvcm0iLCJpc01vZGVFeGlzdHMiLCJnZXRGaXJzdE1vZGUiLCJ1cGRhdGVGb3JtTW9kZUluVUkiLCJnZXRGb3JtTW9kZSIsImRlc3Ryb3lGb3JtIiwicmVuZGVyRm9ybSIsImZvcm1Db25maWciLCJnZXRGb3JtQ29uZmlnIiwiY2hhbmdlTW9kZSIsImNvbnRhaW5lckVsIiwibGFzdENoaWxkIiwiZGVzdHJveUZyYW1lIiwiZm9ybXMiLCJsb2NhbF91aV9wcm9wcyIsIiQiLCJub3RCcmVhZGNydW1icyIsImluaXRVSVByb3BzIiwiZ2V0QnJlYWRjcnVtYnMiLCJnbyIsIlVJQ29uc3RydWN0b3IiLCJtb3VudCIsInNldEhlYWQiLCJoZWFkIiwic2V0VGFpbCIsInRhaWwiLCJjcnVtYnMiLCJ1bW91bnQiLCJVSUJyZWFkY3J1bWJzIiwiTWVudSIsImhpZGUiLCJzZXRPcHRpb25zQWRhcHRlciIsIm9wdGlvbnNBZGFwdGVyIiwiaXNEaXJlY3ROYXZpZ2F0aW9uIiwiZGlyZWN0TmF2aWdhdGlvbiIsImluaXRGaWVsZCIsIkRFRkFVTFQiLCJzb3J0TGlzdCIsInByaW9yaXR5IiwicmVtb3ZlRHVibGljYXRlcyIsInNlY3Rpb25zIiwicHJlcGFyZURhdGEiLCJzZWN0aW9uVGl0bGUiLCJtZW51IiwidW5tb3VudCIsInVwZGF0ZUluZGljYXRvciIsInNlY3Rpb25JZCIsIml0ZW1JZCIsInVwZGF0ZVNlY3Rpb24iLCJpbmRpY2F0b3IiLCJ1cGRhdGVJdGVtIiwidXBkYXRlVGFnIiwidGFnIiwidXBkYXRlU2VjdGlvblRhZyIsInVwZGF0ZUl0ZW1UYWciLCJ1cGRhdGVTZWN0aW9uSXRlbXMiLCJvbGRMaXN0IiwiaXNUb3VjaCIsImdldFNlY3Rpb25Db21wb25lbnQiLCJfTWVudSIsIm9wZW4iLCJ1cmxzIiwiZ2V0TmF2aWdhdGVGdW5jdGlvbiIsInNob3J0IiwiU2lkZU1lbnVTdGF0ZSIsIlNpZGVNZW51U3RvcmUiLCJUWVBFIiwiTUVOVV9QUk9QUyIsIm5vdFRvcE1lbnUiLCJpbml0TWVudVByb3BzIiwiYnJhbmQiLCJzZXRBcHAiLCJ0YXJnZXRTZWxlY3RvciIsIlVJTmF2YmFyIiwidXBkYXRlTWVudUFjdGl2ZUl0ZW0iLCJJTlRFUlZBTF9VUERBVEVfQUNUSVZFX0lURU0iLCJ1cGRhdGVNZW51IiwibGFzdExvY2F0aW9uIiwic2hvdyIsInNldEJ1cmdlclN0YXRlIiwibWVudUNsb3NlZCIsIl9ub3RUb3BNZW51IiwicGxhY2UiLCJVSUljb24iLCJNRU5VX1VJX1BST1BTIiwibm90U2lkZU1lbnUiLCJpbml0TWVudVVJUHJvcHMiLCJjcmVhdGVVSSIsIlVJU2lkZU1lbnUiLCJpbml0U2l6ZVJlc3BvbnNlIiwiYmluZFRvZ2dsZSIsIml0ZW1Jc0FjdGl2ZSIsIml0ZW1VUkwiLCJuYXYiLCJhc2lkZSIsIm1haW4iLCJyZXNpemVBc2lkZUFuZE1haW4iLCJyZXNpemVNYWluIiwic3R5bGUiLCJkaXNwbGF5IiwibWFyZ2luTGVmdCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoZWlnaHQiLCJ3aWR0aCIsImxlZnQiLCJyZXNpemVBc2lkZSIsImlubmVySGVpZ2h0IiwibWFyZ2luVG9wIiwidG9nZ2xlU2VsZWN0b3IiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNPcGVuIiwiX25vdFNpZGVNZW51IiwiY2xvc2VkIiwiREVGQVVMVF9UUkFTRk9STUVSIiwiQUNUSU9OIiwiVElUTEUiLCJkYXRhUHJvdmlkZXIiLCJnb0JhY2siLCJfY2xhc3MiLCJzZXRCcmVhZGNydW1icyIsInByZWxvYWRWYXJpYW50cyIsIiRkZXN0cm95VUkiLCJyZXN1bHRUcmFuc2Zvcm1lciIsImdldENvbnRhaW5lcklubmVyRWxlbWVudCIsInNob3dFcnJvck1lc3NhZ2UiLCJQUkVMT0FEQUJMRSIsIkNSVURWYXJpYW50c1ByZWxvYWRlciIsInByZWxvYWQiLCJsaWJQcm9wcyIsInByb21zIiwiTW9kZWwiLCJyZXN1bHRzIiwicHJvcE5hbWUiLCJyZXN1bHRzTGlzdCIsIkRFRkFVTFRfQUNUSU9OIiwibm90Q1JVRFJvdXRlciIsImV4dHJhY3RBY3Rpb25OYW1lIiwiYWN0aW9uSGFuZGxlckV4aXN0cyIsInJ1bkFjdGlvbiIsIkNSVURNZXNzYWdlIiwic2V0VUkiLCJVSUVycm9yIiwic3VjY2VzcyIsIlVJU3VjY2VzcyIsIkRFRkFVTFRfQlJFQURDUlVNQl9UQUlMIiwiQ1JVREdlbmVyaWNBY3Rpb24iLCJwcmVzZXQiLCJnZXRCcmVhZGNydW1ic1RhaWwiLCJicmVhZGNydW1ic1RhaWxzIiwiZGVhZnVsdEJyZWFkY3J1bWJzVGFpbCIsImdldElkRmllbGQiLCJsb2FkRGF0YVF1ZXJ5IiwiZ2V0TW9kZWxBY3Rpb25OYW1lIiwiTU9ERUxfQUNUSU9OX0dFVCIsInByZXNldEJyZWFkY3J1bWJzIiwiZ2V0VGl0bGUiLCJjb250b2xsZXIiLCJnZXRJdGVtVGl0bGUiLCJicmVhZGNydW1ic1RhaWxUZW1wbGF0ZSIsImlzUmVzcG9uc2VCYWQiLCJnZXRWYWxpZGF0b3JzIiwicHJlcGFyZVVJT3B0aW9ucyIsImRldGFpbHNBY3Rpb25OYW1lIiwidmFsaWRhdG9ycyIsImluamVjdGVkIiwiVFJBTlNGT1JNRVIiLCJnZXRVSSIsInNldFVJTG9hZGluZyIsInNldFVJTG9hZGVkIiwic2V0VUlFcnJvciIsImJpbmRVSUV2ZW50cyIsImJpbmRVSUV2ZW50IiwiaXNVSVJlbmRlcmVkIiwidHdlYWtVSU9wdGlvbnMiLCJ1aUNvbXBvbmVudCIsInJlbmRlckxvYWRpbmdTY3JlZW4iLCJyZW1vdmVMb2FkaW5nU2NyZWVuIiwiZ29CYWNrQWZ0ZXJEZWxheSIsIk5BVklHQVRJT05fREVMQVkiLCJDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSIsIl9DUlVER2VuZXJpY0FjdGlvbiIsImRlZkRhdGEiLCJjcmVhdGVEZWZhdWx0Iiwib25BY3Rpb25TdWJtaXQiLCJDUlVEQWN0aW9uQ3JlYXRlIiwiX0NSVURHZW5lcmljQWN0aW9uQ3JlIiwiQ1JVREdlbmVyaWNBY3Rpb25SZWFkIiwiQ1JVREFjdGlvbkRldGFpbHMiLCJfQ1JVREdlbmVyaWNBY3Rpb25SZWEiLCJDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSIsIk1PREVMX0FDVElPTl9QVVQiLCJDUlVEQWN0aW9uVXBkYXRlIiwiX0NSVURHZW5lcmljQWN0aW9uVXBkIiwiTU9ERUxfQUNUSU9OIiwiQ1JVREFjdGlvbkRlbGV0ZSIsImxvYWRlckFjdGl2ZSIsImxvYWRlclN0eWxlIiwibG9hZGVyVGl0bGUiLCJjb250YWluZXIiLCJjb25maXJtIiwiZGVsZXRlQWN0aW9uTmFtZSIsImdvTGlzdCIsIkNSVURBY3Rpb25MaXN0IiwidHdlYWtBY3Rpb25zTGlzdCIsIkFDVElPTlNfTElTVCIsImdvQ3JlYXRlIiwiY3JlYXRlQWN0aW9uc0J1dHRvbnMiLCJwcmVwZW5kIiwib25seUljb25zIiwiQUNUSU9OUyIsImRldGFpbHMiLCJnb0RldGFpbHMiLCJpY29uIiwiZ29VcGRhdGUiLCJkZWxldGUiLCJnb0RlbGV0ZSIsImFjdGlvbnNCdXR0b25zIiwicHJlcGFyZU9wdGlvbnMiLCJERUZBVUxUX09QVElPTlNfVEFCTEUiLCJpbnRlcmZhY2UiLCJjb21iaW5lZCIsIlRBQkxFX09QVElPTlMiLCJvcHRWYWwiLCJCUkVBRENSVU1CUyIsIlRJVExFX0ZJRUxEU19QUklPUklUWSIsIkxPQURJTkdfU0NSRUVOX1VJX05BTUUiLCJfYWN0aW9ucyIsIl9yb3V0ZXIiLCJfcHJlbG9hZGVyIiwibm90Q1JVRCIsIl9ub3RDb250cm9sbGVyIiwicHJlbG9hZGVyIiwiQ1JVREFjdGlvbnMiLCJDUlVEUm91dGVyIiwiYnVpbGRGcmFtZSIsInNldFZhbGlkYXRvcnMiLCJNb2R1bGVOYW1lUGFydHMiLCJzcGxpdCIsIk1vZHVsZU5hbWUiLCJzZXJ2aWNlTmFtZSIsIkNvbW1vbk1vZHVsZVNlcnZpY2UiLCJhdWdtZW50VmFsaWRhdG9ycyIsIm5ld0hlYWQiLCJzdGFydFdoZW5XU0NsaWVudFJlYWR5IiwiaXNDb25uZWN0ZWQiLCJvbmNlIiwiV1NfQ0hFQ0tfSU5URVJWQUwiLCJiYWNrVG9MaXN0IiwibGlua0JhY2tUb0xpc3QiLCJhZnRlckFjdGlvbiIsIm5hdkJhY2siLCJiYWNrIiwiY3JlYXRlRWxlbWVudCIsImdldEZyYW1lQ2xhc3NlcyIsIlRPUF9DTEFTUyIsImFwcGVuZENoaWxkIiwiTUFJTl9DTEFTUyIsImJvdHRvbSIsIkJPVFRPTV9DTEFTUyIsImdldENvbnRhaW5lclRvcEVsZW1lbnQiLCJnZXRDb250YWluZXJCb3R0b21FbGVtZW50IiwiZ2V0VGl0bGVGcm9tTGliIiwiZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlIiwiZ2V0UHJlbG9hZGVkVmFyaWFudHMiLCJnb0FmdGVyRGVsYXkiLCJhY3Rpb25VSSIsImRlc3Ryb3lVSUJ5TmFtZSIsInNob3dTdWNjZXNzTWVzc2FnZSIsInNpbmdsZVVJIiwiZ2V0QWN0aW9uVUkiLCJjcmVhdGVMb2FkZXJVSSIsIlVJTG9hZGVyIiwiaXRlbUN1c3RvbVByb3BzIiwiUk9VVEVfTElTVCIsIm5vdENSVURQbGFpblJvdXRlciIsIkRFRkFVTFRfUk9VVEUiLCJub3RDUlVEUm91dGVyU3dpdGNoIiwiaXNSb3V0ZVZhcmlhbnRWYWxpZCIsInJvdXRlc1ZhcmlhbnRzIiwiZGV0ZXJtaW5lUm91dGUiLCJyb3V0ZXJBY3Rpb24iLCJlbXB0eVJlc3VsdCIsInNraXAiLCJub3RTZXJ2aWNlTW9kZWxTZWFyY2giLCJnZXRTZWFyY2hSb3V0ZU5hbWUiLCJnZXREYXRhTG9hZFJvdXRlTmFtZSIsInRyYW5zZm9ybVNlYXJjaFJlc3VsdCIsInVzZXJuYW1lIiwidHJhbnNmb3JtU2VsZWN0ZWRSZXN1bHQiLCJzZWFyY2hCeVRlcm0iLCJ0ZXJtIiwib3BlblNlbGVjdG9yIiwiVUlHZW5lcmljU2VsZWN0b3IiLCJjb25zb2xlIiwibmNDUlVEIiwiTG9jYWxlIiwiRWxlbWVudHMiLCJGcmFtZSIsImNvbXBvbmVudHNTZXROYW1lIiwiY29tcG9uZW50TmFtZSJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsV0FBZSxJQUFJOztDQ0FuQjtDQUNBO0NBQ08sSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDLE9BQU87Q0FD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QUc7Q0FDSCxFQUFFO0NBQ0YsQ0FBQyxDQUFDLENBQUM7Q0FDSDs7Q0NoQ0EsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFRLFNBQVNDLE1BQUksRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFH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Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBRTtDQUN0RCxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFFBQVEsR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxNQUFNLEdBQUcsUUFBUSxFQUFFLEdBQUcsTUFBTTs7Q0FFcEYsQ0FBQyxJQUFJLEtBQUssR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUM7O0NBRW5DO0NBQ0EsQ0FBQyxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxLQUFLLE1BQU0sR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDLFNBQVM7Q0FDbEUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7Q0FDaEUsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLFdBQVc7Q0FDdkIsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLFlBQVk7O0NBRXhCO0NBQ0EsQ0FBQyxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDM0IsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxLQUFLLEdBQUcsSUFBSTtDQUM1QyxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDLE1BQU0sR0FBRyxJQUFJOztDQUU5QztDQUNBLENBQUMsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUU7Q0FDckMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFB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QyxVQUFDMDRDLGlCQUFpQixFQUFLO0NBQ2pEdjhDLEVBQUFBLE1BQU0sQ0FBQ3NILElBQUksQ0FBQyswQyxRQUFRLENBQUNFLGlCQUFpQixDQUFDLENBQUMsQ0FBQzE0QyxPQUFPLENBQUMsVUFBQzI0QyxhQUFhLEVBQUs7Q0FDaEVGLElBQUFBLGNBQWtCLENBQUNuYSxZQUFZLENBQzNCcWEsYUFBYSxFQUNiSCxRQUFRLENBQUNFLGlCQUFpQixDQUFDLENBQUNDLGFBQWEsQ0FDN0MsQ0FBQztDQUNMLEVBQUEsQ0FBQyxDQUFDO0NBQ04sQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDcyLDczLDc0LDEwMCwxMDEsMTAyLDEwMywxMDQsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwXX0=
