var notBulma = (function (exports) {
	'use strict';

	var DEV = true;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run$1(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */
	const LEGACY_DERIVED_PROP = 1 << 17;
	const INSPECT_EFFECT = 1 << 18;
	const HEAD_EFFECT = 1 << 19;
	const EFFECT_HAS_DERIVED = 1 << 20;

	const STATE_SYMBOL = Symbol('$state');
	const STATE_SYMBOL_METADATA = Symbol('$state metadata');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/** @import { Equals } from '#client' */
	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
	 * @returns {never}
	 */
	function bind_invalid_checkbox_value() {
		{
			const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		{
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Failed to hydrate the application
	 * @returns {never}
	 */
	function hydration_failed() {
		{
			const error = new Error(`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`
	 * @returns {never}
	 */
	function invalid_snippet() {
		{
			const error = new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%name%(...)` cannot be used in runes mode
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_legacy_only(name) {
		{
			const error = new Error(`lifecycle_legacy_only\n\`${name}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Rest element properties of `$props()` such as `%property%` are readonly
	 * @param {string} property
	 * @returns {never}
	 */
	function props_rest_readonly(property) {
		{
			const error = new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		{
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state
	 * @returns {never}
	 */
	function state_unsafe_local_read() {
		{
			const error = new Error(`state_unsafe_local_read\nReading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state\nhttps://svelte.dev/e/state_unsafe_local_read`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			const error = new Error(`state_unsafe_mutation\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	let legacy_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const HYDRATION_START = '[';
	/** used to indicate that an `{:else}...` block was rendered */
	const HYDRATION_START_ELSE = '[!';
	const HYDRATION_END = ']';
	const HYDRATION_ERROR = {};

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold$1 = 'font-weight: bold';
	var normal$1 = 'font-weight: normal';

	/**
	 * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:
	 * 
	 * %properties%
	 * @param {string | undefined | null} [properties]
	 */
	function state_snapshot_uncloneable(properties) {
		{
			console.warn(`%c[svelte] state_snapshot_uncloneable\n%c${properties
			? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}`
			: "Value cannot be cloned with `$state.snapshot` — the original value was returned"}\nhttps://svelte.dev/e/state_snapshot_uncloneable`, bold$1, normal$1);
		}
	}

	/** @import { Snapshot } from './types' */

	/**
	 * In dev, we keep track of which properties could not be cloned. In prod
	 * we don't bother, but we keep a dummy array around so that the
	 * signature stays the same
	 * @type {string[]}
	 */
	const empty = [];

	/**
	 * @template T
	 * @param {T} value
	 * @param {boolean} [skip_warning]
	 * @returns {Snapshot<T>}
	 */
	function snapshot(value, skip_warning = false) {
		if (!skip_warning) {
			/** @type {string[]} */
			const paths = [];

			const copy = clone(value, new Map(), '', paths);
			if (paths.length === 1 && paths[0] === '') {
				// value could not be cloned
				state_snapshot_uncloneable();
			} else if (paths.length > 0) {
				// some properties could not be cloned
				const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
				const excess = paths.length - slice.length;

				let uncloned = slice.map((path) => `- <value>${path}`).join('\n');
				if (excess > 0) uncloned += `\n- ...and ${excess} more`;

				state_snapshot_uncloneable(uncloned);
			}

			return copy;
		}

		return clone(value, new Map(), '', empty);
	}

	/**
	 * @template T
	 * @param {T} value
	 * @param {Map<T, Snapshot<T>>} cloned
	 * @param {string} path
	 * @param {string[]} paths
	 * @param {null | T} original The original value, if `value` was produced from a `toJSON` call
	 * @returns {Snapshot<T>}
	 */
	function clone(value, cloned, path, paths, original = null) {
		if (typeof value === 'object' && value !== null) {
			var unwrapped = cloned.get(value);
			if (unwrapped !== undefined) return unwrapped;

			if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value));
			if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value));

			if (is_array(value)) {
				var copy = /** @type {Snapshot<any>} */ (Array(value.length));
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var i = 0; i < value.length; i += 1) {
					var element = value[i];
					if (i in value) {
						copy[i] = clone(element, cloned, `${path}[${i}]` , paths);
					}
				}

				return copy;
			}

			if (get_prototype_of(value) === object_prototype) {
				/** @type {Snapshot<any>} */
				copy = {};
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var key in value) {
					// @ts-expect-error
					copy[key] = clone(value[key], cloned, `${path}.${key}` , paths);
				}

				return copy;
			}

			if (value instanceof Date) {
				return /** @type {Snapshot<T>} */ (structuredClone(value));
			}

			if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function') {
				return clone(
					/** @type {T & { toJSON(): any } } */ (value).toJSON(),
					cloned,
					`${path}.toJSON()` ,
					paths,
					// Associate the instance with the toJSON clone
					value
				);
			}
		}

		if (value instanceof EventTarget) {
			// can't be cloned
			return /** @type {Snapshot<T>} */ (value);
		}

		try {
			return /** @type {Snapshot<T>} */ (structuredClone(value));
		} catch (e) {
			{
				paths.push(path);
			}

			return /** @type {Snapshot<T>} */ (value);
		}
	}

	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	let inspect_effects = new Set();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			version: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 */
	function state(v) {
		return push_derived_source(source(v));
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	function mutable_state(v, immutable = false) {
		return push_derived_source(mutable_source(v, immutable));
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function push_derived_source(source) {
		if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
			if (derived_sources === null) {
				set_derived_sources([source]);
			} else {
				derived_sources.push(source);
			}
		}

		return source;
	}

	/**
	 * @template V
	 * @param {Value<V>} source
	 * @param {V} value
	 */
	function mutate(source, value) {
		set(
			source,
			untrack(() => get$2(source))
		);
		return value;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function set(source, value) {
		if (
			active_reaction !== null &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			// If the source was created locally within the current derived, then
			// we allow the mutation.
			(derived_sources === null || !derived_sources.includes(source))
		) {
			state_unsafe_mutation();
		}

		return internal_set(source, value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			source.v = value;
			source.version = increment_version();

			mark_reactions(source, DIRTY);

			// If the current signal is running for the first time, it won't have any
			// reactions as we only allocate and assign the reactions after the signal
			// has fully executed. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & BRANCH_EFFECT) === 0
			) {
				if (new_deps !== null && new_deps.includes(source)) {
					set_signal_status(active_effect, DIRTY);
					schedule_effect(active_effect);
				} else {
					if (untracked_writes === null) {
						set_untracked_writes([source]);
					} else {
						untracked_writes.push(source);
					}
				}
			}

			if (inspect_effects.size > 0) {
				const inspects = Array.from(inspect_effects);
				var previously_flushing_effect = is_flushing_effect;
				set_is_flushing_effect(true);
				try {
					for (const effect of inspects) {
						// Mark clean inspect-effects as maybe dirty and then check their dirtiness
						// instead of just updating the effects - this way we avoid overfiring.
						if ((effect.f & CLEAN) !== 0) {
							set_signal_status(effect, MAYBE_DIRTY);
						}
						if (check_dirtiness(effect)) {
							update_effect(effect);
						}
					}
				} finally {
					set_is_flushing_effect(previously_flushing_effect);
				}
				inspect_effects.clear();
			}
		}

		return value;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if ((flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value
	 * @param {string} attribute
	 * @param {string} html
	 * @param {string} value
	 */
	function hydration_attribute_changed(attribute, html, value) {
		{
			console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${attribute}\` attribute on \`${html}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`, bold, normal);
		}
	}

	/**
	 * The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value
	 * @param {string | undefined | null} [location]
	 */
	function hydration_html_changed(location) {
		{
			console.warn(`%c[svelte] hydration_html_changed\n%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}\nhttps://svelte.dev/e/hydration_html_changed`, bold, normal);
		}
	}

	/**
	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
	 * @param {string | undefined | null} [location]
	 */
	function hydration_mismatch(location) {
		{
			console.warn(`%c[svelte] hydration_mismatch\n%c${"Hydration failed because the initial UI does not match what was rendered on the server"}\nhttps://svelte.dev/e/hydration_mismatch`, bold, normal);
		}
	}

	/**
	 * The `render` function passed to `createRawSnippet` should return HTML for a single element
	 */
	function invalid_raw_snippet_render() {
		{
			console.warn(`%c[svelte] invalid_raw_snippet_render\n%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element\nhttps://svelte.dev/e/invalid_raw_snippet_render`, bold, normal);
		}
	}

	/**
	 * Tried to unmount a component that was not mounted
	 */
	function lifecycle_double_unmount() {
		{
			console.warn(`%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
		}
	}

	/**
	 * %parent% passed a value to %child% with `bind:`, but the value is owned by %owner%. Consider creating a binding between %owner% and %parent%
	 * @param {string} parent
	 * @param {string} child
	 * @param {string} owner
	 */
	function ownership_invalid_binding(parent, child, owner) {
		{
			console.warn(`%c[svelte] ownership_invalid_binding\n%c${parent} passed a value to ${child} with \`bind:\`, but the value is owned by ${owner}. Consider creating a binding between ${owner} and ${parent}\nhttps://svelte.dev/e/ownership_invalid_binding`, bold, normal);
		}
	}

	/**
	 * %component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead
	 * @param {string | undefined | null} [component]
	 * @param {string | undefined | null} [owner]
	 */
	function ownership_invalid_mutation(component, owner) {
		{
			console.warn(`%c[svelte] ownership_invalid_mutation\n%c${component ? `${component} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : "Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead"}\nhttps://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {boolean} value */
	function set_hydrating(value) {
		hydrating = value;
	}

	/**
	 * The node that is currently being hydrated. This starts out as the first node inside the opening
	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
	 * time we leave the block it is the closing comment, which serves as the block's anchor.
	 * @type {TemplateNode}
	 */
	let hydrate_node;

	/** @param {TemplateNode} node */
	function set_hydrate_node(node) {
		if (node === null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return (hydrate_node = node);
	}

	function hydrate_next() {
		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
	}

	/** @param {TemplateNode} node */
	function reset(node) {
		if (!hydrating) return;

		// If the node has remaining siblings, something has gone wrong
		if (get_next_sibling(hydrate_node) !== null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		hydrate_node = node;
	}

	function next(count = 1) {
		if (hydrating) {
			var i = count;
			var node = hydrate_node;

			while (i--) {
				node = /** @type {TemplateNode} */ (get_next_sibling(node));
			}

			hydrate_node = node;
		}
	}

	/**
	 * Removes all nodes starting at `hydrate_node` up until the next hydration end comment
	 */
	function remove_nodes() {
		var depth = 0;
		var node = hydrate_node;

		while (true) {
			if (node.nodeType === 8) {
				var data = /** @type {Comment} */ (node).data;

				if (data === HYDRATION_END) {
					if (depth === 0) return node;
					depth -= 1;
				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
					depth += 1;
				}
			}

			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
			node.remove();
			node = next;
		}
	}

	/** @import { ProxyMetadata } from '#client' */
	/** @typedef {{ file: string, line: number, column: number }} Location */


	/** @type {Record<string, Array<{ start: Location, end: Location, component: Function }>>} */
	const boundaries = {};

	const chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
	const firefox_pattern = /@(.+):(\d+):(\d+)$/;

	function get_stack() {
		const stack = new Error().stack;
		if (!stack) return null;

		const entries = [];

		for (const line of stack.split('\n')) {
			let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);

			if (match) {
				entries.push({
					file: match[1],
					line: +match[2],
					column: +match[3]
				});
			}
		}

		return entries;
	}

	/**
	 * Determines which `.svelte` component is responsible for a given state change
	 * @returns {Function | null}
	 */
	function get_component() {
		// first 4 lines are svelte internals; adjust this number if we change the internal call stack
		const stack = get_stack()?.slice(4);
		if (!stack) return null;

		for (let i = 0; i < stack.length; i++) {
			const entry = stack[i];
			const modules = boundaries[entry.file];
			if (!modules) {
				// If the first entry is not a component, that means the modification very likely happened
				// within a .svelte.js file, possibly triggered by a component. Since these files are not part
				// of the bondaries/component context heuristic, we need to bail in this case, else we would
				// have false positives when the .svelte.ts file provides a state creator function, encapsulating
				// the state and its mutations, and is being called from a component other than the one who
				// called the state creator function.
				if (i === 0) return null;
				continue;
			}

			for (const module of modules) {
				if (module.end == null) {
					return null;
				}
				if (module.start.line < entry.line && module.end.line > entry.line) {
					return module.component;
				}
			}
		}

		return null;
	}

	const ADD_OWNER = Symbol('ADD_OWNER');

	/**
	 * @param {any} object
	 * @param {any} owner
	 * @param {boolean} [global]
	 * @param {boolean} [skip_warning]
	 */
	function add_owner(object, owner, global = false, skip_warning = false) {
		if (object && !global) {
			const component = dev_current_component_function;
			const metadata = object[STATE_SYMBOL_METADATA];
			if (metadata && !has_owner(metadata, component)) {
				let original = get_owner(metadata);

				if (owner[FILENAME] !== component[FILENAME] && !skip_warning) {
					ownership_invalid_binding(component[FILENAME], owner[FILENAME], original[FILENAME]);
				}
			}
		}

		add_owner_to_object(object, owner, new Set());
	}

	/**
	 * @param {ProxyMetadata | null} from
	 * @param {ProxyMetadata} to
	 */
	function widen_ownership(from, to) {
		if (to.owners === null) {
			return;
		}

		while (from) {
			if (from.owners === null) {
				to.owners = null;
				break;
			}

			for (const owner of from.owners) {
				to.owners.add(owner);
			}

			from = from.parent;
		}
	}

	/**
	 * @param {any} object
	 * @param {Function} owner
	 * @param {Set<any>} seen
	 */
	function add_owner_to_object(object, owner, seen) {
		const metadata = /** @type {ProxyMetadata} */ (object?.[STATE_SYMBOL_METADATA]);

		if (metadata) {
			// this is a state proxy, add owner directly, if not globally shared
			if ('owners' in metadata && metadata.owners != null) {
				metadata.owners.add(owner);
			}
		} else if (object && typeof object === 'object') {
			if (seen.has(object)) return;
			seen.add(object);
			if (ADD_OWNER in object && object[ADD_OWNER]) {
				// this is a class with state fields. we put this in a render effect
				// so that if state is replaced (e.g. `instance.name = { first, last }`)
				// the new state is also co-owned by the caller of `getContext`
				render_effect(() => {
					object[ADD_OWNER](owner);
				});
			} else {
				var proto = get_prototype_of(object);

				if (proto === Object.prototype) {
					// recurse until we find a state proxy
					for (const key in object) {
						add_owner_to_object(object[key], owner, seen);
					}
				} else if (proto === Array.prototype) {
					// recurse until we find a state proxy
					for (let i = 0; i < object.length; i += 1) {
						add_owner_to_object(object[i], owner, seen);
					}
				}
			}
		}
	}

	/**
	 * @param {ProxyMetadata} metadata
	 * @param {Function} component
	 * @returns {boolean}
	 */
	function has_owner(metadata, component) {
		if (metadata.owners === null) {
			return true;
		}

		return (
			metadata.owners.has(component) ||
			(metadata.parent !== null && has_owner(metadata.parent, component))
		);
	}

	/**
	 * @param {ProxyMetadata} metadata
	 * @returns {any}
	 */
	function get_owner(metadata) {
		return (
			metadata?.owners?.values().next().value ??
			get_owner(/** @type {ProxyMetadata} */ (metadata.parent))
		);
	}

	/**
	 * @param {ProxyMetadata} metadata
	 */
	function check_ownership(metadata) {

		const component = get_component();

		if (component && !has_owner(metadata, component)) {
			let original = get_owner(metadata);

			// @ts-expect-error
			if (original[FILENAME] !== component[FILENAME]) {
				// @ts-expect-error
				ownership_invalid_mutation(component[FILENAME], original[FILENAME]);
			} else {
				ownership_invalid_mutation();
			}
		}
	}

	/** @import { ProxyMetadata, ProxyStateObject, Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @param {ProxyMetadata | null} [parent]
	 * @param {Source<T>} [prev] dev mode only
	 * @returns {T}
	 */
	function proxy(value, parent = null, prev) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = source(0);

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', source(/** @type {any[]} */ (value).length));
		}

		/** @type {ProxyMetadata} */
		var metadata;

		{
			metadata = {
				parent,
				owners: null
			};

			{
				metadata.owners =
					parent === null
						? component_context !== null
							? new Set([component_context.function])
							: null
						: new Set();
			}
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = source(descriptor.value);
					sources.set(prop, s);
				} else {
					set(s, proxy(descriptor.value, metadata));
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(prop, source(UNINITIALIZED));
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL_METADATA) {
					return metadata;
				}

				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get$2(s);

					// In case of something like `foo = bar.map(...)`, foo would have ownership
					// of the array itself, while the individual items would have ownership
					// of the component that created bar. That means if we later do `foo[0].baz = 42`,
					// we could get a false-positive ownership violation, since the two proxies
					// are not connected to each other via the parent metadata relationship.
					// For this reason, we need to widen the ownership of the children
					// upon access when we detect they are not connected.
					{
						/** @type {ProxyMetadata | undefined} */
						var prop_metadata = v?.[STATE_SYMBOL_METADATA];
						if (prop_metadata && prop_metadata?.parent !== metadata) {
							widen_ownership(metadata, prop_metadata);
						}
					}

					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get$2(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL_METADATA) {
					return true;
				}

				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);
						sources.set(prop, s);
					}

					var value = get$2(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = source(UNINITIALIZED);
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = source(undefined);
						set(s, proxy(value, metadata));
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set(s, proxy(value, metadata));
				}

				{
					/** @type {ProxyMetadata | undefined} */
					var prop_metadata = value?.[STATE_SYMBOL_METADATA];
					if (prop_metadata && prop_metadata?.parent !== metadata) {
						widen_ownership(metadata, prop_metadata);
					}
					check_ownership(metadata);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get$2(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
			return value[STATE_SYMBOL];
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		// the following assignments improve perf of lookups on DOM nodes
		// @ts-expect-error
		element_prototype.__click = undefined;
		// @ts-expect-error
		element_prototype.__className = '';
		// @ts-expect-error
		element_prototype.__attributes = null;
		// @ts-expect-error
		element_prototype.__styles = null;
		// @ts-expect-error
		element_prototype.__e = undefined;

		// @ts-expect-error
		Text.prototype.__t = undefined;

		{
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		if (!hydrating) {
			return get_first_child(node);
		}

		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
		if (child === null) {
			child = hydrate_node.appendChild(create_text());
		} else if (is_text && child.nodeType !== 3) {
			var text = create_text();
			child?.before(text);
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(child);
		return child;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		if (!hydrating) {
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}

		// if an {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && hydrate_node?.nodeType !== 3) {
			var text = create_text();

			hydrate_node?.before(text);
			set_hydrate_node(text);
			return text;
		}

		return hydrate_node;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = hydrating ? hydrate_node : node;
		var last_sibling;

		while (count--) {
			last_sibling = next_sibling;
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		if (!hydrating) {
			return next_sibling;
		}

		var type = next_sibling?.nodeType;

		// if a sibling {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && type !== 3) {
			var text = create_text();
			// If the next sibling is `null` and we're handling text then it's because
			// the SSR content was empty for the text, so we need to generate a new text
			// node and insert it after the last sibling
			if (next_sibling === null) {
				last_sibling?.after(text);
			} else {
				next_sibling.before(text);
			}
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(next_sibling);
		return /** @type {TemplateNode} */ (next_sibling);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;

		if (active_effect === null) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		/** @type {Derived<V>} */
		const signal = {
			children: null,
			ctx: component_context,
			deps: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			v: /** @type {V} */ (null),
			version: 0,
			parent: parent_derived ?? active_effect
		};

		if (parent_derived !== null) {
			(parent_derived.children ??= []).push(signal);
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_children(derived) {
		var children = derived.children;

		if (children !== null) {
			derived.children = null;

			for (var i = 0; i < children.length; i += 1) {
				var child = children[i];
				if ((child.f & DERIVED) !== 0) {
					destroy_derived(/** @type {Derived} */ (child));
				} else {
					destroy_effect(/** @type {Effect} */ (child));
				}
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_children(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.version = increment_version();
		}
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived(derived) {
		destroy_derived_children(derived);
		remove_reactions(derived, 0);
		set_signal_status(derived, DESTROYED);

		derived.v = derived.children = derived.deps = derived.ctx = derived.reactions = null;
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var is_root = (type & ROOT_EFFECT) !== 0;
		var parent_effect = active_effect;

		{
			// Ensure the parent is never an inspect effect
			while (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {
				parent_effect = parent_effect.parent;
			}
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			deriveds: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent: is_root ? null : parent_effect,
			prev: null,
			teardown: null,
			transitions: null,
			version: 0
		};

		{
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			var previously_flushing_effect = is_flushing_effect;

			try {
				set_is_flushing_effect(true);
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			} finally {
				set_is_flushing_effect(previously_flushing_effect);
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & EFFECT_HAS_DERIVED) === 0;

		if (!inert && !is_root && push) {
			if (parent_effect !== null) {
				push_effect(effect, parent_effect);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.children ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		{
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		{
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return render_effect(fn);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean }} */
		var token = { effect: null, ran: false };
		context.l.r1.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			set(context.l.r2, true);
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			if (!get$2(context.l.r2)) return;

			// Run dirty `$:` statements
			for (var token of context.l.r1) {
				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (check_dirtiness(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}

			context.l.r2.v = false; // set directly to avoid rerunning this effect
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function template_effect(fn) {
		{
			define_property(fn, 'name', {
				value: '{expression}'
			});
		}
		return block(fn);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_effect_deriveds(signal) {
		var deriveds = signal.deriveds;

		if (deriveds !== null) {
			signal.deriveds = null;

			for (var i = 0; i < deriveds.length; i += 1) {
				destroy_derived(deriveds[i]);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;
			destroy_effect(effect, remove_dom);
			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			/** @type {TemplateNode | null} */
			var node = effect.nodes_start;
			var end = effect.nodes_end;

			while (node !== null) {
				/** @type {TemplateNode | null} */
				var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

				node.remove();
				node = next;
			}

			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		destroy_effect_deriveds(effect);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		{
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;

		// If a dependency of this effect changed while it was paused,
		// apply the change now
		if (check_dirtiness(effect)) {
			update_effect(effect);
		}

		// Ensure we toggle the flag after possibly updating the effect so that
		// each block logic can correctly operate on inert items
		effect.f ^= INERT;

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	// Fallback for when requestIdleCallback is not available
	const request_idle_callback =
		typeof requestIdleCallback === 'undefined'
			? (/** @type {() => void} */ cb) => setTimeout(cb, 1)
			: requestIdleCallback;

	let is_micro_task_queued$1 = false;
	let is_idle_task_queued = false;

	/** @type {Array<() => void>} */
	let current_queued_micro_tasks = [];
	/** @type {Array<() => void>} */
	let current_queued_idle_tasks = [];

	function process_micro_tasks() {
		is_micro_task_queued$1 = false;
		const tasks = current_queued_micro_tasks.slice();
		current_queued_micro_tasks = [];
		run_all(tasks);
	}

	function process_idle_tasks() {
		is_idle_task_queued = false;
		const tasks = current_queued_idle_tasks.slice();
		current_queued_idle_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (!is_micro_task_queued$1) {
			is_micro_task_queued$1 = true;
			queueMicrotask(process_micro_tasks);
		}
		current_queued_micro_tasks.push(fn);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_idle_task(fn) {
		if (!is_idle_task_queued) {
			is_idle_task_queued = true;
			request_idle_callback(process_idle_tasks);
		}
		current_queued_idle_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		if (is_micro_task_queued$1) {
			process_micro_tasks();
		}
		if (is_idle_task_queued) {
			process_idle_tasks();
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	const FLUSH_MICROTASK = 0;
	const FLUSH_SYNC = 1;
	// Used for DEV time error handling
	/** @param {WeakSet<Error>} value */
	const handled_errors = new WeakSet();
	let is_throwing_error = false;

	// Used for controlling the flush of effects.
	let scheduler_mode = FLUSH_MICROTASK;
	// Used for handling scheduling
	let is_micro_task_queued = false;

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing_effect = false;
	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_flushing_effect(value) {
		is_flushing_effect = value;
	}

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	let flush_count = 0;
	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a derived, we record them so that we can safely allow
	 * local mutations to these sources without the side-effect error being invoked unnecessarily.
	 * @type {null | Source[]}
	 */
	let derived_sources = null;

	/**
	 * @param {Source[] | null} sources
	 */
	function set_derived_sources(sources) {
		derived_sources = sources;
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds it starts from 1 to differentiate between a created effect and a run one for tracing */
	let current_version = 1;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	// Handling runtime component context
	/** @type {ComponentContext | null} */
	let component_context = null;

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	function increment_version() {
		return ++current_version;
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;

				if ((flags & DISCONNECTED) !== 0) {
					for (i = 0; i < dependencies.length; i++) {
						(dependencies[i].reactions ??= []).push(reaction);
					}

					reaction.f ^= DISCONNECTED;
				}

				for (i = 0; i < dependencies.length; i++) {
					var dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					// If we are working with an unowned signal as part of an effect (due to !skip_reaction)
					// and the version hasn't changed, we still need to check that this reaction
					// is linked to the dependency source – otherwise future updates will not be caught.
					if (
						is_unowned &&
						active_effect !== null &&
						!skip_reaction &&
						!dependency?.reactions?.includes(reaction)
					) {
						(dependency.reactions ??= []).push(reaction);
					}

					if (dependency.version > reaction.version) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 */
	function propagate_error(error, effect) {
		/** @type {Effect | null} */
		var current = effect;

		while (current !== null) {
			if ((current.f & BOUNDARY_EFFECT) !== 0) {
				try {
					// @ts-expect-error
					current.fn(error);
					return;
				} catch {
					// Remove boundary flag from effect
					current.f ^= BOUNDARY_EFFECT;
				}
			}

			current = current.parent;
		}

		is_throwing_error = false;
		throw error;
	}

	/**
	 * @param {Effect} effect
	 */
	function should_rethrow_error(effect) {
		return (
			(effect.f & DESTROYED) === 0 &&
			(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)
		);
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 * @param {Effect | null} previous_effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, previous_effect, component_context) {
		if (is_throwing_error) {
			if (previous_effect === null) {
				is_throwing_error = false;
			}

			if (should_rethrow_error(effect)) {
				throw error;
			}

			return;
		}

		if (previous_effect !== null) {
			is_throwing_error = true;
		}

		if (
			component_context === null ||
			!(error instanceof Error) ||
			handled_errors.has(error)
		) {
			propagate_error(error, effect);
			return;
		}

		handled_errors.add(error);

		const component_stack = [];

		const effect_name = effect.fn?.name;

		if (effect_name) {
			component_stack.push(effect_name);
		}

		/** @type {ComponentContext | null} */
		let current_context = component_context;

		while (current_context !== null) {
			{
				/** @type {string} */
				var filename = current_context.function?.[FILENAME];

				if (filename) {
					const file = filename.split('/').pop();
					component_stack.push(file);
				}
			}

			current_context = current_context.p;
		}

		const indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\t';
		define_property(error, 'message', {
			value: error.message + `\n${component_stack.map((name) => `\n${indent}in ${name}`).join('')}\n`
		});
		define_property(error, 'component_stack', {
			value: component_stack
		});

		const stack = error.stack;

		// Filter out internal files from callstack
		if (stack) {
			const lines = stack.split('\n');
			const new_lines = [];
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				if (line.includes('svelte/src/internal')) {
					continue;
				}
				new_lines.push(line);
			}
			define_property(error, 'stack', {
				value: new_lines.join('\n')
			});
		}

		propagate_error(error, effect);

		if (should_rethrow_error(effect)) {
			throw error;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var prev_derived_sources = derived_sources;
		var previous_component_context = component_context;
		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
		skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
		derived_sources = null;
		component_context = reaction.ctx;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			derived_sources = prev_derived_sources;
			component_context = previous_component_context;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = reactions.indexOf(signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var previous_component_context = component_context;

		active_effect = effect;

		{
			var previous_component_fn = dev_current_component_function;
			dev_current_component_function = effect.component_function;
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}
			destroy_effect_deriveds(effect);

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.version = current_version;

			if (DEV) {
				dev_effect_stack.push(effect);
			}
		} catch (error) {
			handle_error(error, effect, previous_effect, previous_component_context || effect.ctx);
		} finally {
			active_effect = previous_effect;

			{
				dev_current_component_function = previous_component_fn;
			}
		}
	}

	function log_effect_stack() {
		// eslint-disable-next-line no-console
		console.error(
			'Last ten effects were: ',
			dev_effect_stack.slice(-10).map((d) => d.fn)
		);
		dev_effect_stack = [];
	}

	function infinite_loop_guard() {
		if (flush_count > 1000) {
			flush_count = 0;
			try {
				effect_update_depth_exceeded();
			} catch (error) {
				{
					// stack is garbage, ignore. Instead add a console.error message.
					define_property(error, 'stack', {
						value: ''
					});
				}
				// Try and handle the error so it can be caught at a boundary, that's
				// if there's an effect available from when it was last scheduled
				if (last_scheduled_effect !== null) {
					{
						try {
							handle_error(error, last_scheduled_effect, null, null);
						} catch (e) {
							// Only log the effect stack if the error is re-thrown
							log_effect_stack();
							throw e;
						}
					}
				} else {
					{
						log_effect_stack();
					}
					throw error;
				}
			}
		}
		flush_count++;
	}

	/**
	 * @param {Array<Effect>} root_effects
	 * @returns {void}
	 */
	function flush_queued_root_effects(root_effects) {
		var length = root_effects.length;
		if (length === 0) {
			return;
		}
		infinite_loop_guard();

		var previously_flushing_effect = is_flushing_effect;
		is_flushing_effect = true;

		try {
			for (var i = 0; i < length; i++) {
				var effect = root_effects[i];

				if ((effect.f & CLEAN) === 0) {
					effect.f ^= CLEAN;
				}

				/** @type {Effect[]} */
				var collected_effects = [];

				process_effects(effect, collected_effects);
				flush_queued_effects(collected_effects);
			}
		} finally {
			is_flushing_effect = previously_flushing_effect;
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0) {
				try {
					if (check_dirtiness(effect)) {
						update_effect(effect);

						// Effects with no dependencies or teardown do not get added to the effect tree.
						// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
						// don't know if we need to keep them until they are executed. Doing the check
						// here (rather than in `update_effect`) allows us to skip the work for
						// immediate effects.
						if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
							if (effect.teardown === null) {
								// remove this effect from the graph
								unlink_effect(effect);
							} else {
								// keep the effect in the graph, but free up some memory
								effect.fn = null;
							}
						}
					}
				} catch (error) {
					handle_error(error, effect, null, effect.ctx);
				}
			}
		}
	}

	function process_deferred() {
		is_micro_task_queued = false;
		if (flush_count > 1001) {
			return;
		}
		const previous_queued_root_effects = queued_root_effects;
		queued_root_effects = [];
		flush_queued_root_effects(previous_queued_root_effects);

		if (!is_micro_task_queued) {
			flush_count = 0;
			last_scheduled_effect = null;
			{
				dev_effect_stack = [];
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		if (scheduler_mode === FLUSH_MICROTASK) {
			if (!is_micro_task_queued) {
				is_micro_task_queued = true;
				queueMicrotask(process_deferred);
			}
		}

		last_scheduled_effect = signal;

		var effect = signal;

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} effect
	 * @param {Effect[]} collected_effects
	 * @returns {void}
	 */
	function process_effects(effect, collected_effects) {
		var current_effect = effect.first;
		var effects = [];

		main_loop: while (current_effect !== null) {
			var flags = current_effect.f;
			var is_branch = (flags & BRANCH_EFFECT) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
			var sibling = current_effect.next;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & RENDER_EFFECT) !== 0) {
					if (is_branch) {
						current_effect.f ^= CLEAN;
					} else {
						try {
							if (check_dirtiness(current_effect)) {
								update_effect(current_effect);
							}
						} catch (error) {
							handle_error(error, current_effect, null, current_effect.ctx);
						}
					}

					var child = current_effect.first;

					if (child !== null) {
						current_effect = child;
						continue;
					}
				} else if ((flags & EFFECT) !== 0) {
					effects.push(current_effect);
				}
			}

			if (sibling === null) {
				let parent = current_effect.parent;

				while (parent !== null) {
					if (effect === parent) {
						break main_loop;
					}
					var parent_sibling = parent.next;
					if (parent_sibling !== null) {
						current_effect = parent_sibling;
						continue main_loop;
					}
					parent = parent.parent;
				}
			}

			current_effect = sibling;
		}

		// We might be dealing with many effects here, far more than can be spread into
		// an array push call (callstack overflow). So let's deal with each effect in a loop.
		for (var i = 0; i < effects.length; i++) {
			child = effects[i];
			collected_effects.push(child);
			process_effects(child, collected_effects);
		}
	}

	/**
	 * Internal version of `flushSync` with the option to not flush previous effects.
	 * Returns the result of the passed function, if given.
	 * @param {() => any} [fn]
	 * @returns {any}
	 */
	function flush_sync(fn) {
		var previous_scheduler_mode = scheduler_mode;
		var previous_queued_root_effects = queued_root_effects;

		try {
			infinite_loop_guard();

			/** @type {Effect[]} */
			const root_effects = [];

			scheduler_mode = FLUSH_SYNC;
			queued_root_effects = root_effects;
			is_micro_task_queued = false;

			flush_queued_root_effects(previous_queued_root_effects);

			var result = fn?.();

			flush_tasks();
			if (queued_root_effects.length > 0 || root_effects.length > 0) {
				flush_sync();
			}

			flush_count = 0;
			last_scheduled_effect = null;
			if (DEV) {
				dev_effect_stack = [];
			}

			return result;
		} finally {
			scheduler_mode = previous_scheduler_mode;
			queued_root_effects = previous_queued_root_effects;
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {
		await Promise.resolve();
		// By calling flush_sync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flush_sync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get$2(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// If the derived is destroyed, just execute it again without retaining
		// its memoisation properties as the derived is stale
		if (is_derived && (flags & DESTROYED) !== 0) {
			var value = execute_derived(/** @type {Derived} */ (signal));
			// Ensure the derived remains destroyed
			destroy_derived(/** @type {Derived} */ (signal));
			return value;
		}

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null) {
			if (derived_sources !== null && derived_sources.includes(signal)) {
				state_unsafe_local_read();
			}
			var deps = active_reaction.deps;

			// If the signal is accessing the same dependencies in the same
			// order as it did last time, increment `skipped_deps`
			// rather than updating `new_deps`, which creates GC cost
			if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
				skipped_deps++;
			} else if (new_deps === null) {
				new_deps = [signal];
			} else {
				new_deps.push(signal);
			}

			if (
				untracked_writes !== null &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & BRANCH_EFFECT) === 0 &&
				untracked_writes.includes(signal)
			) {
				set_signal_status(active_effect, DIRTY);
				schedule_effect(active_effect);
			}
		} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;
			var target = derived;

			while (parent !== null) {
				// Attach the derived to the nearest parent effect, if there are deriveds
				// in between then we also need to attach them too
				if ((parent.f & DERIVED) !== 0) {
					var parent_derived = /** @type {Derived} */ (parent);

					target = parent_derived;
					parent = parent_derived.parent;
				} else {
					var parent_effect = /** @type {Effect} */ (parent);

					if (!parent_effect.deriveds?.includes(target)) {
						(parent_effect.deriveds ??= []).push(target);
					}
					break;
				}
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		const previous_reaction = active_reaction;
		try {
			active_reaction = null;
			return fn();
		} finally {
			active_reaction = previous_reaction;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		const context_map = get_or_init_context_map('getContext');
		const result = /** @type {T} */ (context_map.get(key));

		{
			const fn = /** @type {ComponentContext} */ (component_context).function;
			if (fn) {
				add_owner(result, fn, true);
			}
		}

		return result;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map('setContext');
		context_map.set(key, context);
		return context;
	}

	/**
	 * Checks whether a given `key` has been set in the context of a parent component.
	 * Must be called during component initialisation.
	 *
	 * @param {any} key
	 * @returns {boolean}
	 */
	function hasContext(key) {
		const context_map = get_or_init_context_map('hasContext');
		return context_map.has(key);
	}

	/**
	 * Retrieves the whole context map that belongs to the closest parent component.
	 * Must be called during component initialisation. Useful, for example, if you
	 * programmatically create a component and want to pass the existing context to it.
	 *
	 * @template {Map<any, any>} [T=Map<any, any>]
	 * @returns {T}
	 */
	function getAllContexts() {
		const context_map = get_or_init_context_map('getAllContexts');

		{
			const fn = component_context?.function;
			if (fn) {
				for (const value of context_map.values()) {
					add_owner(value, fn, true);
				}
			}
		}

		return /** @type {T} */ (context_map);
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component(name);
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	/**
	 * @template {number | bigint} T
	 * @param {Value<T>} signal
	 * @param {1 | -1} [d]
	 * @returns {T}
	 */
	function update(signal, d = 1) {
		var value = get$2(signal);
		var result = d === 1 ? value++ : value--;

		set(signal, value);

		// @ts-expect-error
		return result;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		};

		if (legacy_mode_flag && !runes) {
			component_context.l = {
				s: null,
				u: null,
				r1: [],
				r2: source(false)
			};
		}

		{
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			{
				dev_current_component_function = context_stack_item.p?.function ?? null;
			}
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	{
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	const regex_return_characters = /\r/g;

	/**
	 * @param {string} str
	 * @returns {string}
	 */
	function hash(str) {
		str = str.replace(regex_return_characters, '');
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return (hash >>> 0).toString(36);
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** List of elements that require raw contents and should not have SSR comments put in them */
	const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);

	/** @param {string} name */
	function is_raw_text_element(name) {
		return RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name));
	}

	/**
	 * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
	 * @param {string | undefined} location
	 */
	function sanitize_location(location) {
		return location?.replace(/\//g, '/\u200b');
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	/**
	 * The child of a textarea actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLTextAreaElement} dom
	 * @returns {void}
	 */
	function remove_textarea_child(dom) {
		if (hydrating && get_first_child(dom) !== null) {
			clear_text_content(dom);
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { Location } from 'locate-character' */

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} handler
	 * @param {AddEventListenerOptions} options
	 */
	function create_event(event_name, dom, handler, options) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} handler
	 * @param {boolean} capture
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		// @ts-ignore
		if (dom === document.body || dom === window || dom === document) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {
			if (hydrating) {
				assign_nodes(hydrate_node, null);
				return hydrate_node;
			}

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text(value = '') {
		if (!hydrating) {
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}

		var node = hydrate_node;

		if (node.nodeType !== 3) {
			// if an {expression} is empty during SSR, we need to insert an empty text node
			node.before((node = create_text()));
			set_hydrate_node(node);
		}

		assign_nodes(node, node);
		return node;
	}

	function comment() {
		// we're not delegating to `template` here for performance reasons
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {
		if (hydrating) {
			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
			hydrate_next();
			return;
		}

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true — block effects should run their intro transitions —
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/** @param {boolean} value */
	function set_should_intro(value) {
		should_intro = value;
	}

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str == null ? '' : str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/**
	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {{} extends Props ? {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props?: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	} : {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	}} options
	 * @returns {Exports}
	 */
	function hydrate(component, options) {
		init_operations();
		options.intro = options.intro ?? false;
		const target = options.target;
		const was_hydrating = hydrating;
		const previous_hydrate_node = hydrate_node;

		try {
			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
			while (
				anchor &&
				(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
			) {
				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
			}

			if (!anchor) {
				throw HYDRATION_ERROR;
			}

			set_hydrating(true);
			set_hydrate_node(/** @type {Comment} */ (anchor));
			hydrate_next();

			const instance = _mount(component, { ...options, anchor });

			if (
				hydrate_node === null ||
				hydrate_node.nodeType !== 8 ||
				/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
			) {
				hydration_mismatch();
				throw HYDRATION_ERROR;
			}

			set_hydrating(false);

			return /**  @type {Exports} */ (instance);
		} catch (error) {
			if (error === HYDRATION_ERROR) {
				if (options.recover === false) {
					hydration_failed();
				}

				// If an error occured above, the operations might not yet have been initialised.
				init_operations();
				clear_text_content(target);

				set_hydrating(false);
				return mount(component, options);
			}

			throw error;
		} finally {
			set_hydrating(was_hydrating);
			set_hydrate_node(previous_hydrate_node);
		}
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}

				if (hydrating) {
					assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
				}

				should_intro = intro;
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};
				should_intro = true;

				if (hydrating) {
					/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
				}

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		{
			lifecycle_double_unmount();
		}

		return Promise.resolve();
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				const is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (!!condition === is_else) {
					// Hydration mismatch: remove everything inside the anchor and start fresh.
					// This could happen with `{#if browser}...{/if}`, for example
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else if (fn) {
					consequent_effect = branch(() => fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (fn) {
					alternate_effect = branch(() => fn(anchor));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * The row of a keyed each block that is currently updating. We track this
	 * so that `animate:` directives have something to attach themselves to
	 * @type {EachItem | null}
	 */
	let current_each_item = null;

	/** @param {EachItem | null} item */
	function set_current_each_item(item) {
		current_each_item = item;
	}

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index$d(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = hydrating
				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
				: parent_node.appendChild(create_text());
		}

		if (hydrating) {
			hydrate_next();
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		block(() => {
			var collection = get_collection();

			var array = is_array(collection)
				? collection
				: collection == null
					? []
					: array_from(collection);

			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				var is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (is_else !== (length === 0)) {
					// hydration mismatch — remove the server-rendered DOM and start over
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			// this is separate to the previous block because `hydrating` might change
			if (hydrating) {
				/** @type {EachItem | null} */
				var prev = null;

				/** @type {EachItem} */
				var item;

				for (var i = 0; i < length; i++) {
					if (
						hydrate_node.nodeType === 8 &&
						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
					) {
						// The server rendered fewer items than expected,
						// so break out and continue appending non-hydrated items
						anchor = /** @type {Comment} */ (hydrate_node);
						mismatch = true;
						set_hydrating(false);
						break;
					}

					var value = array[i];
					var key = get_key(value, i);
					item = create_item(
						hydrate_node,
						state,
						prev,
						null,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
					state.items.set(key, item);

					prev = item;
				}

				// remove excess nodes
				if (length > 0) {
					set_hydrate_node(remove_nodes());
				}
			}

			if (!hydrating) {
				var effect = /** @type {Effect} */ (active_reaction);
				reconcile(
					array,
					state,
					anchor,
					render_fn,
					flags,
					(effect.f & INERT) !== 0,
					get_key,
					get_collection
				);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get_collection();
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn
	 * @param {number} flags
	 * @param {boolean} is_inert
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, is_inert, get_key, get_collection) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags,
					get_collection
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if (is_inert || (current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if (is_inert || (current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection
	) {
		var previous_each_item = current_each_item;
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).debug = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		current_each_item = item;

		try {
			item.e = branch(() => render_fn(anchor, v, i), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
			current_each_item = previous_each_item;
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element} element
	 * @param {string | null} server_hash
	 * @param {string} value
	 */
	function check_hash(element, server_hash, value) {
		if (!server_hash || server_hash === hash(String(value ?? ''))) return;

		let location;

		// @ts-expect-error
		const loc = element.__svelte_meta?.loc;
		if (loc) {
			location = `near ${loc.file}:${loc.line}:${loc.column}`;
		} else if (dev_current_component_function?.[FILENAME]) {
			location = `in ${dev_current_component_function[FILENAME]}`;
		}

		hydration_html_changed(sanitize_location(location));
	}

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} svg
	 * @param {boolean} mathml
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg, mathml, skip_warning) {
		var anchor = node;

		var value = '';

		/** @type {Effect | undefined} */
		var effect;

		block(() => {
			if (value === (value = get_value() ?? '')) {
				if (hydrating) {
					hydrate_next();
				}
				return;
			}

			if (effect !== undefined) {
				destroy_effect(effect);
				effect = undefined;
			}

			if (value === '') return;

			effect = branch(() => {
				if (hydrating) {
					// We're deliberately not trying to repair mismatches between server and client,
					// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)
					var hash = /** @type {Comment} */ (hydrate_node).data;
					var next = hydrate_next();
					var last = next;

					while (
						next !== null &&
						(next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')
					) {
						last = next;
						next = /** @type {TemplateNode} */ (get_next_sibling(next));
					}

					if (next === null) {
						hydration_mismatch();
						throw HYDRATION_ERROR;
					}

					{
						check_hash(/** @type {Element} */ (next.parentNode), hash, value);
					}

					assign_nodes(hydrate_node, last);
					anchor = set_hydrate_node(next);
					return;
				}

				var html = value + '';

				// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
				// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
				/** @type {DocumentFragment | Element} */
				var node = create_fragment_from_html(html);

				assign_nodes(
					/** @type {TemplateNode} */ (get_first_child(node)),
					/** @type {TemplateNode} */ (node.lastChild)
				);

				{
					anchor.before(node);
				}
			});
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props[name === 'default' ? 'children' : name];
			is_interop = true;
		}

		if (slot_fn === undefined) {
			if (fallback_fn !== null) {
				fallback_fn(anchor);
			}
		} else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var anchor = node;

		/** @type {SnippetFn | null | undefined} */
		// @ts-ignore
		var snippet = noop;

		/** @type {Effect | null} */
		var snippet_effect;

		block(() => {
			if (snippet === (snippet = get_snippet())) return;

			if (snippet_effect) {
				destroy_effect(snippet_effect);
				snippet_effect = null;
			}

			if (snippet == null) {
				invalid_snippet();
			}

			snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Create a snippet programmatically
	 * @template {unknown[]} Params
	 * @param {(...params: Getters<Params>) => {
	 *   render: () => string
	 *   setup?: (element: Element) => void | (() => void)
	 * }} fn
	 * @returns {Snippet<Params>}
	 */
	function createRawSnippet(fn) {
		// @ts-expect-error the types are a lie
		return (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {
			var snippet = fn(...params);

			/** @type {Element} */
			var element;

			if (hydrating) {
				element = /** @type {Element} */ (hydrate_node);
				hydrate_next();
			} else {
				var html = snippet.render().trim();
				var fragment = create_fragment_from_html(html);
				element = /** @type {Element} */ (get_first_child(fragment));

				if ((get_next_sibling(element) !== null || element.nodeType !== 1)) {
					invalid_raw_snippet_render();
				}

				anchor.before(element);
			}

			const result = snippet.setup?.(element);
			assign_nodes(element, element);

			if (typeof result === 'function') {
				teardown(result);
			}
		};
	}

	/** @import { TemplateNode, Dom, Effect } from '#client' */

	/**
	 * @template P
	 * @template {(props: P) => void} C
	 * @param {TemplateNode} node
	 * @param {() => C} get_component
	 * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn
	 * @returns {void}
	 */
	function component(node, get_component, render_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {C} */
		var component;

		/** @type {Effect | null} */
		var effect;

		block(() => {
			if (component === (component = get_component())) return;

			if (effect) {
				pause_effect(effect);
				effect = null;
			}

			if (component) {
				effect = branch(() => render_fn(anchor, component));
			}
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
		let was_hydrating = hydrating;

		if (hydrating) {
			hydrate_next();
		}

		/** @type {string | null} */
		var tag;

		/** @type {string | null} */
		var current_tag;

		/** @type {null | Element} */
		var element = null;

		if (hydrating && hydrate_node.nodeType === 1) {
			element = /** @type {Element} */ (hydrate_node);
			hydrate_next();
		}

		var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);

		/** @type {Effect | null} */
		var effect;

		/**
		 * The keyed `{#each ...}` item block, if any, that this element is inside.
		 * We track this so we can set it when changing the element, allowing any
		 * `animate:` directive to bind itself to the correct block
		 */
		var each_item_block = current_each_item;

		block(() => {
			const next_tag = get_tag() || null;
			var ns = next_tag === 'svg' ? NAMESPACE_SVG : null;

			// Assumption: Noone changes the namespace but not the tag (what would that even mean?)
			if (next_tag === tag) return;

			// See explanation of `each_item_block` above
			var previous_each_item = current_each_item;
			set_current_each_item(each_item_block);

			if (effect) {
				if (next_tag === null) {
					// start outro
					pause_effect(effect, () => {
						effect = null;
						current_tag = null;
					});
				} else if (next_tag === current_tag) {
					// same tag as is currently rendered — abort outro
					resume_effect(effect);
				} else {
					// tag is changing — destroy immediately, render contents without intro transitions
					destroy_effect(effect);
					set_should_intro(false);
				}
			}

			if (next_tag && next_tag !== current_tag) {
				effect = branch(() => {
					element = hydrating
						? /** @type {Element} */ (element)
						: ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					assign_nodes(element, element);

					{
						if (hydrating && is_raw_text_element(next_tag)) {
							// prevent hydration glitches
							element.append(document.createComment(''));
						}

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							hydrating ? get_first_child(element) : element.appendChild(create_text())
						);

						if (hydrating) {
							if (child_anchor === null) {
								set_hydrating(false);
							} else {
								set_hydrate_node(child_anchor);
							}
						}

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				});
			}

			tag = next_tag;
			if (tag) current_tag = tag;
			set_should_intro(true);

			set_current_each_item(previous_each_item);
		}, EFFECT_TRANSPARENT);

		if (was_hydrating) {
			set_hydrating(true);
			set_hydrate_node(anchor);
		}
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	/**
	 * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLInputElement} input
	 * @returns {void}
	 */
	function remove_input_defaults(input) {
		if (!hydrating) return;

		var already_removed = false;

		// We try and remove the default attributes later, rather than sync during hydration.
		// Doing it sync during hydration has a negative impact on performance, but deferring the
		// work in an idle task alleviates this greatly. If a form reset event comes in before
		// the idle callback, then we ensure the input defaults are cleared just before.
		var remove_defaults = () => {
			if (already_removed) return;
			already_removed = true;

			// Remove the attributes but preserve the values
			if (input.hasAttribute('value')) {
				var value = input.value;
				set_attribute(input, 'value', null);
				input.value = value;
			}

			if (input.hasAttribute('checked')) {
				var checked = input.checked;
				set_attribute(input, 'checked', null);
				input.checked = checked;
			}
		};

		// @ts-expect-error
		input.__on_r = remove_defaults;
		queue_idle_task(remove_defaults);
		add_form_reset_listener();
	}

	/**
	 * @param {Element} element
	 * @param {any} value
	 */
	function set_value(element, value) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (
			attributes.value ===
				(attributes.value =
					// treat null and undefined the same for the initial value
					value ?? undefined) ||
			// @ts-expect-error
			// `progress` elements always need their value set when its `0`
			(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))
		) {
			return;
		}

		// @ts-expect-error
		element.value = value;
	}

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (hydrating) {
			attributes[attribute] = element.getAttribute(attribute);

			if (
				attribute === 'src' ||
				attribute === 'srcset' ||
				(attribute === 'href' && element.nodeName === 'LINK')
			) {
				{
					check_src_in_dev_hydration(element, attribute, value ?? '');
				}

				// If we reset these attributes, they would result in another network request, which we want to avoid.
				// We assume they are the same between client and server as checking if they are equal is expensive
				// (we can't just compare the strings as they can be different between client and server but result in the
				// same url, so we would need to create hidden anchor elements to compare them)
				return;
			}
		}

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'style' && '__styles' in element) {
			// reset styles to force style: directive to update
			element.__styles = {};
		}

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string, any> | undefined} prev
	 * @param {Record<string, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [preserve_attribute_case]
	 * @param {boolean} [is_custom_element]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		preserve_attribute_case = false,
		is_custom_element = false,
		skip_warning = false
	) {
		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		}

		if (css_hash !== undefined) {
			next.class = next.class ? next.class + ' ' + css_hash : css_hash;
		}

		var setters = get_setters(element);

		// @ts-expect-error
		var attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			var prev_value = current[key];
			if (value === prev_value) continue;

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style' && value != null) {
				element.style.cssText = value + '';
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (key === '__value' || (key === 'value' && value != null)) {
				// @ts-ignore
				element.value = element[key] = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked — preserve
						let input = /** @type {HTMLInputElement} */ (element);

						if (name === 'value') {
							let prev = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = prev;
						} else {
							let prev = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = prev;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
				} else if (typeof value !== 'function') {
					if (hydrating && (name === 'src' || name === 'href' || name === 'srcset')) {
						if (!skip_warning) check_src_in_dev_hydration(element, name, value ?? '');
					} else {
						set_attribute(element, name, value);
					}
				}
			}
			if (key === 'style' && '__styles' in element) {
				// reset styles to force style: directive to update
				element.__styles = {};
			}
		}

		return current;
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {any} element
	 * @param {string} attribute
	 * @param {string} value
	 */
	function check_src_in_dev_hydration(element, attribute, value) {
		if (attribute === 'srcset' && srcset_url_equal(element, value)) return;
		if (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;

		hydration_attribute_changed(
			attribute,
			element.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),
			String(value)
		);
	}

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
	}

	/** @param {string} srcset */
	function split_srcset(srcset) {
		return srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));
	}

	/**
	 * @param {HTMLSourceElement | HTMLImageElement} element
	 * @param {string} srcset
	 * @returns {boolean}
	 */
	function srcset_url_equal(element, srcset) {
		var element_urls = split_srcset(element.srcset);
		var urls = split_srcset(srcset);

		return (
			urls.length === element_urls.length &&
			urls.every(
				([url, width], i) =>
					width === element_urls[i][1] &&
					// We need to test both ways because Vite will create an a full URL with
					// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
					// relative URLs inside srcset are not automatically resolved to absolute URLs by
					// browsers (in contrast to img.src). This means both SSR and DOM code could
					// contain relative or absolute URLs.
					(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
			)
		);
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {string} value
	 * @param {string} [hash]
	 * @returns {void}
	 */
	function set_class(dom, value, hash) {
		// @ts-expect-error need to add __className to patched prototype
		var prev_class_name = dom.__className;
		var next_class_name = to_class(value, hash);

		if (hydrating && dom.className === next_class_name) {
			// In case of hydration don't reset the class as it's already correct.
			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		} else if (
			prev_class_name !== next_class_name ||
			(hydrating && dom.className !== next_class_name)
		) {
			// Removing the attribute when the value is only an empty string causes
			// peformance issues vs simply making the className an empty string. So
			// we should only remove the class if the the value is nullish.
			if (value == null && !hash) {
				dom.removeAttribute('class');
			} else {
				dom.className = next_class_name;
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		}
	}

	/**
	 * @template V
	 * @param {V} value
	 * @param {string} [hash]
	 * @returns {string | V}
	 */
	function to_class(value, hash) {
		return (value == null ? '' : value) + (hash ? ' ' + hash : '');
	}

	/**
	 * @param {Element} dom
	 * @param {string} class_name
	 * @param {boolean} value
	 * @returns {void}
	 */
	function toggle_class(dom, class_name, value) {
		if (value) {
			if (dom.classList.contains(class_name)) return;
			dom.classList.add(class_name);
		} else {
			if (!dom.classList.contains(class_name)) return;
			dom.classList.remove(class_name);
		}
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @returns {void}
	 */
	function run_tasks() {
		// use `raf.now()` instead of the `requestAnimationFrame` callback argument, because
		// otherwise things can get wonky https://github.com/sveltejs/svelte/pull/14541
		const now = raf.now();

		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		element.dispatchEvent(new CustomEvent(type));
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear$1 = (t) => t;

	/**
	 * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager
	 * and attaches it to the block, so that moves can be animated following reconciliation.
	 * @template P
	 * @param {Element} element
	 * @param {() => AnimateFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 */
	function animation(element, get_fn, get_params) {
		var item = /** @type {EachItem} */ (current_each_item);

		/** @type {DOMRect} */
		var from;

		/** @type {DOMRect} */
		var to;

		/** @type {Animation | undefined} */
		var animation;

		/** @type {null | { position: string, width: string, height: string, transform: string }} */
		var original_styles = null;

		item.a ??= {
			element,
			measure() {
				from = this.element.getBoundingClientRect();
			},
			apply() {
				animation?.abort();

				to = this.element.getBoundingClientRect();

				if (
					from.left !== to.left ||
					from.right !== to.right ||
					from.top !== to.top ||
					from.bottom !== to.bottom
				) {
					const options = get_fn()(this.element, { from, to }, get_params?.());

					animation = animate(this.element, options, undefined, 1, () => {
						animation?.abort();
						animation = undefined;
					});
				}
			},
			fix() {
				// If an animation is already running, transforming the element is likely to fail,
				// because the styles applied by the animation take precedence. In the case of crossfade,
				// that means the `translate(...)` of the crossfade transition overrules the `translate(...)`
				// we would apply below, leading to the element jumping somewhere to the top left.
				if (element.getAnimations().length) return;

				// It's important to destructure these to get fixed values - the object itself has getters,
				// and changing the style to 'absolute' can for example influence the width.
				var { position, width, height } = getComputedStyle(element);

				if (position !== 'absolute' && position !== 'fixed') {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					original_styles = {
						position: style.position,
						width: style.width,
						height: style.height,
						transform: style.transform
					};

					style.position = 'absolute';
					style.width = width;
					style.height = height;
					var to = element.getBoundingClientRect();

					if (from.left !== to.left || from.top !== to.top) {
						var transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`;
						style.transform = style.transform ? `${style.transform} ${transform}` : transform;
					}
				}
			},
			unfix() {
				if (original_styles) {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					style.position = original_styles.position;
					style.width = original_styles.width;
					style.height = original_styles.height;
					style.transform = original_styles.transform;
				}
			}
		};

		// in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called
		// when an animation manager already exists, if the tag changes. in that case, we need to
		// swap out the element rather than creating a new manager, in case it happened at the same
		// moment as a reconciliation
		item.a.element = element;
	}

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = 'both' ;

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			var previous_reaction = active_reaction;
			var previous_effect = active_effect;
			set_active_reaction(null);
			set_active_effect(null);
			try {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			} finally {
				set_active_reaction(previous_reaction);
				set_active_effect(previous_effect);
			}
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;
				});
			},
			out(fn) {

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value — `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear$1 } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		var animation = element.animate(keyframes, { duration: delay });

		animation.onfinish = () => {
			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css(t, 1 - t);
						keyframes.push(css_to_keyframe(styles));
					}
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var runes = is_runes();

		listen_to_event_and_reset_event(input, 'input', (is_reset) => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,
			// because we use mutable state which ensures the render effect always runs)
			if (runes && value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			(hydrating && input.defaultValue !== input.value) ||
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);
		}

		render_effect(() => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			var value = get();

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			(hydrating && input.defaultChecked !== input.checked) ||
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Makes an `export`ed (non-prop) variable available on the `$$props` object
	 * so that consumers can do `bind:x` on the component.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} prop
	 * @param {V} value
	 * @returns {void}
	 */
	function bind_prop(props, prop, value) {
		var desc = get_descriptor(props, prop);

		if (desc && desc.set) {
			props[prop] = value;
			teardown(() => {
				props[prop] = null;
			});
		}
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} [mounting]
	 */
	function select_option(select, value, mounting) {
		if (select.multiple) {
			return select_options(select, value);
		}

		for (var option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {() => V} [get_value]
	 */
	function init_select(select, get_value) {
		let mounting = true;
		effect(() => {
			{
				select_option(select, untrack(get_value), mounting);
			}
			mounting = false;

			var observer = new MutationObserver(() => {
				// @ts-ignore
				var value = select.__value;
				select_option(select, value);
				// Deliberately don't update the potential binding value,
				// the model should be preserved unless explicitly changed
			});

			observer.observe(select, {
				// Listen to option element changes
				childList: true,
				subtree: true, // because of <optgroup>
				// Listen to option element value attribute changes
				// (doesn't get notified of select value changes,
				// because that property is not reflected as an attribute)
				attributes: true,
				attributeFilter: ['value']
			});

			return () => {
				observer.disconnect();
			};
		});
	}

	/**
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 */
	function select_options(select, value) {
		for (var option of select.options) {
			// @ts-ignore
			option.selected = ~value.indexOf(get_option_value(option));
		}
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = get_parts?.() || [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/** @import { ActionReturn } from 'svelte/action' */

	/**
	 * Substitute for the `preventDefault` event modifier
	 * @deprecated
	 * @param {(event: Event, ...args: Array<unknown>) => void} fn
	 * @returns {(event: Event, ...args: unknown[]) => void}
	 */
	function preventDefault(fn) {
		return function (...args) {
			var event = /** @type {Event} */ (args[0]);
			event.preventDefault();
			// @ts-ignore
			return fn?.apply(this, args);
		};
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get$2(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run$1));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get$2(signal);
		}

		props();
	}

	/**
	 * @this {any}
	 * @param {Record<string, unknown>} $$props
	 * @param {Event} event
	 * @returns {void}
	 */
	function bubble_event($$props, event) {
		var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[
			event.type
		];

		var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];

		for (var fn of callbacks) {
			// Preserve "this" context
			fn.call(this, event);
		}
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		if (entry.store !== store) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		return get$2(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {StoreReferencesContainer}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		teardown(() => {
			for (var store_name in stores) {
				const ref = stores[store_name];
				ref.unsubscribe();
			}
		});

		return stores;
	}

	/**
	 * Updates a store with a new value.
	 * @param {Store<V>} store  the store to update
	 * @param {any} expression  the expression that mutates the store
	 * @param {V} new_value  the new store value
	 * @template V
	 */
	function store_mutate(store, expression, new_value) {
		store.set(new_value);
		return expression;
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Source } from './types.js' */

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {
			{
				// TODO should this happen in prod too?
				props_rest_readonly(`${target.name}.${String(key)}`);
			}

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			{ props, exclude, name, other: {}, to_proxy: [] } ,
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for legacy $$restProps and $$props
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}
	 */
	const legacy_rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			get$2(target.version);
			return key in target.special ? target.special[key]() : target.props[key];
		},
		set(target, key, value) {
			if (!(key in target.special)) {
				// Handle props that can temporarily get out of sync with the parent
				/** @type {Record<string, (v?: unknown) => unknown>} */
				target.special[key] = prop(
					{
						get [key]() {
							return target.props[key];
						}
					},
					/** @type {string} */ (key),
					PROPS_IS_UPDATED
				);
			}

			target.special[key](value);
			update(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun
			return true;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		deleteProperty(target, key) {
			// Svelte 4 allowed for deletions on $$restProps
			if (target.exclude.includes(key)) return true;
			target.exclude.push(key);
			update(target.version);
			return true;
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @returns {Record<string, unknown>}
	 */
	function legacy_rest_props(props, exclude) {
		return new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @template {Record<string | symbol, unknown>} T
	 * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function with_parent_branch(fn) {
		var effect = active_effect;
		var previous_effect = active_effect;

		while (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
			effect = effect.parent;
		}
		try {
			set_active_effect(effect);
			return fn();
		} finally {
			set_active_effect(previous_effect);
		}
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
		var is_store_sub = false;
		var prop_value;

		if (bindable) {
			[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			prop_value = /** @type {V} */ (props[key]);
		}

		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

		var setter =
			get_descriptor(props, key)?.set ??
			(is_entry_props && bindable && key in props ? (v) => (props[key] = v) : undefined);

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;
		var fallback_used = false;

		var get_fallback = () => {
			fallback_used = true;
			if (fallback_dirty) {
				fallback_dirty = false;
				if (lazy) {
					fallback_value = untrack(/** @type {() => V} */ (fallback));
				} else {
					fallback_value = /** @type {V} */ (fallback);
				}
			}

			return fallback_value;
		};

		if (prop_value === undefined && fallback !== undefined) {
			if (setter && runes) {
				props_invalid_value(key);
			}

			prop_value = get_fallback();
			if (setter) setter(prop_value);
		}

		/** @type {() => V} */
		var getter;
		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				fallback_used = false;
				return value;
			};
		} else {
			// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
			// Replicate that behavior through using a derived
			var derived_getter = with_parent_branch(() =>
				(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))
			);
			derived_getter.f |= LEGACY_DERIVED_PROP;
			getter = () => {
				var value = get$2(derived_getter);
				if (value !== undefined) fallback_value = /** @type {V} */ (undefined);
				return value === undefined ? fallback_value : value;
			};
		}

		// easy mode — prop is never written to
		if ((flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// intermediate mode — prop is written to, but the parent component had
		// `bind:foo` which means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					// We don't want to notify if the value was mutated and the parent is in runes mode.
					// In that case the state proxy (if it exists) should take care of the notification.
					// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
					// has changed because the parent will not be able to detect the change otherwise.
					if (!runes || !mutation || legacy_parent || is_store_sub) {
						/** @type {Function} */ (setter)(mutation ? getter() : value);
					}
					return value;
				} else {
					return getter();
				}
			};
		}

		// hard mode. this is where it gets ugly — the value in the child should
		// synchronize with the parent, but it should also be possible to temporarily
		// set the value to something else locally.
		var from_child = false;
		var was_from_child = false;

		// The derived returns the current value. The underlying mutable
		// source is written to from various places to persist this value.
		var inner_current_value = mutable_source(prop_value);
		var current_value = with_parent_branch(() =>
			derived(() => {
				var parent_value = getter();
				var child_value = get$2(inner_current_value);

				if (from_child) {
					from_child = false;
					was_from_child = true;
					return child_value;
				}

				was_from_child = false;
				return (inner_current_value.v = parent_value);
			})
		);

		if (!immutable) current_value.equals = safe_equals;

		return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {

			if (arguments.length > 0) {
				const new_value = mutation ? get$2(current_value) : runes && bindable ? proxy(value) : value;

				if (!current_value.equals(new_value)) {
					from_child = true;
					set(inner_current_value, new_value);
					// To ensure the fallback value is consistent when used with proxies, we
					// update the local fallback_value, but only if the fallback is actively used
					if (fallback_used && fallback_value !== undefined) {
						fallback_value = new_value;
					}
					untrack(() => get$2(current_value)); // force a synchronisation immediately
				}

				return value;
			}
			return get$2(current_value);
		};
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside [server-side components](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onMount');
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onDestroy');
		}

		onMount(() => () => untrack(fn));
	}

	/**
	 * @template [T=any]
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {any}params_0
	 * @returns {CustomEvent<T>}
	 */
	function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events)
	 * @template {Record<string, any>} [EventMap = any]
	 * @returns {EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const active_component_context = component_context;
		if (active_component_context === null) {
			lifecycle_outside_component('createEventDispatcher');
		}

		return (type, detail, options) => {
			const events = /** @type {Record<string, Function | Function[]>} */ (
				active_component_context.s.$$events
			)?.[/** @type {any} */ (type)];

			if (events) {
				const callbacks = is_array(events) ? events.slice() : [events];
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = create_custom_event(/** @type {string} */ (type), detail, options);
				for (const fn of callbacks) {
					fn.call(active_component_context.x, event);
				}
				return !event.defaultPrevented;
			}

			return true;
		};
	}

	// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`.
	 *
	 * In runes mode use `$effect.pre` instead.
	 *
	 * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('beforeUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('beforeUpdate');
		}

		init_update_callbacks(component_context).b.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`.
	 *
	 * In runes mode use `$effect` instead.
	 *
	 * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('afterUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('afterUpdate');
		}

		init_update_callbacks(component_context).a.push(fn);
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/**
	 * Synchronously flushes any pending state changes and those that result from it.
	 * @param {() => void} [fn]
	 * @returns {void}
	 */
	function flushSync(fn) {
		flush_sync(fn);
	}

	var indexClient = /*#__PURE__*/Object.freeze({
		__proto__: null,
		afterUpdate: afterUpdate,
		beforeUpdate: beforeUpdate,
		createEventDispatcher: createEventDispatcher,
		createRawSnippet: createRawSnippet,
		flushSync: flushSync,
		getAllContexts: getAllContexts,
		getContext: getContext,
		hasContext: hasContext,
		hydrate: hydrate,
		mount: mount,
		onDestroy: onDestroy,
		onMount: onMount,
		setContext: setContext,
		tick: tick,
		unmount: unmount,
		untrack: untrack
	});

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);

	function _assertClassBrand(e, t, n) {
	  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
	  throw new TypeError("Private element is not present on this object");
	}
	function _assertThisInitialized(e) {
	  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  return e;
	}
	function _callSuper(t, o, e) {
	  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
	}
	function _checkPrivateRedeclaration(e, t) {
	  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	function _classCallCheck(a, n) {
	  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}
	function _classPrivateFieldGet2(s, a) {
	  return s.get(_assertClassBrand(s, a));
	}
	function _classPrivateFieldInitSpec(e, t, a) {
	  _checkPrivateRedeclaration(e, t), t.set(e, a);
	}
	function _classPrivateFieldSet2(s, a, r) {
	  return s.set(_assertClassBrand(s, a), r), r;
	}
	function _classPrivateMethodInitSpec(e, a) {
	  _checkPrivateRedeclaration(e, a), a.add(e);
	}
	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: !1
	  }), e;
	}
	function _defineProperty(e, r, t) {
	  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: !0,
	    configurable: !0,
	    writable: !0
	  }) : e[r] = t, e;
	}
	function _getPrototypeOf(t) {
	  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
	    return t.__proto__ || Object.getPrototypeOf(t);
	  }, _getPrototypeOf(t);
	}
	function _inherits(t, e) {
	  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	  t.prototype = Object.create(e && e.prototype, {
	    constructor: {
	      value: t,
	      writable: !0,
	      configurable: !0
	    }
	  }), Object.defineProperty(t, "prototype", {
	    writable: !1
	  }), e && _setPrototypeOf(t, e);
	}
	function _isNativeReflectConstruct() {
	  try {
	    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	  } catch (t) {}
	  return (_isNativeReflectConstruct = function () {
	    return !!t;
	  })();
	}
	function _possibleConstructorReturn(t, e) {
	  if (e && ("object" == typeof e || "function" == typeof e)) return e;
	  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	  return _assertThisInitialized(t);
	}
	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r || "default");
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}

	const inputValuesExtractors = Object.freeze({
	  checkbox: function (inpEl, defaultValue = undefined) {
	    if (typeof defaultValue == "object" && Object.hasOwn(defaultValue, "checked") && Object.hasOwn(defaultValue, "unchecked")) {
	      return inpEl.checked ? defaultValue.checked : defaultValue.unchecked;
	    } else if (Object.hasOwn(inpEl, "value") && typeof inpEl.value !== "undefined") {
	      return inpEl.checked ? inpEl.value : false;
	    } else {
	      return inpEl.checked;
	    }
	  }
	});

	/**
	 * Collection of common to UI functions and properties
	 *
	 * @class UICommon
	 */
	let UICommon$1 = /*#__PURE__*/function () {
	  function UICommon() {
	    _classCallCheck(this, UICommon);
	  }
	  return _createClass(UICommon, null, [{
	    key: "inputValuesExtractors",
	    get: function () {
	      return inputValuesExtractors;
	    }
	  }, {
	    key: "extractValueFromInput",
	    value: function extractValueFromInput(inpEl, defaultValue = undefined) {
	      if (Object.hasOwn(UICommon.inputValuesExtractors, inpEl.type)) {
	        return UICommon.inputValuesExtractors[inpEl.type](inpEl, defaultValue);
	      }
	      return inpEl.value;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string}      field    field name
	     * @param {import('./events.types').UIEventInputChangeCallback}    onchange
	     * @param {any}         [defaultValue=undefined]
	     * @return {import('./events.types').UIEventCallback}
	     * @memberof UICommon
	     */
	  }, {
	    key: "onInput",
	    value: function onInput(field, onchange, defaultValue = undefined) {
	      if (typeof onchange !== "function") {
	        return undefined;
	      }
	      return function (event) {
	        const value = UICommon.extractValueFromInput(event.currentTarget, defaultValue);
	        return onchange({
	          field,
	          value
	        }, event);
	      };
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {KeyboardEvent} e
	     * @memberof UICommon
	     */
	  }, {
	    key: "isEnterEvent",
	    value: function isEnterEvent(e) {
	      return e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.shiftKey;
	    }
	  }, {
	    key: "onlyOnEnter",
	    value: function onlyOnEnter(callback) {
	      return function (e) {
	        if (UICommon.isEnterEvent(e)) {
	          return callback(e);
	        } else {
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "isMobile",
	    value: function isMobile() {
	      const testMobile = window.matchMedia || window.msMatchMedia;
	      if (testMobile) {
	        let testQuery = "(pointer:coarse)";
	        if (arguments.length) {
	          const max_width = typeof arguments[0] === "boolean" ? this.MOBILE_WIDTH_BREAK_POINT : arguments[0];
	          testQuery = `only screen and (max-width: ${max_width}px)`;
	        }
	        return testMobile(testQuery).matches;
	      }
	      return false;
	    }
	  }, {
	    key: "removeBodyScroll",
	    value: function removeBodyScroll() {
	      document.body.classList.add(this.SCROLL_DISABLER_CLASS);
	    }
	  }, {
	    key: "restoreBodyScroll",
	    value: function restoreBodyScroll() {
	      document.body.classList.remove(this.SCROLL_DISABLER_CLASS);
	    }

	    /**
	     *  Reformats input from any string to strict phone format
	     *  @param {string}    val    free style phone number
	     *  @param {string}    [filler=UICommon.FILLER]    free style phone number
	     *  @returns {string}          phone number
	     **/
	  }, {
	    key: "formatPhone",
	    value: function formatPhone(val, filler = this.FILLER) {
	      //starting from 11 digits in phone number
	      const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];
	      let digits = val.replace(/\D/g, "");
	      //if there are more, move them to country code slot
	      if (digits.length > 11) {
	        let d = digits.length - 11;
	        while (d > 0) {
	          d--;
	          slots.unshift(1);
	        }
	      }
	      let stack = ["", "", "", "", ""];
	      Array.from(digits).forEach(function (digit, index) {
	        let slot = slots[index];
	        stack[slot - 1] = stack[slot - 1] + digit;
	      });
	      //creating map of parts lengths
	      const lens = slots.reduce(function (acc, curr) {
	        if (typeof acc[curr] === "undefined") {
	          acc[curr] = 1;
	        } else {
	          acc[curr] += 1;
	        }
	        return acc;
	      }, {});
	      //fill empty positions with filler (_)
	      for (let t in stack) {
	        let dif = lens[parseInt(t) + 1] - stack[t].length;
	        while (dif > 0) {
	          stack[t] = stack[t] + filler;
	          dif--;
	        }
	      }
	      return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;
	    }
	  }, {
	    key: "setMoneySign",
	    value: function setMoneySign(val) {
	      this.MONEY_SIGN = val;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {number} price
	     * @return {string}
	     * @memberof UICommon
	     */
	  }, {
	    key: "formatPrice",
	    value: function formatPrice(price) {
	      let major = Math.floor(price / 100),
	        minor = price % 100;
	      return `${this.MONEY_SIGN}${major.toString()}.${minor.toString()}`;
	    }
	  }, {
	    key: "formatLocaleDatetime",
	    value: function formatLocaleDatetime(dt, opts = {
	      date: true,
	      time: true
	    }) {
	      const date = dt.toLocaleDateString(window.navigator.language);
	      const time = dt.toLocaleTimeString(window.navigator.language);
	      if (opts.date && opts.time) {
	        return `${date} ${time}`;
	      } else if (opts.date && !opts.time) {
	        return date;
	      } else {
	        return time;
	      }
	    }
	  }, {
	    key: "tryFormatLocaleDateTime",
	    value: function tryFormatLocaleDateTime(value, opts = {
	      date: true,
	      time: true
	    }) {
	      if (typeof value == "string" || typeof value == "number") {
	        const dt = new Date(value);
	        return UICommon.formatLocaleDatetime(dt, opts);
	      } else if (typeof value == "object") {
	        return UICommon.formatLocaleDatetime(value, opts);
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "formatTimestamp",
	    value: function formatTimestamp(timestamp, offset = 0) {
	      let offsetLocal = new Date().getTimezoneOffset();
	      let deltaOffset = (offsetLocal - offset) * 60 * 1000;
	      let localDateTime = new Date(parseInt(timestamp) - deltaOffset);
	      return localDateTime.toLocaleString(window.navigator.language);
	    }
	  }, {
	    key: "declOfNum",
	    value: function declOfNum(n, text_forms) {
	      n = Math.abs(n) % 100;
	      let n1 = n % 10;
	      if (n > 10 && n < 20) {
	        return text_forms[2];
	      }
	      if (n1 > 1 && n1 < 5) {
	        return text_forms[1];
	      }
	      if (n1 == 1) {
	        return text_forms[0];
	      }
	      return text_forms[2];
	    }
	  }, {
	    key: "humanizedTimeDiff",
	    value: function humanizedTimeDiff(date /* unix time */) {
	      let currentTime = new Date().getTime();
	      let sec = Math.round((currentTime - date) / 1000);
	      let unit;
	      if (sec < 60) {
	        unit = this.declOfNum(sec, this.TIME.SECONDS);
	        return `${sec} ${unit} назад`;
	      } else if (sec < 3600) {
	        let min = Math.floor(sec / 60);
	        unit = this.declOfNum(min, this.TIME.MINUTES);
	        return `${min} ${unit} назад`;
	      } else {
	        let hours = Math.floor(sec / (60 * 60));
	        unit = this.declOfNum(hours, this.TIME.HOURS);
	        return `${hours} ${unit} назад`;
	      }
	    }
	  }, {
	    key: "stylesObjectToString",
	    value: function stylesObjectToString(styles = {}) {
	      if (typeof styles === "object") {
	        Object.keys(styles).map(function (prop) {
	          return `${prop}: ${styles.prop};`;
	        }).join("");
	      } else {
	        return "";
	      }
	    }
	  }]);
	}();
	_defineProperty(UICommon$1, "CLEAR_MACRO", "__CLEAR__");
	_defineProperty(UICommon$1, "ERROR_DEFAULT", "Что пошло не так.");
	_defineProperty(UICommon$1, "DEFAULT_REDIRECT_TIMEOUT", 3000);
	_defineProperty(UICommon$1, "CLASS_OK", "is-success");
	_defineProperty(UICommon$1, "CLASS_ERR", "is-danger");
	_defineProperty(UICommon$1, "SCROLL_DISABLER_CLASS", "remove-scroll");
	_defineProperty(UICommon$1, "FILLER", "_");
	_defineProperty(UICommon$1, "SCROLL_OPTIONS", {
	  top: 0,
	  behavior: "smooth"
	});
	_defineProperty(UICommon$1, "MOBILE_WIDTH_BREAK_POINT", 760);
	_defineProperty(UICommon$1, "MONEY_SIGN", "&#8381;");
	_defineProperty(UICommon$1, "TIME", {
	  SECONDS: ["секунду", "секунды", "секунд"],
	  MINUTES: ["минуту", "минуты", "минут"],
	  HOURS: ["час", "часа", "часов"]
	});

	var root$Q = template(`<div><!></div>`);

	function Ui_block($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, 0),
			onclick = prop($$props, "onclick", 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$Q();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", id());
			set_class(div, `block ${classes() ?? ""}`);
			set_attribute(div, "role", role());
			set_attribute(div, "tabindex", tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	function Ui_block_inner_vertical($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, 0),
			onclick = prop($$props, "onclick", 3, () => true);

		const DEFAULT_CLASSES_INNER = "block-inner-vertical";
		let classesInner = state(DEFAULT_CLASSES_INNER);

		user_effect(() => {
			set(classesInner, `block-inner-vertical ${classes()}`);
		});

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);

		Ui_block($$anchor, {
			get id() {
				return id();
			},
			get class() {
				return get$2(classesInner);
			},
			get onclick() {
				return onclick();
			},
			onkeyup: onKeyUp,
			get role() {
				return role();
			},
			get tabIndex() {
				return tabIndex();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				snippet(node, () => $$props.children ?? noop);
				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$P = template(`<div><!></div>`);

	function Ui_box($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, 0),
			onclick = prop($$props, "onclick", 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$P();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", id());
			set_class(div, `box ${classes() ?? ""} `);
			set_attribute(div, "role", role());
			set_attribute(div, "tabindex", tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	var root$O = template(`<div><!></div>`);

	function Ui_content($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, 0),
			onclick = prop($$props, "onclick", 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$O();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", id());
			set_class(div, `content ${classes() ?? ""}`);
			set_attribute(div, "role", role());
			set_attribute(div, "tabindex", tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	var index$c = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBlock: Ui_block,
		UIBlockInnerVertical: Ui_block_inner_vertical,
		UIBox: Ui_box,
		UIContent: Ui_content
	});

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	function initDict(target = {}) {
	  const handler = {
	    get: function (target, prop) {
	      if (!Object.hasOwn(target, prop)) {
	        return prop;
	      }
	      return Reflect.get(...arguments);
	    }
	  };
	  return new Proxy(target, handler);
	}
	function createLocale() {
	  const {
	    subscribe,
	    set,
	    update
	  } = writable(initDict());
	  return {
	    subscribe,
	    update,
	    set: function (val) {
	      set(initDict(val));
	    },
	    reset: function () {
	      return set(initDict());
	    }
	  };
	}
	const LOCALE = createLocale();

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EventEmitter$2 = {exports: {}};

	/*!
	 * EventEmitter v5.2.9 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - https://oli.me.uk/
	 * @preserve
	 */
	var EventEmitter$1 = EventEmitter$2.exports;

	var hasRequiredEventEmitter;

	function requireEventEmitter () {
		if (hasRequiredEventEmitter) return EventEmitter$2.exports;
		hasRequiredEventEmitter = 1;
		(function (module) {
	(function (exports) {

			    /**
			     * Class for managing events.
			     * Can be extended to provide event functionality in other classes.
			     *
			     * @class EventEmitter Manages event registering and emitting.
			     */
			    function EventEmitter() {}

			    // Shortcuts to improve speed and size
			    var proto = EventEmitter.prototype;
			    var originalGlobalValue = exports.EventEmitter;

			    /**
			     * Finds the index of the listener for the event in its storage array.
			     *
			     * @param {Function[]} listeners Array of listeners to search through.
			     * @param {Function} listener Method to look for.
			     * @return {Number} Index of the specified listener, -1 if not found
			     * @api private
			     */
			    function indexOfListener(listeners, listener) {
			        var i = listeners.length;
			        while (i--) {
			            if (listeners[i].listener === listener) {
			                return i;
			            }
			        }

			        return -1;
			    }

			    /**
			     * Alias a method while keeping the context correct, to allow for overwriting of target method.
			     *
			     * @param {String} name The name of the target method.
			     * @return {Function} The aliased method
			     * @api private
			     */
			    function alias(name) {
			        return function aliasClosure() {
			            return this[name].apply(this, arguments);
			        };
			    }

			    /**
			     * Returns the listener array for the specified event.
			     * Will initialise the event object and listener arrays if required.
			     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
			     * Each property in the object response is an array of listener functions.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Function[]|Object} All listener functions for the event.
			     */
			    proto.getListeners = function getListeners(evt) {
			        var events = this._getEvents();
			        var response;
			        var key;

			        // Return a concatenated array of all matching events if
			        // the selector is a regular expression.
			        if (evt instanceof RegExp) {
			            response = {};
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    response[key] = events[key];
			                }
			            }
			        }
			        else {
			            response = events[evt] || (events[evt] = []);
			        }

			        return response;
			    };

			    /**
			     * Takes a list of listener objects and flattens it into a list of listener functions.
			     *
			     * @param {Object[]} listeners Raw listener objects.
			     * @return {Function[]} Just the listener functions.
			     */
			    proto.flattenListeners = function flattenListeners(listeners) {
			        var flatListeners = [];
			        var i;

			        for (i = 0; i < listeners.length; i += 1) {
			            flatListeners.push(listeners[i].listener);
			        }

			        return flatListeners;
			    };

			    /**
			     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Object} All listener functions for an event in an object.
			     */
			    proto.getListenersAsObject = function getListenersAsObject(evt) {
			        var listeners = this.getListeners(evt);
			        var response;

			        if (listeners instanceof Array) {
			            response = {};
			            response[evt] = listeners;
			        }

			        return response || listeners;
			    };

			    function isValidListener (listener) {
			        if (typeof listener === 'function' || listener instanceof RegExp) {
			            return true
			        } else if (listener && typeof listener === 'object') {
			            return isValidListener(listener.listener)
			        } else {
			            return false
			        }
			    }

			    /**
			     * Adds a listener function to the specified event.
			     * The listener will not be added if it is a duplicate.
			     * If the listener returns true then it will be removed after it is called.
			     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListener = function addListener(evt, listener) {
			        if (!isValidListener(listener)) {
			            throw new TypeError('listener must be a function');
			        }

			        var listeners = this.getListenersAsObject(evt);
			        var listenerIsWrapped = typeof listener === 'object';
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
			                listeners[key].push(listenerIsWrapped ? listener : {
			                    listener: listener,
			                    once: false
			                });
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of addListener
			     */
			    proto.on = alias('addListener');

			    /**
			     * Semi-alias of addListener. It will add a listener that will be
			     * automatically removed after its first execution.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addOnceListener = function addOnceListener(evt, listener) {
			        return this.addListener(evt, {
			            listener: listener,
			            once: true
			        });
			    };

			    /**
			     * Alias of addOnceListener.
			     */
			    proto.once = alias('addOnceListener');

			    /**
			     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
			     * You need to tell it what event names should be matched by a regex.
			     *
			     * @param {String} evt Name of the event to create.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvent = function defineEvent(evt) {
			        this.getListeners(evt);
			        return this;
			    };

			    /**
			     * Uses defineEvent to define multiple events.
			     *
			     * @param {String[]} evts An array of event names to define.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvents = function defineEvents(evts) {
			        for (var i = 0; i < evts.length; i += 1) {
			            this.defineEvent(evts[i]);
			        }
			        return this;
			    };

			    /**
			     * Removes a listener function from the specified event.
			     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to remove the listener from.
			     * @param {Function} listener Method to remove from the event.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListener = function removeListener(evt, listener) {
			        var listeners = this.getListenersAsObject(evt);
			        var index;
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key)) {
			                index = indexOfListener(listeners[key], listener);

			                if (index !== -1) {
			                    listeners[key].splice(index, 1);
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of removeListener
			     */
			    proto.off = alias('removeListener');

			    /**
			     * Adds listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
			     * You can also pass it a regular expression to add the array of listeners to all events that match it.
			     * Yeah, this function does quite a bit. That's probably a bad thing.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListeners = function addListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(false, evt, listeners);
			    };

			    /**
			     * Removes listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be removed.
			     * You can also pass it a regular expression to remove the listeners from all events that match it.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListeners = function removeListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(true, evt, listeners);
			    };

			    /**
			     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
			     * The first argument will determine if the listeners are removed (true) or added (false).
			     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be added/removed.
			     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
			     *
			     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
			        var i;
			        var value;
			        var single = remove ? this.removeListener : this.addListener;
			        var multiple = remove ? this.removeListeners : this.addListeners;

			        // If evt is an object then pass each of its properties to this method
			        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			            for (i in evt) {
			                if (evt.hasOwnProperty(i) && (value = evt[i])) {
			                    // Pass the single listener straight through to the singular method
			                    if (typeof value === 'function') {
			                        single.call(this, i, value);
			                    }
			                    else {
			                        // Otherwise pass back to the multiple function
			                        multiple.call(this, i, value);
			                    }
			                }
			            }
			        }
			        else {
			            // So evt must be a string
			            // And listeners must be an array of listeners
			            // Loop over it and pass each one to the multiple method
			            i = listeners.length;
			            while (i--) {
			                single.call(this, evt, listeners[i]);
			            }
			        }

			        return this;
			    };

			    /**
			     * Removes all listeners from a specified event.
			     * If you do not specify an event then all listeners will be removed.
			     * That means every event will be emptied.
			     * You can also pass a regex to remove all events that match it.
			     *
			     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeEvent = function removeEvent(evt) {
			        var type = typeof evt;
			        var events = this._getEvents();
			        var key;

			        // Remove different things depending on the state of evt
			        if (type === 'string') {
			            // Remove all listeners for the specified event
			            delete events[evt];
			        }
			        else if (evt instanceof RegExp) {
			            // Remove all events matching the regex.
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    delete events[key];
			                }
			            }
			        }
			        else {
			            // Remove all listeners in all events
			            delete this._events;
			        }

			        return this;
			    };

			    /**
			     * Alias of removeEvent.
			     *
			     * Added to mirror the node API.
			     */
			    proto.removeAllListeners = alias('removeEvent');

			    /**
			     * Emits an event of your choice.
			     * When emitted, every listener attached to that event will be executed.
			     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
			     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
			     * So they will not arrive within the array on the other side, they will be separate.
			     * You can also pass a regular expression to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {Array} [args] Optional array of arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emitEvent = function emitEvent(evt, args) {
			        var listenersMap = this.getListenersAsObject(evt);
			        var listeners;
			        var listener;
			        var i;
			        var key;
			        var response;

			        for (key in listenersMap) {
			            if (listenersMap.hasOwnProperty(key)) {
			                listeners = listenersMap[key].slice(0);

			                for (i = 0; i < listeners.length; i++) {
			                    // If the listener returns true then it shall be removed from the event
			                    // The function is executed either with a basic call or an apply if there is an args array
			                    listener = listeners[i];

			                    if (listener.once === true) {
			                        this.removeListener(evt, listener.listener);
			                    }

			                    response = listener.listener.apply(this, args || []);

			                    if (response === this._getOnceReturnValue()) {
			                        this.removeListener(evt, listener.listener);
			                    }
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of emitEvent
			     */
			    proto.trigger = alias('emitEvent');

			    /**
			     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
			     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {...*} Optional additional arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emit = function emit(evt) {
			        var args = Array.prototype.slice.call(arguments, 1);
			        return this.emitEvent(evt, args);
			    };

			    /**
			     * Sets the current value to check against when executing listeners. If a
			     * listeners return value matches the one set here then it will be removed
			     * after execution. This value defaults to true.
			     *
			     * @param {*} value The new value to check for when executing listeners.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.setOnceReturnValue = function setOnceReturnValue(value) {
			        this._onceReturnValue = value;
			        return this;
			    };

			    /**
			     * Fetches the current value to check against when executing listeners. If
			     * the listeners return value matches this one then it should be removed
			     * automatically. It will return true by default.
			     *
			     * @return {*|Boolean} The current value to check for or the default, true.
			     * @api private
			     */
			    proto._getOnceReturnValue = function _getOnceReturnValue() {
			        if (this.hasOwnProperty('_onceReturnValue')) {
			            return this._onceReturnValue;
			        }
			        else {
			            return true;
			        }
			    };

			    /**
			     * Fetches the events object and creates one if required.
			     *
			     * @return {Object} The events storage object.
			     * @api private
			     */
			    proto._getEvents = function _getEvents() {
			        return this._events || (this._events = {});
			    };

			    /**
			     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
			     *
			     * @return {Function} Non conflicting EventEmitter class.
			     */
			    EventEmitter.noConflict = function noConflict() {
			        exports.EventEmitter = originalGlobalValue;
			        return EventEmitter;
			    };

			    // Expose the class either via AMD, CommonJS or the global object
			    if (module.exports){
			        module.exports = EventEmitter;
			    }
			    else {
			        exports.EventEmitter = EventEmitter;
			    }
			}(typeof window !== 'undefined' ? window : EventEmitter$1 || {})); 
		} (EventEmitter$2));
		return EventEmitter$2.exports;
	}

	var EventEmitterExports = requireEventEmitter();
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(EventEmitterExports);

	/*
		:property.sub1.func().funcProp
		 = return funcProp of function result of sub1 property of property of object
		:{::helperVal}.sub
		 = return sub property of object property with name retrieved from helperVal property of helpers object
		:{::helperFunc()}.sub
		= return sub property of object property with name retrieved from helperVal function result of helpers object.
		if helpersFunx return 'car' then source path becomes :car.sub

	*/

	var src$1;
	var hasRequiredSrc$1;

	function requireSrc$1 () {
		if (hasRequiredSrc$1) return src$1;
		hasRequiredSrc$1 = 1;
		const SUB_PATH_START = "{",
		    SUB_PATH_END = "}",
		    PATH_SPLIT = ".",
		    PATH_START_OBJECT = ":",
		    PATH_START_HELPERS = "::",
		    FUNCTION_MARKER = "()",
		    MAX_DEEP = 10;

		/**
		 * Set of tools to use notPath property access notation
		 * : is for item
		 * :: is for helpers
		 * {} subpath
		 * . path splitter
		 * () function and should be executed with params (item, helper | undefined)
		 * sub-paths will be parsed and replaced by results in source path
		 */
		class notPath {
		    static get SUB_PATH_START() {
		        return SUB_PATH_START;
		    }
		    static get SUB_PATH_END() {
		        return SUB_PATH_END;
		    }
		    static get PATH_SPLIT() {
		        return PATH_SPLIT;
		    }
		    static get PATH_START_OBJECT() {
		        return PATH_START_OBJECT;
		    }
		    static get PATH_START_HELPERS() {
		        return PATH_START_HELPERS;
		    }
		    static get FUNCTION_MARKER() {
		        return FUNCTION_MARKER;
		    }
		    static get MAX_DEEP() {
		        return MAX_DEEP;
		    }

		    /*
				input ':{::helperVal}.sub'
				return ::helperVal
			*/

		    /**
		     * Returns first subpath in path
		     * if subpath not closed will return it anyway
		     * @param {string} path path in string notation
		     * @return {string|null} subpath or null if no sub path were found
		     */
		    static findNextSubPath(path) {
		        let subPath = "",
		            find = false;
		        for (let i = 0; i < path.length; i++) {
		            if (path[i] === SUB_PATH_START) {
		                find = true;
		                subPath = "";
		            } else {
		                if (path[i] === SUB_PATH_END && find) {
		                    return subPath;
		                } else {
		                    subPath += path[i];
		                }
		            }
		        }
		        return find ? subPath : null;
		    }

		    /**
		     * Replace sub-path in parent path by parsed version
		     * @param {string} path path to process
		     * @param {string} sub sub path to replace
		     * @param {string} parsed parsed sub path
		     * @return {string} parsed path
		     */

		    static replaceSubPath(path, sub, parsed) {
		        let subf = SUB_PATH_START + sub + SUB_PATH_END,
		            i = 0;
		        while (path.indexOf(subf) > -1 && i < MAX_DEEP) {
		            path = path.replace(subf, parsed);
		            i++;
		        }
		        return path;
		    }

		    /**
		     * Parses path while there any sub-paths
		     * @param {string} path raw unparsed path
		     * @param {object} item data
		     * @param {object} helpers helpers
		     * @return {string} parsed path
		     */
		    static parseSubs(path, item, helpers) {
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            i++;
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		        }
		        return path;
		    }

		    /**
		     * Get property value
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} [helpers] helpers object
		     */

		    static get(path, item, helpers = undefined) {
		        switch (path) {
		            case PATH_START_OBJECT:
		                return item;
		            case PATH_START_HELPERS:
		                return helpers;
		        }
		        path = this.parseSubs(path, item, helpers);
		        return this.getValueByPath(
		            path.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		            path,
		            item,
		            helpers
		        );
		    }

		    /**
		     * Set property value
		     * @param {string}  path path to property
		     * @param {object}  item item object
		     * @param {object}  helpers         helpers object if 4 arguments or attrValue if only 3 provided
		     * @param {any}     [attrValue]     value we want to assign
		     */

		    static set(path, item, helpers, attrValue = undefined) {
		        if (arguments.length === 3) {
		            attrValue = helpers;
		            helpers = undefined;
		        }
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		            i++;
		        }
		        this.setValueByPath(item, path, attrValue);
		        if (
		            item.isRecord &&
		            this.normilizePath(path).length > 1 &&
		            item.__isActive
		        ) {
		            item.trigger("change", item, path, attrValue);
		        }
		    }

		    /**
		     * Set target property to null
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} helpers helpers object
		     */

		    static unset(path, item, helpers) {
		        this.set(path, item, helpers, null);
		    }

		    /**
		     * Parses step key, transforms it to end-form
		     * @param {string} step not parsed step key
		     * @param {object} item item object
		     * @param {object} helper helpers object
		     * @return {string|number} parsed step key
		     */

		    static parsePathStep(step, item, helper) {
		        let rStep = null;
		        if (step.indexOf(PATH_START_HELPERS) === 0 && helper) {
		            rStep = step.replace(PATH_START_HELPERS, "");
		            if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                rStep = rStep.replace(FUNCTION_MARKER, "");
		                if (Object.prototype.hasOwnProperty.call(helper, rStep)) {
		                    return helper[rStep](item, undefined);
		                }
		            } else {
		                return helper[rStep];
		            }
		        } else {
		            if (step.indexOf(PATH_START_OBJECT) === 0 && item) {
		                rStep = step.replace(PATH_START_OBJECT, "");
		                if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                    rStep = rStep.replace(FUNCTION_MARKER, "");
		                    if (Object.prototype.hasOwnProperty.call(item, rStep)) {
		                        return item[rStep](item, undefined);
		                    }
		                } else {
		                    return item[rStep];
		                }
		            }
		        }
		        return step;
		    }

		    //::fieldName.result
		    //{}
		    //{fieldName: 'targetRecordField'}
		    ////['targetRecordField', 'result']
		    /**
		     * Transforms path with sub paths to path without
		     * @param {string|array} path path to target property
		     * @param {object} item item object
		     * @param {object} helper helper object
		     * @return {array} parsed path
		     **/
		    static parsePath(path, item, helper) {
		        if (!Array.isArray(path)) {
		            path = path.split(PATH_SPLIT);
		        }
		        for (var i = 0; i < path.length; i++) {
		            path[i] = this.parsePathStep(path[i], item, helper);
		        }
		        return path;
		    }

		    /**
		     * Transforms path from string notation to array of keys
		     * @param {string|array} path  input path, if array does nothing
		     * @return {array} path in array notation
		     */

		    static normilizePath(path) {
		        if (Array.isArray(path)) {
		            return path;
		        } else {
		            while (path.indexOf(PATH_START_OBJECT) > -1) {
		                path = path.replace(PATH_START_OBJECT, "");
		            }
		            return path.split(PATH_SPLIT);
		        }
		    }

		    /*
				small = ["todo"],
				big = ["todo", "length"]
				return true;

			*/

		    /**
		     * Identifies if first path includes second, compared from start,
		     * no floating start position inside ['join', 'me'], ['me']
		     * will result in false
		     * @param {array} big where we will search
		     * @param {array} small what we will search
		     * @return {boolean} if we succeed
		     */

		    static ifFullSubPath(big, small) {
		        if (big.length < small.length) {
		            return false;
		        }
		        for (let t = 0; t < small.length; t++) {
		            if (small[t] !== big[t]) {
		                return false;
		            }
		        }
		        return true;
		    }

		    /**
		     * Getter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be used as getter
		     * @param {string|array} attrPath path to property
		     * @param {object} item supporting data
		     * @param {helpers} object  supporting helpers
		     */

		    static getValueByPath(object, attrPath, item, helpers) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift(),
		            isFunction = attrName.indexOf(FUNCTION_MARKER) > -1;
		        if (isFunction) {
		            attrName = attrName.replace(FUNCTION_MARKER, "");
		        }
		        if (
		            (typeof object === "object" || typeof object === "function") &&
		            typeof object !== "undefined" &&
		            object !== null &&
		            typeof object[attrName] !== "undefined" &&
		            object[attrName] !== null
		        ) {
		            let newObj = isFunction
		                ? object[attrName]({
		                      item,
		                      helpers,
		                  })
		                : object[attrName];
		            if (attrPath.length > 0) {
		                return this.getValueByPath(newObj, attrPath, item, helpers);
		            } else {
		                return newObj;
		            }
		        } else {
		            return undefined;
		        }
		    }

		    /**
		     * Setter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be modified
		     * @param {string|array} attrPath path to property
		     * @param {any} attrValue  value to assign
		     */

		    static setValueByPath(object, attrPath, attrValue) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift();
		        if (attrPath.length > 0) {
		            if (!Object.prototype.hasOwnProperty.call(object, attrName)) {
		                object[attrName] = {};
		            }
		            this.setValueByPath(object[attrName], attrPath, attrValue);
		        } else {
		            object[attrName] = attrValue;
		        }
		    }

		    /**
		     * Joins passed in strings with PATH_SPLIT
		     * @param {string} arguments path to be glued
		     * @return {string} composite path
		     */

		    static join() {
		        let args = Array.prototype.slice.call(arguments);
		        return args.join(PATH_SPLIT);
		    }
		}

		src$1 = notPath;
		return src$1;
	}

	var notPath$1;
	var hasRequiredNotPath;

	function requireNotPath () {
		if (hasRequiredNotPath) return notPath$1;
		hasRequiredNotPath = 1;
		notPath$1 = requireSrc$1();
		return notPath$1;
	}

	var notPathExports = requireNotPath();
	var notPath = /*@__PURE__*/getDefaultExportFromCjs(notPathExports);

	var _notCommon;

	/*
	https://github.com/TehShrike/is-mergeable-object

	Included for convinience only. All rights belongs to their authors and etc.
	start of my code marked.

	*/

	let isMergeableObject = function isMergeableObject(value) {
	  return isNonNullObject(value) && !isSpecial(value);
	};
	function isNonNullObject(value) {
	  return !!value && typeof value === "object";
	}
	function isSpecial(value) {
	  var stringValue = Object.prototype.toString.call(value);
	  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
	function isReactElement(value) {
	  return value.$$typeof === REACT_ELEMENT_TYPE;
	}

	/*
	https://github.com/KyleAMathews/deepmerge

	The MIT License (MIT)

	Copyright (c) 2012 Nicholas Fisher

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	function emptyTarget(val) {
	  return Array.isArray(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	  const clone = !optionsArgument || optionsArgument.clone !== false;
	  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
	}
	function defaultArrayMerge(target, source, optionsArgument) {
	  return target.concat(source).map(function (element) {
	    return cloneUnlessOtherwiseSpecified(element, optionsArgument);
	  });
	}
	function mergeObject(target, source, optionsArgument) {
	  const destination = {};
	  if (isMergeableObject(target)) {
	    Object.keys(target).forEach(function (key) {
	      destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);
	    });
	  }
	  Object.keys(source).forEach(function (key) {
	    if (!isMergeableObject(source[key]) || !target[key]) {
	      destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);
	    } else {
	      destination[key] = deepmerge(target[key], source[key], optionsArgument);
	    }
	  });
	  return destination;
	}
	function deepmerge(target, source, optionsArgument) {
	  const sourceIsArray = Array.isArray(source);
	  const targetIsArray = Array.isArray(target);
	  const options = optionsArgument || {
	    arrayMerge: defaultArrayMerge
	  };
	  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
	  if (!sourceAndTargetTypesMatch) {
	    return cloneUnlessOtherwiseSpecified(source, optionsArgument);
	  } else if (sourceIsArray) {
	    const arrayMerge = options.arrayMerge || defaultArrayMerge;
	    return arrayMerge(target, source, optionsArgument);
	  } else {
	    return mergeObject(target, source, optionsArgument);
	  }
	}
	deepmerge.all = function deepmergeAll(array, optionsArgument) {
	  if (!Array.isArray(array)) {
	    throw new Error("first argument should be an array");
	  }
	  return array.reduce(function (prev, next) {
	    return deepmerge(prev, next, optionsArgument);
	  }, {});
	};

	/**
	 *  Collection of common functions
	 *  @class
	 */
	let notCommon$1 = /*#__PURE__*/function () {
	  function notCommon() {
	    _classCallCheck(this, notCommon);
	  }
	  return _createClass(notCommon, null, [{
	    key: "isError",
	    value:
	    /**
	     *  @static {function} isError  function to perform object test, if it's an error object or not
	     * @param   {object}    e   object to test
	     */
	    function isError(e) {
	      return e instanceof Error ||
	      // @ts-ignore
	      Object.hasOwn(e, "status") && e.status === "error";
	    }
	  }, {
	    key: "mute",
	    value: function mute() {
	      notCommon.ENV_TYPE = "production";
	    }
	  }, {
	    key: "pad",
	    value: function pad(n) {
	      return n < 10 ? "0" + n : n;
	    }
	    /**
	     *  Returns today Date object without hours, minutes, seconds
	     *  @return {number}  current date with 00:00:00 in ms of unix time
	     */
	  }, {
	    key: "getTodayDate",
	    value: function getTodayDate() {
	      let t = new Date();
	      return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
	    }

	    /**
	     *  Returns true if object has field of name
	     *   @param   {object}    obj    some object
	     *  @param  {string}    name  field name
	     *  @return {boolean}          if object contains field with name
	     **/
	  }, {
	    key: "objHas",
	    value: function objHas(obj, name) {
	      // @ts-ignore
	      return Object.hasOwn(obj, name);
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "copyObj",
	    value: function copyObj(obj) {
	      return JSON.parse(JSON.stringify(obj));
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "partCopyObj",
	    value: function partCopyObj(obj, list) {
	      let partObj = Object.keys(obj).reduce(function (prev, curr) {
	        if (list.includes(curr)) {
	          prev[curr] = obj[curr];
	        }
	        return prev;
	      }, {});
	      return JSON.parse(JSON.stringify(partObj));
	    }
	  }, {
	    key: "compareTwoArrays",
	    value: function compareTwoArrays(a, b) {
	      return a.length === b.length && a.every(function (element, index) {
	        return element === b[index];
	      });
	    }

	    /**
	     * Test argument type to be 'function'
	     * @param {any}  func    possible function
	     * @return {boolean}     if this is a function
	     **/
	  }, {
	    key: "isFunc",
	    value: function isFunc(func) {
	      return typeof func === "function";
	    }

	    /**
	     * Returns true if argument is Async function
	     * @param {function} func  to test
	     * @return {boolean}       if this function is constructed as AsyncFunction
	     **/
	  }, {
	    key: "isAsync",
	    value: function isAsync(func) {
	      return func.constructor.name === "AsyncFunction";
	    }

	    /**
	     *  Executes method of object in appropriate way inside Promise
	     * @param {object}   obj     original object
	     * @param {string}   name    method name to execute
	     * @param {Array}     params  array of params
	     * @return {Promise}          results of method execution
	     **/
	  }, {
	    key: "executeObjectFunction",
	    value: async function executeObjectFunction(obj, name, params) {
	      if (obj) {
	        // @ts-ignore
	        const proc = notPath.get(":" + name, obj);
	        if (notCommon.isFunc(proc)) {
	          if (notCommon.isAsync(proc)) {
	            return await proc(...params);
	          } else {
	            return proc(...params);
	          }
	        }
	      }
	    }

	    /**
	     *  Executes method of object in apropriate way inside Promise
	     * @param {Object}   from     original object
	     * @param {Object}   to    method name to execute
	     * @param {Array}     list  array of params
	     * @return {undefined}          results of method execution
	     **/
	  }, {
	    key: "mapBind",
	    value: function mapBind(from, to, list) {
	      list.forEach(function (item) {
	        if (typeof from[item] === "function") {
	          to[item] = from[item].bind(from);
	        }
	      });
	    }
	  }, {
	    key: "isClass",
	    value: function isClass(fn) {
	      return /^\s*class/.test(fn.toString());
	    }
	  }, {
	    key: "detectType",
	    value: function detectType(testie) {
	      if (typeof testie !== "function") {
	        return typeof testie;
	      } else {
	        if (notCommon.isClass(testie)) {
	          return "class";
	        } else {
	          return "function";
	        }
	      }
	    }

	    //Проверка является ли переменная массивом
	  }, {
	    key: "isArray",
	    value: function isArray(data) {
	      return typeof data == "object" && data instanceof Array;
	    }
	  }, {
	    key: "localIsoDate",
	    value: function localIsoDate(date) {
	      date = date || new Date();
	      let localIsoString = date.getFullYear() + "-" + notCommon.pad(date.getMonth() + 1) + "-" + notCommon.pad(date.getDate()) + "T" + notCommon.pad(date.getHours()) + ":" + notCommon.pad(date.getMinutes()) + ":" + notCommon.pad(date.getSeconds());
	      return localIsoString;
	    }
	  }, {
	    key: "getToday",
	    value: function getToday() {
	      let today = new Date();
	      let date = today.getFullYear() + "-" + notCommon.pad(today.getMonth() + 1) + "-" + notCommon.pad(today.getDate());
	      return date;
	    }
	  }, {
	    key: "backlogAdd",
	    value: function backlogAdd(msg, type = "log") {
	      if (notCommon.get("backlog") === true) {
	        notCommon.backlog.push({
	          msg,
	          type
	        });
	      }
	    }
	  }, {
	    key: "dumpBacklog",
	    value: function dumpBacklog() {
	      while (notCommon.backlog.length) {
	        let row = notCommon.backlog.shift();
	        window[notCommon.LOG][row.type](...row.msg);
	      }
	    }
	  }, {
	    key: "logMsg",
	    value: function logMsg() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].log(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "log");
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      notCommon.logMsg(...arguments);
	    }
	  }, {
	    key: "createLogger",
	    value: function createLogger(prefix) {
	      return {
	        log: notCommon.genLogMsg(prefix),
	        error: notCommon.genLogError(prefix),
	        debug: notCommon.genLogDebug(prefix),
	        report: notCommon.report
	      };
	    }

	    //Генерация метода вывода сообщений в консоль с указанием префикса.
	  }, {
	    key: "genLogMsg",
	    value: function genLogMsg(prefix) {
	      return function () {
	        //not arrow bc of arguments special var is not available in arrow functions
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].log(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "log");
	      };
	    }

	    /**
	     * Определяет является ли окружение окружением разработки
	     * @returns  {boolean} true если это запущено в окружении разработки
	     **/
	  }, {
	    key: "isDev",
	    value: function isDev() {
	      return notCommon.ENV_TYPE === notCommon.DEV_ENV;
	    }
	  }, {
	    key: "debug",
	    value: function debug() {
	      if (notCommon.isDev()) {
	        return notCommon.logMsg(...arguments);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "genLogDebug",
	    value: function genLogDebug(prefix) {
	      if (notCommon.isDev()) {
	        return notCommon.genLogMsg(prefix);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      notCommon.logError(...arguments);
	    }

	    //Функция вывода сообщения об ошибке
	  }, {
	    key: "logError",
	    value: function logError() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].error(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "error");
	    }
	  }, {
	    key: "genLogError",
	    value: function genLogError(prefix) {
	      return function () {
	        //do not change to arrow function, bc of arguments
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].error(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "error");
	      };
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon.getApp()) {
	        let reporter = notCommon.getApp().getService("nsErrorReporter");
	        if (reporter) {
	          reporter.report(e).catch(notCommon.error);
	        }
	      } else {
	        if (!notCommon.get("production")) {
	          notCommon.error(...arguments);
	        }
	      }
	    }
	  }, {
	    key: "trace",
	    value: function trace() {
	      if (!notCommon.get("production")) {
	        notCommon.trace(...arguments);
	      }
	    }
	  }, {
	    key: "trimBackslash",
	    value: function trimBackslash(str) {
	      if (str.indexOf("/") === 0) {
	        str = str.substring(1);
	      }
	      if (str[str.length - 1] === "/") {
	        str = str.substring(0, str.length - 1);
	      }
	      return str;
	    }

	    /**
	     *  Builds URL with structure like prefix/module/model/id/action
	     * If some part absent or set to false it will be excluded from result
	     *  @param {object} urlParts
	     *  @param {string} [urlParts.prefix='']
	     *  @param {string} [urlParts.module='']
	     *  @param {string} [urlParts.model='']
	     *  @param {string} [urlParts.id='']
	     *  @param {string} [urlParts.action='']
	     *  @return {string}  url path
	     */
	  }, {
	    key: "buildURL",
	    value: function buildURL({
	      prefix,
	      module,
	      model,
	      id,
	      action
	    } = {
	      prefix: "",
	      module: "",
	      model: "",
	      id: "",
	      action: ""
	    }) {
	      let url = ["/"];
	      if (prefix) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(prefix)));
	      }
	      if (module) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(module)));
	      }
	      if (model) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(model)));
	      }
	      if (id) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(id)));
	      }
	      if (action) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(action)));
	      }
	      url = url.filter(function (el) {
	        return el !== "";
	      });
	      return url.join("/").replace(/\/\//g, "/");
	    }
	  }, {
	    key: "capitalizeFirstLetter",
	    value: function capitalizeFirstLetter(name) {
	      return name.charAt(0).toUpperCase() + name.slice(1);
	    }
	  }, {
	    key: "lowerFirstLetter",
	    value: function lowerFirstLetter(string) {
	      return string.charAt(0).toLowerCase() + string.slice(1);
	    }
	  }, {
	    key: "strLengthCap",
	    value: function strLengthCap(str, MAX_TITLE_LENGTH = 50, POST_FIX = "...") {
	      if (typeof str === "string" && str.length > MAX_TITLE_LENGTH) {
	        return str.substr(0, MAX_TITLE_LENGTH) + POST_FIX;
	      } else {
	        return str;
	      }
	    }
	  }, {
	    key: "escapeHtml",
	    value: function escapeHtml(unsafe) {
	      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
	    }
	  }, {
	    key: "startApp",
	    value: function startApp(starter) {
	      document.addEventListener("DOMContentLoaded", starter);
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon.get("app");
	    }
	  }, {
	    key: "extendAppConfig",
	    value: function extendAppConfig(conf, conf2) {
	      return notCommon.deepMerge(conf, conf2);
	    }
	  }, {
	    key: "absorbModule",
	    value: function absorbModule() {
	      let defaultConf,
	        //app options
	        mod,
	        //module options
	        targets = {}; //various collections
	      if (arguments.length == 1) {
	        targets = {
	          ...arguments[0]
	        };
	        if (Object.hasOwnProperty.call(arguments[0], "defaultConf")) {
	          defaultConf = arguments[0].defaultConf;
	          delete targets.defaultConf;
	        }
	        if (Object.hasOwnProperty.call(arguments[0], "mod")) {
	          mod = arguments[0].mod;
	          delete targets.mod;
	        }
	      } else {
	        notCommon.log("WARNING: absorbModule format obsoleted, use object {defaultConf, mod, services, uis, wsc, etc}");
	        defaultConf = arguments[0];
	        mod = arguments[1];
	        if (arguments.length > 2) {
	          targets.services = arguments[2];
	        }
	        if (arguments.length > 3) {
	          targets.uis = arguments[3];
	        }
	        if (arguments.length > 4) {
	          targets.wcs = arguments[4];
	        }
	      }
	      for (let prop in mod) {
	        //add manifest to other
	        if (prop === "manifest") {
	          defaultConf = notCommon.extendAppConfig(defaultConf, mod.manifest);
	          continue;
	        }
	        if (typeof notCommon.get(`absorb.${prop}`) === "function") {
	          // @ts-ignore
	          if (!Object.hasOwn(targets, prop)) {
	            targets[prop] = {};
	            notCommon.log(`WARNING: no accamulator object provided for '${prop}' collection`);
	          }
	          notCommon.get(`absorb.${prop}`)(targets[prop], mod[prop]);
	        } else if (prop.indexOf("nc") === 0) {
	          // @ts-ignore
	          if (!Object.hasOwn(defaultConf, "controllers")) {
	            defaultConf.controllers = {};
	          }
	          defaultConf.controllers[prop] = mod[prop];
	        } else {
	          //in case of some other stuff presented, isolating it in special var
	          // @ts-ignore
	          if (!Object.hasOwn(window, "notEnv")) {
	            // @ts-ignore
	            window.notEnv = {};
	          }
	          // @ts-ignore
	          window.notEnv[prop] = mod[prop];
	        }
	      }
	      return defaultConf;
	    }
	  }, {
	    key: "defineIfNotExists",
	    value: function defineIfNotExists(obj, key, defaultValue) {
	      // @ts-ignore
	      if (!Object.hasOwn(obj, key)) {
	        obj[key] = defaultValue;
	      }
	    }
	  }, {
	    key: "register",
	    value: function register(key, val) {
	      notCommon.registry[key] = val;
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      // @ts-ignore
	      return Object.hasOwn(notCommon.registry, key) ? notCommon.registry[key] : null;
	    }

	    /**
	     * Moves item inside array from old_index to new_index
	     * @static
	     * @param {Array<any>} array
	     * @param {number} old_index
	     * @param {number} new_index
	     * @memberof notCommon
	     */
	  }, {
	    key: "moveItem",
	    value: function moveItem(array, old_index, new_index) {
	      const inRange = function (num) {
	        return num < array.length && num > -1;
	      };
	      if (inRange(new_index) && inRange(old_index)) {
	        array.splice(new_index, 0, array.splice(old_index, 1)[0]);
	      }
	    }
	  }, {
	    key: "stripProxy",
	    value: function stripProxy(obj) {
	      if (typeof obj !== "undefined" && obj !== null) {
	        if (obj.isProxy) {
	          if (Array.isArray(obj)) {
	            obj = Array.from(obj);
	          } else {
	            obj = Object.assign({}, obj);
	          }
	          for (let t in obj) {
	            // @ts-ignore
	            if (Object.hasOwn(obj, t)) {
	              obj[t] = notCommon.stripProxy(obj[t]);
	            }
	          }
	        }
	      }
	      return obj;
	    }
	  }, {
	    key: "pipe",
	    value: function pipe(data /* feed data */, funcs /* functions array */) {
	      let result;
	      for (let func of funcs) {
	        result = func(result || data);
	      }
	      return result;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string} type
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getAPI",
	    value: function getAPI(type) {
	      return notCommon.getManager()?.getAPI(type) ?? null;
	    }
	  }, {
	    key: "setManager",
	    value: function setManager(v) {
	      notCommon.MANAGER = v;
	    }

	    /**
	     *
	     *
	     * @static
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getManager",
	    value: function getManager() {
	      return notCommon.MANAGER;
	    }
	  }, {
	    key: "getJSON",
	    value: function getJSON(url) {
	      return fetch(url).then(function (response) {
	        return response.json();
	      });
	    }
	  }, {
	    key: "wait",
	    value: function wait(sec) {
	      return new Promise(function (res) {
	        setTimeout(res, sec * 1000);
	      });
	    }
	  }, {
	    key: "registerWidgetEvents",
	    value: function registerWidgetEvents(events) {
	      if (notCommon.getApp()) {
	        Object.keys(events).forEach(function (eventName) {
	          notCommon.getApp().on(eventName, events[eventName]);
	        });
	      }
	    }
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      notCommon.getApp() && notCommon.getApp().getWorking("router").navigate(url);
	    }
	  }, {
	    key: "select",
	    value: function select(variantsSet, value, def) {
	      if (variantsSet && typeof variantsSet == "object" && notCommon.objHas(variantsSet, value) && typeof variantsSet[value] !== "undefined" && variantsSet[value] !== null) {
	        return variantsSet[value];
	      } else {
	        return def;
	      }
	    }
	  }]);
	}();
	_notCommon = notCommon$1;
	/**
	 *  @static {Object} [MANAGER=null]  application manager, in some cases used to control initialization routine
	 */
	_defineProperty(notCommon$1, "MANAGER", null);
	/**
	 *  @static {string} [LOG="console"]  logger, window[LOG]
	 */
	_defineProperty(notCommon$1, "LOG", "console");
	/**
	 *  @static {function} deepMerge  function to perform deep merges of objects
	 */
	_defineProperty(notCommon$1, "deepMerge", deepmerge);
	_defineProperty(notCommon$1, "TZ_OFFSET", new Date().getTimezoneOffset() / 60 * -1);
	_defineProperty(notCommon$1, "DEV_ENV", "production");
	// @ts-ignore
	_defineProperty(notCommon$1, "ENV_TYPE", window.NOT_ENV_TYPE ?? _notCommon.DEV_ENV);
	_defineProperty(notCommon$1, "NOOP", function () {});
	_defineProperty(notCommon$1, "backlog", []);
	_defineProperty(notCommon$1, "registry", {});
	function absorbServices(target, src) {
	  if (target) {
	    for (let serv in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, serv)) {
	        notCommon$1.logError(`services property duplication ${serv}`);
	      }
	      target[serv] = src[serv];
	    }
	  }
	}
	function extendWSClient(wcs, wscName, wscOptions) {
	  // @ts-ignore
	  if (!Object.hasOwn(wcs, wscName)) {
	    wcs[wscName] = {
	      connection: {},
	      router: {
	        routes: {}
	      },
	      messenger: {}
	    };
	  }
	  let target = wcs[wscName];
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "router")) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions.router, "routes")) {
	      for (let routeType in wscOptions.router.routes) {
	        // @ts-ignore
	        if (!Object.hasOwn(target.router.routes, routeType)) {
	          target.router.routes[routeType] = {};
	        }
	        Object.assign(target.router.routes[routeType], {
	          ...wscOptions.router.routes[routeType]
	        });
	      }
	    }
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "messenger")) {
	    Object.assign(target.messenger, {
	      ...wscOptions.messenger
	    });
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "connection")) {
	    Object.assign(target.connection, {
	      ...wscOptions.connection
	    });
	  }
	  for (let t of ["name", "getToken", "logger", "identity", "credentials"]) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions, t)) {
	      target[t] = wscOptions[t];
	    }
	  }
	}
	function absorbWSC(target, src) {
	  if (target) {
	    for (let wsClientName in src) {
	      extendWSClient(target, wsClientName, src[wsClientName]);
	    }
	  }
	}
	function absorbUIs(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`uis property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	function absorbFields(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`fields property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	notCommon$1.register("absorb.wsc", absorbWSC);
	notCommon$1.register("absorb.services", absorbServices);
	notCommon$1.register("absorb.uis", absorbUIs);
	notCommon$1.register("absorb.uis", absorbFields);

	/**
	 * strings localization and formating model
	 * @class
	 */
	let notLocale = /*#__PURE__*/function (_EventEmitter) {
	  function notLocale() {
	    var _this;
	    _classCallCheck(this, notLocale);
	    _this = _callSuper(this, notLocale);
	    _this.dict = {}; //dictionary of phrases
	    _this.helpers = {}; //additional helper functions and constants
	    let dict = _this.restoreFromStorage();
	    if (dict) {
	      _this.set(dict);
	    }
	    return _this;
	  }

	  /**
	   * String format should comply notPath standart.
	   * {path_to_access} - is
	   * : - is used to access to params
	   * :: - is used to access to helpers
	   * Welcome, {:where}! - will replace {:where} with content of params.where
	   * Welcome, {::where}! - will replace {:where} with content of this.helpers.where
	   * () - after path is to invoke function of target object
	   * Welcome, {::where()}! - will try to exec this.helpers.where(params, undefined)
	   * @param    {string}  str         localized string template with mark to include data
	   * @param    {object}  params      params to use in string
	   * @returns  {string}              localized version of string with
	   */
	  _inherits(notLocale, _EventEmitter);
	  return _createClass(notLocale, [{
	    key: "format",
	    value: function format(str, params) {
	      return notPath.parseSubs(str, params, this.helpers);
	    }

	    /**
	     * Return localized version of string with injected data from provided object
	     * may also use Locale.helpers as source of data
	     * @param {string}   phrase    name of string to localize
	     * @param {object}   params    object with data to inject in phrase template
	     * @return {string}            localized string with injected data
	     */
	  }, {
	    key: "say",
	    value: function say(phrase, params = false) {
	      try {
	        if (notCommon$1.objHas(this.dict, phrase)) {
	          let tmpl = this.dict[phrase],
	            result = "";
	          if (params) {
	            result = this.format(tmpl, params);
	          } else {
	            result = tmpl;
	          }
	          return result;
	        } else {
	          throw new Error(`Unknown locale phrase: ${phrase}`);
	        }
	      } catch (e) {
	        notCommon$1.debug(e);
	        return phrase;
	      }
	    }

	    /**
	     * Setting new dictionary. triggers event 'change'
	     * @param {object}     dict      vocabulary of phrases and templates
	     **/
	  }, {
	    key: "set",
	    value: function set(dict) {
	      LOCALE.set(dict);
	      this.saveToStorage(dict);
	      this.dict = Object.assign({}, {
	        ...dict
	      });
	      this.emit("change");
	    }
	  }, {
	    key: "saveToStorage",
	    value: function saveToStorage(dict) {
	      if (window.localStorage) {
	        try {
	          return window.localStorage.setItem("dictionary", JSON.stringify(dict));
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "restoreFromStorage",
	    value: function restoreFromStorage() {
	      if (window.localStorage) {
	        try {
	          let str = window.localStorage.getItem("dictionary");
	          if (str) {
	            let dict = JSON.parse(str);
	            return dict;
	          } else {
	            return false;
	          }
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }

	    /**
	     * Returns writable store of phrases
	     * @return {object}  writable store
	     */
	  }, {
	    key: "vocabulary",
	    value: function vocabulary() {
	      return LOCALE;
	    }
	  }]);
	}(EventEmitter);
	var notLocale$1 = new notLocale();

	const say = notLocale$1.say.bind(notLocale$1);

	var root_1$u = template(`<span role="button" tabindex="0"> </span>`);

	function Ui_tag($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		let sided = state(false);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id] - if we want to address this tag
		 * @property {string} [title]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [padding]
		 * @property {boolean} [bold]
		 * @property {boolean} [right]
		 * @property {boolean} [left]
		 * @property {boolean} [top]
		 * @property {boolean} [bottom]
		 * @property {string} [class]
		 * @property {any} [events]
		 * @property {any} [register] - register event handlers
		 * @property {any} [onUpdate]
		 * @property {any} [action]
		 * @property {object} [vars]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, "tagId"),
			title = prop($$props, "title", 15, "tag"),
			color = prop($$props, "color", 3, "info"),
			size = prop($$props, "size", 3, "normal"),
			padding = prop($$props, "padding", 3, "normal"),
			bold = prop($$props, "bold", 3, false),
			right = prop($$props, "right", 3, false),
			left = prop($$props, "left", 3, false),
			top = prop($$props, "top", 3, false),
			bottom = prop($$props, "bottom", 3, false),
			classes = prop($$props, "class", 3, ""),
			events = prop($$props, "events", 31, () => proxy({})),
			register = prop($$props, "register", 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, "onUpdate", 3, (data) => {
				if (Object.hasOwn(data, "title")) {
					title(data.title);
				}
			}),
			action = prop($$props, "action", 3, () => {
				return true;
			}),
			vars = prop($$props, "vars", 19, () => ({}));

		function getStandartUpdateEventName() {
			return `tag-${id()}:update`;
		}

		let style = state("");

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
			set(sided, proxy(right() || left() || top() || bottom()));
		});

		user_effect(() => {
			set(style, proxy(Object.keys(snapshot(vars())).map((varName) => {
				return `${varName}: ${vars()[varName]};`;
			}).join("")));
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$u();

				span.__keydown = function (...$$args) {
					(action() ? action() : undefined)?.apply(this, $$args);
				};

				span.__click = function (...$$args) {
					(action() ? action() : undefined)?.apply(this, $$args);
				};

				var text = child(span, true);

				reset(span);

				template_effect(() => {
					set_attribute(span, "id", `tag-${id() ?? ""}`);

					set_class(span, `
  tag
  ${(bold() ? 'has-text-weight-bold' : '') ?? ""}
  ${(padding() !== 'normal' ? `is-padded-${padding()}` : '') ?? ""}
  is-${size() ?? ""}
  is-${color() ?? ""}
  ${(get$2(sided) ? 'is-sided' : '') ?? ""}
  ${(right() ? 'is-sided-right' : '') ?? ""}
  ${(left() ? 'is-sided-left' : '') ?? ""}
  ${(top() ? 'is-sided-top' : '') ?? ""}
  ${(bottom() ? 'is-sided-bottom' : '') ?? ""}
  ${classes() ?? ""}`);

					set_attribute(span, "style", get$2(style));
					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(["keydown", "click"]);

	function Ui_boolean($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_TRUE = "not-node:booleans_true"]
		 * @property {string} [LC_FALSE = "not-node:booleans_false"]
		 * @property {any} value
		 * @property {boolean} [inverted = false]
		 */
		/** @type {Props} */
		let LC_TRUE = prop($$props, "LC_TRUE", 3, "not-node:booleans_true"),
			LC_FALSE = prop($$props, "LC_FALSE", 3, "not-node:booleans_false"),
			inverted = prop($$props, "inverted", 3, false);

		const FALSE_VALUE = {
			title: LC_FALSE(),
			color: inverted() ? "success" : "danger"
		};

		const TRUE_VALUE = {
			title: LC_TRUE(),
			color: inverted() ? "danger" : "success"
		};

		//if inverted === true, inverts value
		let tagValue = derived(() => $$props.value ? TRUE_VALUE : FALSE_VALUE);

		Ui_tag($$anchor, spread_props(() => get$2(tagValue)));
	}

	var root$N = template(`<span class="label"> <!></span>`);

	function Ui_boolean_labeled($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		/**
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {any} label
		 * @property {boolean} [inverted]
		 */
		/** @type {Props} */
		let inverted = prop($$props, "inverted", 3, false);
		var span = root$N();
		var text = child(span);
		var node = sibling(text);

		Ui_boolean(node, {
			get value() {
				return $$props.value;
			},
			get inverted() {
				return inverted();
			}
		});

		reset(span);
		template_effect(() => set_text(text, `${$LOCALE()[$$props.label] ?? ""}: `));
		append($$anchor, span);
		pop();
	}

	function Ui_booleans($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [values]
		 * @property {boolean} [inverted]
		 * @property {any} [componentConstructor]
		 */
		/** @type {Props} */
		let values = prop($$props, "values", 19, () => []),
			inverted = prop($$props, "inverted", 3, false),
			componentConstructor = prop($$props, "componentConstructor", 3, Ui_boolean);

		let _values = state(proxy([]));

		onMount(() => {
			if (typeof values() === "boolean") {
				set(_values, proxy([{ value: values() }]));
			} else if (Array.isArray(values())) {
				if (values().every((itm) => typeof itm === "boolean")) {
					set(_values, proxy(values().map((itm) => {
						return { value: itm };
					})));
				} else {
					set(_values, proxy([...values()]));
				}
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, () => get$2(_values), index$d, ($$anchor, item) => {
					var fragment_2 = comment();
					const SvelteComponent = derived(componentConstructor);
					var node_2 = first_child(fragment_2);
					var inverted_1 = derived(() => inverted() || get$2(item).inverted);

					component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
						$$component($$anchor, spread_props(() => get$2(item), {
							get inverted() {
								return get$2(inverted_1);
							}
						}));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$2(_values).length) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function toggleView(_, hidden) {
		hidden(!hidden());
	}

	async function copyContent(
		__1,
		value,
		tooltip,
		contentCopied,
		tooltipTarget,
		tooltipText,
		tooltipTTL
	) {
		try {
			await navigator.clipboard.writeText(value());

			if (tooltip()) {
				set(contentCopied, true);
				get$2(tooltipTarget).dataset.tooltip = tooltipText();

				setTimeout(
					() => {
						set(contentCopied, false);
						get$2(tooltipTarget).removeAttribute("data-tooltip");
					},
					tooltipTTL()
				);
			}
		} catch(err) {
			console.error("Failed to copy: ", err);
		}
	}

	var root_1$t = template(`<span role="button" tabindex="0"><i></i></span>`);
	var root_2$l = template(`<span class="icon is-small is-right is-clickable is-vertical-middle" role="button" tabindex="0"><i></i></span>`);
	var root$M = template(`<span> </span> <!> <!>`, 1);

	function Ui_censored($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {boolean} [hidden]
		 * @property {boolean} [showable]
		 * @property {boolean} [copiable]
		 * @property {string} [copyIcon]
		 * @property {string} [showIcon]
		 * @property {string} [hideIcon]
		 * @property {number} [maxLength]
		 * @property {string} [shadowClass]
		 * @property {boolean} [tooltip]
		 * @property {number} [tooltipTTL]
		 * @property {string} [tooltipText]
		 * @property {string} [tooltipClass]
		 * @property {string} [value]
		 */
		/** @type {Props} */
		let hidden = prop($$props, "hidden", 15, true),
			showable = prop($$props, "showable", 3, true),
			copiable = prop($$props, "copiable", 3, true),
			copyIcon = prop($$props, "copyIcon", 3, "copy"),
			showIcon = prop($$props, "showIcon", 3, "eye"),
			hideIcon = prop($$props, "hideIcon", 3, "eye-slash"),
			maxLength = prop($$props, "maxLength", 3, 20),
			shadowClass = prop($$props, "shadowClass", 3, "has-background-primary-90"),
			tooltip = prop($$props, "tooltip", 3, true),
			tooltipTTL = prop($$props, "tooltipTTL", 3, 2000),
			tooltipText = prop($$props, "tooltipText", 3, "Скопировано в буфер"),
			tooltipClass = prop($$props, "tooltipClass", 3, "has-tooltip-info"),
			value = prop($$props, "value", 3, "");

		let contentCopied = state(false),
			tooltipActive = derived(() => tooltip() && get$2(contentCopied)),
			tooltipTarget = state(undefined);

		var fragment = root$M();
		var span = first_child(fragment);
		var text = child(span, true);

		reset(span);

		var node = sibling(span, 2);

		{
			var consequent = ($$anchor) => {
				var span_1 = root_1$t();

				span_1.__click = [
					copyContent,
					value,
					tooltip,
					contentCopied,
					tooltipTarget,
					tooltipText,
					tooltipTTL
				];

				span_1.__keydown = [
					copyContent,
					value,
					tooltip,
					contentCopied,
					tooltipTarget,
					tooltipText,
					tooltipTTL
				];

				var i = child(span_1);

				reset(span_1);
				bind_this(span_1, ($$value) => set(tooltipTarget, $$value), () => get$2(tooltipTarget));

				template_effect(() => {
					set_class(span_1, "icon is-small is-right is-clickable " + (get$2(tooltipActive) ? ` ${tooltipClass()} ` : "") + " is-vertical-middle");
					set_class(i, `fas fa-${copyIcon() ?? ""}`);
				});

				append($$anchor, span_1);
			};

			if_block(node, ($$render) => {
				if (copiable()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var span_2 = root_2$l();

				span_2.__click = [toggleView, hidden];
				span_2.__keydown = [toggleView, hidden];

				var i_1 = child(span_2);

				reset(span_2);
				template_effect(() => set_class(i_1, `fas fa-${(hidden() ? showIcon() : hideIcon()) ?? ""}`));
				append($$anchor, span_2);
			};

			if_block(node_1, ($$render) => {
				if (showable()) $$render(consequent_1);
			});
		}

		template_effect(() => {
			set_class(span, (hidden() ? "is-censored " + shadowClass() : "") + " is-vertical-middle ");
			set_attribute(span, "style", `display:inline-block; width: ${maxLength()}rem; height: var(--bulma-size-medium); overflow-x:hidden;`);
			set_text(text, hidden() ? "" : value());
		});

		append($$anchor, fragment);
	}

	delegate(["click", "keydown"]);

	var root$L = template(`<span> </span>`);

	function Ui_indicator($$anchor, $$props) {
		push($$props, true);

		let sided = state(false);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id] - if we want to address this indicator
		 * @property {string} [state]
		 * @property {string} [size]
		 * @property {any} [labels]
		 * @property {string} [class]
		 * @property {string} [padding]
		 * @property {boolean} [bold]
		 * @property {boolean} [right]
		 * @property {boolean} [left]
		 * @property {boolean} [top]
		 * @property {boolean} [bottom]
		 * @property {any} [events]
		 * @property {any} [register] - register event handlers
		 * @property {any} [onUpdate]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, "tagId"),
			currentState = prop($$props, "state", 15, "light"),
			size = prop($$props, "size", 3, "normal"),
			labels = prop($$props, "labels", 19, () => ({
				black: "black",
				dark: "dark",
				light: "light",
				white: "white",
				primary: "primary",
				link: "link",
				info: "info",
				success: "success",
				warning: "warning",
				danger: "danger"
			})),
			classes = prop($$props, "class", 3, "mx-1"),
			padding = prop($$props, "padding", 3, "normal"),
			bold = prop($$props, "bold", 3, false),
			right = prop($$props, "right", 3, false),
			left = prop($$props, "left", 3, false),
			top = prop($$props, "top", 3, false),
			bottom = prop($$props, "bottom", 3, false),
			events = prop($$props, "events", 31, () => proxy({})),
			register = prop($$props, "register", 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, "onUpdate", 3, (data) => {
				if (Object.hasOwn(data, "state")) {
					currentState(data.state);
				}
			});

		function getStandartUpdateEventName() {
			return `indicator-${id()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		user_effect(() => {
			set(sided, proxy(right() || left() || top() || bottom()));
		});

		var span = root$L();
		var text = child(span, true);

		reset(span);

		template_effect(() => {
			set_class(span, `tag
is-${size() ?? ""}
${(bold() ? 'has-text-weight-bold' : '') ?? ""}
${(padding() !== 'normal' ? `is-padded-${padding()}` : '') ?? ""}
${(get$2(sided) ? 'is-sided' : '') ?? ""}
${(right() ? 'is-sided-right' : '') ?? ""}
${(left() ? 'is-sided-left' : '') ?? ""}
${(top() ? 'is-sided-top' : '') ?? ""}
${(bottom() ? 'is-sided-bottom' : '') ?? ""}
  is-${currentState() ?? ""} ${classes() ?? ""}
  `);

			set_text(text, labels()[currentState()]);
		});

		append($$anchor, span);
		pop();
	}

	var root_1$s = template(`<div><span class="title"> </span></div>`);

	function Ui_loader($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		//hidden - no loader
		//container - parent container of form
		/**
		 * @typedef {Object} Props
		 * @property {boolean} [loading] - state if form loading
		 * @property {string} [size] - page - whole page
		 * @property {string} [title]
		 */
		/** @type {Props} */
		let loading = prop($$props, "loading", 3, false),
			size = prop($$props, "size", 3, "container"),
			title = prop($$props, "title", 3, "Waiting...");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$s();
				var span = child(div);
				var text = child(span, true);

				reset(span);
				reset(div);

				template_effect(() => {
					set_class(div, `${(size() === 'page' ? 'pageloader' : 'containerloader') ?? ""} ${(loading() ? 'is-active' : '') ?? ""}`);
					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (size() !== "hidden") $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$K = template(`<option> </option>`);

	function Ui_select_option($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		var option = root$K();
		var option_value = {};
		var text = child(option, true);

		reset(option);

		template_effect(() => {
			if (option_value !== (option_value = $$props.value)) {
				option.value = null == (option.__value = $$props.value) ? "" : $$props.value;
			}

			set_selected(option, $$props.selected);
			set_text(text, $LOCALE()[$$props.title]);
		});

		append($$anchor, option);
		pop();
	}

	var root_3$g = template(`<span class="mr-2"> </span>`);
	var root_4$f = template(`<span class="mr-2"> </span>`);
	var root_5$9 = template(`<div><select><!><!></select></div>`);

	function Ui_select($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [value]
		 * @property {any}      [variants]
		 * @property {string} [placeholder]
		 * @property {string} [emptyValueTitle]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 15, ""),
			variants = prop($$props, "variants", 19, () => []),
			placeholder = prop($$props, "placeholder", 3, ""),
			emptyValueTitle = prop($$props, "emptyValueTitle", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "select"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			multiple = prop($$props, "multiple", 3, false),
			size = prop($$props, "size", 3, 8),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"variants",
				"placeholder",
				"emptyValueTitle",
				"fieldname",
				"required",
				"readonly",
				"multiple",
				"size",
				"valid",
				"class",
				"onchange"
			]);

		let selectedVariants = state(proxy([]));

		function filterSelectedVariants(variant) {
			if (Array.isArray(value()) && multiple()) {
				return value().indexOf(variant.id) > -1;
			} else if (value()) {
				return value() == variant.id;
			} else {
				return false;
			}
		}

		let lastChange;

		function onBlur(ev) {
			let data = {
				field: fieldname(),
				value: ev.currentTarget.value
			};

			if (lastChange === data.value) {
				return true;
			} else {
				if (Array.isArray(data.value) && notCommon$1.compareTwoArrays(lastChange, data.value)) {
					return true;
				}
			}

			if (multiple()) {
				value(Array.from(ev.target.selectedOptions).map((el) => el.value));

				if (value().indexOf(UICommon$1.CLEAR_MACRO) > -1) {
					value([]);
				}

				data.value = value();
			} else {
				if (data.value === UICommon$1.CLEAR_MACRO) {
					value("");
				} else {
					value(data.value);
				}
			}

			onchange()(data);
			return true;
		}

		function onInput(ev) {
			let data = {
				field: fieldname(),
				value: ev.currentTarget.value
			};

			if (multiple()) {
				value(Array.from(ev.target.selectedOptions).map((el) => el.value));

				if (value().indexOf(UICommon$1.CLEAR_MACRO) > -1) {
					value([]);
				}

				data.value = value();
			} else {
				if (data.value === UICommon$1.CLEAR_MACRO) {
					value("");
				} else {
					value(data.value);
				}
			}

			lastChange = data.value;
			onchange()(data);
			return true;
		}

		let multipleClass = derived(() => multiple() ? " is-multiple " : "");

		user_effect(() => {
			value();
			set(selectedVariants, proxy(Array.isArray(variants()) ? variants().filter(filterSelectedVariants) : []));
		});

		let invalid = derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$2(selectedVariants), index$d, ($$anchor, selectedVariant) => {
							var span = root_3$g();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$2(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var span_1 = root_4$f();
						var text_1 = child(span_1, true);

						reset(span_1);
						template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
						append($$anchor, span_1);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_3 = ($$anchor) => {
				var div = root_5$9();
				var select = child(div);
				let attributes;

				init_select(select, () => attributes.value);

				var node_3 = child(select);

				{
					var consequent_3 = ($$anchor) => {
						var fragment_3 = comment();
						var node_4 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								Ui_select_option($$anchor, {
									get value() {
										return UICommon$1.CLEAR_MACRO;
									},
									get title() {
										return placeholder();
									}
								});
							};

							var alternate_1 = ($$anchor) => {
								Ui_select_option($$anchor, {
									get value() {
										return UICommon$1.CLEAR_MACRO;
									},
									selected: "selected",
									get title() {
										return placeholder();
									}
								});
							};

							if_block(node_4, ($$render) => {
								if (value()) $$render(consequent_2); else $$render(alternate_1, false);
							});
						}

						append($$anchor, fragment_3);
					};

					if_block(node_3, ($$render) => {
						if (placeholder().length > 0) $$render(consequent_3);
					});
				}

				var node_5 = sibling(node_3);

				each(node_5, 17, variants, index$d, ($$anchor, variant) => {
					var fragment_6 = comment();
					var node_6 = first_child(fragment_6);

					{
						var consequent_4 = ($$anchor) => {
							var selected = derived(() => value() && value().indexOf(get$2(variant).id) > -1);

							Ui_select_option($$anchor, {
								get value() {
									return get$2(variant).id;
								},
								get selected() {
									return get$2(selected);
								},
								get title() {
									return get$2(variant).title;
								}
							});
						};

						var alternate_2 = ($$anchor) => {
							var selected_1 = derived(() => value() == get$2(variant).id);

							Ui_select_option($$anchor, {
								get value() {
									return get$2(variant).id;
								},
								get selected() {
									return get$2(selected_1);
								},
								get title() {
									return get$2(variant).title;
								}
							});
						};

						if_block(node_6, ($$render) => {
							if (multiple()) $$render(consequent_4); else $$render(alternate_2, false);
						});
					}

					append($$anchor, fragment_6);
				});

				reset(select);
				reset(div);

				template_effect(() => {
					set_class(div, `select ${classes() ?? ""} ${get$2(multipleClass) ?? ""}`);

					attributes = set_attributes(select, attributes, {
						id: `form-field-select-${fieldname() ?? ""}`,
						name: fieldname(),
						onblur: onBlur,
						oninput: onInput,
						readonly: readonly(),
						required: required(),
						multiple: multiple(),
						invalid: get$2(invalid),
						size: multiple() ? size() : false,
						...others
					});

					if ("value" in attributes) {
						select_option(select, attributes.value);
					}
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_1); else $$render(alternate_3, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function onClick$7(event, onclick, $$props, action) {
		event.stopPropagation();
		onclick() && onclick()({ event, value: $$props.value });
		return action() && action()(event, $$props.value);
	}

	var root_4$e = template(`<span class="icon"><i></i></span>`);
	var root_5$8 = template(`<span> </span>`);
	var root_6$b = template(`<span class="icon"><i></i></span>`);
	var root_3$f = template(`<!> <!> <!>`, 1);
	var root$J = template(`<button><!></button>`);

	function Ui_button($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [action]
		 * @property {function} [onclick]
		 * @property {any} value
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, "title", 3, ""),
			light = prop($$props, "light", 3, false),
			loading = prop($$props, "loading", 3, false),
			raised = prop($$props, "raised", 3, false),
			outlined = prop($$props, "outlined", 3, false),
			inverted = prop($$props, "inverted", 3, false),
			rounded = prop($$props, "rounded", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			state = prop($$props, "state", 3, ""),
			type = prop($$props, "type", 3, ""),
			color = prop($$props, "color", 3, ""),
			size = prop($$props, "size", 3, ""),
			style = prop($$props, "style", 3, ""),
			classes = prop($$props, "class", 3, ""),
			icon = prop($$props, "icon", 3, false),
			iconSide = prop($$props, "iconSide", 3, "right"),
			onclick = prop($$props, "onclick", 3, () => {
				return true;
			}),
			action = prop($$props, "action", 3, () => {
				return true;
			});

		var button = root$J();

		button.__click = [onClick$7, onclick, $$props, action];

		var node = child(button);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_4 = ($$anchor) => {
						var fragment_2 = root_3$f();
						var node_3 = first_child(fragment_2);

						{
							var consequent_1 = ($$anchor) => {
								var span = root_4$e();
								var i = child(span);

								reset(span);
								template_effect(() => set_class(i, `fas fa-${icon() ?? ""} ${(size() ? `is-${size()}` : '') ?? ""}`));
								append($$anchor, span);
							};

							if_block(node_3, ($$render) => {
								if (iconSide() === "left") $$render(consequent_1);
							});
						}

						var node_4 = sibling(node_3, 2);

						{
							var consequent_2 = ($$anchor) => {
								var span_1 = root_5$8();
								var text = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text, $LOCALE()[title()]));
								append($$anchor, span_1);
							};

							if_block(node_4, ($$render) => {
								if (title()) $$render(consequent_2);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_3 = ($$anchor) => {
								var span_2 = root_6$b();
								var i_1 = child(span_2);

								reset(span_2);
								template_effect(() => set_class(i_1, `fas fa-${icon() ?? ""} ${(size() ? `is-${size()}` : '') ?? ""}`));
								append($$anchor, span_2);
							};

							if_block(node_5, ($$render) => {
								if (iconSide() === "right") $$render(consequent_3);
							});
						}

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[title()]));
						append($$anchor, text_1);
					};

					if_block(
						node_2,
						($$render) => {
							if (icon()) $$render(consequent_4); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		reset(button);

		template_effect(() => {
			button.disabled = disabled();
			set_attribute(button, "type", type() ? type() : "");
			set_attribute(button, "style", style());

			set_class(button, `
  button
  ${classes() ?? ""}
  ${(state() ? `is-${state()}` : '') ?? ""}
  ${(inverted() ? `is-inverted` : '') ?? ""}
  ${(outlined() ? `is-outlined` : '') ?? ""}
  ${(raised() ? `is-raised` : '') ?? ""}
  ${(rounded() ? `is-rounded` : '') ?? ""}
  ${(light() ? `is-light` : '') ?? ""}
  ${(loading() ? `is-loading` : '') ?? ""}
  ${(color() ? `is-${color()}` : '') ?? ""}
  ${(size() ? `is-${size()}` : '') ?? ""}
  `);
		});

		append($$anchor, button);
		pop();
	}

	delegate(["click"]);

	function onClick$6(event, onclick, $$props) {
		event.stopPropagation();
		onclick() && onclick()({ event, value: $$props.value });
	}

	var root$I = template(`<button></button>`);

	function Ui_button_close($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [ariaLabel = "delete button"]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {function} [onclick]
		 * @property {any} value
		 */
		/** @type {Props} */
		let ariaLabel = prop($$props, "ariaLabel", 3, "delete button");
			prop($$props, "light", 3, false);
			prop($$props, "loading", 3, false);
			prop($$props, "raised", 3, false);
			prop($$props, "outlined", 3, false);
			prop($$props, "inverted", 3, false);
			prop($$props, "rounded", 3, false);
			let disabled = prop($$props, "disabled", 3, false);
			prop($$props, "state", 3, "");
			prop($$props, "color", 3, "");
			let size = prop($$props, "size", 3, ""),
			style = prop($$props, "style", 3, ""),
			classes = prop($$props, "class", 3, ""),
			onclick = prop($$props, "onclick", 3, () => {
				return true;
			});

		var button = root$I();

		button.__click = [onClick$6, onclick, $$props];

		template_effect(() => {
			set_attribute(button, "aria-label", ariaLabel());
			button.disabled = disabled();
			set_attribute(button, "style", style());

			set_class(button, `
  delete
  ${classes() ?? ""}  
  ${(size() ? `is-${size()}` : '') ?? ""}
  `);
		});

		append($$anchor, button);
		pop();
	}

	delegate(["click"]);

	var root$H = template(`<div></div>`);

	function Ui_buttons($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {Array<object>} [values = []]
		 * @property {boolean} [centered = false]
		 * @property {boolean} [right = false]
		 * @property {string} [class = '']
		 * @property {import('svelte').Component} [buttonComponent = UIButton]
		 * @property {import('../events.types').UIEventInputChangeCallback} [action = ()=>true]
		 * @property {import('../events.types').UIEventCallback} [onclick = ()=>true]
		 */
		/** @type {Props} */
		let values = prop($$props, "values", 19, () => []),
			centered = prop($$props, "centered", 3, false),
			right = prop($$props, "right", 3, false),
			classes = prop($$props, "class", 3, ""),
			SvelteComponent = prop($$props, "buttonComponent", 3, Ui_button),
			action = prop($$props, "action", 3, () => {
				return true;
			}),
			onclick = prop($$props, "onclick", 3, () => {
				return true;
			});

		let _values = state(proxy([]));

		user_effect(() => {
			set(_values, proxy(values().map((itm) => {
				if (isNaN(itm.id)) {
					itm.id = Math.round(Math.random() * 100);
				}

				return itm;
			})));
		});

		var div = root$H();

		each(div, 21, () => get$2(_values), (item) => item.id, ($$anchor, item, $$index) => {
			var fragment = comment();
			var node = first_child(fragment);

			component(node, SvelteComponent, ($$anchor, $$component) => {
				$$component($$anchor, spread_props(
					{
						get action() {
							return action();
						},
						get onclick() {
							return onclick();
						}
					},
					() => get$2(item),
					{
						get value() {
							return get$2(item).value;
						},
						set value($$value) {
							(get$2(item).value = $$value);
						}
					}
				));
			});

			append($$anchor, fragment);
		});

		reset(div);
		template_effect(() => set_class(div, `buttons has-addons ${(centered() ? 'is-centered' : '') ?? ""} ${(right() ? 'is-right' : '') ?? ""} ${classes() ?? ""}`));
		append($$anchor, div);
		pop();
	}

	var root$G = template(`<div><div class="column"><!></div> <div class="column"><!></div> <div class="column"><!></div></div>`);

	function Ui_buttons_row($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {any} [left]
		 * @property {any} [center]
		 * @property {any} [right]
		 */
		/** @type {Props} */
		let classes = prop($$props, "class", 3, ""),
			left = prop($$props, "left", 19, () => []),
			center = prop($$props, "center", 19, () => []),
			right = prop($$props, "right", 19, () => []);

		var div = root$G();
		var div_1 = child(div);
		var node = child(div_1);

		Ui_buttons(node, {
			get values() {
				return left();
			}
		});

		reset(div_1);

		var div_2 = sibling(div_1, 2);
		var node_1 = child(div_2);

		Ui_buttons(node_1, {
			get values() {
				return center();
			},
			centered: true
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);
		var node_2 = child(div_3);

		Ui_buttons(node_2, {
			get values() {
				return right();
			},
			right: true
		});

		reset(div_3);
		reset(div);
		template_effect(() => set_class(div, `columns ${classes() ?? ""}`));
		append($$anchor, div);
	}

	function Ui_button_switch($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [uiOff]
		 * @property {function} [uiOn]
		 * @property {function} [action]
		 * @property {any} value
		 * @property {boolean} [selected]
		 */
		/** @type {Props} */
		let title = prop($$props, "title", 3, ""),
			light = prop($$props, "light", 3, false),
			loading = prop($$props, "loading", 3, false),
			raised = prop($$props, "raised", 3, false),
			outlined = prop($$props, "outlined", 3, false),
			inverted = prop($$props, "inverted", 3, false),
			rounded = prop($$props, "rounded", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			activeState = prop($$props, "state", 3, ""),
			type = prop($$props, "type", 3, ""),
			color = prop($$props, "color", 3, ""),
			size = prop($$props, "size", 3, ""),
			classes = prop($$props, "class", 3, ""),
			icon = prop($$props, "icon", 3, false),
			iconSide = prop($$props, "iconSide", 3, "right"),
			uiOff = prop($$props, "uiOff", 3, () => {
				return { color: "" };
			}),
			uiOn = prop($$props, "uiOn", 3, () => {
				return { color: "success" };
			}),
			action = prop($$props, "action", 3, () => {
				return !selected();
			}),
			onclick = prop($$props, "onclick", 3, () => {}),
			onchange = prop($$props, "onchange", 3, () => {}),
			selected = prop($$props, "selected", 15, false);

		let childProps = state(proxy({
			title: title(),
			light: light(),
			loading: loading(),
			raised: raised(),
			outlined: outlined(),
			inverted: inverted(),
			rounded: rounded(),
			disabled: disabled(),
			type: type(),
			color: color(),
			size: size(),
			class: classes(),
			icon: icon(),
			iconSide: iconSide(),
			value: $$props.value
		}));

		let uiElement = state(undefined);

		onMount(() => {
			updateUI();
		});

		function onClick(event) {
			selected(action()(event, $$props.value, selected()));
			updateUI();

			onclick()({
				value: $$props.value,
				selected: selected()
			});

			onchange()({
				value: $$props.value,
				selected: selected()
			});
		}

		function updateUI() {
			if (get$2(uiElement)) {
				const propsChanges = selected() ? uiOn()($$props.value, selected()) : uiOff()($$props.value, selected());

				Object.keys(propsChanges).forEach((key) => {
					get$2(childProps)[key] = propsChanges[key];
				});

				set(childProps, proxy(get$2(childProps)));
			}
		}

		user_effect(() => {
			if (typeof selected() !== "undefined") updateUI();
		});

		bind_this(
			Ui_button($$anchor, spread_props(() => get$2(childProps), {
				get state() {
					return activeState();
				},
				onclick: onClick
			})),
			($$value) => set(uiElement, proxy($$value)),
			() => get$2(uiElement)
		);

		return pop({ updateUI });
	}

	var root$F = template(`<div></div>`);

	function Ui_buttons_switchers($$anchor, $$props) {
		push($$props, true);

		const uis = {};

		function updateItemUI(item) {
			uis[item.id].updateUI();
		}

		const defaultAction = (ev, value, selected) => {
			const countOfSelected = countSelected();

			if (countOfSelected === min() && selected) {
				return selected;
			}

			if (countOfSelected === max() && selected !== true) {
				return selected;
			}

			const indexOfCurrent = _values.findIndex((itm) => itm.value === value);
			let newSelected = selected;

			if (indexOfCurrent > -1) {
				newSelected = !newSelected;

				const cnt = countSelected() + (newSelected ? 1 : -1);

				if (min()) {
					if (cnt < min()) {
						selectUpToMin(cnt, indexOfCurrent);
					}
				}

				if (max()) {
					if (max() < cnt) {
						deselectDownToMin(cnt, indexOfCurrent);
					}
				}

				return newSelected;
			}

			return newSelected;
		};

		/**
		 * @typedef {Object} Props
		 * @property {array<object>} [values]
		 * @property {boolean} [centered]
		 * @property {boolean} [right]
		 * @property {string} [class]
		 * @property {import('svelte').Component}      [buttonComponent = UIButtonSwitch]
		 * @property {object}   [buttonProps = {}]
		 * @property {function} [action = (event, value, selected) => boolean]  fires on button switch click, returns new state of selected
		 * @property {function} [onclick]
		 * @property {function} [onchange]
		 * @property {number} [min = 0]
		 * @property {number} [max = 100]
		 */
		/** @type {Props} */
		let values = prop($$props, "values", 23, () => []),
			centered = prop($$props, "centered", 3, false),
			right = prop($$props, "right", 3, false),
			classes = prop($$props, "class", 3, ""),
			buttonComponent = prop($$props, "buttonComponent", 3, Ui_button_switch),
			action = prop($$props, "action", 3, defaultAction),
			onclick = prop($$props, "onclick", 3, () => true),
			onchange = prop($$props, "onchange", 3, () => true),
			min = prop($$props, "min", 3, 0),
			max = prop($$props, "max", 3, 100);
		let _values = proxy(values());

		function onChange() {
			values(snapshot(_values));

			const selected = values().filter((itm) => itm.selected);
			const selectedIds = selected.map((itm) => itm.id);
			const selectedCount = selectedIds.length;

			onchange() && onchange()({
				values: values(),
				selected,
				selectedIds,
				selectedCount
			});
		}

		function selectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = true;
				updateItemUI(itm);
			});

			onChange();
		}

		function deselectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = false;
				updateItemUI(itm);
			});

			onChange();
		}

		onMount(() => {
			const selectedCount = countSelected();

			if (min() && selectedCount < min()) {
				selectUpToMin(selectedCount, -1);
			}
		});

		function addToHistory(id) {
		}

		function countSelected() {
			const countOfSelected = _values.filter((btn) => {
				return btn.selected;
			}).length;

			return countOfSelected;
		}

		function toggleFirstSuited(toValue) {
			const index = _values.findIndex((itm) => !toValue == itm.selected);

			if (index > -1) {
				_values[index].selected = toValue;
				updateItemUI(_values[index]);
			}
		}

		function selectUpToMin(cnt, indexOfCurrent) {
			let delta = min() - cnt;

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (!_values[t].selected) {
					_values[t].selected = true;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function deselectDownToMin(cnt, indexOfCurrent) {
			let delta = cnt - max();

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (_values[t].selected) {
					_values[t].selected = false;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function updateUI() {
			Object.keys(uis).forEach((itemId) => {
				if (uis[itemId]) {
					uis[itemId].updateUI && uis[itemId].updateUI();
				}
			});
		}

		var div = root$F();

		each(div, 23, () => _values, (item) => item.id, ($$anchor, item, index) => {
			var fragment = comment();
			const SvelteComponent = derived(buttonComponent);
			var node = first_child(fragment);

			component(node, () => get$2(SvelteComponent), ($$anchor, $$component) => {
				bind_this(
					$$component($$anchor, spread_props(
						{
							get action() {
								return action();
							}
						},
						() => get$2(item),
						buttonProps,
						{
							get onclick() {
								return onclick();
							},
							onchange: onChange,
							get selected() {
								return _values[get$2(index)].selected;
							},
							set selected($$value) {
								_values[get$2(index)].selected = $$value;
							}
						}
					)),
					($$value, item) => uis[item.id] = $$value,
					(item) => uis?.[item.id],
					() => [get$2(item)]
				);
			});

			append($$anchor, fragment);
		});

		reset(div);
		template_effect(() => set_class(div, `buttons has-addons ${(centered() ? 'is-centered' : '') ?? ""} ${(right() ? 'is-right' : '') ?? ""} ${classes() ?? ""}`));
		append($$anchor, div);

		return pop({
			selectAll,
			deselectAll,
			addToHistory,
			countSelected,
			toggleFirstSuited,
			selectUpToMin,
			deselectDownToMin,
			updateUI
		});
	}

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIButton: Ui_button,
		UIButtonClose: Ui_button_close,
		UIButtonSwitch: Ui_button_switch,
		UIButtons: Ui_buttons,
		UIButtonsRow: Ui_buttons_row,
		UIButtonsSwitchers: Ui_buttons_switchers
	});

	const DEFAULT_STATUS_SUCCESS = "ok";
	const NAVIGATION_DELAY_SHORT = 500;
	const NAVIGATION_DELAY_NORMAL = 1500;
	const NAVIGATION_DELAY_LONG = 5000;
	const NAVIGATION_DELAYS = {
	  SHORT: NAVIGATION_DELAY_SHORT,
	  NORMAL: NAVIGATION_DELAY_NORMAL,
	  LONG: NAVIGATION_DELAY_LONG
	};
	const NAVIGATION_DELAY_DEFAULT = NAVIGATION_DELAY_NORMAL;

	var root_3$e = template(`<div class="field has-addons"><!></div> <div class="control"><!></div>`, 1);

	function Ui_select_from_model_on_demand_inline($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted]
		 * @property {any} value
		 * @property {any} [variants]
		 * @property {string} [placeholder]
		 * @property {string} [fieldname]
		 * @property {string} [modelName]
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId]
		 * @property {string} [optionTitle]
		 * @property {boolean} [icon]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 */
		/** @type {Props} */
		let variants = prop($$props, "variants", 31, () => proxy([])),
			placeholder = prop($$props, "placeholder", 3, "empty select item"),
			fieldname = prop($$props, "fieldname", 3, "selectFromModel"),
			modelName = prop($$props, "modelName", 3, ""),
			actionName = prop($$props, "actionName", 3, ""),
			actionFilter = prop($$props, "actionFilter", 19, () => ({})),
			actionSorter = prop($$props, "actionSorter", 19, () => ({})),
			actionPager = prop($$props, "actionPager", 19, () => ({})),
			actionSearch = prop($$props, "actionSearch", 3, undefined),
			optionId = prop($$props, "optionId", 3, ":_id"),
			optionTitle = prop($$props, "optionTitle", 3, ":title"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			multiple = prop($$props, "multiple", 3, false),
			size = prop($$props, "size", 3, 8),
			valid = prop($$props, "valid", 3, true),
			onreject = prop($$props, "onreject", 3, () => false),
			onresolve = prop($$props, "onresolve", 3, () => true),
			onerror = prop($$props, "onerror", 3, () => true);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let loaded = false;
		let disabled = derived(() => !loaded);
		let state$1 = state("hidden");
		let resultsList = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$1.getApp();
				const Model = notApp.getModel(modelName()).setFilter(actionFilter()).setSorter(actionSorter()).setPager(actionPager()).setSearch(actionSearch());
				const response = await Model[`$` + actionName()]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					resultsList = response.result;

					variants(resultsList.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					}));
				} else {
					onerror()(response.errors || [response.message]);
				}
			}
		});

		let resolvedValue;

		function onModelChanged({ value: selectedValue }) {
			resolvedValue = resultsList.find((item) => notPath.get(optionId(), item) === selectedValue);
		}

		const ACTIONS = {
			add: {
				color: "primary",
				icon: "plus",
				action() {
					set(state$1, "show");
				}
			},
			resolve: {
				icon: "check",
				color: "primary",
				action() {
					set(state$1, "hidden");
					onresolve()(resolvedValue);
				}
			},
			reject: {
				icon: "close",
				color: "danger",
				action() {
					set(state$1, "hidden");
					onreject()();
				}
			}
		};

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_button($$anchor, spread_props(() => ACTIONS.add));
			};

			var alternate = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = root_3$e();
						var div = first_child(fragment_3);
						var node_2 = child(div);

						Ui_select(node_2, {
							get value() {
								return $$props.value;
							},
							get variants() {
								return variants();
							},
							get placeholder() {
								return placeholder();
							},
							get fieldname() {
								return fieldname();
							},
							get required() {
								return required();
							},
							get readonly() {
								return readonly();
							},
							get disabled() {
								return get$2(disabled);
							},
							get multiple() {
								return multiple();
							},
							get size() {
								return size();
							},
							get valid() {
								return valid();
							},
							onchange: onModelChanged
						});

						reset(div);

						var div_1 = sibling(div, 2);
						var node_3 = child(div_1);
						var values = derived(() => [ACTIONS.resolve, ACTIONS.reject]);

						Ui_buttons(node_3, {
							get values() {
								return get$2(values);
							}
						});

						reset(div_1);
						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (get$2(state$1) == "show") $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (get$2(state$1) === "hidden") $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$E = template(`<div class="control"><!></div>`);

	function Ui_select_from_model_with_search_modal($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {boolean} [inputStarted]
		 * @property {boolean} [icon]
		 * @property {string} [fieldname]
		 * @property {boolean} [readonly]
		 * @property {string} [serviceName] - Set this, as ns[ModelName], should be registered in notApp
		 * @property {string} [serviceOpenSelectorMethod] - Set this
		 * @property {string} [serviceLoadDataMethod] - Set this
		 * @property {any} [modelData]
		 * @property {boolean} [loading]
		 * @property {any} [selectedModelTitleFormatter]
		 * @property {string} [loadingLabel]
		 * @property {string} [isEmptyLabel]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 15),
			icon = prop($$props, "icon", 3, false),
			fieldname = prop($$props, "fieldname", 3, ""),
			readonly = prop($$props, "readonly", 3, false),
			serviceName = prop($$props, "serviceName", 3, ""),
			serviceOpenSelectorMethod = prop($$props, "serviceOpenSelectorMethod", 3, "openSelector"),
			serviceLoadDataMethod = prop($$props, "serviceLoadDataMethod", 3, "loadData"),
			modelData = prop($$props, "modelData", 15, null),
			loading = prop($$props, "loading", 15, false),
			selectedModelTitleFormatter = prop($$props, "selectedModelTitleFormatter", 3, (data) => `${data._id}`),
			loadingLabel = prop($$props, "loadingLabel", 3, "not-node:loading_label"),
			isEmptyLabel = prop($$props, "isEmptyLabel", 3, "not-node:field_value_is_empty_placeholder"),
			onchange = prop($$props, "onchange", 3, () => true);

		function getService() {
			if (!serviceName()) throw new Error("serviceName is not set");
			return notCommon$1.getApp().getService(serviceName());
		}

		function openModelSearchAndSelect() {
			if (!serviceOpenSelectorMethod()) {
				throw new Error("serviceOpenSelectorMethod is not set");
			}

			const service = getService();

			service[serviceOpenSelectorMethod()]().then((results) => {
				value(results._id);
				modelData(results);
				return value();
			}).then((value) => {
				onchange()({ field: fieldname(), value });
			}).catch((e) => {
				notCommon$1.report(e);
			});
		}

		function resetSelectedModel() {
			value(undefined);
			modelData(null);
			onchange()({ field: fieldname(), value: value() });
		}

		async function loadModelData() {
			try {
				if (value()) {
					loading(true);
					modelData(await getService()[serviceLoadDataMethod()](value()));
				}
			} catch(e) {
				notCommon$1.report(e);
			} finally {
				loading(false);
			}
		}

		onMount(() => {
			loadModelData();
		});

		const AVAILABLE_BUTTONS = [
			{
				id: 1,
				action: openModelSearchAndSelect,
				icon: icon(),
				color: "warning"
			},
			{
				id: 2,
				action: resetSelectedModel,
				icon: "times",
				color: "danger"
			}
		];

		function getModelButton() {
			if (loading()) {
				return {
					disabled: true,
					loading: loading(),
					title: loadingLabel()
				};
			} else {
				if (modelData()) {
					return {
						disabled: readonly(),
						action: openModelSearchAndSelect,
						title: selectedModelTitleFormatter()(modelData())
					};
				} else {
					return { disabled: true, title: isEmptyLabel() };
				}
			}
		}

		let VISIBLE_BUTTONS = state(proxy([]));

		run(() => {
			if (value()) {
				set(VISIBLE_BUTTONS, proxy([
					getModelButton(),
					...readonly() ? [] : AVAILABLE_BUTTONS
				]));
			} else {
				set(VISIBLE_BUTTONS, proxy([
					getModelButton(),
					...readonly() ? [] : [AVAILABLE_BUTTONS[0]]
				]));
			}
		});

		var div = root$E();
		var node = child(div);

		Ui_buttons(node, {
			get values() {
				return get$2(VISIBLE_BUTTONS);
			},
			classes: "is-no-flex-wrap"
		});

		reset(div);
		append($$anchor, div);
		pop();
	}

	var root$D = template(`<progress> </progress>`);

	function Ui_progress($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {number} [max]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 */
		/** @type {Props} */
		let max = prop($$props, "max", 3, 100),
			color = prop($$props, "color", 3, ""),
			size = prop($$props, "size", 3, ""),
			classes = prop($$props, "class", 3, "");

		var progress = root$D();
		var text = child(progress);

		reset(progress);

		template_effect(() => {
			set_class(progress, `
  progress
  ${classes() ?? ""}
  ${(color() ? `is-${color()}` : '') ?? ""}
  ${(size() ? `is-${size()}` : '') ?? ""}`);

			set_value(progress, $$props.value);
			set_attribute(progress, "max", max());
			set_text(text, `${$$props.value ?? ""}%`);
		});

		append($$anchor, progress);
	}

	function Ui_show_one_from_list($$anchor, $$props) {
		push($$props, true);

		const defaultFilter = (value) => value[idFieldName()] === $$props.id;

		/**
		 * @typedef {Object} Props
		 * @property {any} [values]
		 * @property {any} id
		 * @property {any} UIComponent
		 * @property {any} UIPlaceholder
		 * @property {any} active
		 * @property {string} [idFieldName]
		 * @property {any} [filter]
		 */
		/** @type {Props} */
		let values = prop($$props, "values", 19, () => []),
			active = prop($$props, "active", 15),
			idFieldName = prop($$props, "idFieldName", 3, "_id"),
			filter = prop($$props, "filter", 3, defaultFilter);

		user_effect(() => {
			active(Array.isArray(values()) && values().length && typeof $$props.id !== "undefined" ? values().find(filter() || defaultFilter) : undefined);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				component(node_1, () => $$props.UIComponent, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(active));
				});

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_2 = comment();
				var node_2 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						component(node_3, () => $$props.UIPlaceholder, ($$anchor, $$component) => {
							$$component($$anchor, {});
						});

						append($$anchor, fragment_3);
					};

					if_block(
						node_2,
						($$render) => {
							if ($$props.UIPlaceholder) $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (active()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$C = template(`<div><!> <!> <!></div>`);

	function Ui_tag_value($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id] - if we want to address this tag
		 * @property {any} title
		 * @property {any} value
		 * @property {any} [actions]
		 * @property {string} [class]
		 * @property {any} [actionsGroupContructor]
		 * @property {any} [actionsGroupProps]
		 * @property {boolean} [readonly]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, "taggedValueId"),
			actions = prop($$props, "actions", 19, () => []),
			classes = prop($$props, "class", 3, ""),
			actionsGroupContructor = prop($$props, "actionsGroupContructor", 3, Ui_buttons),
			actionsGroupProps = prop($$props, "actionsGroupProps", 19, () => ({})),
			readonly = prop($$props, "readonly", 3, false);

		var div = root$C();
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.title));
			};

			if_block(node, ($$render) => {
				if ($$props.title) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.value));
			};

			if_block(node_1, ($$render) => {
				if ($$props.value) $$render(consequent_1);
			});
		}

		var node_2 = sibling(node_1, 2);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_2 = comment();
				const SvelteComponent = derived(actionsGroupContructor);
				var node_3 = first_child(fragment_2);

				component(node_3, () => get$2(SvelteComponent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(
						{
							get values() {
								return actions();
							}
						},
						actionsGroupProps
					));
				});

				append($$anchor, fragment_2);
			};

			if_block(node_2, ($$render) => {
				if (!readonly() && actions() && actions().length) $$render(consequent_2);
			});
		}

		reset(div);

		template_effect(() => {
			set_class(div, `tags has-addons ${classes() ?? ""}`);
			set_attribute(div, "id", id());
		});

		append($$anchor, div);
		pop();
	}

	var root$B = template(`<!> <!>`, 1);

	function Ui_title($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {any} [id]
		 * @property {string} [title]
		 * @property {any} subtitle
		 * @property {number} [size]
		 * @property {any} subsize
		 * @property {boolean} [spaced]
		 * @property {string} [align]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 19, () => `title-${Math.random()}`),
			title = prop($$props, "title", 3, ""),
			size = prop($$props, "size", 3, 1),
			spaced = prop($$props, "spaced", 3, false),
			align = prop($$props, "align", 3, "left");

		const scrollToTop = (options = UICommon$1.SCROLL_OPTIONS) => {
			setTimeout(
				() => {
					document.getElementById(id()).scrollIntoView(options);
				},
				100
			);
		};

		let size2 = derived(() => $$props.subsize ? $$props.subsize : parseInt(size()) < 6 ? parseInt(size()) + 1 : size());
		let spacedStyle = derived(() => spaced() ? "is-spaced" : "");
		let resultTitle = derived(() => `<h${size()} id="${id()}" style="text-align: ${align()};" class="title ${get$2(spacedStyle)} is-${size()}">${$LOCALE()[title()]}</h${size()}>`);
		let resultSubtitle = derived(() => `<h${get$2(size2)} id="${id()}" style="text-align: ${align()};" class="subtitle is-${get$2(size2)}">${$LOCALE()[$$props.subtitle]}</h${get$2(size2)}>`);
		var fragment = root$B();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				html(node_1, () => get$2(resultTitle));
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_3 = first_child(fragment_2);

				html(node_3, () => get$2(resultSubtitle));
				append($$anchor, fragment_2);
			};

			if_block(node_2, ($$render) => {
				if ($$props.subtitle) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		return pop({ scrollToTop });
	}

	var root_3$d = template(`<span> </span> `, 1);
	var root_1$r = template(`<p><!></p>`);

	function Ui_errors_list($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {array<string>}  [errors = []]
		 * @property {boolean} [show = false]
		 * @property {string} [class = '']
		 * @property {string} [id = 'errors-list']
		 */
		/** @type {Props} */
		let errors = prop($$props, "errors", 19, () => []),
			show = prop($$props, "show", 3, false),
			classes = prop($$props, "class", 3, ""),
			id = prop($$props, "id", 3, "errors-list");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var p = root_1$r();
				var node_1 = child(p);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 17, errors, index$d, ($$anchor, error, index) => {
							var fragment_2 = root_3$d();
							var span = first_child(fragment_2);
							var text = child(span, true);

							reset(span);

							var text_1 = sibling(span, 1, true);

							template_effect(() => {
								set_text(text, $LOCALE()[get$2(error)]);
								set_text(text_1, index < errors().length - 1 ? ", " : "");
							});

							append($$anchor, fragment_2);
						});

						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var text_2 = text(" ");

						append($$anchor, text_2);
					};

					if_block(node_1, ($$render) => {
						if (show()) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(p);

				template_effect(() => {
					set_class(p, `help ${classes() ?? ""}`);
					set_attribute(p, "id", id());
				});

				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if (Array.isArray(errors()) && errors().length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$A = template(`<article class="media"><figure class="media-left"><p class="image is-32x32"><img></p></figure> <div class="media-content"><div class="content"><p><strong> </strong> <small>@</small> <strong> </strong></p></div></div></article>`);

	function Ui_user_card($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [image]
		 * @property {string} [username]
		 * @property {string} [role]
		 * @property {any} [events]
		 * @property {any} [register] - register event handlers
		 * @property {any} [onUpdate]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, "userCard"),
			image = prop($$props, "image", 3, "https://bulma.io/images/placeholders/32x32.png"),
			username = prop($$props, "username", 15, "John Doe"),
			role = prop($$props, "role", 15, "admin"),
			events = prop($$props, "events", 31, () => proxy({})),
			register = prop($$props, "register", 19, () => notCommon$1.registerWidgetEvents),
			onUpdate = prop($$props, "onUpdate", 3, (data) => {
				if (Object.hasOwn(data, "username")) {
					username(data.username);
				}

				if (Object.hasOwn(data, "role")) {
					role(data.role);
				}
			});

		function getCompId() {
			return `usercard-${id()}`;
		}

		function getStandartUpdateEventName() {
			let compId = getCompId();

			return `${compId}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		var article = root$A();

		template_effect(() => set_attribute(article, "id", getCompId()));

		var figure = child(article);
		var p = child(figure);
		var img = child(p);

		reset(p);
		reset(figure);

		var div = sibling(figure, 2);
		var div_1 = child(div);
		var p_1 = child(div_1);
		var strong = child(p_1);
		var text = child(strong, true);

		reset(strong);

		var strong_1 = sibling(strong, 4);
		var text_1 = child(strong_1, true);

		reset(strong_1);
		reset(p_1);
		reset(div_1);
		reset(div);
		reset(article);

		template_effect(() => {
			set_attribute(img, "src", image());
			set_attribute(img, "alt", username());
			set_text(text, username());
			set_text(text_1, role());
		});

		append($$anchor, article);
		pop();
	}

	var root_1$q = template(`<p> </p>`);
	var root_2$k = template(`<input>`);

	function Ui_textfield($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, ""),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "textfield"),
			required = prop($$props, "required", 3, true),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"fieldname",
				"required",
				"disabled",
				"readonly",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$q();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$k();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-textfield-${fieldname() ?? ""}`,
					class: `input ${classes() ?? ""}`,
					type: "text",
					name: fieldname(),
					invalid: get$2(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					onchange: oninput,
					oninput,
					"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
					"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$z = template(`<div class="columns"><div class="column"><div class="field"><!></div></div></div>`);

	function Ui_simple_search_input($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} [placeholder]
		 * @property {string} [term]
		 */
		/** @type {Props} */
		let placeholder = prop($$props, "placeholder", 19, () => $LOCALE()["not-node:field_search_placeholder"]),
			term = prop($$props, "term", 15, "");

		function onChange({ detail }) {
			dispatch("termChange", detail);
		}

		var div = root$z();
		var div_1 = child(div);
		var div_2 = child(div_1);
		var node = child(div_2);

		Ui_textfield(node, {
			get placeholder() {
				return placeholder();
			},
			fieldname: "searchTermInput",
			icon: "magnifying-glass",
			get value() {
				return term();
			},
			set value($$value) {
				term($$value);
			},
			$$events: { change: onChange }
		});

		reset(div_2);
		reset(div_1);
		reset(div);
		append($$anchor, div);
		pop();
	}

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBoolean: Ui_boolean,
		UIBooleanLabeled: Ui_boolean_labeled,
		UIBooleans: Ui_booleans,
		UICensored: Ui_censored,
		UIErrorsList: Ui_errors_list,
		UIIndicator: Ui_indicator,
		UILoader: Ui_loader,
		UIProgress: Ui_progress,
		UISelectFromModelOnDemandInline: Ui_select_from_model_on_demand_inline,
		UISelectFromModelWithSearchModal: Ui_select_from_model_with_search_modal,
		UIShowOneFromList: Ui_show_one_from_list,
		UISimpleSearchInput: Ui_simple_search_input,
		UITag: Ui_tag,
		UITagValue: Ui_tag_value,
		UITitle: Ui_title,
		UIUserCard: Ui_user_card
	});

	var root$y = template(`<label><!></label>`);

	function Ui_label($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} for
		 * @property {string} [label='label']
		 * @property {string} [class = '']
		 */
		/** @type {Props} */
		let label = prop($$props, "label", 3, "label"),
			labelClass = prop($$props, "class", 3, "");

		var label_1 = root$y();
		var node = child(label_1);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var text$1 = text();

				template_effect(() => set_text(text$1, label() ? $LOCALE()[label()] : ""));
				append($$anchor, text$1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(label_1);

		template_effect(() => {
			set_class(label_1, `label ${labelClass() ?? ""}`);
			set_attribute(label_1, "for", $$props.for);
		});

		append($$anchor, label_1);
		pop();
	}

	function Ui_form_input_errors($$anchor, $$props) {
		push($$props, true);

		let id = prop($$props, "id", 3, "generic-field"),
			classes = prop($$props, "class", 3, "");

		let allErrors = state(proxy([]));
		let showErrors = state(true);

		user_effect(() => {
			set(allErrors, proxy([
				...Array.isArray($$props.errors) ? $$props.errors : [],
				...Array.isArray($$props.formErrors) ? $$props.formErrors : []
			]));

			set(showErrors, proxy($$props.inputStarted && $$props.validated && !$$props.valid));
		});

		Ui_errors_list($$anchor, {
			get show() {
				return get$2(showErrors);
			},
			get errors() {
				return get$2(allErrors);
			},
			get class() {
				return classes();
			},
			get id() {
				return id();
			}
		});

		pop();
	}

	var root$x = template(`<span class="is-relative" style="display: inline-block; width: fit-content; height: fit-content; "><!> <!></span>`);

	function Ui_icon_button_with_tag($$anchor, $$props) {
		push($$props, true);

		let button = prop($$props, "button", 19, () => ({})),
			tag = prop($$props, "tag", 19, () => ({}));

		let siding = state("");
		let vars = state(proxy({}));

		function addVerticalCenteringIfNeeded() {
			if (!$$props.bottom && !$$props.top) {
				set(siding, get$2(siding) + ` is-vertical-centered`);
			}
		}

		function addHorizontalCenteringIfNeeded() {
			if (!$$props.right && !$$props.left) {
				set(siding, get$2(siding) + ` is-horizontal-centered`);
			}
		}

		onMount(() => {
			if ($$props.left) {
				set(siding, get$2(siding) + ` is-sided-left`);
				get$2(vars)[`--siding-left-size`] = $$props.left;
				addVerticalCenteringIfNeeded();
			}

			if ($$props.right) {
				set(siding, get$2(siding) + ` is-sided-right`);
				get$2(vars)["--siding-right-size"] = $$props.right;
				addVerticalCenteringIfNeeded();
			}

			if ($$props.top) {
				set(siding, get$2(siding) + ` is-sided-top`);
				get$2(vars)["--siding-top-size"] = $$props.top;
				addHorizontalCenteringIfNeeded();
			}

			if ($$props.bottom) {
				set(siding, get$2(siding) + ` is-sided-bottom`);
				get$2(vars)["--siding-bottom-size"] = $$props.bottom;
				addHorizontalCenteringIfNeeded();
			}

			set(vars, proxy(get$2(vars)));
		});

		var span = root$x();
		var node = child(span);

		Ui_button(node, spread_props(button));

		var node_1 = sibling(node, 2);

		Ui_tag(node_1, spread_props(tag, {
			get class() {
				return `is-padded-small is-sided ${get$2(siding) ?? ""}`;
			},
			get vars() {
				return get$2(vars);
			}
		}));

		reset(span);
		append($$anchor, span);
		pop();
	}

	var root$w = template(`<div><!></div>`);

	function Ui_icon_floating($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [trigger] - export let direction = 'left';  //left/right/top/bottom/around
		 */
		/** @type {Props} */
		let trigger = prop($$props, "trigger", 19, () => ({
				title: "Click me!",
				icon: "plus",
				color: "primary",
				size: "medium",
				onclick: () => true
			})),
			top = prop($$props, "top", 3, "2em"),
			left = prop($$props, "left", 3, "2em"),
			classes = prop($$props, "class", 3, "");

		let positionStyle = state("");

		onMount(() => {
			set(positionStyle, "");

			if (top()) {
				set(positionStyle, get$2(positionStyle) + `top: ${top()};`);
			}

			if (left()) {
				set(positionStyle, get$2(positionStyle) + `left: ${left()};`);
			}

			if ($$props.right) {
				set(positionStyle, get$2(positionStyle) + `right: ${$$props.right};`);
			}

			if ($$props.bottom) {
				set(positionStyle, get$2(positionStyle) + `bottom: ${$$props.bottom};`);
			}
		});

		var div = root$w();
		var node = child(div);

		Ui_button(node, spread_props(trigger));
		reset(div);

		template_effect(() => {
			set_class(div, `is-absolute ${classes() ?? ""}`);
			set_attribute(div, "style", get$2(positionStyle));
		});

		append($$anchor, div);
		pop();
	}

	var root_1$p = template(`<span><span><i></i> <span> </span></span></span>`);
	var root_2$j = template(`<span><i></i></span>`);

	function Ui_icon_font($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""]
		 * @property {string} [font = ""]
		 * @property {string} [size = ""]
		 * @property {string} [side = ""]
		 * @property {string} [class = ""]
		 * @property {boolean} [pointable = false]
		 */
		/** @type {Props} */
		let title = prop($$props, "title", 3, ""),
			font = prop($$props, "font", 3, ""),
			side = prop($$props, "side", 3, ""),
			size = prop($$props, "size", 3, ""),
			pointable = prop($$props, "pointable", 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$p();
				var span_1 = child(span);
				var i = child(span_1);
				var span_2 = sibling(i, 2);
				var text = child(span_2, true);

				reset(span_2);
				reset(span_1);
				reset(span);

				template_effect(() => {
					set_class(span, `icon-text ${(pointable() ? 'is-clickable' : '') ?? ""}`);
					set_class(span_1, `icon ${(size() ? `is-${size()}` : '') ?? ""}`);

					set_class(i, `is-title-icon fas
      fa-${font() ?? ""}
      ${(size() == 'medium' ? 'fa-lg' : '') ?? ""}
      ${(size() == 'large' ? 'fa-2x' : '') ?? ""}
      `);

					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			var alternate = ($$anchor) => {
				var span_3 = root_2$j();
				var i_1 = child(span_3);

				reset(span_3);

				template_effect(() => {
					set_class(span_3, `
        ${(pointable() ? 'is-clickable' : '') ?? ""}
        ${(side() ? `is-${side()}` : '') ?? ""}
        icon ${(size() ? `is-${size()}` : '') ?? ""} ${(size() == 'medium' ? 'fa-lg' : '') ?? ""}
${(size() == 'large' ? 'fa-2x' : '') ?? ""}`);

					set_class(i_1, `fas fa-${font() ?? ""}`);
				});

				append($$anchor, span_3);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_3$c = template(`<span class="icon"><!></span>`);
	var root_5$7 = template(`<figure><img></figure>`);

	function Ui_icon($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""] - font icon title
		 * @property {string} [size = ""]  - font icon size
		 * @property {string} [font = ""] - font icon name
		 * @property {string} [svg = ""] - svg icon
		 * @property {string} [src = ""] - image icon
		 * @property {number|string} width
		 * @property {number|string} height
		 */
		/** @type {Props} */
		let title = prop($$props, "title", 3, ""),
			size = prop($$props, "size", 3, ""),
			font = prop($$props, "font", 3, ""),
			svg = prop($$props, "svg", 3, ""),
			src = prop($$props, "src", 3, "");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return font();
					},
					get size() {
						return size();
					},
					get title() {
						return title();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var span = root_3$c();
						var node_2 = child(span);

						html(node_2, svg);
						reset(span);
						append($$anchor, span);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								var figure = root_5$7();
								var img = child(figure);

								reset(figure);

								template_effect(() => {
									set_class(figure, `image ${($$props.width && $$props.height ? `is-${$$props.width}x${$$props.height}` : '') ?? ""} `);
									set_attribute(img, "src", src());
									set_attribute(img, "title", title());
									set_attribute(img, "alt", title());
									set_attribute(img, "width", $$props.width);
									set_attribute(img, "height", $$props.height);
								});

								append($$anchor, figure);
							};

							if_block(
								node_3,
								($$render) => {
									if (src()) $$render(consequent_2);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (svg()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (font()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
	}

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIIcon: Ui_icon,
		UIIconButtonWithTag: Ui_icon_button_with_tag,
		UIIconFloating: Ui_icon_floating,
		UIIconFont: Ui_icon_font
	});

	function Ui_form_input_validated_icon($$anchor, $$props) {
		let side = prop($$props, "side", 3, "right"),
			size = prop($$props, "size", 3, "small");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var font = derived(() => $$props.valid ? "check" : "exclamation-triangle");

				Ui_icon_font($$anchor, {
					get font() {
						return get$2(font);
					},
					get side() {
						return side();
					},
					get size() {
						return size();
					}
				});
			};

			if_block(node, ($$render) => {
				if ($$props.validated === true) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root$v = template(`<!> <!> <!>`, 1);

	function Ui_form_input($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any} [value]
		 * @property {boolean} [readonly]
		 * @property {object}  UIInput
		 * @property {string} fieldtype
		 * @property {string} fieldname
		 * @property {string} [fieldnamePrefix = "form-field-"]
		 * @property {string} [icon]
		 * @property {boolean} [valid = true]
		 * @property {boolean} [validated = false]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 15, "");
			prop($$props, "fieldnamePrefix", 3, "form-field-");
			let valid = prop($$props, "valid", 3, true),
			validated = prop($$props, "validated", 3, false),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"readonly",
				"UIInput",
				"label",
				"fieldtype",
				"fieldname",
				"fieldnamePrefix",
				"icon",
				"valid",
				"validated"
			]);

		var fragment = root$v();
		var node = first_child(fragment);

		component(node, () => $$props.UIInput, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(
				{
					get fieldtype() {
						return $$props.fieldtype;
					},
					get fieldname() {
						return $$props.fieldname;
					},
					get valid() {
						return valid();
					},
					get readonly() {
						return $$props.readonly;
					}
				},
				() => others,
				{
					get value() {
						return value();
					},
					set value($$value) {
						value($$value);
					}
				}
			));
		});

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return $$props.icon;
					},
					side: "left",
					size: "small"
				});
			};

			if_block(node_1, ($$render) => {
				if ($$props.icon) $$render(consequent);
			});
		}

		var node_2 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_form_input_validated_icon($$anchor, {
					get validated() {
						return validated();
					},
					get valid() {
						return valid();
					}
				});
			};

			if_block(node_2, ($$render) => {
				if (!$$props.readonly) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
	}

	var root$u = template(`<div><!></div>`);

	function Ui_control($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [class='']
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, "class", 3, "");
		var div = root$u();
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", $$props.id);
			set_class(div, `control ${classes() ?? ""}`);
		});

		append($$anchor, div);
		pop();
	}

	var root_4$d = template(`<!> <!>`, 1);
	var root_6$a = template(` <!>`, 1);
	var root$t = template(`<!> <!>`, 1);

	function Ui_form_control($$anchor, $$props) {
		const control = ($$anchor) => {
			Ui_control($$anchor, {
				get class() {
					return get$2(iconClasses);
				},
				children: ($$anchor, $$slotProps) => {
					Ui_form_input($$anchor, spread_props(
						{
							get UIInput() {
								return $$props.UIInput;
							},
							get placeholder() {
								return placeholder();
							},
							get fieldtype() {
								return $$props.fieldtype;
							},
							get fieldname() {
								return $$props.fieldname;
							},
							get fieldnamePrefix() {
								return fieldnamePrefix();
							},
							get icon() {
								return icon();
							},
							get required() {
								return required();
							},
							get readonly() {
								return readonly();
							},
							get disabled() {
								return disabled();
							},
							get inputStarted() {
								return inputStarted();
							},
							get validated() {
								return validated();
							},
							get valid() {
								return valid();
							},
							get onchange() {
								return onchange();
							},
							get onerror() {
								return onerror();
							}
						},
						() => others,
						{
							get value() {
								return value();
							},
							set value($$value) {
								value($$value);
							}
						}
					));
				},
				$$slots: { default: true }
			});
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted]
		 * @property {boolean} [value]
		 * @property {string} [label]
		 * @property {string} [placeholder]
		 * @property {string} fieldname
		 * @property {string} fieldtype
		 * @property {boolean} [icon]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [disabled]
		 * @property {import('../events.types').UIEventInputChangeCallback} [onchange]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 15, ""),
			inputStarted = prop($$props, "inputStarted", 3, false),
			labelVertical = prop($$props, "labelVertical", 3, true),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldnamePrefix = prop($$props, "fieldnamePrefix", 3, "form-field-"),
			icon = prop($$props, "icon", 3, ""),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			valid = prop($$props, "valid", 3, true),
			validated = prop($$props, "validated", 3, false),
			onchange = prop($$props, "onchange", 3, () => true),
			onerror = prop($$props, "onerror", 3, () => true),
			formErrors = prop($$props, "formErrors", 19, () => []),
			errors = prop($$props, "errors", 19, () => []),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"UIInput",
				"inputStarted",
				"label",
				"labelVertical",
				"placeholder",
				"fieldtype",
				"fieldname",
				"fieldnamePrefix",
				"icon",
				"required",
				"readonly",
				"disabled",
				"valid",
				"validated",
				"onchange",
				"onerror",
				"formErrors",
				"errors"
			]);

		let iconClasses = derived(() => (icon() ? " has-icons-left " : "") + " has-icons-right ");
		var fragment_2 = root$t();
		var node = first_child(fragment_2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_1 = first_child(fragment_3);

				{
					var consequent = ($$anchor) => {
						var fragment_4 = root_4$d();
						var node_2 = first_child(fragment_4);

						Ui_label(node_2, {
							get class() {
								return $$props.fieldtype;
							},
							get for() {
								return `${fieldnamePrefix() ?? ""}${$$props.fieldtype ?? ""}-${$$props.fieldname ?? ""}`;
							},
							get label() {
								return $$props.label;
							}
						});

						var node_3 = sibling(node_2, 2);

						control(node_3);
						append($$anchor, fragment_4);
					};

					var alternate = ($$anchor) => {
						Ui_label($$anchor, {
							get class() {
								return $$props.fieldtype;
							},
							get for() {
								return `${fieldnamePrefix() ?? ""}${$$props.fieldtype ?? ""}-${$$props.fieldname ?? ""}`;
							},
							children: ($$anchor, $$slotProps) => {
								next();

								var fragment_6 = root_6$a();
								var text = first_child(fragment_6);
								var node_4 = sibling(text);

								control(node_4);
								template_effect(() => set_text(text, `${$$props.label ?? ""}: `));
								append($$anchor, fragment_6);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_1, ($$render) => {
						if (labelVertical()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_3);
			};

			var alternate_1 = ($$anchor) => {
				control($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.label) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		var node_5 = sibling(node, 2);

		Ui_form_input_errors(node_5, {
			get inputStarted() {
				return inputStarted();
			},
			get validated() {
				return validated();
			},
			get valid() {
				return valid();
			},
			get errors() {
				return errors();
			},
			get formErrors() {
				return formErrors();
			},
			get id() {
				return `input-field-helper-${$$props.fieldname ?? ""}`;
			}
		});

		append($$anchor, fragment_2);
	}

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIFormControl: Ui_form_control,
		UIFormInput: Ui_form_input,
		UIFormInputErrors: Ui_form_input_errors,
		UIFormInputValidatedIcon: Ui_form_input_validated_icon
	});

	var root_1$o = template(`<figure><img></figure>`);
	var root_2$i = template(`<a><!></a>`);

	function Ui_image($$anchor, $$props) {
		const imageFigure = ($$anchor) => {
			var figure = root_1$o();
			const class_derived = derived(() => `image ${classes() ?? ""} ${(!$$props.width && !$$props.height ? isNaN(size()) ? `is-${size()}` : `is-${size()}x${size()}` : '') ?? ""}`);
			var img = child(figure);

			img.__click = function (...$$args) {
				onclick()?.apply(this, $$args);
			};

			img.__keyup = function (...$$args) {
				onkeyup()?.apply(this, $$args);
			};

			reset(figure);

			template_effect(() => {
				set_class(figure, get$2(class_derived));
				set_attribute(figure, "style", ($$props.width ? `width: ${$$props.width};` : "") + ($$props.height ? `height: ${$$props.height};` : ""));
				toggle_class(figure, "is-contained", contained());
				toggle_class(figure, "is-covered", covered());
				toggle_class(figure, "is-clickable", onclick() && $$props.pointable !== false || $$props.pointable);
				set_attribute(img, "alt", $$props.alt || $$props.title);
				set_attribute(img, "title", $$props.title);
				set_attribute(img, "src", $$props.url);
				set_attribute(img, "crossorigin", cors());
			});

			append($$anchor, figure);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [urlFull]
		 * @property {string} url
		 * @property {string} [title]
		 * @property {string} [alt]
		 * @property {string} [cors='anonymous']
		 * @property {number} [size = 64]
		 * @property {number} [height]
		 * @property {number} [width]
		 * @property {boolean} [contained=false]
		 * @property {boolean} [covered=false]
		 * @property {boolean} [pointable]
		 * @property {string} [class = '']
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let cors = prop($$props, "cors", 3, "anonymous"),
			size = prop($$props, "size", 3, 64),
			contained = prop($$props, "contained", 3, false),
			covered = prop($$props, "covered", 3, false),
			classes = prop($$props, "class", 3, ""),
			onclick = prop($$props, "onclick", 3, undefined),
			onkeyup = prop($$props, "onkeyup", 3, undefined);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var a = root_2$i();

				a.__click = function (...$$args) {
					onclick()?.apply(this, $$args);
				};

				var node_1 = child(a);

				imageFigure(node_1);
				reset(a);

				template_effect(() => {
					set_attribute(a, "href", $$props.urlFull);
					set_attribute(a, "title", $$props.title || $$props.alt);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				imageFigure($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.urlFull) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
	}

	delegate(["click", "keyup"]);

	function Ui_images($$anchor, $$props) {
		let values = prop($$props, "values", 19, () => []),
			override = rest_props($$props, ["$$slots", "$$events", "$$legacy", "values"]);

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.url, ($$anchor, item) => {
			Ui_image($$anchor, spread_props(() => get$2(item), () => override));
		});

		append($$anchor, fragment);
	}

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIImage: Ui_image,
		UIImages: Ui_images
	});

	enable_legacy_mode_flag();

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/


	/**
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/** @import { FlipParams, AnimationConfig } from './public.js' */

	/**
	 * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.
	 * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).
	 *
	 * @param {Element} node
	 * @param {{ from: DOMRect; to: DOMRect }} fromTo
	 * @param {FlipParams} params
	 * @returns {AnimationConfig}
	 */
	function flip(node, { from, to }, params = {}) {
		var style = getComputedStyle(node);
		var zoom = get_zoom(node); // https://drafts.csswg.org/css-viewport/#effective-zoom

		var transform = style.transform === 'none' ? '' : style.transform;
		var [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
		var dsx = from.width / to.width;
		var dsy = from.height / to.height;

		var dx = (from.left + dsx * ox - (to.left + ox)) / zoom;
		var dy = (from.top + dsy * oy - (to.top + oy)) / zoom;
		var { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;

		return {
			delay,
			duration: typeof duration === 'function' ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
			easing,
			css: (t, u) => {
				var x = u * dx;
				var y = u * dy;
				var sx = t + u * dsx;
				var sy = t + u * dsy;
				return `transform: ${transform} scale(${sx}, ${sy}) translate(${x}px, ${y}px);`;
			}
		};
	}

	/**
	 * @param {Element} element
	 */
	function get_zoom(element) {
		if ('currentCSSZoom' in element) {
			return /** @type {number} */ (element.currentCSSZoom);
		}

		/** @type {Element | null} */
		var current = element;
		var zoom = 1;

		while (current !== null) {
			zoom *= +getComputedStyle(current).zoom;
			current = /** @type {Element | null} */ (current.parentElement);
		}

		return zoom;
	}

	/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */
	/** @param {number} x */
	const linear = (x) => x;

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * @param {Element} node
	 * @param {FadeParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = linear } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	var root_1$n = template(`<option selected class="svelte-75ckfb"> </option>`);
	var root_4$c = template(`<option selected class="svelte-75ckfb"> </option>`);
	var root_7$3 = template(`<div class="tags has-addons svelte-75ckfb"><span class="tag svelte-75ckfb"> </span> <span class="tag is-delete svelte-75ckfb"></span></div>`);
	var root_6$9 = template(`<div class="svelte-75ckfb"><!></div>`);
	var root_8$2 = template(`<span class="autocomplete-clear-button svelte-75ckfb"><!></span>`);
	var root_11$3 = template(`<div class="autocomplete-list-item svelte-75ckfb"><!></div>`);
	var root_17 = template(`<div class="autocomplete-list-item-no-results svelte-75ckfb"> </div>`);
	var root_9$1 = template(`<!> <!> <!>`, 1);
	var root_19$1 = template(`<div class="autocomplete-list-item-loading svelte-75ckfb"><!></div>`);
	var root_22$1 = template(`<div class="autocomplete-list-item-create svelte-75ckfb"><!></div>`);
	var root_25 = template(`<div class="autocomplete-list-item-no-results svelte-75ckfb"><!></div>`);
	var root$s = template(`<div><select class="svelte-75ckfb"><!></select> <div class="input-container svelte-75ckfb"><!> <input> <!></div> <div><!></div></div>`);

	function SimpleAutocomplete($$anchor, $$props) {
		const $$sanitized_props = legacy_rest_props($$props, [
			"children",
			"$$slots",
			"$$events",
			"$$legacy"
		]);

		const $$restProps = legacy_rest_props($$sanitized_props, [
			"highlightFilter",
			"items",
			"searchFunction",
			"labelFieldName",
			"keywordsFieldName",
			"valueFieldName",
			"labelFunction",
			"keywordsFunction",
			"valueFunction",
			"keywordsCleanFunction",
			"textCleanFunction",
			"beforeChange",
			"onChange",
			"onFocus",
			"onBlur",
			"onCreate",
			"selectFirstIfEmpty",
			"minCharactersToSearch",
			"maxItemsToShowInList",
			"multiple",
			"create",
			"ignoreAccents",
			"matchAllKeywords",
			"sortByMatchedKeywords",
			"itemFilterFunction",
			"itemSortFunction",
			"lock",
			"delay",
			"localFiltering",
			"localSorting",
			"cleanUserText",
			"lowercaseKeywords",
			"closeOnBlur",
			"orderableSelection",
			"hideArrow",
			"showClear",
			"clearText",
			"showLoadingIndicator",
			"noResultsText",
			"loadingText",
			"moreItemsText",
			"createText",
			"placeholder",
			"className",
			"inputClassName",
			"inputId",
			"name",
			"selectName",
			"selectId",
			"title",
			"html5autocomplete",
			"autocompleteOffValue",
			"readonly",
			"dropdownClassName",
			"disabled",
			"noInputStyles",
			"required",
			"debug",
			"tabindex",
			"selectedItem",
			"value",
			"highlightedItem",
			"text"
		]);

		push($$props, false);

		const showList = mutable_state();
		const hasSelection = mutable_state();
		const clearable = mutable_state();
		const locked = mutable_state();
		let items = prop($$props, "items", 28, () => []);
		let searchFunction = prop($$props, "searchFunction", 8, false);
		let labelFieldName = prop($$props, "labelFieldName", 8, undefined);
		let keywordsFieldName = prop($$props, "keywordsFieldName", 24, labelFieldName);
		let valueFieldName = prop($$props, "valueFieldName", 8, undefined);

		let labelFunction = prop($$props, "labelFunction", 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return labelFieldName() ? item[labelFieldName()] : item;
		});

		let keywordsFunction = prop($$props, "keywordsFunction", 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return keywordsFieldName() ? item[keywordsFieldName()] : labelFunction()(item);
		});

		let valueFunction = prop($$props, "valueFunction", 8, function (item, forceSingle = false) {
			if (item === undefined || item === null) {
				return item;
			}

			if (!multiple() || forceSingle) {
				return valueFieldName() ? item[valueFieldName()] : item;
			} else {
				return item.map((i) => valueFieldName() ? i[valueFieldName()] : i);
			}
		});

		let keywordsCleanFunction = prop($$props, "keywordsCleanFunction", 8, function (keywords) {
			return keywords;
		});

		let textCleanFunction = prop($$props, "textCleanFunction", 8, function (userEnteredText) {
			return userEnteredText;
		});

		let beforeChange = prop($$props, "beforeChange", 8, function (oldSelectedItem, newSelectedItem) {
			return true;
		});

		let onChange = prop($$props, "onChange", 8, function (newSelectedItem) {});
		let onFocus = prop($$props, "onFocus", 8, function () {});
		let onBlur = prop($$props, "onBlur", 8, function () {});

		let onCreate = prop($$props, "onCreate", 8, function (text) {
			if (debug()) {
				console.log("onCreate: " + text);
			}
		});

		let selectFirstIfEmpty = prop($$props, "selectFirstIfEmpty", 8, false);
		let minCharactersToSearch = prop($$props, "minCharactersToSearch", 8, 1);
		let maxItemsToShowInList = prop($$props, "maxItemsToShowInList", 8, 0);
		let multiple = prop($$props, "multiple", 8, false);
		let create = prop($$props, "create", 8, false);
		let ignoreAccents = prop($$props, "ignoreAccents", 8, true);
		let matchAllKeywords = prop($$props, "matchAllKeywords", 8, true);
		let sortByMatchedKeywords = prop($$props, "sortByMatchedKeywords", 8, false);
		let itemFilterFunction = prop($$props, "itemFilterFunction", 8, undefined);
		let itemSortFunction = prop($$props, "itemSortFunction", 8, undefined);
		let lock = prop($$props, "lock", 8, false);
		let delay = prop($$props, "delay", 8, 0);
		let localFiltering = prop($$props, "localFiltering", 8, true);
		let localSorting = prop($$props, "localSorting", 8, true);
		let cleanUserText = prop($$props, "cleanUserText", 8, true);
		let lowercaseKeywords = prop($$props, "lowercaseKeywords", 8, true);
		let closeOnBlur = prop($$props, "closeOnBlur", 8, false);
		let orderableSelection = prop($$props, "orderableSelection", 8, false);
		let hideArrow = prop($$props, "hideArrow", 8, false);
		let showClear = prop($$props, "showClear", 8, false);
		let clearText = prop($$props, "clearText", 8, "&#10006;");
		let showLoadingIndicator = prop($$props, "showLoadingIndicator", 8, false);
		let noResultsText = prop($$props, "noResultsText", 8, "No results found");
		let loadingText = prop($$props, "loadingText", 8, "Loading results...");
		let moreItemsText = prop($$props, "moreItemsText", 8, "items not shown");
		let createText = prop($$props, "createText", 8, "Not found, add anyway?");
		let placeholder = prop($$props, "placeholder", 8, undefined);
		let className = prop($$props, "className", 8, undefined);
		let inputClassName = prop($$props, "inputClassName", 8, undefined);
		let inputId = prop($$props, "inputId", 8, undefined);
		let name = prop($$props, "name", 8, undefined);
		let selectName = prop($$props, "selectName", 8, undefined);
		let selectId = prop($$props, "selectId", 8, undefined);
		let title = prop($$props, "title", 8, undefined);
		let html5autocomplete = prop($$props, "html5autocomplete", 8, undefined);
		let autocompleteOffValue = prop($$props, "autocompleteOffValue", 8, "off");
		let readonly = prop($$props, "readonly", 8, undefined);
		let dropdownClassName = prop($$props, "dropdownClassName", 8, undefined);
		let disabled = prop($$props, "disabled", 8, false);
		let noInputStyles = prop($$props, "noInputStyles", 8, false);
		let required = prop($$props, "required", 8, null);
		let debug = prop($$props, "debug", 8, false);
		let tabindex = prop($$props, "tabindex", 8, 0);
		let selectedItem = prop($$props, "selectedItem", 28, () => multiple() ? [] : undefined);
		let value = prop($$props, "value", 12, undefined);
		let highlightedItem = prop($$props, "highlightedItem", 12, undefined);
		// --- Internal State ----
		const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);
		// HTML elements
		let input = mutable_state();
		let list = mutable_state();
		let inputContainer = mutable_state();
		// UI state
		let opened = mutable_state(false);
		let loading = mutable_state(false);
		let highlightIndex = mutable_state(-1);
		let text$1 = prop($$props, "text", 12, undefined);
		let filteredTextLength = mutable_state(0);
		// view model
		let filteredListItems = mutable_state();
		let listItems = [];
		// requests/responses counters
		let lastRequestId = 0;
		let lastResponseId = 0;
		// other state
		let inputDelayTimeout;
		let setPositionOnNextUpdate = mutable_state(false);

		// --- Lifecycle events ---
		afterUpdate(() => {
			if (get$2(setPositionOnNextUpdate)) {
				setScrollAwareListPosition();
			}

			set(setPositionOnNextUpdate, false);
		});

		// --- Functions ---
		function safeFunction(theFunction, argument) {
			if (typeof theFunction !== "function") {
				console.error("Not a function: " + theFunction + ", argument: " + argument);
				return undefined;
			}

			let result;

			try {
				result = theFunction(argument);
			} catch(error) {
				console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
			}

			return result;
		}

		function safeStringFunction(theFunction, argument) {
			let result = safeFunction(theFunction, argument);

			if (result === undefined || result === null) {
				result = "";
			}

			if (typeof result !== "string") {
				result = result.toString();
			}

			return result;
		}

		function safeLabelFunction(item) {
			// console.log("labelFunction: " + labelFunction);
			// console.log("safeLabelFunction, item: " + item);
			return safeStringFunction(labelFunction(), item);
		}

		function safeKeywordsFunction(item) {
			// console.log("safeKeywordsFunction");
			const keywords = safeStringFunction(keywordsFunction(), item);
			let result = safeStringFunction(keywordsCleanFunction(), keywords);

			result = lowercaseKeywords() ? result.toLowerCase().trim() : result;

			if (ignoreAccents()) {
				result = removeAccents(result);
			}

			if (debug()) {
				console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
			}

			return result;
		}

		function prepareListItems() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete prepare list ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Prepare items to search");
				console.log("items: " + JSON.stringify(items()));
			}

			if (!Array.isArray(items())) {
				console.warn("Autocomplete items / search function did not return array but", items());
				items([]);
			}

			const length = items() ? items().length : 0;

			listItems = new Array(length);

			if (length > 0) {
				items().forEach((item, i) => {
					const listItem = getListItem(item);

					if (listItem === undefined) {
						console.log("Undefined item for: ", item);
					}

					listItems[i] = listItem;
				});
			}

			set(filteredListItems, listItems);

			if (debug()) {
				console.log(listItems.length + " items to search");
				console.timeEnd(timerId);
			}
		}

		function getListItem(item) {
			return {
				// keywords representation of the item
				keywords: localFiltering() ? safeKeywordsFunction(item) : [],
				// item label
				label: safeLabelFunction(item),
				// store reference to the origial item
				item
			};
		}

		function onSelectedItemChanged() {
			value(valueFunction()(selectedItem()));

			if (selectedItem() && !multiple()) {
				text$1(safeLabelFunction(selectedItem()));
			}

			set(filteredListItems, listItems);
			onChange()(selectedItem());
		}

		function prepareUserEnteredText(userEnteredText) {
			if (userEnteredText === undefined || userEnteredText === null) {
				return "";
			}

			if (!cleanUserText()) {
				return userEnteredText;
			}

			const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
			const cleanUserEnteredText = safeStringFunction(textCleanFunction(), textFiltered);
			const textTrimmed = lowercaseKeywords() ? cleanUserEnteredText.toLowerCase().trim() : cleanUserEnteredText.trim();

			return textTrimmed;
		}

		function numberOfMatches(listItem, searchWords) {
			if (!listItem) {
				return 0;
			}

			const itemKeywords = listItem.keywords;
			let matches = 0;

			searchWords.forEach((searchWord) => {
				if (itemKeywords.includes(searchWord)) {
					matches++;
				}
			});

			return matches;
		}

		async function search() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete search ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Searching user entered text: '" + text$1() + "'");
			}

			let textFiltered = prepareUserEnteredText(text$1());

			if (minCharactersToSearch() > 1 && textFiltered.length < minCharactersToSearch()) {
				textFiltered = "";
			}

			set(filteredTextLength, textFiltered.length);

			if (debug()) {
				console.log("Changed user entered text '" + text$1() + "' into '" + textFiltered + "'");
			}

			// if no search text load all items
			if (textFiltered === "") {
				if (searchFunction()) {
					// we will need to rerun the search
					items([]);

					if (debug()) {
						console.log("User entered text is empty clear list of items");
					}
				} else {
					set(filteredListItems, listItems);

					if (debug()) {
						console.log("User entered text is empty set the list of items to all items");
					}
				}

				if (closeIfMinCharsToSearchReached()) {
					if (debug()) {
						console.timeEnd(timerId);
					}

					return;
				}
			}

			if (!searchFunction()) {
				// internal search
				processListItems(textFiltered);
			} else {
				// external search which provides items
				lastRequestId = lastRequestId + 1;

				const currentRequestId = lastRequestId;

				set(loading, true);

				// searchFunction is a generator
				if (searchFunction().constructor.name === "AsyncGeneratorFunction") {
					for await (const chunk of searchFunction()(textFiltered, maxItemsToShowInList())) {
						// a chunk of an old response: throw it away
						if (currentRequestId < lastResponseId) {
							return false;
						}

						// a chunk for a new response: reset the item list
						if (currentRequestId > lastResponseId) {
							items([]);
						}

						lastResponseId = currentRequestId;
						items([...items(), ...chunk]);
						processListItems(textFiltered);
					}

					// there was nothing in the chunk
					if (lastResponseId < currentRequestId) {
						lastResponseId = currentRequestId;
						items([]);
						processListItems(textFiltered);
					}
				} else // searchFunction is a regular function
				{
					let result = await searchFunction()(textFiltered, maxItemsToShowInList());

					// If a response to a newer request has been received
					// while responses to this request were being loaded,
					// then we can just throw away this outdated results.
					if (currentRequestId < lastResponseId) {
						return false;
					}

					lastResponseId = currentRequestId;
					items(result);
					processListItems(textFiltered);
				}

				set(loading, false);
			}

			if (debug()) {
				console.timeEnd(timerId);
				console.log("Search found " + get$2(filteredListItems).length + " items");
			}
		}

		function defaultItemFilterFunction(listItem, searchWords) {
			const matches = numberOfMatches(listItem, searchWords);

			if (matchAllKeywords()) {
				return matches >= searchWords.length;
			} else {
				return matches > 0;
			}
		}

		function defaultItemSortFunction(obj1, obj2, searchWords) {
			return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
		}

		function processListItems(textFiltered) {
			// cleans, filters, orders, and highlights the list items
			prepareListItems();

			const textFilteredWithoutAccents = ignoreAccents() ? removeAccents(textFiltered) : textFiltered;
			const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter((word) => word !== "");
			// local search
			let tempfilteredListItems;

			if (localFiltering()) {
				if (itemFilterFunction()) {
					tempfilteredListItems = listItems.filter((item) => itemFilterFunction()(item.item, searchWords));
				} else {
					tempfilteredListItems = listItems.filter((item) => defaultItemFilterFunction(item, searchWords));
				}

				if (localSorting()) {
					if (itemSortFunction()) {
						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction()(item1.item, item2.item, searchWords));
					} else {
						if (sortByMatchedKeywords()) {
							tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
						}
					}
				}
			} else {
				tempfilteredListItems = listItems;
			}

			const hlfilter = highlightFilter(searchWords, "label");

			set(filteredListItems, tempfilteredListItems.map(hlfilter));
			closeIfMinCharsToSearchReached();
			return true;
		}

		// $: text, search();
		function afterCreate(createdItem) {
			let listItem;

			if (debug()) {
				console.log("createdItem", createdItem);
			}

			if ("undefined" !== typeof createdItem) {
				prepareListItems();
				set(filteredListItems, listItems);

				let index = findItemIndex(createdItem, get$2(filteredListItems));

				// if the items array was not updated, add the created item manually
				if (index <= 0) {
					items([createdItem]);
					prepareListItems();
					set(filteredListItems, listItems);
					index = 0;
				}

				if (index >= 0) {
					set(highlightIndex, index);
					listItem = get$2(filteredListItems)[get$2(highlightIndex)];
				}
			}

			return listItem;
		}

		function selectListItem(listItem) {
			if (debug()) {
				console.log("selectListItem", listItem);
			}

			if ("undefined" === typeof listItem && create()) {
				// allow undefined items if create is enabled
				const createdItem = onCreate()(text$1());

				if ("undefined" !== typeof createdItem) {
					if (typeof createdItem.then === "function") {
						createdItem.then((newItem) => {
							if ("undefined" !== typeof newItem) {
								const newListItem = afterCreate(newItem);

								if ("undefined" !== typeof newListItem) {
									selectListItem(newListItem);
								}
							}
						});

						return true;
					} else {
						listItem = afterCreate(createdItem);
					}
				}
			}

			if ("undefined" === typeof listItem) {
				if (debug()) {
					console.log(`listItem is undefined. Can not select.`);
				}

				return false;
			}

			if (get$2(locked)) {
				return true;
			}

			const newSelectedItem = listItem.item;

			if (beforeChange()(selectedItem(), newSelectedItem)) {
				// simple selection
				if (!multiple()) {
					selectedItem(undefined); // triggers change even if the the same item is selected
					selectedItem(newSelectedItem);
				} else // first selection of multiple ones
				if (!selectedItem()) {
					selectedItem([newSelectedItem]);
				} else // selecting something already selected => unselect it
				if (selectedItem().includes(newSelectedItem)) {
					selectedItem(selectedItem().filter((i) => i !== newSelectedItem));
				} else // adds the element to the selection
				{
					selectedItem([...selectedItem(), newSelectedItem]);
				}
			}

			return true;
		}

		function selectItem() {
			if (debug()) {
				console.log("selectItem", get$2(highlightIndex));
			}

			const listItem = get$2(filteredListItems)[get$2(highlightIndex)];

			if (selectListItem(listItem)) {
				if (debug()) {
					console.log("selectListItem true, closing");
				}

				close();

				if (multiple()) {
					text$1("");
					get$2(input).focus();
				}
			} else {
				if (debug()) {
					console.log("selectListItem false, not closing");
				}
			}
		}

		function up() {
			if (debug()) {
				console.log("up");
			}

			open();

			if (get$2(highlightIndex) > 0) {
				update(highlightIndex, -1);
			}

			highlight();
		}

		function down() {
			if (debug()) {
				console.log("down");
			}

			open();

			if (get$2(highlightIndex) < get$2(filteredListItems).length - 1) {
				update(highlightIndex);
			}

			highlight();
		}

		function highlight() {
			if (debug()) {
				console.log("highlight");
			}

			const query = ".selected";

			if (debug()) {
				console.log("Seaching DOM element: " + query + " in " + get$2(list));
			}

			/**
			 * @param {Element} el
			 */
			const el = get$2(list) && get$2(list).querySelector(query);

			if (el) {
				if (typeof el.scrollIntoViewIfNeeded === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoViewIfNeeded();
				} else if (el.scrollIntoView === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoView();
				} else {
					if (debug()) {
						console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
					}
				}
			} else {
				if (debug()) {
					console.warn("Selected item not found to scroll into view");
				}
			}
		}

		function onListItemClick(listItem) {
			if (debug()) {
				console.log("onListItemClick");
			}

			if (selectListItem(listItem)) {
				close();

				if (multiple()) {
					text$1("");
					get$2(input).focus();
				}
			}
		}

		function onDocumentClick(e) {
			if (debug()) {
				console.log("onDocumentClick");
			}

			if (e.composedPath().some((path) => path.classList && path.classList.contains(uniqueId))) {
				if (debug()) {
					console.log("onDocumentClick inside");
				}

				// resetListToAllItemsAndOpen();
				highlight();
			} else {
				if (debug()) {
					console.log("onDocumentClick outside");
				}

				close();
			}
		}

		function onKeyDown(e) {
			if (debug()) {
				console.log("onKeyDown");
			}

			let key = e.key;

			if (key === "Tab" && e.shiftKey) key = "ShiftTab";

			const fnmap = {
				Tab: get$2(opened) ? close : null,
				ShiftTab: get$2(opened) ? close : null,
				ArrowDown: down.bind(this),
				ArrowUp: up.bind(this),
				Escape: onEsc.bind(this),
				Backspace: multiple() && get$2(hasSelection) && !text$1() ? onBackspace.bind(this) : null
			};

			const fn = fnmap[key];

			if (typeof fn === "function") {
				fn(e);
			}
		}

		function onKeyPress(e) {
			if (debug()) {
				console.log("onKeyPress");
			}

			if (e.key === "Enter") {
				onEnter(e);
			}
		}

		function onEnter(e) {
			if (get$2(opened)) {
				e.preventDefault();
				selectItem();
			}
		}

		function onInput(e) {
			if (debug()) {
				console.log("onInput");
			}

			text$1(e.target.value);

			if (inputDelayTimeout) {
				clearTimeout(inputDelayTimeout);
			}

			if (delay()) {
				inputDelayTimeout = setTimeout(processInput, delay());
			} else {
				processInput();
			}
		}

		function unselectItem(tag) {
			if (debug()) {
				console.log("unselectItem", tag);
			}

			selectedItem(selectedItem().filter((i) => i !== tag));
			get$2(input).focus();
		}

		function processInput() {
			if (search()) {
				set(highlightIndex, 0);
				open();
			}
		}

		function onInputClick() {
			if (debug()) {
				console.log("onInputClick");
			}

			resetListToAllItemsAndOpen();
		}

		function onEsc(e) {
			if (debug()) {
				console.log("onEsc");
			}

			//if (text) return clear();
			e.stopPropagation();

			if (get$2(opened)) {
				get$2(input).focus();
				close();
			}
		}

		function onBackspace(e) {
			if (debug()) {
				console.log("onBackspace");
			}

			unselectItem(selectedItem()[selectedItem().length - 1]);
		}

		function onFocusInternal() {
			if (debug()) {
				console.log("onFocus");
			}

			onFocus()();
			resetListToAllItemsAndOpen();
		}

		function onBlurInternal() {
			if (debug()) {
				console.log("onBlur");
			}

			if (closeOnBlur()) {
				close();
			}

			onBlur()();
		}

		function resetListToAllItemsAndOpen() {
			if (debug()) {
				console.log("resetListToAllItemsAndOpen");
			}

			if (searchFunction() && !listItems.length) {
				search();
			} else if (!text$1()) {
				set(filteredListItems, listItems);
			}

			open();

			// find selected item
			if (selectedItem()) {
				if (debug()) {
					console.log("Searching currently selected item: " + JSON.stringify(selectedItem()));
				}

				const index = findItemIndex(selectedItem(), get$2(filteredListItems));

				if (index >= 0) {
					set(highlightIndex, index);
					highlight();
				}
			}
		}

		function findItemIndex(item, items) {
			if (debug()) {
				console.log("Finding index for item", item);
			}

			let index = -1;

			for (let i = 0; i < items.length; i++) {
				const listItem = items[i];

				if ("undefined" === typeof listItem) {
					if (debug()) {
						console.log(`listItem ${i} is undefined. Skipping.`);
					}

					continue;
				}

				if (debug()) {
					console.log("Item " + i + ": " + JSON.stringify(listItem));
				}

				if (item === listItem.item) {
					index = i;
					break;
				}
			}

			if (debug()) {
				if (index >= 0) {
					console.log("Found index for item: " + index);
				} else {
					console.warn("Not found index for item: " + item);
				}
			}

			return index;
		}

		function open() {
			if (debug()) {
				console.log("open");
			}

			// check if the search text has more than the min chars required
			if (get$2(locked) || notEnoughSearchText()) {
				return;
			}

			set(setPositionOnNextUpdate, true);
			set(opened, true);
		}

		function close() {
			if (debug()) {
				console.log("close");
			}

			set(opened, false);
			set(loading, false);

			if (!text$1() && selectFirstIfEmpty()) {
				set(highlightIndex, 0);
				selectItem();
			}
		}

		function notEnoughSearchText() {
			return minCharactersToSearch() > 0 && get$2(filteredTextLength) < minCharactersToSearch() && (// When no searchFunction is defined, the menu should always open when the input is focused
			searchFunction() || get$2(filteredTextLength) > 0);
		}

		function closeIfMinCharsToSearchReached() {
			if (notEnoughSearchText()) {
				close();
				return true;
			}

			return false;
		}

		function clear() {
			if (debug()) {
				console.log("clear");
			}

			text$1("");
			selectedItem(multiple() ? [] : undefined);

			setTimeout(() => {
				get$2(input).focus();
			});
		}

		function highlightFilter(keywords, field) {
			return (item) => {
				let label = item[field];
				const newItem = Object.assign({ highlighted: undefined }, item);

				newItem.highlighted = label;

				const labelLowercase = label.toLowerCase();
				const labelLowercaseNoAc = ignoreAccents() ? removeAccents(labelLowercase) : labelLowercase;

				if (keywords && keywords.length) {
					const positions = [];

					for (let i = 0; i < keywords.length; i++) {
						let keyword = keywords[i];

						if (ignoreAccents()) {
							keyword = removeAccents(keyword);
						}

						const keywordLen = keyword.length;
						let pos1 = 0;

						do {
							pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

							if (pos1 >= 0) {
								let pos2 = pos1 + keywordLen;

								positions.push([pos1, pos2]);
								pos1 = pos2;
							}
						} while (pos1 !== -1);
					}

					if (positions.length > 0) {
						const keywordPatterns = new Set();

						for (let i = 0; i < positions.length; i++) {
							const pair = positions[i];
							const pos1 = pair[0];
							const pos2 = pair[1];
							const keywordPattern = labelLowercase.substring(pos1, pos2);

							keywordPatterns.add(keywordPattern);
						}

						for (let keywordPattern of keywordPatterns) {
							// FIXME pst: workarond for wrong replacement <b> tags
							if (keywordPattern === "b") {
								continue;
							}

							const reg = new RegExp("(" + keywordPattern + ")", "ig");
							const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");

							newItem.highlighted = newHighlighted;
						}
					}
				}

				return newItem;
			};
		}

		function removeAccents(str) {
			return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
		}

		function isConfirmed(listItem) {
			if (!selectedItem()) {
				return false;
			}

			if (multiple()) {
				return selectedItem().includes(listItem);
			} else {
				return listItem === selectedItem();
			}
		}

		let draggingOver = mutable_state(false);

		function dragstart(event, index) {
			if (orderableSelection()) {
				event.dataTransfer.setData("source", index);
			}
		}

		function dragover(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, index);
			}
		}

		function dragleave(event, index) {
			if (orderableSelection()) {
				set(draggingOver, false);
			}
		}

		function drop(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, false);

				let from = parseInt(event.dataTransfer.getData("source"));
				let to = index;

				if (from != to) {
					moveSelectedItem(from, to);
				}
			}
		}

		function moveSelectedItem(from, to) {
			let newSelection = [...selectedItem()];

			if (from < to) {
				newSelection.splice(to + 1, 0, newSelection[from]);
				newSelection.splice(from, 1);
			} else {
				newSelection.splice(to, 0, newSelection[from]);
				newSelection.splice(from + 1, 1);
			}

			selectedItem(newSelection);
		}

		function setScrollAwareListPosition() {
			const { height: viewPortHeight } = window.visualViewport;
			const { bottom: inputButtom, height: inputHeight } = get$2(inputContainer).getBoundingClientRect();
			const { height: listHeight } = get$2(list).getBoundingClientRect();

			if (inputButtom + listHeight > viewPortHeight) {
				mutate(list, get$2(list).style.top = `-${inputHeight + listHeight}px`);
			} else {
				mutate(list, get$2(list).style.top = "0px");
			}
		}

		legacy_pre_effect(
			() => (
				deep_read_state(items()),
				deep_read_state(searchFunction())
			),
			() => {
				(
					items(),
					searchFunction() || prepareListItems()
				);
			}
		);

		legacy_pre_effect(() => (deep_read_state(selectedItem())), () => {
			(
				selectedItem(),
				onSelectedItemChanged()
			);
		});

		legacy_pre_effect(
			() => (
				get$2(filteredListItems),
				get$2(highlightIndex)
			),
			() => {
				highlightedItem(get$2(filteredListItems) && get$2(highlightIndex) && get$2(highlightIndex) >= 0 && get$2(highlightIndex) < get$2(filteredListItems).length ? get$2(filteredListItems)[get$2(highlightIndex)].item : null);
			}
		);

		legacy_pre_effect(
			() => (
				get$2(opened),
				deep_read_state(items()),
				get$2(filteredTextLength)
			),
			() => {
				set(showList, get$2(opened) && (items() && items().length > 0 || get$2(filteredTextLength) > 0));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(multiple()),
				deep_read_state(selectedItem())
			),
			() => {
				set(hasSelection, multiple() && selectedItem() && selectedItem().length > 0 || !multiple() && selectedItem());
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(showClear()),
				deep_read_state(lock()),
				deep_read_state(multiple()),
				get$2(hasSelection)
			),
			() => {
				set(clearable, showClear() || (lock() || multiple()) && get$2(hasSelection));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(lock()),
				get$2(hasSelection)
			),
			() => {
				set(locked, lock() && get$2(hasSelection));
			}
		);

		legacy_pre_effect_reset();
		init();

		var div = root$s();

		event("click", $window, onDocumentClick);
		event("scroll", $window, () => set(setPositionOnNextUpdate, true));

		var select = child(div);
		var node = child(select);

		{
			var consequent = ($$anchor) => {
				var option = root_1$n();
				var option_value = {};
				var text_1 = child(option, true);

				template_effect(() => set_text(text_1, safeLabelFunction(selectedItem())));
				reset(option);

				template_effect(() => {
					if (option_value !== (option_value = valueFunction()(selectedItem(), true))) {
						option.value = null == (option.__value = valueFunction()(selectedItem(), true)) ? "" : valueFunction()(selectedItem(), true);
					}
				});

				append($$anchor, option);
			};

			var alternate = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 1, selectedItem, index$d, ($$anchor, i) => {
							var option_1 = root_4$c();
							var option_1_value = {};
							var text_2 = child(option_1, true);

							template_effect(() => set_text(text_2, safeLabelFunction(get$2(i))));
							reset(option_1);

							template_effect(() => {
								if (option_1_value !== (option_1_value = valueFunction()(get$2(i), true))) {
									option_1.value = null == (option_1.__value = valueFunction()(get$2(i), true)) ? "" : valueFunction()(get$2(i), true);
								}
							});

							append($$anchor, option_1);
						});

						append($$anchor, fragment_1);
					};

					if_block(
						node_1,
						($$render) => {
							if (multiple() && get$2(hasSelection)) $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment);
			};

			if_block(node, ($$render) => {
				if (!multiple() && get$2(hasSelection)) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(select);

		var div_1 = sibling(select, 2);
		var node_3 = child(div_1);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_2 = comment();
				var node_4 = first_child(fragment_2);

				each(node_4, 11, selectedItem, (tagItem) => valueFunction()(tagItem, true), ($$anchor, tagItem, i) => {
					var div_2 = root_6$9();

					set_attribute(div_2, "draggable", true);

					var node_5 = child(div_2);

					slot(
						node_5,
						$$props,
						"tag",
						{
							get label() {
								return safeLabelFunction(get$2(tagItem));
							},
							get item() {
								return get$2(tagItem);
							},
							unselectItem
						},
						($$anchor) => {
							var div_3 = root_7$3();
							var span = child(div_3);
							var text_3 = child(span, true);

							template_effect(() => set_text(text_3, safeLabelFunction(get$2(tagItem))));
							reset(span);

							var span_1 = sibling(span, 2);
							var event_handler = derived(() => unselectItem(get$2(tagItem)));

							reset(div_3);

							event("click", span_1, preventDefault(function (...$$args) {
								get$2(event_handler)?.apply(this, $$args);
							}));

							event("keypress", span_1, preventDefault((e) => {
								e.key == "Enter" && unselectItem(get$2(tagItem));
							}));

							append($$anchor, div_3);
						}
					);

					reset(div_2);
					template_effect(() => toggle_class(div_2, "is-active", get$2(draggingOver) === get$2(i)));
					animation(div_2, () => flip, () => ({ duration: 200 }));
					transition(3, div_2, () => fade, () => ({ duration: 200 }));
					event("dragstart", div_2, (event) => dragstart(event, get$2(i)));
					event("dragover", div_2, (event) => dragover(event, get$2(i)));
					event("dragleave", div_2, (event) => dragleave(event, get$2(i)));
					event("drop", div_2, (event) => drop(event, get$2(i)));
					append($$anchor, div_2);
				});

				append($$anchor, fragment_2);
			};

			if_block(node_3, ($$render) => {
				if (multiple() && get$2(hasSelection)) $$render(consequent_2);
			});
		}

		var input_1 = sibling(node_3, 2);

		remove_input_defaults(input_1);

		let attributes;

		bind_this(input_1, ($$value) => set(input, $$value), () => get$2(input));

		var node_6 = sibling(input_1, 2);

		{
			var consequent_3 = ($$anchor) => {
				var span_2 = root_8$2();
				var node_7 = child(span_2);

				html(node_7, clearText);
				reset(span_2);
				event("click", span_2, clear);

				event("keypress", span_2, (e) => {
					e.key == "Enter" && clear();
				});

				append($$anchor, span_2);
			};

			if_block(node_6, ($$render) => {
				if (get$2(clearable)) $$render(consequent_3);
			});
		}

		reset(div_1);
		bind_this(div_1, ($$value) => set(inputContainer, $$value), () => get$2(inputContainer));

		var div_4 = sibling(div_1, 2);
		var node_8 = child(div_4);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_3 = root_9$1();
				var node_9 = first_child(fragment_3);

				slot(
					node_9,
					$$props,
					"dropdown-header",
					{
						get nbItems() {
							return get$2(filteredListItems).length;
						},
						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					null
				);

				var node_10 = sibling(node_9, 2);

				each(node_10, 1, () => get$2(filteredListItems), index$d, ($$anchor, listItem, i) => {
					var fragment_4 = comment();
					var node_11 = first_child(fragment_4);

					{
						var consequent_5 = ($$anchor) => {
							var div_5 = root_11$3();
							const class_directive = derived_safe_equal(() => isConfirmed(get$2(listItem).item));

							template_effect(() => toggle_class(div_5, "confirmed", get$2(class_directive)));

							var node_12 = child(div_5);

							slot(
								node_12,
								$$props,
								"item",
								{
									get item() {
										return get$2(listItem).item;
									},
									get label() {
										return get$2(listItem).highlighted ? get$2(listItem).highlighted : get$2(listItem).label;
									}
								},
								($$anchor) => {
									var fragment_5 = comment();
									var node_13 = first_child(fragment_5);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_6 = comment();
											var node_14 = first_child(fragment_6);

											html(node_14, () => get$2(listItem).highlighted);
											append($$anchor, fragment_6);
										};

										var alternate_1 = ($$anchor) => {
											var fragment_7 = comment();
											var node_15 = first_child(fragment_7);

											html(node_15, () => get$2(listItem).label);
											append($$anchor, fragment_7);
										};

										if_block(node_13, ($$render) => {
											if (get$2(listItem).highlighted) $$render(consequent_4); else $$render(alternate_1, false);
										});
									}

									append($$anchor, fragment_5);
								}
							);

							reset(div_5);
							template_effect(() => toggle_class(div_5, "selected", i === get$2(highlightIndex)));
							event("click", div_5, () => onListItemClick(get$2(listItem)));

							event("keypress", div_5, (e) => {
								e.key == "Enter" && onListItemClick(get$2(listItem));
							});

							event("pointerenter", div_5, () => {
								set(highlightIndex, i);
							});

							append($$anchor, div_5);
						};

						if_block(node_11, ($$render) => {
							if (get$2(listItem) && (maxItemsToShowInList() <= 0 || i < maxItemsToShowInList())) $$render(consequent_5);
						});
					}

					append($$anchor, fragment_4);
				});

				var node_16 = sibling(node_10, 2);

				slot(
					node_16,
					$$props,
					"dropdown-footer",
					{
						get nbItems() {
							return get$2(filteredListItems).length;
						},
						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					($$anchor) => {
						var fragment_8 = comment();
						var node_17 = first_child(fragment_8);

						{
							var consequent_7 = ($$anchor) => {
								var fragment_9 = comment();
								var node_18 = first_child(fragment_9);

								{
									var consequent_6 = ($$anchor) => {
										var div_6 = root_17();
										var text_4 = child(div_6);

										reset(div_6);

										template_effect(() => set_text(text_4, `...${get$2(filteredListItems).length - maxItemsToShowInList() ?? ""}
              ${moreItemsText() ?? ""}`));

										append($$anchor, div_6);
									};

									if_block(node_18, ($$render) => {
										if (moreItemsText()) $$render(consequent_6);
									});
								}

								append($$anchor, fragment_9);
							};

							if_block(node_17, ($$render) => {
								if (maxItemsToShowInList() > 0 && get$2(filteredListItems).length > maxItemsToShowInList()) $$render(consequent_7);
							});
						}

						append($$anchor, fragment_8);
					}
				);

				append($$anchor, fragment_3);
			};

			var alternate_4 = ($$anchor) => {
				var fragment_10 = comment();
				var node_19 = first_child(fragment_10);

				{
					var consequent_9 = ($$anchor) => {
						var div_7 = root_19$1();
						var node_20 = child(div_7);

						slot(
							node_20,
							$$props,
							"loading",
							{
								get loadingText() {
									return loadingText();
								}
							},
							($$anchor) => {
								var text_5 = text();

								template_effect(() => set_text(text_5, loadingText()));
								append($$anchor, text_5);
							}
						);

						reset(div_7);
						append($$anchor, div_7);
					};

					var alternate_3 = ($$anchor) => {
						var fragment_12 = comment();
						var node_21 = first_child(fragment_12);

						{
							var consequent_10 = ($$anchor) => {
								var div_8 = root_22$1();
								var node_22 = child(div_8);

								slot(
									node_22,
									$$props,
									"create",
									{
										get createText() {
											return createText();
										}
									},
									($$anchor) => {
										var text_6 = text();

										template_effect(() => set_text(text_6, createText()));
										append($$anchor, text_6);
									}
								);

								reset(div_8);
								event("click", div_8, selectItem);

								event("keypress", div_8, (e) => {
									e.key == "Enter" && selectItem();
								});

								append($$anchor, div_8);
							};

							var alternate_2 = ($$anchor) => {
								var fragment_14 = comment();
								var node_23 = first_child(fragment_14);

								{
									var consequent_11 = ($$anchor) => {
										var div_9 = root_25();
										var node_24 = child(div_9);

										slot(
											node_24,
											$$props,
											"no-results",
											{
												get noResultsText() {
													return noResultsText();
												}
											},
											($$anchor) => {
												var text_7 = text();

												template_effect(() => set_text(text_7, noResultsText()));
												append($$anchor, text_7);
											}
										);

										reset(div_9);
										append($$anchor, div_9);
									};

									if_block(
										node_23,
										($$render) => {
											if (noResultsText()) $$render(consequent_11);
										},
										true
									);
								}

								append($$anchor, fragment_14);
							};

							if_block(
								node_21,
								($$render) => {
									if (create()) $$render(consequent_10); else $$render(alternate_2, false);
								},
								true
							);
						}

						append($$anchor, fragment_12);
					};

					if_block(
						node_19,
						($$render) => {
							if (get$2(loading) && loadingText()) $$render(consequent_9); else $$render(alternate_3, false);
						},
						true
					);
				}

				append($$anchor, fragment_10);
			};

			if_block(node_8, ($$render) => {
				if (get$2(filteredListItems) && get$2(filteredListItems).length > 0) $$render(consequent_8); else $$render(alternate_4, false);
			});
		}

		reset(div_4);
		bind_this(div_4, ($$value) => set(list, $$value), () => get$2(list));
		reset(div);

		template_effect(() => {
			set_class(div, `${(className() ? className() : '') ?? ""} autocomplete select is-fullwidth ${uniqueId ?? ""} svelte-75ckfb`);
			toggle_class(div, "hide-arrow", hideArrow() || !items().length);
			toggle_class(div, "is-multiple", multiple());
			toggle_class(div, "show-clear", get$2(clearable));
			toggle_class(div, "is-loading", showLoadingIndicator() && get$2(loading));
			set_attribute(select, "name", selectName());
			set_attribute(select, "id", selectId());
			select.multiple = multiple();

			attributes = set_attributes(
				input_1,
				attributes,
				{
					type: "text",
					class: `${(inputClassName() ? inputClassName() : '') ?? ""} ${(noInputStyles() ? '' : 'input autocomplete-input') ?? ""}`,
					id: inputId() ? inputId() : "",
					autocomplete: html5autocomplete() ? "on" : autocompleteOffValue(),
					placeholder: placeholder(),
					name: name(),
					disabled: disabled(),
					required: required(),
					title: title(),
					readonly: readonly() || get$2(locked),
					tabindex: tabindex(),
					...$$restProps
				},
				"svelte-75ckfb"
			);

			set_class(div_4, `${(dropdownClassName() ? dropdownClassName() : '') ?? ""} autocomplete-list ${(get$2(showList) ? '' : 'hidden') ?? ""}
    is-fullwidth svelte-75ckfb`);
		});

		bind_value(input_1, text$1);
		event("input", input_1, onInput);
		event("focus", input_1, onFocusInternal);
		event("blur", input_1, onBlurInternal);
		event("keydown", input_1, onKeyDown);
		event("click", input_1, onInputClick);
		event("keypress", input_1, onKeyPress);
		event("dragover", input_1, (event) => dragover(event, selectedItem().length - 1));
		event("drop", input_1, (event) => drop(event, selectedItem().length - 1));
		append($$anchor, div);
		bind_prop($$props, "highlightFilter", highlightFilter);
		return pop({ highlightFilter });
	}

	var root_3$b = template(`<p> </p>`);

	function Ui_autocomplete($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [idField]
		 * @property {string} [labelField]
		 * @property {number} [minCharactersToSearch]
		 * @property {boolean} [selectFirstIfEmpty]
		 * @property {number} [maxItemsToShowInList]
		 * @property {string} [noResultsText]
		 * @property {boolean} [showClear]
		 * @property {any} value
		 * @property {string} [placeholder]
		 * @property {string} [fieldname]
		 * @property {boolean} [disabled]
		 * @property {boolean} [readonly]
		 * @property {boolean} [icon]
		 * @property {boolean} [inputStarted]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {any} [searchFunction]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 15),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "checkbox-list"),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			required = prop($$props, "required", 3, false),
			valid = prop($$props, "valid", 3, true),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"fieldname",
				"disabled",
				"readonly",
				"required",
				"valid",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var value_1 = derived(() => value() ? value().title : "");

				Ui_textfield($$anchor, spread_props(
					{
						get value() {
							return get$2(value_1);
						},
						get fieldname() {
							return fieldname();
						},
						get placeholder() {
							return placeholder();
						}
					},
					() => others
				));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var p = root_3$b();
						var text = child(p, true);

						reset(p);
						template_effect(() => set_text(text, value() ? value().title : ""));
						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						SimpleAutocomplete($$anchor, spread_props(
							{
								onChange: oninput,
								get valid() {
									return valid();
								},
								get invalid() {
									return get$2(invalid);
								},
								get required() {
									return required();
								},
								get placeholder() {
									return $LOCALE()[placeholder()];
								}
							},
							() => others,
							{
								get selectedItem() {
									return value();
								},
								set selectedItem($$value) {
									value($$value);
								}
							}
						));
					};

					if_block(
						node_1,
						($$render) => {
							if (readonly()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (disabled()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$m = template(`<p><time> </time></p>`);
	var root_2$h = template(`<input>`);

	function Ui_date($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 31, () => proxy(new Date())),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "datetime"),
			pattern = prop($$props, "pattern", 3, "d{4}-d{2}-d{2}"),
			required = prop($$props, "required", 3, true),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"fieldname",
				"pattern",
				"required",
				"disabled",
				"readonly",
				"valid",
				"class",
				"onchange"
			]);

		onMount(() => {
			if (value() instanceof Date) {
				value(value().toISOString().split("T")[0]);
			} else if (value().indexOf("T") > 0) {
				value(value().split("T")[0]);
			}
		});

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$m();
				var time = child(p);
				var text = child(time, true);

				template_effect(() => set_text(text, UICommon$1.tryFormatLocaleDateTime(value())));
				reset(time);
				reset(p);
				template_effect(() => set_attribute(time, "datetime", value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$h();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-date-${fieldname() ?? ""}`,
					class: `input ${classes() ?? ""}`,
					type: "date",
					name: fieldname(),
					invalid: get$2(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					pattern: pattern(),
					autocomplete: fieldname(),
					onchange: oninput,
					oninput,
					"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
					"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_2$g = template(`<p> </p>`);
	var root_3$a = template(`<input>`);

	function Ui_datetime_in_tz($$anchor, $$props) {
		push($$props, true);

		function removeMsFromDate(isoDate, markAsZULU = false) {
			return isoDate.split(".")[0] + (markAsZULU ? "" : "Z");
		}

		function shiftDatetime(isoDate, shift) {
			try {
				const dateUtc = new Date(markAsZULU(isoDate)).getTime();
				const offset = shift * -60000;

				if (dateIsValid(dateUtc + offset)) {
					const newDate = new Date(dateUtc + offset);
					const newIsoDate = newDate.toISOString();

					return removeMsFromDate(newIsoDate, true);
				}
			} catch {
				return;
			}
		}

		function markAsZULU(dateString) {
			return dateString && dateString.at(-1) !== "Z" ? dateString + "Z" : dateString;
		}

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, "fieldname", 3, "datetime"),
			value = prop($$props, "value", 31, () => proxy(removeMsFromDate(new Date().toISOString()))),
			timezoneOffset = prop($$props, "timezoneOffset", 3, 0),
			required = prop($$props, "required", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"fieldname",
				"value",
				"timezoneOffset",
				"required",
				"disabled",
				"readonly",
				"valid",
				"class",
				"onchange"
			]);

		let shiftedValue = state(undefined),
			prevShiftedValue;

		const setShifted = (val) => {
			if (dateIsValid(val)) {
				prevShiftedValue = get$2(shiftedValue);
				set(shiftedValue, proxy(val));
			}
		};

		const resetShiftedValue = () => {
			set(shiftedValue, proxy(prevShiftedValue));
		};

		onMount(() => {
			setShifted(shiftDatetime(value(), timezoneOffset()));
		});

		const dateIsValid = (date) => {
			try {
				new Date(date);
				return true;
			} catch {
				return false;
			}
		};

		const changed = () => value() !== shiftDatetime(get$2(shiftedValue), -timezoneOffset());

		const dispatchChange = () => {
			setShifted(get$2(shiftedValue));
			value(markAsZULU(shiftDatetime(get$2(shiftedValue), -timezoneOffset())));
			onchange()({ field: fieldname(), value: value() });
		};

		function onChange(ev) {
			if (ev.currentTarget.value && get$2(shiftedValue) && dateIsValid(get$2(shiftedValue))) {
				if (changed()) {
					dispatchChange();
				}

				return true;
			} else {
				resetShiftedValue();
			}

			return false;
		}

		let invalid = derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var p = root_2$g();
						var text = child(p, true);

						reset(p);
						template_effect(() => set_text(text, get$2(shiftedValue)));
						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						var input = root_3$a();

						remove_input_defaults(input);

						let attributes;

						template_effect(() => attributes = set_attributes(input, attributes, {
							id: `form-field-datetime-in-timezone-${fieldname() ?? ""}`,
							class: `input ${classes() ?? ""}`,
							type: "datetime-local",
							name: fieldname(),
							invalid: get$2(invalid),
							disabled: disabled(),
							required: required(),
							readonly: readonly(),
							autocomplete: fieldname(),
							onchange: onChange,
							onblur: onChange,
							oninput: onChange,
							"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
							"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
							...others
						}));

						bind_value(input, () => get$2(shiftedValue), ($$value) => set(shiftedValue, $$value));
						append($$anchor, input);
					};

					if_block(node_1, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$2(shiftedValue)) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$l = template(`<p> </p>`);
	var root_2$f = template(`<input>`);

	function Ui_email($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, ""),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "email"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"fieldname",
				"required",
				"readonly",
				"disabled",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$l();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$f();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-email-${fieldname() ?? ""}`,
					class: `input ${classes() ?? ""}`,
					type: "email",
					name: fieldname(),
					invalid: get$2(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					onchange: oninput,
					oninput,
					"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
					"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$r = template(`<input type="hidden">`);

	function Ui_hidden($$anchor, $$props) {
		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, ""),
			fieldname = prop($$props, "fieldname", 3, "hidden"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"fieldname",
				"required",
				"readonly"
			]);

		var input = root$r();

		remove_input_defaults(input);

		template_effect(() => {
			set_attribute(input, "id", `form-field-hidden-${fieldname() ?? ""}`);
			input.required = required();
			input.readOnly = readonly();
			set_attribute(input, "name", fieldname());
			set_attribute(input, "others", others);
		});

		bind_value(input, value);
		append($$anchor, input);
	}

	var root_1$k = template(`<p> </p>`);
	var root_2$e = template(`<textarea></textarea>`);

	function Ui_textarea($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, ""),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "textarea"),
			rows = prop($$props, "rows", 3, 10),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"fieldname",
				"rows",
				"required",
				"readonly",
				"disabled",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$k();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var textarea = root_2$e();

				remove_textarea_child(textarea);

				let attributes;

				template_effect(() => attributes = set_attributes(textarea, attributes, {
					id: `form-field-textarea-${fieldname() ?? ""}`,
					class: `textarea ${classes() ?? ""}`,
					name: fieldname(),
					invalid: get$2(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					onblur: oninput,
					placeholder: $LOCALE()[placeholder()],
					rows: rows(),
					"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
					"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
					...others
				}));

				bind_value(textarea, value);
				append($$anchor, textarea);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_json_area($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 31, () => proxy({})),
			fieldname = prop($$props, "fieldname", 3, "jsonarea"),
			valid = prop($$props, "valid", 15, true),
			onchange = prop($$props, "onchange", 3, () => true),
			onerror = prop($$props, "onerror", 3, () => {}),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"fieldname",
				"valid",
				"onchange",
				"onerror"
			]);

		let _value = state("{}");

		onMount(() => {
			try {
				set(_value, proxy(JSON.stringify(value(), null, 4)));
			} catch {
				set(_value, "{}");
			}
		});

		function onChange({ value: val }) {
			try {
				value(JSON.parse(val));
				valid(true);
				onchange()({ field: fieldname(), value: value() });
			} catch(error) {
				onerror()(error.message);
			}

			return true;
		}

		Ui_textarea($$anchor, spread_props(
			{
				onchange: onChange,
				get valid() {
					return valid();
				}
			},
			() => others,
			{
				get value() {
					return get$2(_value);
				},
				set value($$value) {
					set(_value, proxy($$value));
				}
			}
		));

		pop();
	}

	var _lib = /*#__PURE__*/new WeakMap();
	let Lib = /*#__PURE__*/function () {
	  function Lib(seedLib) {
	    _classCallCheck(this, Lib);
	    _classPrivateFieldInitSpec(this, _lib, {});
	    if (seedLib instanceof Lib) {
	      this.import(seedLib.getContent());
	    }
	  }

	  /**
	   *
	   * @params {string}  mode what to do if element exists [replace|add|skip]
	   */
	  return _createClass(Lib, [{
	    key: "add",
	    value: function add(name, comp, mode = "replace") {
	      if (this.contains(name)) {
	        if (mode === "replace") {
	          _classPrivateFieldGet2(_lib, this)[name] = comp;
	        } else if (mode === "add") {
	          _classPrivateFieldGet2(_lib, this)[name] = Object.assign(_classPrivateFieldGet2(_lib, this)[name], comp);
	        }
	      } else {
	        _classPrivateFieldGet2(_lib, this)[name] = comp;
	      }
	    }
	  }, {
	    key: "get",
	    value: function get(name) {
	      return _classPrivateFieldGet2(_lib, this)[name];
	    }
	  }, {
	    key: "contains",
	    value: function contains(name) {
	      return Object.hasOwn(_classPrivateFieldGet2(_lib, this), name);
	    }
	  }, {
	    key: "import",
	    value: function _import(bulk, mode = "replace") {
	      for (let f in bulk) {
	        this.add(f, bulk[f], mode);
	      }
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return Object.keys(_classPrivateFieldGet2(_lib, this)).length === 0;
	    }
	  }, {
	    key: "getContent",
	    value: function getContent() {
	      return {
	        ..._classPrivateFieldGet2(_lib, this)
	      };
	    }
	  }]);
	}();

	/*
	 * Библиотека UI конструкторов
	 */

	const COMPONENTS$1 = new Lib();
	const FIELDS$1 = new Lib();
	const VARIANTS$1 = new Lib();

	function Ui_list_empty_placeholder($$anchor) {
		Ui_title($$anchor, {
			title: "not-node:empty_list_placeholder",
			size: 4,
			align: "center"
		});
	}

	var root_1$j = template(`<span class="icon"><i></i></span>`);
	var root_4$b = template(`<span> </span>`);
	var root_2$d = template(`<!> <!> <!> <!>`, 1);
	var root_6$8 = template(` <!>`, 1);
	var root$q = template(`<a><!></a>`);

	function Ui_link($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		const sideIcon = ($$anchor) => {
			var span = root_1$j();
			var i = child(span);

			reset(span);
			template_effect(() => set_class(i, `fas fa-${$$props.icon ?? ""} ${(size() ? `is-${size()}` : '') ?? ""}`));
			append($$anchor, span);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [title] - attributes
		 * @property {string} [url]
		 * @property {any} download
		 * @property {string} [target]
		 * @property {any} rel
		 * @property {boolean} [light] - visual
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [button]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon] - icons
		 * @property {string} [iconSide]
		 * @property {any} [action]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, "title", 3, ""),
			url = prop($$props, "url", 3, ""),
			target = prop($$props, "target", 3, "_blank"),
			light = prop($$props, "light", 3, false),
			loading = prop($$props, "loading", 3, false),
			raised = prop($$props, "raised", 3, false),
			outlined = prop($$props, "outlined", 3, false),
			inverted = prop($$props, "inverted", 3, false),
			rounded = prop($$props, "rounded", 3, false),
			button = prop($$props, "button", 3, true),
			activeState = prop($$props, "state", 3, ""),
			type = prop($$props, "type", 3, ""),
			color = prop($$props, "color", 3, ""),
			size = prop($$props, "size", 3, ""),
			classes = prop($$props, "class", 3, ""),
			iconSide = prop($$props, "iconSide", 3, "right");

		var a = root$q();

		a.__click = function (...$$args) {
			($$props.action || $$props.onclick)?.apply(this, $$args);
		};

		var node = child(a);

		{
			var consequent_3 = ($$anchor) => {
				var fragment = root_2$d();
				var node_1 = first_child(fragment);

				{
					var consequent = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_1, ($$render) => {
						if (iconSide() === "left") $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						var span_1 = root_4$b();
						var text = child(span_1, true);

						reset(span_1);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span_1);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_1);
					});
				}

				var node_3 = sibling(node_2, 2);

				snippet(node_3, () => $$props.children ?? noop);

				var node_4 = sibling(node_3, 2);

				{
					var consequent_2 = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_4, ($$render) => {
						if (iconSide() === "right") $$render(consequent_2);
					});
				}

				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = root_6$8();
				var text_1 = first_child(fragment_3, true);
				var node_5 = sibling(text_1);

				snippet(node_5, () => $$props.children ?? noop);
				template_effect(() => set_text(text_1, $LOCALE()[title()]));
				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if ($$props.icon) $$render(consequent_3); else $$render(alternate, false);
			});
		}

		reset(a);

		template_effect(() => {
			set_attribute(a, "href", url());
			set_attribute(a, "target", target());
			set_attribute(a, "download", $$props.download);
			set_attribute(a, "rel", $$props.rel);
			set_class(a, `${classes() ?? ""} ${(activeState() ? `is-${activeState()}` : '') ?? ""} ${(color() ? `is-${color()}` : '') ?? ""} ${(type() ? `is-${type()}` : '') ?? ""} ${(size() ? `is-${size()}` : '') ?? ""}`);
			toggle_class(a, "button", button());
			toggle_class(a, "is-light", light());
			toggle_class(a, "is-inverted", inverted());
			toggle_class(a, "is-outlined", outlined());
			toggle_class(a, "is-raised", raised());
			toggle_class(a, "is-rounded", rounded());
			toggle_class(a, "is-loading", loading());
		});

		append($$anchor, a);
		pop();
	}

	delegate(["click"]);

	var root_3$9 = template(`<div><p class="control"><!></p></div>`);
	var root_4$a = template(`<div><!></div>`);

	function Ui_links($$anchor, $$props) {
		const listLinks = ($$anchor) => {
			var fragment = comment();
			var node = first_child(fragment);

			each(node, 17, values, (item) => item.id, ($$anchor, item) => {
				Ui_link($$anchor, spread_props(() => get$2(item), itemsProps));
			});

			append($$anchor, fragment);
		};

		/**
		 * @typedef {Object} Props
		 * @property {array}  [values=[]]
		 * @property {string} [classes='']
		 * @property {boolean} [centered=false]
		 * @property {boolean} [right=false]
		 * @property {boolean} [joined = false]
		 * @property {object}   [itemsProps = {}]
		 */
		/** @type {Props} */
		let values = prop($$props, "values", 19, () => []),
			classes = prop($$props, "class", 3, ""),
			centered = prop($$props, "centered", 3, false),
			right = prop($$props, "right", 3, false),
			joined = prop($$props, "joined", 3, true),
			itemsProps = prop($$props, "itemsProps", 19, () => ({}));

		var fragment_2 = comment();
		var node_1 = first_child(fragment_2);

		{
			var consequent = ($$anchor) => {
				var div = root_3$9();
				var p = child(div);
				var node_2 = child(p);

				listLinks(node_2);
				reset(p);
				reset(div);

				template_effect(() => {
					set_class(div, `field has-addons ${classes() ?? ""}`);
					toggle_class(div, "is-centered", centered());
					toggle_class(div, "is-right", right());
				});

				append($$anchor, div);
			};

			var alternate = ($$anchor) => {
				var div_1 = root_4$a();
				var node_3 = child(div_1);

				listLinks(node_3);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, `buttons ${classes() ?? ""}`);
					toggle_class(div_1, "is-centered", centered());
					toggle_class(div_1, "is-right", right());
				});

				append($$anchor, div_1);
			};

			if_block(node_1, ($$render) => {
				if (joined()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment_2);
	}

	var on_keyup = (e, onClick) => {
		if (e && e.key == "Enter") {
			onClick();
		}
	};

	var on_keyup_1 = (e, onClick, onclickImage, $$props) => {
		e.preventDefault();

		if (e && e.key == "Enter") {
			onClick();
			onclickImage()($$props.value);
		}
	};

	var on_click = (e, onClick, onclickImage, $$props) => {
		e.preventDefault();
		onClick();
		onclickImage()($$props.value);
	};

	var root_5$6 = template(`<figure class="image is-64x64"><img class="is-rounded"></figure>`);
	var root_1$i = template(`<div role="button" tabindex="0" class="list-item-image"><!></div>`);

	var on_click_1 = (e, onClick, onclickContent, $$props) => {
		e.preventDefault();
		onClick();
		onclickContent()($$props.value);
	};

	var on_keyup_2 = (e, onClick, onclickContent, $$props) => {
		e.preventDefault();

		if (e && e.key == "Enter") {
			onClick();
			onclickContent()($$props.value);
		}
	};

	var on_keyup_3 = (e, onClick, onclickTitle, $$props) => {
		e.preventDefault();

		if (e && e.key == "Enter") {
			onClick();
			onclickTitle()($$props.value);
		}
	};

	var on_click_2 = (e, onClick, onclickTitle, $$props) => {
		e.preventDefault();
		onClick();
		onclickTitle()($$props.value);
	};

	var root_6$7 = template(`<div class="list-item-title" role="button" tabindex="0"><!></div>`);

	var on_keyup_4 = (e, onClick, onclickDescription, $$props) => {
		e.preventDefault();

		if (e && e.key == "Enter") {
			onClick();
			onclickDescription()($$props.value);
		}
	};

	var on_click_3 = (e, onClick, onclickDescription, $$props) => {
		e.preventDefault();
		onClick();
		onclickDescription()($$props.value);
	};

	var root_11$2 = template(`<div role="button" tabindex="0" class="list-item-description"><!></div>`);
	var root_16 = template(`<div class="list-item-controls"><!> <!></div>`);
	var root$p = template(`<div role="button" tabindex="0"><!> <div role="button" tabindex="0" class="list-item-content"><!> <!></div> <!></div>`);

	function Ui_list_item($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} title
		 * @property {any} description
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {any} [listActions]
		 * @property {any} [listLinks]
		 * @property {string} [classes]
		 * @property {string} [commonClasses]
		 * @property {string} [image]
		 * @property {any} value - value of item, will be passed to event handlers
		 * @property {any} [index] - index in array 0-length
		 * @property {boolean} [first] - if first
		 * @property {boolean} [last] - if last
		 * @property {any} [titleComponent] - customization
		 * @property {any} [titleComponentProps]
		 * @property {any} descriptionComponent
		 * @property {any} [descriptionComponentProps]
		 * @property {any} imageComponent
		 * @property {any} [imageComponentProps]
		 */
		/** @type {Props} */
		let actions = prop($$props, "actions", 19, () => []),
			links = prop($$props, "links", 19, () => []),
			listActions = prop($$props, "listActions", 19, () => []),
			listLinks = prop($$props, "listLinks", 19, () => []),
			classes = prop($$props, "classes", 3, ""),
			commonClasses = prop($$props, "commonClasses", 3, ""),
			image = prop($$props, "image", 3, ""),
			index = prop($$props, "index", 19, () => -1),
			first = prop($$props, "first", 3, false),
			last = prop($$props, "last", 3, false),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({})),
			onclickImage = prop($$props, "onclickImage", 3, () => false),
			onclickContent = prop($$props, "onclickContent", 3, () => false),
			onclickTitle = prop($$props, "onclickTitle", 3, () => false),
			onclickDescription = prop($$props, "onclickDescription", 3, () => false);

		function onClick() {
			onclick($$props.value);
		}

		let allActions = state(proxy([]));
		let allLinks = state(proxy([]));

		onMount(() => {
			set(allActions, proxy([...actions(), ...listActions()].map((btn) => {
				return {
					...btn,
					action: () => btn.action($$props.value)
				};
			})));

			set(allLinks, proxy([...links(), ...listLinks()]));
		});

		var div = root$p();

		div.__click = onClick;
		div.__keyup = [on_keyup, onClick];

		var node = child(div);

		{
			var consequent_2 = ($$anchor) => {
				var div_1 = root_1$i();

				div_1.__keyup = [on_keyup_1, onClick, onclickImage, $$props];
				div_1.__click = [on_click, onClick, onclickImage, $$props];

				var node_1 = child(div_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment = comment();
						var node_2 = first_child(fragment);

						{
							var consequent = ($$anchor) => {
								var fragment_1 = comment();
								const SvelteComponent = derived(() => $$props.imageComponent);
								var node_3 = first_child(fragment_1);

								component(node_3, () => get$2(SvelteComponent), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get value() {
												return image();
											}
										},
										imageComponentProps
									));
								});

								append($$anchor, fragment_1);
							};

							var alternate = ($$anchor) => {
								var fragment_2 = comment();
								const SvelteComponent_1 = derived(() => $$props.imageComponent);
								var node_4 = first_child(fragment_2);

								component(node_4, () => get$2(SvelteComponent_1), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(image, imageComponentProps));
								});

								append($$anchor, fragment_2);
							};

							if_block(node_2, ($$render) => {
								if (typeof image() === "string") $$render(consequent); else $$render(alternate, false);
							});
						}

						append($$anchor, fragment);
					};

					var alternate_1 = ($$anchor) => {
						var figure = root_5$6();
						var img = child(figure);

						reset(figure);

						template_effect(() => {
							set_attribute(img, "src", image());
							set_attribute(img, "alt", $$props.title);
						});

						append($$anchor, figure);
					};

					if_block(node_1, ($$render) => {
						if ($$props.imageComponent) $$render(consequent_1); else $$render(alternate_1, false);
					});
				}

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node, ($$render) => {
				if (image()) $$render(consequent_2);
			});
		}

		var div_2 = sibling(node, 2);

		div_2.__click = [
			on_click_1,
			onClick,
			onclickContent,
			$$props
		];

		div_2.__keyup = [
			on_keyup_2,
			onClick,
			onclickContent,
			$$props
		];

		var node_5 = child(div_2);

		{
			var consequent_5 = ($$anchor) => {
				var div_3 = root_6$7();

				div_3.__keyup = [on_keyup_3, onClick, onclickTitle, $$props];
				div_3.__click = [on_click_2, onClick, onclickTitle, $$props];

				var node_6 = child(div_3);

				{
					var consequent_4 = ($$anchor) => {
						var fragment_3 = comment();
						var node_7 = first_child(fragment_3);

						{
							var consequent_3 = ($$anchor) => {
								var fragment_4 = comment();
								const SvelteComponent_2 = derived(titleComponent);
								var node_8 = first_child(fragment_4);

								component(node_8, () => get$2(SvelteComponent_2), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get title() {
												return $$props.title;
											}
										},
										titleComponentProps,
										{ onchange }
									));
								});

								append($$anchor, fragment_4);
							};

							var alternate_2 = ($$anchor) => {
								var fragment_5 = comment();
								const SvelteComponent_3 = derived(titleComponent);
								var node_9 = first_child(fragment_5);

								component(node_9, () => get$2(SvelteComponent_3), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(() => $$props.title, titleComponentProps, { onchange }));
								});

								append($$anchor, fragment_5);
							};

							if_block(node_7, ($$render) => {
								if (typeof $$props.title === "string") $$render(consequent_3); else $$render(alternate_2, false);
							});
						}

						append($$anchor, fragment_3);
					};

					var alternate_3 = ($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, $$props.title));
						append($$anchor, text$1);
					};

					if_block(node_6, ($$render) => {
						if (titleComponent()) $$render(consequent_4); else $$render(alternate_3, false);
					});
				}

				reset(div_3);
				append($$anchor, div_3);
			};

			if_block(node_5, ($$render) => {
				if ($$props.title) $$render(consequent_5);
			});
		}

		var node_10 = sibling(node_5, 2);

		{
			var consequent_8 = ($$anchor) => {
				var div_4 = root_11$2();

				div_4.__keyup = [
					on_keyup_4,
					onClick,
					onclickDescription,
					$$props
				];

				div_4.__click = [
					on_click_3,
					onClick,
					onclickDescription,
					$$props
				];

				var node_11 = child(div_4);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_7 = comment();
						var node_12 = first_child(fragment_7);

						{
							var consequent_6 = ($$anchor) => {
								var fragment_8 = comment();
								const SvelteComponent_4 = derived(() => $$props.descriptionComponent);
								var node_13 = first_child(fragment_8);

								component(node_13, () => get$2(SvelteComponent_4), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get value() {
												return $$props.description;
											}
										},
										descriptionComponentProps,
										{ onchange, onclick }
									));
								});

								append($$anchor, fragment_8);
							};

							var alternate_4 = ($$anchor) => {
								var fragment_9 = comment();
								const SvelteComponent_5 = derived(() => $$props.descriptionComponent);
								var node_14 = first_child(fragment_9);

								component(node_14, () => get$2(SvelteComponent_5), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(() => $$props.description, descriptionComponentProps, { onchange, onclick }));
								});

								append($$anchor, fragment_9);
							};

							if_block(node_12, ($$render) => {
								if (typeof $$props.description === "string") $$render(consequent_6); else $$render(alternate_4, false);
							});
						}

						append($$anchor, fragment_7);
					};

					var alternate_5 = ($$anchor) => {
						var text_1 = text();

						template_effect(() => set_text(text_1, $$props.description));
						append($$anchor, text_1);
					};

					if_block(node_11, ($$render) => {
						if ($$props.descriptionComponent) $$render(consequent_7); else $$render(alternate_5, false);
					});
				}

				reset(div_4);
				append($$anchor, div_4);
			};

			if_block(node_10, ($$render) => {
				if ($$props.description) $$render(consequent_8);
			});
		}

		reset(div_2);

		var node_15 = sibling(div_2, 2);

		{
			var consequent_11 = ($$anchor) => {
				var div_5 = root_16();
				var node_16 = child(div_5);

				{
					var consequent_9 = ($$anchor) => {
						Ui_buttons($$anchor, {
							get values() {
								return get$2(allActions);
							},
							right: true
						});
					};

					if_block(node_16, ($$render) => {
						if (get$2(allActions) && get$2(allActions).length) $$render(consequent_9);
					});
				}

				var node_17 = sibling(node_16, 2);

				{
					var consequent_10 = ($$anchor) => {
						Ui_links($$anchor, {
							get values() {
								return get$2(allLinks);
							},
							right: true
						});
					};

					if_block(node_17, ($$render) => {
						if (get$2(allLinks) && get$2(allLinks).length) $$render(consequent_10);
					});
				}

				reset(div_5);
				append($$anchor, div_5);
			};

			if_block(node_15, ($$render) => {
				if (get$2(allActions) && get$2(allActions).length || get$2(allLinks) && get$2(allLinks).length) $$render(consequent_11);
			});
		}

		reset(div);
		template_effect(() => set_class(div, `list-item ${classes() ?? ""} ${commonClasses() ?? ""} ${(last() ? 'list-item-last' : '') ?? ""} ${(first() ? 'list-item-first' : '') ?? ""}  ${`list-item-at-${index()}` ?? ""} ${`list-item-` + (index() % 2 ? 'odd' : 'even') ?? ""}`));
		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	function Ui_list_block($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [idFieldName]
		 * @property {any} [items]
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {string} [itemClasses]
		 * @property {any} [listItemComponent]
		 * @property {any} [listItemComponentProps]
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} descriptionComponent
		 * @property {any} [descriptionComponentProps]
		 * @property {any} imageComponent
		 * @property {any} [imageComponentProps]
		 */
		/** @type {Props} */
		let idFieldName = prop($$props, "idFieldName", 3, "id"),
			items = prop($$props, "items", 23, () => []),
			actions = prop($$props, "actions", 19, () => []),
			links = prop($$props, "links", 19, () => []),
			itemClasses = prop($$props, "itemClasses", 3, ""),
			listItemComponent = prop($$props, "listItemComponent", 3, Ui_list_item),
			listItemComponentProps = prop($$props, "listItemComponentProps", 19, () => ({})),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				const SvelteComponent = derived(listItemComponent);
				var node_1 = first_child(fragment_1);

				each(node_1, 19, items, (item) => item[idFieldName()], ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);
					var first = derived(() => get$2(index) === 0);
					var last = derived(() => get$2(index) === items().length - 1);

					component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
						$$component($$anchor, spread_props(
							listItemComponentProps,
							{
								get titleComponent() {
									return titleComponent();
								},
								get titleComponentProps() {
									return titleComponentProps();
								},
								get descriptionComponent() {
									return $$props.descriptionComponent;
								},
								get descriptionComponentProps() {
									return descriptionComponentProps();
								},
								get imageComponent() {
									return $$props.imageComponent;
								},
								get imageComponentProps() {
									return imageComponentProps();
								}
							},
							() => get$2(item),
							{
								get listActions() {
									return actions();
								},
								get listLinks() {
									return links();
								},
								get commonClasses() {
									return itemClasses();
								},
								get index() {
									return get$2(index);
								},
								get first() {
									return get$2(first);
								},
								get last() {
									return get$2(last);
								},
								get value() {
									return items()[get$2(index)];
								},
								set value($$value) {
									items()[get$2(index)] = $$value;
								},
								$$events: {
									click($$arg) {
										bubble_event.call(this, $$props, $$arg);
									},
									clickContent($$arg) {
										bubble_event.call(this, $$props, $$arg);
									},
									clickDescription($$arg) {
										bubble_event.call(this, $$props, $$arg);
									},
									clickImage($$arg) {
										bubble_event.call(this, $$props, $$arg);
									},
									clickTitle($$arg) {
										bubble_event.call(this, $$props, $$arg);
									}
								}
							}
						));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$h = template(`<div><!></div>`);

	function Ui_list($$anchor, $$props) {
		push($$props, true);

		//customization
		/**
		 * @typedef {Object} Props
		 * @property {string} [classes]
		 * @property {any} [items]
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {boolean} [actionsVisible]
		 * @property {boolean} [itemsHoverable]
		 * @property {boolean} [overflowEllipsis]
		 * @property {boolean} [hiddenImages]
		 * @property {string} [itemClasses]
		 * @property {any} itemLength
		 * @property {string} [idFieldName]
		 * @property {any} [emptyListPlaceholderComponent] - empty
		 * @property {any} [emptyListPlaceholderComponentProps]
		 * @property {any} [listItemComponent] - item
		 * @property {any} [listItemComponentProps]
		 * @property {any} [titleComponent] - item parts
		 * @property {any} [titleComponentProps]
		 * @property {any} descriptionComponent
		 * @property {any} [descriptionComponentProps]
		 * @property {any} imageComponent
		 * @property {any} [imageComponentProps]
		 */
		/** @type {Props} */
		let classes = prop($$props, "classes", 3, ""),
			items = prop($$props, "items", 31, () => proxy([])),
			actions = prop($$props, "actions", 19, () => []),
			links = prop($$props, "links", 19, () => []),
			actionsVisible = prop($$props, "actionsVisible", 3, false),
			itemsHoverable = prop($$props, "itemsHoverable", 3, false),
			overflowEllipsis = prop($$props, "overflowEllipsis", 3, false),
			hiddenImages = prop($$props, "hiddenImages", 3, false),
			itemClasses = prop($$props, "itemClasses", 3, ""),
			idFieldName = prop($$props, "idFieldName", 3, "id"),
			emptyListPlaceholderComponent = prop($$props, "emptyListPlaceholderComponent", 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, "emptyListPlaceholderComponentProps", 19, () => ({})),
			listItemComponent = prop($$props, "listItemComponent", 3, Ui_list_item),
			listItemComponentProps = prop($$props, "listItemComponentProps", 19, () => ({})),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$h();
				var node_1 = child(div);

				Ui_list_block(node_1, {
					get itemClasses() {
						return itemClasses();
					},
					get listItemComponent() {
						return listItemComponent();
					},
					get listItemComponentProps() {
						return listItemComponentProps();
					},
					get idFieldName() {
						return idFieldName();
					},
					get titleComponent() {
						return titleComponent();
					},
					get titleComponentProps() {
						return titleComponentProps();
					},
					get descriptionComponent() {
						return $$props.descriptionComponent;
					},
					get descriptionComponentProps() {
						return descriptionComponentProps();
					},
					get imageComponent() {
						return $$props.imageComponent;
					},
					get imageComponentProps() {
						return imageComponentProps();
					},
					get actions() {
						return actions();
					},
					get links() {
						return links();
					},
					get items() {
						return items();
					},
					set items($$value) {
						items($$value);
					},
					$$events: {
						change($$arg) {
							bubble_event.call(this, $$props, $$arg);
						},
						click($$arg) {
							bubble_event.call(this, $$props, $$arg);
						},
						clickContent($$arg) {
							bubble_event.call(this, $$props, $$arg);
						},
						clickDescription($$arg) {
							bubble_event.call(this, $$props, $$arg);
						},
						clickImage($$arg) {
							bubble_event.call(this, $$props, $$arg);
						},
						clickTitle($$arg) {
							bubble_event.call(this, $$props, $$arg);
						}
					}
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, "style", $$props.itemLength ? `--length: ${$$props.itemLength};` : "");
					set_class(div, `list ${classes() ?? ""} ${(actionsVisible() ? 'has-visible-pointer-controls' : '') ?? ""} ${(itemsHoverable() ? 'has-hoverable-list-items' : '') ?? ""} ${(overflowEllipsis() ? 'has-overflow-ellipsis' : '') ?? ""} ${(hiddenImages() ? 'has-hidden-images' : '') ?? ""}`);
				});

				append($$anchor, div);
			};

			var alternate = ($$anchor) => {
				var fragment_1 = comment();
				const SvelteComponent = derived(emptyListPlaceholderComponent);
				var node_2 = first_child(fragment_1);

				component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(emptyListPlaceholderComponentProps));
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$o = template(`<!> <!>`, 1);

	function Ui_list_of_models($$anchor, $$props) {
		push($$props, true);

		//field props
		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted] - svelte-ignore unused-export-let
		 * @property {any} [value]
		 * @property {string} [placeholder]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid] - validation
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 * @property {string} [modelName] - model bindings
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId] - presentation
		 * @property {string} [optionTitle]
		 * @property {string} [selectorUI] - selector UI to add new item to list
		 * @property {any} [selectorUIProps]
		 * @property {string} [itemUI] - list item UI to present in readonly or editable variants
		 * @property {any} [itemUIProps]
		 * @property {any} [transformValueItemToListItem]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 31, () => proxy([])),
			placeholder = prop($$props, "placeholder", 15, ""),
			fieldname = prop($$props, "fieldname", 15, "selectFromModel"),
			required = prop($$props, "required", 15, true),
			readonly = prop($$props, "readonly", 3, false),
			multiple = prop($$props, "multiple", 15, false),
			size = prop($$props, "size", 15, 8),
			valid = prop($$props, "valid", 15, true),
			modelName = prop($$props, "modelName", 3, ""),
			actionName = prop($$props, "actionName", 3, ""),
			actionFilter = prop($$props, "actionFilter", 19, () => ({})),
			actionSorter = prop($$props, "actionSorter", 19, () => ({})),
			actionPager = prop($$props, "actionPager", 19, () => ({})),
			actionSearch = prop($$props, "actionSearch", 3, undefined),
			optionId = prop($$props, "optionId", 3, ":_id"),
			optionTitle = prop($$props, "optionTitle", 3, ":title"),
			selectorUI = prop($$props, "selectorUI", 3, "UISelectFromModelOnDemandInline"),
			selectorUIProps = prop($$props, "selectorUIProps", 19, () => ({})),
			itemUI = prop($$props, "itemUI", 3, "UIListItem"),
			itemUIProps = prop($$props, "itemUIProps", 19, () => ({})),
			transformValueItemToListItem = prop($$props, "transformValueItemToListItem", 3, (item) => {
				return item
					? {
						id: item._id,
						title: item.title,
						description: item.description,
						value: item
					}
					: undefined;
			});

		function addItem(item) {
			if (!Array.isArray(value())) {
				value([]);
			}

			value().push(item);
			value(value());
		}

		let items = derived(() => value().map ? value().map(transformValueItemToListItem()) : []);

		const ACTIONS = [
			{
				action(listItem) {
					const val = listItem.value;
					const itemIndex = value().findIndex((valueItem) => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex - 1);
						value(valCopy);
					}
				},
				title: "",
				icon: "arrow-up",
				color: "normal"
			},
			{
				action: (listItem) => {
					const val = listItem.value;
					const itemIndex = value().findIndex((valueItem) => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex + 1);
						value(valCopy);
					}
				},
				title: "",
				icon: "arrow-down",
				color: "normal"
			},
			{
				action: (listItem) => {
					const val = listItem.value;
					const itemIndex = value().findIndex((valueItem) => valueItem === val);

					if (itemIndex > -1) {
						value().splice(itemIndex, 1);
						value(value());
					}
				},
				title: "",
				icon: "trash",
				color: "danger"
			}
		];

		var fragment = root$o();
		var node = first_child(fragment);
		var listItemComponent = derived(() => COMPONENTS$1.get(itemUI()));

		Ui_list(node, spread_props(
			{
				get listItemComponent() {
					return get$2(listItemComponent);
				}
			},
			itemUIProps,
			{
				get items() {
					return get$2(items);
				},
				actions: ACTIONS
			}
		));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				const SvelteComponent = derived(() => COMPONENTS$1.get(selectorUI()));
				var node_2 = first_child(fragment_1);

				component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(selectorUIProps, {
						get modelName() {
							return modelName();
						},
						get actionName() {
							return actionName();
						},
						get actionFilter() {
							return actionFilter();
						},
						get actionSorter() {
							return actionSorter();
						},
						get actionPager() {
							return actionPager();
						},
						get actionSearch() {
							return actionSearch();
						},
						get optionId() {
							return optionId();
						},
						get optionTitle() {
							return optionTitle();
						},
						get placeholder() {
							return placeholder();
						},
						set placeholder($$value) {
							placeholder($$value);
						},
						get fieldname() {
							return fieldname();
						},
						set fieldname($$value) {
							fieldname($$value);
						},
						get required() {
							return required();
						},
						set required($$value) {
							required($$value);
						},
						get multiple() {
							return multiple();
						},
						set multiple($$value) {
							multiple($$value);
						},
						get size() {
							return size();
						},
						set size($$value) {
							size($$value);
						},
						get valid() {
							return valid();
						},
						set valid($$value) {
							valid($$value);
						},
						$$events: { resolve: (e) => addItem(e.detail) }
					}));
				});

				append($$anchor, fragment_1);
			};

			if_block(node_1, ($$render) => {
				if (!readonly()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$n = template(`<div><!></div>`);

	function Ui_column($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {string} [title]
		 * @property {boolean} [narrow=false]
		 * @property {any} size
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, ""),
			title = prop($$props, "title", 3, ""),
			narrow = prop($$props, "narrow", 3, false),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, "0");

		var div = root$n();

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", id());
			set_attribute(div, "title", title());
			set_class(div, `column ${classes() ?? ""} ${($$props.size ? `is-${$$props.size}` : '') ?? ""}`);
			set_attribute(div, "role", role());
			set_attribute(div, "tabindex", tabIndex());
			toggle_class(div, "is-narrow", narrow());
		});

		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	var root$m = template(`<div><!></div>`);

	function Ui_columns($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {string} [title]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			title = prop($$props, "title", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, "0");

		var div = root$m();

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", id());
			set_attribute(div, "title", title());
			set_class(div, `columns ${classes() ?? ""}`);
			set_attribute(div, "role", role());
			set_attribute(div, "tabindex", tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	var root$l = template(`<div><!></div>`);

	function Ui_container($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class = '']
		 * @property {string} [title = '']
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {boolean} [widescreen=false]
		 * @property {boolean} [fullhd=false]
		 * @property {boolean} [maxDesktop=false]
		 * @property {boolean} [maxWidescreen=false]
		 * @property {boolean} [fluid = false]
		 * @property {import('svelte').Snippet} [children]
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			title = prop($$props, "title", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, "0"),
			widescreen = prop($$props, "widescreen", 3, false),
			fullhd = prop($$props, "fullhd", 3, false),
			maxDesktop = prop($$props, "maxDesktop", 3, false),
			maxWidescreen = prop($$props, "maxWidescreen", 3, false),
			fluid = prop($$props, "fluid", 3, false);

		var div = root$l();

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, "id", id());
			set_attribute(div, "title", title());
			set_class(div, `container ${classes() ?? ""}`);
			set_attribute(div, "role", role());
			set_attribute(div, "tabindex", tabIndex());
			toggle_class(div, "is-widescreen", widescreen());
			toggle_class(div, "is-fullhd", fullhd());
			toggle_class(div, "is-max-desktop", maxDesktop());
			toggle_class(div, "is-max-widescreen", maxWidescreen());
			toggle_class(div, "is-fluid", fluid());
		});

		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	var root$k = template(`<footer><!></footer>`);

	function Ui_footer($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, "");

		var footer = root$k();
		var node = child(footer);

		snippet(node, () => $$props.children ?? noop);
		reset(footer);

		template_effect(() => {
			set_attribute(footer, "id", id());
			set_class(footer, `footer ${classes() ?? ""} `);
		});

		append($$anchor, footer);
		pop();
	}

	var root$j = template(`<section><!></section>`);

	function Ui_section$2($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class]
		 * @property {string} [role="button"]
		 * @property {number} [tabIndex = 0]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ""),
			classes = prop($$props, "class", 3, ""),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, "0");

		var section = root$j();

		section.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		section.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(section);

		snippet(node, () => $$props.children ?? noop);
		reset(section);

		template_effect(() => {
			set_attribute(section, "id", id());
			set_class(section, `section ${classes() ?? ""}`);
			set_attribute(section, "role", role());
			set_attribute(section, "tabindex", tabIndex());
		});

		append($$anchor, section);
		pop();
	}

	delegate(["click", "keyup"]);

	function Ui_level_item($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [tag]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let tag = prop($$props, "tag", 3, "div");
		var fragment = comment();
		var node = first_child(fragment);

		element(node, tag, false, ($$element, $$anchor) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					snippet(node_2, () => $$props.children ?? noop);
					append($$anchor, fragment_2);
				};

				var alternate = ($$anchor) => {};

				if_block(node_1, ($$render) => {
					if ($$props.children) $$render(consequent); else $$render(alternate, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
		pop();
	}

	var root$i = template(`<nav class="level"><div class="level-left"><!></div> <div class="level-right"><!></div></nav>`);

	function Ui_level($$anchor, $$props) {
		push($$props, true);

		var nav = root$i();
		var div = child(nav);
		var node = child(div);

		snippet(node, () => $$props.left ?? noop);
		reset(div);

		var div_1 = sibling(div, 2);
		var node_1 = child(div_1);

		snippet(node_1, () => $$props.right ?? noop);
		reset(div_1);
		reset(nav);
		append($$anchor, nav);
		pop();
	}

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIColumn: Ui_column,
		UIColumns: Ui_columns,
		UIContainer: Ui_container,
		UIFooter: Ui_footer,
		UILevel: Ui_level,
		UILevelItem: Ui_level_item,
		UISection: Ui_section$2
	});

	var root_1$g = template(`<p> </p>`);
	var root_2$c = template(`<input>`);

	function Ui_number($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, 0),
			placeholder = prop($$props, "placeholder", 3, "0.0"),
			min = prop($$props, "min", 3, 0),
			max = prop($$props, "max", 3, 100),
			step = prop($$props, "step", 3, 1),
			fieldname = prop($$props, "fieldname", 3, "number"),
			required = prop($$props, "required", 3, true),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"min",
				"max",
				"step",
				"fieldname",
				"required",
				"disabled",
				"readonly",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$g();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$c();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-number-${fieldname() ?? ""}`,
					class: `input ${classes() ?? ""}`,
					type: "number",
					name: fieldname(),
					invalid: get$2(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					min: min(),
					max: max(),
					step: step(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					onchange: oninput,
					oninput,
					"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
					"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_2$b = template(`<!> <!> <!>`, 1);
	var root_8$1 = template(`<!> <!> <!>`, 1);
	var root$h = template(`<!> <!> <!>`, 1);

	function Ui_named_numbers_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, "fieldname", 3, "numbers_list"),
			value = prop($$props, "value", 31, () => proxy({})),
			label = prop($$props, "label", 3, "named numbers list"),
			placeholder = prop($$props, "placeholder", 15, "new item"),
			readonly = prop($$props, "readonly", 3, false),
			onchange = prop($$props, "onchange", 3, () => true);

		let list = derived(() => Object.keys(value()).map((name) => {
			return {
				id: name,
				title: name,
				number: value()[name]
			};
		}));

		function remove(id) {
			if (notCommon$1.objHas(value(), id)) {
				delete value()[id];
				value(value());
				onchange()({ value: value(), field: fieldname() });
			}
		}

		function add() {
			const id = newVal.id.trim();
			const number = parseInt(newVal.number);

			if (id && id !== "" && !isNaN(number) && !notCommon$1.objHas(value(), id)) {
				value(value()[id] = number, true);
			}

			onchange()({ value: value(), field: fieldname() });
		}

		const createNewVal = () => {
			return { id: "", number: 0 };
		};

		let newVal = proxy(createNewVal());
		var fragment = root$h();
		var node = first_child(fragment);

		Ui_title(node, {
			get title() {
				return label();
			},
			size: 5
		});

		var node_1 = sibling(node, 2);

		each(node_1, 17, () => get$2(list), (item) => item.id, ($$anchor, item) => {
			Ui_columns($$anchor, {
				children: ($$anchor, $$slotProps) => {
					var fragment_2 = root_2$b();
					var node_2 = first_child(fragment_2);

					Ui_column(node_2, {
						classes: "is-6",
						children: ($$anchor, $$slotProps) => {
							next();

							var text$1 = text();

							template_effect(() => set_text(text$1, get$2(item).title));
							append($$anchor, text$1);
						},
						$$slots: { default: true }
					});

					var node_3 = sibling(node_2, 2);

					Ui_column(node_3, {
						classes: "is-4",
						children: ($$anchor, $$slotProps) => {
							next();

							var text_1 = text();

							template_effect(() => set_text(text_1, get$2(item).number));
							append($$anchor, text_1);
						},
						$$slots: { default: true }
					});

					var node_4 = sibling(node_3, 2);

					{
						var consequent = ($$anchor) => {
							Ui_column($$anchor, {
								classes: "is-2",
								children: ($$anchor, $$slotProps) => {
									Ui_button($$anchor, {
										icon: "minus",
										action: () => remove(get$2(item).id)
									});
								},
								$$slots: { default: true }
							});
						};

						if_block(node_4, ($$render) => {
							if (!readonly()) $$render(consequent);
						});
					}

					append($$anchor, fragment_2);
				},
				$$slots: { default: true }
			});
		});

		var node_5 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_columns($$anchor, {
					children: ($$anchor, $$slotProps) => {
						var fragment_8 = root_8$1();
						var node_6 = first_child(fragment_8);

						Ui_column(node_6, {
							classes: "is-6",
							children: ($$anchor, $$slotProps) => {
								Ui_textfield($$anchor, {
									get value() {
										return newVal.id;
									},
									set value($$value) {
										newVal.id = $$value;
									},
									get placeholder() {
										return placeholder();
									},
									set placeholder($$value) {
										placeholder($$value);
									}
								});
							},
							$$slots: { default: true }
						});

						var node_7 = sibling(node_6, 2);

						Ui_column(node_7, {
							classes: "is-4",
							children: ($$anchor, $$slotProps) => {
								Ui_number($$anchor, {
									get value() {
										return newVal.number;
									},
									set value($$value) {
										newVal.number = $$value;
									}
								});
							},
							$$slots: { default: true }
						});

						var node_8 = sibling(node_7, 2);

						Ui_column(node_8, {
							classes: "is-2",
							children: ($$anchor, $$slotProps) => {
								Ui_button($$anchor, { icon: "plus", action: () => add() });
							},
							$$slots: { default: true }
						});

						append($$anchor, fragment_8);
					},
					$$slots: { default: true }
				});
			};

			if_block(node_5, ($$render) => {
				if (!readonly()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$g = template(`<input>`);

	function Ui_password($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		prop($$props, "inputStarted", 11, false);
			let value = prop($$props, "value", 15, ""),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "password"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"inputStarted",
				"value",
				"placeholder",
				"fieldname",
				"required",
				"readonly",
				"disabled",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var input = root$g();

		remove_input_defaults(input);

		let attributes;

		template_effect(() => attributes = set_attributes(input, attributes, {
			id: `form-field-password-${fieldname() ?? ""}`,
			class: `input ${classes() ?? ""}`,
			type: "password",
			name: fieldname(),
			invalid: get$2(invalid),
			required: required(),
			readonly: readonly(),
			disabled: disabled(),
			placeholder: $LOCALE()[placeholder()],
			autocomplete: fieldname(),
			onchange: oninput,
			oninput,
			"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
			"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
			...others
		}));

		bind_value(input, value);
		append($$anchor, input);
		pop();
	}

	function Ui_radio_buttons($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {any} [variants] - [
		array of groups
		{
		id:number,
		title:string|object,
		image:string|object,
		variants = [
		array of values variants in group
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}]
		}
		]
		 * @property {any} value - multiple && multiple in group
		{
		array of arrays of selected values in group
		if no selection group should be empty array
		[groupId]: [...variantsId]
		}
		multiple && one in group
		{
		[groupId]: variantId
		}
		only one (not multiple && one in group)
		{
		group: groupId
		value: variantId
		}
		 * @property {any} title
		 * @property {any} image
		 * @property {any} [buttonProps]
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [getUIItem]
		 * @property {any} [getDefaultItemSublime]
		 * @property {any} [uiOn]
		 * @property {any} [uiOff]
		 */
		/** @type {Props} */
		let fieldname = prop($$props, "fieldname", 3, "radio-buttons"),
			variants = prop($$props, "variants", 19, () => []),
			value = prop($$props, "value", 15),
			buttonProps = prop($$props, "buttonProps", 19, () => ({})),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 5 })),
			imageComponent = prop($$props, "imageComponent", 3, Ui_image),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, "descriptionComponent", 3, Ui_buttons),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			listComponent = prop($$props, "listComponent", 3, Ui_list),
			listComponentProps = prop($$props, "listComponentProps", 19, () => ({})),
			getUIItem = prop($$props, "getUIItem", 3, (valueId) => {
				return variantsButtons.find((btnVal) => btnVal.value === valueId);
			}),
			getDefaultItemSublime = prop($$props, "getDefaultItemSublime", 3, () => {
				return variants()[0].value;
			}),
			uiOn = prop($$props, "uiOn", 3, (item) => {
				item.color = "success";
				item.outlined = false;
			}),
			uiOff = prop($$props, "uiOff", 3, (item) => {
				item.color = false;
				item.outlined = true;
			}),
			onchange = prop($$props, "onchange", 3, () => true);

		onMount(() => {
			initVariantsButton();
			selectDefault();
		});

		let variantsButtons = [],
			listItems = state(proxy([]));

		function initVariantsButton() {
			variantsButtons = variants().map((variant) => {
				return { ...buttonProps(), ...variant };
			});

			set(listItems, proxy([
				{
					id: 0,
					title: $$props.title,
					image: $$props.image,
					description: { values: variantsButtons }
				}
			]));
		}

		//
		function toggle(selectedValue) {
			let ui = { on: undefined, off: undefined };

			//
			if (value()) {
				ui.off = value();
				ui.on = selectedValue;
			}

			value(selectedValue);
			updateUI(ui);
			//
			onchange()({ field: fieldname(), value: value() });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(getUIItem()(changes.off));
			}

			if (changes.on) {
				uiOn()(getUIItem()(changes.on));
			}

			variantsButtons = variantsButtons;
			set(listItems, proxy(get$2(listItems)));
		}

		//
		function selectDefault() {
			if (variants().length > 0) {
				if (typeof value() !== "undefined") {
					updateUI({ on: value() });
				} else {
					const defValue = getDefaultItemSublime()();

					toggle(defValue);
				}
			}
		}

		const SvelteComponent = derived(listComponent);
		var fragment = comment();
		var node = first_child(fragment);

		var descriptionComponentProps_1 = derived(() => ({
			...descriptionComponentProps(),
			action(event, value) {
				toggle(value);
			}
		}));

		component(node, () => get$2(SvelteComponent), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$2(descriptionComponentProps_1);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return get$2(listItems);
				},
				set items($$value) {
					set(listItems, proxy($$value));
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$f = template(`<p> </p>`);
	var root_4$9 = template(`<option></option>`);
	var root_3$8 = template(`<datalist></datalist>`);
	var root_2$a = template(`<input> <output> </output> <!>`, 1);

	function Ui_range($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, 10),
			min = prop($$props, "min", 3, 0),
			max = prop($$props, "max", 3, 100),
			step = prop($$props, "step", 3, 1),
			tickmarks = prop($$props, "tickmarks", 3, false),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "range"),
			required = prop($$props, "required", 3, true),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"min",
				"max",
				"step",
				"tickmarks",
				"placeholder",
				"fieldname",
				"required",
				"disabled",
				"readonly",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$f();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var fragment_1 = root_2$a();
				var input = first_child(fragment_1);

				remove_input_defaults(input);

				let attributes;
				var output = sibling(input, 2);
				var text_1 = child(output, true);

				reset(output);

				var node_1 = sibling(output, 2);

				{
					var consequent_1 = ($$anchor) => {
						var datalist = root_3$8();

						each(datalist, 21, tickmarks, index$d, ($$anchor, tickmark) => {
							var option = root_4$9();
							var option_value = {};

							template_effect(() => {
								if (option_value !== (option_value = get$2(tickmark).value)) {
									option.value = null == (option.__value = get$2(tickmark).value) ? "" : get$2(tickmark).value;
								}

								set_attribute(option, "label", get$2(tickmark).label);
							});

							append($$anchor, option);
						});

						reset(datalist);
						template_effect(() => set_attribute(datalist, "id", `form-field-range-${fieldname() ?? ""}-tickmarks`));
						append($$anchor, datalist);
					};

					if_block(node_1, ($$render) => {
						if (Array.isArray(tickmarks()) && tickmarks().length) $$render(consequent_1);
					});
				}

				template_effect(() => {
					attributes = set_attributes(input, attributes, {
						id: `form-field-range-${fieldname() ?? ""}`,
						class: `input big-number slider has-output is-fullwidth is-success ${classes() ?? ""}`,
						type: "range",
						name: fieldname(),
						min: min(),
						max: max(),
						step: step(),
						list: `form-field-range-${fieldname() ?? ""}-tickmarks`,
						invalid: get$2(invalid),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
						"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
						onchange: oninput,
						oninput,
						...others
					});

					set_attribute(output, "for", `form-field-range-${fieldname() ?? ""}`);
					set_text(text_1, value());
				});

				bind_value(input, value);
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_select_from_model($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted]
		 * @property {any} value
		 * @property {string} [placeholder]
		 * @property {string} [emptyValueTitle]
		 * @property {string} [fieldname]
		 * @property {string} [modelName]
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId]
		 * @property {string} [optionTitle]
		 * @property {boolean} [icon]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 * @property {boolean} [returnVariant]
		 */
		/** @type {Props} */
		let placeholder = prop($$props, "placeholder", 3, ""),
			emptyValueTitle = prop($$props, "emptyValueTitle", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "selectFromModel"),
			modelName = prop($$props, "modelName", 3, ""),
			actionName = prop($$props, "actionName", 3, ""),
			actionFilter = prop($$props, "actionFilter", 19, () => ({})),
			actionSorter = prop($$props, "actionSorter", 19, () => ({})),
			actionPager = prop($$props, "actionPager", 19, () => ({})),
			actionSearch = prop($$props, "actionSearch", 3, undefined),
			optionId = prop($$props, "optionId", 3, ":_id"),
			optionTitle = prop($$props, "optionTitle", 3, ":title"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			multiple = prop($$props, "multiple", 3, false),
			size = prop($$props, "size", 3, 8),
			valid = prop($$props, "valid", 3, true),
			returnVariant = prop($$props, "returnVariant", 3, false),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			onerror = prop($$props, "onerror", 3, () => {}),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"emptyValueTitle",
				"fieldname",
				"modelName",
				"actionName",
				"actionFilter",
				"actionSorter",
				"actionPager",
				"actionSearch",
				"optionId",
				"optionTitle",
				"required",
				"readonly",
				"multiple",
				"size",
				"valid",
				"returnVariant",
				"class",
				"onchange",
				"onerror"
			]);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let loaded = false;
		let variants = state(proxy([]));
		let disabled = derived(() => !loaded);

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$1.getApp();
				const Model = notApp.getModel(modelName()).setFilter(actionFilter()).setSorter(actionSorter()).setPager(actionPager()).setSearch(actionSearch());
				const response = await Model[`$` + actionName()]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					const result = response.result;

					set(variants, proxy(result.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					})));
				} else {
					onerror()(response.errors || response.message);
				}
			}
		});

		function onChange(data) {
			if (returnVariant()) {
				onchange()({
					...data,
					value: get$2(variants).find((itm) => itm.id === data.value)
				});
			} else {
				onchange()(data);
			}
		}

		Ui_select($$anchor, spread_props(
			{
				get value() {
					return $$props.value;
				},
				get class() {
					return classes();
				},
				get placeholder() {
					return placeholder();
				},
				get emptyValueTitle() {
					return emptyValueTitle();
				},
				get fieldname() {
					return fieldname();
				},
				get required() {
					return required();
				},
				get readonly() {
					return readonly();
				},
				get disabled() {
					return get$2(disabled);
				},
				get multiple() {
					return multiple();
				},
				get size() {
					return size();
				},
				get valid() {
					return valid();
				},
				onchange: onChange
			},
			() => others,
			{
				get variants() {
					return get$2(variants);
				},
				set variants($$value) {
					set(variants, proxy($$value));
				}
			}
		));

		pop();
	}

	var root_2$9 = template(`<!> <input> <label class="label"><!></label>`, 1);

	function Ui_switch$1($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, false),
			label = prop($$props, "label", 3, ""),
			hideLabel = prop($$props, "hideLabel", 3, false),
			placeholder = prop($$props, "placeholder", 3, ""),
			fieldname = prop($$props, "fieldname", 3, "textfield"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"label",
				"hideLabel",
				"placeholder",
				"fieldname",
				"required",
				"readonly",
				"disabled",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_boolean($$anchor, {
					get LC_TRUE() {
						return label();
					},
					get LC_FALSE() {
						return label();
					},
					get value() {
						return value();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = root_2$9();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_boolean($$anchor, { value: false });
					};

					if_block(node_1, ($$render) => {
						if (!label() && !hideLabel()) $$render(consequent_1);
					});
				}

				var input = sibling(node_1, 2);

				remove_input_defaults(input);

				let attributes;
				var label_1 = sibling(input, 2);
				var node_2 = child(label_1);

				{
					var consequent_3 = ($$anchor) => {
						var fragment_4 = comment();
						var node_3 = first_child(fragment_4);

						{
							var consequent_2 = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[label()]));
								append($$anchor, text$1);
							};

							var alternate = ($$anchor) => {
								Ui_boolean($$anchor, { value: false });
							};

							if_block(node_3, ($$render) => {
								if (label()) $$render(consequent_2); else $$render(alternate, false);
							});
						}

						append($$anchor, fragment_4);
					};

					if_block(node_2, ($$render) => {
						if (!hideLabel()) $$render(consequent_3);
					});
				}

				reset(label_1);

				template_effect(() => {
					attributes = set_attributes(input, attributes, {
						id: `form-field-switch-${fieldname() ?? ""}`,
						class: `switch ${classes() ?? ""}`,
						type: "checkbox",
						name: fieldname(),
						placeholder: $LOCALE()[placeholder()],
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						invalid: get$2(invalid),
						onblur: oninput,
						oninput,
						"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
						"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
						...others
					});

					set_attribute(label_1, "for", `form-field-switch-${fieldname() ?? ""}`);
				});

				bind_checked(input, value);
				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_4$8 = template(`<div class="switch-list-item"><input> <!></div>`);

	function Ui_switch_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 31, () => proxy([])),
			variants = prop($$props, "variants", 19, () => []),
			fieldname = prop($$props, "fieldname", 3, "textfield"),
			required = prop($$props, "required", 3, true),
			readonly = prop($$props, "readonly", 3, false),
			disabled = prop($$props, "disabled", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, " is-rounded is-success "),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"variants",
				"fieldname",
				"required",
				"readonly",
				"disabled",
				"valid",
				"class",
				"onchange"
			]);

		function addId(varId) {
			if (!value().includes(varId)) {
				value().push(varId);
				value(value());
			}
		}

		function remId(varId) {
			if (value().includes(varId)) {
				value().splice(value().indexOf(varId), 1);
				value(value());
			}
		}

		function onChange(ev) {
			const varId = ev.target.id.split("-variant-").at(-1);

			ev.target.checked ? addId(varId) : remId(varId);

			let data = { field: fieldname(), value: value() };

			onchange()(data);
			return true;
		}

		let invalid = derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, variants().filter((variant) => value().includes(variant.id)).map((variant) => variant.title).join(", ")));
						append($$anchor, text$1);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = comment();
				var node_2 = first_child(fragment_3);

				each(node_2, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					var div = root_4$8();
					var input = child(div);

					remove_input_defaults(input);

					let attributes;
					var node_3 = sibling(input, 2);

					Ui_label(node_3, {
						class: "label",
						get for() {
							return `form-field-switch-${fieldname() ?? ""}-variant-${get$2(variant).id ?? ""}`;
						},
						get label() {
							return get$2(variant).title;
						}
					});

					reset(div);

					template_effect(() => attributes = set_attributes(input, attributes, {
						type: "checkbox",
						class: `switch ${classes() ?? ""}`,
						id: `form-field-switch-${fieldname() ?? ""}-variant-${get$2(variant).id ?? ""}`,
						checked: value().includes(get$2(variant).id),
						name: fieldname(),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						invalid: get$2(invalid),
						onblur: onChange,
						oninput: onChange,
						"aria-controls": `input-field-helper-${fieldname() ?? ""}-variant-${get$2(variant).id ?? ""}`,
						"aria-describedby": `input-field-helper-${fieldname() ?? ""}-variant-${get$2(variant).id ?? ""}`,
						...others
					}));

					append($$anchor, div);
				});

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function remove(e, value, changeEvent) {
		e && e.preventDefault();

		let id = e.currentTarget.dataset.id;

		if (value().includes(id)) {
			value().splice(value().indexOf(id), 1);
			value(value());
			changeEvent();
		}

		return false;
	}

	var root_4$7 = template(`<button aria-label="delete button" class="delete is-small"></button>`);
	var root_3$7 = template(`<span> <!></span>`);
	var root_6$6 = template(`<div class="select is-small"><select><!><!></select></div> <!>`, 1);
	var root_1$e = template(`<!> <!>`, 1);

	function Ui_tag_select($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		onMount(() => {
			clearValueFromDeadVariants();
		});

		/**
		 * @typedef {Object} Props
		 * @property {any} [value] - list of item ids
		 * @property {any} [variants]
		 * @property {string} [fieldname]
		 * @property {boolean} [readonly] - export let required = true;
		 * @property {boolean} [valid]
		 * @property {any} [beforeAdd]
		 * @property {any} [getItemId]
		 * @property {any} [getItemTitle]
		 * @property {any} [getItemType]
		 * @property {any} [buildItem]
		 */
		/** @type {Props} */
		let value = prop($$props, "value", 31, () => proxy([])),
			LC_ADD = prop($$props, "LC_ADD", 3, "not-node:add_label"),
			LC_SELECT_FROM_LIST = prop($$props, "LC_SELECT_FROM_LIST", 3, "not-node:select_from_list_label"),
			variants = prop($$props, "variants", 19, () => []),
			fieldname = prop($$props, "fieldname", 3, "tag"),
			readonly = prop($$props, "readonly", 3, false),
			beforeAdd = prop($$props, "beforeAdd", 3, () => /*variant, variants*/ {
				return true;
			}),
			getItemId = prop($$props, "getItemId", 3, (variant) => {
				return variant.id;
			}),
			getItemTitle = prop($$props, "getItemTitle", 3, (variant) => {
				return variant.title;
			}),
			getItemType = prop($$props, "getItemType", 3, (variant) => {
				return "info";
			}),
			buildItem = prop($$props, "buildItem", 3, (variant) => {
				return {
					id: getItemId()(variant),
					title: getItemTitle()(variant),
					type: getItemType()(variant)
				};
			}),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true);

		function variantIdToVariant(id) {
			return variants().find((variant) => getItemId()(variant) === id);
		}

		function changeEvent() {
			onchange()({ field: fieldname(), value: value() });
		}

		function add(e) {
			e && e.preventDefault();

			let id = e.currentTarget.parentNode.querySelector("select").value;
			const variant = variantIdToVariant(id);

			if (!variant) {
				return false;
			}

			if (!beforeAdd()(variant, variants())) {
				return false;
			}

			if (id && value().indexOf(id) === -1) {
				value().push(id);
				value(value());
				changeEvent();
			}

			return false;
		}

		function clearValueFromDeadVariants() {
			value(value().filter((id) => {
				return variantIdToVariant(id);
			}));

			return value();
		}

		/*
		item = {
		  id,        //unique
		  title,     //some text
		  type       //for coloring items, usual html template names danger, success, etc
		}
		*/
		let items = derived(() => value().map(variantIdToVariant).filter((variant) => variant).map(buildItem()));

		Ui_columns($$anchor, {
			get class() {
				return classes();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$e();
				var node = first_child(fragment_1);

				Ui_column(node, {
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, () => get$2(items), (item) => item.id, ($$anchor, item) => {
							var span = root_3$7();
							var text = child(span);
							var node_2 = sibling(text);

							{
								var consequent = ($$anchor) => {
									var button = root_4$7();

									button.__click = [remove, value, changeEvent];
									template_effect(() => set_attribute(button, "data-id", get$2(item).id));
									append($$anchor, button);
								};

								if_block(node_2, ($$render) => {
									if (!readonly()) $$render(consequent);
								});
							}

							reset(span);

							template_effect(() => {
								set_class(span, `mx-1 tag is-${get$2(item).type ?? ""}`);
								set_text(text, `${$LOCALE()[get$2(item).title] ?? ""} `);
							});

							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});

				var node_3 = sibling(node, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_column($$anchor, {
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_6$6();
								var div = first_child(fragment_4);
								var select = child(div);
								var node_4 = child(select);

								Ui_select_option(node_4, {
									value: -1,
									selected: true,
									get title() {
										return LC_SELECT_FROM_LIST();
									}
								});

								var node_5 = sibling(node_4);

								each(node_5, 17, variants, index$d, ($$anchor, variant) => {
									Ui_select_option($$anchor, {
										get value() {
											return get$2(variant).id;
										},
										get title() {
											return get$2(variant).title;
										}
									});
								});

								reset(select);
								reset(div);

								var node_6 = sibling(div, 2);

								Ui_button(node_6, {
									color: "primary",
									size: "small",
									action: add,
									get title() {
										return LC_ADD();
									}
								});

								append($$anchor, fragment_4);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_3, ($$render) => {
						if (!readonly()) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
	}

	delegate(["click"]);

	var root_1$d = template(`<p> </p>`);
	var root_2$8 = template(`<input>`);

	function Ui_telephone($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, "value", 15, ""),
			placeholder = prop($$props, "placeholder", 3, "+7 (987) 654-32-10"),
			fieldname = prop($$props, "fieldname", 3, "telephone"),
			required = prop($$props, "required", 3, true),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			valid = prop($$props, "valid", 3, true),
			classes = prop($$props, "class", 3, ""),
			onchange = prop($$props, "onchange", 3, () => true),
			others = rest_props($$props, [
				"$$slots",
				"$$events",
				"$$legacy",
				"value",
				"placeholder",
				"fieldname",
				"required",
				"disabled",
				"readonly",
				"valid",
				"class",
				"onchange"
			]);

		let invalid = derived(() => !valid());
		const oninput = UICommon$1.onInput(fieldname(), onchange());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$d();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$8();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-telephone-${fieldname() ?? ""}`,
					class: `input ${classes() ?? ""}`,
					type: "tel",
					name: fieldname(),
					invalid: get$2(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					onchange: oninput,
					oninput,
					"aria-controls": `input-field-helper-${fieldname() ?? ""}`,
					"aria-describedby": `input-field-helper-${fieldname() ?? ""}`,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIAutocomplete: Ui_autocomplete,
		UIControl: Ui_control,
		UIDate: Ui_date,
		UIDatetimeInTZ: Ui_datetime_in_tz,
		UIEmail: Ui_email,
		UIHidden: Ui_hidden,
		UIJSONArea: Ui_json_area,
		UILabel: Ui_label,
		UIListOfModels: Ui_list_of_models,
		UINamedNumbersList: Ui_named_numbers_list,
		UINumber: Ui_number,
		UIPassword: Ui_password,
		UIRadioButtons: Ui_radio_buttons,
		UIRange: Ui_range,
		UISelect: Ui_select,
		UISelectFromModel: Ui_select_from_model,
		UISelectOption: Ui_select_option,
		UISwitch: Ui_switch$1,
		UISwitchList: Ui_switch_list,
		UITagSelect: Ui_tag_select,
		UITelephone: Ui_telephone,
		UITextarea: Ui_textarea,
		UITextfield: Ui_textfield
	});

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UILink: Ui_link,
		UILinks: Ui_links
	});

	var root_4$6 = template(`<div class="column box"> </div>`);
	var root_1$c = template(`<div class="columns"><div class="column"><!></div> <!> <div class="column"><!></div></div>`);

	function Ui_endless_list_navigation($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		const dispatch = createEventDispatcher();

		// export let skip = 0;
		/**
		 * @typedef {Object} Props
		 * @property {number} [page] - export let count = 0;
		 * @property {number} [pages]
		 * @property {any} [buttonComponent]
		 * @property {any} [buttonComponentProps]
		 */
		/** @type {Props} */
		let page = prop($$props, "page", 3, 0),
			pages = prop($$props, "pages", 3, 0),
			buttonComponent = prop($$props, "buttonComponent", 3, Ui_button),
			buttonComponentProps = prop($$props, "buttonComponentProps", 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_3 = ($$anchor) => {
				var div = root_1$c();
				var div_1 = child(div);
				var node_1 = child(div_1);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						const SvelteComponent = derived(buttonComponent);
						var node_2 = first_child(fragment_1);

						component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(buttonComponentProps, {
								action: () => dispatch('prev'),
								children: ($$anchor, $$slotProps) => {
									next();

									var text$1 = text();

									template_effect(() => set_text(text$1, $LOCALE()['not-node:list_navigation_prev_button_label']));
									append($$anchor, text$1);
								},
								$$slots: { default: true }
							}));
						});

						append($$anchor, fragment_1);
					};

					if_block(node_1, ($$render) => {
						if (page() > 1) $$render(consequent);
					});
				}

				reset(div_1);

				var node_3 = sibling(div_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						var div_2 = root_4$6();
						var text_1 = child(div_2);

						reset(div_2);
						template_effect(() => set_text(text_1, `${page() ?? ""} / ${pages() ?? ""}`));
						append($$anchor, div_2);
					};

					if_block(node_3, ($$render) => {
						if (pages() > 1) $$render(consequent_1);
					});
				}

				var div_3 = sibling(node_3, 2);
				var node_4 = child(div_3);

				{
					var consequent_2 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent_1 = derived(buttonComponent);
						var node_5 = first_child(fragment_3);

						component(node_5, () => get$2(SvelteComponent_1), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(buttonComponentProps, {
								action: () => dispatch('next'),
								children: ($$anchor, $$slotProps) => {
									next();

									var text_2 = text();

									template_effect(() => set_text(text_2, $LOCALE()['not-node:list_navigation_next_button_label']));
									append($$anchor, text_2);
								},
								$$slots: { default: true }
							}));
						});

						append($$anchor, fragment_3);
					};

					if_block(node_4, ($$render) => {
						if (page() < pages()) $$render(consequent_2);
					});
				}

				reset(div_3);
				reset(div);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (pages() > 0) $$render(consequent_3);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$f = template(`<div class="box list-item-selectable svelte-ialyiy" role="button" tabindex="0"><span> </span></div>`);

	function Ui_endless_list_simple_item($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		function click() {
			dispatch("click", {
				_id: $$props._id,
				id: $$props.id,
				title: $$props.title
			});
		}

		var div = root$f();
		var event_handler = derived(() => preventDefault(click));

		div.__click = function (...$$args) {
			get$2(event_handler)?.apply(this, $$args);
		};

		div.__keyup = click;

		var span = child(div);
		var text = child(span, true);

		reset(span);
		reset(div);
		template_effect(() => set_text(text, $$props.title));
		append($$anchor, div);
		pop();
	}

	delegate(["click", "keyup"]);

	var root$e = template(`<div><!></div> <!>`, 1);

	function Ui_endless_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [data]
		 * @property {any} [itemComponent] - list element
		 * @property {any} [itemComponentProps]
		 * @property {any} [emptyListPlaceholderComponent] - if list is empty
		 * @property {any} [emptyListPlaceholderComponentProps]
		 * @property {any} [listNavigationComponent] - prev and next block
		 * @property {any} [listNavigationComponentProps]
		 */
		/** @type {Props} */
		let data = prop($$props, "data", 31, () => proxy({
				list: [],
				skip: 0,
				count: 0,
				page: 0,
				pages: 0
			})),
			itemComponent = prop($$props, "itemComponent", 3, Ui_endless_list_simple_item),
			itemComponentProps = prop($$props, "itemComponentProps", 19, () => ({})),
			emptyListPlaceholderComponent = prop($$props, "emptyListPlaceholderComponent", 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, "emptyListPlaceholderComponentProps", 19, () => ({})),
			listNavigationComponent = prop($$props, "listNavigationComponent", 3, Ui_endless_list_navigation),
			listNavigationComponentProps = prop($$props, "listNavigationComponentProps", 19, () => ({}));

		const SvelteComponent_2 = derived(listNavigationComponent);
		var fragment = root$e();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, () => data().list, (item) => item.id, ($$anchor, item) => {
					var fragment_2 = comment();
					const SvelteComponent = derived(itemComponent);
					var node_2 = first_child(fragment_2);

					component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
						$$component($$anchor, spread_props(
							{
								get onclick() {
									return $$props.onselect;
								}
							},
							itemComponentProps,
							() => get$2(item)
						));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = comment();
				const SvelteComponent_1 = derived(emptyListPlaceholderComponent);
				var node_3 = first_child(fragment_3);

				component(node_3, () => get$2(SvelteComponent_1), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(emptyListPlaceholderComponentProps));
				});

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (data().list.length) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(div);

		var node_4 = sibling(div, 2);

		component(node_4, () => get$2(SvelteComponent_2), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listNavigationComponentProps, {
				get onprev() {
					return $$props.onprev;
				},
				get onnext() {
					return $$props.onnext;
				},
				get page() {
					return data().page;
				},
				set page($$value) {
					data(data().page = $$value, true);
				},
				get pages() {
					return data().pages;
				},
				set pages($$value) {
					data(data().pages = $$value, true);
				},
				get skip() {
					return data().skip;
				},
				set skip($$value) {
					data(data().skip = $$value, true);
				},
				get count() {
					return data().count;
				},
				set count($$value) {
					data(data().count = $$value, true);
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	function Ui_list_select($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {boolean} [multiple]
		 * @property {boolean} [atLeastOne]
		 * @property {any} [variants] - array of values variants in group
		[
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}
		]
		 * @property {any} value - [...selectedItemsValues]
		 * @property {any} [selectedVariantsIds] - [...selectedItemsIds]
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [sublimeValue]
		 * @property {any} [getItem]
		 * @property {any} [getItemValue]
		 * @property {any} [getDefaultItemSublime]
		 * @property {any} [uiOn]
		 * @property {any} [uiOff]
		 */
		/** @type {Props} */
		let fieldname = prop($$props, "fieldname", 3, "list-select"),
			multiple = prop($$props, "multiple", 3, false),
			atLeastOne = prop($$props, "atLeastOne", 3, true),
			variants = prop($$props, "variants", 31, () => proxy([])),
			value = prop($$props, "value", 15),
			selectedVariantsIds = prop($$props, "selectedVariantsIds", 31, () => proxy([])),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 5 })),
			imageComponent = prop($$props, "imageComponent", 3, Ui_image),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, "descriptionComponent", 3, Ui_buttons),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			listComponent = prop($$props, "listComponent", 3, Ui_list),
			listComponentProps = prop($$props, "listComponentProps", 19, () => ({})),
			sublimeValue = prop($$props, "sublimeValue", 3, (value) => value.id),
			getItem = prop($$props, "getItem", 3, ({ valueId }) => {
				return variants().find((btnVal) => btnVal.value.id === valueId);
			}),
			getItemValue = prop($$props, "getItemValue", 3, ({ valueId }) => {
				return getItem()({ valueId }).value;
			}),
			getDefaultItemSublime = prop($$props, "getDefaultItemSublime", 3, () => {
				return variants()[0].id;
			}),
			uiOn = prop($$props, "uiOn", 3, (item) => {
				item.color = "success";
				item.outlined = false;
			}),
			uiOff = prop($$props, "uiOff", 3, (item) => {
				item.color = false;
				item.outlined = true;
			});

		onMount(() => {
			if (value() && Array.isArray(value())) {
				if (atLeastOne() && value().length) {
					value().forEach((itemValue) => {
						let ui = updateSelected(itemValue);

						updateUI(ui);
					});
				}

				return;
			}

			selectDefault();
		});

		//
		function countOfSelected() {
			return Array.isArray(value()) ? selectedVariantsIds().length : 0;
		}

		const notLastOne = () => !(atLeastOne() && countOfSelected() === 1);

		//
		function updateSelected(detail) {
			const valueId = sublimeValue()(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (!Array.isArray(selectedVariantsIds())) {
				selectedVariantsIds([]);
			}

			if (multiple()) {
				if (selectedVariantsIds().includes(valueId)) {
					if (notLastOne()) {
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
						ui.off = { valueId };
					}
				} else {
					selectedVariantsIds().push(valueId);
					ui.on = { valueId };
				}
			} else {
				if (atLeastOne()) {
					if (!selectedVariantsIds().includes(valueId)) {
						if (countOfSelected() > 0) {
							ui.off = { valueId: selectedVariantsIds().pop() };
						}

						ui.on = { valueId };
						selectedVariantsIds([valueId]);
					}
				} else {
					if (selectedVariantsIds().includes(valueId)) {
						ui.off = { valueId };
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
					} else {
						ui.on = { valueId };
						selectedVariantsIds().push(valueId);
					}
				}
			}

			selectedVariantsIds(selectedVariantsIds());
			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);

			updateUI(ui);
			//
			updateValue();
			//
			dispatch("change", { field: fieldname(), value: value() });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(getItem()(changes.off));
			}

			if (changes.on) {
				uiOn()(getItem()(changes.on));
			}

			variants(variants());
		}

		//
		function updateValue() {
			let newVal = [];

			if (typeof selectedVariantsIds() !== "undefined" && Array.isArray(selectedVariantsIds())) {
				newVal = selectedVariantsIds().filter((val) => typeof val !== "undefined").map((valueId) => getItemValue()({ valueId }));
			}

			value(newVal);
		}

		//
		function selectDefault() {
			if (atLeastOne() && variants().length > 0) {
				const defValueId = getDefaultItemSublime()();

				toggle({ id: defValueId });
			}
		}

		const SvelteComponent = derived(listComponent);
		var fragment = comment();
		var node = first_child(fragment);

		var descriptionComponentProps_1 = derived(() => ({
			...descriptionComponentProps(),
			action(event, value) {
				toggle(value);
			}
		}));

		component(node, () => get$2(SvelteComponent), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$2(descriptionComponentProps_1);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return variants();
				},
				set items($$value) {
					variants($$value);
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	function Ui_list_select_with_groups($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {boolean} [multiple]
		 * @property {boolean} [onlyOneInGroup]
		 * @property {boolean} [atLeastOne]
		 * @property {any} [variants] - [
		array of groups
		{
		id:number,
		title:string|object,
		image:string|object,
		variants = [
		array of values variants in group
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}]
		}
		]
		 * @property {any} [variantsSelected] - multiple && multiple in group
		{
		array of arrays of selected values in group
		if no selection group should be empty array
		[groupId]: [...variantsId]
		}
		multiple && one in group
		{
		[groupId]: variantId
		}
		only one (not multiple && one in group)
		{
		group: groupId
		value: variantId
		}
		 * @property {any} value - {[groupId]: [...valuesOfSelectedItems]}
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [sublimeValue]
		 * @property {any} [getItem]
		 * @property {any} [getItemValue]
		 * @property {any} [getDefaultItemSublime]
		 * @property {any} [uiOn]
		 * @property {any} [uiOff]
		 */
		/** @type {Props} */
		let onchange = prop($$props, "onchange", 3, () => true),
			fieldname = prop($$props, "fieldname", 3, "list-select-tags"),
			multiple = prop($$props, "multiple", 3, false),
			onlyOneInGroup = prop($$props, "onlyOneInGroup", 3, true),
			atLeastOne = prop($$props, "atLeastOne", 3, true),
			variants = prop($$props, "variants", 31, () => proxy([])),
			variantsSelected = prop($$props, "variantsSelected", 31, () => proxy({})),
			value = prop($$props, "value", 15),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 5 })),
			imageComponent = prop($$props, "imageComponent", 3, Ui_image),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, "descriptionComponent", 3, Ui_buttons),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			listComponent = prop($$props, "listComponent", 3, Ui_list),
			listComponentProps = prop($$props, "listComponentProps", 19, () => ({})),
			sublimeValue = prop($$props, "sublimeValue", 3, (value) => {
				return { groupId: value.group, valueId: value.id };
			}),
			getItem = prop($$props, "getItem", 3, ({ groupId, valueId }) => {
				return variants().find((group) => group.id === groupId).description.values.find((btnVal) => btnVal.value.id === valueId);
			}),
			getItemValue = prop($$props, "getItemValue", 3, ({ groupId, valueId }) => {
				return getItem()({ groupId, valueId }).value;
			}),
			getDefaultItemSublime = prop($$props, "getDefaultItemSublime", 3, () => {
				return {
					groupId: variants()[0].id,
					valueId: variants()[0].description.values[0].value.id
				};
			}),
			uiOn = prop($$props, "uiOn", 3, (item) => {
				item.color = "success";
				item.outlined = false;
			}),
			uiOff = prop($$props, "uiOff", 3, (item) => {
				item.color = false;
				item.outlined = false;
			});

		onMount(() => {
			if (value()) {
				if (multiple()) {
					if (onlyOneInGroup()) {
						for (let t of Object.keys(value())) {
							const itemValue = value()[t];
							let ui = updateSelected(itemValue);

							updateUI(ui);
						}
					} else {
						for (let t of Object.keys(value())) {
							value()[t].forEach((itemValue) => {
								let ui = updateSelected(itemValue);

								updateUI(ui);
							});
						}
					}
				} else {
					let ui = updateSelected(value());

					updateUI(ui);
				}
			} else {
				selectDefault();
			}
		});

		//
		function countOfSelected() {
			let c = 0;

			if (multiple()) {
				for (let groupValue of Object.values(variantsSelected())) {
					if (onlyOneInGroup()) {
						if (typeof groupValue !== "undefined") {
							c++;
						}
					} else {
						if (typeof groupValue !== "undefined" && Array.isArray(groupValue)) {
							c += groupValue.length;
						}
					}
				}
			} else {
				if (typeof variantsSelected() !== "undefined" && typeof variantsSelected().value !== "undefined" && typeof variantsSelected().group !== "undefined") {
					c++;
				}
			}

			return c;
		}

		//
		function updateSelected(detail) {
			const { valueId, groupId } = sublimeValue()(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (multiple()) {
				if (onlyOneInGroup()) {
					if (typeof variantsSelected()[groupId] !== "undefined") {
						ui.off = {
							groupId,
							valueId: variantsSelected()[groupId]
						};
					}

					variantsSelected(variantsSelected()[groupId] = valueId, true);
					ui.on = { groupId, valueId };
				} else {
					if (!Array.isArray(variantsSelected()[groupId])) {
						variantsSelected(variantsSelected()[groupId] = [], true);
					}

					if (variantsSelected()[groupId].includes(valueId)) {
						if (countOfSelected() > 1) {
							variantsSelected()[groupId].splice(variantsSelected()[groupId].indexOf(valueId), 1);
							ui.off = { groupId, valueId };
						}
					} else {
						variantsSelected()[groupId].push(valueId);
						ui.on = { groupId, valueId };
					}

					variantsSelected(variantsSelected()[groupId] = variantsSelected()[groupId], true);
				}

				variantsSelected(variantsSelected());
			} else {
				if (variantsSelected() && variantsSelected().groupId === groupId && variantsSelected().valueId === valueId) {
					if (!atLeastOne()) {
						variantsSelected(undefined);
						ui.off = { groupId, valueId };
					}
				} else {
					if (variantsSelected()) {
						if (typeof variantsSelected().groupId !== "undefined") {
							ui.off = {
								groupId: variantsSelected().groupId,
								valueId: variantsSelected().valueId
							};
						}
					}

					ui.on = { groupId, valueId };
					variantsSelected({ groupId, valueId });
				}
			}

			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);

			updateUI(ui);
			//
			updateValue();
			//
			onchange()({ field: fieldname(), value: value() });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(getItem()(changes.off));
			}

			if (changes.on) {
				uiOn()(getItem()(changes.on));
			}

			variants(variants());
		}

		//
		function updateValue() {
			if (multiple()) {
				let newVal = {};

				if (onlyOneInGroup()) {
					for (let groupId in variantsSelected()) {
						if (typeof variantsSelected()[groupId] !== "undefined") {
							newVal[groupId] = getItemValue()({
								groupId,
								valueId: variantsSelected()[groupId]
							});
						}
					}
				} else {
					for (let groupId in variantsSelected()) {
						if (typeof variantsSelected()[groupId] !== "undefined" && Array.isArray(variantsSelected()[groupId])) {
							newVal[groupId] = variantsSelected()[groupId].filter((val) => typeof val !== "undefined").map((itemValueId) => {
								return getItemValue()({ groupId, valueId: itemValueId });
							});
						}
					}
				}

				if (Object.keys(newVal).length == 0) {
					value(undefined);
				} else {
					value(newVal);
				}
			} else {
				if (variantsSelected()) {
					value(getItemValue()(variantsSelected()));
				} else {
					value(undefined);
				}
			}
		}

		//
		function selectDefault() {
			if (atLeastOne() && variants().length > 0) {
				const defValue = getDefaultItemSublime()();

				toggle({ id: defValue.valueId, group: defValue.groupId });
			}
		}

		const SvelteComponent = derived(listComponent);
		var fragment = comment();
		var node = first_child(fragment);

		var descriptionComponentProps_1 = derived(() => ({
			...descriptionComponentProps(),
			action(event, value) {
				toggle(value);
			}
		}));

		component(node, () => get$2(SvelteComponent), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$2(descriptionComponentProps_1);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return variants();
				},
				set items($$value) {
					variants($$value);
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	var root$d = template(`<!> <!>`, 1);

	function Ui_list_select_buttons_with_groups($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {any} [variants] - [
		array of groups
		{
		id:number,
		title:string|object,
		image:string|object,
		variants = [
		array of values variants in group
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}]
		}
		]
		 * @property {any} [variantsSelected] - multiple && multiple in group
		{
		array of arrays of selected values in group
		if no selection group should be empty array
		[groupId]: [...variantsId]
		}
		multiple && one in group
		{
		[groupId]: variantId
		}
		only one (not multiple && one in group)
		{
		group: groupId
		value: variantId
		}
		 * @property {any} value - {[groupId]: [...valuesOfSelectedItems]}
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [actionsList]
		 * @property {any} [sublimeValue]
		 */
		/** @type {Props} */
		let onchange = prop($$props, "onchange", 3, () => true),
			fieldname = prop($$props, "fieldname", 3, "list-select-tags"),
			variants = prop($$props, "variants", 31, () => proxy([])),
			value = prop($$props, "value", 15),
			titleComponent = prop($$props, "titleComponent", 3, Ui_title),
			titleComponentProps = prop($$props, "titleComponentProps", 19, () => ({ size: 5 })),
			imageComponent = prop($$props, "imageComponent", 3, Ui_image),
			imageComponentProps = prop($$props, "imageComponentProps", 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, "descriptionComponent", 3, Ui_buttons_switchers),
			descriptionComponentProps = prop($$props, "descriptionComponentProps", 19, () => ({})),
			listComponent = prop($$props, "listComponent", 3, Ui_list),
			listComponentProps = prop($$props, "listComponentProps", 19, () => ({})),
			actionsList = prop($$props, "actionsList", 19, () => ["selectAll", "deselectAll"]),
			sublimeValue = prop($$props, "sublimeValue", 3, (value) => {
				return { groupId: value.group, valueId: value.id };
			});

		//
		const AVAILABLE_ACTIONS = {
			selectAll: {
				title: "Выбрать все",
				color: "success",
				action() {
					selectAll();
				}
			},
			deselectAll: {
				title: "Снять выделение со всех",
				color: "",
				action() {
					deselectAll();
				}
			}
		};

		let ACTIONS = state(proxy([]));

		onMount(() => {
			actionsList().forEach((name) => {
				Object.hasOwn(AVAILABLE_ACTIONS, name) ? get$2(ACTIONS).push(AVAILABLE_ACTIONS[name]) : false;
			});

			set(ACTIONS, proxy(get$2(ACTIONS)));
		});

		const selectAll = () => {
			setSelectionOfAll(true);
		};

		const deselectAll = () => {
			setSelectionOfAll(false);
		};

		const selectGroup = (groupId) => {
			setSelectionOfGroup(groupId, true);
		};

		const deselectGroup = (groupId) => {
			setSelectionOfGroup(groupId, false);
		};

		const setSelectionOfGroup = (groupId, selection) => {
			variants().forEach((group) => {
				if (groupId === group.id) {
					group.description.values.forEach((itm) => {
						itm.selected = selection;
					});
				}
			});

			variants(variants());
			triggerChange();
		};

		const setSelectionOfAll = (selection) => {
			variants().forEach((group) => {
				group.description.values.forEach((itm) => {
					itm.selected = selection;
				});
			});

			variants(variants());
			triggerChange();
		};

		function getSelectedItems() {
			let result = {};

			variants().forEach((group) => {
				if (!Object.hasOwn(result, group.id)) {
					result[group.id] = [];
				}

				group.description.values.forEach((itm) => {
					if (itm.selected) {
						result[group.id].push(sublimeValue()(itm.value));
					}
				});
			});

			return result;
		}

		function triggerChange() {
			value(getSelectedItems());

			onchange()({
				fieldname: fieldname(),
				value: value()
			});
		}

		const SvelteComponent = derived(listComponent);
		var fragment = root$d();
		var node = first_child(fragment);

		Ui_buttons(node, {
			get values() {
				return get$2(ACTIONS);
			},
			centered: true
		});

		var node_1 = sibling(node, 2);

		var descriptionComponentProps_1 = derived(() => ({
			action(event, value, selected) {
				setTimeout(triggerChange, 0);
				return !selected;
			},
			...descriptionComponentProps()
		}));

		component(node_1, () => get$2(SvelteComponent), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$2(descriptionComponentProps_1);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return variants();
				},
				set items($$value) {
					variants($$value);
				}
			}));
		});

		append($$anchor, fragment);

		return pop({
			selectAll,
			deselectAll,
			selectGroup,
			deselectGroup,
			setSelectionOfGroup,
			setSelectionOfAll,
			getSelectedItems
		});
	}

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIEndlessList: Ui_endless_list,
		UIEndlessListNavigation: Ui_endless_list_navigation,
		UIEndlessListSimpleItem: Ui_endless_list_simple_item,
		UIList: Ui_list,
		UIListEmptyPlaceholder: Ui_list_empty_placeholder,
		UIListItem: Ui_list_item,
		UIListSelect: Ui_list_select,
		UIListSelectButtonsWithGroups: Ui_list_select_buttons_with_groups,
		UIListSelectWithGroups: Ui_list_select_with_groups
	});

	function overlayClick(e, closeOnClick, closeOverlay) {
		if (closeOnClick()) {
			closeOverlay(e);
		}
	}

	var root_1$b = template(`<div><!> <!></div>`);

	function Ui_overlay($$anchor, $$props) {
		push($$props, true);

		let overflowSave = state("");

		const defaultCloseButtonProps = {
			class: "is-absolute is-sided-right is-sided-top",
			style: "--siding-right-size: 2rem; --siding-top-size: 2rem",
			size: "normal"
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [closeButton = false]
		 * @property {object}   [closeButtonProps = defaultCloseButtonProps]
		 * @property {boolean}  [show = true]
		 * @property {boolean}  [closeOnClick = true]
		 * @property {number}   [layer = 1]
		 * @property {string}   [class = ""]
		 * @property {number}   [zIndexStep = 1000]
		 * @property {string}   [role = 'button']
		 * @property {string}   [tabIndex = 'button']
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let closeButton = prop($$props, "closeButton", 3, false),
			closeButtonProps = prop($$props, "closeButtonProps", 3, defaultCloseButtonProps),
			show = prop($$props, "show", 7, true),
			closeOnClick = prop($$props, "closeOnClick", 3, true),
			layer = prop($$props, "layer", 3, 1),
			classes = prop($$props, "class", 3, ""),
			onreject = prop($$props, "onreject", 3, () => false),
			zIndexStep = prop($$props, "zIndexStep", 3, 1000),
			role = prop($$props, "role", 3, "button"),
			tabIndex = prop($$props, "tabIndex", 3, "0");

		function closeButtonClick() {
			rejectOverlay();
		}

		function closeOverlay(e) {
			try {
				if (e && e.originalTarget) {
					const target = e.originalTarget;

					if (target.classList && target.classList.contains("is-overlay")) {
						rejectOverlay();
					}
				} //eslint-disable-next-line no-empty
			} catch {}
		}

		function rejectOverlay(data = {}) {
			show(false);
			onreject()(data);
		}

		onMount(() => {
			set(overflowSave, proxy(document.body.style.overflow));

			if (show()) {
				document.body.style.overflow = "hidden";
			} else {
				document.body.style.overflow = get$2(overflowSave);
			}
		});

		onDestroy(() => {
			document.body.style.overflow = get$2(overflowSave);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$b();

				div.__click = [overlayClick, closeOnClick, closeOverlay];
				div.__keyup = [overlayClick, closeOnClick, closeOverlay];

				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						Ui_button_close($$anchor, spread_props(closeButtonProps, { onclick: closeButtonClick }));
					};

					if_block(node_1, ($$render) => {
						if (closeButton()) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				snippet(node_2, () => $$props.children ?? noop);
				reset(div);

				template_effect(() => {
					set_class(div, `is-overlay not-overlay ${classes() ?? ""}`);
					set_attribute(div, "role", role());
					set_attribute(div, "tabindex", tabIndex());
					set_attribute(div, "style", `z-index: ${zIndexStep() * layer() ?? ""};`);
				});

				transition(3, div, () => fade);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(["click", "keyup"]);

	var root_3$6 = template(`<div><span class="title"> </span></div> <!> <!> <!>`, 1);
	var root_2$7 = template(`<!> <!>`, 1);

	function Ui_modal($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [buttonsPosition]
		 * @property {boolean} [closeButton]
		 * @property {boolean} [applyButton]
		 * @property {number} [titleSize]
		 * @property {boolean} [show]
		 * @property {boolean} [loading]
		 * @property {string} [title]
		 * @property {string} [subtitle]
		 * @property {string} [classes]
		 * @property {string} [overlayClasses]
		 * @property {string} [buttonsClasses]
		 * @property {string} [WAITING_TEXT]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let buttonsPosition = prop($$props, "buttonsPosition", 3, "bottom"),
			closeButton = prop($$props, "closeButton", 3, false),
			applyButton = prop($$props, "applyButton", 3, false),
			titleSize = prop($$props, "titleSize", 3, 2),
			show = prop($$props, "show", 3, false),
			loading = prop($$props, "loading", 3, false),
			title = prop($$props, "title", 3, "Modal window"),
			subtitle = prop($$props, "subtitle", 3, ""),
			classes = prop($$props, "classes", 3, ""),
			overlayClasses = prop($$props, "overlayClasses", 3, ""),
			buttonsClasses = prop($$props, "buttonsClasses", 3, ""),
			WAITING_TEXT = prop($$props, "WAITING_TEXT", 3, "Обработка");

		Ui_overlay($$anchor, {
			get show() {
				return show();
			},
			closeOnClick: false,
			closeButton: false,
			get classes() {
				return overlayClasses();
			},
			children: ($$anchor, $$slotProps) => {
				Ui_box($$anchor, {
					get classes() {
						return classes();
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = root_2$7();
						var node = first_child(fragment_2);

						Ui_title(node, {
							get size() {
								return titleSize();
							},
							get title() {
								return $LOCALE()[title()];
							},
							get subtitle() {
								return $LOCALE()[subtitle()];
							}
						});

						var node_1 = sibling(node, 2);

						Ui_content(node_1, {
							children: ($$anchor, $$slotProps) => {
								var fragment_3 = root_3$6();
								var div = first_child(fragment_3);
								var span = child(div);
								var text = child(span, true);

								reset(span);
								reset(div);

								var node_2 = sibling(div, 2);

								{
									var consequent = ($$anchor) => {
										var left = derived(() => closeButton() ? [closeButton()] : []);
										var right = derived(() => applyButton() ? [applyButton()] : []);

										Ui_buttons_row($$anchor, {
											get classes() {
												return buttonsClasses();
											},
											get left() {
												return get$2(left);
											},
											get right() {
												return get$2(right);
											}
										});
									};

									if_block(node_2, ($$render) => {
										if (buttonsPosition() === "top") $$render(consequent);
									});
								}

								var node_3 = sibling(node_2, 2);

								snippet(node_3, () => $$props.children ?? noop);

								var node_4 = sibling(node_3, 2);

								{
									var consequent_1 = ($$anchor) => {
										var classes_1 = derived(() => buttonsClasses() || "is-footer is-mobile");
										var left_1 = derived(() => closeButton() ? [closeButton()] : []);
										var right_1 = derived(() => applyButton() ? [applyButton()] : []);

										Ui_buttons_row($$anchor, {
											get classes() {
												return get$2(classes_1);
											},
											get left() {
												return get$2(left_1);
											},
											get right() {
												return get$2(right_1);
											}
										});
									};

									if_block(node_4, ($$render) => {
										if (buttonsPosition() === "bottom") $$render(consequent_1);
									});
								}

								template_effect(() => {
									set_class(div, `pageloader ${(loading() ? 'is-active' : '') ?? ""}`);
									set_text(text, $LOCALE()[WAITING_TEXT()]);
								});

								append($$anchor, fragment_3);
							},
							$$slots: { default: true }
						});

						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root_1$a = template(`<div><!> <!> <!></div>`);

	function Ui_generic_selector($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [show]
		 * @property {string} [term]
		 * @property {string} [size]
		 * @property {any} [inputComponent]
		 * @property {any} [inputComponentProps]
		 * @property {any} [outputComponent]
		 * @property {any} [outputComponentProps]
		 * @property {any} [results]
		 */
		/** @type {Props} */
		let show = prop($$props, "show", 3, true),
			term = prop($$props, "term", 15, ""),
			size = prop($$props, "size", 3, "narrow"),
			inputComponent = prop($$props, "inputComponent", 3, Ui_simple_search_input),
			inputComponentProps = prop($$props, "inputComponentProps", 19, () => ({})),
			outputComponent = prop($$props, "outputComponent", 3, Ui_endless_list),
			outputComponentProps = prop($$props, "outputComponentProps", 19, () => ({})),
			results = prop($$props, "results", 31, () => proxy({
				list: [],
				page: 0,
				pages: 0,
				skip: 0,
				count: 0
			}));

		const buttons = [
			{
				title: $LOCALE()["not-node:button_cancel_label"],
				action: () => onreject()
			}
		];

		Ui_overlay($$anchor, {
			onreject: overlayClosed,
			get show() {
				return show();
			},
			closeOnClick: true,
			closeButton: false,
			children: ($$anchor, $$slotProps) => {
				var div = root_1$a();
				const SvelteComponent = derived(inputComponent);
				const SvelteComponent_1 = derived(outputComponent);
				var node = child(div);

				component(node, () => get$2(SvelteComponent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(
						{
							get ontermChange() {
								return $$props.ontermChange;
							}
						},
						inputComponentProps,
						{
							get term() {
								return term();
							},
							set term($$value) {
								term($$value);
							}
						}
					));
				});

				var node_1 = sibling(node, 2);

				component(node_1, () => get$2(SvelteComponent_1), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(
						{
							get onprev() {
								return $$props.onprev;
							},
							get onnext() {
								return $$props.onnext;
							},
							get onresolve() {
								return $$props.onresolve;
							}
						},
						outputComponentProps,
						{
							get data() {
								return results();
							},
							set data($$value) {
								results($$value);
							}
						}
					));
				});

				var node_2 = sibling(node_1, 2);

				Ui_buttons(node_2, {
					values: buttons,
					centered: true,
					classes: "mt-5"
				});

				reset(div);
				template_effect(() => set_class(div, `paper box block ${size() ?? ""} svelte-7m3ic0`));
				append($$anchor, div);
			},
			$$slots: { default: true }
		});

		pop();
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIGenericSelector: Ui_generic_selector,
		UIModal: Ui_modal,
		UIOverlay: Ui_overlay
	});

	var root_2$6 = template(`<p> </p>`);
	var root_4$5 = template(`<p> </p>`);
	var root$c = template(`<article><div class="message-header"><!></div> <div class="message-body"><!></div></article>`);

	function Ui_message($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		let classes = prop($$props, "class", 3, "");
		var article = root$c();
		var div = child(article);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.titleSnip, () => $$props.title);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var p = root_2$6();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, $LOCALE()[$$props.title]));
				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if ($$props.titleSnip) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var node_2 = child(div_1);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_3 = first_child(fragment_1);

				snippet(node_3, () => $$props.messageSnip, () => $$props.message);
				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var p_1 = root_4$5();
				var text_1 = child(p_1, true);

				reset(p_1);
				template_effect(() => set_text(text_1, $LOCALE()[$$props.message]));
				append($$anchor, p_1);
			};

			if_block(node_2, ($$render) => {
				if ($$props.messageSnip) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		reset(div_1);
		reset(article);
		template_effect(() => set_class(article, `message ${classes() ?? ""} ${($$props.color ? `is-${$$props.color}` : '') ?? ""}`));
		append($$anchor, article);
		pop();
	}

	function Ui_error($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, "class", 19, () => UICommon$1.CLASS_ERR),
			props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "class"]);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	function Ui_success($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, "class", 19, () => UICommon$1.CLASS_OK),
			props = rest_props($$props, ["$$slots", "$$events", "$$legacy", "class"]);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	var root_1$9 = template(`<div><p> </p> <!></div>`);

	function Ui_cookie_notification($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [show = false]
		 * @property {string} [message]
		 * @property {string} [agree]
		 */
		/** @type {Props} */
		let show = prop($$props, "show", 15, false),
			message = prop($$props, "message", 3, "Для улучшения работы сайта и его взаимодействия с пользователями мы используем файлы cookie. Продолжая работу с сайтом, Вы разрешаете использование cookie-файлов. Вы всегда можете отключить файлы cookie в настройках Вашего браузера."),
			agree = prop($$props, "agree", 3, "Хорошо"),
			cooldown = prop($$props, "cooldown", 3, 31536000000),
			lsKey = prop($$props, "lsKey", 3, "cookie_date"),
			id = prop($$props, "id", 3, "cookie_notification");

		onMount(() => {
			let cookieDate = localStorage.getItem(lsKey());

			if (!cookieDate || +cookieDate + cooldown() < Date.now()) {
				show(true);
			}
		});

		function accept() {
			localStorage.setItem(lsKey(), Date.now());
			show(false);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$9();
				var p = child(div);
				var text$1 = child(p, true);

				reset(p);

				var node_1 = sibling(p, 2);

				Ui_button(node_1, {
					onclick: accept,
					color: "success",
					class: "cookie_accept",
					children: ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[agree()]));
						append($$anchor, text_1);
					},
					$$slots: { default: true }
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, "id", id());
					set_text(text$1, $LOCALE()[message()]);
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UICookieNotification: Ui_cookie_notification,
		UIError: Ui_error,
		UIMessage: Ui_message,
		UISuccess: Ui_success
	});

	//block elements

	var Elements = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Blocks: index$c,
		Buttons: index$b,
		Forms: index$8,
		Icons: index$9,
		Images: index$7,
		Inputs: index$5,
		Layouts: index$6,
		Links: index$4,
		Lists: index$3,
		Modals: index$2,
		Notifications: index$1,
		UICommon: UICommon$1,
		Various: index$a
	});

	const META_METHOD_INIT = Symbol("init"),
	  META_DATA = Symbol("data"),
	  META_WORKING = Symbol("working"),
	  META_OPTIONS = Symbol("options");
	let notBase = /*#__PURE__*/function (_EventEmitter) {
	  function notBase(input) {
	    var _this;
	    _classCallCheck(this, notBase);
	    _this = _callSuper(this, notBase);
	    _this[META_DATA] = {};
	    _this[META_WORKING] = {};
	    _this[META_OPTIONS] = {};
	    _this[META_METHOD_INIT](input);
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notBase, _EventEmitter);
	  return _createClass(notBase, [{
	    key: META_METHOD_INIT,
	    value: function (input) {
	      if (!input) {
	        input = {};
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "data")) {
	        this.setData(input.data);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "working")) {
	        this.setWorking(input.working);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "options")) {
	        this.setOptions(input.options);
	      }
	      this.log = notCommon$1.genLogMsg(this.getWorking("name"));
	      this.info = this.log;
	      this.debug = notCommon$1.genLogDebug(this.getWorking("name"));
	      this.error = notCommon$1.genLogError(this.getWorking("name"));
	    }
	  }, {
	    key: "setCommon",
	    value: function setCommon(what, args) {
	      switch (args.length) {
	        case 1:
	          {
	            /* set collection */
	            what = args[0];
	            break;
	          }
	        case 2:
	          {
	            /* set collection element */
	            notPath.set(args[0] /* path */, what /* collection */, undefined /* helpers */, args[1] /* value */);
	            break;
	          }
	      }
	      return this;
	    }
	  }, {
	    key: "getCommon",
	    value: function getCommon(what, args) {
	      switch (args.length) {
	        /* if we want get data by path */
	        case 1:
	          {
	            return notPath.get(args[0], what);
	          }
	        /* if we want get data by path with default value */
	        case 2:
	          {
	            let res = notPath.get(args[0], what);
	            if (res === undefined) {
	              /* no data, return default value */
	              return args[1];
	            } else {
	              /* data, return it */
	              return res;
	            }
	          }
	        /* return full collection */
	        default:
	          {
	            return what;
	          }
	      }
	    }

	    /*
	    CORE OBJECT
	      DATA - information
	      OPTIONS - how to work
	      WORKING - temporarily generated in proccess
	    */
	  }, {
	    key: "setData",
	    value: function setData() {
	      if (arguments.length === 1) {
	        this[META_DATA] = arguments[0];
	      } else {
	        this.setCommon(this.getData(), arguments);
	      }
	      this.emit("change");
	      return this;
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.getCommon(this[META_DATA], arguments);
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions() {
	      if (arguments.length === 1) {
	        this[META_OPTIONS] = arguments[0];
	      } else {
	        this.setCommon(this.getOptions(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      return this.getCommon(this[META_OPTIONS], arguments);
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking() {
	      if (arguments.length === 1) {
	        this[META_WORKING] = arguments[0];
	      } else {
	        this.setCommon(this.getWorking(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking() {
	      return this.getCommon(this[META_WORKING], arguments);
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon$1.report) {
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removeEvent();
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	      this.emit("destroy");
	    }
	  }]);
	}(EventEmitter);

	const OPT_MODE_HISTORY = Symbol("history"),
	  OPT_MODE_HASH = Symbol("hash"),
	  OPT_DEFAULT_CHECK_INTERVAL = 50;
	let notRouter = /*#__PURE__*/function (_notBase) {
	  function notRouter() {
	    var _this;
	    _classCallCheck(this, notRouter);
	    _this = _callSuper(this, notRouter, [{
	      working: {
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/",
	        //always in slashes /user/, /, /input/. and no /user or input/level
	        initialized: false,
	        delays: NAVIGATION_DELAYS,
	        delay_default: NAVIGATION_DELAY_DEFAULT
	      }
	    }]);
	    _defineProperty(_this, "host", "");
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Set object with named delays
	   * @param {Object.<string, number>} delays
	   * @returns {notRouter}
	   */
	  _inherits(notRouter, _notBase);
	  return _createClass(notRouter, [{
	    key: "setDelays",
	    value: function setDelays(delays) {
	      this.setWorking("delays", delays);
	      return this;
	    }

	    /**
	     * Set default navigation delay, provided as name of one of `delays` or in number form
	     * @param {string|number} delay
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setDefaultNavigationDelay",
	    value: function setDefaultNavigationDelay(delay) {
	      this.setWorking("delay_default", this.delayAsMs(delay));
	      return this;
	    }

	    /**
	     * Returns number of ms, if not set returns NAVIGATION_DELAY_DEFAULT
	     * @returns {number}
	     */
	  }, {
	    key: "getDefaultNavigationDelay",
	    value: function getDefaultNavigationDelay() {
	      return this.getWorking(`delay_default`, NAVIGATION_DELAY_DEFAULT);
	    }

	    /**
	     *  Ensures that delay is in ms, if its provided as name of alias, searches for it and returns, if not found - returns working default_delay
	     * @param {string|number} delay    name of delay alias or number of ms
	     * @returns {number}               delay in ms
	     */
	  }, {
	    key: "delayAsMs",
	    value: function delayAsMs(delay) {
	      if (typeof delay === "number") {
	        return delay;
	      } else {
	        if (typeof delay === "string" && delay.length > 0) {
	          return this.getWorking(`delays.${delay}`, this.getDefaultNavigationDelay());
	        } else {
	          return this.getDefaultNavigationDelay();
	        }
	      }
	    }

	    /**
	     *
	     *  @param {string}              url     we go to url
	     *  @param {string|number}       delay   name of delay alias or number of ms
	     *  @returns {NodeJS.Timeout}            timeout identificator
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay, doBefore) {
	      var _this2 = this;
	      return setTimeout(function () {
	        typeof doBefore === "function" && doBefore();
	        _this2.navigate(url);
	      }, this.delayAsMs(delay));
	    }

	    /**
	     * Use browser History API
	     */
	  }, {
	    key: "history",
	    value: function history() {
	      this.setWorking("mode", OPT_MODE_HISTORY);
	    }

	    /**
	     * Use hash part as container for location information
	     */
	  }, {
	    key: "hash",
	    value: function hash() {
	      this.setWorking("mode", OPT_MODE_HASH);
	    }

	    /**
	     * root should start and end with
	     * @param {string} root
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setRoot",
	    value: function setRoot(root) {
	      this.setWorking("root", root && root !== "/" ? "/" + this.clearSlashes(root) + "/" : "/");
	      return this;
	    }

	    /**
	     * clear first and last slashes from string
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "clearSlashes",
	    value: function clearSlashes(path) {
	      return path.toString().replace(/\/$/, "").replace(/^\//, "");
	    }
	  }, {
	    key: "add",
	    value: function add(re, handler) {
	      if (typeof re == "function") {
	        handler = re;
	        re = "";
	      }
	      let rule = {
	        re: re,
	        handler: handler
	      };
	      this.getWorking("routes").push(rule);
	      return this;
	    }
	  }, {
	    key: "addList",
	    value: function addList(list) {
	      for (let t in list) {
	        this.add(t, list[t]);
	      }
	      return this;
	    }
	  }, {
	    key: "remove",
	    value: function remove(param) {
	      for (var i = 0, r; i < this.getWorking("routes").length, r = this.getWorking("routes")[i]; i++) {
	        if (r.handler === param || r.re === param) {
	          this.getWorking("routes").splice(i, 1);
	          return this;
	        }
	      }
	      return this;
	    }
	  }, {
	    key: "flush",
	    value: function flush() {
	      this.setWorking({
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/"
	      });
	      return this;
	    }
	  }, {
	    key: "isInitialized",
	    value: function isInitialized() {
	      return this.getWorking("initialized");
	    }
	  }, {
	    key: "setInitialized",
	    value: function setInitialized(val = true) {
	      return this.setWorking("initialized", val);
	    }
	  }, {
	    key: "getFragment",
	    value: function getFragment() {
	      var fragment = "";
	      if (this.getWorking("mode") === OPT_MODE_HISTORY) {
	        if (!location) return "";
	        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
	        fragment = fragment.replace(/\?(.*)$/, "");
	        fragment = this.getWorking("root") != "/" ? fragment.replace(this.getWorking("root"), "") : fragment;
	      } else {
	        if (!window) return "";
	        var match = window.location.href.match(/#(.*)$/);
	        fragment = match ? match[1] : "";
	      }
	      return this.clearSlashes(fragment);
	    }
	  }, {
	    key: "checkLocation",
	    value: function checkLocation() {
	      let current = this.getWorking("current"),
	        fragment = this.getFragment(),
	        init = this.isInitialized();
	      if (current !== fragment || !init) {
	        this.setWorking("current", fragment);
	        this.check(fragment);
	        this.setInitialized(true);
	      }
	    }
	  }, {
	    key: "hrefClick",
	    value: function hrefClick() {
	      //console.log(...arguments);
	    }
	  }, {
	    key: "getRoot",
	    value: function getRoot() {
	      return this.getWorking("root");
	    }
	  }, {
	    key: "listen",
	    value: function listen(loopInterval = OPT_DEFAULT_CHECK_INTERVAL) {
	      this.setWorking("current", "notInitialized");
	      clearInterval(this.getWorking("interval"));
	      this.setWorking("interval", setInterval(this.checkLocation.bind(this), loopInterval));
	      window.addEventListener("popstate", this.hrefClick.bind(this));
	      return this;
	    }
	  }, {
	    key: "check",
	    value: function check(f) {
	      let fragment = f || this.getFragment(),
	        failBack = null;
	      for (let i = 0; i < this.getWorking("routes").length; i++) {
	        let path = this.getWorking("root") + this.getWorking("routes")[i].re,
	          fullRE = this.clearSlashes(decodeURI(path)),
	          match = fragment.match(fullRE);
	        if (match && match.length) {
	          if (fullRE === "") {
	            match.shift();
	            failBack = {
	              route: this.getWorking("routes")[i],
	              match
	            };
	          } else {
	            match.shift();
	            this.getWorking("routes")[i].handler.apply(this.host || {}, match);
	            this.emit("afterRoute", this.getWorking("routes")[i]);
	            return this;
	          }
	        }
	      }
	      if (failBack) {
	        failBack.route.handler.apply(this.host || {}, failBack.match);
	        this.emit("afterRoute", failBack.route);
	      }
	      return this;
	    }

	    /**
	     *  Refreshes page
	     * @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      var _this3 = this;
	      if (timeout > 0) {
	        setTimeout(function () {
	          return _this3.refresh();
	        }, timeout);
	      } else {
	        this.check(this.getWorking("current"));
	      }
	    }

	    /**
	     * Changes locations
	     * @param {string} path
	     * @returns
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(path) {
	      path = path ? path : "";
	      switch (this.getWorking("mode")) {
	        case OPT_MODE_HISTORY:
	          {
	            const newRoute = this.getFullRoute(path);
	            if (newRoute === this.lastRoute) {
	              this.refresh();
	            } else {
	              this.lastRoute = newRoute;
	              history.pushState(null, "", this.lastRoute);
	            }
	            break;
	          }
	        case OPT_MODE_HASH:
	          {
	            window.location.href.match(/#(.*)$/);
	            window.location.href = window.location.href.replace(/#(.*)$/, "") + "#" + path;
	            break;
	          }
	      }
	      return this;
	    }

	    /**
	     *  returns app root + path
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "getFullRoute",
	    value: function getFullRoute(path = "") {
	      path = this.clearSlashes(path);
	      const root = this.getWorking("root");
	      if (root !== "/") {
	        if (path.indexOf(root.substring(1)) === 0) {
	          return "/" + path;
	        }
	      }
	      return this.getWorking("root") + this.clearSlashes(path);
	    }

	    /**
	     * Returns all links with n-href attribute
	     * @returns {Array<HTMLAnchorElement>}
	     */
	  }, {
	    key: "getAllLinks",
	    value: function getAllLinks() {
	      const allElements = document.body.querySelectorAll("a");
	      let list = [];
	      for (let j = 0; j < allElements.length; j++) {
	        for (let i = 0, atts = allElements[j].attributes, n = atts.length; i < n; i++) {
	          if (atts[i].nodeName.indexOf("n-href") === 0) {
	            list.push(allElements[j]);
	            break;
	          }
	        }
	      }
	      return list;
	    }

	    /**
	     * Reroute all links(anchor tags) with n-href attribute.
	     * Disable navigation to href.
	     * @returns {notRouter}
	     */
	  }, {
	    key: "reRouteExisted",
	    value: function reRouteExisted() {
	      const list = this.getAllLinks();
	      for (let t = 0; t < list.length; t++) {
	        this.initRerouting(list[t], list[t].getAttribute("n-href"));
	      }
	      return this;
	    }

	    /**
	     * If `el` is not initialized, adds onclick listener to navigate to `link` location.
	     * Disables default navigation to href.
	     * @param {HTMLAnchorElement}   el
	     * @param {string}              link
	     * @returns
	     */
	  }, {
	    key: "initRerouting",
	    value: function initRerouting(el, link) {
	      var _this4 = this;
	      // @ts-ignore
	      if (!el.notRouterInitialized) {
	        let fullLink = this.getFullRoute(link);
	        el.setAttribute("href", fullLink);
	        el.addEventListener("click", function (e) {
	          e.preventDefault();
	          _this4.navigate(link);
	          return false;
	        });
	        // @ts-ignore
	        el.notRouterInitialized = true;
	      }
	      return this;
	    }
	  }]);
	}(notBase);
	var notRouter$1 = new notRouter();

	const LOG_PREFIX$1 = "APIQuee";
	let notAPIQueue = /*#__PURE__*/function (_notBase) {
	  function notAPIQueue(options = {}) {
	    var _this;
	    _classCallCheck(this, notAPIQueue);
	    _this = _callSuper(this, notAPIQueue, [{
	      working: {
	        name: options.name ? options.name : LOG_PREFIX$1
	      },
	      options
	    }]);
	    _this.busy = false;
	    _this.queue = [];
	    _this.busySince = -1;
	    _this.afterEmpty = undefined;
	    _this.start();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIQueue, _notBase);
	  return _createClass(notAPIQueue, [{
	    key: "stop",
	    value: function stop() {
	      if (this.interval) {
	        clearInterval(this.interval);
	        this.interval = undefined;
	        this.busy = false;
	        this.busySince = -1;
	      }
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      this.stop();
	      this.interval = setInterval(this.checkQueue.bind(this), this.QUEUE_CHECK_INTERVAL);
	    }
	  }, {
	    key: "checkQueue",
	    value: function checkQueue() {
	      var _this2 = this;
	      if (!this.isEmpty() && !this.isBusy()) {
	        this.setBusy().runNext().then(this.setFree.bind(this)).catch(function (e) {
	          _this2.error && _this2.error(e);
	          _this2.setFree();
	        });
	      } else {
	        if (!this.isBusy()) {
	          if (this.afterEmpty) {
	            let t = this.afterEmpty;
	            this.afterEmpty = undefined;
	            t();
	          }
	        }
	      }
	    }
	  }, {
	    key: "addToQueue",
	    value: function addToQueue(task) {
	      this.queue.push(task);
	    }
	  }, {
	    key: "runNext",
	    value: function runNext() {
	      let list = this.queue.map(function (action) {
	        return action.title;
	      }).join(", ");
	      this.debug && this.debug(`tasks [${list}]`);
	      let task = this.queue.shift();
	      if (!notCommon$1.isFunc(task.action)) {
	        this.error && this.error("В задании нет исполнимой части, action не функция", task.title);
	        return Promise.resolve();
	      }
	      if (!notCommon$1.isFunc(task.resolve)) {
	        this.error && this.error("В задании нет возвратной части, resolve не функция", task.title);
	        return task.action();
	      }
	      return task.action().then(task.resolve);
	    }
	  }, {
	    key: "isBusy",
	    value: function isBusy() {
	      let busy = !!this.busy,
	        now = Date.now() / 1000;
	      if (busy && this.busySince > -1) {
	        if (now - this.busySince > notAPIQueue.MAX_BUSY_TIME) {
	          this.setFree();
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "setBusy",
	    value: function setBusy() {
	      this.busy = true;
	      this.busySince = Date.now() / 1000;
	      return this;
	    }
	  }, {
	    key: "setFree",
	    value: function setFree() {
	      this.busy = false;
	      this.busySince = -1;
	      return this;
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return this.queue.length === 0;
	    }

	    /**
	     * Исполнитель запросов
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @returns    {Promise}    результат функции
	     **/
	  }, {
	    key: "run",
	    value: function run(action, afterEmpty = undefined, title = "") {
	      var _this3 = this;
	      if (afterEmpty && typeof this.afterEmpty === "undefined") {
	        this.afterEmpty = afterEmpty;
	      }
	      return new Promise(function (resolve, reject) {
	        try {
	          _this3.addToQueue({
	            action,
	            resolve,
	            title
	          });
	        } catch (e) {
	          _this3.error && _this3.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "actionIsQueued",
	    value: function actionIsQueued(title) {
	      return this.queue.some(function (queued) {
	        return queued.title == title;
	      });
	    }

	    /**
	     *
	     *
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @return    {Promise}
	     * @memberof notAPIQueue
	     */
	  }, {
	    key: "runIfNotQueued",
	    value: function runIfNotQueued(action, afterEmpty = undefined, title = "") {
	      if (this.actionIsQueued(title)) {
	        return Promise.resolve();
	      } else {
	        return this.run(action, afterEmpty, title);
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIQueue, "QUEUE_CHECK_INTERVAL", 100);
	_defineProperty(notAPIQueue, "MAX_BUSY_TIME", 300);

	let notAPIOptions = {
	  rps: 50,
	  protocol: 'http',
	  host: 'localhost',
	  port: 9000
	};

	const LOG_PREFIX = 'APIConnection';
	let notAPIConnection = /*#__PURE__*/function (_notBase) {
	  function notAPIConnection(options) {
	    var _this;
	    _classCallCheck(this, notAPIConnection);
	    _this = _callSuper(this, notAPIConnection, [{
	      options,
	      working: {
	        name: options.name ? options.name : LOG_PREFIX
	      }
	    }]);
	    _this.online = null;
	    _this.run();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIConnection, _notBase);
	  return _createClass(notAPIConnection, [{
	    key: "run",
	    value: function run() {
	      this.int = window.setInterval(this.check.bind(this), 1000);
	    }
	  }, {
	    key: "pause",
	    value: function pause() {
	      window.clearInterval(this.int);
	    }
	  }, {
	    key: "resume",
	    value: function resume() {
	      this.run();
	    }
	  }, {
	    key: "isOnline",
	    value: function isOnline() {
	      return window.navigator.onLine;
	    }
	  }, {
	    key: "check",
	    value: function check() {
	      let t = this.isOnline();
	      if (this.online !== null) {
	        if (this.online !== t) {
	          this.changeState(t);
	        }
	      }
	      this.online = t;
	    }
	  }, {
	    key: "changeState",
	    value: function changeState(online = false) {
	      if (online) {
	        this.emit('online');
	      } else {
	        this.emit('offline');
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIConnection, "int", void 0);
	_defineProperty(notAPIConnection, "online", void 0);

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		notAPIConnection: notAPIConnection,
		notAPIOptions: notAPIOptions,
		notAPIQueue: notAPIQueue
	});

	const ALL$1 = {};
	function exist$1(key) {
	  return notCommon$1.objHas(ALL$1, key);
	}
	function get$1(key) {
	  if (exist$1(key)) {
	    return ALL$1[key];
	  } else {
	    return false;
	  }
	}
	function create$1(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist$1(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL$1[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL$1[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL$1[key];
	}

	/**
	 * Creates object that is fake Store
	 * Some time this is useful when you need to initialize local var,
	 * before you could get actual Stores from central storage by its ID
	 *	@params {mixed} val 	data of type that is actual storage will contain
	 * @returns {Object}
	 */

	function fake(val) {
	  return {
	    subscribe(f) {
	      f(val);
	      return function () {};
	    },
	    set() {}
	  };
	}

	var stores = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		fake: fake,
		get: get$1
	});

	const //record
	  META_INTERFACE = Symbol('interface'),
	  META_MAP_TO_INTERFACE = ['getActionsCount', 'getActions', 'setFindBy', 'resetFilter', 'setFilter', 'getFilter', 'setSorter', 'getSorter', 'resetSorter', 'setPageNumber', 'setPageSize', 'setPager', 'setReturn', 'setSearch', 'getSearch', 'resetSearch', 'resetPager', 'getPager', 'addFormFieldType', 'addFormField', 'getFieldTypes', 'getActionFormFields'],
	  DEFAULT_ACTION_PREFIX$1 = '$';

	const OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY = ["_id", "id", "ID"],
	  DEFAULT_FILTER = {},
	  DEFAULT_SEARCH = "",
	  DEFAULT_RETURN = {},
	  DEFAULT_PAGE_NUMBER = 0,
	  DEFAULT_PAGE_SIZE = 10,
	  DEFAULT_ACTION_PREFIX = "$",
	  DEFAULT_WS_ROUTE_ACTION_SPLITTER = "//";
	let notInterface = /*#__PURE__*/function (_notBase) {
	  function notInterface(manifest, options) {
	    var _this;
	    _classCallCheck(this, notInterface);
	    _this = _callSuper(this, notInterface, [{
	      working: {
	        name: "network interface for: " + (manifest.model ? manifest.model : "unknown"),
	        filter: DEFAULT_FILTER,
	        search: DEFAULT_SEARCH,
	        return: DEFAULT_RETURN,
	        pager: {
	          size: DEFAULT_PAGE_SIZE,
	          page: DEFAULT_PAGE_NUMBER
	        }
	      },
	      options
	    }]);
	    _this.manifest = manifest;
	    _this.initActions();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notInterface, _notBase);
	  return _createClass(notInterface, [{
	    key: "initActions",
	    value: function initActions() {
	      if (this.getActionsCount() > 0) {
	        let actions = this.getActions();
	        for (let actionName in actions) {
	          this.initAction(actionName);
	        }
	      }
	    }
	  }, {
	    key: "initAction",
	    value: function initAction(actionName) {
	      var _this2 = this;
	      if (!notCommon$1.objHas(this, DEFAULT_ACTION_PREFIX + actionName)) {
	        this[DEFAULT_ACTION_PREFIX + actionName] = function (opts, headers, fileUpload = false, files) {
	          return _this2.request(_this2, actionName, opts, headers, fileUpload, files);
	        };
	      }
	    }
	  }, {
	    key: "requestHTTP",
	    value: function requestHTTP(record, actionName, params, headers = {}, fileUpload = false, files) {
	      try {
	        let compositeData = Object.assign({}, record.getData && typeof record.getData === "function" ? record.getData() : record, params);
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData),
	          requestParamsEncoded = this.encodeRequest(requestParams),
	          //id = this.getID(compositeData, actionData, actionName),
	          apiServerURL = this.getServerURL(),
	          url = this.getURL(compositeData, actionData, actionName),
	          opts = {};
	        if (fileUpload) {
	          url = this.getURL(params, actionData, actionName);
	          const fd = new FormData();
	          fd.append("file", files);
	          opts.body = fd;
	        } else {
	          if (["OPTIONS", "GET"].indexOf(actionData.method.toUpperCase()) === -1) {
	            opts = {
	              method: actionData.method,
	              body: JSON.stringify(record.getData && typeof record.getData === "function" ? record.getData() : record),
	              headers: {
	                Accept: "application/json",
	                "Content-Type": "application/json"
	              }
	            };
	          }
	        }
	        opts.method = actionData.method.toUpperCase();
	        if (headers && Object.keys(headers).length) {
	          opts.headers = headers;
	        }
	        return fetch(apiServerURL + url + requestParamsEncoded, opts).then(function (response) {
	          return response.json();
	        });
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "requestWS",
	    value: function requestWS(record, actionName) {
	      try {
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData);
	        const WS = notCommon$1.getApp().getWSClient();
	        const messageName = this.getWSRequestName(actionName);
	        const payload = Object.assign({}, requestParams, record.getData());
	        if (notCommon$1.objHas(actionData, "type") && typeof actionData.type === "string" && actionData.type.length && actionData.type !== "request") {
	          return WS.message(actionData.type, messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        } else {
	          return WS.request(messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        }
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "request",
	    value: function request() {
	      let actionData = this.getActionData(arguments[1]);
	      switch (this.selectTransport(actionData)) {
	        case "ws":
	          return this.requestWS(...arguments);
	        case "http":
	          return this.requestHTTP(...arguments);
	        default:
	          throw new Error("Offline");
	      }
	    }
	  }, {
	    key: "wsIsUp",
	    value: function wsIsUp(actionData) {
	      if (actionData.ws === true) {
	        let client;
	        if (notCommon$1.objHas(actionData, "wsClient") && actionData.wsClient) {
	          client = notCommon$1.getApp().getWSClient(actionData.wsClient);
	        } else {
	          client = notCommon$1.getApp().getWSClient();
	        }
	        if (client) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "selectTransport",
	    value: function selectTransport(actionData) {
	      if (this.wsIsUp(actionData)) {
	        return "ws"; //for ws/wss
	      }
	      if (notCommon$1.objHas(actionData, "method")) {
	        return "http"; //for http/https
	      }
	      return false; //for offline
	    }
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this && this.manifest ? this.manifest.model : null;
	    }
	  }, {
	    key: "getActionData",
	    value: function getActionData(actionName) {
	      return this.getActions() && this.getActions()[actionName] ? this.getActions()[actionName] : null;
	    }
	  }, {
	    key: "getActionsCount",
	    value: function getActionsCount() {
	      return this.getActions() ? Object.keys(this.getActions()).length : 0;
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.manifest && this.manifest.actions ? this.manifest.actions : {};
	    }
	  }, {
	    key: "parseParams",
	    value: function parseParams(start, end, line, record) {
	      let fieldName = "";
	      let len = start.length;
	      while (line.indexOf(start) > -1) {
	        let ind = line.indexOf(start);
	        let startSlice = ind + len;
	        let endSlice = line.indexOf(end);
	        if (ind > endSlice) {
	          break;
	        }
	        fieldName = line.slice(startSlice, endSlice);
	        if (fieldName == "") break;
	        this.log && this.log(start + fieldName + end, notPath.get(fieldName, record));
	        line = line.replace(start + fieldName + end, notPath.get(fieldName, record));
	      }
	      return line;
	    }
	  }, {
	    key: "parseLine",
	    value: function parseLine(line, record, actionName) {
	      line = line.replace(":modelName", this.manifest.model);
	      line = line.replace(":actionName", actionName);
	      line = this.parseParams(":record[", "]", line, record);
	      line = this.parseParams(":", "?", line, record);
	      return line;
	    }
	  }, {
	    key: "getURL",
	    value: function getURL(record, actionData, actionName) {
	      var line = this.parseLine(this.manifest.url, record, actionName) + (notCommon$1.objHas(actionData, "postFix") ? this.parseLine(actionData.postFix, record, actionName) : "");
	      return line;
	    }
	  }, {
	    key: "getServerURL",
	    value: function getServerURL() {
	      return notCommon$1.getApp() ? notCommon$1.getApp().getOptions("api.server.url", "") : "";
	    }
	  }, {
	    key: "getWSRequestName",
	    value: function getWSRequestName(actionName) {
	      const modelName = this.manifest.model;
	      return `${modelName}${DEFAULT_WS_ROUTE_ACTION_SPLITTER}${actionName}`;
	    }
	  }, {
	    key: "encodeRequest",
	    value: function encodeRequest(data) {
	      let p = "?";
	      for (let t in data) {
	        if (typeof data[t] !== "undefined" && data[t] !== null) {
	          p += encodeURIComponent(t) + "=" + encodeURIComponent(data[t].constructor === Object ? JSON.stringify(data[t]) : data[t]) + "&";
	        }
	      }
	      //for test purpose only, special test server needed
	      if (this.getOptions("test")) {
	        p += "&test=1";
	        if (this.getOptions("test.session")) {
	          p += "&session=" + this.getOptions("test.session");
	        }
	        if (this.getOptions("test.session")) {
	          p += "&role=" + this.getOptions("test.role");
	        }
	      }
	      return p;
	    }
	  }, {
	    key: "collectRequestData",
	    value: function collectRequestData(actionData) {
	      let requestData = {};
	      if (notCommon$1.objHas(actionData, "data") && Array.isArray(actionData.data)) {
	        for (let i = 0; i < actionData.data.length; i++) {
	          let dataProviderName = "get" + notCommon$1.capitalizeFirstLetter(actionData.data[i]);
	          if (this[dataProviderName] && typeof this[dataProviderName] === "function") {
	            let data = this[dataProviderName](),
	              res = {};
	            if (["pager", "sorter", "filter", "search", "return"].indexOf(actionData.data[i]) > -1) {
	              res[actionData.data[i]] = data;
	            } else {
	              res = data;
	            }
	            requestData = Object.assign(requestData, res);
	          }
	        }
	      }
	      return requestData;
	    }
	  }, {
	    key: "getID",
	    value: function getID(record, actionData) {
	      let resultId,
	        list = OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY,
	        prefixes = ["", this.manifest.model];
	      if (notCommon$1.objHas(actionData, "index") && actionData.index) {
	        list = [actionData.index].concat(OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY);
	      }
	      for (let pre of prefixes) {
	        for (let t of list) {
	          if (notCommon$1.objHas(record, pre + t)) {
	            resultId = record[pre + t];
	            break;
	          }
	        }
	      }
	      return resultId;
	    }
	  }, {
	    key: "setFindBy",
	    value: function setFindBy(key, value) {
	      var obj = {};
	      obj[key] = value;
	      return this.setFilter(obj);
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(filterData = DEFAULT_FILTER) {
	      this.setWorking("filter", filterData);
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      return this.setFilter();
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getWorking("filter");
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(searchData = DEFAULT_SEARCH) {
	      this.setWorking("search", searchData);
	      return this;
	    }
	  }, {
	    key: "resetSearch",
	    value: function resetSearch() {
	      return this.setSearch();
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      return this.getWorking("search");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(sorterData) {
	      this.setWorking("sorter", sorterData);
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter() {
	      return this.setSorter({});
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(returnData = DEFAULT_RETURN) {
	      this.setWorking("return", returnData);
	      return this;
	    }
	  }, {
	    key: "resetReturn",
	    value: function resetReturn() {
	      return this.setReturn({});
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setPageNumber",
	    value: function setPageNumber(pageNumber) {
	      this.setWorking("pager.page", pageNumber);
	      return this;
	    }
	  }, {
	    key: "setPageSize",
	    value: function setPageSize(pageSize) {
	      this.setWorking("pager.size", pageSize);
	      return this;
	    }

	    //pageSize = DEFAULT_PAGE_SIZE, pageNumber = DEFAULT_PAGE_NUMBER
	  }, {
	    key: "setPager",
	    value: function setPager() {
	      if ((arguments.length < 2 || isNaN(arguments[0]) || isNaN(arguments[1])) && arguments[0].constructor === Object && notCommon$1.objHas(arguments[0], "page") && notCommon$1.objHas(arguments[0], "size")) {
	        const pager = arguments[0];
	        this.setWorking("pager", {
	          size: pager.size || DEFAULT_PAGE_SIZE,
	          page: pager.page || DEFAULT_PAGE_NUMBER
	        });
	      } else if (arguments.length === 2 && !isNaN(arguments[0]) && !isNaN(arguments[1])) {
	        this.setWorking("pager", {
	          size: arguments[0] || DEFAULT_PAGE_SIZE,
	          page: arguments[1] || DEFAULT_PAGE_NUMBER
	        });
	      }
	      return this;
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      return this.setPager();
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getWorking("pager");
	    }
	  }, {
	    key: "getRecord",
	    value: function getRecord() {
	      this.getData();
	    }
	  }, {
	    key: "getDefaultAsPlainObject",
	    value: function getDefaultAsPlainObject() {
	      if (!this.manifest || !this.manifest.fields) {
	        return {};
	      }
	      const result = {};
	      for (const fieldName of Object.keys(this.manifest.fields)) {
	        if (Object.hasOwn(this.manifest.fields[fieldName], "default")) {
	          const defaultValue = this.manifest.fields[fieldName].default;
	          if (Array.isArray(defaultValue)) {
	            result[fieldName] = [...defaultValue];
	          } else if (typeof defaultValue === "object") {
	            result[fieldName] = {
	              ...defaultValue
	            };
	          } else {
	            result[fieldName] = defaultValue;
	          }
	        }
	      }
	      return result;
	    }
	  }]);
	}(notBase);

	let notRecord = /*#__PURE__*/function (_notBase) {
	  function notRecord(manifest, item) {
	    var _this;
	    _classCallCheck(this, notRecord);
	    _this = _callSuper(this, notRecord);
	    if (typeof item === "undefined" || item === null || typeof item !== "object") {
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && item.isProxy) {
	      notCommon$1.error("this is Proxy item");
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && (item.isRecord || item.isProperty)) {
	      return _possibleConstructorReturn(_this, item);
	    } else {
	      if (Array.isArray(item)) {
	        return _possibleConstructorReturn(_this, _this.createCollection(manifest, item));
	      }
	    }
	    _this.setOptions({});
	    _this[META_INTERFACE] = new notInterface(manifest, {});
	    _this.setData(item);
	    _this.interfaceUp();
	    _this.mapToInterface();
	    _this.mapToMethods();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notRecord, _notBase);
	  return _createClass(notRecord, [{
	    key: "toDefault",
	    value: function toDefault() {
	      return this.setData(this[META_INTERFACE].getDefaultAsPlainObject());
	    }
	  }, {
	    key: "mapToInterface",
	    value: function mapToInterface() {
	      let rec = this;
	      for (let t of META_MAP_TO_INTERFACE) {
	        if (this[META_INTERFACE][t] && typeof this[META_INTERFACE][t] === "function") {
	          this[t] = function () {
	            let res = rec[META_INTERFACE][t](...arguments);
	            return res == rec[META_INTERFACE] ? rec : res;
	          };
	        }
	      }
	    }
	  }, {
	    key: "mapToMethods",
	    value: function mapToMethods() {
	      let manifest = this[META_INTERFACE].manifest,
	        app = notCommon$1.getApp(),
	        methods = {};
	      if (manifest.methods) {
	        methods = manifest.methods;
	      } else if (app) {
	        methods = app.getOptions(["models", this[META_INTERFACE].manifest.model].join("."), {});
	      }
	      if (methods) {
	        for (let t in methods) {
	          if (Object.hasOwn(methods, t)) {
	            this[t] = methods[t];
	          }
	        }
	      }
	    }
	  }, {
	    key: "createCollection",
	    value: function createCollection(manifest, items) {
	      var collection = [];
	      for (var i = 0; i < items.length; i++) {
	        collection.push(new notRecord(manifest, items[i]));
	      }
	      return collection;
	    }
	  }, {
	    key: "interfaceUp",
	    value: function interfaceUp() {
	      if (this[META_INTERFACE].getActionsCount() > 0) {
	        let actions = this[META_INTERFACE].getActions();
	        for (let i in actions) {
	          this.actionUp(i, actions[i]);
	        }
	      }
	    }
	  }, {
	    key: "actionUp",
	    value: function actionUp(index) {
	      var _this2 = this;
	      if (!Object.hasOwn(this, [DEFAULT_ACTION_PREFIX$1 + index])) {
	        this[DEFAULT_ACTION_PREFIX$1 + index] = function (...params) {
	          return _this2[META_INTERFACE].request(_this2, index, ...params);
	        };
	      }
	    }
	    /*
	    -> 'path.to.key', valueOfKey
	    <- ok, with one onChange event triggered
	    */
	  }, {
	    key: "setAttr",
	    value: function setAttr(key, value) {
	      return this.setData(key, value);
	    }

	    /*
	    ->
	    {
	    'keyPath': value,
	    'key.subPath': value2,
	    'keyPath.0.title': value3
	    }
	    <- ok, with bunch of onChange events triggered
	    */
	  }, {
	    key: "setAttrs",
	    value: function setAttrs(objectPart) {
	      //notCommon.log('setAttrs', objectPart, Object.keys(objectPart));
	      if (objectPart && typeof objectPart === "object" && Object.keys(objectPart).length > 0) {
	        for (let path in objectPart) {
	          //notCommon.log('setAttrs one to go', path);
	          this.setAttr(path, objectPart[path]);
	        }
	      }
	    }

	    /*
	    -> 'pathToKey'
	    <- value1
	    */
	  }, {
	    key: "getAttr",
	    value: function getAttr(what, plain = false) {
	      let prx = this.getData(what, {});
	      if (plain) {
	        return notCommon$1.stripProxy(prx);
	      } else {
	        return prx;
	      }
	    }

	    /*
	    -> ['pathToKey', 'path.to.key', 'simpleKey',...]
	    <- [value1, value2, value3,...]
	    */
	  }, {
	    key: "getAttrs",
	    value: function getAttrs(what) {
	      let result = [];
	      if (what && what.length > 0) {
	        for (let path of what) {
	          result.push(this.getAttr(path));
	        }
	      }
	      return result;
	    }
	  }, {
	    key: "getManifest",
	    value: function getManifest() {
	      if (this[META_INTERFACE]) {
	        return this[META_INTERFACE].manifest;
	      } else {
	        return {};
	      }
	    }
	  }, {
	    key: "setItem",
	    value: function setItem(item) {
	      this.setData(item);
	      return this;
	    }
	  }]);
	}(notBase);

	/**
	 * @const {string} [OPT_CONTROLLER_PREFIX = "nc"] controller names prefix nc aka NotController
	 */
	const OPT_CONTROLLER_PREFIX = "nc";
	/**
	 * @const {string} [OPT_RECORD_PREFIX = "nr"] record names prefix nr aka NotRecord
	 */
	const OPT_RECORD_PREFIX = "nr";
	/**
	 * @const {string} [DEFAULT_WS_CLIENT_NAME = "main"] default name of WS client
	 */
	const DEFAULT_WS_CLIENT_NAME = "main";

	/**
	 * Class of application
	 * @class
	 */
	let notApp = /*#__PURE__*/function (_notBase) {
	  /**
	   * @class
	   * @param {object} options              application options
	   * @param {string} options.name         name
	   * @param {object} options.controllers  controllers
	   * @param {string}  options.manifestURL URL of network manifest with all available models/actions/fields requests options
	   */
	  function notApp(options) {
	    var _this;
	    _classCallCheck(this, notApp);
	    _this = _callSuper(this, notApp, [{
	      working: {
	        name: options.name,
	        interfaces: {},
	        controllers: notCommon$1.objHas(options, "controllers") ? options.controllers : {},
	        initController: null,
	        currentController: null,
	        uis: {},
	        wsc: {},
	        wss: {},
	        services: {}
	      },
	      options
	    }]);
	    _this?.log && _this.log("start app");
	    notCommon$1.register("app", _this);
	    _this.initManifest();
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Initializes application according to network manifest, which is retrieved from server
	   */
	  _inherits(notApp, _notBase);
	  return _createClass(notApp, [{
	    key: "initManifest",
	    value: function initManifest() {
	      var _this2 = this;
	      notCommon$1.getJSON(this.getOptions("manifestURL")).then(function (manifest) {
	        return _this2.setInterfaceManifest(manifest);
	      }).catch(function (e) {
	        return notCommon$1.report(e);
	      });
	    }

	    /**
	     * One page routing initialization
	     */
	  }, {
	    key: "initRouter",
	    value: function initRouter() {
	      this.setWorking("router", notRouter$1);
	      this.getWorking("router").setRoot(this.getOptions("router.root"));
	      notRouter$1.reRouteExisted();
	    }

	    /**
	     * Creates all the routes handlers and pushes them into router
	     */
	  }, {
	    key: "execRouter",
	    value: function execRouter() {
	      var routieInput = {};
	      for (let t = 0; t < this.getOptions("router.manifest").length; t++) {
	        let routeBlock = this.getOptions("router.manifest")[t],
	          paths = routeBlock.paths,
	          schemes = routeBlock.schemes,
	          controller = routeBlock.controller;
	        for (let i = 0; i < paths.length; i++) {
	          let pathScheme = schemes && Array.isArray(schemes) && schemes.length > i ? schemes[i] : false;
	          routieInput[paths[i]] = this.bindController(controller, pathScheme);
	        }
	      }
	      this.getWorking("router").addList(routieInput).listen(); //.navigate(this.getOptions('router.index'));
	    }

	    /**
	     * Sets interface manifest option
	     * @param {object}  manifest    interface manifest
	     */
	  }, {
	    key: "setInterfaceManifest",
	    value: function setInterfaceManifest(manifest) {
	      Object.freeze(manifest);
	      this.setOptions("interfaceManifest", manifest);
	      this.initRouter();
	      this.update();
	    }

	    /**
	     * returns constructor of interface model
	     * @param {string}  modelName   model name
	     * @returns {object}    interface model constructor
	     */
	  }, {
	    key: "getInterfaceManifest",
	    value: function getInterfaceManifest(modelName) {
	      if (modelName) {
	        return this.getOptions("interfaceManifest")[modelName];
	      } else {
	        return this.getOptions("interfaceManifest");
	      }
	    }

	    /**
	     * Updating Application, reloads interfaces, init controller launched, start again
	     */
	  }, {
	    key: "update",
	    value: function update() {
	      //нужно инициализировать
	      //модели полученными интерфейсами
	      this.updateInterfaces();
	      //иницилицировать и запустить контроллер инициализации
	      this.initController();
	      this.startApp();
	    }

	    /**
	     * Initialization of services, startup of routing
	     */
	  }, {
	    key: "startApp",
	    value: function startApp() {
	      this.initServices();
	      //создать контроллеры
	      //роутер и привязать к нему контроллеры
	      this.execRouter();
	      this.emit("afterStarted", this);
	    }

	    /**
	     *
	     * @param {object} controllerName controller constructor
	     * @param {string[]} controllerPathScheme
	     * @returns {function} function creates new controller instance and pass in notApp instance, arguments from router parser and pathScheme
	     */
	  }, {
	    key: "bindController",
	    value: function bindController(controllerName, controllerPathScheme) {
	      let app = this;
	      return function () {
	        new controllerName(app, arguments, controllerPathScheme);
	      };
	    }

	    /**
	     * Initializes 'initialization' controller which is runs once,
	     * to perform custom initializations routines by application code
	     */
	  }, {
	    key: "initController",
	    value: function initController() {
	      if (typeof this.getOptions("initController") !== "undefined") {
	        let initController = this.getOptions("initController");
	        this.setWorking("initController", new initController(this));
	      }
	    }

	    /**
	     * Returns working controller
	     * @returns {object} working controller
	     */
	  }, {
	    key: "getCurrentController",
	    value: function getCurrentController() {
	      return this.getWorking("currentController");
	    }

	    /**
	     * Destroyes working controller then sets provided as working
	     * @param {object} ctrl controller instance
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "setCurrentController",
	    value: function setCurrentController(ctrl) {
	      let oldCtrl = this.getCurrentController();
	      if (oldCtrl && oldCtrl.destroy) {
	        oldCtrl.destroy();
	      }
	      this.setWorking("currentController", ctrl);
	      return this;
	    }

	    /**
	     * Creates arrow function: (modelInitData = {}) => notRecord
	     * Factory that creates notRecord instances with binded
	     * recordManifest and provided data to initialize record
	     * @param {Object} recordManifest
	     * @return {function}
	     * @memberof notApp
	     */
	  }, {
	    key: "createInterfaceModelFactory",
	    value: function createInterfaceModelFactory(recordManifest) {
	      return function (recordData) {
	        return new notRecord(recordManifest, recordData);
	      };
	    }

	    /**
	     * Clears interfaces, recreates all according to Options.interafaceManifest
	     */
	  }, {
	    key: "updateInterfaces",
	    value: function updateInterfaces() {
	      this.clearInterfaces();
	      let manifests = this.getOptions("interfaceManifest");
	      if (manifests) {
	        for (let name in manifests) {
	          let recordManifest = manifests[name],
	            recordMethods = this.getOptions(["models", name].join("."), {});
	          recordManifest.methods = recordMethods;
	          const nameInt = this.createInterfaceModelFactory(recordManifest);
	          this.setInterface(name, nameInt);
	        }
	      }
	    }

	    /**
	     * Converts interface name (modelName) to standartizied prefixModelName
	     * @param {string} name interface model name
	     * @returns {string}    not record name
	     */
	  }, {
	    key: "getRecordName",
	    value: function getRecordName(name) {
	      return OPT_RECORD_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Converts controller name (controllerName) to standartizied prefixControllerName
	     * @param {string} name controller name
	     * @returns {string}    not controller name
	     */
	  }, {
	    key: "getControllerName",
	    value: function getControllerName(name) {
	      return OPT_CONTROLLER_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Sets named interface factory function
	     *
	     * @param {string} name
	     * @param {function} modelFactory
	     * @return {notApp}
	     * @memberof notApp
	     */
	  }, {
	    key: "setInterface",
	    value: function setInterface(name, modelFactory) {
	      return this.setWorking(`interfaces.${name}`, modelFactory);
	    }

	    /**
	     * Returns all network interfaces
	     * @returns {object} all network insterfaces
	     */
	  }, {
	    key: "getInterfaces",
	    value: function getInterfaces() {
	      return this.getWorking("interfaces");
	    }

	    /**
	     * Sets interfaces list clear
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "clearInterfaces",
	    value: function clearInterfaces() {
	      this.setWorking("interfaces", {});
	      return this;
	    }

	    /**
	     * Sets WebSockets client
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME] name of client
	     * @param {object} wsc  notWSClient instance
	     * @returns {object} notApp instance
	     */
	    // @ts-ignore
	  }, {
	    key: "setWSClient",
	    value: function setWSClient(name = DEFAULT_WS_CLIENT_NAME, wsc) {
	      return this.setWorking(`wsc.${name}`, wsc);
	    }

	    /**
	     * Returns web sockets client instance by name
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME]
	     * @returns {object} instance of notWSClient
	     */
	  }, {
	    key: "getWSClient",
	    value: function getWSClient(name = DEFAULT_WS_CLIENT_NAME) {
	      return this.getWorking(`wsc.${name}`);
	    }

	    /**
	     * returns network interface class initializator
	     * @param {string} name name of network interface
	     * @returns {function} interface class initializator
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name) {
	      return this.getInterfaces()[name];
	    }

	    /**
	     * Returns network interface (model) initialized with provided data
	     * @param {string} name interface(modelName)
	     * @param {object} [data={}]    model data
	     * @returns network interface initializes with provided data
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data = {}) {
	      return this.getInterface(name)(data);
	    }

	    /**
	     * Sets service
	     * @param {string} name name of the service
	     * @param {object|function} val service
	     */
	  }, {
	    key: "setService",
	    value: function setService(name, val) {
	      return this.setWorking(`services.${name}`, val);
	    }

	    /**
	     * Returns service
	     * @param {string} name name of the service
	     * @returns {object|function} service
	     */
	  }, {
	    key: "getService",
	    value: function getService(name) {
	      return this.getWorking(`services.${name}`);
	    }

	    /**
	     * Initializes all provided services
	     */
	  }, {
	    key: "initServices",
	    value: function initServices() {
	      if (this.getOptions("services")) {
	        for (let servName in this.getOptions("services")) {
	          try {
	            let serv = this.getOptions(`services.${servName}`);
	            const servType = notCommon$1.detectType(serv);
	            switch (servType) {
	              case "function":
	              case "class":
	                this.setService(servName, new serv(this));
	                break;
	              default:
	                this.setService(servName, serv);
	            }
	          } catch (e) {
	            this?.error && this.error(`Service (${servName}) init error`, e);
	          }
	        }
	      }
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} moduleName   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "getConfigReaderForModule",
	    value: function getConfigReaderForModule(moduleName = "") {
	      var _this3 = this;
	      const modConfPath = ["modules", moduleName].join(".");
	      return {
	        get: function (subPath, fallback) {
	          if (subPath && typeof subPath == "string" && subPath.length) {
	            return _this3.getOptions([modConfPath, subPath].join("."), fallback);
	          } else {
	            return _this3.getOptions(modConfPath, fallback);
	          }
	        }
	      };
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} [moduleName='']   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "moduleConfig",
	    value: function moduleConfig(moduleName = "") {
	      return this.getConfigReaderForModule(moduleName);
	    }
	  }]);
	}(notBase);
	/**
	 *  @static {function} DEFAULT_WS_CLIENT_NAME  function to perform deep merges of objects
	 */
	_defineProperty(notApp, "DEFAULT_WS_CLIENT_NAME", DEFAULT_WS_CLIENT_NAME);

	/**
	 * @const {string}  [OPT_DEFAULT_ACTION_NAME = "default"]      default action name
	 */
	const OPT_DEFAULT_ACTION_NAME = "default";

	/**
	 * @const {string}  [OPT_DEFAULT_CONTAINER_SELECTOR = "main.content"]  selector of container HTML
	 *                          element
	 */
	const OPT_DEFAULT_CONTAINER_SELECTOR = "main.content";

	/**
	 * @const {string}  [OPT_DEFAULT_PLURAL_NAME = "Models"]  default plural name of entities
	 */
	const OPT_DEFAULT_PLURAL_NAME = "Models";

	/**
	 * @const {string}  [OPT_DEFAULT_SINGLE_NAME = "Model"]  default single name of entities
	 */
	const OPT_DEFAULT_SINGLE_NAME = "Model";

	/**
	 * @const {string}  [OPT_DEFAULT_MODULE_NAME="main"]  default module name
	 */
	const OPT_DEFAULT_MODULE_NAME = "main";

	/**
	 * @const {boolean}  [OPT_DEFAULT_AUTO_NAME = true]  if shoould be used auto name generator
	 */
	const OPT_DEFAULT_AUTO_NAME = true;

	/**
	 *  Basic class for user controller
	 *  @extends notBase
	 */
	let notController = /*#__PURE__*/function (_notBase) {
	  /**
	   *  @class
	   *  @param {import('./app.js').default} app
	   *  @param  {string}    name
	   */
	  function notController(app, name) {
	    var _this;
	    _classCallCheck(this, notController);
	    _this = _callSuper(this, notController, [{}]);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "els", void 0);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "make", void 0);
	    /**
	     *
	     * @type    {null|import('./app.js').default}
	     * @memberof notController
	     */
	    _defineProperty(_this, "app", void 0);
	    _this.app = app;
	    _this.app.setCurrentController(_this);
	    _this.setWorking({
	      name,
	      ready: false,
	      views: {},
	      libs: {},
	      helpers: {}
	    });
	    _this.ui = {};
	    _this.els = {};
	    _this.setData({});
	    _this.setOptions({
	      moduleName: OPT_DEFAULT_MODULE_NAME,
	      containerSelector: OPT_DEFAULT_CONTAINER_SELECTOR,
	      prefix: app.getOptions("paths.module"),
	      names: {
	        plural: OPT_DEFAULT_PLURAL_NAME,
	        single: OPT_DEFAULT_SINGLE_NAME
	      }
	    });
	    _this.setURLPrefix(app.getOptions("router.root"));
	    /*
	    сразу делаем доступными модели notRecord из nc`ControllerName` будут доступны как this.nr`ModelName`
	    */
	    let interfaces = app.getInterfaces();
	    _this.make = {};
	    for (let t in interfaces) {
	      // @ts-ignore
	      if (Object.hasOwn(interfaces, t)) {
	        _this.make[t] = interfaces[t];
	      }
	    }
	    _this.on("destroy", function () {
	      _this.app = null;
	      for (let uiName in _this.ui) {
	        _this.ui[uiName].destroy && _this.ui[uiName].destroy();
	        _this.ui[uiName].$destroy && _this.ui[uiName].$destroy();
	        _this.ui[uiName] = null;
	      }
	      _this.els = null;
	      _this.make = null;
	    });
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   *  Returns current notApp
	   *  @return {import('./app.js').default}
	   */
	  _inherits(notController, _notBase);
	  return _createClass(notController, [{
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }

	    /**
	     *  Sets default controller model
	     *  @param {import('./record.js')}  model  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModel",
	    value: function setModel(model) {
	      this.setWorking("model", model);
	      return this;
	    }

	    /**
	     *  If zero or one argument provided this modelName instance will be returned
	     *  If two provided and first is a string than instance of name will be returned initialized with second object param or empty object
	     *  @param {string|object}      [name]    modelName of instance to return or initial data for instance
	     *  @param {object}             [data]    model data
	     *  @return {import('./record.js').default}
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        const int = this.getInterface(name);
	        return int && int(data || {});
	      } else {
	        const int = this.getInterface();
	        return int && int(name || {});
	      }
	    }

	    /**
	     * Returns controller interface if name is not specified or interface of specified
	     *
	     * @param {string} [name=""]
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = "") {
	      return this.app?.getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getWorking("modelName");
	    }
	    /**
	     *  Sets default controller model name
	     *  @param {string}  modelName  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelName",
	    value: function setModelName(modelName) {
	      this.setWorking("modelName", notCommon$1.lowerFirstLetter(modelName));
	      return this;
	    }

	    /**
	     *  Returns current model primary ID field name
	     *  @return {import('./record.js')}
	     */
	  }, {
	    key: "getModelIDFieldName",
	    value: function getModelIDFieldName() {
	      return this.getWorking("modelIDFieldName", "_id");
	    }

	    /**
	     *  Sets current model primary ID field name
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelIDFieldName",
	    value: function setModelIDFieldName(val = "_id") {
	      return this.setWorking("modelIDFieldName", val);
	    }

	    /**
	     *  Marks this controller as ready
	     *  emits "ready"/"busy" events
	     *  @param {Boolean}  val  true/false
	     */
	  }, {
	    key: "setReady",
	    value: function setReady(val = true) {
	      this.setWorking("ready", val);
	      val ? this.emit("ready") : this.emit("busy");
	    }

	    /**
	     *  Sets module URL prefix
	     *  @param {string} val URL prefix
	     *  @return {notController} this
	     */
	  }, {
	    key: "setURLPrefix",
	    value: function setURLPrefix(val) {
	      this.setOptions("urlPrefix", val);
	      this.updateAutoName();
	      return this;
	    }

	    /**
	     *  Returns module url prefix
	     *  @return  {string} prefix
	     */
	  }, {
	    key: "getURLPrefix",
	    value: function getURLPrefix() {
	      return this.getOptions("urlPrefix");
	    }

	    /**
	     *  Sets module name
	     *  @param {string} val name of the module
	     *  @return {notController} this
	     */
	  }, {
	    key: "setModuleName",
	    value: function setModuleName(val) {
	      this.setOptions("moduleName", notCommon$1.lowerFirstLetter(val));
	      this.updateAutoName();
	      return this;
	    }
	    /**
	     *  Returns module name
	     *  @return  {string} module name
	     */
	  }, {
	    key: "getModuleName",
	    value: function getModuleName() {
	      return this.getOptions("moduleName");
	    }

	    /**
	     *  Returns this module path prefix
	     *  @return {string}  path to module dir
	     */
	  }, {
	    key: "getModulePrefix",
	    value: function getModulePrefix() {
	      return [notCommon$1.getApp().getOptions("paths.modules"), this.getModuleName()].join("/");
	    }

	    /**
	     *  Returns this model URL with URL prefix
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelURL",
	    value: function getModelURL() {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName()
	      });
	    }

	    /**
	     *  Returns this model action URL with URL prefix
	     * @param  {string}   id       some identificator of model
	     * @param  {string}   action   action name
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelActionURL",
	    value: function getModelActionURL(id, action = "") {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName(),
	        id,
	        action
	      });
	    }

	    /**
	     * Creates url from value content
	     * @param {object}  val
	     **/
	  }, {
	    key: "buildURL",
	    value: function buildURL(val) {
	      return notCommon$1.buildURL(val);
	    }

	    /**
	     *  Updates working name
	     *  @return {notController} this
	     */
	  }, {
	    key: "updateAutoName",
	    value: function updateAutoName() {
	      if (this.getOptions("autoName", OPT_DEFAULT_AUTO_NAME)) ;
	      return this;
	    }

	    /**
	     *  Sets object name
	     *  @param {string} val name of the object
	     *  @return {notController} this
	     */
	  }, {
	    key: "setName",
	    value: function setName(val) {
	      this.setWorking("name", val);
	      this.setOptions("autoName", false);
	      return this;
	    }

	    /**
	     *  Gets object name
	     *  @return {string}
	     */
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }

	    /**
	     *  Preload records from server, using listAll method,
	     *  returns Promise
	     *  @param {object}  list  map of preloaded records
	     *  @return {Promise}
	     */
	  }, {
	    key: "preloadLib",
	    value: function preloadLib(list = {}) {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        if (typeof list !== "object") {
	          resolve(undefined);
	        } else {
	          _this2.setWorking("loading", []);
	          for (let t in list) {
	            _this2.getWorking("loading").push(list[t]);
	            _this2.make[list[t]]({}).$listAll().then(function (data) {
	              if (!_this2.getOptions("libs")) {
	                _this2.setOptions("libs", {});
	              }
	              _this2.getOptions("libs")[t] = data;
	              if (_this2.getWorking("loading").indexOf(list[t]) > -1) {
	                _this2.getWorking("loading").splice(_this2.getWorking("loading").indexOf(list[t]), 1);
	              }
	              if (_this2.getWorking("loading").length === 0) {
	                resolve(undefined);
	              }
	            }).catch(function (err) {
	              _this2.report(err);
	              reject();
	            });
	          }
	          if (_this2.getWorking("loading").length === 0) {
	            resolve(undefined);
	          }
	        }
	      });
	    }

	    /**
	     * emits afterRender event
	     */
	  }, {
	    key: "onAfterRender",
	    value: function onAfterRender() {
	      this.emit("afterRender");
	    }

	    /**
	     *  Transform route name in action name
	     *  @param {String}   name tranform action name
	     *  @return {String}
	     */
	  }, {
	    key: "getActionName",
	    value: function getActionName(name = OPT_DEFAULT_ACTION_NAME) {
	      return "run" + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     *  Get default controller action name
	     *  @return {String} default action from options
	     */
	  }, {
	    key: "getDefaultActionName",
	    value: function getDefaultActionName() {
	      return this.getActionName(this.getOptions("defaultAction", OPT_DEFAULT_ACTION_NAME));
	    }

	    /**
	     *  Route params into specific run[Route_name] function
	     *  @param {array}   params   controller input params
	     *  @return {undefined}
	     */
	  }, {
	    key: "route",
	    value: function route(params) {
	      let [routerName, ...subParams] = params,
	        actionName = this.getActionName(routerName ? routerName : OPT_DEFAULT_ACTION_NAME);
	      if (typeof this[actionName] === "function") {
	        this.setCurrentAction(actionName);
	        this[actionName](subParams);
	      } else if (this[this.getDefaultActionName()]) {
	        this.setCurrentAction(this.getDefaultActionName());
	        this[this.getDefaultActionName()](subParams);
	      } else {
	        this.setCurrentAction(undefined);
	        this.error && this.error("No action in router", params);
	      }
	    }

	    /**
	     * Sets working action
	     * @params {string} actionName current action name
	     */
	  }, {
	    key: "setCurrentAction",
	    value: function setCurrentAction(actionName) {
	      this.setWorking("action", actionName);
	    }

	    /**
	     * Gets working action
	     * @returns {string} current action name
	     */
	  }, {
	    key: "getCurrentAction",
	    value: function getCurrentAction() {
	      return this.getWorking("action");
	    }

	    /**
	     *  Return application options
	     *  @return {object}
	     */
	  }, {
	    key: "getAppOptions",
	    value: function getAppOptions() {
	      try {
	        return this.getApp().getOptions();
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module options
	     *  @param  {string}   [moduleName]    name of the module which options requested
	     *  @return {object}
	     */
	  }, {
	    key: "getModuleOptions",
	    value: function getModuleOptions(moduleName) {
	      try {
	        return this.getApp().getOptions(["modules", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module services
	     *  @param  {string}   moduleName    name of the module which services requested
	     *  @return {object}
	     */
	  }, {
	    key: "getServices",
	    value: function getServices(moduleName) {
	      try {
	        return this.getApp().getOptions(["services", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module components
	     *  @param  {string}   moduleName    name of the module which components requested
	     *  @return {object}
	     */
	  }, {
	    key: "getComponents",
	    value: function getComponents(moduleName) {
	      try {
	        return this.getApp().getOptions(["components", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Refreshes current URL, re-run all action
	     *  @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      this.app?.getWorking("router").refresh(timeout);
	    }

	    /**
	     * Returns path pattern for router
	     * @params {number} [0] paramsCount   number of params
	     * @return {string}  pattern for controller supported url
	     */
	  }, {
	    key: "getRouter",
	    value:
	    /**
	     * Returns Application router
	     * @returns {import('./router.js').default}
	     */
	    function getRouter() {
	      return this.app?.getWorking("router");
	    }

	    /**
	     * Changes location to `url` after `delay` ms
	     * @param {string} url
	     * @param {number|string}   delay   number in ms or name of delay
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay = NAVIGATION_DELAY_DEFAULT, doBefore = function () {}) {
	      return this.getRouter().navigateWithDelay(url, delay, doBefore);
	    }

	    /**
	     * Changes location to `url`
	     * @param {string} url
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      return this.getRouter().navigate(url);
	    }

	    /**
	     *  Navigating to this controller main model `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateAction",
	    value: function navigateAction(id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), this.getModelName(), id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to this controller module model of `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModelAction",
	    value: function navigateModelAction(modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), modelName, id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to `moduleName` `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} moduleName
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModuleAction",
	    value: function navigateModuleAction(moduleName, modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      if (delay) {
	        return this.getRouter().navigateWithDelay(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }), delay, doBefore);
	      } else {
	        return this.getRouter().navigate(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }));
	      }
	    }

	    /**
	     * Creates menu item from child class constructor
	     *
	     * @static
	     * @param {notController} childConstructor
	     * @return {Array<import('./types.js').NavigationItem>}
	     * @memberof notController
	     */
	  }], [{
	    key: "MODULE_NAME",
	    get:
	    /**
	     *  @static {string} MODULE_NAME  name of module
	     */
	    function () {
	      return OPT_DEFAULT_MODULE_NAME;
	    }
	    /**
	     *  @static {string} MODEL_NAME  name of model
	     */
	  }, {
	    key: "MODEL_NAME",
	    get: function () {
	      return "ModelName";
	    }
	  }, {
	    key: "LABELS",
	    get: function () {
	      return {
	        plural: `${OPT_DEFAULT_MODULE_NAME}:model_label_plural`,
	        single: `${OPT_DEFAULT_MODULE_NAME}:model_label_single`
	      };
	    }
	  }, {
	    key: "getControllerRoute",
	    value: function getControllerRoute(paramsCount = 0) {
	      let path = [];
	      if (this.MODULE_NAME && this.MODULE_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODULE_NAME));
	      }
	      if (this.MODEL_NAME && this.MODEL_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODEL_NAME));
	      }
	      path = [path.join("/")];
	      for (let i = 0; i < paramsCount; i++) {
	        path.push("/([^/]+)");
	      }
	      return path.join("");
	    }

	    /**
	     * Returns path patterns for router
	     * @params {number} [0] paramsDeep   how many paths with params in the end
	     * @return {string[]}  patterns for controller supported url in order of simplification
	     */
	  }, {
	    key: "getControllerRoutes",
	    value: function getControllerRoutes(paramsDeep = 0) {
	      let routes = [this.getControllerRoute(0)];
	      for (let i = 0; i < paramsDeep; i++) {
	        routes.unshift(this.getControllerRoute(i + 1));
	      }
	      return routes;
	    }

	    /**
	     * Returns router rule.
	     * @returns {Object} router rule {paths:String[], controller:notController}
	     */
	  }, {
	    key: "getRoutes",
	    value: function getRoutes() {
	      return {
	        paths: this.getControllerRoutes(this.PARAMS_LENGTH),
	        controller: this
	      };
	    }
	  }, {
	    key: "getCommonMenu",
	    value: function getCommonMenu(childConstructor) {
	      return [{
	        // @ts-ignore
	        section: childConstructor.MODULE_NAME,
	        // @ts-ignore
	        title: childConstructor.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(
        // @ts-ignore
        childConstructor.MODULE_NAME
        // @ts-ignore
        )}/${notCommon$1.lowerFirstLetter(childConstructor.MODEL_NAME)}`
	      }];
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu() {}
	  }]);
	}(notBase);
	/**
	 *  @static {number} PARAMS_LENGTH  number of params in URL path
	 */
	_defineProperty(notController, "PARAMS_LENGTH", 2);

	const ALL = {};
	function exist(key) {
	  return Object.hasOwn(ALL, key);
	}
	function get(key) {
	  if (exist(key)) {
	    return ALL[key];
	  } else {
	    return false;
	  }
	}
	function create(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL[key];
	}

	function onInput(ev, id, fieldname, dispatch) {
		let data = {
			id: id(),
			field: fieldname(),
			value: ev.target.type === 'checkbox' ? ev.target.checked : ev.target.value
		};

		dispatch('change', data);
		return true;
	}

	var root$b = template(`<input type="checkbox"> <label class="label"></label>`, 1);

	function Ui_switch($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {boolean} [value]
		 * @property {string} [fieldname]
		 * @property {boolean} [disabled]
		 * @property {boolean} [readonly]
		 * @property {string} [styling]
		 */
		/** @type {Props} */
		let id = prop($$props, "id", 3, ''),
			value = prop($$props, "value", 15, false),
			fieldname = prop($$props, "fieldname", 3, 'switch'),
			disabled = prop($$props, "disabled", 3, false),
			readonly = prop($$props, "readonly", 3, false),
			styling = prop($$props, "styling", 3, " is-rounded is-success ");

		var fragment = root$b();
		var input = first_child(fragment);

		remove_input_defaults(input);
		input.__input = [onInput, id, fieldname, dispatch];

		var label = sibling(input, 2);

		template_effect(() => {
			set_class(input, `switch ${styling() ?? ""}`);
			set_attribute(input, "id", `edit-table-row-cell-inline-switch-${fieldname() ?? ""}-${id() ?? ""}`);
			set_attribute(input, "name", fieldname());
			input.readOnly = readonly();
			input.disabled = disabled();
			set_attribute(label, "for", `edit-table-row-cell-inline-switch-${fieldname() ?? ""}-${id() ?? ""}`);
		});

		bind_checked(input, value);
		append($$anchor, fragment);
		pop();
	}

	delegate(["input"]);

	var root_3$5 = template(`<a> </a>`);
	var root_2$5 = template(`<div class="mx-1 tags has-addons svelte-38rpfk"><span class="tag"> </span> <span><!></span></div>`);
	var root_6$5 = template(`<a> </a>`);
	var root_5$5 = template(`<span><!></span>`);

	function Ui_tags($$anchor, $$props) {
		/*
		  import { createEventDispatcher } from 'svelte';
		  let dispatch = createEventDispatcher();
		*/
		/**
		 * @typedef {Object} Props
		 * @property {any} [values] - item = {
		id,        //unique
		title,     //some text
		value,      //for double tags
		color       //coloring
		}
		 */
		/** @type {Props} */
		let values = prop($$props, "values", 19, () => []);
		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.id, ($$anchor, item) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var div = root_2$5();
					var span = child(div);
					var text$1 = child(span, true);

					reset(span);

					var span_1 = sibling(span, 2);
					var node_2 = child(span_1);

					{
						var consequent = ($$anchor) => {
							var a = root_3$5();
							var text_1 = child(a, true);

							reset(a);

							template_effect(() => {
								set_attribute(a, "href", get$2(item).url);
								set_class(a, clsx(get$2(item).urlCustomClasses), "svelte-38rpfk");
								set_text(text_1, get$2(item).value);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							var text_2 = text();

							template_effect(() => set_text(text_2, get$2(item).value));
							append($$anchor, text_2);
						};

						if_block(node_2, ($$render) => {
							if (get$2(item).url) $$render(consequent); else $$render(alternate, false);
						});
					}

					reset(span_1);
					reset(div);

					template_effect(() => {
						set_text(text$1, get$2(item).title);
						set_class(span_1, `tag is-${get$2(item).color ?? ""} ${get$2(item).customClasses ?? ""} svelte-38rpfk`);
					});

					append($$anchor, div);
				};

				var alternate_2 = ($$anchor) => {
					var span_2 = root_5$5();
					var node_3 = child(span_2);

					{
						var consequent_2 = ($$anchor) => {
							var a_1 = root_6$5();
							var text_3 = child(a_1, true);

							reset(a_1);

							template_effect(() => {
								set_attribute(a_1, "href", get$2(item).url);
								set_class(a_1, clsx(get$2(item).urlCustomClasses), "svelte-38rpfk");
								set_text(text_3, get$2(item).title);
							});

							append($$anchor, a_1);
						};

						var alternate_1 = ($$anchor) => {
							var text_4 = text();

							template_effect(() => set_text(text_4, get$2(item).title));
							append($$anchor, text_4);
						};

						if_block(node_3, ($$render) => {
							if (get$2(item).url) $$render(consequent_2); else $$render(alternate_1, false);
						});
					}

					reset(span_2);
					template_effect(() => set_class(span_2, `mx-1 tag is-${get$2(item).color ?? ""} ${get$2(item).customClasses ?? ""} svelte-38rpfk`));
					append($$anchor, span_2);
				};

				if_block(node_1, ($$render) => {
					if (Object.hasOwn(get$2(item), "value")) $$render(consequent_1); else $$render(alternate_2, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$a = template(`<td><!></td>`);

	function NotTableCell($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		let title = state("");

		onMount(() => {
			if (typeof field().type === "undefined") {
				if (Object.hasOwn(field(), "titlePath")) {
					set(title, proxy(notPath.get(field().titlePath, item(), helpers())));
				} else if (Object.hasOwn(field(), "titleComposer") && typeof field().titleComposer === "function") {
					set(title, proxy(field().titleComposer(item(), helpers())));
				} else {
					set(title, proxy(notPath.get(field().path, item(), helpers())));
				}
			}
		});

		let getItemId = prop($$props, "getItemId", 3, (item) => item._id),
			field = prop($$props, "field", 19, () => ({})),
			item = prop($$props, "item", 19, () => ({})),
			helpers = prop($$props, "helpers", 19, () => ({}));

		var td = root$a();
		var node = child(td);

		{
			var consequent = ($$anchor) => {
				var values = derived(() => notPath.get(field().path, item(), helpers()));

				Ui_links($$anchor, {
					get values() {
						return get$2(values);
					}
				});
			};

			var alternate_7 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var values_1 = derived(() => notPath.get(field().path, item(), helpers()));

						Ui_buttons($$anchor, {
							get values() {
								return get$2(values_1);
							}
						});
					};

					var alternate_6 = ($$anchor) => {
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								var values_2 = derived(() => notPath.get(field().path, item(), helpers()));

								Ui_images($$anchor, {
									get values() {
										return get$2(values_2);
									}
								});
							};

							var alternate_5 = ($$anchor) => {
								var fragment_5 = comment();
								var node_3 = first_child(fragment_5);

								{
									var consequent_3 = ($$anchor) => {
										var values_3 = derived(() => notPath.get(field().path, item(), helpers()));

										Ui_booleans($$anchor, {
											get values() {
												return get$2(values_3);
											}
										});
									};

									var alternate_4 = ($$anchor) => {
										var fragment_7 = comment();
										var node_4 = first_child(fragment_7);

										{
											var consequent_4 = ($$anchor) => {
												var values_4 = derived(() => notPath.get(field().path, item(), helpers()));

												Ui_tags($$anchor, {
													get values() {
														return get$2(values_4);
													}
												});
											};

											var alternate_3 = ($$anchor) => {
												var fragment_9 = comment();
												var node_5 = first_child(fragment_9);

												{
													var consequent_5 = ($$anchor) => {
														var id = derived(() => getItemId()(item()));
														var value = derived(() => notPath.get(field().path, item(), helpers()));

														Ui_switch($$anchor, {
															get id() {
																return get$2(id);
															},
															get fieldname() {
																return field().path;
															},
															get value() {
																return get$2(value);
															},
															get disabled() {
																return field().disabled;
															},
															get readonly() {
																return field().readonly;
															},
															$$events: {
																change(...$$args) {
																	field().onChange?.apply(this, $$args);
																}
															}
														});
													};

													var alternate_2 = ($$anchor) => {
														var fragment_11 = comment();
														var node_6 = first_child(fragment_11);

														{
															var consequent_6 = ($$anchor) => {
																var fragment_12 = comment();
																var node_7 = first_child(fragment_12);
																var id_1 = derived(() => getItemId()(item()));
																var value_1 = derived(() => notPath.get(field().path, item(), helpers()));

																component(node_7, () => field().component, ($$anchor, $$component) => {
																	$$component($$anchor, spread_props(
																		{
																			get id() {
																				return get$2(id_1);
																			},
																			get fieldname() {
																				return field().path;
																			},
																			get disabled() {
																				return field().disabled;
																			},
																			get readonly() {
																				return field().readonly;
																			},
																			get value() {
																				return get$2(value_1);
																			}
																		},
																		() => field().options,
																		{
																			$$events: {
																				change(...$$args) {
																					field().onChange?.apply(this, $$args);
																				}
																			}
																		}
																	));
																});

																append($$anchor, fragment_12);
															};

															var alternate_1 = ($$anchor) => {
																var fragment_13 = comment();
																var node_8 = first_child(fragment_13);

																{
																	var consequent_7 = ($$anchor) => {
																		var text$1 = text();

																		template_effect(() => set_text(text$1, notCommon$1.strLengthCap(notPath.get(field().path, item(), helpers()), field().maxLength)));
																		append($$anchor, text$1);
																	};

																	var alternate = ($$anchor) => {
																		var text_1 = text();

																		template_effect(() => set_text(text_1, $LOCALE()[notPath.get(field().path, item(), helpers())]));
																		append($$anchor, text_1);
																	};

																	if_block(
																		node_8,
																		($$render) => {
																			if (field() && typeof field() !== "undefined" && !isNaN(field().maxLength) && field().maxLength) $$render(consequent_7); else $$render(alternate, false);
																		},
																		true
																	);
																}

																append($$anchor, fragment_13);
															};

															if_block(
																node_6,
																($$render) => {
																	if (field().component) $$render(consequent_6); else $$render(alternate_1, false);
																},
																true
															);
														}

														append($$anchor, fragment_11);
													};

													if_block(
														node_5,
														($$render) => {
															if (field().type === "switch") $$render(consequent_5); else $$render(alternate_2, false);
														},
														true
													);
												}

												append($$anchor, fragment_9);
											};

											if_block(
												node_4,
												($$render) => {
													if (field().type === "tag") $$render(consequent_4); else $$render(alternate_3, false);
												},
												true
											);
										}

										append($$anchor, fragment_7);
									};

									if_block(
										node_3,
										($$render) => {
											if (field().type === "boolean") $$render(consequent_3); else $$render(alternate_4, false);
										},
										true
									);
								}

								append($$anchor, fragment_5);
							};

							if_block(
								node_2,
								($$render) => {
									if (field().type === "image") $$render(consequent_2); else $$render(alternate_5, false);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (field().type === "button") $$render(consequent_1); else $$render(alternate_6, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (field().type === "link") $$render(consequent); else $$render(alternate_7, false);
			});
		}

		reset(td);

		template_effect(() => {
			set_class(td, (field().hideOnMobile ? " is-hidden-touch " : "") + (field().classes ? ` ${field().classes} ` : ""));
			set_attribute(td, "title", get$2(title));
		});

		append($$anchor, td);
		pop();
	}

	function onRowSelect(
		e,
		dispatch,
		itemId,
		$selectedList,
		selectedList
	) {
		e.preventDefault();

		dispatch('rowSelectChange', {
			id: get$2(itemId),
			selected: $selectedList()[get$2(itemId)]
		});

		return false;
	}

	var root_1$8 = template(`<td><input type="checkbox" placeholder=""></td>`);
	var root$9 = template(`<tr><!><!></tr>`);

	function NotTableRow($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $selectedList = () => store_get(selectedList, "$selectedList", $$stores);
		let dispatch = createEventDispatcher();

		let itemId = state(undefined),
			selectedList;

		onMount(() => {
			set(itemId, proxy(getItemId()(item())));
			selectedList = get($$props.id).selected;
		});

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} [item]
		 * @property {any} [helpers]
		 * @property {any} [fields]
		 * @property {boolean} [showSelect]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let item = prop($$props, "item", 19, () => ({})),
			helpers = prop($$props, "helpers", 19, () => ({})),
			fields = prop($$props, "fields", 19, () => []),
			showSelect = prop($$props, "showSelect", 3, false),
			getItemId = prop($$props, "getItemId", 3, () => {});

		var tr = root$9();
		var node = child(tr);

		{
			var consequent = ($$anchor) => {
				var td = root_1$8();
				var input = child(td);

				remove_input_defaults(input);
				template_effect(() => set_attribute(input, "id", `table-row-select-${getItemId()(item()) ?? ""}`));
				template_effect(() => set_attribute(input, "data-id", getItemId()(item())));
				template_effect(() => set_attribute(input, "name", `row_selected_${getItemId()(item()) ?? ""}`));

				input.__change = [
					onRowSelect,
					dispatch,
					itemId,
					$selectedList,
					selectedList
				];

				reset(td);
				bind_checked(input, () => $selectedList()[get$2(itemId)], ($$value) => store_mutate(selectedList, untrack($selectedList)[get$2(itemId)] = $$value, untrack($selectedList)));
				append($$anchor, td);
			};

			if_block(node, ($$render) => {
				if (showSelect() && $selectedList()) $$render(consequent);
			});
		}

		var node_1 = sibling(node);

		each(node_1, 17, fields, index$d, ($$anchor, field) => {
			NotTableCell($$anchor, {
				get field() {
					return get$2(field);
				},
				get helpers() {
					return helpers();
				},
				get item() {
					return item();
				},
				get getItemId() {
					return getItemId();
				}
			});
		});

		reset(tr);
		append($$anchor, tr);
		pop();
	}

	delegate(["change"]);

	function onSearchInput(ev, dispatch) {
		try {
			let data = ev.currentTarget.value.trim();

			dispatch("searchChange", data);
		} catch {
			return;
		}
	}

	function goPrev(_, dispatch) {
		dispatch("goToPrevPage");
	}

	function goNext(__1, dispatch) {
		dispatch("goToNextPage");
	}

	function goTo(e, dispatch) {
		e.preventDefault();

		let el = e.target;

		dispatch("goToPage", parseInt(el.dataset.page));
		return false;
	}

	function onSelectAll(__2, $$props, items, getItemId, selectAll) {
		get($$props.id).selected.update((value) => {
			items().forEach((item) => {
				value[getItemId()(item)] = selectAll();
			});

			return value;
		});
	}

	var root_1$7 = template(`<div class="field is-grouped"><!></div>`);
	var root_2$4 = template(`<div class="field is-grouped"><!></div>`);
	var root_5$4 = template(`<div class="field"><div class="control"><input class="input" type="text" placeholder="Поиск"></div></div>`);
	var root_6$4 = template(`<th><input type="checkbox" id="table-row-select-page" placeholder="" name="row_selected_all"></th>`);
	var root_7$2 = template(`<th><!></th>`);
	var root_14$1 = template(`<a href="" class="pagination-link is-current" aria-current="page"> </a>`);
	var root_15$1 = template(`<a href="" class="pagination-link"> </a>`);
	var root_13 = template(`<li><!></li>`);
	var root_11$1 = template(`<nav class="pagination is-centered" aria-label="pagination"><a href="" class="pagination-previous">Назад</a> <a href="" class="pagination-next">Вперед</a> <ul class="pagination-list"><!></ul></nav>`);
	var root$8 = template(`<!> <!> <!> <table class="table"><thead><tr><!><!></tr></thead><tbody></tbody></table> <!>`, 1);

	function NotTable($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} filterUI
		 * @property {any} [helpers]
		 * @property {any} [state]
		 * @property {any} [filter]
		 * @property {any} [sorter]
		 * @property {any} [fields]
		 * @property {any} [selected]
		 * @property {any} [items]
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {string} [search]
		 * @property {boolean} [showSearch]
		 * @property {boolean} [showSelect]
		 * @property {boolean} [selectAll]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let helpers = prop($$props, "helpers", 19, () => ({})),
			state = prop($$props, "state", 31, () => proxy({})),
			filter = prop($$props, "filter", 31, () => proxy({})),
			sorter = prop($$props, "sorter", 31, () => proxy({})),
			fields = prop($$props, "fields", 19, () => []),
			selected = prop($$props, "selected", 31, () => proxy({})),
			items = prop($$props, "items", 31, () => proxy([])),
			actions = prop($$props, "actions", 19, () => []),
			links = prop($$props, "links", 19, () => []),
			search = prop($$props, "search", 15, ""),
			showSearch = prop($$props, "showSearch", 3, true),
			showSelect = prop($$props, "showSelect", 3, true),
			selectAll = prop($$props, "selectAll", 15, false),
			getItemId = prop($$props, "getItemId", 3, (item) => item._id);

		onMount(() => {
			if (showSelect()) {
				get($$props.id).selected.subscribe((value) => {
					selected(value);
				});
			}

			get($$props.id).refined.subscribe((value) => {
				items(value);

				if (showSelect()) {
					for (let itemId in selected()) {
						if (!items().some((item) => getItemId()(item) === itemId)) {
							delete selected()[itemId];
						} else {
							if (!Object.hasOwn(selected(), itemId)) {
								selected(selected()[itemId] = false, true);
							}
						}
					}

					selected(selected());
				}
			});

			get($$props.id).state.subscribe((value) => {
				state(value);
			});
		});

		function onSearchChange({ detail }) {
			try {
				dispatch("searchChange", detail);
			} catch {
				return;
			}
		}

		function onFilterChange({ detail }) {
			try {
				dispatch("filterChange", detail);
			} catch {
				return;
			}
		}

		function onFieldHeadClick(field) {
			const propPath = field.path.substring(1);

			if (Object.hasOwn(sorter(), propPath)) {
				sorter(sorter()[propPath] = parseInt(sorter()[propPath]) * -1, true);
			} else {
				sorter({ [propPath]: 1 });
			}

			dispatch("sorterChange", sorter());
		}

		var fragment = root$8();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$7();
				var node_1 = child(div);

				Ui_links(node_1, {
					get values() {
						return links();
					}
				});

				reset(div);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (links().length) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_1 = root_2$4();
				var node_3 = child(div_1);

				Ui_buttons(node_3, {
					get values() {
						return actions();
					}
				});

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_2, ($$render) => {
				if (actions().length) $$render(consequent_1);
			});
		}

		var node_4 = sibling(node_2, 2);

		{
			var consequent_3 = ($$anchor) => {
				var fragment_1 = comment();
				var node_5 = first_child(fragment_1);

				{
					var consequent_2 = ($$anchor) => {
						var fragment_2 = comment();
						const SvelteComponent = derived(() => $$props.filterUI);
						var node_6 = first_child(fragment_2);

						component(node_6, () => get$2(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, {
								get filter() {
									return filter();
								},
								set filter($$value) {
									filter($$value);
								},
								$$events: {
									change: onFilterChange,
									searchChange: onSearchChange
								}
							});
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_5$4();
						var div_3 = child(div_2);
						var input = child(div_3);

						remove_input_defaults(input);
						input.__input = [onSearchInput, dispatch];
						reset(div_3);
						reset(div_2);
						bind_value(input, search);
						append($$anchor, div_2);
					};

					if_block(node_5, ($$render) => {
						if ($$props.filterUI) $$render(consequent_2); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node_4, ($$render) => {
				if (showSearch()) $$render(consequent_3);
			});
		}

		var table = sibling(node_4, 2);
		var thead = child(table);
		var tr = child(thead);
		var node_7 = child(tr);

		{
			var consequent_4 = ($$anchor) => {
				var th = root_6$4();
				var input_1 = child(th);

				remove_input_defaults(input_1);

				input_1.__change = [
					onSelectAll,
					$$props,
					items,
					getItemId,
					selectAll
				];

				reset(th);
				bind_checked(input_1, selectAll);
				append($$anchor, th);
			};

			if_block(node_7, ($$render) => {
				if (showSelect()) $$render(consequent_4);
			});
		}

		var node_8 = sibling(node_7);

		each(node_8, 17, fields, index$d, ($$anchor, field) => {
			var th_1 = root_7$2();
			const propPath = derived(() => get$2(field).path.substring(1));
			var event_handler = derived(() => onFieldHeadClick(get$2(field)));

			th_1.__click = function (...$$args) {
				get$2(event_handler)?.apply(this, $$args);
			};

			var node_9 = child(th_1);

			{
				var consequent_5 = ($$anchor) => {
					var font = derived(() => sorter()[get$2(propPath)] > 0 ? "sort-up" : "sort-down");

					Ui_icon_font($$anchor, {
						get font() {
							return get$2(font);
						},
						get title() {
							return get$2(field).title;
						},
						pointable: true
					});
				};

				var alternate_1 = ($$anchor) => {
					var text$1 = text();

					template_effect(() => set_text(text$1, $LOCALE()[get$2(field).title]));
					append($$anchor, text$1);
				};

				if_block(node_9, ($$render) => {
					if (get$2(field).sortable && Object.hasOwn(sorter(), get$2(propPath))) $$render(consequent_5); else $$render(alternate_1, false);
				});
			}

			reset(th_1);
			template_effect(() => set_class(th_1, (get$2(field).hideOnMobile ? " is-hidden-touch" : "") + (get$2(field).sortable ? " is-clickable" : "")));
			append($$anchor, th_1);
		});

		reset(tr);
		reset(thead);

		var tbody = sibling(thead);

		each(tbody, 21, items, (item) => item._id, ($$anchor, item) => {
			NotTableRow($$anchor, {
				get id() {
					return $$props.id;
				},
				get item() {
					return get$2(item);
				},
				get fields() {
					return fields();
				},
				get helpers() {
					return helpers();
				},
				get showSelect() {
					return showSelect();
				},
				get getItemId() {
					return getItemId();
				},
				$$events: {
					rowSelectChange($$arg) {
						bubble_event.call(this, $$props, $$arg);
					}
				}
			});
		});

		reset(tbody);
		reset(table);

		var node_10 = sibling(table, 2);

		{
			var consequent_8 = ($$anchor) => {
				var nav = root_11$1();
				var a = child(nav);

				a.__click = [goPrev, dispatch];

				var a_1 = sibling(a, 2);

				a_1.__click = [goNext, dispatch];

				var ul = sibling(a_1, 2);
				var node_11 = child(ul);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_6 = comment();
						var node_12 = first_child(fragment_6);

						each(node_12, 17, () => state().pagination.pages.list, index$d, ($$anchor, page) => {
							var li = root_13();
							var node_13 = child(li);

							{
								var consequent_6 = ($$anchor) => {
									var a_2 = root_14$1();
									var text_1 = child(a_2, true);

									reset(a_2);

									template_effect(() => {
										set_attribute(a_2, "aria-label", `Страница ${get$2(page).index ?? ""}`);
										set_text(text_1, get$2(page).index + 1);
									});

									append($$anchor, a_2);
								};

								var alternate_2 = ($$anchor) => {
									var a_3 = root_15$1();

									a_3.__click = [goTo, dispatch];

									var text_2 = child(a_3, true);

									reset(a_3);

									template_effect(() => {
										set_attribute(a_3, "aria-label", `Страница ${get$2(page).index ?? ""}`);
										set_attribute(a_3, "data-page", get$2(page).index);
										set_text(text_2, get$2(page).index + 1);
									});

									append($$anchor, a_3);
								};

								if_block(node_13, ($$render) => {
									if (get$2(page).active) $$render(consequent_6); else $$render(alternate_2, false);
								});
							}

							reset(li);
							append($$anchor, li);
						});

						append($$anchor, fragment_6);
					};

					if_block(node_11, ($$render) => {
						if (state().pagination && state().pagination.pages && state().pagination.pages.list) $$render(consequent_7);
					});
				}

				reset(ul);
				reset(nav);
				append($$anchor, nav);
			};

			if_block(node_10, ($$render) => {
				if (state()?.pagination?.pages?.list.length > 1) $$render(consequent_8);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(["input", "change", "click"]);

	const CONST_ID_DUBLICATE_POSTFIX = "__dublicate__";
	const OPT_DEFAULT_PAGE_SIZE = 20,
	  OPT_DEFAULT_PAGE_NUMBER = 0,
	  OPT_DEFAULT_PAGE_RANGE = 6,
	  OPT_DEFAULT_SORT_DIRECTION = 1,
	  OPT_DEFAULT_SEARCH = "",
	  OPT_DEFAULT_RETURN = {},
	  OPT_DEFAULT_COMBINED = false,
	  OPT_DEFAULT_COMBINED_ACTION = "listAndCount",
	  OPT_DEFAULT_COUNT_ACTION = "count",
	  OPT_DEFAULT_LIST_ACTION = "list",
	  OPT_DEFAULT_SORT_FIELD = "_id",
	  OPT_FIELD_NAME_PRE_PROC = "preprocessor";
	const DEFAULT_OPTIONS = {
	  ui: NotTable,
	  links: [],
	  actions: [],
	  endless: false,
	  idField: "_id",
	  getItemId: function (item) {
	    return item._id;
	  }
	};
	let notTable = /*#__PURE__*/function (_EventEmitter) {
	  function notTable(input = {}) {
	    var _this;
	    _classCallCheck(this, notTable);
	    _this = _callSuper(this, notTable);
	    _this.id = "table-" + Math.random();
	    _this.options = {
	      ...DEFAULT_OPTIONS,
	      ...(input.options ? input.options : {})
	    };
	    _this.ui = {};
	    _this.data = {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {}
	    };
	    _this.state = {
	      pagination: {
	        items: {
	          count: 0,
	          from: 0,
	          to: 0
	        },
	        pages: {
	          count: 0,
	          from: 0,
	          to: 0,
	          current: 0,
	          list: []
	        }
	      }
	    };
	    _this.working = {};
	    _this.stores = create(_this.id, {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {},
	      state: _this.state,
	      working: _this.working
	    });
	    _this.stores.working.subscribe(_this.onWorkingUpdate.bind(_this));
	    //полученные из сети
	    _this.stores.raw.subscribe(_this.onRawUpdate.bind(_this));
	    //применены фильтры, сортировки и т.д.
	    _this.stores.filtered.subscribe(_this.onFilteredUpdate.bind(_this));
	    //урезаны до минимального набора, точно соотвествующего табличному формату
	    _this.stores.refined.subscribe(_this.onRefinedUpdate.bind(_this));
	    //словарь с идентификаторами выбранных строк
	    _this.stores.selected.subscribe(_this.onSelectedUpdate.bind(_this));
	    //pagination, items information
	    _this.stores.state.subscribe(_this.onStateUpdate.bind(_this));
	    if (notCommon$1.objHas(input, "data") && Array.isArray(input.data)) {
	      _this.stores.raw.update(function (val) {
	        val = input.data;
	        return val;
	      });
	    }
	    _this.setCombinedActionName(_this.getOptions("interface.combinedAction", OPT_DEFAULT_COMBINED_ACTION));
	    if (notCommon$1.objHas(_this.options, "filter")) {
	      _this.setFilter(_this.options.filter, true);
	    } else {
	      _this.resetFilter();
	    }
	    if (notCommon$1.objHas(_this.options, "pager")) {
	      _this.setPager(_this.options.pager, true);
	    } else {
	      _this.resetPager();
	    }
	    if (notCommon$1.objHas(_this.options, "sorter")) {
	      _this.setSorter(_this.options.sorter, true);
	    } else {
	      _this.resetSorter(true);
	    }
	    if (notCommon$1.objHas(_this.options, "return")) {
	      _this.setReturn(_this.options.return);
	    } else {
	      _this.setReturn();
	    }
	    if (notCommon$1.objHas(_this.options, "search")) {
	      _this.setSearch(_this.options.search, true);
	    } else {
	      _this.setSearch();
	    }
	    _this.render();
	    _this.updateData();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notTable, _EventEmitter);
	  return _createClass(notTable, [{
	    key: "onWorkingUpdate",
	    value: function onWorkingUpdate(val) {
	      this.working = val;
	      return val;
	    }
	  }, {
	    key: "onRawUpdate",
	    value: function onRawUpdate(val) {
	      this.data.raw = val;
	      return val;
	    }
	  }, {
	    key: "onFilteredUpdate",
	    value: function onFilteredUpdate(val) {
	      this.data.filtered = val;
	      this.refineFiltered();
	      return val;
	    }
	  }, {
	    key: "onRefinedUpdate",
	    value: function onRefinedUpdate(val) {
	      this.data.refined = val;
	      this.clearSelected();
	      return val;
	    }
	  }, {
	    key: "onStateUpdate",
	    value: function onStateUpdate(val) {
	      this.state = val;
	      return val;
	    }
	  }, {
	    key: "onSearchChange",
	    value: function onSearchChange(line) {
	      if (line.length > 3) {
	        this.setSearch(line);
	      } else {
	        this.setSearch();
	      }
	    }
	  }, {
	    key: "onSorterChange",
	    value: function onSorterChange(sorter) {
	      if (sorter) {
	        this.setSorter(sorter);
	      } else {
	        this.resetSorter();
	      }
	    }
	  }, {
	    key: "onFilterChange",
	    value: function onFilterChange({
	      filter,
	      actionName
	    }) {
	      if (actionName.indexOf(OPT_DEFAULT_COMBINED_ACTION) === 0) {
	        this.setCombinedActionName(actionName);
	      }
	      if (filter) {
	        this.setFilter(filter);
	      } else {
	        this.resetFilter();
	      }
	    }
	  }, {
	    key: "onSelectedUpdate",
	    value: function onSelectedUpdate(val) {
	      this.data.selected = val;
	    }
	  }, {
	    key: "clearSelected",
	    value: function clearSelected() {
	      this.data.selected = {};
	    }
	  }, {
	    key: "getSelected",
	    value: function getSelected(object = false, store = "refined") {
	      let res = [];
	      for (let id in this.data.selected) {
	        if (this.data.selected[id]) {
	          if (object) {
	            let indx = this.data[store].findIndex(function (item) {
	              return item._id === id;
	            });
	            if (indx > -1) {
	              res.push(this.data[store][indx]);
	            }
	          } else {
	            res.push(id);
	          }
	        }
	      }
	      return res;
	    }
	  }, {
	    key: "getItemId",
	    value: function getItemId(item) {
	      return this.getOptions("getItemId", DEFAULT_OPTIONS.getItemId)(item);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll() {
	      var _this2 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this2.data.filtered.forEach(function (item) {
	          value[_this2.getItemId(item)] = true;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone() {
	      var _this3 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this3.data.filtered.forEach(function (item) {
	          value[_this3.getItemId(item)] = false;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;
	      if (!this.ui.table) {
	        this.ui.table = new this.options.ui({
	          target: this.options.targetEl,
	          props: {
	            filterUI: this.getOptions("filterUI", undefined),
	            id: this.id,
	            helpers: Object.assign({}, this.getHelpers()),
	            fields: this.getOptions("fields"),
	            actions: this.getActions(),
	            links: this.getLinks(),
	            search: "",
	            showSelect: this.getOptions("showSelect"),
	            showSearch: this.getOptions("showSearch"),
	            showSort: this.getOptions("showSort"),
	            idField: this.getOptions("idField"),
	            getItemId: this.getOptions("getItemId"),
	            filter: this.getFilter()
	          }
	        });
	      }
	      this.ui.table.$on("searchChange", function (e) {
	        return _this4.onSearchChange(e.detail);
	      });
	      this.ui.table.$on("sorterChange", function (e) {
	        return _this4.onSorterChange(e.detail);
	      });
	      this.ui.table.$on("filterChange", function (e) {
	        return _this4.onFilterChange(e.detail);
	      });
	      this.ui.table.$on("goToPage", function (e) {
	        return _this4.goToPage(e.detail);
	      });
	      this.ui.table.$on("goToNextPage", function () {
	        return _this4.goToNext();
	      });
	      this.ui.table.$on("goToPrevPage", function () {
	        return _this4.goToPrev();
	      });
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.getOptions("actions", []);
	    }
	  }, {
	    key: "getLinks",
	    value: function getLinks() {
	      return this.getOptions("links", []);
	    }
	  }, {
	    key: "getHelpers",
	    value: function getHelpers() {
	      return this.options.helpers || {};
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking(key, value) {
	      var _this5 = this;
	      this.stores.working.update(function (val) {
	        notPath.set(key, val, _this5.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking(key, def) {
	      let res = notPath.get(key, this.working, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setState",
	    value: function setState(key, value) {
	      var _this6 = this;
	      this.stores.state.update(function (val) {
	        notPath.set(key, val, _this6.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getState",
	    value: function getState(key, def) {
	      let res = notPath.get(key, this.state, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(key, value) {
	      notPath.set(key, this.options, this.getHelpers(), value);
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions(key, def) {
	      let res = notPath.get(key, this.options, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(hash, withoutInvalidation = false) {
	      this.setState("filter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      this.setState("filter", {});
	      return this;
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getState("filter");
	    }
	  }, {
	    key: "setPager",
	    value: function setPager(hash, withoutInvalidation = false) {
	      this.setState("pager", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getDefaultPageNumber",
	    value: function getDefaultPageNumber() {
	      return isNaN(this.getOptions("pager.page")) ? OPT_DEFAULT_PAGE_NUMBER : this.getOptions("pager.page");
	    }
	  }, {
	    key: "getDefaultPageSize",
	    value: function getDefaultPageSize() {
	      return isNaN(this.getOptions("pager.size")) ? OPT_DEFAULT_PAGE_SIZE : this.getOptions("pager.size");
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      this.setState("pager", {
	        size: this.getDefaultPageSize(),
	        page: this.getDefaultPageNumber()
	      });
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getState("pager");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(hash, withoutInvalidation = false) {
	      this.setWorking("sorter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter(withoutInvalidation = false) {
	      let t = {};
	      t[OPT_DEFAULT_SORT_FIELD] = OPT_DEFAULT_SORT_DIRECTION;
	      return this.setSorter(t, withoutInvalidation);
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "getSorterDirection",
	    value: function getSorterDirection() {
	      try {
	        let names = Object.keys(this.getSorter());
	        return this.getSorter()[names[0]];
	      } catch {
	        return OPT_DEFAULT_SORT_DIRECTION;
	      }
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      let search = typeof this.getWorking("search") !== "undefined" && this.getWorking("search") !== null;
	      return search ? this.getWorking("search") : "";
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(line = OPT_DEFAULT_SEARCH, withoutInvalidation = false) {
	      this.setWorking("search", line);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(ret = OPT_DEFAULT_RETURN) {
	      this.setWorking("return", ret);
	      return this;
	    }
	  }, {
	    key: "clearFilteredData",
	    value: function clearFilteredData() {
	      this.stores.filtered.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRawData",
	    value: function clearRawData() {
	      this.stores.raw.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRefinedData",
	    value: function clearRefinedData() {
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "invalidateData",
	    value: function invalidateData() {
	      //clearing filtered and sorted
	      this.clearFilteredData();
	      //in case live loading from server
	      if (this.isLive()) {
	        //clearing loaded data
	        this.clearRawData();
	      }
	      //resset pager anyway
	      this.resetPager();
	    }
	  }, {
	    key: "isLive",
	    value: function isLive() {
	      return this.getOptions("interface") && this.getOptions("interface.factory");
	    }
	  }, {
	    key: "setUpdating",
	    value: function setUpdating() {
	      this.setState("updating", true);
	    }
	  }, {
	    key: "setUpdated",
	    value: function setUpdated() {
	      this.setState("updating", false);
	    }
	  }, {
	    key: "ifUpdating",
	    value: function ifUpdating() {
	      return this.getState("updating");
	    }
	  }, {
	    key: "getDataInterface",
	    value: function getDataInterface() {
	      let factory = this.getOptions("interface.factory");
	      if (typeof factory === "function") {
	        return factory({});
	      } else {
	        return factory;
	      }
	    }
	  }, {
	    key: "getLoadDataActionName",
	    value: function getLoadDataActionName() {
	      return this.getOptions("interface.listAction") ? this.getOptions("interface.listAction") : OPT_DEFAULT_LIST_ACTION;
	    }
	  }, {
	    key: "setCombinedActionName",
	    value: function setCombinedActionName(actionName = OPT_DEFAULT_COUNT_ACTION) {
	      this.setWorking("interface.combinedAction", actionName);
	    }
	  }, {
	    key: "getCombinedActionName",
	    value: function getCombinedActionName() {
	      return this.getWorking("interface.combinedAction") ? this.getWorking("interface.combinedAction") : OPT_DEFAULT_COMBINED_ACTION;
	    }
	  }, {
	    key: "getCountActionName",
	    value: function getCountActionName() {
	      return this.getOptions("interface.countAction") ? this.getOptions("interface.countAction") : OPT_DEFAULT_COUNT_ACTION;
	    }
	  }, {
	    key: "loadData",
	    value: function loadData() {
	      //load from server
	      let query = this.getDataInterface().setFilter(this.getFilter()).setSorter(this.getSorter()).setReturn(this.getReturn()).setSearch(this.getSearch()).setPager(this.getPager()),
	        actionName;
	      if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	        actionName = this.getCombinedActionName();
	      } else {
	        actionName = this.getLoadDataActionName();
	      }
	      return query["$" + actionName]();
	    }
	  }, {
	    key: "goToNext",
	    value: function goToNext() {
	      let next = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") + 1;
	      this.setState("pager.page", Math.min(next, this.getState("pagination.pages.to")));
	      this.updateData();
	    }
	  }, {
	    key: "goToPrev",
	    value: function goToPrev() {
	      let prev = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") - 1;
	      this.setState("pager.page", Math.max(prev, this.getState("pagination.pages.from")));
	      this.updateData();
	    }
	  }, {
	    key: "goToFirst",
	    value: function goToFirst() {
	      this.setState("pager.page", this.getState("pagination.pages.from"));
	      this.updateData();
	    }
	  }, {
	    key: "goToLast",
	    value: function goToLast() {
	      this.setState("pager.page", this.getState("pagination.pages.to"));
	      this.updateData();
	    }
	  }, {
	    key: "goToPage",
	    value: function goToPage(pageNumber) {
	      this.setState("pager.page", pageNumber);
	      this.updateData();
	    }
	  }, {
	    key: "testDataItem",
	    value: function testDataItem(item) {
	      var strValue = this.getSearch().toLowerCase();
	      for (var k in item) {
	        var toComp = item[k].toString().toLowerCase();
	        if (toComp.indexOf(strValue) > -1) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "getRowsCount",
	    value: function getRowsCount() {
	      var _this7 = this;
	      let query = this.getDataInterface().setFilter(this.getFilter());
	      return query["$" + this.getCountActionName()]().then(function (data) {
	        _this7.updatePagination(data.count);
	      }).catch(function (e) {
	        _this7.error(e);
	      });
	    }
	  }, {
	    key: "updatePagination",
	    value: function updatePagination(itemsCount) {
	      var _this8 = this;
	      this.log("update pagination", itemsCount);
	      this.state.pagination.pages.list.splice(0, this.state.pagination.pages.list.length);
	      let itemsFrom = (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER) * this.getPager().size + 1,
	        pagesCount = itemsCount % this.getPager().size ? Math.floor(itemsCount / this.getPager().size) + 1 : Math.round(itemsCount / this.getPager().size),
	        pagesFrom = Math.max(OPT_DEFAULT_PAGE_NUMBER, this.getPager().page - OPT_DEFAULT_PAGE_RANGE),
	        pagesTo = Math.min(pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER), this.getPager().page + OPT_DEFAULT_PAGE_RANGE),
	        list = [],
	        itemsTo = Math.min(itemsFrom + this.getPager().size - 1, itemsCount);
	      for (let t = pagesFrom; t <= pagesTo; t++) {
	        list.push({
	          index: t,
	          active: t === this.getPager().page
	        });
	      }
	      this.stores.state.update(function (val) {
	        _this8.log("update pagination", val);
	        val.pagination.items.count = itemsCount;
	        val.pagination.items.from = itemsFrom;
	        val.pagination.items.to = itemsTo;
	        val.pagination.pages.count = pagesCount;
	        val.pagination.pages.from = pagesFrom;
	        val.pagination.pages.to = pagesTo;
	        val.pagination.pages.current = _this8.getPager().page;
	        val.pagination.pages.list.splice(0, val.pagination.pages.list.length, ...list);
	        return val;
	      });
	    }
	  }, {
	    key: "updateData",
	    value: function updateData() {
	      var _this9 = this;
	      if (this.isLive()) {
	        if (this.ifUpdating()) {
	          return;
	        }
	        if (!this.getOptions("endless", false)) {
	          this.clearRawData();
	        }
	        this.setUpdating();
	        if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	          this.loadData().then(function (data) {
	            let full = notCommon$1.objHas(data, "status") && notCommon$1.objHas(data, "result");
	            _this9.stores.filtered.update(function (val) {
	              if (!_this9.getOptions("endless", false)) {
	                _this9.clearFilteredData();
	              }
	              if (full) {
	                val.push(...data.result.list);
	              } else {
	                if (notCommon$1.objHas(data, "list") && Array.isArray(data.list)) {
	                  val.push(...data.list);
	                } else if (Array.isArray(data)) {
	                  val.push(...data);
	                }
	              }
	              return val;
	            });
	            _this9.setWorking("lastCount", full ? data.result.count : data.count);
	          }).then(function () {
	            _this9.updatePagination(_this9.getWorking("lastCount"));
	          }).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        } else {
	          this.loadData().then(function (data) {
	            _this9.stores.filtered.update(function (val) {
	              val.push(...data);
	              return val;
	            });
	          }).then(this.getRowsCount.bind(this)).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        }
	      } else {
	        //local magic
	        this.setUpdating();
	        this.processData();
	        this.setUpdated();
	      }
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.data;
	    }
	  }, {
	    key: "processData",
	    value: function processData() {
	      var _this10 = this;
	      let thatFilter = this.getFilter();
	      //this.getData('rows').__setPassive;
	      this.log(this.getData());
	      if (typeof thatFilter !== "undefined" && thatFilter !== null && typeof thatFilter.filterSearch !== "undefined" && thatFilter.filterSearch !== null && thatFilter.filterSearch.length > 0) {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this10.data.raw.filter(_this10.testDataItem.bind(_this10)));
	          return val;
	        });
	      } else {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this10.data.raw);
	          return val;
	        });
	      }
	      ////sorter
	      let thatSorter = this.getSorter();
	      if (typeof thatSorter !== "undefined" && thatSorter !== null) {
	        this.stores.filtered.update(function (val) {
	          val.sort(function (item1, item2) {
	            let t1 = notPath.get(thatSorter.sortByField, item1, {}),
	              t2 = notPath.get(thatSorter.sortByField, item2, {});
	            if (isNaN(t1)) {
	              if (typeof t1 !== "undefined" && typeof t2 !== "undefined" && t1.localeCompare) {
	                return t1.localeCompare() * -thatSorter.sortDirection;
	              } else {
	                return 0;
	              }
	            } else {
	              return (t1 < t2 ? 1 : -1) * thatSorter.sortDirection;
	            }
	          });
	          return val;
	        });
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      if (this.options.logger) {
	        this.options.logger.error(...arguments);
	      }
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      if (this.options.logger) {
	        this.options.logger.log(...arguments);
	      }
	    }
	  }, {
	    key: "checkFieldsNames",
	    value: function checkFieldsNames() {
	      const fieldId = this.getOptions("idField");
	      const pathId = ":" + fieldId;
	      let fields = this.getOptions("fields", []);
	      fields.forEach(function (field) {
	        if (pathId === field.path) {
	          field.path = field.path + CONST_ID_DUBLICATE_POSTFIX;
	        }
	      });
	    }
	  }, {
	    key: "readFieldValue",
	    value: function readFieldValue(path, item, helpers) {
	      if (path.indexOf(CONST_ID_DUBLICATE_POSTFIX) > -1) {
	        const fieldId = this.getOptions("idField");
	        const pathId = ":" + fieldId;
	        return notPath.get(pathId, item, helpers);
	      } else {
	        return notPath.get(path, item, helpers);
	      }
	    }
	  }, {
	    key: "refineFiltered",
	    value: function refineFiltered() {
	      var _this11 = this;
	      let result = [];
	      this.checkFieldsNames();
	      this.data.filtered.forEach(function (item, index) {
	        let refined = {};
	        if (_this11.getOptions("idField")) {
	          refined[_this11.getOptions("idField")] = item[_this11.getOptions("idField")];
	        }
	        _this11.getOptions("fields", []).forEach(function (field) {
	          let preprocessed = null,
	            val = _this11.readFieldValue(field.path, item, _this11.getOptions("helpers"));
	          if (notCommon$1.objHas(field, OPT_FIELD_NAME_PRE_PROC)) {
	            try {
	              preprocessed = field[OPT_FIELD_NAME_PRE_PROC](val, item, index);
	            } catch (e) {
	              _this11.error("Error while preprocessing cell value", val, item, index);
	              _this11.error(e);
	            }
	            notPath.set(field.path, refined, preprocessed);
	          } else {
	            notPath.set(field.path, refined, val);
	          }
	        });
	        result.push(refined);
	      });
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length, ...result);
	        return val;
	      });
	    }
	  }, {
	    key: "$destroy",
	    value: function $destroy() {
	      for (let name in this.ui) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        delete this.ui[name];
	      }
	    }
	  }]);
	}(EventEmitter);

	var root_1$6 = template(`<!> <!>`, 1);
	var root$7 = template(`<!> <!>`, 1);

	function Ui_action_container($$anchor, $$props) {
		push($$props, true);

		//hidden - no loader
		//container - parent container of form
		let success = state(false);
		let error = state(false);

		/**
		 * @typedef {Object} Props
		 * @property {any} [container]
		 * @property {string} [loaderTitle]
		 * @property {boolean} [loaderActive] - state if form loading
		 * @property {string} [loaderSize] - page - whole page
		 * @property {string} [successTitle]
		 * @property {string} [successMessage]
		 * @property {string} [errorTitle]
		 * @property {string} [errorMessage]
		 */
		/** @type {Props} */
		let container = prop($$props, "container", 19, () => ({})),
			loaderTitle = prop($$props, "loaderTitle", 15, "Отправка данных на сервер"),
			loaderActive = prop($$props, "loaderActive", 15, false),
			loaderSize = prop($$props, "loaderSize", 15, "container"),
			successTitle = prop($$props, "successTitle", 15, "OK"),
			successMessage = prop($$props, "successMessage", 15, ""),
			errorTitle = prop($$props, "errorTitle", 15, "Error"),
			errorMessage = prop($$props, "errorMessage", 15, "");

		function showSuccess(title, message) {
			set(error, false);
			set(success, true);

			if (message != undefined) {
				successMessage(message);
			}

			if (title != undefined) {
				successTitle(title);
			}
		}

		function showError(title, message) {
			set(success, false);
			set(error, true);

			if (message != undefined) {
				errorMessage(message);
			}

			if (title != undefined) {
				errorTitle(title);
			}
		}

		function setLoading() {
			loaderActive(true);
			set(success, false);
			set(error, false);
		}

		function resetLoading() {
			loaderActive(false);
		}

		function hideAll() {
			loaderActive(false);
			set(success, false);
			set(error, false);
		}

		var fragment = root$7();
		var node = first_child(fragment);

		Ui_loader(node, {
			get loading() {
				return loaderActive();
			},
			set loading($$value) {
				loaderActive($$value);
			},
			get title() {
				return loaderTitle();
			},
			set title($$value) {
				loaderTitle($$value);
			},
			get size() {
				return loaderSize();
			},
			set size($$value) {
				loaderSize($$value);
			}
		});

		var node_1 = sibling(node, 2);

		Ui_container(node_1, spread_props(container, {
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$6();
				var node_2 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_error($$anchor, {
							get title() {
								return errorTitle();
							},
							set title($$value) {
								errorTitle($$value);
							},
							get message() {
								return errorMessage();
							},
							set message($$value) {
								errorMessage($$value);
							}
						});
					};

					if_block(node_2, ($$render) => {
						if (get$2(error)) $$render(consequent);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_success($$anchor, {
							get title() {
								return successTitle();
							},
							set title($$value) {
								successTitle($$value);
							},
							get message() {
								return successMessage();
							},
							set message($$value) {
								successMessage($$value);
							}
						});
					};

					if_block(node_3, ($$render) => {
						if (get$2(success)) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		}));

		append($$anchor, fragment);

		return pop({
			showSuccess,
			showError,
			setLoading,
			resetLoading,
			hideAll
		});
	}

	const DEFAULT_CONTAINER_SELECTOR$2 = ".container";
	var _uiComponent$1 = /*#__PURE__*/new WeakMap();
	var _ui = /*#__PURE__*/new WeakMap();
	let notActionUI = /*#__PURE__*/function (_notBase) {
	  function notActionUI({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data = {},
	    ui = Ui_action_container //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notActionUI);
	    _this = _callSuper(this, notActionUI, [{
	      working: {
	        name: `${name}ActionUI`,
	        ...working
	      },
	      options,
	      data
	    }]);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent$1, null);
	    _classPrivateFieldInitSpec(_this, _ui, null);
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent$1, _this, ui);
	    _this.initUI();
	    return _this;
	  }
	  _inherits(notActionUI, _notBase);
	  return _createClass(notActionUI, [{
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const target = this.getTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_ui, this, new (_classPrivateFieldGet2(_uiComponent$1, this))({
	          target,
	          props: this.getOptions()
	        }));
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_ui, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_ui, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_ui, this)) {
	        _classPrivateFieldGet2(_ui, this).$destroy && _classPrivateFieldGet2(_ui, this).$destroy();
	        _classPrivateFieldGet2(_ui, this).destroy && _classPrivateFieldGet2(_ui, this).destroy();
	        _classPrivateFieldSet2(_ui, this, null);
	      }
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_ui, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_ui, this).showError(status);
	      this.emit("error", status);
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getTargetEl",
	    value: function getTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$2);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("ActionUI parent element is not defined");
	      }
	    }
	  }]);
	}(notBase);

	let notFormUtils$1 = /*#__PURE__*/function () {
	  function notFormUtils() {
	    _classCallCheck(this, notFormUtils);
	  }
	  return _createClass(notFormUtils, null, [{
	    key: "addComponent",
	    value: function addComponent(name, value) {
	      COMPONENTS$1.add(name, value);
	    }
	  }, {
	    key: "addVariants",
	    value: function addVariants(name, value) {
	      VARIANTS$1.add(name, value);
	    }
	  }, {
	    key: "addField",
	    value: function addField(name, field) {
	      FIELDS$1.add(name, field);
	    }
	  }, {
	    key: "actionFieldsInit",
	    value: function actionFieldsInit(fieldName, options, data) {
	      var _this = this;
	      if (Array.isArray(fieldName)) {
	        fieldName.forEach(function (subFieldName) {
	          _this.actionFieldsInit(subFieldName, options, data);
	        });
	      } else {
	        if (!notCommon$1.objHas(options, "fields")) {
	          options.fields = {};
	        }
	        if (!notCommon$1.objHas(options.fields, fieldName)) {
	          options.fields[fieldName] = {};
	        }
	        //copying initial data
	        if (typeof data !== "undefined" && data !== null && typeof data[fieldName] !== "undefined" && data[fieldName] !== null) {
	          options.fields[fieldName].value = data[fieldName];
	        }
	      }
	    }
	  }]);
	}();
	_defineProperty(notFormUtils$1, "validator", null);

	const DEFAULT_FIELD = {
	  label: "",
	  placeholder: "",
	  enabled: true,
	  visible: true,
	  required: true,
	  validated: false,
	  valid: false,
	  errors: false
	};

	/**
	 * Creates field manifest
	 * @param {string} type      name/type of the field
	 * @param {Object} mutation  mutation to manifest from library
	 * @param {Object} VARIANTS  store which contains named lists of field value variants
	 * @param {Object} FIELDS    store which contains named lists of field manifests
	 * @return {Object}          field manifest
	 **/
	function fieldInit(type, mutation = {}, VARIANTS, FIELDS) {
	  let field = {
	    ...DEFAULT_FIELD
	  };
	  //getting field core manifest
	  if (FIELDS.contains(type)) {
	    field = {
	      ...field,
	      ...FIELDS.get(type)
	    };
	  }
	  //adding mutations
	  if (mutation) {
	    field = {
	      ...field,
	      ...mutation
	    };
	  }
	  //adding variants list to field from VARIANTS store
	  if (notCommon$1.objHas(field, "variantsSource") && VARIANTS.contains(field.variantsSource)) {
	    field.variants = VARIANTS.get(field.variantsSource);
	  } else {
	    if (!field.variants || field.variants.length === 0) {
	      field.variants = [];
	    }
	  }
	  return field;
	}

	/**
	 * Initialization of form structure object
	 * @param {object}               form          form structure object
	 * @param {string|Array<string>} fieldName     name of the field type if string, array of strings = subform
	 * @param {Object}               VARIANTS      store which contains named lists of field value variants
	 * @param {Object}               FIELDS        store which contains named lists of field manifests
	 * @param {Object}               formFieldsOptions   form wide options
	 * @returns {Object}                           form structure object
	 **/
	function initFormByField(form = {}, fieldName = [], VARIANTS, FIELDS, formFieldsOptions, data) {
	  if (Array.isArray(fieldName)) {
	    fieldName.forEach(function (subFormFieldName) {
	      return initFormByField(form, subFormFieldName, VARIANTS, FIELDS, formFieldsOptions, data);
	    });
	  } else {
	    let opts = {};
	    if (formFieldsOptions && notCommon$1.objHas(formFieldsOptions, "mutations") && notCommon$1.objHas(formFieldsOptions.mutations, fieldName)) {
	      opts = formFieldsOptions.mutations[fieldName]; //option mutation for field
	    }
	    if (data && notCommon$1.objHas(data, fieldName)) {
	      opts.value = data[fieldName];
	    }
	    form[fieldName] = fieldInit(fieldName, opts, VARIANTS, FIELDS);
	    //if form readonly, marking every field as readonly
	    if (formFieldsOptions && formFieldsOptions.readonly) {
	      form[fieldName].readonly = true;
	    }
	  }
	  return form;
	}

	/**
	 *  Marking field as invalid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFieldInvalid(form, fieldName, value, errors) {
	  form[fieldName].errors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].valid = false;
	  form[fieldName].value = value;
	  return form;
	}

	/**
	 *  Marking field as valid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @return {Object}                        form structure object
	 **/
	function setFieldValid(form, fieldName, value) {
	  form[fieldName].errors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].value = value;
	  for (let fname in form) {
	    if (fname !== fieldName) {
	      if (Array.isArray(form[fname].errors) && form[fname].errors.length === 0) {
	        form[fname].errors = false;
	      }
	      if (form[fname].errors !== false) {
	        break;
	      }
	    }
	  }
	  return form;
	}

	/**
	 * Checks if field has errors
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @returns {boolean}                      true - valid, false -invalid
	 **/
	function isFieldValid(form, fieldName) {
	  return !Array.isArray(form[fieldName].errors);
	}

	/**
	 * Form level validator error in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldInvalid(form, fieldName, errors) {
	  form[fieldName].formErrors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].inputStarted = true;
	  form[fieldName].valid = false;
	  form[fieldName].formLevelError = true;
	  return form;
	}
	/**
	 * Form level validator success in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldValid(form, fieldName) {
	  form[fieldName].formErrors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].formLevelError = false;
	  return form;
	}

	/**
	 * Updates fields and form error labels
	 * @param {Object}           form                  form structure object
	 * @param {Object}           validationStatus      results of validation
	 **/
	function updateFormValidationStatus({
	  form,
	  formErrors,
	  validationStatus
	} /* FormValidationSession.getCompleteResult() */) {
	  if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
	    formErrors.splice(0, formErrors.length, ...validationStatus.form);
	  } else {
	    formErrors.splice(0, formErrors.length);
	  }
	  if (validationStatus.fields) {
	    for (let fieldName in validationStatus.fields) {
	      if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
	        setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
	      } else {
	        setFormFieldValid(form, fieldName);
	      }
	    }
	  }
	}
	function setFieldsVisibility(form, fieldsList, val) {
	  if (Array.isArray(fieldsList)) {
	    Object.keys(form).forEach(function (fieldName) {
	      form[fieldName].visible = fieldsList.includes(fieldName) ? val : !val;
	    });
	    return true;
	  }
	  return false;
	}
	function setFieldValue(form, fieldName, value) {
	  if (notCommon$1.objHas(form, fieldName)) {
	    form[fieldName].value = value;
	    return true;
	  }
	  return false;
	}
	function fieldIsVisibleAndFilled(form, fieldName) {
	  return notCommon$1.objHas(form, fieldName) && form[fieldName].enabled && form[fieldName].visible && typeof form[fieldName].value !== "undefined";
	}
	function collectData(fields, form) {
	  let result = {};
	  fields.flat().forEach(function (fieldName) {
	    if (fieldIsVisibleAndFilled(form, fieldName)) {
	      result[fieldName] = form[fieldName].value;
	    }
	  });
	  return result;
	}
	var FormHelpers = {
	  fieldInit,
	  initFormByField,
	  setFieldInvalid,
	  setFieldValid,
	  isFieldValid,
	  setFormFieldInvalid,
	  setFormFieldValid,
	  updateFormValidationStatus,
	  fieldIsVisibleAndFilled,
	  setFieldsVisibility,
	  setFieldValue,
	  collectData
	};

	var result;
	var hasRequiredResult;

	function requireResult () {
		if (hasRequiredResult) return result;
		hasRequiredResult = 1;
		const emptyFieldsResults = (data) => {
		    return Object.keys(data).reduce((acc, curr) => {
		        acc[curr] = [];
		        return acc;
		    }, {});
		};

		const FIELDS = ["fields", "form"];

		result = class ValidationResult {
		    #clean = true;
		    #result;

		    constructor(result) {
		        this.#result = JSON.parse(JSON.stringify(result));
		        Object.keys(this.#result).forEach((fieldName) => {
		            if (!FIELDS.includes(fieldName)) {
		                delete this.#result[fieldName];
		            }
		        });
		        this.#clean = this.#result.form.errors.length === 0;
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            if (this.isFieldDirty(fieldName)) {
		                this.#clean = false;
		            }
		        }
		    }

		    destroy() {
		        this.#result = undefined;
		    }

		    get clean() {
		        return this.#clean;
		    }

		    static getDefaultResult(data) {
		        return {
		            fields: emptyFieldsResults(data),
		            form: {
		                fields: emptyFieldsResults(data),
		                errors: [],
		                exceptions: [],
		            },
		        };
		    }

		    getReport() {
		        return JSON.parse(JSON.stringify(this.#getCompleteResult()));
		    }

		    getDetailedReport() {
		        if (typeof this.#result === "object") {
		            return JSON.parse(JSON.stringify(this.#result));
		        } else {
		            return undefined;
		        }
		    }

		    isFieldDirty(fieldName) {
		        if (
		            Array.isArray(this.#result.fields[fieldName]) &&
		            this.#result.fields[fieldName].length
		        ) {
		            return true;
		        }
		        if (
		            Array.isArray(this.#result.form.fields[fieldName]) &&
		            this.#result.form.fields[fieldName].length
		        ) {
		            return true;
		        }
		        return false;
		    }

		    getCompleteResultForField(fieldName) {
		        const fieldResult = [];
		        if (Array.isArray(this.#result.fields[fieldName])) {
		            fieldResult.push(...this.#result.fields[fieldName]);
		        }
		        if (Array.isArray(this.#result.form.fields[fieldName])) {
		            fieldResult.push(...this.#result.form.fields[fieldName]);
		        }
		        return fieldResult;
		    }

		    #getCompleteResult() {
		        const resultComplete = {
		            clean: this.#clean,
		            fields: {},
		            form: [],
		        };
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            const errors = this.getCompleteResultForField(fieldName);
		            if (errors.length) {
		                resultComplete.fields[fieldName] = errors;
		            }
		        }
		        resultComplete.form = [...this.#result.form.errors];
		        if (resultComplete.form.length === 0) {
		            delete resultComplete.form;
		        }
		        return resultComplete;
		    }

		    #getFieldsList() {
		        const fields = Object.keys(this.#result.fields);
		        const fieldsInForm = Object.keys(this.#result.form.fields);
		        return [...new Set([...fieldsInForm, ...fields])];
		    }
		};
		return result;
	}

	/**
	*	Template of error.js
	*	For building for specific environment.
	*	Node.js or Browser
	*	@param {string}	env	node|browser in wich env it will be running
	*	@param {string}	url	URL of report collector
	*	@param {string}	key	key to indetificate reporter
	*/

	var error_node;
	var hasRequiredError_node;

	function requireError_node () {
		if (hasRequiredError_node) return error_node;
		hasRequiredError_node = 1;
		/**
		* Error reporting with features, saving browser info, uri and so on.
		* @module not-error/error
		*/
		class notError extends Error {
			constructor(message, options = {}, error = null){
				super(message);
				this.options = options;
				this.adopt(error);
				this.fill();
				this.getTime();
				return this;
			}

			/**
			*	Adopting native error object
			*	@param {Error}	error 	Error object
			*	@return {notError}		chainable
			*/
			adopt(error){
				if(error instanceof Error){
					this.parent = error;
				}
				return this;
			}

			getStack(){
				if(this.parent){
					return this.parent.stack;
				}else {
					return this.stack;
				}
			}

			getDetails(){
				let src = this;
				if(this.parent){
					src = this.parent;
				}
				return {
					columnNumber:    	src.columnNumber,
					fileName:        	src.fileName,
					lineNumber:      	src.lineNumber,
					name:            	src.name,
					message:        	src.message,
					stack:          	src.stack
				};
			}

			/**
			*	Updating this.env.date property
			*	@return  {object}	{timestamp, offset}
			*/
			getTime(){
				let date = new Date();
				this.env.date = {
					timestamp : date.getTime(),
					offset: date.getTimezoneOffset()
				};
				return this.env.date;
			}


			/**
			******************************************************************************************************
			******************************************************************************************************
			***	Node.js Section
			******************************************************************************************************
			******************************************************************************************************
			**/

			/**
			*	Filtering out key by `white` list
			*	@param {object} object hash to be copied according filter `white` list
			*	@param {array} filter array of sting, which represents keys we want to be
			*						copied in resulting object from source
			*	@return {object}		white listed hash
			*/
			filterEnv(object, filter){
				let result = {};
				for(let t of filter){
					if(Object.prototype.hasOwnProperty.call(object, t)){
						result[t] = object[t];
					}
				}
				return result;
			}

			/**
			*	Collecting information specific for Node.js V8
			*	@return {notError}		chainable
			*/
			fill(){
				/**
				*	You want some fields from env but not all, cause there are passwords
				*	from db, api keys and etc
				*/
				this.env = {
					browser: 	false,
					node: 		true,
					versions: Object.assign({}, process.versions),
					vars: 		this.filterEnv(process.env, this.options.whitelist || ['NODE_ENV'])
				};
				return this;
			}


		}


		error_node = notError;
		return error_node;
	}

	var validation_error_node;
	var hasRequiredValidation_error_node;

	function requireValidation_error_node () {
		if (hasRequiredValidation_error_node) return validation_error_node;
		hasRequiredValidation_error_node = 1;
		const notError = requireError_node();


		//reportable
		class notValidationError extends notError{
		  constructor(message, fields = {}, err = null, params = {}){
		    super(message, {fields, params}, err);
		    return this;
		  }

		  /**
		  * Sets hash of fields errors messages for usage in forms
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  setFieldsErrors(messages){
		    this.options.fields = messages;
		  }

		  /**
		  * Returns hash of errors
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  getFieldsErrors(){
		    return this.options.fields;
		  }

		}


		validation_error_node = notValidationError;
		return validation_error_node;
	}

	/**
	 * Test argument type to be 'function'
	 * @param {any}  func    possible function
	 * @return {boolean}     if this is a function
	 **/

	var common;
	var hasRequiredCommon;

	function requireCommon () {
		if (hasRequiredCommon) return common;
		hasRequiredCommon = 1;
		const isFunc = (func) => {
		    return typeof func === "function";
		};

		/**
		 * Returns true if argument is Async function
		 * @param {function} func  to test
		 * @return {boolean}       if this function is constructed as AsyncFunction
		 **/
		const isAsync = (func) => {
		    return func.constructor.name === "AsyncFunction";
		};

		common = async (proc, params) => {
		    if (isFunc(proc)) {
		        if (isAsync(proc)) {
		            return await proc(...params);
		        } else {
		            return proc(...params);
		        }
		    }
		};
		return common;
	}

	var session;
	var hasRequiredSession;

	function requireSession () {
		if (hasRequiredSession) return session;
		hasRequiredSession = 1;
		const ValidationResult = requireResult();
		const notVaildationError = requireValidation_error_node();
		const executeObjectFunction = requireCommon();

		const ValidationSession = async (validators, data) => {
		    const result = ValidationResult.getDefaultResult(data);
		    await validateFields({ validators, data, result });
		    await validateForm({ validators, data, result });
		    return new ValidationResult(result);
		};

		session = ValidationSession;

		const validateFields = async ({ validators, data, result }) => {
		    for (let t in data) {
		        await validateField(t, data[t], validators, result);
		    }
		};

		const validateField = async (fieldName, value, validators, result) => {
		    const fieldValidators = getFieldValidators(fieldName, validators);
		    return await runFieldValidators(fieldName, value, fieldValidators, result);
		};

		const getFieldValidators = (name, validators) => {
		    return validators && validators.fields && validators.fields[name]
		        ? validators.fields[name]
		        : [];
		};

		const runFieldValidators = async (fieldName, value, validators, result) => {
		    for (let validatorRule of validators) {
		        try {
		            const valid = await executeObjectFunction(
		                validatorRule["validator"],
		                [value]
		            );
		            if (!valid) {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        } catch (e) {
		            if (e instanceof notVaildationError || !validatorRule.message) {
		                setFieldError(fieldName, e.message, result);
		            } else {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        }
		    }
		};

		const setFieldError = (fieldName, errorMessage, result) => {
		    if (!result.fields[fieldName].includes(errorMessage)) {
		        result.fields[fieldName].push(errorMessage);
		    }
		};

		const validateForm = async ({ validators, data, result }) => {
		    const formValidators = getFormValidators(validators);
		    await runFormValidators(data, formValidators, result);
		};

		const getFormValidators = (validators) => {
		    return validators && validators.form ? validators.form : [];
		};

		const runFormValidators = async (data, formValidators, result) => {
		    for (let validator of formValidators) {
		        try {
		            await validator(data);
		        } catch (e) {
		            if (e && typeof e.getFieldsErrors === "function") {
		                const formErrors = e.getFieldsErrors();
		                Array.isArray(formErrors.form) &&
		                    addFormErrors(formErrors.form, result);
		                formErrors.fields &&
		                    addFormFieldsErrors(formErrors.fields, result);
		            } else {
		                throw e;
		            }
		        }
		    }
		};

		const addFormErrors = (errors, result) => {
		    errors.forEach((error) => {
		        addFormError(error, result);
		    });
		};

		const addFormError = (errorMessage, result) => {
		    if (!result.form.errors.includes(errorMessage)) {
		        result.form.errors.push(errorMessage);
		    }
		};

		const addFormFieldsErrors = (fieldsErrors, result) => {
		    for (let fieldName in fieldsErrors) {
		        addFormFieldErrors(fieldName, fieldsErrors[fieldName], result);
		    }
		};

		const addFormFieldErrors = (fieldName, errorMessages, result) => {
		    errorMessages.forEach((error) => {
		        addFormFieldError(fieldName, error, result);
		    });
		};

		const addFormFieldError = (fieldName, errorMessage, result) => {
		    if (!Array.isArray(result.form.fields[fieldName])) {
		        result.form.fields[fieldName] = [];
		    }
		    if (!result.form.fields[fieldName].includes(errorMessage)) {
		        result.form.fields[fieldName].push(errorMessage);
		    }
		};
		return session;
	}

	var runner_utils;
	var hasRequiredRunner_utils;

	function requireRunner_utils () {
		if (hasRequiredRunner_utils) return runner_utils;
		hasRequiredRunner_utils = 1;
		const composeFieldsValidators = (data, validatorsLib) => {
		    if (validatorsLib && validatorsLib.fields) {
		        const list = Object.keys(data);
		        const result = {};
		        list.forEach((fieldName) => {
		            if (Array.isArray(validatorsLib.fields[fieldName])) {
		                result[fieldName] = validatorsLib.fields[fieldName];
		            }
		        });
		        return result;
		    } else {
		        return {};
		    }
		};

		const composeFormValidators = (name, validatorsLib) => {
		    if (!validatorsLib) return [];
		    if (validatorsLib.forms && Array.isArray(validatorsLib.forms[name])) {
		        return validatorsLib.forms[name];
		    }
		    if (Array.isArray(validatorsLib.form)) {
		        return validatorsLib.form;
		    }
		    return [];
		};

		runner_utils = {
		    composeFieldsValidators,
		    composeFormValidators,
		};
		return runner_utils;
	}

	var runner;
	var hasRequiredRunner;

	function requireRunner () {
		if (hasRequiredRunner) return runner;
		hasRequiredRunner = 1;
		const {
		    composeFieldsValidators,
		    composeFormValidators,
		} = requireRunner_utils();

		const ValidationSession = requireSession();

		/**
		 * Creates validation runner function from provided validation rules lib
		 * @param {object}     validationLib object containing fields validation rules and form specific rules
		 * @returns {function} (data: object, formName: string)=>Promise<ValidationResult>
		 **/
		const ValidationRunner = (validatorsLib) => {
		    /**
		     * Validation session runner
		     * @param {object} data      object to validate
		     * @param {string} formName
		     * @returns {Promise}
		     **/
		    return (data, formName) => {
		        const validators = {
		            //fields specific validators
		            fields: composeFieldsValidators(data, validatorsLib),
		            //form specific validators
		            form: composeFormValidators(formName, validatorsLib),
		        };
		        return ValidationSession(validators, data);
		    };
		};

		runner = ValidationRunner;
		return runner;
	}

	var builder_utils;
	var hasRequiredBuilder_utils;

	function requireBuilder_utils () {
		if (hasRequiredBuilder_utils) return builder_utils;
		hasRequiredBuilder_utils = 1;
		const augmentFieldsValidators = (fieldValidators, getValidatorEnv) => {
		    return fieldValidators.map((fieldRule) =>
		        augmentFieldValidator(fieldRule, getValidatorEnv)
		    );
		};

		const augmentFieldValidator = (rule, getValidatorEnv) => {
		    if (rule.validator && typeof rule.validator === "function") {
		        const ruleValidator = rule.validator;
		        const result = {
		            ...rule,
		        };
		        delete result.validator;
		        result.validator = (val) => ruleValidator(val, getValidatorEnv());
		        return result;
		    }
		    return rule;
		};

		const augmentFormValidators = (rules, getValidatorEnv) => {
		    return rules.map((rule) => augmentFormValidator(rule, getValidatorEnv));
		};

		const augmentFormValidator = (rule, getValidatorEnv) => {
		    return (val) => rule(val, getValidatorEnv());
		};

		builder_utils = {
		    augmentFieldsValidators,
		    augmentFieldValidator,
		    augmentFormValidators,
		    augmentFormValidator,
		};
		return builder_utils;
	}

	var builder;
	var hasRequiredBuilder;

	function requireBuilder () {
		if (hasRequiredBuilder) return builder;
		hasRequiredBuilder = 1;
		const objHas = (obj, name) => {
		    return Object.prototype.hasOwnProperty.call(obj, name);
		};
		const {
		    augmentFieldsValidators,
		    augmentFormValidators,
		} = requireBuilder_utils();

		/**
		 * @typedef   {object}    notValidationSchema
		 * @property  {object}    [fields]
		 * @property  {array}     [form]
		 * @property  {object}    [forms]
		 */

		/**
		 * returns valid empty validation scheme
		 *
		 * @return {notValidationSchema}
		 */
		const emptyScheme = () => {
		    return {
		        fields: {},
		        forms: {},
		    };
		};
		/**
		 *
		 *
		 * @param {object} validators
		 * @param {function} getValidatorEnv
		 * @return {notValidationSchema}
		 */
		const validationBuilder = (validators, getValidatorEnv) => {
		    if (typeof validators === "undefined" || validators === null) {
		        return emptyScheme();
		    }
		    const augmented = {};
		    if (objHas(validators, "fields")) {
		        augmented.fields = transformFieldsValidators(
		            validators.fields,
		            getValidatorEnv
		        );
		    }
		    if (objHas(validators, "forms")) {
		        augmented.forms = transformFormsValidators(
		            validators.forms,
		            getValidatorEnv
		        );
		    } else {
		        if (objHas(validators, "form")) {
		            augmented.form = augmentFormValidators(
		                validators.form,
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		builder = validationBuilder;

		const transformFieldsValidators = (fields, getValidatorEnv) => {
		    const augmented = {};
		    for (let fieldName in fields) {
		        if (Array.isArray(fields[fieldName])) {
		            augmented[fieldName] = augmentFieldsValidators(
		                fields[fieldName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		const transformFormsValidators = (formsValidators, getValidatorEnv) => {
		    const augmented = {};
		    for (let formName in formsValidators) {
		        if (Array.isArray(formsValidators[formName])) {
		            augmented[formName] = augmentFormValidators(
		                formsValidators[formName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};
		return builder;
	}

	var src;
	var hasRequiredSrc;

	function requireSrc () {
		if (hasRequiredSrc) return src;
		hasRequiredSrc = 1;
		const Session = requireSession();
		const Runner = requireRunner();
		const Builder = requireBuilder();
		const Result = requireResult();

		src = {
		    name: "not-validation",
		    Session,
		    Runner,
		    Builder,
		    Result,
		};
		return src;
	}

	var srcExports = requireSrc();

	var root_4$4 = template(`<div><div class="field-label is-normal"><!></div> <div class="field-body"></div></div>`);
	var root_7$1 = template(`<!> <!>`, 1);
	var root_6$3 = template(`<div></div>`);

	function Field($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [label]
		 * @property {string} [name]
		 * @property {boolean} [readonly]
		 * @property {boolean} [horizontal]
		 * @property {any} [controls]
		 * @property {import('../../../elements/events.types').UIEventInputChangeCallback} onchange
		 * @property {string} [classes] - field style modification
		 * @property {boolean} [addons] - //addons
		 * @property {boolean} [addonsCentered]
		 * @property {boolean} [addonsRight]
		 * @property {boolean} [grouped] - //group flag
		 * @property {boolean} [groupedMultiline]
		 * @property {boolean} [groupedRight]
		 * @property {boolean} [groupedCentered]
		 */
		/** @type {Props} */
		let label = prop($$props, "label", 3, ""),
			name = prop($$props, "name", 3, "generic field"),
			readonly = prop($$props, "readonly", 3, false),
			horizontal = prop($$props, "horizontal", 3, false),
			controls = prop($$props, "controls", 19, () => []),
			classes = prop($$props, "classes", 3, ""),
			addons = prop($$props, "addons", 3, false),
			addonsCentered = prop($$props, "addonsCentered", 3, false),
			addonsRight = prop($$props, "addonsRight", 3, false),
			grouped = prop($$props, "grouped", 3, false),
			groupedMultiline = prop($$props, "groupedMultiline", 3, false),
			groupedRight = prop($$props, "groupedRight", 3, false),
			groupedCentered = prop($$props, "groupedCentered", 3, false),
			onchange = prop($$props, "onchange", 3, () => true),
			formFieldPrefix = prop($$props, "formFieldPrefix", 3, "form-field-");

		let fieldClasses = state("");
		let hidden = state(false);
		let fieldId = state(undefined);

		onMount(() => {
			set(fieldClasses, get$2(fieldClasses) + (" " + classes()));
			set(fieldClasses, get$2(fieldClasses) + (addons() ? " has-addons " : ""));
			set(fieldClasses, get$2(fieldClasses) + (addonsCentered() ? " has-addons-centered " : ""));
			set(fieldClasses, get$2(fieldClasses) + (addonsRight() ? " has-addons-right " : ""));
			set(fieldClasses, get$2(fieldClasses) + (grouped() ? " is-grouped " : ""));
			set(fieldClasses, get$2(fieldClasses) + (groupedMultiline() ? " is-grouped-multiline " : ""));
			set(fieldClasses, get$2(fieldClasses) + (groupedRight() ? " is-grouped-right " : ""));
			set(fieldClasses, get$2(fieldClasses) + (groupedCentered() ? " is-grouped-centered " : ""));

			if (readonly()) {
				controls().forEach((control) => {
					control.readonly = true;
				});
			}

			let notHidden = controls().filter((control) => control.component !== "UIHidden");

			set(hidden, notHidden.length === 0);

			let tmp = controls().map((itm) => itm.component).join("_");

			set(fieldId, `${formFieldPrefix()}${tmp}-${name()}`);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, controls, index$d, ($$anchor, control) => {
					var fragment_2 = comment();
					const SvelteComponent = derived(() => COMPONENTS$1.get(get$2(control).component));
					var node_2 = first_child(fragment_2);

					component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
						$$component($$anchor, spread_props(() => get$2(control), {
							get onchange() {
								return onchange();
							},
							get fieldname() {
								return name();
							}
						}));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				{
					var consequent_1 = ($$anchor) => {
						var div = root_4$4();
						var div_1 = child(div);
						var node_4 = child(div_1);
						var label_1 = derived(() => label() || controls()[0].label);

						Ui_label(node_4, {
							get for() {
								return get$2(fieldId);
							},
							get label() {
								return get$2(label_1);
							}
						});

						reset(div_1);

						var div_2 = sibling(div_1, 2);

						each(div_2, 21, controls, index$d, ($$anchor, control) => {
							var fragment_4 = comment();
							const SvelteComponent_1 = derived(() => COMPONENTS$1.get(get$2(control).component));
							var node_5 = first_child(fragment_4);

							component(node_5, () => get$2(SvelteComponent_1), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$2(control), {
									get onchange() {
										return onchange();
									},
									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_4);
						});

						reset(div_2);
						reset(div);

						template_effect(() => {
							set_class(div, `field is-horizontal ${get$2(fieldClasses) ?? ""} ${get$2(fieldId) ?? ""}`);
							set_attribute(div_2, "id", get$2(fieldId));
						});

						append($$anchor, div);
					};

					var alternate = ($$anchor) => {
						var div_3 = root_6$3();

						each(div_3, 21, controls, index$d, ($$anchor, control) => {
							var fragment_5 = root_7$1();
							const SvelteComponent_2 = derived(() => COMPONENTS$1.get(get$2(control).component));
							var node_6 = first_child(fragment_5);

							Ui_label(node_6, {
								get for() {
									return `form-field-${get$2(control).component ?? ""}-${name() ?? ""}`;
								},
								get label() {
									return get$2(control).label;
								}
							});

							var node_7 = sibling(node_6, 2);

							component(node_7, () => get$2(SvelteComponent_2), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$2(control), {
									get onchange() {
										return onchange();
									},
									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_5);
						});

						reset(div_3);
						template_effect(() => set_class(div_3, `field ${get$2(fieldClasses) ?? ""} ${get$2(fieldId) ?? ""}`));
						append($$anchor, div_3);
					};

					if_block(
						node_3,
						($$render) => {
							if (horizontal()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (get$2(hidden)) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function submitForm(e, dispatch, collectData) {
		e && e.preventDefault();
		dispatch("submit", collectData());
		return false;
	}

	function rejectForm(_, dispatch) {
		dispatch("reject");
	}

	var root_1$5 = template(`<div><span class="title"> </span></div>`);
	var root_2$3 = template(`<div class="notification is-success"><h3 class="form-success-message"> </h3></div>`);
	var root_4$3 = template(`<h5 class="title is-5"> </h5>`);
	var root_5$3 = template(`<h6 class="subtitle is-6"> </h6>`);
	var root_7 = template(`<button> </button>`);
	var root_8 = template(`<button> </button>`);
	var root_9 = template(`<div class="edit-form-error notification is-danger"> </div>`);
	var root_6$2 = template(`<div class="buttons is-grouped is-centered"><!> <!></div> <!>`, 1);
	var root_14 = template(`<div><!></div>`);
	var root_15 = template(`<div class="column notification is-danger"> </div>`);
	var root_11 = template(`<div class="columns"></div>`);
	var root_19 = template(`<div class="notification is-danger"> </div>`);
	var root_22 = template(`<span> </span>`);
	var root_21 = template(`<div class="edit-form-error notification is-danger"></div>`);
	var root_23 = template(`<button> </button>`);
	var root_24 = template(`<button> </button>`);
	var root_20 = template(`<!> <div class="buttons is-grouped is-centered"><!> <!></div>`, 1);
	var root_3$4 = template(`<!> <!> <!> <!> <!>`, 1);
	var root$6 = template(`<div class="form-container"><!> <!></div>`);

	function Form($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		let dispatch = createEventDispatcher();
		//validation status
		let formErrors = state(proxy([]));
		let formHasErrors = state(false);
		let fieldsHasErrors = state(false);
		let success = state(false);

		//input data
		//form structure object
		//hidden - no loader
		//container - parent container of form
		//fields list structure
		/**
		 * @typedef {Object} Props
		 * @property {any} [form] - {
		[fieldName: string] => description: object
		}
		 * @property {boolean} [loading] - state if form loading
		 * @property {string} [loader] - page - whole page
		 * @property {any} [fields] - each item is a row
		if item is array, then there few fields in a row
		[
		[name, age],
		[email, telephone]
		bio,
		agreed
		]
		 * @property {string} [SUCCESS_TEXT] - form result labels
		 * @property {string} [WAITING_TEXT]
		 * @property {string} [title] - form labels
		 * @property {string} [description]
		 * @property {boolean} [buttonsFirst] - if you want button on top
		 * @property {boolean} [horizontal] - if form fields should have horizontal layout
		 * @property {any} [submit] - buttons labels and availability
		 * @property {any} [cancel]
		 */
		/** @type {Props} */
		let form = prop($$props, "form", 31, () => proxy({})),
			loading = prop($$props, "loading", 15, false),
			loader = prop($$props, "loader", 3, "container"),
			fields = prop($$props, "fields", 19, () => []),
			SUCCESS_TEXT = prop($$props, "SUCCESS_TEXT", 3, "Операция завершена"),
			WAITING_TEXT = prop($$props, "WAITING_TEXT", 3, "Отправка данных на сервер"),
			title = prop($$props, "title", 3, ""),
			description = prop($$props, "description", 3, ""),
			buttonsFirst = prop($$props, "buttonsFirst", 3, false),
			horizontal = prop($$props, "horizontal", 3, false),
			submit = prop($$props, "submit", 19, () => ({ caption: "Отправить", enabled: true })),
			cancel = prop($$props, "cancel", 19, () => ({ caption: "Назад", enabled: true }));

		let formInvalid = derived(() => get$2(formHasErrors) || get$2(fieldsHasErrors));

		function collectData() {
			return FormHelpers.collectData(fields(), form());
		}

		function setFieldInvalid(fieldName, value, errors) {
			form(FormHelpers.setFieldInvalid(form(), fieldName, value, errors));
			set(fieldsHasErrors, true);
		}

		function setFieldValid(fieldName, value) {
			form(FormHelpers.setFieldValid(form(), fieldName, value));
		}

		function isFieldValid(fieldName) {
			return FormHelpers.isFieldValid(form(), fieldName);
		}

		function setFormFieldInvalid(fieldName, errors) {
			form(FormHelpers.setFormFieldInvalid(form(), fieldName, errors));
			dispatch(`field.invalid`, { fieldName });
		}

		function setFormFieldValid(fieldName) {
			form(FormHelpers.setFormFieldValid(form(), fieldName));
			dispatch(`field.valid`, { fieldName });
		}

		function updateFormValidationStatus(
			validationStatus /* FormValidationSession.getCompleteResult() */
		) {
			set(formHasErrors, false);
			set(fieldsHasErrors, false);

			if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
				get$2(formErrors).splice(0, get$2(formErrors).length, ...validationStatus.form);
				set(formHasErrors, true);
			} else {
				get$2(formErrors).splice(0, get$2(formErrors).length);
			}

			set(formErrors, proxy(get$2(formErrors)));

			if (validationStatus.fields) {
				for (let fieldName of Object.keys(form())) {
					if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
						FormHelpers.setFormFieldInvalid(form(), fieldName, validationStatus.fields[fieldName]);
						set(fieldsHasErrors, true);
					} else {
						FormHelpers.setFormFieldValid(form(), fieldName);
					}
				}
			}
		}

		function showSuccess() {
			set(success, true);
		}

		function setLoading() {
			loading(true);
		}

		function resetLoading() {
			loading(false);
		}

		function setFieldsVisibility(fieldsList, val) {
			if (FormHelpers.setFieldsVisibility(form(), fieldsList, val)) {
				form(form());
			}
		}

		function setVisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, true);
		}

		function setInvisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, false);
		}

		function setFieldValue(fieldName, value) {
			if (FormHelpers.setFieldValue(form(), fieldName, value)) {
				onFieldChange({ detail: { field: fieldName, value } });
			}
		}

		function updateField(fieldName, props) {
			form(form()[fieldName] = { ...form()[fieldName], ...props }, true);
			form(form());
		}

		function onFieldChange(ev) {
			let data = ev.detail;

			form(form()[data.field].value = data.value, true);
			form(form());
			dispatch("change", data);
		}

		var div = root$6();
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var div_1 = root_1$5();
				var span = child(div_1);
				var text = child(span, true);

				reset(span);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, `${(loader() === 'page' ? 'pageloader' : 'containerloader') ?? ""} ${(loading() ? 'is-active' : '') ?? ""}`);
					set_text(text, $LOCALE()[WAITING_TEXT()]);
				});

				append($$anchor, div_1);
			};

			if_block(node, ($$render) => {
				if (loader() !== "hidden") $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_2 = root_2$3();
				var h3 = child(div_2);
				var text_1 = child(h3, true);

				reset(h3);
				reset(div_2);
				template_effect(() => set_text(text_1, $LOCALE()[SUCCESS_TEXT()]));
				append($$anchor, div_2);
			};

			var alternate_3 = ($$anchor) => {
				var fragment = root_3$4();
				var node_2 = first_child(fragment);

				{
					var consequent_2 = ($$anchor) => {
						var h5 = root_4$3();
						var text_2 = child(h5, true);

						reset(h5);
						template_effect(() => set_text(text_2, $LOCALE()[title()]));
						append($$anchor, h5);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_2);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_3 = ($$anchor) => {
						var h6 = root_5$3();
						var text_3 = child(h6, true);

						reset(h6);
						template_effect(() => set_text(text_3, $LOCALE()[description()]));
						append($$anchor, h6);
					};

					if_block(node_3, ($$render) => {
						if (description()) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_1 = root_6$2();
						var div_3 = first_child(fragment_1);
						var node_5 = child(div_3);

						{
							var consequent_4 = ($$anchor) => {
								var button = root_7();

								button.__click = [rejectForm, dispatch];

								var text_4 = child(button, true);

								reset(button);

								template_effect(() => {
									set_class(button, `button is-outlined ${cancel().classes ?? ""}`);
									set_text(text_4, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button);
							};

							if_block(node_5, ($$render) => {
								if (cancel().enabled) $$render(consequent_4);
							});
						}

						var node_6 = sibling(node_5, 2);

						{
							var consequent_5 = ($$anchor) => {
								var button_1 = root_8();

								button_1.__click = [submitForm, dispatch, collectData];

								var text_5 = child(button_1, true);

								reset(button_1);

								template_effect(() => {
									button_1.disabled = get$2(formInvalid);
									set_class(button_1, `button is-primary is-hovered ${submit().classes ?? ""}`);
									set_text(text_5, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_1);
							};

							if_block(node_6, ($$render) => {
								if (submit().enabled) $$render(consequent_5);
							});
						}

						reset(div_3);

						var node_7 = sibling(div_3, 2);

						{
							var consequent_6 = ($$anchor) => {
								var div_4 = root_9();
								var text_6 = child(div_4, true);

								template_effect(() => set_text(text_6, get$2(formErrors).join(", ")));
								reset(div_4);
								append($$anchor, div_4);
							};

							if_block(node_7, ($$render) => {
								if (get$2(formErrors).length > 0) $$render(consequent_6);
							});
						}

						append($$anchor, fragment_1);
					};

					if_block(node_4, ($$render) => {
						if (buttonsFirst()) $$render(consequent_7);
					});
				}

				var node_8 = sibling(node_4, 2);

				each(node_8, 17, fields, index$d, ($$anchor, field) => {
					var fragment_2 = comment();
					var node_9 = first_child(fragment_2);

					{
						var consequent_10 = ($$anchor) => {
							var div_5 = root_11();

							each(div_5, 21, () => get$2(field), index$d, ($$anchor, subfield) => {
								var fragment_3 = comment();
								var node_10 = first_child(fragment_3);

								{
									var consequent_9 = ($$anchor) => {
										var fragment_4 = comment();
										var node_11 = first_child(fragment_4);

										{
											var consequent_8 = ($$anchor) => {
												var div_6 = root_14();
												var node_12 = child(div_6);
												var controls = derived(() => [form()[get$2(subfield)]]);

												Field(node_12, {
													get controls() {
														return get$2(controls);
													},
													get name() {
														return get$2(subfield);
													},
													get horizontal() {
														return horizontal();
													},
													get label() {
														return form()[get$2(subfield)].label;
													},
													$$events: { change: onFieldChange }
												});

												reset(div_6);
												template_effect(() => set_class(div_6, `column ${(form()[get$2(subfield)].fieldSize ? 'is-' + form()[get$2(subfield)].fieldSize : '') ?? ""} `));
												append($$anchor, div_6);
											};

											if_block(node_11, ($$render) => {
												if (form()[get$2(subfield)].visible) $$render(consequent_8);
											});
										}

										append($$anchor, fragment_4);
									};

									var alternate = ($$anchor) => {
										var div_7 = root_15();
										var text_7 = child(div_7);

										reset(div_7);
										template_effect(() => set_text(text_7, `Subfield '${get$2(subfield) ?? ""}' is not registered`));
										append($$anchor, div_7);
									};

									if_block(node_10, ($$render) => {
										if (form()[get$2(subfield)] && form()[get$2(subfield)].component) $$render(consequent_9); else $$render(alternate, false);
									});
								}

								append($$anchor, fragment_3);
							});

							reset(div_5);
							append($$anchor, div_5);
						};

						var alternate_2 = ($$anchor) => {
							var fragment_5 = comment();
							var node_13 = first_child(fragment_5);

							{
								var consequent_12 = ($$anchor) => {
									var fragment_6 = comment();
									var node_14 = first_child(fragment_6);

									{
										var consequent_11 = ($$anchor) => {
											var controls_1 = derived(() => [form()[get$2(field)]]);

											Field($$anchor, {
												get controls() {
													return get$2(controls_1);
												},
												get name() {
													return get$2(field);
												},
												get horizontal() {
													return horizontal();
												},
												get label() {
													return form()[get$2(field)].label;
												},
												$$events: { change: onFieldChange }
											});
										};

										if_block(node_14, ($$render) => {
											if (form()[get$2(field)].visible) $$render(consequent_11);
										});
									}

									append($$anchor, fragment_6);
								};

								var alternate_1 = ($$anchor) => {
									var div_8 = root_19();
									var text_8 = child(div_8);

									reset(div_8);
									template_effect(() => set_text(text_8, `Field '${get$2(field) ?? ""}' is not registered`));
									append($$anchor, div_8);
								};

								if_block(
									node_13,
									($$render) => {
										if (form()[get$2(field)] && form()[get$2(field)].component) $$render(consequent_12); else $$render(alternate_1, false);
									},
									true
								);
							}

							append($$anchor, fragment_5);
						};

						if_block(node_9, ($$render) => {
							if (Array.isArray(get$2(field))) $$render(consequent_10); else $$render(alternate_2, false);
						});
					}

					append($$anchor, fragment_2);
				});

				var node_15 = sibling(node_8, 2);

				{
					var consequent_16 = ($$anchor) => {
						var fragment_8 = root_20();
						var node_16 = first_child(fragment_8);

						{
							var consequent_13 = ($$anchor) => {
								var div_9 = root_21();

								each(div_9, 21, () => get$2(formErrors), index$d, ($$anchor, formError) => {
									var span_1 = root_22();
									var text_9 = child(span_1, true);

									reset(span_1);
									template_effect(() => set_text(text_9, $LOCALE()[get$2(formError)]));
									append($$anchor, span_1);
								});

								reset(div_9);
								append($$anchor, div_9);
							};

							if_block(node_16, ($$render) => {
								if (get$2(formErrors).length > 0) $$render(consequent_13);
							});
						}

						var div_10 = sibling(node_16, 2);
						var node_17 = child(div_10);

						{
							var consequent_14 = ($$anchor) => {
								var button_2 = root_23();

								button_2.__click = [rejectForm, dispatch];

								var text_10 = child(button_2, true);

								reset(button_2);

								template_effect(() => {
									set_class(button_2, `button ${(cancel().classes ? cancel().classes : '') ?? ""}`);
									set_text(text_10, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button_2);
							};

							if_block(node_17, ($$render) => {
								if (cancel().enabled) $$render(consequent_14);
							});
						}

						var node_18 = sibling(node_17, 2);

						{
							var consequent_15 = ($$anchor) => {
								var button_3 = root_24();

								button_3.__click = [submitForm, dispatch, collectData];

								var text_11 = child(button_3, true);

								reset(button_3);

								template_effect(() => {
									button_3.disabled = get$2(formInvalid);
									set_class(button_3, `button is-primary is-hovered ${(submit().classes ? submit().classes : '') ?? ""}`);
									set_text(text_11, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_3);
							};

							if_block(node_18, ($$render) => {
								if (submit().enabled) $$render(consequent_15);
							});
						}

						reset(div_10);
						append($$anchor, fragment_8);
					};

					if_block(node_15, ($$render) => {
						if (!buttonsFirst()) $$render(consequent_16);
					});
				}

				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (get$2(success)) $$render(consequent_1); else $$render(alternate_3, false);
			});
		}

		reset(div);
		append($$anchor, div);

		return pop({
			collectData,
			setFieldInvalid,
			setFieldValid,
			isFieldValid,
			setFormFieldInvalid,
			setFormFieldValid,
			updateFormValidationStatus,
			showSuccess,
			setLoading,
			resetLoading,
			setFieldsVisibility,
			setVisibleFields,
			setInvisibleFields,
			setFieldValue,
			updateField
		});
	}

	delegate(["click"]);

	const DEFAULT_RULES = {
	  notReadonly(v) {
	    return {
	      readonly: !v
	    };
	  },
	  readonly(v) {
	    return {
	      readonly: v
	    };
	  },
	  enable(v) {
	    return {
	      disabled: !v
	    };
	  },
	  disable(v) {
	    return {
	      disabled: v
	    };
	  }
	};
	let notFormRules = /*#__PURE__*/function () {
	  function notFormRules() {
	    _classCallCheck(this, notFormRules);
	  }
	  return _createClass(notFormRules, null, [{
	    key: "add",
	    value: function add(name, func) {
	      if (!notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name)) {
	        _assertClassBrand(notFormRules, this, _RULES)._[name] = func;
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove(name) {
	      if (notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name) && !Object.keys(DEFAULT_RULES).includes(name)) {
	        delete _assertClassBrand(notFormRules, this, _RULES)._[name];
	      }
	    }
	  }, {
	    key: "exec",
	    value: function exec(rule, master, slaves, value, form) {
	      return _assertClassBrand(notFormRules, this, _RULES)._[rule](value, master, slaves, form);
	    }
	  }]);
	}();
	var _RULES = {
	  _: {
	    ...DEFAULT_RULES
	  }
	};

	const DEFAULT_CONTAINER_SELECTOR$1 = ".form";
	const DEFAULT_ACTION_NAME = "default";
	var _uiComponent = /*#__PURE__*/new WeakMap();
	var _validationRunner = /*#__PURE__*/new WeakMap();
	var _form$1 = /*#__PURE__*/new WeakMap();
	var _action = /*#__PURE__*/new WeakMap();
	var _fields = /*#__PURE__*/new WeakMap();
	var _variants = /*#__PURE__*/new WeakMap();
	var _notForm_brand = /*#__PURE__*/new WeakSet();
	let notForm = /*#__PURE__*/function (_notBase) {
	  //variants for UI

	  function notForm({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data: _data = {},
	    ui = Form //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notForm);
	    _this = _callSuper(this, notForm, [{
	      working: {
	        name: `${name}Form`,
	        ...working
	      },
	      options,
	      data: _data
	    }]);
	    _classPrivateMethodInitSpec(_this, _notForm_brand);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent, null);
	    //form validation
	    _classPrivateFieldInitSpec(_this, _validationRunner, null);
	    //ui component
	    _classPrivateFieldInitSpec(_this, _form$1, null);
	    //model.action
	    _classPrivateFieldInitSpec(_this, _action, DEFAULT_ACTION_NAME);
	    //fields schemas
	    _classPrivateFieldInitSpec(_this, _fields, new Lib());
	    //fields of UI
	    //variants sets for select menus and so on
	    _classPrivateFieldInitSpec(_this, _variants, null);
	    _classPrivateFieldSet2(_variants, _this, new Lib(VARIANTS$1.getContent()));
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent, _this, ui);
	    if (notCommon$1.objHas(options, "action")) {
	      _classPrivateFieldSet2(_action, _this, options.action);
	    }
	    _this.initForm();
	    return _this;
	  }
	  _inherits(notForm, _notBase);
	  return _createClass(notForm, [{
	    key: "initForm",
	    value: function initForm() {
	      if (this.getOptions("autoInit", true)) {
	        this.initLibs();
	      }
	      if (this.getOptions("autoRender", true)) {
	        this.initUI();
	      }
	    }
	  }, {
	    key: "initLibs",
	    value: function initLibs() {
	      this.initFields();
	      this.initVariants();
	      this.initValidator();
	    }
	  }, {
	    key: "reInit",
	    value: function reInit() {
	      this.initLibs();
	      this.updateUI();
	      this.resetLoading();
	    }
	  }, {
	    key: "initFields",
	    value: function initFields() {
	      const manifest = this.getFormManifest();
	      if (notCommon$1.objHas(manifest, "fields") && _classPrivateFieldGet2(_fields, this).isEmpty()) {
	        _classPrivateFieldGet2(_fields, this).import(manifest.fields); //all fields available in model manifest
	      }
	    }
	  }, {
	    key: "initVariants",
	    value: function initVariants() {
	      if (this.getOptions("variants")) {
	        _classPrivateFieldGet2(_variants, this).import(this.getOptions("variants"));
	      }
	    }

	    //creating validators runner for this specific form
	  }, {
	    key: "initValidator",
	    value: function initValidator() {
	      _classPrivateFieldSet2(_validationRunner, this, srcExports.Runner(this.getFormValidators()));
	    }
	  }, {
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        const target = this.getFormTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_form$1, this, new (_classPrivateFieldGet2(_uiComponent, this))({
	          target,
	          props
	        }));
	        _assertClassBrand(_notForm_brand, this, _bindUIEvents).call(this);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "updateUI",
	    value: function updateUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        _classPrivateFieldGet2(_form$1, this).$set(props);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "validateForm",
	    value: async function validateForm() {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      try {
	        const validationResult = await _classPrivateFieldGet2(_validationRunner, this).call(this, _classPrivateFieldGet2(_form$1, this).collectData(), this.getFormAction());
	        _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(validationResult.getReport());
	        if (!validationResult.clean) {
	          this.emit("error", validationResult.getReport());
	        }
	      } catch (e) {
	        const report = {
	          form: [UICommon$1.ERROR_DEFAULT, e.message]
	        };
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(report);
	        this.emit("error", report);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "submit",
	    value: function submit(data) {
	      this.emit("submit", data);
	    }
	  }, {
	    key: "reject",
	    value: function reject() {
	      this.emit("reject");
	    }

	    //binding event to actual UI
	  }, {
	    key: "$on",
	    value: function $on() {
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$on(...arguments);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_form$1, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_form$1, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$destroy && _classPrivateFieldGet2(_form$1, this).$destroy();
	        _classPrivateFieldGet2(_form$1, this).destroy && _classPrivateFieldGet2(_form$1, this).destroy();
	        _classPrivateFieldSet2(_form$1, this, null);
	      }
	      _classPrivateFieldSet2(_validationRunner, this, null);
	      _classPrivateFieldSet2(_action, this, null);
	      _classPrivateFieldSet2(_fields, this, null);
	      _classPrivateFieldSet2(_variants, this, null);
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }
	  }, {
	    key: "getFormAction",
	    value: function getFormAction() {
	      return _classPrivateFieldGet2(_action, this);
	    }
	  }, {
	    key: "setFormAction",
	    value: function setFormAction(val) {
	      if (val && val !== _classPrivateFieldGet2(_action, this)) {
	        _classPrivateFieldSet2(_action, this, val);
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).$destroy();
	        this.initForm();
	      }
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_form$1, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(status);
	      this.emit("error", status);
	    }

	    /**
	     * Returns variant by collection name and item id
	     * @param {string}         name  name of the variants collection
	     * @param {string|number}  id    item identificator
	     * @returns {object}             item
	     **/
	  }, {
	    key: "getVariant",
	    value: function getVariant(name, id) {
	      let lib = _classPrivateFieldGet2(_variants, this).get(name);
	      let result = lib.find(function (item) {
	        return item.id === id;
	      });
	      if (result) {
	        return result;
	      }
	      return null;
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$1);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("Form parent element is not defined");
	      }
	    }
	  }, {
	    key: "getFormValidators",
	    value: function getFormValidators() {
	      if (this.getOptions("validators")) {
	        return this.getOptions("validators", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "validators");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormManifest",
	    value: function getFormManifest() {
	      const modelName = this.getModelName();
	      if (modelName && notCommon$1.getApp()) {
	        return notCommon$1.getApp().getInterfaceManifest(modelName);
	      }
	      if (this.getOptions("manifest", undefined)) {
	        return this.getOptions("manifest", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "manifest");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormData",
	    value: function getFormData() {
	      if (this.getData()) {
	        return this.getData();
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "data");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormOptions",
	    value: function getFormOptions() {
	      if (this.getOptions("ui", undefined) || this.getOptions("fields", undefined)) {
	        return {
	          ui: this.getOptions("ui", {}),
	          fields: this.getOptions("fields", {})
	        };
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "options");
	        return {
	          ui: {},
	          fields: {}
	        };
	      }
	    }
	  }, {
	    key: "getFormInjectedProps",
	    value: function getFormInjectedProps() {
	      return this.getOptions("injected", {});
	    }

	    /**
	     * Override empty message
	     **/
	  }, {
	    key: "collectData",
	    value:
	    /**
	     * Form operations
	     **/
	    function collectData() {
	      if (this.getOptions("readonly", false)) {
	        return this.getData();
	      }
	      const data = _classPrivateFieldGet2(_form$1, this).collectData();
	      this.setData({
	        ...data
	      }); //update in inner store
	      return data;
	    }
	  }, {
	    key: "updateField",
	    value: function updateField(fieldName, props) {
	      _classPrivateFieldGet2(_form$1, this).updateField(fieldName, props);
	    }
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        return this.getInterface(name)(data || {});
	      } else {
	        return this.getInterface()(name || {});
	      }
	    }
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = false) {
	      return notCommon$1.getApp().getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getOptions("model");
	    }
	  }]);
	}(notBase);
	function _bindUIEvents() {
	  var _this2 = this;
	  _classPrivateFieldGet2(_form$1, this).$on("change", function () {
	    return _this2.validateForm();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("change", function (ev) {
	    _this2.emit("change", ev.detail);
	    _this2.emit(`change.${ev.detail.field}`, ev.detail.value);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("submit", function (ev) {
	    return _this2.submit(ev.detail);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("reject", function () {
	    return _this2.reject();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("error", function ({
	    detail
	  }) {
	    return _this2.emit("error", detail);
	  });
	  _assertClassBrand(_notForm_brand, this, _bindMasterSlaveEvents).call(this);
	}
	function _bindMasterSlaveEvents() {
	  const masters = this.getOptions("masters", false);
	  if (!masters) {
	    return;
	  }
	  for (let master in masters) {
	    const rules = masters[master];
	    for (let ruleName in rules) {
	      const ruleSlaves = rules[ruleName];
	      _assertClassBrand(_notForm_brand, this, _addMasterSlaveEvents).call(this, ruleName, master, ruleSlaves);
	    }
	  }
	}
	function _addMasterSlaveEvents(rule, master, slaves = []) {
	  var _this3 = this;
	  this.on(`change.${master}`, function (value) {
	    _assertClassBrand(_notForm_brand, _this3, _execSlaveRule).call(_this3, rule, master, slaves, value);
	  });
	  this.emit(`change.${master}`, this.getFormData()[master]);
	}
	function _execSlaveRule(rule, master, slaves, value) {
	  var _this4 = this;
	  const cmd = notFormRules.exec(rule, master, slaves, value, this);
	  slaves.forEach(function (slaveField) {
	    _this4.updateField(slaveField, cmd);
	  });
	}
	function _getFormProps({
	  manifest,
	  //model manifest
	  formOptions = {
	    ui: {},
	    fields: {}
	  },
	  //some options
	  data = null,
	  //initial data for form
	  injectedProps = {}
	}) {
	  const action = _classPrivateFieldGet2(_action, this);
	  if (typeof formOptions === "undefined" || formOptions === null) {
	    formOptions = {
	      ui: {},
	      fields: {}
	    };
	  }
	  const form = FormHelpers.initFormByField(
	  //form seed object
	  {},
	  /*
	  Form structure
	  [
	  //each item is line of form
	  //field - field takes whole line of form
	  //[field1, field2] - few fields in one line
	  nameFirst, nameLast
	  [age, country, language],
	  [email, telephone]
	  ]
	  */
	  manifest.actions[action].fields,
	  //form fields structure
	  _classPrivateFieldGet2(_variants, this),
	  //variants library
	  _classPrivateFieldGet2(_fields, this),
	  //fields library
	  formOptions.fields,
	  //form wide fields options
	  data);
	  return {
	    //if no auto init of form structure, set to loading state
	    loading: !this.getOptions("autoInit", true),
	    title: manifest.actions[action].title,
	    description: manifest.actions[action].description,
	    fields: manifest.actions[action].fields,
	    form,
	    //injecting options to UI from top level input
	    ...formOptions.ui,
	    //form UI options
	    ...injectedProps
	  };
	}
	function _missingOverrideWarning(missing) {
	  this.error(`${missing} for ${this.getWorking("name")} form is not defined`);
	}

	var root$5 = template(`<div class="block-container"><div class="form-paper"></div> <!></div>`);

	function Form_set($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [name]
		 * @property {boolean} [showModes]
		 * @property {string} [mode]
		 * @property {any} [forms]
		 */
		/** @type {Props} */
		let name = prop($$props, "name", 3, 'default-form'),
			showModes = prop($$props, "showModes", 3, false),
			mode = prop($$props, "mode", 15, 'default'),
			forms = prop($$props, "forms", 19, () => []);

		function setMode(val) {
			mode(val);
			dispatch('mode', val);
			updateModesButtons();
		}

		let FORMS_BUTTONS = state(proxy([]));

		function updateModesButtons() {
			set(FORMS_BUTTONS, proxy(forms().filter((form) => {
				return mode() !== form.mode;
			}).map((form) => {
				return {
					title: form.title,
					outlined: true,
					type: 'link',
					action() {
						setMode(form.mode);
					}
				};
			})));
		}

		onMount(() => {
			updateModesButtons();
		});

		var div = root$5();
		var div_1 = child(div);
		var node = sibling(div_1, 2);

		{
			var consequent = ($$anchor) => {
				Ui_buttons($$anchor, {
					centered: true,
					classes: "mt-4",
					get values() {
						return get$2(FORMS_BUTTONS);
					},
					set values($$value) {
						set(FORMS_BUTTONS, proxy($$value));
					}
				});
			};

			if_block(node, ($$render) => {
				if (showModes()) $$render(consequent);
			});
		}

		reset(div);

		template_effect(() => {
			set_attribute(div, "id", `${name() ?? ""}-form-set`);
			set_attribute(div_1, "id", `${name() ?? ""}-form-set-container`);
		});

		append($$anchor, div);
		pop();
	}

	const DEFAULT_CONTAINER_SELECTOR = ".form-set";
	const DEFAULT_FORM_SET_NAME = "form-set";
	var _formSetComponent = /*#__PURE__*/new WeakMap();
	var _formComponent = /*#__PURE__*/new WeakMap();
	var _form = /*#__PURE__*/new WeakMap();
	var _frame = /*#__PURE__*/new WeakMap();
	var _notFormSet_brand = /*#__PURE__*/new WeakSet();
	let notFormSet = /*#__PURE__*/function (_notBase) {
	  /*
	  new notFormSet({
	  options:{
	    target: el,
	    forms: [{
	      mode: 'form1',
	      title: 'Form 1',
	      form: formConstructor1 //custom constructors
	    },{
	      mode: 'form2',
	      title: 'Form 2',
	      props: {}             //params to create notForm instance
	    },{
	      mode: 'form3',
	      title: 'Form 3',
	      form: formConstructor3 //custom constructors
	    }]
	  }
	  });
	  */

	  function notFormSet({
	    options = {},
	    formComponent = Form,
	    formSetComponent = Form_set
	  }) {
	    var _this;
	    _classCallCheck(this, notFormSet);
	    _this = _callSuper(this, notFormSet, [{
	      options: {
	        name: DEFAULT_FORM_SET_NAME,
	        mode: "default",
	        showModes: true,
	        ...options
	      }
	    }]);
	    _classPrivateMethodInitSpec(_this, _notFormSet_brand);
	    _classPrivateFieldInitSpec(_this, _formSetComponent, null);
	    _classPrivateFieldInitSpec(_this, _formComponent, null);
	    _classPrivateFieldInitSpec(_this, _form, null);
	    _classPrivateFieldInitSpec(_this, _frame, null);
	    _classPrivateFieldSet2(_formComponent, _this, formComponent);
	    _classPrivateFieldSet2(_formSetComponent, _this, formSetComponent);
	    _this.setFormMode(_this.getOptions("mode"));
	    _this.initUI();
	    return _this;
	  }

	  /**
	   * Initalizing form frame mode, with switchers between modes
	   **/
	  _inherits(notFormSet, _notBase);
	  return _createClass(notFormSet, [{
	    key: "initUI",
	    value: function initUI() {
	      var _this2 = this;
	      const target = this.getFrameTargetEl();
	      while (target.children.length) target.removeChild(target.firstChild);
	      _classPrivateFieldSet2(_frame, this, new (_classPrivateFieldGet2(_formSetComponent, this))({
	        target,
	        props: _assertClassBrand(_notFormSet_brand, this, _getFrameProps).call(this)
	      }));
	      _classPrivateFieldGet2(_frame, this).$on("mode", function (ev) {
	        _this2.setFormMode(ev.detail);
	        _this2.updateForm();
	      });
	      this.updateForm();
	    }
	  }, {
	    key: "setFormMode",
	    value: function setFormMode(name) {
	      if (this.isModeExists(name)) {
	        this.setWorking("mode", name);
	      } else {
	        this.setWorking("mode", this.getFirstMode());
	        this.updateFormModeInUI();
	      }
	    }
	  }, {
	    key: "updateFormModeInUI",
	    value: function updateFormModeInUI() {
	      if (_classPrivateFieldGet2(_frame, this) && this.getWorking("mode") !== null) {
	        _classPrivateFieldGet2(_frame, this).$set({
	          mode: this.getWorking("mode")
	        });
	      }
	    }
	  }, {
	    key: "getFormMode",
	    value: function getFormMode() {
	      return this.getWorking("mode");
	    }
	  }, {
	    key: "updateForm",
	    value: function updateForm() {
	      this.destroyForm();
	      if (this.getWorking("mode") !== null) {
	        this.renderForm();
	      }
	    }
	  }, {
	    key: "renderForm",
	    value: function renderForm() {
	      var _this3 = this;
	      const targetEl = this.getFormTargetEl();
	      const formConfig = this.getFormConfig();
	      if (!(targetEl instanceof HTMLElement && formConfig)) {
	        throw new Error("error while form rendering");
	      }
	      const changeMode = function (mode) {
	        _this3.setFormMode(mode);
	        _this3.updateForm();
	      };
	      if (formConfig.form) {
	        while (targetEl.children.length) targetEl.removeChild(targetEl.firstChild);
	        _classPrivateFieldSet2(_form, this, new formConfig.form({
	          options: {
	            target: targetEl,
	            changeMode
	          }
	        }));
	      } else if (formConfig.props) {
	        _classPrivateFieldSet2(_form, this, new (_classPrivateFieldGet2(_formComponent, this))({
	          target: targetEl,
	          ...formConfig.props,
	          changeMode
	        }));
	      }
	    }
	  }, {
	    key: "getFormConfig",
	    value: function getFormConfig() {
	      var _this4 = this;
	      return this.getOptions("forms").find(function (form) {
	        return form.mode === _this4.getFormMode();
	      });
	    }
	  }, {
	    key: "destroyForm",
	    value: function destroyForm() {
	      const containerEl = this.getFormTargetEl();
	      if (containerEl) {
	        while (containerEl.firstChild) {
	          containerEl.removeChild(containerEl.lastChild);
	        }
	      }
	      if (_classPrivateFieldGet2(_form, this) && _classPrivateFieldGet2(_form, this).$destroy) {
	        _classPrivateFieldGet2(_form, this).$destroy();
	      }
	      _classPrivateFieldSet2(_form, this, null);
	    }
	  }, {
	    key: "destroyFrame",
	    value: function destroyFrame() {
	      if (_classPrivateFieldGet2(_frame, this) && _classPrivateFieldGet2(_frame, this).$destroy) {
	        _classPrivateFieldGet2(_frame, this).$destroy();
	      }
	      _classPrivateFieldSet2(_frame, this, null);
	    }
	  }, {
	    key: "isModeExists",
	    value: function isModeExists(mode) {
	      const forms = this.getOptions("forms", []);
	      return forms.some(function (item) {
	        return item.mode === mode;
	      });
	    }
	  }, {
	    key: "getFirstMode",
	    value: function getFirstMode() {
	      const forms = this.getOptions("forms", []);
	      if (forms.length > 0) {
	        return forms[0].mode;
	      }
	      return null;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      _classPrivateFieldSet2(_formSetComponent, this, null);
	      _classPrivateFieldSet2(_formComponent, this, null);
	      this.destroyForm();
	      this.destroyFrame();
	      this.setData(null);
	      this.setOptions(null);
	      this.setWorking(null);
	    }
	  }, {
	    key: "getFrameTargetEl",
	    value: function getFrameTargetEl() {
	      const target = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR);
	      if (target instanceof HTMLElement) {
	        return target;
	      } else if (typeof target === "string") {
	        return document.querySelector(target);
	      } else {
	        throw new Error("form set target is not HTMLElement or string");
	      }
	    }
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const name = this.getOptions("name", DEFAULT_FORM_SET_NAME);
	      return document.querySelector(`#${name}-form-set-container`);
	    }
	  }]);
	}(notBase);
	function _getFrameProps() {
	  return {
	    showModes: this.getOptions("showModes", true),
	    mode: this.getFormMode(),
	    forms: this.getOptions("forms", []),
	    name: this.getOptions("name", DEFAULT_FORM_SET_NAME)
	  };
	}

	function onClick$5(ev, go) {
		if (typeof go() === 'function') {
			ev.preventDefault();
			go()(ev.currentTarget.dataset.href);
			return false;
		} else {
			return true;
		}
	}

	var root_3$3 = template(`<li class="is-active"><a aria-current="page"> </a></li>`);
	var root_5$2 = template(`<li class="is-plain-crumb"> </li>`);
	var root_6$1 = template(`<li><a> </a></li>`);
	var root_1$4 = template(`<nav class="breadcrumb" aria-label="breadcrumbs"><ul></ul></nav>`);

	function Ui_breadcrumbs($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [go]
		 */
		/** @type {Props} */
		let root = prop($$props, "root", 3, ''),
			items = prop($$props, "items", 19, () => []),
			go = prop($$props, "go", 3, null);

		var nav = root_1$4();
		var ul = child(nav);

		each(ul, 21, items, index$d, ($$anchor, link, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var li = root_3$3();
					var a = child(li);
					var text = child(a, true);

					reset(a);
					reset(li);

					template_effect(() => {
						set_attribute(a, "href", `${root() ?? ""}${get$2(link).url ?? ""}`);
						set_attribute(a, "data-href", get$2(link).url);
						set_text(text, $LOCALE()[get$2(link).title]);
					});

					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					{
						var consequent_1 = ($$anchor) => {
							var li_1 = root_5$2();
							var text_1 = child(li_1, true);

							reset(li_1);
							template_effect(() => set_text(text_1, $LOCALE()[get$2(link).title]));
							append($$anchor, li_1);
						};

						var alternate = ($$anchor) => {
							var li_2 = root_6$1();
							var a_1 = child(li_2);

							a_1.__click = [onClick$5, go];

							var text_2 = child(a_1, true);

							reset(a_1);
							reset(li_2);

							template_effect(() => {
								set_attribute(a_1, "href", `${root() ?? ""}${get$2(link).url ?? ""}`);
								set_attribute(a_1, "data-href", get$2(link).url);
								set_text(text_2, $LOCALE()[get$2(link).title]);
							});

							append($$anchor, li_2);
						};

						if_block(node_1, ($$render) => {
							if (get$2(link).url === false) $$render(consequent_1); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_1);
				};

				if_block(node, ($$render) => {
					if (items().length === index + 1) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		reset(nav);
		append($$anchor, nav);
		pop();
	}

	delegate(["click"]);

	let notBreadcrumbs = /*#__PURE__*/function () {
	  function notBreadcrumbs() {
	    _classCallCheck(this, notBreadcrumbs);
	  }
	  return _createClass(notBreadcrumbs, null, [{
	    key: "render",
	    value: function render({
	      target,
	      root = '',
	      navigate
	    }) {
	      this.remove();
	      if (notBreadcrumbs.UIConstructor) {
	        this.ui = new notBreadcrumbs.UIConstructor({
	          target,
	          props: {
	            items: this.getBreadcrumbs(),
	            root: root,
	            go: navigate
	          }
	        });
	      }
	    }
	  }, {
	    key: "setHead",
	    value: function setHead(head) {
	      this.head.splice(0, this.head.length, ...head);
	      return this;
	    }
	  }, {
	    key: "setTail",
	    value: function setTail(tail) {
	      this.tail.splice(0, this.tail.length, ...tail);
	      return this;
	    }
	  }, {
	    key: "getBreadcrumbs",
	    value: function getBreadcrumbs() {
	      let crumbs = [];
	      crumbs.push(...this.head);
	      crumbs.push(...this.tail);
	      return crumbs;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.ui) {
	        this.ui.$set({
	          items: this.getBreadcrumbs()
	        });
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.ui) {
	        this.ui.$destroy();
	        this.ui = null;
	      }
	      return this;
	    }
	  }]);
	}();
	_defineProperty(notBreadcrumbs, "UIConstructor", null);
	_defineProperty(notBreadcrumbs, "ui", null);
	_defineProperty(notBreadcrumbs, "head", []);
	_defineProperty(notBreadcrumbs, "tail", []);

	notBreadcrumbs.UIConstructor = Ui_breadcrumbs;

	var _Menu;
	let Menu = /*#__PURE__*/function () {
	  function Menu() {
	    _classCallCheck(this, Menu);
	  }
	  return _createClass(Menu, null, [{
	    key: "hide",
	    value: function hide() {}
	  }, {
	    key: "setApp",
	    value: function setApp(app) {
	      if (!this.app) {
	        this.app = app;
	      }
	      return this;
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(options) {
	      this.options = {
	        ...this.options,
	        ...options
	      };
	      return this;
	    }
	  }, {
	    key: "getOptionsPathTo",
	    value: function getOptionsPathTo(what) {
	      return `menu.${this.options.type}.${what}`;
	    }
	  }, {
	    key: "isDirectNavigation",
	    value: function isDirectNavigation() {
	      return this.app ? this.app.getOptions(this.getOptionsPathTo("directNavigation"), this.options.directNavigation) : this.options.directNavigation;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      if (this.app) {
	        return {
	          brand: this.app.getOptions("brand", this.options.brand),
	          items: this.app.getOptions(this.getOptionsPathTo("items"), this.options.items),
	          sections: this.app.getOptions(this.getOptionsPathTo("sections"), this.options.sections),
	          targetSelector: this.app.getOptions(this.getOptionsPathTo("targetSelector"), this.options.targetSelector),
	          toggleSelector: this.app.getOptions(this.getOptionsPathTo("toggleSelector"), this.options.toggleSelector),
	          open: this.app.getOptions(this.getOptionsPathTo("open"), this.options.open),
	          directNavigation: this.app.getOptions(this.getOptionsPathTo("directNavigation"), this.options.directNavigation),
	          root: this.app.getOptions("router.root", this.options.root),
	          navigate: this.options.navigate.bind(this),
	          getComponent: this.getComponent.bind(this)
	        };
	      } else {
	        return this.options;
	      }
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(name) {
	      if (COMPONENTS$1.contains(name)) {
	        return COMPONENTS$1.get(name);
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "initField",
	    value: function initField(list, fields = []) {
	      var _this = this;
	      list.forEach(function (item) {
	        fields.forEach(function (field) {
	          if (!Object.hasOwn(item, field)) {
	            item[field] = _this.DEFAULT[field];
	          }
	        });
	        if (Object.hasOwn(item, "items")) {
	          _this.initField(item.items, fields);
	        }
	      });
	    }
	  }, {
	    key: "sortList",
	    value: function sortList(list) {
	      var _this2 = this;
	      list.sort(function (item1, item2) {
	        if (Object.hasOwn(item1, "items")) {
	          _this2.sortList(item1.items);
	        }
	        if (Object.hasOwn(item2, "items")) {
	          _this2.sortList(item2.items);
	        }
	        if (item1.priority === item2.priority) {
	          return item1.title > item2.title ? 1 : -1;
	        } else {
	          return item1.priority < item2.priority ? 1 : -1;
	        }
	      });
	    }
	  }, {
	    key: "removeDublicates",
	    value: function removeDublicates(sections) {
	      for (let i = 0; i < sections.length; i++) {
	        let priority = sections[i].priority;
	        sections.filter(function (section) {
	          return section.id === sections[i].id;
	        }).forEach(function (item, indx) {
	          if (indx === 0) {
	            return;
	          }
	          if (item.priority < priority) {
	            priority = item.priority;
	          }
	          sections.splice(sections.indexOf(item), 1);
	        });
	        sections[i].priority = priority;
	      }
	      return sections;
	    }
	  }, {
	    key: "prepareData",
	    value: function prepareData() {
	      let items = [];
	      items.push(...this.getOptions().items);
	      let sections = [];
	      sections.push(...this.getOptions().sections);
	      this.initField(sections, ["priority"]);
	      this.removeDublicates(sections);
	      this.initField(items, ["priority", "section", "type"]);
	      this.sortList(sections);
	      sections.push({
	        id: this.DEFAULT.section,
	        title: this.DEFAULT.sectionTitle
	      });
	      this.sortList(items);
	      this.sections = sections;
	      this.items = items;
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.menu) {
	        this.menu.$destroy();
	        this.menu = null;
	        clearInterval(this.interval);
	      }
	    }
	  }, {
	    key: "updateIndicator",
	    value: function updateIndicator(sectionId, itemId, state) {
	      this.updateSection(sectionId, function (section) {
	        section.indicator.state = state;
	      });
	      this.updateItem(itemId, function (item) {
	        item.indicator.state = state;
	      });
	    }
	  }, {
	    key: "updateTag",
	    value: function updateTag(sectionId, itemId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = tag;
	      });
	      this.updateItem(itemId, function (item) {
	        item.tag = tag;
	      });
	    }
	  }, {
	    key: "updateSectionTag",
	    value: function updateSectionTag(sectionId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = {
	          ...section.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateItemTag",
	    value: function updateItemTag(itemId, tag) {
	      this.updateItem(itemId, function (item) {
	        item.tag = {
	          ...item.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateSection",
	    value: function updateSection(sectionId, proc) {
	      if (this.sections && sectionId) {
	        for (let section in this.sections) {
	          if (this.sections[section].id !== sectionId) continue;
	          proc(this.sections[section]);
	        }
	        if (this.menu) {
	          this.menu.$set({
	            sections: this.sections
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateSectionItems",
	    value: function updateSectionItems(sectionId, proc) {
	      if (this.sections && sectionId) {
	        let oldList = this.items.filter(function (item) {
	          return item.section === sectionId;
	        });
	        for (let i of oldList) {
	          this.items.splice(this.items.indexOf(i), 1);
	        }
	        this.items.push(...proc(oldList));
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateItem",
	    value: function updateItem(itemId, proc) {
	      if (itemId && this.items) {
	        this.items.forEach(function (item) {
	          if (item.id !== itemId) return;
	          proc(item);
	        });
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "isTouch",
	    value: function isTouch() {
	      return UICommon$1.isMobile(true);
	    }
	  }, {
	    key: "getSectionComponent",
	    value: function getSectionComponent() {}
	  }]);
	}();
	_Menu = Menu;
	_defineProperty(Menu, "MAX_TOUCH_WIDTH", 1023);
	_defineProperty(Menu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  open: false
	});
	/**
	 *
	 * @type {import('../../app.js').default | null}
	 * @static
	 * @memberof Menu
	 */
	_defineProperty(Menu, "app", null);
	_defineProperty(Menu, "directNavigation", false);
	_defineProperty(Menu, "menu", void 0);
	_defineProperty(Menu, "options", {
	  directNavigation: false,
	  navigate: function (urls) {
	    _Menu.hide();
	    if (!_Menu.isDirectNavigation() && _Menu.app) {
	      let func = _Menu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});
	_defineProperty(Menu, "items", []);
	_defineProperty(Menu, "sections", []);
	_defineProperty(Menu, "location", void 0);
	_defineProperty(Menu, "interval", void 0);

	function onClick$4(ev, onnavigate) {
		ev.preventDefault();

		onnavigate()({
			full: ev.target.getAttribute("href"),
			short: ev.target.dataset.href
		});

		return false;
	}

	var root_2$2 = template(`<li><a> <!> <!></a></li>`);
	var root_5$1 = template(`<li> <!> <!></li>`);

	function Ui_item_without_children($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 */
		/** @type {Props} */
		let root = prop($$props, "root", 3, ""),
			item = prop($$props, "item", 19, () => ({})),
			onnavigate = prop($$props, "onnavigate", 3, () => {});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var li = root_2$2();
				var a = child(li);

				a.__click = [onClick$4, onnavigate];

				var text = child(a);
				var node_1 = sibling(text);

				{
					var consequent = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_1, ($$render) => {
						if (item().tag) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_2, ($$render) => {
						if (item().indicator) $$render(consequent_1);
					});
				}

				reset(a);
				reset(li);

				template_effect(() => {
					set_class(li, clsx(item().classes), "");
					set_attribute(a, "href", `${root() ?? ""}${item().url ?? ""}`);
					set_attribute(a, "data-href", item().url);
					set_text(text, `${$LOCALE()[item().title] ?? ""} `);
				});

				append($$anchor, li);
			};

			var alternate = ($$anchor) => {
				var li_1 = root_5$1();
				var text_1 = child(li_1);
				var node_3 = sibling(text_1);

				{
					var consequent_3 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_3, ($$render) => {
						if (item().tag) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_4 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_4, ($$render) => {
						if (item().indicator) $$render(consequent_4);
					});
				}

				reset(li_1);

				template_effect(() => {
					set_class(li_1, `is-no-follow-subtitle ${item().classes ?? ""}`);
					set_text(text_1, `${$LOCALE()[item().title] ?? ""} `);
				});

				append($$anchor, li_1);
			};

			if_block(node, ($$render) => {
				if (typeof item().url !== "undefined" && item().url !== false) $$render(consequent_2); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(["click"]);

	function onClick$3(e, closed, ontoggle) {
		e && e.preventDefault() && e.stopPropagation();
		closed(!closed());

		if (!ontoggle()(closed())) {
			closed(!closed());
		}

		return false;
	}

	var root$4 = template(`<span class="icon is-small is-toggle-submenu is-pulled-right" role="button" tabindex="0"><i aria-hidden="true"></i></span>`);

	function Ui_trigger($$anchor, $$props) {
		push($$props, true);

		const CLASS_ICON = {
			OPENED: "fa-angle-down",
			CLOSED: "fa-angle-up"
		};

		/**
		 * @typedef {Object} Props
		 * @property {any} [icon_opened]
		 * @property {any} [icon_closed]
		 * @property {boolean} [closed]    returns if we should apply toggle or if false - reject it and toggle backward
		 */
		/** @type {Props} */
		let icon_opened = prop($$props, "icon_opened", 19, () => CLASS_ICON.OPENED),
			icon_closed = prop($$props, "icon_closed", 19, () => CLASS_ICON.CLOSED),
			closed = prop($$props, "closed", 7),
			ontoggle = prop($$props, "ontoggle", 3, () => {
				return true;
			});

		var span = root$4();

		span.__click = [onClick$3, closed, ontoggle];
		span.__keyup = [onClick$3, closed, ontoggle];

		var i = child(span);

		reset(span);
		template_effect(() => set_class(i, `fas ${(closed() ? icon_closed() : icon_opened()) ?? ""}`));
		append($$anchor, span);
		pop();
	}

	delegate(["click", "keyup"]);

	var root_4$2 = template(`<span class="is-no-link"> </span>`);
	var root$3 = template(`<!> <!> <!> <!>`, 1);

	function Ui_item_label($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		let item = prop($$props, "item", 19, () => ({}));
		var fragment = root$3();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, spread_props(() => item().icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent = derived(() => COMPONENTS$1.get(item().component));
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get id() {
										return item().id;
									}
								},
								() => item().props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var span = root_4$2();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[item().title]));
						append($$anchor, span);
					};

					if_block(
						node_1,
						($$render) => {
							if (item().type === "component" && item().component && COMPONENTS$1.contains(item().component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (item().icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().tag
				));
			};

			if_block(node_3, ($$render) => {
				if (item().tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().indicator
				));
			};

			if_block(node_4, ($$render) => {
				if (item().indicator) $$render(consequent_3);
			});
		}

		var node_5 = sibling(node_4, 2);

		snippet(node_5, () => $$props.children ?? noop);
		append($$anchor, fragment);
		pop();
	}

	function onClick$2(ev, onnavigate) {
		ev.preventDefault();

		onnavigate()({
			full: ev.target.getAttribute("href"),
			short: ev.target.dataset.href
		});

		return false;
	}

	var root_4$1 = template(`<a class="has-subitems"><!></a>`);
	var root_3$2 = template(`<li><!> <!></li>`);
	var root_1$3 = template(`<ul></ul>`);

	function Ui_items_1($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {boolean} [closed]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let root = prop($$props, "root", 3, ""),
			items = prop($$props, "items", 19, () => []),
			onnavigate = prop($$props, "onnavigate", 3, () => {});

		const createClosedItemsLib = (lst) => {
			const lib = {};

			lst.forEach((itm, index) => lib[index] = itm.closed);
			return lib;
		};

		let closedChildren = proxy(createClosedItemsLib(items()));
		var ul = root_1$3();

		each(ul, 21, items, index$d, ($$anchor, item, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent_1 = ($$anchor) => {
					var li = root_3$2();
					var node_1 = child(li);

					{
						var consequent = ($$anchor) => {
							var a = root_4$1();

							a.__click = [onClick$2, onnavigate];

							var node_2 = child(a);

							Ui_item_label(node_2, {
								get item() {
									return get$2(item);
								},
								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},
										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},
								$$slots: { default: true }
							});

							reset(a);

							template_effect(() => {
								set_attribute(a, "href", `${root() ?? ""}${get$2(item).url ?? ""}`);
								set_attribute(a, "data-href", get$2(item).url);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							Ui_item_label($$anchor, {
								get item() {
									return get$2(item);
								},
								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},
										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},
								$$slots: { default: true }
							});
						};

						if_block(node_1, ($$render) => {
							if (typeof get$2(item).url !== "undefined" && get$2(item).url !== false) $$render(consequent); else $$render(alternate, false);
						});
					}

					var node_3 = sibling(node_1, 2);

					Ui_items_1(node_3, {
						get root() {
							return root();
						},
						get items() {
							return get$2(item).items;
						},
						get onnavigate() {
							return onnavigate();
						},
						get closed() {
							return closedChildren[index];
						},
						set closed($$value) {
							closedChildren[index] = $$value;
						}
					});

					reset(li);
					template_effect(() => set_class(li, `is-no-follow-subtitle ${get$2(item).classes ?? ""}`));
					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					Ui_item_without_children($$anchor, {
						get root() {
							return root();
						},
						get item() {
							return get$2(item);
						},
						get onnavigate() {
							return onnavigate();
						}
					});
				};

				if_block(node, ($$render) => {
					if (get$2(item).items && get$2(item).items.length) $$render(consequent_1); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		template_effect(() => set_class(ul, `menu-list ${($$props.closed ? 'is-closed' : '') ?? ""}`));
		append($$anchor, ul);
		pop();
	}

	delegate(["click"]);

	var root_3$1 = template(`<p><!> <!> <!></p>`);
	var root_1$2 = template(`<!> <!>`, 1);

	function Ui_section$1($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {any}      section
		 * @property {any}      [items]
		 * @property {string}   [root]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let items = prop($$props, "items", 19, () => []),
			root = prop($$props, "root", 3, ""),
			onnavigate = prop($$props, "onnavigate", 3, () => {});

		let sectionItems = derived(() => items().filter((item) => $$props.section.id === item.section));
		var fragment = root_1$2();
		var node = first_child(fragment);

		{
			var consequent_4 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_3 = ($$anchor) => {
						var p = root_3$1();
						var node_2 = child(p);

						{
							var consequent = ($$anchor) => {
								var fragment_2 = comment();
								const SvelteComponent = derived(() => COMPONENTS$1.get($$props.section.component));
								var node_3 = first_child(fragment_2);

								component(node_3, () => get$2(SvelteComponent), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get id() {
												return $$props.section.id;
											}
										},
										() => $$props.section.props
									));
								});

								append($$anchor, fragment_2);
							};

							var alternate = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[$$props.section.title]));
								append($$anchor, text$1);
							};

							if_block(node_2, ($$render) => {
								if ($$props.section.type === "component" && $$props.section.component && COMPONENTS$1.contains($$props.section.component)) $$render(consequent); else $$render(alternate, false);
							});
						}

						var node_4 = sibling(node_2, 2);

						{
							var consequent_1 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.tag
								));
							};

							if_block(node_4, ($$render) => {
								if ($$props.section.tag) $$render(consequent_1);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_2 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.indicator
								));
							};

							if_block(node_5, ($$render) => {
								if ($$props.section.indicator) $$render(consequent_2);
							});
						}

						reset(p);
						template_effect(() => set_class(p, `menu-label ${$$props.section.classes ?? ""}`));
						append($$anchor, p);
					};

					if_block(node_1, ($$render) => {
						if (get$2(sectionItems).length || $$props.section.component || $$props.section.tag || $$props.section.indicator) $$render(consequent_3);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.section) $$render(consequent_4);
			});
		}

		var node_6 = sibling(node, 2);

		{
			var consequent_5 = ($$anchor) => {
				Ui_items_1($$anchor, {
					get root() {
						return root();
					},
					get items() {
						return get$2(sectionItems);
					},
					get onnavigate() {
						return onnavigate();
					}
				});
			};

			if_block(node_6, ($$render) => {
				if (get$2(sectionItems).length) $$render(consequent_5);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_side_menu($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [sections]
		 * @property {any} [navigate = ()=>undefined]
		 */
		/** @type {Props} */
		let root = prop($$props, "root", 3, ""),
			items = prop($$props, "items", 19, () => []),
			sections = prop($$props, "sections", 19, () => []),
			navigate = prop($$props, "navigate", 3, null);

		function onClick(ev) {
			if (typeof navigate() === "function") {
				navigate()(ev);
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, sections, index$d, ($$anchor, section) => {
			Ui_section$1($$anchor, {
				get section() {
					return get$2(section);
				},
				get items() {
					return items();
				},
				get root() {
					return root();
				},
				onnavigate: onClick
			});
		});

		append($$anchor, fragment);
		pop();
	}

	const SideMenuState = writable({
	  open: true
	});

	var _notSideMenu;
	const TYPE$1 = "side";
	let notSideMenu = /*#__PURE__*/function (_Menu) {
	  function notSideMenu() {
	    _classCallCheck(this, notSideMenu);
	    return _callSuper(this, notSideMenu, arguments);
	  }
	  _inherits(notSideMenu, _Menu);
	  return _createClass(notSideMenu, null, [{
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        this.createUI();
	      }
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.menu) {
	        this.menu.$destroy();
	        this.createUI();
	      }
	    }
	  }, {
	    key: "createUI",
	    value: function createUI() {
	      let target = document.querySelector(this.getOptions().targetSelector);
	      if (!target) {
	        return;
	      }
	      this.menu = mount(Ui_side_menu, {
	        target,
	        props: {
	          items: this.items,
	          sections: this.sections,
	          root: this.getOptions().root,
	          navigate: this.getOptions().navigate
	        }
	      });
	      this.initSizeResponse();
	      this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	      this.bindToggle();
	    }
	  }, {
	    key: "itemIsActive",
	    value: function itemIsActive(itemURL) {
	      return (this.location + "/").indexOf(itemURL + "/") > -1;
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu() {
	      var _this = this;
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " a")).forEach(function (item) {
	        if (_this.itemIsActive(item.getAttribute("href"))) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu();
	        }
	      } else {
	        this.location = url;
	        this.updateMenu();
	      }
	    }
	  }, {
	    key: "initSizeResponse",
	    value: function initSizeResponse() {
	      this.nav = document.querySelector("nav.navbar");
	      this.aside = document.querySelector("aside");
	      this.main = document.querySelector("main");
	      this.resizeAsideAndMain(this.aside, this.main, this.nav);
	      this.resizeMain(this.main, this.aside);
	      window.addEventListener("resize", this.resizeMain.bind(this));
	      if (this.isTouch()) {
	        if (this.getOptions().open) {
	          this.show();
	        } else {
	          this.hide();
	        }
	      }
	    }
	  }, {
	    key: "resizeMain",
	    value: function resizeMain() {
	      if (this.isTouch()) {
	        if (this.aside.classList.contains("is-active")) {
	          this.main.style.display = "none";
	        } else {
	          this.main.style.display = "block";
	          this.main.style.marginLeft = "0px";
	        }
	      } else {
	        let rect = this.aside.getBoundingClientRect();
	        this.main.style.display = "block";
	        if (this.main.style.height === "0px") {
	          this.main.style.height = "auto";
	        }
	        this.main.style.marginLeft = rect.width + rect.left + "px";
	      }
	    }
	  }, {
	    key: "resizeAside",
	    value: function resizeAside() {
	      if (this.aside.style.display !== "none") {
	        let rect = this.nav.getBoundingClientRect();
	        this.aside.style.height = window.innerHeight - rect.height + "px";
	        this.aside.style.marginTop = rect.height + "px";
	      }
	    }
	  }, {
	    key: "resizeAsideAndMain",
	    value: function resizeAsideAndMain() {
	      let rect = this.nav.getBoundingClientRect();
	      this.aside.style.height = window.innerHeight - rect.height + "px";
	      //this.aside.style.paddingTop = (rect.height) + 'px';
	      //this.main.style.marginTop = (rect.height) + 'px';
	    }
	  }, {
	    key: "bindToggle",
	    value: function bindToggle() {
	      var _this2 = this;
	      let els = document.querySelectorAll(this.getOptions().toggleSelector);
	      Array.from(els).forEach(function (el) {
	        el.removeEventListener("click", _this2.toggle.bind(_this2));
	        el.addEventListener("click", _this2.toggle.bind(_this2));
	      });
	    }
	  }, {
	    key: "toggle",
	    value: function toggle(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.toggle("is-active");
	        } else {
	          this.aside.classList.toggle("is-closed");
	        }
	        this.resizeMain();
	      }
	      return false;
	    }
	  }, {
	    key: "hide",
	    value: function hide(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.remove("is-active");
	        } else {
	          this.aside.classList.add("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = false;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "show",
	    value: function show(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.add("is-active");
	        } else {
	          this.aside.classList.remove("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = true;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "isOpen",
	    value: function isOpen() {
	      if (this.aside) {
	        if (this.isTouch()) {
	          return this.aside.classList.contains("is-active");
	        } else {
	          return !this.aside.classList.contains("is-closed");
	        }
	      } else {
	        return true;
	      }
	    }
	  }]);
	}(Menu);
	_notSideMenu = notSideMenu;
	_defineProperty(notSideMenu, "nav", void 0);
	_defineProperty(notSideMenu, "main", void 0);
	_defineProperty(notSideMenu, "aside", void 0);
	_defineProperty(notSideMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  open: true,
	  type: "link"
	});
	_defineProperty(notSideMenu, "options", {
	  directNavigation: false,
	  type: TYPE$1,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE$1}-menu`,
	  toggleSelector: `.${TYPE$1}-menu-toggle`,
	  root: "/",
	  open: true,
	  navigate: function (urls) {
	    if (_notSideMenu.isTouch()) {
	      _notSideMenu.hide();
	      _notSideMenu.app && _notSideMenu.app.emit("top-navbar-burger:update", {
	        closed: true
	      });
	    }
	    if (!_notSideMenu.isDirectNavigation() && _notSideMenu.app) {
	      let func = _notSideMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	var root$2 = template(`<a class="navbar-item"><!> <!></a>`);

	function Ui_brand($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [url]
		 * @property {string} [title]
		 * @property {any} [icon]
		 */
		/** @type {Props} */
		let url = prop($$props, "url", 3, "/"),
			title = prop($$props, "title", 3, ""),
			icon = prop($$props, "icon", 19, () => ({
				src: "https://via.placeholder.com/56x28",
				width: 28,
				height: 56
			}));

		var a = root$2();
		var node = child(a);

		Ui_icon(node, spread_props(icon));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_2 = first_child(fragment);

				html(node_2, () => `<span class="navbar-item-brand-title">${title()}</span>`);
				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		reset(a);
		template_effect(() => set_attribute(a, "href", url()));
		append($$anchor, a);
	}

	var root$1 = template(`<!> <!> <!>`, 1);

	function Ui_item_content($$anchor, $$props) {
		push($$props, true);

		const $$stores = setup_stores();
		const $LOCALE = () => store_get(LOCALE, "$LOCALE", $$stores);
		var fragment = root$1();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon($$anchor, spread_props(() => $$props.item.icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent = derived(() => COMPONENTS$1.get($$props.item.component));
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$2(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get id() {
										return $$props.item.id;
									}
								},
								() => $$props.item.props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, $LOCALE()[$$props.item.title]));
						append($$anchor, text$1);
					};

					if_block(
						node_1,
						($$render) => {
							if ($$props.item.type === 'component' && $$props.item.component && COMPONENTS$1.contains($$props.item.component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if ($$props.item.icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						top: true,
						right: true,
						size: "small",
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.tag
				));
			};

			if_block(node_3, ($$render) => {
				if ($$props.item.tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.indicator
				));
			};

			if_block(node_4, ($$render) => {
				if ($$props.item.indicator) $$render(consequent_3);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function onClick$1(event, dispatch, item) {
		dispatch("click", { event, element: item() });
	}

	var root_2$1 = template(`<hr>`);
	var root_3 = template(`<a><!></a>`);
	var root_4 = template(`<div role="button" tabindex="0"><!></div>`);
	var root_1$1 = template(`<!> <!>`, 1);

	function Ui_item($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 * @property {string} [hidden]
		 * @property {string} [classes]
		 */
		/** @type {Props} */
		let root = prop($$props, "root", 3, ""),
			item = prop($$props, "item", 19, () => ({})),
			hidden = prop($$props, "hidden", 3, ""),
			classes = prop($$props, "classes", 3, "");

		var fragment = root_1$1();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var hr = root_2$1();

				template_effect(() => set_class(hr, `navbar-divider ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ""} `));
				append($$anchor, hr);
			};

			if_block(node, ($$render) => {
				if (item().break) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var a = root_3();

				a.__click = [onClick$1, dispatch, item];

				var node_2 = child(a);

				Ui_item_content(node_2, {
					get item() {
						return item();
					}
				});

				reset(a);

				template_effect(() => {
					set_class(a, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ""} ${item().classes ?? ""} ${classes() ?? ""} `);
					set_attribute(a, "href", `${root() ?? ""}${item().url ?? ""}`);
					set_attribute(a, "data-href", item().url);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				var div = root_4();

				div.__click = [onClick$1, dispatch, item];
				div.__keyup = [onClick$1, dispatch, item];

				var node_3 = child(div);

				Ui_item_content(node_3, {
					get item() {
						return item();
					}
				});

				reset(div);
				template_effect(() => set_class(div, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ""} ${item().classes ?? ""} ${classes() ?? ""}`));
				append($$anchor, div);
			};

			if_block(node_1, ($$render) => {
				if (item().url) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(["click", "keyup"]);

	function onClick(event, dispatch, section) {
		dispatch("click", { event, element: section() });
	}

	var root_2 = template(`<div><a href=""><!></a> <div></div></div>`);
	var root_5 = template(`<a><!></a>`);
	var root_6 = template(`<div role="button" tabindex="0"><!></div>`);

	function Ui_section($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [section]
		 * @property {any} [items]
		 * @property {string} [hidden]
		 * @property {boolean} [hoverable]
		 * @property {boolean} [arrowless]
		 * @property {boolean} [right]
		 */
		/** @type {Props} */
		let root = prop($$props, "root", 3, ""),
			section = prop($$props, "section", 19, () => ({})),
			items = prop($$props, "items", 19, () => []),
			hidden = prop($$props, "hidden", 3, ""),
			hoverable = prop($$props, "hoverable", 3, true),
			arrowless = prop($$props, "arrowless", 3, false),
			right = prop($$props, "right", 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_2();
				var a = child(div);

				a.__click = [onClick, dispatch, section];

				var node_1 = child(a);

				Ui_item_content(node_1, {
					get item() {
						return section();
					}
				});

				reset(a);

				var div_1 = sibling(a, 2);

				each(div_1, 21, items, (item) => item.id, ($$anchor, item) => {
					Ui_item($$anchor, {
						get root() {
							return root();
						},
						get item() {
							return get$2(item);
						},
						$$events: {
							click($$arg) {
								bubble_event.call(this, $$props, $$arg);
							}
						}
					});
				});

				reset(div_1);
				reset(div);

				template_effect(() => {
					set_class(div, `navbar-item has-dropdown ${(hoverable() ? 'is-hoverable' : '') ?? ""} ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ""} `);
					set_class(a, `navbar-link ${(arrowless() ? 'is-arrowless' : '') ?? ""}`);
					set_class(div_1, `navbar-dropdown ${(right() ? 'is-right' : '') ?? ""}`);
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_2 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var a_1 = root_5();

						a_1.__click = [onClick, dispatch, section];

						var node_3 = child(a_1);

						Ui_item_content(node_3, {
							get item() {
								return section();
							}
						});

						reset(a_1);

						template_effect(() => {
							set_class(a_1, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ""} `);
							set_attribute(a_1, "href", `${root() ?? ""}${section().url ?? ""}`);
							set_attribute(a_1, "data-href", section().url);
						});

						append($$anchor, a_1);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_6();

						div_2.__click = [onClick, dispatch, section];
						div_2.__keyup = [onClick, dispatch, section];

						var node_4 = child(div_2);

						Ui_item_content(node_4, {
							get item() {
								return section();
							}
						});

						reset(div_2);
						template_effect(() => set_class(div_2, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ""} `));
						append($$anchor, div_2);
					};

					if_block(
						node_2,
						($$render) => {
							if (section().url) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(["click", "keyup"]);

	function toggle(e, closed, dispatch) {
		e.preventDefault();
		closed(!closed());
		dispatch("toggle", { closed: closed() });
		return false;
	}

	var root = template(`<a href="" role="button" aria-label="menu" aria-expanded="false" data-target="navbar"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a>`);

	function Ui_burger($$anchor, $$props) {
		push($$props, true);

		const COMPONENT_NAME = "top-navbar-burger";
		const dispatch = createEventDispatcher();

		function getStandartUpdateEventName() {
			return COMPONENT_NAME + ":update";
		}

		/**
		 * @typedef {Object} Props
		 * @property {any} [events]
		 * @property {any} [register]
		 * @property {boolean} [closed]
		 * @property {any} [onUpdate]
		 */
		/** @type {Props} */
		let events = prop($$props, "events", 31, () => proxy({})),
			register = prop($$props, "register", 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			closed = prop($$props, "closed", 15, true),
			onUpdate = prop($$props, "onUpdate", 3, (data) => {
				closed(data.closed);
			});

		onMount(() => {
			if (!notCommon$1.objHas(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		SideMenuState.subscribe((val) => {
			closed(!val.open);
			return val;
		});

		var a = root();

		a.__click = [toggle, closed, dispatch];
		template_effect(() => set_class(a, `navbar-burger ${(closed() ? '' : 'is-active') ?? ""}`));
		append($$anchor, a);
		pop();
	}

	delegate(["click"]);

	var root_1 = template(`<div class="navbar-brand"><!> <!> <!> <!></div> <div id="navbar"><div class="navbar-start"></div> <div class="navbar-end"></div></div>`, 1);

	function Ui_top($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} [sections] - import { beforeUpdate } from "svelte";
		 * @property {any} [items]
		 * @property {string} [root]
		 * @property {any} [navigate]
		 * @property {boolean} [brand]
		 * @property {boolean} [showBurger]
		 * @property {boolean} [burgerControlsSidemenu]
		 */
		/** @type {Props} */
		let sections = prop($$props, "sections", 19, () => []),
			items = prop($$props, "items", 19, () => []),
			root = prop($$props, "root", 3, ""),
			navigate = prop($$props, "navigate", 3, null),
			brand = prop($$props, "brand", 3, false),
			showBurger = prop($$props, "showBurger", 3, true),
			burgerControlsSidemenu = prop($$props, "burgerControlsSidemenu", 3, true);

		let menuClosed = state(true);

		function onClick({ detail }) {
			let { event, element } = detail;

			if (Object.hasOwn(element, "action")) {
				return element.action(event, element);
			}

			event.preventDefault();

			if (typeof navigate() === "function") {
				navigate()({
					full: event.currentTarget.getAttribute("href"),
					short: event.currentTarget.dataset.href
				});
			}

			return false;
		}

		let sectionsItemsCount = {};
		let sectionsItems = {};

		/*
		beforeUpdate(() => {
		    for (let section of sections) {
		        sectionsItems[section.id] = items.filter(
		            (t) => t.section === section.id
		        );
		        sectionsItemsCount[section.id] = items.filter(
		            (t) => t.section === section.id
		        ).length;
		    }
		});
		*/
		function toggleBurger({ detail }) {
			if (burgerControlsSidemenu()) {
				notSideMenu.toggle();
			} else {
				dispatch("toggleBurger", detail);
				set(menuClosed, proxy(detail.closed));
			}
		}

		var fragment = root_1();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_brand($$anchor, spread_props(brand));
			};

			if_block(node, ($$render) => {
				if (brand()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		each(node_1, 17, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_2 = comment();
			var node_2 = first_child(fragment_2);

			{
				var consequent_1 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: "desktop",
						get item() {
							return get$2(section);
						},
						get root() {
							return root();
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_2, ($$render) => {
					if (get$2(section).showOnTouch) $$render(consequent_1);
				});
			}

			append($$anchor, fragment_2);
		});

		var node_3 = sibling(node_1, 2);

		each(node_3, 17, items, (item) => item.id, ($$anchor, item) => {
			var fragment_4 = comment();
			var node_4 = first_child(fragment_4);

			{
				var consequent_2 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: "desktop",
						get item() {
							return get$2(item);
						},
						get root() {
							return root();
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_4, ($$render) => {
					if (get$2(item).showOnTouch) $$render(consequent_2);
				});
			}

			append($$anchor, fragment_4);
		});

		var node_5 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_burger($$anchor, { $$events: { toggle: toggleBurger } });
			};

			if_block(node_5, ($$render) => {
				if (showBurger()) $$render(consequent_3);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var div_2 = child(div_1);

		each(div_2, 21, items, index$d, ($$anchor, item) => {
			var fragment_7 = comment();
			var node_6 = first_child(fragment_7);

			{
				var consequent_4 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: "touch",
						get item() {
							return get$2(item);
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_6, ($$render) => {
					if (get$2(item).place === "start") $$render(consequent_4);
				});
			}

			append($$anchor, fragment_7);
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);

		each(div_3, 21, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_9 = comment();
			var node_7 = first_child(fragment_9);

			{
				var consequent_5 = ($$anchor) => {
					Ui_section($$anchor, {
						right: true,
						get hidden() {
							return get$2(section).hidden;
						},
						get root() {
							return root();
						},
						get section() {
							return get$2(section);
						},
						get items() {
							return sectionsItems[get$2(section).id];
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_7, ($$render) => {
					if ((sectionsItemsCount[get$2(section).id] || get$2(section).indicator || get$2(section).tag) && get$2(section).place == "end") $$render(consequent_5);
				});
			}

			append($$anchor, fragment_9);
		});

		reset(div_3);
		reset(div_1);
		template_effect(() => set_class(div_1, `navbar-menu ${(get$2(menuClosed) ? '' : 'is-active') ?? ""}`));
		append($$anchor, fragment);
		pop();
	}

	var _notTopMenu;
	const TYPE = "top";
	let notTopMenu = /*#__PURE__*/function (_Menu) {
	  function notTopMenu() {
	    _classCallCheck(this, notTopMenu);
	    return _callSuper(this, notTopMenu, arguments);
	  }
	  _inherits(notTopMenu, _Menu);
	  return _createClass(notTopMenu, null, [{
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        let target = document.querySelector(this.getOptions().targetSelector);
	        if (!target) {
	          return;
	        }
	        this.menu = mount(Ui_top, {
	          target,
	          props: {
	            brand: this.getOptions().brand,
	            items: this.items,
	            sections: this.sections,
	            root: this.getOptions().root,
	            navigate: this.getOptions().navigate
	          }
	        });
	        this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	      }
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu(url) {
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " aside.menu a")).forEach(function (item) {
	        if (item.href == url || url.href && url.href.indexOf(item.href) == 0) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu(url);
	        }
	      } else {
	        this.location = url;
	        this.updateMenu(url);
	      }
	    }
	  }, {
	    key: "toggle",
	    value: function toggle() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.toggle("is-active");
	    }
	  }, {
	    key: "hide",
	    value: function hide() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.remove("is-active");
	    }
	  }, {
	    key: "setBurgerState",
	    value: function setBurgerState(menuClosed) {
	      this.menu.$set({
	        menuClosed
	      });
	    }
	  }]);
	}(Menu);
	_notTopMenu = notTopMenu;
	_defineProperty(notTopMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  place: "main"
	});
	_defineProperty(notTopMenu, "options", {
	  brand: false,
	  type: TYPE,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE}-menu`,
	  root: "/",
	  directNavigation: false,
	  navigate: function (urls) {
	    _notTopMenu.hide();
	    if (!_notTopMenu.isDirectNavigation() && _notTopMenu.app) {
	      let func = _notTopMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	const DEFAULT_TRASFORMER = function (res) {
	  // @ts-ignore
	  return Object.hasOwn(res, "status") && Object.hasOwn(res, "result") ? res.result : res;
	};

	var create_crud_action_ui_view = (function ({
	  ACTION,
	  TITLE,
	  UIConstructor,
	  dataProvider,
	  goBack
	}) {
	  return /*#__PURE__*/function () {
	    function _class() {
	      _classCallCheck(this, _class);
	    }
	    return _createClass(_class, null, [{
	      key: "run",
	      value: async function run(controller, params) {
	        try {
	          controller.setBreadcrumbs([{
	            title: `Просмотр "${TITLE}"`
	          }]);
	          await controller.preloadVariants(ACTION);
	          if (controller.ui[ACTION]) {
	            return;
	          } else {
	            controller.$destroyUI();
	          }
	          let data = {};
	          if (dataProvider) {
	            if (notCommon$1.isFunc(dataProvider)) {
	              if (notCommon$1.isAsync(dataProvider)) {
	                data = await dataProvider(params);
	              } else {
	                data = dataProvider(params);
	              }
	            } else {
	              data = {
	                ...dataProvider
	              };
	            }
	          }
	          const resultTransformer = controller.getOptions(`${ACTION}.transformer`, DEFAULT_TRASFORMER);
	          controller.ui[ACTION] = new UIConstructor({
	            target: controller.getContainerInnerElement(),
	            props: {
	              params,
	              ...resultTransformer(data)
	            }
	          });
	          controller.emit(`after:render:${ACTION}`);
	          if (goBack && notCommon$1.isFunc(goBack)) {
	            controller.ui[ACTION].on("reject", function () {
	              return goBack();
	            });
	          }
	        } catch (e) {
	          controller.report(e);
	          controller.showErrorMessage(e);
	        }
	      }
	    }]);
	  }();
	});

	const PRELOADABLE = ["create", "update", "list", "delete", "details"];
	let CRUDVariantsPreloader = /*#__PURE__*/function () {
	  function CRUDVariantsPreloader() {
	    _classCallCheck(this, CRUDVariantsPreloader);
	  }
	  return _createClass(CRUDVariantsPreloader, null, [{
	    key: "preload",
	    value: async function preload(controller, type = "list") {
	      try {
	        if (!PRELOADABLE.includes(type)) {
	          return;
	        }
	        let preload = controller.getOptions(`${type}.preload`, {});
	        if (Object.keys(preload).length == 0) {
	          preload = controller.getOptions(`preload`, {});
	        }
	        if (Object.keys(preload).length > 0) {
	          let libProps = Object.keys(preload);
	          let proms = [];
	          libProps.forEach(function (prop) {
	            let modelName = notCommon$1.lowerFirstLetter(preload[prop]);
	            let Model = controller.make[modelName]({});
	            proms.push(Model.$listAll());
	          });
	          let results = await Promise.all(proms);
	          for (let i = 0; i < libProps.length; i++) {
	            const propName = libProps[i];
	            if (results[i].status === "ok" && Array.isArray(results[i].result)) {
	              const resultsList = results[i].result;
	              const variants = resultsList.map(function (item) {
	                return {
	                  id: item._id,
	                  title: item.title
	                };
	              });
	              controller.setOptions(`variants.${type}.${propName}`, variants);
	            }
	          }
	        }
	        controller.log("preload finished");
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const DEFAULT_ACTION = "list";
	let notCRUDRouter = /*#__PURE__*/function () {
	  function notCRUDRouter() {
	    _classCallCheck(this, notCRUDRouter);
	  }
	  return _createClass(notCRUDRouter, null, [{
	    key: "extractActionName",
	    value: function extractActionName(controller, params) {
	      let actionName = DEFAULT_ACTION;
	      if (params.length === 1) {
	        if (params[0] === "create") {
	          actionName = "create";
	        } else if (controller.actionHandlerExists(params[0])) {
	          actionName = params[0];
	        } else {
	          actionName = "details";
	        }
	      } else if (params.length > 1) {
	        if (params[1] === "delete") {
	          actionName = "delete";
	        } else if (params[1] === "update") {
	          actionName = "update";
	        } else {
	          actionName = params[1];
	        }
	      }
	      return actionName;
	    }
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = notCRUDRouter.extractActionName(controller, params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	let CRUDMessage = /*#__PURE__*/function () {
	  function CRUDMessage() {
	    _classCallCheck(this, CRUDMessage);
	  }
	  return _createClass(CRUDMessage, null, [{
	    key: "error",
	    value: function error(controller, title, message) {
	      controller.setUI("__message__", new Ui_error({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }, {
	    key: "success",
	    value: function success(controller, title, message) {
	      controller.setUI("__message__", new Ui_success({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }]);
	}();

	const DEFAULT_BREADCRUMB_TAIL$2 = "Просмотр";

	/**
	 * Generic CRUD action class
	 * @class
	 */
	let CRUDGenericAction = /*#__PURE__*/function () {
	  function CRUDGenericAction() {
	    _classCallCheck(this, CRUDGenericAction);
	  }
	  return _createClass(CRUDGenericAction, null, [{
	    key: "NAVIGATION_DELAY",
	    get: function () {
	      return NAVIGATION_DELAY_DEFAULT;
	    }
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	  }, {
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$2;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL$2,
	        set: 'Просмотр, "{:title}"'
	      };
	    }

	    /**
	     * Returns template of breadcrumbs tail
	     * @param   {string}    name
	     * @returns {string}    template string
	     */
	  }, {
	    key: "getBreadcrumbsTail",
	    value: function getBreadcrumbsTail(name) {
	      if (!this.breadcrumbsTails) {
	        return "";
	      }
	      return notCommon$1.select(this.breadcrumbsTails, name, this.deafultBreadcrumbsTail);
	    }
	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "details";
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {object} UIConstructor    constructor of UI component
	     */
	  }, {
	    key: "UIConstructor",
	    get: function () {
	      return notForm;
	    }
	    /**
	     * @static {function}   TRANSFORMER     response.result transformation function if want to change it's structure
	     */
	  }, {
	    key: "TRANSFORMER",
	    get: function () {
	      return DEFAULT_TRASFORMER;
	    }
	    /**
	     * Returns name of model identificaiton field
	     * @param {object} controller instance of controller
	     * @returns {string}    default id field name is '_id'
	     */
	  }, {
	    key: "getIdField",
	    value: function getIdField(controller) {
	      return controller.getOptions(`${this.ACTION}.idField`, "_id");
	    }
	  }, {
	    key: "loadDataQuery",
	    value: function loadDataQuery(controller, params) {
	      const idField = this.getIdField(controller);
	      return {
	        [idField]: params[0]
	      };
	    }

	    /**
	     * Return Promise of API reponse
	     * @param {object} controller instance of controller
	     * @param {string[]} params     array of strings parsed from URI by router and passed to controller
	     * @returns {Promise}   API response {status:string, result:any, message:string, errors: {[fieldname]:[...errorMessages]}}
	     */
	  }, {
	    key: "loadData",
	    value: async function loadData(controller, params) {
	      const query = this.loadDataQuery(controller, params);
	      const actionName = this.getModelActionName(controller);
	      return await controller.getModel(query)[`$${actionName}`]();
	    }

	    /**
	     * Returns model API action name
	     * @param {object} controller instance of controller
	     * @returns {string}    network interface model action name, for API; default: this.MODEL_ACTION_GET
	     */
	  }, {
	    key: "getModelActionName",
	    value: function getModelActionName(controller) {
	      return controller.getOptions(`${this.ACTION}.actionName`, this.MODEL_ACTION_GET);
	    }

	    /**
	     * Sets breadcrumbs tail, without result details
	     * @param {object} controller instance of controller
	     * @param {string[]} params     list of route params
	     */
	  }, {
	    key: "presetBreadcrumbs",
	    value: function presetBreadcrumbs(controller, params) {
	      controller.setBreadcrumbs([{
	        title: this.getBreadcrumbsTail("preset"),
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response.result);
	    }

	    /**
	     * Sets breadcrumbs tail with response details, aka title of loaded item
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response in wrapper
	     * @param {object} response.result  API response result
	     */
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(controller, params, response) {
	      const title = this.getTitle(controller, params, response);
	      const breadcrumbsTailTemplate = this.getBreadcrumbsTail("set");
	      controller.setBreadcrumbs([{
	        title: breadcrumbsTailTemplate ? notLocale$1.format(breadcrumbsTailTemplate, {
	          title
	        }) : title,
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }

	    /**
	     * Checks response on success
	     * @param {object} response
	     * @param {string} response.status
	     * @returns {boolean}   true if response is bad
	     */
	  }, {
	    key: "isResponseBad",
	    value: function isResponseBad(response) {
	      return !response || response.status !== "ok";
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators(controller) {
	      return controller.getValidators && controller.getValidators() || controller.getOptions("Validators");
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const detailsActionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: detailsActionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          fields: {
	            readonly: true
	          },
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	          injected: controller.getOptions(`${this.ACTION}.injected`, {})
	        },
	        data: this.TRANSFORMER(response.result)
	      };
	    }

	    /**
	     * Returns instance of this action UI component from controller
	     * @param {object} controller   instance of controller
	     * @returns {object}    instance of UI component
	     */
	  }, {
	    key: "getUI",
	    value: function getUI(controller) {
	      return controller.getUI(this.ACTION);
	    }

	    /**
	     * Sets UI of this action in controller
	     * @param {object} controller   instance of controller
	     * @param {object} ui           instance of UI component
	     */
	  }, {
	    key: "setUI",
	    value: function setUI(controller, ui) {
	      controller.setUI(this.ACTION, ui);
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `true`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoading",
	    value: function setUILoading(controller) {
	      this.getUI(controller).$set({
	        loading: true
	      });
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `false`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoaded",
	    value: function setUILoaded(controller) {
	      this.getUI(controller).$set({
	        loading: false
	      });
	    }

	    /**
	     *  Sets via `.$set` method `error` to `message`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @param   {Error} message     error message
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUIError",
	    value: function setUIError(controller, message) {
	      this.getUI(controller).$set({
	        error: message
	      });
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return controller.goBack();
	        });
	      }
	    }

	    /**
	     * Bind event handler named event to UI. Checks different binder notation $on/on
	     * @param {object} controller   instance of controller
	     * @param {string} event        event name
	     * @param {function} callback   callback function on event
	     * @returns
	     */
	  }, {
	    key: "bindUIEvent",
	    value: function bindUIEvent(controller, event, callback) {
	      const ui = this.getUI(controller);
	      if (ui.$on) {
	        return ui.$on(event, callback);
	      }
	      if (ui.on) {
	        return ui.on(event, callback);
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }
	  }, {
	    key: "createUI",
	    value: function createUI(uiComponent, controller, response) {
	      if (notCommon$1.isFunc(uiComponent)) {
	        return mount(uiComponent, this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      } else {
	        return new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      }
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        //eslint-disable-next-line no-unused-vars
	        const uiComponent = this.UIConstructor;
	        //eslint-disable-next-line no-unused-vars
	        const ui = this.createUI();
	        this.setUI(controller);
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "goBackAfterDelay",
	    value: function goBackAfterDelay(controller) {
	      controller.goBack(this.NAVIGATION_DELAY);
	    }
	  }, {
	    key: "goBack",
	    value: function goBack(controller) {
	      controller.goBack(0);
	    }
	  }]);
	}();

	const ACTION$2 = "create";
	const DEFAULT_BREADCRUMB_TAIL$1 = "Создание";
	let CRUDGenericActionCreate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionCreate() {
	    _classCallCheck(this, CRUDGenericActionCreate);
	    return _callSuper(this, CRUDGenericActionCreate, arguments);
	  }
	  _inherits(CRUDGenericActionCreate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionCreate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$1;
	    }
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return undefined;
	    }
	  }, {
	    key: "ACTION",
	    get: function () {
	      return ACTION$2;
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     *
	     * @param {import('../../controller.crud')} controller
	     * @param {any}                         [params]
	     * @returns {import('not-node/src/types').notAppResponse}
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "loadData",
	    value: function loadData(controller, params = {}) {
	      let defData = controller.createDefault();
	      if (defData.getData) {
	        defData = defData.getData();
	      }
	      return {
	        status: "ok",
	        result: defData
	      };
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response);
	    }
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const actionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: actionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(response)
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	let CRUDActionCreate = /*#__PURE__*/function (_CRUDGenericActionCre) {
	  function CRUDActionCreate() {
	    _classCallCheck(this, CRUDActionCreate);
	    return _callSuper(this, CRUDActionCreate, arguments);
	  }
	  _inherits(CRUDActionCreate, _CRUDGenericActionCre);
	  return _createClass(CRUDActionCreate);
	}(CRUDGenericActionCreate);

	/**
	 * Generic CRUD Details action class
	 * @class
	 */
	let CRUDGenericActionRead = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionRead() {
	    _classCallCheck(this, CRUDGenericActionRead);
	    return _callSuper(this, CRUDGenericActionRead, arguments);
	  }
	  _inherits(CRUDGenericActionRead, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionRead, null, [{
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      options.options.ui = {
	        submit: {
	          enabled: false
	        }
	      };
	      return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action details
	 */
	let CRUDActionDetails = /*#__PURE__*/function (_CRUDGenericActionRea) {
	  function CRUDActionDetails() {
	    _classCallCheck(this, CRUDActionDetails);
	    return _callSuper(this, CRUDActionDetails, arguments);
	  }
	  _inherits(CRUDActionDetails, _CRUDGenericActionRea);
	  return _createClass(CRUDActionDetails);
	}(CRUDGenericActionRead);

	const DEFAULT_BREADCRUMB_TAIL = "Редактирование";
	/**
	 * Generic CRUD Update action class
	 * @class
	 */
	let CRUDGenericActionUpdate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionUpdate() {
	    _classCallCheck(this, CRUDGenericActionUpdate);
	    return _callSuper(this, CRUDGenericActionUpdate, arguments);
	  }
	  _inherits(CRUDGenericActionUpdate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionUpdate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get:
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    function () {
	      return DEFAULT_BREADCRUMB_TAIL;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL,
	        set: `${DEFAULT_BREADCRUMB_TAIL}: "{:title}"`
	      };
	    }

	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "update";
	    }

	    /**
	     * @static {string} MODEL_ACTION_GET    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "getRaw";
	    }

	    /**
	     * @static {string} MODEL_ACTION_PUT    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "update";
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: this.MODEL_ACTION_PUT,
	          //will be used to get form fields information from manifest
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          ui: controller.getOptions(`${this.ACTION}.ui`, {}),
	          fields: controller.getOptions(`${this.ACTION}.fields`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(notCommon$1.stripProxy(response.result))
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, [params]);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action update
	 */
	let CRUDActionUpdate = /*#__PURE__*/function (_CRUDGenericActionUpd) {
	  function CRUDActionUpdate() {
	    _classCallCheck(this, CRUDActionUpdate);
	    return _callSuper(this, CRUDActionUpdate, arguments);
	  }
	  _inherits(CRUDActionUpdate, _CRUDGenericActionUpd);
	  return _createClass(CRUDActionUpdate);
	}(CRUDGenericActionUpdate);

	const ACTION$1 = "delete";
	const MODEL_ACTION = "delete";
	let CRUDActionDelete = /*#__PURE__*/function () {
	  function CRUDActionDelete() {
	    _classCallCheck(this, CRUDActionDelete);
	  }
	  return _createClass(CRUDActionDelete, null, [{
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        if (controller.ui[ACTION$1]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION$1] = new notActionUI({
	          name: "CRUDDelete",
	          target: controller.getContainerInnerElement(),
	          options: {
	            loaderActive: true,
	            loaderStyle: "container",
	            loaderTitle: "not-node:crud_delete_action_waiting",
	            container: {
	              id: `crud-delete-action-${params[0]}`
	            }
	          }
	        });
	        controller.setBreadcrumbs([{
	          title: "Удаление",
	          url: controller.getModelActionURL(params[0], ACTION$1)
	        }]);
	        if (confirm("Удалить запись?")) {
	          const deleteActionName = controller.getOptions(`${ACTION$1}.actionName`, MODEL_ACTION);
	          const success = await controller.onActionSubmit(deleteActionName, {
	            _id: params[0]
	          });
	          if (success) {
	            controller.goList();
	          }
	          return;
	        }
	        controller.goList();
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const ACTION = "list";
	let CRUDActionList = /*#__PURE__*/function () {
	  function CRUDActionList() {
	    _classCallCheck(this, CRUDActionList);
	  }
	  return _createClass(CRUDActionList, null, [{
	    key: "tweakActionsList",
	    value: function tweakActionsList(controller, ACTIONS_LIST) {
	      if (controller.getOptions(`${ACTION}.createAction`, true)) {
	        ACTIONS_LIST.push({
	          title: "Создать",
	          action: function () {
	            return controller.goCreate();
	          }
	        });
	      }
	      return ACTIONS_LIST;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../controller.crud').default} controller
	     * @param {string} value
	     * @param {number} [delay=0]
	     * @param {Array<string>} [actions=["details", "update", "delete"]]
	     * @param {Array<object>} [prepend=[]]
	     * @param {Array<object>} [append=[]]
	     * @param {boolean} [onlyIcons=true]
	     * @return {Array<object>}
	     * @memberof CRUDActionList
	     */
	  }, {
	    key: "createActionsButtons",
	    value: function createActionsButtons(controller, value, delay = 0, actions = ["details", "update", "delete"], prepend = [], append = [], onlyIcons = true) {
	      const ACTIONS = {
	        details: {
	          action: function () {
	            return controller.goDetails(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "circle-info"
	          } : {
	            title: "Подробнее"
	          }),
	          size: "small"
	        },
	        update: {
	          action: function () {
	            return controller.goUpdate(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "edit"
	          } : {
	            title: "Изменить"
	          }),
	          color: "warning",
	          size: "small"
	        },
	        delete: {
	          action: function () {
	            return controller.goDelete(value, delay);
	          },
	          color: "danger",
	          ...(onlyIcons ? {
	            icon: "trash"
	          } : {
	            title: "Удалить"
	          }),
	          size: "small",
	          style: "outlined"
	        }
	      };
	      const actionsButtons = [...prepend];
	      if (Array.isArray(actions)) {
	        actions.forEach(function (actionName) {
	          return actionsButtons.push(ACTIONS[actionName]);
	        });
	      }
	      actionsButtons.push(...append);
	      return actionsButtons;
	    }
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        await controller.preloadVariants(ACTION);
	        controller.setBreadcrumbs([{
	          title: "Список",
	          url: controller.getModelURL()
	        }]);
	        if (controller.ui[ACTION]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION] = new notTable(this.tweakUIOptions(CRUDActionList.prepareOptions(controller)));
	        controller.emit(`after:render:${ACTION}`, params, controller.ui[ACTION]);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${ACTION}`, params, e);
	        controller.report(e);
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "prepareOptions",
	    value: function prepareOptions(controller) {
	      const DEFAULT_OPTIONS_TABLE = {
	        interface: controller.getOptions(`${ACTION}.interface`, {
	          combined: true,
	          factory: controller.getInterface()
	        }),
	        fields: undefined,
	        showSelect: undefined,
	        getItemId: undefined,
	        idField: undefined,
	        preload: {},
	        filterUI: controller.getOptions(`${ACTION}.filterUI`),
	        pager: {
	          size: 50,
	          page: 0
	        },
	        sorter: {
	          id: -1
	        },
	        filter: undefined,
	        ui: undefined
	      };
	      //forming actions buttons list
	      let ACTIONS_LIST = [...controller.getOptions(`${ACTION}.actions`, [])];
	      ACTIONS_LIST = this.tweakActionsList(controller, ACTIONS_LIST);
	      //
	      const TABLE_OPTIONS = {
	        options: {
	          targetEl: controller.getContainerInnerElement(),
	          endless: false,
	          actions: ACTIONS_LIST
	        }
	      };
	      Object.keys(DEFAULT_OPTIONS_TABLE).forEach(function (key) {
	        let optVal = controller.getOptions(`${ACTION}.${key}`, DEFAULT_OPTIONS_TABLE[key]);
	        if (typeof optVal !== "undefined") {
	          TABLE_OPTIONS.options[key] = optVal;
	        }
	      });
	      return TABLE_OPTIONS;
	    }
	  }]);
	}();

	var CRUDActions = {
	  create: CRUDActionCreate,
	  details: CRUDActionDetails,
	  update: CRUDActionUpdate,
	  delete: CRUDActionDelete,
	  list: CRUDActionList
	};

	const BREADCRUMBS = [];
	const TITLE_FIELDS_PRIORITY = ["title", "label", "id", "name"];
	const LOADING_SCREEN_UI_NAME = "loading_screen";
	var _actions = /*#__PURE__*/new WeakMap();
	var _router = /*#__PURE__*/new WeakMap();
	var _preloader = /*#__PURE__*/new WeakMap();
	let notCRUD = /*#__PURE__*/function (_notController) {
	  function notCRUD(app, name, {
	    actions,
	    router,
	    preloader
	  } = {
	    actions: undefined,
	    router: undefined,
	    preloader: undefined
	  }) {
	    var _this;
	    _classCallCheck(this, notCRUD);
	    _this = _callSuper(this, notCRUD, [app, `CRUD.${name}`]);
	    _classPrivateFieldInitSpec(_this, _actions, {
	      ...CRUDActions
	    });
	    _classPrivateFieldInitSpec(_this, _router, notCRUDRouter);
	    _classPrivateFieldInitSpec(_this, _preloader, CRUDVariantsPreloader);
	    _defineProperty(_this, "TITLE_FIELDS_PRIORITY", TITLE_FIELDS_PRIORITY);
	    _defineProperty(_this, "TOP_CLASS", ["box"]);
	    _defineProperty(_this, "MAIN_CLASS", ["box"]);
	    _defineProperty(_this, "BOTTOM_CLASS", ["box"]);
	    _defineProperty(_this, "WS_CHECK_INTERVAL", 200);
	    if (actions) {
	      // @ts-ignore
	      _classPrivateFieldSet2(_actions, _this, {
	        ..._classPrivateFieldGet2(_actions, _this),
	        ...actions
	      });
	    }
	    if (router) {
	      _classPrivateFieldSet2(_router, _this, router);
	    }
	    if (preloader) {
	      _classPrivateFieldSet2(_preloader, _this, preloader);
	    }
	    _this.ui = {};
	    _this.els = {};
	    _this.setOptions("names", {
	      module: "",
	      plural: "plural",
	      single: "single"
	    });
	    _this.setOptions("containerSelector", _this.app?.getOptions("crud.containerSelector"));
	    _this.buildFrame();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notCRUD, _notController);
	  return _createClass(notCRUD, [{
	    key: "setValidators",
	    value: function setValidators(validators) {
	      //not-module-name -> [not,module,name]
	      const ModuleNameParts = this.getModuleName().split("-");
	      //[not,module,name] -> ModuleName
	      const ModuleName = (ModuleNameParts[0] === "not" ? ModuleNameParts.splice(1) : ModuleNameParts).map(notCommon$1.capitalizeFirstLetter).join("");
	      const serviceName = `ns${ModuleName}Common`;
	      const CommonModuleService = this.app?.getService(serviceName);
	      this.setWorking("validators", CommonModuleService.augmentValidators(validators));
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators() {
	      return this.getWorking("validators");
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      var _this2 = this;
	      let newHead = [];
	      if (this.getModuleName() && this.getOptions("names.module")) {
	        newHead.push({
	          title: this.getOptions("names.module"),
	          url: false
	        });
	      }
	      newHead.push({
	        title: this.getOptions("names.plural"),
	        url: this.getModelURL()
	      });
	      BREADCRUMBS.splice(0, BREADCRUMBS.length, ...newHead);
	      notBreadcrumbs.setHead(BREADCRUMBS).render({
	        root: "",
	        target: this.els.top,
	        navigate: function (url) {
	          return _this2.app?.getWorking("router").navigate(url);
	        }
	      });
	      this.route(this.getOptions("params"));
	    }
	  }, {
	    key: "startWhenWSClientReady",
	    value: function startWhenWSClientReady() {
	      var _this3 = this;
	      if (this.app?.getWSClient()) {
	        if (this.app?.getWSClient().isConnected()) {
	          this.start();
	        } else {
	          this.app.getWSClient().once("connected", this.startWhenWSClientReady.bind(this));
	        }
	      } else {
	        setTimeout(function () {
	          return _this3.startWhenWSClientReady();
	        }, this.WS_CHECK_INTERVAL);
	      }
	    }
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(tail) {
	      notBreadcrumbs.setTail(tail).update();
	    }
	  }, {
	    key: "backToList",
	    value: function backToList() {
	      this.navigate(this.linkBackToList());
	    }
	  }, {
	    key: "linkBackToList",
	    value: function linkBackToList() {
	      return this.getModelURL();
	    }
	  }, {
	    key: "afterAction",
	    value: function afterAction(action = "list") {
	      let navBack = this.app?.getOptions("crud.navigateBackAfter", []);
	      if (navBack && Array.isArray(navBack) && navBack.indexOf(action) > -1) {
	        window.history.back();
	      } else {
	        this.backToList();
	      }
	    }
	  }, {
	    key: "buildFrame",
	    value: function buildFrame() {
	      var _this4 = this;
	      let el = document.querySelector(this.app?.getOptions("crud.containerSelector", "body"));
	      while (el.firstChild) {
	        el.removeChild(el.firstChild);
	      }
	      this.els.top = document.createElement("div");
	      this.els.top.id = "crud-top";
	      this.getFrameClasses().TOP_CLASS.forEach(function (name) {
	        return _this4.els.top.classList.add(name);
	      });
	      el.appendChild(this.els.top);
	      this.els.main = document.createElement("div");
	      this.els.main.id = "crud-main";
	      this.getFrameClasses().MAIN_CLASS.forEach(function (name) {
	        return _this4.els.main.classList.add(name);
	      });
	      el.appendChild(this.els.main);
	      this.els.bottom = document.createElement("div");
	      this.els.bottom.id = "crud-bottom";
	      this.getFrameClasses().BOTTOM_CLASS.forEach(function (name) {
	        return _this4.els.bottom.classList.add(name);
	      });
	      el.appendChild(this.els.bottom);
	    }
	  }, {
	    key: "getFrameClasses",
	    value: function getFrameClasses() {
	      return {
	        TOP_CLASS: this.TOP_CLASS,
	        MAIN_CLASS: this.MAIN_CLASS,
	        BOTTOM_CLASS: this.BOTTOM_CLASS
	      };
	    }
	  }, {
	    key: "getContainerTopElement",
	    value: function getContainerTopElement() {
	      return this.els.top;
	    }
	  }, {
	    key: "getContainerInnerElement",
	    value: function getContainerInnerElement() {
	      return this.els.main;
	    }
	  }, {
	    key: "getContainerBottomElement",
	    value: function getContainerBottomElement() {
	      return this.els.bottom;
	    }
	  }, {
	    key: "preloadVariants",
	    value: async function preloadVariants(type = "list") {
	      await _classPrivateFieldGet2(_preloader, this).preload(this, type);
	    }
	  }, {
	    key: "getTitleFromLib",
	    value: function getTitleFromLib(propName, id) {
	      const actionName = this.getCurrentAction();
	      this.debug && this.debug("notCRUD.getTitleFromLib is obsolete, use notCRUD.getPreloadedVariantTitle(actionName, propName, id)");
	      return this.getPreloadedVariantTitle(actionName, propName, id);
	    }
	  }, {
	    key: "getPreloadedVariants",
	    value: function getPreloadedVariants(actionName, propName) {
	      return this.getOptions(`variants.${actionName}.${propName}`, []);
	    }
	  }, {
	    key: "getPreloadedVariantTitle",
	    value: function getPreloadedVariantTitle(actionName, propName, id) {
	      const variants = this.getPreloadedVariants(actionName, propName);
	      const item = variants.find(function (item) {
	        return item.id === id;
	      });
	      if (item) {
	        return item.title;
	      } else {
	        return id;
	      }
	    }
	  }, {
	    key: "getItemTitle",
	    value: function getItemTitle(item) {
	      const fieldName = this.TITLE_FIELDS_PRIORITY.find(function (key) {
	        return notCommon$1.objHas(item, key);
	      });
	      if (fieldName) {
	        return item[fieldName];
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "createDefault",
	    value: function createDefault() {
	      return this.getModel({}).toDefault();
	    }
	  }, {
	    key: "route",
	    value: function route(params = []) {
	      try {
	        return _classPrivateFieldGet2(_router, this).route(this, params);
	      } catch (e) {
	        this.report(e);
	        this.showErrorMessage(e);
	      }
	    }
	  }, {
	    key: "actionHandlerExists",
	    value: function actionHandlerExists(actionName) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return true;
	      }
	      if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "runAction",
	    value: function runAction(actionName, params) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return _classPrivateFieldGet2(_actions, this)[actionName].run(this, params);
	      } else if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return this["run" + notCommon$1.capitalizeFirstLetter(actionName)](params);
	      } else {
	        throw new Error(`No such action: ${actionName} in contoller ${this.getWorking("name")}`);
	      }
	    }

	    /**
	     *  Changes location to create page, after delay
	     *  @param {number|string} [delay=0] number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goCreate",
	    value: function goCreate(delay = 0) {
	      this.goAfterDelay(this.getModelActionURL("", "create"), delay);
	    }

	    /**
	     *  Changes location to document details page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDetails",
	    value: function goDetails(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, ""), delay);
	    }

	    /**
	     * Changes location to document update page, after delay
	     * @param {string}          id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goUpdate",
	    value: function goUpdate(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "update"), delay);
	    }

	    /**
	     *  Changes location to document delete page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDelete",
	    value: function goDelete(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "delete"), delay);
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goList",
	    value: function goList(delay = 0) {
	      this.goAfterDelay(this.getModelURL(), delay);
	    }

	    /**
	     *
	     * @param {string} url
	     * @param {number|string} delay
	     */
	  }, {
	    key: "goAfterDelay",
	    value: function goAfterDelay(url, delay = 0) {
	      var _this5 = this;
	      this.navigateWithDelay(url, delay, function () {
	        return _this5.$destroyUI();
	      });
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goBack",
	    value: function goBack(delay = 0) {
	      this.goList(delay);
	    }
	  }, {
	    key: "onActionSubmit",
	    value: async function onActionSubmit(action, item) {
	      let state = true;
	      const actionUI = this.ui[action];
	      if (actionUI) {
	        try {
	          actionUI.setLoading();
	          let result = await this.getModel(item)[`$${action}`]();
	          state = actionUI.processResult(result);
	        } catch (e) {
	          state = actionUI.processResult(e);
	        } finally {
	          actionUI.resetLoading();
	          // eslint-disable-next-line no-unsafe-finally
	          return state;
	        }
	      } else {
	        throw new Error("Action UI doesnt exist");
	      }
	    }
	  }, {
	    key: "$destroyUI",
	    value: function $destroyUI() {
	      for (let name in this.ui) {
	        this.destroyUIByName(name);
	      }
	    }
	  }, {
	    key: "destroyUIByName",
	    value: function destroyUIByName(name) {
	      // @ts-ignore
	      if (Object.hasOwn(this.ui, name)) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        this.ui[name].destroy && this.ui[name].destroy();
	        delete this.ui[name];
	      }
	    }
	  }, {
	    key: "showErrorMessage",
	    value: function showErrorMessage(res) {
	      this.error && this.error(res);
	      this.app && this.app.emit("error", {
	        title: "Произошла ошибка",
	        message: res.message ? res.message : UICommon$1.ERROR_DEFAULT
	      });
	      CRUDMessage.error(this, "Произошла ошибка", res.message ? res.message : UICommon$1.ERROR_DEFAULT);
	    }
	  }, {
	    key: "showSuccessMessage",
	    value: function showSuccessMessage(title, message) {
	      this.app && this.app.emit("success", {
	        title,
	        message
	      });
	      CRUDMessage.success(this, title, message);
	    }
	  }, {
	    key: "setUI",
	    value: function setUI(name, val, singleUI = true) {
	      if (singleUI) {
	        this.$destroyUI();
	      }
	      this.ui[name] = val;
	    }
	  }, {
	    key: "getUI",
	    value: function getUI(name) {
	      return this.ui[name];
	    }
	  }, {
	    key: "getActionUI",
	    value: function getActionUI() {
	      return this.ui[this.getCurrentAction()];
	    }
	  }, {
	    key: "renderLoadingScreen",
	    value: function renderLoadingScreen() {
	      this.setUI(LOADING_SCREEN_UI_NAME, this.createLoaderUI());
	    }
	  }, {
	    key: "removeLoadingScreen",
	    value: function removeLoadingScreen() {
	      this.destroyUIByName(LOADING_SCREEN_UI_NAME);
	    }
	  }, {
	    key: "createLoaderUI",
	    value: function createLoaderUI() {
	      return mount(Ui_loader, {
	        target: this.getContainerInnerElement(),
	        props: {
	          loading: true,
	          title: ""
	        }
	      });
	    }
	  }], [{
	    key: "LABELS",
	    get: function () {
	      return Object.freeze({
	        plural: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_plural`,
	        single: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_single`
	      });
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu(itemCustomProps = {}) {
	      return [{
	        section: this.MODULE_NAME,
	        title: this.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(this.MODULE_NAME)}/${notCommon$1.lowerFirstLetter(this.MODEL_NAME)}`,
	        ...itemCustomProps
	      }];
	    }
	  }]);
	}(notController);
	_defineProperty(notCRUD, "ERROR_DEFAULT", UICommon$1.ERROR_DEFAULT);

	const ROUTE_LIST = "list";
	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDPlainRouter = /*#__PURE__*/function () {
	  function notCRUDPlainRouter() {
	    _classCallCheck(this, notCRUDPlainRouter);
	  }
	  return _createClass(notCRUDPlainRouter, null, [{
	    key: "extractActionName",
	    value:
	    /**
	     * Returns first item from params or throws Error
	     * @param {string[]} params array of strings parsed from URI by route rules
	     * @returns {string}
	     */
	    function extractActionName(params) {
	      if (params.length > 0) {
	        return params[0];
	      }
	      return this.DEFAULT_ROUTE;
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = this.extractActionName(params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();
	_defineProperty(notCRUDPlainRouter, "DEFAULT_ROUTE", ROUTE_LIST);

	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDRouterSwitch = /*#__PURE__*/function () {
	  function notCRUDRouterSwitch() {
	    _classCallCheck(this, notCRUDRouterSwitch);
	  }
	  return _createClass(notCRUDRouterSwitch, null, [{
	    key: "routesVariants",
	    get:
	    /**
	     * Variants of this action
	     */
	    function () {
	      return {
	        /**
	        routeName: Action
	         */
	      };
	    }

	    /**
	     * Returns true if variant name is valid
	     * @param {string} name    name of route variant
	     * @returns {boolean}
	     */
	  }, {
	    key: "isRouteVariantValid",
	    value: function isRouteVariantValid(name) {
	      return name !== "" && notCommon$1.objHas(this.routesVariants, name);
	    }

	    /**
	     * This function returns which of routes variant should be executed
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]}    params  params passed to router
	     * @returns {Promise<string>}    name of route variant
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "determineRoute",
	    value: async function determineRoute(controller, params = []) {
	      return "";
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: async function route(controller, params) {
	      try {
	        const actionName = await this.determineRoute(controller, params);
	        if (this.isRouteVariantValid(actionName)) {
	          controller.setCurrentAction(actionName);
	          const routerAction = this.routesVariants[actionName];
	          if (notCommon$1.isAsync(routerAction.run)) {
	            await routerAction.run(controller, params);
	          } else {
	            routerAction.run(controller, params);
	          }
	        } else {
	          throw new Error(`No such action: ${actionName} in contoller ${controller.getWorking("name")}`);
	        }
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const emptyResult = function () {
	  return {
	    list: [],
	    count: 0,
	    page: 0,
	    pages: 0,
	    skip: 0
	  };
	};
	let notServiceModelSearch = /*#__PURE__*/function () {
	  function notServiceModelSearch(app, modelName) {
	    _classCallCheck(this, notServiceModelSearch);
	    this.modelName = modelName;
	    this.app = app;
	  }
	  return _createClass(notServiceModelSearch, [{
	    key: "destroy",
	    value: function destroy() {
	      delete this.app;
	    }
	  }, {
	    key: "getSearchRouteName",
	    value: function getSearchRouteName() {
	      return "listAndCount";
	    }
	  }, {
	    key: "getDataLoadRouteName",
	    value: function getDataLoadRouteName() {
	      return "get";
	    }
	  }, {
	    key: "transformSearchResult",
	    value: function transformSearchResult(result) {
	      var _this = this;
	      result.list = result.list.map(function (item) {
	        return {
	          _id: item._id,
	          id: item[`${_this.modelName}ID`],
	          title: item.name || item.title || item.label || item.username
	        };
	      });
	      return result;
	    }
	  }, {
	    key: "transformSelectedResult",
	    value: function transformSelectedResult(result) {
	      return {
	        _id: result._id,
	        [`${this.modelName}ID`]: result.id,
	        title: result.title
	      };
	    }
	  }, {
	    key: "searchByTerm",
	    value: async function searchByTerm(term) {
	      try {
	        if (term.value.length > 2) {
	          const model = this.app.getModel(this.modelName);
	          model.setSearch(term.value);
	          const response = await model[`$${this.getSearchRouteName()}`]();
	          if (response.status === "ok") {
	            return this.transformSearchResult(response.result);
	          } else {
	            return emptyResult();
	          }
	        } else {
	          return emptyResult();
	        }
	      } catch {
	        return emptyResult();
	      }
	    }
	  }, {
	    key: "openSelector",
	    value: function openSelector() {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        try {
	          const el = mount(Ui_generic_selector, {
	            target: document.body,
	            props: {}
	          });
	          el.$on("termChange", async function ({
	            detail
	          }) {
	            const results = await _this2.searchByTerm(detail);
	            el.$set({
	              results
	            });
	          });
	          el.$on("next", function () {
	            console.log("next selector results");
	          });
	          el.$on("prev", function () {
	            console.log("prev selector results");
	          });
	          el.$on("reject", function () {
	            unmount(el);
	            reject();
	          });
	          el.$on("resolve", function ({
	            detail
	          }) {
	            unmount(el);
	            resolve(_this2.transformSelectedResult(detail));
	          });
	        } catch (e) {
	          _this2.app.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "loadData",
	    value: async function loadData(_id) {
	      try {
	        if (_id && _id.length > 10) {
	          const model = this.app.getModel(this.modelName, {
	            _id
	          });
	          const response = await model[`$${this.getDataLoadRouteName()}`]();
	          if (response.status === "ok") {
	            return response.result;
	          } else {
	            return null;
	          }
	        } else {
	          return null;
	        }
	      } catch (e) {
	        this.app.error(e);
	        return null;
	      }
	    }
	  }]);
	}();

	//import 'babel-polyfill/dist/polyfill';

	const ncCRUD = notCRUD; //legacy alias

	var Frame = /*#__PURE__*/Object.freeze({
		__proto__: null,
		COMPONENTS: COMPONENTS$1,
		FIELDS: FIELDS$1,
		UIForm: Form,
		VARIANTS: VARIANTS$1,
		createCRUDActionUIView: create_crud_action_ui_view,
		ncCRUD: ncCRUD,
		notAPI: index,
		notApp: notApp,
		notBase: notBase,
		notBreadcrumbs: notBreadcrumbs,
		notCRUD: notCRUD,
		notCRUDRouter: notCRUDRouter,
		notCRUDRouterPlain: notCRUDPlainRouter,
		notCRUDRouterSwitch: notCRUDRouterSwitch,
		notCommon: notCommon$1,
		notController: notController,
		notForm: notForm,
		notFormHelpers: FormHelpers,
		notFormRules: notFormRules,
		notFormSet: notFormSet,
		notFormUtils: notFormUtils$1,
		notInterface: notInterface,
		notPath: notPath,
		notRecord: notRecord,
		notRouter: notRouter$1,
		notServiceModelSearch: notServiceModelSearch,
		notSideMenu: notSideMenu,
		notStores: stores,
		notTable: notTable,
		notTopMenu: notTopMenu
	});

	const Locale = {
	  LOCALE,
	  say,
	  notLocale: notLocale$1
	};
	const UICommon = UICommon$1;
	const {
	  notCommon,
	  COMPONENTS,
	  FIELDS,
	  VARIANTS,
	  notFormUtils
	} = Frame;
	Object.keys(Elements).forEach(function (componentsSetName) {
	  Object.keys(Elements[componentsSetName]).forEach(function (componentName) {
	    notFormUtils$1.addComponent(componentName, Elements[componentsSetName][componentName]);
	  });
	});

	exports.COMPONENTS = COMPONENTS;
	exports.Elements = Elements;
	exports.FIELDS = FIELDS;
	exports.Frame = Frame;
	exports.LOCALE = LOCALE;
	exports.Locale = Locale;
	exports.UICommon = UICommon;
	exports.VARIANTS = VARIANTS;
	exports.notCommon = notCommon;
	exports.notFormUtils = notFormUtils;
	exports.notLocale = notLocale$1;
	exports.say = say;
	exports.svelte = indexClient;

	return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90QnVsbWEuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9lc20tZW52L3RydWUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvY2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3dhcm5pbmdzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9oeWRyYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L293bmVyc2hpcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9wcm94eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL29wZXJhdGlvbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VmZmVjdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3Rhc2suanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvbWlzYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3Mvc2hhcmVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9ldmVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3JlY29uY2lsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3RlbXBsYXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2lmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvZWFjaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2h0bWwuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbG90LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc25pcHBldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zdmVsdGUtZWxlbWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvYXR0cmlidXRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYXR0cmlidXRlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvY2xhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvdGltaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2xvb3AuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL3RyYW5zaXRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9pbnB1dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvcHJvcHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NlbGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvdGhpcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vbGVnYWN5L2V2ZW50LW1vZGlmaWVycy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vbGVnYWN5L2xpZmVjeWNsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vbGVnYWN5L21pc2MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zdG9yZS91dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3N0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvcHJvcHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbmRleC1jbGllbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy92ZXJzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi5qcyIsIi4uL3NyYy9lbGVtZW50cy9jb21tb24uanMiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuYmxvY2suc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Jsb2NrL3VpLmJsb2NrLmlubmVyLnZlcnRpY2FsLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9ibG9jay91aS5ib3guc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Jsb2NrL3VpLmNvbnRlbnQuc3ZlbHRlIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwiLi4vc3JjL2xvY2FsZS9zdG9yZS5qcyIsIi4uL25vZGVfbW9kdWxlcy93b2xmeTg3LWV2ZW50ZW1pdHRlci9FdmVudEVtaXR0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXBhdGgvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC1wYXRoL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbW1vbi5qcyIsIi4uL3NyYy9sb2NhbGUvbm90TG9jYWxlLmpzIiwiLi4vc3JjL2xvY2FsZS9pbmRleC5qcyIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnRhZy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5ib29sZWFuLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW4ubGFiZWxlZC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5ib29sZWFucy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5jZW5zb3JlZC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkubG9hZGVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5zZWxlY3Qub3B0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5zZWxlY3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b24uY2xvc2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9idXR0b24vdWkuYnV0dG9ucy5yb3cuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b24uc3dpdGNoLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9idXR0b24vdWkuYnV0dG9ucy5zd2l0Y2hlcnMuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbnN0LmpzIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuc2VsZWN0LmZyb20ubW9kZWwub24uZGVtYW5kLmlubGluZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zZWxlY3QuZnJvbS5tb2RlbC53aXRoLnNlYXJjaC5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5wcm9ncmVzcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zaG93Lm9uZS5mcm9tLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnZhbHVlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmVycm9ycy5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnVzZXIuY2FyZC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkudGV4dGZpZWxkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmxhYmVsLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9mb3JtL3VpLmZvcm0uaW5wdXQuZXJyb3JzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pY29uL3VpLmljb24uYnV0dG9uLndpdGgudGFnLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pY29uL3VpLmljb24uZmxvYXRpbmcuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mb250LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pY29uL3VpLmljb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC52YWxpZGF0ZWQuaWNvbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvZm9ybS91aS5mb3JtLmlucHV0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9mb3JtL3VpLmZvcm0uY29udHJvbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ltYWdlL3VpLmltYWdlcy5zdmVsdGUiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9mbGFncy9sZWdhY3kuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9lYXNpbmcvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9hbmltYXRlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvdHJhbnNpdGlvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zaW1wbGUtc3ZlbHRlLWF1dG9jb21wbGV0ZS9zcmMvU2ltcGxlQXV0b2NvbXBsZXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5hdXRvY29tcGxldGUuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmRhdGUuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmRhdGV0aW1lLmluLnR6LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5lbWFpbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuaGlkZGVuLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS50ZXh0YXJlYS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuanNvbi5hcmVhLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9saWIuanMiLCIuLi9zcmMvZnJhbWUvTElCLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5lbXB0eS5wbGFjZWhvbGRlci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGluay91aS5saW5rLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saW5rL3VpLmxpbmtzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3VpLmxpc3QuaXRlbS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC91aS5saXN0LmJsb2NrLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3VpLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmxpc3Qub2YubW9kZWxzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkuY29sdW1uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkuY29sdW1ucy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmNvbnRhaW5lci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmZvb3Rlci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLnNlY3Rpb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5sZXZlbC5pdGVtLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5udW1iZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLm5hbWVkLm51bWJlcnMubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucGFzc3dvcmQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnJhZGlvLmJ1dHRvbnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnJhbmdlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5zZWxlY3QuZnJvbS5tb2RlbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc3dpdGNoLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5zd2l0Y2gubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkudGFnLnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkudGVsZXBob25lLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0Lm5hdmlnYXRpb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvZW5kbGVzcy91aS5lbmRsZXNzLmxpc3Quc2ltcGxlLml0ZW0uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvZW5kbGVzcy91aS5lbmRsZXNzLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5zZWxlY3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5zZWxlY3Qud2l0aC5ncm91cHMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5zZWxlY3QuYnV0dG9ucy53aXRoLmdyb3Vwcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbW9kYWwvdWkub3ZlcmxheS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbW9kYWwvdWkubW9kYWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL21vZGFsL3VpLmdlbmVyaWMuc2VsZWN0b3Iuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5tZXNzYWdlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9ub3RpZmljYXRpb24vdWkuZXJyb3Iuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5zdWNjZXNzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9ub3RpZmljYXRpb24vdWkuY29va2llLm5vdGlmaWNhdGlvbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvYmFzZS5qcyIsIi4uL3NyYy9mcmFtZS9yb3V0ZXIuanMiLCIuLi9zcmMvZnJhbWUvYXBpL3F1ZXVlLmpzIiwiLi4vc3JjL2ZyYW1lL2FwaS9vcHRpb25zLmpzIiwiLi4vc3JjL2ZyYW1lL2FwaS9jb25uZWN0aW9uLmpzIiwiLi4vc3JjL2ZyYW1lL3N0b3Jlcy5qcyIsIi4uL3NyYy9mcmFtZS9vcHRpb25zLmpzIiwiLi4vc3JjL2ZyYW1lL2ludGVyZmFjZS5qcyIsIi4uL3NyYy9mcmFtZS9yZWNvcmQuanMiLCIuLi9zcmMvZnJhbWUvYXBwLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbnRyb2xsZXIuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9zdG9yZXMuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9jb250cm9scy91aS5zd2l0Y2guc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvdGFibGUvY29udHJvbHMvdWkudGFncy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZUNlbGwuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvdGFibGUvbm90VGFibGVSb3cuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvdGFibGUvbm90VGFibGUuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvdGFibGUvbm90VGFibGUuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9hY3Rpb24vdWkuYWN0aW9uLmNvbnRhaW5lci5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9hY3Rpb24vYWN0aW9uLnVpLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS91dGlscy5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5oZWxwZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9yZXN1bHQuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LWVycm9yL3NyYy9lcnJvci5ub2RlLmNqcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtZXJyb3Ivc3JjL3ZhbGlkYXRpb24uZXJyb3Iubm9kZS5janMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL2NvbW1vbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvc2Vzc2lvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvcnVubmVyLnV0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9ydW5uZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL2J1aWxkZXIudXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL2J1aWxkZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9maWVsZC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9mb3JtLnJ1bGVzLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9mb3JtLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9mb3JtLnNldC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uc2V0LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvYnJlYWRjcnVtYnMvdWkuYnJlYWRjcnVtYnMuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvYnJlYWRjcnVtYnMvYnJlYWRjcnVtYnMuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vbWVudS5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5pdGVtLndpdGhvdXQuY2hpbGRyZW4uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLnRyaWdnZXIuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLml0ZW0ubGFiZWwuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLml0ZW1zLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5zZWN0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5zaWRlLm1lbnUuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3N0b3JlLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuYnJhbmQuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuaXRlbS5jb250ZW50LnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLml0ZW0uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuc2VjdGlvbi5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS5idXJnZXIuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkudG9wLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvY29uc3QuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9jcmVhdGUuY3J1ZC5hY3Rpb24udWkudmlldy5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3ZhcmlhbnRzLnByZWxvYWRlci5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3JvdXRlci5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL21lc3NhZ2UuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvYWN0aW9uLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9nZW5lcmljL2NyZWF0ZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvY3JlYXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9nZW5lcmljL3JlYWQuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2RldGFpbHMuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvdXBkYXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy91cGRhdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2RlbGV0ZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvbGlzdC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9jb250cm9sbGVyLmNydWQuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9yb3V0ZXIucGxhaW4uanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9yb3V0ZXIuc3dpdGNoLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvc2VhcmNoLnNlcnZpY2UuanMiLCIuLi9zcmMvZnJhbWUvaW5kZXguanMiLCIuLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgdHJ1ZTtcbiIsIi8vIFN0b3JlIHRoZSByZWZlcmVuY2VzIHRvIGdsb2JhbHMgaW4gY2FzZSBzb21lb25lIHRyaWVzIHRvIG1vbmtleSBwYXRjaCB0aGVzZSwgY2F1c2luZyB0aGUgYmVsb3dcbi8vIHRvIGRlLW9wdCAodGhpcyBvY2N1cnMgb2Z0ZW4gd2hlbiB1c2luZyBwb3B1bGFyIGV4dGVuc2lvbnMpLlxuZXhwb3J0IHZhciBpc19hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5leHBvcnQgdmFyIGFycmF5X2Zyb20gPSBBcnJheS5mcm9tO1xuZXhwb3J0IHZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IHZhciBkZWZpbmVfcHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5leHBvcnQgdmFyIGdldF9kZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmV4cG9ydCB2YXIgZ2V0X2Rlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5leHBvcnQgdmFyIG9iamVjdF9wcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZXhwb3J0IHZhciBhcnJheV9wcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5leHBvcnQgdmFyIGdldF9wcm90b3R5cGVfb2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlPy50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHBhcmFtIHtGdW5jdGlvbn0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbi8qKiBAcGFyYW0ge0FycmF5PCgpID0+IHZvaWQ+fSBhcnIgKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fYWxsKGFycikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdGFycltpXSgpO1xuXHR9XG59XG5cbi8qKlxuICogVE9ETyByZXBsYWNlIHdpdGggUHJvbWlzZS53aXRoUmVzb2x2ZXJzIG9uY2Ugc3VwcG9ydGVkIHdpZGVseSBlbm91Z2hcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZlcnJlZCgpIHtcblx0LyoqIEB0eXBlIHsodmFsdWU6IFQpID0+IHZvaWR9ICovXG5cdHZhciByZXNvbHZlO1xuXG5cdC8qKiBAdHlwZSB7KHJlYXNvbjogYW55KSA9PiB2b2lkfSAqL1xuXHR2YXIgcmVqZWN0O1xuXG5cdC8qKiBAdHlwZSB7UHJvbWlzZTxUPn0gKi9cblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRyZXNvbHZlID0gcmVzO1xuXHRcdHJlamVjdCA9IHJlajtcblx0fSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtWIHwgKCgpID0+IFYpfSBmYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBbbGF6eV1cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFsbGJhY2sodmFsdWUsIGZhbGxiYWNrLCBsYXp5ID0gZmFsc2UpIHtcblx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcblx0XHQ/IGxhenlcblx0XHRcdD8gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoZmFsbGJhY2spKClcblx0XHRcdDogLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spXG5cdFx0OiB2YWx1ZTtcbn1cbiIsImV4cG9ydCBjb25zdCBERVJJVkVEID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IEVGRkVDVCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBSRU5ERVJfRUZGRUNUID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VGRkVDVCA9IDEgPDwgNDtcbmV4cG9ydCBjb25zdCBCUkFOQ0hfRUZGRUNUID0gMSA8PCA1O1xuZXhwb3J0IGNvbnN0IFJPT1RfRUZGRUNUID0gMSA8PCA2O1xuZXhwb3J0IGNvbnN0IEJPVU5EQVJZX0VGRkVDVCA9IDEgPDwgNztcbmV4cG9ydCBjb25zdCBVTk9XTkVEID0gMSA8PCA4O1xuZXhwb3J0IGNvbnN0IERJU0NPTk5FQ1RFRCA9IDEgPDwgOTtcbmV4cG9ydCBjb25zdCBDTEVBTiA9IDEgPDwgMTA7XG5leHBvcnQgY29uc3QgRElSVFkgPSAxIDw8IDExO1xuZXhwb3J0IGNvbnN0IE1BWUJFX0RJUlRZID0gMSA8PCAxMjtcbmV4cG9ydCBjb25zdCBJTkVSVCA9IDEgPDwgMTM7XG5leHBvcnQgY29uc3QgREVTVFJPWUVEID0gMSA8PCAxNDtcbmV4cG9ydCBjb25zdCBFRkZFQ1RfUkFOID0gMSA8PCAxNTtcbi8qKiAnVHJhbnNwYXJlbnQnIGVmZmVjdHMgZG8gbm90IGNyZWF0ZSBhIHRyYW5zaXRpb24gYm91bmRhcnkgKi9cbmV4cG9ydCBjb25zdCBFRkZFQ1RfVFJBTlNQQVJFTlQgPSAxIDw8IDE2O1xuLyoqIFN2ZWx0ZSA0IGxlZ2FjeSBtb2RlIHByb3BzIG5lZWQgdG8gYmUgaGFuZGxlZCB3aXRoIGRlcml2ZWRzIGFuZCBiZSByZWNvZ25pemVkIGVsc2V3aGVyZSwgaGVuY2UgdGhlIGRlZGljYXRlZCBmbGFnICovXG5leHBvcnQgY29uc3QgTEVHQUNZX0RFUklWRURfUFJPUCA9IDEgPDwgMTc7XG5leHBvcnQgY29uc3QgSU5TUEVDVF9FRkZFQ1QgPSAxIDw8IDE4O1xuZXhwb3J0IGNvbnN0IEhFQURfRUZGRUNUID0gMSA8PCAxOTtcbmV4cG9ydCBjb25zdCBFRkZFQ1RfSEFTX0RFUklWRUQgPSAxIDw8IDIwO1xuXG5leHBvcnQgY29uc3QgU1RBVEVfU1lNQk9MID0gU3ltYm9sKCckc3RhdGUnKTtcbmV4cG9ydCBjb25zdCBTVEFURV9TWU1CT0xfTUVUQURBVEEgPSBTeW1ib2woJyRzdGF0ZSBtZXRhZGF0YScpO1xuZXhwb3J0IGNvbnN0IExFR0FDWV9QUk9QUyA9IFN5bWJvbCgnbGVnYWN5IHByb3BzJyk7XG5leHBvcnQgY29uc3QgTE9BRElOR19BVFRSX1NZTUJPTCA9IFN5bWJvbCgnJyk7XG4iLCIvKiogQGltcG9ydCB7IEVxdWFscyB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHModmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSB0aGlzLnY7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBhXG4gKiBAcGFyYW0ge3Vua25vd259IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhXG5cdFx0PyBiID09IGJcblx0XHQ6IGEgIT09IGIgfHwgKGEgIT09IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPT0gYjtcbn1cblxuLyoqIEB0eXBlIHtFcXVhbHN9ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9lcXVhbHModmFsdWUpIHtcblx0cmV0dXJuICFzYWZlX25vdF9lcXVhbCh2YWx1ZSwgdGhpcy52KTtcbn1cbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKlxuICogVXNpbmcgYGJpbmQ6dmFsdWVgIHRvZ2V0aGVyIHdpdGggYSBjaGVja2JveCBpbnB1dCBpcyBub3QgYWxsb3dlZC4gVXNlIGBiaW5kOmNoZWNrZWRgIGluc3RlYWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVcXG5Vc2luZyBcXGBiaW5kOnZhbHVlXFxgIHRvZ2V0aGVyIHdpdGggYSBjaGVja2JveCBpbnB1dCBpcyBub3QgYWxsb3dlZC4gVXNlIFxcYGJpbmQ6Y2hlY2tlZFxcYCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIENvbXBvbmVudCAlY29tcG9uZW50JSBoYXMgYW4gZXhwb3J0IG5hbWVkIGAla2V5JWAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIGBiaW5kOiVrZXklYCwgd2hpY2ggaXMgZGlzYWxsb3dlZC4gSW5zdGVhZCwgdXNlIGBiaW5kOnRoaXNgIChlLmcuIGA8JW5hbWUlIGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPmApIGFuZCB0aGVuIGFjY2VzcyB0aGUgcHJvcGVydHkgb24gdGhlIGJvdW5kIGNvbXBvbmVudCBpbnN0YW5jZSAoZS5nLiBgY29tcG9uZW50LiVrZXklYClcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ludmFsaWRfZXhwb3J0KGNvbXBvbmVudCwga2V5LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9pbnZhbGlkX2V4cG9ydFxcbkNvbXBvbmVudCAke2NvbXBvbmVudH0gaGFzIGFuIGV4cG9ydCBuYW1lZCBcXGAke2tleX1cXGAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIFxcYGJpbmQ6JHtrZXl9XFxgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgXFxgYmluZDp0aGlzXFxgIChlLmcuIFxcYDwke25hbWV9IGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPlxcYCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIFxcYGNvbXBvbmVudC4ke2tleX1cXGApXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXHR9XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgaXMgYXR0ZW1wdGluZyB0byBiaW5kIHRvIGEgbm9uLWJpbmRhYmxlIHByb3BlcnR5IGAla2V5JWAgYmVsb25naW5nIHRvICVjb21wb25lbnQlIChpLmUuIGA8JW5hbWUlIGJpbmQ6JWtleSU9ey4uLn0+YCkuIFRvIG1hcmsgYSBwcm9wZXJ0eSBhcyBiaW5kYWJsZTogYGxldCB7ICVrZXklID0gJGJpbmRhYmxlKCkgfSA9ICRwcm9wcygpYFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfbm90X2JpbmRhYmxlKGtleSwgY29tcG9uZW50LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9ub3RfYmluZGFibGVcXG5BIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgXFxgJHtrZXl9XFxgIGJlbG9uZ2luZyB0byAke2NvbXBvbmVudH0gKGkuZS4gXFxgPCR7bmFtZX0gYmluZDoke2tleX09ey4uLn0+XFxgKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBcXGBsZXQgeyAke2tleX0gPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX25vdF9iaW5kYWJsZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9ub3RfYmluZGFibGVgKTtcblx0fVxufVxuXG4vKipcbiAqICVwYXJlbnQlIGNhbGxlZCBgJW1ldGhvZCVgIG9uIGFuIGluc3RhbmNlIG9mICVjb21wb25lbnQlLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfY2hhbmdlZChwYXJlbnQsIG1ldGhvZCwgY29tcG9uZW50KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY29tcG9uZW50X2FwaV9jaGFuZ2VkXFxuJHtwYXJlbnR9IGNhbGxlZCBcXGAke21ldGhvZH1cXGAgb24gYW4gaW5zdGFuY2Ugb2YgJHtjb21wb25lbnR9LCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2NoYW5nZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIGluc3RhbnRpYXRlICVjb21wb25lbnQlIHdpdGggYG5ldyAlbmFtZSVgLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDUuIElmIHRoaXMgY29tcG9uZW50IGlzIG5vdCB1bmRlciB5b3VyIGNvbnRyb2wsIHNldCB0aGUgYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpYCBjb21waWxlciBvcHRpb24gdG8gYDRgIHRvIGtlZXAgaXQgd29ya2luZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfYXBpX2ludmFsaWRfbmV3KGNvbXBvbmVudCwgbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXdcXG5BdHRlbXB0ZWQgdG8gaW5zdGFudGlhdGUgJHtjb21wb25lbnR9IHdpdGggXFxgbmV3ICR7bmFtZX1cXGAsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNS4gSWYgdGhpcyBjb21wb25lbnQgaXMgbm90IHVuZGVyIHlvdXIgY29udHJvbCwgc2V0IHRoZSBcXGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaVxcYCBjb21waWxlciBvcHRpb24gdG8gXFxgNFxcYCB0byBrZWVwIGl0IHdvcmtpbmcuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXHR9XG59XG5cbi8qKlxuICogQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZlxcbkEgZGVyaXZlZCB2YWx1ZSBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZiByZWN1cnNpdmVseVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZmApO1xuXHR9XG59XG5cbi8qKlxuICogS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBgJXZhbHVlJWAgYXQgaW5kZXhlcyAlYSUgYW5kICViJVxuICogQHBhcmFtIHtzdHJpbmd9IGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2hfa2V5X2R1cGxpY2F0ZShhLCBiLCB2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVhY2hfa2V5X2R1cGxpY2F0ZVxcbiR7dmFsdWUgPyBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBcXGAke3ZhbHVlfVxcYCBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gIDogYEtleWVkIGVhY2ggYmxvY2sgaGFzIGR1cGxpY2F0ZSBrZXkgYXQgaW5kZXhlcyAke2F9IGFuZCAke2J9YH1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lYWNoX2tleV9kdXBsaWNhdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3RlYXJkb3duKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdGVhcmRvd25cXG5cXGAke3J1bmV9XFxgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgY2xlYW51cCBmdW5jdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl90ZWFyZG93bmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3RlYXJkb3duYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBFZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgYCRkZXJpdmVkYCB2YWx1ZSB0aGF0IHdhcyBub3QgaXRzZWxmIGNyZWF0ZWQgaW5zaWRlIGFuIGVmZmVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkXFxuRWZmZWN0IGNhbm5vdCBiZSBjcmVhdGVkIGluc2lkZSBhIFxcYCRkZXJpdmVkXFxgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IChlLmcuIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24pXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X29ycGhhbihydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X29ycGhhblxcblxcYCR7cnVuZX1cXGAgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IChlLmcuIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24pXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXHR9XG59XG5cbi8qKlxuICogTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgcmVhY3RpdmUgYmxvY2sgb3IgZWZmZWN0IHJlcGVhdGVkbHkgc2V0cyBhIG5ldyB2YWx1ZS4gU3ZlbHRlIGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZFxcbk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIHJlYWN0aXZlIGJsb2NrIG9yIGVmZmVjdCByZXBlYXRlZGx5IHNldHMgYSBuZXcgdmFsdWUuIFN2ZWx0ZSBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXHR9XG59XG5cbi8qKlxuICogRmFpbGVkIHRvIGh5ZHJhdGUgdGhlIGFwcGxpY2F0aW9uXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fZmFpbGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGh5ZHJhdGlvbl9mYWlsZWRcXG5GYWlsZWQgdG8gaHlkcmF0ZSB0aGUgYXBwbGljYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb3VsZCBub3QgYHtAcmVuZGVyfWAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgLiBDb25zaWRlciB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBge0ByZW5kZXIgc25pcHBldD8uKCl9YFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9zbmlwcGV0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWRfc25pcHBldFxcbkNvdWxkIG5vdCBcXGB7QHJlbmRlcn1cXGAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgXFxgbnVsbFxcYCBvciBcXGB1bmRlZmluZWRcXGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIFxcYHtAcmVuZGVyIHNuaXBwZXQ/LigpfVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJW5hbWUlKC4uLilgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfbGVnYWN5X29ubHkobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9sZWdhY3lfb25seVxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW5ub3QgYmUgdXNlZCBpbiBydW5lcyBtb2RlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBkbyBgYmluZDola2V5JT17dW5kZWZpbmVkfWAgd2hlbiBgJWtleSVgIGhhcyBhIGZhbGxiYWNrIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pbnZhbGlkX3ZhbHVlKGtleSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHByb3BzX2ludmFsaWRfdmFsdWVcXG5DYW5ub3QgZG8gXFxgYmluZDoke2tleX09e3VuZGVmaW5lZH1cXGAgd2hlbiBcXGAke2tleX1cXGAgaGFzIGEgZmFsbGJhY2sgdmFsdWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXN0IGVsZW1lbnQgcHJvcGVydGllcyBvZiBgJHByb3BzKClgIHN1Y2ggYXMgYCVwcm9wZXJ0eSVgIGFyZSByZWFkb25seVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19yZXN0X3JlYWRvbmx5KHByb3BlcnR5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfcmVzdF9yZWFkb25seVxcblJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIFxcYCRwcm9wcygpXFxgIHN1Y2ggYXMgXFxgJHtwcm9wZXJ0eX1cXGAgYXJlIHJlYWRvbmx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGAlcnVuZSVgIHJ1bmUgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIGAuc3ZlbHRlYCBhbmQgYC5zdmVsdGUuanMvdHNgIGZpbGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuZV9vdXRzaWRlX3N2ZWx0ZShydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcnVuZV9vdXRzaWRlX3N2ZWx0ZVxcblRoZSBcXGAke3J1bmV9XFxgIHJ1bmUgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIFxcYC5zdmVsdGVcXGAgYW5kIFxcYC5zdmVsdGUuanMvdHNcXGAgZmlsZXNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9ydW5lX291dHNpZGVfc3ZlbHRlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9ydW5lX291dHNpZGVfc3ZlbHRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBQcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIGAkc3RhdGVgIG9iamVjdHMgbXVzdCBjb250YWluIGB2YWx1ZWAgYW5kIGFsd2F5cyBiZSBgZW51bWVyYWJsZWAsIGBjb25maWd1cmFibGVgIGFuZCBgd3JpdGFibGVgLlxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRcXG5Qcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIFxcYCRzdGF0ZVxcYCBvYmplY3RzIG11c3QgY29udGFpbiBcXGB2YWx1ZVxcYCBhbmQgYWx3YXlzIGJlIFxcYGVudW1lcmFibGVcXGAsIFxcYGNvbmZpZ3VyYWJsZVxcYCBhbmQgXFxgd3JpdGFibGVcXGAuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBgJHN0YXRlYCBvYmplY3RcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3RvdHlwZV9maXhlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV9wcm90b3R5cGVfZml4ZWRcXG5DYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBcXGAkc3RhdGVcXGAgb2JqZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJvdG90eXBlX2ZpeGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFJlYWRpbmcgc3RhdGUgdGhhdCB3YXMgY3JlYXRlZCBpbnNpZGUgdGhlIHNhbWUgZGVyaXZlZCBpcyBmb3JiaWRkZW4uIENvbnNpZGVyIHVzaW5nIGB1bnRyYWNrYCB0byByZWFkIGxvY2FsbHkgY3JlYXRlZCBzdGF0ZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWRcXG5SZWFkaW5nIHN0YXRlIHRoYXQgd2FzIGNyZWF0ZWQgaW5zaWRlIHRoZSBzYW1lIGRlcml2ZWQgaXMgZm9yYmlkZGVuLiBDb25zaWRlciB1c2luZyBcXGB1bnRyYWNrXFxgIHRvIHJlYWQgbG9jYWxseSBjcmVhdGVkIHN0YXRlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9sb2NhbF9yZWFkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVcGRhdGluZyBzdGF0ZSBpbnNpZGUgYSBkZXJpdmVkIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgYCRzdGF0ZWBcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV91bnNhZmVfbXV0YXRpb25cXG5VcGRhdGluZyBzdGF0ZSBpbnNpZGUgYSBkZXJpdmVkIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgXFxgJHN0YXRlXFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX211dGF0aW9uYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbXV0YXRpb25gKTtcblx0fVxufSIsImV4cG9ydCBsZXQgbGVnYWN5X21vZGVfZmxhZyA9IGZhbHNlO1xuZXhwb3J0IGxldCB0cmFjaW5nX21vZGVfZmxhZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX2xlZ2FjeV9tb2RlX2ZsYWcoKSB7XG5cdGxlZ2FjeV9tb2RlX2ZsYWcgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX3RyYWNpbmdfbW9kZV9mbGFnKCkge1xuXHR0cmFjaW5nX21vZGVfZmxhZyA9IHRydWU7XG59XG4iLCJleHBvcnQgY29uc3QgRUFDSF9JVEVNX1JFQUNUSVZFID0gMTtcbmV4cG9ydCBjb25zdCBFQUNIX0lOREVYX1JFQUNUSVZFID0gMSA8PCAxO1xuLyoqIFNlZSBFYWNoQmxvY2sgaW50ZXJmYWNlIG1ldGFkYXRhLmlzX2NvbnRyb2xsZWQgZm9yIGFuIGV4cGxhbmF0aW9uIHdoYXQgdGhpcyBpcyAqL1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVNfQ09OVFJPTExFRCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBFQUNIX0lTX0FOSU1BVEVEID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVRFTV9JTU1VVEFCTEUgPSAxIDw8IDQ7XG5cbmV4cG9ydCBjb25zdCBQUk9QU19JU19JTU1VVEFCTEUgPSAxO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX1JVTkVTID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX1VQREFURUQgPSAxIDw8IDI7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfQklOREFCTEUgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfTEFaWV9JTklUSUFMID0gMSA8PCA0O1xuXG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9JTiA9IDE7XG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9PVVQgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9HTE9CQUwgPSAxIDw8IDI7XG5cbmV4cG9ydCBjb25zdCBURU1QTEFURV9GUkFHTUVOVCA9IDE7XG5leHBvcnQgY29uc3QgVEVNUExBVEVfVVNFX0lNUE9SVF9OT0RFID0gMSA8PCAxO1xuXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUID0gJ1snO1xuLyoqIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhbiBgezplbHNlfS4uLmAgYmxvY2sgd2FzIHJlbmRlcmVkICovXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUX0VMU0UgPSAnWyEnO1xuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9FTkQgPSAnXSc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VSUk9SID0ge307XG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX0lTX05BTUVTUEFDRUQgPSAxO1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRfUFJFU0VSVkVfQVRUUklCVVRFX0NBU0UgPSAxIDw8IDE7XG5cbmV4cG9ydCBjb25zdCBVTklOSVRJQUxJWkVEID0gU3ltYm9sKCk7XG5cbi8vIERldi10aW1lIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgRklMRU5BTUUgPSBTeW1ib2woJ2ZpbGVuYW1lJyk7XG5leHBvcnQgY29uc3QgSE1SID0gU3ltYm9sKCdobXInKTtcblxuZXhwb3J0IGNvbnN0IE5BTUVTUEFDRV9TVkcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuZXhwb3J0IGNvbnN0IE5BTUVTUEFDRV9NQVRITUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG5cbi8vIHdlIHVzZSBhIGxpc3Qgb2YgaWdub3JhYmxlIHJ1bnRpbWUgd2FybmluZ3MgYmVjYXVzZSBub3QgZXZlcnkgcnVudGltZSB3YXJuaW5nXG4vLyBjYW4gYmUgaWdub3JlZCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSB2YWxpZGF0aW9uIGZvciBzdmVsdGUtaWdub3JlIGluIHBsYWNlXG5leHBvcnQgY29uc3QgSUdOT1JBQkxFX1JVTlRJTUVfV0FSTklOR1MgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUnLFxuXHQnYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmUnLFxuXHQnaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkJyxcblx0J2h5ZHJhdGlvbl9odG1sX2NoYW5nZWQnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfYmluZGluZycsXG5cdCdvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbidcbl0pO1xuXG4vKipcbiAqIFdoaXRlc3BhY2UgaW5zaWRlIG9uZSBvZiB0aGVzZSBlbGVtZW50cyB3aWxsIG5vdCByZXN1bHQgaW5cbiAqIGEgd2hpdGVzcGFjZSBub2RlIGJlaW5nIGNyZWF0ZWQgaW4gYW55IGNpcmN1bXN0YW5jZXMuIChUaGlzXG4gKiBsaXN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgdmVyeSBpbmNvbXBsZXRlKVxuICogVE9ETyB0aGlzIGlzIGN1cnJlbnRseSB1bnVzZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRTX1dJVEhPVVRfVEVYVCA9IFsnYXVkaW8nLCAnZGF0YWxpc3QnLCAnZGwnLCAnb3B0Z3JvdXAnLCAnc2VsZWN0JywgJ3ZpZGVvJ107XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG52YXIgYm9sZCA9ICdmb250LXdlaWdodDogYm9sZCc7XG52YXIgbm9ybWFsID0gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG4vKipcbiAqIGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiV0YWclXCI+YCBpcyBhIHZvaWQgZWxlbWVudCDigJQgaXQgY2Fubm90IGhhdmUgY29udGVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudCh0YWcpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBkeW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50XFxuJWNcXGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPlxcYCBpcyBhIHZvaWQgZWxlbWVudCDigJQgaXQgY2Fubm90IGhhdmUgY29udGVudFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2R5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBgJHN0YXRlLnNuYXBzaG90YCDigJQgdGhlIHJldHVybiB2YWx1ZSBjb250YWlucyB0aGUgb3JpZ2luYWxzOlxuICogXG4gKiAlcHJvcGVydGllcyVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW3Byb3BlcnRpZXNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZShwcm9wZXJ0aWVzKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGVcXG4lYyR7cHJvcGVydGllc1xuXHRcdFx0PyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBcXGAkc3RhdGUuc25hcHNob3RcXGAg4oCUIHRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgdGhlIG9yaWdpbmFsczpcblxuJHtwcm9wZXJ0aWVzfWBcblx0XHRcdDogXCJWYWx1ZSBjYW5ub3QgYmUgY2xvbmVkIHdpdGggYCRzdGF0ZS5zbmFwc2hvdGAg4oCUIHRoZSBvcmlnaW5hbCB2YWx1ZSB3YXMgcmV0dXJuZWRcIn1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBTbmFwc2hvdCB9IGZyb20gJy4vdHlwZXMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfcHJvdG90eXBlX29mLCBpc19hcnJheSwgb2JqZWN0X3Byb3RvdHlwZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEluIGRldiwgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGNvdWxkIG5vdCBiZSBjbG9uZWQuIEluIHByb2RcbiAqIHdlIGRvbid0IGJvdGhlciwgYnV0IHdlIGtlZXAgYSBkdW1teSBhcnJheSBhcm91bmQgc28gdGhhdCB0aGVcbiAqIHNpZ25hdHVyZSBzdGF5cyB0aGUgc2FtZVxuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG5jb25zdCBlbXB0eSA9IFtdO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwc2hvdCh2YWx1ZSwgc2tpcF93YXJuaW5nID0gZmFsc2UpIHtcblx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblx0XHRjb25zdCBwYXRocyA9IFtdO1xuXG5cdFx0Y29uc3QgY29weSA9IGNsb25lKHZhbHVlLCBuZXcgTWFwKCksICcnLCBwYXRocyk7XG5cdFx0aWYgKHBhdGhzLmxlbmd0aCA9PT0gMSAmJiBwYXRoc1swXSA9PT0gJycpIHtcblx0XHRcdC8vIHZhbHVlIGNvdWxkIG5vdCBiZSBjbG9uZWRcblx0XHRcdHcuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUoKTtcblx0XHR9IGVsc2UgaWYgKHBhdGhzLmxlbmd0aCA+IDApIHtcblx0XHRcdC8vIHNvbWUgcHJvcGVydGllcyBjb3VsZCBub3QgYmUgY2xvbmVkXG5cdFx0XHRjb25zdCBzbGljZSA9IHBhdGhzLmxlbmd0aCA+IDEwID8gcGF0aHMuc2xpY2UoMCwgNykgOiBwYXRocy5zbGljZSgwLCAxMCk7XG5cdFx0XHRjb25zdCBleGNlc3MgPSBwYXRocy5sZW5ndGggLSBzbGljZS5sZW5ndGg7XG5cblx0XHRcdGxldCB1bmNsb25lZCA9IHNsaWNlLm1hcCgocGF0aCkgPT4gYC0gPHZhbHVlPiR7cGF0aH1gKS5qb2luKCdcXG4nKTtcblx0XHRcdGlmIChleGNlc3MgPiAwKSB1bmNsb25lZCArPSBgXFxuLSAuLi5hbmQgJHtleGNlc3N9IG1vcmVgO1xuXG5cdFx0XHR3LnN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHVuY2xvbmVkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29weTtcblx0fVxuXG5cdHJldHVybiBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgZW1wdHkpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge01hcDxULCBTbmFwc2hvdDxUPj59IGNsb25lZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzXG4gKiBAcGFyYW0ge251bGwgfCBUfSBvcmlnaW5hbCBUaGUgb3JpZ2luYWwgdmFsdWUsIGlmIGB2YWx1ZWAgd2FzIHByb2R1Y2VkIGZyb20gYSBgdG9KU09OYCBjYWxsXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlLCBjbG9uZWQsIHBhdGgsIHBhdGhzLCBvcmlnaW5hbCA9IG51bGwpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHR2YXIgdW53cmFwcGVkID0gY2xvbmVkLmdldCh2YWx1ZSk7XG5cdFx0aWYgKHVud3JhcHBlZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdW53cmFwcGVkO1xuXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSByZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKG5ldyBNYXAodmFsdWUpKTtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAobmV3IFNldCh2YWx1ZSkpO1xuXG5cdFx0aWYgKGlzX2FycmF5KHZhbHVlKSkge1xuXHRcdFx0dmFyIGNvcHkgPSAvKiogQHR5cGUge1NuYXBzaG90PGFueT59ICovIChBcnJheSh2YWx1ZS5sZW5ndGgpKTtcblx0XHRcdGNsb25lZC5zZXQodmFsdWUsIGNvcHkpO1xuXG5cdFx0XHRpZiAob3JpZ2luYWwgIT09IG51bGwpIHtcblx0XHRcdFx0Y2xvbmVkLnNldChvcmlnaW5hbCwgY29weSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB2YWx1ZVtpXTtcblx0XHRcdFx0aWYgKGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRjb3B5W2ldID0gY2xvbmUoZWxlbWVudCwgY2xvbmVkLCBERVYgPyBgJHtwYXRofVske2l9XWAgOiBwYXRoLCBwYXRocyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fVxuXG5cdFx0aWYgKGdldF9wcm90b3R5cGVfb2YodmFsdWUpID09PSBvYmplY3RfcHJvdG90eXBlKSB7XG5cdFx0XHQvKiogQHR5cGUge1NuYXBzaG90PGFueT59ICovXG5cdFx0XHRjb3B5ID0ge307XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRjb3B5W2tleV0gPSBjbG9uZSh2YWx1ZVtrZXldLCBjbG9uZWQsIERFViA/IGAke3BhdGh9LiR7a2V5fWAgOiBwYXRoLCBwYXRocyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiAoLyoqIEB0eXBlIHtUICYgeyB0b0pTT04/OiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGNsb25lKFxuXHRcdFx0XHQvKiogQHR5cGUge1QgJiB7IHRvSlNPTigpOiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKCksXG5cdFx0XHRcdGNsb25lZCxcblx0XHRcdFx0REVWID8gYCR7cGF0aH0udG9KU09OKClgIDogcGF0aCxcblx0XHRcdFx0cGF0aHMsXG5cdFx0XHRcdC8vIEFzc29jaWF0ZSB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgdG9KU09OIGNsb25lXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0Ly8gY2FuJ3QgYmUgY2xvbmVkXG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovICh2YWx1ZSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAodmFsdWUpO1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRjb21wb25lbnRfY29udGV4dCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRuZXdfZGVwcyxcblx0YWN0aXZlX2VmZmVjdCxcblx0dW50cmFja2VkX3dyaXRlcyxcblx0Z2V0LFxuXHRpc19ydW5lcyxcblx0c2NoZWR1bGVfZWZmZWN0LFxuXHRzZXRfdW50cmFja2VkX3dyaXRlcyxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVudHJhY2ssXG5cdGluY3JlbWVudF92ZXJzaW9uLFxuXHR1cGRhdGVfZWZmZWN0LFxuXHRkZXJpdmVkX3NvdXJjZXMsXG5cdHNldF9kZXJpdmVkX3NvdXJjZXMsXG5cdGNoZWNrX2RpcnRpbmVzcyxcblx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCxcblx0aXNfZmx1c2hpbmdfZWZmZWN0XG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZXF1YWxzLCBzYWZlX2VxdWFscyB9IGZyb20gJy4vZXF1YWxpdHkuanMnO1xuaW1wb3J0IHtcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdERJUlRZLFxuXHRCUkFOQ0hfRUZGRUNULFxuXHRJTlNQRUNUX0VGRkVDVCxcblx0VU5PV05FRCxcblx0TUFZQkVfRElSVFksXG5cdEJMT0NLX0VGRkVDVFxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZywgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuLi9kZXYvdHJhY2luZy5qcyc7XG5cbmV4cG9ydCBsZXQgaW5zcGVjdF9lZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnNwZWN0X2VmZmVjdHModikge1xuXHRpbnNwZWN0X2VmZmVjdHMgPSB2O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZcbiAqIEBwYXJhbSB7RXJyb3IgfCBudWxsfSBbc3RhY2tdXG4gKiBAcmV0dXJucyB7U291cmNlPFY+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc291cmNlKHYsIHN0YWNrKSB7XG5cdC8qKiBAdHlwZSB7VmFsdWV9ICovXG5cdHZhciBzaWduYWwgPSB7XG5cdFx0ZjogMCwgLy8gVE9ETyBpZGVhbGx5IHdlIGNvdWxkIHNraXAgdGhpcyBhbHRvZ2V0aGVyLCBidXQgaXQgY2F1c2VzIHR5cGUgZXJyb3JzXG5cdFx0dixcblx0XHRyZWFjdGlvbnM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdHZlcnNpb246IDBcblx0fTtcblxuXHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0c2lnbmFsLmNyZWF0ZWQgPSBzdGFjayA/PyBnZXRfc3RhY2soJ0NyZWF0ZWRBdCcpO1xuXHRcdHNpZ25hbC5kZWJ1ZyA9IG51bGw7XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlKHYpIHtcblx0cmV0dXJuIHB1c2hfZGVyaXZlZF9zb3VyY2Uoc291cmNlKHYpKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSBpbml0aWFsX3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW11dGFibGVdXG4gKiBAcmV0dXJucyB7U291cmNlPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXRhYmxlX3NvdXJjZShpbml0aWFsX3ZhbHVlLCBpbW11dGFibGUgPSBmYWxzZSkge1xuXHRjb25zdCBzID0gc291cmNlKGluaXRpYWxfdmFsdWUpO1xuXHRpZiAoIWltbXV0YWJsZSkge1xuXHRcdHMuZXF1YWxzID0gc2FmZV9lcXVhbHM7XG5cdH1cblxuXHQvLyBiaW5kIHRoZSBzaWduYWwgdG8gdGhlIGNvbXBvbmVudCBjb250ZXh0LCBpbiBjYXNlIHdlIG5lZWQgdG9cblx0Ly8gdHJhY2sgdXBkYXRlcyB0byB0cmlnZ2VyIGJlZm9yZVVwZGF0ZS9hZnRlclVwZGF0ZSBjYWxsYmFja3Ncblx0aWYgKGxlZ2FjeV9tb2RlX2ZsYWcgJiYgY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCAhPT0gbnVsbCkge1xuXHRcdChjb21wb25lbnRfY29udGV4dC5sLnMgPz89IFtdKS5wdXNoKHMpO1xuXHR9XG5cblx0cmV0dXJuIHM7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdlxuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGFibGVfc3RhdGUodiwgaW1tdXRhYmxlID0gZmFsc2UpIHtcblx0cmV0dXJuIHB1c2hfZGVyaXZlZF9zb3VyY2UobXV0YWJsZV9zb3VyY2UodiwgaW1tdXRhYmxlKSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBwdXNoX2Rlcml2ZWRfc291cmNlKHNvdXJjZSkge1xuXHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmIChhY3RpdmVfcmVhY3Rpb24uZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0aWYgKGRlcml2ZWRfc291cmNlcyA9PT0gbnVsbCkge1xuXHRcdFx0c2V0X2Rlcml2ZWRfc291cmNlcyhbc291cmNlXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlcml2ZWRfc291cmNlcy5wdXNoKHNvdXJjZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNvdXJjZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPn0gc291cmNlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXRhdGUoc291cmNlLCB2YWx1ZSkge1xuXHRzZXQoXG5cdFx0c291cmNlLFxuXHRcdHVudHJhY2soKCkgPT4gZ2V0KHNvdXJjZSkpXG5cdCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQoc291cmNlLCB2YWx1ZSkge1xuXHRpZiAoXG5cdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmXG5cdFx0aXNfcnVuZXMoKSAmJlxuXHRcdChhY3RpdmVfcmVhY3Rpb24uZiAmIChERVJJVkVEIHwgQkxPQ0tfRUZGRUNUKSkgIT09IDAgJiZcblx0XHQvLyBJZiB0aGUgc291cmNlIHdhcyBjcmVhdGVkIGxvY2FsbHkgd2l0aGluIHRoZSBjdXJyZW50IGRlcml2ZWQsIHRoZW5cblx0XHQvLyB3ZSBhbGxvdyB0aGUgbXV0YXRpb24uXG5cdFx0KGRlcml2ZWRfc291cmNlcyA9PT0gbnVsbCB8fCAhZGVyaXZlZF9zb3VyY2VzLmluY2x1ZGVzKHNvdXJjZSkpXG5cdCkge1xuXHRcdGUuc3RhdGVfdW5zYWZlX211dGF0aW9uKCk7XG5cdH1cblxuXHRyZXR1cm4gaW50ZXJuYWxfc2V0KHNvdXJjZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1NvdXJjZTxWPn0gc291cmNlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVybmFsX3NldChzb3VyY2UsIHZhbHVlKSB7XG5cdGlmICghc291cmNlLmVxdWFscyh2YWx1ZSkpIHtcblx0XHRzb3VyY2UudiA9IHZhbHVlO1xuXHRcdHNvdXJjZS52ZXJzaW9uID0gaW5jcmVtZW50X3ZlcnNpb24oKTtcblxuXHRcdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRcdHNvdXJjZS51cGRhdGVkID0gZ2V0X3N0YWNrKCdVcGRhdGVkQXQnKTtcblx0XHR9XG5cblx0XHRtYXJrX3JlYWN0aW9ucyhzb3VyY2UsIERJUlRZKTtcblxuXHRcdC8vIElmIHRoZSBjdXJyZW50IHNpZ25hbCBpcyBydW5uaW5nIGZvciB0aGUgZmlyc3QgdGltZSwgaXQgd29uJ3QgaGF2ZSBhbnlcblx0XHQvLyByZWFjdGlvbnMgYXMgd2Ugb25seSBhbGxvY2F0ZSBhbmQgYXNzaWduIHRoZSByZWFjdGlvbnMgYWZ0ZXIgdGhlIHNpZ25hbFxuXHRcdC8vIGhhcyBmdWxseSBleGVjdXRlZC4gU28gaW4gdGhlIGNhc2Ugb2YgZW5zdXJpbmcgaXQgcmVnaXN0ZXJzIHRoZSByZWFjdGlvblxuXHRcdC8vIHByb3Blcmx5IGZvciBpdHNlbGYsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBjdXJyZW50IGVmZmVjdCBhY3R1YWxseSBnZXRzXG5cdFx0Ly8gc2NoZWR1bGVkLiBpLmU6IGAkZWZmZWN0KCgpID0+IHgrKylgXG5cdFx0aWYgKFxuXHRcdFx0aXNfcnVuZXMoKSAmJlxuXHRcdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIENMRUFOKSAhPT0gMCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIEJSQU5DSF9FRkZFQ1QpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRpZiAobmV3X2RlcHMgIT09IG51bGwgJiYgbmV3X2RlcHMuaW5jbHVkZXMoc291cmNlKSkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhhY3RpdmVfZWZmZWN0LCBESVJUWSk7XG5cdFx0XHRcdHNjaGVkdWxlX2VmZmVjdChhY3RpdmVfZWZmZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh1bnRyYWNrZWRfd3JpdGVzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0c2V0X3VudHJhY2tlZF93cml0ZXMoW3NvdXJjZV0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVudHJhY2tlZF93cml0ZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKERFViAmJiBpbnNwZWN0X2VmZmVjdHMuc2l6ZSA+IDApIHtcblx0XHRcdGNvbnN0IGluc3BlY3RzID0gQXJyYXkuZnJvbShpbnNwZWN0X2VmZmVjdHMpO1xuXHRcdFx0dmFyIHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0ID0gaXNfZmx1c2hpbmdfZWZmZWN0O1xuXHRcdFx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCh0cnVlKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoY29uc3QgZWZmZWN0IG9mIGluc3BlY3RzKSB7XG5cdFx0XHRcdFx0Ly8gTWFyayBjbGVhbiBpbnNwZWN0LWVmZmVjdHMgYXMgbWF5YmUgZGlydHkgYW5kIHRoZW4gY2hlY2sgdGhlaXIgZGlydGluZXNzXG5cdFx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBqdXN0IHVwZGF0aW5nIHRoZSBlZmZlY3RzIC0gdGhpcyB3YXkgd2UgYXZvaWQgb3ZlcmZpcmluZy5cblx0XHRcdFx0XHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIE1BWUJFX0RJUlRZKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhlZmZlY3QpKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0KTtcblx0XHRcdH1cblx0XHRcdGluc3BlY3RfZWZmZWN0cy5jbGVhcigpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgc2hvdWxkIGJlIERJUlRZIG9yIE1BWUJFX0RJUlRZXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gbWFya19yZWFjdGlvbnMoc2lnbmFsLCBzdGF0dXMpIHtcblx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHR2YXIgcnVuZXMgPSBpc19ydW5lcygpO1xuXHR2YXIgbGVuZ3RoID0gcmVhY3Rpb25zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHJlYWN0aW9uID0gcmVhY3Rpb25zW2ldO1xuXHRcdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0XHQvLyBTa2lwIGFueSBlZmZlY3RzIHRoYXQgYXJlIGFscmVhZHkgZGlydHlcblx0XHRpZiAoKGZsYWdzICYgRElSVFkpICE9PSAwKSBjb250aW51ZTtcblxuXHRcdC8vIEluIGxlZ2FjeSBtb2RlLCBza2lwIHRoZSBjdXJyZW50IGVmZmVjdCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0aWYgKCFydW5lcyAmJiByZWFjdGlvbiA9PT0gYWN0aXZlX2VmZmVjdCkgY29udGludWU7XG5cblx0XHQvLyBJbnNwZWN0IGVmZmVjdHMgbmVlZCB0byBydW4gaW1tZWRpYXRlbHksIHNvIHRoYXQgdGhlIHN0YWNrIHRyYWNlIG1ha2VzIHNlbnNlXG5cdFx0aWYgKERFViAmJiAoZmxhZ3MgJiBJTlNQRUNUX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdGluc3BlY3RfZWZmZWN0cy5hZGQocmVhY3Rpb24pO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIHN0YXR1cyk7XG5cblx0XHQvLyBJZiB0aGUgc2lnbmFsIGEpIHdhcyBwcmV2aW91c2x5IGNsZWFuIG9yIGIpIGlzIGFuIHVub3duZWQgZGVyaXZlZCwgdGhlbiBtYXJrIGl0XG5cdFx0aWYgKChmbGFncyAmIChDTEVBTiB8IFVOT1dORUQpKSAhPT0gMCkge1xuXHRcdFx0aWYgKChmbGFncyAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHRcdG1hcmtfcmVhY3Rpb25zKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2NoZWR1bGVfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogQXNzaWdubWVudCB0byBgJXByb3BlcnR5JWAgcHJvcGVydHkgKCVsb2NhdGlvbiUpIHdpbGwgZXZhbHVhdGUgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSwgbm90IHRoZSB2YWx1ZSBvZiBgJXByb3BlcnR5JWAgZm9sbG93aW5nIHRoZSBhc3NpZ25tZW50LiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvdXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWdubWVudF92YWx1ZV9zdGFsZShwcm9wZXJ0eSwgbG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBhc3NpZ25tZW50X3ZhbHVlX3N0YWxlXFxuJWNBc3NpZ25tZW50IHRvIFxcYCR7cHJvcGVydHl9XFxgIHByb3BlcnR5ICgke2xvY2F0aW9ufSkgd2lsbCBldmFsdWF0ZSB0byB0aGUgcmlnaHQtaGFuZCBzaWRlLCBub3QgdGhlIHZhbHVlIG9mIFxcYCR7cHJvcGVydHl9XFxgIGZvbGxvd2luZyB0aGUgYXNzaWdubWVudC4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2Fzc2lnbm1lbnRfdmFsdWVfc3RhbGVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXNzaWdubWVudF92YWx1ZV9zdGFsZWApO1xuXHR9XG59XG5cbi8qKlxuICogYCViaW5kaW5nJWAgKCVsb2NhdGlvbiUpIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5kaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlKGJpbmRpbmcsIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVcXG4lYyR7bG9jYXRpb24gPyBgXFxgJHtiaW5kaW5nfVxcYCAoJHtsb2NhdGlvbn0pIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlgIDogYFxcYCR7YmluZGluZ31cXGAgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eWB9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgKTtcblx0fVxufVxuXG4vKipcbiAqIFlvdXIgYGNvbnNvbGUuJW1ldGhvZCVgIGNvbnRhaW5lZCBgJHN0YXRlYCBwcm94aWVzLiBDb25zaWRlciB1c2luZyBgJGluc3BlY3QoLi4uKWAgb3IgYCRzdGF0ZS5zbmFwc2hvdCguLi4pYCBpbnN0ZWFkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zb2xlX2xvZ19zdGF0ZShtZXRob2QpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBjb25zb2xlX2xvZ19zdGF0ZVxcbiVjWW91ciBcXGBjb25zb2xlLiR7bWV0aG9kfVxcYCBjb250YWluZWQgXFxgJHN0YXRlXFxgIHByb3hpZXMuIENvbnNpZGVyIHVzaW5nIFxcYCRpbnNwZWN0KC4uLilcXGAgb3IgXFxgJHN0YXRlLnNuYXBzaG90KC4uLilcXGAgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbnNvbGVfbG9nX3N0YXRlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbnNvbGVfbG9nX3N0YXRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlaGFuZGxlciUgc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgbWVhbiB0byAlc3VnZ2VzdGlvbiU/XG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlclxuICogQHBhcmFtIHtzdHJpbmd9IHN1Z2dlc3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50X2hhbmRsZXJfaW52YWxpZChoYW5kbGVyLCBzdWdnZXN0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gZXZlbnRfaGFuZGxlcl9pbnZhbGlkXFxuJWMke2hhbmRsZXJ9IHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gdG8gJHtzdWdnZXN0aW9ufT9cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9ldmVudF9oYW5kbGVyX2ludmFsaWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZXZlbnRfaGFuZGxlcl9pbnZhbGlkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYCVhdHRyaWJ1dGUlYCBhdHRyaWJ1dGUgb24gYCVodG1sJWAgY2hhbmdlZCBpdHMgdmFsdWUgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlLCBgJXZhbHVlJWAsIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkKGF0dHJpYnV0ZSwgaHRtbCwgdmFsdWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBoeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRcXG4lY1RoZSBcXGAke2F0dHJpYnV0ZX1cXGAgYXR0cmlidXRlIG9uIFxcYCR7aHRtbH1cXGAgY2hhbmdlZCBpdHMgdmFsdWUgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlLCBcXGAke3ZhbHVlfVxcYCwgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHZhbHVlIG9mIGFuIGB7QGh0bWwgLi4ufWAgYmxvY2sgJWxvY2F0aW9uJSBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX2h0bWxfY2hhbmdlZChsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9odG1sX2NoYW5nZWRcXG4lYyR7bG9jYXRpb24gPyBgVGhlIHZhbHVlIG9mIGFuIFxcYHtAaHRtbCAuLi59XFxgIGJsb2NrICR7bG9jYXRpb259IGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZWAgOiBcIlRoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVwifVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9odG1sX2NoYW5nZWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2h0bWxfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSBlcnJvciBvY2N1cnJlZCBuZWFyICVsb2NhdGlvbiVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX21pc21hdGNoKGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX21pc21hdGNoXFxuJWMke2xvY2F0aW9uID8gYEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAke2xvY2F0aW9ufWAgOiBcIkh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyXCJ9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX21pc21hdGNoYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGByZW5kZXJgIGZ1bmN0aW9uIHBhc3NlZCB0byBgY3JlYXRlUmF3U25pcHBldGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlclxcbiVjVGhlIFxcYHJlbmRlclxcYCBmdW5jdGlvbiBwYXNzZWQgdG8gXFxgY3JlYXRlUmF3U25pcHBldFxcYCBzaG91bGQgcmV0dXJuIEhUTUwgZm9yIGEgc2luZ2xlIGVsZW1lbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmApO1xuXHR9XG59XG5cbi8qKlxuICogRGV0ZWN0ZWQgYSBtaWdyYXRlZCBgJDpgIHJlYWN0aXZlIGJsb2NrIGluIGAlZmlsZW5hbWUlYCB0aGF0IGJvdGggYWNjZXNzZXMgYW5kIHVwZGF0ZXMgdGhlIHNhbWUgcmVhY3RpdmUgdmFsdWUuIFRoaXMgbWF5IGNhdXNlIHJlY3Vyc2l2ZSB1cGRhdGVzIHdoZW4gY29udmVydGVkIHRvIGFuIGAkZWZmZWN0YC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9jayhmaWxlbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tcXG4lY0RldGVjdGVkIGEgbWlncmF0ZWQgXFxgJDpcXGAgcmVhY3RpdmUgYmxvY2sgaW4gXFxgJHtmaWxlbmFtZX1cXGAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBcXGAkZWZmZWN0XFxgLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9ja2ApO1xuXHR9XG59XG5cbi8qKlxuICogVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudFxcbiVjVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9kb3VibGVfdW5tb3VudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgKTtcblx0fVxufVxuXG4vKipcbiAqICVwYXJlbnQlIHBhc3NlZCBhIHZhbHVlIHRvICVjaGlsZCUgd2l0aCBgYmluZDpgLCBidXQgdGhlIHZhbHVlIGlzIG93bmVkIGJ5ICVvd25lciUuIENvbnNpZGVyIGNyZWF0aW5nIGEgYmluZGluZyBiZXR3ZWVuICVvd25lciUgYW5kICVwYXJlbnQlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvd25lclxuICovXG5leHBvcnQgZnVuY3Rpb24gb3duZXJzaGlwX2ludmFsaWRfYmluZGluZyhwYXJlbnQsIGNoaWxkLCBvd25lcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdcXG4lYyR7cGFyZW50fSBwYXNzZWQgYSB2YWx1ZSB0byAke2NoaWxkfSB3aXRoIFxcYGJpbmQ6XFxgLCBidXQgdGhlIHZhbHVlIGlzIG93bmVkIGJ5ICR7b3duZXJ9LiBDb25zaWRlciBjcmVhdGluZyBhIGJpbmRpbmcgYmV0d2VlbiAke293bmVyfSBhbmQgJHtwYXJlbnR9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ2AsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nYCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlY29tcG9uZW50JSBtdXRhdGVkIGEgdmFsdWUgb3duZWQgYnkgJW93bmVyJS4gVGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgcGFzc2luZyB2YWx1ZXMgdG8gY2hpbGQgY29tcG9uZW50cyB3aXRoIGBiaW5kOmAsIG9yIHVzZSBhIGNhbGxiYWNrIGluc3RlYWRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2NvbXBvbmVudF1cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW293bmVyXVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24oY29tcG9uZW50LCBvd25lcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uXFxuJWMke2NvbXBvbmVudCA/IGAke2NvbXBvbmVudH0gbXV0YXRlZCBhIHZhbHVlIG93bmVkIGJ5ICR7b3duZXJ9LiBUaGlzIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBDb25zaWRlciBwYXNzaW5nIHZhbHVlcyB0byBjaGlsZCBjb21wb25lbnRzIHdpdGggXFxgYmluZDpcXGAsIG9yIHVzZSBhIGNhbGxiYWNrIGluc3RlYWRgIDogXCJNdXRhdGluZyBhIHZhbHVlIG91dHNpZGUgdGhlIGNvbXBvbmVudCB0aGF0IGNyZWF0ZWQgaXQgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQuIENvbnNpZGVyIHBhc3NpbmcgdmFsdWVzIHRvIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBgYmluZDpgLCBvciB1c2UgYSBjYWxsYmFjayBpbnN0ZWFkXCJ9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25gLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25gKTtcblx0fVxufVxuXG4vKipcbiAqIFJlYWN0aXZlIGAkc3RhdGUoLi4uKWAgcHJveGllcyBhbmQgdGhlIHZhbHVlcyB0aGV5IHByb3h5IGhhdmUgZGlmZmVyZW50IGlkZW50aXRpZXMuIEJlY2F1c2Ugb2YgdGhpcywgY29tcGFyaXNvbnMgd2l0aCBgJW9wZXJhdG9yJWAgd2lsbCBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0c1xuICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChvcGVyYXRvcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoXFxuJWNSZWFjdGl2ZSBcXGAkc3RhdGUoLi4uKVxcYCBwcm94aWVzIGFuZCB0aGUgdmFsdWVzIHRoZXkgcHJveHkgaGF2ZSBkaWZmZXJlbnQgaWRlbnRpdGllcy4gQmVjYXVzZSBvZiB0aGlzLCBjb21wYXJpc29ucyB3aXRoIFxcYCR7b3BlcmF0b3J9XFxgIHdpbGwgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaGApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuXG5pbXBvcnQge1xuXHRIWURSQVRJT05fRU5ELFxuXHRIWURSQVRJT05fRVJST1IsXG5cdEhZRFJBVElPTl9TVEFSVCxcblx0SFlEUkFUSU9OX1NUQVJUX0VMU0Vcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogVXNlIHRoaXMgdmFyaWFibGUgdG8gZ3VhcmQgZXZlcnl0aGluZyByZWxhdGVkIHRvIGh5ZHJhdGlvbiBjb2RlIHNvIGl0IGNhbiBiZSB0cmVlc2hha2VuIG91dFxuICogaWYgdGhlIHVzZXIgZG9lc24ndCB1c2UgdGhlIGBoeWRyYXRlYCBtZXRob2QgYW5kIHRoZXNlIGNvZGUgcGF0aHMgYXJlIHRoZXJlZm9yZSBub3QgbmVlZGVkLlxuICovXG5leHBvcnQgbGV0IGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9oeWRyYXRpbmcodmFsdWUpIHtcblx0aHlkcmF0aW5nID0gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIG5vZGUgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgaHlkcmF0ZWQuIFRoaXMgc3RhcnRzIG91dCBhcyB0aGUgZmlyc3Qgbm9kZSBpbnNpZGUgdGhlIG9wZW5pbmdcbiAqIDwhLS1bLS0+IGNvbW1lbnQsIGFuZCB1cGRhdGVzIGVhY2ggdGltZSBhIGNvbXBvbmVudCBjYWxscyBgJC5jaGlsZCguLi4pYCBvciBgJC5zaWJsaW5nKC4uLilgLlxuICogV2hlbiBlbnRlcmluZyBhIGJsb2NrIChlLmcuIGB7I2lmIC4uLn1gKSwgYGh5ZHJhdGVfbm9kZWAgaXMgdGhlIGJsb2NrIG9wZW5pbmcgY29tbWVudDsgYnkgdGhlXG4gKiB0aW1lIHdlIGxlYXZlIHRoZSBibG9jayBpdCBpcyB0aGUgY2xvc2luZyBjb21tZW50LCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGJsb2NrJ3MgYW5jaG9yLlxuICogQHR5cGUge1RlbXBsYXRlTm9kZX1cbiAqL1xuZXhwb3J0IGxldCBoeWRyYXRlX25vZGU7XG5cbi8qKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9oeWRyYXRlX25vZGUobm9kZSkge1xuXHRpZiAobm9kZSA9PT0gbnVsbCkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0cmV0dXJuIChoeWRyYXRlX25vZGUgPSBub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGVfbmV4dCgpIHtcblx0cmV0dXJuIHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKGh5ZHJhdGVfbm9kZSkpKTtcbn1cblxuLyoqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQobm9kZSkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdC8vIElmIHRoZSBub2RlIGhhcyByZW1haW5pbmcgc2libGluZ3MsIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZ1xuXHRpZiAoZ2V0X25leHRfc2libGluZyhoeWRyYXRlX25vZGUpICE9PSBudWxsKSB7XG5cdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdH1cblxuXHRoeWRyYXRlX25vZGUgPSBub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGVfdGVtcGxhdGUodGVtcGxhdGUpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVGVtcGxhdGVOb2RlIGRvZXNuJ3QgaW5jbHVkZSBEb2N1bWVudEZyYWdtZW50LCBidXQgaXQncyBhY3R1YWxseSBmaW5lXG5cdFx0aHlkcmF0ZV9ub2RlID0gdGVtcGxhdGUuY29udGVudDtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV4dChjb3VudCA9IDEpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdHZhciBpID0gY291bnQ7XG5cdFx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHR9XG5cblx0XHRoeWRyYXRlX25vZGUgPSBub2RlO1xuXHR9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgbm9kZXMgc3RhcnRpbmcgYXQgYGh5ZHJhdGVfbm9kZWAgdXAgdW50aWwgdGhlIG5leHQgaHlkcmF0aW9uIGVuZCBjb21tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfbm9kZXMoKSB7XG5cdHZhciBkZXB0aCA9IDA7XG5cdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDgpIHtcblx0XHRcdHZhciBkYXRhID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSkuZGF0YTtcblxuXHRcdFx0aWYgKGRhdGEgPT09IEhZRFJBVElPTl9FTkQpIHtcblx0XHRcdFx0aWYgKGRlcHRoID09PSAwKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0ZGVwdGggLT0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKSB7XG5cdFx0XHRcdGRlcHRoICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgUHJveHlNZXRhZGF0YSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQHR5cGVkZWYge3sgZmlsZTogc3RyaW5nLCBsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyIH19IExvY2F0aW9uICovXG5cbmltcG9ydCB7IFNUQVRFX1NZTUJPTF9NRVRBREFUQSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyByZW5kZXJfZWZmZWN0LCB1c2VyX3ByZV9lZmZlY3QgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBnZXRfcHJvdG90eXBlX29mIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEFycmF5PHsgc3RhcnQ6IExvY2F0aW9uLCBlbmQ6IExvY2F0aW9uLCBjb21wb25lbnQ6IEZ1bmN0aW9uIH0+Pn0gKi9cbmNvbnN0IGJvdW5kYXJpZXMgPSB7fTtcblxuY29uc3QgY2hyb21lX3BhdHRlcm4gPSAvYXQgKD86LisgXFwoKT8oLispOihcXGQrKTooXFxkKylcXCk/JC87XG5jb25zdCBmaXJlZm94X3BhdHRlcm4gPSAvQCguKyk6KFxcZCspOihcXGQrKSQvO1xuXG5mdW5jdGlvbiBnZXRfc3RhY2soKSB7XG5cdGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG5cdGlmICghc3RhY2spIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IGVudHJpZXMgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGxpbmUgb2Ygc3RhY2suc3BsaXQoJ1xcbicpKSB7XG5cdFx0bGV0IG1hdGNoID0gY2hyb21lX3BhdHRlcm4uZXhlYyhsaW5lKSA/PyBmaXJlZm94X3BhdHRlcm4uZXhlYyhsaW5lKTtcblxuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0ZW50cmllcy5wdXNoKHtcblx0XHRcdFx0ZmlsZTogbWF0Y2hbMV0sXG5cdFx0XHRcdGxpbmU6ICttYXRjaFsyXSxcblx0XHRcdFx0Y29sdW1uOiArbWF0Y2hbM11cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbnRyaWVzO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggYC5zdmVsdGVgIGNvbXBvbmVudCBpcyByZXNwb25zaWJsZSBmb3IgYSBnaXZlbiBzdGF0ZSBjaGFuZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbiB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfY29tcG9uZW50KCkge1xuXHQvLyBmaXJzdCA0IGxpbmVzIGFyZSBzdmVsdGUgaW50ZXJuYWxzOyBhZGp1c3QgdGhpcyBudW1iZXIgaWYgd2UgY2hhbmdlIHRoZSBpbnRlcm5hbCBjYWxsIHN0YWNrXG5cdGNvbnN0IHN0YWNrID0gZ2V0X3N0YWNrKCk/LnNsaWNlKDQpO1xuXHRpZiAoIXN0YWNrKSByZXR1cm4gbnVsbDtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgZW50cnkgPSBzdGFja1tpXTtcblx0XHRjb25zdCBtb2R1bGVzID0gYm91bmRhcmllc1tlbnRyeS5maWxlXTtcblx0XHRpZiAoIW1vZHVsZXMpIHtcblx0XHRcdC8vIElmIHRoZSBmaXJzdCBlbnRyeSBpcyBub3QgYSBjb21wb25lbnQsIHRoYXQgbWVhbnMgdGhlIG1vZGlmaWNhdGlvbiB2ZXJ5IGxpa2VseSBoYXBwZW5lZFxuXHRcdFx0Ly8gd2l0aGluIGEgLnN2ZWx0ZS5qcyBmaWxlLCBwb3NzaWJseSB0cmlnZ2VyZWQgYnkgYSBjb21wb25lbnQuIFNpbmNlIHRoZXNlIGZpbGVzIGFyZSBub3QgcGFydFxuXHRcdFx0Ly8gb2YgdGhlIGJvbmRhcmllcy9jb21wb25lbnQgY29udGV4dCBoZXVyaXN0aWMsIHdlIG5lZWQgdG8gYmFpbCBpbiB0aGlzIGNhc2UsIGVsc2Ugd2Ugd291bGRcblx0XHRcdC8vIGhhdmUgZmFsc2UgcG9zaXRpdmVzIHdoZW4gdGhlIC5zdmVsdGUudHMgZmlsZSBwcm92aWRlcyBhIHN0YXRlIGNyZWF0b3IgZnVuY3Rpb24sIGVuY2Fwc3VsYXRpbmdcblx0XHRcdC8vIHRoZSBzdGF0ZSBhbmQgaXRzIG11dGF0aW9ucywgYW5kIGlzIGJlaW5nIGNhbGxlZCBmcm9tIGEgY29tcG9uZW50IG90aGVyIHRoYW4gdGhlIG9uZSB3aG9cblx0XHRcdC8vIGNhbGxlZCB0aGUgc3RhdGUgY3JlYXRvciBmdW5jdGlvbi5cblx0XHRcdGlmIChpID09PSAwKSByZXR1cm4gbnVsbDtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZXMpIHtcblx0XHRcdGlmIChtb2R1bGUuZW5kID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9kdWxlLnN0YXJ0LmxpbmUgPCBlbnRyeS5saW5lICYmIG1vZHVsZS5lbmQubGluZSA+IGVudHJ5LmxpbmUpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5jb21wb25lbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjb25zdCBBRERfT1dORVIgPSBTeW1ib2woJ0FERF9PV05FUicpO1xuXG4vKipcbiAqIFRvZ2V0aGVyIHdpdGggYG1hcmtfbW9kdWxlX2VuZGAsIHRoaXMgZnVuY3Rpb24gZXN0YWJsaXNoZXMgdGhlIGJvdW5kYXJpZXMgb2YgYSBgLnN2ZWx0ZWAgZmlsZSxcbiAqIHN1Y2ggdGhhdCBzdWJzZXF1ZW50IGNhbGxzIHRvIGBnZXRfY29tcG9uZW50YCBjYW4gdGVsbCB1cyB3aGljaCBjb21wb25lbnQgaXMgcmVzcG9uc2libGVcbiAqIGZvciBhIGdpdmVuIHN0YXRlIGNoYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya19tb2R1bGVfc3RhcnQoKSB7XG5cdGNvbnN0IHN0YXJ0ID0gZ2V0X3N0YWNrKCk/LlsyXTtcblxuXHRpZiAoc3RhcnQpIHtcblx0XHQoYm91bmRhcmllc1tzdGFydC5maWxlXSA/Pz0gW10pLnB1c2goe1xuXHRcdFx0c3RhcnQsXG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRlbmQ6IG51bGwsXG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHdlIGFkZCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQsIHNpbmNlIEhNUiB3aWxsIG92ZXJ3cml0ZSB0aGUgZnVuY3Rpb25cblx0XHRcdGNvbXBvbmVudDogbnVsbFxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcG9uZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrX21vZHVsZV9lbmQoY29tcG9uZW50KSB7XG5cdGNvbnN0IGVuZCA9IGdldF9zdGFjaygpPy5bMl07XG5cblx0aWYgKGVuZCkge1xuXHRcdGNvbnN0IGJvdW5kYXJpZXNfZmlsZSA9IGJvdW5kYXJpZXNbZW5kLmZpbGVdO1xuXHRcdGNvbnN0IGJvdW5kYXJ5ID0gYm91bmRhcmllc19maWxlW2JvdW5kYXJpZXNfZmlsZS5sZW5ndGggLSAxXTtcblxuXHRcdGJvdW5kYXJ5LmVuZCA9IGVuZDtcblx0XHRib3VuZGFyeS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge2FueX0gb3duZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9vd25lcihvYmplY3QsIG93bmVyLCBnbG9iYWwgPSBmYWxzZSwgc2tpcF93YXJuaW5nID0gZmFsc2UpIHtcblx0aWYgKG9iamVjdCAmJiAhZ2xvYmFsKSB7XG5cdFx0Y29uc3QgY29tcG9uZW50ID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdGNvbnN0IG1ldGFkYXRhID0gb2JqZWN0W1NUQVRFX1NZTUJPTF9NRVRBREFUQV07XG5cdFx0aWYgKG1ldGFkYXRhICYmICFoYXNfb3duZXIobWV0YWRhdGEsIGNvbXBvbmVudCkpIHtcblx0XHRcdGxldCBvcmlnaW5hbCA9IGdldF9vd25lcihtZXRhZGF0YSk7XG5cblx0XHRcdGlmIChvd25lcltGSUxFTkFNRV0gIT09IGNvbXBvbmVudFtGSUxFTkFNRV0gJiYgIXNraXBfd2FybmluZykge1xuXHRcdFx0XHR3Lm93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcoY29tcG9uZW50W0ZJTEVOQU1FXSwgb3duZXJbRklMRU5BTUVdLCBvcmlnaW5hbFtGSUxFTkFNRV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0LCBvd25lciwgbmV3IFNldCgpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldF9vYmplY3RcbiAqIEBwYXJhbSB7YW55fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9vd25lcl9lZmZlY3QoZ2V0X29iamVjdCwgQ29tcG9uZW50LCBza2lwX3dhcm5pbmcgPSBmYWxzZSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdGFkZF9vd25lcihnZXRfb2JqZWN0KCksIENvbXBvbmVudCwgZmFsc2UsIHNraXBfd2FybmluZyk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YSB8IG51bGx9IGZyb21cbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gdG9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpZGVuX293bmVyc2hpcChmcm9tLCB0bykge1xuXHRpZiAodG8ub3duZXJzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0d2hpbGUgKGZyb20pIHtcblx0XHRpZiAoZnJvbS5vd25lcnMgPT09IG51bGwpIHtcblx0XHRcdHRvLm93bmVycyA9IG51bGw7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IG93bmVyIG9mIGZyb20ub3duZXJzKSB7XG5cdFx0XHR0by5vd25lcnMuYWRkKG93bmVyKTtcblx0XHR9XG5cblx0XHRmcm9tID0gZnJvbS5wYXJlbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvd25lclxuICogQHBhcmFtIHtTZXQ8YW55Pn0gc2VlblxuICovXG5mdW5jdGlvbiBhZGRfb3duZXJfdG9fb2JqZWN0KG9iamVjdCwgb3duZXIsIHNlZW4pIHtcblx0Y29uc3QgbWV0YWRhdGEgPSAvKiogQHR5cGUge1Byb3h5TWV0YWRhdGF9ICovIChvYmplY3Q/LltTVEFURV9TWU1CT0xfTUVUQURBVEFdKTtcblxuXHRpZiAobWV0YWRhdGEpIHtcblx0XHQvLyB0aGlzIGlzIGEgc3RhdGUgcHJveHksIGFkZCBvd25lciBkaXJlY3RseSwgaWYgbm90IGdsb2JhbGx5IHNoYXJlZFxuXHRcdGlmICgnb3duZXJzJyBpbiBtZXRhZGF0YSAmJiBtZXRhZGF0YS5vd25lcnMgIT0gbnVsbCkge1xuXHRcdFx0bWV0YWRhdGEub3duZXJzLmFkZChvd25lcik7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChzZWVuLmhhcyhvYmplY3QpKSByZXR1cm47XG5cdFx0c2Vlbi5hZGQob2JqZWN0KTtcblx0XHRpZiAoQUREX09XTkVSIGluIG9iamVjdCAmJiBvYmplY3RbQUREX09XTkVSXSkge1xuXHRcdFx0Ly8gdGhpcyBpcyBhIGNsYXNzIHdpdGggc3RhdGUgZmllbGRzLiB3ZSBwdXQgdGhpcyBpbiBhIHJlbmRlciBlZmZlY3Rcblx0XHRcdC8vIHNvIHRoYXQgaWYgc3RhdGUgaXMgcmVwbGFjZWQgKGUuZy4gYGluc3RhbmNlLm5hbWUgPSB7IGZpcnN0LCBsYXN0IH1gKVxuXHRcdFx0Ly8gdGhlIG5ldyBzdGF0ZSBpcyBhbHNvIGNvLW93bmVkIGJ5IHRoZSBjYWxsZXIgb2YgYGdldENvbnRleHRgXG5cdFx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0b2JqZWN0W0FERF9PV05FUl0ob3duZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwcm90byA9IGdldF9wcm90b3R5cGVfb2Yob2JqZWN0KTtcblxuXHRcdFx0aWYgKHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKSB7XG5cdFx0XHRcdC8vIHJlY3Vyc2UgdW50aWwgd2UgZmluZCBhIHN0YXRlIHByb3h5XG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRcdGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0W2tleV0sIG93bmVyLCBzZWVuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwcm90byA9PT0gQXJyYXkucHJvdG90eXBlKSB7XG5cdFx0XHRcdC8vIHJlY3Vyc2UgdW50aWwgd2UgZmluZCBhIHN0YXRlIHByb3h5XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0YWRkX293bmVyX3RvX29iamVjdChvYmplY3RbaV0sIG93bmVyLCBzZWVuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gbWV0YWRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc19vd25lcihtZXRhZGF0YSwgY29tcG9uZW50KSB7XG5cdGlmIChtZXRhZGF0YS5vd25lcnMgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiAoXG5cdFx0bWV0YWRhdGEub3duZXJzLmhhcyhjb21wb25lbnQpIHx8XG5cdFx0KG1ldGFkYXRhLnBhcmVudCAhPT0gbnVsbCAmJiBoYXNfb3duZXIobWV0YWRhdGEucGFyZW50LCBjb21wb25lbnQpKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gbWV0YWRhdGFcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldF9vd25lcihtZXRhZGF0YSkge1xuXHRyZXR1cm4gKFxuXHRcdG1ldGFkYXRhPy5vd25lcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSA/P1xuXHRcdGdldF9vd25lcigvKiogQHR5cGUge1Byb3h5TWV0YWRhdGF9ICovIChtZXRhZGF0YS5wYXJlbnQpKVxuXHQpO1xufVxuXG5sZXQgc2tpcCA9IGZhbHNlO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2tpcF9vd25lcnNoaXBfdmFsaWRhdGlvbihmbikge1xuXHRza2lwID0gdHJ1ZTtcblx0Zm4oKTtcblx0c2tpcCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gbWV0YWRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX293bmVyc2hpcChtZXRhZGF0YSkge1xuXHRpZiAoc2tpcCkgcmV0dXJuO1xuXG5cdGNvbnN0IGNvbXBvbmVudCA9IGdldF9jb21wb25lbnQoKTtcblxuXHRpZiAoY29tcG9uZW50ICYmICFoYXNfb3duZXIobWV0YWRhdGEsIGNvbXBvbmVudCkpIHtcblx0XHRsZXQgb3JpZ2luYWwgPSBnZXRfb3duZXIobWV0YWRhdGEpO1xuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGlmIChvcmlnaW5hbFtGSUxFTkFNRV0gIT09IGNvbXBvbmVudFtGSUxFTkFNRV0pIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdHcub3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24oY29tcG9uZW50W0ZJTEVOQU1FXSwgb3JpZ2luYWxbRklMRU5BTUVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbigpO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBQcm94eU1ldGFkYXRhLCBQcm94eVN0YXRlT2JqZWN0LCBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBnZXQsIGNvbXBvbmVudF9jb250ZXh0LCBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdGFycmF5X3Byb3RvdHlwZSxcblx0Z2V0X2Rlc2NyaXB0b3IsXG5cdGdldF9wcm90b3R5cGVfb2YsXG5cdGlzX2FycmF5LFxuXHRvYmplY3RfcHJvdG90eXBlXG59IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBjaGVja19vd25lcnNoaXAsIHdpZGVuX293bmVyc2hpcCB9IGZyb20gJy4vZGV2L293bmVyc2hpcC5qcyc7XG5pbXBvcnQgeyBzb3VyY2UsIHNldCB9IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IFNUQVRFX1NZTUJPTCwgU1RBVEVfU1lNQk9MX01FVEFEQVRBIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGdldF9zdGFjayB9IGZyb20gJy4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YSB8IG51bGx9IFtwYXJlbnRdXG4gKiBAcGFyYW0ge1NvdXJjZTxUPn0gW3ByZXZdIGRldiBtb2RlIG9ubHlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHkodmFsdWUsIHBhcmVudCA9IG51bGwsIHByZXYpIHtcblx0LyoqIEB0eXBlIHtFcnJvciB8IG51bGx9ICovXG5cdHZhciBzdGFjayA9IG51bGw7XG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzdGFjayA9IGdldF9zdGFjaygnQ3JlYXRlZEF0Jyk7XG5cdH1cblx0Ly8gaWYgbm9uLXByb3h5YWJsZSwgb3IgaXMgYWxyZWFkeSBhIHByb3h5LCByZXR1cm4gYHZhbHVlYFxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRjb25zdCBwcm90b3R5cGUgPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblxuXHRpZiAocHJvdG90eXBlICE9PSBvYmplY3RfcHJvdG90eXBlICYmIHByb3RvdHlwZSAhPT0gYXJyYXlfcHJvdG90eXBlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtNYXA8YW55LCBTb3VyY2U8YW55Pj59ICovXG5cdHZhciBzb3VyY2VzID0gbmV3IE1hcCgpO1xuXHR2YXIgaXNfcHJveGllZF9hcnJheSA9IGlzX2FycmF5KHZhbHVlKTtcblx0dmFyIHZlcnNpb24gPSBzb3VyY2UoMCk7XG5cblx0aWYgKGlzX3Byb3hpZWRfYXJyYXkpIHtcblx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSB0aGUgbGVuZ3RoIHNvdXJjZSBlYWdlcmx5IHRvIGVuc3VyZSB0aGF0XG5cdFx0Ly8gbXV0YXRpb25zIHRvIHRoZSBhcnJheSBhcmUgcHJvcGVybHkgc3luY2VkIHdpdGggb3VyIHByb3h5XG5cdFx0c291cmNlcy5zZXQoJ2xlbmd0aCcsIHNvdXJjZSgvKiogQHR5cGUge2FueVtdfSAqLyAodmFsdWUpLmxlbmd0aCwgc3RhY2spKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7UHJveHlNZXRhZGF0YX0gKi9cblx0dmFyIG1ldGFkYXRhO1xuXG5cdGlmIChERVYpIHtcblx0XHRtZXRhZGF0YSA9IHtcblx0XHRcdHBhcmVudCxcblx0XHRcdG93bmVyczogbnVsbFxuXHRcdH07XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0Ly8gUmV1c2Ugb3duZXJzIGZyb20gcHJldmlvdXMgc3RhdGU7IG5lY2Vzc2FyeSBiZWNhdXNlIHJlYXNzaWdubWVudCBpcyBub3QgZ3VhcmFudGVlZCB0byBoYXZlIGNvcnJlY3QgY29tcG9uZW50IGNvbnRleHQuXG5cdFx0XHQvLyBJZiBubyBwcmV2aW91cyBwcm94eSBleGlzdHMgd2UgcGxheSBpdCBzYWZlIGFuZCBhc3N1bWUgb3duZXJsZXNzIHN0YXRlXG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRjb25zdCBwcmV2X293bmVycyA9IHByZXYudj8uW1NUQVRFX1NZTUJPTF9NRVRBREFUQV0/Lm93bmVycztcblx0XHRcdG1ldGFkYXRhLm93bmVycyA9IHByZXZfb3duZXJzID8gbmV3IFNldChwcmV2X293bmVycykgOiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXRhZGF0YS5vd25lcnMgPVxuXHRcdFx0XHRwYXJlbnQgPT09IG51bGxcblx0XHRcdFx0XHQ/IGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsXG5cdFx0XHRcdFx0XHQ/IG5ldyBTZXQoW2NvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uXSlcblx0XHRcdFx0XHRcdDogbnVsbFxuXHRcdFx0XHRcdDogbmV3IFNldCgpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgUHJveHkoLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSksIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShfLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHdlIGRpc2FsbG93IG5vbi1iYXNpYyBkZXNjcmlwdG9ycywgYmVjYXVzZSB1bmxlc3MgdGhleSBhcmUgYXBwbGllZCB0byB0aGVcblx0XHRcdFx0Ly8gdGFyZ2V0IG9iamVjdCDigJQgd2hpY2ggd2UgYXZvaWQsIHNvIHRoYXQgc3RhdGUgY2FuIGJlIGZvcmtlZCDigJQgd2Ugd2lsbCBydW5cblx0XHRcdFx0Ly8gYWZvdWwgb2YgdGhlIHZhcmlvdXMgaW52YXJpYW50c1xuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9Qcm94eS9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjaW52YXJpYW50c1xuXHRcdFx0XHRlLnN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cyA9IHNvdXJjZShkZXNjcmlwdG9yLnZhbHVlLCBzdGFjayk7XG5cdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0KHMsIHByb3h5KGRlc2NyaXB0b3IudmFsdWUsIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdoZW4gd29ya2luZyB3aXRoIGFycmF5cywgd2UgbmVlZCB0byBhbHNvIGVuc3VyZSB3ZSB1cGRhdGUgdGhlIGxlbmd0aCB3aGVuIHJlbW92aW5nXG5cdFx0XHRcdC8vIGFuIGluZGV4ZWQgcHJvcGVydHlcblx0XHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGxzID0gLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHNvdXJjZXMuZ2V0KCdsZW5ndGgnKSk7XG5cdFx0XHRcdFx0dmFyIG4gPSBOdW1iZXIocHJvcCk7XG5cblx0XHRcdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSAmJiBuIDwgbHMudikge1xuXHRcdFx0XHRcdFx0c2V0KGxzLCBuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0KHMsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHR1cGRhdGVfdmVyc2lvbih2ZXJzaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHRpZiAoREVWICYmIHByb3AgPT09IFNUQVRFX1NZTUJPTF9NRVRBREFUQSkge1xuXHRcdFx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcm9wID09PSBTVEFURV9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGV4aXN0cyA9IHByb3AgaW4gdGFyZ2V0O1xuXG5cdFx0XHQvLyBjcmVhdGUgYSBzb3VyY2UsIGJ1dCBvbmx5IGlmIGl0J3MgYW4gb3duIHByb3BlcnR5IGFuZCBub3QgYSBwcm90b3R5cGUgcHJvcGVydHlcblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQgJiYgKCFleGlzdHMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKSB7XG5cdFx0XHRcdHMgPSBzb3VyY2UocHJveHkoZXhpc3RzID8gdGFyZ2V0W3Byb3BdIDogVU5JTklUSUFMSVpFRCwgbWV0YWRhdGEpLCBzdGFjayk7XG5cdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciB2ID0gZ2V0KHMpO1xuXG5cdFx0XHRcdC8vIEluIGNhc2Ugb2Ygc29tZXRoaW5nIGxpa2UgYGZvbyA9IGJhci5tYXAoLi4uKWAsIGZvbyB3b3VsZCBoYXZlIG93bmVyc2hpcFxuXHRcdFx0XHQvLyBvZiB0aGUgYXJyYXkgaXRzZWxmLCB3aGlsZSB0aGUgaW5kaXZpZHVhbCBpdGVtcyB3b3VsZCBoYXZlIG93bmVyc2hpcFxuXHRcdFx0XHQvLyBvZiB0aGUgY29tcG9uZW50IHRoYXQgY3JlYXRlZCBiYXIuIFRoYXQgbWVhbnMgaWYgd2UgbGF0ZXIgZG8gYGZvb1swXS5iYXogPSA0MmAsXG5cdFx0XHRcdC8vIHdlIGNvdWxkIGdldCBhIGZhbHNlLXBvc2l0aXZlIG93bmVyc2hpcCB2aW9sYXRpb24sIHNpbmNlIHRoZSB0d28gcHJveGllc1xuXHRcdFx0XHQvLyBhcmUgbm90IGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHZpYSB0aGUgcGFyZW50IG1ldGFkYXRhIHJlbGF0aW9uc2hpcC5cblx0XHRcdFx0Ly8gRm9yIHRoaXMgcmVhc29uLCB3ZSBuZWVkIHRvIHdpZGVuIHRoZSBvd25lcnNoaXAgb2YgdGhlIGNoaWxkcmVuXG5cdFx0XHRcdC8vIHVwb24gYWNjZXNzIHdoZW4gd2UgZGV0ZWN0IHRoZXkgYXJlIG5vdCBjb25uZWN0ZWQuXG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge1Byb3h5TWV0YWRhdGEgfCB1bmRlZmluZWR9ICovXG5cdFx0XHRcdFx0dmFyIHByb3BfbWV0YWRhdGEgPSB2Py5bU1RBVEVfU1lNQk9MX01FVEFEQVRBXTtcblx0XHRcdFx0XHRpZiAocHJvcF9tZXRhZGF0YSAmJiBwcm9wX21ldGFkYXRhPy5wYXJlbnQgIT09IG1ldGFkYXRhKSB7XG5cdFx0XHRcdFx0XHR3aWRlbl9vd25lcnNoaXAobWV0YWRhdGEsIHByb3BfbWV0YWRhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2ID09PSBVTklOSVRJQUxJWkVEID8gdW5kZWZpbmVkIDogdjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXHRcdH0sXG5cblx0XHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChkZXNjcmlwdG9yICYmICd2YWx1ZScgaW4gZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHRpZiAocykgZGVzY3JpcHRvci52YWx1ZSA9IGdldChzKTtcblx0XHRcdH0gZWxzZSBpZiAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlPy52O1xuXG5cdFx0XHRcdGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0fSxcblxuXHRcdGhhcyh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGlmIChERVYgJiYgcHJvcCA9PT0gU1RBVEVfU1lNQk9MX01FVEFEQVRBKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJvcCA9PT0gU1RBVEVfU1lNQk9MKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGhhcyA9IChzICE9PSB1bmRlZmluZWQgJiYgcy52ICE9PSBVTklOSVRJQUxJWkVEKSB8fCBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHMgIT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAoIWhhcyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHMgPSBzb3VyY2UoaGFzID8gcHJveHkodGFyZ2V0W3Byb3BdLCBtZXRhZGF0YSkgOiBVTklOSVRJQUxJWkVELCBzdGFjayk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXQocyk7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFzO1xuXHRcdH0sXG5cblx0XHRzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIHZhcmlhYmxlLmxlbmd0aCA9IHZhbHVlIC0+IGNsZWFyIGFsbCBzaWduYWxzIHdpdGggaW5kZXggPj0gdmFsdWVcblx0XHRcdGlmIChpc19wcm94aWVkX2FycmF5ICYmIHByb3AgPT09ICdsZW5ndGgnKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB2YWx1ZTsgaSA8IC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovIChzKS52OyBpICs9IDEpIHtcblx0XHRcdFx0XHR2YXIgb3RoZXJfcyA9IHNvdXJjZXMuZ2V0KGkgKyAnJyk7XG5cdFx0XHRcdFx0aWYgKG90aGVyX3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2V0KG90aGVyX3MsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaSBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBpdGVtIGV4aXN0cyBpbiB0aGUgb3JpZ2luYWwsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdW5pbml0aWFsaXplZCBzb3VyY2UsXG5cdFx0XHRcdFx0XHQvLyBlbHNlIGEgbGF0ZXIgcmVhZCBvZiB0aGUgcHJvcGVydHkgd291bGQgcmVzdWx0IGluIGEgc291cmNlIGJlaW5nIGNyZWF0ZWQgd2l0aFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBpdGVtIGF0IHRoYXQgaW5kZXguXG5cdFx0XHRcdFx0XHRvdGhlcl9zID0gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKTtcblx0XHRcdFx0XHRcdHNvdXJjZXMuc2V0KGkgKyAnJywgb3RoZXJfcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgeWV0IGNyZWF0ZWQgYSBzb3VyY2UgZm9yIHRoaXMgcHJvcGVydHksIHdlIG5lZWQgdG8gZW5zdXJlXG5cdFx0XHQvLyB3ZSBkbyBzbyBvdGhlcndpc2UgaWYgd2UgcmVhZCBpdCBsYXRlciwgdGhlbiB0aGUgd3JpdGUgd29uJ3QgYmUgdHJhY2tlZCBhbmRcblx0XHRcdC8vIHRoZSBoZXVyaXN0aWNzIG9mIGVmZmVjdHMgd2lsbCBiZSBkaWZmZXJlbnQgdnMgaWYgd2UgaGFkIHJlYWQgdGhlIHByb3hpZWRcblx0XHRcdC8vIG9iamVjdCBwcm9wZXJ0eSBiZWZvcmUgd3JpdGluZyB0byB0aGF0IHByb3BlcnR5LlxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoIWhhcyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkge1xuXHRcdFx0XHRcdHMgPSBzb3VyY2UodW5kZWZpbmVkLCBzdGFjayk7XG5cdFx0XHRcdFx0c2V0KHMsIHByb3h5KHZhbHVlLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYXMgPSBzLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cdFx0XHRcdHNldChzLCBwcm94eSh2YWx1ZSwgbWV0YWRhdGEpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHQvKiogQHR5cGUge1Byb3h5TWV0YWRhdGEgfCB1bmRlZmluZWR9ICovXG5cdFx0XHRcdHZhciBwcm9wX21ldGFkYXRhID0gdmFsdWU/LltTVEFURV9TWU1CT0xfTUVUQURBVEFdO1xuXHRcdFx0XHRpZiAocHJvcF9tZXRhZGF0YSAmJiBwcm9wX21ldGFkYXRhPy5wYXJlbnQgIT09IG1ldGFkYXRhKSB7XG5cdFx0XHRcdFx0d2lkZW5fb3duZXJzaGlwKG1ldGFkYXRhLCBwcm9wX21ldGFkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGVja19vd25lcnNoaXAobWV0YWRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3IHZhbHVlIGJlZm9yZSB1cGRhdGluZyBhbnkgc2lnbmFscyBzbyB0aGF0IGFueSBsaXN0ZW5lcnMgZ2V0IHRoZSBuZXcgdmFsdWVcblx0XHRcdGlmIChkZXNjcmlwdG9yPy5zZXQpIHtcblx0XHRcdFx0ZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWhhcykge1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG11dGF0ZWQgYW4gYXJyYXkgZGlyZWN0bHksIHdlIG1pZ2h0IG5lZWQgdG9cblx0XHRcdFx0Ly8gc2lnbmFsIHRoYXQgbGVuZ3RoIGhhcyBhbHNvIGNoYW5nZWQuIERvIGl0IGJlZm9yZSB1cGRhdGluZyBtZXRhZGF0YVxuXHRcdFx0XHQvLyB0byBlbnN1cmUgdGhhdCBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXkgYXMgYSByZXN1bHQgb2YgYSBtZXRhZGF0YSB1cGRhdGVcblx0XHRcdFx0Ly8gd2lsbCBub3QgY2F1c2UgdGhlIGxlbmd0aCB0byBiZSBvdXQgb2Ygc3luYy5cblx0XHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGxzID0gLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHNvdXJjZXMuZ2V0KCdsZW5ndGgnKSk7XG5cdFx0XHRcdFx0dmFyIG4gPSBOdW1iZXIocHJvcCk7XG5cblx0XHRcdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSAmJiBuID49IGxzLnYpIHtcblx0XHRcdFx0XHRcdHNldChscywgbiArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVwZGF0ZV92ZXJzaW9uKHZlcnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0dmFyIG93bl9rZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZmlsdGVyKChrZXkpID0+IHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KGtleSk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBba2V5LCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdFx0aWYgKHNvdXJjZS52ICE9PSBVTklOSVRJQUxJWkVEICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHRvd25fa2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG93bl9rZXlzO1xuXHRcdH0sXG5cblx0XHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRcdGUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NvdXJjZTxudW1iZXI+fSBzaWduYWxcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlX3ZlcnNpb24oc2lnbmFsLCBkID0gMSkge1xuXHRzZXQoc2lnbmFsLCBzaWduYWwudiArIGQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Byb3hpZWRfdmFsdWUodmFsdWUpIHtcblx0aWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU1RBVEVfU1lNQk9MIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlW1NUQVRFX1NZTUJPTF07XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdHJldHVybiBPYmplY3QuaXMoZ2V0X3Byb3hpZWRfdmFsdWUoYSksIGdldF9wcm94aWVkX3ZhbHVlKGIpKTtcbn1cbiIsImltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0X3Byb3hpZWRfdmFsdWUgfSBmcm9tICcuLi9wcm94eS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpIHtcblx0Y29uc3QgYXJyYXlfcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXHQvLyBUaGUgUkVQTCBlbmRzIHVwIGhlcmUgb3ZlciBhbmQgb3ZlciwgYW5kIHRoaXMgcHJldmVudHMgaXQgZnJvbSBhZGRpbmcgbW9yZSBhbmQgbW9yZSBwYXRjaGVzXG5cdC8vIG9mIHRoZSBzYW1lIGtpbmQgdG8gdGhlIHByb3RvdHlwZSwgd2hpY2ggd291bGQgc2xvdyBkb3duIGV2ZXJ5dGhpbmcgb3ZlciB0aW1lLlxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGNsZWFudXAgPSBBcnJheS5fX3N2ZWx0ZV9jbGVhbnVwO1xuXHRpZiAoY2xlYW51cCkge1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXG5cdGNvbnN0IHsgaW5kZXhPZiwgbGFzdEluZGV4T2YsIGluY2x1ZGVzIH0gPSBhcnJheV9wcm90b3R5cGU7XG5cblx0YXJyYXlfcHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdGNvbnN0IGluZGV4ID0gaW5kZXhPZi5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXgpO1xuXG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IGZyb21faW5kZXggPz8gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkuaW5kZXhPZiguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0YXJyYXlfcHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHQvLyB3ZSBuZWVkIHRvIHNwZWNpZnkgdGhpcy5sZW5ndGggLSAxIGJlY2F1c2UgaXQncyBwcm9iYWJseSB1c2luZyBzb21ldGhpbmcgbGlrZVxuXHRcdC8vIGBhcmd1bWVudHNgIGluc2lkZSBzbyBwYXNzaW5nIHVuZGVmaW5lZCBpcyBkaWZmZXJlbnQgZnJvbSBub3QgcGFzc2luZyBhbnl0aGluZ1xuXHRcdGNvbnN0IGluZGV4ID0gbGFzdEluZGV4T2YuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4ID8/IHRoaXMubGVuZ3RoIC0gMSk7XG5cblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSAoZnJvbV9pbmRleCA/PyB0aGlzLmxlbmd0aCAtIDEpOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkubGFzdEluZGV4T2YoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGFycmF5X3Byb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Y29uc3QgaGFzID0gaW5jbHVkZXMuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4KTtcblxuXHRcdGlmICghaGFzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkuaW5jbHVkZXMoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhcztcblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdEFycmF5Ll9fc3ZlbHRlX2NsZWFudXAgPSAoKSA9PiB7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmluZGV4T2YgPSBpbmRleE9mO1xuXHRcdGFycmF5X3Byb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuXHRcdGFycmF5X3Byb3RvdHlwZS5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtib29sZWFufSBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpY3RfZXF1YWxzKGEsIGIsIGVxdWFsID0gdHJ1ZSkge1xuXHQvLyB0cnktY2F0Y2ggbmVlZGVkIGJlY2F1c2UgdGhpcyB0cmllcyB0byByZWFkIHByb3BlcnRpZXMgb2YgYGFgIGFuZCBgYmAsXG5cdC8vIHdoaWNoIGNvdWxkIGJlIGRpc2FsbG93ZWQgZm9yIGV4YW1wbGUgaW4gYSBzZWN1cmUgY29udGV4dFxuXHR0cnkge1xuXHRcdGlmICgoYSA9PT0gYikgIT09IChnZXRfcHJveGllZF92YWx1ZShhKSA9PT0gZ2V0X3Byb3hpZWRfdmFsdWUoYikpKSB7XG5cdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKGVxdWFsID8gJz09PScgOiAnIT09Jyk7XG5cdFx0fVxuXHR9IGNhdGNoIHt9XG5cblx0cmV0dXJuIChhID09PSBiKSA9PT0gZXF1YWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVxdWFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiLCBlcXVhbCA9IHRydWUpIHtcblx0aWYgKChhID09IGIpICE9PSAoZ2V0X3Byb3hpZWRfdmFsdWUoYSkgPT0gZ2V0X3Byb3hpZWRfdmFsdWUoYikpKSB7XG5cdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChlcXVhbCA/ICc9PScgOiAnIT0nKTtcblx0fVxuXG5cdHJldHVybiAoYSA9PSBiKSA9PT0gZXF1YWw7XG59XG4iLCIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSB9IGZyb20gJy4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaW5pdF9hcnJheV9wcm90b3R5cGVfd2FybmluZ3MgfSBmcm9tICcuLi9kZXYvZXF1YWxpdHkuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vLyBleHBvcnQgdGhlc2UgZm9yIHJlZmVyZW5jZSBpbiB0aGUgY29tcGlsZWQgY29kZSwgbWFraW5nIGdsb2JhbCBuYW1lIGRlZHVwbGljYXRpb24gdW5uZWNlc3Nhcnlcbi8qKiBAdHlwZSB7V2luZG93fSAqL1xuZXhwb3J0IHZhciAkd2luZG93O1xuXG4vKiogQHR5cGUge0RvY3VtZW50fSAqL1xuZXhwb3J0IHZhciAkZG9jdW1lbnQ7XG5cbi8qKiBAdHlwZSB7KCkgPT4gTm9kZSB8IG51bGx9ICovXG52YXIgZmlyc3RfY2hpbGRfZ2V0dGVyO1xuLyoqIEB0eXBlIHsoKSA9PiBOb2RlIHwgbnVsbH0gKi9cbnZhciBuZXh0X3NpYmxpbmdfZ2V0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlc2UgbGF6aWx5IHRvIGF2b2lkIGlzc3VlcyB3aGVuIHVzaW5nIHRoZSBydW50aW1lIGluIGEgc2VydmVyIGNvbnRleHRcbiAqIHdoZXJlIHRoZXNlIGdsb2JhbHMgYXJlIG5vdCBhdmFpbGFibGUgd2hpbGUgYXZvaWRpbmcgYSBzZXBhcmF0ZSBzZXJ2ZXIgZW50cnkgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfb3BlcmF0aW9ucygpIHtcblx0aWYgKCR3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdCR3aW5kb3cgPSB3aW5kb3c7XG5cdCRkb2N1bWVudCA9IGRvY3VtZW50O1xuXG5cdHZhciBlbGVtZW50X3Byb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuXHR2YXIgbm9kZV9wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdGZpcnN0X2NoaWxkX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnZmlyc3RDaGlsZCcpLmdldDtcblx0Ly8gQHRzLWlnbm9yZVxuXHRuZXh0X3NpYmxpbmdfZ2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3Iobm9kZV9wcm90b3R5cGUsICduZXh0U2libGluZycpLmdldDtcblxuXHQvLyB0aGUgZm9sbG93aW5nIGFzc2lnbm1lbnRzIGltcHJvdmUgcGVyZiBvZiBsb29rdXBzIG9uIERPTSBub2Rlc1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnRfcHJvdG90eXBlLl9fY2xpY2sgPSB1bmRlZmluZWQ7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudF9wcm90b3R5cGUuX19jbGFzc05hbWUgPSAnJztcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX2F0dHJpYnV0ZXMgPSBudWxsO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnRfcHJvdG90eXBlLl9fc3R5bGVzID0gbnVsbDtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX2UgPSB1bmRlZmluZWQ7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRUZXh0LnByb3RvdHlwZS5fX3QgPSB1bmRlZmluZWQ7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX3N2ZWx0ZV9tZXRhID0gbnVsbDtcblxuXHRcdGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3RleHQodmFsdWUgPSAnJykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Tm9kZX0gTlxuICogQHBhcmFtIHtOfSBub2RlXG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbi8qQF9fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9maXJzdF9jaGlsZChub2RlKSB7XG5cdHJldHVybiBmaXJzdF9jaGlsZF9nZXR0ZXIuY2FsbChub2RlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfbmV4dF9zaWJsaW5nKG5vZGUpIHtcblx0cmV0dXJuIG5leHRfc2libGluZ19nZXR0ZXIuY2FsbChub2RlKTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBpc190ZXh0XG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZChub2RlLCBpc190ZXh0KSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0cmV0dXJuIGdldF9maXJzdF9jaGlsZChub2RlKTtcblx0fVxuXG5cdHZhciBjaGlsZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGh5ZHJhdGVfbm9kZSkpO1xuXG5cdC8vIENoaWxkIGNhbiBiZSBudWxsIGlmIHdlIGhhdmUgYW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIGNoaWxkLCBsaWtlIGA8cD57dGV4dH08L3A+YCwgd2hlcmUgYHRleHRgIGlzIGVtcHR5XG5cdGlmIChjaGlsZCA9PT0gbnVsbCkge1xuXHRcdGNoaWxkID0gaHlkcmF0ZV9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9IGVsc2UgaWYgKGlzX3RleHQgJiYgY2hpbGQubm9kZVR5cGUgIT09IDMpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0Y2hpbGQ/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZCk7XG5cdHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBUZW1wbGF0ZU5vZGVbXX0gZnJhZ21lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RfY2hpbGQoZnJhZ21lbnQsIGlzX3RleHQpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHQvLyB3aGVuIG5vdCBoeWRyYXRpbmcsIGBmcmFnbWVudGAgaXMgYSBgRG9jdW1lbnRGcmFnbWVudGAgKHRoZSByZXN1bHQgb2YgY2FsbGluZyBgb3Blbl9mcmFnYClcblx0XHR2YXIgZmlyc3QgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZnJhZ21lbnQpKSk7XG5cblx0XHQvLyBUT0RPIHByZXZlbnQgdXNlciBjb21tZW50cyB3aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBwcmVzZXJ2ZUNvbW1lbnRzIGlzIHRydWVcblx0XHRpZiAoZmlyc3QgaW5zdGFuY2VvZiBDb21tZW50ICYmIGZpcnN0LmRhdGEgPT09ICcnKSByZXR1cm4gZ2V0X25leHRfc2libGluZyhmaXJzdCk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH1cblxuXHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUg4oCUIHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgaHlkcmF0ZV9ub2RlPy5ub2RlVHlwZSAhPT0gMykge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblxuXHRcdGh5ZHJhdGVfbm9kZT8uYmVmb3JlKHRleHQpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2libGluZyhub2RlLCBjb3VudCA9IDEsIGlzX3RleHQgPSBmYWxzZSkge1xuXHRsZXQgbmV4dF9zaWJsaW5nID0gaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZTtcblx0dmFyIGxhc3Rfc2libGluZztcblxuXHR3aGlsZSAoY291bnQtLSkge1xuXHRcdGxhc3Rfc2libGluZyA9IG5leHRfc2libGluZztcblx0XHRuZXh0X3NpYmxpbmcgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobmV4dF9zaWJsaW5nKSk7XG5cdH1cblxuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBuZXh0X3NpYmxpbmc7XG5cdH1cblxuXHR2YXIgdHlwZSA9IG5leHRfc2libGluZz8ubm9kZVR5cGU7XG5cblx0Ly8gaWYgYSBzaWJsaW5nIHtleHByZXNzaW9ufSBpcyBlbXB0eSBkdXJpbmcgU1NSLCB0aGVyZSBtaWdodCBiZSBub1xuXHQvLyB0ZXh0IG5vZGUgdG8gaHlkcmF0ZSDigJQgd2UgbXVzdCB0aGVyZWZvcmUgY3JlYXRlIG9uZVxuXHRpZiAoaXNfdGV4dCAmJiB0eXBlICE9PSAzKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdC8vIElmIHRoZSBuZXh0IHNpYmxpbmcgaXMgYG51bGxgIGFuZCB3ZSdyZSBoYW5kbGluZyB0ZXh0IHRoZW4gaXQncyBiZWNhdXNlXG5cdFx0Ly8gdGhlIFNTUiBjb250ZW50IHdhcyBlbXB0eSBmb3IgdGhlIHRleHQsIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgYSBuZXcgdGV4dFxuXHRcdC8vIG5vZGUgYW5kIGluc2VydCBpdCBhZnRlciB0aGUgbGFzdCBzaWJsaW5nXG5cdFx0aWYgKG5leHRfc2libGluZyA9PT0gbnVsbCkge1xuXHRcdFx0bGFzdF9zaWJsaW5nPy5hZnRlcih0ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV4dF9zaWJsaW5nLmJlZm9yZSh0ZXh0KTtcblx0XHR9XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHNldF9oeWRyYXRlX25vZGUobmV4dF9zaWJsaW5nKTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dF9zaWJsaW5nKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcl90ZXh0X2NvbnRlbnQobm9kZSkge1xuXHRub2RlLnRleHRDb250ZW50ID0gJyc7XG59XG4iLCIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRERVNUUk9ZRUQsXG5cdERJUlRZLFxuXHRFRkZFQ1RfSEFTX0RFUklWRUQsXG5cdE1BWUJFX0RJUlRZLFxuXHRVTk9XTkVEXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHJlbW92ZV9yZWFjdGlvbnMsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHRza2lwX3JlYWN0aW9uLFxuXHR1cGRhdGVfcmVhY3Rpb24sXG5cdGluY3JlbWVudF92ZXJzaW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0Y29tcG9uZW50X2NvbnRleHRcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlcXVhbHMsIHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBkZXN0cm95X2VmZmVjdCB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBpbnNwZWN0X2VmZmVjdHMsIHNldF9pbnNwZWN0X2VmZmVjdHMgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrIH0gZnJvbSAnLi4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKGZuKSB7XG5cdHZhciBmbGFncyA9IERFUklWRUQgfCBESVJUWTtcblxuXHRpZiAoYWN0aXZlX2VmZmVjdCA9PT0gbnVsbCkge1xuXHRcdGZsYWdzIHw9IFVOT1dORUQ7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2luY2UgZGVyaXZlZHMgYXJlIGV2YWx1YXRlZCBsYXppbHksIGFueSBlZmZlY3RzIGNyZWF0ZWQgaW5zaWRlIHRoZW0gYXJlXG5cdFx0Ly8gY3JlYXRlZCB0b28gbGF0ZSB0byBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IGVmZmVjdCBpcyBhZGRlZCB0byB0aGUgdHJlZVxuXHRcdGFjdGl2ZV9lZmZlY3QuZiB8PSBFRkZFQ1RfSEFTX0RFUklWRUQ7XG5cdH1cblxuXHR2YXIgcGFyZW50X2Rlcml2ZWQgPVxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMFxuXHRcdFx0PyAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChhY3RpdmVfcmVhY3Rpb24pXG5cdFx0XHQ6IG51bGw7XG5cblx0LyoqIEB0eXBlIHtEZXJpdmVkPFY+fSAqL1xuXHRjb25zdCBzaWduYWwgPSB7XG5cdFx0Y2hpbGRyZW46IG51bGwsXG5cdFx0Y3R4OiBjb21wb25lbnRfY29udGV4dCxcblx0XHRkZXBzOiBudWxsLFxuXHRcdGVxdWFscyxcblx0XHRmOiBmbGFncyxcblx0XHRmbixcblx0XHRyZWFjdGlvbnM6IG51bGwsXG5cdFx0djogLyoqIEB0eXBlIHtWfSAqLyAobnVsbCksXG5cdFx0dmVyc2lvbjogMCxcblx0XHRwYXJlbnQ6IHBhcmVudF9kZXJpdmVkID8/IGFjdGl2ZV9lZmZlY3Rcblx0fTtcblxuXHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0c2lnbmFsLmNyZWF0ZWQgPSBnZXRfc3RhY2soJ0NyZWF0ZWRBdCcpO1xuXHR9XG5cblx0aWYgKHBhcmVudF9kZXJpdmVkICE9PSBudWxsKSB7XG5cdFx0KHBhcmVudF9kZXJpdmVkLmNoaWxkcmVuID8/PSBbXSkucHVzaChzaWduYWwpO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfc2FmZV9lcXVhbChmbikge1xuXHRjb25zdCBzaWduYWwgPSBkZXJpdmVkKGZuKTtcblx0c2lnbmFsLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3lfZGVyaXZlZF9jaGlsZHJlbihkZXJpdmVkKSB7XG5cdHZhciBjaGlsZHJlbiA9IGRlcml2ZWQuY2hpbGRyZW47XG5cblx0aWYgKGNoaWxkcmVuICE9PSBudWxsKSB7XG5cdFx0ZGVyaXZlZC5jaGlsZHJlbiA9IG51bGw7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmICgoY2hpbGQuZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHRcdGRlc3Ryb3lfZGVyaXZlZCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChjaGlsZCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChjaGlsZCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgdXBkYXRpbmcgZGVyaXZlZHMsIHVzZWQgdG8gZGV0ZWN0IGluZmluaXRlIHJlY3Vyc2lvblxuICogaW4gZGV2IG1vZGUgYW5kIHByb3ZpZGUgYSBuaWNlciBlcnJvciB0aGFuICd0b28gbXVjaCByZWN1cnNpb24nXG4gKiBAdHlwZSB7RGVyaXZlZFtdfVxuICovXG5sZXQgc3RhY2sgPSBbXTtcblxuLyoqXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHtFZmZlY3QgfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRfZGVyaXZlZF9wYXJlbnRfZWZmZWN0KGRlcml2ZWQpIHtcblx0dmFyIHBhcmVudCA9IGRlcml2ZWQucGFyZW50O1xuXHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0aWYgKChwYXJlbnQuZiAmIERFUklWRUQpID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChwYXJlbnQpO1xuXHRcdH1cblx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZV9kZXJpdmVkKGRlcml2ZWQpIHtcblx0dmFyIHZhbHVlO1xuXHR2YXIgcHJldl9hY3RpdmVfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHRzZXRfYWN0aXZlX2VmZmVjdChnZXRfZGVyaXZlZF9wYXJlbnRfZWZmZWN0KGRlcml2ZWQpKTtcblxuXHRpZiAoREVWKSB7XG5cdFx0bGV0IHByZXZfaW5zcGVjdF9lZmZlY3RzID0gaW5zcGVjdF9lZmZlY3RzO1xuXHRcdHNldF9pbnNwZWN0X2VmZmVjdHMobmV3IFNldCgpKTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHN0YWNrLmluY2x1ZGVzKGRlcml2ZWQpKSB7XG5cdFx0XHRcdGUuZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGYoKTtcblx0XHRcdH1cblxuXHRcdFx0c3RhY2sucHVzaChkZXJpdmVkKTtcblxuXHRcdFx0ZGVzdHJveV9kZXJpdmVkX2NoaWxkcmVuKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0XHRzZXRfaW5zcGVjdF9lZmZlY3RzKHByZXZfaW5zcGVjdF9lZmZlY3RzKTtcblx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnkge1xuXHRcdFx0ZGVzdHJveV9kZXJpdmVkX2NoaWxkcmVuKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZSA9IGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKTtcblx0dmFyIHN0YXR1cyA9XG5cdFx0KHNraXBfcmVhY3Rpb24gfHwgKGRlcml2ZWQuZiAmIFVOT1dORUQpICE9PSAwKSAmJiBkZXJpdmVkLmRlcHMgIT09IG51bGwgPyBNQVlCRV9ESVJUWSA6IENMRUFOO1xuXG5cdHNldF9zaWduYWxfc3RhdHVzKGRlcml2ZWQsIHN0YXR1cyk7XG5cblx0aWYgKCFkZXJpdmVkLmVxdWFscyh2YWx1ZSkpIHtcblx0XHRkZXJpdmVkLnYgPSB2YWx1ZTtcblx0XHRkZXJpdmVkLnZlcnNpb24gPSBpbmNyZW1lbnRfdmVyc2lvbigpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZGVyaXZlZChkZXJpdmVkKSB7XG5cdGRlc3Ryb3lfZGVyaXZlZF9jaGlsZHJlbihkZXJpdmVkKTtcblx0cmVtb3ZlX3JlYWN0aW9ucyhkZXJpdmVkLCAwKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZGVyaXZlZCwgREVTVFJPWUVEKTtcblxuXHRkZXJpdmVkLnYgPSBkZXJpdmVkLmNoaWxkcmVuID0gZGVyaXZlZC5kZXBzID0gZGVyaXZlZC5jdHggPSBkZXJpdmVkLnJlYWN0aW9ucyA9IG51bGw7XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIENvbXBvbmVudENvbnRleHRMZWdhY3ksIERlcml2ZWQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlLCBUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRjaGVja19kaXJ0aW5lc3MsXG5cdGNvbXBvbmVudF9jb250ZXh0LFxuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0Z2V0LFxuXHRpc19kZXN0cm95aW5nX2VmZmVjdCxcblx0aXNfZmx1c2hpbmdfZWZmZWN0LFxuXHRyZW1vdmVfcmVhY3Rpb25zLFxuXHRzY2hlZHVsZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCxcblx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVudHJhY2ssXG5cdHNraXBfcmVhY3Rpb25cbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQge1xuXHRESVJUWSxcblx0QlJBTkNIX0VGRkVDVCxcblx0UkVOREVSX0VGRkVDVCxcblx0RUZGRUNULFxuXHRERVNUUk9ZRUQsXG5cdElORVJULFxuXHRFRkZFQ1RfUkFOLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRFRkZFQ1RfVFJBTlNQQVJFTlQsXG5cdERFUklWRUQsXG5cdFVOT1dORUQsXG5cdENMRUFOLFxuXHRJTlNQRUNUX0VGRkVDVCxcblx0SEVBRF9FRkZFQ1QsXG5cdE1BWUJFX0RJUlRZLFxuXHRFRkZFQ1RfSEFTX0RFUklWRURcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vZG9tL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgZGVzdHJveV9kZXJpdmVkIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsnJGVmZmVjdCcgfCAnJGVmZmVjdC5wcmUnIHwgJyRpbnNwZWN0J30gcnVuZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWZmZWN0KHJ1bmUpIHtcblx0aWYgKGFjdGl2ZV9lZmZlY3QgPT09IG51bGwgJiYgYWN0aXZlX3JlYWN0aW9uID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3Rfb3JwaGFuKHJ1bmUpO1xuXHR9XG5cblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBVTk9XTkVEKSAhPT0gMCkge1xuXHRcdGUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpO1xuXHR9XG5cblx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0ZS5lZmZlY3RfaW5fdGVhcmRvd24ocnVuZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdH0gcGFyZW50X2VmZmVjdFxuICovXG5mdW5jdGlvbiBwdXNoX2VmZmVjdChlZmZlY3QsIHBhcmVudF9lZmZlY3QpIHtcblx0dmFyIHBhcmVudF9sYXN0ID0gcGFyZW50X2VmZmVjdC5sYXN0O1xuXHRpZiAocGFyZW50X2xhc3QgPT09IG51bGwpIHtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBwYXJlbnRfZWZmZWN0LmZpcnN0ID0gZWZmZWN0O1xuXHR9IGVsc2Uge1xuXHRcdHBhcmVudF9sYXN0Lm5leHQgPSBlZmZlY3Q7XG5cdFx0ZWZmZWN0LnByZXYgPSBwYXJlbnRfbGFzdDtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBlZmZlY3Q7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHBhcmFtIHtudWxsIHwgKCgpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCkpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHB1c2hcbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9lZmZlY3QodHlwZSwgZm4sIHN5bmMsIHB1c2ggPSB0cnVlKSB7XG5cdHZhciBpc19yb290ID0gKHR5cGUgJiBST09UX0VGRkVDVCkgIT09IDA7XG5cdHZhciBwYXJlbnRfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHRpZiAoREVWKSB7XG5cdFx0Ly8gRW5zdXJlIHRoZSBwYXJlbnQgaXMgbmV2ZXIgYW4gaW5zcGVjdCBlZmZlY3Rcblx0XHR3aGlsZSAocGFyZW50X2VmZmVjdCAhPT0gbnVsbCAmJiAocGFyZW50X2VmZmVjdC5mICYgSU5TUEVDVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRwYXJlbnRfZWZmZWN0ID0gcGFyZW50X2VmZmVjdC5wYXJlbnQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3R9ICovXG5cdHZhciBlZmZlY3QgPSB7XG5cdFx0Y3R4OiBjb21wb25lbnRfY29udGV4dCxcblx0XHRkZXBzOiBudWxsLFxuXHRcdGRlcml2ZWRzOiBudWxsLFxuXHRcdG5vZGVzX3N0YXJ0OiBudWxsLFxuXHRcdG5vZGVzX2VuZDogbnVsbCxcblx0XHRmOiB0eXBlIHwgRElSVFksXG5cdFx0Zmlyc3Q6IG51bGwsXG5cdFx0Zm4sXG5cdFx0bGFzdDogbnVsbCxcblx0XHRuZXh0OiBudWxsLFxuXHRcdHBhcmVudDogaXNfcm9vdCA/IG51bGwgOiBwYXJlbnRfZWZmZWN0LFxuXHRcdHByZXY6IG51bGwsXG5cdFx0dGVhcmRvd246IG51bGwsXG5cdFx0dHJhbnNpdGlvbnM6IG51bGwsXG5cdFx0dmVyc2lvbjogMFxuXHR9O1xuXG5cdGlmIChERVYpIHtcblx0XHRlZmZlY3QuY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHR9XG5cblx0aWYgKHN5bmMpIHtcblx0XHR2YXIgcHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QgPSBpc19mbHVzaGluZ19lZmZlY3Q7XG5cblx0XHR0cnkge1xuXHRcdFx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCh0cnVlKTtcblx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdGVmZmVjdC5mIHw9IEVGRkVDVF9SQU47XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdHRocm93IGU7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9pc19mbHVzaGluZ19lZmZlY3QocHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChmbiAhPT0gbnVsbCkge1xuXHRcdHNjaGVkdWxlX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0Ly8gaWYgYW4gZWZmZWN0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG5vIERPTSBhbmQgbm8gdGVhcmRvd24gZnVuY3Rpb24sXG5cdC8vIGRvbid0IGJvdGhlciBhZGRpbmcgaXQgdG8gdGhlIGVmZmVjdCB0cmVlXG5cdHZhciBpbmVydCA9XG5cdFx0c3luYyAmJlxuXHRcdGVmZmVjdC5kZXBzID09PSBudWxsICYmXG5cdFx0ZWZmZWN0LmZpcnN0ID09PSBudWxsICYmXG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsICYmXG5cdFx0ZWZmZWN0LnRlYXJkb3duID09PSBudWxsICYmXG5cdFx0KGVmZmVjdC5mICYgRUZGRUNUX0hBU19ERVJJVkVEKSA9PT0gMDtcblxuXHRpZiAoIWluZXJ0ICYmICFpc19yb290ICYmIHB1c2gpIHtcblx0XHRpZiAocGFyZW50X2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0cHVzaF9lZmZlY3QoZWZmZWN0LCBwYXJlbnRfZWZmZWN0KTtcblx0XHR9XG5cblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGRlcml2ZWQsIGFkZCB0aGUgZWZmZWN0IHRoZXJlIHRvb1xuXHRcdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdChkZXJpdmVkLmNoaWxkcmVuID8/PSBbXSkucHVzaChlZmZlY3QpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3QudHJhY2tpbmcoKWBcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3RyYWNraW5nKCkge1xuXHRpZiAoYWN0aXZlX3JlYWN0aW9uID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBza2lwcGVkLCB0aGF0J3MgYmVjYXVzZSB3ZSdyZSBpbnNpZGUgYW4gdW5vd25lZFxuXHQvLyB0aGF0IGlzIG5vdCBiZWluZyB0cmFja2VkIGJ5IGFub3RoZXIgcmVhY3Rpb25cblx0cmV0dXJuICFza2lwX3JlYWN0aW9uO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlYXJkb3duKGZuKSB7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCwgbnVsbCwgZmFsc2UpO1xuXHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIENMRUFOKTtcblx0ZWZmZWN0LnRlYXJkb3duID0gZm47XG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3QoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfZWZmZWN0KGZuKSB7XG5cdHZhbGlkYXRlX2VmZmVjdCgnJGVmZmVjdCcpO1xuXG5cdC8vIE5vbi1uZXN0ZWQgYCRlZmZlY3QoLi4uKWAgaW4gYSBjb21wb25lbnQgc2hvdWxkIGJlIGRlZmVycmVkXG5cdC8vIHVudGlsIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZFxuXHR2YXIgZGVmZXIgPVxuXHRcdGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiZcblx0XHQoYWN0aXZlX2VmZmVjdC5mICYgQlJBTkNIX0VGRkVDVCkgIT09IDAgJiZcblx0XHRjb21wb25lbnRfY29udGV4dCAhPT0gbnVsbCAmJlxuXHRcdCFjb21wb25lbnRfY29udGV4dC5tO1xuXG5cdGlmIChERVYpIHtcblx0XHRkZWZpbmVfcHJvcGVydHkoZm4sICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICckZWZmZWN0J1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKGRlZmVyKSB7XG5cdFx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHR9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cdFx0KGNvbnRleHQuZSA/Pz0gW10pLnB1c2goe1xuXHRcdFx0Zm4sXG5cdFx0XHRlZmZlY3Q6IGFjdGl2ZV9lZmZlY3QsXG5cdFx0XHRyZWFjdGlvbjogYWN0aXZlX3JlYWN0aW9uXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHNpZ25hbCA9IGVmZmVjdChmbik7XG5cdFx0cmV0dXJuIHNpZ25hbDtcblx0fVxufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnByZSguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfcHJlX2VmZmVjdChmbikge1xuXHR2YWxpZGF0ZV9lZmZlY3QoJyRlZmZlY3QucHJlJyk7XG5cdGlmIChERVYpIHtcblx0XHRkZWZpbmVfcHJvcGVydHkoZm4sICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICckZWZmZWN0LnByZSdcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gcmVuZGVyX2VmZmVjdChmbik7XG59XG5cbi8qKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuICovXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdF9lZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoSU5TUEVDVF9FRkZFQ1QsIGZuLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC5yb290KC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9yb290KGZuKSB7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUk9PVF9FRkZFQ1QsIGZuLCB0cnVlKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdH07XG59XG5cbi8qKlxuICogQW4gZWZmZWN0IHJvb3Qgd2hvc2UgY2hpbGRyZW4gY2FuIHRyYW5zaXRpb24gb3V0XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KG9wdGlvbnM/OiB7IG91dHJvPzogYm9vbGVhbiB9KSA9PiBQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X3Jvb3QoZm4pIHtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChST09UX0VGRkVDVCwgZm4sIHRydWUpO1xuXG5cdHJldHVybiAob3B0aW9ucyA9IHt9KSA9PiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWwpID0+IHtcblx0XHRcdGlmIChvcHRpb25zLm91dHJvKSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRcdGZ1bGZpbCh1bmRlZmluZWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdGZ1bGZpbCh1bmRlZmluZWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoRUZGRUNULCBmbiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkOiAuLmBcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBkZXBzXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcHJlX2VmZmVjdChkZXBzLCBmbikge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHQvKiogQHR5cGUge3sgZWZmZWN0OiBudWxsIHwgRWZmZWN0LCByYW46IGJvb2xlYW4gfX0gKi9cblx0dmFyIHRva2VuID0geyBlZmZlY3Q6IG51bGwsIHJhbjogZmFsc2UgfTtcblx0Y29udGV4dC5sLnIxLnB1c2godG9rZW4pO1xuXG5cdHRva2VuLmVmZmVjdCA9IHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGRlcHMoKTtcblxuXHRcdC8vIElmIHRoaXMgbGVnYWN5IHByZSBlZmZlY3QgaGFzIGFscmVhZHkgcnVuIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSByZXNldCwgdGhlblxuXHRcdC8vIGJhaWwgb3V0IHRvIGVtdWxhdGUgdGhlIHNhbWUgYmVoYXZpb3IuXG5cdFx0aWYgKHRva2VuLnJhbikgcmV0dXJuO1xuXG5cdFx0dG9rZW4ucmFuID0gdHJ1ZTtcblx0XHRzZXQoY29udGV4dC5sLnIyLCB0cnVlKTtcblx0XHR1bnRyYWNrKGZuKTtcblx0fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcHJlX2VmZmVjdF9yZXNldCgpIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKCFnZXQoY29udGV4dC5sLnIyKSkgcmV0dXJuO1xuXG5cdFx0Ly8gUnVuIGRpcnR5IGAkOmAgc3RhdGVtZW50c1xuXHRcdGZvciAodmFyIHRva2VuIG9mIGNvbnRleHQubC5yMSkge1xuXHRcdFx0dmFyIGVmZmVjdCA9IHRva2VuLmVmZmVjdDtcblxuXHRcdFx0Ly8gSWYgdGhlIGVmZmVjdCBpcyBDTEVBTiwgdGhlbiBtYWtlIGl0IE1BWUJFX0RJUlRZLiBUaGlzIGVuc3VyZXMgd2UgdHJhdmVyc2UgdGhyb3VnaFxuXHRcdFx0Ly8gdGhlIGVmZmVjdHMgZGVwZW5kZW5jaWVzIGFuZCBjb3JyZWN0bHkgZW5zdXJlIGVhY2ggZGVwZW5kZW5jeSBpcyB1cC10by1kYXRlLlxuXHRcdFx0aWYgKChlZmZlY3QuZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIE1BWUJFX0RJUlRZKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhlZmZlY3QpKSB7XG5cdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0dG9rZW4ucmFuID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29udGV4dC5sLnIyLnYgPSBmYWxzZTsgLy8gc2V0IGRpcmVjdGx5IHRvIGF2b2lkIHJlcnVubmluZyB0aGlzIGVmZmVjdFxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyX2VmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNULCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlX2VmZmVjdChmbikge1xuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAne2V4cHJlc3Npb259J1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBibG9jayhmbik7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrKGZuLCBmbGFncyA9IDApIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IEJMT0NLX0VGRkVDVCB8IGZsYWdzLCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwdXNoXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoKGZuLCBwdXNoID0gdHJ1ZSkge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNUIHwgQlJBTkNIX0VGRkVDVCwgZm4sIHRydWUsIHB1c2gpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCkge1xuXHR2YXIgdGVhcmRvd24gPSBlZmZlY3QudGVhcmRvd247XG5cdGlmICh0ZWFyZG93biAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QgPSBpc19kZXN0cm95aW5nX2VmZmVjdDtcblx0XHRjb25zdCBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHR0cnkge1xuXHRcdFx0dGVhcmRvd24uY2FsbChudWxsKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QpO1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdF9kZXJpdmVkcyhzaWduYWwpIHtcblx0dmFyIGRlcml2ZWRzID0gc2lnbmFsLmRlcml2ZWRzO1xuXG5cdGlmIChkZXJpdmVkcyAhPT0gbnVsbCkge1xuXHRcdHNpZ25hbC5kZXJpdmVkcyA9IG51bGw7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcml2ZWRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRkZXN0cm95X2Rlcml2ZWQoZGVyaXZlZHNbaV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtb3ZlX2RvbVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihzaWduYWwsIHJlbW92ZV9kb20gPSBmYWxzZSkge1xuXHR2YXIgZWZmZWN0ID0gc2lnbmFsLmZpcnN0O1xuXHRzaWduYWwuZmlyc3QgPSBzaWduYWwubGFzdCA9IG51bGw7XG5cblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0LCByZW1vdmVfZG9tKTtcblx0XHRlZmZlY3QgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IHNpZ25hbC5maXJzdDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblx0XHRpZiAoKGVmZmVjdC5mICYgQlJBTkNIX0VGRkVDVCkgPT09IDApIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0fVxuXHRcdGVmZmVjdCA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfZG9tXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdChlZmZlY3QsIHJlbW92ZV9kb20gPSB0cnVlKSB7XG5cdHZhciByZW1vdmVkID0gZmFsc2U7XG5cblx0aWYgKChyZW1vdmVfZG9tIHx8IChlZmZlY3QuZiAmIEhFQURfRUZGRUNUKSAhPT0gMCkgJiYgZWZmZWN0Lm5vZGVzX3N0YXJ0ICE9PSBudWxsKSB7XG5cdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHRcdHZhciBub2RlID0gZWZmZWN0Lm5vZGVzX3N0YXJ0O1xuXHRcdHZhciBlbmQgPSBlZmZlY3Qubm9kZXNfZW5kO1xuXG5cdFx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0XHRcdHZhciBuZXh0ID0gbm9kZSA9PT0gZW5kID8gbnVsbCA6IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cblx0XHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0XHRub2RlID0gbmV4dDtcblx0XHR9XG5cblx0XHRyZW1vdmVkID0gdHJ1ZTtcblx0fVxuXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCwgcmVtb3ZlX2RvbSAmJiAhcmVtb3ZlZCk7XG5cdGRlc3Ryb3lfZWZmZWN0X2Rlcml2ZWRzKGVmZmVjdCk7XG5cdHJlbW92ZV9yZWFjdGlvbnMoZWZmZWN0LCAwKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBERVNUUk9ZRUQpO1xuXG5cdHZhciB0cmFuc2l0aW9ucyA9IGVmZmVjdC50cmFuc2l0aW9ucztcblxuXHRpZiAodHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgdHJhbnNpdGlvbnMpIHtcblx0XHRcdHRyYW5zaXRpb24uc3RvcCgpO1xuXHRcdH1cblx0fVxuXG5cdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCk7XG5cblx0dmFyIHBhcmVudCA9IGVmZmVjdC5wYXJlbnQ7XG5cblx0Ly8gSWYgdGhlIHBhcmVudCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLCB0aGVuIHNraXAgdGhpcyB3b3JrIGFsdG9nZXRoZXJcblx0aWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZmlyc3QgIT09IG51bGwpIHtcblx0XHR1bmxpbmtfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cdH1cblxuXHQvLyBgZmlyc3RgIGFuZCBgY2hpbGRgIGFyZSBudWxsZWQgb3V0IGluIGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuXG5cdC8vIHdlIGRvbid0IG51bGwgb3V0IGBwYXJlbnRgIHNvIHRoYXQgZXJyb3IgcHJvcGFnYXRpb24gY2FuIHdvcmsgY29ycmVjdGx5XG5cdGVmZmVjdC5uZXh0ID1cblx0XHRlZmZlY3QucHJldiA9XG5cdFx0ZWZmZWN0LnRlYXJkb3duID1cblx0XHRlZmZlY3QuY3R4ID1cblx0XHRlZmZlY3QuZGVwcyA9XG5cdFx0ZWZmZWN0LmZuID1cblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPVxuXHRcdGVmZmVjdC5ub2Rlc19lbmQgPVxuXHRcdFx0bnVsbDtcbn1cblxuLyoqXG4gKiBEZXRhY2ggYW4gZWZmZWN0IGZyb20gdGhlIGVmZmVjdCB0cmVlLCBmcmVlaW5nIHVwIG1lbW9yeSBhbmRcbiAqIHJlZHVjaW5nIHRoZSBhbW91bnQgb2Ygd29yayB0aGF0IGhhcHBlbnMgb24gc3Vic2VxdWVudCB0cmF2ZXJzYWxzXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpbmtfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblx0dmFyIHByZXYgPSBlZmZlY3QucHJldjtcblx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblxuXHRpZiAocHJldiAhPT0gbnVsbCkgcHJldi5uZXh0ID0gbmV4dDtcblx0aWYgKG5leHQgIT09IG51bGwpIG5leHQucHJldiA9IHByZXY7XG5cblx0aWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmIChwYXJlbnQuZmlyc3QgPT09IGVmZmVjdCkgcGFyZW50LmZpcnN0ID0gbmV4dDtcblx0XHRpZiAocGFyZW50Lmxhc3QgPT09IGVmZmVjdCkgcGFyZW50Lmxhc3QgPSBwcmV2O1xuXHR9XG59XG5cbi8qKlxuICogV2hlbiBhIGJsb2NrIGVmZmVjdCBpcyByZW1vdmVkLCB3ZSBkb24ndCBpbW1lZGlhdGVseSBkZXN0cm95IGl0IG9yIHlhbmsgaXRcbiAqIG91dCBvZiB0aGUgRE9NLCBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgdHJhbnNpdGlvbnMuIEluc3RlYWQsIHdlICdwYXVzZScgaXQuXG4gKiBJdCBzdGF5cyBhcm91bmQgKGluIG1lbW9yeSwgYW5kIGluIHRoZSBET00pIHVudGlsIG91dHJvIHRyYW5zaXRpb25zIGhhdmVcbiAqIGNvbXBsZXRlZCwgYW5kIGlmIHRoZSBzdGF0ZSBjaGFuZ2UgaXMgcmV2ZXJzZWQgdGhlbiB3ZSBfcmVzdW1lXyBpdC5cbiAqIEEgcGF1c2VkIGVmZmVjdCBkb2VzIG5vdCB1cGRhdGUsIGFuZCB0aGUgRE9NIHN1YnRyZWUgYmVjb21lcyBpbmVydC5cbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF1c2VfZWZmZWN0KGVmZmVjdCwgY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblxuXHRwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCB0cnVlKTtcblxuXHRydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCAoKSA9PiB7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gdHJhbnNpdGlvbnNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIGZuKSB7XG5cdHZhciByZW1haW5pbmcgPSB0cmFuc2l0aW9ucy5sZW5ndGg7XG5cdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0dmFyIGNoZWNrID0gKCkgPT4gLS1yZW1haW5pbmcgfHwgZm4oKTtcblx0XHRmb3IgKHZhciB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLm91dChjaGVjayk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge1RyYW5zaXRpb25NYW5hZ2VyW119IHRyYW5zaXRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCBsb2NhbCkge1xuXHRpZiAoKGVmZmVjdC5mICYgSU5FUlQpICE9PSAwKSByZXR1cm47XG5cdGVmZmVjdC5mIF49IElORVJUO1xuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9IChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fCAoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHBhdXNlX2NoaWxkcmVuIHJlY3Vyc2l2ZWx5IHdpdGggYSBsaW5rZWQgbGlzdCBpbiBwbGFjZVxuXHRcdC8vIGl0J3Mgc2xpZ2h0bHkgbW9yZSBpbnZvbHZlZCB0aG91Z2ggYXMgd2UgaGF2ZSB0byBhY2NvdW50IGZvciBgdHJhbnNwYXJlbnRgIGNoYW5naW5nXG5cdFx0Ly8gdGhyb3VnaCB0aGUgdHJlZS5cblx0XHRwYXVzZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNpdGlvbnMsIHRyYW5zcGFyZW50ID8gbG9jYWwgOiBmYWxzZSk7XG5cdFx0Y2hpbGQgPSBzaWJsaW5nO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBwYXVzZV9lZmZlY3RgLiBXZSBjYWxsIHRoaXMgaWYgKGZvciBleGFtcGxlKVxuICogYHhgIGJlY29tZXMgZmFsc3kgdGhlbiB0cnV0aHk6IGB7I2lmIHh9Li4uey9pZn1gXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN1bWVfZWZmZWN0KGVmZmVjdCkge1xuXHRyZXN1bWVfY2hpbGRyZW4oZWZmZWN0LCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZV9jaGlsZHJlbihlZmZlY3QsIGxvY2FsKSB7XG5cdGlmICgoZWZmZWN0LmYgJiBJTkVSVCkgPT09IDApIHJldHVybjtcblxuXHQvLyBJZiBhIGRlcGVuZGVuY3kgb2YgdGhpcyBlZmZlY3QgY2hhbmdlZCB3aGlsZSBpdCB3YXMgcGF1c2VkLFxuXHQvLyBhcHBseSB0aGUgY2hhbmdlIG5vd1xuXHRpZiAoY2hlY2tfZGlydGluZXNzKGVmZmVjdCkpIHtcblx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHQvLyBFbnN1cmUgd2UgdG9nZ2xlIHRoZSBmbGFnIGFmdGVyIHBvc3NpYmx5IHVwZGF0aW5nIHRoZSBlZmZlY3Qgc28gdGhhdFxuXHQvLyBlYWNoIGJsb2NrIGxvZ2ljIGNhbiBjb3JyZWN0bHkgb3BlcmF0ZSBvbiBpbmVydCBpdGVtc1xuXHRlZmZlY3QuZiBePSBJTkVSVDtcblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9IChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fCAoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHJlc3VtZV9jaGlsZHJlbiByZWN1cnNpdmVseSB3aXRoIGEgbGlua2VkIGxpc3QgaW4gcGxhY2Vcblx0XHQvLyBpdCdzIHNsaWdodGx5IG1vcmUgaW52b2x2ZWQgdGhvdWdoIGFzIHdlIGhhdmUgdG8gYWNjb3VudCBmb3IgYHRyYW5zcGFyZW50YCBjaGFuZ2luZ1xuXHRcdC8vIHRocm91Z2ggdGhlIHRyZWUuXG5cdFx0cmVzdW1lX2NoaWxkcmVuKGNoaWxkLCB0cmFuc3BhcmVudCA/IGxvY2FsIDogZmFsc2UpO1xuXHRcdGNoaWxkID0gc2libGluZztcblx0fVxuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5pbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIiwiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8vIEZhbGxiYWNrIGZvciB3aGVuIHJlcXVlc3RJZGxlQ2FsbGJhY2sgaXMgbm90IGF2YWlsYWJsZVxuZXhwb3J0IGNvbnN0IHJlcXVlc3RfaWRsZV9jYWxsYmFjayA9XG5cdHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrID09PSAndW5kZWZpbmVkJ1xuXHRcdD8gKC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi8gY2IpID0+IHNldFRpbWVvdXQoY2IsIDEpXG5cdFx0OiByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuXG5sZXQgaXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcbmxldCBpc19pZGxlX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cbi8qKiBAdHlwZSB7QXJyYXk8KCkgPT4gdm9pZD59ICovXG5sZXQgY3VycmVudF9xdWV1ZWRfbWljcm9fdGFza3MgPSBbXTtcbi8qKiBAdHlwZSB7QXJyYXk8KCkgPT4gdm9pZD59ICovXG5sZXQgY3VycmVudF9xdWV1ZWRfaWRsZV90YXNrcyA9IFtdO1xuXG5mdW5jdGlvbiBwcm9jZXNzX21pY3JvX3Rhc2tzKCkge1xuXHRpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXHRjb25zdCB0YXNrcyA9IGN1cnJlbnRfcXVldWVkX21pY3JvX3Rhc2tzLnNsaWNlKCk7XG5cdGN1cnJlbnRfcXVldWVkX21pY3JvX3Rhc2tzID0gW107XG5cdHJ1bl9hbGwodGFza3MpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2lkbGVfdGFza3MoKSB7XG5cdGlzX2lkbGVfdGFza19xdWV1ZWQgPSBmYWxzZTtcblx0Y29uc3QgdGFza3MgPSBjdXJyZW50X3F1ZXVlZF9pZGxlX3Rhc2tzLnNsaWNlKCk7XG5cdGN1cnJlbnRfcXVldWVkX2lkbGVfdGFza3MgPSBbXTtcblx0cnVuX2FsbCh0YXNrcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVldWVfbWljcm9fdGFzayhmbikge1xuXHRpZiAoIWlzX21pY3JvX3Rhc2tfcXVldWVkKSB7XG5cdFx0aXNfbWljcm9fdGFza19xdWV1ZWQgPSB0cnVlO1xuXHRcdHF1ZXVlTWljcm90YXNrKHByb2Nlc3NfbWljcm9fdGFza3MpO1xuXHR9XG5cdGN1cnJlbnRfcXVldWVkX21pY3JvX3Rhc2tzLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXVlX2lkbGVfdGFzayhmbikge1xuXHRpZiAoIWlzX2lkbGVfdGFza19xdWV1ZWQpIHtcblx0XHRpc19pZGxlX3Rhc2tfcXVldWVkID0gdHJ1ZTtcblx0XHRyZXF1ZXN0X2lkbGVfY2FsbGJhY2socHJvY2Vzc19pZGxlX3Rhc2tzKTtcblx0fVxuXHRjdXJyZW50X3F1ZXVlZF9pZGxlX3Rhc2tzLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgcnVuIGFueSBxdWV1ZWQgdGFza3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF90YXNrcygpIHtcblx0aWYgKGlzX21pY3JvX3Rhc2tfcXVldWVkKSB7XG5cdFx0cHJvY2Vzc19taWNyb190YXNrcygpO1xuXHR9XG5cdGlmIChpc19pZGxlX3Rhc2tfcXVldWVkKSB7XG5cdFx0cHJvY2Vzc19pZGxlX3Rhc2tzKCk7XG5cdH1cbn1cbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKlxuICogQ2Fubm90IHVzZSBge0ByZW5kZXIgY2hpbGRyZW4oLi4uKX1gIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgYGxldDpgIGRpcmVjdGl2ZXMuIENvbnNpZGVyIHVzaW5nIGEgbmFtZWQgc25pcHBldCBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX2RlZmF1bHRfc25pcHBldCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkX2RlZmF1bHRfc25pcHBldFxcbkNhbm5vdCB1c2UgXFxge0ByZW5kZXIgY2hpbGRyZW4oLi4uKX1cXGAgaWYgdGhlIHBhcmVudCBjb21wb25lbnQgdXNlcyBcXGBsZXQ6XFxgIGRpcmVjdGl2ZXMuIENvbnNpZGVyIHVzaW5nIGEgbmFtZWQgc25pcHBldCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJW5hbWUlKC4uLilgIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudChuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50XFxuXFxgJHtuYW1lfSguLi4pXFxgIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJW5hbWUlYCBpcyBub3QgYSBzdG9yZSB3aXRoIGEgYHN1YnNjcmliZWAgbWV0aG9kXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfaW52YWxpZF9zaGFwZShuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RvcmVfaW52YWxpZF9zaGFwZVxcblxcYCR7bmFtZX1cXGAgaXMgbm90IGEgc3RvcmUgd2l0aCBhIFxcYHN1YnNjcmliZVxcYCBtZXRob2RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdG9yZV9pbnZhbGlkX3NoYXBlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdG9yZV9pbnZhbGlkX3NoYXBlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHRoaXNgIHByb3Agb24gYDxzdmVsdGU6ZWxlbWVudD5gIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVcXG5UaGUgXFxgdGhpc1xcYCBwcm9wIG9uIFxcYDxzdmVsdGU6ZWxlbWVudD5cXGAgbXVzdCBiZSBhIHN0cmluZywgaWYgZGVmaW5lZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlYCk7XG5cdH1cbn0iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNpZ25hbCwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgZ2V0X2Rlc2NyaXB0b3JzLCBnZXRfcHJvdG90eXBlX29mIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuLFxuXHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbixcblx0ZGVzdHJveV9lZmZlY3RfZGVyaXZlZHMsXG5cdGVmZmVjdCxcblx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24sXG5cdHVubGlua19lZmZlY3Rcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0RUZGRUNULFxuXHRSRU5ERVJfRUZGRUNULFxuXHRESVJUWSxcblx0TUFZQkVfRElSVFksXG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRVTk9XTkVELFxuXHRERVNUUk9ZRUQsXG5cdElORVJULFxuXHRCUkFOQ0hfRUZGRUNULFxuXHRTVEFURV9TWU1CT0wsXG5cdEJMT0NLX0VGRkVDVCxcblx0Uk9PVF9FRkZFQ1QsXG5cdExFR0FDWV9ERVJJVkVEX1BST1AsXG5cdERJU0NPTk5FQ1RFRCxcblx0Qk9VTkRBUllfRUZGRUNUXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGZsdXNoX3Rhc2tzIH0gZnJvbSAnLi9kb20vdGFzay5qcyc7XG5pbXBvcnQgeyBhZGRfb3duZXIgfSBmcm9tICcuL2Rldi9vd25lcnNoaXAuanMnO1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0LCBzZXQsIHNvdXJjZSB9IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGRlc3Ryb3lfZGVyaXZlZCwgZXhlY3V0ZV9kZXJpdmVkLCB1cGRhdGVfZGVyaXZlZCB9IGZyb20gJy4vcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC9lcnJvcnMuanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZywgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX2V4cHJlc3Npb25zLCBnZXRfc3RhY2sgfSBmcm9tICcuL2Rldi90cmFjaW5nLmpzJztcblxuY29uc3QgRkxVU0hfTUlDUk9UQVNLID0gMDtcbmNvbnN0IEZMVVNIX1NZTkMgPSAxO1xuLy8gVXNlZCBmb3IgREVWIHRpbWUgZXJyb3IgaGFuZGxpbmdcbi8qKiBAcGFyYW0ge1dlYWtTZXQ8RXJyb3I+fSB2YWx1ZSAqL1xuY29uc3QgaGFuZGxlZF9lcnJvcnMgPSBuZXcgV2Vha1NldCgpO1xuZXhwb3J0IGxldCBpc190aHJvd2luZ19lcnJvciA9IGZhbHNlO1xuXG4vLyBVc2VkIGZvciBjb250cm9sbGluZyB0aGUgZmx1c2ggb2YgZWZmZWN0cy5cbmxldCBzY2hlZHVsZXJfbW9kZSA9IEZMVVNIX01JQ1JPVEFTSztcbi8vIFVzZWQgZm9yIGhhbmRsaW5nIHNjaGVkdWxpbmdcbmxldCBpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXG4vKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5sZXQgbGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gbnVsbDtcblxuZXhwb3J0IGxldCBpc19mbHVzaGluZ19lZmZlY3QgPSBmYWxzZTtcbmV4cG9ydCBsZXQgaXNfZGVzdHJveWluZ19lZmZlY3QgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHZhbHVlKSB7XG5cdGlzX2ZsdXNoaW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc19kZXN0cm95aW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG4vLyBIYW5kbGUgZWZmZWN0IHF1ZXVlc1xuXG4vKiogQHR5cGUge0VmZmVjdFtdfSAqL1xubGV0IHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxubGV0IGZsdXNoX2NvdW50ID0gMDtcbi8qKiBAdHlwZSB7RWZmZWN0W119IFN0YWNrIG9mIGVmZmVjdHMsIGRldiBvbmx5ICovXG5sZXQgZGV2X2VmZmVjdF9zdGFjayA9IFtdO1xuLy8gSGFuZGxlIHNpZ25hbCByZWFjdGl2aXR5IHRyZWUgZGVwZW5kZW5jaWVzIGFuZCByZWFjdGlvbnNcblxuLyoqIEB0eXBlIHtudWxsIHwgUmVhY3Rpb259ICovXG5leHBvcnQgbGV0IGFjdGl2ZV9yZWFjdGlvbiA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBSZWFjdGlvbn0gcmVhY3Rpb24gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYWN0aXZlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdGFjdGl2ZV9yZWFjdGlvbiA9IHJlYWN0aW9uO1xufVxuXG4vKiogQHR5cGUge251bGwgfCBFZmZlY3R9ICovXG5leHBvcnQgbGV0IGFjdGl2ZV9lZmZlY3QgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgRWZmZWN0fSBlZmZlY3QgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYWN0aXZlX2VmZmVjdChlZmZlY3QpIHtcblx0YWN0aXZlX2VmZmVjdCA9IGVmZmVjdDtcbn1cblxuLyoqXG4gKiBXaGVuIHNvdXJjZXMgYXJlIGNyZWF0ZWQgd2l0aGluIGEgZGVyaXZlZCwgd2UgcmVjb3JkIHRoZW0gc28gdGhhdCB3ZSBjYW4gc2FmZWx5IGFsbG93XG4gKiBsb2NhbCBtdXRhdGlvbnMgdG8gdGhlc2Ugc291cmNlcyB3aXRob3V0IHRoZSBzaWRlLWVmZmVjdCBlcnJvciBiZWluZyBpbnZva2VkIHVubmVjZXNzYXJpbHkuXG4gKiBAdHlwZSB7bnVsbCB8IFNvdXJjZVtdfVxuICovXG5leHBvcnQgbGV0IGRlcml2ZWRfc291cmNlcyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtTb3VyY2VbXSB8IG51bGx9IHNvdXJjZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZXJpdmVkX3NvdXJjZXMoc291cmNlcykge1xuXHRkZXJpdmVkX3NvdXJjZXMgPSBzb3VyY2VzO1xufVxuXG4vKipcbiAqIFRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIHJlYWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkLiBJbiBtYW55IGNhc2VzLFxuICogdGhlIGRlcGVuZGVuY2llcyBhcmUgdW5jaGFuZ2VkIGJldHdlZW4gcnVucywgYW5kIHNvIHRoaXMgd2lsbCBiZSBgbnVsbGAgdW5sZXNzXG4gKiBhbmQgdW50aWwgYSBuZXcgZGVwZW5kZW5jeSBpcyBhY2Nlc3NlZCDigJQgd2UgdHJhY2sgdGhpcyB2aWEgYHNraXBwZWRfZGVwc2BcbiAqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX1cbiAqL1xuZXhwb3J0IGxldCBuZXdfZGVwcyA9IG51bGw7XG5cbmxldCBza2lwcGVkX2RlcHMgPSAwO1xuXG4vKipcbiAqIFRyYWNrcyB3cml0ZXMgdGhhdCB0aGUgZWZmZWN0IGl0J3MgZXhlY3V0ZWQgaW4gZG9lc24ndCBsaXN0ZW4gdG8geWV0LFxuICogc28gdGhhdCB0aGUgZGVwZW5kZW5jeSBjYW4gYmUgYWRkZWQgdG8gdGhlIGVmZmVjdCBsYXRlciBvbiBpZiBpdCB0aGVuIHJlYWRzIGl0XG4gKiBAdHlwZSB7bnVsbCB8IFNvdXJjZVtdfVxuICovXG5leHBvcnQgbGV0IHVudHJhY2tlZF93cml0ZXMgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgU291cmNlW119IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3VudHJhY2tlZF93cml0ZXModmFsdWUpIHtcblx0dW50cmFja2VkX3dyaXRlcyA9IHZhbHVlO1xufVxuXG4vKiogQHR5cGUge251bWJlcn0gVXNlZCBieSBzb3VyY2VzIGFuZCBkZXJpdmVkcyBmb3IgaGFuZGxpbmcgdXBkYXRlcyB0byB1bm93bmVkIGRlcml2ZWRzIGl0IHN0YXJ0cyBmcm9tIDEgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGEgY3JlYXRlZCBlZmZlY3QgYW5kIGEgcnVuIG9uZSBmb3IgdHJhY2luZyAqL1xubGV0IGN1cnJlbnRfdmVyc2lvbiA9IDE7XG5cbi8vIElmIHdlIGFyZSB3b3JraW5nIHdpdGggYSBnZXQoKSBjaGFpbiB0aGF0IGhhcyBubyBhY3RpdmUgY29udGFpbmVyLFxuLy8gdG8gcHJldmVudCBtZW1vcnkgbGVha3MsIHdlIHNraXAgYWRkaW5nIHRoZSByZWFjdGlvbi5cbmV4cG9ydCBsZXQgc2tpcF9yZWFjdGlvbiA9IGZhbHNlO1xuLy8gSGFuZGxlIGNvbGxlY3RpbmcgYWxsIHNpZ25hbHMgd2hpY2ggYXJlIHJlYWQgZHVyaW5nIGEgc3BlY2lmaWMgdGltZSBmcmFtZVxuLyoqIEB0eXBlIHtTZXQ8VmFsdWU+IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY2FwdHVyZWRfc2lnbmFscyA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge1NldDxWYWx1ZT4gfCBudWxsfSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jYXB0dXJlZF9zaWduYWxzKHZhbHVlKSB7XG5cdGNhcHR1cmVkX3NpZ25hbHMgPSB2YWx1ZTtcbn1cblxuLy8gSGFuZGxpbmcgcnVudGltZSBjb21wb25lbnQgY29udGV4dFxuLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY29tcG9uZW50X2NvbnRleHQgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29udGV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jb21wb25lbnRfY29udGV4dChjb250ZXh0KSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGN1cnJlbnQgY29tcG9uZW50IGNvbnRleHQ6XG4gKiBgYGBodG1sXG4gKiA8IS0tIEFwcC5zdmVsdGUgLS0+XG4gKiA8Rm9vPlxuICogICA8QmFyIC8+IDwhLS0gY29udGV4dCA9PSBGb28uc3ZlbHRlLCBmdW5jdGlvbiA9PSBBcHAuc3ZlbHRlIC0tPlxuICogPC9Gb28+XG4gKiBgYGBcbiAqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfVxuICovXG5leHBvcnQgbGV0IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRbJ2Z1bmN0aW9uJ119IGZuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihmbikge1xuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBmbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudF92ZXJzaW9uKCkge1xuXHRyZXR1cm4gKytjdXJyZW50X3ZlcnNpb247XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19ydW5lcygpIHtcblx0cmV0dXJuICFsZWdhY3lfbW9kZV9mbGFnIHx8IChjb21wb25lbnRfY29udGV4dCAhPT0gbnVsbCAmJiBjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBkZXJpdmVkIG9yIGVmZmVjdCBpcyBkaXJ0eS5cbiAqIElmIGl0IGlzIE1BWUJFX0RJUlRZLCB3aWxsIHNldCB0aGUgc3RhdHVzIHRvIENMRUFOXG4gKiBAcGFyYW0ge1JlYWN0aW9ufSByZWFjdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19kaXJ0aW5lc3MocmVhY3Rpb24pIHtcblx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRpZiAoKGZsYWdzICYgRElSVFkpICE9PSAwKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoKGZsYWdzICYgTUFZQkVfRElSVFkpICE9PSAwKSB7XG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IHJlYWN0aW9uLmRlcHM7XG5cdFx0dmFyIGlzX3Vub3duZWQgPSAoZmxhZ3MgJiBVTk9XTkVEKSAhPT0gMDtcblxuXHRcdGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoKGZsYWdzICYgRElTQ09OTkVDVEVEKSAhPT0gMCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0KGRlcGVuZGVuY2llc1tpXS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKHJlYWN0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlYWN0aW9uLmYgXj0gRElTQ09OTkVDVEVEO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuXG5cdFx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwZW5kZW5jeSkpKSB7XG5cdFx0XHRcdFx0dXBkYXRlX2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhbiB1bm93bmVkIHNpZ25hbCBhcyBwYXJ0IG9mIGFuIGVmZmVjdCAoZHVlIHRvICFza2lwX3JlYWN0aW9uKVxuXHRcdFx0XHQvLyBhbmQgdGhlIHZlcnNpb24gaGFzbid0IGNoYW5nZWQsIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGlzIHJlYWN0aW9uXG5cdFx0XHRcdC8vIGlzIGxpbmtlZCB0byB0aGUgZGVwZW5kZW5jeSBzb3VyY2Ug4oCTIG90aGVyd2lzZSBmdXR1cmUgdXBkYXRlcyB3aWxsIG5vdCBiZSBjYXVnaHQuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRpc191bm93bmVkICYmXG5cdFx0XHRcdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdFx0XHRcdCFza2lwX3JlYWN0aW9uICYmXG5cdFx0XHRcdFx0IWRlcGVuZGVuY3k/LnJlYWN0aW9ucz8uaW5jbHVkZXMocmVhY3Rpb24pXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdChkZXBlbmRlbmN5LnJlYWN0aW9ucyA/Pz0gW10pLnB1c2gocmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRlcGVuZGVuY3kudmVyc2lvbiA+IHJlYWN0aW9uLnZlcnNpb24pIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVub3duZWQgc2lnbmFscyBzaG91bGQgbmV2ZXIgYmUgbWFya2VkIGFzIGNsZWFuIHVubGVzcyB0aGV5XG5cdFx0Ly8gYXJlIHVzZWQgd2l0aGluIGFuIGFjdGl2ZV9lZmZlY3Qgd2l0aG91dCBza2lwX3JlYWN0aW9uXG5cdFx0aWYgKCFpc191bm93bmVkIHx8IChhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICFza2lwX3JlYWN0aW9uKSkge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIENMRUFOKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBlcnJvclxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5mdW5jdGlvbiBwcm9wYWdhdGVfZXJyb3IoZXJyb3IsIGVmZmVjdCkge1xuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBjdXJyZW50ID0gZWZmZWN0O1xuXG5cdHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdFx0aWYgKChjdXJyZW50LmYgJiBCT1VOREFSWV9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdGN1cnJlbnQuZm4oZXJyb3IpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0Ly8gUmVtb3ZlIGJvdW5kYXJ5IGZsYWcgZnJvbSBlZmZlY3Rcblx0XHRcdFx0Y3VycmVudC5mIF49IEJPVU5EQVJZX0VGRkVDVDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG5cdH1cblxuXHRpc190aHJvd2luZ19lcnJvciA9IGZhbHNlO1xuXHR0aHJvdyBlcnJvcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIHNob3VsZF9yZXRocm93X2Vycm9yKGVmZmVjdCkge1xuXHRyZXR1cm4gKFxuXHRcdChlZmZlY3QuZiAmIERFU1RST1lFRCkgPT09IDAgJiZcblx0XHQoZWZmZWN0LnBhcmVudCA9PT0gbnVsbCB8fCAoZWZmZWN0LnBhcmVudC5mICYgQk9VTkRBUllfRUZGRUNUKSA9PT0gMClcblx0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0X2lzX3Rocm93aW5nX2Vycm9yKCkge1xuXHRpc190aHJvd2luZ19lcnJvciA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7RWZmZWN0IHwgbnVsbH0gcHJldmlvdXNfZWZmZWN0XG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHQgfCBudWxsfSBjb21wb25lbnRfY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX2Vycm9yKGVycm9yLCBlZmZlY3QsIHByZXZpb3VzX2VmZmVjdCwgY29tcG9uZW50X2NvbnRleHQpIHtcblx0aWYgKGlzX3Rocm93aW5nX2Vycm9yKSB7XG5cdFx0aWYgKHByZXZpb3VzX2VmZmVjdCA9PT0gbnVsbCkge1xuXHRcdFx0aXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkX3JldGhyb3dfZXJyb3IoZWZmZWN0KSkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHByZXZpb3VzX2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdGlzX3Rocm93aW5nX2Vycm9yID0gdHJ1ZTtcblx0fVxuXG5cdGlmIChcblx0XHQhREVWIHx8XG5cdFx0Y29tcG9uZW50X2NvbnRleHQgPT09IG51bGwgfHxcblx0XHQhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHx8XG5cdFx0aGFuZGxlZF9lcnJvcnMuaGFzKGVycm9yKVxuXHQpIHtcblx0XHRwcm9wYWdhdGVfZXJyb3IoZXJyb3IsIGVmZmVjdCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aGFuZGxlZF9lcnJvcnMuYWRkKGVycm9yKTtcblxuXHRjb25zdCBjb21wb25lbnRfc3RhY2sgPSBbXTtcblxuXHRjb25zdCBlZmZlY3RfbmFtZSA9IGVmZmVjdC5mbj8ubmFtZTtcblxuXHRpZiAoZWZmZWN0X25hbWUpIHtcblx0XHRjb21wb25lbnRfc3RhY2sucHVzaChlZmZlY3RfbmFtZSk7XG5cdH1cblxuXHQvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHQgfCBudWxsfSAqL1xuXHRsZXQgY3VycmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cblx0d2hpbGUgKGN1cnJlbnRfY29udGV4dCAhPT0gbnVsbCkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuXHRcdFx0dmFyIGZpbGVuYW1lID0gY3VycmVudF9jb250ZXh0LmZ1bmN0aW9uPy5bRklMRU5BTUVdO1xuXG5cdFx0XHRpZiAoZmlsZW5hbWUpIHtcblx0XHRcdFx0Y29uc3QgZmlsZSA9IGZpbGVuYW1lLnNwbGl0KCcvJykucG9wKCk7XG5cdFx0XHRcdGNvbXBvbmVudF9zdGFjay5wdXNoKGZpbGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnJlbnRfY29udGV4dCA9IGN1cnJlbnRfY29udGV4dC5wO1xuXHR9XG5cblx0Y29uc3QgaW5kZW50ID0gL0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAnICAnIDogJ1xcdCc7XG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ21lc3NhZ2UnLCB7XG5cdFx0dmFsdWU6IGVycm9yLm1lc3NhZ2UgKyBgXFxuJHtjb21wb25lbnRfc3RhY2subWFwKChuYW1lKSA9PiBgXFxuJHtpbmRlbnR9aW4gJHtuYW1lfWApLmpvaW4oJycpfVxcbmBcblx0fSk7XG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ2NvbXBvbmVudF9zdGFjaycsIHtcblx0XHR2YWx1ZTogY29tcG9uZW50X3N0YWNrXG5cdH0pO1xuXG5cdGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2s7XG5cblx0Ly8gRmlsdGVyIG91dCBpbnRlcm5hbCBmaWxlcyBmcm9tIGNhbGxzdGFja1xuXHRpZiAoc3RhY2spIHtcblx0XHRjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcblx0XHRjb25zdCBuZXdfbGluZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAobGluZS5pbmNsdWRlcygnc3ZlbHRlL3NyYy9pbnRlcm5hbCcpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0bmV3X2xpbmVzLnB1c2gobGluZSk7XG5cdFx0fVxuXHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywge1xuXHRcdFx0dmFsdWU6IG5ld19saW5lcy5qb2luKCdcXG4nKVxuXHRcdH0pO1xuXHR9XG5cblx0cHJvcGFnYXRlX2Vycm9yKGVycm9yLCBlZmZlY3QpO1xuXG5cdGlmIChzaG91bGRfcmV0aHJvd19lcnJvcihlZmZlY3QpKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdHZhciBwcmV2aW91c19kZXBzID0gbmV3X2RlcHM7XG5cdHZhciBwcmV2aW91c19za2lwcGVkX2RlcHMgPSBza2lwcGVkX2RlcHM7XG5cdHZhciBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID0gdW50cmFja2VkX3dyaXRlcztcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfc2tpcF9yZWFjdGlvbiA9IHNraXBfcmVhY3Rpb247XG5cdHZhciBwcmV2X2Rlcml2ZWRfc291cmNlcyA9IGRlcml2ZWRfc291cmNlcztcblx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0bmV3X2RlcHMgPSAvKiogQHR5cGUge251bGwgfCBWYWx1ZVtdfSAqLyAobnVsbCk7XG5cdHNraXBwZWRfZGVwcyA9IDA7XG5cdHVudHJhY2tlZF93cml0ZXMgPSBudWxsO1xuXHRhY3RpdmVfcmVhY3Rpb24gPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDAgPyByZWFjdGlvbiA6IG51bGw7XG5cdHNraXBfcmVhY3Rpb24gPSAhaXNfZmx1c2hpbmdfZWZmZWN0ICYmIChmbGFncyAmIFVOT1dORUQpICE9PSAwO1xuXHRkZXJpdmVkX3NvdXJjZXMgPSBudWxsO1xuXHRjb21wb25lbnRfY29udGV4dCA9IHJlYWN0aW9uLmN0eDtcblxuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAoMCwgcmVhY3Rpb24uZm4pKCk7XG5cdFx0dmFyIGRlcHMgPSByZWFjdGlvbi5kZXBzO1xuXG5cdFx0aWYgKG5ld19kZXBzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblxuXHRcdFx0aWYgKGRlcHMgIT09IG51bGwgJiYgc2tpcHBlZF9kZXBzID4gMCkge1xuXHRcdFx0XHRkZXBzLmxlbmd0aCA9IHNraXBwZWRfZGVwcyArIG5ld19kZXBzLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5ld19kZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGVwc1tza2lwcGVkX2RlcHMgKyBpXSA9IG5ld19kZXBzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWFjdGlvbi5kZXBzID0gZGVwcyA9IG5ld19kZXBzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNraXBfcmVhY3Rpb24pIHtcblx0XHRcdFx0Zm9yIChpID0gc2tpcHBlZF9kZXBzOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdChkZXBzW2ldLnJlYWN0aW9ucyA/Pz0gW10pLnB1c2gocmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA8IGRlcHMubGVuZ3RoKSB7XG5cdFx0XHRyZW1vdmVfcmVhY3Rpb25zKHJlYWN0aW9uLCBza2lwcGVkX2RlcHMpO1xuXHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBmaW5hbGx5IHtcblx0XHRuZXdfZGVwcyA9IHByZXZpb3VzX2RlcHM7XG5cdFx0c2tpcHBlZF9kZXBzID0gcHJldmlvdXNfc2tpcHBlZF9kZXBzO1xuXHRcdHVudHJhY2tlZF93cml0ZXMgPSBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzO1xuXHRcdGFjdGl2ZV9yZWFjdGlvbiA9IHByZXZpb3VzX3JlYWN0aW9uO1xuXHRcdHNraXBfcmVhY3Rpb24gPSBwcmV2aW91c19za2lwX3JlYWN0aW9uO1xuXHRcdGRlcml2ZWRfc291cmNlcyA9IHByZXZfZGVyaXZlZF9zb3VyY2VzO1xuXHRcdGNvbXBvbmVudF9jb250ZXh0ID0gcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBkZXBlbmRlbmN5XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9uKHNpZ25hbCwgZGVwZW5kZW5jeSkge1xuXHRsZXQgcmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHR2YXIgaW5kZXggPSByZWFjdGlvbnMuaW5kZXhPZihzaWduYWwpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHZhciBuZXdfbGVuZ3RoID0gcmVhY3Rpb25zLmxlbmd0aCAtIDE7XG5cdFx0XHRpZiAobmV3X2xlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZWFjdGlvbnMgPSBkZXBlbmRlbmN5LnJlYWN0aW9ucyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBTd2FwIHdpdGggbGFzdCBlbGVtZW50IGFuZCB0aGVuIHJlbW92ZS5cblx0XHRcdFx0cmVhY3Rpb25zW2luZGV4XSA9IHJlYWN0aW9uc1tuZXdfbGVuZ3RoXTtcblx0XHRcdFx0cmVhY3Rpb25zLnBvcCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBJZiB0aGUgZGVyaXZlZCBoYXMgbm8gcmVhY3Rpb25zLCB0aGVuIHdlIGNhbiBkaXNjb25uZWN0IGl0IGZyb20gdGhlIGdyYXBoLFxuXHQvLyBhbGxvd2luZyBpdCB0byBlaXRoZXIgcmVjb25uZWN0IGluIHRoZSBmdXR1cmUsIG9yIGJlIEdDJ2QgYnkgdGhlIFZNLlxuXHRpZiAoXG5cdFx0cmVhY3Rpb25zID09PSBudWxsICYmXG5cdFx0KGRlcGVuZGVuY3kuZiAmIERFUklWRUQpICE9PSAwICYmXG5cdFx0Ly8gRGVzdHJveWluZyBhIGNoaWxkIGVmZmVjdCB3aGlsZSB1cGRhdGluZyBhIHBhcmVudCBlZmZlY3QgY2FuIGNhdXNlIGEgZGVwZW5kZW5jeSB0byBhcHBlYXJcblx0XHQvLyB0byBiZSB1bnVzZWQsIHdoZW4gaW4gZmFjdCBpdCBpcyB1c2VkIGJ5IHRoZSBjdXJyZW50bHktdXBkYXRpbmcgcGFyZW50LiBDaGVja2luZyBgbmV3X2RlcHNgXG5cdFx0Ly8gYWxsb3dzIHVzIHRvIHNraXAgdGhlIGV4cGVuc2l2ZSB3b3JrIG9mIGRpc2Nvbm5lY3RpbmcgYW5kIGltbWVkaWF0ZWx5IHJlY29ubmVjdGluZyBpdFxuXHRcdChuZXdfZGVwcyA9PT0gbnVsbCB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoZGVwZW5kZW5jeSkpXG5cdCkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGRlcGVuZGVuY3ksIE1BWUJFX0RJUlRZKTtcblx0XHQvLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZGVyaXZlZCB0aGF0IGlzIG93bmVkIGJ5IGFuIGVmZmVjdCwgdGhlbiBtYXJrIGl0IGFzIGJlaW5nXG5cdFx0Ly8gZGlzY29ubmVjdGVkLlxuXHRcdGlmICgoZGVwZW5kZW5jeS5mICYgKFVOT1dORUQgfCBESVNDT05ORUNURUQpKSA9PT0gMCkge1xuXHRcdFx0ZGVwZW5kZW5jeS5mIF49IERJU0NPTk5FQ1RFRDtcblx0XHR9XG5cdFx0cmVtb3ZlX3JlYWN0aW9ucygvKiogQHR5cGUge0Rlcml2ZWR9ICoqLyAoZGVwZW5kZW5jeSksIDApO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfaW5kZXhcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9ucyhzaWduYWwsIHN0YXJ0X2luZGV4KSB7XG5cdHZhciBkZXBlbmRlbmNpZXMgPSBzaWduYWwuZGVwcztcblx0aWYgKGRlcGVuZGVuY2llcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdGZvciAodmFyIGkgPSBzdGFydF9pbmRleDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuXHRcdHJlbW92ZV9yZWFjdGlvbihzaWduYWwsIGRlcGVuZGVuY2llc1tpXSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9lZmZlY3QoZWZmZWN0KSB7XG5cdHZhciBmbGFncyA9IGVmZmVjdC5mO1xuXG5cdGlmICgoZmxhZ3MgJiBERVNUUk9ZRUQpICE9PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBDTEVBTik7XG5cblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdHZhciBwcmV2aW91c19jb21wb25lbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXG5cdGFjdGl2ZV9lZmZlY3QgPSBlZmZlY3Q7XG5cblx0aWYgKERFVikge1xuXHRcdHZhciBwcmV2aW91c19jb21wb25lbnRfZm4gPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb247XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKChmbGFncyAmIEJMT0NLX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fVxuXHRcdGRlc3Ryb3lfZWZmZWN0X2Rlcml2ZWRzKGVmZmVjdCk7XG5cblx0XHRleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpO1xuXHRcdHZhciB0ZWFyZG93biA9IHVwZGF0ZV9yZWFjdGlvbihlZmZlY3QpO1xuXHRcdGVmZmVjdC50ZWFyZG93biA9IHR5cGVvZiB0ZWFyZG93biA9PT0gJ2Z1bmN0aW9uJyA/IHRlYXJkb3duIDogbnVsbDtcblx0XHRlZmZlY3QudmVyc2lvbiA9IGN1cnJlbnRfdmVyc2lvbjtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9lZmZlY3Rfc3RhY2sucHVzaChlZmZlY3QpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGVmZmVjdCwgcHJldmlvdXNfZWZmZWN0LCBwcmV2aW91c19jb21wb25lbnRfY29udGV4dCB8fCBlZmZlY3QuY3R4KTtcblx0fSBmaW5hbGx5IHtcblx0XHRhY3RpdmVfZWZmZWN0ID0gcHJldmlvdXNfZWZmZWN0O1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gcHJldmlvdXNfY29tcG9uZW50X2ZuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsb2dfZWZmZWN0X3N0YWNrKCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmVycm9yKFxuXHRcdCdMYXN0IHRlbiBlZmZlY3RzIHdlcmU6ICcsXG5cdFx0ZGV2X2VmZmVjdF9zdGFjay5zbGljZSgtMTApLm1hcCgoZCkgPT4gZC5mbilcblx0KTtcblx0ZGV2X2VmZmVjdF9zdGFjayA9IFtdO1xufVxuXG5mdW5jdGlvbiBpbmZpbml0ZV9sb29wX2d1YXJkKCkge1xuXHRpZiAoZmx1c2hfY291bnQgPiAxMDAwKSB7XG5cdFx0Zmx1c2hfY291bnQgPSAwO1xuXHRcdHRyeSB7XG5cdFx0XHRlLmVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHQvLyBzdGFjayBpcyBnYXJiYWdlLCBpZ25vcmUuIEluc3RlYWQgYWRkIGEgY29uc29sZS5lcnJvciBtZXNzYWdlLlxuXHRcdFx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcblx0XHRcdFx0XHR2YWx1ZTogJydcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUcnkgYW5kIGhhbmRsZSB0aGUgZXJyb3Igc28gaXQgY2FuIGJlIGNhdWdodCBhdCBhIGJvdW5kYXJ5LCB0aGF0J3Ncblx0XHRcdC8vIGlmIHRoZXJlJ3MgYW4gZWZmZWN0IGF2YWlsYWJsZSBmcm9tIHdoZW4gaXQgd2FzIGxhc3Qgc2NoZWR1bGVkXG5cdFx0XHRpZiAobGFzdF9zY2hlZHVsZWRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QsIG51bGwsIG51bGwpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdC8vIE9ubHkgbG9nIHRoZSBlZmZlY3Qgc3RhY2sgaWYgdGhlIGVycm9yIGlzIHJlLXRocm93blxuXHRcdFx0XHRcdFx0bG9nX2VmZmVjdF9zdGFjaygpO1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QsIG51bGwsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0bG9nX2VmZmVjdF9zdGFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmbHVzaF9jb3VudCsrO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RWZmZWN0Pn0gcm9vdF9lZmZlY3RzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcXVldWVkX3Jvb3RfZWZmZWN0cyhyb290X2VmZmVjdHMpIHtcblx0dmFyIGxlbmd0aCA9IHJvb3RfZWZmZWN0cy5sZW5ndGg7XG5cdGlmIChsZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aW5maW5pdGVfbG9vcF9ndWFyZCgpO1xuXG5cdHZhciBwcmV2aW91c2x5X2ZsdXNoaW5nX2VmZmVjdCA9IGlzX2ZsdXNoaW5nX2VmZmVjdDtcblx0aXNfZmx1c2hpbmdfZWZmZWN0ID0gdHJ1ZTtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlZmZlY3QgPSByb290X2VmZmVjdHNbaV07XG5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgPT09IDApIHtcblx0XHRcdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0XHR9XG5cblx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0W119ICovXG5cdFx0XHR2YXIgY29sbGVjdGVkX2VmZmVjdHMgPSBbXTtcblxuXHRcdFx0cHJvY2Vzc19lZmZlY3RzKGVmZmVjdCwgY29sbGVjdGVkX2VmZmVjdHMpO1xuXHRcdFx0Zmx1c2hfcXVldWVkX2VmZmVjdHMoY29sbGVjdGVkX2VmZmVjdHMpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpc19mbHVzaGluZ19lZmZlY3QgPSBwcmV2aW91c2x5X2ZsdXNoaW5nX2VmZmVjdDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RWZmZWN0Pn0gZWZmZWN0c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3F1ZXVlZF9lZmZlY3RzKGVmZmVjdHMpIHtcblx0dmFyIGxlbmd0aCA9IGVmZmVjdHMubGVuZ3RoO1xuXHRpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhciBlZmZlY3QgPSBlZmZlY3RzW2ldO1xuXG5cdFx0aWYgKChlZmZlY3QuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpID09PSAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoY2hlY2tfZGlydGluZXNzKGVmZmVjdCkpIHtcblx0XHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cblx0XHRcdFx0XHQvLyBFZmZlY3RzIHdpdGggbm8gZGVwZW5kZW5jaWVzIG9yIHRlYXJkb3duIGRvIG5vdCBnZXQgYWRkZWQgdG8gdGhlIGVmZmVjdCB0cmVlLlxuXHRcdFx0XHRcdC8vIERlZmVycmVkIGVmZmVjdHMgKGUuZy4gYCRlZmZlY3QoLi4uKWApIF9hcmVfIGFkZGVkIHRvIHRoZSB0cmVlIGJlY2F1c2Ugd2Vcblx0XHRcdFx0XHQvLyBkb24ndCBrbm93IGlmIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVudGlsIHRoZXkgYXJlIGV4ZWN1dGVkLiBEb2luZyB0aGUgY2hlY2tcblx0XHRcdFx0XHQvLyBoZXJlIChyYXRoZXIgdGhhbiBpbiBgdXBkYXRlX2VmZmVjdGApIGFsbG93cyB1cyB0byBza2lwIHRoZSB3b3JrIGZvclxuXHRcdFx0XHRcdC8vIGltbWVkaWF0ZSBlZmZlY3RzLlxuXHRcdFx0XHRcdGlmIChlZmZlY3QuZGVwcyA9PT0gbnVsbCAmJiBlZmZlY3QuZmlyc3QgPT09IG51bGwgJiYgZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpZiAoZWZmZWN0LnRlYXJkb3duID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSB0aGlzIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRcdFx0XHR1bmxpbmtfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3QgaW4gdGhlIGdyYXBoLCBidXQgZnJlZSB1cCBzb21lIG1lbW9yeVxuXHRcdFx0XHRcdFx0XHRlZmZlY3QuZm4gPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBlZmZlY3QsIG51bGwsIGVmZmVjdC5jdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2RlZmVycmVkKCkge1xuXHRpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXHRpZiAoZmx1c2hfY291bnQgPiAxMDAxKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMgPSBxdWV1ZWRfcm9vdF9lZmZlY3RzO1xuXHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cdGZsdXNoX3F1ZXVlZF9yb290X2VmZmVjdHMocHJldmlvdXNfcXVldWVkX3Jvb3RfZWZmZWN0cyk7XG5cblx0aWYgKCFpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdGZsdXNoX2NvdW50ID0gMDtcblx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX2VmZmVjdChzaWduYWwpIHtcblx0aWYgKHNjaGVkdWxlcl9tb2RlID09PSBGTFVTSF9NSUNST1RBU0spIHtcblx0XHRpZiAoIWlzX21pY3JvX3Rhc2tfcXVldWVkKSB7XG5cdFx0XHRpc19taWNyb190YXNrX3F1ZXVlZCA9IHRydWU7XG5cdFx0XHRxdWV1ZU1pY3JvdGFzayhwcm9jZXNzX2RlZmVycmVkKTtcblx0XHR9XG5cdH1cblxuXHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBzaWduYWw7XG5cblx0dmFyIGVmZmVjdCA9IHNpZ25hbDtcblxuXHR3aGlsZSAoZWZmZWN0LnBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGVmZmVjdCA9IGVmZmVjdC5wYXJlbnQ7XG5cdFx0dmFyIGZsYWdzID0gZWZmZWN0LmY7XG5cblx0XHRpZiAoKGZsYWdzICYgKFJPT1RfRUZGRUNUIHwgQlJBTkNIX0VGRkVDVCkpICE9PSAwKSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgQ0xFQU4pID09PSAwKSByZXR1cm47XG5cdFx0XHRlZmZlY3QuZiBePSBDTEVBTjtcblx0XHR9XG5cdH1cblxuXHRxdWV1ZWRfcm9vdF9lZmZlY3RzLnB1c2goZWZmZWN0KTtcbn1cblxuLyoqXG4gKlxuICogVGhpcyBmdW5jdGlvbiBib3RoIHJ1bnMgcmVuZGVyIGVmZmVjdHMgYW5kIGNvbGxlY3RzIHVzZXIgZWZmZWN0cyBpbiB0b3BvbG9naWNhbCBvcmRlclxuICogZnJvbSB0aGUgc3RhcnRpbmcgZWZmZWN0IHBhc3NlZCBpbi4gRWZmZWN0cyB3aWxsIGJlIGNvbGxlY3RlZCB3aGVuIHRoZXkgbWF0Y2ggdGhlIGZpbHRlcmVkXG4gKiBiaXR3aXNlIGZsYWcgcGFzc2VkIGluIG9ubHkuIFRoZSBjb2xsZWN0ZWQgZWZmZWN0cyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGFsbCB0aGUgdXNlclxuICogZWZmZWN0cyB0byBiZSBmbHVzaGVkLlxuICpcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7RWZmZWN0W119IGNvbGxlY3RlZF9lZmZlY3RzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc19lZmZlY3RzKGVmZmVjdCwgY29sbGVjdGVkX2VmZmVjdHMpIHtcblx0dmFyIGN1cnJlbnRfZWZmZWN0ID0gZWZmZWN0LmZpcnN0O1xuXHR2YXIgZWZmZWN0cyA9IFtdO1xuXG5cdG1haW5fbG9vcDogd2hpbGUgKGN1cnJlbnRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIGZsYWdzID0gY3VycmVudF9lZmZlY3QuZjtcblx0XHR2YXIgaXNfYnJhbmNoID0gKGZsYWdzICYgQlJBTkNIX0VGRkVDVCkgIT09IDA7XG5cdFx0dmFyIGlzX3NraXBwYWJsZV9icmFuY2ggPSBpc19icmFuY2ggJiYgKGZsYWdzICYgQ0xFQU4pICE9PSAwO1xuXHRcdHZhciBzaWJsaW5nID0gY3VycmVudF9lZmZlY3QubmV4dDtcblxuXHRcdGlmICghaXNfc2tpcHBhYmxlX2JyYW5jaCAmJiAoZmxhZ3MgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBSRU5ERVJfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0XHRpZiAoaXNfYnJhbmNoKSB7XG5cdFx0XHRcdFx0Y3VycmVudF9lZmZlY3QuZiBePSBDTEVBTjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhjdXJyZW50X2VmZmVjdCkpIHtcblx0XHRcdFx0XHRcdFx0dXBkYXRlX2VmZmVjdChjdXJyZW50X2VmZmVjdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdGhhbmRsZV9lcnJvcihlcnJvciwgY3VycmVudF9lZmZlY3QsIG51bGwsIGN1cnJlbnRfZWZmZWN0LmN0eCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gY3VycmVudF9lZmZlY3QuZmlyc3Q7XG5cblx0XHRcdFx0aWYgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VycmVudF9lZmZlY3QgPSBjaGlsZDtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICgoZmxhZ3MgJiBFRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRcdGVmZmVjdHMucHVzaChjdXJyZW50X2VmZmVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNpYmxpbmcgPT09IG51bGwpIHtcblx0XHRcdGxldCBwYXJlbnQgPSBjdXJyZW50X2VmZmVjdC5wYXJlbnQ7XG5cblx0XHRcdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKGVmZmVjdCA9PT0gcGFyZW50KSB7XG5cdFx0XHRcdFx0YnJlYWsgbWFpbl9sb29wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBwYXJlbnRfc2libGluZyA9IHBhcmVudC5uZXh0O1xuXHRcdFx0XHRpZiAocGFyZW50X3NpYmxpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0XHRjdXJyZW50X2VmZmVjdCA9IHBhcmVudF9zaWJsaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlIG1haW5fbG9vcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnJlbnRfZWZmZWN0ID0gc2libGluZztcblx0fVxuXG5cdC8vIFdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBtYW55IGVmZmVjdHMgaGVyZSwgZmFyIG1vcmUgdGhhbiBjYW4gYmUgc3ByZWFkIGludG9cblx0Ly8gYW4gYXJyYXkgcHVzaCBjYWxsIChjYWxsc3RhY2sgb3ZlcmZsb3cpLiBTbyBsZXQncyBkZWFsIHdpdGggZWFjaCBlZmZlY3QgaW4gYSBsb29wLlxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZCA9IGVmZmVjdHNbaV07XG5cdFx0Y29sbGVjdGVkX2VmZmVjdHMucHVzaChjaGlsZCk7XG5cdFx0cHJvY2Vzc19lZmZlY3RzKGNoaWxkLCBjb2xsZWN0ZWRfZWZmZWN0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB2ZXJzaW9uIG9mIGBmbHVzaFN5bmNgIHdpdGggdGhlIG9wdGlvbiB0byBub3QgZmx1c2ggcHJldmlvdXMgZWZmZWN0cy5cbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9uLCBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBbZm5dXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfc3luYyhmbikge1xuXHR2YXIgcHJldmlvdXNfc2NoZWR1bGVyX21vZGUgPSBzY2hlZHVsZXJfbW9kZTtcblx0dmFyIHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMgPSBxdWV1ZWRfcm9vdF9lZmZlY3RzO1xuXG5cdHRyeSB7XG5cdFx0aW5maW5pdGVfbG9vcF9ndWFyZCgpO1xuXG5cdFx0LyoqIEB0eXBlIHtFZmZlY3RbXX0gKi9cblx0XHRjb25zdCByb290X2VmZmVjdHMgPSBbXTtcblxuXHRcdHNjaGVkdWxlcl9tb2RlID0gRkxVU0hfU1lOQztcblx0XHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gcm9vdF9lZmZlY3RzO1xuXHRcdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cblx0XHRmbHVzaF9xdWV1ZWRfcm9vdF9lZmZlY3RzKHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMpO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGZuPy4oKTtcblxuXHRcdGZsdXNoX3Rhc2tzKCk7XG5cdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCB8fCByb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Zmx1c2hfc3luYygpO1xuXHRcdH1cblxuXHRcdGZsdXNoX2NvdW50ID0gMDtcblx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9IGZpbmFsbHkge1xuXHRcdHNjaGVkdWxlcl9tb2RlID0gcHJldmlvdXNfc2NoZWR1bGVyX21vZGU7XG5cdFx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHM7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGljaygpIHtcblx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdC8vIEJ5IGNhbGxpbmcgZmx1c2hfc3luYyB3ZSBndWFyYW50ZWUgdGhhdCBhbnkgcGVuZGluZyBzdGF0ZSBjaGFuZ2VzIGFyZSBhcHBsaWVkIGFmdGVyIG9uZSB0aWNrLlxuXHQvLyBUT0RPIGxvb2sgaW50byB3aGV0aGVyIHdlIGNhbiBtYWtlIGZsdXNoaW5nIHN1YnNlcXVlbnQgdXBkYXRlcyBzeW5jaHJvbm91c2x5IGluIHRoZSBmdXR1cmUuXG5cdGZsdXNoX3N5bmMoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPn0gc2lnbmFsXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzaWduYWwpIHtcblx0dmFyIGZsYWdzID0gc2lnbmFsLmY7XG5cdHZhciBpc19kZXJpdmVkID0gKGZsYWdzICYgREVSSVZFRCkgIT09IDA7XG5cblx0Ly8gSWYgdGhlIGRlcml2ZWQgaXMgZGVzdHJveWVkLCBqdXN0IGV4ZWN1dGUgaXQgYWdhaW4gd2l0aG91dCByZXRhaW5pbmdcblx0Ly8gaXRzIG1lbW9pc2F0aW9uIHByb3BlcnRpZXMgYXMgdGhlIGRlcml2ZWQgaXMgc3RhbGVcblx0aWYgKGlzX2Rlcml2ZWQgJiYgKGZsYWdzICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdHZhciB2YWx1ZSA9IGV4ZWN1dGVfZGVyaXZlZCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpKTtcblx0XHQvLyBFbnN1cmUgdGhlIGRlcml2ZWQgcmVtYWlucyBkZXN0cm95ZWRcblx0XHRkZXN0cm95X2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKSk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKGNhcHR1cmVkX3NpZ25hbHMgIT09IG51bGwpIHtcblx0XHRjYXB0dXJlZF9zaWduYWxzLmFkZChzaWduYWwpO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGRlcGVuZGVuY3kgb24gdGhlIGN1cnJlbnQgcmVhY3Rpb24gc2lnbmFsLlxuXHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsKSB7XG5cdFx0aWYgKGRlcml2ZWRfc291cmNlcyAhPT0gbnVsbCAmJiBkZXJpdmVkX3NvdXJjZXMuaW5jbHVkZXMoc2lnbmFsKSkge1xuXHRcdFx0ZS5zdGF0ZV91bnNhZmVfbG9jYWxfcmVhZCgpO1xuXHRcdH1cblx0XHR2YXIgZGVwcyA9IGFjdGl2ZV9yZWFjdGlvbi5kZXBzO1xuXG5cdFx0Ly8gSWYgdGhlIHNpZ25hbCBpcyBhY2Nlc3NpbmcgdGhlIHNhbWUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lXG5cdFx0Ly8gb3JkZXIgYXMgaXQgZGlkIGxhc3QgdGltZSwgaW5jcmVtZW50IGBza2lwcGVkX2RlcHNgXG5cdFx0Ly8gcmF0aGVyIHRoYW4gdXBkYXRpbmcgYG5ld19kZXBzYCwgd2hpY2ggY3JlYXRlcyBHQyBjb3N0XG5cdFx0aWYgKG5ld19kZXBzID09PSBudWxsICYmIGRlcHMgIT09IG51bGwgJiYgZGVwc1tza2lwcGVkX2RlcHNdID09PSBzaWduYWwpIHtcblx0XHRcdHNraXBwZWRfZGVwcysrO1xuXHRcdH0gZWxzZSBpZiAobmV3X2RlcHMgPT09IG51bGwpIHtcblx0XHRcdG5ld19kZXBzID0gW3NpZ25hbF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld19kZXBzLnB1c2goc2lnbmFsKTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHR1bnRyYWNrZWRfd3JpdGVzICE9PSBudWxsICYmXG5cdFx0XHRhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmXG5cdFx0XHQoYWN0aXZlX2VmZmVjdC5mICYgQ0xFQU4pICE9PSAwICYmXG5cdFx0XHQoYWN0aXZlX2VmZmVjdC5mICYgQlJBTkNIX0VGRkVDVCkgPT09IDAgJiZcblx0XHRcdHVudHJhY2tlZF93cml0ZXMuaW5jbHVkZXMoc2lnbmFsKVxuXHRcdCkge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoYWN0aXZlX2VmZmVjdCwgRElSVFkpO1xuXHRcdFx0c2NoZWR1bGVfZWZmZWN0KGFjdGl2ZV9lZmZlY3QpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChpc19kZXJpdmVkICYmIC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCkuZGVwcyA9PT0gbnVsbCkge1xuXHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKTtcblx0XHR2YXIgcGFyZW50ID0gZGVyaXZlZC5wYXJlbnQ7XG5cdFx0dmFyIHRhcmdldCA9IGRlcml2ZWQ7XG5cblx0XHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHQvLyBBdHRhY2ggdGhlIGRlcml2ZWQgdG8gdGhlIG5lYXJlc3QgcGFyZW50IGVmZmVjdCwgaWYgdGhlcmUgYXJlIGRlcml2ZWRzXG5cdFx0XHQvLyBpbiBiZXR3ZWVuIHRoZW4gd2UgYWxzbyBuZWVkIHRvIGF0dGFjaCB0aGVtIHRvb1xuXHRcdFx0aWYgKChwYXJlbnQuZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHRcdHZhciBwYXJlbnRfZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHBhcmVudCk7XG5cblx0XHRcdFx0dGFyZ2V0ID0gcGFyZW50X2Rlcml2ZWQ7XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudF9kZXJpdmVkLnBhcmVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJlbnRfZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChwYXJlbnQpO1xuXG5cdFx0XHRcdGlmICghcGFyZW50X2VmZmVjdC5kZXJpdmVkcz8uaW5jbHVkZXModGFyZ2V0KSkge1xuXHRcdFx0XHRcdChwYXJlbnRfZWZmZWN0LmRlcml2ZWRzID8/PSBbXSkucHVzaCh0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChpc19kZXJpdmVkKSB7XG5cdFx0ZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCk7XG5cblx0XHRpZiAoY2hlY2tfZGlydGluZXNzKGRlcml2ZWQpKSB7XG5cdFx0XHR1cGRhdGVfZGVyaXZlZChkZXJpdmVkKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoXG5cdFx0REVWICYmXG5cdFx0dHJhY2luZ19tb2RlX2ZsYWcgJiZcblx0XHR0cmFjaW5nX2V4cHJlc3Npb25zICE9PSBudWxsICYmXG5cdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmXG5cdFx0dHJhY2luZ19leHByZXNzaW9ucy5yZWFjdGlvbiA9PT0gYWN0aXZlX3JlYWN0aW9uXG5cdCkge1xuXHRcdC8vIFVzZWQgd2hlbiBtYXBwaW5nIHN0YXRlIGJldHdlZW4gc3BlY2lhbCBibG9ja3MgbGlrZSBgZWFjaGBcblx0XHRpZiAoc2lnbmFsLmRlYnVnKSB7XG5cdFx0XHRzaWduYWwuZGVidWcoKTtcblx0XHR9IGVsc2UgaWYgKHNpZ25hbC5jcmVhdGVkKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuZ2V0KHNpZ25hbCk7XG5cblx0XHRcdGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGVudHJ5ID0geyByZWFkOiBbXSB9O1xuXHRcdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuc2V0KHNpZ25hbCwgZW50cnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRlbnRyeS5yZWFkLnB1c2goZ2V0X3N0YWNrKCdUcmFjZWRBdCcpKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsLnY7XG59XG5cbi8qKlxuICogTGlrZSBgZ2V0YCwgYnV0IGNoZWNrcyBmb3IgYHVuZGVmaW5lZGAuIFVzZWQgZm9yIGB2YXJgIGRlY2xhcmF0aW9ucyBiZWNhdXNlIHRoZXkgY2FuIGJlIGFjY2Vzc2VkIGJlZm9yZSBiZWluZyBkZWNsYXJlZFxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj4gfCB1bmRlZmluZWR9IHNpZ25hbFxuICogQHJldHVybnMge1YgfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX2dldChzaWduYWwpIHtcblx0cmV0dXJuIHNpZ25hbCAmJiBnZXQoc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlIGFuIGFycmF5IG9mIGFsbCB0aGUgc2lnbmFscyB0aGF0IGFyZSByZWFkIHdoZW4gYGZuYCBpcyBjYWxsZWRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlX3NpZ25hbHMoZm4pIHtcblx0dmFyIHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMgPSBjYXB0dXJlZF9zaWduYWxzO1xuXHRjYXB0dXJlZF9zaWduYWxzID0gbmV3IFNldCgpO1xuXG5cdHZhciBjYXB0dXJlZCA9IGNhcHR1cmVkX3NpZ25hbHM7XG5cdHZhciBzaWduYWw7XG5cblx0dHJ5IHtcblx0XHR1bnRyYWNrKGZuKTtcblx0XHRpZiAocHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscyAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yIChzaWduYWwgb2YgY2FwdHVyZWRfc2lnbmFscykge1xuXHRcdFx0XHRwcmV2aW91c19jYXB0dXJlZF9zaWduYWxzLmFkZChzaWduYWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRjYXB0dXJlZF9zaWduYWxzID0gcHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscztcblx0fVxuXG5cdHJldHVybiBjYXB0dXJlZDtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGEgZnVuY3Rpb24gYW5kIGNhcHR1cmVzIGFsbCBzaWduYWxzIHRoYXQgYXJlIHJlYWQgZHVyaW5nIHRoZSBpbnZvY2F0aW9uLFxuICogdGhlbiBpbnZhbGlkYXRlcyB0aGVtLlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlX2lubmVyX3NpZ25hbHMoZm4pIHtcblx0dmFyIGNhcHR1cmVkID0gY2FwdHVyZV9zaWduYWxzKCgpID0+IHVudHJhY2soZm4pKTtcblxuXHRmb3IgKHZhciBzaWduYWwgb2YgY2FwdHVyZWQpIHtcblx0XHQvLyBHbyBvbmUgbGV2ZWwgdXAgYmVjYXVzZSBkZXJpdmVkIHNpZ25hbHMgY3JlYXRlZCBhcyBwYXJ0IG9mIHByb3BzIGluIGxlZ2FjeSBtb2RlXG5cdFx0aWYgKChzaWduYWwuZiAmIExFR0FDWV9ERVJJVkVEX1BST1ApICE9PSAwKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGRlcCBvZiAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmRlcHMgfHwgW10pIHtcblx0XHRcdFx0aWYgKChkZXAuZiAmIERFUklWRUQpID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gVXNlIGludGVybmFsX3NldCBpbnN0ZWFkIG9mIHNldCBoZXJlIGFuZCBiZWxvdyB0byBhdm9pZCBtdXRhdGlvbiB2YWxpZGF0aW9uXG5cdFx0XHRcdFx0aW50ZXJuYWxfc2V0KGRlcCwgZGVwLnYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGludGVybmFsX3NldChzaWduYWwsIHNpZ25hbC52KTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW5zaWRlIGEgW2AkZGVyaXZlZGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZGVyaXZlZCkgb3IgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpLFxuICogYW55IHN0YXRlIHJlYWQgaW5zaWRlIGBmbmAgd2lsbCBub3QgYmUgdHJlYXRlZCBhcyBhIGRlcGVuZGVuY3kuXG4gKlxuICogYGBgdHNcbiAqICRlZmZlY3QoKCkgPT4ge1xuICogICAvLyB0aGlzIHdpbGwgcnVuIHdoZW4gYGRhdGFgIGNoYW5nZXMsIGJ1dCBub3Qgd2hlbiBgdGltZWAgY2hhbmdlc1xuICogICBzYXZlKGRhdGEsIHtcbiAqICAgICB0aW1lc3RhbXA6IHVudHJhY2soKCkgPT4gdGltZSlcbiAqICAgfSk7XG4gKiB9KTtcbiAqIGBgYFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW50cmFjayhmbikge1xuXHRjb25zdCBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dHJ5IHtcblx0XHRhY3RpdmVfcmVhY3Rpb24gPSBudWxsO1xuXHRcdHJldHVybiBmbigpO1xuXHR9IGZpbmFsbHkge1xuXHRcdGFjdGl2ZV9yZWFjdGlvbiA9IHByZXZpb3VzX3JlYWN0aW9uO1xuXHR9XG59XG5cbmNvbnN0IFNUQVRVU19NQVNLID0gfihESVJUWSB8IE1BWUJFX0RJUlRZIHwgQ0xFQU4pO1xuXG4vKipcbiAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NpZ25hbF9zdGF0dXMoc2lnbmFsLCBzdGF0dXMpIHtcblx0c2lnbmFsLmYgPSAoc2lnbmFsLmYgJiBTVEFUVVNfTUFTSykgfCBzdGF0dXM7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnZ2V0Q29udGV4dCcpO1xuXHRjb25zdCByZXN1bHQgPSAvKiogQHR5cGUge1R9ICovIChjb250ZXh0X21hcC5nZXQoa2V5KSk7XG5cblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGZuID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpLmZ1bmN0aW9uO1xuXHRcdGlmIChmbikge1xuXHRcdFx0YWRkX293bmVyKHJlc3VsdCwgZm4sIHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXNzb2NpYXRlcyBhbiBhcmJpdHJhcnkgYGNvbnRleHRgIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50IGNvbXBvbmVudCBhbmQgdGhlIHNwZWNpZmllZCBga2V5YFxuICogYW5kIHJldHVybnMgdGhhdCBvYmplY3QuIFRoZSBjb250ZXh0IGlzIHRoZW4gYXZhaWxhYmxlIHRvIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnRcbiAqIChpbmNsdWRpbmcgc2xvdHRlZCBjb250ZW50KSB3aXRoIGBnZXRDb250ZXh0YC5cbiAqXG4gKiBMaWtlIGxpZmVjeWNsZSBmdW5jdGlvbnMsIHRoaXMgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHBhcmFtIHtUfSBjb250ZXh0XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ3NldENvbnRleHQnKTtcblx0Y29udGV4dF9tYXAuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdoYXNDb250ZXh0Jyk7XG5cdHJldHVybiBjb250ZXh0X21hcC5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gW1Q9TWFwPGFueSwgYW55Pl1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ2dldEFsbENvbnRleHRzJyk7XG5cblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGZuID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uO1xuXHRcdGlmIChmbikge1xuXHRcdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiBjb250ZXh0X21hcC52YWx1ZXMoKSkge1xuXHRcdFx0XHRhZGRfb3duZXIodmFsdWUsIGZuLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+fVxuICovXG5mdW5jdGlvbiBnZXRfb3JfaW5pdF9jb250ZXh0X21hcChuYW1lKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudChuYW1lKTtcblx0fVxuXG5cdHJldHVybiAoY29tcG9uZW50X2NvbnRleHQuYyA/Pz0gbmV3IE1hcChnZXRfcGFyZW50X2NvbnRleHQoY29tcG9uZW50X2NvbnRleHQpIHx8IHVuZGVmaW5lZCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dH0gY29tcG9uZW50X2NvbnRleHRcbiAqIEByZXR1cm5zIHtNYXA8dW5rbm93biwgdW5rbm93bj4gfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRfcGFyZW50X2NvbnRleHQoY29tcG9uZW50X2NvbnRleHQpIHtcblx0bGV0IHBhcmVudCA9IGNvbXBvbmVudF9jb250ZXh0LnA7XG5cdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRjb25zdCBjb250ZXh0X21hcCA9IHBhcmVudC5jO1xuXHRcdGlmIChjb250ZXh0X21hcCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHRfbWFwO1xuXHRcdH1cblx0XHRwYXJlbnQgPSBwYXJlbnQucDtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge251bWJlciB8IGJpZ2ludH0gVFxuICogQHBhcmFtIHtWYWx1ZTxUPn0gc2lnbmFsXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShzaWduYWwsIGQgPSAxKSB7XG5cdHZhciB2YWx1ZSA9IGdldChzaWduYWwpO1xuXHR2YXIgcmVzdWx0ID0gZCA9PT0gMSA/IHZhbHVlKysgOiB2YWx1ZS0tO1xuXG5cdHNldChzaWduYWwsIHZhbHVlKTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtudW1iZXIgfCBiaWdpbnR9IFRcbiAqIEBwYXJhbSB7VmFsdWU8VD59IHNpZ25hbFxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlKHNpZ25hbCwgZCA9IDEpIHtcblx0dmFyIHZhbHVlID0gZ2V0KHNpZ25hbCk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gc2V0KHNpZ25hbCwgZCA9PT0gMSA/ICsrdmFsdWUgOiAtLXZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGtleXNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVfZnJvbV9vYmplY3Qob2JqLCBrZXlzKSB7XG5cdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICovXG5cdHZhciByZXN1bHQgPSB7fTtcblxuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcblx0XHRcdHJlc3VsdFtrZXldID0gb2JqW2tleV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHthbnl9IHJ1bmVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1c2gocHJvcHMsIHJ1bmVzID0gZmFsc2UsIGZuKSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0ge1xuXHRcdHA6IGNvbXBvbmVudF9jb250ZXh0LFxuXHRcdGM6IG51bGwsXG5cdFx0ZTogbnVsbCxcblx0XHRtOiBmYWxzZSxcblx0XHRzOiBwcm9wcyxcblx0XHR4OiBudWxsLFxuXHRcdGw6IG51bGxcblx0fTtcblxuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiAhcnVuZXMpIHtcblx0XHRjb21wb25lbnRfY29udGV4dC5sID0ge1xuXHRcdFx0czogbnVsbCxcblx0XHRcdHU6IG51bGwsXG5cdFx0XHRyMTogW10sXG5cdFx0XHRyMjogc291cmNlKGZhbHNlKVxuXHRcdH07XG5cdH1cblxuXHRpZiAoREVWKSB7XG5cdFx0Ly8gY29tcG9uZW50IGZ1bmN0aW9uXG5cdFx0Y29tcG9uZW50X2NvbnRleHQuZnVuY3Rpb24gPSBmbjtcblx0XHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBmbjtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gVFxuICogQHBhcmFtIHtUfSBbY29tcG9uZW50XVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3AoY29tcG9uZW50KSB7XG5cdGNvbnN0IGNvbnRleHRfc3RhY2tfaXRlbSA9IGNvbXBvbmVudF9jb250ZXh0O1xuXHRpZiAoY29udGV4dF9zdGFja19pdGVtICE9PSBudWxsKSB7XG5cdFx0aWYgKGNvbXBvbmVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250ZXh0X3N0YWNrX2l0ZW0ueCA9IGNvbXBvbmVudDtcblx0XHR9XG5cdFx0Y29uc3QgY29tcG9uZW50X2VmZmVjdHMgPSBjb250ZXh0X3N0YWNrX2l0ZW0uZTtcblx0XHRpZiAoY29tcG9uZW50X2VmZmVjdHMgIT09IG51bGwpIHtcblx0XHRcdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRcdFx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHRcdFx0Y29udGV4dF9zdGFja19pdGVtLmUgPSBudWxsO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRfZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBjb21wb25lbnRfZWZmZWN0ID0gY29tcG9uZW50X2VmZmVjdHNbaV07XG5cdFx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QoY29tcG9uZW50X2VmZmVjdC5lZmZlY3QpO1xuXHRcdFx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24oY29tcG9uZW50X2VmZmVjdC5yZWFjdGlvbik7XG5cdFx0XHRcdFx0ZWZmZWN0KGNvbXBvbmVudF9lZmZlY3QuZm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29tcG9uZW50X2NvbnRleHQgPSBjb250ZXh0X3N0YWNrX2l0ZW0ucDtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBjb250ZXh0X3N0YWNrX2l0ZW0ucD8uZnVuY3Rpb24gPz8gbnVsbDtcblx0XHR9XG5cdFx0Y29udGV4dF9zdGFja19pdGVtLm0gPSB0cnVlO1xuXHR9XG5cdC8vIE1pY3JvLW9wdGltaXphdGlvbjogRG9uJ3Qgc2V0IC5hIGFib3ZlIHRvIHRoZSBlbXB0eSBvYmplY3Rcblx0Ly8gc28gaXQgY2FuIGJlIGdhcmJhZ2UtY29sbGVjdGVkIHdoZW4gdGhlIHJldHVybiBoZXJlIGlzIHVudXNlZFxuXHRyZXR1cm4gY29tcG9uZW50IHx8IC8qKiBAdHlwZSB7VH0gKi8gKHt9KTtcbn1cblxuLyoqXG4gKiBQb3NzaWJseSB0cmF2ZXJzZSBhbiBvYmplY3QgYW5kIHJlYWQgYWxsIGl0cyBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVhY3RpdmUgaW4gY2FzZSB0aGlzIGlzIGAkc3RhdGVgLlxuICogRG9lcyBvbmx5IGNoZWNrIGZpcnN0IGxldmVsIG9mIGFuIG9iamVjdCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAoaGV1cmlzdGljIHNob3VsZCBiZSBnb29kIGZvciA5OSUgb2YgYWxsIGNhc2VzKS5cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwX3JlYWRfc3RhdGUodmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgIXZhbHVlIHx8IHZhbHVlIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoU1RBVEVfU1lNQk9MIGluIHZhbHVlKSB7XG5cdFx0ZGVlcF9yZWFkKHZhbHVlKTtcblx0fSBlbHNlIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdGNvbnN0IHByb3AgPSB2YWx1ZVtrZXldO1xuXHRcdFx0aWYgKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0JyAmJiBwcm9wICYmIFNUQVRFX1NZTUJPTCBpbiBwcm9wKSB7XG5cdFx0XHRcdGRlZXBfcmVhZChwcm9wKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBEZWVwbHkgdHJhdmVyc2UgYW4gb2JqZWN0IGFuZCByZWFkIGFsbCBpdHMgcHJvcGVydGllc1xuICogc28gdGhhdCB0aGV5J3JlIGFsbCByZWFjdGl2ZSBpbiBjYXNlIHRoaXMgaXMgYCRzdGF0ZWBcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtTZXQ8YW55Pn0gdmlzaXRlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwX3JlYWQodmFsdWUsIHZpc2l0ZWQgPSBuZXcgU2V0KCkpIHtcblx0aWYgKFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2UgRE9NIGVsZW1lbnRzXG5cdFx0ISh2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSAmJlxuXHRcdCF2aXNpdGVkLmhhcyh2YWx1ZSlcblx0KSB7XG5cdFx0dmlzaXRlZC5hZGQodmFsdWUpO1xuXHRcdC8vIFdoZW4gd29ya2luZyB3aXRoIGEgcG9zc2libGUgU3ZlbHRlRGF0ZSwgdGhpc1xuXHRcdC8vIHdpbGwgZW5zdXJlIHdlIGNhcHR1cmUgY2hhbmdlcyB0byBpdC5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHR2YWx1ZS5nZXRUaW1lKCk7XG5cdFx0fVxuXHRcdGZvciAobGV0IGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGVlcF9yZWFkKHZhbHVlW2tleV0sIHZpc2l0ZWQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBjb250aW51ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBwcm90byA9IGdldF9wcm90b3R5cGVfb2YodmFsdWUpO1xuXHRcdGlmIChcblx0XHRcdHByb3RvICE9PSBPYmplY3QucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gQXJyYXkucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gTWFwLnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IFNldC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBEYXRlLnByb3RvdHlwZVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgZGVzY3JpcHRvcnMgPSBnZXRfZGVzY3JpcHRvcnMocHJvdG8pO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIGRlc2NyaXB0b3JzKSB7XG5cdFx0XHRcdGNvbnN0IGdldCA9IGRlc2NyaXB0b3JzW2tleV0uZ2V0O1xuXHRcdFx0XHRpZiAoZ2V0KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGdldC5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5pZiAoREVWKSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuXHQgKi9cblx0ZnVuY3Rpb24gdGhyb3dfcnVuZV9lcnJvcihydW5lKSB7XG5cdFx0aWYgKCEocnVuZSBpbiBnbG9iYWxUaGlzKSkge1xuXHRcdFx0Ly8gVE9ETyBpZiBwZW9wbGUgc3RhcnQgYWRqdXN0aW5nIHRoZSBcInRoaXMgY2FuIGNvbnRhaW4gcnVuZXNcIiBjb25maWcgdGhyb3VnaCB2LXAtcyBtb3JlLCBhZGp1c3QgdGhpcyBtZXNzYWdlXG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi9cblx0XHRcdGxldCB2YWx1ZTsgLy8gbGV0J3MgaG9wZSBub29uZSBtb2RpZmllcyB0aGlzIGdsb2JhbCwgYnV0IGJlbHRzIGFuZCBicmFjZXNcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBydW5lLCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlLnJ1bmVfb3V0c2lkZV9zdmVsdGUocnVuZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogKHYpID0+IHtcblx0XHRcdFx0XHR2YWx1ZSA9IHY7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHRocm93X3J1bmVfZXJyb3IoJyRzdGF0ZScpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckZWZmZWN0Jyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRkZXJpdmVkJyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRpbnNwZWN0Jyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRwcm9wcycpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckYmluZGFibGUnKTtcbn1cbiIsImNvbnN0IHJlZ2V4X3JldHVybl9jaGFyYWN0ZXJzID0gL1xcci9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHN0cikge1xuXHRzdHIgPSBzdHIucmVwbGFjZShyZWdleF9yZXR1cm5fY2hhcmFjdGVycywgJycpO1xuXHRsZXQgaGFzaCA9IDUzODE7XG5cdGxldCBpID0gc3RyLmxlbmd0aDtcblxuXHR3aGlsZSAoaS0tKSBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcblx0cmV0dXJuIChoYXNoID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbmNvbnN0IFZPSURfRUxFTUVOVF9OQU1FUyA9IFtcblx0J2FyZWEnLFxuXHQnYmFzZScsXG5cdCdicicsXG5cdCdjb2wnLFxuXHQnY29tbWFuZCcsXG5cdCdlbWJlZCcsXG5cdCdocicsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQna2V5Z2VuJyxcblx0J2xpbmsnLFxuXHQnbWV0YScsXG5cdCdwYXJhbScsXG5cdCdzb3VyY2UnLFxuXHQndHJhY2snLFxuXHQnd2JyJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgb2YgYSB2b2lkIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc192b2lkKG5hbWUpIHtcblx0cmV0dXJuIFZPSURfRUxFTUVOVF9OQU1FUy5pbmNsdWRlcyhuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IFJFU0VSVkVEX1dPUkRTID0gW1xuXHQnYXJndW1lbnRzJyxcblx0J2F3YWl0Jyxcblx0J2JyZWFrJyxcblx0J2Nhc2UnLFxuXHQnY2F0Y2gnLFxuXHQnY2xhc3MnLFxuXHQnY29uc3QnLFxuXHQnY29udGludWUnLFxuXHQnZGVidWdnZXInLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWxldGUnLFxuXHQnZG8nLFxuXHQnZWxzZScsXG5cdCdlbnVtJyxcblx0J2V2YWwnLFxuXHQnZXhwb3J0Jyxcblx0J2V4dGVuZHMnLFxuXHQnZmFsc2UnLFxuXHQnZmluYWxseScsXG5cdCdmb3InLFxuXHQnZnVuY3Rpb24nLFxuXHQnaWYnLFxuXHQnaW1wbGVtZW50cycsXG5cdCdpbXBvcnQnLFxuXHQnaW4nLFxuXHQnaW5zdGFuY2VvZicsXG5cdCdpbnRlcmZhY2UnLFxuXHQnbGV0Jyxcblx0J25ldycsXG5cdCdudWxsJyxcblx0J3BhY2thZ2UnLFxuXHQncHJpdmF0ZScsXG5cdCdwcm90ZWN0ZWQnLFxuXHQncHVibGljJyxcblx0J3JldHVybicsXG5cdCdzdGF0aWMnLFxuXHQnc3VwZXInLFxuXHQnc3dpdGNoJyxcblx0J3RoaXMnLFxuXHQndGhyb3cnLFxuXHQndHJ1ZScsXG5cdCd0cnknLFxuXHQndHlwZW9mJyxcblx0J3ZhcicsXG5cdCd2b2lkJyxcblx0J3doaWxlJyxcblx0J3dpdGgnLFxuXHQneWllbGQnXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGB3b3JkYCBpcyBhIHJlc2VydmVkIEphdmFTY3JpcHQga2V5d29yZFxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Jlc2VydmVkKHdvcmQpIHtcblx0cmV0dXJuIFJFU0VSVkVEX1dPUkRTLmluY2x1ZGVzKHdvcmQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jYXB0dXJlX2V2ZW50KG5hbWUpIHtcblx0cmV0dXJuIG5hbWUuZW5kc1dpdGgoJ2NhcHR1cmUnKSAmJiBuYW1lICE9PSAnZ290cG9pbnRlcmNhcHR1cmUnICYmIG5hbWUgIT09ICdsb3N0cG9pbnRlcmNhcHR1cmUnO1xufVxuXG4vKiogTGlzdCBvZiBFbGVtZW50IGV2ZW50cyB0aGF0IHdpbGwgYmUgZGVsZWdhdGVkICovXG5jb25zdCBERUxFR0FURURfRVZFTlRTID0gW1xuXHQnYmVmb3JlaW5wdXQnLFxuXHQnY2xpY2snLFxuXHQnY2hhbmdlJyxcblx0J2RibGNsaWNrJyxcblx0J2NvbnRleHRtZW51Jyxcblx0J2ZvY3VzaW4nLFxuXHQnZm9jdXNvdXQnLFxuXHQnaW5wdXQnLFxuXHQna2V5ZG93bicsXG5cdCdrZXl1cCcsXG5cdCdtb3VzZWRvd24nLFxuXHQnbW91c2Vtb3ZlJyxcblx0J21vdXNlb3V0Jyxcblx0J21vdXNlb3ZlcicsXG5cdCdtb3VzZXVwJyxcblx0J3BvaW50ZXJkb3duJyxcblx0J3BvaW50ZXJtb3ZlJyxcblx0J3BvaW50ZXJvdXQnLFxuXHQncG9pbnRlcm92ZXInLFxuXHQncG9pbnRlcnVwJyxcblx0J3RvdWNoZW5kJyxcblx0J3RvdWNobW92ZScsXG5cdCd0b3VjaHN0YXJ0J1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgZXZlbnRfbmFtZWAgaXMgYSBkZWxlZ2F0ZWQgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kZWxlZ2F0ZWQoZXZlbnRfbmFtZSkge1xuXHRyZXR1cm4gREVMRUdBVEVEX0VWRU5UUy5pbmNsdWRlcyhldmVudF9uYW1lKTtcbn1cblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHRoYXQgYXJlIGJvb2xlYW4sIGkuZS4gdGhleSBhcmUgcHJlc2VudCBvciBub3QgcHJlc2VudC5cbiAqL1xuY29uc3QgRE9NX0JPT0xFQU5fQVRUUklCVVRFUyA9IFtcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2hpZGRlbicsXG5cdCdpbmRldGVybWluYXRlJyxcblx0J2lzbWFwJyxcblx0J2xvb3AnLFxuXHQnbXVsdGlwbGUnLFxuXHQnbXV0ZWQnLFxuXHQnbm9tb2R1bGUnLFxuXHQnbm92YWxpZGF0ZScsXG5cdCdvcGVuJyxcblx0J3BsYXlzaW5saW5lJyxcblx0J3JlYWRvbmx5Jyxcblx0J3JlcXVpcmVkJyxcblx0J3JldmVyc2VkJyxcblx0J3NlYW1sZXNzJyxcblx0J3NlbGVjdGVkJyxcblx0J3dlYmtpdGRpcmVjdG9yeSdcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19ib29sZWFuX2F0dHJpYnV0ZShuYW1lKSB7XG5cdHJldHVybiBET01fQk9PTEVBTl9BVFRSSUJVVEVTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBzaG91bGQgYmUgYWxpYXNlZCB0byB0aGVpciBwcm9wZXJ0eSBuYW1lc1xuICogYmVjYXVzZSB0aGV5IGJlaGF2ZSBkaWZmZXJlbnRseSBiZXR3ZWVuIHNldHRpbmcgdGhlbSBhcyBhbiBhdHRyaWJ1dGUgYW5kXG4gKiBzZXR0aW5nIHRoZW0gYXMgYSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgQVRUUklCVVRFX0FMSUFTRVMgPSB7XG5cdC8vIG5vIGBjbGFzczogJ2NsYXNzTmFtZSdgIGJlY2F1c2Ugd2UgaGFuZGxlIHRoYXQgc2VwYXJhdGVseVxuXHRmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcblx0aXNtYXA6ICdpc01hcCcsXG5cdG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuXHRwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcblx0cmVhZG9ubHk6ICdyZWFkT25seScsXG5cdGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG5cdGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuXHRzcmNvYmplY3Q6ICdzcmNPYmplY3QnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVfYXR0cmlidXRlKG5hbWUpIHtcblx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0cmV0dXJuIEFUVFJJQlVURV9BTElBU0VTW25hbWVdID8/IG5hbWU7XG59XG5cbmNvbnN0IERPTV9QUk9QRVJUSUVTID0gW1xuXHQuLi5ET01fQk9PTEVBTl9BVFRSSUJVVEVTLFxuXHQnZm9ybU5vVmFsaWRhdGUnLFxuXHQnaXNNYXAnLFxuXHQnbm9Nb2R1bGUnLFxuXHQncGxheXNJbmxpbmUnLFxuXHQncmVhZE9ubHknLFxuXHQndmFsdWUnLFxuXHQnaW5lcnQnLFxuXHQndm9sdW1lJyxcblx0J2RlZmF1bHRWYWx1ZScsXG5cdCdkZWZhdWx0Q2hlY2tlZCcsXG5cdCdzcmNPYmplY3QnXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kb21fcHJvcGVydHkobmFtZSkge1xuXHRyZXR1cm4gRE9NX1BST1BFUlRJRVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE5PTl9TVEFUSUNfUFJPUEVSVElFUyA9IFsnYXV0b2ZvY3VzJywgJ211dGVkJywgJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCddO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgY2Fubm90IGJlIHNldCB0aHJvdWdoIHRoZSB0ZW1wbGF0ZVxuICogc3RyaW5nLCBpLmUuIG5lZWRzIHNvbWUga2luZCBvZiBKYXZhU2NyaXB0IGhhbmRsaW5nIHRvIHdvcmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90X2JlX3NldF9zdGF0aWNhbGx5KG5hbWUpIHtcblx0cmV0dXJuIE5PTl9TVEFUSUNfUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBTdWJzZXQgb2YgZGVsZWdhdGVkIGV2ZW50cyB3aGljaCBzaG91bGQgYmUgcGFzc2l2ZSBieSBkZWZhdWx0LlxuICogVGhlc2UgdHdvIGFyZSBhbHJlYWR5IHBhc3NpdmUgdmlhIGJyb3dzZXIgZGVmYXVsdHMgb24gd2luZG93LCBkb2N1bWVudCBhbmQgYm9keS5cbiAqIEJ1dCBzaW5jZVxuICogLSB3ZSdyZSBkZWxlZ2F0aW5nIHRoZW1cbiAqIC0gdGhleSBoYXBwZW4gb2Z0ZW5cbiAqIC0gdGhleSBhcHBseSB0byBtb2JpbGUgd2hpY2ggaXMgZ2VuZXJhbGx5IGxlc3MgcGVyZm9ybWFudFxuICogd2UncmUgbWFya2luZyB0aGVtIGFzIHBhc3NpdmUgYnkgZGVmYXVsdCBmb3Igb3RoZXIgZWxlbWVudHMsIHRvby5cbiAqL1xuY29uc3QgUEFTU0lWRV9FVkVOVFMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIGEgcGFzc2l2ZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Bhc3NpdmVfZXZlbnQobmFtZSkge1xuXHRyZXR1cm4gUEFTU0lWRV9FVkVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IENPTlRFTlRfRURJVEFCTEVfQklORElOR1MgPSBbJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCcsICdpbm5lclRleHQnXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY29udGVudF9lZGl0YWJsZV9iaW5kaW5nKG5hbWUpIHtcblx0cmV0dXJuIENPTlRFTlRfRURJVEFCTEVfQklORElOR1MuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IExPQURfRVJST1JfRUxFTUVOVFMgPSBbXG5cdCdib2R5Jyxcblx0J2VtYmVkJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnbGluaycsXG5cdCdvYmplY3QnLFxuXHQnc2NyaXB0Jyxcblx0J3N0eWxlJyxcblx0J3RyYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBlbWl0cyBgbG9hZGAgYW5kIGBlcnJvcmAgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfbG9hZF9lcnJvcl9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIExPQURfRVJST1JfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFNWR19FTEVNRU5UUyA9IFtcblx0J2FsdEdseXBoJyxcblx0J2FsdEdseXBoRGVmJyxcblx0J2FsdEdseXBoSXRlbScsXG5cdCdhbmltYXRlJyxcblx0J2FuaW1hdGVDb2xvcicsXG5cdCdhbmltYXRlTW90aW9uJyxcblx0J2FuaW1hdGVUcmFuc2Zvcm0nLFxuXHQnY2lyY2xlJyxcblx0J2NsaXBQYXRoJyxcblx0J2NvbG9yLXByb2ZpbGUnLFxuXHQnY3Vyc29yJyxcblx0J2RlZnMnLFxuXHQnZGVzYycsXG5cdCdkaXNjYXJkJyxcblx0J2VsbGlwc2UnLFxuXHQnZmVCbGVuZCcsXG5cdCdmZUNvbG9yTWF0cml4Jyxcblx0J2ZlQ29tcG9uZW50VHJhbnNmZXInLFxuXHQnZmVDb21wb3NpdGUnLFxuXHQnZmVDb252b2x2ZU1hdHJpeCcsXG5cdCdmZURpZmZ1c2VMaWdodGluZycsXG5cdCdmZURpc3BsYWNlbWVudE1hcCcsXG5cdCdmZURpc3RhbnRMaWdodCcsXG5cdCdmZURyb3BTaGFkb3cnLFxuXHQnZmVGbG9vZCcsXG5cdCdmZUZ1bmNBJyxcblx0J2ZlRnVuY0InLFxuXHQnZmVGdW5jRycsXG5cdCdmZUZ1bmNSJyxcblx0J2ZlR2F1c3NpYW5CbHVyJyxcblx0J2ZlSW1hZ2UnLFxuXHQnZmVNZXJnZScsXG5cdCdmZU1lcmdlTm9kZScsXG5cdCdmZU1vcnBob2xvZ3knLFxuXHQnZmVPZmZzZXQnLFxuXHQnZmVQb2ludExpZ2h0Jyxcblx0J2ZlU3BlY3VsYXJMaWdodGluZycsXG5cdCdmZVNwb3RMaWdodCcsXG5cdCdmZVRpbGUnLFxuXHQnZmVUdXJidWxlbmNlJyxcblx0J2ZpbHRlcicsXG5cdCdmb250Jyxcblx0J2ZvbnQtZmFjZScsXG5cdCdmb250LWZhY2UtZm9ybWF0Jyxcblx0J2ZvbnQtZmFjZS1uYW1lJyxcblx0J2ZvbnQtZmFjZS1zcmMnLFxuXHQnZm9udC1mYWNlLXVyaScsXG5cdCdmb3JlaWduT2JqZWN0Jyxcblx0J2cnLFxuXHQnZ2x5cGgnLFxuXHQnZ2x5cGhSZWYnLFxuXHQnaGF0Y2gnLFxuXHQnaGF0Y2hwYXRoJyxcblx0J2hrZXJuJyxcblx0J2ltYWdlJyxcblx0J2xpbmUnLFxuXHQnbGluZWFyR3JhZGllbnQnLFxuXHQnbWFya2VyJyxcblx0J21hc2snLFxuXHQnbWVzaCcsXG5cdCdtZXNoZ3JhZGllbnQnLFxuXHQnbWVzaHBhdGNoJyxcblx0J21lc2hyb3cnLFxuXHQnbWV0YWRhdGEnLFxuXHQnbWlzc2luZy1nbHlwaCcsXG5cdCdtcGF0aCcsXG5cdCdwYXRoJyxcblx0J3BhdHRlcm4nLFxuXHQncG9seWdvbicsXG5cdCdwb2x5bGluZScsXG5cdCdyYWRpYWxHcmFkaWVudCcsXG5cdCdyZWN0Jyxcblx0J3NldCcsXG5cdCdzb2xpZGNvbG9yJyxcblx0J3N0b3AnLFxuXHQnc3ZnJyxcblx0J3N3aXRjaCcsXG5cdCdzeW1ib2wnLFxuXHQndGV4dCcsXG5cdCd0ZXh0UGF0aCcsXG5cdCd0cmVmJyxcblx0J3RzcGFuJyxcblx0J3Vua25vd24nLFxuXHQndXNlJyxcblx0J3ZpZXcnLFxuXHQndmtlcm4nXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19zdmcobmFtZSkge1xuXHRyZXR1cm4gU1ZHX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBNQVRITUxfRUxFTUVOVFMgPSBbXG5cdCdhbm5vdGF0aW9uJyxcblx0J2Fubm90YXRpb24teG1sJyxcblx0J21hY3Rpb24nLFxuXHQnbWF0aCcsXG5cdCdtZXJyb3InLFxuXHQnbWZyYWMnLFxuXHQnbWknLFxuXHQnbW11bHRpc2NyaXB0cycsXG5cdCdtbicsXG5cdCdtbycsXG5cdCdtb3ZlcicsXG5cdCdtcGFkZGVkJyxcblx0J21waGFudG9tJyxcblx0J21wcmVzY3JpcHRzJyxcblx0J21yb290Jyxcblx0J21yb3cnLFxuXHQnbXMnLFxuXHQnbXNwYWNlJyxcblx0J21zcXJ0Jyxcblx0J21zdHlsZScsXG5cdCdtc3ViJyxcblx0J21zdWJzdXAnLFxuXHQnbXN1cCcsXG5cdCdtdGFibGUnLFxuXHQnbXRkJyxcblx0J210ZXh0Jyxcblx0J210cicsXG5cdCdtdW5kZXInLFxuXHQnbXVuZGVyb3ZlcicsXG5cdCdzZW1hbnRpY3MnXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19tYXRobWwobmFtZSkge1xuXHRyZXR1cm4gTUFUSE1MX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBSVU5FUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCckc3RhdGUnLFxuXHQnJHN0YXRlLnJhdycsXG5cdCckc3RhdGUuc25hcHNob3QnLFxuXHQnJHByb3BzJyxcblx0JyRiaW5kYWJsZScsXG5cdCckZGVyaXZlZCcsXG5cdCckZGVyaXZlZC5ieScsXG5cdCckZWZmZWN0Jyxcblx0JyRlZmZlY3QucHJlJyxcblx0JyRlZmZlY3QudHJhY2tpbmcnLFxuXHQnJGVmZmVjdC5yb290Jyxcblx0JyRpbnNwZWN0Jyxcblx0JyRpbnNwZWN0KCkud2l0aCcsXG5cdCckaW5zcGVjdC50cmFjZScsXG5cdCckaG9zdCdcbl0pO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBSVU5FU1tudW1iZXJdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZShuYW1lKSB7XG5cdHJldHVybiBSVU5FUy5pbmNsdWRlcygvKiogQHR5cGUge1JVTkVTW251bWJlcl19ICovIChuYW1lKSk7XG59XG5cbi8qKiBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgcmVxdWlyZSByYXcgY29udGVudHMgYW5kIHNob3VsZCBub3QgaGF2ZSBTU1IgY29tbWVudHMgcHV0IGluIHRoZW0gKi9cbmNvbnN0IFJBV19URVhUX0VMRU1FTlRTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3RpdGxlJ10pO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yYXdfdGV4dF9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIFJBV19URVhUX0VMRU1FTlRTLmluY2x1ZGVzKC8qKiBAdHlwZSB7UkFXX1RFWFRfRUxFTUVOVFNbbnVtYmVyXX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqXG4gKiBQcmV2ZW50IGRldnRvb2xzIHRyeWluZyB0byBtYWtlIGBsb2NhdGlvbmAgYSBjbGlja2FibGUgbGluayBieSBpbnNlcnRpbmcgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSB7XG5cdHJldHVybiBsb2NhdGlvbj8ucmVwbGFjZSgvXFwvL2csICcvXFx1MjAwYicpO1xufVxuIiwiaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNsZWFyX3RleHRfY29udGVudCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9mb2N1cyhkb20sIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSkge1xuXHRcdGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHRcdGRvbS5hdXRvZm9jdXMgPSB0cnVlO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gYm9keSkge1xuXHRcdFx0XHRkb20uZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBjaGlsZCBvZiBhIHRleHRhcmVhIGFjdHVhbGx5IGNvcnJlc3BvbmRzIHRvIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHksIHNvIHdlIG5lZWRcbiAqIHRvIHJlbW92ZSBpdCB1cG9uIGh5ZHJhdGlvbiB0byBhdm9pZCBhIGJ1ZyB3aGVuIHNvbWVvbmUgcmVzZXRzIHRoZSBmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtIVE1MVGV4dEFyZWFFbGVtZW50fSBkb21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX3RleHRhcmVhX2NoaWxkKGRvbSkge1xuXHRpZiAoaHlkcmF0aW5nICYmIGdldF9maXJzdF9jaGlsZChkb20pICE9PSBudWxsKSB7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KGRvbSk7XG5cdH1cbn1cblxubGV0IGxpc3RlbmluZ190b19mb3JtX3Jlc2V0ID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRfZm9ybV9yZXNldF9saXN0ZW5lcigpIHtcblx0aWYgKCFsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCkge1xuXHRcdGxpc3RlbmluZ190b19mb3JtX3Jlc2V0ID0gdHJ1ZTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0J3Jlc2V0Jyxcblx0XHRcdChldnQpID0+IHtcblx0XHRcdFx0Ly8gTmVlZHMgdG8gaGFwcGVuIG9uZSB0aWNrIGxhdGVyIG9yIGVsc2UgdGhlIGRvbSBwcm9wZXJ0aWVzIG9mIHRoZSBmb3JtXG5cdFx0XHRcdC8vIGVsZW1lbnRzIGhhdmUgbm90IHVwZGF0ZWQgdG8gdGhlaXIgcmVzZXQgdmFsdWVzIHlldFxuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoIWV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGUgb2YgLyoqQHR5cGUge0hUTUxGb3JtRWxlbWVudH0gKi8gKGV2dC50YXJnZXQpLmVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdFx0ZS5fX29uX3I/LigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSW4gdGhlIGNhcHR1cmUgcGhhc2UgdG8gZ3VhcmFudGVlIHdlIGdldCBub3RpY2VkIG9mIGl0IChubyBwb3NzaWJsaXR5IG9mIHN0b3BQcm9wYWdhdGlvbilcblx0XHRcdHsgY2FwdHVyZTogdHJ1ZSB9XG5cdFx0KTtcblx0fVxufVxuIiwiaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5cbi8qKlxuICogRmlyZXMgdGhlIGhhbmRsZXIgb25jZSBpbW1lZGlhdGVseSAodW5sZXNzIGNvcnJlc3BvbmRpbmcgYXJnIGlzIHNldCB0byBgZmFsc2VgKSxcbiAqIHRoZW4gbGlzdGVucyB0byB0aGUgZ2l2ZW4gZXZlbnRzIHVudGlsIHRoZSByZW5kZXIgZWZmZWN0IGNvbnRleHQgaXMgZGVzdHJveWVkXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0geyhldmVudD86IEV2ZW50KSA9PiB2b2lkfSBoYW5kbGVyXG4gKiBAcGFyYW0ge2FueX0gY2FsbF9oYW5kbGVyX2ltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudHMsIGhhbmRsZXIsIGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSA9IHRydWUpIHtcblx0aWYgKGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSkge1xuXHRcdGhhbmRsZXIoKTtcblx0fVxuXG5cdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG5cdH1cblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Zm9yICh2YXIgbmFtZSBvZiBldmVudHMpIHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dChmbikge1xuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogTGlzdGVuIHRvIHRoZSBnaXZlbiBldmVudCwgYW5kIHRoZW4gaW5zdGFudGlhdGUgYSBnbG9iYWwgZm9ybSByZXNldCBsaXN0ZW5lciBpZiBub3QgYWxyZWFkeSBkb25lLFxuICogdG8gbm90aWZ5IGFsbCBiaW5kaW5ncyB3aGVuIHRoZSBmb3JtIGlzIHJlc2V0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHsoaXNfcmVzZXQ/OiB0cnVlKSA9PiB2b2lkfSBbb25fcmVzZXRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBvbl9yZXNldCA9IGhhbmRsZXIpIHtcblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoKSA9PiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoaGFuZGxlcikpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IHByZXYgPSBlbGVtZW50Ll9fb25fcjtcblx0aWYgKHByZXYpIHtcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGNoZWNrYm94IHRoYXQgY2FuIGhhdmUgbXVsdGlwbGUgYmluZHMgKGdyb3VwICYgY2hlY2tlZClcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiB7XG5cdFx0XHRwcmV2KCk7XG5cdFx0XHRvbl9yZXNldCh0cnVlKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50Ll9fb25fciA9ICgpID0+IG9uX3Jlc2V0KHRydWUpO1xuXHR9XG5cblx0YWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdsb2NhdGUtY2hhcmFjdGVyJyAqL1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG4vKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuZXhwb3J0IGNvbnN0IGFsbF9yZWdpc3RlcmVkX2V2ZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtTZXQ8KGV2ZW50czogQXJyYXk8c3RyaW5nPikgPT4gdm9pZD59ICovXG5leHBvcnQgY29uc3Qgcm9vdF9ldmVudF9oYW5kbGVzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIFNTUiBhZGRzIG9ubG9hZCBhbmQgb25lcnJvciBhdHRyaWJ1dGVzIHRvIGNhdGNoIHRob3NlIGV2ZW50cyBiZWZvcmUgdGhlIGh5ZHJhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB0aG9zZSBjYXNlcywgcmVtb3ZlcyB0aGUgYXR0cmlidXRlcyBhbmQgcmVwbGF5cyB0aGUgZXZlbnRzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlfZXZlbnRzKGRvbSkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdGlmIChkb20ub25sb2FkKSB7XG5cdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25sb2FkJyk7XG5cdH1cblx0aWYgKGRvbS5vbmVycm9yKSB7XG5cdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25lcnJvcicpO1xuXHR9XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgZXZlbnQgPSBkb20uX19lO1xuXHRpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRkb20uX19lID0gdW5kZWZpbmVkO1xuXHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdGlmIChkb20uaXNDb25uZWN0ZWQpIHtcblx0XHRcdFx0ZG9tLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGRvbVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBvcHRpb25zKSB7XG5cdC8qKlxuXHQgKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRmdW5jdGlvbiB0YXJnZXRfaGFuZGxlcigvKiogQHR5cGUge0V2ZW50fSAqLyBldmVudCkge1xuXHRcdGlmICghb3B0aW9ucy5jYXB0dXJlKSB7XG5cdFx0XHQvLyBPbmx5IGNhbGwgaW4gdGhlIGJ1YmJsZSBwaGFzZSwgZWxzZSBkZWxlZ2F0ZWQgZXZlbnRzIHdvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNhcHR1cmluZyBldmVudHNcblx0XHRcdGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbi5jYWxsKGRvbSwgZXZlbnQpO1xuXHRcdH1cblx0XHRpZiAoIWV2ZW50LmNhbmNlbEJ1YmJsZSkge1xuXHRcdFx0cmV0dXJuIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hyb21lIGhhcyBhIGJ1ZyB3aGVyZSBwb2ludGVyIGV2ZW50cyBkb24ndCB3b3JrIHdoZW4gYXR0YWNoZWQgdG8gYSBET00gZWxlbWVudCB0aGF0IGhhcyBiZWVuIGNsb25lZFxuXHQvLyB3aXRoIGNsb25lTm9kZSgpIGFuZCB0aGUgRE9NIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50LiBUbyBlbnN1cmUgdGhlIGV2ZW50IHdvcmtzLCB3ZVxuXHQvLyBkZWZlciB0aGUgYXR0YWNobWVudCB0aWxsIGFmdGVyIGl0J3MgYmVlbiBhcHBlbmRlZCB0byB0aGUgZG9jdW1lbnQuIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIGZpeGVzXG5cdC8vIHRoaXMgYnVnLiBUaGUgc2FtZSBhcHBsaWVzIHRvIHdoZWVsIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuXHRpZiAoXG5cdFx0ZXZlbnRfbmFtZS5zdGFydHNXaXRoKCdwb2ludGVyJykgfHxcblx0XHRldmVudF9uYW1lLnN0YXJ0c1dpdGgoJ3RvdWNoJykgfHxcblx0XHRldmVudF9uYW1lID09PSAnd2hlZWwnXG5cdCkge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXRfaGFuZGxlcjtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGhhbmRsZXIuIFVzaW5nIHRoaXNcbiAqIHJhdGhlciB0aGFuIGBhZGRFdmVudExpc3RlbmVyYCB3aWxsIHByZXNlcnZlIHRoZSBjb3JyZWN0IG9yZGVyIHJlbGF0aXZlIHRvIGhhbmRsZXJzIGFkZGVkIGRlY2xhcmF0aXZlbHlcbiAqICh3aXRoIGF0dHJpYnV0ZXMgbGlrZSBgb25jbGlja2ApLCB3aGljaCB1c2UgZXZlbnQgZGVsZWdhdGlvbiBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudCh0eXBlLCBlbGVtZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FwdHVyZVxuICogQHBhcmFtIHtib29sZWFufSBbcGFzc2l2ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlKSB7XG5cdHZhciBvcHRpb25zID0geyBjYXB0dXJlLCBwYXNzaXZlIH07XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0aWYgKGRvbSA9PT0gZG9jdW1lbnQuYm9keSB8fCBkb20gPT09IHdpbmRvdyB8fCBkb20gPT09IGRvY3VtZW50KSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZWdhdGUoZXZlbnRzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudHNbaV0pO1xuXHR9XG5cblx0Zm9yICh2YXIgZm4gb2Ygcm9vdF9ldmVudF9oYW5kbGVzKSB7XG5cdFx0Zm4oZXZlbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbihldmVudCkge1xuXHR2YXIgaGFuZGxlcl9lbGVtZW50ID0gdGhpcztcblx0dmFyIG93bmVyX2RvY3VtZW50ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoaGFuZGxlcl9lbGVtZW50KS5vd25lckRvY3VtZW50O1xuXHR2YXIgZXZlbnRfbmFtZSA9IGV2ZW50LnR5cGU7XG5cdHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoPy4oKSB8fCBbXTtcblx0dmFyIGN1cnJlbnRfdGFyZ2V0ID0gLyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi8gKHBhdGhbMF0gfHwgZXZlbnQudGFyZ2V0KTtcblxuXHQvLyBjb21wb3NlZFBhdGggY29udGFpbnMgbGlzdCBvZiBub2RlcyB0aGUgZXZlbnQgaGFzIHByb3BhZ2F0ZWQgdGhyb3VnaC5cblx0Ly8gV2UgY2hlY2sgX19yb290IHRvIHNraXAgYWxsIG5vZGVzIGJlbG93IGl0IGluIGNhc2UgdGhpcyBpcyBhXG5cdC8vIHBhcmVudCBvZiB0aGUgX19yb290IG5vZGUsIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZXJlJ3MgbmVzdGVkXG5cdC8vIG1vdW50ZWQgYXBwcy4gSW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudHMgbXVsdGlwbGUgdGltZXMuXG5cdHZhciBwYXRoX2lkeCA9IDA7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyBhZGRlZCBiZWxvd1xuXHR2YXIgaGFuZGxlZF9hdCA9IGV2ZW50Ll9fcm9vdDtcblxuXHRpZiAoaGFuZGxlZF9hdCkge1xuXHRcdHZhciBhdF9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlZF9hdCk7XG5cdFx0aWYgKFxuXHRcdFx0YXRfaWR4ICE9PSAtMSAmJlxuXHRcdFx0KGhhbmRsZXJfZWxlbWVudCA9PT0gZG9jdW1lbnQgfHwgaGFuZGxlcl9lbGVtZW50ID09PSAvKiogQHR5cGUge2FueX0gKi8gKHdpbmRvdykpXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBvciBhIHdpbmRvdyBsaXN0ZW5lciwgYnV0IHRoZSBldmVudCB3YXMgYWxyZWFkeSBoYW5kbGVkXG5cdFx0XHQvLyAtPiBpZ25vcmUsIGJ1dCBzZXQgaGFuZGxlX2F0IHRvIGRvY3VtZW50L3dpbmRvdyBzbyB0aGF0IHdlJ3JlIHJlc2V0dGluZyB0aGUgZXZlbnRcblx0XHRcdC8vIGNoYWluIGluIGNhc2Ugc29tZW9uZSBtYW51YWxseSBkaXNwYXRjaGVzIHRoZSBzYW1lIGV2ZW50IG9iamVjdCBhZ2Fpbi5cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHNraXBwaW5nIGlmIHRoZSBpbmRleCBpcyBoaWdoZXIsIGJlY2F1c2Vcblx0XHQvLyBzb21lb25lIGNvdWxkIGNyZWF0ZSBhbiBldmVudCBwcm9ncmFtbWF0aWNhbGx5IGFuZCBlbWl0IGl0IG11bHRpcGxlIHRpbWVzLFxuXHRcdC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgdGhlIHdob2xlIHByb3BhZ2F0aW9uIGNoYWluIHByb3Blcmx5IGVhY2ggdGltZS5cblx0XHQvLyAodGhpcyB3aWxsIG9ubHkgYmUgYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtdWx0aXBsZSB0aW1lcyBhbmRcblx0XHQvLyB0aGUgZmFsbGJhY2sgZG9jdW1lbnQgbGlzdGVuZXIgaXNuJ3QgcmVhY2hlZCBpbiBiZXR3ZWVuLCBidXQgdGhhdCdzIHN1cGVyIHJhcmUpXG5cdFx0dmFyIGhhbmRsZXJfaWR4ID0gcGF0aC5pbmRleE9mKGhhbmRsZXJfZWxlbWVudCk7XG5cdFx0aWYgKGhhbmRsZXJfaWR4ID09PSAtMSkge1xuXHRcdFx0Ly8gaGFuZGxlX2lkeCBjYW4gdGhlb3JldGljYWxseSBiZSAtMSAoaGFwcGVuZWQgaW4gc29tZSBKU0RPTSB0ZXN0aW5nIHNjZW5hcmlvcyB3aXRoIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgb2JqZWN0KVxuXHRcdFx0Ly8gc28gZ3VhcmQgYWdhaW5zdCB0aGF0LCB0b28sIGFuZCBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIHdhcyBoYW5kbGVkIGF0IHRoaXMgcG9pbnQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGF0X2lkeCA8PSBoYW5kbGVyX2lkeCkge1xuXHRcdFx0cGF0aF9pZHggPSBhdF9pZHg7XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChwYXRoW3BhdGhfaWR4XSB8fCBldmVudC50YXJnZXQpO1xuXHQvLyB0aGVyZSBjYW4gb25seSBiZSBvbmUgZGVsZWdhdGVkIGV2ZW50IHBlciBlbGVtZW50LCBhbmQgd2UgZWl0aGVyIGFscmVhZHkgaGFuZGxlZCB0aGUgY3VycmVudCB0YXJnZXQsXG5cdC8vIG9yIHRoaXMgaXMgdGhlIHZlcnkgZmlyc3QgdGFyZ2V0IGluIHRoZSBjaGFpbiB3aGljaCBoYXMgYSBub24tZGVsZWdhdGVkIGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGl0J3Mgc2FmZVxuXHQvLyB0byBoYW5kbGUgYSBwb3NzaWJsZSBkZWxlZ2F0ZWQgZXZlbnQgb24gaXQgbGF0ZXIgKHRocm91Z2ggdGhlIHJvb3QgZGVsZWdhdGlvbiBsaXN0ZW5lciBmb3IgZXhhbXBsZSkuXG5cdGlmIChjdXJyZW50X3RhcmdldCA9PT0gaGFuZGxlcl9lbGVtZW50KSByZXR1cm47XG5cblx0Ly8gUHJveHkgY3VycmVudFRhcmdldCB0byBjb3JyZWN0IHRhcmdldFxuXHRkZWZpbmVfcHJvcGVydHkoZXZlbnQsICdjdXJyZW50VGFyZ2V0Jywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudF90YXJnZXQgfHwgb3duZXJfZG9jdW1lbnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGlzIHN0YXJ0ZWQgYmVjYXVzZSBvZiBDaHJvbWl1bSBpc3N1ZSBodHRwczovL2Nocm9tZXN0YXR1cy5jb20vZmVhdHVyZS81MTI4Njk2ODIzNTQ1ODU2LFxuXHQvLyB3aGVyZSByZW1vdmFsIG9yIG1vdmluZyBvZiBvZiB0aGUgRE9NIGNhbiBjYXVzZSBzeW5jIGBibHVyYCBldmVudHMgdG8gZmlyZSwgd2hpY2ggY2FuIGNhdXNlIGxvZ2ljXG5cdC8vIHRvIHJ1biBpbnNpZGUgdGhlIGN1cnJlbnQgYGFjdGl2ZV9yZWFjdGlvbmAsIHdoaWNoIGlzbid0IHdoYXQgd2Ugd2FudCBhdCBhbGwuIEhvd2V2ZXIsIG9uIHJlZmxlY3Rpb24sXG5cdC8vIGl0J3MgcHJvYmFibHkgYmVzdCB0aGF0IGFsbCBldmVudCBoYW5kbGVkIGJ5IFN2ZWx0ZSBoYXZlIHRoaXMgYmVoYXZpb3VyLCBhcyB3ZSBkb24ndCByZWFsbHkgd2FudFxuXHQvLyBhbiBldmVudCBoYW5kbGVyIHRvIHJ1biBpbiB0aGUgY29udGV4dCBvZiBhbm90aGVyIHJlYWN0aW9uIG9yIGVmZmVjdC5cblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cblx0dHJ5IHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bn1cblx0XHQgKi9cblx0XHR2YXIgdGhyb3dfZXJyb3I7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3Vua25vd25bXX1cblx0XHQgKi9cblx0XHR2YXIgb3RoZXJfZXJyb3JzID0gW107XG5cblx0XHR3aGlsZSAoY3VycmVudF90YXJnZXQgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdFx0XHR2YXIgcGFyZW50X2VsZW1lbnQgPVxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5hc3NpZ25lZFNsb3QgfHxcblx0XHRcdFx0Y3VycmVudF90YXJnZXQucGFyZW50Tm9kZSB8fFxuXHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5ob3N0IHx8XG5cdFx0XHRcdG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0dmFyIGRlbGVnYXRlZCA9IGN1cnJlbnRfdGFyZ2V0WydfXycgKyBldmVudF9uYW1lXTtcblxuXHRcdFx0XHRpZiAoZGVsZWdhdGVkICE9PSB1bmRlZmluZWQgJiYgISgvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5kaXNhYmxlZCkpIHtcblx0XHRcdFx0XHRpZiAoaXNfYXJyYXkoZGVsZWdhdGVkKSkge1xuXHRcdFx0XHRcdFx0dmFyIFtmbiwgLi4uZGF0YV0gPSBkZWxlZ2F0ZWQ7XG5cdFx0XHRcdFx0XHRmbi5hcHBseShjdXJyZW50X3RhcmdldCwgW2V2ZW50LCAuLi5kYXRhXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRlbGVnYXRlZC5jYWxsKGN1cnJlbnRfdGFyZ2V0LCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdFx0XHRvdGhlcl9lcnJvcnMucHVzaChlcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3dfZXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSB8fCBwYXJlbnRfZWxlbWVudCA9PT0gaGFuZGxlcl9lbGVtZW50IHx8IHBhcmVudF9lbGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudF90YXJnZXQgPSBwYXJlbnRfZWxlbWVudDtcblx0XHR9XG5cblx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdGZvciAobGV0IGVycm9yIG9mIG90aGVyX2Vycm9ycykge1xuXHRcdFx0XHQvLyBUaHJvdyB0aGUgcmVzdCBvZiB0aGUgZXJyb3JzLCBvbmUtYnktb25lIG9uIGEgbWljcm90YXNrXG5cdFx0XHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyB0aHJvd19lcnJvcjtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyB1c2VkIGFib3ZlXG5cdFx0ZXZlbnQuX19yb290ID0gaGFuZGxlcl9lbGVtZW50O1xuXHRcdC8vIEB0cy1pZ25vcmUgcmVtb3ZlIHByb3h5IG9uIGN1cnJlbnRUYXJnZXRcblx0XHRkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2LCB3YXJuIGlmIGFuIGV2ZW50IGhhbmRsZXIgaXMgbm90IGEgZnVuY3Rpb24sIGFzIGl0IG1lYW5zIHRoZVxuICogdXNlciBwcm9iYWJseSBjYWxsZWQgdGhlIGhhbmRsZXIgb3IgZm9yZ290IHRvIGFkZCBhIGAoKSA9PmBcbiAqIEBwYXJhbSB7KCkgPT4gKGV2ZW50OiBFdmVudCwgLi4uYXJnczogYW55KSA9PiB2b2lkfSB0aHVua1xuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtbRXZlbnQsIC4uLmFueV19IGFyZ3NcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gW2xvY11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZV9wYXJlbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseShcblx0dGh1bmssXG5cdGVsZW1lbnQsXG5cdGFyZ3MsXG5cdGNvbXBvbmVudCxcblx0bG9jLFxuXHRoYXNfc2lkZV9lZmZlY3RzID0gZmFsc2UsXG5cdHJlbW92ZV9wYXJlbnMgPSBmYWxzZVxuKSB7XG5cdGxldCBoYW5kbGVyO1xuXHRsZXQgZXJyb3I7XG5cblx0dHJ5IHtcblx0XHRoYW5kbGVyID0gdGh1bmsoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGVycm9yID0gZTtcblx0fVxuXG5cdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhhbmRsZXIuYXBwbHkoZWxlbWVudCwgYXJncyk7XG5cdH0gZWxzZSBpZiAoaGFzX3NpZGVfZWZmZWN0cyB8fCBoYW5kbGVyICE9IG51bGwgfHwgZXJyb3IpIHtcblx0XHRjb25zdCBmaWxlbmFtZSA9IGNvbXBvbmVudD8uW0ZJTEVOQU1FXTtcblx0XHRjb25zdCBsb2NhdGlvbiA9IGxvYyA/IGAgYXQgJHtmaWxlbmFtZX06JHtsb2NbMF19OiR7bG9jWzFdfWAgOiBgIGluICR7ZmlsZW5hbWV9YDtcblxuXHRcdGNvbnN0IGV2ZW50X25hbWUgPSBhcmdzWzBdLnR5cGU7XG5cdFx0Y29uc3QgZGVzY3JpcHRpb24gPSBgXFxgJHtldmVudF9uYW1lfVxcYCBoYW5kbGVyJHtsb2NhdGlvbn1gO1xuXHRcdGNvbnN0IHN1Z2dlc3Rpb24gPSByZW1vdmVfcGFyZW5zID8gJ3JlbW92ZSB0aGUgdHJhaWxpbmcgYCgpYCcgOiAnYWRkIGEgbGVhZGluZyBgKCkgPT5gJztcblxuXHRcdHcuZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGRlc2NyaXB0aW9uLCBzdWdnZXN0aW9uKTtcblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59XG4iLCIvKiogQHBhcmFtIHtzdHJpbmd9IGh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpIHtcblx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRlbGVtLmlubmVySFRNTCA9IGh0bWw7XG5cdHJldHVybiBlbGVtLmNvbnRlbnQ7XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgVEVNUExBVEVfRlJBR01FTlQsIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZSB8IG51bGx9IGVuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpIHtcblx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cdGlmIChlZmZlY3Qubm9kZXNfc3RhcnQgPT09IG51bGwpIHtcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBzdGFydDtcblx0XHRlZmZlY3Qubm9kZXNfZW5kID0gZW5kO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHVzZV9pbXBvcnRfbm9kZSA9IChmbGFncyAmIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHtOb2RlfSAqL1xuXHR2YXIgbm9kZTtcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChoYXNfc3RhcnQgPyBjb250ZW50IDogJzwhPicgKyBjb250ZW50KTtcblx0XHRcdGlmICghaXNfZnJhZ21lbnQpIG5vZGUgPSAvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHR1c2VfaW1wb3J0X25vZGUgPyBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpIDogbm9kZS5jbG9uZU5vZGUodHJ1ZSlcblx0XHQpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlX3dpdGhfc2NyaXB0KGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBmbiA9IHRlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKTtcblx0cmV0dXJuICgpID0+IHJ1bl9zY3JpcHRzKC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovIChmbigpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsnc3ZnJyB8ICdtYXRoJ30gbnNcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBuc190ZW1wbGF0ZShjb250ZW50LCBmbGFncywgbnMgPSAnc3ZnJykge1xuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB3cmFwcGVkID0gYDwke25zfT4ke2hhc19zdGFydCA/IGNvbnRlbnQgOiAnPCE+JyArIGNvbnRlbnR9PC8ke25zfT5gO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovXG5cdHZhciBub2RlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmICghbm9kZSkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCh3cmFwcGVkKSk7XG5cdFx0XHR2YXIgcm9vdCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChyb290KSkge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHN2Z190ZW1wbGF0ZV93aXRoX3NjcmlwdChjb250ZW50LCBmbGFncykge1xuXHR2YXIgZm4gPSBuc190ZW1wbGF0ZShjb250ZW50LCBmbGFncyk7XG5cdHJldHVybiAoKSA9PiBydW5fc2NyaXB0cygvKiogQHR5cGUge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSAqLyAoZm4oKSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRobWxfdGVtcGxhdGUoY29udGVudCwgZmxhZ3MpIHtcblx0cmV0dXJuIG5zX3RlbXBsYXRlKGNvbnRlbnQsIGZsYWdzLCAnbWF0aCcpO1xufVxuXG4vKipcbiAqIENyZWF0aW5nIGEgZG9jdW1lbnQgZnJhZ21lbnQgZnJvbSBIVE1MIHRoYXQgY29udGFpbnMgc2NyaXB0IHRhZ3Mgd2lsbCBub3QgZXhlY3V0ZVxuICogdGhlIHNjcmlwdHMuIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgc2NyaXB0IHRhZ3Mgd2l0aCBuZXcgb25lcyBzbyB0aGF0IHRoZXkgYXJlIGV4ZWN1dGVkLlxuICogQHBhcmFtIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBOb2RlW119XG4gKi9cbmZ1bmN0aW9uIHJ1bl9zY3JpcHRzKG5vZGUpIHtcblx0Ly8gc2NyaXB0cyB3ZXJlIFNTUidkLCBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBydW5cblx0aWYgKGh5ZHJhdGluZykgcmV0dXJuIG5vZGU7XG5cblx0Y29uc3QgaXNfZnJhZ21lbnQgPSBub2RlLm5vZGVUeXBlID09PSAxMTtcblx0Y29uc3Qgc2NyaXB0cyA9XG5cdFx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLnRhZ05hbWUgPT09ICdTQ1JJUFQnXG5cdFx0XHQ/IFsvKiogQHR5cGUge0hUTUxTY3JpcHRFbGVtZW50fSAqLyAobm9kZSldXG5cdFx0XHQ6IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0Jyk7XG5cdGNvbnN0IGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0Zm9yIChjb25zdCBzY3JpcHQgb2Ygc2NyaXB0cykge1xuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0Zm9yICh2YXIgYXR0cmlidXRlIG9mIHNjcmlwdC5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRjbG9uZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUudGV4dENvbnRlbnQgPSBzY3JpcHQudGV4dENvbnRlbnQ7XG5cblx0XHQvLyBUaGUgc2NyaXB0IGhhcyBjaGFuZ2VkIC0gaWYgaXQncyBhdCB0aGUgZWRnZXMsIHRoZSBlZmZlY3Qgbm93IHBvaW50cyBhdCBkZWFkIG5vZGVzXG5cdFx0aWYgKGlzX2ZyYWdtZW50ID8gbm9kZS5maXJzdENoaWxkID09PSBzY3JpcHQgOiBub2RlID09PSBzY3JpcHQpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IGNsb25lO1xuXHRcdH1cblx0XHRpZiAoaXNfZnJhZ21lbnQgPyBub2RlLmxhc3RDaGlsZCA9PT0gc2NyaXB0IDogbm9kZSA9PT0gc2NyaXB0KSB7XG5cdFx0XHRlZmZlY3Qubm9kZXNfZW5kID0gY2xvbmU7XG5cdFx0fVxuXG5cdFx0c2NyaXB0LnJlcGxhY2VXaXRoKGNsb25lKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQodmFsdWUgPSAnJykge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHZhciB0ID0gY3JlYXRlX3RleHQodmFsdWUgKyAnJyk7XG5cdFx0YXNzaWduX25vZGVzKHQsIHQpO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDMpIHtcblx0XHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgd2UgbmVlZCB0byBpbnNlcnQgYW4gZW1wdHkgdGV4dCBub2RlXG5cdFx0bm9kZS5iZWZvcmUoKG5vZGUgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShub2RlKTtcblx0fVxuXG5cdGFzc2lnbl9ub2Rlcyhub2RlLCBub2RlKTtcblx0cmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KCkge1xuXHQvLyB3ZSdyZSBub3QgZGVsZWdhdGluZyB0byBgdGVtcGxhdGVgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdH1cblxuXHR2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0dmFyIHN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG5cdHZhciBhbmNob3IgPSBjcmVhdGVfdGV4dCgpO1xuXHRmcmFnLmFwcGVuZChzdGFydCwgYW5jaG9yKTtcblxuXHRhc3NpZ25fbm9kZXMoc3RhcnQsIGFuY2hvcik7XG5cblx0cmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQXNzaWduIHRoZSBjcmVhdGVkIChvciBpbiBoeWRyYXRpb24gbW9kZSwgdHJhdmVyc2VkKSBkb20gZWxlbWVudHMgdG8gdGhlIGN1cnJlbnQgYmxvY2tcbiAqIGFuZCBpbnNlcnQgdGhlIGVsZW1lbnRzIGludG8gdGhlIGRvbSAoaW4gY2xpZW50IG1vZGUpLlxuICogQHBhcmFtIHtUZXh0IHwgQ29tbWVudCB8IEVsZW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoYW5jaG9yLCBkb20pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gaHlkcmF0ZV9ub2RlO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChhbmNob3IgPT09IG51bGwpIHtcblx0XHQvLyBlZGdlIGNhc2Ug4oCUIHZvaWQgYDxzdmVsdGU6ZWxlbWVudD5gIHdpdGggY29udGVudFxuXHRcdHJldHVybjtcblx0fVxuXG5cdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZG9tKSk7XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIE1vdW50T3B0aW9ucyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRjbGVhcl90ZXh0X2NvbnRlbnQsXG5cdGNyZWF0ZV90ZXh0LFxuXHRnZXRfZmlyc3RfY2hpbGQsXG5cdGdldF9uZXh0X3NpYmxpbmcsXG5cdGluaXRfb3BlcmF0aW9uc1xufSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9FUlJPUiwgSFlEUkFUSU9OX1NUQVJUIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHB1c2gsIHBvcCwgY29tcG9uZW50X2NvbnRleHQsIGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X3Jvb3QsIGJyYW5jaCB9IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGFycmF5X2Zyb20gfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLFxuXHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sXG5cdHJvb3RfZXZlbnRfaGFuZGxlc1xufSBmcm9tICcuL2RvbS9lbGVtZW50cy9ldmVudHMuanMnO1xuaW1wb3J0IHsgcmVzZXRfaGVhZF9hbmNob3IgfSBmcm9tICcuL2RvbS9ibG9ja3Mvc3ZlbHRlLWhlYWQuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi9kb20vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgaXNfcGFzc2l2ZV9ldmVudCB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIG5vcm1hbGx5IHRydWUg4oCUIGJsb2NrIGVmZmVjdHMgc2hvdWxkIHJ1biB0aGVpciBpbnRybyB0cmFuc2l0aW9ucyDigJRcbiAqIGJ1dCBpcyBmYWxzZSBkdXJpbmcgaHlkcmF0aW9uICh1bmxlc3MgYG9wdGlvbnMuaW50cm9gIGlzIGB0cnVlYCkgYW5kXG4gKiB3aGVuIGNyZWF0aW5nIHRoZSBjaGlsZHJlbiBvZiBhIGA8c3ZlbHRlOmVsZW1lbnQ+YCB0aGF0IGp1c3QgY2hhbmdlZCB0YWdcbiAqL1xuZXhwb3J0IGxldCBzaG91bGRfaW50cm8gPSB0cnVlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zaG91bGRfaW50cm8odmFsdWUpIHtcblx0c2hvdWxkX2ludHJvID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3RleHQodGV4dCwgdmFsdWUpIHtcblx0Ly8gRm9yIG9iamVjdHMsIHdlIGFwcGx5IHN0cmluZyBjb2VyY2lvbiAod2hpY2ggbWlnaHQgbWFrZSB0aGluZ3MgbGlrZSAkc3RhdGUgYXJyYXkgcmVmZXJlbmNlcyBpbiB0aGUgdGVtcGxhdGUgcmVhY3RpdmUpIGJlZm9yZSBkaWZmaW5nXG5cdHZhciBzdHIgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgKyAnJyA6IHZhbHVlO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlmIChzdHIgIT09ICh0ZXh0Ll9fdCA/Pz0gdGV4dC5ub2RlVmFsdWUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHQuX190ID0gc3RyO1xuXHRcdHRleHQubm9kZVZhbHVlID0gc3RyID09IG51bGwgPyAnJyA6IHN0ciArICcnO1xuXHR9XG59XG5cbi8qKlxuICogTW91bnRzIGEgY29tcG9uZW50IHRvIHRoZSBnaXZlbiB0YXJnZXQgYW5kIHJldHVybnMgdGhlIGV4cG9ydHMgYW5kIHBvdGVudGlhbGx5IHRoZSBwcm9wcyAoaWYgY29tcGlsZWQgd2l0aCBgYWNjZXNzb3JzOiB0cnVlYCkgb2YgdGhlIGNvbXBvbmVudC5cbiAqIFRyYW5zaXRpb25zIHdpbGwgcGxheSBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIHVubGVzcyB0aGUgYGludHJvYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHtNb3VudE9wdGlvbnM8UHJvcHM+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRyZXR1cm4gX21vdW50KGNvbXBvbmVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSHlkcmF0ZXMgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIHRhcmdldCBhbmQgcmV0dXJucyB0aGUgZXhwb3J0cyBhbmQgcG90ZW50aWFsbHkgdGhlIHByb3BzIChpZiBjb21waWxlZCB3aXRoIGBhY2Nlc3NvcnM6IHRydWVgKSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7fSBleHRlbmRzIFByb3BzID8ge1xuICogXHRcdHRhcmdldDogRG9jdW1lbnQgfCBFbGVtZW50IHwgU2hhZG93Um9vdDtcbiAqIFx0XHRwcm9wcz86IFByb3BzO1xuICogXHRcdGV2ZW50cz86IFJlY29yZDxzdHJpbmcsIChlOiBhbnkpID0+IGFueT47XG4gKiAgXHRjb250ZXh0PzogTWFwPGFueSwgYW55PjtcbiAqIFx0XHRpbnRybz86IGJvb2xlYW47XG4gKiBcdFx0cmVjb3Zlcj86IGJvb2xlYW47XG4gKiBcdH0gOiB7XG4gKiBcdFx0dGFyZ2V0OiBEb2N1bWVudCB8IEVsZW1lbnQgfCBTaGFkb3dSb290O1xuICogXHRcdHByb3BzOiBQcm9wcztcbiAqIFx0XHRldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCAoZTogYW55KSA9PiBhbnk+O1xuICogIFx0Y29udGV4dD86IE1hcDxhbnksIGFueT47XG4gKiBcdFx0aW50cm8/OiBib29sZWFuO1xuICogXHRcdHJlY292ZXI/OiBib29sZWFuO1xuICogXHR9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdGluaXRfb3BlcmF0aW9ucygpO1xuXHRvcHRpb25zLmludHJvID0gb3B0aW9ucy5pbnRybyA/PyBmYWxzZTtcblx0Y29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cdGNvbnN0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGNvbnN0IHByZXZpb3VzX2h5ZHJhdGVfbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR0cnkge1xuXHRcdHZhciBhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZCh0YXJnZXQpKTtcblx0XHR3aGlsZSAoXG5cdFx0XHRhbmNob3IgJiZcblx0XHRcdChhbmNob3Iubm9kZVR5cGUgIT09IDggfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhICE9PSBIWURSQVRJT05fU1RBUlQpXG5cdFx0KSB7XG5cdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoYW5jaG9yKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFhbmNob3IpIHtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKSk7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cblx0XHRjb25zdCBpbnN0YW5jZSA9IF9tb3VudChjb21wb25lbnQsIHsgLi4ub3B0aW9ucywgYW5jaG9yIH0pO1xuXG5cdFx0aWYgKFxuXHRcdFx0aHlkcmF0ZV9ub2RlID09PSBudWxsIHx8XG5cdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgIT09IDggfHxcblx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSAhPT0gSFlEUkFUSU9OX0VORFxuXHRcdCkge1xuXHRcdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblxuXHRcdHJldHVybiAvKiogIEB0eXBlIHtFeHBvcnRzfSAqLyAoaW5zdGFuY2UpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChlcnJvciA9PT0gSFlEUkFUSU9OX0VSUk9SKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5yZWNvdmVyID09PSBmYWxzZSkge1xuXHRcdFx0XHRlLmh5ZHJhdGlvbl9mYWlsZWQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYW4gZXJyb3Igb2NjdXJlZCBhYm92ZSwgdGhlIG9wZXJhdGlvbnMgbWlnaHQgbm90IHlldCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0XHRpbml0X29wZXJhdGlvbnMoKTtcblx0XHRcdGNsZWFyX3RleHRfY29udGVudCh0YXJnZXQpO1xuXG5cdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdHJldHVybiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9oeWRyYXRpbmcod2FzX2h5ZHJhdGluZyk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShwcmV2aW91c19oeWRyYXRlX25vZGUpO1xuXHRcdHJlc2V0X2hlYWRfYW5jaG9yKCk7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZG9jdW1lbnRfbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxhbnk+PiB8IENvbXBvbmVudDxhbnk+fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZnVuY3Rpb24gX21vdW50KENvbXBvbmVudCwgeyB0YXJnZXQsIGFuY2hvciwgcHJvcHMgPSB7fSwgZXZlbnRzLCBjb250ZXh0LCBpbnRybyA9IHRydWUgfSkge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblxuXHR2YXIgcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cblx0LyoqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzICovXG5cdHZhciBldmVudF9oYW5kbGUgPSAoZXZlbnRzKSA9PiB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBldmVudF9uYW1lID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRpZiAocmVnaXN0ZXJlZF9ldmVudHMuaGFzKGV2ZW50X25hbWUpKSBjb250aW51ZTtcblx0XHRcdHJlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudF9uYW1lKTtcblxuXHRcdFx0dmFyIHBhc3NpdmUgPSBpc19wYXNzaXZlX2V2ZW50KGV2ZW50X25hbWUpO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJvdGggdGhlIGNvbnRhaW5lciBhbmQgdGhlIGRvY3VtZW50LlxuXHRcdFx0Ly8gVGhlIGNvbnRhaW5lciBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyBmcm9tIHdpdGhpbiBpbiBjYXNlXG5cdFx0XHQvLyB0aGUgb3V0ZXIgY29udGVudCBzdG9wcyBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblxuXHRcdFx0dmFyIG4gPSBkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpO1xuXG5cdFx0XHRpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFRoZSBkb2N1bWVudCBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZSBmcm9tIGVsZW1lbnRzIHRoYXQgd2VyZVxuXHRcdFx0XHQvLyBtYW51YWxseSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBjb250YWluZXIgKGUuZy4gdmlhIG1hbnVhbCBwb3J0YWxzKS5cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbiArIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRldmVudF9oYW5kbGUoYXJyYXlfZnJvbShhbGxfcmVnaXN0ZXJlZF9ldmVudHMpKTtcblx0cm9vdF9ldmVudF9oYW5kbGVzLmFkZChldmVudF9oYW5kbGUpO1xuXG5cdC8qKiBAdHlwZSB7RXhwb3J0c30gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3aWxsIGJlIGRlZmluZWQgYmVjYXVzZSB0aGUgcmVuZGVyIGVmZmVjdCBydW5zIHN5bmNocm9ub3VzbHlcblx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgdW5tb3VudCA9IGNvbXBvbmVudF9yb290KCgpID0+IHtcblx0XHR2YXIgYW5jaG9yX25vZGUgPSBhbmNob3IgPz8gdGFyZ2V0LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXG5cdFx0YnJhbmNoKCgpID0+IHtcblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHB1c2goe30pO1xuXHRcdFx0XHR2YXIgY3R4ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdFx0XHRjdHguYyA9IGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0Ly8gV2UgY2FuJ3Qgc3ByZWFkIHRoZSBvYmplY3Qgb3IgZWxzZSB3ZSdkIGxvc2UgdGhlIHN0YXRlIHByb3h5IHN0dWZmLCBpZiBpdCBpcyBvbmVcblx0XHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChwcm9wcykuJCRldmVudHMgPSBldmVudHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0YXNzaWduX25vZGVzKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoYW5jaG9yX25vZGUpLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0c2hvdWxkX2ludHJvID0gaW50cm87XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBwdWJsaWMgdHlwaW5ncyBhcmUgbm90IHdoYXQgdGhlIGFjdHVhbCBmdW5jdGlvbiBsb29rcyBsaWtlXG5cdFx0XHRjb21wb25lbnQgPSBDb21wb25lbnQoYW5jaG9yX25vZGUsIHByb3BzKSB8fCB7fTtcblx0XHRcdHNob3VsZF9pbnRybyA9IHRydWU7XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHBvcCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAodmFyIGV2ZW50X25hbWUgb2YgcmVnaXN0ZXJlZF9ldmVudHMpIHtcblx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblxuXHRcdFx0XHR2YXIgbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZG9jdW1lbnRfbGlzdGVuZXJzLmdldChldmVudF9uYW1lKSk7XG5cblx0XHRcdFx0aWYgKC0tbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblx0XHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuZGVsZXRlKGV2ZW50X25hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cm9vdF9ldmVudF9oYW5kbGVzLmRlbGV0ZShldmVudF9oYW5kbGUpO1xuXG5cdFx0XHRpZiAoYW5jaG9yX25vZGUgIT09IGFuY2hvcikge1xuXHRcdFx0XHRhbmNob3Jfbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChhbmNob3Jfbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0bW91bnRlZF9jb21wb25lbnRzLnNldChjb21wb25lbnQsIHVubW91bnQpO1xuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG1vdW50ZWQgb3IgaHlkcmF0ZWQuXG4gKiBVc2VzIGEgYFdlYWtNYXBgIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAqL1xubGV0IG1vdW50ZWRfY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VudGVkIHVzaW5nIGBtb3VudGAgb3IgYGh5ZHJhdGVgLlxuICpcbiAqIFNpbmNlIDUuMTMuMCwgaWYgYG9wdGlvbnMub3V0cm9gIGlzIGB0cnVlYCwgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgd2lsbCBwbGF5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBhZnRlciB0cmFuc2l0aW9ucyBoYXZlIGNvbXBsZXRlZCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgdHJ1ZSwgb3IgaW1tZWRpYXRlbHkgb3RoZXJ3aXNlIChwcmlvciB0byA1LjEzLjAsIHJldHVybnMgYHZvaWRgKS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbW91bnQsIHVubW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICogaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zdmVsdGUnO1xuICpcbiAqIGNvbnN0IGFwcCA9IG1vdW50KEFwcCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSk7XG4gKlxuICogLy8gbGF0ZXIuLi5cbiAqIHVubW91bnQoYXBwLCB7IG91dHJvOiB0cnVlIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7IG91dHJvPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0Y29uc3QgZm4gPSBtb3VudGVkX2NvbXBvbmVudHMuZ2V0KGNvbXBvbmVudCk7XG5cblx0aWYgKGZuKSB7XG5cdFx0bW91bnRlZF9jb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuXHRcdHJldHVybiBmbihvcHRpb25zKTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHR3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpO1xuXHR9XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0cmVtb3ZlX25vZGVzLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBwYXVzZV9lZmZlY3QsIHJlc3VtZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX1NUQVJUX0VMU0UsIFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geyhicmFuY2g6IChmbjogKGFuY2hvcjogTm9kZSkgPT4gdm9pZCwgZmxhZz86IGJvb2xlYW4pID0+IHZvaWQpID0+IHZvaWR9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbHNlaWZdIFRydWUgaWYgdGhpcyBpcyBhbiBgezplbHNlIGlmIC4uLn1gIGJsb2NrIHJhdGhlciB0aGFuIGFuIGB7I2lmIC4uLn1gLCBhcyB0aGF0IGFmZmVjdHMgd2hpY2ggdHJhbnNpdGlvbnMgYXJlIGNvbnNpZGVyZWQgJ2xvY2FsJ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZl9ibG9jayhub2RlLCBmbiwgZWxzZWlmID0gZmFsc2UpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgY29uc2VxdWVudF9lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGFsdGVybmF0ZV9lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7VU5JTklUSUFMSVpFRCB8IGJvb2xlYW4gfCBudWxsfSAqL1xuXHR2YXIgY29uZGl0aW9uID0gVU5JTklUSUFMSVpFRDtcblxuXHR2YXIgZmxhZ3MgPSBlbHNlaWYgPyBFRkZFQ1RfVFJBTlNQQVJFTlQgOiAwO1xuXG5cdHZhciBoYXNfYnJhbmNoID0gZmFsc2U7XG5cblx0Y29uc3Qgc2V0X2JyYW5jaCA9ICgvKiogQHR5cGUgeyhhbmNob3I6IE5vZGUpID0+IHZvaWR9ICovIGZuLCBmbGFnID0gdHJ1ZSkgPT4ge1xuXHRcdGhhc19icmFuY2ggPSB0cnVlO1xuXHRcdHVwZGF0ZV9icmFuY2goZmxhZywgZm4pO1xuXHR9O1xuXG5cdGNvbnN0IHVwZGF0ZV9icmFuY2ggPSAoXG5cdFx0LyoqIEB0eXBlIHtib29sZWFuIHwgbnVsbH0gKi8gbmV3X2NvbmRpdGlvbixcblx0XHQvKiogQHR5cGUge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9ICovIGZuXG5cdCkgPT4ge1xuXHRcdGlmIChjb25kaXRpb24gPT09IChjb25kaXRpb24gPSBuZXdfY29uZGl0aW9uKSkgcmV0dXJuO1xuXG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhIGh5ZHJhdGlvbiBtaXNtYXRjaC4gTmVlZHMgdG8gYmUgYSBgbGV0YCBvciBlbHNlIGl0IGlzbid0IHRyZWVzaGFrZW4gb3V0ICovXG5cdFx0bGV0IG1pc21hdGNoID0gZmFsc2U7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRjb25zdCBpc19lbHNlID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRTtcblxuXHRcdFx0aWYgKCEhY29uZGl0aW9uID09PSBpc19lbHNlKSB7XG5cdFx0XHRcdC8vIEh5ZHJhdGlvbiBtaXNtYXRjaDogcmVtb3ZlIGV2ZXJ5dGhpbmcgaW5zaWRlIHRoZSBhbmNob3IgYW5kIHN0YXJ0IGZyZXNoLlxuXHRcdFx0XHQvLyBUaGlzIGNvdWxkIGhhcHBlbiB3aXRoIGB7I2lmIGJyb3dzZXJ9Li4uey9pZn1gLCBmb3IgZXhhbXBsZVxuXHRcdFx0XHRhbmNob3IgPSByZW1vdmVfbm9kZXMoKTtcblxuXHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNvbmRpdGlvbikge1xuXHRcdFx0aWYgKGNvbnNlcXVlbnRfZWZmZWN0KSB7XG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoY29uc2VxdWVudF9lZmZlY3QpO1xuXHRcdFx0fSBlbHNlIGlmIChmbikge1xuXHRcdFx0XHRjb25zZXF1ZW50X2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBmbihhbmNob3IpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFsdGVybmF0ZV9lZmZlY3QpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGFsdGVybmF0ZV9lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRhbHRlcm5hdGVfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhbHRlcm5hdGVfZWZmZWN0KSB7XG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoYWx0ZXJuYXRlX2VmZmVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGZuKSB7XG5cdFx0XHRcdGFsdGVybmF0ZV9lZmZlY3QgPSBicmFuY2goKCkgPT4gZm4oYW5jaG9yKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb25zZXF1ZW50X2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoY29uc2VxdWVudF9lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRjb25zZXF1ZW50X2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRoYXNfYnJhbmNoID0gZmFsc2U7XG5cdFx0Zm4oc2V0X2JyYW5jaCk7XG5cdFx0aWYgKCFoYXNfYnJhbmNoKSB7XG5cdFx0XHR1cGRhdGVfYnJhbmNoKG51bGwsIG51bGwpO1xuXHRcdH1cblx0fSwgZmxhZ3MpO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWFjaEl0ZW0sIEVhY2hTdGF0ZSwgRWZmZWN0LCBNYXliZVNvdXJjZSwgU291cmNlLCBUZW1wbGF0ZU5vZGUsIFRyYW5zaXRpb25NYW5hZ2VyLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRFQUNIX0lOREVYX1JFQUNUSVZFLFxuXHRFQUNIX0lTX0FOSU1BVEVELFxuXHRFQUNIX0lTX0NPTlRST0xMRUQsXG5cdEVBQ0hfSVRFTV9JTU1VVEFCTEUsXG5cdEVBQ0hfSVRFTV9SRUFDVElWRSxcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX1NUQVJUX0VMU0Vcbn0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHJlbW92ZV9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nXG59IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnMsXG5cdHBhdXNlX2NoaWxkcmVuLFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgbXV0YWJsZV9zb3VyY2UsIGludGVybmFsX3NldCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tLCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBJTkVSVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24gfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIFRoZSByb3cgb2YgYSBrZXllZCBlYWNoIGJsb2NrIHRoYXQgaXMgY3VycmVudGx5IHVwZGF0aW5nLiBXZSB0cmFjayB0aGlzXG4gKiBzbyB0aGF0IGBhbmltYXRlOmAgZGlyZWN0aXZlcyBoYXZlIHNvbWV0aGluZyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0b1xuICogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2VhY2hfaXRlbSA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gaXRlbSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2VhY2hfaXRlbShpdGVtKSB7XG5cdGN1cnJlbnRfZWFjaF9pdGVtID0gaXRlbTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gX1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KF8sIGkpIHtcblx0cmV0dXJuIGk7XG59XG5cbi8qKlxuICogUGF1c2UgbXVsdGlwbGUgZWZmZWN0cyBzaW11bHRhbmVvdXNseSwgYW5kIGNvb3JkaW5hdGUgdGhlaXJcbiAqIHN1YnNlcXVlbnQgZGVzdHJ1Y3Rpb24uIFVzZWQgaW4gZWFjaCBibG9ja3NcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbVtdfSBpdGVtc1xuICogQHBhcmFtIHtudWxsIHwgTm9kZX0gY29udHJvbGxlZF9hbmNob3JcbiAqIEBwYXJhbSB7TWFwPGFueSwgRWFjaEl0ZW0+fSBpdGVtc19tYXBcbiAqL1xuZnVuY3Rpb24gcGF1c2VfZWZmZWN0cyhzdGF0ZSwgaXRlbXMsIGNvbnRyb2xsZWRfYW5jaG9yLCBpdGVtc19tYXApIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0cGF1c2VfY2hpbGRyZW4oaXRlbXNbaV0uZSwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXHR9XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSBsZW5ndGggPiAwICYmIHRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCAmJiBjb250cm9sbGVkX2FuY2hvciAhPT0gbnVsbDtcblx0Ly8gSWYgd2UgaGF2ZSBhIGNvbnRyb2xsZWQgYW5jaG9yLCBpdCBtZWFucyB0aGF0IHRoZSBlYWNoIGJsb2NrIGlzIGluc2lkZSBhIHNpbmdsZVxuXHQvLyBET00gZWxlbWVudCwgc28gd2UgY2FuIGFwcGx5IGEgZmFzdC1wYXRoIGZvciBjbGVhcmluZyB0aGUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoXG5cdFx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovIChjb250cm9sbGVkX2FuY2hvcikucGFyZW50Tm9kZVxuXHRcdCk7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KHBhcmVudF9ub2RlKTtcblx0XHRwYXJlbnRfbm9kZS5hcHBlbmQoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoY29udHJvbGxlZF9hbmNob3IpKTtcblx0XHRpdGVtc19tYXAuY2xlYXIoKTtcblx0XHRsaW5rKHN0YXRlLCBpdGVtc1swXS5wcmV2LCBpdGVtc1tsZW5ndGggLSAxXS5uZXh0KTtcblx0fVxuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKCFpc19jb250cm9sbGVkKSB7XG5cdFx0XHRcdGl0ZW1zX21hcC5kZWxldGUoaXRlbS5rKTtcblx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0fVxuXHRcdFx0ZGVzdHJveV9lZmZlY3QoaXRlbS5lLCAhaXNfY29udHJvbGxlZCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudH0gbm9kZSBUaGUgbmV4dCBzaWJsaW5nIG5vZGUsIG9yIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGlzIGlzIGEgJ2NvbnRyb2xsZWQnIGJsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IE1heWJlU291cmNlPG51bWJlcj4pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG5vZGUsIGZsYWdzLCBnZXRfY29sbGVjdGlvbiwgZ2V0X2tleSwgcmVuZGVyX2ZuLCBmYWxsYmFja19mbiA9IG51bGwpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoU3RhdGV9ICovXG5cdHZhciBzdGF0ZSA9IHsgZmxhZ3MsIGl0ZW1zOiBuZXcgTWFwKCksIGZpcnN0OiBudWxsIH07XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwO1xuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSk7XG5cblx0XHRhbmNob3IgPSBoeWRyYXRpbmdcblx0XHRcdD8gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge0NvbW1lbnQgfCBUZXh0fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHBhcmVudF9ub2RlKSkpXG5cdFx0XHQ6IHBhcmVudF9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZmFsbGJhY2sgPSBudWxsO1xuXG5cdHZhciB3YXNfZW1wdHkgPSBmYWxzZTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSBnZXRfY29sbGVjdGlvbigpO1xuXG5cdFx0dmFyIGFycmF5ID0gaXNfYXJyYXkoY29sbGVjdGlvbilcblx0XHRcdD8gY29sbGVjdGlvblxuXHRcdFx0OiBjb2xsZWN0aW9uID09IG51bGxcblx0XHRcdFx0PyBbXVxuXHRcdFx0XHQ6IGFycmF5X2Zyb20oY29sbGVjdGlvbik7XG5cblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0aWYgKHdhc19lbXB0eSAmJiBsZW5ndGggPT09IDApIHtcblx0XHRcdC8vIGlnbm9yZSB1cGRhdGVzIGlmIHRoZSBhcnJheSBpcyBlbXB0eSxcblx0XHRcdC8vIGFuZCBpdCBhbHJlYWR5IHdhcyBlbXB0eSBvbiBwcmV2aW91cyBydW5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0d2FzX2VtcHR5ID0gbGVuZ3RoID09PSAwO1xuXG5cdFx0LyoqIGB0cnVlYCBpZiB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdGxldCBtaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0dmFyIGlzX2Vsc2UgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoaXNfZWxzZSAhPT0gKGxlbmd0aCA9PT0gMCkpIHtcblx0XHRcdFx0Ly8gaHlkcmF0aW9uIG1pc21hdGNoIOKAlCByZW1vdmUgdGhlIHNlcnZlci1yZW5kZXJlZCBET00gYW5kIHN0YXJ0IG92ZXJcblx0XHRcdFx0YW5jaG9yID0gcmVtb3ZlX25vZGVzKCk7XG5cblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0bWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoaXMgaXMgc2VwYXJhdGUgdG8gdGhlIHByZXZpb3VzIGJsb2NrIGJlY2F1c2UgYGh5ZHJhdGluZ2AgbWlnaHQgY2hhbmdlXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdFx0XHR2YXIgcHJldiA9IG51bGw7XG5cblx0XHRcdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdFx0XHR2YXIgaXRlbTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLm5vZGVUeXBlID09PSA4ICYmXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhID09PSBIWURSQVRJT05fRU5EXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIFRoZSBzZXJ2ZXIgcmVuZGVyZWQgZmV3ZXIgaXRlbXMgdGhhbiBleHBlY3RlZCxcblx0XHRcdFx0XHQvLyBzbyBicmVhayBvdXQgYW5kIGNvbnRpbnVlIGFwcGVuZGluZyBub24taHlkcmF0ZWQgaXRlbXNcblx0XHRcdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0XHR2YXIga2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRcdGl0ZW0gPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRoeWRyYXRlX25vZGUsXG5cdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0cHJldixcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdHJlbmRlcl9mbixcblx0XHRcdFx0XHRmbGFncyxcblx0XHRcdFx0XHRnZXRfY29sbGVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0XHRzdGF0ZS5pdGVtcy5zZXQoa2V5LCBpdGVtKTtcblxuXHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGV4Y2VzcyBub2Rlc1xuXHRcdFx0aWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShyZW1vdmVfbm9kZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHRcdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9yZWFjdGlvbik7XG5cdFx0XHRyZWNvbmNpbGUoXG5cdFx0XHRcdGFycmF5LFxuXHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0YW5jaG9yLFxuXHRcdFx0XHRyZW5kZXJfZm4sXG5cdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHQoZWZmZWN0LmYgJiBJTkVSVCkgIT09IDAsXG5cdFx0XHRcdGdldF9rZXksXG5cdFx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoZmFsbGJhY2spIHtcblx0XHRcdFx0XHRyZXN1bWVfZWZmZWN0KGZhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IGJyYW5jaCgoKSA9PiBmYWxsYmFja19mbihhbmNob3IpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZmFsbGJhY2ssICgpID0+IHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB3ZSBtb3VudCB0aGUgZWFjaCBibG9jayBmb3IgdGhlIGZpcnN0IHRpbWUsIHRoZSBjb2xsZWN0aW9uIHdvbid0IGJlXG5cdFx0Ly8gY29ubmVjdGVkIHRvIHRoaXMgZWZmZWN0IGFzIHRoZSBlZmZlY3QgaGFzbid0IGZpbmlzaGVkIHJ1bm5pbmcgeWV0IGFuZCBpdHMgZGVwc1xuXHRcdC8vIHdvbid0IGJlIGFzc2lnbmVkLiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgd2hlbiByZWNvbmNpbGluZyB0aGUgZWFjaCBibG9ja1xuXHRcdC8vIHRoYXQgYSBtdXRhdGlvbiBvY2N1cnJlZCBhbmQgaXQncyBtYWRlIHRoZSBjb2xsZWN0aW9uIE1BWUJFX0RJUlRZLCBzbyByZWFkaW5nIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gYWdhaW4gY2FuIHByb3ZpZGUgY29uc2lzdGVuY3kgdG8gdGhlIHJlYWN0aXZlIGdyYXBoIGFnYWluIGFzIHRoZSBkZXJpdmVkc1xuXHRcdC8vIHdpbGwgbm93IGJlIGBDTEVBTmAuXG5cdFx0Z2V0X2NvbGxlY3Rpb24oKTtcblx0fSk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEFkZCwgcmVtb3ZlLCBvciByZW9yZGVyIGl0ZW1zIG91dHB1dCBieSBhbiBlYWNoIGJsb2NrIGFzIGl0cyBpbnB1dCBjaGFuZ2VzXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtBcnJheTxWPn0gYXJyYXlcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudCB8IFRleHR9IGFuY2hvclxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFNvdXJjZTxudW1iZXI+KSA9PiB2b2lkfSByZW5kZXJfZm5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtib29sZWFufSBpc19pbmVydFxuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHBhcmFtIHsoKSA9PiBWW119IGdldF9jb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVjb25jaWxlKGFycmF5LCBzdGF0ZSwgYW5jaG9yLCByZW5kZXJfZm4sIGZsYWdzLCBpc19pbmVydCwgZ2V0X2tleSwgZ2V0X2NvbGxlY3Rpb24pIHtcblx0dmFyIGlzX2FuaW1hdGVkID0gKGZsYWdzICYgRUFDSF9JU19BTklNQVRFRCkgIT09IDA7XG5cdHZhciBzaG91bGRfdXBkYXRlID0gKGZsYWdzICYgKEVBQ0hfSVRFTV9SRUFDVElWRSB8IEVBQ0hfSU5ERVhfUkVBQ1RJVkUpKSAhPT0gMDtcblxuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR2YXIgaXRlbXMgPSBzdGF0ZS5pdGVtcztcblx0dmFyIGZpcnN0ID0gc3RhdGUuZmlyc3Q7XG5cdHZhciBjdXJyZW50ID0gZmlyc3Q7XG5cblx0LyoqIEB0eXBlIHt1bmRlZmluZWQgfCBTZXQ8RWFjaEl0ZW0+fSAqL1xuXHR2YXIgc2VlbjtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH0gKi9cblx0dmFyIHByZXYgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHRvX2FuaW1hdGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbVtdfSAqL1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIHN0YXNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge1Z9ICovXG5cdHZhciB2YWx1ZTtcblxuXHQvKiogQHR5cGUge2FueX0gKi9cblx0dmFyIGtleTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaXRlbTtcblxuXHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0dmFyIGk7XG5cblx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0a2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRpdGVtID0gaXRlbXMuZ2V0KGtleSk7XG5cblx0XHRcdGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aXRlbS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdCh0b19hbmltYXRlID8/PSBuZXcgU2V0KCkpLmFkZChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdGl0ZW0gPSBpdGVtcy5nZXQoa2V5KTtcblxuXHRcdGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSBjdXJyZW50ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjdXJyZW50LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdFx0XHRwcmV2ID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdGNoaWxkX2FuY2hvcixcblx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdHByZXYsXG5cdFx0XHRcdHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0aSxcblx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRmbGFncyxcblx0XHRcdFx0Z2V0X2NvbGxlY3Rpb25cblx0XHRcdCk7XG5cblx0XHRcdGl0ZW1zLnNldChrZXksIHByZXYpO1xuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdGN1cnJlbnQgPSBwcmV2Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkX3VwZGF0ZSkge1xuXHRcdFx0dXBkYXRlX2l0ZW0oaXRlbSwgdmFsdWUsIGksIGZsYWdzKTtcblx0XHR9XG5cblx0XHRpZiAoKGl0ZW0uZS5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0XHRyZXN1bWVfZWZmZWN0KGl0ZW0uZSk7XG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0aXRlbS5hPy51bmZpeCgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5kZWxldGUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gIT09IGN1cnJlbnQpIHtcblx0XHRcdGlmIChzZWVuICE9PSB1bmRlZmluZWQgJiYgc2Vlbi5oYXMoaXRlbSkpIHtcblx0XHRcdFx0aWYgKG1hdGNoZWQubGVuZ3RoIDwgc3Rhc2hlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGxhdGVyIGl0ZW1zIHRvIHRoZSBmcm9udFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHN0YXNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGo7XG5cblx0XHRcdFx0XHRwcmV2ID0gc3RhcnQucHJldjtcblxuXHRcdFx0XHRcdHZhciBhID0gbWF0Y2hlZFswXTtcblx0XHRcdFx0XHR2YXIgYiA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRtb3ZlKG1hdGNoZWRbal0sIHN0YXJ0LCBhbmNob3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzdGFzaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRzZWVuLmRlbGV0ZShzdGFzaGVkW2pdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBhLnByZXYsIGIubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgYSk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYiwgc3RhcnQpO1xuXG5cdFx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHByZXYgPSBiO1xuXHRcdFx0XHRcdGkgLT0gMTtcblxuXHRcdFx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdFx0XHRzdGFzaGVkID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBlYXJsaWVyIGl0ZW1zIHRvIHRoZSBiYWNrXG5cdFx0XHRcdFx0c2Vlbi5kZWxldGUoaXRlbSk7XG5cdFx0XHRcdFx0bW92ZShpdGVtLCBjdXJyZW50LCBhbmNob3IpO1xuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0sIHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuayAhPT0ga2V5KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0IGFuZCBhbiBpdGVtIGhhcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGluZXJ0LFxuXHRcdFx0XHQvLyBza2lwIG92ZXIgYWRkaW5nIGl0IHRvIG91ciBzZWVuIFNldCBhcyB0aGUgaXRlbSBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcblx0XHRcdFx0aWYgKGlzX2luZXJ0IHx8IChjdXJyZW50LmUuZiAmIElORVJUKSA9PT0gMCkge1xuXHRcdFx0XHRcdChzZWVuID8/PSBuZXcgU2V0KCkpLmFkZChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFzaGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtID0gY3VycmVudDtcblx0XHR9XG5cblx0XHRtYXRjaGVkLnB1c2goaXRlbSk7XG5cdFx0cHJldiA9IGl0ZW07XG5cdFx0Y3VycmVudCA9IGl0ZW0ubmV4dDtcblx0fVxuXG5cdGlmIChjdXJyZW50ICE9PSBudWxsIHx8IHNlZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciB0b19kZXN0cm95ID0gc2VlbiA9PT0gdW5kZWZpbmVkID8gW10gOiBhcnJheV9mcm9tKHNlZW4pO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0LCB0aGVuIGluZXJ0IGVmZmVjdHMgYXJlIGN1cnJlbnRseSBvdXRyb2luZyBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWRcblx0XHRcdGlmIChpc19pbmVydCB8fCAoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0dG9fZGVzdHJveS5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdHJveV9sZW5ndGggPSB0b19kZXN0cm95Lmxlbmd0aDtcblxuXHRcdGlmIChkZXN0cm95X2xlbmd0aCA+IDApIHtcblx0XHRcdHZhciBjb250cm9sbGVkX2FuY2hvciA9IChmbGFncyAmIEVBQ0hfSVNfQ09OVFJPTExFRCkgIT09IDAgJiYgbGVuZ3RoID09PSAwID8gYW5jaG9yIDogbnVsbDtcblxuXHRcdFx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZXN0cm95X2xlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dG9fZGVzdHJveVtpXS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8uZml4KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGF1c2VfZWZmZWN0cyhzdGF0ZSwgdG9fZGVzdHJveSwgY29udHJvbGxlZF9hbmNob3IsIGl0ZW1zKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmICh0b19hbmltYXRlID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGZvciAoaXRlbSBvZiB0b19hbmltYXRlKSB7XG5cdFx0XHRcdGl0ZW0uYT8uYXBwbHkoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZmlyc3QgPSBzdGF0ZS5maXJzdCAmJiBzdGF0ZS5maXJzdC5lO1xuXHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmxhc3QgPSBwcmV2ICYmIHByZXYuZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VhY2hJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVfaXRlbShpdGVtLCB2YWx1ZSwgaW5kZXgsIHR5cGUpIHtcblx0aWYgKCh0eXBlICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMCkge1xuXHRcdGludGVybmFsX3NldChpdGVtLnYsIHZhbHVlKTtcblx0fVxuXG5cdGlmICgodHlwZSAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpICE9PSAwKSB7XG5cdFx0aW50ZXJuYWxfc2V0KC8qKiBAdHlwZSB7VmFsdWU8bnVtYmVyPn0gKi8gKGl0ZW0uaSksIGluZGV4KTtcblx0fSBlbHNlIHtcblx0XHRpdGVtLmkgPSBpbmRleDtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge05vZGV9IGFuY2hvclxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7dW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogViB8IFNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFZhbHVlPG51bWJlcj4pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtFYWNoSXRlbX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2l0ZW0oXG5cdGFuY2hvcixcblx0c3RhdGUsXG5cdHByZXYsXG5cdG5leHQsXG5cdHZhbHVlLFxuXHRrZXksXG5cdGluZGV4LFxuXHRyZW5kZXJfZm4sXG5cdGZsYWdzLFxuXHRnZXRfY29sbGVjdGlvblxuKSB7XG5cdHZhciBwcmV2aW91c19lYWNoX2l0ZW0gPSBjdXJyZW50X2VhY2hfaXRlbTtcblx0dmFyIHJlYWN0aXZlID0gKGZsYWdzICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMDtcblx0dmFyIG11dGFibGUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fSU1NVVRBQkxFKSA9PT0gMDtcblxuXHR2YXIgdiA9IHJlYWN0aXZlID8gKG11dGFibGUgPyBtdXRhYmxlX3NvdXJjZSh2YWx1ZSkgOiBzb3VyY2UodmFsdWUpKSA6IHZhbHVlO1xuXHR2YXIgaSA9IChmbGFncyAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpID09PSAwID8gaW5kZXggOiBzb3VyY2UoaW5kZXgpO1xuXG5cdGlmIChERVYgJiYgcmVhY3RpdmUpIHtcblx0XHQvLyBGb3IgdHJhY2luZyBwdXJwb3Nlcywgd2UgbmVlZCB0byBsaW5rIHRoZSBzb3VyY2Ugc2lnbmFsIHdlIGNyZWF0ZSB3aXRoIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gKyBpbmRleCBzbyB0aGF0IHRyYWNpbmcgd29ya3MgYXMgaW50ZW5kZWRcblx0XHQvKiogQHR5cGUge1ZhbHVlfSAqLyAodikuZGVidWcgPSAoKSA9PiB7XG5cdFx0XHR2YXIgY29sbGVjdGlvbl9pbmRleCA9IHR5cGVvZiBpID09PSAnbnVtYmVyJyA/IGluZGV4IDogaS52O1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdGdldF9jb2xsZWN0aW9uKClbY29sbGVjdGlvbl9pbmRleF07XG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdHZhciBpdGVtID0ge1xuXHRcdGksXG5cdFx0dixcblx0XHRrOiBrZXksXG5cdFx0YTogbnVsbCxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZTogbnVsbCxcblx0XHRwcmV2LFxuXHRcdG5leHRcblx0fTtcblxuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG5cblx0dHJ5IHtcblx0XHRpdGVtLmUgPSBicmFuY2goKCkgPT4gcmVuZGVyX2ZuKGFuY2hvciwgdiwgaSksIGh5ZHJhdGluZyk7XG5cblx0XHRpdGVtLmUucHJldiA9IHByZXYgJiYgcHJldi5lO1xuXHRcdGl0ZW0uZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cblx0XHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdFx0c3RhdGUuZmlyc3QgPSBpdGVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBpdGVtO1xuXHRcdFx0cHJldi5lLm5leHQgPSBpdGVtLmU7XG5cdFx0fVxuXG5cdFx0aWYgKG5leHQgIT09IG51bGwpIHtcblx0XHRcdG5leHQucHJldiA9IGl0ZW07XG5cdFx0XHRuZXh0LmUucHJldiA9IGl0ZW0uZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fSBmaW5hbGx5IHtcblx0XHRjdXJyZW50X2VhY2hfaXRlbSA9IHByZXZpb3VzX2VhY2hfaXRlbTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaEl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKiBAcGFyYW0ge1RleHQgfCBFbGVtZW50IHwgQ29tbWVudH0gYW5jaG9yXG4gKi9cbmZ1bmN0aW9uIG1vdmUoaXRlbSwgbmV4dCwgYW5jaG9yKSB7XG5cdHZhciBlbmQgPSBpdGVtLm5leHQgPyAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGl0ZW0ubmV4dC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblxuXHR2YXIgZGVzdCA9IG5leHQgPyAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHQuZS5ub2Rlc19zdGFydCkgOiBhbmNob3I7XG5cdHZhciBub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChpdGVtLmUubm9kZXNfc3RhcnQpO1xuXG5cdHdoaWxlIChub2RlICE9PSBlbmQpIHtcblx0XHR2YXIgbmV4dF9ub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHRkZXN0LmJlZm9yZShub2RlKTtcblx0XHRub2RlID0gbmV4dF9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqL1xuZnVuY3Rpb24gbGluayhzdGF0ZSwgcHJldiwgbmV4dCkge1xuXHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdHN0YXRlLmZpcnN0ID0gbmV4dDtcblx0fSBlbHNlIHtcblx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdHByZXYuZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cdH1cblxuXHRpZiAobmV4dCAhPT0gbnVsbCkge1xuXHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0bmV4dC5lLnByZXYgPSBwcmV2ICYmIHByZXYuZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgSFlEUkFUSU9OX0VSUk9SIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIGRlc3Ryb3lfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4uL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBoYXNoLCBzYW5pdGl6ZV9sb2NhdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBnZXRfZmlyc3RfY2hpbGQsIGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gc2VydmVyX2hhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBjaGVja19oYXNoKGVsZW1lbnQsIHNlcnZlcl9oYXNoLCB2YWx1ZSkge1xuXHRpZiAoIXNlcnZlcl9oYXNoIHx8IHNlcnZlcl9oYXNoID09PSBoYXNoKFN0cmluZyh2YWx1ZSA/PyAnJykpKSByZXR1cm47XG5cblx0bGV0IGxvY2F0aW9uO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgbG9jID0gZWxlbWVudC5fX3N2ZWx0ZV9tZXRhPy5sb2M7XG5cdGlmIChsb2MpIHtcblx0XHRsb2NhdGlvbiA9IGBuZWFyICR7bG9jLmZpbGV9OiR7bG9jLmxpbmV9OiR7bG9jLmNvbHVtbn1gO1xuXHR9IGVsc2UgaWYgKGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbj8uW0ZJTEVOQU1FXSkge1xuXHRcdGxvY2F0aW9uID0gYGluICR7ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uW0ZJTEVOQU1FXX1gO1xuXHR9XG5cblx0dy5oeWRyYXRpb25faHRtbF9jaGFuZ2VkKHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50IHwgVGV4dCB8IENvbW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ZnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1hdGhtbFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sKG5vZGUsIGdldF92YWx1ZSwgc3ZnLCBtYXRobWwsIHNraXBfd2FybmluZykge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHR2YXIgdmFsdWUgPSAnJztcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGVmZmVjdDtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0aWYgKHZhbHVlID09PSAodmFsdWUgPSBnZXRfdmFsdWUoKSA/PyAnJykpIHtcblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGVmZmVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0ZWZmZWN0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuXHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3QgdHJ5aW5nIHRvIHJlcGFpciBtaXNtYXRjaGVzIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsXG5cdFx0XHRcdC8vIGFzIGl0J3MgY29zdGx5IGFuZCBlcnJvci1wcm9uZSAoYW5kIGl0J3MgYW4gZWRnZSBjYXNlIHRvIGhhdmUgYSBtaXNtYXRjaCBhbnl3YXkpXG5cdFx0XHRcdHZhciBoYXNoID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhO1xuXHRcdFx0XHR2YXIgbmV4dCA9IGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0XHR2YXIgbGFzdCA9IG5leHQ7XG5cblx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdG5leHQgIT09IG51bGwgJiZcblx0XHRcdFx0XHQobmV4dC5ub2RlVHlwZSAhPT0gOCB8fCAvKiogQHR5cGUge0NvbW1lbnR9ICovIChuZXh0KS5kYXRhICE9PSAnJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0bGFzdCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhuZXh0KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0XHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdFx0Y2hlY2tfaGFzaCgvKiogQHR5cGUge0VsZW1lbnR9ICovIChuZXh0LnBhcmVudE5vZGUpLCBoYXNoLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBsYXN0KTtcblx0XHRcdFx0YW5jaG9yID0gc2V0X2h5ZHJhdGVfbm9kZShuZXh0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaHRtbCA9IHZhbHVlICsgJyc7XG5cdFx0XHRpZiAoc3ZnKSBodG1sID0gYDxzdmc+JHtodG1sfTwvc3ZnPmA7XG5cdFx0XHRlbHNlIGlmIChtYXRobWwpIGh0bWwgPSBgPG1hdGg+JHtodG1sfTwvbWF0aD5gO1xuXG5cdFx0XHQvLyBEb24ndCB1c2UgY3JlYXRlX2ZyYWdtZW50X3dpdGhfc2NyaXB0X2Zyb21faHRtbCBoZXJlIGJlY2F1c2UgdGhhdCB3b3VsZCBtZWFuIHNjcmlwdCB0YWdzIGFyZSBleGVjdXRlZC5cblx0XHRcdC8vIEBodG1sIGlzIGJhc2ljYWxseSBgLmlubmVySFRNTCA9IC4uLmAgYW5kIHRoYXQgZG9lc24ndCBleGVjdXRlIHNjcmlwdHMgZWl0aGVyIGR1ZSB0byBzZWN1cml0eSByZWFzb25zLlxuXHRcdFx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gKi9cblx0XHRcdHZhciBub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKTtcblxuXHRcdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0XHR9XG5cblx0XHRcdGFzc2lnbl9ub2Rlcyhcblx0XHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpLFxuXHRcdFx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5vZGUubGFzdENoaWxkKVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChub2RlKSkge1xuXHRcdFx0XHRcdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuY2hvci5iZWZvcmUobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29tbWVudH0gYW5jaG9yXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBzbG90X3Byb3BzXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogQ29tbWVudCkgPT4gdm9pZCl9IGZhbGxiYWNrX2ZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbG90KGFuY2hvciwgJCRwcm9wcywgbmFtZSwgc2xvdF9wcm9wcywgZmFsbGJhY2tfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIHNsb3RfZm4gPSAkJHByb3BzLiQkc2xvdHM/LltuYW1lXTtcblx0Ly8gSW50ZXJvcDogQ2FuIHVzZSBzbmlwcGV0cyB0byBmaWxsIHNsb3RzXG5cdHZhciBpc19pbnRlcm9wID0gZmFsc2U7XG5cdGlmIChzbG90X2ZuID09PSB0cnVlKSB7XG5cdFx0c2xvdF9mbiA9ICQkcHJvcHNbbmFtZSA9PT0gJ2RlZmF1bHQnID8gJ2NoaWxkcmVuJyA6IG5hbWVdO1xuXHRcdGlzX2ludGVyb3AgPSB0cnVlO1xuXHR9XG5cblx0aWYgKHNsb3RfZm4gPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0ZmFsbGJhY2tfZm4oYW5jaG9yKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c2xvdF9mbihhbmNob3IsIGlzX2ludGVyb3AgPyAoKSA9PiBzbG90X3Byb3BzIDogc2xvdF9wcm9wcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZV9zbG90cyhwcm9wcykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuXHRjb25zdCBzYW5pdGl6ZWQgPSB7fTtcblx0aWYgKHByb3BzLmNoaWxkcmVuKSBzYW5pdGl6ZWQuZGVmYXVsdCA9IHRydWU7XG5cdGZvciAoY29uc3Qga2V5IGluIHByb3BzLiQkc2xvdHMpIHtcblx0XHRzYW5pdGl6ZWRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHNhbml0aXplZDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZScgKi9cbi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBicmFuY2gsIGJsb2NrLCBkZXN0cm95X2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgeyhub2RlOiBUZW1wbGF0ZU5vZGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBTbmlwcGV0Rm5cbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IFNuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9IGdldF9zbmlwcGV0XG4gKiBAcGFyYW0geygoKSA9PiBhbnkpW119IGFyZ3NcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25pcHBldChub2RlLCBnZXRfc25pcHBldCwgLi4uYXJncykge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge1NuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0dmFyIHNuaXBwZXQgPSBub29wO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIHNuaXBwZXRfZWZmZWN0O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoc25pcHBldCA9PT0gKHNuaXBwZXQgPSBnZXRfc25pcHBldCgpKSkgcmV0dXJuO1xuXG5cdFx0aWYgKHNuaXBwZXRfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChzbmlwcGV0X2VmZmVjdCk7XG5cdFx0XHRzbmlwcGV0X2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKERFViAmJiBzbmlwcGV0ID09IG51bGwpIHtcblx0XHRcdGUuaW52YWxpZF9zbmlwcGV0KCk7XG5cdFx0fVxuXG5cdFx0c25pcHBldF9lZmZlY3QgPSBicmFuY2goKCkgPT4gLyoqIEB0eXBlIHtTbmlwcGV0Rm59ICovIChzbmlwcGV0KShhbmNob3IsIC4uLmFyZ3MpKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2ZWxvcG1lbnQsIHdyYXAgdGhlIHNuaXBwZXQgZnVuY3Rpb24gc28gdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbiwgYW5kIHNvIHRoYXQgdGhlXG4gKiBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0IGlzIHNldCBmb3Igb3duZXJzaGlwIGNoZWNrc1xuICogQHBhcmFtIHthbnl9IGNvbXBvbmVudFxuICogQHBhcmFtIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBfc25pcHBldChjb21wb25lbnQsIGZuKSB7XG5cdHJldHVybiAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIG5vZGUsIC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oY29tcG9uZW50KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4obm9kZSwgLi4uYXJncyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24ocHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc25pcHBldCBwcm9ncmFtbWF0aWNhbGx5XG4gKiBAdGVtcGxhdGUge3Vua25vd25bXX0gUGFyYW1zXG4gKiBAcGFyYW0geyguLi5wYXJhbXM6IEdldHRlcnM8UGFyYW1zPikgPT4ge1xuICogICByZW5kZXI6ICgpID0+IHN0cmluZ1xuICogICBzZXR1cD86IChlbGVtZW50OiBFbGVtZW50KSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpXG4gKiB9fSBmblxuICogQHJldHVybnMge1NuaXBwZXQ8UGFyYW1zPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhd1NuaXBwZXQoZm4pIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZXMgYXJlIGEgbGllXG5cdHJldHVybiAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIGFuY2hvciwgLyoqIEB0eXBlIHtHZXR0ZXJzPFBhcmFtcz59ICovIC4uLnBhcmFtcykgPT4ge1xuXHRcdHZhciBzbmlwcGV0ID0gZm4oLi4ucGFyYW1zKTtcblxuXHRcdC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cblx0XHR2YXIgZWxlbWVudDtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBodG1sID0gc25pcHBldC5yZW5kZXIoKS50cmltKCk7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpO1xuXHRcdFx0ZWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoREVWICYmIChnZXRfbmV4dF9zaWJsaW5nKGVsZW1lbnQpICE9PSBudWxsIHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpKSB7XG5cdFx0XHRcdHcuaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSBzbmlwcGV0LnNldHVwPy4oZWxlbWVudCk7XG5cdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRlYXJkb3duKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUsIERvbSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBwYXVzZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFBcbiAqIEB0ZW1wbGF0ZSB7KHByb3BzOiBQKSA9PiB2b2lkfSBDXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBDfSBnZXRfY29tcG9uZW50XG4gKiBAcGFyYW0geyhhbmNob3I6IFRlbXBsYXRlTm9kZSwgY29tcG9uZW50OiBDKSA9PiBEb20gfCB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50KG5vZGUsIGdldF9jb21wb25lbnQsIHJlbmRlcl9mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0N9ICovXG5cdHZhciBjb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoY29tcG9uZW50ID09PSAoY29tcG9uZW50ID0gZ2V0X2NvbXBvbmVudCgpKSkgcmV0dXJuO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChjb21wb25lbnQpIHtcblx0XHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiByZW5kZXJfZm4oYW5jaG9yLCBjb21wb25lbnQpKTtcblx0XHR9XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgTkFNRVNQQUNFX1NWRyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQge1xuXHRibG9jayxcblx0YnJhbmNoLFxuXHRkZXN0cm95X2VmZmVjdCxcblx0cGF1c2VfZWZmZWN0LFxuXHRyZXN1bWVfZWZmZWN0XG59IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzZXRfc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfZWFjaF9pdGVtLCBzZXRfY3VycmVudF9lYWNoX2l0ZW0gfSBmcm9tICcuL2VhY2guanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGlzX3Jhd190ZXh0X2VsZW1lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtDb21tZW50IHwgRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF90YWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoZWxlbWVudDogRWxlbWVudCwgYW5jaG9yOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCl9IHJlbmRlcl9mbixcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgKCgpID0+IHN0cmluZyl9IGdldF9uYW1lc3BhY2VcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgW251bWJlciwgbnVtYmVyXX0gbG9jYXRpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChub2RlLCBnZXRfdGFnLCBpc19zdmcsIHJlbmRlcl9mbiwgZ2V0X25hbWVzcGFjZSwgbG9jYXRpb24pIHtcblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGZpbGVuYW1lID0gREVWICYmIGxvY2F0aW9uICYmIGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbltGSUxFTkFNRV07XG5cblx0LyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuXHR2YXIgdGFnO1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cblx0dmFyIGN1cnJlbnRfdGFnO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdHZhciBlbGVtZW50ID0gbnVsbDtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZSk7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdC8qKlxuXHQgKiBUaGUga2V5ZWQgYHsjZWFjaCAuLi59YCBpdGVtIGJsb2NrLCBpZiBhbnksIHRoYXQgdGhpcyBlbGVtZW50IGlzIGluc2lkZS5cblx0ICogV2UgdHJhY2sgdGhpcyBzbyB3ZSBjYW4gc2V0IGl0IHdoZW4gY2hhbmdpbmcgdGhlIGVsZW1lbnQsIGFsbG93aW5nIGFueVxuXHQgKiBgYW5pbWF0ZTpgIGRpcmVjdGl2ZSB0byBiaW5kIGl0c2VsZiB0byB0aGUgY29ycmVjdCBibG9ja1xuXHQgKi9cblx0dmFyIGVhY2hfaXRlbV9ibG9jayA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRjb25zdCBuZXh0X3RhZyA9IGdldF90YWcoKSB8fCBudWxsO1xuXHRcdHZhciBucyA9IGdldF9uYW1lc3BhY2UgPyBnZXRfbmFtZXNwYWNlKCkgOiBpc19zdmcgfHwgbmV4dF90YWcgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG51bGw7XG5cblx0XHQvLyBBc3N1bXB0aW9uOiBOb29uZSBjaGFuZ2VzIHRoZSBuYW1lc3BhY2UgYnV0IG5vdCB0aGUgdGFnICh3aGF0IHdvdWxkIHRoYXQgZXZlbiBtZWFuPylcblx0XHRpZiAobmV4dF90YWcgPT09IHRhZykgcmV0dXJuO1xuXG5cdFx0Ly8gU2VlIGV4cGxhbmF0aW9uIG9mIGBlYWNoX2l0ZW1fYmxvY2tgIGFib3ZlXG5cdFx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShlYWNoX2l0ZW1fYmxvY2spO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0aWYgKG5leHRfdGFnID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIHN0YXJ0IG91dHJvXG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRfdGFnID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKG5leHRfdGFnID09PSBjdXJyZW50X3RhZykge1xuXHRcdFx0XHQvLyBzYW1lIHRhZyBhcyBpcyBjdXJyZW50bHkgcmVuZGVyZWQg4oCUIGFib3J0IG91dHJvXG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRhZyBpcyBjaGFuZ2luZyDigJQgZGVzdHJveSBpbW1lZGlhdGVseSwgcmVuZGVyIGNvbnRlbnRzIHdpdGhvdXQgaW50cm8gdHJhbnNpdGlvbnNcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0c2V0X3Nob3VsZF9pbnRybyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRfdGFnICYmIG5leHRfdGFnICE9PSBjdXJyZW50X3RhZykge1xuXHRcdFx0ZWZmZWN0ID0gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0ZWxlbWVudCA9IGh5ZHJhdGluZ1xuXHRcdFx0XHRcdD8gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZWxlbWVudClcblx0XHRcdFx0XHQ6IG5zXG5cdFx0XHRcdFx0XHQ/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgbmV4dF90YWcpXG5cdFx0XHRcdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dF90YWcpO1xuXG5cdFx0XHRcdGlmIChERVYgJiYgbG9jYXRpb24pIHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdFx0XHRcdFx0bG9jOiB7XG5cdFx0XHRcdFx0XHRcdGZpbGU6IGZpbGVuYW1lLFxuXHRcdFx0XHRcdFx0XHRsaW5lOiBsb2NhdGlvblswXSxcblx0XHRcdFx0XHRcdFx0Y29sdW1uOiBsb2NhdGlvblsxXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ25fbm9kZXMoZWxlbWVudCwgZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKHJlbmRlcl9mbikge1xuXHRcdFx0XHRcdGlmIChoeWRyYXRpbmcgJiYgaXNfcmF3X3RleHRfZWxlbWVudChuZXh0X3RhZykpIHtcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgaHlkcmF0aW9uIGdsaXRjaGVzXG5cdFx0XHRcdFx0XHRlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgaHlkcmF0aW5nLCB1c2UgdGhlIGV4aXN0aW5nIHNzciBjb21tZW50IGFzIHRoZSBhbmNob3Igc28gdGhhdCB0aGVcblx0XHRcdFx0XHQvLyBpbm5lciBvcGVuIGFuZCBjbG9zZSBtZXRob2RzIGNhbiBwaWNrIHVwIHRoZSBleGlzdGluZyBub2RlcyBjb3JyZWN0bHlcblx0XHRcdFx0XHR2YXIgY2hpbGRfYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdFx0XHRcdGh5ZHJhdGluZyA/IGdldF9maXJzdF9jaGlsZChlbGVtZW50KSA6IGVsZW1lbnQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkX2FuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBgY2hpbGRfYW5jaG9yYCBpcyB1bmRlZmluZWQgaWYgdGhpcyBpcyBhIHZvaWQgZWxlbWVudCwgYnV0IHdlIHN0aWxsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjYWxsIGByZW5kZXJfZm5gIGluIG9yZGVyIHRvIHJ1biBhY3Rpb25zIGV0Yy4gSWYgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyBjb250YWlucyBjaGlsZHJlbiwgaXQncyBhIHVzZXIgZXJyb3IgKHdoaWNoIGlzIHdhcm5lZCBvbiBlbHNld2hlcmUpXG5cdFx0XHRcdFx0Ly8gYW5kIHRoZSBET00gd2lsbCBiZSBzaWxlbnRseSBkaXNjYXJkZWRcblx0XHRcdFx0XHRyZW5kZXJfZm4oZWxlbWVudCwgY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHdlIGRvIHRoaXMgYWZ0ZXIgY2FsbGluZyBgcmVuZGVyX2ZuYCBzbyB0aGF0IGNoaWxkIGVmZmVjdHMgZG9uJ3Qgb3ZlcnJpZGUgYG5vZGVzLmVuZGBcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBlbGVtZW50O1xuXG5cdFx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0YWcgPSBuZXh0X3RhZztcblx0XHRpZiAodGFnKSBjdXJyZW50X3RhZyA9IHRhZztcblx0XHRzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXG5cdFx0c2V0X2N1cnJlbnRfZWFjaF9pdGVtKHByZXZpb3VzX2VhY2hfaXRlbSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0fVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBvPWUubGVuZ3RoO2Zvcih0PTA7dDxvO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zil9ZWxzZSBmb3IoZiBpbiBlKWVbZl0mJihuJiYobis9XCIgXCIpLG4rPWYpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIixvPWFyZ3VtZW50cy5sZW5ndGg7ZjxvO2YrKykoZT1hcmd1bWVudHNbZl0pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgeyBlc2NhcGVfaHRtbCB9IGZyb20gJy4uLy4uL2VzY2FwaW5nLmpzJztcbmltcG9ydCB7IGNsc3ggYXMgX2Nsc3ggfSBmcm9tICdjbHN4JztcblxuLyoqXG4gKiBgPGRpdiB0cmFuc2xhdGU9e2ZhbHNlfT5gIHNob3VsZCBiZSByZW5kZXJlZCBhcyBgPGRpdiB0cmFuc2xhdGU9XCJub1wiPmAgYW5kIF9ub3RfXG4gKiBgPGRpdiB0cmFuc2xhdGU9XCJmYWxzZVwiPmAsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYDxkaXYgdHJhbnNsYXRlPVwieWVzXCI+YC4gVGhlcmVcbiAqIG1heSBiZSBvdGhlciBvZGQgY2FzZXMgdGhhdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoaXMgbGlzdCBpbiBmdXR1cmVcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBNYXA8YW55LCBzdHJpbmc+Pn1cbiAqL1xuY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuXHR0cmFuc2xhdGU6IG5ldyBNYXAoW1xuXHRcdFt0cnVlLCAneWVzJ10sXG5cdFx0W2ZhbHNlLCAnbm8nXVxuXHRdKVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX2Jvb2xlYW5dXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSwgaXNfYm9vbGVhbiA9IGZhbHNlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8ICghdmFsdWUgJiYgaXNfYm9vbGVhbikgfHwgKHZhbHVlID09PSAnJyAmJiBuYW1lID09PSAnY2xhc3MnKSkgcmV0dXJuICcnO1xuXHRjb25zdCBub3JtYWxpemVkID0gKG5hbWUgaW4gcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1tuYW1lXS5nZXQodmFsdWUpKSB8fCB2YWx1ZTtcblx0Y29uc3QgYXNzaWdubWVudCA9IGlzX2Jvb2xlYW4gPyAnJyA6IGA9XCIke2VzY2FwZV9odG1sKG5vcm1hbGl6ZWQsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKipcbiAqIFNtYWxsIHdyYXBwZXIgYXJvdW5kIGNsc3ggdG8gcHJlc2VydmUgU3ZlbHRlJ3MgKHdlaXJkKSBoYW5kbGluZyBvZiBmYWxzeSB2YWx1ZXMuXG4gKiBUT0RPIFN2ZWx0ZSA2IHJldmlzaXQgdGhpcywgYW5kIGxpa2VseSB0dXJuIGFsbCBmYWxzeSB2YWx1ZXMgaW50byB0aGUgZW1wdHkgc3RyaW5nICh3aGF0IGNsc3ggYWxzbyBkb2VzKVxuICogQHBhcmFtICB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xzeCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBfY2xzeCh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlID8/ICcnO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvcnMsIGdldF9wcm90b3R5cGVfb2YgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlX2V2ZW50LCBkZWxlZ2F0ZSB9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyLCBhdXRvZm9jdXMgfSBmcm9tICcuL21pc2MuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBMT0FESU5HX0FUVFJfU1lNQk9MIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHF1ZXVlX2lkbGVfdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgaXNfY2FwdHVyZV9ldmVudCwgaXNfZGVsZWdhdGVkLCBub3JtYWxpemVfYXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNsc3ggfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5cbi8qKlxuICogVGhlIHZhbHVlL2NoZWNrZWQgYXR0cmlidXRlIGluIHRoZSB0ZW1wbGF0ZSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX2lucHV0X2RlZmF1bHRzKGlucHV0KSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0dmFyIGFscmVhZHlfcmVtb3ZlZCA9IGZhbHNlO1xuXG5cdC8vIFdlIHRyeSBhbmQgcmVtb3ZlIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXMgbGF0ZXIsIHJhdGhlciB0aGFuIHN5bmMgZHVyaW5nIGh5ZHJhdGlvbi5cblx0Ly8gRG9pbmcgaXQgc3luYyBkdXJpbmcgaHlkcmF0aW9uIGhhcyBhIG5lZ2F0aXZlIGltcGFjdCBvbiBwZXJmb3JtYW5jZSwgYnV0IGRlZmVycmluZyB0aGVcblx0Ly8gd29yayBpbiBhbiBpZGxlIHRhc2sgYWxsZXZpYXRlcyB0aGlzIGdyZWF0bHkuIElmIGEgZm9ybSByZXNldCBldmVudCBjb21lcyBpbiBiZWZvcmVcblx0Ly8gdGhlIGlkbGUgY2FsbGJhY2ssIHRoZW4gd2UgZW5zdXJlIHRoZSBpbnB1dCBkZWZhdWx0cyBhcmUgY2xlYXJlZCBqdXN0IGJlZm9yZS5cblx0dmFyIHJlbW92ZV9kZWZhdWx0cyA9ICgpID0+IHtcblx0XHRpZiAoYWxyZWFkeV9yZW1vdmVkKSByZXR1cm47XG5cdFx0YWxyZWFkeV9yZW1vdmVkID0gdHJ1ZTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlcyBidXQgcHJlc2VydmUgdGhlIHZhbHVlc1xuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ3ZhbHVlJywgbnVsbCk7XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuXHRcdFx0dmFyIGNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ2NoZWNrZWQnLCBudWxsKTtcblx0XHRcdGlucHV0LmNoZWNrZWQgPSBjaGVja2VkO1xuXHRcdH1cblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlucHV0Ll9fb25fciA9IHJlbW92ZV9kZWZhdWx0cztcblx0cXVldWVfaWRsZV90YXNrKHJlbW92ZV9kZWZhdWx0cyk7XG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMudmFsdWUgPT09XG5cdFx0XHQoYXR0cmlidXRlcy52YWx1ZSA9XG5cdFx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdFx0dmFsdWUgPz8gdW5kZWZpbmVkKSB8fFxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHQvLyBgcHJvZ3Jlc3NgIGVsZW1lbnRzIGFsd2F5cyBuZWVkIHRoZWlyIHZhbHVlIHNldCB3aGVuIGl0cyBgMGBcblx0XHQoZWxlbWVudC52YWx1ZSA9PT0gdmFsdWUgJiYgKHZhbHVlICE9PSAwIHx8IGVsZW1lbnQubm9kZU5hbWUgIT09ICdQUk9HUkVTUycpKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2NoZWNrZWQoZWxlbWVudCwgY2hlY2tlZCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMuY2hlY2tlZCA9PT1cblx0XHQoYXR0cmlidXRlcy5jaGVja2VkID1cblx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdGNoZWNrZWQgPz8gdW5kZWZpbmVkKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgb24gYW4gYG9wdGlvbmAgZWxlbWVudC5cbiAqIE5vdCBzZXQgdGhyb3VnaCB0aGUgcHJvcGVydHkgYmVjYXVzZSB0aGF0IGRvZXNuJ3QgcmVmbGVjdCB0byB0aGUgRE9NLFxuICogd2hpY2ggbWVhbnMgaXQgd291bGRuJ3QgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gYSBmb3JtIGlzIHJlc2V0LlxuICogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NlbGVjdGVkKGVsZW1lbnQsIHNlbGVjdGVkKSB7XG5cdGlmIChzZWxlY3RlZCkge1xuXHRcdC8vIFRoZSBzZWxlY3RlZCBvcHRpb24gY291bGQndmUgY2hhbmdlZCB2aWEgdXNlciBzZWxlY3Rpb24sIGFuZFxuXHRcdC8vIHNldHRpbmcgdGhlIHZhbHVlIHdpdGhvdXQgdGhpcyBjaGVjayB3b3VsZCBzZXQgaXQgYmFjay5cblx0XHRpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnJyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZGVmYXVsdCBjaGVja2VkIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgY2hlY2tlZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVmYXVsdF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG5cdGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuXHRlbGVtZW50LmNoZWNrZWQgPSBleGlzdGluZ192YWx1ZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IHZhbHVlIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgdmFsdWUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X3ZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG5cdGNvbnN0IGV4aXN0aW5nX3ZhbHVlID0gZWxlbWVudC52YWx1ZTtcblx0ZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcblx0ZWxlbWVudC52YWx1ZSA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlLCBza2lwX3dhcm5pbmcpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgYXR0cmlidXRlcyA9IChlbGVtZW50Ll9fYXR0cmlidXRlcyA/Pz0ge30pO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXG5cdFx0aWYgKFxuXHRcdFx0YXR0cmlidXRlID09PSAnc3JjJyB8fFxuXHRcdFx0YXR0cmlidXRlID09PSAnc3Jjc2V0JyB8fFxuXHRcdFx0KGF0dHJpYnV0ZSA9PT0gJ2hyZWYnICYmIGVsZW1lbnQubm9kZU5hbWUgPT09ICdMSU5LJylcblx0XHQpIHtcblx0XHRcdGlmICghc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdGNoZWNrX3NyY19pbl9kZXZfaHlkcmF0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUgPz8gJycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSByZXNldCB0aGVzZSBhdHRyaWJ1dGVzLCB0aGV5IHdvdWxkIHJlc3VsdCBpbiBhbm90aGVyIG5ldHdvcmsgcmVxdWVzdCwgd2hpY2ggd2Ugd2FudCB0byBhdm9pZC5cblx0XHRcdC8vIFdlIGFzc3VtZSB0aGV5IGFyZSB0aGUgc2FtZSBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyIGFzIGNoZWNraW5nIGlmIHRoZXkgYXJlIGVxdWFsIGlzIGV4cGVuc2l2ZVxuXHRcdFx0Ly8gKHdlIGNhbid0IGp1c3QgY29tcGFyZSB0aGUgc3RyaW5ncyBhcyB0aGV5IGNhbiBiZSBkaWZmZXJlbnQgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBidXQgcmVzdWx0IGluIHRoZVxuXHRcdFx0Ly8gc2FtZSB1cmwsIHNvIHdlIHdvdWxkIG5lZWQgdG8gY3JlYXRlIGhpZGRlbiBhbmNob3IgZWxlbWVudHMgdG8gY29tcGFyZSB0aGVtKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPT09IChhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZSkpIHJldHVybjtcblxuXHRpZiAoYXR0cmlidXRlID09PSAnc3R5bGUnICYmICdfX3N0eWxlcycgaW4gZWxlbWVudCkge1xuXHRcdC8vIHJlc2V0IHN0eWxlcyB0byBmb3JjZSBzdHlsZTogZGlyZWN0aXZlIHRvIHVwZGF0ZVxuXHRcdGVsZW1lbnQuX19zdHlsZXMgPSB7fTtcblx0fVxuXG5cdGlmIChhdHRyaWJ1dGUgPT09ICdsb2FkaW5nJykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50W0xPQURJTkdfQVRUUl9TWU1CT0xdID0gdmFsdWU7XG5cdH1cblxuXHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiBnZXRfc2V0dGVycyhlbGVtZW50KS5pbmNsdWRlcyhhdHRyaWJ1dGUpKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGVsZW1lbnRbYXR0cmlidXRlXSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3hsaW5rX2F0dHJpYnV0ZShkb20sIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0ZG9tLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEobm9kZSwgcHJvcCwgdmFsdWUpIHtcblx0Ly8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCBzZXR0aW5nIGN1c3RvbSBlbGVtZW50IHByb3BzLCB3aGljaCBjYW5cblx0Ly8gaW52b2tlIGxpZmVjeWNsZSBtZXRob2RzIG9uIG90aGVyIGN1c3RvbSBlbGVtZW50cywgZG9lcyBub3QgYWxzb1xuXHQvLyBhc3NvY2lhdGUgdGhvc2UgbGlmZWN5Y2xlIG1ldGhvZHMgd2l0aCB0aGUgY3VycmVudCBhY3RpdmUgcmVhY3Rpb25cblx0Ly8gb3IgZWZmZWN0XG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHRyeSB7XG5cdFx0aWYgKFxuXHRcdFx0Ly8gRG9uJ3QgY29tcHV0ZSBzZXR0ZXJzIGZvciBjdXN0b20gZWxlbWVudHMgd2hpbGUgdGhleSBhcmVuJ3QgcmVnaXN0ZXJlZCB5ZXQsXG5cdFx0XHQvLyBiZWNhdXNlIGR1cmluZyB0aGVpciB1cGdyYWRlL2luc3RhbnRpYXRpb24gdGhleSBtaWdodCBhZGQgbW9yZSBzZXR0ZXJzLlxuXHRcdFx0Ly8gSW5zdGVhZCwgZmFsbCBiYWNrIHRvIGEgc2ltcGxlIFwiYW4gb2JqZWN0LCB0aGVuIHNldCBhcyBwcm9wZXJ0eVwiIGhldXJpc3RpYy5cblx0XHRcdHNldHRlcnNfY2FjaGUuaGFzKG5vZGUubm9kZU5hbWUpIHx8IGN1c3RvbUVsZW1lbnRzLmdldChub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0PyBnZXRfc2V0dGVycyhub2RlKS5pbmNsdWRlcyhwcm9wKVxuXHRcdFx0XHQ6IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdG5vZGVbcHJvcF0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gV2UgZGlkIGdldHRlcnMgZXRjIGNoZWNrcyBhbHJlYWR5LCBzdHJpbmdpZnkgYmVmb3JlIHBhc3NpbmcgdG8gc2V0X2F0dHJpYnV0ZVxuXHRcdFx0Ly8gdG8gZW5zdXJlIGl0IGRvZXNuJ3QgaW52b2tlIHRoZSBzYW1lIGxvZ2ljIGFnYWluLCBhbmQgcG90ZW50aWFsbHkgcG9wdWxhdGluZ1xuXHRcdFx0Ly8gdGhlIHNldHRlcnMgY2FjaGUgdG9vIGVhcmx5LlxuXHRcdFx0c2V0X2F0dHJpYnV0ZShub2RlLCBwcm9wLCB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIFNwcmVhZHMgYXR0cmlidXRlcyBvbnRvIGEgRE9NIGVsZW1lbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnRseSBzZXQgYXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWR9IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gbmV4dCBOZXcgYXR0cmlidXRlcyAtIHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlXVxuICogQHBhcmFtIHtib29sZWFufSBbaXNfY3VzdG9tX2VsZW1lbnRdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKFxuXHRlbGVtZW50LFxuXHRwcmV2LFxuXHRuZXh0LFxuXHRjc3NfaGFzaCxcblx0cHJlc2VydmVfYXR0cmlidXRlX2Nhc2UgPSBmYWxzZSxcblx0aXNfY3VzdG9tX2VsZW1lbnQgPSBmYWxzZSxcblx0c2tpcF93YXJuaW5nID0gZmFsc2Vcbikge1xuXHR2YXIgY3VycmVudCA9IHByZXYgfHwge307XG5cdHZhciBpc19vcHRpb25fZWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09QVElPTic7XG5cblx0Zm9yICh2YXIga2V5IGluIHByZXYpIHtcblx0XHRpZiAoIShrZXkgaW4gbmV4dCkpIHtcblx0XHRcdG5leHRba2V5XSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5leHQuY2xhc3MpIHtcblx0XHRuZXh0LmNsYXNzID0gY2xzeChuZXh0LmNsYXNzKTtcblx0fVxuXG5cdGlmIChjc3NfaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bmV4dC5jbGFzcyA9IG5leHQuY2xhc3MgPyBuZXh0LmNsYXNzICsgJyAnICsgY3NzX2hhc2ggOiBjc3NfaGFzaDtcblx0fVxuXG5cdHZhciBzZXR0ZXJzID0gZ2V0X3NldHRlcnMoZWxlbWVudCk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgYXR0cmlidXRlcyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICoqLyAoZWxlbWVudC5fX2F0dHJpYnV0ZXMgPz89IHt9KTtcblxuXHQvLyBzaW5jZSBrZXkgaXMgY2FwdHVyZWQgd2UgdXNlIGNvbnN0XG5cdGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcblx0XHQvLyBsZXQgaW5zdGVhZCBvZiB2YXIgYmVjYXVzZSByZWZlcmVuY2VkIGluIGEgY2xvc3VyZVxuXHRcdGxldCB2YWx1ZSA9IG5leHRba2V5XTtcblxuXHRcdC8vIFVwIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRvIGRvIHRoaXMgZm9yIHRoZSBpbml0aWFsIHZhbHVlLCB0b28sIGV2ZW4gaWYgaXQncyB1bmRlZmluZWQsXG5cdFx0Ly8gYW5kIHRoaXMgd291bGRuJ3QgYmUgcmVhY2hlZCBpbiBjYXNlIG9mIHVuZGVmaW5lZCBiZWNhdXNlIG9mIHRoZSBlcXVhbGl0eSBjaGVjayBiZWxvd1xuXHRcdGlmIChpc19vcHRpb25fZWxlbWVudCAmJiBrZXkgPT09ICd2YWx1ZScgJiYgdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0Ly8gVGhlIDxvcHRpb24+IGVsZW1lbnQgaXMgYSBzcGVjaWFsIGNhc2UgYmVjYXVzZSByZW1vdmluZyB0aGUgdmFsdWUgYXR0cmlidXRlIG1lYW5zXG5cdFx0XHQvLyB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG9wdGlvbiBlbGVtZW50LCBhbmQgc2V0dGluZyB0aGUgdmFsdWVcblx0XHRcdC8vIHRvIG51bGwgb3IgdW5kZWZpbmVkIG1lYW5zIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHN0cmluZyBcIm51bGxcIiBvciBcInVuZGVmaW5lZFwiLlxuXHRcdFx0Ly8gVG8gYWxpZ24gd2l0aCBob3cgd2UgaGFuZGxlIHRoaXMgY2FzZSBpbiBub24tc3ByZWFkLXNjZW5hcmlvcywgdGhpcyBsb2dpYyBpcyBuZWVkZWQuXG5cdFx0XHQvLyBUaGVyZSdzIGEgc3VwZXItZWRnZS1jYXNlIGJ1ZyBoZXJlIHRoYXQgaXMgbGVmdCBpbiBpbiBmYXZvciBvZiBzbWFsbGVyIGNvZGUgc2l6ZTpcblx0XHRcdC8vIEJlY2F1c2Ugb2YgdGhlIFwic2V0IG1pc3NpbmcgcHJvcHMgdG8gbnVsbFwiIGxvZ2ljIGFib3ZlLCB3ZSBjYW4ndCBkaWZmZXJlbnRpYXRlXG5cdFx0XHQvLyBiZXR3ZWVuIGEgbWlzc2luZyB2YWx1ZSBhbmQgYW4gZXhwbGljaXRseSBzZXQgdmFsdWUgb2YgbnVsbCBvciB1bmRlZmluZWQuIFRoYXQgbWVhbnNcblx0XHRcdC8vIHRoYXQgb25jZSBzZXQsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgb2YgYW4gPG9wdGlvbj4gZWxlbWVudCBjYW4ndCBiZSByZW1vdmVkLiBUaGlzIGlzXG5cdFx0XHQvLyBhIHZlcnkgcmFyZSBlZGdlIGNhc2UsIGFuZCByZW1vdmluZyB0aGUgYXR0cmlidXRlIGFsdG9nZXRoZXIgaXNuJ3QgcG9zc2libGUgZWl0aGVyXG5cdFx0XHQvLyBmb3IgdGhlIDxvcHRpb24gdmFsdWU9e3VuZGVmaW5lZH0+IGNhc2UsIHNvIHdlJ3JlIG5vdCBsb3NpbmcgYW55IGZ1bmN0aW9uYWxpdHkgaGVyZS5cblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGVsZW1lbnQudmFsdWUgPSBlbGVtZW50Ll9fdmFsdWUgPSAnJztcblx0XHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFyIHByZXZfdmFsdWUgPSBjdXJyZW50W2tleV07XG5cdFx0aWYgKHZhbHVlID09PSBwcmV2X3ZhbHVlKSBjb250aW51ZTtcblxuXHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXG5cdFx0dmFyIHByZWZpeCA9IGtleVswXSArIGtleVsxXTsgLy8gdGhpcyBpcyBmYXN0ZXIgdGhhbiBrZXkuc2xpY2UoMCwgMilcblx0XHRpZiAocHJlZml4ID09PSAnJCQnKSBjb250aW51ZTtcblxuXHRcdGlmIChwcmVmaXggPT09ICdvbicpIHtcblx0XHRcdC8qKiBAdHlwZSB7eyBjYXB0dXJlPzogdHJ1ZSB9fSAqL1xuXHRcdFx0Y29uc3Qgb3B0cyA9IHt9O1xuXHRcdFx0Y29uc3QgZXZlbnRfaGFuZGxlX2tleSA9ICckJCcgKyBrZXk7XG5cdFx0XHRsZXQgZXZlbnRfbmFtZSA9IGtleS5zbGljZSgyKTtcblx0XHRcdHZhciBkZWxlZ2F0ZWQgPSBpc19kZWxlZ2F0ZWQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChpc19jYXB0dXJlX2V2ZW50KGV2ZW50X25hbWUpKSB7XG5cdFx0XHRcdGV2ZW50X25hbWUgPSBldmVudF9uYW1lLnNsaWNlKDAsIC03KTtcblx0XHRcdFx0b3B0cy5jYXB0dXJlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZWxlZ2F0ZWQgJiYgcHJldl92YWx1ZSkge1xuXHRcdFx0XHQvLyBMaXN0ZW5pbmcgdG8gc2FtZSBldmVudCBidXQgZGlmZmVyZW50IGhhbmRsZXIgLT4gb3VyIGhhbmRsZSBmdW5jdGlvbiBiZWxvdyB0YWtlcyBjYXJlIG9mIHRoaXNcblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSB0byByZW1vdmUgYW5kIGFkZCBsaXN0ZW5lcnMgaW4gdGhpcyBjYXNlLCBpdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgZXZlbnQgaXMgXCJzd2FsbG93ZWRcIlxuXHRcdFx0XHQvLyAodGhlIGJyb3dzZXIgc2VlbXMgdG8gbm90IGtub3cgeWV0IHRoYXQgYSBuZXcgb25lIGV4aXN0cyBub3cpIGFuZCBkb2Vzbid0IHJlYWNoIHRoZSBoYW5kbGVyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzExOTAzXG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgY3VycmVudFtldmVudF9oYW5kbGVfa2V5XSwgb3B0cyk7XG5cdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIWRlbGVnYXRlZCkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIEB0aGlzIHthbnl9XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKGV2dCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFtrZXldLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGVsZW1lbnQsIGhhbmRsZSwgb3B0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVsZWdhdGUoW2V2ZW50X25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W2BfXyR7ZXZlbnRfbmFtZX1gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRlbGVtZW50LnN0eWxlLmNzc1RleHQgPSB2YWx1ZSArICcnO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnYXV0b2ZvY3VzJykge1xuXHRcdFx0YXV0b2ZvY3VzKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChlbGVtZW50KSwgQm9vbGVhbih2YWx1ZSkpO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScgfHwgKGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSAhPSBudWxsKSkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnRba2V5XSA9IGVsZW1lbnQuX192YWx1ZSA9IHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2VsZWN0ZWQnICYmIGlzX29wdGlvbl9lbGVtZW50KSB7XG5cdFx0XHRzZXRfc2VsZWN0ZWQoLyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudH0gKi8gKGVsZW1lbnQpLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuYW1lID0ga2V5O1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZSkge1xuXHRcdFx0XHRuYW1lID0gbm9ybWFsaXplX2F0dHJpYnV0ZShuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlzX2RlZmF1bHQgPSBuYW1lID09PSAnZGVmYXVsdFZhbHVlJyB8fCBuYW1lID09PSAnZGVmYXVsdENoZWNrZWQnO1xuXG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaXNfY3VzdG9tX2VsZW1lbnQgJiYgIWlzX2RlZmF1bHQpIHtcblx0XHRcdFx0YXR0cmlidXRlc1trZXldID0gbnVsbDtcblxuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnY2hlY2tlZCcpIHtcblx0XHRcdFx0XHQvLyByZW1vdmluZyB2YWx1ZS9jaGVja2VkIGFsc28gcmVtb3ZlcyBkZWZhdWx0VmFsdWUvZGVmYXVsdENoZWNrZWQg4oCUIHByZXNlcnZlXG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqLyAoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHRcdFx0bGV0IHByZXYgPSBpbnB1dC5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0VmFsdWUgPSBwcmV2O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsZXQgcHJldiA9IGlucHV0LmRlZmF1bHRDaGVja2VkO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBwcmV2O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRpc19kZWZhdWx0IHx8XG5cdFx0XHRcdChzZXR0ZXJzLmluY2x1ZGVzKG5hbWUpICYmIChpc19jdXN0b21fZWxlbWVudCB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSlcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGVsZW1lbnRbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmIChoeWRyYXRpbmcgJiYgKG5hbWUgPT09ICdzcmMnIHx8IG5hbWUgPT09ICdocmVmJyB8fCBuYW1lID09PSAnc3Jjc2V0JykpIHtcblx0XHRcdFx0XHRpZiAoIXNraXBfd2FybmluZykgY2hlY2tfc3JjX2luX2Rldl9oeWRyYXRpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUgPz8gJycpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldF9hdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChrZXkgPT09ICdzdHlsZScgJiYgJ19fc3R5bGVzJyBpbiBlbGVtZW50KSB7XG5cdFx0XHQvLyByZXNldCBzdHlsZXMgdG8gZm9yY2Ugc3R5bGU6IGRpcmVjdGl2ZSB0byB1cGRhdGVcblx0XHRcdGVsZW1lbnQuX19zdHlsZXMgPSB7fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudDtcbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBzdHJpbmdbXT59ICovXG52YXIgc2V0dGVyc19jYWNoZSA9IG5ldyBNYXAoKTtcblxuLyoqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAqL1xuZnVuY3Rpb24gZ2V0X3NldHRlcnMoZWxlbWVudCkge1xuXHR2YXIgc2V0dGVycyA9IHNldHRlcnNfY2FjaGUuZ2V0KGVsZW1lbnQubm9kZU5hbWUpO1xuXHRpZiAoc2V0dGVycykgcmV0dXJuIHNldHRlcnM7XG5cdHNldHRlcnNfY2FjaGUuc2V0KGVsZW1lbnQubm9kZU5hbWUsIChzZXR0ZXJzID0gW10pKTtcblxuXHR2YXIgZGVzY3JpcHRvcnM7XG5cdHZhciBwcm90byA9IGVsZW1lbnQ7IC8vIEluIHRoZSBjYXNlIG9mIGN1c3RvbSBlbGVtZW50cyB0aGVyZSBtaWdodCBiZSBzZXR0ZXJzIG9uIHRoZSBpbnN0YW5jZVxuXHR2YXIgZWxlbWVudF9wcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG5cdC8vIFN0b3AgYXQgRWxlbWVudCwgZnJvbSB0aGVyZSBvbiB0aGVyZSdzIG9ubHkgdW5uZWNlc3Nhcnkgc2V0dGVycyB3ZSdyZSBub3QgaW50ZXJlc3RlZCBpblxuXHQvLyBEbyBub3QgdXNlIGNvbnRydWN0b3IubmFtZSBoZXJlIGFzIHRoYXQncyB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlciBlbnZpcm9ubWVudHNcblx0d2hpbGUgKGVsZW1lbnRfcHJvdG8gIT09IHByb3RvKSB7XG5cdFx0ZGVzY3JpcHRvcnMgPSBnZXRfZGVzY3JpcHRvcnMocHJvdG8pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGRlc2NyaXB0b3JzKSB7XG5cdFx0XHRpZiAoZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcblx0XHRcdFx0c2V0dGVycy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHByb3RvKTtcblx0fVxuXG5cdHJldHVybiBzZXR0ZXJzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tfc3JjX2luX2Rldl9oeWRyYXRpb24oZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRpZiAoIURFVikgcmV0dXJuO1xuXHRpZiAoYXR0cmlidXRlID09PSAnc3Jjc2V0JyAmJiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnQsIHZhbHVlKSkgcmV0dXJuO1xuXHRpZiAoc3JjX3VybF9lcXVhbChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpID8/ICcnLCB2YWx1ZSkpIHJldHVybjtcblxuXHR3Lmh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZChcblx0XHRhdHRyaWJ1dGUsXG5cdFx0ZWxlbWVudC5vdXRlckhUTUwucmVwbGFjZShlbGVtZW50LmlubmVySFRNTCwgZWxlbWVudC5pbm5lckhUTUwgJiYgJy4uLicpLFxuXHRcdFN0cmluZyh2YWx1ZSlcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcblx0aWYgKGVsZW1lbnRfc3JjID09PSB1cmwpIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gbmV3IFVSTChlbGVtZW50X3NyYywgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZiA9PT0gbmV3IFVSTCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWY7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0ICovXG5mdW5jdGlvbiBzcGxpdF9zcmNzZXQoc3Jjc2V0KSB7XG5cdHJldHVybiBzcmNzZXQuc3BsaXQoJywnKS5tYXAoKHNyYykgPT4gc3JjLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihCb29sZWFuKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU291cmNlRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzcmNzZXRfdXJsX2VxdWFsKGVsZW1lbnQsIHNyY3NldCkge1xuXHR2YXIgZWxlbWVudF91cmxzID0gc3BsaXRfc3Jjc2V0KGVsZW1lbnQuc3Jjc2V0KTtcblx0dmFyIHVybHMgPSBzcGxpdF9zcmNzZXQoc3Jjc2V0KTtcblxuXHRyZXR1cm4gKFxuXHRcdHVybHMubGVuZ3RoID09PSBlbGVtZW50X3VybHMubGVuZ3RoICYmXG5cdFx0dXJscy5ldmVyeShcblx0XHRcdChbdXJsLCB3aWR0aF0sIGkpID0+XG5cdFx0XHRcdHdpZHRoID09PSBlbGVtZW50X3VybHNbaV1bMV0gJiZcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGJvdGggd2F5cyBiZWNhdXNlIFZpdGUgd2lsbCBjcmVhdGUgYW4gYSBmdWxsIFVSTCB3aXRoXG5cdFx0XHRcdC8vIGBuZXcgVVJMKGFzc2V0LCBpbXBvcnQubWV0YS51cmwpLmhyZWZgIGZvciB0aGUgY2xpZW50IHdoZW4gYGJhc2U6ICcuLydgLCBhbmQgdGhlXG5cdFx0XHRcdC8vIHJlbGF0aXZlIFVSTHMgaW5zaWRlIHNyY3NldCBhcmUgbm90IGF1dG9tYXRpY2FsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgVVJMcyBieVxuXHRcdFx0XHQvLyBicm93c2VycyAoaW4gY29udHJhc3QgdG8gaW1nLnNyYykuIFRoaXMgbWVhbnMgYm90aCBTU1IgYW5kIERPTSBjb2RlIGNvdWxkXG5cdFx0XHRcdC8vIGNvbnRhaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgVVJMcy5cblx0XHRcdFx0KHNyY191cmxfZXF1YWwoZWxlbWVudF91cmxzW2ldWzBdLCB1cmwpIHx8IHNyY191cmxfZXF1YWwodXJsLCBlbGVtZW50X3VybHNbaV1bMF0pKVxuXHRcdClcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX2xhenlfaW1nKGVsZW1lbnQpIHtcblx0Ly8gSWYgd2UncmUgdXNpbmcgYW4gaW1hZ2UgdGhhdCBoYXMgYSBsYXp5IGxvYWRpbmcgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIGFwcGx5XG5cdC8vIHRoZSBsb2FkaW5nIGFuZCBzcmMgYWZ0ZXIgdGhlIGltZyBlbGVtZW50IGhhcyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudC5cblx0Ly8gT3RoZXJ3aXNlIHRoZSBsYXp5IGJlaGF2aW91ciB3aWxsIG5vdCB3b3JrIGR1ZSB0byBvdXIgY2xvbmVOb2RlIGhldXJpc3RpYyBmb3Jcblx0Ly8gdGVtcGxhdGVzLlxuXHRpZiAoIWh5ZHJhdGluZyAmJiBlbGVtZW50LmxvYWRpbmcgPT09ICdsYXp5Jykge1xuXHRcdHZhciBzcmMgPSBlbGVtZW50LnNyYztcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudFtMT0FESU5HX0FUVFJfU1lNQk9MXSA9IG51bGw7XG5cdFx0ZWxlbWVudC5sb2FkaW5nID0gJ2VhZ2VyJztcblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGlmIChlbGVtZW50W0xPQURJTkdfQVRUUl9TWU1CT0xdICE9PSAnZWFnZXInKSB7XG5cdFx0XHRcdGVsZW1lbnQubG9hZGluZyA9ICdsYXp5Jztcblx0XHRcdH1cblx0XHRcdGVsZW1lbnQuc3JjID0gc3JjO1xuXHRcdH0pO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT09ICcnKSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWF0aE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X21hdGhtbF9jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT09ICcnKSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5jbGFzc05hbWUgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uY2xhc3NOYW1lICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdC8vIFJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgd2hlbiB0aGUgdmFsdWUgaXMgb25seSBhbiBlbXB0eSBzdHJpbmcgY2F1c2VzXG5cdFx0Ly8gcGVmb3JtYW5jZSBpc3N1ZXMgdnMgc2ltcGx5IG1ha2luZyB0aGUgY2xhc3NOYW1lIGFuIGVtcHR5IHN0cmluZy4gU29cblx0XHQvLyB3ZSBzaG91bGQgb25seSByZW1vdmUgdGhlIGNsYXNzIGlmIHRoZSB0aGUgdmFsdWUgaXMgbnVsbGlzaC5cblx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaGFzaCkge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLmNsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0XHR9XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBWfVxuICovXG5mdW5jdGlvbiB0b19jbGFzcyh2YWx1ZSwgaGFzaCkge1xuXHRyZXR1cm4gKHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKSArIChoYXNoID8gJyAnICsgaGFzaCA6ICcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzX25hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGRvbSwgY2xhc3NfbmFtZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlKSB7XG5cdFx0aWYgKGRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NfbmFtZSkpIHJldHVybjtcblx0XHRkb20uY2xhc3NMaXN0LmFkZChjbGFzc19uYW1lKTtcblx0fSBlbHNlIHtcblx0XHRpZiAoIWRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NfbmFtZSkpIHJldHVybjtcblx0XHRkb20uY2xhc3NMaXN0LnJlbW92ZShjbGFzc19uYW1lKTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBSYWYgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbmltcG9ydCB7IEJST1dTRVIgfSBmcm9tICdlc20tZW52JztcblxuY29uc3Qgbm93ID0gQlJPV1NFUiA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogKCkgPT4gRGF0ZS5ub3coKTtcblxuLyoqIEB0eXBlIHtSYWZ9ICovXG5leHBvcnQgY29uc3QgcmFmID0ge1xuXHQvLyBkb24ndCBhY2Nlc3MgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGVhZ2VybHkgb3V0c2lkZSBtZXRob2Rcblx0Ly8gdGhpcyBhbGxvd3MgYmFzaWMgdGVzdGluZyBvZiB1c2VyIGNvZGUgd2l0aG91dCBKU0RPTVxuXHQvLyBidW5kZXIgd2lsbCBldmFsIGFuZCByZW1vdmUgdGVybmFyeSB3aGVuIHRoZSB1c2VyJ3MgYXBwIGlzIGJ1aWx0XG5cdHRpY2s6IC8qKiBAcGFyYW0ge2FueX0gXyAqLyAoXykgPT4gKEJST1dTRVIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBub29wKShfKSxcblx0bm93OiAoKSA9PiBub3coKSxcblx0dGFza3M6IG5ldyBTZXQoKVxufTtcbiIsIi8qKiBAaW1wb3J0IHsgVGFza0NhbGxiYWNrLCBUYXNrLCBUYXNrRW50cnkgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgcmFmIH0gZnJvbSAnLi90aW1pbmcuanMnO1xuXG4vLyBUT0RPIG1vdmUgdGhpcyBpbnRvIHRpbWluZy5qcyB3aGVyZSBpdCBwcm9iYWJseSBiZWxvbmdzXG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJ1bl90YXNrcygpIHtcblx0Ly8gdXNlIGByYWYubm93KClgIGluc3RlYWQgb2YgdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrIGFyZ3VtZW50LCBiZWNhdXNlXG5cdC8vIG90aGVyd2lzZSB0aGluZ3MgY2FuIGdldCB3b25reSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvMTQ1NDFcblx0Y29uc3Qgbm93ID0gcmFmLm5vdygpO1xuXG5cdHJhZi50YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB7XG5cdFx0aWYgKCF0YXNrLmMobm93KSkge1xuXHRcdFx0cmFmLnRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHRcdHRhc2suZigpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKHJhZi50YXNrcy5zaXplICE9PSAwKSB7XG5cdFx0cmFmLnRpY2socnVuX3Rhc2tzKTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKiBAcGFyYW0ge1Rhc2tDYWxsYmFja30gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtUYXNrfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuXHQvKiogQHR5cGUge1Rhc2tFbnRyeX0gKi9cblx0bGV0IHRhc2s7XG5cblx0aWYgKHJhZi50YXNrcy5zaXplID09PSAwKSB7XG5cdFx0cmFmLnRpY2socnVuX3Rhc2tzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZTogbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHtcblx0XHRcdHJhZi50YXNrcy5hZGQoKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pKTtcblx0XHR9KSxcblx0XHRhYm9ydCgpIHtcblx0XHRcdHJhZi50YXNrcy5kZWxldGUodGFzayk7XG5cdFx0fVxuXHR9O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBBbmltYXRlRm4sIEFuaW1hdGlvbiwgQW5pbWF0aW9uQ29uZmlnLCBFYWNoSXRlbSwgRWZmZWN0LCBUcmFuc2l0aW9uRm4sIFRyYW5zaXRpb25NYW5hZ2VyIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IG5vb3AsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGVmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHR1bnRyYWNrXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgbG9vcCB9IGZyb20gJy4uLy4uL2xvb3AuanMnO1xuaW1wb3J0IHsgc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfZWFjaF9pdGVtIH0gZnJvbSAnLi4vYmxvY2tzL2VhY2guanMnO1xuaW1wb3J0IHsgVFJBTlNJVElPTl9HTE9CQUwsIFRSQU5TSVRJT05fSU4sIFRSQU5TSVRJT05fT1VUIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEJMT0NLX0VGRkVDVCwgRUZGRUNUX1JBTiwgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7J2ludHJvc3RhcnQnIHwgJ2ludHJvZW5kJyB8ICdvdXRyb3N0YXJ0JyB8ICdvdXRyb2VuZCd9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaF9ldmVudChlbGVtZW50LCB0eXBlKSB7XG5cdGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJvcGVydHkgdG8gdGhlIGNhbWVsLWNhc2UgZm9ybWF0IGV4cGVjdGVkIGJ5IEVsZW1lbnQuYW5pbWF0ZSgpLCBLZXlmcmFtZUVmZmVjdCgpLCBhbmQgS2V5ZnJhbWVFZmZlY3Quc2V0S2V5ZnJhbWVzKCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNzc19wcm9wZXJ0eV90b19jYW1lbGNhc2Uoc3R5bGUpIHtcblx0Ly8gaW4gY29tcGxpYW5jZSB3aXRoIHNwZWNcblx0aWYgKHN0eWxlID09PSAnZmxvYXQnKSByZXR1cm4gJ2Nzc0Zsb2F0Jztcblx0aWYgKHN0eWxlID09PSAnb2Zmc2V0JykgcmV0dXJuICdjc3NPZmZzZXQnO1xuXG5cdC8vIGRvIG5vdCByZW5hbWUgY3VzdG9tIEBwcm9wZXJ0aWVzXG5cdGlmIChzdHlsZS5zdGFydHNXaXRoKCctLScpKSByZXR1cm4gc3R5bGU7XG5cblx0Y29uc3QgcGFydHMgPSBzdHlsZS5zcGxpdCgnLScpO1xuXHRpZiAocGFydHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydHNbMF07XG5cdHJldHVybiAoXG5cdFx0cGFydHNbMF0gK1xuXHRcdHBhcnRzXG5cdFx0XHQuc2xpY2UoMSlcblx0XHRcdC5tYXAoLyoqIEBwYXJhbSB7YW55fSB3b3JkICovICh3b3JkKSA9PiB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuXHRcdFx0LmpvaW4oJycpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1xuICogQHJldHVybnMge0tleWZyYW1lfVxuICovXG5mdW5jdGlvbiBjc3NfdG9fa2V5ZnJhbWUoY3NzKSB7XG5cdC8qKiBAdHlwZSB7S2V5ZnJhbWV9ICovXG5cdGNvbnN0IGtleWZyYW1lID0ge307XG5cdGNvbnN0IHBhcnRzID0gY3NzLnNwbGl0KCc7Jyk7XG5cdGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuXHRcdGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdID0gcGFydC5zcGxpdCgnOicpO1xuXHRcdGlmICghcHJvcGVydHkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG5cblx0XHRjb25zdCBmb3JtYXR0ZWRfcHJvcGVydHkgPSBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHByb3BlcnR5LnRyaW0oKSk7XG5cdFx0a2V5ZnJhbWVbZm9ybWF0dGVkX3Byb3BlcnR5XSA9IHZhbHVlLnRyaW0oKTtcblx0fVxuXHRyZXR1cm4ga2V5ZnJhbWU7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdCAqL1xuY29uc3QgbGluZWFyID0gKHQpID0+IHQ7XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBrZXllZCBgeyNlYWNoIC4uLn1gIGJsb2NrcyAoYXMgYCQuYW5pbWF0aW9uKC4uLilgKS4gVGhpcyBjcmVhdGVzIGFuIGFuaW1hdGlvbiBtYW5hZ2VyXG4gKiBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIGJsb2NrLCBzbyB0aGF0IG1vdmVzIGNhbiBiZSBhbmltYXRlZCBmb2xsb3dpbmcgcmVjb25jaWxpYXRpb24uXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IEFuaW1hdGVGbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuaW1hdGlvbihlbGVtZW50LCBnZXRfZm4sIGdldF9wYXJhbXMpIHtcblx0dmFyIGl0ZW0gPSAvKiogQHR5cGUge0VhY2hJdGVtfSAqLyAoY3VycmVudF9lYWNoX2l0ZW0pO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIGZyb207XG5cblx0LyoqIEB0eXBlIHtET01SZWN0fSAqL1xuXHR2YXIgdG87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBhbmltYXRpb247XG5cblx0LyoqIEB0eXBlIHtudWxsIHwgeyBwb3NpdGlvbjogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgdHJhbnNmb3JtOiBzdHJpbmcgfX0gKi9cblx0dmFyIG9yaWdpbmFsX3N0eWxlcyA9IG51bGw7XG5cblx0aXRlbS5hID8/PSB7XG5cdFx0ZWxlbWVudCxcblx0XHRtZWFzdXJlKCkge1xuXHRcdFx0ZnJvbSA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9LFxuXHRcdGFwcGx5KCkge1xuXHRcdFx0YW5pbWF0aW9uPy5hYm9ydCgpO1xuXG5cdFx0XHR0byA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRmcm9tLmxlZnQgIT09IHRvLmxlZnQgfHxcblx0XHRcdFx0ZnJvbS5yaWdodCAhPT0gdG8ucmlnaHQgfHxcblx0XHRcdFx0ZnJvbS50b3AgIT09IHRvLnRvcCB8fFxuXHRcdFx0XHRmcm9tLmJvdHRvbSAhPT0gdG8uYm90dG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IGdldF9mbigpKHRoaXMuZWxlbWVudCwgeyBmcm9tLCB0byB9LCBnZXRfcGFyYW1zPy4oKSk7XG5cblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSh0aGlzLmVsZW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCwgMSwgKCkgPT4ge1xuXHRcdFx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblx0XHRcdFx0XHRhbmltYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zml4KCkge1xuXHRcdFx0Ly8gSWYgYW4gYW5pbWF0aW9uIGlzIGFscmVhZHkgcnVubmluZywgdHJhbnNmb3JtaW5nIHRoZSBlbGVtZW50IGlzIGxpa2VseSB0byBmYWlsLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgc3R5bGVzIGFwcGxpZWQgYnkgdGhlIGFuaW1hdGlvbiB0YWtlIHByZWNlZGVuY2UuIEluIHRoZSBjYXNlIG9mIGNyb3NzZmFkZSxcblx0XHRcdC8vIHRoYXQgbWVhbnMgdGhlIGB0cmFuc2xhdGUoLi4uKWAgb2YgdGhlIGNyb3NzZmFkZSB0cmFuc2l0aW9uIG92ZXJydWxlcyB0aGUgYHRyYW5zbGF0ZSguLi4pYFxuXHRcdFx0Ly8gd2Ugd291bGQgYXBwbHkgYmVsb3csIGxlYWRpbmcgdG8gdGhlIGVsZW1lbnQganVtcGluZyBzb21ld2hlcmUgdG8gdGhlIHRvcCBsZWZ0LlxuXHRcdFx0aWYgKGVsZW1lbnQuZ2V0QW5pbWF0aW9ucygpLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0byBkZXN0cnVjdHVyZSB0aGVzZSB0byBnZXQgZml4ZWQgdmFsdWVzIC0gdGhlIG9iamVjdCBpdHNlbGYgaGFzIGdldHRlcnMsXG5cdFx0XHQvLyBhbmQgY2hhbmdpbmcgdGhlIHN0eWxlIHRvICdhYnNvbHV0ZScgY2FuIGZvciBleGFtcGxlIGluZmx1ZW5jZSB0aGUgd2lkdGguXG5cdFx0XHR2YXIgeyBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGU7XG5cblx0XHRcdFx0b3JpZ2luYWxfc3R5bGVzID0ge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBzdHlsZS5wb3NpdGlvbixcblx0XHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG5cdFx0XHRcdFx0dHJhbnNmb3JtOiBzdHlsZS50cmFuc2Zvcm1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0dmFyIHRvID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8IGZyb20udG9wICE9PSB0by50b3ApIHtcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2Zyb20ubGVmdCAtIHRvLmxlZnR9cHgsICR7ZnJvbS50b3AgLSB0by50b3B9cHgpYDtcblx0XHRcdFx0XHRzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPyBgJHtzdHlsZS50cmFuc2Zvcm19ICR7dHJhbnNmb3JtfWAgOiB0cmFuc2Zvcm07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuZml4KCkge1xuXHRcdFx0aWYgKG9yaWdpbmFsX3N0eWxlcykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdHN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxfc3R5bGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IG9yaWdpbmFsX3N0eWxlcy53aWR0aDtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxfc3R5bGVzLmhlaWdodDtcblx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gb3JpZ2luYWxfc3R5bGVzLnRyYW5zZm9ybTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gaW4gdGhlIGNhc2Ugb2YgYSBgPHN2ZWx0ZTplbGVtZW50PmAsIGl0J3MgcG9zc2libGUgZm9yIGAkLmFuaW1hdGlvbiguLi4pYCB0byBiZSBjYWxsZWRcblx0Ly8gd2hlbiBhbiBhbmltYXRpb24gbWFuYWdlciBhbHJlYWR5IGV4aXN0cywgaWYgdGhlIHRhZyBjaGFuZ2VzLiBpbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG9cblx0Ly8gc3dhcCBvdXQgdGhlIGVsZW1lbnQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgbWFuYWdlciwgaW4gY2FzZSBpdCBoYXBwZW5lZCBhdCB0aGUgc2FtZVxuXHQvLyBtb21lbnQgYXMgYSByZWNvbmNpbGlhdGlvblxuXHRpdGVtLmEuZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBibG9jayBlZmZlY3RzIGFzIGAkLnRyYW5zaXRpb24oLi4uKWAuIFRoaXMgY3JlYXRlcyBhIHRyYW5zaXRpb24gbWFuYWdlciBhbmRcbiAqIGF0dGFjaGVzIGl0IHRvIHRoZSBjdXJyZW50IGVmZmVjdCDigJQgbGF0ZXIsIGluc2lkZSBgcGF1c2VfZWZmZWN0YCBhbmQgYHJlc3VtZV9lZmZlY3RgLCB3ZVxuICogdXNlIHRoaXMgdG8gY3JlYXRlIGBpbnRyb2AgYW5kIGBvdXRyb2AgdHJhbnNpdGlvbnMuXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IFRyYW5zaXRpb25GbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbihmbGFncywgZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpc19pbnRybyA9IChmbGFncyAmIFRSQU5TSVRJT05fSU4pICE9PSAwO1xuXHR2YXIgaXNfb3V0cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX09VVCkgIT09IDA7XG5cdHZhciBpc19ib3RoID0gaXNfaW50cm8gJiYgaXNfb3V0cm87XG5cdHZhciBpc19nbG9iYWwgPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0dMT0JBTCkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHsnaW4nIHwgJ291dCcgfCAnYm90aCd9ICovXG5cdHZhciBkaXJlY3Rpb24gPSBpc19ib3RoID8gJ2JvdGgnIDogaXNfaW50cm8gPyAnaW4nIDogJ291dCc7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGN1cnJlbnRfb3B0aW9ucztcblxuXHR2YXIgaW5lcnQgPSBlbGVtZW50LmluZXJ0O1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaW50cm87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBvdXRybztcblxuXHRmdW5jdGlvbiBnZXRfb3B0aW9ucygpIHtcblx0XHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0XHR0cnkge1xuXHRcdFx0Ly8gSWYgYSB0cmFuc2l0aW9uIGlzIHN0aWxsIG9uZ29pbmcsIHdlIHVzZSB0aGUgZXhpc3Rpbmcgb3B0aW9ucyByYXRoZXIgdGhhbiBnZW5lcmF0aW5nXG5cdFx0XHQvLyBuZXcgb25lcy4gVGhpcyBlbnN1cmVzIHRoYXQgcmV2ZXJzaWJsZSB0cmFuc2l0aW9ucyByZXZlcnNlIHNtb290aGx5LCByYXRoZXIgdGhhblxuXHRcdFx0Ly8ganVtcGluZyB0byBhIG5ldyBzcG90IGJlY2F1c2UgKGZvciBleGFtcGxlKSBhIGRpZmZlcmVudCBgZHVyYXRpb25gIHdhcyB1c2VkXG5cdFx0XHRyZXR1cm4gKGN1cnJlbnRfb3B0aW9ucyA/Pz0gZ2V0X2ZuKCkoZWxlbWVudCwgZ2V0X3BhcmFtcz8uKCkgPz8gLyoqIEB0eXBlIHtQfSAqLyAoe30pLCB7XG5cdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0fSkpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcn0gKi9cblx0dmFyIHRyYW5zaXRpb24gPSB7XG5cdFx0aXNfZ2xvYmFsLFxuXHRcdGluKCkge1xuXHRcdFx0ZWxlbWVudC5pbmVydCA9IGluZXJ0O1xuXG5cdFx0XHRpZiAoIWlzX2ludHJvKSB7XG5cdFx0XHRcdG91dHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRvdXRybz8ucmVzZXQ/LigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNfb3V0cm8pIHtcblx0XHRcdFx0Ly8gaWYgd2UgaW50cm8gdGhlbiBvdXRybyB0aGVuIGludHJvIGFnYWluLCB3ZSB3YW50IHRvIGFib3J0IHRoZSBmaXJzdCBpbnRybyxcblx0XHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiaWRpcmVjdGlvbmFsIHRyYW5zaXRpb25cblx0XHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdpbnRyb3N0YXJ0Jyk7XG5cblx0XHRcdGludHJvID0gYW5pbWF0ZShlbGVtZW50LCBnZXRfb3B0aW9ucygpLCBvdXRybywgMSwgKCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnaW50cm9lbmQnKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgd2UgY2FuY2VsIHRoZSBhbmltYXRpb24gdG8gcHJldmVudCBsZWFraW5nXG5cdFx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRpbnRybyA9IGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b3V0KGZuKSB7XG5cdFx0XHRpZiAoIWlzX291dHJvKSB7XG5cdFx0XHRcdGZuPy4oKTtcblx0XHRcdFx0Y3VycmVudF9vcHRpb25zID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQuaW5lcnQgPSB0cnVlO1xuXG5cdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnb3V0cm9zdGFydCcpO1xuXG5cdFx0XHRvdXRybyA9IGFuaW1hdGUoZWxlbWVudCwgZ2V0X29wdGlvbnMoKSwgaW50cm8sIDAsICgpID0+IHtcblx0XHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ291dHJvZW5kJyk7XG5cdFx0XHRcdGZuPy4oKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0c3RvcDogKCkgPT4ge1xuXHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHRvdXRybz8uYWJvcnQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGUgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdChlLnRyYW5zaXRpb25zID8/PSBbXSkucHVzaCh0cmFuc2l0aW9uKTtcblxuXHQvLyBpZiB0aGlzIGlzIGEgbG9jYWwgdHJhbnNpdGlvbiwgd2Ugb25seSB3YW50IHRvIHJ1biBpdCBpZiB0aGUgcGFyZW50IChicmFuY2gpIGVmZmVjdCdzXG5cdC8vIHBhcmVudCAoYmxvY2spIGVmZmVjdCBpcyB3aGVyZSB0aGUgc3RhdGUgY2hhbmdlIGhhcHBlbmVkLiB3ZSBjYW4gZGV0ZXJtaW5lIHRoYXQgYnlcblx0Ly8gbG9va2luZyBhdCB3aGV0aGVyIHRoZSBibG9jayBlZmZlY3QgaXMgY3VycmVudGx5IGluaXRpYWxpemluZ1xuXHRpZiAoaXNfaW50cm8gJiYgc2hvdWxkX2ludHJvKSB7XG5cdFx0dmFyIHJ1biA9IGlzX2dsb2JhbDtcblxuXHRcdGlmICghcnVuKSB7XG5cdFx0XHR2YXIgYmxvY2sgPSAvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovIChlLnBhcmVudCk7XG5cblx0XHRcdC8vIHNraXAgb3ZlciB0cmFuc3BhcmVudCBibG9ja3MgKGUuZy4gc25pcHBldHMsIGVsc2UtaWYgYmxvY2tzKVxuXHRcdFx0d2hpbGUgKGJsb2NrICYmIChibG9jay5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCkge1xuXHRcdFx0XHR3aGlsZSAoKGJsb2NrID0gYmxvY2sucGFyZW50KSkge1xuXHRcdFx0XHRcdGlmICgoYmxvY2suZiAmIEJMT0NLX0VGRkVDVCkgIT09IDApIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJ1biA9ICFibG9jayB8fCAoYmxvY2suZiAmIEVGRkVDVF9SQU4pICE9PSAwO1xuXHRcdH1cblxuXHRcdGlmIChydW4pIHtcblx0XHRcdGVmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdHVudHJhY2soKCkgPT4gdHJhbnNpdGlvbi5pbigpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEFuaW1hdGVzIGFuIGVsZW1lbnQsIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0FuaW1hdGlvbkNvbmZpZyB8ICgob3B0czogeyBkaXJlY3Rpb246ICdpbicgfCAnb3V0JyB9KSA9PiBBbmltYXRpb25Db25maWcpfSBvcHRpb25zXG4gKiBAcGFyYW0ge0FuaW1hdGlvbiB8IHVuZGVmaW5lZH0gY291bnRlcnBhcnQgVGhlIGNvcnJlc3BvbmRpbmcgaW50cm8vb3V0cm8gdG8gdGhpcyBvdXRyby9pbnRyb1xuICogQHBhcmFtIHtudW1iZXJ9IHQyIFRoZSB0YXJnZXQgYHRgIHZhbHVlIOKAlCBgMWAgZm9yIGludHJvLCBgMGAgZm9yIG91dHJvXG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gb25fZmluaXNoIENhbGxlZCBhZnRlciBzdWNjZXNzZnVsbHkgY29tcGxldGluZyB0aGUgYW5pbWF0aW9uXG4gKiBAcmV0dXJucyB7QW5pbWF0aW9ufVxuICovXG5mdW5jdGlvbiBhbmltYXRlKGVsZW1lbnQsIG9wdGlvbnMsIGNvdW50ZXJwYXJ0LCB0Miwgb25fZmluaXNoKSB7XG5cdHZhciBpc19pbnRybyA9IHQyID09PSAxO1xuXG5cdGlmIChpc19mdW5jdGlvbihvcHRpb25zKSkge1xuXHRcdC8vIEluIHRoZSBjYXNlIG9mIGEgZGVmZXJyZWQgdHJhbnNpdGlvbiAoc3VjaCBhcyBgY3Jvc3NmYWRlYCksIGBvcHRpb25gIHdpbGwgYmVcblx0XHQvLyBhIGZ1bmN0aW9uIHJhdGhlciB0aGFuIGFuIGBBbmltYXRpb25Db25maWdgLiBXZSBuZWVkIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuXHRcdC8vIG9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLi4uXG5cdFx0LyoqIEB0eXBlIHtBbmltYXRpb259ICovXG5cdFx0dmFyIGE7XG5cdFx0dmFyIGFib3J0ZWQgPSBmYWxzZTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGFib3J0ZWQpIHJldHVybjtcblx0XHRcdHZhciBvID0gb3B0aW9ucyh7IGRpcmVjdGlvbjogaXNfaW50cm8gPyAnaW4nIDogJ291dCcgfSk7XG5cdFx0XHRhID0gYW5pbWF0ZShlbGVtZW50LCBvLCBjb3VudGVycGFydCwgdDIsIG9uX2ZpbmlzaCk7XG5cdFx0fSk7XG5cblx0XHQvLyAuLi5idXQgd2Ugd2FudCB0byBkbyBzbyB3aXRob3V0IHVzaW5nIGBhc3luY2AvYGF3YWl0YCBldmVyeXdoZXJlLCBzb1xuXHRcdC8vIHdlIHJldHVybiBhIGZhY2FkZSB0aGF0IGFsbG93cyBldmVyeXRoaW5nIHRvIHJlbWFpbiBzeW5jaHJvbm91c1xuXHRcdHJldHVybiB7XG5cdFx0XHRhYm9ydDogKCkgPT4ge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0YT8uYWJvcnQoKTtcblx0XHRcdH0sXG5cdFx0XHRkZWFjdGl2YXRlOiAoKSA9PiBhLmRlYWN0aXZhdGUoKSxcblx0XHRcdHJlc2V0OiAoKSA9PiBhLnJlc2V0KCksXG5cdFx0XHR0OiAoKSA9PiBhLnQoKVxuXHRcdH07XG5cdH1cblxuXHRjb3VudGVycGFydD8uZGVhY3RpdmF0ZSgpO1xuXG5cdGlmICghb3B0aW9ucz8uZHVyYXRpb24pIHtcblx0XHRvbl9maW5pc2goKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRhYm9ydDogbm9vcCxcblx0XHRcdGRlYWN0aXZhdGU6IG5vb3AsXG5cdFx0XHRyZXNldDogbm9vcCxcblx0XHRcdHQ6ICgpID0+IHQyXG5cdFx0fTtcblx0fVxuXG5cdGNvbnN0IHsgZGVsYXkgPSAwLCBjc3MsIHRpY2ssIGVhc2luZyA9IGxpbmVhciB9ID0gb3B0aW9ucztcblxuXHR2YXIga2V5ZnJhbWVzID0gW107XG5cblx0aWYgKGlzX2ludHJvICYmIGNvdW50ZXJwYXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAodGljaykge1xuXHRcdFx0dGljaygwLCAxKTsgLy8gVE9ETyBwdXQgaW4gbmVzdGVkIGVmZmVjdCwgdG8gYXZvaWQgaW50ZXJsZWF2ZWQgcmVhZHMvd3JpdGVzP1xuXHRcdH1cblxuXHRcdGlmIChjc3MpIHtcblx0XHRcdHZhciBzdHlsZXMgPSBjc3NfdG9fa2V5ZnJhbWUoY3NzKDAsIDEpKTtcblx0XHRcdGtleWZyYW1lcy5wdXNoKHN0eWxlcywgc3R5bGVzKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgZ2V0X3QgPSAoKSA9PiAxIC0gdDI7XG5cblx0Ly8gY3JlYXRlIGEgZHVtbXkgYW5pbWF0aW9uIHRoYXQgbGFzdHMgYXMgbG9uZyBhcyB0aGUgZGVsYXkgKGJ1dCB3aXRoIHdoYXRldmVyIGRldnRvb2xzXG5cdC8vIG11bHRpcGxpZXIgaXMgaW4gZWZmZWN0KS4gaW4gdGhlIGNvbW1vbiBjYXNlIHRoYXQgaXQgaXMgYDBgLCB3ZSBrZWVwIGl0IGFueXdheSBzbyB0aGF0XG5cdC8vIHRoZSBDU1Mga2V5ZnJhbWVzIGFyZW4ndCBjcmVhdGVkIHVudGlsIHRoZSBET00gaXMgdXBkYXRlZFxuXHR2YXIgYW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbjogZGVsYXkgfSk7XG5cblx0YW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuXHRcdC8vIGZvciBiaWRpcmVjdGlvbmFsIHRyYW5zaXRpb25zLCB3ZSBzdGFydCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLFxuXHRcdC8vIHJhdGhlciB0aGFuIGRvaW5nIGEgZnVsbCBpbnRyby9vdXRyb1xuXHRcdHZhciB0MSA9IGNvdW50ZXJwYXJ0Py50KCkgPz8gMSAtIHQyO1xuXHRcdGNvdW50ZXJwYXJ0Py5hYm9ydCgpO1xuXG5cdFx0dmFyIGRlbHRhID0gdDIgLSB0MTtcblx0XHR2YXIgZHVyYXRpb24gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKG9wdGlvbnMuZHVyYXRpb24pICogTWF0aC5hYnMoZGVsdGEpO1xuXHRcdHZhciBrZXlmcmFtZXMgPSBbXTtcblxuXHRcdGlmIChkdXJhdGlvbiA+IDApIHtcblx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0dmFyIG4gPSBNYXRoLmNlaWwoZHVyYXRpb24gLyAoMTAwMCAvIDYwKSk7IC8vIGBuYCBtdXN0IGJlIGFuIGludGVnZXIsIG9yIHdlIHJpc2sgbWlzc2luZyB0aGUgYHQyYCB2YWx1ZVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkgKz0gMSkge1xuXHRcdFx0XHRcdHZhciB0ID0gdDEgKyBkZWx0YSAqIGVhc2luZyhpIC8gbik7XG5cdFx0XHRcdFx0dmFyIHN0eWxlcyA9IGNzcyh0LCAxIC0gdCk7XG5cdFx0XHRcdFx0a2V5ZnJhbWVzLnB1c2goY3NzX3RvX2tleWZyYW1lKHN0eWxlcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdldF90ID0gKCkgPT4ge1xuXHRcdFx0XHR2YXIgdGltZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gKi8gKGFuaW1hdGlvbikuY3VycmVudFRpbWVcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXR1cm4gdDEgKyBkZWx0YSAqIGVhc2luZyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRpY2spIHtcblx0XHRcdFx0bG9vcCgoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGFuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdydW5uaW5nJykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0dmFyIHQgPSBnZXRfdCgpO1xuXHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuaW1hdGlvbiA9IGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZXMsIHsgZHVyYXRpb24sIGZpbGw6ICdmb3J3YXJkcycgfSk7XG5cblx0XHRhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG5cdFx0XHRnZXRfdCA9ICgpID0+IHQyO1xuXHRcdFx0dGljaz8uKHQyLCAxIC0gdDIpO1xuXHRcdFx0b25fZmluaXNoKCk7XG5cdFx0fTtcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdGFib3J0OiAoKSA9PiB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi5jYW5jZWwoKTtcblx0XHRcdFx0Ly8gVGhpcyBwcmV2ZW50cyBtZW1vcnkgbGVha3MgaW4gQ2hyb21pdW1cblx0XHRcdFx0YW5pbWF0aW9uLmVmZmVjdCA9IG51bGw7XG5cdFx0XHRcdC8vIFRoaXMgcHJldmVudHMgb25maW5pc2ggdG8gYmUgbGF1bmNoZWQgYWZ0ZXIgY2FuY2VsKCksXG5cdFx0XHRcdC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gc29tZSByYXJlIGNhc2VzXG5cdFx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xMzY4MVxuXHRcdFx0XHRhbmltYXRpb24ub25maW5pc2ggPSBub29wO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVhY3RpdmF0ZTogKCkgPT4ge1xuXHRcdFx0b25fZmluaXNoID0gbm9vcDtcblx0XHR9LFxuXHRcdHJlc2V0OiAoKSA9PiB7XG5cdFx0XHRpZiAodDIgPT09IDApIHtcblx0XHRcdFx0dGljaz8uKDEsIDApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dDogKCkgPT4gZ2V0X3QoKVxuXHR9O1xufVxuIiwiaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyByZW5kZXJfZWZmZWN0LCB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50IH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi8uLi8uLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi8uLi8uLi9wcm94eS5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi8uLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgaXNfcnVuZXMsIHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3ZhbHVlKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgcnVuZXMgPSBpc19ydW5lcygpO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdpbnB1dCcsIChpc19yZXNldCkgPT4ge1xuXHRcdGlmIChERVYgJiYgaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLmJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdC8qKiBAdHlwZSB7YW55fSAqL1xuXHRcdHZhciB2YWx1ZSA9IGlzX3Jlc2V0ID8gaW5wdXQuZGVmYXVsdFZhbHVlIDogaW5wdXQudmFsdWU7XG5cdFx0dmFsdWUgPSBpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSA/IHRvX251bWJlcih2YWx1ZSkgOiB2YWx1ZTtcblx0XHRzZXQodmFsdWUpO1xuXG5cdFx0Ly8gSW4gcnVuZXMgbW9kZSwgcmVzcGVjdCBhbnkgdmFsaWRhdGlvbiBpbiBhY2Nlc3NvcnMgKGRvZXNuJ3QgYXBwbHkgaW4gbGVnYWN5IG1vZGUsXG5cdFx0Ly8gYmVjYXVzZSB3ZSB1c2UgbXV0YWJsZSBzdGF0ZSB3aGljaCBlbnN1cmVzIHRoZSByZW5kZXIgZWZmZWN0IGFsd2F5cyBydW5zKVxuXHRcdGlmIChydW5lcyAmJiB2YWx1ZSAhPT0gKHZhbHVlID0gZ2V0KCkpKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydDtcblx0XHRcdHZhciBlbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG5cblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBjb2VyY2VkIG9uIGFzc2lnbm1lbnRcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWUgPz8gJyc7XG5cblx0XHRcdC8vIFJlc3RvcmUgc2VsZWN0aW9uXG5cdFx0XHRpZiAoZW5kICE9PSBudWxsKSB7XG5cdFx0XHRcdGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHQoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRWYWx1ZSAhPT0gaW5wdXQudmFsdWUpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdFZhbHVlIGlzIHNldCwgdGhlbiB2YWx1ZSA9PSBkZWZhdWx0VmFsdWVcblx0XHQvLyBUT0RPIFN2ZWx0ZSA2OiByZW1vdmUgaW5wdXQudmFsdWUgY2hlY2sgYW5kIHNldCB0byBlbXB0eSBzdHJpbmc/XG5cdFx0KHVudHJhY2soZ2V0KSA9PSBudWxsICYmIGlucHV0LnZhbHVlKVxuXHQpIHtcblx0XHRzZXQoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIoaW5wdXQudmFsdWUpIDogaW5wdXQudmFsdWUpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKERFViAmJiBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHRpZiAoaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgJiYgdmFsdWUgPT09IHRvX251bWJlcihpbnB1dC52YWx1ZSkpIHtcblx0XHRcdC8vIGhhbmRsZXMgMCB2cyAwMCBjYXNlIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvOTk1OSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoaW5wdXQudHlwZSA9PT0gJ2RhdGUnICYmICF2YWx1ZSAmJiAhaW5wdXQudmFsdWUpIHtcblx0XHRcdC8vIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSB0ZW1wb3JhcmlseSBpbnZhbGlkIGRhdGUgaXMgc2V0ICh3aGlsZSB0eXBpbmcsIGZvciBleGFtcGxlIHdpdGggYSBsZWFkaW5nIDAgZm9yIHRoZSBkYXkpXG5cdFx0XHQvLyBhbmQgcHJldmVudHMgdGhpcyBzdGF0ZSBmcm9tIGNsZWFyaW5nIHRoZSBvdGhlciBwYXJ0cyBvZiB0aGUgZGF0ZSBpbnB1dCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzc4OTcpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZG9uJ3Qgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaWYgaXQncyB0aGUgc2FtZSB0byBhbGxvd1xuXHRcdC8vIG1pbmxlbmd0aCB0byB3b3JrIHByb3Blcmx5XG5cdFx0aWYgKHZhbHVlICE9PSBpbnB1dC52YWx1ZSkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdmFsdWUgaXMgY29lcmNlZCBvbiBhc3NpZ25tZW50XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlID8/ICcnO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKiBAdHlwZSB7U2V0PEhUTUxJbnB1dEVsZW1lbnRbXT59ICovXG5jb25zdCBwZW5kaW5nID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudFtdfSBpbnB1dHNcbiAqIEBwYXJhbSB7bnVsbCB8IFtudW1iZXJdfSBncm91cF9pbmRleFxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ncm91cChpbnB1dHMsIGdyb3VwX2luZGV4LCBpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGlzX2NoZWNrYm94ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdjaGVja2JveCc7XG5cdHZhciBiaW5kaW5nX2dyb3VwID0gaW5wdXRzO1xuXG5cdC8vIG5lZWRzIHRvIGJlIGxldCBvciByZWxhdGVkIGNvZGUgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgaWYgaXQncyBhbHdheXMgZmFsc2Vcblx0bGV0IGh5ZHJhdGlvbl9taXNtYXRjaCA9IGZhbHNlO1xuXG5cdGlmIChncm91cF9pbmRleCAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGluZGV4IG9mIGdyb3VwX2luZGV4KSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRiaW5kaW5nX2dyb3VwID0gYmluZGluZ19ncm91cFtpbmRleF0gPz89IFtdO1xuXHRcdH1cblx0fVxuXG5cdGJpbmRpbmdfZ3JvdXAucHVzaChpbnB1dCk7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChcblx0XHRpbnB1dCxcblx0XHQnY2hhbmdlJyxcblx0XHQoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC5fX3ZhbHVlO1xuXG5cdFx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfYmluZGluZ19ncm91cF92YWx1ZShiaW5kaW5nX2dyb3VwLCB2YWx1ZSwgaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHR9XG5cblx0XHRcdHNldCh2YWx1ZSk7XG5cdFx0fSxcblx0XHQvLyBUT0RPIGJldHRlciBkZWZhdWx0IHZhbHVlIGhhbmRsaW5nXG5cdFx0KCkgPT4gc2V0KGlzX2NoZWNrYm94ID8gW10gOiBudWxsKVxuXHQpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLCB0aGVuIHVzZSB0aGUgdXBkYXRlIHZhbHVlXG5cdFx0Ly8gZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHRpZiAoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRDaGVja2VkICE9PSBpbnB1dC5jaGVja2VkKSB7XG5cdFx0XHRoeWRyYXRpb25fbWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBbXTtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGlucHV0LmNoZWNrZWQgPSB2YWx1ZS5pbmNsdWRlcyhpbnB1dC5fX3ZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IGlzKGlucHV0Ll9fdmFsdWUsIHZhbHVlKTtcblx0XHR9XG5cdH0pO1xuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHR2YXIgaW5kZXggPSBiaW5kaW5nX2dyb3VwLmluZGV4T2YoaW5wdXQpO1xuXG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0YmluZGluZ19ncm91cC5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKCFwZW5kaW5nLmhhcyhiaW5kaW5nX2dyb3VwKSkge1xuXHRcdHBlbmRpbmcuYWRkKGJpbmRpbmdfZ3JvdXApO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHQvLyBuZWNlc3NhcnkgdG8gbWFpbnRhaW4gYmluZGluZyBncm91cCBvcmRlciBpbiBhbGwgaW5zZXJ0aW9uIHNjZW5hcmlvc1xuXHRcdFx0YmluZGluZ19ncm91cC5zb3J0KChhLCBiKSA9PiAoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA9PT0gNCA/IC0xIDogMSkpO1xuXHRcdFx0cGVuZGluZy5kZWxldGUoYmluZGluZ19ncm91cCk7XG5cdFx0fSk7XG5cdH1cblxuXHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW9uX21pc21hdGNoKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cblx0XHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGJpbmRpbmdfZ3JvdXAsIHZhbHVlLCBpbnB1dC5jaGVja2VkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoeWRyYXRpb25faW5wdXQgPSBiaW5kaW5nX2dyb3VwLmZpbmQoKGlucHV0KSA9PiBpbnB1dC5jaGVja2VkKTtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHR2YWx1ZSA9IGh5ZHJhdGlvbl9pbnB1dD8uX192YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0c2V0KHZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfY2hlY2tlZChpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2NoYW5nZScsIChpc19yZXNldCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGlzX3Jlc2V0ID8gaW5wdXQuZGVmYXVsdENoZWNrZWQgOiBpbnB1dC5jaGVja2VkO1xuXHRcdHNldCh2YWx1ZSk7XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZSB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdENoZWNrZWQgIT09IGlucHV0LmNoZWNrZWQpIHx8XG5cdFx0Ly8gSWYgZGVmYXVsdENoZWNrZWQgaXMgc2V0LCB0aGVuIGNoZWNrZWQgPT0gZGVmYXVsdENoZWNrZWRcblx0XHR1bnRyYWNrKGdldCkgPT0gbnVsbFxuXHQpIHtcblx0XHRzZXQoaW5wdXQuY2hlY2tlZCk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblx0XHRpbnB1dC5jaGVja2VkID0gQm9vbGVhbih2YWx1ZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0FycmF5PEhUTUxJbnB1dEVsZW1lbnQ+fSBncm91cFxuICogQHBhcmFtIHtWfSBfX3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqIEByZXR1cm5zIHtWW119XG4gKi9cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG5cdHZhciB2YWx1ZSA9IG5ldyBTZXQoKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGdyb3VwW2ldLmNoZWNrZWQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWNoZWNrZWQpIHtcblx0XHR2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSB7XG5cdHZhciB0eXBlID0gaW5wdXQudHlwZTtcblx0cmV0dXJuIHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IEZpbGVMaXN0IHwgbnVsbH0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogRmlsZUxpc3QgfCBudWxsKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZmlsZXMoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdjaGFuZ2UnLCAoKSA9PiB7XG5cdFx0c2V0KGlucHV0LmZpbGVzKTtcblx0fSk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aW5wdXQuZmlsZXMgPSBnZXQoKTtcblx0fSk7XG59XG4iLCJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogTWFrZXMgYW4gYGV4cG9ydGBlZCAobm9uLXByb3ApIHZhcmlhYmxlIGF2YWlsYWJsZSBvbiB0aGUgYCQkcHJvcHNgIG9iamVjdFxuICogc28gdGhhdCBjb25zdW1lcnMgY2FuIGRvIGBiaW5kOnhgIG9uIHRoZSBjb21wb25lbnQuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcHJvcChwcm9wcywgcHJvcCwgdmFsdWUpIHtcblx0dmFyIGRlc2MgPSBnZXRfZGVzY3JpcHRvcihwcm9wcywgcHJvcCk7XG5cblx0aWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcblx0XHRwcm9wc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdHByb3BzW3Byb3BdID0gbnVsbDtcblx0XHR9KTtcblx0fVxufVxuIiwiaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcblxuLyoqXG4gKiBTZWxlY3RzIHRoZSBjb3JyZWN0IG9wdGlvbihzKSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdClcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW21vdW50aW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuXHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0cmV0dXJuIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpO1xuXHR9XG5cblx0Zm9yICh2YXIgb3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0dmFyIG9wdGlvbl92YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUob3B0aW9uKTtcblx0XHRpZiAoaXMob3B0aW9uX3ZhbHVlLCB2YWx1ZSkpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgaWYgYHZhbHVlYCBpcyBnaXZlbixcbiAqIGFuZCB0aGVuIHNldHMgdXAgYSBtdXRhdGlvbiBvYnNlcnZlciB0byBzeW5jIHRoZVxuICogY3VycmVudCBzZWxlY3Rpb24gdG8gdGhlIGRvbSB3aGVuIGl0IGNoYW5nZXMuIFN1Y2hcbiAqIGNoYW5nZXMgY291bGQgZm9yIGV4YW1wbGUgb2NjdXIgd2hlbiBvcHRpb25zIGFyZVxuICogaW5zaWRlIGFuIGAjZWFjaGAgYmxvY2suXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0geygpID0+IFZ9IFtnZXRfdmFsdWVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X3NlbGVjdChzZWxlY3QsIGdldF92YWx1ZSkge1xuXHRsZXQgbW91bnRpbmcgPSB0cnVlO1xuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChnZXRfdmFsdWUpIHtcblx0XHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCB1bnRyYWNrKGdldF92YWx1ZSksIG1vdW50aW5nKTtcblx0XHR9XG5cdFx0bW91bnRpbmcgPSBmYWxzZTtcblxuXHRcdHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhciB2YWx1ZSA9IHNlbGVjdC5fX3ZhbHVlO1xuXHRcdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKTtcblx0XHRcdC8vIERlbGliZXJhdGVseSBkb24ndCB1cGRhdGUgdGhlIHBvdGVudGlhbCBiaW5kaW5nIHZhbHVlLFxuXHRcdFx0Ly8gdGhlIG1vZGVsIHNob3VsZCBiZSBwcmVzZXJ2ZWQgdW5sZXNzIGV4cGxpY2l0bHkgY2hhbmdlZFxuXHRcdH0pO1xuXG5cdFx0b2JzZXJ2ZXIub2JzZXJ2ZShzZWxlY3QsIHtcblx0XHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCBjaGFuZ2VzXG5cdFx0XHRjaGlsZExpc3Q6IHRydWUsXG5cdFx0XHRzdWJ0cmVlOiB0cnVlLCAvLyBiZWNhdXNlIG9mIDxvcHRncm91cD5cblx0XHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCB2YWx1ZSBhdHRyaWJ1dGUgY2hhbmdlc1xuXHRcdFx0Ly8gKGRvZXNuJ3QgZ2V0IG5vdGlmaWVkIG9mIHNlbGVjdCB2YWx1ZSBjaGFuZ2VzLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGF0IHByb3BlcnR5IGlzIG5vdCByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlKVxuXHRcdFx0YXR0cmlidXRlczogdHJ1ZSxcblx0XHRcdGF0dHJpYnV0ZUZpbHRlcjogWyd2YWx1ZSddXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9zZWxlY3RfdmFsdWUoc2VsZWN0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgbW91bnRpbmcgPSB0cnVlO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoc2VsZWN0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHF1ZXJ5ID0gaXNfcmVzZXQgPyAnW3NlbGVjdGVkXScgOiAnOmNoZWNrZWQnO1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bn0gKi9cblx0XHR2YXIgdmFsdWU7XG5cblx0XHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0XHR2YWx1ZSA9IFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZ2V0X29wdGlvbl92YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9XG5cdFx0XHRcdHNlbGVjdC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSA/P1xuXHRcdFx0XHQvLyB3aWxsIGZhbGwgYmFjayB0byBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uIGlmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZFxuXHRcdFx0XHRzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uOm5vdChbZGlzYWJsZWRdKScpO1xuXHRcdFx0dmFsdWUgPSBzZWxlY3RlZF9vcHRpb24gJiYgZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSk7XG5cdH0pO1xuXG5cdC8vIE5lZWRzIHRvIGJlIGFuIGVmZmVjdCwgbm90IGEgcmVuZGVyX2VmZmVjdCwgc28gdGhhdCBpbiBjYXNlIG9mIGVhY2ggbG9vcHMgdGhlIGxvZ2ljIHJ1bnMgYWZ0ZXIgdGhlIGVhY2ggYmxvY2sgaGFzIHVwZGF0ZWRcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblx0XHRzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKTtcblxuXHRcdC8vIE1vdW50aW5nIGFuZCB2YWx1ZSB1bmRlZmluZWQgLT4gdGFrZSBzZWxlY3Rpb24gZnJvbSBkb21cblx0XHRpZiAobW91bnRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0LyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudCB8IG51bGx9ICovXG5cdFx0XHR2YXIgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdFx0XHRpZiAoc2VsZWN0ZWRfb3B0aW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdFx0XHRzZXQodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzZWxlY3QuX192YWx1ZSA9IHZhbHVlO1xuXHRcdG1vdW50aW5nID0gZmFsc2U7XG5cdH0pO1xuXG5cdC8vIGRvbid0IHBhc3MgZ2V0X3ZhbHVlLCB3ZSBhbHJlYWR5IGluaXRpYWxpemUgaXQgaW4gdGhlIGVmZmVjdCBhYm92ZVxuXHRpbml0X3NlbGVjdChzZWxlY3QpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBvcHRpb24gb2Ygc2VsZWN0Lm9wdGlvbnMpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0b3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2YoZ2V0X29wdGlvbl92YWx1ZShvcHRpb24pKTtcblx0fVxufVxuXG4vKiogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gb3B0aW9uICovXG5mdW5jdGlvbiBnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbikge1xuXHQvLyBfX3ZhbHVlIG9ubHkgZXhpc3RzIGlmIHRoZSA8b3B0aW9uPiBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGVcblx0aWYgKCdfX3ZhbHVlJyBpbiBvcHRpb24pIHtcblx0XHRyZXR1cm4gb3B0aW9uLl9fdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG9wdGlvbi52YWx1ZTtcblx0fVxufVxuIiwiaW1wb3J0IHsgU1RBVEVfU1lNQk9MIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGVmZmVjdCwgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vLi4vdGFzay5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGJvdW5kX3ZhbHVlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRfb3JfY29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNfYm91bmRfdGhpcyhib3VuZF92YWx1ZSwgZWxlbWVudF9vcl9jb21wb25lbnQpIHtcblx0cmV0dXJuIChcblx0XHRib3VuZF92YWx1ZSA9PT0gZWxlbWVudF9vcl9jb21wb25lbnQgfHwgYm91bmRfdmFsdWU/LltTVEFURV9TWU1CT0xdID09PSBlbGVtZW50X29yX2NvbXBvbmVudFxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlbGVtZW50X29yX2NvbXBvbmVudFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24sIC4uLnBhcnRzOiB1bmtub3duW10pID0+IHZvaWR9IHVwZGF0ZVxuICogQHBhcmFtIHsoLi4ucGFydHM6IHVua25vd25bXSkgPT4gdW5rbm93bn0gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0geygpID0+IHVua25vd25bXX0gW2dldF9wYXJ0c10gU2V0IGlmIHRoZSB0aGlzIGJpbmRpbmcgaXMgdXNlZCBpbnNpZGUgYW4gZWFjaCBibG9jayxcbiAqIFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJucyBhbGwgdGhlIHBhcnRzIG9mIHRoZSBlYWNoIGJsb2NrIGNvbnRleHQgdGhhdCBhcmUgdXNlZCBpbiB0aGUgZXhwcmVzc2lvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3RoaXMoZWxlbWVudF9vcl9jb21wb25lbnQgPSB7fSwgdXBkYXRlLCBnZXRfdmFsdWUsIGdldF9wYXJ0cykge1xuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuXHRcdHZhciBvbGRfcGFydHM7XG5cblx0XHQvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblx0XHR2YXIgcGFydHM7XG5cblx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9sZF9wYXJ0cyA9IHBhcnRzO1xuXHRcdFx0Ly8gV2Ugb25seSB0cmFjayBjaGFuZ2VzIHRvIHRoZSBwYXJ0cywgbm90IHRoZSB2YWx1ZSBpdHNlbGYgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVydW5zLlxuXHRcdFx0cGFydHMgPSBnZXRfcGFydHM/LigpIHx8IFtdO1xuXG5cdFx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdFx0aWYgKGVsZW1lbnRfb3JfY29tcG9uZW50ICE9PSBnZXRfdmFsdWUoLi4ucGFydHMpKSB7XG5cdFx0XHRcdFx0dXBkYXRlKGVsZW1lbnRfb3JfY29tcG9uZW50LCAuLi5wYXJ0cyk7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlZmZlY3QgcmVydW4gKGNhdXNlOiBlYWNoIGJsb2NrIGNvbnRleHQgY2hhbmdlcyksIHRoZW4gbnVsbGZpeSB0aGUgYmluZGluZyBhdFxuXHRcdFx0XHRcdC8vIHRoZSBwcmV2aW91cyBwb3NpdGlvbiBpZiBpdCBpc24ndCBhbHJlYWR5IHRha2VuIG92ZXIgYnkgYSBkaWZmZXJlbnQgZWZmZWN0LlxuXHRcdFx0XHRcdGlmIChvbGRfcGFydHMgJiYgaXNfYm91bmRfdGhpcyhnZXRfdmFsdWUoLi4ub2xkX3BhcnRzKSwgZWxlbWVudF9vcl9jb21wb25lbnQpKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUobnVsbCwgLi4ub2xkX3BhcnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdC8vIFdlIGNhbm5vdCB1c2UgZWZmZWN0cyBpbiB0aGUgdGVhcmRvd24gcGhhc2UsIHdlIHdlIHVzZSBhIG1pY3JvdGFzayBpbnN0ZWFkLlxuXHRcdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRcdGlmIChwYXJ0cyAmJiBpc19ib3VuZF90aGlzKGdldF92YWx1ZSguLi5wYXJ0cyksIGVsZW1lbnRfb3JfY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdHVwZGF0ZShudWxsLCAuLi5wYXJ0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50X29yX2NvbXBvbmVudDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQWN0aW9uUmV0dXJuIH0gZnJvbSAnc3ZlbHRlL2FjdGlvbicgKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgdXNlcl9wcmVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG9uIH0gZnJvbSAnLi4vZWxlbWVudHMvZXZlbnRzLmpzJztcblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHRydXN0ZWRgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRpZiAoZXZlbnQuaXNUcnVzdGVkKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc2VsZmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGYoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc3RvcFByb3BhZ2F0aW9uYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYG9uY2VgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdHZhciByYW4gPSBmYWxzZTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHByZXZlbnREZWZhdWx0YCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBwYXNzaXZlYCBldmVudCBtb2RpZmllciwgaW1wbGVtZW50ZWQgYXMgYW4gYWN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtbZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKCkgPT4gRXZlbnRMaXN0ZW5lcl19IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3NpdmUobm9kZSwgW2V2ZW50LCBoYW5kbGVyXSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHJldHVybiBvbihub2RlLCBldmVudCwgaGFuZGxlcigpID8/IG5vb3AsIHtcblx0XHRcdHBhc3NpdmU6IHRydWVcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBub25wYXNzaXZlYCBldmVudCBtb2RpZmllciwgaW1wbGVtZW50ZWQgYXMgYW4gYWN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtbZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKCkgPT4gRXZlbnRMaXN0ZW5lcl19IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbnBhc3NpdmUobm9kZSwgW2V2ZW50LCBoYW5kbGVyXSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHJldHVybiBvbihub2RlLCBldmVudCwgaGFuZGxlcigpID8/IG5vb3AsIHtcblx0XHRcdHBhc3NpdmU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0TGVnYWN5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJ1biwgcnVuX2FsbCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgeyB1c2VyX3ByZV9lZmZlY3QsIHVzZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBkZWVwX3JlYWRfc3RhdGUsIGdldCwgdW50cmFjayB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIExlZ2FjeS1tb2RlIG9ubHk6IENhbGwgYG9uTW91bnRgIGNhbGxiYWNrcyBhbmQgc2V0IHVwIGBiZWZvcmVVcGRhdGVgL2BhZnRlclVwZGF0ZWAgZWZmZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChpbW11dGFibGUgPSBmYWxzZSkge1xuXHRjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbnRleHQubC51O1xuXHRpZiAoIWNhbGxiYWNrcykgcmV0dXJuO1xuXG5cdGxldCBwcm9wcyA9ICgpID0+IGRlZXBfcmVhZF9zdGF0ZShjb250ZXh0LnMpO1xuXG5cdGlmIChpbW11dGFibGUpIHtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0bGV0IHByZXYgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cblx0XHQvLyBJbiBsZWdhY3kgaW1tdXRhYmxlIG1vZGUsIGJlZm9yZS9hZnRlclVwZGF0ZSBvbmx5IGZpcmUgaWYgdGhlIG9iamVjdCBpZGVudGl0eSBvZiBhIHByb3AgY2hhbmdlc1xuXHRcdGNvbnN0IGQgPSBkZXJpdmVkKCgpID0+IHtcblx0XHRcdGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGNvbnRleHQucztcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wc1trZXldICE9PSBwcmV2W2tleV0pIHtcblx0XHRcdFx0XHRwcmV2W2tleV0gPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hhbmdlZCkgdmVyc2lvbisrO1xuXHRcdFx0cmV0dXJuIHZlcnNpb247XG5cdFx0fSk7XG5cblx0XHRwcm9wcyA9ICgpID0+IGdldChkKTtcblx0fVxuXG5cdC8vIGJlZm9yZVVwZGF0ZVxuXHRpZiAoY2FsbGJhY2tzLmIubGVuZ3RoKSB7XG5cdFx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmIpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gb25Nb3VudCAobXVzdCBydW4gYmVmb3JlIGFmdGVyVXBkYXRlKVxuXHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgZm5zID0gdW50cmFjaygoKSA9PiBjYWxsYmFja3MubS5tYXAocnVuKSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gYWZ0ZXJVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5hLmxlbmd0aCkge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmEpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogSW52b2tlIHRoZSBnZXR0ZXIgb2YgYWxsIHNpZ25hbHMgYXNzb2NpYXRlZCB3aXRoIGEgY29tcG9uZW50XG4gKiBzbyB0aGV5IGNhbiBiZSByZWdpc3RlcmVkIHRvIHRoZSBlZmZlY3QgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4uXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRMZWdhY3l9IGNvbnRleHRcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBwcm9wc1xuICovXG5mdW5jdGlvbiBvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcykge1xuXHRpZiAoY29udGV4dC5sLnMpIHtcblx0XHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBjb250ZXh0LmwucykgZ2V0KHNpZ25hbCk7XG5cdH1cblxuXHRwcm9wcygpO1xufVxuIiwiaW1wb3J0IHsgc2V0LCBzb3VyY2UgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBpbXBvcnRzIG1heSBiZSByZWFjdGl2ZSBpbiBsZWdhY3kgbW9kZS4gSW4gdGhhdCBjYXNlLFxuICogdGhleSBzaG91bGQgYmUgdXNpbmcgYHJlYWN0aXZlX2ltcG9ydGAgYXMgcGFydCBvZiB0aGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhY3RpdmVfaW1wb3J0KGZuKSB7XG5cdHZhciBzID0gc291cmNlKDApO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHNldChzLCBnZXQocykgKyAxKTtcblx0XHRcdHJldHVybiBhcmd1bWVudHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldChzKTtcblx0XHRcdHJldHVybiBmbigpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAdGhpcyB7YW55fVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gJCRwcm9wc1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlX2V2ZW50KCQkcHJvcHMsIGV2ZW50KSB7XG5cdHZhciBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10gfCBGdW5jdGlvbj59ICovICgkJHByb3BzLiQkZXZlbnRzKT8uW1xuXHRcdGV2ZW50LnR5cGVcblx0XTtcblxuXHR2YXIgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogZXZlbnRzID09IG51bGwgPyBbXSA6IFtldmVudHNdO1xuXG5cdGZvciAodmFyIGZuIG9mIGNhbGxiYWNrcykge1xuXHRcdC8vIFByZXNlcnZlIFwidGhpc1wiIGNvbnRleHRcblx0XHRmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fVxufVxuXG4vKipcbiAqIFVzZWQgdG8gc2ltdWxhdGUgYCRvbmAgb24gYSBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbiBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGkgPT09IDRgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudF9jYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xlZ2FjeV9ldmVudF9saXN0ZW5lcigkJHByb3BzLCBldmVudF9uYW1lLCBldmVudF9jYWxsYmFjaykge1xuXHQkJHByb3BzLiQkZXZlbnRzIHx8PSB7fTtcblx0JCRwcm9wcy4kJGV2ZW50c1tldmVudF9uYW1lXSB8fD0gW107XG5cdCQkcHJvcHMuJCRldmVudHNbZXZlbnRfbmFtZV0ucHVzaChldmVudF9jYWxsYmFjayk7XG59XG5cbi8qKlxuICogVXNlZCB0byBzaW11bGF0ZSBgJHNldGAgb24gYSBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbiBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGkgPT09IDRgLlxuICogTmVlZHMgY29tcG9uZW50IGFjY2Vzc29ycyBzbyB0aGF0IGl0IGNhbiBjYWxsIHRoZSBzZXR0ZXIgb2YgdGhlIHByb3AuIFRoZXJlZm9yZSBkb2Vzbid0XG4gKiB3b3JrIGZvciB1cGRhdGluZyBwcm9wcyBpbiBgJCRwcm9wc2Agb3IgYCQkcmVzdFByb3BzYC5cbiAqIEB0aGlzIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJG5ld19wcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2xlZ2FjeV9wcm9wcygkJG5ld19wcm9wcykge1xuXHRmb3IgKHZhciBrZXkgaW4gJCRuZXdfcHJvcHMpIHtcblx0XHRpZiAoa2V5IGluIHRoaXMpIHtcblx0XHRcdHRoaXNba2V5XSA9ICQkbmV3X3Byb3BzW2tleV07XG5cdFx0fVxuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnLi9wdWJsaWMnICovXG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vaW5kZXgtY2xpZW50LmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBydW5cbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBbaW52YWxpZGF0ZV1cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCBydW4sIGludmFsaWRhdGUpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0cnVuKHVuZGVmaW5lZCk7XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0aWYgKGludmFsaWRhdGUpIGludmFsaWRhdGUodW5kZWZpbmVkKTtcblxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cblx0Ly8gU3ZlbHRlIHN0b3JlIHRha2VzIGEgcHJpdmF0ZSBzZWNvbmQgYXJndW1lbnRcblx0Ly8gU3RhcnRTdG9wTm90aWZpZXIgY291bGQgbXV0YXRlIHN0YXRlLCBhbmQgd2Ugd2FudCB0byBzaWxlbmNlIHRoZSBjb3JyZXNwb25kaW5nIHZhbGlkYXRpb24gZXJyb3Jcblx0Y29uc3QgdW5zdWIgPSB1bnRyYWNrKCgpID0+XG5cdFx0c3RvcmUuc3Vic2NyaWJlKFxuXHRcdFx0cnVuLFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0aW52YWxpZGF0ZVxuXHRcdClcblx0KTtcblxuXHQvLyBBbHNvIHN1cHBvcnQgUnhKU1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IHRoaXMgaW4gdGhlIHR5cGVzP1xuXHRyZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG4iLCIvKiogQGltcG9ydCB7IFN0b3JlUmVmZXJlbmNlc0NvbnRhaW5lciB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IFN0b3JlIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uLy4uLy4uL3N0b3JlL3V0aWxzLmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBtdXRhYmxlX3NvdXJjZSwgc2V0IH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcCBjdXJyZW50bHkgYmVpbmcgcmVhZCBpcyBhIHN0b3JlIGJpbmRpbmcsIGFzIGluXG4gKiBgPENoaWxkIGJpbmQ6eD17JHl9IC8+YC4gSWYgaXQgaXMsIHdlIHRyZWF0IHRoZSBwcm9wIGFzIG11dGFibGUgZXZlbiBpblxuICogcnVuZXMgbW9kZSwgYW5kIHNraXAgYGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCB2YWxpZGF0aW9uXG4gKi9cbmxldCBpc19zdG9yZV9iaW5kaW5nID0gZmFsc2U7XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIHN0b3JlLiBJZiB0aGUgc3RvcmUgaXNuJ3Qgc3Vic2NyaWJlZCB0byB5ZXQsIGl0IHdpbGwgY3JlYXRlIGEgcHJveHlcbiAqIHNpZ25hbCB0aGF0IHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZSBzdG9yZSBpcy4gVGhlIHN0b3JlIHJlZmVyZW5jZXMgY29udGFpbmVyIGlzIG5lZWRlZCB0b1xuICogdHJhY2sgcmVhc3NpZ25tZW50cyB0byBzdG9yZXMgYW5kIHRvIHRyYWNrIHRoZSBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0LlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfZ2V0KHN0b3JlLCBzdG9yZV9uYW1lLCBzdG9yZXMpIHtcblx0Y29uc3QgZW50cnkgPSAoc3RvcmVzW3N0b3JlX25hbWVdID8/PSB7XG5cdFx0c3RvcmU6IG51bGwsXG5cdFx0c291cmNlOiBtdXRhYmxlX3NvdXJjZSh1bmRlZmluZWQpLFxuXHRcdHVuc3Vic2NyaWJlOiBub29wXG5cdH0pO1xuXG5cdGlmIChlbnRyeS5zdG9yZSAhPT0gc3RvcmUpIHtcblx0XHRlbnRyeS51bnN1YnNjcmliZSgpO1xuXHRcdGVudHJ5LnN0b3JlID0gc3RvcmUgPz8gbnVsbDtcblxuXHRcdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0XHRlbnRyeS5zb3VyY2UudiA9IHVuZGVmaW5lZDsgLy8gc2VlIHN5bmNocm9ub3VzIGNhbGxiYWNrIGNvbW1lbnQgYmVsb3dcblx0XHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gbm9vcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrID0gdHJ1ZTtcblxuXHRcdFx0ZW50cnkudW5zdWJzY3JpYmUgPSBzdWJzY3JpYmVfdG9fc3RvcmUoc3RvcmUsICh2KSA9PiB7XG5cdFx0XHRcdGlmIChpc19zeW5jaHJvbm91c19jYWxsYmFjaykge1xuXHRcdFx0XHRcdC8vIElmIHRoZSBmaXJzdCB1cGRhdGVzIHRvIHRoZSBzdG9yZSB2YWx1ZSAocG9zc2libHkgbXVsdGlwbGUgb2YgdGhlbSkgYXJlIHN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHQvLyBpbnNpZGUgYSBkZXJpdmVkLCB3ZSB3aWxsIGhpdCB0aGUgYHN0YXRlX3Vuc2FmZV9tdXRhdGlvbmAgZXJyb3IgaWYgd2UgYHNldGAgdGhlIHZhbHVlXG5cdFx0XHRcdFx0ZW50cnkuc291cmNlLnYgPSB2O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNldChlbnRyeS5zb3VyY2UsIHYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aXNfc3luY2hyb25vdXNfY2FsbGJhY2sgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZ2V0KGVudHJ5LnNvdXJjZSk7XG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGlmIGl0J3Mgbm90IHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gdGhlIHN0b3JlIHJlZmVyZW5jZXMgY29udGFpbmVyLlxuICogV2UgbmVlZCB0aGlzIGluIGFkZGl0aW9uIHRvIGBzdG9yZV9nZXRgIGJlY2F1c2Ugc29tZW9uZSBjb3VsZCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgYnV0XG4gKiB0aGVuIG5ldmVyIHN1YnNjcmliZSB0byB0aGUgbmV3IG9uZSAoaWYgYW55KSwgY2F1c2luZyB0aGUgc3Vic2NyaXB0aW9uIHRvIHN0YXkgb3BlbiB3cm9uZ2Z1bGx5LlxuICogQHBhcmFtIHtTdG9yZTxhbnk+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV91bnN1YihzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdC8qKiBAdHlwZSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyWycnXSB8IHVuZGVmaW5lZH0gKi9cblx0bGV0IGVudHJ5ID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXG5cdGlmIChlbnRyeSAmJiBlbnRyeS5zdG9yZSAhPT0gc3RvcmUpIHtcblx0XHQvLyBEb24ndCByZXNldCBzdG9yZSB5ZXQsIHNvIHRoYXQgc3RvcmVfZ2V0IGFib3ZlIGNhbiByZXN1YnNjcmliZSB0byBuZXcgc3RvcmUgaWYgbmVjZXNzYXJ5XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdH1cblxuXHRyZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbmV3IHZhbHVlIG9mIGEgc3RvcmUgYW5kIHJldHVybnMgdGhhdCB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+fSBzdG9yZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9zZXQoc3RvcmUsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZV9zdG9yZShzdG9yZXMsIHN0b3JlX25hbWUpIHtcblx0dmFyIGVudHJ5ID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXHRpZiAoZW50cnkuc3RvcmUgIT09IG51bGwpIHtcblx0XHRzdG9yZV9zZXQoZW50cnkuc3RvcmUsIGVudHJ5LnNvdXJjZS52KTtcblx0fVxufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBhdXRvLXN1YnNjcmliZWQgc3RvcmVzIG9uIGRlc3Ryb3lcbiAqIEByZXR1cm5zIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cF9zdG9yZXMoKSB7XG5cdC8qKiBAdHlwZSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSAqL1xuXHRjb25zdCBzdG9yZXMgPSB7fTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Zm9yICh2YXIgc3RvcmVfbmFtZSBpbiBzdG9yZXMpIHtcblx0XHRcdGNvbnN0IHJlZiA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblx0XHRcdHJlZi51bnN1YnNjcmliZSgpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHN0b3Jlcztcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgc3RvcmUgd2l0aCBhIG5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlICB0aGUgc3RvcmUgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gZXhwcmVzc2lvbiAgdGhlIGV4cHJlc3Npb24gdGhhdCBtdXRhdGVzIHRoZSBzdG9yZVxuICogQHBhcmFtIHtWfSBuZXdfdmFsdWUgIHRoZSBuZXcgc3RvcmUgdmFsdWVcbiAqIEB0ZW1wbGF0ZSBWXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9tdXRhdGUoc3RvcmUsIGV4cHJlc3Npb24sIG5ld192YWx1ZSkge1xuXHRzdG9yZS5zZXQobmV3X3ZhbHVlKTtcblx0cmV0dXJuIGV4cHJlc3Npb247XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0b3JlX3ZhbHVlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3N0b3JlKHN0b3JlLCBzdG9yZV92YWx1ZSwgZCA9IDEpIHtcblx0c3RvcmUuc2V0KHN0b3JlX3ZhbHVlICsgZCk7XG5cdHJldHVybiBzdG9yZV92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcmVfdmFsdWVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3N0b3JlKHN0b3JlLCBzdG9yZV92YWx1ZSwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBzdG9yZV92YWx1ZSArIGQ7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgaW5zaWRlIHByb3AgZ2V0dGVycyB0byBjb21tdW5pY2F0ZSB0aGF0IHRoZSBwcm9wIGlzIGEgc3RvcmUgYmluZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya19zdG9yZV9iaW5kaW5nKCkge1xuXHRpc19zdG9yZV9iaW5kaW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHVwbGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBgZm4oKWAgcmVhZHMgYSBwcm9wIHRoYXQgaXMgYSBzdG9yZSBiaW5kaW5nLlxuICogVXNlZCB0byBwcmV2ZW50IGBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAgdmFsaWRhdGlvbiBmYWxzZSBwb3NpdGl2ZXMgYW5kXG4gKiBlbnN1cmUgdGhhdCB0aGVzZSBwcm9wcyBhcmUgdHJlYXRlZCBhcyBtdXRhYmxlIGV2ZW4gaW4gcnVuZXMgbW9kZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtbVCwgYm9vbGVhbl19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlX3N0b3JlX2JpbmRpbmcoZm4pIHtcblx0dmFyIHByZXZpb3VzX2lzX3N0b3JlX2JpbmRpbmcgPSBpc19zdG9yZV9iaW5kaW5nO1xuXG5cdHRyeSB7XG5cdFx0aXNfc3RvcmVfYmluZGluZyA9IGZhbHNlO1xuXHRcdHJldHVybiBbZm4oKSwgaXNfc3RvcmVfYmluZGluZ107XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfc3RvcmVfYmluZGluZyA9IHByZXZpb3VzX2lzX3N0b3JlX2JpbmRpbmc7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi90eXBlcy5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0UFJPUFNfSVNfQklOREFCTEUsXG5cdFBST1BTX0lTX0lNTVVUQUJMRSxcblx0UFJPUFNfSVNfTEFaWV9JTklUSUFMLFxuXHRQUk9QU19JU19SVU5FUyxcblx0UFJPUFNfSVNfVVBEQVRFRFxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IG11dGFibGVfc291cmNlLCBzZXQsIHNvdXJjZSB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkLCBkZXJpdmVkX3NhZmVfZXF1YWwgfSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGdldCxcblx0Y2FwdHVyZWRfc2lnbmFscyxcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHVudHJhY2ssXG5cdHVwZGF0ZVxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQge1xuXHRCUkFOQ0hfRUZGRUNULFxuXHRMRUdBQ1lfREVSSVZFRF9QUk9QLFxuXHRMRUdBQ1lfUFJPUFMsXG5cdFJPT1RfRUZGRUNULFxuXHRTVEFURV9TWU1CT0xcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHByb3h5IH0gZnJvbSAnLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgY2FwdHVyZV9zdG9yZV9iaW5kaW5nIH0gZnJvbSAnLi9zdG9yZS5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJvcChmbiwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBmbigpO1xuXHRmbih2YWx1ZSArIGQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKHZhbHVlPzogbnVtYmVyKSA9PiBudW1iZXIpfSBmblxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmVfcHJvcChmbiwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBmbigpICsgZDtcblx0Zm4odmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHJlc3QgcHJvcHMgKGkuZS4gYGNvbnN0IHsgeCwgLi4ucmVzdCB9ID0gJHByb3BzKClgKS5cbiAqIElzIHBhc3NlZCB0aGUgZnVsbCBgJCRwcm9wc2Agb2JqZWN0IGFuZCBleGNsdWRlcyB0aGUgbmFtZWQgcHJvcHMuXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+LCBleGNsdWRlOiBBcnJheTxzdHJpbmcgfCBzeW1ib2w+LCBuYW1lPzogc3RyaW5nIH0+fX1cbiAqL1xuY29uc3QgcmVzdF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdHJldHVybiB0YXJnZXQucHJvcHNba2V5XTtcblx0fSxcblx0c2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLnByb3BzX3Jlc3RfcmVhZG9ubHkoYCR7dGFyZ2V0Lm5hbWV9LiR7U3RyaW5nKGtleSl9YCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQucHJvcHM7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQucHJvcHMpLmZpbHRlcigoa2V5KSA9PiAhdGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSk7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4Y2x1ZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSwgbmFtZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KFxuXHRcdERFViA/IHsgcHJvcHMsIGV4Y2x1ZGUsIG5hbWUsIG90aGVyOiB7fSwgdG9fcHJveHk6IFtdIH0gOiB7IHByb3BzLCBleGNsdWRlIH0sXG5cdFx0cmVzdF9wcm9wc19oYW5kbGVyXG5cdCk7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIGxlZ2FjeSAkJHJlc3RQcm9wcyBhbmQgJCRwcm9wc1xuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgc3BlY2lhbDogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgKHY/OiB1bmtub3duKSA9PiB1bmtub3duPiwgdmVyc2lvbjogU291cmNlPG51bWJlcj4gfT59fVxuICovXG5jb25zdCBsZWdhY3lfcmVzdF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGdldCh0YXJnZXQudmVyc2lvbik7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQuc3BlY2lhbCA/IHRhcmdldC5zcGVjaWFsW2tleV0oKSA6IHRhcmdldC5wcm9wc1trZXldO1xuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG5cdFx0aWYgKCEoa2V5IGluIHRhcmdldC5zcGVjaWFsKSkge1xuXHRcdFx0Ly8gSGFuZGxlIHByb3BzIHRoYXQgY2FuIHRlbXBvcmFyaWx5IGdldCBvdXQgb2Ygc3luYyB3aXRoIHRoZSBwYXJlbnRcblx0XHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgKHY/OiB1bmtub3duKSA9PiB1bmtub3duPn0gKi9cblx0XHRcdHRhcmdldC5zcGVjaWFsW2tleV0gPSBwcm9wKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Z2V0IFtrZXldKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovIChrZXkpLFxuXHRcdFx0XHRQUk9QU19JU19VUERBVEVEXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRhcmdldC5zcGVjaWFsW2tleV0odmFsdWUpO1xuXHRcdHVwZGF0ZSh0YXJnZXQudmVyc2lvbik7IC8vICQkcHJvcHMgaXMgY29hcnNlLWdyYWluZWQ6IHdoZW4gJCRwcm9wcy54IGlzIHVwZGF0ZWQsIHVzYWdlcyBvZiAkJHByb3BzLnkgZXRjIGFyZSBhbHNvIHJlcnVuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cdFx0aWYgKGtleSBpbiB0YXJnZXQucHJvcHMpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHRhcmdldC5wcm9wc1trZXldXG5cdFx0XHR9O1xuXHRcdH1cblx0fSxcblx0ZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcblx0XHQvLyBTdmVsdGUgNCBhbGxvd2VkIGZvciBkZWxldGlvbnMgb24gJCRyZXN0UHJvcHNcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIHRydWU7XG5cdFx0dGFyZ2V0LmV4Y2x1ZGUucHVzaChrZXkpO1xuXHRcdHVwZGF0ZSh0YXJnZXQudmVyc2lvbik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQucHJvcHM7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQucHJvcHMpLmZpbHRlcigoa2V5KSA9PiAhdGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSk7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4Y2x1ZGVcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9yZXN0X3Byb3BzKHByb3BzLCBleGNsdWRlKSB7XG5cdHJldHVybiBuZXcgUHJveHkoeyBwcm9wcywgZXhjbHVkZSwgc3BlY2lhbDoge30sIHZlcnNpb246IHNvdXJjZSgwKSB9LCBsZWdhY3lfcmVzdF9wcm9wc19oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJveHkgaGFuZGxlciBmb3Igc3ByZWFkIHByb3BzLiBIYW5kbGVzIHRoZSBpbmNvbWluZyBhcnJheSBvZiBwcm9wc1xuICogdGhhdCBsb29rcyBsaWtlIGAoKSA9PiB7IGR5bmFtaWM6IHByb3BzIH0sIHsgc3RhdGljOiBwcm9wIH0sIC4uYCBhbmQgd3JhcHNcbiAqIHRoZW0gc28gdGhhdCB0aGUgd2hvbGUgdGhpbmcgaXMgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQgYXMgdGhlIGAkJHByb3BzYCBhcmd1bWVudC5cbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj59IFRcbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogQXJyYXk8VCB8ICgoKSA9PiBUKT4gfT59fVxuICovXG5jb25zdCBzcHJlYWRfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsICYmIGtleSBpbiBwKSByZXR1cm4gcFtrZXldO1xuXHRcdH1cblx0fSxcblx0c2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGNvbnN0IGRlc2MgPSBnZXRfZGVzY3JpcHRvcihwLCBrZXkpO1xuXHRcdFx0aWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcblx0XHRcdFx0ZGVzYy5zZXQodmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwgJiYga2V5IGluIHApIHtcblx0XHRcdFx0Y29uc3QgZGVzY3JpcHRvciA9IGdldF9kZXNjcmlwdG9yKHAsIGtleSk7XG5cdFx0XHRcdGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgYSBcIk5vbi1jb25maWd1cmFiaWxpdHkgUmVwb3J0IEVycm9yXCI6IFRoZSB0YXJnZXQgaXMgYW4gYXJyYXksIGl0IGRvZXNcblx0XHRcdFx0XHQvLyBub3QgYWN0dWFsbHkgY29udGFpbiB0aGlzIHByb3BlcnR5LiBJZiBpdCBpcyBub3cgZGVzY3JpYmVkIGFzIG5vbi1jb25maWd1cmFibGUsXG5cdFx0XHRcdFx0Ly8gdGhlIHByb3h5IHRocm93cyBhIHZhbGlkYXRpb24gZXJyb3IuIFNldHRpbmcgaXQgdG8gdHJ1ZSBhdm9pZHMgdGhhdC5cblx0XHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHQvLyBUbyBwcmV2ZW50IGEgZmFsc2UgcG9zaXRpdmUgYGlzX2VudHJ5X3Byb3BzYCBpbiB0aGUgYHByb3BgIGZ1bmN0aW9uXG5cdFx0aWYgKGtleSA9PT0gU1RBVEVfU1lNQk9MIHx8IGtleSA9PT0gTEVHQUNZX1BST1BTKSByZXR1cm4gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBwIG9mIHRhcmdldC5wcm9wcykge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHAgIT0gbnVsbCAmJiBrZXkgaW4gcCkgcmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nIHwgc3ltYm9sPn0gKi9cblx0XHRjb25zdCBrZXlzID0gW107XG5cblx0XHRmb3IgKGxldCBwIG9mIHRhcmdldC5wcm9wcykge1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gcCkge1xuXHRcdFx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkga2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGtleXM7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8ICgoKSA9PiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik+fSBwcm9wc1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZF9wcm9wcyguLi5wcm9wcykge1xuXHRyZXR1cm4gbmV3IFByb3h5KHsgcHJvcHMgfSwgc3ByZWFkX3Byb3BzX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gd2l0aF9wYXJlbnRfYnJhbmNoKGZuKSB7XG5cdHZhciBlZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsICYmIChlZmZlY3QuZiAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSA9PT0gMCkge1xuXHRcdGVmZmVjdCA9IGVmZmVjdC5wYXJlbnQ7XG5cdH1cblx0dHJ5IHtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChlZmZlY3QpO1xuXHRcdHJldHVybiBmbigpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBzeW5jaHJvbml6aW5nIGEgcG9zc2libHkgYm91bmQgcHJvcCB3aXRoIHRoZSBpbm5lciBjb21wb25lbnQgc3RhdGUuXG4gKiBJdCBpcyB1c2VkIHdoZW5ldmVyIHRoZSBjb21waWxlciBzZWVzIHRoYXQgdGhlIGNvbXBvbmVudCB3cml0ZXMgdG8gdGhlIHByb3AsIG9yIHdoZW4gaXQgaGFzIGEgZGVmYXVsdCBwcm9wX3ZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7ViB8ICgoKSA9PiBWKX0gW2ZhbGxiYWNrXVxuICogQHJldHVybnMgeygoKSA9PiBWIHwgKChhcmc6IFYpID0+IFYpIHwgKChhcmc6IFYsIG11dGF0aW9uOiBib29sZWFuKSA9PiBWKSl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wKHByb3BzLCBrZXksIGZsYWdzLCBmYWxsYmFjaykge1xuXHR2YXIgaW1tdXRhYmxlID0gKGZsYWdzICYgUFJPUFNfSVNfSU1NVVRBQkxFKSAhPT0gMDtcblx0dmFyIHJ1bmVzID0gIWxlZ2FjeV9tb2RlX2ZsYWcgfHwgKGZsYWdzICYgUFJPUFNfSVNfUlVORVMpICE9PSAwO1xuXHR2YXIgYmluZGFibGUgPSAoZmxhZ3MgJiBQUk9QU19JU19CSU5EQUJMRSkgIT09IDA7XG5cdHZhciBsYXp5ID0gKGZsYWdzICYgUFJPUFNfSVNfTEFaWV9JTklUSUFMKSAhPT0gMDtcblx0dmFyIGlzX3N0b3JlX3N1YiA9IGZhbHNlO1xuXHR2YXIgcHJvcF92YWx1ZTtcblxuXHRpZiAoYmluZGFibGUpIHtcblx0XHRbcHJvcF92YWx1ZSwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZygoKSA9PiAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKSk7XG5cdH0gZWxzZSB7XG5cdFx0cHJvcF92YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pO1xuXHR9XG5cblx0Ly8gQ2FuIGJlIHRoZSBjYXNlIHdoZW4gc29tZW9uZSBkb2VzIGBtb3VudChDb21wb25lbnQsIHByb3BzKWAgd2l0aCBgbGV0IHByb3BzID0gJHN0YXRlKHsuLi59KWBcblx0Ly8gb3IgYGNyZWF0ZUNsYXNzQ29tcG9uZW50KENvbXBvbmVudCwgcHJvcHMpYFxuXHR2YXIgaXNfZW50cnlfcHJvcHMgPSBTVEFURV9TWU1CT0wgaW4gcHJvcHMgfHwgTEVHQUNZX1BST1BTIGluIHByb3BzO1xuXG5cdHZhciBzZXR0ZXIgPVxuXHRcdGdldF9kZXNjcmlwdG9yKHByb3BzLCBrZXkpPy5zZXQgPz9cblx0XHQoaXNfZW50cnlfcHJvcHMgJiYgYmluZGFibGUgJiYga2V5IGluIHByb3BzID8gKHYpID0+IChwcm9wc1trZXldID0gdikgOiB1bmRlZmluZWQpO1xuXG5cdHZhciBmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKGZhbGxiYWNrKTtcblx0dmFyIGZhbGxiYWNrX2RpcnR5ID0gdHJ1ZTtcblx0dmFyIGZhbGxiYWNrX3VzZWQgPSBmYWxzZTtcblxuXHR2YXIgZ2V0X2ZhbGxiYWNrID0gKCkgPT4ge1xuXHRcdGZhbGxiYWNrX3VzZWQgPSB0cnVlO1xuXHRcdGlmIChmYWxsYmFja19kaXJ0eSkge1xuXHRcdFx0ZmFsbGJhY2tfZGlydHkgPSBmYWxzZTtcblx0XHRcdGlmIChsYXp5KSB7XG5cdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gdW50cmFjaygvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbGxiYWNrX3ZhbHVlO1xuXHR9O1xuXG5cdGlmIChwcm9wX3ZhbHVlID09PSB1bmRlZmluZWQgJiYgZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChzZXR0ZXIgJiYgcnVuZXMpIHtcblx0XHRcdGUucHJvcHNfaW52YWxpZF92YWx1ZShrZXkpO1xuXHRcdH1cblxuXHRcdHByb3BfdmFsdWUgPSBnZXRfZmFsbGJhY2soKTtcblx0XHRpZiAoc2V0dGVyKSBzZXR0ZXIocHJvcF92YWx1ZSk7XG5cdH1cblxuXHQvKiogQHR5cGUgeygpID0+IFZ9ICovXG5cdHZhciBnZXR0ZXI7XG5cdGlmIChydW5lcykge1xuXHRcdGdldHRlciA9ICgpID0+IHtcblx0XHRcdHZhciB2YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pO1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBnZXRfZmFsbGJhY2soKTtcblx0XHRcdGZhbGxiYWNrX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdGZhbGxiYWNrX3VzZWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN2ZWx0ZSA0IGRpZCBub3QgdHJpZ2dlciB1cGRhdGVzIHdoZW4gYSBwcmltaXRpdmUgdmFsdWUgd2FzIHVwZGF0ZWQgdG8gdGhlIHNhbWUgdmFsdWUuXG5cdFx0Ly8gUmVwbGljYXRlIHRoYXQgYmVoYXZpb3IgdGhyb3VnaCB1c2luZyBhIGRlcml2ZWRcblx0XHR2YXIgZGVyaXZlZF9nZXR0ZXIgPSB3aXRoX3BhcmVudF9icmFuY2goKCkgPT5cblx0XHRcdChpbW11dGFibGUgPyBkZXJpdmVkIDogZGVyaXZlZF9zYWZlX2VxdWFsKSgoKSA9PiAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKSlcblx0XHQpO1xuXHRcdGRlcml2ZWRfZ2V0dGVyLmYgfD0gTEVHQUNZX0RFUklWRURfUFJPUDtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXQoZGVyaXZlZF9nZXR0ZXIpO1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIGZhbGxiYWNrX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAodW5kZWZpbmVkKTtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsbGJhY2tfdmFsdWUgOiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gZWFzeSBtb2RlIOKAlCBwcm9wIGlzIG5ldmVyIHdyaXR0ZW4gdG9cblx0aWYgKChmbGFncyAmIFBST1BTX0lTX1VQREFURUQpID09PSAwKSB7XG5cdFx0cmV0dXJuIGdldHRlcjtcblx0fVxuXG5cdC8vIGludGVybWVkaWF0ZSBtb2RlIOKAlCBwcm9wIGlzIHdyaXR0ZW4gdG8sIGJ1dCB0aGUgcGFyZW50IGNvbXBvbmVudCBoYWRcblx0Ly8gYGJpbmQ6Zm9vYCB3aGljaCBtZWFucyB3ZSBjYW4ganVzdCBjYWxsIGAkJHByb3BzLmZvbyA9IHZhbHVlYCBkaXJlY3RseVxuXHRpZiAoc2V0dGVyKSB7XG5cdFx0dmFyIGxlZ2FjeV9wYXJlbnQgPSBwcm9wcy4kJGxlZ2FjeTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKC8qKiBAdHlwZSB7YW55fSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gbm90aWZ5IGlmIHRoZSB2YWx1ZSB3YXMgbXV0YXRlZCBhbmQgdGhlIHBhcmVudCBpcyBpbiBydW5lcyBtb2RlLlxuXHRcdFx0XHQvLyBJbiB0aGF0IGNhc2UgdGhlIHN0YXRlIHByb3h5IChpZiBpdCBleGlzdHMpIHNob3VsZCB0YWtlIGNhcmUgb2YgdGhlIG5vdGlmaWNhdGlvbi5cblx0XHRcdFx0Ly8gSWYgdGhlIHBhcmVudCBpcyBub3QgaW4gcnVuZXMgbW9kZSwgd2UgbmVlZCB0byBub3RpZnkgb24gbXV0YXRpb24sIHRvbywgdGhhdCB0aGUgcHJvcFxuXHRcdFx0XHQvLyBoYXMgY2hhbmdlZCBiZWNhdXNlIHRoZSBwYXJlbnQgd2lsbCBub3QgYmUgYWJsZSB0byBkZXRlY3QgdGhlIGNoYW5nZSBvdGhlcndpc2UuXG5cdFx0XHRcdGlmICghcnVuZXMgfHwgIW11dGF0aW9uIHx8IGxlZ2FjeV9wYXJlbnQgfHwgaXNfc3RvcmVfc3ViKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKHNldHRlcikobXV0YXRpb24gPyBnZXR0ZXIoKSA6IHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZ2V0dGVyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIGhhcmQgbW9kZS4gdGhpcyBpcyB3aGVyZSBpdCBnZXRzIHVnbHkg4oCUIHRoZSB2YWx1ZSBpbiB0aGUgY2hpbGQgc2hvdWxkXG5cdC8vIHN5bmNocm9uaXplIHdpdGggdGhlIHBhcmVudCwgYnV0IGl0IHNob3VsZCBhbHNvIGJlIHBvc3NpYmxlIHRvIHRlbXBvcmFyaWx5XG5cdC8vIHNldCB0aGUgdmFsdWUgdG8gc29tZXRoaW5nIGVsc2UgbG9jYWxseS5cblx0dmFyIGZyb21fY2hpbGQgPSBmYWxzZTtcblx0dmFyIHdhc19mcm9tX2NoaWxkID0gZmFsc2U7XG5cblx0Ly8gVGhlIGRlcml2ZWQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZS4gVGhlIHVuZGVybHlpbmcgbXV0YWJsZVxuXHQvLyBzb3VyY2UgaXMgd3JpdHRlbiB0byBmcm9tIHZhcmlvdXMgcGxhY2VzIHRvIHBlcnNpc3QgdGhpcyB2YWx1ZS5cblx0dmFyIGlubmVyX2N1cnJlbnRfdmFsdWUgPSBtdXRhYmxlX3NvdXJjZShwcm9wX3ZhbHVlKTtcblx0dmFyIGN1cnJlbnRfdmFsdWUgPSB3aXRoX3BhcmVudF9icmFuY2goKCkgPT5cblx0XHRkZXJpdmVkKCgpID0+IHtcblx0XHRcdHZhciBwYXJlbnRfdmFsdWUgPSBnZXR0ZXIoKTtcblx0XHRcdHZhciBjaGlsZF92YWx1ZSA9IGdldChpbm5lcl9jdXJyZW50X3ZhbHVlKTtcblxuXHRcdFx0aWYgKGZyb21fY2hpbGQpIHtcblx0XHRcdFx0ZnJvbV9jaGlsZCA9IGZhbHNlO1xuXHRcdFx0XHR3YXNfZnJvbV9jaGlsZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBjaGlsZF92YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0d2FzX2Zyb21fY2hpbGQgPSBmYWxzZTtcblx0XHRcdHJldHVybiAoaW5uZXJfY3VycmVudF92YWx1ZS52ID0gcGFyZW50X3ZhbHVlKTtcblx0XHR9KVxuXHQpO1xuXG5cdGlmICghaW1tdXRhYmxlKSBjdXJyZW50X3ZhbHVlLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoLyoqIEB0eXBlIHthbnl9ICovIHZhbHVlLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIG11dGF0aW9uKSB7XG5cdFx0Ly8gbGVnYWN5IG5vbnNlbnNlIOKAlCBuZWVkIHRvIGVuc3VyZSB0aGUgc291cmNlIGlzIGludmFsaWRhdGVkIHdoZW4gbmVjZXNzYXJ5XG5cdFx0Ly8gYWxzbyBuZWVkZWQgZm9yIHdoZW4gaGFuZGxpbmcgaW5zcGVjdCBsb2dpYyBzbyB3ZSBjYW4gaW5zcGVjdCB0aGUgY29ycmVjdCBzb3VyY2Ugc2lnbmFsXG5cdFx0aWYgKGNhcHR1cmVkX3NpZ25hbHMgIT09IG51bGwpIHtcblx0XHRcdC8vIHNldCB0aGlzIHNvIHRoYXQgd2UgZG9uJ3QgcmVzZXQgdG8gdGhlIHBhcmVudCB2YWx1ZSBpZiBgZGBcblx0XHRcdC8vIGlzIGludmFsaWRhdGVkIGJlY2F1c2Ugb2YgYGludmFsaWRhdGVfaW5uZXJfc2lnbmFsc2AgKHJhdGhlclxuXHRcdFx0Ly8gdGhhbiBiZWNhdXNlIHRoZSBwYXJlbnQgb3IgY2hpbGQgdmFsdWUgY2hhbmdlZClcblx0XHRcdGZyb21fY2hpbGQgPSB3YXNfZnJvbV9jaGlsZDtcblx0XHRcdC8vIGludm9rZSBnZXR0ZXJzIHNvIHRoYXQgc2lnbmFscyBhcmUgcGlja2VkIHVwIGJ5IGBpbnZhbGlkYXRlX2lubmVyX3NpZ25hbHNgXG5cdFx0XHRnZXR0ZXIoKTtcblx0XHRcdGdldChpbm5lcl9jdXJyZW50X3ZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IG5ld192YWx1ZSA9IG11dGF0aW9uID8gZ2V0KGN1cnJlbnRfdmFsdWUpIDogcnVuZXMgJiYgYmluZGFibGUgPyBwcm94eSh2YWx1ZSkgOiB2YWx1ZTtcblxuXHRcdFx0aWYgKCFjdXJyZW50X3ZhbHVlLmVxdWFscyhuZXdfdmFsdWUpKSB7XG5cdFx0XHRcdGZyb21fY2hpbGQgPSB0cnVlO1xuXHRcdFx0XHRzZXQoaW5uZXJfY3VycmVudF92YWx1ZSwgbmV3X3ZhbHVlKTtcblx0XHRcdFx0Ly8gVG8gZW5zdXJlIHRoZSBmYWxsYmFjayB2YWx1ZSBpcyBjb25zaXN0ZW50IHdoZW4gdXNlZCB3aXRoIHByb3hpZXMsIHdlXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgbG9jYWwgZmFsbGJhY2tfdmFsdWUsIGJ1dCBvbmx5IGlmIHRoZSBmYWxsYmFjayBpcyBhY3RpdmVseSB1c2VkXG5cdFx0XHRcdGlmIChmYWxsYmFja191c2VkICYmIGZhbGxiYWNrX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR1bnRyYWNrKCgpID0+IGdldChjdXJyZW50X3ZhbHVlKSk7IC8vIGZvcmNlIGEgc3luY2hyb25pc2F0aW9uIGltbWVkaWF0ZWx5XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGdldChjdXJyZW50X3ZhbHVlKTtcblx0fTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vaW5kZXguanMnICovXG4vKiogQGltcG9ydCB7IE5vdEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlcy5qcycgKi9cbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBmbHVzaF9zeW5jLCB1bnRyYWNrIH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4vaW50ZXJuYWwvc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJfZWZmZWN0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9lcnJvcnMuanMnO1xuaW1wb3J0IHsgbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50IH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcgfSBmcm9tICcuL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBJZiBhIGZ1bmN0aW9uIGlzIHJldHVybmVkIF9zeW5jaHJvbm91c2x5XyBmcm9tIGBvbk1vdW50YCwgaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBbc2VydmVyLXNpZGUgY29tcG9uZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3N2ZWx0ZS1zZXJ2ZXIjcmVuZGVyKS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBOb3RGdW5jdGlvbjxUPiB8IFByb21pc2U8Tm90RnVuY3Rpb248VD4+IHwgKCgpID0+IGFueSl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdvbk1vdW50Jyk7XG5cdH1cblxuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiBjb21wb25lbnRfY29udGV4dC5sICE9PSBudWxsKSB7XG5cdFx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5tLnB1c2goZm4pO1xuXHR9IGVsc2Uge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdGNvbnN0IGNsZWFudXAgPSB1bnRyYWNrKGZuKTtcblx0XHRcdGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi8gKGNsZWFudXApO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdvbkRlc3Ryb3knKTtcblx0fVxuXG5cdG9uTW91bnQoKCkgPT4gKCkgPT4gdW50cmFjayhmbikpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBbVD1hbnldXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHBhcmFtIHthbnl9cGFyYW1zXzBcbiAqIEByZXR1cm5zIHtDdXN0b21FdmVudDxUPn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9sZWdhY3ktb24jQ29tcG9uZW50LWV2ZW50cykuXG4gKiBFdmVudCBkaXNwYXRjaGVycyBhcmUgZnVuY3Rpb25zIHRoYXQgY2FuIHRha2UgdHdvIGFyZ3VtZW50czogYG5hbWVgIGFuZCBgZGV0YWlsYC5cbiAqXG4gKiBDb21wb25lbnQgZXZlbnRzIGNyZWF0ZWQgd2l0aCBgY3JlYXRlRXZlbnREaXNwYXRjaGVyYCBjcmVhdGUgYVxuICogW0N1c3RvbUV2ZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQpLlxuICogVGhlc2UgZXZlbnRzIGRvIG5vdCBbYnViYmxlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0xlYXJuL0phdmFTY3JpcHQvQnVpbGRpbmdfYmxvY2tzL0V2ZW50cyNFdmVudF9idWJibGluZ19hbmRfY2FwdHVyZSkuXG4gKiBUaGUgYGRldGFpbGAgYXJndW1lbnQgY29ycmVzcG9uZHMgdG8gdGhlIFtDdXN0b21FdmVudC5kZXRhaWxdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9kZXRhaWwpXG4gKiBwcm9wZXJ0eSBhbmQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgZGF0YS5cbiAqXG4gKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBjYW4gYmUgdHlwZWQgdG8gbmFycm93IHRoZSBhbGxvd2VkIGV2ZW50IG5hbWVzIGFuZCB0aGUgdHlwZSBvZiB0aGUgYGRldGFpbGAgYXJndW1lbnQ6XG4gKiBgYGB0c1xuICogY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXI8e1xuICogIGxvYWRlZDogbmV2ZXI7IC8vIGRvZXMgbm90IHRha2UgYSBkZXRhaWwgYXJndW1lbnRcbiAqICBjaGFuZ2U6IHN0cmluZzsgLy8gdGFrZXMgYSBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBzdHJpbmcsIHdoaWNoIGlzIHJlcXVpcmVkXG4gKiAgb3B0aW9uYWw6IG51bWJlciB8IG51bGw7IC8vIHRha2VzIGFuIG9wdGlvbmFsIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIG51bWJlclxuICogfT4oKTtcbiAqIGBgYFxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBjYWxsYmFjayBwcm9wcyBhbmQvb3IgdGhlIGAkaG9zdCgpYCBydW5lIGluc3RlYWQg4oCUIHNlZSBbbWlncmF0aW9uIGd1aWRlXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdjUtbWlncmF0aW9uLWd1aWRlI0V2ZW50LWNoYW5nZXMtQ29tcG9uZW50LWV2ZW50cylcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gW0V2ZW50TWFwID0gYW55XVxuICogQHJldHVybnMge0V2ZW50RGlzcGF0Y2hlcjxFdmVudE1hcD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG5cdGNvbnN0IGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXHRpZiAoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdjcmVhdGVFdmVudERpc3BhdGNoZXInKTtcblx0fVxuXG5cdHJldHVybiAodHlwZSwgZGV0YWlsLCBvcHRpb25zKSA9PiB7XG5cdFx0Y29uc3QgZXZlbnRzID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbiB8IEZ1bmN0aW9uW10+fSAqLyAoXG5cdFx0XHRhY3RpdmVfY29tcG9uZW50X2NvbnRleHQucy4kJGV2ZW50c1xuXHRcdCk/LlsvKiogQHR5cGUge2FueX0gKi8gKHR5cGUpXTtcblxuXHRcdGlmIChldmVudHMpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGlzX2FycmF5KGV2ZW50cykgPyBldmVudHMuc2xpY2UoKSA6IFtldmVudHNdO1xuXHRcdFx0Ly8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuXHRcdFx0Ly8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuXHRcdFx0Y29uc3QgZXZlbnQgPSBjcmVhdGVfY3VzdG9tX2V2ZW50KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGRldGFpbCwgb3B0aW9ucyk7XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0XHRmbi5jYWxsKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC54LCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbi8vIFRPRE8gbWFyayBiZWZvcmVVcGRhdGUgYW5kIGFmdGVyVXBkYXRlIGFzIGRlcHJlY2F0ZWQgaW4gU3ZlbHRlIDZcblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBhZnRlciBhbnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYmVmb3JlIHRoZSBpbml0aWFsIGBvbk1vdW50YC5cbiAqXG4gKiBJbiBydW5lcyBtb2RlIHVzZSBgJGVmZmVjdC5wcmVgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIFtgJGVmZmVjdC5wcmVgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCMkZWZmZWN0LnByZSkgaW5zdGVhZFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdiZWZvcmVVcGRhdGUnKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfbGVnYWN5X29ubHkoJ2JlZm9yZVVwZGF0ZScpO1xuXHR9XG5cblx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5iLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBhZnRlciB0aGUgaW5pdGlhbCBgb25Nb3VudGAuXG4gKlxuICogSW4gcnVuZXMgbW9kZSB1c2UgYCRlZmZlY3RgIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIFtgJGVmZmVjdGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSBpbnN0ZWFkXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyVXBkYXRlKGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYWZ0ZXJVcGRhdGUnKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfbGVnYWN5X29ubHkoJ2FmdGVyVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmEucHVzaChmbik7XG59XG5cbi8qKlxuICogTGVnYWN5LW1vZGU6IEluaXQgY2FsbGJhY2tzIG9iamVjdCBmb3Igb25Nb3VudC9iZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29udGV4dCkge1xuXHR2YXIgbCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbnRleHQpLmw7XG5cdHJldHVybiAobC51ID8/PSB7IGE6IFtdLCBiOiBbXSwgbTogW10gfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBmbHVzaGVzIGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgYW5kIHRob3NlIHRoYXQgcmVzdWx0IGZyb20gaXQuXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtmbl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG5cdGZsdXNoX3N5bmMoZm4pO1xufVxuXG5leHBvcnQgeyBoeWRyYXRlLCBtb3VudCwgdW5tb3VudCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyc7XG5cbmV4cG9ydCB7XG5cdGdldENvbnRleHQsXG5cdGdldEFsbENvbnRleHRzLFxuXHRoYXNDb250ZXh0LFxuXHRzZXRDb250ZXh0LFxuXHR0aWNrLFxuXHR1bnRyYWNrXG59IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuXG5leHBvcnQgeyBjcmVhdGVSYXdTbmlwcGV0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbiIsIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLWNvbXBpbGVyI3N2ZWx0ZS12ZXJzaW9uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc1LjE2LjAnO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzUnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHw9IHsgdjogbmV3IFNldCgpIH0pLnYuYWRkKFBVQkxJQ19WRVJTSU9OKTtcbiIsImNvbnN0IGlucHV0VmFsdWVzRXh0cmFjdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNoZWNrYm94OiAoaW5wRWwsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZGVmYXVsdFZhbHVlID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oZGVmYXVsdFZhbHVlLCBcImNoZWNrZWRcIikgJiZcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oZGVmYXVsdFZhbHVlLCBcInVuY2hlY2tlZFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBFbC5jaGVja2VkXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWUuY2hlY2tlZFxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlLnVuY2hlY2tlZDtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oaW5wRWwsIFwidmFsdWVcIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpbnBFbC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBFbC5jaGVja2VkID8gaW5wRWwudmFsdWUgOiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBFbC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgY29tbW9uIHRvIFVJIGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllc1xuICpcbiAqIEBjbGFzcyBVSUNvbW1vblxuICovXG5jbGFzcyBVSUNvbW1vbiB7XG4gICAgc3RhdGljIENMRUFSX01BQ1JPID0gXCJfX0NMRUFSX19cIjtcbiAgICBzdGF0aWMgRVJST1JfREVGQVVMVCA9IFwi0KfRgtC+INC/0L7RiNC70L4g0L3QtSDRgtCw0LouXCI7XG4gICAgc3RhdGljIERFRkFVTFRfUkVESVJFQ1RfVElNRU9VVCA9IDMwMDA7XG4gICAgc3RhdGljIENMQVNTX09LID0gXCJpcy1zdWNjZXNzXCI7XG4gICAgc3RhdGljIENMQVNTX0VSUiA9IFwiaXMtZGFuZ2VyXCI7XG4gICAgc3RhdGljIFNDUk9MTF9ESVNBQkxFUl9DTEFTUyA9IFwicmVtb3ZlLXNjcm9sbFwiO1xuICAgIHN0YXRpYyBGSUxMRVIgPSBcIl9cIjtcblxuICAgIHN0YXRpYyBTQ1JPTExfT1BUSU9OUyA9IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBiZWhhdmlvcjogXCJzbW9vdGhcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldCBpbnB1dFZhbHVlc0V4dHJhY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlc0V4dHJhY3RvcnM7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4dHJhY3RWYWx1ZUZyb21JbnB1dChpbnBFbCwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKFVJQ29tbW9uLmlucHV0VmFsdWVzRXh0cmFjdG9ycywgaW5wRWwudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBVSUNvbW1vbi5pbnB1dFZhbHVlc0V4dHJhY3RvcnNbaW5wRWwudHlwZV0oXG4gICAgICAgICAgICAgICAgaW5wRWwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnBFbC52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGZpZWxkICAgIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50SW5wdXRDaGFuZ2VDYWxsYmFja30gICAgb25jaGFuZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gICAgICAgICBbZGVmYXVsdFZhbHVlPXVuZGVmaW5lZF1cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4vZXZlbnRzLnR5cGVzJykuVUlFdmVudENhbGxiYWNrfVxuICAgICAqIEBtZW1iZXJvZiBVSUNvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBvbklucHV0KGZpZWxkLCBvbmNoYW5nZSwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25jaGFuZ2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IFVJQ29tbW9uLmV4dHJhY3RWYWx1ZUZyb21JbnB1dChcbiAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBvbmNoYW5nZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQG1lbWJlcm9mIFVJQ29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIGlzRW50ZXJFdmVudChlKSB7XG4gICAgICAgIHJldHVybiBlLmtleSA9PT0gXCJFbnRlclwiICYmICFlLmFsdEtleSAmJiAhZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5O1xuICAgIH1cblxuICAgIHN0YXRpYyBvbmx5T25FbnRlcihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChVSUNvbW1vbi5pc0VudGVyRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBNT0JJTEVfV0lEVEhfQlJFQUtfUE9JTlQgPSA3NjA7XG5cbiAgICBzdGF0aWMgaXNNb2JpbGUoKSB7XG4gICAgICAgIGNvbnN0IHRlc3RNb2JpbGUgPSB3aW5kb3cubWF0Y2hNZWRpYSB8fCB3aW5kb3cubXNNYXRjaE1lZGlhO1xuICAgICAgICBpZiAodGVzdE1vYmlsZSkge1xuICAgICAgICAgICAgbGV0IHRlc3RRdWVyeSA9IFwiKHBvaW50ZXI6Y29hcnNlKVwiO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhfd2lkdGggPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLk1PQklMRV9XSURUSF9CUkVBS19QT0lOVFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGVzdFF1ZXJ5ID0gYG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAke21heF93aWR0aH1weClgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlc3RNb2JpbGUodGVzdFF1ZXJ5KS5tYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlQm9keVNjcm9sbCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHRoaXMuU0NST0xMX0RJU0FCTEVSX0NMQVNTKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzdG9yZUJvZHlTY3JvbGwoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLlNDUk9MTF9ESVNBQkxFUl9DTEFTUyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJlZm9ybWF0cyBpbnB1dCBmcm9tIGFueSBzdHJpbmcgdG8gc3RyaWN0IHBob25lIGZvcm1hdFxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gICAgdmFsICAgIGZyZWUgc3R5bGUgcGhvbmUgbnVtYmVyXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICBbZmlsbGVyPVVJQ29tbW9uLkZJTExFUl0gICAgZnJlZSBzdHlsZSBwaG9uZSBudW1iZXJcbiAgICAgKiAgQHJldHVybnMge3N0cmluZ30gICAgICAgICAgcGhvbmUgbnVtYmVyXG4gICAgICoqL1xuICAgIHN0YXRpYyBmb3JtYXRQaG9uZSh2YWwsIGZpbGxlciA9IHRoaXMuRklMTEVSKSB7XG4gICAgICAgIC8vc3RhcnRpbmcgZnJvbSAxMSBkaWdpdHMgaW4gcGhvbmUgbnVtYmVyXG4gICAgICAgIGNvbnN0IHNsb3RzID0gWzEsIDIsIDIsIDIsIDMsIDMsIDMsIDQsIDQsIDUsIDVdO1xuICAgICAgICBsZXQgZGlnaXRzID0gdmFsLnJlcGxhY2UoL1xcRC9nLCBcIlwiKTtcbiAgICAgICAgLy9pZiB0aGVyZSBhcmUgbW9yZSwgbW92ZSB0aGVtIHRvIGNvdW50cnkgY29kZSBzbG90XG4gICAgICAgIGlmIChkaWdpdHMubGVuZ3RoID4gMTEpIHtcbiAgICAgICAgICAgIGxldCBkID0gZGlnaXRzLmxlbmd0aCAtIDExO1xuICAgICAgICAgICAgd2hpbGUgKGQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZC0tO1xuICAgICAgICAgICAgICAgIHNsb3RzLnVuc2hpZnQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YWNrID0gW1wiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCJdO1xuICAgICAgICBBcnJheS5mcm9tKGRpZ2l0cykuZm9yRWFjaCgoZGlnaXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2xvdCA9IHNsb3RzW2luZGV4XTtcbiAgICAgICAgICAgIHN0YWNrW3Nsb3QgLSAxXSA9IHN0YWNrW3Nsb3QgLSAxXSArIGRpZ2l0O1xuICAgICAgICB9KTtcbiAgICAgICAgLy9jcmVhdGluZyBtYXAgb2YgcGFydHMgbGVuZ3Roc1xuICAgICAgICBjb25zdCBsZW5zID0gc2xvdHMucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWNjW2N1cnJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgYWNjW2N1cnJdID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjW2N1cnJdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vZmlsbCBlbXB0eSBwb3NpdGlvbnMgd2l0aCBmaWxsZXIgKF8pXG4gICAgICAgIGZvciAobGV0IHQgaW4gc3RhY2spIHtcbiAgICAgICAgICAgIGxldCBkaWYgPSBsZW5zW3BhcnNlSW50KHQpICsgMV0gLSBzdGFja1t0XS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoZGlmID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YWNrW3RdID0gc3RhY2tbdF0gKyBmaWxsZXI7XG4gICAgICAgICAgICAgICAgZGlmLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGArJHtzdGFja1swXX0gKCR7c3RhY2tbMV19KSAke3N0YWNrWzJdfS0ke3N0YWNrWzNdfS0ke3N0YWNrWzRdfWA7XG4gICAgfVxuXG4gICAgc3RhdGljIE1PTkVZX1NJR04gPSBcIiYjODM4MTtcIjtcblxuICAgIHN0YXRpYyBzZXRNb25leVNpZ24odmFsKSB7XG4gICAgICAgIHRoaXMuTU9ORVlfU0lHTiA9IHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmljZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgVUlDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0UHJpY2UocHJpY2UpIHtcbiAgICAgICAgbGV0IG1ham9yID0gTWF0aC5mbG9vcihwcmljZSAvIDEwMCksXG4gICAgICAgICAgICBtaW5vciA9IHByaWNlICUgMTAwO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5NT05FWV9TSUdOfSR7bWFqb3IudG9TdHJpbmcoKX0uJHttaW5vci50b1N0cmluZygpfWA7XG4gICAgfVxuXG4gICAgc3RhdGljIGZvcm1hdExvY2FsZURhdGV0aW1lKGR0LCBvcHRzID0geyBkYXRlOiB0cnVlLCB0aW1lOiB0cnVlIH0pIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IGR0LnRvTG9jYWxlRGF0ZVN0cmluZyh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlKTtcbiAgICAgICAgY29uc3QgdGltZSA9IGR0LnRvTG9jYWxlVGltZVN0cmluZyh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlKTtcbiAgICAgICAgaWYgKG9wdHMuZGF0ZSAmJiBvcHRzLnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtkYXRlfSAke3RpbWV9YDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLmRhdGUgJiYgIW9wdHMudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB0cnlGb3JtYXRMb2NhbGVEYXRlVGltZSh2YWx1ZSwgb3B0cyA9IHsgZGF0ZTogdHJ1ZSwgdGltZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgZHQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gVUlDb21tb24uZm9ybWF0TG9jYWxlRGF0ZXRpbWUoZHQsIG9wdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gVUlDb21tb24uZm9ybWF0TG9jYWxlRGF0ZXRpbWUodmFsdWUsIG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZm9ybWF0VGltZXN0YW1wKHRpbWVzdGFtcCwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgb2Zmc2V0TG9jYWwgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIGxldCBkZWx0YU9mZnNldCA9IChvZmZzZXRMb2NhbCAtIG9mZnNldCkgKiA2MCAqIDEwMDA7XG4gICAgICAgIGxldCBsb2NhbERhdGVUaW1lID0gbmV3IERhdGUocGFyc2VJbnQodGltZXN0YW1wKSAtIGRlbHRhT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZVRpbWUudG9Mb2NhbGVTdHJpbmcod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIFRJTUUgPSB7XG4gICAgICAgIFNFQ09ORFM6IFtcItGB0LXQutGD0L3QtNGDXCIsIFwi0YHQtdC60YPQvdC00YtcIiwgXCLRgdC10LrRg9C90LRcIl0sXG4gICAgICAgIE1JTlVURVM6IFtcItC80LjQvdGD0YLRg1wiLCBcItC80LjQvdGD0YLRi1wiLCBcItC80LjQvdGD0YJcIl0sXG4gICAgICAgIEhPVVJTOiBbXCLRh9Cw0YFcIiwgXCLRh9Cw0YHQsFwiLCBcItGH0LDRgdC+0LJcIl0sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWNsT2ZOdW0obiwgdGV4dF9mb3Jtcykge1xuICAgICAgICBuID0gTWF0aC5hYnMobikgJSAxMDA7XG4gICAgICAgIGxldCBuMSA9IG4gJSAxMDtcbiAgICAgICAgaWYgKG4gPiAxMCAmJiBuIDwgMjApIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0X2Zvcm1zWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA+IDEgJiYgbjEgPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dF9mb3Jtc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjEgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRfZm9ybXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRfZm9ybXNbMl07XG4gICAgfVxuXG4gICAgc3RhdGljIGh1bWFuaXplZFRpbWVEaWZmKGRhdGUgLyogdW5peCB0aW1lICovKSB7XG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBsZXQgc2VjID0gTWF0aC5yb3VuZCgoY3VycmVudFRpbWUgLSBkYXRlKSAvIDEwMDApO1xuICAgICAgICBsZXQgdW5pdDtcbiAgICAgICAgaWYgKHNlYyA8IDYwKSB7XG4gICAgICAgICAgICB1bml0ID0gdGhpcy5kZWNsT2ZOdW0oc2VjLCB0aGlzLlRJTUUuU0VDT05EUyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7c2VjfSAke3VuaXR9INC90LDQt9Cw0LRgO1xuICAgICAgICB9IGVsc2UgaWYgKHNlYyA8IDM2MDApIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSBNYXRoLmZsb29yKHNlYyAvIDYwKTtcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmRlY2xPZk51bShtaW4sIHRoaXMuVElNRS5NSU5VVEVTKTtcbiAgICAgICAgICAgIHJldHVybiBgJHttaW59ICR7dW5pdH0g0L3QsNC30LDQtGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKHNlYyAvICg2MCAqIDYwKSk7XG4gICAgICAgICAgICB1bml0ID0gdGhpcy5kZWNsT2ZOdW0oaG91cnMsIHRoaXMuVElNRS5IT1VSUyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7aG91cnN9ICR7dW5pdH0g0L3QsNC30LDQtGA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgc3R5bGVzT2JqZWN0VG9TdHJpbmcoc3R5bGVzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcylcbiAgICAgICAgICAgICAgICAubWFwKChwcm9wKSA9PiBgJHtwcm9wfTogJHtzdHlsZXMucHJvcH07YClcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVSUNvbW1vbjtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdGFiSW5kZXg9MF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGljayA9ICgpID0+IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IDAsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBvbktleVVwID1cbiAgICAgICAgb25rZXl1cCA/PyAob25jbGljayA/IFVJQ29tbW9uLm9ubHlPbkVudGVyKG9uY2xpY2spIDogdW5kZWZpbmVkKTtcbjwvc2NyaXB0PlxuXG48ZGl2IHtpZH0gY2xhc3M9XCJibG9jayB7Y2xhc3Nlc31cIiB7b25jbGlja30gb25rZXl1cD17b25LZXlVcH0ge3JvbGV9IHt0YWJJbmRleH0+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgaW1wb3J0IFVJQmxvY2sgZnJvbSBcIi4vdWkuYmxvY2suc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdGFiSW5kZXg9MF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGljayA9ICgpID0+IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IDAsXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBERUZBVUxUX0NMQVNTRVNfSU5ORVIgPSBcImJsb2NrLWlubmVyLXZlcnRpY2FsXCI7XG5cbiAgICBsZXQgY2xhc3Nlc0lubmVyID0gJHN0YXRlKERFRkFVTFRfQ0xBU1NFU19JTk5FUik7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2xhc3Nlc0lubmVyID0gYGJsb2NrLWlubmVyLXZlcnRpY2FsICR7Y2xhc3Nlc31gO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPFVJQmxvY2tcbiAgICB7aWR9XG4gICAgY2xhc3M9e2NsYXNzZXNJbm5lcn1cbiAgICB7b25jbGlja31cbiAgICBvbmtleXVwPXtvbktleVVwfVxuICAgIHtyb2xlfVxuICAgIHt0YWJJbmRleH1cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L1VJQmxvY2s+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2sgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSAwLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPGRpdiB7aWR9IGNsYXNzPVwiYm94IHtjbGFzc2VzfSBcIiB7b25jbGlja30gb25rZXl1cD17b25LZXlVcH0ge3JvbGV9IHt0YWJJbmRleH0+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2sgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSAwLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIHtpZH1cbiAgICBjbGFzcz1cImNvbnRlbnQge2NsYXNzZXN9XCJcbiAgICB7b25jbGlja31cbiAgICBvbmtleXVwPXtvbktleVVwfVxuICAgIHtyb2xlfVxuICAgIHt0YWJJbmRleH1cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIi8qKiBAaW1wb3J0IHsgUmVhZGFibGUsIFN0YXJ0U3RvcE5vdGlmaWVyLCBTdWJzY3JpYmVyLCBVbnN1YnNjcmliZXIsIFVwZGF0ZXIsIFdyaXRhYmxlIH0gZnJvbSAnLi4vcHVibGljLmpzJyAqL1xuLyoqIEBpbXBvcnQgeyBTdG9yZXMsIFN0b3Jlc1ZhbHVlcywgU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlIH0gZnJvbSAnLi4vcHJpdmF0ZS5qcycgKi9cbmltcG9ydCB7IG5vb3AsIHJ1bl9hbGwgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgc2FmZV9ub3RfZXF1YWwgfSBmcm9tICcuLi8uLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmVfdG9fc3RvcmUgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxhbnk+IHwgYW55Pn1cbiAqL1xuY29uc3Qgc3Vic2NyaWJlcl9xdWV1ZSA9IFtdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxuXHR9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7V3JpdGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG5cdC8qKiBAdHlwZSB7VW5zdWJzY3JpYmVyIHwgbnVsbH0gKi9cblx0bGV0IHN0b3AgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7U2V0PFN1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPj59ICovXG5cdGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcblx0XHRpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0aWYgKHN0b3ApIHtcblx0XHRcdFx0Ly8gc3RvcmUgaXMgcmVhZHlcblx0XHRcdFx0Y29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcblx0XHRcdFx0XHRzdWJzY3JpYmVyWzFdKCk7XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuX3F1ZXVlKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VXBkYXRlcjxUPn0gZm5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGUoZm4pIHtcblx0XHRzZXQoZm4oLyoqIEB0eXBlIHtUfSAqLyAodmFsdWUpKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtTdWJzY3JpYmVyPFQ+fSBydW5cblx0ICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbaW52YWxpZGF0ZV1cblx0ICogQHJldHVybnMge1Vuc3Vic2NyaWJlcn1cblx0ICovXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShydW4sIGludmFsaWRhdGUgPSBub29wKSB7XG5cdFx0LyoqIEB0eXBlIHtTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD59ICovXG5cdFx0Y29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuXHRcdHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuXHRcdFx0c3RvcCA9IHN0YXJ0KHNldCwgdXBkYXRlKSB8fCBub29wO1xuXHRcdH1cblx0XHRydW4oLyoqIEB0eXBlIHtUfSAqLyAodmFsdWUpKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0c3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXHRcdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDAgJiYgc3RvcCkge1xuXHRcdFx0XHRzdG9wKCk7XG5cdFx0XHRcdHN0b3AgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xufVxuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFN0b3Jlc1ZhbHVlczxTPiwgc2V0OiAodmFsdWU6IFQpID0+IHZvaWQsIHVwZGF0ZTogKGZuOiBVcGRhdGVyPFQ+KSA9PiB2b2lkKSA9PiBVbnN1YnNjcmliZXIgfCB2b2lkfSBmblxuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV1cbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7U3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBTdG9yZXNWYWx1ZXM8Uz4pID0+IFR9IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG4vKipcbiAqIEB0ZW1wbGF0ZSB7U3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChzdG9yZXMsIGZuLCBpbml0aWFsX3ZhbHVlKSB7XG5cdGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG5cdC8qKiBAdHlwZSB7QXJyYXk8UmVhZGFibGU8YW55Pj59ICovXG5cdGNvbnN0IHN0b3Jlc19hcnJheSA9IHNpbmdsZSA/IFtzdG9yZXNdIDogc3RvcmVzO1xuXHRpZiAoIXN0b3Jlc19hcnJheS5ldmVyeShCb29sZWFuKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZGVyaXZlZCgpIGV4cGVjdHMgc3RvcmVzIGFzIGlucHV0LCBnb3QgYSBmYWxzeSB2YWx1ZScpO1xuXHR9XG5cdGNvbnN0IGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuXHRyZXR1cm4gcmVhZGFibGUoaW5pdGlhbF92YWx1ZSwgKHNldCwgdXBkYXRlKSA9PiB7XG5cdFx0bGV0IHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1RbXX0gKi9cblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRsZXQgcGVuZGluZyA9IDA7XG5cdFx0bGV0IGNsZWFudXAgPSBub29wO1xuXHRcdGNvbnN0IHN5bmMgPSAoKSA9PiB7XG5cdFx0XHRpZiAocGVuZGluZykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBmbihzaW5nbGUgPyB2YWx1ZXNbMF0gOiB2YWx1ZXMsIHNldCwgdXBkYXRlKTtcblx0XHRcdGlmIChhdXRvKSB7XG5cdFx0XHRcdHNldChyZXN1bHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xlYW51cCA9IHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgPyByZXN1bHQgOiBub29wO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgdW5zdWJzY3JpYmVycyA9IHN0b3Jlc19hcnJheS5tYXAoKHN0b3JlLCBpKSA9PlxuXHRcdFx0c3Vic2NyaWJlX3RvX3N0b3JlKFxuXHRcdFx0XHRzdG9yZSxcblx0XHRcdFx0KHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dmFsdWVzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0cGVuZGluZyAmPSB+KDEgPDwgaSk7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0ZWQpIHtcblx0XHRcdFx0XHRcdHN5bmMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCgpID0+IHtcblx0XHRcdFx0XHRwZW5kaW5nIHw9IDEgPDwgaTtcblx0XHRcdFx0fVxuXHRcdFx0KVxuXHRcdCk7XG5cdFx0c3RhcnRlZCA9IHRydWU7XG5cdFx0c3luYygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuXHRcdFx0cnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdC8vIFdlIG5lZWQgdG8gc2V0IHRoaXMgdG8gZmFsc2UgYmVjYXVzZSBjYWxsYmFja3MgY2FuIHN0aWxsIGhhcHBlbiBkZXNwaXRlIGhhdmluZyB1bnN1YnNjcmliZWQ6XG5cdFx0XHQvLyBDYWxsYmFja3MgbWlnaHQgYWxyZWFkeSBiZSBwbGFjZWQgaW4gdGhlIHF1ZXVlIHdoaWNoIGRvZXNuJ3Qga25vdyBpdCBzaG91bGQgbm8gbG9uZ2VyXG5cdFx0XHQvLyBpbnZva2UgdGhpcyBkZXJpdmVkIHN0b3JlLlxuXHRcdFx0c3RhcnRlZCA9IGZhbHNlO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RvcmUgYW5kIHJldHVybnMgYSBuZXcgb25lIGRlcml2ZWQgZnJvbSB0aGUgb2xkIG9uZSB0aGF0IGlzIHJlYWRhYmxlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+fSBzdG9yZSAgLSBzdG9yZSB0byBtYWtlIHJlYWRvbmx5XG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkb25seShzdG9yZSkge1xuXHRyZXR1cm4ge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBpIHN1c3BlY3QgdGhlIGJpbmQgaXMgdW5uZWNlc3Nhcnlcblx0XHRzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZS5iaW5kKHN0b3JlKVxuXHR9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UmVhZGFibGU8VD59IHN0b3JlXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzdG9yZSkge1xuXHRsZXQgdmFsdWU7XG5cdHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgKF8pID0+ICh2YWx1ZSA9IF8pKSgpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiB2YWx1ZTtcbn1cbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5mdW5jdGlvbiBpbml0RGljdCh0YXJnZXQgPSB7fSkge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCguLi5hcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbGUoKSB7XG4gICAgY29uc3QgeyBzdWJzY3JpYmUsIHNldCwgdXBkYXRlIH0gPSB3cml0YWJsZShpbml0RGljdCgpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgc2V0OiAodmFsKSA9PiB7XG4gICAgICAgICAgICBzZXQoaW5pdERpY3QodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiBzZXQoaW5pdERpY3QoKSksXG4gICAgfTtcbn1cblxuY29uc3QgTE9DQUxFID0gY3JlYXRlTG9jYWxlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IExPQ0FMRTtcbiIsIi8qIVxuICogRXZlbnRFbWl0dGVyIHY1LjIuOSAtIGdpdC5pby9lZVxuICogVW5saWNlbnNlIC0gaHR0cDovL3VubGljZW5zZS5vcmcvXG4gKiBPbGl2ZXIgQ2FsZHdlbGwgLSBodHRwczovL29saS5tZS51ay9cbiAqIEBwcmVzZXJ2ZVxuICovXG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnRzLlxuICAgICAqIENhbiBiZSBleHRlbmRlZCB0byBwcm92aWRlIGV2ZW50IGZ1bmN0aW9uYWxpdHkgaW4gb3RoZXIgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBFdmVudEVtaXR0ZXIgTWFuYWdlcyBldmVudCByZWdpc3RlcmluZyBhbmQgZW1pdHRpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cblxuICAgIC8vIFNob3J0Y3V0cyB0byBpbXByb3ZlIHNwZWVkIGFuZCBzaXplXG4gICAgdmFyIHByb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcbiAgICB2YXIgb3JpZ2luYWxHbG9iYWxWYWx1ZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyO1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50IGluIGl0cyBzdG9yYWdlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBsaXN0ZW5lcnMgQXJyYXkgb2YgbGlzdGVuZXJzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBsb29rIGZvci5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIsIC0xIGlmIG5vdCBmb3VuZFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBhIG1ldGhvZCB3aGlsZSBrZWVwaW5nIHRoZSBjb250ZXh0IGNvcnJlY3QsIHRvIGFsbG93IGZvciBvdmVyd3JpdGluZyBvZiB0YXJnZXQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhcmdldCBtZXRob2QuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBhbGlhc2VkIG1ldGhvZFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFsaWFzQ2xvc3VyZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogV2lsbCBpbml0aWFsaXNlIHRoZSBldmVudCBvYmplY3QgYW5kIGxpc3RlbmVyIGFycmF5cyBpZiByZXF1aXJlZC5cbiAgICAgKiBXaWxsIHJldHVybiBhbiBvYmplY3QgaWYgeW91IHVzZSBhIHJlZ2V4IHNlYXJjaC4gVGhlIG9iamVjdCBjb250YWlucyBrZXlzIGZvciBlYWNoIG1hdGNoZWQgZXZlbnQuIFNvIC9iYVtyel0vIG1pZ2h0IHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBiYXIgYW5kIGJhei4gQnV0IG9ubHkgaWYgeW91IGhhdmUgZWl0aGVyIGRlZmluZWQgdGhlbSB3aXRoIGRlZmluZUV2ZW50IG9yIGFkZGVkIHNvbWUgbGlzdGVuZXJzIHRvIHRoZW0uXG4gICAgICogRWFjaCBwcm9wZXJ0eSBpbiB0aGUgb2JqZWN0IHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb25bXXxPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcm90by5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIC8vIFJldHVybiBhIGNvbmNhdGVuYXRlZCBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgZXZlbnRzIGlmXG4gICAgICAgIC8vIHRoZSBzZWxlY3RvciBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgICAgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2tleV0gPSBldmVudHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGV2ZW50c1tldnRdIHx8IChldmVudHNbZXZ0XSA9IFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IG9mIGxpc3RlbmVyIG9iamVjdHMgYW5kIGZsYXR0ZW5zIGl0IGludG8gYSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGxpc3RlbmVycyBSYXcgbGlzdGVuZXIgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfSBKdXN0IHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgcHJvdG8uZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uIGZsYXR0ZW5MaXN0ZW5lcnMobGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBmbGF0TGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZsYXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZsYXRMaXN0ZW5lcnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHJlcXVlc3RlZCBsaXN0ZW5lcnMgdmlhIGdldExpc3RlbmVycyBidXQgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSByZXN1bHRzIGluc2lkZSBhbiBvYmplY3QuIFRoaXMgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UgYnV0IG90aGVycyBtYXkgZmluZCBpdCB1c2VmdWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgYW4gZXZlbnQgaW4gYW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHByb3RvLmdldExpc3RlbmVyc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuICAgICAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgcmVzcG9uc2VbZXZ0XSA9IGxpc3RlbmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZSB8fCBsaXN0ZW5lcnM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRMaXN0ZW5lciAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyB8fCBsaXN0ZW5lciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lciAmJiB0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZExpc3RlbmVyKGxpc3RlbmVyLmxpc3RlbmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBUaGUgbGlzdGVuZXIgd2lsbCBub3QgYmUgYWRkZWQgaWYgaXQgaXMgYSBkdXBsaWNhdGUuXG4gICAgICogSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBjYWxsZWQuXG4gICAgICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUgdGhlbiB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIWlzVmFsaWRMaXN0ZW5lcihsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGxpc3RlbmVySXNXcmFwcGVkID0gdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JztcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVySXNXcmFwcGVkID8gbGlzdGVuZXIgOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBhZGRMaXN0ZW5lclxuICAgICAqL1xuICAgIHByb3RvLm9uID0gYWxpYXMoJ2FkZExpc3RlbmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBTZW1pLWFsaWFzIG9mIGFkZExpc3RlbmVyLiBJdCB3aWxsIGFkZCBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciBpdHMgZmlyc3QgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5hZGRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRPbmNlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldnQsIHtcbiAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGFkZE9uY2VMaXN0ZW5lci5cbiAgICAgKi9cbiAgICBwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhbiBldmVudCBuYW1lLiBUaGlzIGlzIHJlcXVpcmVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHJlZ2V4IHRvIGFkZCBhIGxpc3RlbmVyIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBJZiB5b3UgZG9uJ3QgZG8gdGhpcyB0aGVuIGhvdyBkbyB5b3UgZXhwZWN0IGl0IHRvIGtub3cgd2hhdCBldmVudCB0byBhZGQgdG8/IFNob3VsZCBpdCBqdXN0IGFkZCB0byBldmVyeSBwb3NzaWJsZSBtYXRjaCBmb3IgYSByZWdleD8gTm8uIFRoYXQgaXMgc2NhcnkgYW5kIGJhZC5cbiAgICAgKiBZb3UgbmVlZCB0byB0ZWxsIGl0IHdoYXQgZXZlbnQgbmFtZXMgc2hvdWxkIGJlIG1hdGNoZWQgYnkgYSByZWdleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gY3JlYXRlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gZGVmaW5lRXZlbnQoZXZ0KSB7XG4gICAgICAgIHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGRlZmluZUV2ZW50IHRvIGRlZmluZSBtdWx0aXBsZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBldnRzIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRlZmluZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5kZWZpbmVFdmVudHMgPSBmdW5jdGlvbiBkZWZpbmVFdmVudHMoZXZ0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lRXZlbnQoZXZ0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogV2hlbiBwYXNzZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUsIGl0IHdpbGwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiByZW1vdmVMaXN0ZW5lclxuICAgICAqL1xuICAgIHByb3RvLm9mZiA9IGFsaWFzKCdyZW1vdmVMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBmaXJzdCBhcmd1bWVudCB5b3UgY2FuIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYWRkIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqIFllYWgsIHRoaXMgZnVuY3Rpb24gZG9lcyBxdWl0ZSBhIGJpdC4gVGhhdCdzIHByb2JhYmx5IGEgYmFkIHRoaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnMoZmFsc2UsIGV2dCwgbGlzdGVuZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBmaXJzdCBhcmd1bWVudCB5b3UgY2FuIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIHJlbW92ZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKHRydWUsIGV2dCwgbGlzdGVuZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRWRpdHMgbGlzdGVuZXJzIGluIGJ1bGsuIFRoZSBhZGRMaXN0ZW5lcnMgYW5kIHJlbW92ZUxpc3RlbmVycyBtZXRob2RzIGJvdGggdXNlIHRoaXMgdG8gZG8gdGhlaXIgam9iLiBZb3Ugc2hvdWxkIHJlYWxseSB1c2UgdGhvc2UgaW5zdGVhZCwgdGhpcyBpcyBhIGxpdHRsZSBsb3dlciBsZXZlbC5cbiAgICAgKiBUaGUgZmlyc3QgYXJndW1lbnQgd2lsbCBkZXRlcm1pbmUgaWYgdGhlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCAodHJ1ZSkgb3IgYWRkZWQgKGZhbHNlKS5cbiAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC9yZW1vdmVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hbmlwdWxhdGUgdGhlIGxpc3RlbmVycyBvZiBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSBUcnVlIGlmIHlvdSB3YW50IHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGZhbHNlIGlmIHlvdSB3YW50IHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC9yZW1vdmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIG1hbmlwdWxhdGVMaXN0ZW5lcnMocmVtb3ZlLCBldnQsIGxpc3RlbmVycykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgc2luZ2xlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lciA6IHRoaXMuYWRkTGlzdGVuZXI7XG4gICAgICAgIHZhciBtdWx0aXBsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXJzIDogdGhpcy5hZGRMaXN0ZW5lcnM7XG5cbiAgICAgICAgLy8gSWYgZXZ0IGlzIGFuIG9iamVjdCB0aGVuIHBhc3MgZWFjaCBvZiBpdHMgcHJvcGVydGllcyB0byB0aGlzIG1ldGhvZFxuICAgICAgICBpZiAodHlwZW9mIGV2dCA9PT0gJ29iamVjdCcgJiYgIShldnQgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAodmFsdWUgPSBldnRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIHNpbmdsZSBsaXN0ZW5lciBzdHJhaWdodCB0aHJvdWdoIHRvIHRoZSBzaW5ndWxhciBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHBhc3MgYmFjayB0byB0aGUgbXVsdGlwbGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU28gZXZ0IG11c3QgYmUgYSBzdHJpbmdcbiAgICAgICAgICAgIC8vIEFuZCBsaXN0ZW5lcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBsaXN0ZW5lcnNcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBpdCBhbmQgcGFzcyBlYWNoIG9uZSB0byB0aGUgbXVsdGlwbGUgbWV0aG9kXG4gICAgICAgICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBzaW5nbGUuY2FsbCh0aGlzLCBldnQsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGFuIGV2ZW50IHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICogVGhhdCBtZWFucyBldmVyeSBldmVudCB3aWxsIGJlIGVtcHRpZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWdleCB0byByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBbZXZ0XSBPcHRpb25hbCBuYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuIFdpbGwgcmVtb3ZlIGZyb20gZXZlcnkgZXZlbnQgaWYgbm90IHBhc3NlZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGV2dCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBldnQ7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAvLyBSZW1vdmUgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIGV2dFxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW2V2dF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgcmVnZXguXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gYWxsIGV2ZW50c1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiByZW1vdmVFdmVudC5cbiAgICAgKlxuICAgICAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gYWxpYXMoJ3JlbW92ZUV2ZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBvZiB5b3VyIGNob2ljZS5cbiAgICAgKiBXaGVuIGVtaXR0ZWQsIGV2ZXJ5IGxpc3RlbmVyIGF0dGFjaGVkIHRvIHRoYXQgZXZlbnQgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKiBJZiB5b3UgcGFzcyB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYXJyYXkgdGhlbiB0aG9zZSBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgdG8gZXZlcnkgbGlzdGVuZXIgdXBvbiBleGVjdXRpb24uXG4gICAgICogQmVjYXVzZSBpdCB1c2VzIGBhcHBseWAsIHlvdXIgYXJyYXkgb2YgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIGlmIHlvdSB3cm90ZSB0aGVtIG91dCBzZXBhcmF0ZWx5LlxuICAgICAqIFNvIHRoZXkgd2lsbCBub3QgYXJyaXZlIHdpdGhpbiB0aGUgYXJyYXkgb24gdGhlIG90aGVyIHNpZGUsIHRoZXkgd2lsbCBiZSBzZXBhcmF0ZS5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gT3B0aW9uYWwgYXJyYXkgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uIGVtaXRFdmVudChldnQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyc01hcCA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGxpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVyc01hcCkge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwW2tleV0uc2xpY2UoMCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCBzaGFsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBlaXRoZXIgd2l0aCBhIGJhc2ljIGNhbGwgb3IgYW4gYXBwbHkgaWYgdGhlcmUgaXMgYW4gYXJncyBhcnJheVxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25jZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbGlzdGVuZXIubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyB8fCBbXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBlbWl0RXZlbnRcbiAgICAgKi9cbiAgICBwcm90by50cmlnZ2VyID0gYWxpYXMoJ2VtaXRFdmVudCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidGx5IGRpZmZlcmVudCBmcm9tIGVtaXRFdmVudCBpbiB0aGF0IGl0IHdpbGwgcGFzcyBpdHMgYXJndW1lbnRzIG9uIHRvIHRoZSBsaXN0ZW5lcnMsIGFzIG9wcG9zZWQgdG8gdGFraW5nIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIG9uLlxuICAgICAqIEFzIHdpdGggZW1pdEV2ZW50LCB5b3UgY2FuIHBhc3MgYSByZWdleCBpbiBwbGFjZSBvZiB0aGUgZXZlbnQgbmFtZSB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLip9IE9wdGlvbmFsIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXRFdmVudChldnQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZiBhXG4gICAgICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBhZnRlciBleGVjdXRpb24uIFRoaXMgdmFsdWUgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnNldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIHNldE9uY2VSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vbmNlUmV0dXJuVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmXG4gICAgICogdGhlIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGlzIG9uZSB0aGVuIGl0IHNob3VsZCBiZSByZW1vdmVkXG4gICAgICogYXV0b21hdGljYWxseS4gSXQgd2lsbCByZXR1cm4gdHJ1ZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KnxCb29sZWFufSBUaGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBmb3Igb3IgdGhlIGRlZmF1bHQsIHRydWUuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX2dldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIF9nZXRPbmNlUmV0dXJuVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KCdfb25jZVJldHVyblZhbHVlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmNlUmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBldmVudHMgb2JqZWN0IGFuZCBjcmVhdGVzIG9uZSBpZiByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGV2ZW50cyBzdG9yYWdlIG9iamVjdC5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gX2dldEV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBnbG9iYWwge0BsaW5rIEV2ZW50RW1pdHRlcn0gdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBOb24gY29uZmxpY3RpbmcgRXZlbnRFbWl0dGVyIGNsYXNzLlxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBvcmlnaW5hbEdsb2JhbFZhbHVlO1xuICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH07XG5cbiAgICAvLyBFeHBvc2UgdGhlIGNsYXNzIGVpdGhlciB2aWEgQU1ELCBDb21tb25KUyBvciB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyl7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgfVxufSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMgfHwge30pKTtcbiIsIi8qXG5cdDpwcm9wZXJ0eS5zdWIxLmZ1bmMoKS5mdW5jUHJvcFxuXHQgPSByZXR1cm4gZnVuY1Byb3Agb2YgZnVuY3Rpb24gcmVzdWx0IG9mIHN1YjEgcHJvcGVydHkgb2YgcHJvcGVydHkgb2Ygb2JqZWN0XG5cdDp7OjpoZWxwZXJWYWx9LnN1YlxuXHQgPSByZXR1cm4gc3ViIHByb3BlcnR5IG9mIG9iamVjdCBwcm9wZXJ0eSB3aXRoIG5hbWUgcmV0cmlldmVkIGZyb20gaGVscGVyVmFsIHByb3BlcnR5IG9mIGhlbHBlcnMgb2JqZWN0XG5cdDp7OjpoZWxwZXJGdW5jKCl9LnN1YlxuXHQ9IHJldHVybiBzdWIgcHJvcGVydHkgb2Ygb2JqZWN0IHByb3BlcnR5IHdpdGggbmFtZSByZXRyaWV2ZWQgZnJvbSBoZWxwZXJWYWwgZnVuY3Rpb24gcmVzdWx0IG9mIGhlbHBlcnMgb2JqZWN0LlxuXHRpZiBoZWxwZXJzRnVueCByZXR1cm4gJ2NhcicgdGhlbiBzb3VyY2UgcGF0aCBiZWNvbWVzIDpjYXIuc3ViXG5cbiovXG5cbmNvbnN0IFNVQl9QQVRIX1NUQVJUID0gXCJ7XCIsXG4gICAgU1VCX1BBVEhfRU5EID0gXCJ9XCIsXG4gICAgUEFUSF9TUExJVCA9IFwiLlwiLFxuICAgIFBBVEhfU1RBUlRfT0JKRUNUID0gXCI6XCIsXG4gICAgUEFUSF9TVEFSVF9IRUxQRVJTID0gXCI6OlwiLFxuICAgIEZVTkNUSU9OX01BUktFUiA9IFwiKClcIixcbiAgICBNQVhfREVFUCA9IDEwO1xuXG4vKipcbiAqIFNldCBvZiB0b29scyB0byB1c2Ugbm90UGF0aCBwcm9wZXJ0eSBhY2Nlc3Mgbm90YXRpb25cbiAqIDogaXMgZm9yIGl0ZW1cbiAqIDo6IGlzIGZvciBoZWxwZXJzXG4gKiB7fSBzdWJwYXRoXG4gKiAuIHBhdGggc3BsaXR0ZXJcbiAqICgpIGZ1bmN0aW9uIGFuZCBzaG91bGQgYmUgZXhlY3V0ZWQgd2l0aCBwYXJhbXMgKGl0ZW0sIGhlbHBlciB8IHVuZGVmaW5lZClcbiAqIHN1Yi1wYXRocyB3aWxsIGJlIHBhcnNlZCBhbmQgcmVwbGFjZWQgYnkgcmVzdWx0cyBpbiBzb3VyY2UgcGF0aFxuICovXG5jbGFzcyBub3RQYXRoIHtcbiAgICBzdGF0aWMgZ2V0IFNVQl9QQVRIX1NUQVJUKCkge1xuICAgICAgICByZXR1cm4gU1VCX1BBVEhfU1RBUlQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgU1VCX1BBVEhfRU5EKCkge1xuICAgICAgICByZXR1cm4gU1VCX1BBVEhfRU5EO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFBBVEhfU1BMSVQoKSB7XG4gICAgICAgIHJldHVybiBQQVRIX1NQTElUO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFBBVEhfU1RBUlRfT0JKRUNUKCkge1xuICAgICAgICByZXR1cm4gUEFUSF9TVEFSVF9PQkpFQ1Q7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgUEFUSF9TVEFSVF9IRUxQRVJTKCkge1xuICAgICAgICByZXR1cm4gUEFUSF9TVEFSVF9IRUxQRVJTO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEZVTkNUSU9OX01BUktFUigpIHtcbiAgICAgICAgcmV0dXJuIEZVTkNUSU9OX01BUktFUjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBNQVhfREVFUCgpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9ERUVQO1xuICAgIH1cblxuICAgIC8qXG5cdFx0aW5wdXQgJzp7OjpoZWxwZXJWYWx9LnN1Yidcblx0XHRyZXR1cm4gOjpoZWxwZXJWYWxcblx0Ki9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3Qgc3VicGF0aCBpbiBwYXRoXG4gICAgICogaWYgc3VicGF0aCBub3QgY2xvc2VkIHdpbGwgcmV0dXJuIGl0IGFueXdheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggaW4gc3RyaW5nIG5vdGF0aW9uXG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bGx9IHN1YnBhdGggb3IgbnVsbCBpZiBubyBzdWIgcGF0aCB3ZXJlIGZvdW5kXG4gICAgICovXG4gICAgc3RhdGljIGZpbmROZXh0U3ViUGF0aChwYXRoKSB7XG4gICAgICAgIGxldCBzdWJQYXRoID0gXCJcIixcbiAgICAgICAgICAgIGZpbmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gU1VCX1BBVEhfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICBmaW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdWJQYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09IFNVQl9QQVRIX0VORCAmJiBmaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJQYXRoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YlBhdGggKz0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmQgPyBzdWJQYXRoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHN1Yi1wYXRoIGluIHBhcmVudCBwYXRoIGJ5IHBhcnNlZCB2ZXJzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YiBzdWIgcGF0aCB0byByZXBsYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcnNlZCBwYXJzZWQgc3ViIHBhdGhcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhcnNlZCBwYXRoXG4gICAgICovXG5cbiAgICBzdGF0aWMgcmVwbGFjZVN1YlBhdGgocGF0aCwgc3ViLCBwYXJzZWQpIHtcbiAgICAgICAgbGV0IHN1YmYgPSBTVUJfUEFUSF9TVEFSVCArIHN1YiArIFNVQl9QQVRIX0VORCxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAocGF0aC5pbmRleE9mKHN1YmYpID4gLTEgJiYgaSA8IE1BWF9ERUVQKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHN1YmYsIHBhcnNlZCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHBhdGggd2hpbGUgdGhlcmUgYW55IHN1Yi1wYXRoc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHJhdyB1bnBhcnNlZCBwYXRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWxwZXJzIGhlbHBlcnNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHBhcnNlZCBwYXRoXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlU3VicyhwYXRoLCBpdGVtLCBoZWxwZXJzKSB7XG4gICAgICAgIGxldCBzdWJQYXRoID0gdGhpcy5maW5kTmV4dFN1YlBhdGgocGF0aCksXG4gICAgICAgICAgICBzdWJQYXRoUGFyc2VkLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChzdWJQYXRoKSB7XG4gICAgICAgICAgICBzdWJQYXRoUGFyc2VkID0gdGhpcy5nZXRWYWx1ZUJ5UGF0aChcbiAgICAgICAgICAgICAgICBzdWJQYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9IRUxQRVJTKSA+IC0xID8gaGVscGVycyA6IGl0ZW0sXG4gICAgICAgICAgICAgICAgc3ViUGF0aCxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIGhlbHBlcnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5yZXBsYWNlU3ViUGF0aChwYXRoLCBzdWJQYXRoLCBzdWJQYXRoUGFyc2VkKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChpID4gTUFYX0RFRVApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlBhdGggPSB0aGlzLmZpbmROZXh0U3ViUGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gaXRlbSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2hlbHBlcnNdIGhlbHBlcnMgb2JqZWN0XG4gICAgICovXG5cbiAgICBzdGF0aWMgZ2V0KHBhdGgsIGl0ZW0sIGhlbHBlcnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChwYXRoKSB7XG4gICAgICAgICAgICBjYXNlIFBBVEhfU1RBUlRfT0JKRUNUOlxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgY2FzZSBQQVRIX1NUQVJUX0hFTFBFUlM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHRoaXMucGFyc2VTdWJzKHBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUJ5UGF0aChcbiAgICAgICAgICAgIHBhdGguaW5kZXhPZihQQVRIX1NUQVJUX0hFTFBFUlMpID4gLTEgPyBoZWxwZXJzIDogaXRlbSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaGVscGVyc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgcGF0aCBwYXRoIHRvIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICBpdGVtIGl0ZW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICBoZWxwZXJzICAgICAgICAgaGVscGVycyBvYmplY3QgaWYgNCBhcmd1bWVudHMgb3IgYXR0clZhbHVlIGlmIG9ubHkgMyBwcm92aWRlZFxuICAgICAqIEBwYXJhbSB7YW55fSAgICAgW2F0dHJWYWx1ZV0gICAgIHZhbHVlIHdlIHdhbnQgdG8gYXNzaWduXG4gICAgICovXG5cbiAgICBzdGF0aWMgc2V0KHBhdGgsIGl0ZW0sIGhlbHBlcnMsIGF0dHJWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgYXR0clZhbHVlID0gaGVscGVycztcbiAgICAgICAgICAgIGhlbHBlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YlBhdGggPSB0aGlzLmZpbmROZXh0U3ViUGF0aChwYXRoKSxcbiAgICAgICAgICAgIHN1YlBhdGhQYXJzZWQsXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKHN1YlBhdGgpIHtcbiAgICAgICAgICAgIHN1YlBhdGhQYXJzZWQgPSB0aGlzLmdldFZhbHVlQnlQYXRoKFxuICAgICAgICAgICAgICAgIHN1YlBhdGguaW5kZXhPZihQQVRIX1NUQVJUX0hFTFBFUlMpID4gLTEgPyBoZWxwZXJzIDogaXRlbSxcbiAgICAgICAgICAgICAgICBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgaGVscGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLnJlcGxhY2VTdWJQYXRoKHBhdGgsIHN1YlBhdGgsIHN1YlBhdGhQYXJzZWQpO1xuICAgICAgICAgICAgaWYgKGkgPiBNQVhfREVFUCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViUGF0aCA9IHRoaXMuZmluZE5leHRTdWJQYXRoKHBhdGgpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VmFsdWVCeVBhdGgoaXRlbSwgcGF0aCwgYXR0clZhbHVlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXRlbS5pc1JlY29yZCAmJlxuICAgICAgICAgICAgdGhpcy5ub3JtaWxpemVQYXRoKHBhdGgpLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIGl0ZW0uX19pc0FjdGl2ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGl0ZW0udHJpZ2dlcihcImNoYW5nZVwiLCBpdGVtLCBwYXRoLCBhdHRyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRhcmdldCBwcm9wZXJ0eSB0byBudWxsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGhlbHBlcnMgaGVscGVycyBvYmplY3RcbiAgICAgKi9cblxuICAgIHN0YXRpYyB1bnNldChwYXRoLCBpdGVtLCBoZWxwZXJzKSB7XG4gICAgICAgIHRoaXMuc2V0KHBhdGgsIGl0ZW0sIGhlbHBlcnMsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBzdGVwIGtleSwgdHJhbnNmb3JtcyBpdCB0byBlbmQtZm9ybVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGVwIG5vdCBwYXJzZWQgc3RlcCBrZXlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWxwZXIgaGVscGVycyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfSBwYXJzZWQgc3RlcCBrZXlcbiAgICAgKi9cblxuICAgIHN0YXRpYyBwYXJzZVBhdGhTdGVwKHN0ZXAsIGl0ZW0sIGhlbHBlcikge1xuICAgICAgICBsZXQgclN0ZXAgPSBudWxsO1xuICAgICAgICBpZiAoc3RlcC5pbmRleE9mKFBBVEhfU1RBUlRfSEVMUEVSUykgPT09IDAgJiYgaGVscGVyKSB7XG4gICAgICAgICAgICByU3RlcCA9IHN0ZXAucmVwbGFjZShQQVRIX1NUQVJUX0hFTFBFUlMsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKHJTdGVwLmluZGV4T2YoRlVOQ1RJT05fTUFSS0VSKSA9PT0gclN0ZXAubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgIHJTdGVwID0gclN0ZXAucmVwbGFjZShGVU5DVElPTl9NQVJLRVIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVscGVyLCByU3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcltyU3RlcF0oaXRlbSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJbclN0ZXBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0ZXAuaW5kZXhPZihQQVRIX1NUQVJUX09CSkVDVCkgPT09IDAgJiYgaXRlbSkge1xuICAgICAgICAgICAgICAgIHJTdGVwID0gc3RlcC5yZXBsYWNlKFBBVEhfU1RBUlRfT0JKRUNULCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoclN0ZXAuaW5kZXhPZihGVU5DVElPTl9NQVJLRVIpID09PSByU3RlcC5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJTdGVwID0gclN0ZXAucmVwbGFjZShGVU5DVElPTl9NQVJLRVIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZW0sIHJTdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bclN0ZXBdKGl0ZW0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVtyU3RlcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH1cblxuICAgIC8vOjpmaWVsZE5hbWUucmVzdWx0XG4gICAgLy97fVxuICAgIC8ve2ZpZWxkTmFtZTogJ3RhcmdldFJlY29yZEZpZWxkJ31cbiAgICAvLy8vWyd0YXJnZXRSZWNvcmRGaWVsZCcsICdyZXN1bHQnXVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgcGF0aCB3aXRoIHN1YiBwYXRocyB0byBwYXRoIHdpdGhvdXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gcGF0aCBwYXRoIHRvIHRhcmdldCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGhlbHBlciBoZWxwZXIgb2JqZWN0XG4gICAgICogQHJldHVybiB7YXJyYXl9IHBhcnNlZCBwYXRoXG4gICAgICoqL1xuICAgIHN0YXRpYyBwYXJzZVBhdGgocGF0aCwgaXRlbSwgaGVscGVyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoUEFUSF9TUExJVCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoW2ldID0gdGhpcy5wYXJzZVBhdGhTdGVwKHBhdGhbaV0sIGl0ZW0sIGhlbHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBwYXRoIGZyb20gc3RyaW5nIG5vdGF0aW9uIHRvIGFycmF5IG9mIGtleXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gcGF0aCAgaW5wdXQgcGF0aCwgaWYgYXJyYXkgZG9lcyBub3RoaW5nXG4gICAgICogQHJldHVybiB7YXJyYXl9IHBhdGggaW4gYXJyYXkgbm90YXRpb25cbiAgICAgKi9cblxuICAgIHN0YXRpYyBub3JtaWxpemVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHBhdGguaW5kZXhPZihQQVRIX1NUQVJUX09CSkVDVCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoUEFUSF9TVEFSVF9PQkpFQ1QsIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGguc3BsaXQoUEFUSF9TUExJVCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuXHRcdHNtYWxsID0gW1widG9kb1wiXSxcblx0XHRiaWcgPSBbXCJ0b2RvXCIsIFwibGVuZ3RoXCJdXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0Ki9cblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgaWYgZmlyc3QgcGF0aCBpbmNsdWRlcyBzZWNvbmQsIGNvbXBhcmVkIGZyb20gc3RhcnQsXG4gICAgICogbm8gZmxvYXRpbmcgc3RhcnQgcG9zaXRpb24gaW5zaWRlIFsnam9pbicsICdtZSddLCBbJ21lJ11cbiAgICAgKiB3aWxsIHJlc3VsdCBpbiBmYWxzZVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGJpZyB3aGVyZSB3ZSB3aWxsIHNlYXJjaFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHNtYWxsIHdoYXQgd2Ugd2lsbCBzZWFyY2hcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiB3ZSBzdWNjZWVkXG4gICAgICovXG5cbiAgICBzdGF0aWMgaWZGdWxsU3ViUGF0aChiaWcsIHNtYWxsKSB7XG4gICAgICAgIGlmIChiaWcubGVuZ3RoIDwgc21hbGwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBzbWFsbC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgaWYgKHNtYWxsW3RdICE9PSBiaWdbdF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0dGVyIHRocm91Z2ggdGhpcmQgb2JqZWN0XG4gICAgICogUGF0aCBpcyBwYXJzZWQsIG5vIGV2ZW50IHRyaWdnZXJpbmcgZm9yIG5vdFJlY29yZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3Qgb2JqZWN0IHRvIGJlIHVzZWQgYXMgZ2V0dGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IGF0dHJQYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBzdXBwb3J0aW5nIGRhdGFcbiAgICAgKiBAcGFyYW0ge2hlbHBlcnN9IG9iamVjdCAgc3VwcG9ydGluZyBoZWxwZXJzXG4gICAgICovXG5cbiAgICBzdGF0aWMgZ2V0VmFsdWVCeVBhdGgob2JqZWN0LCBhdHRyUGF0aCwgaXRlbSwgaGVscGVycykge1xuICAgICAgICBhdHRyUGF0aCA9IHRoaXMubm9ybWlsaXplUGF0aChhdHRyUGF0aCk7XG4gICAgICAgIGxldCBhdHRyTmFtZSA9IGF0dHJQYXRoLnNoaWZ0KCksXG4gICAgICAgICAgICBpc0Z1bmN0aW9uID0gYXR0ck5hbWUuaW5kZXhPZihGVU5DVElPTl9NQVJLRVIpID4gLTE7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHJOYW1lLnJlcGxhY2UoRlVOQ1RJT05fTUFSS0VSLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqZWN0ID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmplY3RbYXR0ck5hbWVdICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBvYmplY3RbYXR0ck5hbWVdICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgbGV0IG5ld09iaiA9IGlzRnVuY3Rpb25cbiAgICAgICAgICAgICAgICA/IG9iamVjdFthdHRyTmFtZV0oe1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgaGVscGVycyxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBvYmplY3RbYXR0ck5hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHJQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUJ5UGF0aChuZXdPYmosIGF0dHJQYXRoLCBpdGVtLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR0ZXIgdGhyb3VnaCB0aGlyZCBvYmplY3RcbiAgICAgKiBQYXRoIGlzIHBhcnNlZCwgbm8gZXZlbnQgdHJpZ2dlcmluZyBmb3Igbm90UmVjb3JkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBvYmplY3QgdG8gYmUgbW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gYXR0clBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7YW55fSBhdHRyVmFsdWUgIHZhbHVlIHRvIGFzc2lnblxuICAgICAqL1xuXG4gICAgc3RhdGljIHNldFZhbHVlQnlQYXRoKG9iamVjdCwgYXR0clBhdGgsIGF0dHJWYWx1ZSkge1xuICAgICAgICBhdHRyUGF0aCA9IHRoaXMubm9ybWlsaXplUGF0aChhdHRyUGF0aCk7XG4gICAgICAgIGxldCBhdHRyTmFtZSA9IGF0dHJQYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChhdHRyUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdFthdHRyTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVCeVBhdGgob2JqZWN0W2F0dHJOYW1lXSwgYXR0clBhdGgsIGF0dHJWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3RbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSm9pbnMgcGFzc2VkIGluIHN0cmluZ3Mgd2l0aCBQQVRIX1NQTElUXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3VtZW50cyBwYXRoIHRvIGJlIGdsdWVkXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBjb21wb3NpdGUgcGF0aFxuICAgICAqL1xuXG4gICAgc3RhdGljIGpvaW4oKSB7XG4gICAgICAgIGxldCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3Muam9pbihQQVRIX1NQTElUKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm90UGF0aDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvaW5kZXguanMnKTtcbiIsIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG4vKlxuaHR0cHM6Ly9naXRodWIuY29tL1RlaFNocmlrZS9pcy1tZXJnZWFibGUtb2JqZWN0XG5cbkluY2x1ZGVkIGZvciBjb252aW5pZW5jZSBvbmx5LiBBbGwgcmlnaHRzIGJlbG9uZ3MgdG8gdGhlaXIgYXV0aG9ycyBhbmQgZXRjLlxuc3RhcnQgb2YgbXkgY29kZSBtYXJrZWQuXG5cbiovXG5cbmxldCBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkgJiYgIWlzU3BlY2lhbCh2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuICAgIHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBzdHJpbmdWYWx1ZSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIiB8fFxuICAgICAgICBzdHJpbmdWYWx1ZSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgfHxcbiAgICAgICAgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG4gICAgKTtcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIikgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbi8qXG5odHRwczovL2dpdGh1Yi5jb20vS3lsZUFNYXRoZXdzL2RlZXBtZXJnZVxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSAyMDEyIE5pY2hvbGFzIEZpc2hlclxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fTtcbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIGNvbnN0IGNsb25lID0gIW9wdGlvbnNBcmd1bWVudCB8fCBvcHRpb25zQXJndW1lbnQuY2xvbmUgIT09IGZhbHNlO1xuXG4gICAgcmV0dXJuIGNsb25lICYmIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKVxuICAgICAgICA/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zQXJndW1lbnQpXG4gICAgICAgIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0ge307XG4gICAgaWYgKGlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSxcbiAgICAgICAgICAgICAgICBvcHRpb25zQXJndW1lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSB8fCAhdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgICAgICBvcHRpb25zQXJndW1lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gZGVlcG1lcmdlKFxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldLFxuICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNBcmd1bWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICBjb25zdCBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNBcmd1bWVudCB8fCB7XG4gICAgICAgIGFycmF5TWVyZ2U6IGRlZmF1bHRBcnJheU1lcmdlLFxuICAgIH07XG4gICAgY29uc3Qgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cbiAgICBpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcbiAgICAgICAgY29uc3QgYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcbiAgICAgICAgcmV0dXJuIGFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICByZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfSwge30pO1xufTtcblxuLyoqXG4gKiAgQ29sbGVjdGlvbiBvZiBjb21tb24gZnVuY3Rpb25zXG4gKiAgQGNsYXNzXG4gKi9cbmNsYXNzIG5vdENvbW1vbiB7XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge09iamVjdH0gW01BTkFHRVI9bnVsbF0gIGFwcGxpY2F0aW9uIG1hbmFnZXIsIGluIHNvbWUgY2FzZXMgdXNlZCB0byBjb250cm9sIGluaXRpYWxpemF0aW9uIHJvdXRpbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgTUFOQUdFUiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge3N0cmluZ30gW0xPRz1cImNvbnNvbGVcIl0gIGxvZ2dlciwgd2luZG93W0xPR11cbiAgICAgKi9cbiAgICBzdGF0aWMgTE9HID0gXCJjb25zb2xlXCI7XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge2Z1bmN0aW9ufSBkZWVwTWVyZ2UgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gZGVlcCBtZXJnZXMgb2Ygb2JqZWN0c1xuICAgICAqL1xuICAgIHN0YXRpYyBkZWVwTWVyZ2UgPSBkZWVwbWVyZ2U7XG5cbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7ZnVuY3Rpb259IGlzRXJyb3IgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gb2JqZWN0IHRlc3QsIGlmIGl0J3MgYW4gZXJyb3Igb2JqZWN0IG9yIG5vdFxuICAgICAqIEBwYXJhbSAgIHtvYmplY3R9ICAgIGUgICBvYmplY3QgdG8gdGVzdFxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Vycm9yKGUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciB8fFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgKE9iamVjdC5oYXNPd24oZSwgXCJzdGF0dXNcIikgJiYgZS5zdGF0dXMgPT09IFwiZXJyb3JcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgVFpfT0ZGU0VUID0gKG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDYwKSAqIC0xO1xuICAgIHN0YXRpYyBERVZfRU5WID0gXCJwcm9kdWN0aW9uXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHN0YXRpYyBFTlZfVFlQRSA9IHdpbmRvdy5OT1RfRU5WX1RZUEUgPz8gbm90Q29tbW9uLkRFVl9FTlY7XG4gICAgc3RhdGljIE5PT1AgPSAoKSA9PiB7fTtcblxuICAgIHN0YXRpYyBtdXRlKCkge1xuICAgICAgICBub3RDb21tb24uRU5WX1RZUEUgPSBcInByb2R1Y3Rpb25cIjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFkKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPCAxMCA/IFwiMFwiICsgbiA6IG47XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRvZGF5IERhdGUgb2JqZWN0IHdpdGhvdXQgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHNcbiAgICAgKiAgQHJldHVybiB7bnVtYmVyfSAgY3VycmVudCBkYXRlIHdpdGggMDA6MDA6MDAgaW4gbXMgb2YgdW5peCB0aW1lXG4gICAgICovXG4gICAgc3RhdGljIGdldFRvZGF5RGF0ZSgpIHtcbiAgICAgICAgbGV0IHQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLCB0LmdldE1vbnRoKCksIHQuZ2V0RGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIGZpZWxkIG9mIG5hbWVcbiAgICAgKiAgIEBwYXJhbSAgIHtvYmplY3R9ICAgIG9iaiAgICBzb21lIG9iamVjdFxuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgIG5hbWUgIGZpZWxkIG5hbWVcbiAgICAgKiAgQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgaWYgb2JqZWN0IGNvbnRhaW5zIGZpZWxkIHdpdGggbmFtZVxuICAgICAqKi9cbiAgICBzdGF0aWMgb2JqSGFzKG9iaiwgbmFtZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3QuaGFzT3duKG9iaiwgbmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG9iamVjdCB0byBzZWN1cmUgaXQgZnJvbSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgb2JqICAgICBvcmlnaW5hbCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIGNvcHkgb2Ygb2JqZWN0XG4gICAgICoqL1xuICAgIHN0YXRpYyBjb3B5T2JqKG9iaikge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb2JqZWN0IHRvIHNlY3VyZSBpdCBmcm9tIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICBvYmogICAgIG9yaWdpbmFsIG9iamVjdFxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgY29weSBvZiBvYmplY3RcbiAgICAgKiovXG4gICAgc3RhdGljIHBhcnRDb3B5T2JqKG9iaiwgbGlzdCkge1xuICAgICAgICBsZXQgcGFydE9iaiA9IE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdC5pbmNsdWRlcyhjdXJyKSkge1xuICAgICAgICAgICAgICAgIHByZXZbY3Vycl0gPSBvYmpbY3Vycl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJ0T2JqKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbXBhcmVUd29BcnJheXMoYSwgYikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmXG4gICAgICAgICAgICBhLmV2ZXJ5KChlbGVtZW50LCBpbmRleCkgPT4gZWxlbWVudCA9PT0gYltpbmRleF0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBhcmd1bWVudCB0eXBlIHRvIGJlICdmdW5jdGlvbidcbiAgICAgKiBAcGFyYW0ge2FueX0gIGZ1bmMgICAgcG9zc2libGUgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgaWYgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gICAgICoqL1xuICAgIHN0YXRpYyBpc0Z1bmMoZnVuYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYXJndW1lbnQgaXMgQXN5bmMgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jICB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgaWYgdGhpcyBmdW5jdGlvbiBpcyBjb25zdHJ1Y3RlZCBhcyBBc3luY0Z1bmN0aW9uXG4gICAgICoqL1xuICAgIHN0YXRpYyBpc0FzeW5jKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEV4ZWN1dGVzIG1ldGhvZCBvZiBvYmplY3QgaW4gYXBwcm9wcmlhdGUgd2F5IGluc2lkZSBQcm9taXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgb2JqICAgICBvcmlnaW5hbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lICAgIG1ldGhvZCBuYW1lIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgcGFyYW1zICBhcnJheSBvZiBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICByZXN1bHRzIG9mIG1ldGhvZCBleGVjdXRpb25cbiAgICAgKiovXG4gICAgc3RhdGljIGFzeW5jIGV4ZWN1dGVPYmplY3RGdW5jdGlvbihvYmosIG5hbWUsIHBhcmFtcykge1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBwcm9jID0gbm90UGF0aC5nZXQoXCI6XCIgKyBuYW1lLCBvYmopO1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMocHJvYykpIHtcbiAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzQXN5bmMocHJvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2MoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvYyguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFeGVjdXRlcyBtZXRob2Qgb2Ygb2JqZWN0IGluIGFwcm9wcmlhdGUgd2F5IGluc2lkZSBQcm9taXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgZnJvbSAgICAgb3JpZ2luYWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgdG8gICAgbWV0aG9kIG5hbWUgdG8gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBsaXN0ICBhcnJheSBvZiBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgICAgIHJlc3VsdHMgb2YgbWV0aG9kIGV4ZWN1dGlvblxuICAgICAqKi9cbiAgICBzdGF0aWMgbWFwQmluZChmcm9tLCB0bywgbGlzdCkge1xuICAgICAgICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbVtpdGVtXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdG9baXRlbV0gPSBmcm9tW2l0ZW1dLmJpbmQoZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0NsYXNzKGZuKSB7XG4gICAgICAgIHJldHVybiAvXlxccypjbGFzcy8udGVzdChmbi50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGV0ZWN0VHlwZSh0ZXN0aWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXN0aWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ZXN0aWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzQ2xhc3ModGVzdGllKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNsYXNzXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL9Cf0YDQvtCy0LXRgNC60LAg0Y/QstC70Y/QtdGC0YHRjyDQu9C4INC/0LXRgNC10LzQtdC90L3QsNGPINC80LDRgdGB0LjQstC+0LxcbiAgICBzdGF0aWMgaXNBcnJheShkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PSBcIm9iamVjdFwiICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9jYWxJc29EYXRlKGRhdGUpIHtcbiAgICAgICAgZGF0ZSA9IGRhdGUgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGxvY2FsSXNvU3RyaW5nID1cbiAgICAgICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQoZGF0ZS5nZXREYXRlKCkpICtcbiAgICAgICAgICAgIFwiVFwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQoZGF0ZS5nZXRIb3VycygpKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0TWludXRlcygpKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsSXNvU3RyaW5nO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRUb2RheSgpIHtcbiAgICAgICAgbGV0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGRhdGUgPVxuICAgICAgICAgICAgdG9kYXkuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKHRvZGF5LmdldE1vbnRoKCkgKyAxKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKHRvZGF5LmdldERhdGUoKSk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHN0YXRpYyBiYWNrbG9nID0gW107XG5cbiAgICBzdGF0aWMgYmFja2xvZ0FkZChtc2csIHR5cGUgPSBcImxvZ1wiKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uZ2V0KFwiYmFja2xvZ1wiKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm90Q29tbW9uLmJhY2tsb2cucHVzaCh7IG1zZywgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBkdW1wQmFja2xvZygpIHtcbiAgICAgICAgd2hpbGUgKG5vdENvbW1vbi5iYWNrbG9nLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJvdyA9IG5vdENvbW1vbi5iYWNrbG9nLnNoaWZ0KCk7XG4gICAgICAgICAgICB3aW5kb3dbbm90Q29tbW9uLkxPR11bcm93LnR5cGVdKC4uLnJvdy5tc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGxvZ01zZygpIHtcbiAgICAgICAgbGV0IG5vdyA9IG5vdENvbW1vbi5sb2NhbElzb0RhdGUoKTtcbiAgICAgICAgIFxuICAgICAgICB3aW5kb3dbbm90Q29tbW9uLkxPR10ubG9nKGBbJHtub3d9XTogYCwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgbm90Q29tbW9uLmJhY2tsb2dBZGQoW2BbJHtub3d9XTogYCwgLi4uYXJndW1lbnRzXSwgXCJsb2dcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvZygpIHtcbiAgICAgICAgbm90Q29tbW9uLmxvZ01zZyguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVMb2dnZXIocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2c6IG5vdENvbW1vbi5nZW5Mb2dNc2cocHJlZml4KSxcbiAgICAgICAgICAgIGVycm9yOiBub3RDb21tb24uZ2VuTG9nRXJyb3IocHJlZml4KSxcbiAgICAgICAgICAgIGRlYnVnOiBub3RDb21tb24uZ2VuTG9nRGVidWcocHJlZml4KSxcbiAgICAgICAgICAgIHJlcG9ydDogbm90Q29tbW9uLnJlcG9ydCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvL9CT0LXQvdC10YDQsNGG0LjRjyDQvNC10YLQvtC00LAg0LLRi9Cy0L7QtNCwINGB0L7QvtCx0YnQtdC90LjQuSDQsiDQutC+0L3RgdC+0LvRjCDRgSDRg9C60LDQt9Cw0L3QuNC10Lwg0L/RgNC10YTQuNC60YHQsC5cbiAgICBzdGF0aWMgZ2VuTG9nTXNnKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9ub3QgYXJyb3cgYmMgb2YgYXJndW1lbnRzIHNwZWNpYWwgdmFyIGlzIG5vdCBhdmFpbGFibGUgaW4gYXJyb3cgZnVuY3Rpb25zXG4gICAgICAgICAgICBsZXQgbm93ID0gbm90Q29tbW9uLmxvY2FsSXNvRGF0ZSgpO1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddLmxvZyhgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFxuICAgICAgICAgICAgICAgIFtgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzXSxcbiAgICAgICAgICAgICAgICBcImxvZ1wiXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqINCe0L/RgNC10LTQtdC70Y/QtdGCINGP0LLQu9GP0LXRgtGB0Y8g0LvQuCDQvtC60YDRg9C20LXQvdC40LUg0L7QutGA0YPQttC10L3QuNC10Lwg0YDQsNC30YDQsNCx0L7RgtC60LhcbiAgICAgKiBAcmV0dXJucyAge2Jvb2xlYW59IHRydWUg0LXRgdC70Lgg0Y3RgtC+INC30LDQv9GD0YnQtdC90L4g0LIg0L7QutGA0YPQttC10L3QuNC4INGA0LDQt9GA0LDQsdC+0YLQutC4XG4gICAgICoqL1xuICAgIHN0YXRpYyBpc0RldigpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5FTlZfVFlQRSA9PT0gbm90Q29tbW9uLkRFVl9FTlY7XG4gICAgfVxuXG4gICAgc3RhdGljIGRlYnVnKCkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRGV2KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24ubG9nTXNnKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLk5PT1A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2VuTG9nRGVidWcocHJlZml4KSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNEZXYoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZW5Mb2dNc2cocHJlZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24uTk9PUDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBlcnJvcigpIHtcbiAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy/QpNGD0L3QutGG0LjRjyDQstGL0LLQvtC00LAg0YHQvtC+0LHRidC10L3QuNGPINC+0LEg0L7RiNC40LHQutC1XG4gICAgc3RhdGljIGxvZ0Vycm9yKCkge1xuICAgICAgICBsZXQgbm93ID0gbm90Q29tbW9uLmxvY2FsSXNvRGF0ZSgpO1xuICAgICAgICAgXG4gICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5lcnJvcihgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFtgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50c10sIFwiZXJyb3JcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGdlbkxvZ0Vycm9yKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9kbyBub3QgY2hhbmdlIHRvIGFycm93IGZ1bmN0aW9uLCBiYyBvZiBhcmd1bWVudHNcbiAgICAgICAgICAgIGxldCBub3cgPSBub3RDb21tb24ubG9jYWxJc29EYXRlKCk7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICB3aW5kb3dbbm90Q29tbW9uLkxPR10uZXJyb3IoYFske25vd31dOiAke3ByZWZpeH06OmAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBub3RDb21tb24uYmFja2xvZ0FkZChcbiAgICAgICAgICAgICAgICBbYFske25vd31dOiAke3ByZWZpeH06OmAsIC4uLmFyZ3VtZW50c10sXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyByZXBvcnQoZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmdldEFwcCgpKSB7XG4gICAgICAgICAgICBsZXQgcmVwb3J0ZXIgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0U2VydmljZShcIm5zRXJyb3JSZXBvcnRlclwiKTtcbiAgICAgICAgICAgIGlmIChyZXBvcnRlcikge1xuICAgICAgICAgICAgICAgIHJlcG9ydGVyLnJlcG9ydChlKS5jYXRjaChub3RDb21tb24uZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFub3RDb21tb24uZ2V0KFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHRyYWNlKCkge1xuICAgICAgICBpZiAoIW5vdENvbW1vbi5nZXQoXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBub3RDb21tb24udHJhY2UoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB0cmltQmFja3NsYXNoKHN0cikge1xuICAgICAgICBpZiAoc3RyLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQnVpbGRzIFVSTCB3aXRoIHN0cnVjdHVyZSBsaWtlIHByZWZpeC9tb2R1bGUvbW9kZWwvaWQvYWN0aW9uXG4gICAgICogSWYgc29tZSBwYXJ0IGFic2VudCBvciBzZXQgdG8gZmFsc2UgaXQgd2lsbCBiZSBleGNsdWRlZCBmcm9tIHJlc3VsdFxuICAgICAqICBAcGFyYW0ge29iamVjdH0gdXJsUGFydHNcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFt1cmxQYXJ0cy5wcmVmaXg9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMubW9kdWxlPScnXVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLm1vZGVsPScnXVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLmlkPScnXVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLmFjdGlvbj0nJ11cbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfSAgdXJsIHBhdGhcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRVUkwoXG4gICAgICAgIHsgcHJlZml4LCBtb2R1bGUsIG1vZGVsLCBpZCwgYWN0aW9uIH0gPSB7XG4gICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICBtb2R1bGU6IFwiXCIsXG4gICAgICAgICAgICBtb2RlbDogXCJcIixcbiAgICAgICAgICAgIGlkOiBcIlwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlwiLFxuICAgICAgICB9XG4gICAgKSB7XG4gICAgICAgIGxldCB1cmwgPSBbXCIvXCJdO1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2gocHJlZml4KSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChtb2R1bGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2gobW9kZWwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2goaWQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgdXJsLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5vdENvbW1vbi50cmltQmFja3NsYXNoKGFjdGlvbikpKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB1cmwuZmlsdGVyKChlbCkgPT4gZWwgIT09IFwiXCIpO1xuICAgICAgICByZXR1cm4gdXJsLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLy9nLCBcIi9cIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGNhcGl0YWxpemVGaXJzdExldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG93ZXJGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3RyTGVuZ3RoQ2FwKHN0ciwgTUFYX1RJVExFX0xFTkdUSCA9IDUwLCBQT1NUX0ZJWCA9IFwiLi4uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgc3RyLmxlbmd0aCA+IE1BWF9USVRMRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIE1BWF9USVRMRV9MRU5HVEgpICsgUE9TVF9GSVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVzY2FwZUh0bWwodW5zYWZlKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdGFydEFwcChzdGFydGVyKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHN0YXJ0ZXIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBcHAoKSB7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uZ2V0KFwiYXBwXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHRlbmRBcHBDb25maWcoY29uZiwgY29uZjIpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5kZWVwTWVyZ2UoY29uZiwgY29uZjIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhYnNvcmJNb2R1bGUoKSB7XG4gICAgICAgIGxldCBkZWZhdWx0Q29uZiwgLy9hcHAgb3B0aW9uc1xuICAgICAgICAgICAgbW9kLCAvL21vZHVsZSBvcHRpb25zXG4gICAgICAgICAgICB0YXJnZXRzID0ge307IC8vdmFyaW91cyBjb2xsZWN0aW9uc1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB0YXJnZXRzID0geyAuLi5hcmd1bWVudHNbMF0gfTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbMF0sIFwiZGVmYXVsdENvbmZcIikpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZiA9IGFyZ3VtZW50c1swXS5kZWZhdWx0Q29uZjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0cy5kZWZhdWx0Q29uZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbMF0sIFwibW9kXCIpKSB7XG4gICAgICAgICAgICAgICAgbW9kID0gYXJndW1lbnRzWzBdLm1vZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0cy5tb2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3RDb21tb24ubG9nKFxuICAgICAgICAgICAgICAgIFwiV0FSTklORzogYWJzb3JiTW9kdWxlIGZvcm1hdCBvYnNvbGV0ZWQsIHVzZSBvYmplY3Qge2RlZmF1bHRDb25mLCBtb2QsIHNlcnZpY2VzLCB1aXMsIHdzYywgZXRjfVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdENvbmYgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBtb2QgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnNlcnZpY2VzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cy51aXMgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLndjcyA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1vZCkge1xuICAgICAgICAgICAgLy9hZGQgbWFuaWZlc3QgdG8gb3RoZXJcbiAgICAgICAgICAgIGlmIChwcm9wID09PSBcIm1hbmlmZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZiA9IG5vdENvbW1vbi5leHRlbmRBcHBDb25maWcoXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mLFxuICAgICAgICAgICAgICAgICAgICBtb2QubWFuaWZlc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub3RDb21tb24uZ2V0KGBhYnNvcmIuJHtwcm9wfWApID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldHMsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGBXQVJOSU5HOiBubyBhY2NhbXVsYXRvciBvYmplY3QgcHJvdmlkZWQgZm9yICcke3Byb3B9JyBjb2xsZWN0aW9uYFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3RDb21tb24uZ2V0KGBhYnNvcmIuJHtwcm9wfWApKHRhcmdldHNbcHJvcF0sIG1vZFtwcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AuaW5kZXhPZihcIm5jXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihkZWZhdWx0Q29uZiwgXCJjb250cm9sbGVyc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZi5jb250cm9sbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZi5jb250cm9sbGVyc1twcm9wXSA9IG1vZFtwcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9pbiBjYXNlIG9mIHNvbWUgb3RoZXIgc3R1ZmYgcHJlc2VudGVkLCBpc29sYXRpbmcgaXQgaW4gc3BlY2lhbCB2YXJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHdpbmRvdywgXCJub3RFbnZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubm90RW52ID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB3aW5kb3cubm90RW52W3Byb3BdID0gbW9kW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29uZjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmaW5lSWZOb3RFeGlzdHMob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlZ2lzdHJ5ID0ge307XG5cbiAgICBzdGF0aWMgcmVnaXN0ZXIoa2V5LCB2YWwpIHtcbiAgICAgICAgbm90Q29tbW9uLnJlZ2lzdHJ5W2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldChrZXkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bihub3RDb21tb24ucmVnaXN0cnksIGtleSlcbiAgICAgICAgICAgID8gbm90Q29tbW9uLnJlZ2lzdHJ5W2tleV1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBpdGVtIGluc2lkZSBhcnJheSBmcm9tIG9sZF9pbmRleCB0byBuZXdfaW5kZXhcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRfaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3X2luZGV4XG4gICAgICogQG1lbWJlcm9mIG5vdENvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlSXRlbShhcnJheSwgb2xkX2luZGV4LCBuZXdfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5SYW5nZSA9IChudW0pID0+IG51bSA8IGFycmF5Lmxlbmd0aCAmJiBudW0gPiAtMTtcbiAgICAgICAgaWYgKGluUmFuZ2UobmV3X2luZGV4KSAmJiBpblJhbmdlKG9sZF9pbmRleCkpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShuZXdfaW5kZXgsIDAsIGFycmF5LnNwbGljZShvbGRfaW5kZXgsIDEpWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzdHJpcFByb3h5KG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChvYmouaXNQcm94eSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gQXJyYXkuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24ob2JqLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3RdID0gbm90Q29tbW9uLnN0cmlwUHJveHkob2JqW3RdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBwaXBlKGRhdGEgLyogZmVlZCBkYXRhICovLCBmdW5jcyAvKiBmdW5jdGlvbnMgYXJyYXkgKi8pIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgZm9yIChsZXQgZnVuYyBvZiBmdW5jcykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhyZXN1bHQgfHwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJvZiBub3RDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QVBJKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRNYW5hZ2VyKCk/LmdldEFQSSh0eXBlKSA/PyBudWxsO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRNYW5hZ2VyKHYpIHtcbiAgICAgICAgbm90Q29tbW9uLk1BTkFHRVIgPSB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJvZiBub3RDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5NQU5BR0VSO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgd2FpdChzZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzLCBzZWMgKiAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlZ2lzdGVyV2lkZ2V0RXZlbnRzKGV2ZW50cykge1xuICAgICAgICBpZiAobm90Q29tbW9uLmdldEFwcCgpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5vbihldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIG5hdmlnYXRlKHVybCkge1xuICAgICAgICBub3RDb21tb24uZ2V0QXBwKCkgJiZcbiAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXb3JraW5nKFwicm91dGVyXCIpLm5hdmlnYXRlKHVybCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdCh2YXJpYW50c1NldCwgdmFsdWUsIGRlZikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB2YXJpYW50c1NldCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhcmlhbnRzU2V0ID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXModmFyaWFudHNTZXQsIHZhbHVlKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhcmlhbnRzU2V0W3ZhbHVlXSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdmFyaWFudHNTZXRbdmFsdWVdICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzU2V0W3ZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFic29yYlNlcnZpY2VzKHRhcmdldCwgc3JjKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBzZXJ2IGluIHNyYykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odGFyZ2V0LCBzZXJ2KSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5sb2dFcnJvcihgc2VydmljZXMgcHJvcGVydHkgZHVwbGljYXRpb24gJHtzZXJ2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3NlcnZdID0gc3JjW3NlcnZdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRXU0NsaWVudCh3Y3MsIHdzY05hbWUsIHdzY09wdGlvbnMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFPYmplY3QuaGFzT3duKHdjcywgd3NjTmFtZSkpIHtcbiAgICAgICAgd2NzW3dzY05hbWVdID0ge1xuICAgICAgICAgICAgY29ubmVjdGlvbjoge30sXG4gICAgICAgICAgICByb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICByb3V0ZXM6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3Nlbmdlcjoge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSB3Y3Nbd3NjTmFtZV07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChPYmplY3QuaGFzT3duKHdzY09wdGlvbnMsIFwicm91dGVyXCIpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucy5yb3V0ZXIsIFwicm91dGVzXCIpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByb3V0ZVR5cGUgaW4gd3NjT3B0aW9ucy5yb3V0ZXIucm91dGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bih0YXJnZXQucm91dGVyLnJvdXRlcywgcm91dGVUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucm91dGVyLnJvdXRlc1tyb3V0ZVR5cGVdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LnJvdXRlci5yb3V0ZXNbcm91dGVUeXBlXSwge1xuICAgICAgICAgICAgICAgICAgICAuLi53c2NPcHRpb25zLnJvdXRlci5yb3V0ZXNbcm91dGVUeXBlXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucywgXCJtZXNzZW5nZXJcIikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQubWVzc2VuZ2VyLCB7IC4uLndzY09wdGlvbnMubWVzc2VuZ2VyIH0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucywgXCJjb25uZWN0aW9uXCIpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LmNvbm5lY3Rpb24sIHsgLi4ud3NjT3B0aW9ucy5jb25uZWN0aW9uIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCB0IG9mIFtcIm5hbWVcIiwgXCJnZXRUb2tlblwiLCBcImxvZ2dlclwiLCBcImlkZW50aXR5XCIsIFwiY3JlZGVudGlhbHNcIl0pIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLCB0KSkge1xuICAgICAgICAgICAgdGFyZ2V0W3RdID0gd3NjT3B0aW9uc1t0XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWJzb3JiV1NDKHRhcmdldCwgc3JjKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCB3c0NsaWVudE5hbWUgaW4gc3JjKSB7XG4gICAgICAgICAgICBleHRlbmRXU0NsaWVudCh0YXJnZXQsIHdzQ2xpZW50TmFtZSwgc3JjW3dzQ2xpZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhYnNvcmJVSXModGFyZ2V0LCBzcmMpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IHVpIGluIHNyYykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odGFyZ2V0LCB1aSkpIHtcbiAgICAgICAgICAgICAgICBub3RDb21tb24ubG9nRXJyb3IoYHVpcyBwcm9wZXJ0eSBkdXBsaWNhdGlvbiAke3VpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3VpXSA9IHNyY1t1aV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFic29yYkZpZWxkcyh0YXJnZXQsIHNyYykge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgdWkgaW4gc3JjKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0YXJnZXQsIHVpKSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5sb2dFcnJvcihgZmllbGRzIHByb3BlcnR5IGR1cGxpY2F0aW9uICR7dWl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbdWldID0gc3JjW3VpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLndzY1wiLCBhYnNvcmJXU0MpO1xubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLnNlcnZpY2VzXCIsIGFic29yYlNlcnZpY2VzKTtcbm5vdENvbW1vbi5yZWdpc3RlcihcImFic29yYi51aXNcIiwgYWJzb3JiVUlzKTtcbm5vdENvbW1vbi5yZWdpc3RlcihcImFic29yYi51aXNcIiwgYWJzb3JiRmllbGRzKTtcblxuZXhwb3J0IGRlZmF1bHQgbm90Q29tbW9uO1xuIiwiLyoqXG4gKiBQdXJwb3NlIG9mIHRoaXMgTG9jYWxlIG9iamVjdCBpcyB0aGF0IGl0IHdpbGwgaG9sZCBsaWJyYXJ5IG9mIGxvY2FsaXphdGlvblxuICogdGVtcGxhdGVzIGFuZCBwcm92aWRlIGJhc2ljIGxvY2FsaXphdGlvbiBzZXJ2aWNlIHRvIG90aGVyIG1vZHVsZXNcbiAqKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwid29sZnk4Ny1ldmVudGVtaXR0ZXJcIjtcblxuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vZnJhbWUvY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcblxuaW1wb3J0IExPQ0FMRSBmcm9tIFwiLi9zdG9yZVwiO1xuXG4vKipcbiAqIHN0cmluZ3MgbG9jYWxpemF0aW9uIGFuZCBmb3JtYXRpbmcgbW9kZWxcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBub3RMb2NhbGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTsgLy9kaWN0aW9uYXJ5IG9mIHBocmFzZXNcbiAgICAgICAgdGhpcy5oZWxwZXJzID0ge307IC8vYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIGFuZCBjb25zdGFudHNcbiAgICAgICAgbGV0IGRpY3QgPSB0aGlzLnJlc3RvcmVGcm9tU3RvcmFnZSgpO1xuICAgICAgICBpZiAoZGljdCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoZGljdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgZm9ybWF0IHNob3VsZCBjb21wbHkgbm90UGF0aCBzdGFuZGFydC5cbiAgICAgKiB7cGF0aF90b19hY2Nlc3N9IC0gaXNcbiAgICAgKiA6IC0gaXMgdXNlZCB0byBhY2Nlc3MgdG8gcGFyYW1zXG4gICAgICogOjogLSBpcyB1c2VkIHRvIGFjY2VzcyB0byBoZWxwZXJzXG4gICAgICogV2VsY29tZSwgezp3aGVyZX0hIC0gd2lsbCByZXBsYWNlIHs6d2hlcmV9IHdpdGggY29udGVudCBvZiBwYXJhbXMud2hlcmVcbiAgICAgKiBXZWxjb21lLCB7Ojp3aGVyZX0hIC0gd2lsbCByZXBsYWNlIHs6d2hlcmV9IHdpdGggY29udGVudCBvZiB0aGlzLmhlbHBlcnMud2hlcmVcbiAgICAgKiAoKSAtIGFmdGVyIHBhdGggaXMgdG8gaW52b2tlIGZ1bmN0aW9uIG9mIHRhcmdldCBvYmplY3RcbiAgICAgKiBXZWxjb21lLCB7Ojp3aGVyZSgpfSEgLSB3aWxsIHRyeSB0byBleGVjIHRoaXMuaGVscGVycy53aGVyZShwYXJhbXMsIHVuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0gICAge3N0cmluZ30gIHN0ciAgICAgICAgIGxvY2FsaXplZCBzdHJpbmcgdGVtcGxhdGUgd2l0aCBtYXJrIHRvIGluY2x1ZGUgZGF0YVxuICAgICAqIEBwYXJhbSAgICB7b2JqZWN0fSAgcGFyYW1zICAgICAgcGFyYW1zIHRvIHVzZSBpbiBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyAge3N0cmluZ30gICAgICAgICAgICAgIGxvY2FsaXplZCB2ZXJzaW9uIG9mIHN0cmluZyB3aXRoXG4gICAgICovXG4gICAgZm9ybWF0KHN0ciwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBub3RQYXRoLnBhcnNlU3VicyhzdHIsIHBhcmFtcywgdGhpcy5oZWxwZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbG9jYWxpemVkIHZlcnNpb24gb2Ygc3RyaW5nIHdpdGggaW5qZWN0ZWQgZGF0YSBmcm9tIHByb3ZpZGVkIG9iamVjdFxuICAgICAqIG1heSBhbHNvIHVzZSBMb2NhbGUuaGVscGVycyBhcyBzb3VyY2Ugb2YgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgIHBocmFzZSAgICBuYW1lIG9mIHN0cmluZyB0byBsb2NhbGl6ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIHBhcmFtcyAgICBvYmplY3Qgd2l0aCBkYXRhIHRvIGluamVjdCBpbiBwaHJhc2UgdGVtcGxhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgbG9jYWxpemVkIHN0cmluZyB3aXRoIGluamVjdGVkIGRhdGFcbiAgICAgKi9cbiAgICBzYXkocGhyYXNlLCBwYXJhbXMgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5kaWN0LCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcGwgPSB0aGlzLmRpY3RbcGhyYXNlXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZm9ybWF0KHRtcGwsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG1wbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvY2FsZSBwaHJhc2U6ICR7cGhyYXNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uZGVidWcoZSk7XG4gICAgICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGluZyBuZXcgZGljdGlvbmFyeS4gdHJpZ2dlcnMgZXZlbnQgJ2NoYW5nZSdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgIGRpY3QgICAgICB2b2NhYnVsYXJ5IG9mIHBocmFzZXMgYW5kIHRlbXBsYXRlc1xuICAgICAqKi9cbiAgICBzZXQoZGljdCkge1xuICAgICAgICBMT0NBTEUuc2V0KGRpY3QpO1xuICAgICAgICB0aGlzLnNhdmVUb1N0b3JhZ2UoZGljdCk7XG4gICAgICAgIHRoaXMuZGljdCA9IE9iamVjdC5hc3NpZ24oe30sIHsgLi4uZGljdCB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIH1cblxuICAgIHNhdmVUb1N0b3JhZ2UoZGljdCkge1xuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcImRpY3Rpb25hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGljdClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5kZWJ1ZyhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlc3RvcmVGcm9tU3RvcmFnZSgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ciA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImRpY3Rpb25hcnlcIik7XG4gICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGljdCA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBub3RDb21tb24uZGVidWcoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdyaXRhYmxlIHN0b3JlIG9mIHBocmFzZXNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICB3cml0YWJsZSBzdG9yZVxuICAgICAqL1xuICAgIHZvY2FidWxhcnkoKSB7XG4gICAgICAgIHJldHVybiBMT0NBTEU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgbm90TG9jYWxlKCk7XG4iLCJpbXBvcnQgTE9DQUxFIGZyb20gXCIuL3N0b3JlLmpzXCI7XG5pbXBvcnQgbm90TG9jYWxlIGZyb20gXCIuL25vdExvY2FsZS5qc1wiO1xuY29uc3Qgc2F5ID0gbm90TG9jYWxlLnNheS5iaW5kKG5vdExvY2FsZSk7XG5cbmV4cG9ydCB7IExPQ0FMRSwgc2F5LCBub3RMb2NhbGUgfTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIGxldCBzaWRlZCA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdIC0gaWYgd2Ugd2FudCB0byBhZGRyZXNzIHRoaXMgdGFnXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BhZGRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYm9sZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWZ0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3RvcF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtib3R0b21dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2V2ZW50c11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3JlZ2lzdGVyXSAtIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtvblVwZGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW3ZhcnNdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJ0YWdJZFwiLFxuICAgICAgICB0aXRsZSA9ICRiaW5kYWJsZShcInRhZ1wiKSxcbiAgICAgICAgY29sb3IgPSBcImluZm9cIixcbiAgICAgICAgc2l6ZSA9IFwibm9ybWFsXCIsXG4gICAgICAgIHBhZGRpbmcgPSBcIm5vcm1hbFwiLFxuICAgICAgICBib2xkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxlZnQgPSBmYWxzZSxcbiAgICAgICAgdG9wID0gZmFsc2UsXG4gICAgICAgIGJvdHRvbSA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGV2ZW50cyA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIHJlZ2lzdGVyID0gbm90Q29tbW9uLnJlZ2lzdGVyV2lkZ2V0RXZlbnRzLmJpbmQobm90Q29tbW9uKSxcbiAgICAgICAgb25VcGRhdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZGF0YSwgXCJ0aXRsZVwiKSkge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhcnMgPSB7fSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGB0YWctJHtpZH06dXBkYXRlYDtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGV2ZW50cywgZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpXSA9IG9uVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyKGV2ZW50cyk7XG4gICAgICAgIHNpZGVkID0gcmlnaHQgfHwgbGVmdCB8fCB0b3AgfHwgYm90dG9tO1xuICAgIH0pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0eWxlID0gT2JqZWN0LmtleXMoJHN0YXRlLnNuYXBzaG90KHZhcnMpKVxuICAgICAgICAgICAgLm1hcCgodmFyTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt2YXJOYW1lfTogJHt2YXJzW3Zhck5hbWVdfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGV9XG4gICAgPHNwYW5cbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIG9ua2V5ZG93bj17YWN0aW9uID8gYWN0aW9uIDogdW5kZWZpbmVkfVxuICAgICAgICBvbmNsaWNrPXthY3Rpb24gPyBhY3Rpb24gOiB1bmRlZmluZWR9XG4gICAgICAgIGlkPVwidGFnLXtpZH1cIlxuICAgICAgICBjbGFzcz1cIlxuICB0YWdcbiAge2JvbGQgPyAnaGFzLXRleHQtd2VpZ2h0LWJvbGQnIDogJyd9XG4gIHtwYWRkaW5nICE9PSAnbm9ybWFsJyA/IGBpcy1wYWRkZWQtJHtwYWRkaW5nfWAgOiAnJ31cbiAgaXMte3NpemV9XG4gIGlzLXtjb2xvcn1cbiAge3NpZGVkID8gJ2lzLXNpZGVkJyA6ICcnfVxuICB7cmlnaHQgPyAnaXMtc2lkZWQtcmlnaHQnIDogJyd9XG4gIHtsZWZ0ID8gJ2lzLXNpZGVkLWxlZnQnIDogJyd9XG4gIHt0b3AgPyAnaXMtc2lkZWQtdG9wJyA6ICcnfVxuICB7Ym90dG9tID8gJ2lzLXNpZGVkLWJvdHRvbScgOiAnJ31cbiAge2NsYXNzZXN9XCJcbiAgICAgICAge3N0eWxlfT57JExPQ0FMRVt0aXRsZV19PC9zcGFuXG4gICAgPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuL3VpLnRhZy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19UUlVFID0gXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19GQUxTRSA9IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZCA9IGZhbHNlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBMQ19UUlVFID0gXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCIsXG4gICAgICAgIExDX0ZBTFNFID0gXCJub3Qtbm9kZTpib29sZWFuc19mYWxzZVwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBGQUxTRV9WQUxVRSA9IHtcbiAgICAgICAgdGl0bGU6IExDX0ZBTFNFLFxuICAgICAgICBjb2xvcjogaW52ZXJ0ZWQgPyBcInN1Y2Nlc3NcIiA6IFwiZGFuZ2VyXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IFRSVUVfVkFMVUUgPSB7XG4gICAgICAgIHRpdGxlOiBMQ19UUlVFLFxuICAgICAgICBjb2xvcjogaW52ZXJ0ZWQgPyBcImRhbmdlclwiIDogXCJzdWNjZXNzXCIsXG4gICAgfTtcblxuICAgIC8vaWYgaW52ZXJ0ZWQgPT09IHRydWUsIGludmVydHMgdmFsdWVcbiAgICBsZXQgdGFnVmFsdWUgPSAkZGVyaXZlZCh2YWx1ZSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRSk7XG48L3NjcmlwdD5cblxuPFVJVGFnIHsuLi50YWdWYWx1ZX0gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4vdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHthbnl9IGxhYmVsXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHZhbHVlLCBsYWJlbCwgaW52ZXJ0ZWQgPSBmYWxzZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHNwYW4gY2xhc3M9XCJsYWJlbFwiPnskTE9DQUxFW2xhYmVsXX06IDxVSUJvb2xlYW4ge3ZhbHVlfSB7aW52ZXJ0ZWR9IC8+PC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4vdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZXNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtjb21wb25lbnRDb25zdHJ1Y3Rvcl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgdmFsdWVzID0gW10sIGludmVydGVkID0gZmFsc2UsIGNvbXBvbmVudENvbnN0cnVjdG9yID0gVUlCb29sZWFuIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBfdmFsdWVzID0gJHN0YXRlKFtdKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIF92YWx1ZXMgPSBbeyB2YWx1ZTogdmFsdWVzIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5ldmVyeSgoaXRtKSA9PiB0eXBlb2YgaXRtID09PSBcImJvb2xlYW5cIikpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzID0gdmFsdWVzLm1hcCgoaXRtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdG0gfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlcyA9IFsuLi52YWx1ZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBfdmFsdWVzLmxlbmd0aH1cbiAgICB7I2VhY2ggX3ZhbHVlcyBhcyBpdGVtfVxuICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IGNvbXBvbmVudENvbnN0cnVjdG9yfVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50XG4gICAgICAgICAgICB7Li4uaXRlbX1cbiAgICAgICAgICAgIGludmVydGVkPXtpbnZlcnRlZCB8fCBpdGVtLmludmVydGVkfVxuICAgICAgICAvPlxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXRvb2x0aXAvZGlzdC9jc3MvYnVsbWEtdG9vbHRpcC5taW4uY3NzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hpZGRlbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93YWJsZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb3BpYWJsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvcHlJY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2hvd0ljb25dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtoaWRlSWNvbl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21heExlbmd0aF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NoYWRvd0NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXBdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b29sdGlwVFRMXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdG9vbHRpcFRleHRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0b29sdGlwQ2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt2YWx1ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaGlkZGVuID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICBzaG93YWJsZSA9IHRydWUsXG4gICAgICAgIGNvcGlhYmxlID0gdHJ1ZSxcbiAgICAgICAgY29weUljb24gPSBcImNvcHlcIixcbiAgICAgICAgc2hvd0ljb24gPSBcImV5ZVwiLFxuICAgICAgICBoaWRlSWNvbiA9IFwiZXllLXNsYXNoXCIsXG4gICAgICAgIG1heExlbmd0aCA9IDIwLFxuICAgICAgICBzaGFkb3dDbGFzcyA9IFwiaGFzLWJhY2tncm91bmQtcHJpbWFyeS05MFwiLFxuICAgICAgICB0b29sdGlwID0gdHJ1ZSxcbiAgICAgICAgdG9vbHRpcFRUTCA9IDIwMDAsXG4gICAgICAgIHRvb2x0aXBUZXh0ID0gXCLQodC60L7Qv9C40YDQvtCy0LDQvdC+INCyINCx0YPRhNC10YBcIixcbiAgICAgICAgdG9vbHRpcENsYXNzID0gXCJoYXMtdG9vbHRpcC1pbmZvXCIsXG4gICAgICAgIHZhbHVlID0gXCJcIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVWaWV3KCkge1xuICAgICAgICBoaWRkZW4gPSAhaGlkZGVuO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50Q29waWVkID0gJHN0YXRlKGZhbHNlKSxcbiAgICAgICAgdG9vbHRpcEFjdGl2ZSA9ICRkZXJpdmVkKHRvb2x0aXAgJiYgY29udGVudENvcGllZCksXG4gICAgICAgIHRvb2x0aXBUYXJnZXQgPSAkc3RhdGUoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvcHlDb250ZW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q29waWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0b29sdGlwVGFyZ2V0LmRhdGFzZXQudG9vbHRpcCA9IHRvb2x0aXBUZXh0O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Q29waWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUYXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10b29sdGlwXCIpO1xuICAgICAgICAgICAgICAgIH0sIHRvb2x0aXBUVEwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29weTogXCIsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPHNwYW5cbiAgICBjbGFzcz17KGhpZGRlbiA/IFwiaXMtY2Vuc29yZWQgXCIgKyBzaGFkb3dDbGFzcyA6IFwiXCIpICtcbiAgICAgICAgXCIgaXMtdmVydGljYWwtbWlkZGxlIFwifVxuICAgIHN0eWxlPXtgZGlzcGxheTppbmxpbmUtYmxvY2s7IHdpZHRoOiAke21heExlbmd0aH1yZW07IGhlaWdodDogdmFyKC0tYnVsbWEtc2l6ZS1tZWRpdW0pOyBvdmVyZmxvdy14OmhpZGRlbjtgfVxuICAgID57aGlkZGVuID8gXCJcIiA6IHZhbHVlfTwvc3BhblxuPlxueyNpZiBjb3BpYWJsZX1cbiAgICA8c3BhblxuICAgICAgICBiaW5kOnRoaXM9e3Rvb2x0aXBUYXJnZXR9XG4gICAgICAgIG9uY2xpY2s9e2NvcHlDb250ZW50fVxuICAgICAgICBvbmtleWRvd249e2NvcHlDb250ZW50fVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgY2xhc3M9e1wiaWNvbiBpcy1zbWFsbCBpcy1yaWdodCBpcy1jbGlja2FibGUgXCIgK1xuICAgICAgICAgICAgKHRvb2x0aXBBY3RpdmUgPyBgICR7dG9vbHRpcENsYXNzfSBgIDogXCJcIikgK1xuICAgICAgICAgICAgXCIgaXMtdmVydGljYWwtbWlkZGxlXCJ9PjxpIGNsYXNzPVwiZmFzIGZhLXtjb3B5SWNvbn1cIj48L2k+PC9zcGFuXG4gICAgPlxuey9pZn1cbnsjaWYgc2hvd2FibGV9XG4gICAgPHNwYW5cbiAgICAgICAgY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLXJpZ2h0IGlzLWNsaWNrYWJsZSBpcy12ZXJ0aWNhbC1taWRkbGVcIlxuICAgICAgICBvbmNsaWNrPXt0b2dnbGVWaWV3fVxuICAgICAgICBvbmtleWRvd249e3RvZ2dsZVZpZXd9XG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIj48aSBjbGFzcz1cImZhcyBmYS17aGlkZGVuID8gc2hvd0ljb24gOiBoaWRlSWNvbn1cIj48L2k+PC9zcGFuXG4gICAgPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIGxldCBzaWRlZCA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdIC0gaWYgd2Ugd2FudCB0byBhZGRyZXNzIHRoaXMgaW5kaWNhdG9yXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsYWJlbHNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BhZGRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYm9sZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWZ0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3RvcF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtib3R0b21dXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtldmVudHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtyZWdpc3Rlcl0gLSByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbb25VcGRhdGVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJ0YWdJZFwiLFxuICAgICAgICBzdGF0ZTogY3VycmVudFN0YXRlID0gJGJpbmRhYmxlKFwibGlnaHRcIiksXG4gICAgICAgIHNpemUgPSBcIm5vcm1hbFwiLFxuICAgICAgICBsYWJlbHMgPSB7XG4gICAgICAgICAgICBibGFjazogXCJibGFja1wiLFxuICAgICAgICAgICAgZGFyazogXCJkYXJrXCIsXG4gICAgICAgICAgICBsaWdodDogXCJsaWdodFwiLFxuICAgICAgICAgICAgd2hpdGU6IFwid2hpdGVcIixcbiAgICAgICAgICAgIHByaW1hcnk6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgbGluazogXCJsaW5rXCIsXG4gICAgICAgICAgICBpbmZvOiBcImluZm9cIixcbiAgICAgICAgICAgIHN1Y2Nlc3M6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgd2FybmluZzogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgICBkYW5nZXI6IFwiZGFuZ2VyXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJteC0xXCIsXG4gICAgICAgIHBhZGRpbmcgPSBcIm5vcm1hbFwiLFxuICAgICAgICBib2xkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxlZnQgPSBmYWxzZSxcbiAgICAgICAgdG9wID0gZmFsc2UsXG4gICAgICAgIGJvdHRvbSA9IGZhbHNlLFxuICAgICAgICBldmVudHMgPSAkYmluZGFibGUoe30pLFxuICAgICAgICByZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50cy5iaW5kKG5vdENvbW1vbiksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwic3RhdGVcIikpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBkYXRhLnN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gYGluZGljYXRvci0ke2lkfTp1cGRhdGVgO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oZXZlbnRzLCBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpKSkge1xuICAgICAgICAgICAgZXZlbnRzW2dldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCldID0gb25VcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXIoZXZlbnRzKTtcbiAgICB9KTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBzaWRlZCA9IHJpZ2h0IHx8IGxlZnQgfHwgdG9wIHx8IGJvdHRvbTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48c3BhblxuICAgIGNsYXNzPVwidGFnXG5pcy17c2l6ZX1cbntib2xkID8gJ2hhcy10ZXh0LXdlaWdodC1ib2xkJyA6ICcnfVxue3BhZGRpbmcgIT09ICdub3JtYWwnID8gYGlzLXBhZGRlZC0ke3BhZGRpbmd9YCA6ICcnfVxue3NpZGVkID8gJ2lzLXNpZGVkJyA6ICcnfVxue3JpZ2h0ID8gJ2lzLXNpZGVkLXJpZ2h0JyA6ICcnfVxue2xlZnQgPyAnaXMtc2lkZWQtbGVmdCcgOiAnJ31cbnt0b3AgPyAnaXMtc2lkZWQtdG9wJyA6ICcnfVxue2JvdHRvbSA/ICdpcy1zaWRlZC1ib3R0b20nIDogJyd9XG4gIGlzLXtjdXJyZW50U3RhdGV9IHtjbGFzc2VzfVxuICBcIj57bGFiZWxzW2N1cnJlbnRTdGF0ZV19PC9zcGFuXG4+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXBhZ2Vsb2FkZXJcIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuICAgIFxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nXSAtIHN0YXRlIGlmIGZvcm0gbG9hZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV0gLSBwYWdlIC0gd2hvbGUgcGFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IGxvYWRpbmcgPSBmYWxzZSwgc2l6ZSA9IFwiY29udGFpbmVyXCIsIHRpdGxlID0gXCJXYWl0aW5nLi4uXCIgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgc2l6ZSAhPT0gXCJoaWRkZW5cIn1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwie3NpemUgPT09ICdwYWdlJyA/ICdwYWdlbG9hZGVyJyA6ICdjb250YWluZXJsb2FkZXInfSB7bG9hZGluZ1xuICAgICAgICAgICAgPyAnaXMtYWN0aXZlJ1xuICAgICAgICAgICAgOiAnJ31cIlxuICAgID5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPnskTE9DQUxFW3RpdGxlXX08L3NwYW4+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgbGV0IHsgdmFsdWUsIHRpdGxlLCBzZWxlY3RlZCB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPG9wdGlvbiB7dmFsdWV9IHtzZWxlY3RlZH0+eyRMT0NBTEVbdGl0bGVdfTwvb3B0aW9uPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSVNlbGVjdE9wdGlvbiBmcm9tIFwiLi91aS5zZWxlY3Qub3B0aW9uLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt2YWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbdmFyaWFudHNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2VtcHR5VmFsdWVUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttdWx0aXBsZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGVtcHR5VmFsdWVUaXRsZSA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic2VsZWN0XCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAgICAgc2l6ZSA9IDgsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBzZWxlY3RlZFZhcmlhbnRzID0gJHN0YXRlKFtdKTtcblxuICAgIGZ1bmN0aW9uIGZpbHRlclNlbGVjdGVkVmFyaWFudHModmFyaWFudCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKHZhcmlhbnQuaWQpID4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSB2YXJpYW50LmlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGxhc3RDaGFuZ2U7XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoZXYpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGV2LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsYXN0Q2hhbmdlID09PSBkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEudmFsdWUpICYmXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmNvbXBhcmVUd29BcnJheXMobGFzdENoYW5nZSwgZGF0YS52YWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBBcnJheS5mcm9tKGV2LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgoZWwpID0+IGVsLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFVJQ29tbW9uLkNMRUFSX01BQ1JPKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlID09PSBVSUNvbW1vbi5DTEVBUl9NQUNSTykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb25jaGFuZ2UoZGF0YSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoZXYpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGV2LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBBcnJheS5mcm9tKGV2LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgoZWwpID0+IGVsLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKFVJQ29tbW9uLkNMRUFSX01BQ1JPKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlID09PSBVSUNvbW1vbi5DTEVBUl9NQUNSTykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdENoYW5nZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIG9uY2hhbmdlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgbXVsdGlwbGVDbGFzcyA9ICRkZXJpdmVkKG11bHRpcGxlID8gXCIgaXMtbXVsdGlwbGUgXCIgOiBcIlwiKTtcbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFsdWU7XG4gICAgICAgIHNlbGVjdGVkVmFyaWFudHMgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRzKVxuICAgICAgICAgICAgPyB2YXJpYW50cy5maWx0ZXIoZmlsdGVyU2VsZWN0ZWRWYXJpYW50cylcbiAgICAgICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICB7I2lmIHZhbHVlfVxuICAgICAgICB7I2VhY2ggc2VsZWN0ZWRWYXJpYW50cyBhcyBzZWxlY3RlZFZhcmlhbnR9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1yLTJcIj57JExPQ0FMRVtzZWxlY3RlZFZhcmlhbnQudGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9lYWNofVxuICAgIHs6ZWxzZX1cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJtci0yXCI+eyRMT0NBTEVbZW1wdHlWYWx1ZVRpdGxlXX08L3NwYW4+XG4gICAgey9pZn1cbns6ZWxzZX1cbiAgICA8ZGl2IGNsYXNzPVwic2VsZWN0IHtjbGFzc2VzfSB7bXVsdGlwbGVDbGFzc31cIj5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXNlbGVjdC17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBvbmJsdXI9e29uQmx1cn1cbiAgICAgICAgICAgIG9uaW5wdXQ9e29uSW5wdXR9XG4gICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICB7bXVsdGlwbGV9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHNpemU9e211bHRpcGxlID8gc2l6ZSA6IGZhbHNlfVxuICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgPlxuICAgICAgICAgICAgeyNpZiBwbGFjZWhvbGRlci5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgIHsjaWYgdmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e1VJQ29tbW9uLkNMRUFSX01BQ1JPfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17VUlDb21tb24uQ0xFQVJfTUFDUk99XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD1cInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50fVxuICAgICAgICAgICAgICAgIHsjaWYgbXVsdGlwbGV9XG4gICAgICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhcmlhbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17dmFsdWUgJiYgdmFsdWUuaW5kZXhPZih2YXJpYW50LmlkKSA+IC0xfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3ZhcmlhbnQudGl0bGV9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YXJpYW50LmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e3ZhbHVlID09IHZhcmlhbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dmFyaWFudC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhaXNlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdXRsaW5lZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3VuZGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3R5bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2FjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGxpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmFpc2VkID0gZmFsc2UsXG4gICAgICAgIG91dGxpbmVkID0gZmFsc2UsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgICAgIHJvdW5kZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgc3RhdGUgPSBcIlwiLFxuICAgICAgICB0eXBlID0gXCJcIixcbiAgICAgICAgY29sb3IgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgc3R5bGUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGljb24gPSBmYWxzZSxcbiAgICAgICAgaWNvblNpZGUgPSBcInJpZ2h0XCIsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBvbmNsaWNrICYmIG9uY2xpY2soeyBldmVudCwgdmFsdWUgfSk7XG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uKGV2ZW50LCB2YWx1ZSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b25cbiAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgIHtkaXNhYmxlZH1cbiAgICB0eXBlPXt0eXBlID8gdHlwZSA6IFwiXCJ9XG4gICAge3N0eWxlfVxuICAgIGNsYXNzPVwiXG4gIGJ1dHRvblxuICB7Y2xhc3Nlc31cbiAge3N0YXRlID8gYGlzLSR7c3RhdGV9YCA6ICcnfVxuICB7aW52ZXJ0ZWQgPyBgaXMtaW52ZXJ0ZWRgIDogJyd9XG4gIHtvdXRsaW5lZCA/IGBpcy1vdXRsaW5lZGAgOiAnJ31cbiAge3JhaXNlZCA/IGBpcy1yYWlzZWRgIDogJyd9XG4gIHtyb3VuZGVkID8gYGlzLXJvdW5kZWRgIDogJyd9XG4gIHtsaWdodCA/IGBpcy1saWdodGAgOiAnJ31cbiAge2xvYWRpbmcgPyBgaXMtbG9hZGluZ2AgOiAnJ31cbiAge2NvbG9yID8gYGlzLSR7Y29sb3J9YCA6ICcnfVxuICB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVxuICBcIlxuPlxuICAgIHsjaWYgY2hpbGRyZW59e0ByZW5kZXIgY2hpbGRyZW4oKX17OmVsc2UgaWYgaWNvbn1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJsZWZ0XCJ9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIlxuICAgICAgICAgICAgICAgID48aSBjbGFzcz1cImZhcyBmYS17aWNvbn0ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj48L2k+PC9zcGFuXG4gICAgICAgICAgICA+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgdGl0bGV9XG4gICAgICAgICAgICA8c3Bhbj57JExPQ0FMRVt0aXRsZV19PC9zcGFuPlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIGljb25TaWRlID09PSBcInJpZ2h0XCJ9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIlxuICAgICAgICAgICAgICAgID48aSBjbGFzcz1cImZhcyBmYS17aWNvbn0ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj48L2k+PC9zcGFuXG4gICAgICAgICAgICA+XG4gICAgICAgIHsvaWZ9XG4gICAgezplbHNlfVxuICAgICAgICB7JExPQ0FMRVt0aXRsZV19XG4gICAgey9pZn1cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXJpYUxhYmVsID0gXCJkZWxldGUgYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGlnaHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWlzZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0bGluZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcm91bmRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3R5bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgYXJpYUxhYmVsID0gXCJkZWxldGUgYnV0dG9uXCIsXG4gICAgICAgIGxpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmFpc2VkID0gZmFsc2UsXG4gICAgICAgIG91dGxpbmVkID0gZmFsc2UsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgICAgIHJvdW5kZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgc3RhdGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBzdHlsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBvbmNsaWNrICYmIG9uY2xpY2soeyBldmVudCwgdmFsdWUgfSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b25cbiAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWx9XG4gICAgb25jbGljaz17b25DbGlja31cbiAgICB7ZGlzYWJsZWR9XG4gICAge3N0eWxlfVxuICAgIGNsYXNzPVwiXG4gIGRlbGV0ZVxuICB7Y2xhc3Nlc30gIFxuICB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVxuICBcIlxuPjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSBcIi4vdWkuYnV0dG9uLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5PG9iamVjdD59IFt2YWx1ZXMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjZW50ZXJlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JpZ2h0ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5Db21wb25lbnR9IFtidXR0b25Db21wb25lbnQgPSBVSUJ1dHRvbl1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vZXZlbnRzLnR5cGVzJykuVUlFdmVudElucHV0Q2hhbmdlQ2FsbGJhY2t9IFthY3Rpb24gPSAoKT0+dHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vZXZlbnRzLnR5cGVzJykuVUlFdmVudENhbGxiYWNrfSBbb25jbGljayA9ICgpPT50cnVlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgY2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBidXR0b25Db21wb25lbnQ6IFN2ZWx0ZUNvbXBvbmVudCA9IFVJQnV0dG9uLFxuICAgICAgICBhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBfdmFsdWVzID0gJHN0YXRlKFtdKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBfdmFsdWVzID0gdmFsdWVzLm1hcCgoaXRtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oaXRtLmlkKSkge1xuICAgICAgICAgICAgICAgIGl0bS5pZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRtO1xuICAgICAgICB9KTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJidXR0b25zIGhhcy1hZGRvbnMge2NlbnRlcmVkID8gJ2lzLWNlbnRlcmVkJyA6ICcnfSB7cmlnaHRcbiAgICAgICAgPyAnaXMtcmlnaHQnXG4gICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4+XG4gICAgeyNlYWNoIF92YWx1ZXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnQge2FjdGlvbn0ge29uY2xpY2t9IHsuLi5pdGVtfSBiaW5kOnZhbHVlPXtpdGVtLnZhbHVlfSAvPlxuICAgIHsvZWFjaH1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsZWZ0XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY2VudGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbcmlnaHRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgbGVmdCA9IFtdLCBjZW50ZXIgPSBbXSwgcmlnaHQgPSBbXSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNvbHVtbnMge2NsYXNzZXN9XCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17bGVmdH0+PC9VSUJ1dHRvbnM+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17Y2VudGVyfSBjZW50ZXJlZD17dHJ1ZX0+PC9VSUJ1dHRvbnM+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17cmlnaHR9IHJpZ2h0PXt0cnVlfT48L1VJQnV0dG9ucz5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi91aS5idXR0b24uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGlnaHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWlzZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0bGluZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcm91bmRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ljb25dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2lkZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbdWlPZmZdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3VpT25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2FjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBsaWdodCA9IGZhbHNlLFxuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHJhaXNlZCA9IGZhbHNlLFxuICAgICAgICBvdXRsaW5lZCA9IGZhbHNlLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICByb3VuZGVkID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHN0YXRlOiBhY3RpdmVTdGF0ZSA9IFwiXCIsXG4gICAgICAgIHR5cGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGljb24gPSBmYWxzZSxcbiAgICAgICAgaWNvblNpZGUgPSBcInJpZ2h0XCIsXG4gICAgICAgIHVpT2ZmID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHVpT24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7fSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB7fSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHNlbGVjdGVkID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgY2hpbGRQcm9wcyA9ICRzdGF0ZSh7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBsaWdodCxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgcmFpc2VkLFxuICAgICAgICBvdXRsaW5lZCxcbiAgICAgICAgaW52ZXJ0ZWQsXG4gICAgICAgIHJvdW5kZWQsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMsXG4gICAgICAgIGljb24sXG4gICAgICAgIGljb25TaWRlLFxuICAgICAgICB2YWx1ZSxcbiAgICB9KTtcblxuICAgIGxldCB1aUVsZW1lbnQgPSAkc3RhdGUoKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBzZWxlY3RlZCA9IGFjdGlvbihldmVudCwgdmFsdWUsIHNlbGVjdGVkKTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgb25jbGljayh7IHZhbHVlLCBzZWxlY3RlZCB9KTtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVVJKCkge1xuICAgICAgICBpZiAodWlFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wc0NoYW5nZXMgPSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gdWlPbih2YWx1ZSwgc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgOiB1aU9mZih2YWx1ZSwgc2VsZWN0ZWQpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHNDaGFuZ2VzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFByb3BzW2tleV0gPSBwcm9wc0NoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGRQcm9wcyA9IGNoaWxkUHJvcHM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RlZCAhPT0gXCJ1bmRlZmluZWRcIikgdXBkYXRlVUkoKTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48VUlCdXR0b25cbiAgICBiaW5kOnRoaXM9e3VpRWxlbWVudH1cbiAgICB7Li4uY2hpbGRQcm9wc31cbiAgICBzdGF0ZT17YWN0aXZlU3RhdGV9XG4gICAgb25jbGljaz17b25DbGlja31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlCdXR0b25Td2l0Y2ggZnJvbSBcIi4vdWkuYnV0dG9uLnN3aXRjaC5zdmVsdGVcIjtcblxuICAgIGNvbnN0IHVpcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlSXRlbVVJKGl0ZW0pIHtcbiAgICAgICAgdWlzW2l0ZW0uaWRdLnVwZGF0ZVVJKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdEFjdGlvbiA9IChldiwgdmFsdWUsIHNlbGVjdGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50T2ZTZWxlY3RlZCA9IGNvdW50U2VsZWN0ZWQoKTtcbiAgICAgICAgaWYgKGNvdW50T2ZTZWxlY3RlZCA9PT0gbWluICYmIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50T2ZTZWxlY3RlZCA9PT0gbWF4ICYmIHNlbGVjdGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhPZkN1cnJlbnQgPSBfdmFsdWVzLmZpbmRJbmRleCgoaXRtKSA9PiBpdG0udmFsdWUgPT09IHZhbHVlKTtcbiAgICAgICAgbGV0IG5ld1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIGlmIChpbmRleE9mQ3VycmVudCA+IC0xKSB7XG4gICAgICAgICAgICBuZXdTZWxlY3RlZCA9ICFuZXdTZWxlY3RlZDtcbiAgICAgICAgICAgIGNvbnN0IGNudCA9IGNvdW50U2VsZWN0ZWQoKSArIChuZXdTZWxlY3RlZCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAobWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNudCA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RVcFRvTWluKGNudCwgaW5kZXhPZkN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXgpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4IDwgY250KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2VsZWN0RG93blRvTWluKGNudCwgaW5kZXhPZkN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGFkZFRvSGlzdG9yeShpbmRleE9mQ3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3U2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NlbGVjdGVkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8b2JqZWN0Pn0gW3ZhbHVlc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjZW50ZXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5Db21wb25lbnR9ICAgICAgW2J1dHRvbkNvbXBvbmVudCA9IFVJQnV0dG9uU3dpdGNoXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtidXR0b25Qcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFthY3Rpb24gPSAoZXZlbnQsIHZhbHVlLCBzZWxlY3RlZCkgPT4gYm9vbGVhbl0gIGZpcmVzIG9uIGJ1dHRvbiBzd2l0Y2ggY2xpY2ssIHJldHVybnMgbmV3IHN0YXRlIG9mIHNlbGVjdGVkXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluID0gMF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21heCA9IDEwMF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGNlbnRlcmVkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgYnV0dG9uQ29tcG9uZW50ID0gVUlCdXR0b25Td2l0Y2gsXG4gICAgICAgIGFjdGlvbiA9IGRlZmF1bHRBY3Rpb24sXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIG1heCA9IDEwMCxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBzZWxlY3RIaXN0b3J5ID0gW107XG4gICAgbGV0IF92YWx1ZXMgPSAkc3RhdGUodmFsdWVzKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgICB2YWx1ZXMgPSAkc3RhdGUuc25hcHNob3QoX3ZhbHVlcyk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gdmFsdWVzLmZpbHRlcigoaXRtKSA9PiBpdG0uc2VsZWN0ZWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZElkcyA9IHNlbGVjdGVkLm1hcCgoaXRtKSA9PiBpdG0uaWQpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gc2VsZWN0ZWRJZHMubGVuZ3RoO1xuICAgICAgICBvbmNoYW5nZSAmJlxuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZElkcyxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZENvdW50LFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdEFsbCgpIHtcbiAgICAgICAgX3ZhbHVlcy5mb3JFYWNoKChpdG0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBfdmFsdWVzW2luZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB1cGRhdGVJdGVtVUkoaXRtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGRlc2VsZWN0QWxsKCkge1xuICAgICAgICBfdmFsdWVzLmZvckVhY2goKGl0bSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIF92YWx1ZXNbaW5kZXhdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB1cGRhdGVJdGVtVUkoaXRtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ291bnQgPSBjb3VudFNlbGVjdGVkKCk7XG4gICAgICAgIGlmIChtaW4gJiYgc2VsZWN0ZWRDb3VudCA8IG1pbikge1xuICAgICAgICAgICAgc2VsZWN0VXBUb01pbihzZWxlY3RlZENvdW50LCAtMSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBhZGRUb0hpc3RvcnkoaWQpIHtcbiAgICAgICAgaWYgKHNlbGVjdEhpc3RvcnkuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICBzZWxlY3RIaXN0b3J5LnNwbGljZShzZWxlY3RIaXN0b3J5LmluZGV4T2YoaWQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RIaXN0b3J5LnB1c2goaWQpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBjb3VudFNlbGVjdGVkKCkge1xuICAgICAgICBjb25zdCBjb3VudE9mU2VsZWN0ZWQgPSBfdmFsdWVzLmZpbHRlcigoYnRuKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYnRuLnNlbGVjdGVkO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBjb3VudE9mU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUZpcnN0U3VpdGVkKHRvVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBfdmFsdWVzLmZpbmRJbmRleCgoaXRtKSA9PiAhdG9WYWx1ZSA9PSBpdG0uc2VsZWN0ZWQpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgX3ZhbHVlc1tpbmRleF0uc2VsZWN0ZWQgPSB0b1ZhbHVlO1xuICAgICAgICAgICAgdXBkYXRlSXRlbVVJKF92YWx1ZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGFkZFRvSGlzdG9yeShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2VsZWN0VXBUb01pbihjbnQsIGluZGV4T2ZDdXJyZW50KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IG1pbiAtIGNudDtcbiAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgaW4gX3ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHQgPT09IGluZGV4T2ZDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV92YWx1ZXNbdF0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzW3RdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtVUkoX3ZhbHVlc1t0XSk7XG4gICAgICAgICAgICAgICAgYWRkVG9IaXN0b3J5KHQpO1xuICAgICAgICAgICAgICAgIGRlbHRhLS07XG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZGVzZWxlY3REb3duVG9NaW4oY250LCBpbmRleE9mQ3VycmVudCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjbnQgLSBtYXg7XG4gICAgICAgIGlmICghZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IGluIF92YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSBpbmRleE9mQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF92YWx1ZXNbdF0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzW3RdLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbVVJKF92YWx1ZXNbdF0pO1xuICAgICAgICAgICAgICAgIGRlbHRhLS07XG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gdXBkYXRlVUkoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHVpcykuZm9yRWFjaCgoaXRlbUlkKSA9PiB7XG4gICAgICAgICAgICBpZiAodWlzW2l0ZW1JZF0pIHtcbiAgICAgICAgICAgICAgICB1aXNbaXRlbUlkXS51cGRhdGVVSSAmJiB1aXNbaXRlbUlkXS51cGRhdGVVSSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwiYnV0dG9ucyBoYXMtYWRkb25zIHtjZW50ZXJlZCA/ICdpcy1jZW50ZXJlZCcgOiAnJ30ge3JpZ2h0XG4gICAgICAgID8gJ2lzLXJpZ2h0J1xuICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuPlxuICAgIHsjZWFjaCBfdmFsdWVzIGFzIGl0ZW0sIGluZGV4IChpdGVtLmlkKX1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBidXR0b25Db21wb25lbnR9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnRcbiAgICAgICAgICAgIGJpbmQ6dGhpcz17dWlzW2l0ZW0uaWRdfVxuICAgICAgICAgICAge2FjdGlvbn1cbiAgICAgICAgICAgIHsuLi5pdGVtfVxuICAgICAgICAgICAgey4uLmJ1dHRvblByb3BzfVxuICAgICAgICAgICAge29uY2xpY2t9XG4gICAgICAgICAgICBiaW5kOnNlbGVjdGVkPXtfdmFsdWVzW2luZGV4XS5zZWxlY3RlZH1cbiAgICAgICAgICAgIG9uY2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgLz5cbiAgICB7L2VhY2h9XG48L2Rpdj5cbiIsImNvbnN0IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgPSBcIm9rXCI7XG5jb25zdCBERUZBVUxUX1NUQVRVU19FUlJPUiA9IFwiZXJyb3JcIjtcblxuY29uc3QgTkFWSUdBVElPTl9ERUxBWV9TSE9SVCA9IDUwMDtcbmNvbnN0IE5BVklHQVRJT05fREVMQVlfTk9STUFMID0gMTUwMDtcbmNvbnN0IE5BVklHQVRJT05fREVMQVlfTE9ORyA9IDUwMDA7XG5cbmNvbnN0IE5BVklHQVRJT05fREVMQVlTID0ge1xuICAgIFNIT1JUOiBOQVZJR0FUSU9OX0RFTEFZX1NIT1JULFxuICAgIE5PUk1BTDogTkFWSUdBVElPTl9ERUxBWV9OT1JNQUwsXG4gICAgTE9ORzogTkFWSUdBVElPTl9ERUxBWV9MT05HLFxufTtcblxuY29uc3QgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUID0gTkFWSUdBVElPTl9ERUxBWV9OT1JNQUw7XG5cbmV4cG9ydCB7XG4gICAgREVGQVVMVF9TVEFUVVNfU1VDQ0VTUyxcbiAgICBERUZBVUxUX1NUQVRVU19FUlJPUixcbiAgICBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQsXG4gICAgTkFWSUdBVElPTl9ERUxBWVMsXG59O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbiAgICBpbXBvcnQgVUlTZWxlY3QgZnJvbSBcIi4uL2lucHV0L3VpLnNlbGVjdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbnMsIFVJQnV0dG9uIH0gZnJvbSBcIi4uL2J1dHRvblwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuICAgIGltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vZnJhbWUvY29uc3RcIjtcblxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lucHV0U3RhcnRlZF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhcmlhbnRzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RlbE5hbWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpb25OYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uRmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uU29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uUGFnZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25TZWFyY2hdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25JZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvblRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ljb25dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlwbGVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkYXRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlcnJvcnNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9ybUVycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtTGV2ZWxFcnJvcl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhcmlhbnRzID0gJGJpbmRhYmxlKFtdKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcImVtcHR5IHNlbGVjdCBpdGVtXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic2VsZWN0RnJvbU1vZGVsXCIsXG4gICAgICAgIG1vZGVsTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbk5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25GaWx0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU29ydGVyID0ge30sXG4gICAgICAgIGFjdGlvblBhZ2VyID0ge30sXG4gICAgICAgIGFjdGlvblNlYXJjaCA9IHVuZGVmaW5lZCxcbiAgICAgICAgb3B0aW9uSWQgPSBcIjpfaWRcIixcbiAgICAgICAgb3B0aW9uVGl0bGUgPSBcIjp0aXRsZVwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgIHNpemUgPSA4LFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIG9ucmVqZWN0ID0gKCkgPT4gZmFsc2UsXG4gICAgICAgIG9ucmVzb2x2ZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB0cnVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFyZ3VtZW50c1NldFByb3ZpZGVkKCkge1xuICAgICAgICByZXR1cm4gbW9kZWxOYW1lICYmIGFjdGlvbk5hbWUgJiYgYWN0aW9uRmlsdGVyO1xuICAgIH1cblxuICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcblxuICAgIGxldCBkaXNhYmxlZCA9ICRkZXJpdmVkKCFsb2FkZWQpO1xuICAgIGxldCBzdGF0ZSA9ICRzdGF0ZShcImhpZGRlblwiKTtcbiAgICBsZXQgcmVzdWx0c0xpc3QgPSBbXTtcblxuICAgIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYXJndW1lbnRzU2V0UHJvdmlkZWQoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm90QXBwID0gbm90Q29tbW9uLmdldEFwcCgpO1xuICAgICAgICAgICAgY29uc3QgTW9kZWwgPSBub3RBcHBcbiAgICAgICAgICAgICAgICAuZ2V0TW9kZWwobW9kZWxOYW1lKVxuICAgICAgICAgICAgICAgIC5zZXRGaWx0ZXIoYWN0aW9uRmlsdGVyKVxuICAgICAgICAgICAgICAgIC5zZXRTb3J0ZXIoYWN0aW9uU29ydGVyKVxuICAgICAgICAgICAgICAgIC5zZXRQYWdlcihhY3Rpb25QYWdlcilcbiAgICAgICAgICAgICAgICAuc2V0U2VhcmNoKGFjdGlvblNlYXJjaCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE1vZGVsW2AkYCArIGFjdGlvbk5hbWVdKCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBERUZBVUxUX1NUQVRVU19TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c0xpc3QgPSByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyaWFudHMgPSByZXN1bHRzTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub3RQYXRoLmdldChvcHRpb25JZCwgaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbm90UGF0aC5nZXQob3B0aW9uVGl0bGUsIGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbmVycm9yKHJlc3BvbnNlLmVycm9ycyB8fCBbcmVzcG9uc2UubWVzc2FnZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzb2x2ZWRWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIG9uTW9kZWxDaGFuZ2VkKHsgdmFsdWU6IHNlbGVjdGVkVmFsdWUgfSkge1xuICAgICAgICByZXNvbHZlZFZhbHVlID0gcmVzdWx0c0xpc3QuZmluZChcbiAgICAgICAgICAgIChpdGVtKSA9PiBub3RQYXRoLmdldChvcHRpb25JZCwgaXRlbSkgPT09IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBBQ1RJT05TID0ge1xuICAgICAgICBhZGQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGljb246IFwicGx1c1wiLFxuICAgICAgICAgICAgYWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJzaG93XCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICBpY29uOiBcImNoZWNrXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIG9ucmVzb2x2ZShyZXNvbHZlZFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDoge1xuICAgICAgICAgICAgaWNvbjogXCJjbG9zZVwiLFxuICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIG9ucmVqZWN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG48L3NjcmlwdD5cblxueyNpZiBzdGF0ZSA9PT0gXCJoaWRkZW5cIn1cbiAgICA8VUlCdXR0b24gey4uLkFDVElPTlMuYWRkfT48L1VJQnV0dG9uPlxuezplbHNlIGlmIHN0YXRlID09IFwic2hvd1wifVxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZCBoYXMtYWRkb25zXCI+XG4gICAgICAgIDxVSVNlbGVjdFxuICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAge3ZhcmlhbnRzfVxuICAgICAgICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAge2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIHttdWx0aXBsZX1cbiAgICAgICAgICAgIHtzaXplfVxuICAgICAgICAgICAge3ZhbGlkfVxuICAgICAgICAgICAgb25jaGFuZ2U9e29uTW9kZWxDaGFuZ2VkfVxuICAgICAgICAvPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgIDxVSUJ1dHRvbnMgdmFsdWVzPXtbQUNUSU9OUy5yZXNvbHZlLCBBQ1RJT05TLnJlamVjdF19PjwvVUlCdXR0b25zPlxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICBpbXBvcnQgeyBVSUJ1dHRvbnMgfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnB1dFN0YXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlcnZpY2VOYW1lXSAtIFNldCB0aGlzLCBhcyBuc1tNb2RlbE5hbWVdLCBzaG91bGQgYmUgcmVnaXN0ZXJlZCBpbiBub3RBcHBcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2RdIC0gU2V0IHRoaXNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlcnZpY2VMb2FkRGF0YU1ldGhvZF0gLSBTZXQgdGhpc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbW9kZWxEYXRhXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2FkaW5nTGFiZWxdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpc0VtcHR5TGFiZWxdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKCksXG4gICAgICAgIGljb24gPSBmYWxzZSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJcIixcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgc2VydmljZU5hbWUgPSBcIlwiLFxuICAgICAgICBzZXJ2aWNlT3BlblNlbGVjdG9yTWV0aG9kID0gXCJvcGVuU2VsZWN0b3JcIixcbiAgICAgICAgc2VydmljZUxvYWREYXRhTWV0aG9kID0gXCJsb2FkRGF0YVwiLFxuICAgICAgICBtb2RlbERhdGEgPSAkYmluZGFibGUobnVsbCksXG4gICAgICAgIGxvYWRpbmcgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXIgPSAoZGF0YSkgPT4gYCR7ZGF0YS5faWR9YCxcbiAgICAgICAgbG9hZGluZ0xhYmVsID0gXCJub3Qtbm9kZTpsb2FkaW5nX2xhYmVsXCIsXG4gICAgICAgIGlzRW1wdHlMYWJlbCA9IFwibm90LW5vZGU6ZmllbGRfdmFsdWVfaXNfZW1wdHlfcGxhY2Vob2xkZXJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGdldFNlcnZpY2UoKSB7XG4gICAgICAgIGlmICghc2VydmljZU5hbWUpIHRocm93IG5ldyBFcnJvcihcInNlcnZpY2VOYW1lIGlzIG5vdCBzZXRcIik7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uZ2V0QXBwKCkuZ2V0U2VydmljZShzZXJ2aWNlTmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3Blbk1vZGVsU2VhcmNoQW5kU2VsZWN0KCkge1xuICAgICAgICBpZiAoIXNlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2QgaXMgbm90IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlID0gZ2V0U2VydmljZSgpO1xuICAgICAgICBzZXJ2aWNlW3NlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2RdKClcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRzLl9pZDtcbiAgICAgICAgICAgICAgICBtb2RlbERhdGEgPSByZXN1bHRzO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFNlbGVjdGVkTW9kZWwoKSB7XG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBtb2RlbERhdGEgPSBudWxsO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNb2RlbERhdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb2RlbERhdGEgPSBhd2FpdCBnZXRTZXJ2aWNlKClbc2VydmljZUxvYWREYXRhTWV0aG9kXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgbG9hZE1vZGVsRGF0YSgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgQVZBSUxBQkxFX0JVVFRPTlMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgYWN0aW9uOiBvcGVuTW9kZWxTZWFyY2hBbmRTZWxlY3QsXG4gICAgICAgICAgICBpY29uLFxuICAgICAgICAgICAgY29sb3I6IFwid2FybmluZ1wiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBpZDogMixcbiAgICAgICAgICAgIGFjdGlvbjogcmVzZXRTZWxlY3RlZE1vZGVsLFxuICAgICAgICAgICAgaWNvbjogXCJ0aW1lc1wiLFxuICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgIH0sXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGdldE1vZGVsQnV0dG9uKCkge1xuICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBsb2FkaW5nTGFiZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGVsRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiByZWFkb25seSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBvcGVuTW9kZWxTZWFyY2hBbmRTZWxlY3QsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXIobW9kZWxEYXRhKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGlzRW1wdHlMYWJlbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IFZJU0lCTEVfQlVUVE9OUyA9ICRzdGF0ZShbXSk7XG4gICAgcnVuKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBWSVNJQkxFX0JVVFRPTlMgPSBbXG4gICAgICAgICAgICAgICAgZ2V0TW9kZWxCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAuLi4ocmVhZG9ubHkgPyBbXSA6IEFWQUlMQUJMRV9CVVRUT05TKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBWSVNJQkxFX0JVVFRPTlMgPSBbXG4gICAgICAgICAgICAgICAgZ2V0TW9kZWxCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAuLi4ocmVhZG9ubHkgPyBbXSA6IFtBVkFJTEFCTEVfQlVUVE9OU1swXV0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgPFVJQnV0dG9ucyB2YWx1ZXM9e1ZJU0lCTEVfQlVUVE9OU30gY2xhc3Nlcz17XCJpcy1uby1mbGV4LXdyYXBcIn0+PC9VSUJ1dHRvbnM+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21heF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbWF4ID0gMTAwLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxwcm9ncmVzc1xuICAgIGNsYXNzPVwiXG4gIHByb2dyZXNzXG4gIHtjbGFzc2VzfVxuICB7Y29sb3IgPyBgaXMtJHtjb2xvcn1gIDogJyd9XG4gIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCJcbiAgICB7dmFsdWV9XG4gICAge21heH0+e3ZhbHVlfSU8L3Byb2dyZXNzXG4+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHJ1biB9IGZyb20gXCJzdmVsdGUvbGVnYWN5XCI7XG5cbiAgICBjb25zdCBkZWZhdWx0RmlsdGVyID0gKHZhbHVlKSA9PiB2YWx1ZVtpZEZpZWxkTmFtZV0gPT09IGlkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZXNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGlkXG4gICAgICogQHByb3BlcnR5IHthbnl9IFVJQ29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHthbnl9IFVJUGxhY2Vob2xkZXJcbiAgICAgKiBAcHJvcGVydHkge2FueX0gYWN0aXZlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZEZpZWxkTmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ZpbHRlcl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGlkLFxuICAgICAgICBVSUNvbXBvbmVudCxcbiAgICAgICAgVUlQbGFjZWhvbGRlcixcbiAgICAgICAgYWN0aXZlID0gJGJpbmRhYmxlKCksXG4gICAgICAgIGlkRmllbGROYW1lID0gXCJfaWRcIixcbiAgICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgYWN0aXZlID1cbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiB2YWx1ZXMubGVuZ3RoICYmIHR5cGVvZiBpZCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gdmFsdWVzLmZpbmQoZmlsdGVyIHx8IGRlZmF1bHRGaWx0ZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBhY3RpdmV9XG4gICAgPFVJQ29tcG9uZW50IHsuLi5hY3RpdmV9IC8+XG57OmVsc2UgaWYgVUlQbGFjZWhvbGRlcn1cbiAgICA8VUlQbGFjZWhvbGRlciAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuL3VpLnRhZy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gLSBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyB0YWdcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbnNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbnNHcm91cENvbnRydWN0b3JdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25zR3JvdXBQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInRhZ2dlZFZhbHVlSWRcIixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgYWN0aW9uc0dyb3VwQ29udHJ1Y3RvciA9IFVJQnV0dG9ucyxcbiAgICAgICAgYWN0aW9uc0dyb3VwUHJvcHMgPSB7fSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInRhZ3MgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIiB7aWR9PlxuICAgIHsjaWYgdGl0bGV9PFVJVGFnIHsuLi50aXRsZX0gLz57L2lmfVxuICAgIHsjaWYgdmFsdWV9PFVJVGFnIHsuLi52YWx1ZX0gLz57L2lmfVxuICAgIHsjaWYgIXJlYWRvbmx5ICYmIGFjdGlvbnMgJiYgYWN0aW9ucy5sZW5ndGh9XG4gICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gYWN0aW9uc0dyb3VwQ29udHJ1Y3Rvcn1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudCB2YWx1ZXM9e2FjdGlvbnN9IHsuLi5hY3Rpb25zR3JvdXBQcm9wc30gLz5cbiAgICB7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIC8qIGVzbGludCBzdmVsdGUvbm8tYXQtaHRtbC10YWdzOiAwICovXG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBzdWJ0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gc3Vic2l6ZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NwYWNlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FsaWduXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IGB0aXRsZS0ke01hdGgucmFuZG9tKCl9YCxcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBzdWJ0aXRsZSxcbiAgICAgICAgc2l6ZSA9IDEsXG4gICAgICAgIHN1YnNpemUsXG4gICAgICAgIHNwYWNlZCA9IGZhbHNlLFxuICAgICAgICBhbGlnbiA9IFwibGVmdFwiLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGV4cG9ydCBjb25zdCBzY3JvbGxUb1RvcCA9IChvcHRpb25zID0gVUlDb21tb24uU0NST0xMX09QVElPTlMpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc2Nyb2xsSW50b1ZpZXcob3B0aW9ucyk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfTtcblxuICAgIGxldCBzaXplMiA9ICRkZXJpdmVkKFxuICAgICAgICBzdWJzaXplID8gc3Vic2l6ZSA6IHBhcnNlSW50KHNpemUpIDwgNiA/IHBhcnNlSW50KHNpemUpICsgMSA6IHNpemVcbiAgICApO1xuXG4gICAgbGV0IHNwYWNlZFN0eWxlID0gJGRlcml2ZWQoc3BhY2VkID8gXCJpcy1zcGFjZWRcIiA6IFwiXCIpO1xuXG4gICAgbGV0IHJlc3VsdFRpdGxlID0gJGRlcml2ZWQoXG4gICAgICAgIGA8aCR7c2l6ZX0gaWQ9XCIke2lkfVwiIHN0eWxlPVwidGV4dC1hbGlnbjogJHthbGlnbn07XCIgY2xhc3M9XCJ0aXRsZSAke3NwYWNlZFN0eWxlfSBpcy0ke3NpemV9XCI+JHskTE9DQUxFW3RpdGxlXX08L2gke3NpemV9PmBcbiAgICApO1xuICAgIGxldCByZXN1bHRTdWJ0aXRsZSA9ICRkZXJpdmVkKFxuICAgICAgICBgPGgke3NpemUyfSBpZD1cIiR7aWR9XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiAke2FsaWdufTtcIiBjbGFzcz1cInN1YnRpdGxlIGlzLSR7c2l6ZTJ9XCI+JHskTE9DQUxFW3N1YnRpdGxlXX08L2gke3NpemUyfT5gXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I2lmIHRpdGxlfVxuICAgIHtAaHRtbCByZXN1bHRUaXRsZX1cbnsvaWZ9XG5cbnsjaWYgc3VidGl0bGV9XG4gICAge0BodG1sIHJlc3VsdFN1YnRpdGxlfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheTxzdHJpbmc+fSAgW2Vycm9ycyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3cgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZCA9ICdlcnJvcnMtbGlzdCddXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgICBzaG93ID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaWQgPSBcImVycm9ycy1saXN0XCIsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgQXJyYXkuaXNBcnJheShlcnJvcnMpICYmIGVycm9ycy5sZW5ndGh9XG4gICAgPHAgY2xhc3M9XCJoZWxwIHtjbGFzc2VzfVwiIHtpZH0+XG4gICAgICAgIHsjaWYgc2hvd31cbiAgICAgICAgICAgIHsjZWFjaCBlcnJvcnMgYXMgZXJyb3IsIGluZGV4fVxuICAgICAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW2Vycm9yXX08L3NwYW4+e2luZGV4IDwgZXJyb3JzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgPyBcIiwgXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwifVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7OmVsc2V9Jm5ic3A7ey9pZn1cbiAgICA8L3A+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG5cbiAgICBcbiAgICBcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VzZXJuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9sZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2V2ZW50c11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3JlZ2lzdGVyXSAtIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtvblVwZGF0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInVzZXJDYXJkXCIsXG4gICAgICAgIGltYWdlID0gXCJodHRwczovL2J1bG1hLmlvL2ltYWdlcy9wbGFjZWhvbGRlcnMvMzJ4MzIucG5nXCIsXG4gICAgICAgIHVzZXJuYW1lID0gJGJpbmRhYmxlKFwiSm9obiBEb2VcIiksXG4gICAgICAgIHJvbGUgPSAkYmluZGFibGUoXCJhZG1pblwiKSxcbiAgICAgICAgZXZlbnRzID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMsXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwidXNlcm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZSA9IGRhdGEudXNlcm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwicm9sZVwiKSkge1xuICAgICAgICAgICAgICAgIHJvbGUgPSBkYXRhLnJvbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRDb21wSWQoKSB7XG4gICAgICAgIHJldHVybiBgdXNlcmNhcmQtJHtpZH1gO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkge1xuICAgICAgICBsZXQgY29tcElkID0gZ2V0Q29tcElkKCk7XG4gICAgICAgIHJldHVybiBgJHtjb21wSWR9OnVwZGF0ZWA7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxhcnRpY2xlIGlkPXtnZXRDb21wSWQoKX0gY2xhc3M9XCJtZWRpYVwiPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJtZWRpYS1sZWZ0XCI+XG4gICAgICAgIDxwIGNsYXNzPVwiaW1hZ2UgaXMtMzJ4MzJcIj5cbiAgICAgICAgICAgIDxpbWcgc3JjPXtpbWFnZX0gYWx0PXt1c2VybmFtZX0gLz5cbiAgICAgICAgPC9wPlxuICAgIDwvZmlndXJlPlxuICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPnt1c2VybmFtZX08L3N0cm9uZz5cbiAgICAgICAgICAgICAgICA8c21hbGw+QDwvc21hbGw+XG4gICAgICAgICAgICAgICAgPHN0cm9uZz57cm9sZX08L3N0cm9uZz5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2FydGljbGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgbGV0IGlucCA9ICRzdGF0ZSgpO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRleHRmaWVsZFwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvbmNoYW5nZSk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtdGV4dGZpZWxkLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgb25jaGFuZ2U9e29uaW5wdXR9XG4gICAgICAgIHtvbmlucHV0fVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IFVJVGV4dGZpZWxkIGZyb20gXCIuLi9pbnB1dC91aS50ZXh0ZmllbGQuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbcGxhY2Vob2xkZXJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXJtXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBwbGFjZWhvbGRlciA9ICRMT0NBTEVbXCJub3Qtbm9kZTpmaWVsZF9zZWFyY2hfcGxhY2Vob2xkZXJcIl0sXG4gICAgICAgIHRlcm0gPSAkYmluZGFibGUoXCJcIiksXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoeyBkZXRhaWwgfSkge1xuICAgICAgICBkaXNwYXRjaChcInRlcm1DaGFuZ2VcIiwgZGV0YWlsKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImNvbHVtbnNcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgPFVJVGV4dGZpZWxkXG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17dGVybX1cbiAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgZmllbGRuYW1lPVwic2VhcmNoVGVybUlucHV0XCJcbiAgICAgICAgICAgICAgICBpY29uPVwibWFnbmlmeWluZy1nbGFzc1wiXG4gICAgICAgICAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZvclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWw9J2xhYmVsJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZvcjogZm9ySWQsXG4gICAgICAgIGxhYmVsID0gXCJsYWJlbFwiLFxuICAgICAgICBjbGFzczogbGFiZWxDbGFzcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48bGFiZWwgY2xhc3M9XCJsYWJlbCB7bGFiZWxDbGFzc31cIiBmb3I9e2ZvcklkfT5cbiAgICB7I2lmIGNoaWxkcmVufVxuICAgICAgICB7QHJlbmRlciBjaGlsZHJlbigpfVxuICAgIHs6ZWxzZX17bGFiZWwgPyAkTE9DQUxFW2xhYmVsXSA6IFwiXCJ9ey9pZn1cbjwvbGFiZWw+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBFcnJvcnNMaXN0IGZyb20gXCIuLi92YXJpb3VzL3VpLmVycm9ycy5saXN0LnN2ZWx0ZVwiO1xuXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcImdlbmVyaWMtZmllbGRcIixcbiAgICAgICAgaW5wdXRTdGFydGVkLFxuICAgICAgICB2YWxpZGF0ZWQsXG4gICAgICAgIHZhbGlkLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZvcm1FcnJvcnMsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgYWxsRXJyb3JzID0gJHN0YXRlKFtdKTtcbiAgICBsZXQgc2hvd0Vycm9ycyA9ICRzdGF0ZSh0cnVlKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBhbGxFcnJvcnMgPSBbXG4gICAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShlcnJvcnMpID8gZXJyb3JzIDogW10pLFxuICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZm9ybUVycm9ycykgPyBmb3JtRXJyb3JzIDogW10pLFxuICAgICAgICBdO1xuICAgICAgICBzaG93RXJyb3JzID0gaW5wdXRTdGFydGVkICYmIHZhbGlkYXRlZCAmJiAhdmFsaWQ7XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPEVycm9yc0xpc3Qgc2hvdz17c2hvd0Vycm9yc30gZXJyb3JzPXthbGxFcnJvcnN9IGNsYXNzPXtjbGFzc2VzfSB7aWR9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b24uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuLi92YXJpb3VzL3VpLnRhZy5zdmVsdGVcIjtcblxuICAgIGxldCB7IGJ1dHRvbiA9IHt9LCB0YWcgPSB7fSwgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBzaWRpbmcgPSAkc3RhdGUoXCJcIik7XG4gICAgbGV0IHZhcnMgPSAkc3RhdGUoe30pO1xuXG4gICAgZnVuY3Rpb24gYWRkVmVydGljYWxDZW50ZXJpbmdJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCFib3R0b20gJiYgIXRvcCkge1xuICAgICAgICAgICAgc2lkaW5nICs9IGAgaXMtdmVydGljYWwtY2VudGVyZWRgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkSG9yaXpvbnRhbENlbnRlcmluZ0lmTmVlZGVkKCkge1xuICAgICAgICBpZiAoIXJpZ2h0ICYmICFsZWZ0KSB7XG4gICAgICAgICAgICBzaWRpbmcgKz0gYCBpcy1ob3Jpem9udGFsLWNlbnRlcmVkYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgc2lkaW5nICs9IGAgaXMtc2lkZWQtbGVmdGA7XG4gICAgICAgICAgICB2YXJzW2AtLXNpZGluZy1sZWZ0LXNpemVgXSA9IGxlZnQ7XG4gICAgICAgICAgICBhZGRWZXJ0aWNhbENlbnRlcmluZ0lmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgICAgICBzaWRpbmcgKz0gYCBpcy1zaWRlZC1yaWdodGA7XG4gICAgICAgICAgICB2YXJzW1wiLS1zaWRpbmctcmlnaHQtc2l6ZVwiXSA9IHJpZ2h0O1xuICAgICAgICAgICAgYWRkVmVydGljYWxDZW50ZXJpbmdJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHNpZGluZyArPSBgIGlzLXNpZGVkLXRvcGA7XG4gICAgICAgICAgICB2YXJzW1wiLS1zaWRpbmctdG9wLXNpemVcIl0gPSB0b3A7XG4gICAgICAgICAgICBhZGRIb3Jpem9udGFsQ2VudGVyaW5nSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm90dG9tKSB7XG4gICAgICAgICAgICBzaWRpbmcgKz0gYCBpcy1zaWRlZC1ib3R0b21gO1xuICAgICAgICAgICAgdmFyc1tcIi0tc2lkaW5nLWJvdHRvbS1zaXplXCJdID0gYm90dG9tO1xuICAgICAgICAgICAgYWRkSG9yaXpvbnRhbENlbnRlcmluZ0lmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFycyA9IHZhcnM7XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPHNwYW5cbiAgICBjbGFzcz1cImlzLXJlbGF0aXZlXCJcbiAgICBzdHlsZT1cImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IGZpdC1jb250ZW50OyBoZWlnaHQ6IGZpdC1jb250ZW50OyBcIlxuPlxuICAgIDxVSUJ1dHRvbiB7Li4uYnV0dG9ufSAvPlxuICAgIDxVSVRhZyB7Li4udGFnfSBjbGFzcz1cImlzLXBhZGRlZC1zbWFsbCBpcy1zaWRlZCB7c2lkaW5nfVwiIHt2YXJzfSAvPlxuPC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0cmlnZ2VyXSAtIGV4cG9ydCBsZXQgZGlyZWN0aW9uID0gJ2xlZnQnOyAgLy9sZWZ0L3JpZ2h0L3RvcC9ib3R0b20vYXJvdW5kXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRyaWdnZXIgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCJDbGljayBtZSFcIixcbiAgICAgICAgICAgIGljb246IFwicGx1c1wiLFxuICAgICAgICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgc2l6ZTogXCJtZWRpdW1cIixcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRvcCA9IFwiMmVtXCIsXG4gICAgICAgIGxlZnQgPSBcIjJlbVwiLFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHBvc2l0aW9uU3R5bGUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgcG9zaXRpb25TdHlsZSA9IFwiXCI7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYHRvcDogJHt0b3B9O2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYGxlZnQ6ICR7bGVmdH07YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYHJpZ2h0OiAke3JpZ2h0fTtgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3R0b20pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYGJvdHRvbTogJHtib3R0b219O2A7XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiaXMtYWJzb2x1dGUge2NsYXNzZXN9XCIgc3R5bGU9e3Bvc2l0aW9uU3R5bGV9PlxuICAgIDxVSUJ1dHRvbiB7Li4udHJpZ2dlcn0gLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udCA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpZGUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50YWJsZSA9IGZhbHNlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGZvbnQgPSBcIlwiLFxuICAgICAgICBzaWRlID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIHBvaW50YWJsZSA9IGZhbHNlLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIHRpdGxlfVxuICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10ZXh0IHtwb2ludGFibGUgPyAnaXMtY2xpY2thYmxlJyA6ICcnfVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImljb24ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj5cbiAgICAgICAgICAgIDxpXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpcy10aXRsZS1pY29uIGZhc1xuICAgICAgZmEte2ZvbnR9XG4gICAgICB7c2l6ZSA9PSAnbWVkaXVtJyA/ICdmYS1sZycgOiAnJ31cbiAgICAgIHtzaXplID09ICdsYXJnZScgPyAnZmEtMngnIDogJyd9XG4gICAgICBcIlxuICAgICAgICAgICAgPjwvaT5cbiAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW3RpdGxlXX08L3NwYW4+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG57OmVsc2V9XG4gICAgPHNwYW5cbiAgICAgICAgY2xhc3M9XCJcbiAgICAgICAge3BvaW50YWJsZSA/ICdpcy1jbGlja2FibGUnIDogJyd9XG4gICAgICAgIHtzaWRlID8gYGlzLSR7c2lkZX1gIDogJyd9XG4gICAgICAgIGljb24ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge3NpemUgPT0gJ21lZGl1bScgPyAnZmEtbGcnIDogJyd9XG57c2l6ZSA9PSAnbGFyZ2UnID8gJ2ZhLTJ4JyA6ICcnfVwiXG4gICAgPlxuICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS17Zm9udH1cIj48L2k+XG4gICAgPC9zcGFuPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgLyogZXNsaW50IHN2ZWx0ZS9uby1hdC1odG1sLXRhZ3M6IDAgKi9cblxuICAgIGltcG9ydCBVSUljb25Gb250IGZyb20gXCIuL3VpLmljb24uZm9udC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZSA9IFwiXCJdIC0gZm9udCBpY29uIHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplID0gXCJcIl0gIC0gZm9udCBpY29uIHNpemVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnQgPSBcIlwiXSAtIGZvbnQgaWNvbiBuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdmcgPSBcIlwiXSAtIHN2ZyBpY29uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzcmMgPSBcIlwiXSAtIGltYWdlIGljb25cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IHdpZHRoXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSBoZWlnaHRcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgZm9udCA9IFwiXCIsXG4gICAgICAgIHN2ZyA9IFwiXCIsXG4gICAgICAgIHNyYyA9IFwiXCIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgZm9udH1cbiAgICA8VUlJY29uRm9udCB7Zm9udH0ge3NpemV9IHt0aXRsZX0+PC9VSUljb25Gb250PlxuezplbHNlIGlmIHN2Z31cbiAgICA8c3BhbiBjbGFzcz1cImljb25cIj57QGh0bWwgc3ZnfTwvc3Bhbj5cbns6ZWxzZSBpZiBzcmN9XG4gICAgPGZpZ3VyZSBjbGFzcz1cImltYWdlIHt3aWR0aCAmJiBoZWlnaHQgPyBgaXMtJHt3aWR0aH14JHtoZWlnaHR9YCA6ICcnfSBcIj5cbiAgICAgICAgPGltZyB7c3JjfSB7dGl0bGV9IGFsdD17dGl0bGV9IHt3aWR0aH0ge2hlaWdodH0gLz5cbiAgICA8L2ZpZ3VyZT5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFVJSWNvbkZvbnQgfSBmcm9tIFwiLi4vaWNvblwiO1xuXG4gICAgbGV0IHsgdmFsaWRhdGVkLCB2YWxpZCwgc2lkZSA9IFwicmlnaHRcIiwgc2l6ZSA9IFwic21hbGxcIiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiB2YWxpZGF0ZWQgPT09IHRydWV9XG4gICAgPFVJSWNvbkZvbnQgZm9udD17dmFsaWQgPyBcImNoZWNrXCIgOiBcImV4Y2xhbWF0aW9uLXRyaWFuZ2xlXCJ9IHtzaWRlfSB7c2l6ZX0gLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUZvcm1JbnB1dFZhbGlkYXRlZEljb24gZnJvbSBcIi4vdWkuZm9ybS5pbnB1dC52YWxpZGF0ZWQuaWNvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUljb25Gb250IH0gZnJvbSBcIi4uL2ljb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gIFVJSW5wdXRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGR0eXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZpZWxkbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lUHJlZml4ID0gXCJmb3JtLWZpZWxkLVwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkID0gZmFsc2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICByZWFkb25seSxcbiAgICAgICAgVUlJbnB1dCxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZpZWxkdHlwZSxcbiAgICAgICAgZmllbGRuYW1lLFxuICAgICAgICBmaWVsZG5hbWVQcmVmaXggPSBcImZvcm0tZmllbGQtXCIsXG4gICAgICAgIGljb24sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVkID0gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlJbnB1dCB7ZmllbGR0eXBlfSB7ZmllbGRuYW1lfSB7dmFsaWR9IHtyZWFkb25seX0gYmluZDp2YWx1ZSB7Li4ub3RoZXJzfSAvPlxuPCEtLSBlZGl0IFVJIHJlbmRlcmVyIC0tPlxueyNpZiBpY29ufVxuICAgIDxVSUljb25Gb250IGZvbnQ9e2ljb259IHNpZGU9e1wibGVmdFwifSBzaXplPXtcInNtYWxsXCJ9IC8+XG57L2lmfVxueyNpZiAhcmVhZG9ubHl9XG4gICAgPCEtLSB2YWxpZGF0ZWQgYW5kIHZhbGlkIHNob3VsZCBiZSBjcmVhdGVkIGJ5ICRzdGF0ZSgpIC0tPlxuICAgIDxVSUZvcm1JbnB1dFZhbGlkYXRlZEljb24ge3ZhbGlkYXRlZH0ge3ZhbGlkfT48L1VJRm9ybUlucHV0VmFsaWRhdGVkSWNvbj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcz0nJ11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBpZCwgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLCBjaGlsZHJlbiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiB7aWR9IGNsYXNzPVwiY29udHJvbCB7Y2xhc3Nlc31cIj57QHJlbmRlciBjaGlsZHJlbj8uKCl9PC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxhYmVsIGZyb20gXCIuLi9pbnB1dC91aS5sYWJlbC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgSW5wdXRFcnJvcnMgZnJvbSBcIi4vdWkuZm9ybS5pbnB1dC5lcnJvcnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJRm9ybUlucHV0IGZyb20gXCIuL3VpLmZvcm0uaW5wdXQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udHJvbCBmcm9tIFwiLi4vaW5wdXQvdWkuY29udHJvbC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW5wdXRTdGFydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGRuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZpZWxkdHlwZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ljb25dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZWRdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uL2V2ZW50cy50eXBlcycpLlVJRXZlbnRJbnB1dENoYW5nZUNhbGxiYWNrfSBbb25jaGFuZ2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Vycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtRXJyb3JzXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgVUlJbnB1dCxcbiAgICAgICAgaW5wdXRTdGFydGVkID0gZmFsc2UsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsYWJlbFZlcnRpY2FsID0gdHJ1ZSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZHR5cGUsXG4gICAgICAgIGZpZWxkbmFtZSxcbiAgICAgICAgZmllbGRuYW1lUHJlZml4ID0gXCJmb3JtLWZpZWxkLVwiLFxuICAgICAgICBpY29uID0gXCJcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmb3JtRXJyb3JzID0gW10sXG4gICAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaWNvbkNsYXNzZXMgPSAkZGVyaXZlZChcbiAgICAgICAgKGljb24gPyBcIiBoYXMtaWNvbnMtbGVmdCBcIiA6IFwiXCIpICsgXCIgaGFzLWljb25zLXJpZ2h0IFwiXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgY29udHJvbCgpfVxuICAgIDxVSUNvbnRyb2wgY2xhc3M9e2ljb25DbGFzc2VzfT5cbiAgICAgICAgPFVJRm9ybUlucHV0XG4gICAgICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgICAgICB7VUlJbnB1dH1cbiAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIHtmaWVsZHR5cGV9XG4gICAgICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICAgICAge2ZpZWxkbmFtZVByZWZpeH1cbiAgICAgICAgICAgIHtpY29ufVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge2lucHV0U3RhcnRlZH1cbiAgICAgICAgICAgIHt2YWxpZGF0ZWR9XG4gICAgICAgICAgICB7dmFsaWR9XG4gICAgICAgICAgICB7b25jaGFuZ2V9XG4gICAgICAgICAgICB7b25lcnJvcn1cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgPC9VSUNvbnRyb2w+XG57L3NuaXBwZXR9XG5cbnsjaWYgbGFiZWx9XG4gICAgeyNpZiBsYWJlbFZlcnRpY2FsfVxuICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgY2xhc3M9e2ZpZWxkdHlwZX1cbiAgICAgICAgICAgIGZvcj1cIntmaWVsZG5hbWVQcmVmaXh9e2ZpZWxkdHlwZX0te2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAvPlxuICAgICAgICB7QHJlbmRlciBjb250cm9sKCl9XG4gICAgezplbHNlfVxuICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgY2xhc3M9e2ZpZWxkdHlwZX1cbiAgICAgICAgICAgIGZvcj1cIntmaWVsZG5hbWVQcmVmaXh9e2ZpZWxkdHlwZX0te2ZpZWxkbmFtZX1cIlxuICAgICAgICA+XG4gICAgICAgICAgICB7bGFiZWx9OiB7QHJlbmRlciBjb250cm9sKCl9XG4gICAgICAgIDwvVUlMYWJlbD5cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIHtAcmVuZGVyIGNvbnRyb2woKX1cbnsvaWZ9XG5cbjxJbnB1dEVycm9yc1xuICAgIHtpbnB1dFN0YXJ0ZWR9XG4gICAge3ZhbGlkYXRlZH1cbiAgICB7dmFsaWR9XG4gICAge2Vycm9yc31cbiAgICB7Zm9ybUVycm9yc31cbiAgICBpZD1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4vPlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsRnVsbF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdXJsXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FsdF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvcnM9J2Fub255bW91cyddXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplID0gNjRdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHRdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb250YWluZWQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY292ZXJlZD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwb2ludGFibGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB1cmxGdWxsLFxuICAgICAgICB1cmwsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBhbHQsXG4gICAgICAgIGNvcnMgPSBcImFub255bW91c1wiLFxuICAgICAgICBzaXplID0gNjQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNvbnRhaW5lZCA9IGZhbHNlLFxuICAgICAgICBjb3ZlcmVkID0gZmFsc2UsXG4gICAgICAgIHBvaW50YWJsZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNsaWNrID0gdW5kZWZpbmVkLFxuICAgICAgICBvbmtleXVwID0gdW5kZWZpbmVkLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgaW1hZ2VGaWd1cmUoKX1cbiAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeV9ub19ub25pbnRlcmFjdGl2ZV9lbGVtZW50X2ludGVyYWN0aW9ucyAtLT5cbiAgICA8ZmlndXJlXG4gICAgICAgIGNsYXNzPVwiaW1hZ2Uge2NsYXNzZXN9IHshd2lkdGggJiYgIWhlaWdodFxuICAgICAgICAgICAgPyBpc05hTihzaXplKVxuICAgICAgICAgICAgICAgID8gYGlzLSR7c2l6ZX1gXG4gICAgICAgICAgICAgICAgOiBgaXMtJHtzaXplfXgke3NpemV9YFxuICAgICAgICAgICAgOiAnJ31cIlxuICAgICAgICBjbGFzczppcy1jb250YWluZWQ9e2NvbnRhaW5lZH1cbiAgICAgICAgY2xhc3M6aXMtY292ZXJlZD17Y292ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtY2xpY2thYmxlPXsob25jbGljayAmJiBwb2ludGFibGUgIT09IGZhbHNlKSB8fCBwb2ludGFibGV9XG4gICAgICAgIHN0eWxlPXsod2lkdGggPyBgd2lkdGg6ICR7d2lkdGh9O2AgOiBcIlwiKSArXG4gICAgICAgICAgICAoaGVpZ2h0ID8gYGhlaWdodDogJHtoZWlnaHR9O2AgOiBcIlwiKX1cbiAgICA+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAge29ua2V5dXB9XG4gICAgICAgICAgICBjbGFzcz1cIlwiXG4gICAgICAgICAgICBhbHQ9e2FsdCB8fCB0aXRsZX1cbiAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgIHNyYz17dXJsfVxuICAgICAgICAgICAgY3Jvc3NPcmlnaW49e2NvcnN9XG4gICAgICAgIC8+XG4gICAgPC9maWd1cmU+XG57L3NuaXBwZXR9XG5cbnsjaWYgdXJsRnVsbH1cbiAgICA8YSBocmVmPXt1cmxGdWxsfSB0aXRsZT17dGl0bGUgfHwgYWx0fSB7b25jbGlja30+XG4gICAgICAgIHtAcmVuZGVyIGltYWdlRmlndXJlKCl9XG4gICAgPC9hPlxuezplbHNlfVxuICAgIHtAcmVuZGVyIGltYWdlRmlndXJlKCl9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi91aS5pbWFnZS5zdmVsdGVcIjtcblxuICAgIGxldCB7IHZhbHVlcyA9IFtdLCAuLi5vdmVycmlkZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNlYWNoIHZhbHVlcyBhcyBpdGVtIChpdGVtLnVybCl9XG4gICAgPFVJSW1hZ2Ugey4uLml0ZW19IHsuLi5vdmVycmlkZX0gLz5cbnsvZWFjaH1cbiIsImltcG9ydCB7IGVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi9pbmRleC5qcyc7XG5cbmVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnKCk7XG4iLCIvKlxuQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbFxuRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Vhc2VzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuXHRyZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbih0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuXHRjb25zdCBhID0gNC4wIC8gMTEuMDtcblx0Y29uc3QgYiA9IDguMCAvIDExLjA7XG5cdGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuXHRjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuXHRjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG5cdGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0cmV0dXJuIHQgPCBhXG5cdFx0PyA3LjU2MjUgKiB0MlxuXHRcdDogdCA8IGJcblx0XHRcdD8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjRcblx0XHRcdDogdCA8IGNcblx0XHRcdFx0PyBjYSAqIHQyIC0gY2IgKiB0ICsgY2Ncblx0XHRcdFx0OiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKSA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcblx0cmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW4odCkge1xuXHRyZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNVxuXHRcdD8gMC41ICogTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcblx0XHQ6IDAuNSAqXG5cdFx0XHRcdE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG5cdFx0XHRcdE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcblx0XHRcdFx0MS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcblx0XHQ/IHRcblx0XHQ6IHQgPCAwLjVcblx0XHRcdD8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuXHRcdFx0OiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luKHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCA/IHQgOiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb091dCh0KSB7XG5cdHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcblx0dCAvPSAwLjU7XG5cdGlmICh0IDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0O1xuXHR0LS07XG5cdHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW4odCkge1xuXHRyZXR1cm4gdCAqIHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkT3V0KHQpIHtcblx0cmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gKzguMCAqIE1hdGgucG93KHQsIDQuMCkgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuXHRyZXR1cm4gTWF0aC5wb3codCwgNC4wKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0T3V0KHQpIHtcblx0cmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludEluT3V0KHQpIHtcblx0aWYgKCh0ICo9IDIpIDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRJbih0KSB7XG5cdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcblx0cmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcblx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lSW4odCkge1xuXHRjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuXHRpZiAoTWF0aC5hYnModikgPCAxZS0xNCkgcmV0dXJuIDE7XG5cdGVsc2UgcmV0dXJuIDEgLSB2O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZU91dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG4iLCIvKiogQGltcG9ydCB7IEZsaXBQYXJhbXMsIEFuaW1hdGlvbkNvbmZpZyB9IGZyb20gJy4vcHVibGljLmpzJyAqL1xuaW1wb3J0IHsgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXguanMnO1xuXG4vKipcbiAqIFRoZSBmbGlwIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBhbmQgYW5pbWF0ZXMgYmV0d2VlbiB0aGVtLCB0cmFuc2xhdGluZyB0aGUgeCBhbmQgeSB2YWx1ZXMuXG4gKiBgZmxpcGAgc3RhbmRzIGZvciBbRmlyc3QsIExhc3QsIEludmVydCwgUGxheV0oaHR0cHM6Ly9hZXJvdHdpc3QuY29tL2Jsb2cvZmxpcC15b3VyLWFuaW1hdGlvbnMvKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7eyBmcm9tOiBET01SZWN0OyB0bzogRE9NUmVjdCB9fSBmcm9tVG9cbiAqIEBwYXJhbSB7RmxpcFBhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxpcChub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyA9IHt9KSB7XG5cdHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdHZhciB6b29tID0gZ2V0X3pvb20obm9kZSk7IC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtdmlld3BvcnQvI2VmZmVjdGl2ZS16b29tXG5cblx0dmFyIHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdHZhciBbb3gsIG95XSA9IHN0eWxlLnRyYW5zZm9ybU9yaWdpbi5zcGxpdCgnICcpLm1hcChwYXJzZUZsb2F0KTtcblx0dmFyIGRzeCA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcblx0dmFyIGRzeSA9IGZyb20uaGVpZ2h0IC8gdG8uaGVpZ2h0O1xuXG5cdHZhciBkeCA9IChmcm9tLmxlZnQgKyBkc3ggKiBveCAtICh0by5sZWZ0ICsgb3gpKSAvIHpvb207XG5cdHZhciBkeSA9IChmcm9tLnRvcCArIGRzeSAqIG95IC0gKHRvLnRvcCArIG95KSkgLyB6b29tO1xuXHR2YXIgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gKGQpID0+IE1hdGguc3FydChkKSAqIDEyMCwgZWFzaW5nID0gY3ViaWNPdXQgfSA9IHBhcmFtcztcblxuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uOiB0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicgPyBkdXJhdGlvbihNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKSA6IGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0LCB1KSA9PiB7XG5cdFx0XHR2YXIgeCA9IHUgKiBkeDtcblx0XHRcdHZhciB5ID0gdSAqIGR5O1xuXHRcdFx0dmFyIHN4ID0gdCArIHUgKiBkc3g7XG5cdFx0XHR2YXIgc3kgPSB0ICsgdSAqIGRzeTtcblx0XHRcdHJldHVybiBgdHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHtzeH0sICR7c3l9KSB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpO2A7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRfem9vbShlbGVtZW50KSB7XG5cdGlmICgnY3VycmVudENTU1pvb20nIGluIGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbGVtZW50LmN1cnJlbnRDU1Nab29tKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWxlbWVudCB8IG51bGx9ICovXG5cdHZhciBjdXJyZW50ID0gZWxlbWVudDtcblx0dmFyIHpvb20gPSAxO1xuXG5cdHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdFx0em9vbSAqPSArZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50KS56b29tO1xuXHRcdGN1cnJlbnQgPSAvKiogQHR5cGUge0VsZW1lbnQgfCBudWxsfSAqLyAoY3VycmVudC5wYXJlbnRFbGVtZW50KTtcblx0fVxuXG5cdHJldHVybiB6b29tO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBCbHVyUGFyYW1zLCBDcm9zc2ZhZGVQYXJhbXMsIERyYXdQYXJhbXMsIEZhZGVQYXJhbXMsIEZseVBhcmFtcywgU2NhbGVQYXJhbXMsIFNsaWRlUGFyYW1zLCBUcmFuc2l0aW9uQ29uZmlnIH0gZnJvbSAnLi9wdWJsaWMnICovXG4vKiogQHBhcmFtIHtudW1iZXJ9IHggKi9cbmNvbnN0IGxpbmVhciA9ICh4KSA9PiB4O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHQgKi9cbmZ1bmN0aW9uIGN1YmljX291dCh0KSB7XG5cdGNvbnN0IGYgPSB0IC0gMS4wO1xuXHRyZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjdWJpY19pbl9vdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5mdW5jdGlvbiBzcGxpdF9jc3NfdW5pdCh2YWx1ZSkge1xuXHRjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuXHRyZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogWy8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodmFsdWUpLCAncHgnXTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhIGBibHVyYCBmaWx0ZXIgYWxvbmdzaWRlIGFuIGVsZW1lbnQncyBvcGFjaXR5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtCbHVyUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHVyKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljX2luX291dCwgYW1vdW50ID0gNSwgb3BhY2l0eSA9IDAgfSA9IHt9XG4pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCBmID0gc3R5bGUuZmlsdGVyID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLmZpbHRlcjtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdGNvbnN0IFt2YWx1ZSwgdW5pdF0gPSBzcGxpdF9jc3NfdW5pdChhbW91bnQpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfdCwgdSkgPT4gYG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9OyBmaWx0ZXI6ICR7Zn0gYmx1cigke3UgKiB2YWx1ZX0ke3VuaXR9KTtgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCBmcm9tIDAgdG8gdGhlIGN1cnJlbnQgb3BhY2l0eSBmb3IgYGluYCB0cmFuc2l0aW9ucyBhbmQgZnJvbSB0aGUgY3VycmVudCBvcGFjaXR5IHRvIDAgZm9yIGBvdXRgIHRyYW5zaXRpb25zLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtGYWRlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0gPSB7fSkge1xuXHRjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCkgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSB4IGFuZCB5IHBvc2l0aW9ucyBhbmQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudC4gYGluYCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcy4gYG91dGAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7Rmx5UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHkoXG5cdG5vZGUsXG5cdHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfb3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdGNvbnN0IFt4X3ZhbHVlLCB4X3VuaXRdID0gc3BsaXRfY3NzX3VuaXQoeCk7XG5cdGNvbnN0IFt5X3ZhbHVlLCB5X3VuaXRdID0gc3BsaXRfY3NzX3VuaXQoeSk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgkeygxIC0gdCkgKiB4X3ZhbHVlfSR7eF91bml0fSwgJHsoMSAtIHQpICogeV92YWx1ZX0ke3lfdW5pdH0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX1gXG5cdH07XG59XG5cbi8qKlxuICogU2xpZGVzIGFuIGVsZW1lbnQgaW4gYW5kIG91dC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U2xpZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfb3V0LCBheGlzID0gJ3knIH0gPSB7fSkge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eSA9IGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbcHJpbWFyeV9wcm9wZXJ0eV0pO1xuXHRjb25zdCBzZWNvbmRhcnlfcHJvcGVydGllcyA9IGF4aXMgPT09ICd5JyA/IFsndG9wJywgJ2JvdHRvbSddIDogWydsZWZ0JywgJ3JpZ2h0J107XG5cdGNvbnN0IGNhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzID0gc2Vjb25kYXJ5X3Byb3BlcnRpZXMubWFwKFxuXHRcdChlKSA9PiAvKiogQHR5cGUgeydMZWZ0JyB8ICdSaWdodCcgfCAnVG9wJyB8ICdCb3R0b20nfSAqLyAoYCR7ZVswXS50b1VwcGVyQ2FzZSgpfSR7ZS5zbGljZSgxKX1gKVxuXHQpO1xuXHRjb25zdCBwYWRkaW5nX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuXHRjb25zdCBwYWRkaW5nX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYHBhZGRpbmcke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfWBdKTtcblx0Y29uc3QgbWFyZ2luX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgbWFyZ2luJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG5cdGNvbnN0IG1hcmdpbl9lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BtYXJnaW4ke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfWBdKTtcblx0Y29uc3QgYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChcblx0XHRzdHlsZVtgYm9yZGVyJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1XaWR0aGBdXG5cdCk7XG5cdGNvbnN0IGJvcmRlcl93aWR0aF9lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KFxuXHRcdHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfVdpZHRoYF1cblx0KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCkgPT5cblx0XHRcdCdvdmVyZmxvdzogaGlkZGVuOycgK1xuXHRcdFx0YG9wYWNpdHk6ICR7TWF0aC5taW4odCAqIDIwLCAxKSAqIG9wYWNpdHl9O2AgK1xuXHRcdFx0YCR7cHJpbWFyeV9wcm9wZXJ0eX06ICR7dCAqIHByaW1hcnlfcHJvcGVydHlfdmFsdWV9cHg7YCArXG5cdFx0XHRgcGFkZGluZy0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfTogJHt0ICogcGFkZGluZ19zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBwYWRkaW5nLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19OiAke3QgKiBwYWRkaW5nX2VuZF92YWx1ZX1weDtgICtcblx0XHRcdGBtYXJnaW4tJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX06ICR7dCAqIG1hcmdpbl9zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBtYXJnaW4tJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX06ICR7dCAqIG1hcmdpbl9lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgYm9yZGVyLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19LXdpZHRoOiAke3QgKiBib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgYm9yZGVyLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19LXdpZHRoOiAke3QgKiBib3JkZXJfd2lkdGhfZW5kX3ZhbHVlfXB4O2Bcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgb3BhY2l0eSBhbmQgc2NhbGUgb2YgYW4gZWxlbWVudC4gYGluYCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMsIHRvIGFuIGVsZW1lbnQncyBjdXJyZW50IChkZWZhdWx0KSB2YWx1ZXMuIGBvdXRgIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSBhbiBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U2NhbGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljX291dCwgc3RhcnQgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdGNvbnN0IHNkID0gMSAtIHN0YXJ0O1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoX3QsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHNjYWxlKCR7MSAtIHNkICogdX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX1cblx0XHRgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIHN0cm9rZSBvZiBhbiBTVkcgZWxlbWVudCwgbGlrZSBhIHNuYWtlIGluIGEgdHViZS4gYGluYCB0cmFuc2l0aW9ucyBiZWdpbiB3aXRoIHRoZSBwYXRoIGludmlzaWJsZSBhbmQgZHJhdyB0aGUgcGF0aCB0byB0aGUgc2NyZWVuIG92ZXIgdGltZS4gYG91dGAgdHJhbnNpdGlvbnMgc3RhcnQgaW4gYSB2aXNpYmxlIHN0YXRlIGFuZCBncmFkdWFsbHkgZXJhc2UgdGhlIHBhdGguIGBkcmF3YCBvbmx5IHdvcmtzIHdpdGggZWxlbWVudHMgdGhhdCBoYXZlIGEgYGdldFRvdGFsTGVuZ3RoYCBtZXRob2QsIGxpa2UgYDxwYXRoPmAgYW5kIGA8cG9seWxpbmU+YC5cbiAqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnQgJiB7IGdldFRvdGFsTGVuZ3RoKCk6IG51bWJlciB9fSBub2RlXG4gKiBAcGFyYW0ge0RyYXdQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXcobm9kZSwgeyBkZWxheSA9IDAsIHNwZWVkLCBkdXJhdGlvbiwgZWFzaW5nID0gY3ViaWNfaW5fb3V0IH0gPSB7fSkge1xuXHRsZXQgbGVuID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGlmIChzdHlsZS5zdHJva2VMaW5lY2FwICE9PSAnYnV0dCcpIHtcblx0XHRsZW4gKz0gcGFyc2VJbnQoc3R5bGUuc3Ryb2tlV2lkdGgpO1xuXHR9XG5cdGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGR1cmF0aW9uID0gODAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkdXJhdGlvbiA9IGxlbiAvIHNwZWVkO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRkdXJhdGlvbiA9IGR1cmF0aW9uKGxlbik7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAoXywgdSkgPT4gYFxuXHRcdFx0c3Ryb2tlLWRhc2hhcnJheTogJHtsZW59O1xuXHRcdFx0c3Ryb2tlLWRhc2hvZmZzZXQ6ICR7dSAqIGxlbn07XG5cdFx0YFxuXHR9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtUfSB0YXJcbiAqIEBwYXJhbSB7U30gc3JjXG4gKiBAcmV0dXJucyB7VCAmIFN9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vKipcbiAqIFRoZSBgY3Jvc3NmYWRlYCBmdW5jdGlvbiBjcmVhdGVzIGEgcGFpciBvZiBbdHJhbnNpdGlvbnNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS90cmFuc2l0aW9uKSBjYWxsZWQgYHNlbmRgIGFuZCBgcmVjZWl2ZWAuIFdoZW4gYW4gZWxlbWVudCBpcyAnc2VudCcsIGl0IGxvb2tzIGZvciBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBiZWluZyAncmVjZWl2ZWQnLCBhbmQgZ2VuZXJhdGVzIGEgdHJhbnNpdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIGVsZW1lbnQgdG8gaXRzIGNvdW50ZXJwYXJ0J3MgcG9zaXRpb24gYW5kIGZhZGVzIGl0IG91dC4gV2hlbiBhbiBlbGVtZW50IGlzICdyZWNlaXZlZCcsIHRoZSByZXZlcnNlIGhhcHBlbnMuIElmIHRoZXJlIGlzIG5vIGNvdW50ZXJwYXJ0LCB0aGUgYGZhbGxiYWNrYCB0cmFuc2l0aW9uIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtDcm9zc2ZhZGVQYXJhbXMgJiB7XG4gKiBcdGZhbGxiYWNrPzogKG5vZGU6IEVsZW1lbnQsIHBhcmFtczogQ3Jvc3NmYWRlUGFyYW1zLCBpbnRybzogYm9vbGVhbikgPT4gVHJhbnNpdGlvbkNvbmZpZztcbiAqIH19IHBhcmFtc1xuICogQHJldHVybnMge1sobm9kZTogYW55LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IFRyYW5zaXRpb25Db25maWcsIChub2RlOiBhbnksIHBhcmFtczogQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gVHJhbnNpdGlvbkNvbmZpZ119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zc2ZhZGUoeyBmYWxsYmFjaywgLi4uZGVmYXVsdHMgfSkge1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuXHQvKiogQHR5cGUge01hcDxhbnksIEVsZW1lbnQ+fSAqL1xuXHRjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21fbm9kZVxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcblx0ICogQHBhcmFtIHtDcm9zc2ZhZGVQYXJhbXN9IHBhcmFtc1xuXHQgKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cblx0ICovXG5cdGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tX25vZGUsIG5vZGUsIHBhcmFtcykge1xuXHRcdGNvbnN0IHtcblx0XHRcdGRlbGF5ID0gMCxcblx0XHRcdGR1cmF0aW9uID0gLyoqIEBwYXJhbSB7bnVtYmVyfSBkICovIChkKSA9PiBNYXRoLnNxcnQoZCkgKiAzMCxcblx0XHRcdGVhc2luZyA9IGN1YmljX291dFxuXHRcdH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG5cdFx0Y29uc3QgZnJvbSA9IGZyb21fbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuXHRcdGNvbnN0IGR5ID0gZnJvbS50b3AgLSB0by50b3A7XG5cdFx0Y29uc3QgZHcgPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG5cdFx0Y29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcblx0XHRjb25zdCBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdFx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0XHRjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlbGF5LFxuXHRcdFx0ZHVyYXRpb246IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGR1cmF0aW9uKGQpIDogZHVyYXRpb24sXG5cdFx0XHRlYXNpbmcsXG5cdFx0XHRjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHQgICBvcGFjaXR5OiAke3QgKiBvcGFjaXR5fTtcblx0XHRcdCAgIHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0ICAgdHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCR7dSAqIGR5fXB4KSBzY2FsZSgke3QgKyAoMSAtIHQpICogZHd9LCAke1xuXHRcdFx0XHRcdFx0dCArICgxIC0gdCkgKiBkaFxuXHRcdFx0XHRcdH0pO1xuXHRcdCAgIGBcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7TWFwPGFueSwgRWxlbWVudD59IGl0ZW1zXG5cdCAqIEBwYXJhbSB7TWFwPGFueSwgRWxlbWVudD59IGNvdW50ZXJwYXJ0c1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGludHJvXG5cdCAqIEByZXR1cm5zIHsobm9kZTogYW55LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IFRyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGltcHJvdmUgdHlwaW5ncyAoYXJlIHRoZSBwdWJsaWMgdHlwZXMgd3Jvbmc/KVxuXHRcdHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG5cdFx0XHRpdGVtcy5zZXQocGFyYW1zLmtleSwgbm9kZSk7XG5cdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuXHRcdFx0XHRcdGNvbnN0IG90aGVyX25vZGUgPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRcdGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG5cdFx0XHRcdFx0cmV0dXJuIGNyb3NzZmFkZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChvdGhlcl9ub2RlKSwgbm9kZSwgcGFyYW1zKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgbm9kZSBpcyBkaXNhcHBlYXJpbmcgYWx0b2dldGhlclxuXHRcdFx0XHQvLyAoaS5lLiB3YXNuJ3QgY2xhaW1lZCBieSB0aGUgb3RoZXIgbGlzdClcblx0XHRcdFx0Ly8gdGhlbiB3ZSBuZWVkIHRvIHN1cHBseSBhbiBvdXRyb1xuXHRcdFx0XHRpdGVtcy5kZWxldGUocGFyYW1zLmtleSk7XG5cdFx0XHRcdHJldHVybiBmYWxsYmFjayAmJiBmYWxsYmFjayhub2RlLCBwYXJhbXMsIGludHJvKTtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW3RyYW5zaXRpb24odG9fc2VuZCwgdG9fcmVjZWl2ZSwgZmFsc2UpLCB0cmFuc2l0aW9uKHRvX3JlY2VpdmUsIHRvX3NlbmQsIHRydWUpXTtcbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGZsaXAgfSBmcm9tIFwic3ZlbHRlL2FuaW1hdGVcIlxuICBpbXBvcnQgeyBmYWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCJcbiAgaW1wb3J0IHthZnRlclVwZGF0ZX0gZnJvbSAnc3ZlbHRlJ1xuXG4gIC8vIHRoZSBsaXN0IG9mIGl0ZW1zICB0aGUgdXNlciBjYW4gc2VsZWN0IGZyb21cbiAgZXhwb3J0IGxldCBpdGVtcyA9IFtdXG5cbiAgLyoqXG4gICAqIGZ1bmN0aW9uIHRvIHVzZSB0byBnZXQgYWxsIGl0ZW1zIChhbHRlcm5hdGl2ZSB0byBwcm92aWRpbmcgaXRlbXMpXG4gICAqIEB0eXBlIHtib29sZWFufGZ1bmN0aW9ufVxuICAgKi9cbiAgZXhwb3J0IGxldCBzZWFyY2hGdW5jdGlvbiA9IGZhbHNlXG5cbiAgLy8gZmllbGQgb2YgZWFjaCBpdGVtIHRoYXQncyB1c2VkIGZvciB0aGUgbGFiZWxzIGluIHRoZSBsaXN0XG4gIGV4cG9ydCBsZXQgbGFiZWxGaWVsZE5hbWUgPSB1bmRlZmluZWRcbiAgZXhwb3J0IGxldCBrZXl3b3Jkc0ZpZWxkTmFtZSA9IGxhYmVsRmllbGROYW1lXG4gIGV4cG9ydCBsZXQgdmFsdWVGaWVsZE5hbWUgPSB1bmRlZmluZWRcblxuICBleHBvcnQgbGV0IGxhYmVsRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsRmllbGROYW1lID8gaXRlbVtsYWJlbEZpZWxkTmFtZV0gOiBpdGVtXG4gIH1cblxuICBleHBvcnQgbGV0IGtleXdvcmRzRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIGtleXdvcmRzRmllbGROYW1lID8gaXRlbVtrZXl3b3Jkc0ZpZWxkTmFtZV0gOiBsYWJlbEZ1bmN0aW9uKGl0ZW0pXG4gIH1cblxuICBleHBvcnQgbGV0IHZhbHVlRnVuY3Rpb24gPSBmdW5jdGlvbiAoaXRlbSwgZm9yY2VTaW5nbGUgPSBmYWxzZSkge1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gICAgaWYgKCFtdWx0aXBsZSB8fCBmb3JjZVNpbmdsZSkge1xuICAgICAgcmV0dXJuIHZhbHVlRmllbGROYW1lID8gaXRlbVt2YWx1ZUZpZWxkTmFtZV0gOiBpdGVtXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVtLm1hcCgoaSkgPT4gKHZhbHVlRmllbGROYW1lID8gaVt2YWx1ZUZpZWxkTmFtZV0gOiBpKSlcbiAgICB9XG4gIH1cblxuICBleHBvcnQgbGV0IGtleXdvcmRzQ2xlYW5GdW5jdGlvbiA9IGZ1bmN0aW9uIChrZXl3b3Jkcykge1xuICAgIHJldHVybiBrZXl3b3Jkc1xuICB9XG5cbiAgZXhwb3J0IGxldCB0ZXh0Q2xlYW5GdW5jdGlvbiA9IGZ1bmN0aW9uICh1c2VyRW50ZXJlZFRleHQpIHtcbiAgICByZXR1cm4gdXNlckVudGVyZWRUZXh0XG4gIH1cblxuICAvLyBldmVudHNcbiAgZXhwb3J0IGxldCBiZWZvcmVDaGFuZ2UgPSBmdW5jdGlvbiAob2xkU2VsZWN0ZWRJdGVtLCBuZXdTZWxlY3RlZEl0ZW0pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGV4cG9ydCBsZXQgb25DaGFuZ2UgPSBmdW5jdGlvbiAobmV3U2VsZWN0ZWRJdGVtKSB7fVxuICBleHBvcnQgbGV0IG9uRm9jdXMgPSBmdW5jdGlvbiAoKSB7fVxuICBleHBvcnQgbGV0IG9uQmx1ciA9IGZ1bmN0aW9uICgpIHt9XG4gIGV4cG9ydCBsZXQgb25DcmVhdGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkNyZWF0ZTogXCIgKyB0ZXh0KVxuICAgIH1cbiAgfVxuXG4gIC8vIEJlaGF2aW91ciBwcm9wZXJ0aWVzXG4gIGV4cG9ydCBsZXQgc2VsZWN0Rmlyc3RJZkVtcHR5ID0gZmFsc2VcbiAgZXhwb3J0IGxldCBtaW5DaGFyYWN0ZXJzVG9TZWFyY2ggPSAxXG4gIGV4cG9ydCBsZXQgbWF4SXRlbXNUb1Nob3dJbkxpc3QgPSAwXG4gIGV4cG9ydCBsZXQgbXVsdGlwbGUgPSBmYWxzZVxuICBleHBvcnQgbGV0IGNyZWF0ZSA9IGZhbHNlXG5cbiAgLy8gaWdub3JlcyB0aGUgYWNjZW50cyB3aGVuIG1hdGNoaW5nIGl0ZW1zXG4gIGV4cG9ydCBsZXQgaWdub3JlQWNjZW50cyA9IHRydWVcblxuICAvLyBhbGwgdGhlIGlucHV0IGtleXdvcmRzIHNob3VsZCBiZSBtYXRjaGVkIGluIHRoZSBpdGVtIGtleXdvcmRzXG4gIGV4cG9ydCBsZXQgbWF0Y2hBbGxLZXl3b3JkcyA9IHRydWVcblxuICAvLyBzb3J0cyB0aGUgaXRlbXMgYnkgdGhlIG51bWJlciBvZiBtYXRjaGluayBrZXl3b3Jkc1xuICBleHBvcnQgbGV0IHNvcnRCeU1hdGNoZWRLZXl3b3JkcyA9IGZhbHNlXG5cbiAgLy8gYWxsb3cgdXNlcnMgdG8gdXNlIGEgY3VzdG9tIGl0ZW0gZmlsdGVyIGZ1bmN0aW9uXG4gIGV4cG9ydCBsZXQgaXRlbUZpbHRlckZ1bmN0aW9uID0gdW5kZWZpbmVkXG5cbiAgLy8gYWxsb3cgdXNlcnMgdG8gdXNlIGEgY3VzdG9tIGl0ZW0gc29ydCBmdW5jdGlvblxuICBleHBvcnQgbGV0IGl0ZW1Tb3J0RnVuY3Rpb24gPSB1bmRlZmluZWRcblxuICAvLyBkbyBub3QgYWxsb3cgcmUtc2VsZWN0aW9uIGFmdGVyIGluaXRpYWwgc2VsZWN0aW9uXG4gIGV4cG9ydCBsZXQgbG9jayA9IGZhbHNlXG5cbiAgLy8gZGVsYXkgdG8gd2FpdCBhZnRlciBhIGtleXByZXNzIHRvIHNlYXJjaCBmb3IgbmV3IGl0ZW1zXG4gIGV4cG9ydCBsZXQgZGVsYXkgPSAwXG5cbiAgLy8gdHJ1ZSB0byBwZXJmb3JtIGxvY2FsIGZpbHRlcmluZyBvZiBpdGVtcywgZXZlbiBpZiBzZWFyY2hGdW5jdGlvbiBpcyBwcm92aWRlZFxuICBleHBvcnQgbGV0IGxvY2FsRmlsdGVyaW5nID0gdHJ1ZVxuXG4gIC8vIHRydWUgdG8gcGVyZm9ybSBsb2NhbCBzb3J0eWluZyBvZiBpdGVtc1xuICBleHBvcnQgbGV0IGxvY2FsU29ydGluZyA9IHRydWVcblxuICAvLyB0cnVlIHRvIGNsZWFuIHRoZSB1c2VyIGVudGVyZWQgdGV4dCAocmVtb3ZlcyBzcGFjZXMpXG4gIGV4cG9ydCBsZXQgY2xlYW5Vc2VyVGV4dCA9IHRydWVcblxuICAvLyB0cnVlIHRvIGxvd2VyY2FzZSB0aGUga2V5d29yZHMgZGVyaXZlZCBmcm9tIGVhY2ggaXRlbSAobG93ZXJjYXNlKVxuICBleHBvcnQgbGV0IGxvd2VyY2FzZUtleXdvcmRzID0gdHJ1ZVxuXG4gIC8vIHRydWUgdG8gY2xvc2UgdGhlIGRyb3Bkb3duIHdoZW4gdGhlIGNvbXBvbmVudCBsb3NlcyBmb2N1c1xuICBleHBvcnQgbGV0IGNsb3NlT25CbHVyID0gZmFsc2VcblxuICAvLyB0cnVlIHRvIGFsbG93IHNlbGVjdGlvbiByZW9yZGVyaW5nIGJ5IGRyYWcgYW5kIGRyb3AsIG5lZWRzIG11bHRpcGxlIHRvIHRydWVcbiAgZXhwb3J0IGxldCBvcmRlcmFibGVTZWxlY3Rpb24gPSBmYWxzZVxuXG4gIC8vIFVJIHByb3BlcnRpZXNcblxuICAvLyBvcHRpb24gdG8gaGlkZSB0aGUgZHJvcGRvd24gYXJyb3dcbiAgZXhwb3J0IGxldCBoaWRlQXJyb3cgPSBmYWxzZVxuXG4gIC8vIG9wdGlvbiB0byBzaG93IGNsZWFyIHNlbGVjdGlvbiBidXR0b25cbiAgZXhwb3J0IGxldCBzaG93Q2xlYXIgPSBmYWxzZVxuXG4gIC8vIHRleHQgdG8gdXNlIGZvciBjbGVhclxuICBleHBvcnQgbGV0IGNsZWFyVGV4dCA9IFwiJiMxMDAwNjtcIlxuXG4gIC8vIG9wdGlvbiB0byBzaG93IGxvYWRpbmcgaW5kaWNhdG9yIHdoZW4gdGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkXG4gIGV4cG9ydCBsZXQgc2hvd0xvYWRpbmdJbmRpY2F0b3IgPSBmYWxzZVxuXG4gIC8vIHRleHQgZGlzcGxheWVkIHdoZW4gbm8gaXRlbXMgbWF0Y2ggdGhlIGlucHV0IHRleHRcbiAgZXhwb3J0IGxldCBub1Jlc3VsdHNUZXh0ID0gXCJObyByZXN1bHRzIGZvdW5kXCJcblxuICAvLyB0ZXh0IGRpc3BsYXllZCB3aGVuIGFzeW5jIGRhdGEgaXMgYmVpbmcgbG9hZGVkXG4gIGV4cG9ydCBsZXQgbG9hZGluZ1RleHQgPSBcIkxvYWRpbmcgcmVzdWx0cy4uLlwiXG5cbiAgLy8gdGV4dCBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciB0ZXh0IG1hdGNoZXMgYSBsb3Qgb2YgaXRlbXMgYW5kIHdlIGNhbiBub3QgZGlzcGxheSB0aGVtIGFsbCBpbiB0aGUgZHJvcGRvd25cbiAgZXhwb3J0IGxldCBtb3JlSXRlbXNUZXh0ID0gXCJpdGVtcyBub3Qgc2hvd25cIlxuXG4gIC8vIHRleHQgZGlzcGxheWVkIHdoZW4gYXN5bmMgZGF0YSBpcyBiZWluZyBsb2FkZWRcbiAgZXhwb3J0IGxldCBjcmVhdGVUZXh0ID0gXCJOb3QgZm91bmQsIGFkZCBhbnl3YXk/XCJcblxuICAvLyB0aGUgdGV4dCBkaXNwbGF5ZWQgd2hlbiBubyBvcHRpb24gaXMgc2VsZWN0ZWRcbiAgZXhwb3J0IGxldCBwbGFjZWhvbGRlciA9IHVuZGVmaW5lZFxuXG4gIC8vIGFwcGx5IGEgY2xhc3NOYW1lIHRvIHRoZSBjb250cm9sXG4gIGV4cG9ydCBsZXQgY2xhc3NOYW1lID0gdW5kZWZpbmVkXG5cbiAgLy8gSFRNTCBpbnB1dCBVSSBwcm9wZXJ0aWVzXG4gIC8vIGFwcGx5IGEgY2xhc3NOYW1lIHRvIHRoZSBpbnB1dCBjb250cm9sXG4gIGV4cG9ydCBsZXQgaW5wdXRDbGFzc05hbWUgPSB1bmRlZmluZWRcbiAgLy8gYXBwbHkgYSBpZCB0byB0aGUgaW5wdXQgY29udHJvbFxuICBleHBvcnQgbGV0IGlucHV0SWQgPSB1bmRlZmluZWRcbiAgLy8gZ2VuZXJhdGUgYW4gSFRNTCBpbnB1dCB3aXRoIHRoaXMgbmFtZVxuICBleHBvcnQgbGV0IG5hbWUgPSB1bmRlZmluZWRcbiAgLy8gZ2VuZXJhdGUgYSA8c2VsZWN0PiB0YWcgdGhhdCBob2xkcyB0aGUgdmFsdWVcbiAgZXhwb3J0IGxldCBzZWxlY3ROYW1lID0gdW5kZWZpbmVkXG4gIC8vIGFwcGx5IGEgaWQgdG8gdGhlIDxzZWxlY3Q+XG4gIGV4cG9ydCBsZXQgc2VsZWN0SWQgPSB1bmRlZmluZWRcbiAgLy8gYWRkIHRoZSB0aXRsZSB0byB0aGUgSFRNTCBpbnB1dFxuICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gIC8vIGVuYWJsZSB0aGUgaHRtbDUgYXV0b2NvbXBsZXRpb24gdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCBodG1sNWF1dG9jb21wbGV0ZSA9IHVuZGVmaW5lZFxuICAvLyBlbmFibGUgdGhlIGh0bWw1IGF1dG9jb21wbGV0aW9uIHZhbHVlXG4gIGV4cG9ydCBsZXQgYXV0b2NvbXBsZXRlT2ZmVmFsdWUgPSBcIm9mZlwiXG4gIC8vIG1ha2UgdGhlIGlucHV0IHJlYWRvbmx5XG4gIGV4cG9ydCBsZXQgcmVhZG9ubHkgPSB1bmRlZmluZWRcbiAgLy8gYXBwbHkgYSBjbGFzc05hbWUgdG8gdGhlIGRyb3Bkb3duIGRpdlxuICBleHBvcnQgbGV0IGRyb3Bkb3duQ2xhc3NOYW1lID0gdW5kZWZpbmVkXG4gIC8vIGFkZHMgdGhlIGRpc2FibGVkIHRhZyB0byB0aGUgSFRNTCBpbnB1dFxuICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2VcbiAgLy8gcmVtb3ZlIHRoZSBhdXRvY29tcGxldGUtaW5wdXQgY2xhc3Mgb2YgdGhlIGlucHV0XG4gIGV4cG9ydCBsZXQgbm9JbnB1dFN0eWxlcyA9IGZhbHNlXG4gIC8vIGFkZHMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSB0byB0aGUgSFRNTCBpbnB1dFxuICBleHBvcnQgbGV0IHJlcXVpcmVkID0gbnVsbFxuXG4gIGV4cG9ydCBsZXQgZGVidWcgPSBmYWxzZVxuXG4gIC8vIGFkZCB0YWJpbmRleCBzdXBwb3J0IGZvciB0aGUgaW5wdXRcbiAgLy8gc2V0IHN0YW5kYXJkIHRvIDA6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcbiAgZXhwb3J0IGxldCB0YWJpbmRleCA9IDBcblxuICAvLyAtLS0gUHVibGljIFN0YXRlIC0tLS1cblxuICAvLyBzZWxlY3RlZCBpdGVtIHN0YXRlXG4gIGV4cG9ydCBsZXQgc2VsZWN0ZWRJdGVtID0gbXVsdGlwbGUgPyBbXSA6IHVuZGVmaW5lZFxuICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gIGV4cG9ydCBsZXQgaGlnaGxpZ2h0ZWRJdGVtID0gdW5kZWZpbmVkXG5cbiAgLy8gLS0tIEludGVybmFsIFN0YXRlIC0tLS1cbiAgY29uc3QgdW5pcXVlSWQgPSBcInNhdXRvY29tcGxldGUtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKVxuXG4gIC8vIEhUTUwgZWxlbWVudHNcbiAgbGV0IGlucHV0XG4gIGxldCBsaXN0XG4gIGxldCBpbnB1dENvbnRhaW5lclxuXG4gIC8vIFVJIHN0YXRlXG4gIGxldCBvcGVuZWQgPSBmYWxzZVxuICBsZXQgbG9hZGluZyA9IGZhbHNlXG4gIGxldCBoaWdobGlnaHRJbmRleCA9IC0xXG4gIGV4cG9ydCBsZXQgdGV4dCA9IHVuZGVmaW5lZFxuICBsZXQgZmlsdGVyZWRUZXh0TGVuZ3RoID0gMFxuXG4gIC8vIHZpZXcgbW9kZWxcbiAgbGV0IGZpbHRlcmVkTGlzdEl0ZW1zXG4gIGxldCBsaXN0SXRlbXMgPSBbXVxuXG4gIC8vIHJlcXVlc3RzL3Jlc3BvbnNlcyBjb3VudGVyc1xuICBsZXQgbGFzdFJlcXVlc3RJZCA9IDBcbiAgbGV0IGxhc3RSZXNwb25zZUlkID0gMFxuXG4gIC8vIG90aGVyIHN0YXRlXG4gIGxldCBpbnB1dERlbGF5VGltZW91dFxuXG4gIGxldCBzZXRQb3NpdGlvbk9uTmV4dFVwZGF0ZSA9IGZhbHNlO1xuXG4gIC8vIC0tLSBMaWZlY3ljbGUgZXZlbnRzIC0tLVxuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZihzZXRQb3NpdGlvbk9uTmV4dFVwZGF0ZSkge1xuICAgICAgc2V0U2Nyb2xsQXdhcmVMaXN0UG9zaXRpb24oKVxuICAgIH1cbiAgICBzZXRQb3NpdGlvbk9uTmV4dFVwZGF0ZSA9IGZhbHNlXG4gIH0pXG5cbiAgLy8gLS0tIEZ1bmN0aW9ucyAtLS1cblxuICBmdW5jdGlvbiBzYWZlRnVuY3Rpb24odGhlRnVuY3Rpb24sIGFyZ3VtZW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGVGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTm90IGEgZnVuY3Rpb246IFwiICsgdGhlRnVuY3Rpb24gKyBcIiwgYXJndW1lbnQ6IFwiICsgYXJndW1lbnQpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIGxldCByZXN1bHRcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhlRnVuY3Rpb24oYXJndW1lbnQpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJFcnJvciBleGVjdXRpbmcgQXV0b2NvbXBsZXRlIGZ1bmN0aW9uIG9uIHZhbHVlOiBcIiArIGFyZ3VtZW50ICsgXCIgZnVuY3Rpb246IFwiICsgdGhlRnVuY3Rpb25cbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZVN0cmluZ0Z1bmN0aW9uKHRoZUZ1bmN0aW9uLCBhcmd1bWVudCkge1xuICAgIGxldCByZXN1bHQgPSBzYWZlRnVuY3Rpb24odGhlRnVuY3Rpb24sIGFyZ3VtZW50KVxuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCB8fCByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IFwiXCJcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1N0cmluZygpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVMYWJlbEZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcImxhYmVsRnVuY3Rpb246IFwiICsgbGFiZWxGdW5jdGlvbik7XG4gICAgLy8gY29uc29sZS5sb2coXCJzYWZlTGFiZWxGdW5jdGlvbiwgaXRlbTogXCIgKyBpdGVtKTtcbiAgICByZXR1cm4gc2FmZVN0cmluZ0Z1bmN0aW9uKGxhYmVsRnVuY3Rpb24sIGl0ZW0pXG4gIH1cblxuICBmdW5jdGlvbiBzYWZlS2V5d29yZHNGdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJzYWZlS2V5d29yZHNGdW5jdGlvblwiKTtcbiAgICBjb25zdCBrZXl3b3JkcyA9IHNhZmVTdHJpbmdGdW5jdGlvbihrZXl3b3Jkc0Z1bmN0aW9uLCBpdGVtKVxuICAgIGxldCByZXN1bHQgPSBzYWZlU3RyaW5nRnVuY3Rpb24oa2V5d29yZHNDbGVhbkZ1bmN0aW9uLCBrZXl3b3JkcylcbiAgICByZXN1bHQgPSBsb3dlcmNhc2VLZXl3b3JkcyA/IHJlc3VsdC50b0xvd2VyQ2FzZSgpLnRyaW0oKSA6IHJlc3VsdFxuICAgIGlmIChpZ25vcmVBY2NlbnRzKSB7XG4gICAgICByZXN1bHQgPSByZW1vdmVBY2NlbnRzKHJlc3VsdClcbiAgICB9XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGVkIGtleXdvcmRzOiAnXCIgKyByZXN1bHQgKyBcIicgZnJvbSBpdGVtOiBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW0pKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlTGlzdEl0ZW1zKCkge1xuICAgIGxldCB0aW1lcklkXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICB0aW1lcklkID0gYEF1dG9jb21wbGV0ZSBwcmVwYXJlIGxpc3QgJHtpbnB1dElkID8gYChpZDogJHtpbnB1dElkfSlgIDogXCJcIn1gXG4gICAgICBjb25zb2xlLnRpbWUodGltZXJJZClcbiAgICAgIGNvbnNvbGUubG9nKFwiUHJlcGFyZSBpdGVtcyB0byBzZWFyY2hcIilcbiAgICAgIGNvbnNvbGUubG9nKFwiaXRlbXM6IFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbXMpKVxuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkF1dG9jb21wbGV0ZSBpdGVtcyAvIHNlYXJjaCBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhcnJheSBidXRcIiwgaXRlbXMpXG4gICAgICBpdGVtcyA9IFtdXG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0gaXRlbXMgPyBpdGVtcy5sZW5ndGggOiAwXG4gICAgbGlzdEl0ZW1zID0gbmV3IEFycmF5KGxlbmd0aClcblxuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtID0gZ2V0TGlzdEl0ZW0oaXRlbSlcbiAgICAgICAgaWYgKGxpc3RJdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuZGVmaW5lZCBpdGVtIGZvcjogXCIsIGl0ZW0pXG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1zW2ldID0gbGlzdEl0ZW1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2cobGlzdEl0ZW1zLmxlbmd0aCArIFwiIGl0ZW1zIHRvIHNlYXJjaFwiKVxuICAgICAgY29uc29sZS50aW1lRW5kKHRpbWVySWQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGlzdEl0ZW0oaXRlbSkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBrZXl3b3JkcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaXRlbVxuICAgICAga2V5d29yZHM6IGxvY2FsRmlsdGVyaW5nID8gc2FmZUtleXdvcmRzRnVuY3Rpb24oaXRlbSkgOiBbXSxcbiAgICAgIC8vIGl0ZW0gbGFiZWxcbiAgICAgIGxhYmVsOiBzYWZlTGFiZWxGdW5jdGlvbihpdGVtKSxcbiAgICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2lhbCBpdGVtXG4gICAgICBpdGVtOiBpdGVtLFxuICAgIH1cbiAgfVxuXG4gIC8vIC0tIFJlYWN0aXZpdHkgLS1cbiAgJDogaXRlbXMsIHNlYXJjaEZ1bmN0aW9uIHx8IHByZXBhcmVMaXN0SXRlbXMoKVxuXG4gIGZ1bmN0aW9uIG9uU2VsZWN0ZWRJdGVtQ2hhbmdlZCgpIHtcbiAgICB2YWx1ZSA9IHZhbHVlRnVuY3Rpb24oc2VsZWN0ZWRJdGVtKVxuICAgIGlmIChzZWxlY3RlZEl0ZW0gJiYgIW11bHRpcGxlKSB7XG4gICAgICB0ZXh0ID0gc2FmZUxhYmVsRnVuY3Rpb24oc2VsZWN0ZWRJdGVtKVxuICAgIH1cblxuICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgb25DaGFuZ2Uoc2VsZWN0ZWRJdGVtKVxuICB9XG5cbiAgJDogc2VsZWN0ZWRJdGVtLCBvblNlbGVjdGVkSXRlbUNoYW5nZWQoKVxuXG4gICQ6IGhpZ2hsaWdodGVkSXRlbSA9XG4gICAgZmlsdGVyZWRMaXN0SXRlbXMgJiZcbiAgICBoaWdobGlnaHRJbmRleCAmJlxuICAgIGhpZ2hsaWdodEluZGV4ID49IDAgJiZcbiAgICBoaWdobGlnaHRJbmRleCA8IGZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aFxuICAgICAgPyBmaWx0ZXJlZExpc3RJdGVtc1toaWdobGlnaHRJbmRleF0uaXRlbVxuICAgICAgOiBudWxsXG5cbiAgJDogc2hvd0xpc3QgPSBvcGVuZWQgJiYgKChpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB8fCBmaWx0ZXJlZFRleHRMZW5ndGggPiAwKVxuXG4gICQ6IGhhc1NlbGVjdGlvbiA9XG4gICAgKG11bHRpcGxlICYmIHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0ubGVuZ3RoID4gMCkgfHwgKCFtdWx0aXBsZSAmJiBzZWxlY3RlZEl0ZW0pXG5cbiAgJDogY2xlYXJhYmxlID0gc2hvd0NsZWFyIHx8ICgobG9jayB8fCBtdWx0aXBsZSkgJiYgaGFzU2VsZWN0aW9uKVxuXG4gICQ6IGxvY2tlZCA9IGxvY2sgJiYgaGFzU2VsZWN0aW9uXG5cbiAgZnVuY3Rpb24gcHJlcGFyZVVzZXJFbnRlcmVkVGV4dCh1c2VyRW50ZXJlZFRleHQpIHtcbiAgICBpZiAodXNlckVudGVyZWRUZXh0ID09PSB1bmRlZmluZWQgfHwgdXNlckVudGVyZWRUZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cblxuICAgIGlmICghY2xlYW5Vc2VyVGV4dCkge1xuICAgICAgcmV0dXJuIHVzZXJFbnRlcmVkVGV4dFxuICAgIH1cblxuICAgIGNvbnN0IHRleHRGaWx0ZXJlZCA9IHVzZXJFbnRlcmVkVGV4dC5yZXBsYWNlKC9bJi9cXFxcIywrKCkkfiUuJ1wiOio/PD57fV0vZywgXCIgXCIpLnRyaW0oKVxuXG4gICAgY29uc3QgY2xlYW5Vc2VyRW50ZXJlZFRleHQgPSBzYWZlU3RyaW5nRnVuY3Rpb24odGV4dENsZWFuRnVuY3Rpb24sIHRleHRGaWx0ZXJlZClcbiAgICBjb25zdCB0ZXh0VHJpbW1lZCA9IGxvd2VyY2FzZUtleXdvcmRzXG4gICAgICA/IGNsZWFuVXNlckVudGVyZWRUZXh0LnRvTG93ZXJDYXNlKCkudHJpbSgpXG4gICAgICA6IGNsZWFuVXNlckVudGVyZWRUZXh0LnRyaW0oKVxuXG4gICAgcmV0dXJuIHRleHRUcmltbWVkXG4gIH1cblxuICBmdW5jdGlvbiBudW1iZXJPZk1hdGNoZXMobGlzdEl0ZW0sIHNlYXJjaFdvcmRzKSB7XG4gICAgaWYgKCFsaXN0SXRlbSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtS2V5d29yZHMgPSBsaXN0SXRlbS5rZXl3b3Jkc1xuXG4gICAgbGV0IG1hdGNoZXMgPSAwXG4gICAgc2VhcmNoV29yZHMuZm9yRWFjaCgoc2VhcmNoV29yZCkgPT4ge1xuICAgICAgaWYgKGl0ZW1LZXl3b3Jkcy5pbmNsdWRlcyhzZWFyY2hXb3JkKSkge1xuICAgICAgICBtYXRjaGVzKytcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIG1hdGNoZXNcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICBsZXQgdGltZXJJZFxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgdGltZXJJZCA9IGBBdXRvY29tcGxldGUgc2VhcmNoICR7aW5wdXRJZCA/IGAoaWQ6ICR7aW5wdXRJZH0pYCA6IFwiXCJ9YFxuICAgICAgY29uc29sZS50aW1lKHRpbWVySWQpXG4gICAgICBjb25zb2xlLmxvZyhcIlNlYXJjaGluZyB1c2VyIGVudGVyZWQgdGV4dDogJ1wiICsgdGV4dCArIFwiJ1wiKVxuICAgIH1cblxuICAgIGxldCB0ZXh0RmlsdGVyZWQgPSBwcmVwYXJlVXNlckVudGVyZWRUZXh0KHRleHQpXG4gICAgaWYgKG1pbkNoYXJhY3RlcnNUb1NlYXJjaCA+IDEgJiYgdGV4dEZpbHRlcmVkLmxlbmd0aCA8IG1pbkNoYXJhY3RlcnNUb1NlYXJjaCkge1xuICAgICAgdGV4dEZpbHRlcmVkID0gXCJcIlxuICAgIH1cbiAgICBmaWx0ZXJlZFRleHRMZW5ndGggPSB0ZXh0RmlsdGVyZWQubGVuZ3RoXG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hhbmdlZCB1c2VyIGVudGVyZWQgdGV4dCAnXCIgKyB0ZXh0ICsgXCInIGludG8gJ1wiICsgdGV4dEZpbHRlcmVkICsgXCInXCIpXG4gICAgfVxuXG4gICAgLy8gaWYgbm8gc2VhcmNoIHRleHQgbG9hZCBhbGwgaXRlbXNcbiAgICBpZiAodGV4dEZpbHRlcmVkID09PSBcIlwiKSB7XG4gICAgICBpZiAoc2VhcmNoRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHJlcnVuIHRoZSBzZWFyY2hcbiAgICAgICAgaXRlbXMgPSBbXVxuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZXIgZW50ZXJlZCB0ZXh0IGlzIGVtcHR5IGNsZWFyIGxpc3Qgb2YgaXRlbXNcIilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIGVudGVyZWQgdGV4dCBpcyBlbXB0eSBzZXQgdGhlIGxpc3Qgb2YgaXRlbXMgdG8gYWxsIGl0ZW1zXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZUlmTWluQ2hhcnNUb1NlYXJjaFJlYWNoZWQoKSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLnRpbWVFbmQodGltZXJJZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNlYXJjaEZ1bmN0aW9uKSB7XG4gICAgICAvLyBpbnRlcm5hbCBzZWFyY2hcbiAgICAgIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleHRlcm5hbCBzZWFyY2ggd2hpY2ggcHJvdmlkZXMgaXRlbXNcbiAgICAgIGxhc3RSZXF1ZXN0SWQgPSBsYXN0UmVxdWVzdElkICsgMVxuICAgICAgY29uc3QgY3VycmVudFJlcXVlc3RJZCA9IGxhc3RSZXF1ZXN0SWRcbiAgICAgIGxvYWRpbmcgPSB0cnVlXG5cbiAgICAgIC8vIHNlYXJjaEZ1bmN0aW9uIGlzIGEgZ2VuZXJhdG9yXG4gICAgICBpZiAoc2VhcmNoRnVuY3Rpb24uY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzZWFyY2hGdW5jdGlvbih0ZXh0RmlsdGVyZWQsIG1heEl0ZW1zVG9TaG93SW5MaXN0KSkge1xuICAgICAgICAgIC8vIGEgY2h1bmsgb2YgYW4gb2xkIHJlc3BvbnNlOiB0aHJvdyBpdCBhd2F5XG4gICAgICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0SWQgPCBsYXN0UmVzcG9uc2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYSBjaHVuayBmb3IgYSBuZXcgcmVzcG9uc2U6IHJlc2V0IHRoZSBpdGVtIGxpc3RcbiAgICAgICAgICBpZiAoY3VycmVudFJlcXVlc3RJZCA+IGxhc3RSZXNwb25zZUlkKSB7XG4gICAgICAgICAgICBpdGVtcyA9IFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGFzdFJlc3BvbnNlSWQgPSBjdXJyZW50UmVxdWVzdElkXG4gICAgICAgICAgaXRlbXMgPSBbLi4uaXRlbXMsIC4uLmNodW5rXVxuICAgICAgICAgIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlcmUgd2FzIG5vdGhpbmcgaW4gdGhlIGNodW5rXG4gICAgICAgIGlmIChsYXN0UmVzcG9uc2VJZCA8IGN1cnJlbnRSZXF1ZXN0SWQpIHtcbiAgICAgICAgICBsYXN0UmVzcG9uc2VJZCA9IGN1cnJlbnRSZXF1ZXN0SWRcbiAgICAgICAgICBpdGVtcyA9IFtdXG4gICAgICAgICAgcHJvY2Vzc0xpc3RJdGVtcyh0ZXh0RmlsdGVyZWQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc2VhcmNoRnVuY3Rpb24gaXMgYSByZWd1bGFyIGZ1bmN0aW9uXG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHNlYXJjaEZ1bmN0aW9uKHRleHRGaWx0ZXJlZCwgbWF4SXRlbXNUb1Nob3dJbkxpc3QpXG5cbiAgICAgICAgLy8gSWYgYSByZXNwb25zZSB0byBhIG5ld2VyIHJlcXVlc3QgaGFzIGJlZW4gcmVjZWl2ZWRcbiAgICAgICAgLy8gd2hpbGUgcmVzcG9uc2VzIHRvIHRoaXMgcmVxdWVzdCB3ZXJlIGJlaW5nIGxvYWRlZCxcbiAgICAgICAgLy8gdGhlbiB3ZSBjYW4ganVzdCB0aHJvdyBhd2F5IHRoaXMgb3V0ZGF0ZWQgcmVzdWx0cy5cbiAgICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0SWQgPCBsYXN0UmVzcG9uc2VJZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFJlc3BvbnNlSWQgPSBjdXJyZW50UmVxdWVzdElkXG4gICAgICAgIGl0ZW1zID0gcmVzdWx0XG4gICAgICAgIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKVxuICAgICAgfVxuXG4gICAgICBsb2FkaW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZCh0aW1lcklkKVxuICAgICAgY29uc29sZS5sb2coXCJTZWFyY2ggZm91bmQgXCIgKyBmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGggKyBcIiBpdGVtc1wiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRJdGVtRmlsdGVyRnVuY3Rpb24obGlzdEl0ZW0sIHNlYXJjaFdvcmRzKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IG51bWJlck9mTWF0Y2hlcyhsaXN0SXRlbSwgc2VhcmNoV29yZHMpXG4gICAgaWYgKG1hdGNoQWxsS2V5d29yZHMpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzID49IHNlYXJjaFdvcmRzLmxlbmd0aFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyA+IDBcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0SXRlbVNvcnRGdW5jdGlvbihvYmoxLCBvYmoyLCBzZWFyY2hXb3Jkcykge1xuICAgIHJldHVybiBudW1iZXJPZk1hdGNoZXMob2JqMiwgc2VhcmNoV29yZHMpIC0gbnVtYmVyT2ZNYXRjaGVzKG9iajEsIHNlYXJjaFdvcmRzKVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0xpc3RJdGVtcyh0ZXh0RmlsdGVyZWQpIHtcbiAgICAvLyBjbGVhbnMsIGZpbHRlcnMsIG9yZGVycywgYW5kIGhpZ2hsaWdodHMgdGhlIGxpc3QgaXRlbXNcbiAgICBwcmVwYXJlTGlzdEl0ZW1zKClcblxuICAgIGNvbnN0IHRleHRGaWx0ZXJlZFdpdGhvdXRBY2NlbnRzID0gaWdub3JlQWNjZW50cyA/IHJlbW92ZUFjY2VudHModGV4dEZpbHRlcmVkKSA6IHRleHRGaWx0ZXJlZFxuICAgIGNvbnN0IHNlYXJjaFdvcmRzID0gdGV4dEZpbHRlcmVkV2l0aG91dEFjY2VudHMuc3BsaXQoL1xccysvZykuZmlsdGVyKCh3b3JkKSA9PiB3b3JkICE9PSBcIlwiKVxuXG4gICAgLy8gbG9jYWwgc2VhcmNoXG4gICAgbGV0IHRlbXBmaWx0ZXJlZExpc3RJdGVtc1xuICAgIGlmIChsb2NhbEZpbHRlcmluZykge1xuICAgICAgaWYgKGl0ZW1GaWx0ZXJGdW5jdGlvbikge1xuICAgICAgICB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXMuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICAgIGl0ZW1GaWx0ZXJGdW5jdGlvbihpdGVtLml0ZW0sIHNlYXJjaFdvcmRzKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXMuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICAgIGRlZmF1bHRJdGVtRmlsdGVyRnVuY3Rpb24oaXRlbSwgc2VhcmNoV29yZHMpXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2FsU29ydGluZykge1xuICAgICAgICBpZiAoaXRlbVNvcnRGdW5jdGlvbikge1xuICAgICAgICAgIHRlbXBmaWx0ZXJlZExpc3RJdGVtcyA9IHRlbXBmaWx0ZXJlZExpc3RJdGVtcy5zb3J0KChpdGVtMSwgaXRlbTIpID0+XG4gICAgICAgICAgICBpdGVtU29ydEZ1bmN0aW9uKGl0ZW0xLml0ZW0sIGl0ZW0yLml0ZW0sIHNlYXJjaFdvcmRzKVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc29ydEJ5TWF0Y2hlZEtleXdvcmRzKSB7XG4gICAgICAgICAgICB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMgPSB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMuc29ydCgoaXRlbTEsIGl0ZW0yKSA9PlxuICAgICAgICAgICAgICBkZWZhdWx0SXRlbVNvcnRGdW5jdGlvbihpdGVtMSwgaXRlbTIsIHNlYXJjaFdvcmRzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICB9XG5cbiAgICBjb25zdCBobGZpbHRlciA9IGhpZ2hsaWdodEZpbHRlcihzZWFyY2hXb3JkcywgXCJsYWJlbFwiKVxuICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gdGVtcGZpbHRlcmVkTGlzdEl0ZW1zLm1hcChobGZpbHRlcilcbiAgICBjbG9zZUlmTWluQ2hhcnNUb1NlYXJjaFJlYWNoZWQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAkOiB0ZXh0LCBzZWFyY2goKTtcblxuICBmdW5jdGlvbiBhZnRlckNyZWF0ZShjcmVhdGVkSXRlbSkge1xuICAgIGxldCBsaXN0SXRlbVxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJjcmVhdGVkSXRlbVwiLCBjcmVhdGVkSXRlbSlcbiAgICB9XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjcmVhdGVkSXRlbSkge1xuICAgICAgcHJlcGFyZUxpc3RJdGVtcygpXG4gICAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgICAgbGV0IGluZGV4ID0gZmluZEl0ZW1JbmRleChjcmVhdGVkSXRlbSwgZmlsdGVyZWRMaXN0SXRlbXMpXG5cbiAgICAgIC8vIGlmIHRoZSBpdGVtcyBhcnJheSB3YXMgbm90IHVwZGF0ZWQsIGFkZCB0aGUgY3JlYXRlZCBpdGVtIG1hbnVhbGx5XG4gICAgICBpZiAoaW5kZXggPD0gMCkge1xuICAgICAgICBpdGVtcyA9IFtjcmVhdGVkSXRlbV1cbiAgICAgICAgcHJlcGFyZUxpc3RJdGVtcygpXG4gICAgICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBoaWdobGlnaHRJbmRleCA9IGluZGV4XG4gICAgICAgIGxpc3RJdGVtID0gZmlsdGVyZWRMaXN0SXRlbXNbaGlnaGxpZ2h0SW5kZXhdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0SXRlbVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0TGlzdEl0ZW0obGlzdEl0ZW0pIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0TGlzdEl0ZW1cIiwgbGlzdEl0ZW0pXG4gICAgfVxuICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbGlzdEl0ZW0gJiYgY3JlYXRlKSB7XG4gICAgICAvLyBhbGxvdyB1bmRlZmluZWQgaXRlbXMgaWYgY3JlYXRlIGlzIGVuYWJsZWRcbiAgICAgIGNvbnN0IGNyZWF0ZWRJdGVtID0gb25DcmVhdGUodGV4dClcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY3JlYXRlZEl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVkSXRlbS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjcmVhdGVkSXRlbS50aGVuKChuZXdJdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG5ld0l0ZW0pIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3TGlzdEl0ZW0gPSBhZnRlckNyZWF0ZShuZXdJdGVtKVxuICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIG5ld0xpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TGlzdEl0ZW0obmV3TGlzdEl0ZW0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdEl0ZW0gPSBhZnRlckNyZWF0ZShjcmVhdGVkSXRlbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbGlzdEl0ZW0pIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhgbGlzdEl0ZW0gaXMgdW5kZWZpbmVkLiBDYW4gbm90IHNlbGVjdC5gKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBuZXdTZWxlY3RlZEl0ZW0gPSBsaXN0SXRlbS5pdGVtXG4gICAgaWYgKGJlZm9yZUNoYW5nZShzZWxlY3RlZEl0ZW0sIG5ld1NlbGVjdGVkSXRlbSkpIHtcbiAgICAgIC8vIHNpbXBsZSBzZWxlY3Rpb25cbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgc2VsZWN0ZWRJdGVtID0gdW5kZWZpbmVkIC8vIHRyaWdnZXJzIGNoYW5nZSBldmVuIGlmIHRoZSB0aGUgc2FtZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IG5ld1NlbGVjdGVkSXRlbVxuICAgICAgfVxuICAgICAgLy8gZmlyc3Qgc2VsZWN0aW9uIG9mIG11bHRpcGxlIG9uZXNcbiAgICAgIGVsc2UgaWYgKCFzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgc2VsZWN0ZWRJdGVtID0gW25ld1NlbGVjdGVkSXRlbV1cbiAgICAgIH1cbiAgICAgIC8vIHNlbGVjdGluZyBzb21ldGhpbmcgYWxyZWFkeSBzZWxlY3RlZCA9PiB1bnNlbGVjdCBpdFxuICAgICAgZWxzZSBpZiAoc2VsZWN0ZWRJdGVtLmluY2x1ZGVzKG5ld1NlbGVjdGVkSXRlbSkpIHtcbiAgICAgICAgc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtLmZpbHRlcigoaSkgPT4gaSAhPT0gbmV3U2VsZWN0ZWRJdGVtKVxuICAgICAgfVxuICAgICAgLy8gYWRkcyB0aGUgZWxlbWVudCB0byB0aGUgc2VsZWN0aW9uXG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWRJdGVtID0gWy4uLnNlbGVjdGVkSXRlbSwgbmV3U2VsZWN0ZWRJdGVtXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0SXRlbSgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0SXRlbVwiLCBoaWdobGlnaHRJbmRleClcbiAgICB9XG4gICAgY29uc3QgbGlzdEl0ZW0gPSBmaWx0ZXJlZExpc3RJdGVtc1toaWdobGlnaHRJbmRleF1cbiAgICBpZiAoc2VsZWN0TGlzdEl0ZW0obGlzdEl0ZW0pKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3RMaXN0SXRlbSB0cnVlLCBjbG9zaW5nXCIpXG4gICAgICB9XG4gICAgICBjbG9zZSgpXG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgdGV4dCA9IFwiXCJcbiAgICAgICAgaW5wdXQuZm9jdXMoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3RMaXN0SXRlbSBmYWxzZSwgbm90IGNsb3NpbmdcIilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cCgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidXBcIilcbiAgICB9XG5cbiAgICBvcGVuKClcbiAgICBpZiAoaGlnaGxpZ2h0SW5kZXggPiAwKSB7XG4gICAgICBoaWdobGlnaHRJbmRleC0tXG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvd24oKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImRvd25cIilcbiAgICB9XG5cbiAgICBvcGVuKClcbiAgICBpZiAoaGlnaGxpZ2h0SW5kZXggPCBmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICBoaWdobGlnaHRJbmRleCsrXG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodCgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiaGlnaGxpZ2h0XCIpXG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnkgPSBcIi5zZWxlY3RlZFwiXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlNlYWNoaW5nIERPTSBlbGVtZW50OiBcIiArIHF1ZXJ5ICsgXCIgaW4gXCIgKyBsaXN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICAgKi9cbiAgICBjb25zdCBlbCA9IGxpc3QgJiYgbGlzdC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KVxuICAgIGlmIChlbCkge1xuICAgICAgaWYgKHR5cGVvZiBlbC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTY3JvbGxpbmcgc2VsZWN0ZWQgaXRlbSBpbnRvIHZpZXdcIilcbiAgICAgICAgfVxuICAgICAgICBlbC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkKClcbiAgICAgIH0gZWxzZSBpZiAoZWwuc2Nyb2xsSW50b1ZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNjcm9sbGluZyBzZWxlY3RlZCBpdGVtIGludG8gdmlld1wiKVxuICAgICAgICB9XG4gICAgICAgIGVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiQ291bGQgbm90IHNjcm9sbCBzZWxlY3RlZCBpdGVtIGludG8gdmlldywgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCBub3Qgc3VwcG9ydGVkXCJcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlNlbGVjdGVkIGl0ZW0gbm90IGZvdW5kIHRvIHNjcm9sbCBpbnRvIHZpZXdcIilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkxpc3RJdGVtQ2xpY2sobGlzdEl0ZW0pIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25MaXN0SXRlbUNsaWNrXCIpXG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdExpc3RJdGVtKGxpc3RJdGVtKSkge1xuICAgICAgY2xvc2UoKVxuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIHRleHQgPSBcIlwiXG4gICAgICAgIGlucHV0LmZvY3VzKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50Q2xpY2soZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkRvY3VtZW50Q2xpY2tcIilcbiAgICB9XG4gICAgaWYgKGUuY29tcG9zZWRQYXRoKCkuc29tZSgocGF0aCkgPT4gcGF0aC5jbGFzc0xpc3QgJiYgcGF0aC5jbGFzc0xpc3QuY29udGFpbnModW5pcXVlSWQpKSkge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib25Eb2N1bWVudENsaWNrIGluc2lkZVwiKVxuICAgICAgfVxuICAgICAgLy8gcmVzZXRMaXN0VG9BbGxJdGVtc0FuZE9wZW4oKTtcbiAgICAgIGhpZ2hsaWdodCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uRG9jdW1lbnRDbGljayBvdXRzaWRlXCIpXG4gICAgICB9XG4gICAgICBjbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25LZXlEb3duXCIpXG4gICAgfVxuXG4gICAgbGV0IGtleSA9IGUua2V5XG4gICAgaWYgKGtleSA9PT0gXCJUYWJcIiAmJiBlLnNoaWZ0S2V5KSBrZXkgPSBcIlNoaWZ0VGFiXCJcbiAgICBjb25zdCBmbm1hcCA9IHtcbiAgICAgIFRhYjogb3BlbmVkID8gY2xvc2UgOiBudWxsLFxuICAgICAgU2hpZnRUYWI6IG9wZW5lZCA/IGNsb3NlIDogbnVsbCxcbiAgICAgIEFycm93RG93bjogZG93bi5iaW5kKHRoaXMpLFxuICAgICAgQXJyb3dVcDogdXAuYmluZCh0aGlzKSxcbiAgICAgIEVzY2FwZTogb25Fc2MuYmluZCh0aGlzKSxcbiAgICAgIEJhY2tzcGFjZTogbXVsdGlwbGUgJiYgaGFzU2VsZWN0aW9uICYmICF0ZXh0ID8gb25CYWNrc3BhY2UuYmluZCh0aGlzKSA6IG51bGwsXG4gICAgfVxuICAgIGNvbnN0IGZuID0gZm5tYXBba2V5XVxuICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm4oZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVByZXNzKGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25LZXlQcmVzc1wiKVxuICAgIH1cblxuICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICBvbkVudGVyKGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbnRlcihlKSB7XG4gICAgaWYgKG9wZW5lZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBzZWxlY3RJdGVtKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbklucHV0KGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25JbnB1dFwiKVxuICAgIH1cblxuICAgIHRleHQgPSBlLnRhcmdldC52YWx1ZVxuICAgIGlmIChpbnB1dERlbGF5VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGlucHV0RGVsYXlUaW1lb3V0KVxuICAgIH1cblxuICAgIGlmIChkZWxheSkge1xuICAgICAgaW5wdXREZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KHByb2Nlc3NJbnB1dCwgZGVsYXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NJbnB1dCgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW5zZWxlY3RJdGVtKHRhZykge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJ1bnNlbGVjdEl0ZW1cIiwgdGFnKVxuICAgIH1cbiAgICBzZWxlY3RlZEl0ZW0gPSBzZWxlY3RlZEl0ZW0uZmlsdGVyKChpKSA9PiBpICE9PSB0YWcpXG4gICAgaW5wdXQuZm9jdXMoKVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lucHV0KCkge1xuICAgIGlmIChzZWFyY2goKSkge1xuICAgICAgaGlnaGxpZ2h0SW5kZXggPSAwXG4gICAgICBvcGVuKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbklucHV0Q2xpY2soKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uSW5wdXRDbGlja1wiKVxuICAgIH1cbiAgICByZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlbigpXG4gIH1cblxuICBmdW5jdGlvbiBvbkVzYyhlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uRXNjXCIpXG4gICAgfVxuXG4gICAgLy9pZiAodGV4dCkgcmV0dXJuIGNsZWFyKCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGlmIChvcGVuZWQpIHtcbiAgICAgIGlucHV0LmZvY3VzKClcbiAgICAgIGNsb3NlKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkJhY2tzcGFjZShlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uQmFja3NwYWNlXCIpXG4gICAgfVxuXG4gICAgdW5zZWxlY3RJdGVtKHNlbGVjdGVkSXRlbVtzZWxlY3RlZEl0ZW0ubGVuZ3RoIC0gMV0pXG4gIH1cblxuICBmdW5jdGlvbiBvbkZvY3VzSW50ZXJuYWwoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uRm9jdXNcIilcbiAgICB9XG5cbiAgICBvbkZvY3VzKClcblxuICAgIHJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmx1ckludGVybmFsKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkJsdXJcIilcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VPbkJsdXIpIHtcbiAgICAgIGNsb3NlKClcbiAgICB9XG5cbiAgICBvbkJsdXIoKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRMaXN0VG9BbGxJdGVtc0FuZE9wZW4oKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuXCIpXG4gICAgfVxuXG4gICAgaWYgKHNlYXJjaEZ1bmN0aW9uICYmICFsaXN0SXRlbXMubGVuZ3RoKSB7XG4gICAgICBzZWFyY2goKVxuICAgIH0gZWxzZSBpZiAoIXRleHQpIHtcbiAgICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgfVxuXG4gICAgb3BlbigpXG5cbiAgICAvLyBmaW5kIHNlbGVjdGVkIGl0ZW1cbiAgICBpZiAoc2VsZWN0ZWRJdGVtKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTZWFyY2hpbmcgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW06IFwiICsgSlNPTi5zdHJpbmdpZnkoc2VsZWN0ZWRJdGVtKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBmaW5kSXRlbUluZGV4KHNlbGVjdGVkSXRlbSwgZmlsdGVyZWRMaXN0SXRlbXMpXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBoaWdobGlnaHRJbmRleCA9IGluZGV4XG4gICAgICAgIGhpZ2hsaWdodCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEl0ZW1JbmRleChpdGVtLCBpdGVtcykge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJGaW5kaW5nIGluZGV4IGZvciBpdGVtXCIsIGl0ZW0pXG4gICAgfVxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGlzdEl0ZW0gPSBpdGVtc1tpXVxuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBsaXN0SXRlbSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgbGlzdEl0ZW0gJHtpfSBpcyB1bmRlZmluZWQuIFNraXBwaW5nLmApXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkl0ZW0gXCIgKyBpICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkobGlzdEl0ZW0pKVxuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gPT09IGxpc3RJdGVtLml0ZW0pIHtcbiAgICAgICAgaW5kZXggPSBpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIGluZGV4IGZvciBpdGVtOiBcIiArIGluZGV4KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm90IGZvdW5kIGluZGV4IGZvciBpdGVtOiBcIiArIGl0ZW0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleFxuICB9XG5cbiAgZnVuY3Rpb24gb3BlbigpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib3BlblwiKVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoZSBzZWFyY2ggdGV4dCBoYXMgbW9yZSB0aGFuIHRoZSBtaW4gY2hhcnMgcmVxdWlyZWRcbiAgICBpZiAobG9ja2VkIHx8IG5vdEVub3VnaFNlYXJjaFRleHQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUgPSB0cnVlXG5cbiAgICBvcGVuZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY2xvc2VcIilcbiAgICB9XG4gICAgb3BlbmVkID0gZmFsc2VcbiAgICBsb2FkaW5nID0gZmFsc2VcblxuICAgIGlmICghdGV4dCAmJiBzZWxlY3RGaXJzdElmRW1wdHkpIHtcbiAgICAgIGhpZ2hsaWdodEluZGV4ID0gMFxuICAgICAgc2VsZWN0SXRlbSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm90RW5vdWdoU2VhcmNoVGV4dCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbWluQ2hhcmFjdGVyc1RvU2VhcmNoID4gMCAmJlxuICAgICAgZmlsdGVyZWRUZXh0TGVuZ3RoIDwgbWluQ2hhcmFjdGVyc1RvU2VhcmNoICYmXG4gICAgICAvLyBXaGVuIG5vIHNlYXJjaEZ1bmN0aW9uIGlzIGRlZmluZWQsIHRoZSBtZW51IHNob3VsZCBhbHdheXMgb3BlbiB3aGVuIHRoZSBpbnB1dCBpcyBmb2N1c2VkXG4gICAgICAoc2VhcmNoRnVuY3Rpb24gfHwgZmlsdGVyZWRUZXh0TGVuZ3RoID4gMClcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUlmTWluQ2hhcnNUb1NlYXJjaFJlYWNoZWQoKSB7XG4gICAgaWYgKG5vdEVub3VnaFNlYXJjaFRleHQoKSkge1xuICAgICAgY2xvc2UoKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY2xlYXJcIilcbiAgICB9XG5cbiAgICB0ZXh0ID0gXCJcIlxuICAgIHNlbGVjdGVkSXRlbSA9IG11bHRpcGxlID8gW10gOiB1bmRlZmluZWRcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaW5wdXQuZm9jdXMoKVxuICAgIH0pXG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gaGlnaGxpZ2h0RmlsdGVyKGtleXdvcmRzLCBmaWVsZCkge1xuICAgIHJldHVybiAoaXRlbSkgPT4ge1xuICAgICAgbGV0IGxhYmVsID0gaXRlbVtmaWVsZF1cblxuICAgICAgY29uc3QgbmV3SXRlbSA9IE9iamVjdC5hc3NpZ24oeyBoaWdobGlnaHRlZDogdW5kZWZpbmVkIH0sIGl0ZW0pXG4gICAgICBuZXdJdGVtLmhpZ2hsaWdodGVkID0gbGFiZWxcblxuICAgICAgY29uc3QgbGFiZWxMb3dlcmNhc2UgPSBsYWJlbC50b0xvd2VyQ2FzZSgpXG4gICAgICBjb25zdCBsYWJlbExvd2VyY2FzZU5vQWMgPSBpZ25vcmVBY2NlbnRzID8gcmVtb3ZlQWNjZW50cyhsYWJlbExvd2VyY2FzZSkgOiBsYWJlbExvd2VyY2FzZVxuXG4gICAgICBpZiAoa2V5d29yZHMgJiYga2V5d29yZHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXl3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBrZXl3b3JkID0ga2V5d29yZHNbaV1cbiAgICAgICAgICBpZiAoaWdub3JlQWNjZW50cykge1xuICAgICAgICAgICAga2V5d29yZCA9IHJlbW92ZUFjY2VudHMoa2V5d29yZClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qga2V5d29yZExlbiA9IGtleXdvcmQubGVuZ3RoXG5cbiAgICAgICAgICBsZXQgcG9zMSA9IDBcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBwb3MxID0gbGFiZWxMb3dlcmNhc2VOb0FjLmluZGV4T2Yoa2V5d29yZCwgcG9zMSlcbiAgICAgICAgICAgIGlmIChwb3MxID49IDApIHtcbiAgICAgICAgICAgICAgbGV0IHBvczIgPSBwb3MxICsga2V5d29yZExlblxuICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaChbcG9zMSwgcG9zMl0pXG4gICAgICAgICAgICAgIHBvczEgPSBwb3MyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAocG9zMSAhPT0gLTEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBrZXl3b3JkUGF0dGVybnMgPSBuZXcgU2V0KClcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IHBvc2l0aW9uc1tpXVxuICAgICAgICAgICAgY29uc3QgcG9zMSA9IHBhaXJbMF1cbiAgICAgICAgICAgIGNvbnN0IHBvczIgPSBwYWlyWzFdXG5cbiAgICAgICAgICAgIGNvbnN0IGtleXdvcmRQYXR0ZXJuID0gbGFiZWxMb3dlcmNhc2Uuc3Vic3RyaW5nKHBvczEsIHBvczIpXG4gICAgICAgICAgICBrZXl3b3JkUGF0dGVybnMuYWRkKGtleXdvcmRQYXR0ZXJuKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBrZXl3b3JkUGF0dGVybiBvZiBrZXl3b3JkUGF0dGVybnMpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIHBzdDogd29ya2Fyb25kIGZvciB3cm9uZyByZXBsYWNlbWVudCA8Yj4gdGFnc1xuICAgICAgICAgICAgaWYgKGtleXdvcmRQYXR0ZXJuID09PSBcImJcIikge1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChcIihcIiArIGtleXdvcmRQYXR0ZXJuICsgXCIpXCIsIFwiaWdcIilcblxuICAgICAgICAgICAgY29uc3QgbmV3SGlnaGxpZ2h0ZWQgPSBuZXdJdGVtLmhpZ2hsaWdodGVkLnJlcGxhY2UocmVnLCBcIjxiPiQxPC9iPlwiKVxuICAgICAgICAgICAgbmV3SXRlbS5oaWdobGlnaHRlZCA9IG5ld0hpZ2hsaWdodGVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJdGVtXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQWNjZW50cyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLm5vcm1hbGl6ZShcIk5GRFwiKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCBcIlwiKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNDb25maXJtZWQobGlzdEl0ZW0pIHtcbiAgICBpZiAoIXNlbGVjdGVkSXRlbSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkSXRlbS5pbmNsdWRlcyhsaXN0SXRlbSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpc3RJdGVtID09PSBzZWxlY3RlZEl0ZW1cbiAgICB9XG4gIH1cblxuICBsZXQgZHJhZ2dpbmdPdmVyID0gZmFsc2VcblxuICBmdW5jdGlvbiBkcmFnc3RhcnQoZXZlbnQsIGluZGV4KSB7XG4gICAgaWYgKG9yZGVyYWJsZVNlbGVjdGlvbikge1xuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJzb3VyY2VcIiwgaW5kZXgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhZ292ZXIoZXZlbnQsIGluZGV4KSB7XG4gICAgaWYgKG9yZGVyYWJsZVNlbGVjdGlvbikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgZHJhZ2dpbmdPdmVyID0gaW5kZXhcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnbGVhdmUoZXZlbnQsIGluZGV4KSB7XG4gICAgaWYgKG9yZGVyYWJsZVNlbGVjdGlvbikge1xuICAgICAgZHJhZ2dpbmdPdmVyID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcm9wKGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGRyYWdnaW5nT3ZlciA9IGZhbHNlXG4gICAgICBsZXQgZnJvbSA9IHBhcnNlSW50KGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwic291cmNlXCIpKVxuICAgICAgbGV0IHRvID0gaW5kZXhcbiAgICAgIGlmIChmcm9tICE9IHRvKSB7XG4gICAgICAgIG1vdmVTZWxlY3RlZEl0ZW0oZnJvbSwgdG8pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVNlbGVjdGVkSXRlbShmcm9tLCB0bykge1xuICAgIGxldCBuZXdTZWxlY3Rpb24gPSBbLi4uc2VsZWN0ZWRJdGVtXVxuICAgIGlmIChmcm9tIDwgdG8pIHtcbiAgICAgIG5ld1NlbGVjdGlvbi5zcGxpY2UodG8gKyAxLCAwLCBuZXdTZWxlY3Rpb25bZnJvbV0pXG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKGZyb20sIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NlbGVjdGlvbi5zcGxpY2UodG8sIDAsIG5ld1NlbGVjdGlvbltmcm9tXSlcbiAgICAgIG5ld1NlbGVjdGlvbi5zcGxpY2UoZnJvbSArIDEsIDEpXG4gICAgfVxuICAgIHNlbGVjdGVkSXRlbSA9IG5ld1NlbGVjdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2Nyb2xsQXdhcmVMaXN0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBoZWlnaHQ6IHZpZXdQb3J0SGVpZ2h0IH0gPSB3aW5kb3cudmlzdWFsVmlld3BvcnRcbiAgICBjb25zdCB7IGJvdHRvbTogaW5wdXRCdXR0b20sIGhlaWdodDogaW5wdXRIZWlnaHQgfSA9IGlucHV0Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeyBoZWlnaHQ6IGxpc3RIZWlnaHQgfSA9IGxpc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgIGlmIChpbnB1dEJ1dHRvbSArIGxpc3RIZWlnaHQgPiB2aWV3UG9ydEhlaWdodCkge1xuICAgICAgbGlzdC5zdHlsZS50b3AgPSBgLSR7aW5wdXRIZWlnaHQgKyBsaXN0SGVpZ2h0fXB4YFxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnN0eWxlLnRvcCA9IFwiMHB4XCJcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuPGRpdlxuICBjbGFzcz1cIntjbGFzc05hbWUgPyBjbGFzc05hbWUgOiAnJ30gYXV0b2NvbXBsZXRlIHNlbGVjdCBpcy1mdWxsd2lkdGgge3VuaXF1ZUlkfVwiXG4gIGNsYXNzOmhpZGUtYXJyb3c9e2hpZGVBcnJvdyB8fCAhaXRlbXMubGVuZ3RofVxuICBjbGFzczppcy1tdWx0aXBsZT17bXVsdGlwbGV9XG4gIGNsYXNzOnNob3ctY2xlYXI9e2NsZWFyYWJsZX1cbiAgY2xhc3M6aXMtbG9hZGluZz17c2hvd0xvYWRpbmdJbmRpY2F0b3IgJiYgbG9hZGluZ31cbj5cbiAgPHNlbGVjdCBuYW1lPXtzZWxlY3ROYW1lfSBpZD17c2VsZWN0SWR9IHttdWx0aXBsZX0+XG4gICAgeyNpZiAhbXVsdGlwbGUgJiYgaGFzU2VsZWN0aW9ufVxuICAgICAgPG9wdGlvbiB2YWx1ZT17dmFsdWVGdW5jdGlvbihzZWxlY3RlZEl0ZW0sIHRydWUpfSBzZWxlY3RlZD5cbiAgICAgICAge3NhZmVMYWJlbEZ1bmN0aW9uKHNlbGVjdGVkSXRlbSl9XG4gICAgICA8L29wdGlvbj5cbiAgICB7OmVsc2UgaWYgbXVsdGlwbGUgJiYgaGFzU2VsZWN0aW9ufVxuICAgICAgeyNlYWNoIHNlbGVjdGVkSXRlbSBhcyBpfVxuICAgICAgICA8b3B0aW9uIHZhbHVlPXt2YWx1ZUZ1bmN0aW9uKGksIHRydWUpfSBzZWxlY3RlZD5cbiAgICAgICAgICB7c2FmZUxhYmVsRnVuY3Rpb24oaSl9XG4gICAgICAgIDwvb3B0aW9uPlxuICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG4gIDwvc2VsZWN0PlxuICA8ZGl2IGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCIgYmluZDp0aGlzPXtpbnB1dENvbnRhaW5lcn0+XG4gICAgeyNpZiBtdWx0aXBsZSAmJiBoYXNTZWxlY3Rpb259XG4gICAgICB7I2VhY2ggc2VsZWN0ZWRJdGVtIGFzIHRhZ0l0ZW0sIGkgKHZhbHVlRnVuY3Rpb24odGFnSXRlbSwgdHJ1ZSkpfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgZHJhZ2dhYmxlPXt0cnVlfVxuICAgICAgICAgIGFuaW1hdGU6ZmxpcD17eyBkdXJhdGlvbjogMjAwIH19XG4gICAgICAgICAgdHJhbnNpdGlvbjpmYWRlPXt7IGR1cmF0aW9uOiAyMDAgfX1cbiAgICAgICAgICBvbjpkcmFnc3RhcnQ9eyhldmVudCkgPT4gZHJhZ3N0YXJ0KGV2ZW50LCBpKX1cbiAgICAgICAgICBvbjpkcmFnb3Zlcj17KGV2ZW50KSA9PiBkcmFnb3ZlcihldmVudCwgaSl9XG4gICAgICAgICAgb246ZHJhZ2xlYXZlPXsoZXZlbnQpID0+IGRyYWdsZWF2ZShldmVudCwgaSl9XG4gICAgICAgICAgb246ZHJvcD17KGV2ZW50KSA9PiBkcm9wKGV2ZW50LCBpKX1cbiAgICAgICAgICBjbGFzczppcy1hY3RpdmU9e2RyYWdnaW5nT3ZlciA9PT0gaX1cbiAgICAgICAgPlxuICAgICAgICAgIDxzbG90IG5hbWU9XCJ0YWdcIiBsYWJlbD17c2FmZUxhYmVsRnVuY3Rpb24odGFnSXRlbSl9IGl0ZW09e3RhZ0l0ZW19IHt1bnNlbGVjdEl0ZW19PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhZ3MgaGFzLWFkZG9uc1wiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRhZ1wiPntzYWZlTGFiZWxGdW5jdGlvbih0YWdJdGVtKX08L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0YWcgaXMtZGVsZXRlXCJcbiAgICAgICAgICAgICAgICBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdD17dW5zZWxlY3RJdGVtKHRhZ0l0ZW0pfVxuICAgICAgICAgICAgICAgIG9uOmtleXByZXNzfHByZXZlbnREZWZhdWx0PXsoZSkgPT4ge2Uua2V5ID09IFwiRW50ZXJcIiAmJiB1bnNlbGVjdEl0ZW0odGFnSXRlbSl9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgY2xhc3M9XCJ7aW5wdXRDbGFzc05hbWUgPyBpbnB1dENsYXNzTmFtZSA6ICcnfSB7bm9JbnB1dFN0eWxlc1xuICAgICAgICA/ICcnXG4gICAgICAgIDogJ2lucHV0IGF1dG9jb21wbGV0ZS1pbnB1dCd9XCJcbiAgICAgIGlkPXtpbnB1dElkID8gaW5wdXRJZCA6IFwiXCJ9XG4gICAgICBhdXRvY29tcGxldGU9e2h0bWw1YXV0b2NvbXBsZXRlID8gXCJvblwiIDogYXV0b2NvbXBsZXRlT2ZmVmFsdWV9XG4gICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICB7bmFtZX1cbiAgICAgIHtkaXNhYmxlZH1cbiAgICAgIHtyZXF1aXJlZH1cbiAgICAgIHt0aXRsZX1cbiAgICAgIHJlYWRvbmx5PXtyZWFkb25seSB8fCBsb2NrZWR9XG4gICAgICB7dGFiaW5kZXh9XG4gICAgICBiaW5kOnRoaXM9e2lucHV0fVxuICAgICAgYmluZDp2YWx1ZT17dGV4dH1cbiAgICAgIG9uOmlucHV0PXtvbklucHV0fVxuICAgICAgb246Zm9jdXM9e29uRm9jdXNJbnRlcm5hbH1cbiAgICAgIG9uOmJsdXI9e29uQmx1ckludGVybmFsfVxuICAgICAgb246a2V5ZG93bj17b25LZXlEb3dufVxuICAgICAgb246Y2xpY2s9e29uSW5wdXRDbGlja31cbiAgICAgIG9uOmtleXByZXNzPXtvbktleVByZXNzfVxuICAgICAgb246ZHJhZ292ZXI9eyhldmVudCkgPT4gZHJhZ292ZXIoZXZlbnQsIHNlbGVjdGVkSXRlbS5sZW5ndGggLSAxKX1cbiAgICAgIG9uOmRyb3A9eyhldmVudCkgPT4gZHJvcChldmVudCwgc2VsZWN0ZWRJdGVtLmxlbmd0aCAtIDEpfVxuICAgICAgey4uLiQkcmVzdFByb3BzfVxuICAgIC8+XG4gICAgeyNpZiBjbGVhcmFibGV9XG4gICAgICA8c3BhblxuICAgICAgICBvbjpjbGljaz17Y2xlYXJ9XG4gICAgICAgIG9uOmtleXByZXNzPXsoZSkgPT4ge2Uua2V5ID09IFwiRW50ZXJcIiAmJiBjbGVhcigpfX1cbiAgICAgICAgY2xhc3M9XCJhdXRvY29tcGxldGUtY2xlYXItYnV0dG9uXCJcbiAgICAgICAgPntAaHRtbCBjbGVhclRleHR9PC9zcGFuPlxuICAgIHsvaWZ9XG4gIDwvZGl2PlxuICA8ZGl2XG4gICAgY2xhc3M9XCJ7ZHJvcGRvd25DbGFzc05hbWUgPyBkcm9wZG93bkNsYXNzTmFtZSA6ICcnfSBhdXRvY29tcGxldGUtbGlzdCB7c2hvd0xpc3QgPyAnJyA6ICdoaWRkZW4nfVxuICAgIGlzLWZ1bGx3aWR0aFwiXG4gICAgYmluZDp0aGlzPXtsaXN0fVxuICA+XG4gICAgeyNpZiBmaWx0ZXJlZExpc3RJdGVtcyAmJiBmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGggPiAwfVxuICAgICAgPHNsb3QgbmFtZT1cImRyb3Bkb3duLWhlYWRlclwiIG5iSXRlbXM9e2ZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aH0ge21heEl0ZW1zVG9TaG93SW5MaXN0fSAvPlxuXG4gICAgICB7I2VhY2ggZmlsdGVyZWRMaXN0SXRlbXMgYXMgbGlzdEl0ZW0sIGl9XG4gICAgICAgIHsjaWYgbGlzdEl0ZW0gJiYgKG1heEl0ZW1zVG9TaG93SW5MaXN0IDw9IDAgfHwgaSA8IG1heEl0ZW1zVG9TaG93SW5MaXN0KX1cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW1cIlxuICAgICAgICAgICAgY2xhc3M6c2VsZWN0ZWQ9e2kgPT09IGhpZ2hsaWdodEluZGV4fVxuICAgICAgICAgICAgY2xhc3M6Y29uZmlybWVkPXtpc0NvbmZpcm1lZChsaXN0SXRlbS5pdGVtKX1cbiAgICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiBvbkxpc3RJdGVtQ2xpY2sobGlzdEl0ZW0pfVxuICAgICAgICAgICAgb246a2V5cHJlc3M9eyhlKSA9PiB7ZS5rZXkgPT0gXCJFbnRlclwiICYmIG9uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSl9fVxuICAgICAgICAgICAgb246cG9pbnRlcmVudGVyPXsoKSA9PiB7XG4gICAgICAgICAgICAgIGhpZ2hsaWdodEluZGV4ID0gaVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c2xvdFxuICAgICAgICAgICAgICBuYW1lPVwiaXRlbVwiXG4gICAgICAgICAgICAgIGl0ZW09e2xpc3RJdGVtLml0ZW19XG4gICAgICAgICAgICAgIGxhYmVsPXtsaXN0SXRlbS5oaWdobGlnaHRlZCA/IGxpc3RJdGVtLmhpZ2hsaWdodGVkIDogbGlzdEl0ZW0ubGFiZWx9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHsjaWYgbGlzdEl0ZW0uaGlnaGxpZ2h0ZWR9XG4gICAgICAgICAgICAgICAge0BodG1sIGxpc3RJdGVtLmhpZ2hsaWdodGVkfVxuICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAge0BodG1sIGxpc3RJdGVtLmxhYmVsfVxuICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgICAgey9lYWNofVxuXG4gICAgICA8c2xvdCBuYW1lPVwiZHJvcGRvd24tZm9vdGVyXCIgbmJJdGVtcz17ZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RofSB7bWF4SXRlbXNUb1Nob3dJbkxpc3R9PlxuICAgICAgICB7I2lmIG1heEl0ZW1zVG9TaG93SW5MaXN0ID4gMCAmJiBmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGggPiBtYXhJdGVtc1RvU2hvd0luTGlzdH1cbiAgICAgICAgICB7I2lmIG1vcmVJdGVtc1RleHR9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1uby1yZXN1bHRzXCI+XG4gICAgICAgICAgICAgIC4uLntmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGggLSBtYXhJdGVtc1RvU2hvd0luTGlzdH1cbiAgICAgICAgICAgICAge21vcmVJdGVtc1RleHR9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2lmfVxuICAgICAgPC9zbG90PlxuICAgIHs6ZWxzZSBpZiBsb2FkaW5nICYmIGxvYWRpbmdUZXh0fVxuICAgICAgPGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbG9hZGluZ1wiPlxuICAgICAgICA8c2xvdCBuYW1lPVwibG9hZGluZ1wiIHtsb2FkaW5nVGV4dH0+e2xvYWRpbmdUZXh0fTwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIHs6ZWxzZSBpZiBjcmVhdGV9XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1jcmVhdGVcIlxuICAgICAgICBvbjpjbGljaz17c2VsZWN0SXRlbX1cbiAgICAgICAgb246a2V5cHJlc3M9eyhlKSA9PiB7ZS5rZXkgPT0gXCJFbnRlclwiICYmIHNlbGVjdEl0ZW0oKX19XG4gICAgICA+XG4gICAgICAgIDxzbG90IG5hbWU9XCJjcmVhdGVcIiB7Y3JlYXRlVGV4dH0+e2NyZWF0ZVRleHR9PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgezplbHNlIGlmIG5vUmVzdWx0c1RleHR9XG4gICAgICA8ZGl2IGNsYXNzPVwiYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1uby1yZXN1bHRzXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJuby1yZXN1bHRzXCIge25vUmVzdWx0c1RleHR9Pntub1Jlc3VsdHNUZXh0fTwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIHsvaWZ9XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxzdmVsdGU6d2luZG93IG9uOmNsaWNrPXtvbkRvY3VtZW50Q2xpY2t9IG9uOnNjcm9sbD17KCkgPT4gc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUgPSB0cnVlfSAvPlxuXG48c3R5bGU+XG4gIC5hdXRvY29tcGxldGUge1xuICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIG1heC13aWR0aDogMTAwJTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcbiAgICBoZWlnaHQ6IDIuMjVlbTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGU6bm90KC5oaWRlLWFycm93KTpub3QoLmlzLWxvYWRpbmcpOjphZnRlciB7XG4gICAgYm9yZGVyOiAzcHggc29saWQ7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIGJvcmRlci1yaWdodDogMDtcbiAgICBib3JkZXItdG9wOiAwO1xuICAgIGNvbnRlbnQ6IFwiIFwiO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIGhlaWdodDogMC42MjVlbTtcbiAgICBtYXJnaW4tdG9wOiAtMC40Mzc1ZW07XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogNTAlO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgICB3aWR0aDogMC42MjVlbTtcbiAgICBib3JkZXItY29sb3I6ICMzMjczZGM7XG4gICAgcmlnaHQ6IDEuMTI1ZW07XG4gICAgei1pbmRleDogNDtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuc2hvdy1jbGVhcjpub3QoLmhpZGUtYXJyb3cpOjphZnRlciB7XG4gICAgcmlnaHQ6IDIuM2VtO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZSAqIHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG4gIC5hdXRvY29tcGxldGUtaW5wdXQge1xuICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBhZGRpbmc6IDVweCAxMXB4O1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZTpub3QoLmhpZGUtYXJyb3cpIC5hdXRvY29tcGxldGUtaW5wdXQge1xuICAgIHBhZGRpbmctcmlnaHQ6IDJlbTtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLnNob3ctY2xlYXI6bm90KC5oaWRlLWFycm93KSAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAzLjJlbTtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLmhpZGUtYXJyb3cuc2hvdy1jbGVhciAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyZW07XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLWxpc3Qge1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgei1pbmRleDogOTk7XG4gICAgcGFkZGluZzogMTBweCAwO1xuICAgIHRvcDogMHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XG4gICAgbWF4LWhlaWdodDogY2FsYygxNSAqICgxcmVtICsgMTBweCkgKyAxNXB4KTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3Q6ZW1wdHkge1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0ge1xuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgIGNvbG9yOiAjMzMzO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtLmNvbmZpcm1lZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzc4OWZlZDtcbiAgICBjb2xvcjogI2ZmZjtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS5zZWxlY3RlZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJlNjllMjtcbiAgICBjb2xvcjogI2ZmZjtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1uby1yZXN1bHRzIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBjb2xvcjogIzk5OTtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1jcmVhdGUge1xuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtLWxvYWRpbmcge1xuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS1saXN0LmhpZGRlbiB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5zaG93LWNsZWFyIC5hdXRvY29tcGxldGUtY2xlYXItYnV0dG9uIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMC4xZW07XG4gICAgcGFkZGluZzogMC4zZW0gMC42ZW07XG4gICAgdG9wOiA1MCU7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgei1pbmRleDogNDtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGU6bm90KC5zaG93LWNsZWFyKSAuYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUgc2VsZWN0IHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAuaW5wdXQtY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IGF1dG87XG4gICAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMnB4IHJnYmEoMTAsIDEwLCAxMCwgMC4xKTtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2I1YjViNTtcbiAgICBwYWRkaW5nLWxlZnQ6IDAuNGVtO1xuICAgIHBhZGRpbmctcmlnaHQ6IDAuNGVtO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLmlzLW11bHRpcGxlIC50YWcge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWFyZ2luLXRvcDogMC41ZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMC4zZW07XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLmlzLW11bHRpcGxlIC50YWcuaXMtZGVsZXRlIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLmlzLW11bHRpcGxlIC50YWdzIHtcbiAgICBtYXJnaW4tcmlnaHQ6IDAuM2VtO1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLmlzLW11bHRpcGxlIC5hdXRvY29tcGxldGUtaW5wdXQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZmxleDogMSAxIDUwcHg7XG4gICAgbWluLXdpZHRoOiAzZW07XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgYmFja2dyb3VuZDogbm9uZTtcbiAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IEF1dG9Db21wbGV0ZSBmcm9tIFwic2ltcGxlLXN2ZWx0ZS1hdXRvY29tcGxldGVcIjtcblxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlUZXh0ZmllbGRJbnB1dCBmcm9tIFwiLi91aS50ZXh0ZmllbGQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZEZpZWxkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxGaWVsZF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21pbkNoYXJhY3RlcnNUb1NlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZWxlY3RGaXJzdElmRW1wdHldXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhJdGVtc1RvU2hvd0luTGlzdF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25vUmVzdWx0c1RleHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvd0NsZWFyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnB1dFN0YXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Vycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtRXJyb3JzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VhcmNoRnVuY3Rpb25dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIC8vZ2VuZXJpYyBpbnB1dCBwcm9wc1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY2hlY2tib3gtbGlzdFwiLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb25jaGFuZ2UpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgZGlzYWJsZWR9XG4gICAgPFVJVGV4dGZpZWxkSW5wdXRcbiAgICAgICAgdmFsdWU9e3ZhbHVlID8gdmFsdWUudGl0bGUgOiBcIlwifVxuICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbns6ZWxzZSBpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWUgPyB2YWx1ZS50aXRsZSA6IFwiXCJ9PC9wPlxuezplbHNlfVxuICAgIDxBdXRvQ29tcGxldGVcbiAgICAgICAgYmluZDpzZWxlY3RlZEl0ZW09e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25pbnB1dH1cbiAgICAgICAge3ZhbGlkfVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKG5ldyBEYXRlKCkpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgcGF0dGVybiA9IFwiZHs0fS1kezJ9LWR7Mn1cIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0lTT1N0cmluZygpLnNwbGl0KFwiVFwiKVswXTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKFwiVFwiKSA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoXCJUXCIpWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvbmNoYW5nZSk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD5cbiAgICAgICAgPHRpbWUgZGF0ZXRpbWU9e3ZhbHVlfT57VUlDb21tb24udHJ5Rm9ybWF0TG9jYWxlRGF0ZVRpbWUodmFsdWUpfTwvdGltZT5cbiAgICA8L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC1kYXRlLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwiZGF0ZVwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICB7cGF0dGVybn1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIG9uY2hhbmdlPXtvbmlucHV0fVxuICAgICAgICB7b25pbnB1dH1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTXNGcm9tRGF0ZShpc29EYXRlLCBtYXJrQXNaVUxVID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGlzb0RhdGUuc3BsaXQoXCIuXCIpWzBdICsgKG1hcmtBc1pVTFUgPyBcIlwiIDogXCJaXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoaWZ0RGF0ZXRpbWUoaXNvRGF0ZSwgc2hpZnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVVdGMgPSBuZXcgRGF0ZShtYXJrQXNaVUxVKGlzb0RhdGUpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzaGlmdCAqIC02MDAwMDtcbiAgICAgICAgICAgIGlmIChkYXRlSXNWYWxpZChkYXRlVXRjICsgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlVXRjICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJc29EYXRlID0gbmV3RGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVNc0Zyb21EYXRlKG5ld0lzb0RhdGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtBc1pVTFUoZGF0ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gZGF0ZVN0cmluZyAmJiBkYXRlU3RyaW5nLmF0KC0xKSAhPT0gXCJaXCJcbiAgICAgICAgICAgID8gZGF0ZVN0cmluZyArIFwiWlwiXG4gICAgICAgICAgICA6IGRhdGVTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcImRhdGV0aW1lXCIsXG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKHJlbW92ZU1zRnJvbURhdGUobmV3IERhdGUoKS50b0lTT1N0cmluZygpKSksXG4gICAgICAgIHRpbWV6b25lT2Zmc2V0ID0gMCxcbiAgICAgICAgcmVxdWlyZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHNoaWZ0ZWRWYWx1ZSA9ICRzdGF0ZSgpLFxuICAgICAgICBwcmV2U2hpZnRlZFZhbHVlO1xuXG4gICAgY29uc3Qgc2V0U2hpZnRlZCA9ICh2YWwpID0+IHtcbiAgICAgICAgaWYgKGRhdGVJc1ZhbGlkKHZhbCkpIHtcbiAgICAgICAgICAgIHByZXZTaGlmdGVkVmFsdWUgPSBzaGlmdGVkVmFsdWU7XG4gICAgICAgICAgICBzaGlmdGVkVmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVzZXRTaGlmdGVkVmFsdWUgPSAoKSA9PiB7XG4gICAgICAgIHNoaWZ0ZWRWYWx1ZSA9IHByZXZTaGlmdGVkVmFsdWU7XG4gICAgfTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBzZXRTaGlmdGVkKHNoaWZ0RGF0ZXRpbWUodmFsdWUsIHRpbWV6b25lT2Zmc2V0KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkYXRlSXNWYWxpZCA9IChkYXRlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gKCkgPT5cbiAgICAgICAgdmFsdWUgIT09IHNoaWZ0RGF0ZXRpbWUoc2hpZnRlZFZhbHVlLCAtdGltZXpvbmVPZmZzZXQsIHRydWUpO1xuXG4gICAgY29uc3QgZGlzcGF0Y2hDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIHNldFNoaWZ0ZWQoc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBtYXJrQXNaVUxVKHNoaWZ0RGF0ZXRpbWUoc2hpZnRlZFZhbHVlLCAtdGltZXpvbmVPZmZzZXQsIHRydWUpKTtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZXYpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXYuY3VycmVudFRhcmdldC52YWx1ZSAmJlxuICAgICAgICAgICAgc2hpZnRlZFZhbHVlICYmXG4gICAgICAgICAgICBkYXRlSXNWYWxpZChzaGlmdGVkVmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQoKSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0U2hpZnRlZFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbjwvc2NyaXB0PlxuXG57I2lmIHNoaWZ0ZWRWYWx1ZX1cbiAgICB7I2lmIHJlYWRvbmx5fVxuICAgICAgICA8cD57c2hpZnRlZFZhbHVlfTwvcD5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLWRhdGV0aW1lLWluLXRpbWV6b25lLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIGNsYXNzPVwiaW5wdXQge2NsYXNzZXN9XCJcbiAgICAgICAgICAgIHR5cGU9XCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBiaW5kOnZhbHVlPXtzaGlmdGVkVmFsdWV9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICAgICAgb25jaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgb25ibHVyPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uaW5wdXQ9e29uQ2hhbmdlfVxuICAgICAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgey9pZn1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImVtYWlsXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb25jaGFuZ2UpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLWVtYWlsLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwiZW1haWxcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIG9uY2hhbmdlPXtvbmlucHV0fVxuICAgICAgICB7b25pbnB1dH1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImhpZGRlblwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48aW5wdXRcbiAgICBpZD1cImZvcm0tZmllbGQtaGlkZGVuLXtmaWVsZG5hbWV9XCJcbiAgICB0eXBlPVwiaGlkZGVuXCJcbiAgICBiaW5kOnZhbHVlXG4gICAge3JlcXVpcmVkfVxuICAgIHtyZWFkb25seX1cbiAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAge290aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRleHRhcmVhXCIsXG4gICAgICAgIHJvd3MgPSAxMCxcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvbmNoYW5nZSk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDx0ZXh0YXJlYVxuICAgICAgICBpZD1cImZvcm0tZmllbGQtdGV4dGFyZWEte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cInRleHRhcmVhIHtjbGFzc2VzfVwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgb25ibHVyPXtvbmlucHV0fVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHtyb3dzfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgPjwvdGV4dGFyZWE+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRleHRhcmVhIGZyb20gXCIuL3VpLnRleHRhcmVhLnN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIGZpZWxkbmFtZSA9IFwianNvbmFyZWFcIixcbiAgICAgICAgdmFsaWQgPSAkYmluZGFibGUodHJ1ZSksXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25lcnJvciA9ICgpID0+IHt9LFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgX3ZhbHVlID0gJHN0YXRlKFwie31cIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF92YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCA0KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBfdmFsdWUgPSBcInt9XCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKHsgdmFsdWU6IHZhbCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsKTtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvbmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlUZXh0YXJlYSBiaW5kOnZhbHVlPXtfdmFsdWV9IG9uY2hhbmdlPXtvbkNoYW5nZX0ge3ZhbGlkfSB7Li4ub3RoZXJzfSAvPlxuIiwiY2xhc3MgTGliIHtcbiAgICAjbGliID0ge307XG5cbiAgICBjb25zdHJ1Y3RvcihzZWVkTGliKSB7XG4gICAgICAgIGlmIChzZWVkTGliIGluc3RhbmNlb2YgTGliKSB7XG4gICAgICAgICAgICB0aGlzLmltcG9ydChzZWVkTGliLmdldENvbnRlbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbXMge3N0cmluZ30gIG1vZGUgd2hhdCB0byBkbyBpZiBlbGVtZW50IGV4aXN0cyBbcmVwbGFjZXxhZGR8c2tpcF1cbiAgICAgKi9cbiAgICBhZGQobmFtZSwgY29tcCwgbW9kZSA9IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsaWJbbmFtZV0gPSBjb21wO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImFkZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbGliW25hbWVdID0gT2JqZWN0LmFzc2lnbih0aGlzLiNsaWJbbmFtZV0sIGNvbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbGliW25hbWVdID0gY29tcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNsaWJbbmFtZV07XG4gICAgfVxuXG4gICAgY29udGFpbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bih0aGlzLiNsaWIsIG5hbWUpO1xuICAgIH1cblxuICAgIGltcG9ydChidWxrLCBtb2RlID0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgZm9yIChsZXQgZiBpbiBidWxrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChmLCBidWxrW2ZdLCBtb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiNsaWIpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICBnZXRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy4jbGliLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGliO1xuIiwiLypcbiAqINCR0LjQsdC70LjQvtGC0LXQutCwIFVJINC60L7QvdGB0YLRgNGD0LrRgtC+0YDQvtCyXG4gKi9cblxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IExpYiBmcm9tIFwiLi9saWIuanNcIjtcblxuY29uc3QgQ09NUE9ORU5UUyA9IG5ldyBMaWIoKTtcbmNvbnN0IEZJRUxEUyA9IG5ldyBMaWIoKTtcbmNvbnN0IFZBUklBTlRTID0gbmV3IExpYigpO1xuXG5leHBvcnQgeyBDT01QT05FTlRTLCBGSUVMRFMsIFZBUklBTlRTIH07XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFVJVGl0bGUgfSBmcm9tIFwiLi4vdmFyaW91c1wiO1xuPC9zY3JpcHQ+XG5cbjxVSVRpdGxlIHRpdGxlPXtcIm5vdC1ub2RlOmVtcHR5X2xpc3RfcGxhY2Vob2xkZXJcIn0gc2l6ZT17NH0gYWxpZ249e1wiY2VudGVyXCJ9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV0gLSBhdHRyaWJ1dGVzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGRvd25sb2FkXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YXJnZXRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHJlbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpZ2h0XSAtIHZpc3VhbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmFpc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dGxpbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdW5kZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnV0dG9uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl0gLSBpY29uc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICB1cmwgPSBcIlwiLFxuICAgICAgICBkb3dubG9hZCxcbiAgICAgICAgdGFyZ2V0ID0gXCJfYmxhbmtcIixcbiAgICAgICAgcmVsLFxuICAgICAgICBsaWdodCA9IGZhbHNlLFxuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHJhaXNlZCA9IGZhbHNlLFxuICAgICAgICBvdXRsaW5lZCA9IGZhbHNlLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICByb3VuZGVkID0gZmFsc2UsXG4gICAgICAgIGJ1dHRvbiA9IHRydWUsXG4gICAgICAgIHN0YXRlOiBhY3RpdmVTdGF0ZSA9IFwiXCIsXG4gICAgICAgIHR5cGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGljb24sXG4gICAgICAgIGljb25TaWRlID0gXCJyaWdodFwiLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgc2lkZUljb24oKX1cbiAgICA8c3BhbiBjbGFzcz1cImljb25cIlxuICAgICAgICA+PGkgY2xhc3M9XCJmYXMgZmEte2ljb259IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCI+PC9pPjwvc3BhblxuICAgID5cbnsvc25pcHBldH1cblxuPGFcbiAgICBvbmNsaWNrPXthY3Rpb24gfHwgb25jbGlja31cbiAgICBocmVmPXt1cmx9XG4gICAge3RhcmdldH1cbiAgICB7ZG93bmxvYWR9XG4gICAge3JlbH1cbiAgICBjbGFzcz1cIntjbGFzc2VzfSB7YWN0aXZlU3RhdGUgPyBgaXMtJHthY3RpdmVTdGF0ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgOiAnJ30ge3R5cGUgPyBgaXMtJHt0eXBlfWAgOiAnJ30ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIlxuICAgIGNsYXNzOmJ1dHRvblxuICAgIGNsYXNzOmlzLWxpZ2h0PXtsaWdodH1cbiAgICBjbGFzczppcy1pbnZlcnRlZD17aW52ZXJ0ZWR9XG4gICAgY2xhc3M6aXMtb3V0bGluZWQ9e291dGxpbmVkfVxuICAgIGNsYXNzOmlzLXJhaXNlZD17cmFpc2VkfVxuICAgIGNsYXNzOmlzLXJvdW5kZWQ9e3JvdW5kZWR9XG4gICAgY2xhc3M6aXMtbG9hZGluZz17bG9hZGluZ31cbj5cbiAgICB7I2lmIGljb259XG4gICAgICAgIHsjaWYgaWNvblNpZGUgPT09IFwibGVmdFwifXtAcmVuZGVyIHNpZGVJY29uKCl9ey9pZn1cbiAgICAgICAgeyNpZiB0aXRsZX08c3Bhbj57JExPQ0FMRVt0aXRsZV19PC9zcGFuPnsvaWZ9XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJyaWdodFwifXtAcmVuZGVyIHNpZGVJY29uKCl9ey9pZn1cbiAgICB7OmVsc2V9eyRMT0NBTEVbdGl0bGVdfXtAcmVuZGVyIGNoaWxkcmVuPy4oKX17L2lmfVxuPC9hPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMaW5rIGZyb20gXCIuL3VpLmxpbmsuc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgW3ZhbHVlcz1bXV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzZXM9JyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2VudGVyZWQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbam9pbmVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2l0ZW1zUHJvcHMgPSB7fV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgam9pbmVkID0gdHJ1ZSxcbiAgICAgICAgaXRlbXNQcm9wcyA9IHt9LFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgbGlzdExpbmtzKCl9XG4gICAgeyNlYWNoIHZhbHVlcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgPFVJTGluayB7Li4uaXRlbX0gey4uLml0ZW1zUHJvcHN9IC8+XG4gICAgey9lYWNofVxuey9zbmlwcGV0fVxuXG57I2lmIGpvaW5lZH1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiZmllbGQgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICA+XG4gICAgICAgIDxwIGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAge0ByZW5kZXIgbGlzdExpbmtzKCl9XG4gICAgICAgIDwvcD5cbiAgICA8L2Rpdj5cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiYnV0dG9ucyB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICA+XG4gICAgICAgIHtAcmVuZGVyIGxpc3RMaW5rcygpfVxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpbmtzIGZyb20gXCIuLi9saW5rL3VpLmxpbmtzLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge2FueX0gZGVzY3JpcHRpb25cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaW5rc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3RBY3Rpb25zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdExpbmtzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbW1vbkNsYXNzZXNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWUgLSB2YWx1ZSBvZiBpdGVtLCB3aWxsIGJlIHBhc3NlZCB0byBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaW5kZXhdIC0gaW5kZXggaW4gYXJyYXkgMC1sZW5ndGhcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmaXJzdF0gLSBpZiBmaXJzdFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xhc3RdIC0gaWYgbGFzdFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRdIC0gY3VzdG9taXphdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gZGVzY3JpcHRpb25Db21wb25lbnRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGltYWdlQ29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpbWFnZUNvbXBvbmVudFByb3BzXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgbGlzdEFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlzdExpbmtzID0gW10sXG4gICAgICAgIGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjb21tb25DbGFzc2VzID0gXCJcIixcbiAgICAgICAgaW1hZ2UgPSBcIlwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgZmlyc3QgPSBmYWxzZSxcbiAgICAgICAgbGFzdCA9IGZhbHNlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDYgfSxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnQsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgb25jbGlja0ltYWdlID0gKCkgPT4gZmFsc2UsXG4gICAgICAgIG9uY2xpY2tDb250ZW50ID0gKCkgPT4gZmFsc2UsXG4gICAgICAgIG9uY2xpY2tUaXRsZSA9ICgpID0+IGZhbHNlLFxuICAgICAgICBvbmNsaWNrRGVzY3JpcHRpb24gPSAoKSA9PiBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICBvbmNsaWNrKHZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgYWxsQWN0aW9ucyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IGFsbExpbmtzID0gJHN0YXRlKFtdKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBhbGxBY3Rpb25zID0gWy4uLmFjdGlvbnMsIC4uLmxpc3RBY3Rpb25zXS5tYXAoKGJ0bikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYnRuLCBhY3Rpb246ICgpID0+IGJ0bi5hY3Rpb24odmFsdWUpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxMaW5rcyA9IFsuLi5saW5rcywgLi4ubGlzdExpbmtzXTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgcm9sZT1cImJ1dHRvblwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICBjbGFzcz1cImxpc3QtaXRlbSB7Y2xhc3Nlc30ge2NvbW1vbkNsYXNzZXN9IHtsYXN0XG4gICAgICAgID8gJ2xpc3QtaXRlbS1sYXN0J1xuICAgICAgICA6ICcnfSB7Zmlyc3RcbiAgICAgICAgICAgID8gJ2xpc3QtaXRlbS1maXJzdCdcbiAgICAgICAgICAgIDogJyd9ICB7YGxpc3QtaXRlbS1hdC0ke2luZGV4fWB9IHtgbGlzdC1pdGVtLWAgK1xuICAgICAgICAoaW5kZXggJSAyID8gJ29kZCcgOiAnZXZlbicpfVwiXG4gICAgb25jbGljaz17b25DbGlja31cbiAgICBvbmtleXVwPXsoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLmtleSA9PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH19XG4+XG4gICAgeyNpZiBpbWFnZX1cbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0taW1hZ2VcIlxuICAgICAgICAgICAgb25rZXl1cD17KGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5rZXkgPT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgb25jbGlja0ltYWdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25jbGljaz17KGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb25DbGljaygpO1xuICAgICAgICAgICAgICAgIG9uY2xpY2tJbWFnZSh2YWx1ZSk7XG4gICAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgICB7I2lmIGltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgIHsjaWYgdHlwZW9mIGltYWdlID09PSBcInN0cmluZ1wifVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IGltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICA8U3ZlbHRlQ29tcG9uZW50IHZhbHVlPXtpbWFnZX0gey4uLmltYWdlQ29tcG9uZW50UHJvcHN9IC8+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF8xID0gaW1hZ2VDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnRfMSB7Li4uaW1hZ2V9IHsuLi5pbWFnZUNvbXBvbmVudFByb3BzfSAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGZpZ3VyZSBjbGFzcz1cImltYWdlIGlzLTY0eDY0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJpcy1yb3VuZGVkXCIgc3JjPXtpbWFnZX0gYWx0PXt0aXRsZX0gLz5cbiAgICAgICAgICAgICAgICA8L2ZpZ3VyZT5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvZGl2PlxuICAgIHsvaWZ9XG4gICAgPGRpdlxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0tY29udGVudFwiXG4gICAgICAgIG9uY2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICBvbmNsaWNrQ29udGVudCh2YWx1ZSk7XG4gICAgICAgIH19XG4gICAgICAgIG9ua2V5dXA9eyhlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLmtleSA9PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgb25jbGlja0NvbnRlbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fVxuICAgID5cbiAgICAgICAgeyNpZiB0aXRsZX1cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzcz1cImxpc3QtaXRlbS10aXRsZVwiXG4gICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICBvbmtleXVwPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUua2V5ID09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGlja1RpdGxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgb25jbGljaz17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2tUaXRsZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7I2lmIHRpdGxlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICB7I2lmIHR5cGVvZiB0aXRsZSA9PT0gXCJzdHJpbmdcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50XzIgPSB0aXRsZUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnRfMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Li4udGl0bGVDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b25jaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF8zID0gdGl0bGVDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3ZlbHRlQ29tcG9uZW50XzNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Li4udGl0bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey4uLnRpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29uY2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICBvbmtleXVwPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUua2V5ID09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGlja0Rlc2NyaXB0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0tZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgICAgIG9uY2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrRGVzY3JpcHRpb24odmFsdWUpO1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgeyNpZiBkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgeyNpZiB0eXBlb2YgZGVzY3JpcHRpb24gPT09IFwic3RyaW5nXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF80ID0gZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3ZlbHRlQ29tcG9uZW50XzRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge29uY2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnRfNSA9IGRlc2NyaXB0aW9uQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudF81XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey4uLmRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5kZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtvbmNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b25jbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb259XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuXG4gICAgeyNpZiAoYWxsQWN0aW9ucyAmJiBhbGxBY3Rpb25zLmxlbmd0aCkgfHwgKGFsbExpbmtzICYmIGFsbExpbmtzLmxlbmd0aCl9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW0tY29udHJvbHNcIj5cbiAgICAgICAgICAgIHsjaWYgYWxsQWN0aW9ucyAmJiBhbGxBY3Rpb25zLmxlbmd0aH1cbiAgICAgICAgICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17YWxsQWN0aW9uc30gcmlnaHQ9e3RydWV9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNpZiBhbGxMaW5rcyAmJiBhbGxMaW5rcy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgPFVJTGlua3MgdmFsdWVzPXthbGxMaW5rc30gcmlnaHQ9e3RydWV9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxpc3RJdGVtIGZyb20gXCIuL3VpLmxpc3QuaXRlbS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZEZpZWxkTmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpbmtzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaXRlbUNsYXNzZXNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0SXRlbUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3RJdGVtQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0aXRsZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGRlc2NyaXB0aW9uQ29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBpbWFnZUNvbXBvbmVudFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaW1hZ2VDb21wb25lbnRQcm9wc11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWRGaWVsZE5hbWUgPSBcImlkXCIsXG4gICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgaXRlbUNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBsaXN0SXRlbUNvbXBvbmVudCA9IFVJTGlzdEl0ZW0sXG4gICAgICAgIGxpc3RJdGVtQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA2IH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGltYWdlQ29tcG9uZW50LFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXN9XG4gICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBsaXN0SXRlbUNvbXBvbmVudH1cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaW5kZXggKGl0ZW1baWRGaWVsZE5hbWVdKX1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICAgICAgey4uLmxpc3RJdGVtQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7dGl0bGVDb21wb25lbnR9XG4gICAgICAgICAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7Li4uaXRlbX1cbiAgICAgICAgICAgIGxpc3RBY3Rpb25zPXthY3Rpb25zfVxuICAgICAgICAgICAgbGlzdExpbmtzPXtsaW5rc31cbiAgICAgICAgICAgIGNvbW1vbkNsYXNzZXM9e2l0ZW1DbGFzc2VzfVxuICAgICAgICAgICAgYmluZDp2YWx1ZT17aXRlbXNbaW5kZXhdfVxuICAgICAgICAgICAge2luZGV4fVxuICAgICAgICAgICAgZmlyc3Q9e2luZGV4ID09PSAwfVxuICAgICAgICAgICAgbGFzdD17aW5kZXggPT09IGl0ZW1zLmxlbmd0aCAtIDF9XG4gICAgICAgICAgICBvbjpjbGlja1xuICAgICAgICAgICAgb246Y2xpY2tDb250ZW50XG4gICAgICAgICAgICBvbjpjbGlja0Rlc2NyaXB0aW9uXG4gICAgICAgICAgICBvbjpjbGlja0ltYWdlXG4gICAgICAgICAgICBvbjpjbGlja1RpdGxlXG4gICAgICAgIC8+XG4gICAgey9lYWNofVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGlzdEVtcHR5UGxhY2Vob2xkZXIgZnJvbSBcIi4vdWkubGlzdC5lbXB0eS5wbGFjZWhvbGRlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlMaXN0SXRlbSBmcm9tIFwiLi91aS5saXN0Lml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlzdEJsb2NrIGZyb20gXCIuL3VpLmxpc3QuYmxvY2suc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG5cblxuXG5cbiAgICAvL2N1c3RvbWl6YXRpb25cbiAgICBcbiAgICBcbiAgICBcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpbmtzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FjdGlvbnNWaXNpYmxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2l0ZW1zSG92ZXJhYmxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJmbG93RWxsaXBzaXNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaGlkZGVuSW1hZ2VzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaXRlbUNsYXNzZXNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGl0ZW1MZW5ndGhcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkRmllbGROYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRdIC0gZW1wdHlcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2VtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0SXRlbUNvbXBvbmVudF0gLSBpdGVtXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0SXRlbUNvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRdIC0gaXRlbSBwYXJ0c1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gZGVzY3JpcHRpb25Db21wb25lbnRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGltYWdlQ29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpbWFnZUNvbXBvbmVudFByb3BzXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaXRlbXMgPSAkYmluZGFibGUoW10pLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGxpbmtzID0gW10sXG4gICAgICAgIGFjdGlvbnNWaXNpYmxlID0gZmFsc2UsXG4gICAgICAgIGl0ZW1zSG92ZXJhYmxlID0gZmFsc2UsXG4gICAgICAgIG92ZXJmbG93RWxsaXBzaXMgPSBmYWxzZSxcbiAgICAgICAgaGlkZGVuSW1hZ2VzID0gZmFsc2UsXG4gICAgICAgIGl0ZW1DbGFzc2VzID0gXCJcIixcbiAgICAgICAgaXRlbUxlbmd0aCxcbiAgICAgICAgaWRGaWVsZE5hbWUgPSBcImlkXCIsXG4gICAgICAgIGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50ID0gVUlMaXN0RW1wdHlQbGFjZWhvbGRlcixcbiAgICAgICAgZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0SXRlbUNvbXBvbmVudCA9IFVJTGlzdEl0ZW0sXG4gICAgICAgIGxpc3RJdGVtQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA2IH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGltYWdlQ29tcG9uZW50LFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0ge31cbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtcy5sZW5ndGh9XG4gICAgPGRpdlxuICAgICAgICBzdHlsZT17aXRlbUxlbmd0aCA/IGAtLWxlbmd0aDogJHtpdGVtTGVuZ3RofTtgIDogXCJcIn1cbiAgICAgICAgY2xhc3M9XCJsaXN0IHtjbGFzc2VzfSB7YWN0aW9uc1Zpc2libGVcbiAgICAgICAgICAgID8gJ2hhcy12aXNpYmxlLXBvaW50ZXItY29udHJvbHMnXG4gICAgICAgICAgICA6ICcnfSB7aXRlbXNIb3ZlcmFibGVcbiAgICAgICAgICAgICAgICA/ICdoYXMtaG92ZXJhYmxlLWxpc3QtaXRlbXMnXG4gICAgICAgICAgICAgICAgOiAnJ30ge292ZXJmbG93RWxsaXBzaXNcbiAgICAgICAgICAgICAgICAgICAgPyAnaGFzLW92ZXJmbG93LWVsbGlwc2lzJ1xuICAgICAgICAgICAgICAgICAgICA6ICcnfSB7aGlkZGVuSW1hZ2VzID8gJ2hhcy1oaWRkZW4taW1hZ2VzJyA6ICcnfVwiXG4gICAgPlxuICAgICAgICA8VUlMaXN0QmxvY2tcbiAgICAgICAgICAgIGJpbmQ6aXRlbXNcbiAgICAgICAgICAgIHtpdGVtQ2xhc3Nlc31cbiAgICAgICAgICAgIHtsaXN0SXRlbUNvbXBvbmVudH1cbiAgICAgICAgICAgIHtsaXN0SXRlbUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2lkRmllbGROYW1lfVxuICAgICAgICAgICAge3RpdGxlQ29tcG9uZW50fVxuICAgICAgICAgICAge3RpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtpbWFnZUNvbXBvbmVudH1cbiAgICAgICAgICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2FjdGlvbnN9XG4gICAgICAgICAgICB7bGlua3N9XG4gICAgICAgICAgICBvbjpjaGFuZ2VcbiAgICAgICAgICAgIG9uOmNsaWNrXG4gICAgICAgICAgICBvbjpjbGlja0NvbnRlbnRcbiAgICAgICAgICAgIG9uOmNsaWNrRGVzY3JpcHRpb25cbiAgICAgICAgICAgIG9uOmNsaWNrSW1hZ2VcbiAgICAgICAgICAgIG9uOmNsaWNrVGl0bGVcbiAgICAgICAgLz5cbiAgICA8L2Rpdj5cbns6ZWxzZX1cbiAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50fVxuICAgIDxTdmVsdGVDb21wb25lbnRcbiAgICAgICAgey4uLmVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IENPTVBPTkVOVFMgfSBmcm9tIFwiLi4vLi4vZnJhbWUvTElCLmpzXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uLmpzXCI7XG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vbGlzdC91aS5saXN0LnN2ZWx0ZVwiO1xuXG4gICAgLy9maWVsZCBwcm9wc1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnB1dFN0YXJ0ZWRdIC0gc3ZlbHRlLWlnbm9yZSB1bnVzZWQtZXhwb3J0LWxldFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttdWx0aXBsZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRdIC0gdmFsaWRhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkYXRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlcnJvcnNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9ybUVycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtTGV2ZWxFcnJvcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW21vZGVsTmFtZV0gLSBtb2RlbCBiaW5kaW5nc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWN0aW9uTmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbkZpbHRlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvblNvcnRlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvblBhZ2VyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uU2VhcmNoXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9uSWRdIC0gcHJlc2VudGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25UaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdG9yVUldIC0gc2VsZWN0b3IgVUkgdG8gYWRkIG5ldyBpdGVtIHRvIGxpc3RcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlbGVjdG9yVUlQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2l0ZW1VSV0gLSBsaXN0IGl0ZW0gVUkgdG8gcHJlc2VudCBpbiByZWFkb25seSBvciBlZGl0YWJsZSB2YXJpYW50c1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbVVJUHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0cmFuc2Zvcm1WYWx1ZUl0ZW1Ub0xpc3RJdGVtXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBmaWVsZG5hbWUgPSAkYmluZGFibGUoXCJzZWxlY3RGcm9tTW9kZWxcIiksXG4gICAgICAgIHJlcXVpcmVkID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBtdWx0aXBsZSA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIHNpemUgPSAkYmluZGFibGUoOCksXG4gICAgICAgIHZhbGlkID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICBtb2RlbE5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25OYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uRmlsdGVyID0ge30sXG4gICAgICAgIGFjdGlvblNvcnRlciA9IHt9LFxuICAgICAgICBhY3Rpb25QYWdlciA9IHt9LFxuICAgICAgICBhY3Rpb25TZWFyY2ggPSB1bmRlZmluZWQsXG4gICAgICAgIG9wdGlvbklkID0gXCI6X2lkXCIsXG4gICAgICAgIG9wdGlvblRpdGxlID0gXCI6dGl0bGVcIixcbiAgICAgICAgc2VsZWN0b3JVSSA9IFwiVUlTZWxlY3RGcm9tTW9kZWxPbkRlbWFuZElubGluZVwiLFxuICAgICAgICBzZWxlY3RvclVJUHJvcHMgPSB7fSxcbiAgICAgICAgaXRlbVVJID0gXCJVSUxpc3RJdGVtXCIsXG4gICAgICAgIGl0ZW1VSVByb3BzID0ge30sXG4gICAgICAgIHRyYW5zZm9ybVZhbHVlSXRlbVRvTGlzdEl0ZW0gPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBhZGRJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGxldCBpdGVtcyA9ICRkZXJpdmVkKFxuICAgICAgICB2YWx1ZS5tYXAgPyB2YWx1ZS5tYXAodHJhbnNmb3JtVmFsdWVJdGVtVG9MaXN0SXRlbSkgOiBbXVxuICAgICk7XG5cbiAgICBjb25zdCBBQ1RJT05TID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb24obGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0SXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSW5kZXggPSB2YWx1ZS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUl0ZW0pID0+IHZhbHVlSXRlbSA9PT0gdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsQ29weSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5tb3ZlSXRlbSh2YWxDb3B5LCBpdGVtSW5kZXgsIGl0ZW1JbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbENvcHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICAgICAgaWNvbjogXCJhcnJvdy11cFwiLFxuICAgICAgICAgICAgY29sb3I6IFwibm9ybWFsXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gbGlzdEl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gdmFsdWUuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgICAodmFsdWVJdGVtKSA9PiB2YWx1ZUl0ZW0gPT09IHZhbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbENvcHkgPSBbLi4udmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ubW92ZUl0ZW0odmFsQ29weSwgaXRlbUluZGV4LCBpdGVtSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWxDb3B5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgIGljb246IFwiYXJyb3ctZG93blwiLFxuICAgICAgICAgICAgY29sb3I6IFwibm9ybWFsXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gbGlzdEl0ZW0udmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gdmFsdWUuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgICAodmFsdWVJdGVtKSA9PiB2YWx1ZUl0ZW0gPT09IHZhbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgIGljb246IFwidHJhc2hcIixcbiAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICB9LFxuICAgIF07XG48L3NjcmlwdD5cblxuPFVJTGlzdFxuICAgIGxpc3RJdGVtQ29tcG9uZW50PXtDT01QT05FTlRTLmdldChpdGVtVUkpfVxuICAgIHsuLi5pdGVtVUlQcm9wc31cbiAgICB7aXRlbXN9XG4gICAgYWN0aW9ucz17QUNUSU9OU31cbi8+XG57I2lmICFyZWFkb25seX1cbiAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IENPTVBPTkVOVFMuZ2V0KHNlbGVjdG9yVUkpfVxuICAgIDxTdmVsdGVDb21wb25lbnRcbiAgICAgICAgey4uLnNlbGVjdG9yVUlQcm9wc31cbiAgICAgICAge21vZGVsTmFtZX1cbiAgICAgICAge2FjdGlvbk5hbWV9XG4gICAgICAgIHthY3Rpb25GaWx0ZXJ9XG4gICAgICAgIHthY3Rpb25Tb3J0ZXJ9XG4gICAgICAgIHthY3Rpb25QYWdlcn1cbiAgICAgICAge2FjdGlvblNlYXJjaH1cbiAgICAgICAge29wdGlvbklkfVxuICAgICAgICB7b3B0aW9uVGl0bGV9XG4gICAgICAgIGJpbmQ6cGxhY2Vob2xkZXJcbiAgICAgICAgYmluZDpmaWVsZG5hbWVcbiAgICAgICAgYmluZDpyZXF1aXJlZFxuICAgICAgICBiaW5kOm11bHRpcGxlXG4gICAgICAgIGJpbmQ6c2l6ZVxuICAgICAgICBiaW5kOnZhbGlkXG4gICAgICAgIG9uOnJlc29sdmU9eyhlKSA9PiBhZGRJdGVtKGUuZGV0YWlsKX1cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtuYXJyb3c9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHNpemVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleD0wXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBzaXplLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIG5hcnJvdyA9IGZhbHNlLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSBcIjBcIixcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICB7aWR9XG4gICAge3RpdGxlfVxuICAgIGNsYXNzPVwiY29sdW1uIHtjbGFzc2VzfSB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiXG4gICAgY2xhc3M6aXMtbmFycm93PXtuYXJyb3d9XG4gICAge29uY2xpY2t9XG4gICAge29ua2V5dXB9XG4gICAge3JvbGV9XG4gICAge3RhYkluZGV4fVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gXCIwXCIsXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAge2lkfVxuICAgIHt0aXRsZX1cbiAgICBjbGFzcz1cImNvbHVtbnMge2NsYXNzZXN9XCJcbiAgICB7b25jbGlja31cbiAgICB7b25rZXl1cH1cbiAgICB7cm9sZX1cbiAgICB7dGFiSW5kZXh9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZCA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdGFiSW5kZXg9MF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3aWRlc2NyZWVuPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Z1bGxoZD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXhEZXNrdG9wPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21heFdpZGVzY3JlZW49ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZmx1aWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwiXCIsXG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSBcIjBcIixcbiAgICAgICAgd2lkZXNjcmVlbiA9IGZhbHNlLFxuICAgICAgICBmdWxsaGQgPSBmYWxzZSxcbiAgICAgICAgbWF4RGVza3RvcCA9IGZhbHNlLFxuICAgICAgICBtYXhXaWRlc2NyZWVuID0gZmFsc2UsXG4gICAgICAgIGZsdWlkID0gZmFsc2UsXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAge2lkfVxuICAgIHt0aXRsZX1cbiAgICBjbGFzcz1cImNvbnRhaW5lciB7Y2xhc3Nlc31cIlxuICAgIGNsYXNzOmlzLXdpZGVzY3JlZW49e3dpZGVzY3JlZW59XG4gICAgY2xhc3M6aXMtZnVsbGhkPXtmdWxsaGR9XG4gICAgY2xhc3M6aXMtbWF4LWRlc2t0b3A9e21heERlc2t0b3B9XG4gICAgY2xhc3M6aXMtbWF4LXdpZGVzY3JlZW49e21heFdpZGVzY3JlZW59XG4gICAgY2xhc3M6aXMtZmx1aWQ9e2ZsdWlkfVxuICAgIHtvbmNsaWNrfVxuICAgIHtvbmtleXVwfVxuICAgIHtyb2xlfVxuICAgIHt0YWJJbmRleH1cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgaWQgPSBcIlwiLCBjbGFzczogY2xhc3NlcyA9IFwiXCIsIGNoaWxkcmVuIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48Zm9vdGVyIHtpZH0gY2xhc3M9XCJmb290ZXIge2NsYXNzZXN9IFwiPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZm9vdGVyPlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWQgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFiSW5kZXggPSAwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSBcIjBcIixcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uIHtpZH0gY2xhc3M9XCJzZWN0aW9uIHtjbGFzc2VzfVwiIHtvbmNsaWNrfSB7b25rZXl1cH0ge3JvbGV9IHt0YWJJbmRleH0+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9zZWN0aW9uPlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGFnXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHRhZyA9IFwiZGl2XCIsIGNoaWxkcmVuIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmVsZW1lbnQgdGhpcz17dGFnfT5cbiAgICB7I2lmIGNoaWxkcmVufXtAcmVuZGVyIGNoaWxkcmVuPy4oKX17OmVsc2V9PCEtLSBvcHRpb25hbCBmYWxsYmFjayAtLT57L2lmfVxuPC9zdmVsdGU6ZWxlbWVudD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKDApLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiMC4wXCIsXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIG1heCA9IDEwMCxcbiAgICAgICAgc3RlcCA9IDEsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwibnVtYmVyXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb25jaGFuZ2UpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLW51bWJlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAge21pbn1cbiAgICAgICAge21heH1cbiAgICAgICAge3N0ZXB9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIG9uY2hhbmdlPXtvbmlucHV0fVxuICAgICAgICB7b25pbnB1dH1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIGltcG9ydCB7IFVJQ29sdW1ucywgVUlDb2x1bW4gfSBmcm9tIFwiLi4vbGF5b3V0XCI7XG4gICAgaW1wb3J0IHsgVUlCdXR0b24gfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG4gICAgaW1wb3J0IFVJTnVtYmVyIGZyb20gXCIuL3VpLm51bWJlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUZXh0ZmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSVRpdGxlIH0gZnJvbSBcIi4uL3ZhcmlvdXNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZmllbGRuYW1lID0gXCJudW1iZXJzX2xpc3RcIixcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBsYWJlbCA9IFwibmFtZWQgbnVtYmVycyBsaXN0XCIsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gJGJpbmRhYmxlKFwibmV3IGl0ZW1cIiksXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgbGlzdCA9ICRkZXJpdmVkKFxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBuYW1lLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBuYW1lLFxuICAgICAgICAgICAgICAgIG51bWJlcjogdmFsdWVbbmFtZV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModmFsdWUsIGlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2lkXTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBvbmNoYW5nZSh7IHZhbHVlLCBmaWVsZDogZmllbGRuYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKCkge1xuICAgICAgICBjb25zdCBpZCA9IG5ld1ZhbC5pZC50cmltKCk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KG5ld1ZhbC5udW1iZXIpO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IFwiXCIgJiYgIWlzTmFOKG51bWJlcikgJiYgIW5vdENvbW1vbi5vYmpIYXModmFsdWUsIGlkKSkge1xuICAgICAgICAgICAgdmFsdWVbaWRdID0gbnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIG9uY2hhbmdlKHsgdmFsdWUsIGZpZWxkOiBmaWVsZG5hbWUgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3JlYXRlTmV3VmFsID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IFwiXCIsXG4gICAgICAgICAgICBudW1iZXI6IDAsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBuZXdWYWwgPSAkc3RhdGUoY3JlYXRlTmV3VmFsKCkpO1xuPC9zY3JpcHQ+XG5cbjxVSVRpdGxlIHRpdGxlPXtsYWJlbH0gc2l6ZT17NX0gLz5cbnsjZWFjaCBsaXN0IGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgIDxVSUNvbHVtbnM+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtNlwiPlxuICAgICAgICAgICAge2l0ZW0udGl0bGV9XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtNFwiPlxuICAgICAgICAgICAge2l0ZW0ubnVtYmVyfVxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICB7I2lmICFyZWFkb25seX1cbiAgICAgICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtMlwiPlxuICAgICAgICAgICAgICAgIDxVSUJ1dHRvbiBpY29uPXtcIm1pbnVzXCJ9IGFjdGlvbj17KCkgPT4gcmVtb3ZlKGl0ZW0uaWQpfSAvPlxuICAgICAgICAgICAgPC9VSUNvbHVtbj5cbiAgICAgICAgey9pZn1cbiAgICA8L1VJQ29sdW1ucz5cbnsvZWFjaH1cbnsjaWYgIXJlYWRvbmx5fVxuICAgIDxVSUNvbHVtbnM+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtNlwiPlxuICAgICAgICAgICAgPFVJVGV4dGZpZWxkIGJpbmQ6dmFsdWU9e25ld1ZhbC5pZH0gYmluZDpwbGFjZWhvbGRlciAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTRcIj5cbiAgICAgICAgICAgIDxVSU51bWJlciBiaW5kOnZhbHVlPXtuZXdWYWwubnVtYmVyfSAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTJcIj5cbiAgICAgICAgICAgIDxVSUJ1dHRvbiBpY29uPXtcInBsdXNcIn0gYWN0aW9uPXsoKSA9PiBhZGQoKX0gLz5cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICA8L1VJQ29sdW1ucz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpbnB1dFN0YXJ0ZWQgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInBhc3N3b3JkXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb25jaGFuZ2UpO1xuPC9zY3JpcHQ+XG5cbjxpbnB1dFxuICAgIGlkPVwiZm9ybS1maWVsZC1wYXNzd29yZC17ZmllbGRuYW1lfVwiXG4gICAgY2xhc3M9XCJpbnB1dCB7Y2xhc3Nlc31cIlxuICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgbmFtZT17ZmllbGRuYW1lfVxuICAgIGJpbmQ6dmFsdWVcbiAgICB7aW52YWxpZH1cbiAgICB7cmVxdWlyZWR9XG4gICAge3JlYWRvbmx5fVxuICAgIHtkaXNhYmxlZH1cbiAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgb25jaGFuZ2U9e29uaW5wdXR9XG4gICAge29uaW5wdXR9XG4gICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgey4uLm90aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vbGlzdC91aS5saXN0LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUltYWdlIGZyb20gXCIuLi9pbWFnZS91aS5pbWFnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcblxuICAgIC8vXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdmFyaWFudHNdIC0gW1xuYXJyYXkgb2YgZ3JvdXBzXG57XG5pZDpudW1iZXIsXG50aXRsZTpzdHJpbmd8b2JqZWN0LFxuaW1hZ2U6c3RyaW5nfG9iamVjdCxcbnZhcmlhbnRzID0gW1xuYXJyYXkgb2YgdmFsdWVzIHZhcmlhbnRzIGluIGdyb3VwXG57XG5pZDpudW1iZXIsXG50aXRsZTpzdHJpbmd8b2JqZWN0LFxuZGVzY3JpcHRpb246c3RyaW5nfG9iamVjdCxcbmltYWdlOnN0cmluZ3xvYmplY3QsXG52YWx1ZTpvYmplY3Rcbn1dXG59XG5dXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlIC0gbXVsdGlwbGUgJiYgbXVsdGlwbGUgaW4gZ3JvdXBcbntcbmFycmF5IG9mIGFycmF5cyBvZiBzZWxlY3RlZCB2YWx1ZXMgaW4gZ3JvdXBcbmlmIG5vIHNlbGVjdGlvbiBncm91cCBzaG91bGQgYmUgZW1wdHkgYXJyYXlcbltncm91cElkXTogWy4uLnZhcmlhbnRzSWRdXG59XG5tdWx0aXBsZSAmJiBvbmUgaW4gZ3JvdXBcbntcbltncm91cElkXTogdmFyaWFudElkXG59XG5vbmx5IG9uZSAobm90IG11bHRpcGxlICYmIG9uZSBpbiBncm91cClcbntcbmdyb3VwOiBncm91cElkXG52YWx1ZTogdmFyaWFudElkXG59XG4gICAgICogQHByb3BlcnR5IHthbnl9IHRpdGxlXG4gICAgICogQHByb3BlcnR5IHthbnl9IGltYWdlXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtidXR0b25Qcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaW1hZ2VDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3RDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtnZXRVSUl0ZW1dXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtnZXREZWZhdWx0SXRlbVN1YmxpbWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt1aU9uXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdWlPZmZdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZpZWxkbmFtZSA9IFwicmFkaW8tYnV0dG9uc1wiLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgaW1hZ2UsXG4gICAgICAgIGJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIHRpdGxlQ29tcG9uZW50ID0gVUlUaXRsZSxcbiAgICAgICAgdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNSB9LFxuICAgICAgICBpbWFnZUNvbXBvbmVudCA9IFVJSW1hZ2UsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7IGNvdmVyZWQ6IHRydWUgfSxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnQgPSBVSUJ1dHRvbnMsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdENvbXBvbmVudCA9IFVJTGlzdCxcbiAgICAgICAgbGlzdENvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGdldFVJSXRlbSA9ICh2YWx1ZUlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudHNCdXR0b25zLmZpbmQoKGJ0blZhbCkgPT4gYnRuVmFsLnZhbHVlID09PSB2YWx1ZUlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzWzBdLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1aU9uID0gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY29sb3IgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICAgIGl0ZW0ub3V0bGluZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdWlPZmYgPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5jb2xvciA9IGZhbHNlO1xuICAgICAgICAgICAgaXRlbS5vdXRsaW5lZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaW5pdFZhcmlhbnRzQnV0dG9uKCk7XG4gICAgICAgIHNlbGVjdERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIGxldCB2YXJpYW50c0J1dHRvbnMgPSBbXSxcbiAgICAgICAgbGlzdEl0ZW1zID0gJHN0YXRlKFtdKTtcblxuICAgIGZ1bmN0aW9uIGluaXRWYXJpYW50c0J1dHRvbigpIHtcbiAgICAgICAgdmFyaWFudHNCdXR0b25zID0gdmFyaWFudHMubWFwKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5idXR0b25Qcm9wcywgLi4udmFyaWFudCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdEl0ZW1zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7IHZhbHVlczogdmFyaWFudHNCdXR0b25zIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIC8vXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgbGV0IHVpID0ge1xuICAgICAgICAgICAgb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICAvL1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHVpLm9mZiA9IHZhbHVlO1xuICAgICAgICAgICAgdWkub24gPSBzZWxlY3RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgdXBkYXRlVUkodWkpO1xuICAgICAgICAvL1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVVJKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMub2ZmKSB7XG4gICAgICAgICAgICB1aU9mZihnZXRVSUl0ZW0oY2hhbmdlcy5vZmYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5vbikge1xuICAgICAgICAgICAgdWlPbihnZXRVSUl0ZW0oY2hhbmdlcy5vbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhbnRzQnV0dG9ucyA9IHZhcmlhbnRzQnV0dG9ucztcbiAgICAgICAgbGlzdEl0ZW1zID0gbGlzdEl0ZW1zO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHNlbGVjdERlZmF1bHQoKSB7XG4gICAgICAgIGlmICh2YXJpYW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVUkoeyBvbjogdmFsdWUgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZlZhbHVlID0gZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKGRlZlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9ICRkZXJpdmVkKGxpc3RDb21wb25lbnQpO1xuPC9zY3JpcHQ+XG5cbjxTdmVsdGVDb21wb25lbnRcbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIGJpbmQ6aXRlbXM9e2xpc3RJdGVtc31cbiAgICB7dGl0bGVDb21wb25lbnR9XG4gICAge3RpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAge2Rlc2NyaXB0aW9uQ29tcG9uZW50fVxuICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHM9e3tcbiAgICAgICAgLi4uZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyxcbiAgICAgICAgYWN0aW9uKGV2ZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9fVxuICAgIHtpbWFnZUNvbXBvbmVudH1cbiAgICB7aW1hZ2VDb21wb25lbnRQcm9wc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgxMCksXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIG1heCA9IDEwMCxcbiAgICAgICAgc3RlcCA9IDEsXG4gICAgICAgIHRpY2ttYXJrcyA9IGZhbHNlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwicmFuZ2VcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvbmNoYW5nZSk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IGJpZy1udW1iZXIgc2xpZGVyIGhhcy1vdXRwdXQgaXMtZnVsbHdpZHRoIGlzLXN1Y2Nlc3Mge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICB7bWlufVxuICAgICAgICB7bWF4fVxuICAgICAgICB7c3RlcH1cbiAgICAgICAgbGlzdD1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX0tdGlja21hcmtzXCJcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBvbmNoYW5nZT17b25pbnB1dH1cbiAgICAgICAge29uaW5wdXR9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbiAgICA8b3V0cHV0IGZvcj1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX1cIj57dmFsdWV9PC9vdXRwdXQ+XG4gICAgeyNpZiBBcnJheS5pc0FycmF5KHRpY2ttYXJrcykgJiYgdGlja21hcmtzLmxlbmd0aH1cbiAgICAgICAgPGRhdGFsaXN0IGlkPVwiZm9ybS1maWVsZC1yYW5nZS17ZmllbGRuYW1lfS10aWNrbWFya3NcIj5cbiAgICAgICAgICAgIHsjZWFjaCB0aWNrbWFya3MgYXMgdGlja21hcmt9XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17dGlja21hcmsudmFsdWV9IGxhYmVsPXt0aWNrbWFyay5sYWJlbH0+PC9vcHRpb24+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGF0YWxpc3Q+XG4gICAgey9pZn1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG4gICAgaW1wb3J0IFVJU2VsZWN0IGZyb20gXCIuL3VpLnNlbGVjdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcbiAgICBpbXBvcnQgeyBERUZBVUxUX1NUQVRVU19TVUNDRVNTIH0gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbnN0XCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnB1dFN0YXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2VtcHR5VmFsdWVUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW21vZGVsTmFtZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FjdGlvbk5hbWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25GaWx0ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25Tb3J0ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25QYWdlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvblNlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbklkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9uVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttdWx0aXBsZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Vycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtRXJyb3JzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zvcm1MZXZlbEVycm9yXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JldHVyblZhcmlhbnRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGVtcHR5VmFsdWVUaXRsZSA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic2VsZWN0RnJvbU1vZGVsXCIsXG4gICAgICAgIG1vZGVsTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbk5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25GaWx0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU29ydGVyID0ge30sXG4gICAgICAgIGFjdGlvblBhZ2VyID0ge30sXG4gICAgICAgIGFjdGlvblNlYXJjaCA9IHVuZGVmaW5lZCxcbiAgICAgICAgb3B0aW9uSWQgPSBcIjpfaWRcIixcbiAgICAgICAgb3B0aW9uVGl0bGUgPSBcIjp0aXRsZVwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgIHNpemUgPSA4LFxuICAgICAgICB2YWxpZCA9IHRydWUsXG5cbiAgICAgICAgcmV0dXJuVmFyaWFudCA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25lcnJvciA9ICgpID0+IHt9LFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBhcmd1bWVudHNTZXRQcm92aWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsTmFtZSAmJiBhY3Rpb25OYW1lICYmIGFjdGlvbkZpbHRlcjtcbiAgICB9XG5cbiAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgbGV0IHZhcmlhbnRzID0gJHN0YXRlKFtdKTtcbiAgICBsZXQgZGlzYWJsZWQgPSAkZGVyaXZlZCghbG9hZGVkKTtcblxuICAgIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYXJndW1lbnRzU2V0UHJvdmlkZWQoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm90QXBwID0gbm90Q29tbW9uLmdldEFwcCgpO1xuICAgICAgICAgICAgY29uc3QgTW9kZWwgPSBub3RBcHBcbiAgICAgICAgICAgICAgICAuZ2V0TW9kZWwobW9kZWxOYW1lKVxuICAgICAgICAgICAgICAgIC5zZXRGaWx0ZXIoYWN0aW9uRmlsdGVyKVxuICAgICAgICAgICAgICAgIC5zZXRTb3J0ZXIoYWN0aW9uU29ydGVyKVxuICAgICAgICAgICAgICAgIC5zZXRQYWdlcihhY3Rpb25QYWdlcilcbiAgICAgICAgICAgICAgICAuc2V0U2VhcmNoKGFjdGlvblNlYXJjaCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE1vZGVsW2AkYCArIGFjdGlvbk5hbWVdKCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBERUZBVUxUX1NUQVRVU19TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhcmlhbnRzID0gcmVzdWx0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vdFBhdGguZ2V0KG9wdGlvbklkLCBpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBub3RQYXRoLmdldChvcHRpb25UaXRsZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uZXJyb3IocmVzcG9uc2UuZXJyb3JzIHx8IHJlc3BvbnNlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmIChyZXR1cm5WYXJpYW50KSB7XG4gICAgICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFyaWFudHMuZmluZCgoaXRtKSA9PiBpdG0uaWQgPT09IGRhdGEudmFsdWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbmNoYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlTZWxlY3RcbiAgICB7dmFsdWV9XG4gICAgYmluZDp2YXJpYW50c1xuICAgIGNsYXNzPXtjbGFzc2VzfVxuICAgIHtwbGFjZWhvbGRlcn1cbiAgICB7ZW1wdHlWYWx1ZVRpdGxlfVxuICAgIHtmaWVsZG5hbWV9XG4gICAge3JlcXVpcmVkfVxuICAgIHtyZWFkb25seX1cbiAgICB7ZGlzYWJsZWR9XG4gICAge211bHRpcGxlfVxuICAgIHtzaXplfVxuICAgIHt2YWxpZH1cbiAgICBvbmNoYW5nZT17b25DaGFuZ2V9XG4gICAgey4uLm90aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXN3aXRjaFwiO1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4uL3ZhcmlvdXMvdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBsYWJlbCA9IFwiXCIsXG4gICAgICAgIGhpZGVMYWJlbCA9IGZhbHNlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwidGV4dGZpZWxkXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb25jaGFuZ2UpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPFVJQm9vbGVhbiBMQ19UUlVFPXtsYWJlbH0gTENfRkFMU0U9e2xhYmVsfSB7dmFsdWV9IC8+XG57OmVsc2V9XG4gICAgeyNpZiAhbGFiZWwgJiYgIWhpZGVMYWJlbH1cbiAgICAgICAgPFVJQm9vbGVhbiB2YWx1ZT17ZmFsc2V9IC8+XG4gICAgey9pZn1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwic3dpdGNoIHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDpjaGVja2VkPXt2YWx1ZX1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgb25ibHVyPXtvbmlucHV0fVxuICAgICAgICB7b25pbnB1dH1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG4gICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIiBmb3I9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfVwiPlxuICAgICAgICB7I2lmICFoaWRlTGFiZWx9XG4gICAgICAgICAgICB7I2lmIGxhYmVsfVxuICAgICAgICAgICAgICAgIHskTE9DQUxFW2xhYmVsXX1cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8VUlCb29sZWFuIHZhbHVlPXtmYWxzZX0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvaWZ9XG4gICAgPC9sYWJlbD5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxhYmVsIGZyb20gXCIuL3VpLmxhYmVsLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBcImJ1bG1hLXN3aXRjaFwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIGZpZWxkbmFtZSA9IFwidGV4dGZpZWxkXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiIGlzLXJvdW5kZWQgaXMtc3VjY2VzcyBcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBhZGRJZCh2YXJJZCkge1xuICAgICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKHZhcklkKSkge1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YXJJZCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtSWQodmFySWQpIHtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKHZhcklkKSkge1xuICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHZhbHVlLmluZGV4T2YodmFySWQpLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShldikge1xuICAgICAgICBjb25zdCB2YXJJZCA9IGV2LnRhcmdldC5pZC5zcGxpdChcIi12YXJpYW50LVwiKS5hdCgtMSk7XG4gICAgICAgIGV2LnRhcmdldC5jaGVja2VkID8gYWRkSWQodmFySWQpIDogcmVtSWQodmFySWQpO1xuICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgb25jaGFuZ2UoZGF0YSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIHsjaWYgdmFsdWV9XG4gICAgICAgIHt2YXJpYW50c1xuICAgICAgICAgICAgLmZpbHRlcigodmFyaWFudCkgPT4gdmFsdWUuaW5jbHVkZXModmFyaWFudC5pZCkpXG4gICAgICAgICAgICAubWFwKCh2YXJpYW50KSA9PiB2YXJpYW50LnRpdGxlKVxuICAgICAgICAgICAgLmpvaW4oXCIsIFwiKX1cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50ICh2YXJpYW50LmlkKX1cbiAgICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1saXN0LWl0ZW1cIj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzd2l0Y2gge2NsYXNzZXN9XCJcbiAgICAgICAgICAgICAgICBpZD1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZS5pbmNsdWRlcyh2YXJpYW50LmlkKX1cbiAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICAgICAgb25ibHVyPXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICBvbmlucHV0PXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxVSUxhYmVsXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgZm9yPVwiZm9ybS1maWVsZC1zd2l0Y2gte2ZpZWxkbmFtZX0tdmFyaWFudC17dmFyaWFudC5pZH1cIlxuICAgICAgICAgICAgICAgIGxhYmVsPXt2YXJpYW50LnRpdGxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgey9lYWNofVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCB7IFVJQ29sdW1uLCBVSUNvbHVtbnMgfSBmcm9tIFwiLi4vbGF5b3V0XCI7XG4gICAgaW1wb3J0IFVJU2VsZWN0T3B0aW9uIGZyb20gXCIuL3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9uIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY2xlYXJWYWx1ZUZyb21EZWFkVmFyaWFudHMoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZV0gLSBsaXN0IG9mIGl0ZW0gaWRzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YXJpYW50c11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV0gLSBleHBvcnQgbGV0IHJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2JlZm9yZUFkZF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2dldEl0ZW1JZF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2dldEl0ZW1UaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2dldEl0ZW1UeXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYnVpbGRJdGVtXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIExDX0FERCA9IFwibm90LW5vZGU6YWRkX2xhYmVsXCIsXG4gICAgICAgIExDX1NFTEVDVF9GUk9NX0xJU1QgPSBcIm5vdC1ub2RlOnNlbGVjdF9mcm9tX2xpc3RfbGFiZWxcIixcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJ0YWdcIixcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcblxuICAgICAgICBiZWZvcmVBZGQgPSAoLyp2YXJpYW50LCB2YXJpYW50cyovKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SXRlbUlkID0gKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50LmlkO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtVGl0bGUgPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnQudGl0bGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGdldEl0ZW1UeXBlID0gKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBcImluZm9cIjtcbiAgICAgICAgfSxcbiAgICAgICAgYnVpbGRJdGVtID0gKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGdldEl0ZW1JZCh2YXJpYW50KSxcbiAgICAgICAgICAgICAgICB0aXRsZTogZ2V0SXRlbVRpdGxlKHZhcmlhbnQpLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldEl0ZW1UeXBlKHZhcmlhbnQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gdmFyaWFudElkVG9WYXJpYW50KGlkKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiBnZXRJdGVtSWQodmFyaWFudCkgPT09IGlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGlkID0gZS5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaWQ7XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgICAgIHZhbHVlLnNwbGljZSh2YWx1ZS5pbmRleE9mKGlkKSwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBpZCA9IGUuY3VycmVudFRhcmdldC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3RcIikudmFsdWU7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB2YXJpYW50SWRUb1ZhcmlhbnQoaWQpO1xuICAgICAgICBpZiAoIXZhcmlhbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJlZm9yZUFkZCh2YXJpYW50LCB2YXJpYW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgJiYgdmFsdWUuaW5kZXhPZihpZCkgPT09IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGlkKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhclZhbHVlRnJvbURlYWRWYXJpYW50cygpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5maWx0ZXIoKGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudElkVG9WYXJpYW50KGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKlxuaXRlbSA9IHtcbiAgaWQsICAgICAgICAvL3VuaXF1ZVxuICB0aXRsZSwgICAgIC8vc29tZSB0ZXh0XG4gIHR5cGUgICAgICAgLy9mb3IgY29sb3JpbmcgaXRlbXMsIHVzdWFsIGh0bWwgdGVtcGxhdGUgbmFtZXMgZGFuZ2VyLCBzdWNjZXNzLCBldGNcbn1cbiovXG4gICAgbGV0IGl0ZW1zID0gJGRlcml2ZWQoXG4gICAgICAgIHZhbHVlXG4gICAgICAgICAgICAubWFwKHZhcmlhbnRJZFRvVmFyaWFudClcbiAgICAgICAgICAgIC5maWx0ZXIoKHZhcmlhbnQpID0+IHZhcmlhbnQpXG4gICAgICAgICAgICAubWFwKGJ1aWxkSXRlbSlcbiAgICApO1xuPC9zY3JpcHQ+XG5cbjxVSUNvbHVtbnMgY2xhc3M9e2NsYXNzZXN9PlxuICAgIDxVSUNvbHVtbj5cbiAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJteC0xIHRhZyBpcy17aXRlbS50eXBlfVwiXG4gICAgICAgICAgICAgICAgPnskTE9DQUxFW2l0ZW0udGl0bGVdfVxuICAgICAgICAgICAgICAgIHsjaWYgIXJlYWRvbmx5fVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiZGVsZXRlIGJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWlkPXtpdGVtLmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJkZWxldGUgaXMtc21hbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17cmVtb3ZlfVxuICAgICAgICAgICAgICAgICAgICA+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgey9lYWNofVxuICAgIDwvVUlDb2x1bW4+XG5cbiAgICB7I2lmICFyZWFkb25seX1cbiAgICAgICAgPFVJQ29sdW1uPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdCBpcy1zbWFsbFwiPlxuICAgICAgICAgICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9ey0xfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17TENfU0VMRUNUX0ZST01fTElTVH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgeyNlYWNoIHZhcmlhbnRzIGFzIHZhcmlhbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dmFyaWFudC5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17dmFyaWFudC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPFVJQnV0dG9uXG4gICAgICAgICAgICAgICAgY29sb3I9e1wicHJpbWFyeVwifVxuICAgICAgICAgICAgICAgIHNpemU9e1wic21hbGxcIn1cbiAgICAgICAgICAgICAgICBhY3Rpb249e2FkZH1cbiAgICAgICAgICAgICAgICB0aXRsZT17TENfQUREfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICB7L2lmfVxuPC9VSUNvbHVtbnM+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIis3ICg5ODcpIDY1NC0zMi0xMFwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRlbGVwaG9uZVwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG9uY2hhbmdlKTtcbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZX08L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC10ZWxlcGhvbmUte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJ0ZWxcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIG9uY2hhbmdlPXtvbmlucHV0fVxuICAgICAgICB7b25pbnB1dH1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQge0xPQ0FMRX0gZnJvbSAnLi4vLi4vLi4vbG9jYWxlJztcbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSAnLi4vLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGUnO1xuICAgIFxuICAgIGltcG9ydCB7Y3JlYXRlRXZlbnREaXNwYXRjaGVyfSBmcm9tICdzdmVsdGUnO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgIC8vIGV4cG9ydCBsZXQgc2tpcCA9IDA7XG4gICAgXG5cbiAgIC8qKlxuICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFnZV0gLSBleHBvcnQgbGV0IGNvdW50ID0gMDtcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFnZXNdXG4gICAgKiBAcHJvcGVydHkge2FueX0gW2J1dHRvbkNvbXBvbmVudF1cbiAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYnV0dG9uQ29tcG9uZW50UHJvcHNdXG4gICAgKi9cblxuICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgIGxldCB7XG4gICAgICAgcGFnZSA9IDAsXG4gICAgICAgcGFnZXMgPSAwLFxuICAgICAgIGJ1dHRvbkNvbXBvbmVudCA9IFVJQnV0dG9uLFxuICAgICAgIGJ1dHRvbkNvbXBvbmVudFByb3BzID0ge31cbiAgIH0gPSAkcHJvcHMoKTtcblxuPC9zY3JpcHQ+XG5cbnsjaWYgcGFnZXMgPiAwIH1cbjxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbHVtblwiPlxuICAgICAgICB7I2lmIHBhZ2UgPiAxIH1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBidXR0b25Db21wb25lbnR9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnQgICAgICAgICAgICBcbiAgICAgICAgICAgIHsuLi5idXR0b25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIGFjdGlvbj17KCkgPT4gZGlzcGF0Y2goJ3ByZXYnKX1cbiAgICAgICAgICAgID57JExPQ0FMRVsnbm90LW5vZGU6bGlzdF9uYXZpZ2F0aW9uX3ByZXZfYnV0dG9uX2xhYmVsJ119PC9TdmVsdGVDb21wb25lbnQ+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG4gICAgeyNpZiBwYWdlcyA+IDEgfVxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gYm94XCI+XG4gICAgICAgIHtwYWdlfSAvIHtwYWdlc31cbiAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cbiAgICAgICAgeyNpZiBwYWdlIDwgcGFnZXMgfVxuICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF8xID0gYnV0dG9uQ29tcG9uZW50fVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50XzEgICAgICAgICAgICBcbiAgICAgICAgICAgIHsuLi5idXR0b25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIGFjdGlvbj17KCkgPT4gZGlzcGF0Y2goJ25leHQnKX1cbiAgICAgICAgICAgID57JExPQ0FMRVsnbm90LW5vZGU6bGlzdF9uYXZpZ2F0aW9uX25leHRfYnV0dG9uX2xhYmVsJ119PC9TdmVsdGVDb21wb25lbnRfMT5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbjwvZGl2Plxuey9pZn1cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJ3N2ZWx0ZS9sZWdhY3knO1xuXG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBsZXQgeyB0aXRsZSwgaWQsIF9pZCB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgZGlzcGF0Y2goXCJjbGlja1wiLCB7XG4gICAgICAgICAgICBfaWQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIG9uY2xpY2s9e3ByZXZlbnREZWZhdWx0KGNsaWNrKX1cbiAgICBjbGFzcz1cImJveCBsaXN0LWl0ZW0tc2VsZWN0YWJsZVwiXG4gICAgb25rZXl1cD17Y2xpY2t9XG4gICAgcm9sZT1cImJ1dHRvblwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICA8c3Bhbj57dGl0bGV9PC9zcGFuPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAubGlzdC1pdGVtLXNlbGVjdGFibGUge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IDFlbTtcbiAgICB9XG5cbiAgICAubGlzdC1pdGVtLXNlbGVjdGFibGU6aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDhjNzhlO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJRW5kbGVzc0xpc3RTaW1wbGVJdGVtIGZyb20gXCIuL3VpLmVuZGxlc3MubGlzdC5zaW1wbGUuaXRlbS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlFbmRsZXNzTGlzdEVtcHR5UGxhY2Vob2xkZXIgZnJvbSBcIi4uL3VpLmxpc3QuZW1wdHkucGxhY2Vob2xkZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJRW5kbGVzc0xpc3ROYXZpZ2F0aW9uIGZyb20gXCIuL3VpLmVuZGxlc3MubGlzdC5uYXZpZ2F0aW9uLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2RhdGFdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtQ29tcG9uZW50XSAtIGxpc3QgZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbUNvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRdIC0gaWYgbGlzdCBpcyBlbXB0eVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3ROYXZpZ2F0aW9uQ29tcG9uZW50XSAtIHByZXYgYW5kIG5leHQgYmxvY2tcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3ROYXZpZ2F0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGRhdGEgPSAkYmluZGFibGUoe1xuICAgICAgICAgICAgbGlzdDogW10sXG4gICAgICAgICAgICBza2lwOiAwLFxuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICBwYWdlOiAwLFxuICAgICAgICAgICAgcGFnZXM6IDAsXG4gICAgICAgIH0pLFxuICAgICAgICBpdGVtQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdFNpbXBsZUl0ZW0sXG4gICAgICAgIGl0ZW1Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudCA9IFVJRW5kbGVzc0xpc3RFbXB0eVBsYWNlaG9sZGVyLFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdE5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgb25zZWxlY3QsXG4gICAgICAgIG9ucHJldixcbiAgICAgICAgb25uZXh0LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF8yID0gJGRlcml2ZWQobGlzdE5hdmlnYXRpb25Db21wb25lbnQpO1xuPC9zY3JpcHQ+XG5cbjxkaXY+XG4gICAgeyNpZiBkYXRhLmxpc3QubGVuZ3RofVxuICAgICAgICB7I2VhY2ggZGF0YS5saXN0IGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBpdGVtQ29tcG9uZW50fVxuICAgICAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uc2VsZWN0fVxuICAgICAgICAgICAgICAgIHsuLi5pdGVtQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLml0ZW19XG4gICAgICAgICAgICAvPlxuICAgICAgICB7L2VhY2h9XG4gICAgezplbHNlfVxuICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF8xID0gZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnR9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnRfMSB7Li4uZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wc30gLz5cbiAgICB7L2lmfVxuPC9kaXY+XG48U3ZlbHRlQ29tcG9uZW50XzJcbiAgICB7Li4ubGlzdE5hdmlnYXRpb25Db21wb25lbnRQcm9wc31cbiAgICBiaW5kOnBhZ2U9e2RhdGEucGFnZX1cbiAgICBiaW5kOnBhZ2VzPXtkYXRhLnBhZ2VzfVxuICAgIGJpbmQ6c2tpcD17ZGF0YS5za2lwfVxuICAgIGJpbmQ6Y291bnQ9e2RhdGEuY291bnR9XG4gICAge29ucHJldn1cbiAgICB7b25uZXh0fVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG4gICAgLy9cbiAgICBpbXBvcnQgVUlMaXN0IGZyb20gXCIuL3VpLmxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4uL2ltYWdlL3VpLmltYWdlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuXG5cbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcbiAgICBcblxuICAgIFxuXG5cbiAgICBcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211bHRpcGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0TGVhc3RPbmVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YXJpYW50c10gLSBhcnJheSBvZiB2YWx1ZXMgdmFyaWFudHMgaW4gZ3JvdXBcbltcbntcbmlkOm51bWJlcixcbnRpdGxlOnN0cmluZ3xvYmplY3QsXG5kZXNjcmlwdGlvbjpzdHJpbmd8b2JqZWN0LFxuaW1hZ2U6c3RyaW5nfG9iamVjdCxcbnZhbHVlOm9iamVjdFxufVxuXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZSAtIFsuLi5zZWxlY3RlZEl0ZW1zVmFsdWVzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VsZWN0ZWRWYXJpYW50c0lkc10gLSBbLi4uc2VsZWN0ZWRJdGVtc0lkc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaW1hZ2VDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3RDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzdWJsaW1lVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtnZXRJdGVtXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbVZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdWlPbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3VpT2ZmXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0XCIsXG4gICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlLFxuICAgICAgICB2YXJpYW50cyA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKCksXG4gICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSAkYmluZGFibGUoW10pLFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDUgfSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlLFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBzdWJsaW1lVmFsdWUgPSAodmFsdWUpID0+IHZhbHVlLmlkLFxuICAgICAgICBnZXRJdGVtID0gKHsgdmFsdWVJZCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudHMuZmluZCgoYnRuVmFsKSA9PiBidG5WYWwudmFsdWUuaWQgPT09IHZhbHVlSWQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtVmFsdWUgPSAoeyB2YWx1ZUlkIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRJdGVtKHsgdmFsdWVJZCB9KS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzWzBdLmlkO1xuICAgICAgICB9LFxuICAgICAgICB1aU9uID0gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY29sb3IgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICAgIGl0ZW0ub3V0bGluZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdWlPZmYgPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5jb2xvciA9IGZhbHNlO1xuICAgICAgICAgICAgaXRlbS5vdXRsaW5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoYXRMZWFzdE9uZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVpID0gdXBkYXRlU2VsZWN0ZWQoaXRlbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVUkodWkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdERlZmF1bHQoKTtcbiAgICB9KTtcbiAgICAvL1xuICAgIGZ1bmN0aW9uIGNvdW50T2ZTZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gc2VsZWN0ZWRWYXJpYW50c0lkcy5sZW5ndGggOiAwO1xuICAgIH1cblxuICAgIGNvbnN0IG5vdExhc3RPbmUgPSAoKSA9PiAhKGF0TGVhc3RPbmUgJiYgY291bnRPZlNlbGVjdGVkKCkgPT09IDEpO1xuICAgIC8vXG4gICAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWQoZGV0YWlsKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlSWQgPSBzdWJsaW1lVmFsdWUoZGV0YWlsKTtcbiAgICAgICAgbGV0IHVpID0ge1xuICAgICAgICAgICAgb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9mZjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICAvL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZWN0ZWRWYXJpYW50c0lkcykpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhcmlhbnRzSWRzLmluY2x1ZGVzKHZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdExhc3RPbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuaW5kZXhPZih2YWx1ZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdWkub2ZmID0geyB2YWx1ZUlkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzLnB1c2godmFsdWVJZCk7XG4gICAgICAgICAgICAgICAgdWkub24gPSB7IHZhbHVlSWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdExlYXN0T25lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFZhcmlhbnRzSWRzLmluY2x1ZGVzKHZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudE9mU2VsZWN0ZWQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLm9mZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkOiBzZWxlY3RlZFZhcmlhbnRzSWRzLnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1aS5vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSBbdmFsdWVJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRWYXJpYW50c0lkcy5pbmNsdWRlcyh2YWx1ZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5vZmYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhcmlhbnRzSWRzLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuaW5kZXhPZih2YWx1ZUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1aS5vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMucHVzaCh2YWx1ZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcyA9IHNlbGVjdGVkVmFyaWFudHNJZHM7XG4gICAgICAgIHJldHVybiB1aTtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB0b2dnbGUoZGV0YWlsKSB7XG4gICAgICAgIGxldCB1aSA9IHVwZGF0ZVNlbGVjdGVkKGRldGFpbCk7XG4gICAgICAgIHVwZGF0ZVVJKHVpKTtcbiAgICAgICAgLy9cbiAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgLy9cbiAgICAgICAgZGlzcGF0Y2goXCJjaGFuZ2VcIiwge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVVSShjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm9mZikge1xuICAgICAgICAgICAgdWlPZmYoZ2V0SXRlbShjaGFuZ2VzLm9mZikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLm9uKSB7XG4gICAgICAgICAgICB1aU9uKGdldEl0ZW0oY2hhbmdlcy5vbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhbnRzID0gdmFyaWFudHM7XG4gICAgfVxuICAgIC8vXG4gICAgZnVuY3Rpb24gdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIGxldCBuZXdWYWwgPSBbXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlbGVjdGVkVmFyaWFudHNJZHMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoc2VsZWN0ZWRWYXJpYW50c0lkcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBuZXdWYWwgPSBzZWxlY3RlZFZhcmlhbnRzSWRzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodmFsKSA9PiB0eXBlb2YgdmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbHVlSWQpID0+XG4gICAgICAgICAgICAgICAgICAgIGdldEl0ZW1WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBuZXdWYWw7XG4gICAgfVxuICAgIC8vXG4gICAgZnVuY3Rpb24gc2VsZWN0RGVmYXVsdCgpIHtcbiAgICAgICAgaWYgKGF0TGVhc3RPbmUgJiYgdmFyaWFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmVmFsdWVJZCA9IGdldERlZmF1bHRJdGVtU3VibGltZSgpO1xuICAgICAgICAgICAgdG9nZ2xlKHsgaWQ6IGRlZlZhbHVlSWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBTdmVsdGVDb21wb25lbnQgPSAkZGVyaXZlZChsaXN0Q29tcG9uZW50KTtcbjwvc2NyaXB0PlxuXG48U3ZlbHRlQ29tcG9uZW50XG4gICAgey4uLmxpc3RDb21wb25lbnRQcm9wc31cbiAgICBiaW5kOml0ZW1zPXt2YXJpYW50c31cbiAgICB7dGl0bGVDb21wb25lbnR9XG4gICAge3RpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAge2Rlc2NyaXB0aW9uQ29tcG9uZW50fVxuICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHM9e3tcbiAgICAgICAgLi4uZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyxcbiAgICAgICAgYWN0aW9uKGV2ZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9fVxuICAgIHtpbWFnZUNvbXBvbmVudH1cbiAgICB7aW1hZ2VDb21wb25lbnRQcm9wc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvL1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4vdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211bHRpcGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29ubHlPbmVJbkdyb3VwXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0TGVhc3RPbmVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YXJpYW50c10gLSBbXG5hcnJheSBvZiBncm91cHNcbntcbmlkOm51bWJlcixcbnRpdGxlOnN0cmluZ3xvYmplY3QsXG5pbWFnZTpzdHJpbmd8b2JqZWN0LFxudmFyaWFudHMgPSBbXG5hcnJheSBvZiB2YWx1ZXMgdmFyaWFudHMgaW4gZ3JvdXBcbntcbmlkOm51bWJlcixcbnRpdGxlOnN0cmluZ3xvYmplY3QsXG5kZXNjcmlwdGlvbjpzdHJpbmd8b2JqZWN0LFxuaW1hZ2U6c3RyaW5nfG9iamVjdCxcbnZhbHVlOm9iamVjdFxufV1cbn1cbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhcmlhbnRzU2VsZWN0ZWRdIC0gbXVsdGlwbGUgJiYgbXVsdGlwbGUgaW4gZ3JvdXBcbntcbmFycmF5IG9mIGFycmF5cyBvZiBzZWxlY3RlZCB2YWx1ZXMgaW4gZ3JvdXBcbmlmIG5vIHNlbGVjdGlvbiBncm91cCBzaG91bGQgYmUgZW1wdHkgYXJyYXlcbltncm91cElkXTogWy4uLnZhcmlhbnRzSWRdXG59XG5tdWx0aXBsZSAmJiBvbmUgaW4gZ3JvdXBcbntcbltncm91cElkXTogdmFyaWFudElkXG59XG5vbmx5IG9uZSAobm90IG11bHRpcGxlICYmIG9uZSBpbiBncm91cClcbntcbmdyb3VwOiBncm91cElkXG52YWx1ZTogdmFyaWFudElkXG59XG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlIC0ge1tncm91cElkXTogWy4uLnZhbHVlc09mU2VsZWN0ZWRJdGVtc119XG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0aXRsZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpbWFnZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtkZXNjcmlwdGlvbkNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdENvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc3VibGltZVZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2dldEl0ZW1WYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2dldERlZmF1bHRJdGVtU3VibGltZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3VpT25dXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt1aU9mZl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0LXRhZ3NcIixcbiAgICAgICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAgICAgb25seU9uZUluR3JvdXAgPSB0cnVlLFxuICAgICAgICBhdExlYXN0T25lID0gdHJ1ZSxcbiAgICAgICAgdmFyaWFudHMgPSAkYmluZGFibGUoW10pLFxuICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoKSxcbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCA9IFVJQnV0dG9ucyxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0Q29tcG9uZW50ID0gVUlMaXN0LFxuICAgICAgICBsaXN0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgc3VibGltZVZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHZhbHVlLmdyb3VwLFxuICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SXRlbSA9ICh7IGdyb3VwSWQsIHZhbHVlSWQgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzXG4gICAgICAgICAgICAgICAgLmZpbmQoKGdyb3VwKSA9PiBncm91cC5pZCA9PT0gZ3JvdXBJZClcbiAgICAgICAgICAgICAgICAuZGVzY3JpcHRpb24udmFsdWVzLmZpbmQoXG4gICAgICAgICAgICAgICAgICAgIChidG5WYWwpID0+IGJ0blZhbC52YWx1ZS5pZCA9PT0gdmFsdWVJZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEl0ZW1WYWx1ZSA9ICh7IGdyb3VwSWQsIHZhbHVlSWQgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldEl0ZW0oeyBncm91cElkLCB2YWx1ZUlkIH0pLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXREZWZhdWx0SXRlbVN1YmxpbWUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHZhcmlhbnRzWzBdLmlkLFxuICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHZhcmlhbnRzWzBdLmRlc2NyaXB0aW9uLnZhbHVlc1swXS52YWx1ZS5pZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHVpT24gPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5jb2xvciA9IFwic3VjY2Vzc1wiO1xuICAgICAgICAgICAgaXRlbS5vdXRsaW5lZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICB1aU9mZiA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLmNvbG9yID0gZmFsc2U7XG4gICAgICAgICAgICBpdGVtLm91dGxpbmVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlPbmVJbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsdWUgPSB2YWx1ZVt0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1aSA9IHVwZGF0ZVNlbGVjdGVkKGl0ZW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVVSSh1aSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbdF0uZm9yRWFjaCgoaXRlbVZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVpID0gdXBkYXRlU2VsZWN0ZWQoaXRlbVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVVSSh1aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHVpID0gdXBkYXRlU2VsZWN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVVJKHVpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vXG4gICAgZnVuY3Rpb24gY291bnRPZlNlbGVjdGVkKCkge1xuICAgICAgICBsZXQgYyA9IDA7XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhcmlhbnRzU2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlPbmVJbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ3JvdXBWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGdyb3VwVmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ3JvdXBWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjICs9IGdyb3VwVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YXJpYW50c1NlbGVjdGVkICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhcmlhbnRzU2VsZWN0ZWQudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFyaWFudHNTZWxlY3RlZC5ncm91cCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkKGRldGFpbCkge1xuICAgICAgICBjb25zdCB7IHZhbHVlSWQsIGdyb3VwSWQgfSA9IHN1YmxpbWVWYWx1ZShkZXRhaWwpO1xuICAgICAgICBsZXQgdWkgPSB7XG4gICAgICAgICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2ZmOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vXG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKG9ubHlPbmVJbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLm9mZiA9IHsgZ3JvdXBJZCwgdmFsdWVJZDogdmFyaWFudHNTZWxlY3RlZFtncm91cElkXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdID0gdmFsdWVJZDtcbiAgICAgICAgICAgICAgICB1aS5vbiA9IHsgZ3JvdXBJZCwgdmFsdWVJZCB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFyaWFudHNTZWxlY3RlZFtncm91cElkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudHNTZWxlY3RlZFtncm91cElkXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFyaWFudHNTZWxlY3RlZFtncm91cElkXS5pbmNsdWRlcyh2YWx1ZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRPZlNlbGVjdGVkKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdLmluZGV4T2YodmFsdWVJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLm9mZiA9IHsgZ3JvdXBJZCwgdmFsdWVJZCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudHNTZWxlY3RlZFtncm91cElkXS5wdXNoKHZhbHVlSWQpO1xuICAgICAgICAgICAgICAgICAgICB1aS5vbiA9IHsgZ3JvdXBJZCwgdmFsdWVJZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdID0gdmFyaWFudHNTZWxlY3RlZFtncm91cElkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcmlhbnRzU2VsZWN0ZWQgPSB2YXJpYW50c1NlbGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzU2VsZWN0ZWQgJiZcbiAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkLmdyb3VwSWQgPT09IGdyb3VwSWQgJiZcbiAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkLnZhbHVlSWQgPT09IHZhbHVlSWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmICghYXRMZWFzdE9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB1aS5vZmYgPSB7IGdyb3VwSWQsIHZhbHVlSWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYW50c1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFyaWFudHNTZWxlY3RlZC5ncm91cElkICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aS5vZmYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogdmFyaWFudHNTZWxlY3RlZC5ncm91cElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHZhcmlhbnRzU2VsZWN0ZWQudmFsdWVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdWkub24gPSB7IGdyb3VwSWQsIHZhbHVlSWQgfTtcbiAgICAgICAgICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0geyBncm91cElkLCB2YWx1ZUlkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZShkZXRhaWwpIHtcbiAgICAgICAgbGV0IHVpID0gdXBkYXRlU2VsZWN0ZWQoZGV0YWlsKTtcbiAgICAgICAgdXBkYXRlVUkodWkpO1xuICAgICAgICAvL1xuICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAvL1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVVJKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMub2ZmKSB7XG4gICAgICAgICAgICB1aU9mZihnZXRJdGVtKGNoYW5nZXMub2ZmKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMub24pIHtcbiAgICAgICAgICAgIHVpT24oZ2V0SXRlbShjaGFuZ2VzLm9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFudHMgPSB2YXJpYW50cztcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgbmV3VmFsID0ge307XG4gICAgICAgICAgICBpZiAob25seU9uZUluR3JvdXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cElkIGluIHZhcmlhbnRzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWxbZ3JvdXBJZF0gPSBnZXRJdGVtVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZDogdmFyaWFudHNTZWxlY3RlZFtncm91cElkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cElkIGluIHZhcmlhbnRzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhcmlhbnRzU2VsZWN0ZWRbZ3JvdXBJZF0gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFyaWFudHNTZWxlY3RlZFtncm91cElkXSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWxbZ3JvdXBJZF0gPSB2YXJpYW50c1NlbGVjdGVkW2dyb3VwSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsKSA9PiB0eXBlb2YgdmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW1WYWx1ZUlkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJdGVtVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IGl0ZW1WYWx1ZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdWYWwpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhcmlhbnRzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldEl0ZW1WYWx1ZSh2YXJpYW50c1NlbGVjdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiBzZWxlY3REZWZhdWx0KCkge1xuICAgICAgICBpZiAoYXRMZWFzdE9uZSAmJiB2YXJpYW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZWYWx1ZSA9IGdldERlZmF1bHRJdGVtU3VibGltZSgpO1xuICAgICAgICAgICAgdG9nZ2xlKHsgaWQ6IGRlZlZhbHVlLnZhbHVlSWQsIGdyb3VwOiBkZWZWYWx1ZS5ncm91cElkIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gJGRlcml2ZWQobGlzdENvbXBvbmVudCk7XG48L3NjcmlwdD5cblxuPFN2ZWx0ZUNvbXBvbmVudFxuICAgIHsuLi5saXN0Q29tcG9uZW50UHJvcHN9XG4gICAgYmluZDppdGVtcz17dmFyaWFudHN9XG4gICAge3RpdGxlQ29tcG9uZW50fVxuICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzPXt7XG4gICAgICAgIC4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMsXG4gICAgICAgIGFjdGlvbihldmVudCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRvZ2dsZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfX1cbiAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLy9cbiAgICBpbXBvcnQgVUlMaXN0IGZyb20gXCIuL3VpLmxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4uL2ltYWdlL3VpLmltYWdlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnNTd2l0Y2hlcnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN3aXRjaGVycy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YXJpYW50c10gLSBbXG5hcnJheSBvZiBncm91cHNcbntcbmlkOm51bWJlcixcbnRpdGxlOnN0cmluZ3xvYmplY3QsXG5pbWFnZTpzdHJpbmd8b2JqZWN0LFxudmFyaWFudHMgPSBbXG5hcnJheSBvZiB2YWx1ZXMgdmFyaWFudHMgaW4gZ3JvdXBcbntcbmlkOm51bWJlcixcbnRpdGxlOnN0cmluZ3xvYmplY3QsXG5kZXNjcmlwdGlvbjpzdHJpbmd8b2JqZWN0LFxuaW1hZ2U6c3RyaW5nfG9iamVjdCxcbnZhbHVlOm9iamVjdFxufV1cbn1cbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhcmlhbnRzU2VsZWN0ZWRdIC0gbXVsdGlwbGUgJiYgbXVsdGlwbGUgaW4gZ3JvdXBcbntcbmFycmF5IG9mIGFycmF5cyBvZiBzZWxlY3RlZCB2YWx1ZXMgaW4gZ3JvdXBcbmlmIG5vIHNlbGVjdGlvbiBncm91cCBzaG91bGQgYmUgZW1wdHkgYXJyYXlcbltncm91cElkXTogWy4uLnZhcmlhbnRzSWRdXG59XG5tdWx0aXBsZSAmJiBvbmUgaW4gZ3JvdXBcbntcbltncm91cElkXTogdmFyaWFudElkXG59XG5vbmx5IG9uZSAobm90IG11bHRpcGxlICYmIG9uZSBpbiBncm91cClcbntcbmdyb3VwOiBncm91cElkXG52YWx1ZTogdmFyaWFudElkXG59XG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlIC0ge1tncm91cElkXTogWy4uLnZhbHVlc09mU2VsZWN0ZWRJdGVtc119XG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0aXRsZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpbWFnZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtkZXNjcmlwdGlvbkNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdENvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uc0xpc3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzdWJsaW1lVmFsdWVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJsaXN0LXNlbGVjdC10YWdzXCIsXG4gICAgICAgIHZhcmlhbnRzID0gJGJpbmRhYmxlKFtdKSxcblxuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDUgfSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlLFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zU3dpdGNoZXJzLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBhY3Rpb25zTGlzdCA9IFtcInNlbGVjdEFsbFwiLCBcImRlc2VsZWN0QWxsXCJdLFxuICAgICAgICBzdWJsaW1lVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogdmFsdWUuZ3JvdXAsXG4gICAgICAgICAgICAgICAgdmFsdWVJZDogdmFsdWUuaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcbiAgICAvL1xuXG4gICAgY29uc3QgQVZBSUxBQkxFX0FDVElPTlMgPSB7XG4gICAgICAgIHNlbGVjdEFsbDoge1xuICAgICAgICAgICAgdGl0bGU6IFwi0JLRi9Cx0YDQsNGC0Ywg0LLRgdC1XCIsXG4gICAgICAgICAgICBjb2xvcjogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkZXNlbGVjdEFsbDoge1xuICAgICAgICAgICAgdGl0bGU6IFwi0KHQvdGP0YLRjCDQstGL0LTQtdC70LXQvdC40LUg0YHQviDQstGB0LXRhVwiLFxuICAgICAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVzZWxlY3RBbGwoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGxldCBBQ1RJT05TID0gJHN0YXRlKFtdKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBhY3Rpb25zTGlzdC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKEFWQUlMQUJMRV9BQ1RJT05TLCBuYW1lKVxuICAgICAgICAgICAgICAgID8gQUNUSU9OUy5wdXNoKEFWQUlMQUJMRV9BQ1RJT05TW25hbWVdKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBBQ1RJT05TID0gQUNUSU9OUztcbiAgICB9KTtcblxuICAgIGV4cG9ydCBjb25zdCBzZWxlY3RBbGwgPSAoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9mQWxsKHRydWUpO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3QgZGVzZWxlY3RBbGwgPSAoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9mQWxsKGZhbHNlKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHNlbGVjdEdyb3VwID0gKGdyb3VwSWQpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0aW9uT2ZHcm91cChncm91cElkLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IGRlc2VsZWN0R3JvdXAgPSAoZ3JvdXBJZCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3Rpb25PZkdyb3VwKGdyb3VwSWQsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHNldFNlbGVjdGlvbk9mR3JvdXAgPSAoZ3JvdXBJZCwgc2VsZWN0aW9uKSA9PiB7XG4gICAgICAgIHZhcmlhbnRzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBJZCA9PT0gZ3JvdXAuaWQpIHtcbiAgICAgICAgICAgICAgICBncm91cC5kZXNjcmlwdGlvbi52YWx1ZXMuZm9yRWFjaCgoaXRtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0bS5zZWxlY3RlZCA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhcmlhbnRzID0gdmFyaWFudHM7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHNldFNlbGVjdGlvbk9mQWxsID0gKHNlbGVjdGlvbikgPT4ge1xuICAgICAgICB2YXJpYW50cy5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgICAgICAgICAgZ3JvdXAuZGVzY3JpcHRpb24udmFsdWVzLmZvckVhY2goKGl0bSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0bS5zZWxlY3RlZCA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyaWFudHMgPSB2YXJpYW50cztcbiAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRJdGVtcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICB2YXJpYW50cy5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHJlc3VsdCwgZ3JvdXAuaWQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2dyb3VwLmlkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXAuZGVzY3JpcHRpb24udmFsdWVzLmZvckVhY2goKGl0bSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdG0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2dyb3VwLmlkXS5wdXNoKHN1YmxpbWVWYWx1ZShpdG0udmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRTZWxlY3RlZEl0ZW1zKCk7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBTdmVsdGVDb21wb25lbnQgPSAkZGVyaXZlZChsaXN0Q29tcG9uZW50KTtcbjwvc2NyaXB0PlxuXG48VUlCdXR0b25zIHZhbHVlcz17QUNUSU9OU30gY2VudGVyZWQ9e3RydWV9IC8+XG5cbjxTdmVsdGVDb21wb25lbnRcbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIGJpbmQ6aXRlbXM9e3ZhcmlhbnRzfVxuICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcz17e1xuICAgICAgICBhY3Rpb24oZXZlbnQsIHZhbHVlLCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCh0cmlnZ2VyQ2hhbmdlLCAwKTtcbiAgICAgICAgICAgIHJldHVybiAhc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMsXG4gICAgfX1cbiAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBmYWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gICAgaW1wb3J0IHsgb25Nb3VudCwgb25EZXN0cm95IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgVUlCdXR0b25DbG9zZSB9IGZyb20gXCIuLi9idXR0b25cIjtcblxuICAgIGxldCBvdmVyZmxvd1NhdmUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBkZWZhdWx0Q2xvc2VCdXR0b25Qcm9wcyA9IHtcbiAgICAgICAgY2xhc3M6IFwiaXMtYWJzb2x1dGUgaXMtc2lkZWQtcmlnaHQgaXMtc2lkZWQtdG9wXCIsXG4gICAgICAgIHN0eWxlOiBcIi0tc2lkaW5nLXJpZ2h0LXNpemU6IDJyZW07IC0tc2lkaW5nLXRvcC1zaXplOiAycmVtXCIsXG4gICAgICAgIHNpemU6IFwibm9ybWFsXCIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2Nsb3NlQnV0dG9uID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2Nsb3NlQnV0dG9uUHJvcHMgPSBkZWZhdWx0Q2xvc2VCdXR0b25Qcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbc2hvdyA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2Nsb3NlT25DbGljayA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW2xheWVyID0gMV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt6SW5kZXhTdGVwID0gMTAwMF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZSA9ICdidXR0b24nXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0YWJJbmRleCA9ICdidXR0b24nXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGNsb3NlQnV0dG9uID0gZmFsc2UsXG4gICAgICAgIGNsb3NlQnV0dG9uUHJvcHMgPSBkZWZhdWx0Q2xvc2VCdXR0b25Qcm9wcyxcbiAgICAgICAgc2hvdyA9IHRydWUsXG4gICAgICAgIGNsb3NlT25DbGljayA9IHRydWUsXG4gICAgICAgIGxheWVyID0gMSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgb25yZWplY3QgPSAoKSA9PiBmYWxzZSxcbiAgICAgICAgekluZGV4U3RlcCA9IDEwMDAsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IFwiMFwiLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG92ZXJsYXlDbGljayhlKSB7XG4gICAgICAgIGlmIChjbG9zZU9uQ2xpY2spIHtcbiAgICAgICAgICAgIGNsb3NlT3ZlcmxheShlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlQnV0dG9uQ2xpY2soKSB7XG4gICAgICAgIHJlamVjdE92ZXJsYXkoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZU92ZXJsYXkoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGUgJiYgZS5vcmlnaW5hbFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUub3JpZ2luYWxUYXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1vdmVybGF5XCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdE92ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0T3ZlcmxheShkYXRhID0ge30pIHtcbiAgICAgICAgc2hvdyA9IGZhbHNlO1xuICAgICAgICBvbnJlamVjdChkYXRhKTtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgb3ZlcmZsb3dTYXZlID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93U2F2ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93U2F2ZTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG57I2lmIHNob3d9XG4gICAgPGRpdlxuICAgICAgICB0cmFuc2l0aW9uOmZhZGVcbiAgICAgICAgY2xhc3M9XCJpcy1vdmVybGF5IG5vdC1vdmVybGF5IHtjbGFzc2VzfVwiXG4gICAgICAgIG9uY2xpY2s9e292ZXJsYXlDbGlja31cbiAgICAgICAgb25rZXl1cD17b3ZlcmxheUNsaWNrfVxuICAgICAgICB7cm9sZX1cbiAgICAgICAge3RhYkluZGV4fVxuICAgICAgICBzdHlsZT1cInotaW5kZXg6IHt6SW5kZXhTdGVwICogbGF5ZXJ9O1wiXG4gICAgPlxuICAgICAgICB7I2lmIGNsb3NlQnV0dG9ufVxuICAgICAgICAgICAgPFVJQnV0dG9uQ2xvc2Ugey4uLmNsb3NlQnV0dG9uUHJvcHN9IG9uY2xpY2s9e2Nsb3NlQnV0dG9uQ2xpY2t9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIGltcG9ydCBVSU92ZXJsYXkgZnJvbSBcIi4vdWkub3ZlcmxheS5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSUJveCBmcm9tIFwiLi4vYmxvY2svdWkuYm94LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbnRlbnQgZnJvbSBcIi4uL2Jsb2NrL3VpLmNvbnRlbnQuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zUm93IGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5yb3cuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYnV0dG9uc1Bvc2l0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nsb3NlQnV0dG9uXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FwcGx5QnV0dG9uXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGl0bGVTaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3ddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VidGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc2VzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3ZlcmxheUNsYXNzZXNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtidXR0b25zQ2xhc3Nlc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW1dBSVRJTkdfVEVYVF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBidXR0b25zUG9zaXRpb24gPSBcImJvdHRvbVwiLFxuICAgICAgICBjbG9zZUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICBhcHBseUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICB0aXRsZVNpemUgPSAyLFxuICAgICAgICBzaG93ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgdGl0bGUgPSBcIk1vZGFsIHdpbmRvd1wiLFxuICAgICAgICBzdWJ0aXRsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvdmVybGF5Q2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGJ1dHRvbnNDbGFzc2VzID0gXCJcIixcbiAgICAgICAgV0FJVElOR19URVhUID0gXCLQntCx0YDQsNCx0L7RgtC60LBcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxVSU92ZXJsYXlcbiAgICB7c2hvd31cbiAgICBjbG9zZU9uQ2xpY2s9e2ZhbHNlfVxuICAgIGNsb3NlQnV0dG9uPXtmYWxzZX1cbiAgICBjbGFzc2VzPXtvdmVybGF5Q2xhc3Nlc31cbj5cbiAgICA8VUlCb3gge2NsYXNzZXN9PlxuICAgICAgICA8VUlUaXRsZVxuICAgICAgICAgICAgc2l6ZT17dGl0bGVTaXplfVxuICAgICAgICAgICAgdGl0bGU9eyRMT0NBTEVbdGl0bGVdfVxuICAgICAgICAgICAgc3VidGl0bGU9eyRMT0NBTEVbc3VidGl0bGVdfVxuICAgICAgICAvPlxuICAgICAgICA8VUlDb250ZW50PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2Vsb2FkZXIge2xvYWRpbmcgPyAnaXMtYWN0aXZlJyA6ICcnfVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj57JExPQ0FMRVtXQUlUSU5HX1RFWFRdfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICB7I2lmIGJ1dHRvbnNQb3NpdGlvbiA9PT0gXCJ0b3BcIn1cbiAgICAgICAgICAgICAgICA8VUlCdXR0b25zUm93XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM9e2J1dHRvbnNDbGFzc2VzfVxuICAgICAgICAgICAgICAgICAgICBsZWZ0PXtjbG9zZUJ1dHRvbiA/IFtjbG9zZUJ1dHRvbl0gOiBbXX1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ9e2FwcGx5QnV0dG9uID8gW2FwcGx5QnV0dG9uXSA6IFtdfVxuICAgICAgICAgICAgICAgID48L1VJQnV0dG9uc1Jvdz5cbiAgICAgICAgICAgIHsvaWZ9XG5cbiAgICAgICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cblxuICAgICAgICAgICAgeyNpZiBidXR0b25zUG9zaXRpb24gPT09IFwiYm90dG9tXCJ9XG4gICAgICAgICAgICAgICAgPFVJQnV0dG9uc1Jvd1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzPXtidXR0b25zQ2xhc3NlcyB8fCBcImlzLWZvb3RlciBpcy1tb2JpbGVcIn1cbiAgICAgICAgICAgICAgICAgICAgbGVmdD17Y2xvc2VCdXR0b24gPyBbY2xvc2VCdXR0b25dIDogW119XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0PXthcHBseUJ1dHRvbiA/IFthcHBseUJ1dHRvbl0gOiBbXX1cbiAgICAgICAgICAgICAgICA+PC9VSUJ1dHRvbnNSb3c+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L1VJQ29udGVudD5cbiAgICA8L1VJQm94PlxuPC9VSU92ZXJsYXk+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlPdmVybGF5IGZyb20gXCIuL3VpLm92ZXJsYXkuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUVuZGxlc3NMaXN0IH0gZnJvbSBcIi4uL2xpc3QvZW5kbGVzc1wiO1xuICAgIGltcG9ydCBVSVNpbXBsZVNlYXJjaElucHV0IGZyb20gXCIuLi92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3ddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXJtXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2lucHV0Q29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaW5wdXRDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW291dHB1dENvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW291dHB1dENvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbcmVzdWx0c11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgc2hvdyA9IHRydWUsXG4gICAgICAgIHRlcm0gPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHNpemUgPSBcIm5hcnJvd1wiLFxuICAgICAgICBpbnB1dENvbXBvbmVudCA9IFVJU2ltcGxlU2VhcmNoSW5wdXQsXG4gICAgICAgIGlucHV0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgb3V0cHV0Q29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdCxcbiAgICAgICAgb3V0cHV0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgcmVzdWx0cyA9ICRiaW5kYWJsZSh7IGxpc3Q6IFtdLCBwYWdlOiAwLCBwYWdlczogMCwgc2tpcDogMCwgY291bnQ6IDAgfSksXG4gICAgICAgIG9udGVybUNoYW5nZSxcbiAgICAgICAgb25wcmV2LFxuICAgICAgICBvbm5leHQsXG4gICAgICAgIG9ucmVzb2x2ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogJExPQ0FMRVtcIm5vdC1ub2RlOmJ1dHRvbl9jYW5jZWxfbGFiZWxcIl0sXG4gICAgICAgICAgICBhY3Rpb246ICgpID0+IG9ucmVqZWN0KCksXG4gICAgICAgIH0sXG4gICAgXTtcbjwvc2NyaXB0PlxuXG48VUlPdmVybGF5XG4gICAgb25yZWplY3Q9e292ZXJsYXlDbG9zZWR9XG4gICAge3Nob3d9XG4gICAgY2xvc2VPbkNsaWNrPXt0cnVlfVxuICAgIGNsb3NlQnV0dG9uPXtmYWxzZX1cbj5cbiAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IGlucHV0Q29tcG9uZW50fVxuICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50XzEgPSBvdXRwdXRDb21wb25lbnR9XG4gICAgPGRpdiBjbGFzcz1cInBhcGVyIGJveCBibG9jayB7c2l6ZX1cIj5cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudCB7b250ZXJtQ2hhbmdlfSBiaW5kOnRlcm0gey4uLmlucHV0Q29tcG9uZW50UHJvcHN9XG4gICAgICAgID48L1N2ZWx0ZUNvbXBvbmVudD5cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudF8xXG4gICAgICAgICAgICBiaW5kOmRhdGE9e3Jlc3VsdHN9XG4gICAgICAgICAgICB7b25wcmV2fVxuICAgICAgICAgICAge29ubmV4dH1cbiAgICAgICAgICAgIHtvbnJlc29sdmV9XG4gICAgICAgICAgICB7Li4ub3V0cHV0Q29tcG9uZW50UHJvcHN9XG4gICAgICAgID48L1N2ZWx0ZUNvbXBvbmVudF8xPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17YnV0dG9uc30gY2VudGVyZWQ9e3RydWV9IGNsYXNzZXM9XCJtdC01XCIgLz5cbiAgICA8L2Rpdj5cbjwvVUlPdmVybGF5PlxuXG48c3R5bGU+XG4gICAgLnBhcGVyLmJveCB7XG4gICAgICAgIG1hcmdpbjogMTB2aCBhdXRvIGF1dG8gYXV0bztcbiAgICB9XG5cbiAgICAucGFwZXIuYm94LmZ1bGxzY3JlZW4ge1xuICAgICAgICB3aWR0aDogMTAwdnc7XG4gICAgfVxuXG4gICAgLnBhcGVyLmJveC53aWRlIHtcbiAgICAgICAgd2lkdGg6IDc1dnc7XG4gICAgfVxuXG4gICAgLnBhcGVyLmJveC5ub3JtYWwge1xuICAgICAgICB3aWR0aDogNTB2dztcbiAgICB9XG5cbiAgICAucGFwZXIuYm94Lm5hcnJvdyB7XG4gICAgICAgIHdpZHRoOiAyNXZ3O1xuICAgIH1cblxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xuICAgICAgICAucGFwZXIuYm94IHtcbiAgICAgICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgICAgICBtYXJnaW46IDB2aCBhdXRvIGF1dG8gYXV0bztcbiAgICAgICAgfVxuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICB0aXRsZVNuaXAsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VTbmlwLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNvbG9yLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48YXJ0aWNsZSBjbGFzcz1cIm1lc3NhZ2Uge2NsYXNzZXN9IHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ31cIj5cbiAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1oZWFkZXJcIj5cbiAgICAgICAgeyNpZiB0aXRsZVNuaXB9XG4gICAgICAgICAgICB7QHJlbmRlciB0aXRsZVNuaXAodGl0bGUpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8cD57JExPQ0FMRVt0aXRsZV19PC9wPlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLWJvZHlcIj5cbiAgICAgICAgeyNpZiBtZXNzYWdlU25pcH1cbiAgICAgICAgICAgIHtAcmVuZGVyIG1lc3NhZ2VTbmlwKG1lc3NhZ2UpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8cD57JExPQ0FMRVttZXNzYWdlXX08L3A+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG48L2FydGljbGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU1lc3NhZ2UgZnJvbSBcIi4vdWkubWVzc2FnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBVSUNvbW1vbi5DTEFTU19FUlIsIC4uLnByb3BzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlNZXNzYWdlIHsuLi5wcm9wc30gY2xhc3M9e2NsYXNzZXN9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU1lc3NhZ2UgZnJvbSBcIi4vdWkubWVzc2FnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBVSUNvbW1vbi5DTEFTU19PSywgLi4ucHJvcHMgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxVSU1lc3NhZ2Ugey4uLnByb3BzfSBjbGFzcz17Y2xhc3Nlc30gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttZXNzYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWdyZWVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHNob3cgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBtZXNzYWdlID0gXCLQlNC70Y8g0YPQu9GD0YfRiNC10L3QuNGPINGA0LDQsdC+0YLRiyDRgdCw0LnRgtCwINC4INC10LPQviDQstC30LDQuNC80L7QtNC10LnRgdGC0LLQuNGPINGBINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C80Lgg0LzRiyDQuNGB0L/QvtC70YzQt9GD0LXQvCDRhNCw0LnQu9GLIGNvb2tpZS4g0J/RgNC+0LTQvtC70LbQsNGPINGA0LDQsdC+0YLRgyDRgSDRgdCw0LnRgtC+0LwsINCS0Ysg0YDQsNC30YDQtdGI0LDQtdGC0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LUgY29va2llLdGE0LDQudC70L7Qsi4g0JLRiyDQstGB0LXQs9C00LAg0LzQvtC20LXRgtC1INC+0YLQutC70Y7Rh9C40YLRjCDRhNCw0LnQu9GLIGNvb2tpZSDQsiDQvdCw0YHRgtGA0L7QudC60LDRhSDQktCw0YjQtdCz0L4g0LHRgNCw0YPQt9C10YDQsC5cIixcbiAgICAgICAgYWdyZWUgPSBcItCl0L7RgNC+0YjQvlwiLFxuICAgICAgICBjb29sZG93biA9IDMxNTM2MDAwMDAwLFxuICAgICAgICBsc0tleSA9IFwiY29va2llX2RhdGVcIixcbiAgICAgICAgaWQgPSBcImNvb2tpZV9ub3RpZmljYXRpb25cIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgbGV0IGNvb2tpZURhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsc0tleSk7XG4gICAgICAgIGlmICghY29va2llRGF0ZSB8fCArY29va2llRGF0ZSArIGNvb2xkb3duIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFjY2VwdCgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obHNLZXksIERhdGUubm93KCkpO1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgc2hvd31cbiAgICA8ZGl2IHtpZH0+XG4gICAgICAgIDxwPnskTE9DQUxFW21lc3NhZ2VdfTwvcD5cbiAgICAgICAgPFVJQnV0dG9uIG9uY2xpY2s9e2FjY2VwdH0gY29sb3I9XCJzdWNjZXNzXCIgY2xhc3M9XCJjb29raWVfYWNjZXB0XCJcbiAgICAgICAgICAgID57JExPQ0FMRVthZ3JlZV19PC9VSUJ1dHRvblxuICAgICAgICA+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiLy9ibG9jayBlbGVtZW50c1xuaW1wb3J0ICogYXMgQmxvY2tzIGZyb20gXCIuL2Jsb2NrXCI7XG5leHBvcnQgeyBCbG9ja3MgfTtcblxuLy9nZW5lcmFsIGVsZW1lbnRzXG5pbXBvcnQgKiBhcyBWYXJpb3VzIGZyb20gXCIuL3ZhcmlvdXNcIjtcbmV4cG9ydCB7IFZhcmlvdXMgfTtcblxuLy9cbmltcG9ydCAqIGFzIEJ1dHRvbnMgZnJvbSBcIi4vYnV0dG9uXCI7XG5leHBvcnQgeyBCdXR0b25zIH07XG5cbi8vZm9ybSBlbGVtZW50c1xuaW1wb3J0ICogYXMgRm9ybXMgZnJvbSBcIi4vZm9ybVwiO1xuZXhwb3J0IHsgRm9ybXMgfTtcblxuLy9pY29ucyB2YXJpYW50c1xuaW1wb3J0ICogYXMgSWNvbnMgZnJvbSBcIi4vaWNvblwiO1xuZXhwb3J0IHsgSWNvbnMgfTtcblxuLy9pbWFnZXMgdWlcbmltcG9ydCAqIGFzIEltYWdlcyBmcm9tIFwiLi9pbWFnZVwiO1xuZXhwb3J0IHsgSW1hZ2VzIH07XG5cbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi9pbnB1dFwiO1xuZXhwb3J0IHsgSW5wdXRzIH07XG5cbmltcG9ydCAqIGFzIExheW91dHMgZnJvbSBcIi4vbGF5b3V0XCI7XG5leHBvcnQgeyBMYXlvdXRzIH07XG5cbmltcG9ydCAqIGFzIExpbmtzIGZyb20gXCIuL2xpbmtcIjtcbmV4cG9ydCB7IExpbmtzIH07XG5cbmltcG9ydCAqIGFzIExpc3RzIGZyb20gXCIuL2xpc3RcIjtcbmV4cG9ydCB7IExpc3RzIH07XG5cbmltcG9ydCAqIGFzIE1vZGFscyBmcm9tIFwiLi9tb2RhbFwiO1xuZXhwb3J0IHsgTW9kYWxzIH07XG5cbmltcG9ydCAqIGFzIE5vdGlmaWNhdGlvbnMgZnJvbSBcIi4vbm90aWZpY2F0aW9uXCI7XG5leHBvcnQgeyBOb3RpZmljYXRpb25zIH07XG5cbmltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi9jb21tb25cIjtcbmV4cG9ydCB7IFVJQ29tbW9uIH07XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJ3b2xmeTg3LWV2ZW50ZW1pdHRlclwiO1xuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbmNvbnN0IE1FVEFfTUVUSE9EX0lOSVQgPSBTeW1ib2woXCJpbml0XCIpLFxuICAgIE1FVEFfREFUQSA9IFN5bWJvbChcImRhdGFcIiksXG4gICAgTUVUQV9XT1JLSU5HID0gU3ltYm9sKFwid29ya2luZ1wiKSxcbiAgICBNRVRBX09QVElPTlMgPSBTeW1ib2woXCJvcHRpb25zXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBub3RCYXNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzW01FVEFfREFUQV0gPSB7fTtcbiAgICAgICAgdGhpc1tNRVRBX1dPUktJTkddID0ge307XG4gICAgICAgIHRoaXNbTUVUQV9PUFRJT05TXSA9IHt9O1xuICAgICAgICB0aGlzW01FVEFfTUVUSE9EX0lOSVRdKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgW01FVEFfTUVUSE9EX0lOSVRdKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGlucHV0LCBcImRhdGFcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaW5wdXQsIFwid29ya2luZ1wiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKGlucHV0LndvcmtpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpbnB1dCwgXCJvcHRpb25zXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoaW5wdXQub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZyA9IG5vdENvbW1vbi5nZW5Mb2dNc2codGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKSk7XG4gICAgICAgIHRoaXMuaW5mbyA9IHRoaXMubG9nO1xuICAgICAgICB0aGlzLmRlYnVnID0gbm90Q29tbW9uLmdlbkxvZ0RlYnVnKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgICAgICB0aGlzLmVycm9yID0gbm90Q29tbW9uLmdlbkxvZ0Vycm9yKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgIH1cblxuICAgIHNldENvbW1vbih3aGF0LCBhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8qIHNldCBjb2xsZWN0aW9uICovXG4gICAgICAgICAgICAgICAgd2hhdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAvKiBzZXQgY29sbGVjdGlvbiBlbGVtZW50ICovXG4gICAgICAgICAgICAgICAgbm90UGF0aC5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gLyogcGF0aCAqLyxcbiAgICAgICAgICAgICAgICAgICAgd2hhdCAvKiBjb2xsZWN0aW9uICovLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgLyogaGVscGVycyAqLyxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSAvKiB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldENvbW1vbih3aGF0LCBhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIGlmIHdlIHdhbnQgZ2V0IGRhdGEgYnkgcGF0aCAqL1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KGFyZ3NbMF0sIHdoYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaWYgd2Ugd2FudCBnZXQgZGF0YSBieSBwYXRoIHdpdGggZGVmYXVsdCB2YWx1ZSAqL1xuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IG5vdFBhdGguZ2V0KGFyZ3NbMF0sIHdoYXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBubyBkYXRhLCByZXR1cm4gZGVmYXVsdCB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBkYXRhLCByZXR1cm4gaXQgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiByZXR1cm4gZnVsbCBjb2xsZWN0aW9uICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIENPUkUgT0JKRUNUXG4gICAgICBEQVRBIC0gaW5mb3JtYXRpb25cbiAgICAgIE9QVElPTlMgLSBob3cgdG8gd29ya1xuICAgICAgV09SS0lORyAtIHRlbXBvcmFyaWx5IGdlbmVyYXRlZCBpbiBwcm9jY2Vzc1xuICAqL1xuXG4gICAgc2V0RGF0YSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbTUVUQV9EQVRBXSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29tbW9uKHRoaXMuZ2V0RGF0YSgpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9EQVRBXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzZXRPcHRpb25zKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpc1tNRVRBX09QVElPTlNdID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21tb24odGhpcy5nZXRPcHRpb25zKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9PUFRJT05TXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzZXRXb3JraW5nKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpc1tNRVRBX1dPUktJTkddID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21tb24odGhpcy5nZXRXb3JraW5nKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9XT1JLSU5HXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXBvcnQoZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLnJlcG9ydCkge1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEFwcCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgfVxufVxuIiwiaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuXG5pbXBvcnQgeyBOQVZJR0FUSU9OX0RFTEFZUywgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUIH0gZnJvbSBcIi4vY29uc3QuanNcIjtcblxuY29uc3QgT1BUX01PREVfSElTVE9SWSA9IFN5bWJvbChcImhpc3RvcnlcIiksXG4gICAgT1BUX01PREVfSEFTSCA9IFN5bWJvbChcImhhc2hcIiksXG4gICAgT1BUX0RFRkFVTFRfQ0hFQ0tfSU5URVJWQUwgPSA1MDtcblxuY2xhc3Mgbm90Um91dGVyIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgaG9zdCA9IFwiXCI7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICByb3V0ZXM6IFtdLFxuICAgICAgICAgICAgICAgIG1vZGU6IE9QVF9NT0RFX0hJU1RPUlksXG4gICAgICAgICAgICAgICAgcm9vdDogXCIvXCIsIC8vYWx3YXlzIGluIHNsYXNoZXMgL3VzZXIvLCAvLCAvaW5wdXQvLiBhbmQgbm8gL3VzZXIgb3IgaW5wdXQvbGV2ZWxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVsYXlzOiBOQVZJR0FUSU9OX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBkZWxheV9kZWZhdWx0OiBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9iamVjdCB3aXRoIG5hbWVkIGRlbGF5c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbGF5c1xuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgc2V0RGVsYXlzKGRlbGF5cykge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJkZWxheXNcIiwgZGVsYXlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgbmF2aWdhdGlvbiBkZWxheSwgcHJvdmlkZWQgYXMgbmFtZSBvZiBvbmUgb2YgYGRlbGF5c2Agb3IgaW4gbnVtYmVyIGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRlbGF5XG4gICAgICogQHJldHVybnMge25vdFJvdXRlcn1cbiAgICAgKi9cbiAgICBzZXREZWZhdWx0TmF2aWdhdGlvbkRlbGF5KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImRlbGF5X2RlZmF1bHRcIiwgdGhpcy5kZWxheUFzTXMoZGVsYXkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgb2YgbXMsIGlmIG5vdCBzZXQgcmV0dXJucyBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoYGRlbGF5X2RlZmF1bHRgLCBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFbnN1cmVzIHRoYXQgZGVsYXkgaXMgaW4gbXMsIGlmIGl0cyBwcm92aWRlZCBhcyBuYW1lIG9mIGFsaWFzLCBzZWFyY2hlcyBmb3IgaXQgYW5kIHJldHVybnMsIGlmIG5vdCBmb3VuZCAtIHJldHVybnMgd29ya2luZyBkZWZhdWx0X2RlbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZWxheSAgICBuYW1lIG9mIGRlbGF5IGFsaWFzIG9yIG51bWJlciBvZiBtc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9ICAgICAgICAgICAgICAgZGVsYXkgaW4gbXNcbiAgICAgKi9cbiAgICBkZWxheUFzTXMoZGVsYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJzdHJpbmdcIiAmJiBkZWxheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgYGRlbGF5cy4ke2RlbGF5fWAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICB1cmwgICAgIHdlIGdvIHRvIHVybFxuICAgICAqICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9ICAgICAgIGRlbGF5ICAgbmFtZSBvZiBkZWxheSBhbGlhcyBvciBudW1iZXIgb2YgbXNcbiAgICAgKiAgQHJldHVybnMge05vZGVKUy5UaW1lb3V0fSAgICAgICAgICAgIHRpbWVvdXQgaWRlbnRpZmljYXRvclxuICAgICAqL1xuICAgIG5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksIGRvQmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHR5cGVvZiBkb0JlZm9yZSA9PT0gXCJmdW5jdGlvblwiICYmIGRvQmVmb3JlKCk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlKHVybCk7XG4gICAgICAgIH0sIHRoaXMuZGVsYXlBc01zKGRlbGF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIGJyb3dzZXIgSGlzdG9yeSBBUElcbiAgICAgKi9cbiAgICBoaXN0b3J5KCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlXCIsIE9QVF9NT0RFX0hJU1RPUlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBoYXNoIHBhcnQgYXMgY29udGFpbmVyIGZvciBsb2NhdGlvbiBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVcIiwgT1BUX01PREVfSEFTSCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm9vdCBzaG91bGQgc3RhcnQgYW5kIGVuZCB3aXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RcbiAgICAgKiBAcmV0dXJucyB7bm90Um91dGVyfVxuICAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcInJvb3RcIixcbiAgICAgICAgICAgIHJvb3QgJiYgcm9vdCAhPT0gXCIvXCIgPyBcIi9cIiArIHRoaXMuY2xlYXJTbGFzaGVzKHJvb3QpICsgXCIvXCIgOiBcIi9cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbGVhciBmaXJzdCBhbmQgbGFzdCBzbGFzaGVzIGZyb20gc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsZWFyU2xhc2hlcyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG5cbiAgICBhZGQocmUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSByZTtcbiAgICAgICAgICAgIHJlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVsZSA9IHtcbiAgICAgICAgICAgIHJlOiByZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKS5wdXNoKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhZGRMaXN0KGxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgdCBpbiBsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0LCBsaXN0W3RdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmUocGFyYW0pIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBpID0gMCwgcjtcbiAgICAgICAgICAgIGkgPCB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikubGVuZ3RoLFxuICAgICAgICAgICAgKHIgPSB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIilbaV0pO1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHIuaGFuZGxlciA9PT0gcGFyYW0gfHwgci5yZSA9PT0gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoe1xuICAgICAgICAgICAgcm91dGVzOiBbXSxcbiAgICAgICAgICAgIG1vZGU6IE9QVF9NT0RFX0hJU1RPUlksXG4gICAgICAgICAgICByb290OiBcIi9cIixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJpbml0aWFsaXplZFwiKTtcbiAgICB9XG5cbiAgICBzZXRJbml0aWFsaXplZCh2YWwgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFdvcmtpbmcoXCJpbml0aWFsaXplZFwiLCB2YWwpO1xuICAgIH1cblxuICAgIGdldEZyYWdtZW50KCkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSA9PT0gT1BUX01PREVfSElTVE9SWSkge1xuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuY2xlYXJTbGFzaGVzKFxuICAgICAgICAgICAgICAgIGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcPyguKikkLywgXCJcIik7XG4gICAgICAgICAgICBmcmFnbWVudCA9XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSAhPSBcIi9cIlxuICAgICAgICAgICAgICAgICAgICA/IGZyYWdtZW50LnJlcGxhY2UodGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBmcmFnbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghd2luZG93KSByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJTbGFzaGVzKGZyYWdtZW50KTtcbiAgICB9XG5cbiAgICBjaGVja0xvY2F0aW9uKCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0V29ya2luZyhcImN1cnJlbnRcIiksXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IGZyYWdtZW50IHx8ICFpbml0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJjdXJyZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2soZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsaXplZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhyZWZDbGljaygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpO1xuICAgIH1cblxuICAgIGxpc3Rlbihsb29wSW50ZXJ2YWwgPSBPUFRfREVGQVVMVF9DSEVDS19JTlRFUlZBTCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJjdXJyZW50XCIsIFwibm90SW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5nZXRXb3JraW5nKFwiaW50ZXJ2YWxcIikpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcImludGVydmFsXCIsXG4gICAgICAgICAgICBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrTG9jYXRpb24uYmluZCh0aGlzKSwgbG9vcEludGVydmFsKVxuICAgICAgICApO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuaHJlZkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjaGVjayhmKSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IGYgfHwgdGhpcy5nZXRGcmFnbWVudCgpLFxuICAgICAgICAgICAgZmFpbEJhY2sgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhdGggPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpICsgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLnJlLFxuICAgICAgICAgICAgICAgIGZ1bGxSRSA9IHRoaXMuY2xlYXJTbGFzaGVzKGRlY29kZVVSSShwYXRoKSksXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmcmFnbWVudC5tYXRjaChmdWxsUkUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsUkUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZmFpbEJhY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLmhhbmRsZXIuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3QgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJvdXRlXCIsIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbEJhY2spIHtcbiAgICAgICAgICAgIGZhaWxCYWNrLnJvdXRlLmhhbmRsZXIuYXBwbHkodGhpcy5ob3N0IHx8IHt9LCBmYWlsQmFjay5tYXRjaCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJvdXRlXCIsIGZhaWxCYWNrLnJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmcmVzaGVzIHBhZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCB0aW1lIHRvIHdhaXQgaW4gbXNcbiAgICAgKi9cbiAgICByZWZyZXNoKHRpbWVvdXQgPSAwKSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlZnJlc2goKSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrKHRoaXMuZ2V0V29ya2luZyhcImN1cnJlbnRcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBsb2NhdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbmF2aWdhdGUocGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aCA/IHBhdGggOiBcIlwiO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIikpIHtcbiAgICAgICAgICAgIGNhc2UgT1BUX01PREVfSElTVE9SWToge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdXRlID0gdGhpcy5nZXRGdWxsUm91dGUocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JvdXRlID09PSB0aGlzLmxhc3RSb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RSb3V0ZSA9IG5ld1JvdXRlO1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBcIlwiLCB0aGlzLmxhc3RSb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUFRfTU9ERV9IQVNIOiB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIyguKikkLywgXCJcIikgKyBcIiNcIiArIHBhdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHJldHVybnMgYXBwIHJvb3QgKyBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEZ1bGxSb3V0ZShwYXRoID0gXCJcIikge1xuICAgICAgICBwYXRoID0gdGhpcy5jbGVhclNsYXNoZXMocGF0aCk7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpO1xuICAgICAgICBpZiAocm9vdCAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2Yocm9vdC5zdWJzdHJpbmcoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgcGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSArIHRoaXMuY2xlYXJTbGFzaGVzKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGxpbmtzIHdpdGggbi1ocmVmIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxIVE1MQW5jaG9yRWxlbWVudD59XG4gICAgICovXG4gICAgZ2V0QWxsTGlua3MoKSB7XG4gICAgICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiYVwiKTtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhbGxFbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDAsIGF0dHMgPSBhbGxFbGVtZW50c1tqXS5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaSA8IG47XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0c1tpXS5ub2RlTmFtZS5pbmRleE9mKFwibi1ocmVmXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhbGxFbGVtZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXJvdXRlIGFsbCBsaW5rcyhhbmNob3IgdGFncykgd2l0aCBuLWhyZWYgYXR0cmlidXRlLlxuICAgICAqIERpc2FibGUgbmF2aWdhdGlvbiB0byBocmVmLlxuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgcmVSb3V0ZUV4aXN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldEFsbExpbmtzKCk7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbGlzdC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdGhpcy5pbml0UmVyb3V0aW5nKGxpc3RbdF0sIGxpc3RbdF0uZ2V0QXR0cmlidXRlKFwibi1ocmVmXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBgZWxgIGlzIG5vdCBpbml0aWFsaXplZCwgYWRkcyBvbmNsaWNrIGxpc3RlbmVyIHRvIG5hdmlnYXRlIHRvIGBsaW5rYCBsb2NhdGlvbi5cbiAgICAgKiBEaXNhYmxlcyBkZWZhdWx0IG5hdmlnYXRpb24gdG8gaHJlZi5cbiAgICAgKiBAcGFyYW0ge0hUTUxBbmNob3JFbGVtZW50fSAgIGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBsaW5rXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBpbml0UmVyb3V0aW5nKGVsLCBsaW5rKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFlbC5ub3RSb3V0ZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbGV0IGZ1bGxMaW5rID0gdGhpcy5nZXRGdWxsUm91dGUobGluayk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGZ1bGxMaW5rKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlKGxpbmspO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZWwubm90Um91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IG5vdFJvdXRlcigpO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vYmFzZS5qc1wiO1xuXG5jb25zdCBMT0dfUFJFRklYID0gXCJBUElRdWVlXCI7XG5cbmNsYXNzIG5vdEFQSVF1ZXVlIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgc3RhdGljIFFVRVVFX0NIRUNLX0lOVEVSVkFMID0gMTAwO1xuXG4gICAgc3RhdGljIE1BWF9CVVNZX1RJTUUgPSAzMDA7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSA/IG9wdGlvbnMubmFtZSA6IExPR19QUkVGSVgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgIHRoaXMuY2hlY2tRdWV1ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdGhpcy5RVUVVRV9DSEVDS19JTlRFUlZBTFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNoZWNrUXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkgJiYgIXRoaXMuaXNCdXN5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnVzeSgpXG4gICAgICAgICAgICAgICAgLnJ1bk5leHQoKVxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0RnJlZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RnJlZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQnVzeSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuYWZ0ZXJFbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZnRlckVtcHR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkVG9RdWV1ZSh0YXNrKSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICB9XG5cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMucXVldWUubWFwKChhY3Rpb24pID0+IGFjdGlvbi50aXRsZSkuam9pbihcIiwgXCIpO1xuICAgICAgICB0aGlzLmRlYnVnICYmIHRoaXMuZGVidWcoYHRhc2tzIFske2xpc3R9XWApO1xuICAgICAgICBsZXQgdGFzayA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFub3RDb21tb24uaXNGdW5jKHRhc2suYWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwi0JIg0LfQsNC00LDQvdC40Lgg0L3QtdGCINC40YHQv9C+0LvQvdC40LzQvtC5INGH0LDRgdGC0LgsIGFjdGlvbiDQvdC1INGE0YPQvdC60YbQuNGPXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhc2sudGl0bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub3RDb21tb24uaXNGdW5jKHRhc2sucmVzb2x2ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcItCSINC30LDQtNCw0L3QuNC4INC90LXRgiDQstC+0LfQstGA0LDRgtC90L7QuSDRh9Cw0YHRgtC4LCByZXNvbHZlINC90LUg0YTRg9C90LrRhtC40Y9cIixcbiAgICAgICAgICAgICAgICAgICAgdGFzay50aXRsZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5hY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFzay5hY3Rpb24oKS50aGVuKHRhc2sucmVzb2x2ZSk7XG4gICAgfVxuXG4gICAgaXNCdXN5KCkge1xuICAgICAgICBsZXQgYnVzeSA9ICEhdGhpcy5idXN5LFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIGlmIChidXN5ICYmIHRoaXMuYnVzeVNpbmNlID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aGlzLmJ1c3lTaW5jZSA+IG5vdEFQSVF1ZXVlLk1BWF9CVVNZX1RJTUUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZyZWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QnVzeSgpIHtcbiAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXN5U2luY2UgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0RnJlZSgpIHtcbiAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDQmNGB0L/QvtC70L3QuNGC0LXQu9GMINC30LDQv9GA0L7RgdC+0LJcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgYWN0aW9uICAgICAg0LTQvtC70LbQvdCwINCy0L7Qt9Cy0YDQsNGJ0LDRgtGMIFByb21pc2VcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgW2FmdGVyRW1wdHkgPSB1bmRlZmluZWRdICDQsdGD0LTQtdGCINCy0YvQv9C+0LvQvdC10L3QsCDQutC+0LPQtNCwINC+0YfRg9GA0YPQtNGMINC+0L/Rg9GB0YLQtdC10YIg0Lgg0LHRg9C00LXRgiDRgdCy0L7QsdC+0LTQvdCwLiDQv9C+0LvQtdC30L3QsCDQv9GA0Lgg0L/QsNGH0LrQtSDQvtC00L3QvtGC0LjQv9C90YvRhSDQt9Cw0LTQsNC90LjQuVxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBbdGl0bGUgPSAnJ10gICAgb3B0aW9uYWwgdGl0bGUgb2YgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zICAgIHtQcm9taXNlfSAgICDRgNC10LfRg9C70YzRgtCw0YIg0YTRg9C90LrRhtC40LhcbiAgICAgKiovXG4gICAgcnVuKGFjdGlvbiwgYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZCwgdGl0bGUgPSBcIlwiKSB7XG4gICAgICAgIGlmIChhZnRlckVtcHR5ICYmIHR5cGVvZiB0aGlzLmFmdGVyRW1wdHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IGFmdGVyRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb1F1ZXVlKHsgYWN0aW9uLCByZXNvbHZlLCB0aXRsZSB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3Rpb25Jc1F1ZXVlZCh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5zb21lKChxdWV1ZWQpID0+IHF1ZXVlZC50aXRsZSA9PSB0aXRsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAgIHtmdW5jdGlvbn0gICBhY3Rpb24gICAgICDQtNC+0LvQttC90LAg0LLQvtC30LLRgNCw0YnQsNGC0YwgUHJvbWlzZVxuICAgICAqIEBwYXJhbSAgICAgIHtmdW5jdGlvbn0gICBbYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZF0gINCx0YPQtNC10YIg0LLRi9C/0L7Qu9C90LXQvdCwINC60L7Qs9C00LAg0L7Rh9GD0YDRg9C00Ywg0L7Qv9GD0YHRgtC10LXRgiDQuCDQsdGD0LTQtdGCINGB0LLQvtCx0L7QtNC90LAuINC/0L7Qu9C10LfQvdCwINC/0YDQuCDQv9Cw0YfQutC1INC+0LTQvdC+0YLQuNC/0L3Ri9GFINC30LDQtNCw0L3QuNC5XG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIFt0aXRsZSA9ICcnXSAgICBvcHRpb25hbCB0aXRsZSBvZiByZXF1ZXN0XG4gICAgICogQHJldHVybiAgICB7UHJvbWlzZX1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QVBJUXVldWVcbiAgICAgKi9cbiAgICBydW5JZk5vdFF1ZXVlZChhY3Rpb24sIGFmdGVyRW1wdHkgPSB1bmRlZmluZWQsIHRpdGxlID0gXCJcIikge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25Jc1F1ZXVlZCh0aXRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bihhY3Rpb24sIGFmdGVyRW1wdHksIHRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QVBJUXVldWU7XG4iLCJsZXQgbm90QVBJT3B0aW9ucyA9IHtcbiAgICBycHM6IDUwLFxuICAgIHByb3RvY29sOiAnaHR0cCcsXG4gICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgcG9ydDogOTAwMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbm90QVBJT3B0aW9ucztcbiIsImltcG9ydCBub3RCYXNlIGZyb20gJy4uL2Jhc2UuanMnO1xuY29uc3QgTE9HX1BSRUZJWCA9ICdBUElDb25uZWN0aW9uJztcblxuY2xhc3Mgbm90QVBJQ29ubmVjdGlvbiBleHRlbmRzIG5vdEJhc2V7XG4gICAgc3RhdGljIGludDtcbiAgICBzdGF0aWMgb25saW5lO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZT9vcHRpb25zLm5hbWU6TE9HX1BSRUZJWFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMuaW50ID0gd2luZG93LnNldEludGVydmFsKHRoaXMuY2hlY2suYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaW50KTtcbiAgICB9XG5cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuXG4gICAgaXNPbmxpbmUoKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lO1xuICAgIH1cblxuICAgIGNoZWNrKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXMuaXNPbmxpbmUoKTtcbiAgICAgICAgaWYgKHRoaXMub25saW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbmxpbmUgIT09IHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25saW5lID0gdDtcbiAgICB9XG5cbiAgICBjaGFuZ2VTdGF0ZShvbmxpbmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAob25saW5lKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ29ubGluZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEFQSUNvbm5lY3Rpb247XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbmNvbnN0IEFMTCA9IHt9O1xuXG5mdW5jdGlvbiBleGlzdChrZXkpIHtcbiAgICByZXR1cm4gbm90Q29tbW9uLm9iakhhcyhBTEwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoZXhpc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gQUxMW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKFxuICAgIGtleSxcbiAgICBwcm9wcyA9IHtcbiAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgZmlsdGVyZWQ6IFtdLFxuICAgICAgICBzZWxlY3RlZDoge30sXG4gICAgfVxuKSB7XG4gICAgaWYgKCFleGlzdChrZXkpKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgQUxMW2tleV0gPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgQUxMW2tleV1bbmFtZV0gPSB3cml0YWJsZShwcm9wc1tuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0b3JlJ3MgcHJvcHMgd2Fzbid0IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQUxMW2tleV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBvYmplY3QgdGhhdCBpcyBmYWtlIFN0b3JlXG4gKiBTb21lIHRpbWUgdGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBpbml0aWFsaXplIGxvY2FsIHZhcixcbiAqIGJlZm9yZSB5b3UgY291bGQgZ2V0IGFjdHVhbCBTdG9yZXMgZnJvbSBjZW50cmFsIHN0b3JhZ2UgYnkgaXRzIElEXG4gKlx0QHBhcmFtcyB7bWl4ZWR9IHZhbCBcdGRhdGEgb2YgdHlwZSB0aGF0IGlzIGFjdHVhbCBzdG9yYWdlIHdpbGwgY29udGFpblxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBmYWtlKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShmKSB7XG4gICAgICAgICAgICBmKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHt9LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSwgZ2V0LCBmYWtlIH07XG4iLCJjb25zdFxuICAgIC8vaW50ZXJmYWNlXG4gICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSA9IFsnX2lkJywgJ2lkJywgJ0lEJ10sXG4gICAgREVGQVVMVF9GSUxURVIgPSB7fSxcbiAgICBERUZBVUxUX1NFQVJDSCA9ICcnLFxuICAgIERFRkFVTFRfUkVUVVJOID0ge30sXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUiA9IDEsXG4gICAgREVGQVVMVF9QQUdFX1NJWkUgPSAxMCxcbiAgICAvL3JlY29yZFxuICAgIE1FVEFfSU5URVJGQUNFID0gU3ltYm9sKCdpbnRlcmZhY2UnKSxcbiAgICBNRVRBX01BUF9UT19JTlRFUkZBQ0UgPSBbXG4gICAgICAgICdnZXRBY3Rpb25zQ291bnQnLFxuICAgICAgICAnZ2V0QWN0aW9ucycsXG4gICAgICAgICdzZXRGaW5kQnknLFxuICAgICAgICAncmVzZXRGaWx0ZXInLFxuICAgICAgICAnc2V0RmlsdGVyJyxcbiAgICAgICAgJ2dldEZpbHRlcicsXG4gICAgICAgICdzZXRTb3J0ZXInLFxuICAgICAgICAnZ2V0U29ydGVyJyxcbiAgICAgICAgJ3Jlc2V0U29ydGVyJyxcbiAgICAgICAgJ3NldFBhZ2VOdW1iZXInLFxuICAgICAgICAnc2V0UGFnZVNpemUnLFxuICAgICAgICAnc2V0UGFnZXInLFxuICAgICAgICAnc2V0UmV0dXJuJyxcbiAgICAgICAgJ3NldFNlYXJjaCcsXG4gICAgICAgICdnZXRTZWFyY2gnLFxuICAgICAgICAncmVzZXRTZWFyY2gnLFxuICAgICAgICAncmVzZXRQYWdlcicsXG4gICAgICAgICdnZXRQYWdlcicsXG4gICAgICAgICdhZGRGb3JtRmllbGRUeXBlJyxcbiAgICAgICAgJ2FkZEZvcm1GaWVsZCcsXG4gICAgICAgICdnZXRGaWVsZFR5cGVzJyxcbiAgICAgICAgJ2dldEFjdGlvbkZvcm1GaWVsZHMnXG4gICAgXSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVggPSAnJCc7XG5cbmV4cG9ydCB7XG4gICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSxcbiAgICBERUZBVUxUX0ZJTFRFUixcbiAgICBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgIERFRkFVTFRfUEFHRV9TSVpFLFxuICAgIERFRkFVTFRfU0VBUkNILFxuICAgIERFRkFVTFRfUkVUVVJOLFxuICAgIE1FVEFfSU5URVJGQUNFLFxuICAgIE1FVEFfTUFQX1RPX0lOVEVSRkFDRSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVhcbn07XG4iLCJpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5cbmNvbnN0IE9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFkgPSBbXCJfaWRcIiwgXCJpZFwiLCBcIklEXCJdLFxuICAgIERFRkFVTFRfRklMVEVSID0ge30sXG4gICAgREVGQVVMVF9TRUFSQ0ggPSBcIlwiLFxuICAgIERFRkFVTFRfUkVUVVJOID0ge30sXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUiA9IDAsXG4gICAgREVGQVVMVF9QQUdFX1NJWkUgPSAxMCxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVggPSBcIiRcIixcbiAgICBERUZBVUxUX1dTX1JPVVRFX0FDVElPTl9TUExJVFRFUiA9IFwiLy9cIjtcblxuY2xhc3Mgbm90SW50ZXJmYWNlIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgY29uc3RydWN0b3IobWFuaWZlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6XG4gICAgICAgICAgICAgICAgICAgIFwibmV0d29yayBpbnRlcmZhY2UgZm9yOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChtYW5pZmVzdC5tb2RlbCA/IG1hbmlmZXN0Lm1vZGVsIDogXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogREVGQVVMVF9GSUxURVIsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBERUZBVUxUX1NFQVJDSCxcbiAgICAgICAgICAgICAgICByZXR1cm46IERFRkFVTFRfUkVUVVJOLFxuICAgICAgICAgICAgICAgIHBhZ2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IERFRkFVTFRfUEFHRV9TSVpFLFxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgICAgdGhpcy5pbml0QWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbml0QWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QWN0aW9uc0NvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMuZ2V0QWN0aW9ucygpO1xuICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uTmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdEFjdGlvbihhY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyh0aGlzLCBERUZBVUxUX0FDVElPTl9QUkVGSVggKyBhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgdGhpc1tERUZBVUxUX0FDVElPTl9QUkVGSVggKyBhY3Rpb25OYW1lXSA9IChcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgZmlsZVVwbG9hZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICApID0+XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlVXBsb2FkLFxuICAgICAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0SFRUUChcbiAgICAgICAgcmVjb3JkLFxuICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgICAgZmlsZVVwbG9hZCA9IGZhbHNlLFxuICAgICAgICBmaWxlc1xuICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0ZURhdGEgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIHJlY29yZC5nZXREYXRhICYmIHR5cGVvZiByZWNvcmQuZ2V0RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVjb3JkLmdldERhdGEoKVxuICAgICAgICAgICAgICAgICAgICA6IHJlY29yZCxcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IHRoaXMuZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gdGhpcy5jb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtc0VuY29kZWQgPSB0aGlzLmVuY29kZVJlcXVlc3QocmVxdWVzdFBhcmFtcyksXG4gICAgICAgICAgICAgICAgLy9pZCA9IHRoaXMuZ2V0SUQoY29tcG9zaXRlRGF0YSwgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgYXBpU2VydmVyVVJMID0gdGhpcy5nZXRTZXJ2ZXJVUkwoKSxcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmdldFVSTChjb21wb3NpdGVEYXRhLCBhY3Rpb25EYXRhLCBhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgICBpZiAoZmlsZVVwbG9hZCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZ2V0VVJMKHBhcmFtcywgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQoXCJmaWxlXCIsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBmZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBbXCJPUFRJT05TXCIsIFwiR0VUXCJdLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICkgPT09IC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGFjdGlvbkRhdGEubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmdldERhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlY29yZC5nZXREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWNvcmQuZ2V0RGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gYWN0aW9uRGF0YS5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYXBpU2VydmVyVVJMICsgdXJsICsgcmVxdWVzdFBhcmFtc0VuY29kZWQsIG9wdHMpLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvcihlKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0V1MocmVjb3JkLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IHRoaXMuZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gdGhpcy5jb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBXUyA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXU0NsaWVudCgpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZU5hbWUgPSB0aGlzLmdldFdTUmVxdWVzdE5hbWUoYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcywgcmVjb3JkLmdldERhdGEoKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcInR5cGVcIikgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgYWN0aW9uRGF0YS50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgYWN0aW9uRGF0YS50eXBlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEudHlwZSAhPT0gXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBXUy5tZXNzYWdlKGFjdGlvbkRhdGEudHlwZSwgbWVzc2FnZU5hbWUsIHBheWxvYWQpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UucGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBXUy5yZXF1ZXN0KG1lc3NhZ2VOYW1lLCBwYXlsb2FkKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLnBheWxvYWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uZXJyb3IoZSk7XG4gICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdCgpIHtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSB0aGlzLmdldEFjdGlvbkRhdGEoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdFRyYW5zcG9ydChhY3Rpb25EYXRhKSkge1xuICAgICAgICAgICAgY2FzZSBcIndzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFdTKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RIVFRQKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZmxpbmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3c0lzVXAoYWN0aW9uRGF0YSkge1xuICAgICAgICBpZiAoYWN0aW9uRGF0YS53cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwid3NDbGllbnRcIikgJiZcbiAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLndzQ2xpZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0V1NDbGllbnQoYWN0aW9uRGF0YS53c0NsaWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaWVudCA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXU0NsaWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3RUcmFuc3BvcnQoYWN0aW9uRGF0YSkge1xuICAgICAgICBpZiAodGhpcy53c0lzVXAoYWN0aW9uRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIndzXCI7IC8vZm9yIHdzL3dzc1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwibWV0aG9kXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwXCI7IC8vZm9yIGh0dHAvaHR0cHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vZm9yIG9mZmxpbmVcbiAgICB9XG5cbiAgICBnZXRNb2RlbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzICYmIHRoaXMubWFuaWZlc3QgPyB0aGlzLm1hbmlmZXN0Lm1vZGVsIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25EYXRhKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9ucygpICYmIHRoaXMuZ2V0QWN0aW9ucygpW2FjdGlvbk5hbWVdXG4gICAgICAgICAgICA/IHRoaXMuZ2V0QWN0aW9ucygpW2FjdGlvbk5hbWVdXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3Rpb25zKCkgPyBPYmplY3Qua2V5cyh0aGlzLmdldEFjdGlvbnMoKSkubGVuZ3RoIDogMDtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdCAmJiB0aGlzLm1hbmlmZXN0LmFjdGlvbnNcbiAgICAgICAgICAgID8gdGhpcy5tYW5pZmVzdC5hY3Rpb25zXG4gICAgICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIHBhcnNlUGFyYW1zKHN0YXJ0LCBlbmQsIGxpbmUsIHJlY29yZCkge1xuICAgICAgICBsZXQgZmllbGROYW1lID0gXCJcIjtcbiAgICAgICAgbGV0IGxlbiA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxpbmUuaW5kZXhPZihzdGFydCkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGluZCA9IGxpbmUuaW5kZXhPZihzdGFydCk7XG4gICAgICAgICAgICBsZXQgc3RhcnRTbGljZSA9IGluZCArIGxlbjtcbiAgICAgICAgICAgIGxldCBlbmRTbGljZSA9IGxpbmUuaW5kZXhPZihlbmQpO1xuICAgICAgICAgICAgaWYgKGluZCA+IGVuZFNsaWNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBsaW5lLnNsaWNlKHN0YXJ0U2xpY2UsIGVuZFNsaWNlKTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT0gXCJcIikgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxvZyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICAgICAgICBzdGFydCArIGZpZWxkTmFtZSArIGVuZCxcbiAgICAgICAgICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGROYW1lLCByZWNvcmQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBmaWVsZE5hbWUgKyBlbmQsXG4gICAgICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGROYW1lLCByZWNvcmQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIHBhcnNlTGluZShsaW5lLCByZWNvcmQsIGFjdGlvbk5hbWUpIHtcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShcIjptb2RlbE5hbWVcIiwgdGhpcy5tYW5pZmVzdC5tb2RlbCk7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCI6YWN0aW9uTmFtZVwiLCBhY3Rpb25OYW1lKTtcbiAgICAgICAgbGluZSA9IHRoaXMucGFyc2VQYXJhbXMoXCI6cmVjb3JkW1wiLCBcIl1cIiwgbGluZSwgcmVjb3JkKTtcbiAgICAgICAgbGluZSA9IHRoaXMucGFyc2VQYXJhbXMoXCI6XCIsIFwiP1wiLCBsaW5lLCByZWNvcmQpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICBnZXRVUkwocmVjb3JkLCBhY3Rpb25EYXRhLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIHZhciBsaW5lID1cbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKHRoaXMubWFuaWZlc3QudXJsLCByZWNvcmQsIGFjdGlvbk5hbWUpICtcbiAgICAgICAgICAgIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwicG9zdEZpeFwiKVxuICAgICAgICAgICAgICAgID8gdGhpcy5wYXJzZUxpbmUoYWN0aW9uRGF0YS5wb3N0Rml4LCByZWNvcmQsIGFjdGlvbk5hbWUpXG4gICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgZ2V0U2VydmVyVVJMKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpXG4gICAgICAgICAgICA/IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRPcHRpb25zKFwiYXBpLnNlcnZlci51cmxcIiwgXCJcIilcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICB9XG5cbiAgICBnZXRXU1JlcXVlc3ROYW1lKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5tYW5pZmVzdC5tb2RlbDtcbiAgICAgICAgcmV0dXJuIGAke21vZGVsTmFtZX0ke0RFRkFVTFRfV1NfUk9VVEVfQUNUSU9OX1NQTElUVEVSfSR7YWN0aW9uTmFtZX1gO1xuICAgIH1cblxuICAgIGVuY29kZVJlcXVlc3QoZGF0YSkge1xuICAgICAgICBsZXQgcCA9IFwiP1wiO1xuICAgICAgICBmb3IgKGxldCB0IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVt0XSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhW3RdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcCArPVxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodCkgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbdF0uY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoZGF0YVt0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFbdF1cbiAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgIFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZm9yIHRlc3QgcHVycG9zZSBvbmx5LCBzcGVjaWFsIHRlc3Qgc2VydmVyIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdFwiKSkge1xuICAgICAgICAgICAgcCArPSBcIiZ0ZXN0PTFcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJ0ZXN0LnNlc3Npb25cIikpIHtcbiAgICAgICAgICAgICAgICBwICs9IFwiJnNlc3Npb249XCIgKyB0aGlzLmdldE9wdGlvbnMoXCJ0ZXN0LnNlc3Npb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdC5zZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgcCArPSBcIiZyb2xlPVwiICsgdGhpcy5nZXRPcHRpb25zKFwidGVzdC5yb2xlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGNvbGxlY3RSZXF1ZXN0RGF0YShhY3Rpb25EYXRhKSB7XG4gICAgICAgIGxldCByZXF1ZXN0RGF0YSA9IHt9O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwiZGF0YVwiKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhY3Rpb25EYXRhLmRhdGEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25EYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVByb3ZpZGVyTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgIFwiZ2V0XCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbkRhdGEuZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzW2RhdGFQcm92aWRlck5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW2RhdGFQcm92aWRlck5hbWVdID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzW2RhdGFQcm92aWRlck5hbWVdKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNvcnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJldHVyblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5pbmRleE9mKGFjdGlvbkRhdGEuZGF0YVtpXSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1thY3Rpb25EYXRhLmRhdGFbaV1dID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEgPSBPYmplY3QuYXNzaWduKHJlcXVlc3REYXRhLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdERhdGE7XG4gICAgfVxuXG4gICAgZ2V0SUQocmVjb3JkLCBhY3Rpb25EYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHRJZCxcbiAgICAgICAgICAgIGxpc3QgPSBPUFRfREVGQVVMVF9JTkRFWF9GSUVMRF9OQU1FX1BSSU9SSVRZLFxuICAgICAgICAgICAgcHJlZml4ZXMgPSBbXCJcIiwgdGhpcy5tYW5pZmVzdC5tb2RlbF07XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwiaW5kZXhcIikgJiYgYWN0aW9uRGF0YS5pbmRleCkge1xuICAgICAgICAgICAgbGlzdCA9IFthY3Rpb25EYXRhLmluZGV4XS5jb25jYXQoXG4gICAgICAgICAgICAgICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcmUgb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgbGlzdCkge1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHJlY29yZCwgcHJlICsgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SWQgPSByZWNvcmRbcHJlICsgdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0SWQ7XG4gICAgfVxuXG4gICAgc2V0RmluZEJ5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRGaWx0ZXIob2JqKTtcbiAgICB9XG5cbiAgICBzZXRGaWx0ZXIoZmlsdGVyRGF0YSA9IERFRkFVTFRfRklMVEVSKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImZpbHRlclwiLCBmaWx0ZXJEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEZpbHRlcigpO1xuICAgIH1cblxuICAgIGdldEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImZpbHRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRTZWFyY2goc2VhcmNoRGF0YSA9IERFRkFVTFRfU0VBUkNIKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInNlYXJjaFwiLCBzZWFyY2hEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRTZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFNlYXJjaCgpO1xuICAgIH1cblxuICAgIGdldFNlYXJjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNlYXJjaFwiKTtcbiAgICB9XG5cbiAgICBzZXRTb3J0ZXIoc29ydGVyRGF0YSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzb3J0ZXJcIiwgc29ydGVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0U29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3J0ZXIoe30pO1xuICAgIH1cblxuICAgIGdldFNvcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNvcnRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRSZXR1cm4ocmV0dXJuRGF0YSA9IERFRkFVTFRfUkVUVVJOKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJldHVyblwiLCByZXR1cm5EYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRSZXR1cm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFJldHVybih7fSk7XG4gICAgfVxuXG4gICAgZ2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicmV0dXJuXCIpO1xuICAgIH1cblxuICAgIHNldFBhZ2VOdW1iZXIocGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlci5wYWdlXCIsIHBhZ2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRQYWdlU2l6ZShwYWdlU2l6ZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlci5zaXplXCIsIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9wYWdlU2l6ZSA9IERFRkFVTFRfUEFHRV9TSVpFLCBwYWdlTnVtYmVyID0gREVGQVVMVF9QQUdFX05VTUJFUlxuICAgIHNldFBhZ2VyKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYXJndW1lbnRzLmxlbmd0aCA8IDIgfHxcbiAgICAgICAgICAgICAgICBpc05hTihhcmd1bWVudHNbMF0pIHx8XG4gICAgICAgICAgICAgICAgaXNOYU4oYXJndW1lbnRzWzFdKSkgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFyZ3VtZW50c1swXSwgXCJwYWdlXCIpICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFyZ3VtZW50c1swXSwgXCJzaXplXCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcGFnZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlclwiLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogcGFnZXIuc2l6ZSB8fCBERUZBVUxUX1BBR0VfU0laRSxcbiAgICAgICAgICAgICAgICBwYWdlOiBwYWdlci5wYWdlIHx8IERFRkFVTFRfUEFHRV9OVU1CRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICFpc05hTihhcmd1bWVudHNbMF0pICYmXG4gICAgICAgICAgICAhaXNOYU4oYXJndW1lbnRzWzFdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcInBhZ2VyXCIsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBhcmd1bWVudHNbMF0gfHwgREVGQVVMVF9QQUdFX1NJWkUsXG4gICAgICAgICAgICAgICAgcGFnZTogYXJndW1lbnRzWzFdIHx8IERFRkFVTFRfUEFHRV9OVU1CRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlcigpO1xuICAgIH1cblxuICAgIGdldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicGFnZXJcIik7XG4gICAgfVxuXG4gICAgZ2V0UmVjb3JkKCkge1xuICAgICAgICB0aGlzLmdldERhdGEoKTtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0QXNQbGFpbk9iamVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmlmZXN0IHx8ICF0aGlzLm1hbmlmZXN0LmZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLm1hbmlmZXN0LmZpZWxkcykpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRoaXMubWFuaWZlc3QuZmllbGRzW2ZpZWxkTmFtZV0sIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMubWFuaWZlc3QuZmllbGRzW2ZpZWxkTmFtZV0uZGVmYXVsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gWy4uLmRlZmF1bHRWYWx1ZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0geyAuLi5kZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEludGVyZmFjZTtcbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbmltcG9ydCB7XG4gICAgTUVUQV9JTlRFUkZBQ0UsXG4gICAgTUVUQV9NQVBfVE9fSU5URVJGQUNFLFxuICAgIERFRkFVTFRfQUNUSU9OX1BSRUZJWCxcbn0gZnJvbSBcIi4vb3B0aW9uc1wiO1xuXG5pbXBvcnQgbm90SW50ZXJmYWNlIGZyb20gXCIuL2ludGVyZmFjZVwiO1xuXG5jbGFzcyBub3RSZWNvcmQgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihtYW5pZmVzdCwgaXRlbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgaXRlbSA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09IFwib2JqZWN0XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmlzUHJveHkpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvcihcInRoaXMgaXMgUHJveHkgaXRlbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIChpdGVtLmlzUmVjb3JkIHx8IGl0ZW0uaXNQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKG1hbmlmZXN0LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE9wdGlvbnMoe30pO1xuICAgICAgICB0aGlzW01FVEFfSU5URVJGQUNFXSA9IG5ldyBub3RJbnRlcmZhY2UobWFuaWZlc3QsIHt9KTtcbiAgICAgICAgdGhpcy5zZXREYXRhKGl0ZW0pO1xuICAgICAgICB0aGlzLmludGVyZmFjZVVwKCk7XG4gICAgICAgIHRoaXMubWFwVG9JbnRlcmZhY2UoKTtcbiAgICAgICAgdGhpcy5tYXBUb01ldGhvZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9EZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKHRoaXNbTUVUQV9JTlRFUkZBQ0VdLmdldERlZmF1bHRBc1BsYWluT2JqZWN0KCkpO1xuICAgIH1cblxuICAgIG1hcFRvSW50ZXJmYWNlKCkge1xuICAgICAgICBsZXQgcmVjID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgdCBvZiBNRVRBX01BUF9UT19JTlRFUkZBQ0UpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzW01FVEFfSU5URVJGQUNFXVt0XSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW01FVEFfSU5URVJGQUNFXVt0XSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gcmVjW01FVEFfSU5URVJGQUNFXVt0XSguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzID09IHJlY1tNRVRBX0lOVEVSRkFDRV0gPyByZWMgOiByZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcFRvTWV0aG9kcygpIHtcbiAgICAgICAgbGV0IG1hbmlmZXN0ID0gdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3QsXG4gICAgICAgICAgICBhcHAgPSBub3RDb21tb24uZ2V0QXBwKCksXG4gICAgICAgICAgICBtZXRob2RzID0ge307XG4gICAgICAgIGlmIChtYW5pZmVzdC5tZXRob2RzKSB7XG4gICAgICAgICAgICBtZXRob2RzID0gbWFuaWZlc3QubWV0aG9kcztcbiAgICAgICAgfSBlbHNlIGlmIChhcHApIHtcbiAgICAgICAgICAgIG1ldGhvZHMgPSBhcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJtb2RlbHNcIiwgdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3QubW9kZWxdLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihtZXRob2RzLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RdID0gbWV0aG9kc1t0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVDb2xsZWN0aW9uKG1hbmlmZXN0LCBpdGVtcykge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobmV3IG5vdFJlY29yZChtYW5pZmVzdCwgaXRlbXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnRlcmZhY2VVcCgpIHtcbiAgICAgICAgaWYgKHRoaXNbTUVUQV9JTlRFUkZBQ0VdLmdldEFjdGlvbnNDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzW01FVEFfSU5URVJGQUNFXS5nZXRBY3Rpb25zKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblVwKGksIGFjdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVXAoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRoaXMsIFtERUZBVUxUX0FDVElPTl9QUkVGSVggKyBpbmRleF0pKSB7XG4gICAgICAgICAgICB0aGlzW0RFRkFVTFRfQUNUSU9OX1BSRUZJWCArIGluZGV4XSA9ICguLi5wYXJhbXMpID0+XG4gICAgICAgICAgICAgICAgdGhpc1tNRVRBX0lOVEVSRkFDRV0ucmVxdWVzdCh0aGlzLCBpbmRleCwgLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAtPiAncGF0aC50by5rZXknLCB2YWx1ZU9mS2V5XG4gIDwtIG9rLCB3aXRoIG9uZSBvbkNoYW5nZSBldmVudCB0cmlnZ2VyZWRcbiAgKi9cblxuICAgIHNldEF0dHIoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qXG4gIC0+XG4gIHtcbiAgICAna2V5UGF0aCc6IHZhbHVlLFxuICAgICdrZXkuc3ViUGF0aCc6IHZhbHVlMixcbiAgICAna2V5UGF0aC4wLnRpdGxlJzogdmFsdWUzXG4gIH1cbiAgPC0gb2ssIHdpdGggYnVuY2ggb2Ygb25DaGFuZ2UgZXZlbnRzIHRyaWdnZXJlZFxuICAqL1xuICAgIHNldEF0dHJzKG9iamVjdFBhcnQpIHtcbiAgICAgICAgLy9ub3RDb21tb24ubG9nKCdzZXRBdHRycycsIG9iamVjdFBhcnQsIE9iamVjdC5rZXlzKG9iamVjdFBhcnQpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2JqZWN0UGFydCAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdFBhcnQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFBhcnQpLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXRoIGluIG9iamVjdFBhcnQpIHtcbiAgICAgICAgICAgICAgICAvL25vdENvbW1vbi5sb2coJ3NldEF0dHJzIG9uZSB0byBnbycsIHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cihwYXRoLCBvYmplY3RQYXJ0W3BhdGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gIC0+ICdwYXRoVG9LZXknXG4gIDwtIHZhbHVlMVxuICAqL1xuICAgIGdldEF0dHIod2hhdCwgcGxhaW4gPSBmYWxzZSkge1xuICAgICAgICBsZXQgcHJ4ID0gdGhpcy5nZXREYXRhKHdoYXQsIHt9KTtcbiAgICAgICAgaWYgKHBsYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLnN0cmlwUHJveHkocHJ4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcng7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAtPiBbJ3BhdGhUb0tleScsICdwYXRoLnRvLmtleScsICdzaW1wbGVLZXknLC4uLl1cbiAgPC0gW3ZhbHVlMSwgdmFsdWUyLCB2YWx1ZTMsLi4uXVxuICAqL1xuICAgIGdldEF0dHJzKHdoYXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAod2hhdCAmJiB3aGF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBhdGggb2Ygd2hhdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2V0QXR0cihwYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRNYW5pZmVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXNbTUVUQV9JTlRFUkZBQ0VdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZXREYXRhKGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFJlY29yZDtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90UmVjb3JkIGZyb20gXCIuL3JlY29yZC5qc1wiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IG5vdFJvdXRlciBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW09QVF9DT05UUk9MTEVSX1BSRUZJWCA9IFwibmNcIl0gY29udHJvbGxlciBuYW1lcyBwcmVmaXggbmMgYWthIE5vdENvbnRyb2xsZXJcbiAqL1xuY29uc3QgT1BUX0NPTlRST0xMRVJfUFJFRklYID0gXCJuY1wiO1xuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW09QVF9SRUNPUkRfUFJFRklYID0gXCJuclwiXSByZWNvcmQgbmFtZXMgcHJlZml4IG5yIGFrYSBOb3RSZWNvcmRcbiAqL1xuY29uc3QgT1BUX1JFQ09SRF9QUkVGSVggPSBcIm5yXCI7XG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSBbREVGQVVMVF9XU19DTElFTlRfTkFNRSA9IFwibWFpblwiXSBkZWZhdWx0IG5hbWUgb2YgV1MgY2xpZW50XG4gKi9cbmNvbnN0IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBcIm1haW5cIjtcblxuLyoqXG4gKiBDbGFzcyBvZiBhcHBsaWNhdGlvblxuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdEFwcCBleHRlbmRzIG5vdEJhc2Uge1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtmdW5jdGlvbn0gREVGQVVMVF9XU19DTElFTlRfTkFNRSAgZnVuY3Rpb24gdG8gcGVyZm9ybSBkZWVwIG1lcmdlcyBvZiBvYmplY3RzXG4gICAgICovXG4gICAgc3RhdGljIERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBERUZBVUxUX1dTX0NMSUVOVF9OQU1FO1xuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAgICAgICAgIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jb250cm9sbGVycyAgY29udHJvbGxlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG9wdGlvbnMubWFuaWZlc3RVUkwgVVJMIG9mIG5ldHdvcmsgbWFuaWZlc3Qgd2l0aCBhbGwgYXZhaWxhYmxlIG1vZGVscy9hY3Rpb25zL2ZpZWxkcyByZXF1ZXN0cyBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGludGVyZmFjZXM6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJzOiBub3RDb21tb24ub2JqSGFzKG9wdGlvbnMsIFwiY29udHJvbGxlcnNcIilcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmNvbnRyb2xsZXJzXG4gICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICAgICAgaW5pdENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgdWlzOiB7fSxcbiAgICAgICAgICAgICAgICB3c2M6IHt9LFxuICAgICAgICAgICAgICAgIHdzczoge30sXG4gICAgICAgICAgICAgICAgc2VydmljZXM6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzPy5sb2cgJiYgdGhpcy5sb2coXCJzdGFydCBhcHBcIik7XG4gICAgICAgIG5vdENvbW1vbi5yZWdpc3RlcihcImFwcFwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0TWFuaWZlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYXBwbGljYXRpb24gYWNjb3JkaW5nIHRvIG5ldHdvcmsgbWFuaWZlc3QsIHdoaWNoIGlzIHJldHJpZXZlZCBmcm9tIHNlcnZlclxuICAgICAqL1xuICAgIGluaXRNYW5pZmVzdCgpIHtcbiAgICAgICAgbm90Q29tbW9uXG4gICAgICAgICAgICAuZ2V0SlNPTih0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFVSTFwiKSlcbiAgICAgICAgICAgIC50aGVuKChtYW5pZmVzdCkgPT4gdGhpcy5zZXRJbnRlcmZhY2VNYW5pZmVzdChtYW5pZmVzdCkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IG5vdENvbW1vbi5yZXBvcnQoZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uZSBwYWdlIHJvdXRpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBpbml0Um91dGVyKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJyb3V0ZXJcIiwgbm90Um91dGVyKTtcbiAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVyXCIpLnNldFJvb3QodGhpcy5nZXRPcHRpb25zKFwicm91dGVyLnJvb3RcIikpO1xuICAgICAgICBub3RSb3V0ZXIucmVSb3V0ZUV4aXN0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFsbCB0aGUgcm91dGVzIGhhbmRsZXJzIGFuZCBwdXNoZXMgdGhlbSBpbnRvIHJvdXRlclxuICAgICAqL1xuICAgIGV4ZWNSb3V0ZXIoKSB7XG4gICAgICAgIHZhciByb3V0aWVJbnB1dCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuZ2V0T3B0aW9ucyhcInJvdXRlci5tYW5pZmVzdFwiKS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHJvdXRlQmxvY2sgPSB0aGlzLmdldE9wdGlvbnMoXCJyb3V0ZXIubWFuaWZlc3RcIilbdF0sXG4gICAgICAgICAgICAgICAgcGF0aHMgPSByb3V0ZUJsb2NrLnBhdGhzLFxuICAgICAgICAgICAgICAgIHNjaGVtZXMgPSByb3V0ZUJsb2NrLnNjaGVtZXMsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IHJvdXRlQmxvY2suY29udHJvbGxlcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0aFNjaGVtZSA9XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtZXMgJiYgQXJyYXkuaXNBcnJheShzY2hlbWVzKSAmJiBzY2hlbWVzLmxlbmd0aCA+IGlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2NoZW1lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICByb3V0aWVJbnB1dFtwYXRoc1tpXV0gPSB0aGlzLmJpbmRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBwYXRoU2NoZW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXJcIikuYWRkTGlzdChyb3V0aWVJbnB1dCkubGlzdGVuKCk7IC8vLm5hdmlnYXRlKHRoaXMuZ2V0T3B0aW9ucygncm91dGVyLmluZGV4JykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaW50ZXJmYWNlIG1hbmlmZXN0IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgbWFuaWZlc3QgICAgaW50ZXJmYWNlIG1hbmlmZXN0XG4gICAgICovXG4gICAgc2V0SW50ZXJmYWNlTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShtYW5pZmVzdCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIsIG1hbmlmZXN0KTtcbiAgICAgICAgdGhpcy5pbml0Um91dGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBjb25zdHJ1Y3RvciBvZiBpbnRlcmZhY2UgbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG1vZGVsTmFtZSAgIG1vZGVsIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICBpbnRlcmZhY2UgbW9kZWwgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2VNYW5pZmVzdChtb2RlbE5hbWUpIHtcbiAgICAgICAgaWYgKG1vZGVsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIpW21vZGVsTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlTWFuaWZlc3RcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGluZyBBcHBsaWNhdGlvbiwgcmVsb2FkcyBpbnRlcmZhY2VzLCBpbml0IGNvbnRyb2xsZXIgbGF1bmNoZWQsIHN0YXJ0IGFnYWluXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvL9C90YPQttC90L4g0LjQvdC40YbQuNCw0LvQuNC30LjRgNC+0LLQsNGC0YxcbiAgICAgICAgLy/QvNC+0LTQtdC70Lgg0L/QvtC70YPRh9C10L3QvdGL0LzQuCDQuNC90YLQtdGA0YTQtdC50YHQsNC80LhcbiAgICAgICAgdGhpcy51cGRhdGVJbnRlcmZhY2VzKCk7XG4gICAgICAgIC8v0LjQvdC40YbQuNC70LjRhtC40YDQvtCy0LDRgtGMINC4INC30LDQv9GD0YHRgtC40YLRjCDQutC+0L3RgtGA0L7Qu9C70LXRgCDQuNC90LjRhtC40LDQu9C40LfQsNGG0LjQuFxuICAgICAgICB0aGlzLmluaXRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRBcHAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvbiBvZiBzZXJ2aWNlcywgc3RhcnR1cCBvZiByb3V0aW5nXG4gICAgICovXG4gICAgc3RhcnRBcHAoKSB7XG4gICAgICAgIHRoaXMuaW5pdFNlcnZpY2VzKCk7XG4gICAgICAgIC8v0YHQvtC30LTQsNGC0Ywg0LrQvtC90YLRgNC+0LvQu9C10YDRi1xuICAgICAgICAvL9GA0L7Rg9GC0LXRgCDQuCDQv9GA0LjQstGP0LfQsNGC0Ywg0Log0L3QtdC80YMg0LrQvtC90YLRgNC+0LvQu9C10YDRi1xuICAgICAgICB0aGlzLmV4ZWNSb3V0ZXIoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJTdGFydGVkXCIsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXJOYW1lIGNvbnRyb2xsZXIgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb250cm9sbGVyUGF0aFNjaGVtZVxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZnVuY3Rpb24gY3JlYXRlcyBuZXcgY29udHJvbGxlciBpbnN0YW5jZSBhbmQgcGFzcyBpbiBub3RBcHAgaW5zdGFuY2UsIGFyZ3VtZW50cyBmcm9tIHJvdXRlciBwYXJzZXIgYW5kIHBhdGhTY2hlbWVcbiAgICAgKi9cbiAgICBiaW5kQ29udHJvbGxlcihjb250cm9sbGVyTmFtZSwgY29udHJvbGxlclBhdGhTY2hlbWUpIHtcbiAgICAgICAgbGV0IGFwcCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXcgY29udHJvbGxlck5hbWUoYXBwLCBhcmd1bWVudHMsIGNvbnRyb2xsZXJQYXRoU2NoZW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyAnaW5pdGlhbGl6YXRpb24nIGNvbnRyb2xsZXIgd2hpY2ggaXMgcnVucyBvbmNlLFxuICAgICAqIHRvIHBlcmZvcm0gY3VzdG9tIGluaXRpYWxpemF0aW9ucyByb3V0aW5lcyBieSBhcHBsaWNhdGlvbiBjb2RlXG4gICAgICovXG4gICAgaW5pdENvbnRyb2xsZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXRPcHRpb25zKFwiaW5pdENvbnRyb2xsZXJcIikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBpbml0Q29udHJvbGxlciA9IHRoaXMuZ2V0T3B0aW9ucyhcImluaXRDb250cm9sbGVyXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiaW5pdENvbnRyb2xsZXJcIiwgbmV3IGluaXRDb250cm9sbGVyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd29ya2luZyBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gd29ya2luZyBjb250cm9sbGVyXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJjdXJyZW50Q29udHJvbGxlclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95ZXMgd29ya2luZyBjb250cm9sbGVyIHRoZW4gc2V0cyBwcm92aWRlZCBhcyB3b3JraW5nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGN0cmwgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG5vdEFwcCBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDb250cm9sbGVyKGN0cmwpIHtcbiAgICAgICAgbGV0IG9sZEN0cmwgPSB0aGlzLmdldEN1cnJlbnRDb250cm9sbGVyKCk7XG4gICAgICAgIGlmIChvbGRDdHJsICYmIG9sZEN0cmwuZGVzdHJveSkge1xuICAgICAgICAgICAgb2xkQ3RybC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiY3VycmVudENvbnRyb2xsZXJcIiwgY3RybCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYXJyb3cgZnVuY3Rpb246IChtb2RlbEluaXREYXRhID0ge30pID0+IG5vdFJlY29yZFxuICAgICAqIEZhY3RvcnkgdGhhdCBjcmVhdGVzIG5vdFJlY29yZCBpbnN0YW5jZXMgd2l0aCBiaW5kZWRcbiAgICAgKiByZWNvcmRNYW5pZmVzdCBhbmQgcHJvdmlkZWQgZGF0YSB0byBpbml0aWFsaXplIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRNYW5pZmVzdFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgICAqIEBtZW1iZXJvZiBub3RBcHBcbiAgICAgKi9cbiAgICBjcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkocmVjb3JkTWFuaWZlc3QpIHtcbiAgICAgICAgcmV0dXJuIChyZWNvcmREYXRhKSA9PiBuZXcgbm90UmVjb3JkKHJlY29yZE1hbmlmZXN0LCByZWNvcmREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgaW50ZXJmYWNlcywgcmVjcmVhdGVzIGFsbCBhY2NvcmRpbmcgdG8gT3B0aW9ucy5pbnRlcmFmYWNlTWFuaWZlc3RcbiAgICAgKi9cbiAgICB1cGRhdGVJbnRlcmZhY2VzKCkge1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJmYWNlcygpO1xuICAgICAgICBsZXQgbWFuaWZlc3RzID0gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlTWFuaWZlc3RcIik7XG4gICAgICAgIGlmIChtYW5pZmVzdHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gbWFuaWZlc3RzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY29yZE1hbmlmZXN0ID0gbWFuaWZlc3RzW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRNZXRob2RzID0gdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wibW9kZWxzXCIsIG5hbWVdLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAge31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZWNvcmRNYW5pZmVzdC5tZXRob2RzID0gcmVjb3JkTWV0aG9kcztcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lSW50ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkocmVjb3JkTWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJmYWNlKG5hbWUsIG5hbWVJbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgaW50ZXJmYWNlIG5hbWUgKG1vZGVsTmFtZSkgdG8gc3RhbmRhcnRpemllZCBwcmVmaXhNb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBpbnRlcmZhY2UgbW9kZWwgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIG5vdCByZWNvcmQgbmFtZVxuICAgICAqL1xuICAgIGdldFJlY29yZE5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gT1BUX1JFQ09SRF9QUkVGSVggKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGNvbnRyb2xsZXIgbmFtZSAoY29udHJvbGxlck5hbWUpIHRvIHN0YW5kYXJ0aXppZWQgcHJlZml4Q29udHJvbGxlck5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb250cm9sbGVyIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICBub3QgY29udHJvbGxlciBuYW1lXG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlck5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gT1BUX0NPTlRST0xMRVJfUFJFRklYICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG5hbWVkIGludGVyZmFjZSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGVsRmFjdG9yeVxuICAgICAqIEByZXR1cm4ge25vdEFwcH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QXBwXG4gICAgICovXG4gICAgc2V0SW50ZXJmYWNlKG5hbWUsIG1vZGVsRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGBpbnRlcmZhY2VzLiR7bmFtZX1gLCBtb2RlbEZhY3RvcnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIG5ldHdvcmsgaW50ZXJmYWNlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFsbCBuZXR3b3JrIGluc3RlcmZhY2VzXG4gICAgICovXG4gICAgZ2V0SW50ZXJmYWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZXNcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbnRlcmZhY2VzIGxpc3QgY2xlYXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjbGVhckludGVyZmFjZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImludGVyZmFjZXNcIiwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFdlYlNvY2tldHMgY2xpZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPURFRkFVTFRfV1NfQ0xJRU5UX05BTUVdIG5hbWUgb2YgY2xpZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHdzYyAgbm90V1NDbGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2V0V1NDbGllbnQobmFtZSA9IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUsIHdzYykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGB3c2MuJHtuYW1lfWAsIHdzYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3ZWIgc29ja2V0cyBjbGllbnQgaW5zdGFuY2UgYnkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1ERUZBVUxUX1dTX0NMSUVOVF9OQU1FXVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGluc3RhbmNlIG9mIG5vdFdTQ2xpZW50XG4gICAgICovXG4gICAgZ2V0V1NDbGllbnQobmFtZSA9IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhgd3NjLiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIG5ldHdvcmsgaW50ZXJmYWNlIGNsYXNzIGluaXRpYWxpemF0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIG5ldHdvcmsgaW50ZXJmYWNlXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBpbnRlcmZhY2UgY2xhc3MgaW5pdGlhbGl6YXRvclxuICAgICAqL1xuICAgIGdldEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZXMoKVtuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldHdvcmsgaW50ZXJmYWNlIChtb2RlbCkgaW5pdGlhbGl6ZWQgd2l0aCBwcm92aWRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgaW50ZXJmYWNlKG1vZGVsTmFtZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGE9e31dICAgIG1vZGVsIGRhdGFcbiAgICAgKiBAcmV0dXJucyBuZXR3b3JrIGludGVyZmFjZSBpbml0aWFsaXplcyB3aXRoIHByb3ZpZGVkIGRhdGFcbiAgICAgKi9cbiAgICBnZXRNb2RlbChuYW1lLCBkYXRhID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJmYWNlKG5hbWUpKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VydmljZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gdmFsIHNlcnZpY2VcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlKG5hbWUsIHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGBzZXJ2aWNlcy4ke25hbWV9YCwgdmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gICAgICogQHJldHVybnMge29iamVjdHxmdW5jdGlvbn0gc2VydmljZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2UobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKGBzZXJ2aWNlcy4ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHByb3ZpZGVkIHNlcnZpY2VzXG4gICAgICovXG4gICAgaW5pdFNlcnZpY2VzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwic2VydmljZXNcIikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlcnZOYW1lIGluIHRoaXMuZ2V0T3B0aW9ucyhcInNlcnZpY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcnYgPSB0aGlzLmdldE9wdGlvbnMoYHNlcnZpY2VzLiR7c2Vydk5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZUeXBlID0gbm90Q29tbW9uLmRldGVjdFR5cGUoc2Vydik7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VydlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZXJ2aWNlKHNlcnZOYW1lLCBuZXcgc2Vydih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VydmljZShzZXJ2TmFtZSwgc2Vydik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXM/LmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBTZXJ2aWNlICgke3NlcnZOYW1lfSkgaW5pdCBlcnJvcmAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kdWxlIGRlZGljYXRlZCBvcHRpb25zIHJlYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lICAgbW9kdWxlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByZWFkZXIgb2JqZWN0IHtnZXQocGF0aFRvVmFsdWUsIGRlZmF1bHRWYWx1ZSl9XG4gICAgICovXG4gICAgZ2V0Q29uZmlnUmVhZGVyRm9yTW9kdWxlKG1vZHVsZU5hbWUgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IG1vZENvbmZQYXRoID0gW1wibW9kdWxlc1wiLCBtb2R1bGVOYW1lXS5qb2luKFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogKHN1YlBhdGgsIGZhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlBhdGggJiYgdHlwZW9mIHN1YlBhdGggPT0gXCJzdHJpbmdcIiAmJiBzdWJQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgW21vZENvbmZQYXRoLCBzdWJQYXRoXS5qb2luKFwiLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhtb2RDb25mUGF0aCwgZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtb2R1bGUgZGVkaWNhdGVkIG9wdGlvbnMgcmVhZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2R1bGVOYW1lPScnXSAgIG1vZHVsZSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVhZGVyIG9iamVjdCB7Z2V0KHBhdGhUb1ZhbHVlLCBkZWZhdWx0VmFsdWUpfVxuICAgICAqL1xuICAgIG1vZHVsZUNvbmZpZyhtb2R1bGVOYW1lID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWdSZWFkZXJGb3JNb2R1bGUobW9kdWxlTmFtZSk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgbm90QXBwO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IE5BVklHQVRJT05fREVMQVlfREVGQVVMVCB9IGZyb20gXCIuL2NvbnN0LmpzXCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUgPSBcImRlZmF1bHRcIl0gICAgICBkZWZhdWx0IGFjdGlvbiBuYW1lXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FID0gXCJkZWZhdWx0XCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCJtYWluLmNvbnRlbnRcIl0gIHNlbGVjdG9yIG9mIGNvbnRhaW5lciBIVE1MXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFxuICovXG5jb25zdCBPUFRfREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIm1haW4uY29udGVudFwiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX1BMVVJBTF9OQU1FID0gXCJNb2RlbHNcIl0gIGRlZmF1bHQgcGx1cmFsIG5hbWUgb2YgZW50aXRpZXNcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfUExVUkFMX05BTUUgPSBcIk1vZGVsc1wiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX1NJTkdMRV9OQU1FID0gXCJNb2RlbFwiXSAgZGVmYXVsdCBzaW5nbGUgbmFtZSBvZiBlbnRpdGllc1xuICovXG5jb25zdCBPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSA9IFwiTW9kZWxcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gIFtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRT1cIm1haW5cIl0gIGRlZmF1bHQgbW9kdWxlIG5hbWVcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfTU9EVUxFX05BTUUgPSBcIm1haW5cIjtcblxuLyoqXG4gKiBAY29uc3Qge2Jvb2xlYW59ICBbT1BUX0RFRkFVTFRfQVVUT19OQU1FID0gdHJ1ZV0gIGlmIHNob291bGQgYmUgdXNlZCBhdXRvIG5hbWUgZ2VuZXJhdG9yXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX0FVVE9fTkFNRSA9IHRydWU7XG5cbi8qKlxuICogIEJhc2ljIGNsYXNzIGZvciB1c2VyIGNvbnRyb2xsZXJcbiAqICBAZXh0ZW5kcyBub3RCYXNlXG4gKi9cbmNsYXNzIG5vdENvbnRyb2xsZXIgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7bnVtYmVyfSBQQVJBTVNfTEVOR1RIICBudW1iZXIgb2YgcGFyYW1zIGluIFVSTCBwYXRoXG4gICAgICovXG4gICAgc3RhdGljIFBBUkFNU19MRU5HVEggPSAyO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtzdHJpbmd9IE1PRFVMRV9OQU1FICBuYW1lIG9mIG1vZHVsZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9EVUxFX05BTUUoKSB7XG4gICAgICAgIHJldHVybiBPUFRfREVGQVVMVF9NT0RVTEVfTkFNRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfTkFNRSAgbmFtZSBvZiBtb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfTkFNRSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTW9kZWxOYW1lXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBMQUJFTFMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbHVyYWw6IGAke09QVF9ERUZBVUxUX01PRFVMRV9OQU1FfTptb2RlbF9sYWJlbF9wbHVyYWxgLFxuICAgICAgICAgICAgc2luZ2xlOiBgJHtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRX06bW9kZWxfbGFiZWxfc2luZ2xlYCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlICAgIHtvYmplY3R8bnVsbH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIGVscztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlICAgIHtvYmplY3R8bnVsbH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIG1ha2U7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSAgICB7bnVsbHxpbXBvcnQoJy4vYXBwLmpzJykuZGVmYXVsdH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIGFwcDtcbiAgICAvKipcbiAgICAgKiAgQGNsYXNzXG4gICAgICogIEBwYXJhbSB7aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9IGFwcFxuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgIG5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5hcHAuc2V0Q3VycmVudENvbnRyb2xsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcmVhZHk6IGZhbHNlLFxuICAgICAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICAgICAgbGliczoge30sXG4gICAgICAgICAgICBoZWxwZXJzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHt9KTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IE9QVF9ERUZBVUxUX01PRFVMRV9OQU1FLFxuICAgICAgICAgICAgY29udGFpbmVyU2VsZWN0b3I6IE9QVF9ERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUixcbiAgICAgICAgICAgIHByZWZpeDogYXBwLmdldE9wdGlvbnMoXCJwYXRocy5tb2R1bGVcIiksXG4gICAgICAgICAgICBuYW1lczoge1xuICAgICAgICAgICAgICAgIHBsdXJhbDogT1BUX0RFRkFVTFRfUExVUkFMX05BTUUsXG4gICAgICAgICAgICAgICAgc2luZ2xlOiBPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFVSTFByZWZpeChhcHAuZ2V0T3B0aW9ucyhcInJvdXRlci5yb290XCIpKTtcbiAgICAgICAgLypcbiAgICAgINGB0YDQsNC30YMg0LTQtdC70LDQtdC8INC00L7RgdGC0YPQv9C90YvQvNC4INC80L7QtNC10LvQuCBub3RSZWNvcmQg0LjQtyBuY2BDb250cm9sbGVyTmFtZWAg0LHRg9C00YPRgiDQtNC+0YHRgtGD0L/QvdGLINC60LDQuiB0aGlzLm5yYE1vZGVsTmFtZWBcbiAgICAqL1xuICAgICAgICBsZXQgaW50ZXJmYWNlcyA9IGFwcC5nZXRJbnRlcmZhY2VzKCk7XG4gICAgICAgIHRoaXMubWFrZSA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0IGluIGludGVyZmFjZXMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGludGVyZmFjZXMsIHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlW3RdID0gaW50ZXJmYWNlc1t0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCB1aU5hbWUgaW4gdGhpcy51aSkge1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXS5kZXN0cm95ICYmIHRoaXMudWlbdWlOYW1lXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51aVt1aU5hbWVdLiRkZXN0cm95ICYmIHRoaXMudWlbdWlOYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVscyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1ha2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgY3VycmVudCBub3RBcHBcbiAgICAgKiAgQHJldHVybiB7aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZ2V0QXBwKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIGRlZmF1bHQgY29udHJvbGxlciBtb2RlbFxuICAgICAqICBAcGFyYW0ge2ltcG9ydCgnLi9yZWNvcmQuanMnKX0gIG1vZGVsICBub3RSZWNvcmQgaW50ZXJmYWNlIG9iamVjdFxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVsXCIsIG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIElmIHplcm8gb3Igb25lIGFyZ3VtZW50IHByb3ZpZGVkIHRoaXMgbW9kZWxOYW1lIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiAgSWYgdHdvIHByb3ZpZGVkIGFuZCBmaXJzdCBpcyBhIHN0cmluZyB0aGFuIGluc3RhbmNlIG9mIG5hbWUgd2lsbCBiZSByZXR1cm5lZCBpbml0aWFsaXplZCB3aXRoIHNlY29uZCBvYmplY3QgcGFyYW0gb3IgZW1wdHkgb2JqZWN0XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICBbbmFtZV0gICAgbW9kZWxOYW1lIG9mIGluc3RhbmNlIHRvIHJldHVybiBvciBpbml0aWFsIGRhdGEgZm9yIGluc3RhbmNlXG4gICAgICogIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICBbZGF0YV0gICAgbW9kZWwgZGF0YVxuICAgICAqICBAcmV0dXJuIHtpbXBvcnQoJy4vcmVjb3JkLmpzJykuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBnZXRNb2RlbChuYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgaW50ID0gdGhpcy5nZXRJbnRlcmZhY2UobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50ICYmIGludChkYXRhIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGludCA9IHRoaXMuZ2V0SW50ZXJmYWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ICYmIGludChuYW1lIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbGxlciBpbnRlcmZhY2UgaWYgbmFtZSBpcyBub3Qgc3BlY2lmaWVkIG9yIGludGVyZmFjZSBvZiBzcGVjaWZpZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1cIlwiXVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2UobmFtZSA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwPy5nZXRJbnRlcmZhY2UobmFtZSB8fCB0aGlzLmdldE1vZGVsTmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBjdXJyZW50IG1vZGVsIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vZGVsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm1vZGVsTmFtZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgZGVmYXVsdCBjb250cm9sbGVyIG1vZGVsIG5hbWVcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICBtb2RlbE5hbWUgIG5vdFJlY29yZCBpbnRlcmZhY2Ugb2JqZWN0XG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9XG4gICAgICovXG4gICAgc2V0TW9kZWxOYW1lKG1vZGVsTmFtZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlbE5hbWVcIiwgbm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIobW9kZWxOYW1lKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGN1cnJlbnQgbW9kZWwgcHJpbWFyeSBJRCBmaWVsZCBuYW1lXG4gICAgICogIEByZXR1cm4ge2ltcG9ydCgnLi9yZWNvcmQuanMnKX1cbiAgICAgKi9cbiAgICBnZXRNb2RlbElERmllbGROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibW9kZWxJREZpZWxkTmFtZVwiLCBcIl9pZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBjdXJyZW50IG1vZGVsIHByaW1hcnkgSUQgZmllbGQgbmFtZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsSURGaWVsZE5hbWUodmFsID0gXCJfaWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKFwibW9kZWxJREZpZWxkTmFtZVwiLCB2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBNYXJrcyB0aGlzIGNvbnRyb2xsZXIgYXMgcmVhZHlcbiAgICAgKiAgZW1pdHMgXCJyZWFkeVwiL1wiYnVzeVwiIGV2ZW50c1xuICAgICAqICBAcGFyYW0ge0Jvb2xlYW59ICB2YWwgIHRydWUvZmFsc2VcbiAgICAgKi9cbiAgICBzZXRSZWFkeSh2YWwgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJlYWR5XCIsIHZhbCk7XG4gICAgICAgIHZhbCA/IHRoaXMuZW1pdChcInJlYWR5XCIpIDogdGhpcy5lbWl0KFwiYnVzeVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBtb2R1bGUgVVJMIHByZWZpeFxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmFsIFVSTCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldFVSTFByZWZpeCh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidXJsUHJlZml4XCIsIHZhbCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXV0b05hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIHVybCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiAge3N0cmluZ30gcHJlZml4XG4gICAgICovXG4gICAgZ2V0VVJMUHJlZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwidXJsUHJlZml4XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIG1vZHVsZSBuYW1lXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgbmFtZSBvZiB0aGUgbW9kdWxlXG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRNb2R1bGVOYW1lKHZhbCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJtb2R1bGVOYW1lXCIsIG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHZhbCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1dG9OYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBtb2R1bGUgbmFtZVxuICAgICAqICBAcmV0dXJuICB7c3RyaW5nfSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldE1vZHVsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJtb2R1bGVOYW1lXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kdWxlIHBhdGggcHJlZml4XG4gICAgICogIEByZXR1cm4ge3N0cmluZ30gIHBhdGggdG8gbW9kdWxlIGRpclxuICAgICAqL1xuICAgIGdldE1vZHVsZVByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRPcHRpb25zKFwicGF0aHMubW9kdWxlc1wiKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICBdLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kZWwgVVJMIHdpdGggVVJMIHByZWZpeFxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9ICB1cmwgcGF0aFxuICAgICAqL1xuICAgIGdldE1vZGVsVVJMKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhpcyBtb2RlbCBhY3Rpb24gVVJMIHdpdGggVVJMIHByZWZpeFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBpZCAgICAgICBzb21lIGlkZW50aWZpY2F0b3Igb2YgbW9kZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgYWN0aW9uICAgYWN0aW9uIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfSAgdXJsIHBhdGhcbiAgICAgKi9cbiAgICBnZXRNb2RlbEFjdGlvblVSTChpZCwgYWN0aW9uID0gXCJcIikge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHVybCBmcm9tIHZhbHVlIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIHZhbFxuICAgICAqKi9cbiAgICBidWlsZFVSTCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5idWlsZFVSTCh2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBVcGRhdGVzIHdvcmtpbmcgbmFtZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfSB0aGlzXG4gICAgICovXG4gICAgdXBkYXRlQXV0b05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvTmFtZVwiLCBPUFRfREVGQVVMVF9BVVRPX05BTUUpKSB7XG4gICAgICAgICAgICAvL3RoaXMuc2V0V29ya2luZygnbmFtZScsIHRoaXMuZ2V0TW9kZWxVUkwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgb2JqZWN0IG5hbWVcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBuYW1lIG9mIHRoZSBvYmplY3RcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldE5hbWUodmFsKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm5hbWVcIiwgdmFsKTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwiYXV0b05hbWVcIiwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgR2V0cyBvYmplY3QgbmFtZVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFByZWxvYWQgcmVjb3JkcyBmcm9tIHNlcnZlciwgdXNpbmcgbGlzdEFsbCBtZXRob2QsXG4gICAgICogIHJldHVybnMgUHJvbWlzZVxuICAgICAqICBAcGFyYW0ge29iamVjdH0gIGxpc3QgIG1hcCBvZiBwcmVsb2FkZWQgcmVjb3Jkc1xuICAgICAqICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHByZWxvYWRMaWIobGlzdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcImxvYWRpbmdcIiwgW10pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLnB1c2gobGlzdFt0XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVtsaXN0W3RdXSh7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC4kbGlzdEFsbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRPcHRpb25zKFwibGlic1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJsaWJzXCIsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwibGlic1wiKVt0XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmluZGV4T2YobGlzdFt0XSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ya2luZyhcImxvYWRpbmdcIikuaW5kZXhPZihsaXN0W3RdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0V29ya2luZyhcImxvYWRpbmdcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbWl0cyBhZnRlclJlbmRlciBldmVudFxuICAgICAqL1xuICAgIG9uQWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImFmdGVyUmVuZGVyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBUcmFuc2Zvcm0gcm91dGUgbmFtZSBpbiBhY3Rpb24gbmFtZVxuICAgICAqICBAcGFyYW0ge1N0cmluZ30gICBuYW1lIHRyYW5mb3JtIGFjdGlvbiBuYW1lXG4gICAgICogIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBY3Rpb25OYW1lKG5hbWUgPSBPUFRfREVGQVVMVF9BQ1RJT05fTkFNRSkge1xuICAgICAgICByZXR1cm4gXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEdldCBkZWZhdWx0IGNvbnRyb2xsZXIgYWN0aW9uIG5hbWVcbiAgICAgKiAgQHJldHVybiB7U3RyaW5nfSBkZWZhdWx0IGFjdGlvbiBmcm9tIG9wdGlvbnNcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0QWN0aW9uTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9uTmFtZShcbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImRlZmF1bHRBY3Rpb25cIiwgT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJvdXRlIHBhcmFtcyBpbnRvIHNwZWNpZmljIHJ1bltSb3V0ZV9uYW1lXSBmdW5jdGlvblxuICAgICAqICBAcGFyYW0ge2FycmF5fSAgIHBhcmFtcyAgIGNvbnRyb2xsZXIgaW5wdXQgcGFyYW1zXG4gICAgICogIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICByb3V0ZShwYXJhbXMpIHtcbiAgICAgICAgbGV0IFtyb3V0ZXJOYW1lLCAuLi5zdWJQYXJhbXNdID0gcGFyYW1zLFxuICAgICAgICAgICAgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0QWN0aW9uTmFtZShcbiAgICAgICAgICAgICAgICByb3V0ZXJOYW1lID8gcm91dGVyTmFtZSA6IE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FXG4gICAgICAgICAgICApO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbYWN0aW9uTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgdGhpc1thY3Rpb25OYW1lXShzdWJQYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbdGhpcy5nZXREZWZhdWx0QWN0aW9uTmFtZSgpXSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50QWN0aW9uKHRoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKSk7XG4gICAgICAgICAgICB0aGlzW3RoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKV0oc3ViUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudEFjdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKFwiTm8gYWN0aW9uIGluIHJvdXRlclwiLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3b3JraW5nIGFjdGlvblxuICAgICAqIEBwYXJhbXMge3N0cmluZ30gYWN0aW9uTmFtZSBjdXJyZW50IGFjdGlvbiBuYW1lXG4gICAgICovXG4gICAgc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImFjdGlvblwiLCBhY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdvcmtpbmcgYWN0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3VycmVudCBhY3Rpb24gbmFtZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRBY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJhY3Rpb25cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRBcHBPcHRpb25zKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBtb2R1bGUgb3B0aW9uc1xuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgW21vZHVsZU5hbWVdICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBvcHRpb25zIHJlcXVlc3RlZFxuICAgICAqICBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cbiAgICBnZXRNb2R1bGVPcHRpb25zKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcCgpLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgW1wibW9kdWxlc1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIHNlcnZpY2VzXG4gICAgICogIEBwYXJhbSAge3N0cmluZ30gICBtb2R1bGVOYW1lICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBzZXJ2aWNlcyByZXF1ZXN0ZWRcbiAgICAgKiAgQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgZ2V0U2VydmljZXMobW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJzZXJ2aWNlc1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIGNvbXBvbmVudHNcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgIG1vZHVsZU5hbWUgICAgbmFtZSBvZiB0aGUgbW9kdWxlIHdoaWNoIGNvbXBvbmVudHMgcmVxdWVzdGVkXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuICAgIGdldENvbXBvbmVudHMobW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJjb21wb25lbnRzXCIsIG1vZHVsZU5hbWUgfHwgdGhpcy5nZXRNb2R1bGVOYW1lKCldLmpvaW4oXCIuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmcmVzaGVzIGN1cnJlbnQgVVJMLCByZS1ydW4gYWxsIGFjdGlvblxuICAgICAqICBAcGFyYW0ge251bWJlcn0gdGltZW91dCB0aW1lIHRvIHdhaXQgaW4gbXNcbiAgICAgKi9cbiAgICByZWZyZXNoKHRpbWVvdXQgPSAwKSB7XG4gICAgICAgIHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpLnJlZnJlc2godGltZW91dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwYXRoIHBhdHRlcm4gZm9yIHJvdXRlclxuICAgICAqIEBwYXJhbXMge251bWJlcn0gWzBdIHBhcmFtc0NvdW50ICAgbnVtYmVyIG9mIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIHBhdHRlcm4gZm9yIGNvbnRyb2xsZXIgc3VwcG9ydGVkIHVybFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb250cm9sbGVyUm91dGUocGFyYW1zQ291bnQgPSAwKSB7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGlmICh0aGlzLk1PRFVMRV9OQU1FICYmIHRoaXMuTU9EVUxFX05BTUUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHRoaXMuTU9EVUxFX05BTUUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5NT0RFTF9OQU1FICYmIHRoaXMuTU9ERUxfTkFNRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIodGhpcy5NT0RFTF9OQU1FKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IFtwYXRoLmpvaW4oXCIvXCIpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCIvKFteL10rKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGF0aCBwYXR0ZXJucyBmb3Igcm91dGVyXG4gICAgICogQHBhcmFtcyB7bnVtYmVyfSBbMF0gcGFyYW1zRGVlcCAgIGhvdyBtYW55IHBhdGhzIHdpdGggcGFyYW1zIGluIHRoZSBlbmRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gIHBhdHRlcm5zIGZvciBjb250cm9sbGVyIHN1cHBvcnRlZCB1cmwgaW4gb3JkZXIgb2Ygc2ltcGxpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29udHJvbGxlclJvdXRlcyhwYXJhbXNEZWVwID0gMCkge1xuICAgICAgICBsZXQgcm91dGVzID0gW3RoaXMuZ2V0Q29udHJvbGxlclJvdXRlKDApXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXNEZWVwOyBpKyspIHtcbiAgICAgICAgICAgIHJvdXRlcy51bnNoaWZ0KHRoaXMuZ2V0Q29udHJvbGxlclJvdXRlKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJvdXRlciBydWxlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJvdXRlciBydWxlIHtwYXRoczpTdHJpbmdbXSwgY29udHJvbGxlcjpub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoczogdGhpcy5nZXRDb250cm9sbGVyUm91dGVzKHRoaXMuUEFSQU1TX0xFTkdUSCksXG4gICAgICAgICAgICBjb250cm9sbGVyOiB0aGlzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQXBwbGljYXRpb24gcm91dGVyXG4gICAgICogQHJldHVybnMge2ltcG9ydCgnLi9yb3V0ZXIuanMnKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIGdldFJvdXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgbG9jYXRpb24gdG8gYHVybGAgYWZ0ZXIgYGRlbGF5YCBtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICAgZGVsYXkgICBudW1iZXIgaW4gbXMgb3IgbmFtZSBvZiBkZWxheVxuICAgICAqL1xuICAgIG5hdmlnYXRlV2l0aERlbGF5KFxuICAgICAgICB1cmwsXG4gICAgICAgIGRlbGF5ID0gTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxULFxuICAgICAgICBkb0JlZm9yZSA9ICgpID0+IHt9XG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvdXRlcigpLm5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksIGRvQmVmb3JlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGxvY2F0aW9uIHRvIGB1cmxgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIG5hdmlnYXRlKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZSh1cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBOYXZpZ2F0aW5nIHRvIHRoaXMgY29udHJvbGxlciBtYWluIG1vZGVsIGBhY3Rpb25gIHdpdGggcHJvdmlkZWQgYGlkYCxcbiAgICAgKiAgZW1wdHkgYGlkYCB3aWxsIGJlIGRyb3BwZWQgZnJvbSByZXN1bHRpbmcgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZUFjdGlvbihpZCwgYWN0aW9uID0gXCJcIiwgZGVsYXkgPSAwLCBkb0JlZm9yZSA9ICgpID0+IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlTW9kdWxlQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICB0aGlzLmdldE1vZGVsTmFtZSgpLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE5hdmlnYXRpbmcgdG8gdGhpcyBjb250cm9sbGVyIG1vZHVsZSBtb2RlbCBvZiBgbW9kZWxOYW1lYCBgYWN0aW9uYCB3aXRoIHByb3ZpZGVkIGBpZGAsXG4gICAgICogIGVtcHR5IGBpZGAgd2lsbCBiZSBkcm9wcGVkIGZyb20gcmVzdWx0aW5nIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uPVwiXCJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSAgICAgICAgICAgIGRlbGF5IGluIG1zIGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gIFtkb0JlZm9yZV0gICAgICB3aWxsIGV4ZWN1dGVkIG9ubHkgaWYgZGVsYXllZCBhZnRlciBkZWxheSBidXQgYmVmb3JlIG5hdmlnYXRlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIG5hdmlnYXRlTW9kZWxBY3Rpb24oXG4gICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGlvbiA9IFwiXCIsXG4gICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgZG9CZWZvcmUgPSAoKSA9PiB7fVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE5hdmlnYXRpbmcgdG8gYG1vZHVsZU5hbWVgIGBtb2RlbE5hbWVgIGBhY3Rpb25gIHdpdGggcHJvdmlkZWQgYGlkYCxcbiAgICAgKiAgZW1wdHkgYGlkYCB3aWxsIGJlIGRyb3BwZWQgZnJvbSByZXN1bHRpbmcgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICBpZCxcbiAgICAgICAgYWN0aW9uID0gXCJcIixcbiAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICBkb0JlZm9yZSA9ICgpID0+IHt9XG4gICAgKSB7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVyKCkubmF2aWdhdGVXaXRoRGVsYXkoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiB0aGlzLmdldFVSTFByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICAgICAgZG9CZWZvcmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZShcbiAgICAgICAgICAgICAgICBub3RDb21tb24uYnVpbGRVUkwoe1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHRoaXMuZ2V0VVJMUHJlZml4KCksXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWVudSBpdGVtIGZyb20gY2hpbGQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge25vdENvbnRyb2xsZXJ9IGNoaWxkQ29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5OYXZpZ2F0aW9uSXRlbT59XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29tbW9uTWVudShjaGlsZENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHNlY3Rpb246IGNoaWxkQ29uc3RydWN0b3IuTU9EVUxFX05BTUUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGlsZENvbnN0cnVjdG9yLkxBQkVMUy5wbHVyYWwsXG4gICAgICAgICAgICAgICAgdXJsOiBgLyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb25zdHJ1Y3Rvci5NT0RVTEVfTkFNRVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgKX0vJHtub3RDb21tb24ubG93ZXJGaXJzdExldHRlcihjaGlsZENvbnN0cnVjdG9yLk1PREVMX05BTUUpfWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNZW51KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q29udHJvbGxlcjtcbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBBTEwgPSB7fTtcblxuZnVuY3Rpb24gZXhpc3Qoa2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd24oQUxMLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGV4aXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIEFMTFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShcbiAgICBrZXksXG4gICAgcHJvcHMgPSB7XG4gICAgICAgIHJhdzogW10sXG4gICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgIH1cbikge1xuICAgIGlmICghZXhpc3Qoa2V5KSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIEFMTFtrZXldID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFMTFtrZXldW25hbWVdID0gd3JpdGFibGUocHJvcHNbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdG9yZSdzIHByb3BzIHdhc24ndCBzcGVjaWZpZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFMTFtrZXldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgb2JqZWN0IHRoYXQgaXMgZmFrZSBTdG9yZVxuICogU29tZSB0aW1lIHRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBsb2NhbCB2YXIsXG4gKiBiZWZvcmUgeW91IGNvdWxkIGdldCBhY3R1YWwgU3RvcmVzIGZyb20gY2VudHJhbCBzdG9yYWdlIGJ5IGl0cyBJRFxuICpcdEBwYXJhbXMge21peGVkfSB2YWwgXHRkYXRhIG9mIHR5cGUgdGhhdCBpcyBhY3R1YWwgc3RvcmFnZSB3aWxsIGNvbnRhaW5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmFrZSh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZikge1xuICAgICAgICAgICAgZih2YWwpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7fSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGUsIGdldCwgZmFrZSB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0ICdidWxtYS1zd2l0Y2gnO1xuXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHlsaW5nXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgaWQgPSAnJyxcbiAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgIGZpZWxkbmFtZSA9ICdzd2l0Y2gnLFxuICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICBzdHlsaW5nID0gXCIgaXMtcm91bmRlZCBpcy1zdWNjZXNzIFwiXG4gIH0gPSAkcHJvcHMoKTtcblxuZnVuY3Rpb24gb25JbnB1dChldil7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICB2YWx1ZTogZXYudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcgPyBldi50YXJnZXQuY2hlY2tlZDpldi50YXJnZXQudmFsdWVcbiAgICB9O1xuICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCBkYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuPC9zY3JpcHQ+XG5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICBjbGFzcz1cInN3aXRjaCB7c3R5bGluZ31cIlxuICBpZD1cImVkaXQtdGFibGUtcm93LWNlbGwtaW5saW5lLXN3aXRjaC17ZmllbGRuYW1lfS17aWR9XCJcbiAgYmluZDpjaGVja2VkPXt2YWx1ZX1cbiAgbmFtZT1cIntmaWVsZG5hbWV9XCJcbiAge3JlYWRvbmx5fSB7ZGlzYWJsZWR9XG4gIG9uaW5wdXQ9e29uSW5wdXR9XG4gIC8+XG48bGFiZWwgY2xhc3M9XCJsYWJlbFwiIGZvcj1cImVkaXQtdGFibGUtcm93LWNlbGwtaW5saW5lLXN3aXRjaC17ZmllbGRuYW1lfS17aWR9XCI+PC9sYWJlbD5cbiIsIjxzY3JpcHQ+XG4gICAgLypcbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcbiAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG4qL1xuICAgIFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge2FueX0gW3ZhbHVlc10gLSBpdGVtID0ge1xuaWQsICAgICAgICAvL3VuaXF1ZVxudGl0bGUsICAgICAvL3NvbWUgdGV4dFxudmFsdWUsICAgICAgLy9mb3IgZG91YmxlIHRhZ3NcbmNvbG9yICAgICAgIC8vY29sb3Jpbmdcbn1cbiAgICovXG5cbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgbGV0IHsgdmFsdWVzID0gW10gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjZWFjaCB2YWx1ZXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgeyNpZiBPYmplY3QuaGFzT3duKGl0ZW0sIFwidmFsdWVcIil9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJteC0xIHRhZ3MgaGFzLWFkZG9uc1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWdcIj57aXRlbS50aXRsZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRhZyBpcy17aXRlbS5jb2xvcn0ge2l0ZW0uY3VzdG9tQ2xhc3Nlc31cIj5cbiAgICAgICAgICAgICAgICB7I2lmIGl0ZW0udXJsfVxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPXtpdGVtLnVybH0gY2xhc3M9e2l0ZW0udXJsQ3VzdG9tQ2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgID57aXRlbS52YWx1ZX08L2FcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAge2l0ZW0udmFsdWV9XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgezplbHNlfVxuICAgICAgICA8c3BhbiBjbGFzcz1cIm14LTEgdGFnIGlzLXtpdGVtLmNvbG9yfSB7aXRlbS5jdXN0b21DbGFzc2VzfVwiPlxuICAgICAgICAgICAgeyNpZiBpdGVtLnVybH1cbiAgICAgICAgICAgICAgICA8YSBocmVmPXtpdGVtLnVybH0gY2xhc3M9e2l0ZW0udXJsQ3VzdG9tQ2xhc3Nlc30+e2l0ZW0udGl0bGV9PC9hXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHtpdGVtLnRpdGxlfVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9zcGFuPlxuICAgIHsvaWZ9XG57L2VhY2h9XG5cbjxzdHlsZT5cbiAgICAudGFnczpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgbGV0IHRpdGxlID0gJHN0YXRlKFwiXCIpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGQudHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsIFwidGl0bGVQYXRoXCIpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBub3RQYXRoLmdldChmaWVsZC50aXRsZVBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBPYmplY3QuaGFzT3duKGZpZWxkLCBcInRpdGxlQ29tcG9zZXJcIikgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZmllbGQudGl0bGVDb21wb3NlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGZpZWxkLnRpdGxlQ29tcG9zZXIoaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gbm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlua3MgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xpbmsvdWkubGlua3Muc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2VzIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9pbWFnZS91aS5pbWFnZXMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQm9vbGVhbnMgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuYm9vbGVhbnMuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVGFibGVTd2l0Y2ggZnJvbSBcIi4vY29udHJvbHMvdWkuc3dpdGNoLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBUYWJsZVRhZ3MgZnJvbSBcIi4vY29udHJvbHMvdWkudGFncy5zdmVsdGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIGdldEl0ZW1JZCA9IChpdGVtKSA9PiBpdGVtLl9pZCxcbiAgICAgICAgZmllbGQgPSB7fSxcbiAgICAgICAgaXRlbSA9IHt9LFxuICAgICAgICBoZWxwZXJzID0ge31cbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHRkXG4gICAgY2xhc3M9eyhmaWVsZC5oaWRlT25Nb2JpbGUgPyBcIiBpcy1oaWRkZW4tdG91Y2ggXCIgOiBcIlwiKSArXG4gICAgICAgIChmaWVsZC5jbGFzc2VzID8gYCAke2ZpZWxkLmNsYXNzZXN9IGAgOiBcIlwiKX1cbiAgICB7dGl0bGV9XG4+XG4gICAgeyNpZiBmaWVsZC50eXBlID09PSBcImxpbmtcIn1cbiAgICAgICAgPFVJTGlua3MgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJidXR0b25cIn1cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcImltYWdlXCJ9XG4gICAgICAgIDxVSUltYWdlcyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcImJvb2xlYW5cIn1cbiAgICAgICAgPFVJQm9vbGVhbnMgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJ0YWdcIn1cbiAgICAgICAgPFRhYmxlVGFncyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcInN3aXRjaFwifVxuICAgICAgICA8VGFibGVTd2l0Y2hcbiAgICAgICAgICAgIGlkPXtnZXRJdGVtSWQoaXRlbSl9XG4gICAgICAgICAgICBmaWVsZG5hbWU9e2ZpZWxkLnBhdGh9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgdmFsdWU9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfVxuICAgICAgICAgICAgcmVhZG9ubHk9e2ZpZWxkLnJlYWRvbmx5fVxuICAgICAgICAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC5jb21wb25lbnR9XG4gICAgICAgIDxmaWVsZC5jb21wb25lbnRcbiAgICAgICAgICAgIGlkPXtnZXRJdGVtSWQoaXRlbSl9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgZmllbGRuYW1lPXtmaWVsZC5wYXRofVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfVxuICAgICAgICAgICAgcmVhZG9ubHk9e2ZpZWxkLnJlYWRvbmx5fVxuICAgICAgICAgICAgdmFsdWU9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfVxuICAgICAgICAgICAgey4uLmZpZWxkLm9wdGlvbnN9XG4gICAgICAgIC8+XG4gICAgezplbHNlIGlmIGZpZWxkICYmIHR5cGVvZiBmaWVsZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNOYU4oZmllbGQubWF4TGVuZ3RoKSAmJiBmaWVsZC5tYXhMZW5ndGh9XG4gICAgICAgIHtub3RDb21tb24uc3RyTGVuZ3RoQ2FwKFxuICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyksXG4gICAgICAgICAgICBmaWVsZC5tYXhMZW5ndGhcbiAgICAgICAgKX1cbiAgICB7OmVsc2V9XG4gICAgICAgIHskTE9DQUxFW25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpXX1cbiAgICB7L2lmfVxuPC90ZD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBVSVRhYmxlQ2VsbCBmcm9tICcuL25vdFRhYmxlQ2VsbC5zdmVsdGUnO1xuICBpbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSAnLi9zdG9yZXMuanMnO1xuICBcbiAgaW1wb3J0IHtvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXJ9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGxldCBpdGVtSWQgPSAkc3RhdGUoKSwgc2VsZWN0ZWRMaXN0O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgICAgaXRlbUlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgc2VsZWN0ZWRMaXN0ID0gU3RvcmVzLmdldChpZCkuc2VsZWN0ZWQ7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBpZFxuICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbaGVscGVyc11cbiAgICogQHByb3BlcnR5IHthbnl9IFtmaWVsZHNdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dTZWxlY3RdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbUlkXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgaWQsXG4gICAgICBpdGVtID0ge30sXG4gICAgICBoZWxwZXJzID0ge30sXG4gICAgICBmaWVsZHMgPSBbXSxcbiAgICAgIHNob3dTZWxlY3QgPSBmYWxzZSxcbiAgICAgIGdldEl0ZW1JZCA9ICgpPT57fVxuICB9ID0gJHByb3BzKCk7XG5cbiAgZnVuY3Rpb24gb25Sb3dTZWxlY3QoZSl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNwYXRjaCgncm93U2VsZWN0Q2hhbmdlJywge1xuICAgICAgICAgIGlkOiAgICAgICBpdGVtSWQsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICRzZWxlY3RlZExpc3RbaXRlbUlkXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG48L3NjcmlwdD5cblxuPHRyPlxuICB7I2lmIHNob3dTZWxlY3QgJiYgJHNlbGVjdGVkTGlzdCB9XG4gIDx0ZD5cbiAgICA8aW5wdXQgaWQ9XCJ0YWJsZS1yb3ctc2VsZWN0LXtnZXRJdGVtSWQoaXRlbSl9XCIgdHlwZT1cImNoZWNrYm94XCIgZGF0YS1pZD1cIntnZXRJdGVtSWQoaXRlbSl9XCIgYmluZDpjaGVja2VkPXskc2VsZWN0ZWRMaXN0W2l0ZW1JZF19IHBsYWNlaG9sZGVyPVwiXCIgbmFtZT1cInJvd19zZWxlY3RlZF97Z2V0SXRlbUlkKGl0ZW0pfVwiIG9uY2hhbmdlPXtvblJvd1NlbGVjdH0gLz5cbiAgPC90ZD5cbiAgey9pZn1cbiAgeyNlYWNoIGZpZWxkcyBhcyBmaWVsZCB9XG4gIDxVSVRhYmxlQ2VsbCB7ZmllbGR9IHtoZWxwZXJzfSB7aXRlbX0ge2dldEl0ZW1JZH0gLz5cbiAgey9lYWNofVxuPC90cj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0ICogYXMgU3RvcmVzIGZyb20gXCIuL3N0b3Jlcy5qc1wiO1xuXG4gICAgaW1wb3J0IFVJVGFibGVSb3cgZnJvbSBcIi4vbm90VGFibGVSb3cuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUxpbmtzIH0gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xpbmtcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbnMgfSBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvYnV0dG9uXCI7XG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLmZvbnQuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBpZFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaWx0ZXJVSVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaGVscGVyc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZmllbGRzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VsZWN0ZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaW5rc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93U2VhcmNoXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dTZWxlY3RdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2VsZWN0QWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbUlkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCxcbiAgICAgICAgZmlsdGVyVUksXG4gICAgICAgIGhlbHBlcnMgPSB7fSxcbiAgICAgICAgc3RhdGUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWx0ZXIgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBzb3J0ZXIgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWVsZHMgPSBbXSxcbiAgICAgICAgc2VsZWN0ZWQgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBpdGVtcyA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgc2VhcmNoID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBzaG93U2VhcmNoID0gdHJ1ZSxcbiAgICAgICAgc2hvd1NlbGVjdCA9IHRydWUsXG4gICAgICAgIHNlbGVjdEFsbCA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIGdldEl0ZW1JZCA9IChpdGVtKSA9PiBpdGVtLl9pZCxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHNob3dTZWxlY3QpIHtcbiAgICAgICAgICAgIFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgU3RvcmVzLmdldChpZCkucmVmaW5lZC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpdGVtcyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHNob3dTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtSWQgaW4gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcy5zb21lKChpdGVtKSA9PiBnZXRJdGVtSWQoaXRlbSkgPT09IGl0ZW1JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFtpdGVtSWRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHNlbGVjdGVkLCBpdGVtSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbaXRlbUlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBTdG9yZXMuZ2V0KGlkKS5zdGF0ZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uU2VhcmNoSW5wdXQoZXYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZXYuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBkaXNwYXRjaChcInNlYXJjaENoYW5nZVwiLCBkYXRhKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblNlYXJjaENoYW5nZSh7IGRldGFpbCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChcInNlYXJjaENoYW5nZVwiLCBkZXRhaWwpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRmlsdGVyQ2hhbmdlKHsgZGV0YWlsIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKFwiZmlsdGVyQ2hhbmdlXCIsIGRldGFpbCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29QcmV2KCkge1xuICAgICAgICBkaXNwYXRjaChcImdvVG9QcmV2UGFnZVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb05leHQoKSB7XG4gICAgICAgIGRpc3BhdGNoKFwiZ29Ub05leHRQYWdlXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvVG8oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBlbCA9IGUudGFyZ2V0O1xuICAgICAgICBkaXNwYXRjaChcImdvVG9QYWdlXCIsIHBhcnNlSW50KGVsLmRhdGFzZXQucGFnZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TZWxlY3RBbGwoKSB7XG4gICAgICAgIFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkLnVwZGF0ZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtnZXRJdGVtSWQoaXRlbSldID0gc2VsZWN0QWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRmllbGRIZWFkQ2xpY2soZmllbGQpIHtcbiAgICAgICAgY29uc3QgcHJvcFBhdGggPSBmaWVsZC5wYXRoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oc29ydGVyLCBwcm9wUGF0aCkpIHtcbiAgICAgICAgICAgIHNvcnRlcltwcm9wUGF0aF0gPSBwYXJzZUludChzb3J0ZXJbcHJvcFBhdGhdKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydGVyID0ge1xuICAgICAgICAgICAgICAgIFtwcm9wUGF0aF06IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKFwic29ydGVyQ2hhbmdlXCIsIHNvcnRlcik7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgbGlua3MubGVuZ3RofVxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZCBpcy1ncm91cGVkXCI+XG4gICAgICAgIDxVSUxpbmtzIHZhbHVlcz17bGlua3N9IC8+XG4gICAgPC9kaXY+XG57L2lmfVxueyNpZiBhY3Rpb25zLmxlbmd0aH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZFwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17YWN0aW9uc30gLz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG57I2lmIHNob3dTZWFyY2h9XG4gICAgeyNpZiBmaWx0ZXJVSX1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBmaWx0ZXJVSX1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICAgICAgYmluZDpmaWx0ZXJcbiAgICAgICAgICAgIG9uOmNoYW5nZT17b25GaWx0ZXJDaGFuZ2V9XG4gICAgICAgICAgICBvbjpzZWFyY2hDaGFuZ2U9e29uU2VhcmNoQ2hhbmdlfVxuICAgICAgICAvPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cItCf0L7QuNGB0LpcIlxuICAgICAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtzZWFyY2h9XG4gICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9e29uU2VhcmNoSW5wdXR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuey9pZn1cbjx0YWJsZSBjbGFzcz1cInRhYmxlXCI+XG4gICAgPHRoZWFkPlxuICAgICAgICA8dHI+XG4gICAgICAgICAgICB7I2lmIHNob3dTZWxlY3R9XG4gICAgICAgICAgICAgICAgPHRoXG4gICAgICAgICAgICAgICAgICAgID48aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cInRhYmxlLXJvdy1zZWxlY3QtcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e3NlbGVjdEFsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyb3dfc2VsZWN0ZWRfYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2hhbmdlPXtvblNlbGVjdEFsbH1cbiAgICAgICAgICAgICAgICAgICAgLz48L3RoXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCBmaWVsZHMgYXMgZmllbGR9XG4gICAgICAgICAgICAgICAge0Bjb25zdCBwcm9wUGF0aCA9IGZpZWxkLnBhdGguc3Vic3RyaW5nKDEpfVxuICAgICAgICAgICAgICAgIDx0aFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz17KGZpZWxkLmhpZGVPbk1vYmlsZSA/IFwiIGlzLWhpZGRlbi10b3VjaFwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZpZWxkLnNvcnRhYmxlID8gXCIgaXMtY2xpY2thYmxlXCIgOiBcIlwiKX1cbiAgICAgICAgICAgICAgICAgICAgb25jbGljaz17b25GaWVsZEhlYWRDbGljayhmaWVsZCl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGZpZWxkLnNvcnRhYmxlICYmIE9iamVjdC5oYXNPd24oc29ydGVyLCBwcm9wUGF0aCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VUlJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udD17c29ydGVyW3Byb3BQYXRoXSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInNvcnQtdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwic29ydC1kb3duXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2ZpZWxkLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50YWJsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHskTE9DQUxFW2ZpZWxkLnRpdGxlXX1cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5PlxuICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5faWQpfVxuICAgICAgICAgICAgPFVJVGFibGVSb3dcbiAgICAgICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICAgICAge2l0ZW19XG4gICAgICAgICAgICAgICAge2ZpZWxkc31cbiAgICAgICAgICAgICAgICB7aGVscGVyc31cbiAgICAgICAgICAgICAgICB7c2hvd1NlbGVjdH1cbiAgICAgICAgICAgICAgICB7Z2V0SXRlbUlkfVxuICAgICAgICAgICAgICAgIG9uOnJvd1NlbGVjdENoYW5nZVxuICAgICAgICAgICAgLz5cbiAgICAgICAgey9lYWNofVxuICAgIDwvdGJvZHk+XG48L3RhYmxlPlxueyNpZiBzdGF0ZT8ucGFnaW5hdGlvbj8ucGFnZXM/Lmxpc3QubGVuZ3RoID4gMX1cbiAgICA8bmF2IGNsYXNzPVwicGFnaW5hdGlvbiBpcy1jZW50ZXJlZFwiIGFyaWEtbGFiZWw9XCJwYWdpbmF0aW9uXCI+XG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XCJwYWdpbmF0aW9uLXByZXZpb3VzXCIgb25jbGljaz17Z29QcmV2fT7QndCw0LfQsNC0PC9hPlxuICAgICAgICA8YSBocmVmIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgb25jbGljaz17Z29OZXh0fT7QktC/0LXRgNC10LQ8L2E+XG4gICAgICAgIDx1bCBjbGFzcz1cInBhZ2luYXRpb24tbGlzdFwiPlxuICAgICAgICAgICAgeyNpZiBzdGF0ZS5wYWdpbmF0aW9uICYmIHN0YXRlLnBhZ2luYXRpb24ucGFnZXMgJiYgc3RhdGUucGFnaW5hdGlvbi5wYWdlcy5saXN0fVxuICAgICAgICAgICAgICAgIHsjZWFjaCBzdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QgYXMgcGFnZX1cbiAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBwYWdlLmFjdGl2ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1saW5rIGlzLWN1cnJlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwi0KHRgtGA0LDQvdC40YbQsCB7cGFnZS5pbmRleH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWN1cnJlbnQ9XCJwYWdlXCI+e3BhZ2UuaW5kZXggKyAxfTwvYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cItCh0YLRgNCw0L3QuNGG0LAge3BhZ2UuaW5kZXh9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1wYWdlPXtwYWdlLmluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtnb1RvfT57cGFnZS5pbmRleCArIDF9PC9hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3VsPlxuICAgIDwvbmF2Plxuey9pZn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIndvbGZ5ODctZXZlbnRlbWl0dGVyXCI7XG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vbi5qc1wiO1xuXG5pbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSBcIi4vc3RvcmVzLmpzXCI7XG5pbXBvcnQgVUlUYWJsZSBmcm9tIFwiLi9ub3RUYWJsZS5zdmVsdGVcIjtcblxuY29uc3QgQ09OU1RfSURfRFVCTElDQVRFX1BPU1RGSVggPSBcIl9fZHVibGljYXRlX19cIjtcblxuY29uc3QgT1BUX0RFRkFVTFRfUEFHRV9TSVpFID0gMjAsXG4gICAgT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVIgPSAwLFxuICAgIE9QVF9ERUZBVUxUX1BBR0VfUkFOR0UgPSA2LFxuICAgIE9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OID0gMSxcbiAgICBPUFRfREVGQVVMVF9TRUFSQ0ggPSBcIlwiLFxuICAgIE9QVF9ERUZBVUxUX1JFVFVSTiA9IHt9LFxuICAgIE9QVF9ERUZBVUxUX0NPTUJJTkVEID0gZmFsc2UsXG4gICAgT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OID0gXCJsaXN0QW5kQ291bnRcIixcbiAgICBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT04gPSBcImNvdW50XCIsXG4gICAgT1BUX0RFRkFVTFRfTElTVF9BQ1RJT04gPSBcImxpc3RcIixcbiAgICBPUFRfREVGQVVMVF9TT1JUX0ZJRUxEID0gXCJfaWRcIixcbiAgICBPUFRfRklFTERfTkFNRV9QUkVfUFJPQyA9IFwicHJlcHJvY2Vzc29yXCI7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1aTogVUlUYWJsZSxcbiAgICBsaW5rczogW10sXG4gICAgYWN0aW9uczogW10sXG4gICAgZW5kbGVzczogZmFsc2UsXG4gICAgaWRGaWVsZDogXCJfaWRcIixcbiAgICBnZXRJdGVtSWQ6IChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLl9pZDtcbiAgICB9LFxufTtcblxuY2xhc3Mgbm90VGFibGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IFwidGFibGUtXCIgKyBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX09QVElPTlMsXG4gICAgICAgICAgICAuLi4oaW5wdXQub3B0aW9ucyA/IGlucHV0Lm9wdGlvbnMgOiB7fSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgICAgIHJlZmluZWQ6IFtdLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2luZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuc3RvcmVzID0gU3RvcmVzLmNyZWF0ZSh0aGlzLmlkLCB7XG4gICAgICAgICAgICByYXc6IFtdLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IFtdLFxuICAgICAgICAgICAgcmVmaW5lZDogW10sXG4gICAgICAgICAgICBzZWxlY3RlZDoge30sXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHdvcmtpbmc6IHRoaXMud29ya2luZyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdG9yZXMud29ya2luZy5zdWJzY3JpYmUodGhpcy5vbldvcmtpbmdVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0L/QvtC70YPRh9C10L3QvdGL0LUg0LjQtyDRgdC10YLQuFxuICAgICAgICB0aGlzLnN0b3Jlcy5yYXcuc3Vic2NyaWJlKHRoaXMub25SYXdVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0L/RgNC40LzQtdC90LXQvdGLINGE0LjQu9GM0YLRgNGLLCDRgdC+0YDRgtC40YDQvtCy0LrQuCDQuCDRgi7QtC5cbiAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQuc3Vic2NyaWJlKHRoaXMub25GaWx0ZXJlZFVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy/Rg9GA0LXQt9Cw0L3RiyDQtNC+INC80LjQvdC40LzQsNC70YzQvdC+0LPQviDQvdCw0LHQvtGA0LAsINGC0L7Rh9C90L4g0YHQvtC+0YLQstC10YHRgtCy0YPRjtGJ0LXQs9C+INGC0LDQsdC70LjRh9C90L7QvNGDINGE0L7RgNC80LDRgtGDXG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQuc3Vic2NyaWJlKHRoaXMub25SZWZpbmVkVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL9GB0LvQvtCy0LDRgNGMINGBINC40LTQtdC90YLQuNGE0LjQutCw0YLQvtGA0LDQvNC4INCy0YvQsdGA0LDQvdC90YvRhSDRgdGC0YDQvtC6XG4gICAgICAgIHRoaXMuc3RvcmVzLnNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLm9uU2VsZWN0ZWRVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vcGFnaW5hdGlvbiwgaXRlbXMgaW5mb3JtYXRpb25cbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUuc3Vic2NyaWJlKHRoaXMub25TdGF0ZVVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhpbnB1dCwgXCJkYXRhXCIpICYmIEFycmF5LmlzQXJyYXkoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLnJhdy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbCA9IGlucHV0LmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDb21iaW5lZEFjdGlvbk5hbWUoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIixcbiAgICAgICAgICAgICAgICBPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT05cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwiZmlsdGVyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpbHRlcih0aGlzLm9wdGlvbnMuZmlsdGVyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwicGFnZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZXIodGhpcy5vcHRpb25zLnBhZ2VyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHRoaXMub3B0aW9ucywgXCJzb3J0ZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ydGVyKHRoaXMub3B0aW9ucy5zb3J0ZXIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNvcnRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwicmV0dXJuXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJldHVybih0aGlzLm9wdGlvbnMucmV0dXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5vcHRpb25zLCBcInNlYXJjaFwiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2godGhpcy5vcHRpb25zLnNlYXJjaCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvbldvcmtpbmdVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblJhd1VwZGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5kYXRhLnJhdyA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvbkZpbHRlcmVkVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRhdGEuZmlsdGVyZWQgPSB2YWw7XG4gICAgICAgIHRoaXMucmVmaW5lRmlsdGVyZWQoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblJlZmluZWRVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5yZWZpbmVkID0gdmFsO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblN0YXRlVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIG9uU2VhcmNoQ2hhbmdlKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2gobGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Tb3J0ZXJDaGFuZ2Uoc29ydGVyKSB7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ydGVyKHNvcnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U29ydGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkZpbHRlckNoYW5nZSh7IGZpbHRlciwgYWN0aW9uTmFtZSB9KSB7XG4gICAgICAgIGlmIChhY3Rpb25OYW1lLmluZGV4T2YoT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21iaW5lZEFjdGlvbk5hbWUoYWN0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2VsZWN0ZWRVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZWxlY3RlZCA9IHZhbDtcbiAgICB9XG5cbiAgICBjbGVhclNlbGVjdGVkKCkge1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0ZWQgPSB7fTtcbiAgICB9XG5cbiAgICBnZXRTZWxlY3RlZChvYmplY3QgPSBmYWxzZSwgc3RvcmUgPSBcInJlZmluZWRcIikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuZGF0YS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5zZWxlY3RlZFtpZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmR4ID0gdGhpcy5kYXRhW3N0b3JlXS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5faWQgPT09IGlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuZGF0YVtzdG9yZV1baW5keF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGdldEl0ZW1JZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJnZXRJdGVtSWRcIiwgREVGQVVMVF9PUFRJT05TLmdldEl0ZW1JZCkoaXRlbSk7XG4gICAgfVxuXG4gICAgc2VsZWN0QWxsKCkge1xuICAgICAgICB0aGlzLnN0b3Jlcy5zZWxlY3RlZC51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ge307XG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlsdGVyZWQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlW3RoaXMuZ2V0SXRlbUlkKGl0ZW0pXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZWN0Tm9uZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc2VsZWN0ZWQudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0aGlzLmdldEl0ZW1JZChpdGVtKV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy51aS50YWJsZSkge1xuICAgICAgICAgICAgdGhpcy51aS50YWJsZSA9IG5ldyB0aGlzLm9wdGlvbnMudWkoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldEVsLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclVJOiB0aGlzLmdldE9wdGlvbnMoXCJmaWx0ZXJVSVwiLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRIZWxwZXJzKCkpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogdGhpcy5nZXRBY3Rpb25zKCksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzOiB0aGlzLmdldExpbmtzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlbGVjdDogdGhpcy5nZXRPcHRpb25zKFwic2hvd1NlbGVjdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlYXJjaDogdGhpcy5nZXRPcHRpb25zKFwic2hvd1NlYXJjaFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NvcnQ6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dTb3J0XCIpLFxuICAgICAgICAgICAgICAgICAgICBpZEZpZWxkOiB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpLFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtSWQ6IHRoaXMuZ2V0T3B0aW9ucyhcImdldEl0ZW1JZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmdldEZpbHRlcigpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcInNlYXJjaENoYW5nZVwiLCAoZSkgPT4gdGhpcy5vblNlYXJjaENoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcInNvcnRlckNoYW5nZVwiLCAoZSkgPT4gdGhpcy5vblNvcnRlckNoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImZpbHRlckNoYW5nZVwiLCAoZSkgPT4gdGhpcy5vbkZpbHRlckNoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImdvVG9QYWdlXCIsIChlKSA9PiB0aGlzLmdvVG9QYWdlKGUuZGV0YWlsKSk7XG4gICAgICAgIHRoaXMudWkudGFibGUuJG9uKFwiZ29Ub05leHRQYWdlXCIsICgpID0+IHRoaXMuZ29Ub05leHQoKSk7XG4gICAgICAgIHRoaXMudWkudGFibGUuJG9uKFwiZ29Ub1ByZXZQYWdlXCIsICgpID0+IHRoaXMuZ29Ub1ByZXYoKSk7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImFjdGlvbnNcIiwgW10pO1xuICAgIH1cblxuICAgIGdldExpbmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibGlua3NcIiwgW10pO1xuICAgIH1cblxuICAgIGdldEhlbHBlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaGVscGVycyB8fCB7fTtcbiAgICB9XG5cbiAgICBzZXRXb3JraW5nKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMud29ya2luZy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgbm90UGF0aC5zZXQoa2V5LCB2YWwsIHRoaXMuZ2V0SGVscGVycygpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V29ya2luZyhrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLndvcmtpbmcsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFN0YXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIG5vdFBhdGguc2V0KGtleSwgdmFsLCB0aGlzLmdldEhlbHBlcnMoKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFN0YXRlKGtleSwgZGVmKSB7XG4gICAgICAgIGxldCByZXMgPSBub3RQYXRoLmdldChrZXksIHRoaXMuc3RhdGUsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldE9wdGlvbnMoa2V5LCB2YWx1ZSkge1xuICAgICAgICBub3RQYXRoLnNldChrZXksIHRoaXMub3B0aW9ucywgdGhpcy5nZXRIZWxwZXJzKCksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucyhrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEZpbHRlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImZpbHRlclwiLCBoYXNoKTtcbiAgICAgICAgaWYgKHdpdGhvdXRJbnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0RmlsdGVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwiZmlsdGVyXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZShcImZpbHRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRQYWdlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInBhZ2VyXCIsIGhhc2gpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRQYWdlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gaXNOYU4odGhpcy5nZXRPcHRpb25zKFwicGFnZXIucGFnZVwiKSlcbiAgICAgICAgICAgID8gT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVJcbiAgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25zKFwicGFnZXIucGFnZVwiKTtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0UGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiBpc05hTih0aGlzLmdldE9wdGlvbnMoXCJwYWdlci5zaXplXCIpKVxuICAgICAgICAgICAgPyBPUFRfREVGQVVMVF9QQUdFX1NJWkVcbiAgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25zKFwicGFnZXIuc2l6ZVwiKTtcbiAgICB9XG5cbiAgICByZXNldFBhZ2VyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXJcIiwge1xuICAgICAgICAgICAgc2l6ZTogdGhpcy5nZXREZWZhdWx0UGFnZVNpemUoKSxcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0UGFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKFwicGFnZXJcIik7XG4gICAgfVxuXG4gICAgc2V0U29ydGVyKGhhc2gsIHdpdGhvdXRJbnZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzb3J0ZXJcIiwgaGFzaCk7XG4gICAgICAgIGlmICh3aXRob3V0SW52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludmFsaWRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFNvcnRlcih3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHQgPSB7fTtcbiAgICAgICAgdFtPUFRfREVGQVVMVF9TT1JUX0ZJRUxEXSA9IE9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3J0ZXIodCwgd2l0aG91dEludmFsaWRhdGlvbik7XG4gICAgfVxuXG4gICAgZ2V0U29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwic29ydGVyXCIpO1xuICAgIH1cblxuICAgIGdldFNvcnRlckRpcmVjdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0U29ydGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVyKClbbmFtZXNbMF1dO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBPUFRfREVGQVVMVF9TT1JUX0RJUkVDVElPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNlYXJjaCgpIHtcbiAgICAgICAgbGV0IHNlYXJjaCA9XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5nZXRXb3JraW5nKFwic2VhcmNoXCIpICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIikgIT09IG51bGw7XG4gICAgICAgIHJldHVybiBzZWFyY2ggPyB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIikgOiBcIlwiO1xuICAgIH1cblxuICAgIHNldFNlYXJjaChsaW5lID0gT1BUX0RFRkFVTFRfU0VBUkNILCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwic2VhcmNoXCIsIGxpbmUpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicmV0dXJuXCIpO1xuICAgIH1cblxuICAgIHNldFJldHVybihyZXQgPSBPUFRfREVGQVVMVF9SRVRVUk4pIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicmV0dXJuXCIsIHJldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyRmlsdGVyZWREYXRhKCkge1xuICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyUmF3RGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMucmF3LnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXJSZWZpbmVkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMucmVmaW5lZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGludmFsaWRhdGVEYXRhKCkge1xuICAgICAgICAvL2NsZWFyaW5nIGZpbHRlcmVkIGFuZCBzb3J0ZWRcbiAgICAgICAgdGhpcy5jbGVhckZpbHRlcmVkRGF0YSgpO1xuICAgICAgICAvL2luIGNhc2UgbGl2ZSBsb2FkaW5nIGZyb20gc2VydmVyXG4gICAgICAgIGlmICh0aGlzLmlzTGl2ZSgpKSB7XG4gICAgICAgICAgICAvL2NsZWFyaW5nIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICB0aGlzLmNsZWFyUmF3RGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVzc2V0IHBhZ2VyIGFueXdheVxuICAgICAgICB0aGlzLnJlc2V0UGFnZXIoKTtcbiAgICB9XG5cbiAgICBpc0xpdmUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2VcIikgJiYgdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmZhY3RvcnlcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXRVcGRhdGluZygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInVwZGF0aW5nXCIsIHRydWUpO1xuICAgIH1cblxuICAgIHNldFVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJ1cGRhdGluZ1wiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWZVcGRhdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoXCJ1cGRhdGluZ1wiKTtcbiAgICB9XG5cbiAgICBnZXREYXRhSW50ZXJmYWNlKCkge1xuICAgICAgICBsZXQgZmFjdG9yeSA9IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5mYWN0b3J5XCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkoe30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMb2FkRGF0YUFjdGlvbk5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UubGlzdEFjdGlvblwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UubGlzdEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9MSVNUX0FDVElPTjtcbiAgICB9XG5cbiAgICBzZXRDb21iaW5lZEFjdGlvbk5hbWUoYWN0aW9uTmFtZSA9IE9QVF9ERUZBVUxUX0NPVU5UX0FDVElPTikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIiwgYWN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgZ2V0Q29tYmluZWRBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwiaW50ZXJmYWNlLmNvbWJpbmVkQWN0aW9uXCIpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZS5jb21iaW5lZEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT047XG4gICAgfVxuXG4gICAgZ2V0Q291bnRBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvdW50QWN0aW9uXCIpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5jb3VudEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT047XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKSB7XG4gICAgICAgIC8vbG9hZCBmcm9tIHNlcnZlclxuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmdldERhdGFJbnRlcmZhY2UoKVxuICAgICAgICAgICAgICAgIC5zZXRGaWx0ZXIodGhpcy5nZXRGaWx0ZXIoKSlcbiAgICAgICAgICAgICAgICAuc2V0U29ydGVyKHRoaXMuZ2V0U29ydGVyKCkpXG4gICAgICAgICAgICAgICAgLnNldFJldHVybih0aGlzLmdldFJldHVybigpKVxuICAgICAgICAgICAgICAgIC5zZXRTZWFyY2godGhpcy5nZXRTZWFyY2goKSlcbiAgICAgICAgICAgICAgICAuc2V0UGFnZXIodGhpcy5nZXRQYWdlcigpKSxcbiAgICAgICAgICAgIGFjdGlvbk5hbWU7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UuY29tYmluZWRcIiwgT1BUX0RFRkFVTFRfQ09NQklORUQpKSB7XG4gICAgICAgICAgICBhY3Rpb25OYW1lID0gdGhpcy5nZXRDb21iaW5lZEFjdGlvbk5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbk5hbWUgPSB0aGlzLmdldExvYWREYXRhQWN0aW9uTmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeVtcIiRcIiArIGFjdGlvbk5hbWVdKCk7XG4gICAgfVxuXG4gICAgZ29Ub05leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaXNOYU4odGhpcy5nZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIikpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKVxuICAgICAgICAgICAgOiB0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSArIDE7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICBcInBhZ2VyLnBhZ2VcIixcbiAgICAgICAgICAgIE1hdGgubWluKG5leHQsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLnRvXCIpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICB9XG5cbiAgICBnb1RvUHJldigpIHtcbiAgICAgICAgbGV0IHByZXYgPSBpc05hTih0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSlcbiAgICAgICAgICAgID8gdGhpcy5nZXREZWZhdWx0UGFnZU51bWJlcigpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0U3RhdGUoXCJwYWdlci5wYWdlXCIpIC0gMTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgIFwicGFnZXIucGFnZVwiLFxuICAgICAgICAgICAgTWF0aC5tYXgocHJldiwgdGhpcy5nZXRTdGF0ZShcInBhZ2luYXRpb24ucGFnZXMuZnJvbVwiKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub0ZpcnN0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCB0aGlzLmdldFN0YXRlKFwicGFnaW5hdGlvbi5wYWdlcy5mcm9tXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub0xhc3QoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJwYWdlci5wYWdlXCIsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLnRvXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub1BhZ2UocGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCBwYWdlTnVtYmVyKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgdGVzdERhdGFJdGVtKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gdGhpcy5nZXRTZWFyY2goKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKHZhciBrIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciB0b0NvbXAgPSBpdGVtW2tdLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0b0NvbXAuaW5kZXhPZihzdHJWYWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRSb3dzQ291bnQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZ2V0RGF0YUludGVyZmFjZSgpLnNldEZpbHRlcih0aGlzLmdldEZpbHRlcigpKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5W1wiJFwiICsgdGhpcy5nZXRDb3VudEFjdGlvbk5hbWUoKV0oKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oZGF0YS5jb3VudCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhZ2luYXRpb24oaXRlbXNDb3VudCkge1xuICAgICAgICB0aGlzLmxvZyhcInVwZGF0ZSBwYWdpbmF0aW9uXCIsIGl0ZW1zQ291bnQpO1xuICAgICAgICB0aGlzLnN0YXRlLnBhZ2luYXRpb24ucGFnZXMubGlzdC5zcGxpY2UoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGxldCBpdGVtc0Zyb20gPVxuICAgICAgICAgICAgICAgICh0aGlzLmdldFBhZ2VyKCkucGFnZSAtIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSKSAqXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5zaXplICtcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgcGFnZXNDb3VudCA9XG4gICAgICAgICAgICAgICAgaXRlbXNDb3VudCAlIHRoaXMuZ2V0UGFnZXIoKS5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcihpdGVtc0NvdW50IC8gdGhpcy5nZXRQYWdlcigpLnNpemUpICsgMVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucm91bmQoaXRlbXNDb3VudCAvIHRoaXMuZ2V0UGFnZXIoKS5zaXplKSxcbiAgICAgICAgICAgIHBhZ2VzRnJvbSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5wYWdlIC0gT1BUX0RFRkFVTFRfUEFHRV9SQU5HRVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHBhZ2VzVG8gPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBwYWdlc0NvdW50IC0gKDEgLSBPUFRfREVGQVVMVF9QQUdFX05VTUJFUiksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRQYWdlcigpLnBhZ2UgKyBPUFRfREVGQVVMVF9QQUdFX1JBTkdFXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICAgICAgaXRlbXNUbyA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIGl0ZW1zRnJvbSArIHRoaXMuZ2V0UGFnZXIoKS5zaXplIC0gMSxcbiAgICAgICAgICAgICAgICBpdGVtc0NvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCB0ID0gcGFnZXNGcm9tOyB0IDw9IHBhZ2VzVG87IHQrKykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogdCxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IHQgPT09IHRoaXMuZ2V0UGFnZXIoKS5wYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3Jlcy5zdGF0ZS51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ1cGRhdGUgcGFnaW5hdGlvblwiLCB2YWwpO1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24uaXRlbXMuY291bnQgPSBpdGVtc0NvdW50O1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24uaXRlbXMuZnJvbSA9IGl0ZW1zRnJvbTtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLml0ZW1zLnRvID0gaXRlbXNUbztcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmNvdW50ID0gcGFnZXNDb3VudDtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmZyb20gPSBwYWdlc0Zyb207XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy50byA9IHBhZ2VzVG87XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5jdXJyZW50ID0gdGhpcy5nZXRQYWdlcigpLnBhZ2U7XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5saXN0LnNwbGljZShcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgICAgIC4uLmxpc3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVEYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWZVcGRhdGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldE9wdGlvbnMoXCJlbmRsZXNzXCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSYXdEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFVwZGF0aW5nKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvbWJpbmVkXCIsIE9QVF9ERUZBVUxUX0NPTUJJTkVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bGwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgXCJzdGF0dXNcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGRhdGEsIFwicmVzdWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0T3B0aW9ucyhcImVuZGxlc3NcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGaWx0ZXJlZERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnB1c2goLi4uZGF0YS5yZXN1bHQubGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhkYXRhLCBcImxpc3RcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS5saXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEubGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnB1c2goLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFzdENvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbCA/IGRhdGEucmVzdWx0LmNvdW50IDogZGF0YS5jb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uKHRoaXMuZ2V0V29ya2luZyhcImxhc3RDb3VudFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aGlzLmVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0VXBkYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRSb3dzQ291bnQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHRoaXMuZXJyb3IuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5zZXRVcGRhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9sb2NhbCBtYWdpY1xuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGluZygpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgdGhhdEZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyKCk7XG4gICAgICAgIC8vdGhpcy5nZXREYXRhKCdyb3dzJykuX19zZXRQYXNzaXZlO1xuICAgICAgICB0aGlzLmxvZyh0aGlzLmdldERhdGEoKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGF0RmlsdGVyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhhdEZpbHRlci5maWx0ZXJTZWFyY2ggIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHRoYXRGaWx0ZXIuZmlsdGVyU2VhcmNoICE9PSBudWxsICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyLmZpbHRlclNlYXJjaC5sZW5ndGggPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICB2YWwubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmRhdGEucmF3LmZpbHRlcih0aGlzLnRlc3REYXRhSXRlbS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgsIC4uLnRoaXMuZGF0YS5yYXcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLy8vc29ydGVyXG4gICAgICAgIGxldCB0aGF0U29ydGVyID0gdGhpcy5nZXRTb3J0ZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGF0U29ydGVyICE9PSBcInVuZGVmaW5lZFwiICYmIHRoYXRTb3J0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdDEgPSBub3RQYXRoLmdldCh0aGF0U29ydGVyLnNvcnRCeUZpZWxkLCBpdGVtMSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBub3RQYXRoLmdldCh0aGF0U29ydGVyLnNvcnRCeUZpZWxkLCBpdGVtMiwge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHQxICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHQyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEubG9jYWxlQ29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEubG9jYWxlQ29tcGFyZSgpICogLXRoYXRTb3J0ZXIuc29ydERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0MSA8IHQyID8gMSA6IC0xKSAqIHRoYXRTb3J0ZXIuc29ydERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvZ2dlci5lcnJvciguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvZ2dlci5sb2coLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrRmllbGRzTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpO1xuICAgICAgICBjb25zdCBwYXRoSWQgPSBcIjpcIiArIGZpZWxkSWQ7XG4gICAgICAgIGxldCBmaWVsZHMgPSB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwgW10pO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXRoSWQgPT09IGZpZWxkLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5wYXRoID0gZmllbGQucGF0aCArIENPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWFkRmllbGRWYWx1ZShwYXRoLCBpdGVtLCBoZWxwZXJzKSB7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoQ09OU1RfSURfRFVCTElDQVRFX1BPU1RGSVgpID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpO1xuICAgICAgICAgICAgY29uc3QgcGF0aElkID0gXCI6XCIgKyBmaWVsZElkO1xuICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KHBhdGhJZCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90UGF0aC5nZXQocGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZpbmVGaWx0ZXJlZCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrRmllbGRzTmFtZXMoKTtcbiAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImlkRmllbGRcIikpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW3RoaXMuZ2V0T3B0aW9ucyhcImlkRmllbGRcIildID1cbiAgICAgICAgICAgICAgICAgICAgaXRlbVt0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiLCBbXSkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlcHJvY2Vzc2VkID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkRmllbGRWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwiaGVscGVyc1wiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGZpZWxkLCBPUFRfRklFTERfTkFNRV9QUkVfUFJPQykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXByb2Nlc3NlZCA9IGZpZWxkW09QVF9GSUVMRF9OQU1FX1BSRV9QUk9DXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVycm9yIHdoaWxlIHByZXByb2Nlc3NpbmcgY2VsbCB2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub3RQYXRoLnNldChmaWVsZC5wYXRoLCByZWZpbmVkLCBwcmVwcm9jZXNzZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdFBhdGguc2V0KGZpZWxkLnBhdGgsIHJlZmluZWQsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5zcGxpY2UoMCwgdmFsLmxlbmd0aCwgLi4ucmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMudWkpIHtcbiAgICAgICAgICAgIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3kgJiYgdGhpcy51aVtuYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudWlbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFRhYmxlO1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMb2FkZXIgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkubG9hZGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbnRhaW5lciBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvbGF5b3V0L3VpLmNvbnRhaW5lci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOb3RpZmljYXRpb25FcnJvciBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLmVycm9yLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5vdGlmaWNhdGlvblN1Y2Nlc3MgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5zdWNjZXNzLnN2ZWx0ZVwiO1xuXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuXG4gICAgbGV0IHN1Y2Nlc3MgPSAkc3RhdGUoZmFsc2UpO1xuXG4gICAgbGV0IGVycm9yID0gJHN0YXRlKGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY29udGFpbmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGVyQWN0aXZlXSAtIHN0YXRlIGlmIGZvcm0gbG9hZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyU2l6ZV0gLSBwYWdlIC0gd2hvbGUgcGFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VjY2Vzc1RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VjY2Vzc01lc3NhZ2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvclRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JNZXNzYWdlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjb250YWluZXIgPSB7fSxcbiAgICAgICAgbG9hZGVyVGl0bGUgPSAkYmluZGFibGUoXCLQntGC0L/RgNCw0LLQutCwINC00LDQvdC90YvRhSDQvdCwINGB0LXRgNCy0LXRgFwiKSxcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbG9hZGVyU2l6ZSA9ICRiaW5kYWJsZShcImNvbnRhaW5lclwiKSxcbiAgICAgICAgc3VjY2Vzc1RpdGxlID0gJGJpbmRhYmxlKFwiT0tcIiksXG4gICAgICAgIHN1Y2Nlc3NNZXNzYWdlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBlcnJvclRpdGxlID0gJGJpbmRhYmxlKFwiRXJyb3JcIiksXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2hvd1N1Y2Nlc3ModGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChtZXNzYWdlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VjY2Vzc01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NUaXRsZSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dFcnJvcih0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yVGl0bGUgPSB0aXRsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRMb2FkaW5nKCkge1xuICAgICAgICBsb2FkZXJBY3RpdmUgPSB0cnVlO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGhpZGVBbGwoKSB7XG4gICAgICAgIGxvYWRlckFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSUxvYWRlclxuICAgIGJpbmQ6bG9hZGluZz17bG9hZGVyQWN0aXZlfVxuICAgIGJpbmQ6dGl0bGU9e2xvYWRlclRpdGxlfVxuICAgIGJpbmQ6c2l6ZT17bG9hZGVyU2l6ZX1cbi8+XG48VUlDb250YWluZXIgey4uLmNvbnRhaW5lcn0+XG4gICAgeyNpZiBlcnJvcn1cbiAgICAgICAgPFVJTm90aWZpY2F0aW9uRXJyb3JcbiAgICAgICAgICAgIGJpbmQ6dGl0bGU9e2Vycm9yVGl0bGV9XG4gICAgICAgICAgICBiaW5kOm1lc3NhZ2U9e2Vycm9yTWVzc2FnZX1cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuICAgIHsjaWYgc3VjY2Vzc31cbiAgICAgICAgPFVJTm90aWZpY2F0aW9uU3VjY2Vzc1xuICAgICAgICAgICAgYmluZDp0aXRsZT17c3VjY2Vzc1RpdGxlfVxuICAgICAgICAgICAgYmluZDptZXNzYWdlPXtzdWNjZXNzTWVzc2FnZX1cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuPC9VSUNvbnRhaW5lcj5cbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuLi8uLi9iYXNlXCI7XG5cbmltcG9ydCBVSUFjdGlvbkNvbnRhaW5lciBmcm9tIFwiLi91aS5hY3Rpb24uY29udGFpbmVyLnN2ZWx0ZVwiO1xuY29uc3QgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIi5jb250YWluZXJcIjtcbmltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vY29uc3RcIjtcblxuY2xhc3Mgbm90QWN0aW9uVUkgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvL1VJIHJlbmRlcmVyIGNvbXBvbmVudCBjbGFzcyBjb25zdHJ1Y3RvclxuICAgICN1aUNvbXBvbmVudCA9IG51bGw7XG4gICAgI3VpID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgICAgbmFtZSA9IFwiRGVmYXVsdFwiLFxuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIHdvcmtpbmcgPSB7fSxcbiAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICB1aSA9IFVJQWN0aW9uQ29udGFpbmVyLCAvL2RlZmF1bHQgVUlcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtuYW1lfUFjdGlvblVJYCxcbiAgICAgICAgICAgICAgICAuLi53b3JraW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdWlDb21wb25lbnQgPSB1aTtcbiAgICAgICAgdGhpcy5pbml0VUkoKTtcbiAgICB9XG5cbiAgICBpbml0VUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldEVsKCk7XG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0LmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQodGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy4jdWkgPSBuZXcgdGhpcy4jdWlDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wczogdGhpcy5nZXRPcHRpb25zKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMuI3VpLnNldExvYWRpbmcoKTtcbiAgICB9XG5cbiAgICByZXNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRlZFwiKTtcbiAgICAgICAgdGhpcy4jdWkucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI3VpKSB7XG4gICAgICAgICAgICB0aGlzLiN1aS4kZGVzdHJveSAmJiB0aGlzLiN1aS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jdWkuZGVzdHJveSAmJiB0aGlzLiN1aS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiN1aSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG51bGwpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YShudWxsKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gREVGQVVMVF9TVEFUVVNfU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtU3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1FcnJvcnMocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgRm9ybSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAqKi9cbiAgICBzZXRGb3JtU3VjY2VzcygpIHtcbiAgICAgICAgdGhpcy4jdWkuc2hvd1N1Y2Nlc3MoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtRXJyb3JzKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBmb3JtOiBbXSxcbiAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgc3RhdHVzLmZvcm0ucHVzaChyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiYgT2JqZWN0LmtleXMocmVzdWx0LmVycm9ycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdHVzLmZpZWxkcyA9IHsgLi4ucmVzdWx0LmVycm9ycyB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VpLnNob3dFcnJvcihzdGF0dXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIC8qKipcbiAgICAgKiBSZWRlZmluYWJsZSBnZXR0ZXJzXG4gICAgICoqL1xuICAgIGdldFRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuZ2V0T3B0aW9ucyhcInRhcmdldFwiLCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUik7XG4gICAgICAgIGlmICh0YXJnZXRFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0RWw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldEVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3Rpb25VSSBwYXJlbnQgZWxlbWVudCBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QWN0aW9uVUk7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb25cIjtcblxuaW1wb3J0IHsgRklFTERTLCBDT01QT05FTlRTLCBWQVJJQU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcblxuY2xhc3Mgbm90Rm9ybVV0aWxzIHtcbiAgICBzdGF0aWMgdmFsaWRhdG9yID0gbnVsbDtcblxuICAgIHN0YXRpYyBhZGRDb21wb25lbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgQ09NUE9ORU5UUy5hZGQobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRWYXJpYW50cyhuYW1lLCB2YWx1ZSkge1xuICAgICAgICBWQVJJQU5UUy5hZGQobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRGaWVsZChuYW1lLCBmaWVsZCkge1xuICAgICAgICBGSUVMRFMuYWRkKG5hbWUsIGZpZWxkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWN0aW9uRmllbGRzSW5pdChmaWVsZE5hbWUsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZmllbGROYW1lLmZvckVhY2goKHN1YkZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uRmllbGRzSW5pdChzdWJGaWVsZE5hbWUsIG9wdGlvbnMsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5vdENvbW1vbi5vYmpIYXMob3B0aW9ucywgXCJmaWVsZHNcIikpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub3RDb21tb24ub2JqSGFzKG9wdGlvbnMuZmllbGRzLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZHNbZmllbGROYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb3B5aW5nIGluaXRpYWwgZGF0YVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgZGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhW2ZpZWxkTmFtZV0gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gIT09IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzW2ZpZWxkTmFtZV0udmFsdWUgPSBkYXRhW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEZvcm1VdGlscztcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG5jb25zdCBERUZBVUxUX0ZJRUxEID0ge1xuICAgIGxhYmVsOiBcIlwiLFxuICAgIHBsYWNlaG9sZGVyOiBcIlwiLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgdmlzaWJsZTogdHJ1ZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB2YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHZhbGlkOiBmYWxzZSxcbiAgICBlcnJvcnM6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGZpZWxkIG1hbmlmZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgICAgIG5hbWUvdHlwZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBtdXRhdGlvbiAgbXV0YXRpb24gdG8gbWFuaWZlc3QgZnJvbSBsaWJyYXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gVkFSSUFOVFMgIHN0b3JlIHdoaWNoIGNvbnRhaW5zIG5hbWVkIGxpc3RzIG9mIGZpZWxkIHZhbHVlIHZhcmlhbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gRklFTERTICAgIHN0b3JlIHdoaWNoIGNvbnRhaW5zIG5hbWVkIGxpc3RzIG9mIGZpZWxkIG1hbmlmZXN0c1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBmaWVsZCBtYW5pZmVzdFxuICoqL1xuZnVuY3Rpb24gZmllbGRJbml0KHR5cGUsIG11dGF0aW9uID0ge30sIFZBUklBTlRTLCBGSUVMRFMpIHtcbiAgICBsZXQgZmllbGQgPSB7IC4uLkRFRkFVTFRfRklFTEQgfTtcbiAgICAvL2dldHRpbmcgZmllbGQgY29yZSBtYW5pZmVzdFxuICAgIGlmIChGSUVMRFMuY29udGFpbnModHlwZSkpIHtcbiAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIC4uLkZJRUxEUy5nZXQodHlwZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYWRkaW5nIG11dGF0aW9uc1xuICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgLi4ubXV0YXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYWRkaW5nIHZhcmlhbnRzIGxpc3QgdG8gZmllbGQgZnJvbSBWQVJJQU5UUyBzdG9yZVxuICAgIGlmIChcbiAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmaWVsZCwgXCJ2YXJpYW50c1NvdXJjZVwiKSAmJlxuICAgICAgICBWQVJJQU5UUy5jb250YWlucyhmaWVsZC52YXJpYW50c1NvdXJjZSlcbiAgICApIHtcbiAgICAgICAgZmllbGQudmFyaWFudHMgPSBWQVJJQU5UUy5nZXQoZmllbGQudmFyaWFudHNTb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmllbGQudmFyaWFudHMgfHwgZmllbGQudmFyaWFudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC52YXJpYW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBvZiBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkIHR5cGUgaWYgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzID0gc3ViZm9ybVxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgVkFSSUFOVFMgICAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCB2YWx1ZSB2YXJpYW50c1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgRklFTERTICAgICAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCBtYW5pZmVzdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zICAgZm9ybSB3aWRlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBpbml0Rm9ybUJ5RmllbGQoXG4gICAgZm9ybSA9IHt9LFxuICAgIGZpZWxkTmFtZSA9IFtdLFxuICAgIFZBUklBTlRTLFxuICAgIEZJRUxEUyxcbiAgICBmb3JtRmllbGRzT3B0aW9ucyxcbiAgICBkYXRhXG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZE5hbWUpKSB7XG4gICAgICAgIGZpZWxkTmFtZS5mb3JFYWNoKChzdWJGb3JtRmllbGROYW1lKSA9PlxuICAgICAgICAgICAgaW5pdEZvcm1CeUZpZWxkKFxuICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgc3ViRm9ybUZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBWQVJJQU5UUyxcbiAgICAgICAgICAgICAgICBGSUVMRFMsXG4gICAgICAgICAgICAgICAgZm9ybUZpZWxkc09wdGlvbnMsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBvcHRzID0ge307XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGZvcm1GaWVsZHNPcHRpb25zLCBcIm11dGF0aW9uc1wiKSAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmb3JtRmllbGRzT3B0aW9ucy5tdXRhdGlvbnMsIGZpZWxkTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRzID0gZm9ybUZpZWxkc09wdGlvbnMubXV0YXRpb25zW2ZpZWxkTmFtZV07IC8vb3B0aW9uIG11dGF0aW9uIGZvciBmaWVsZFxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICYmIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgb3B0cy52YWx1ZSA9IGRhdGFbZmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtW2ZpZWxkTmFtZV0gPSBmaWVsZEluaXQoZmllbGROYW1lLCBvcHRzLCBWQVJJQU5UUywgRklFTERTKTtcbiAgICAgICAgLy9pZiBmb3JtIHJlYWRvbmx5LCBtYXJraW5nIGV2ZXJ5IGZpZWxkIGFzIHJlYWRvbmx5XG4gICAgICAgIGlmIChmb3JtRmllbGRzT3B0aW9ucyAmJiBmb3JtRmllbGRzT3B0aW9ucy5yZWFkb25seSkge1xuICAgICAgICAgICAgZm9ybVtmaWVsZE5hbWVdLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiAgTWFya2luZyBmaWVsZCBhcyBpbnZhbGlkIGJ5IG93biB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgZmllbGROYW1lICAgICBuYW1lIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIHthbnl9ICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgIHZhbHVlIG9mIGZpZWxkXG4gKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgIGVycm9ycyAgICAgICAgbGlzdCBvZiBlcnJvcnNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpIHtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzID0gWy4uLmVycm9yc107XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGZvcm07XG59XG5cbi8qKlxuICogIE1hcmtpbmcgZmllbGQgYXMgdmFsaWQgYnkgb3duIHZhbGlkYXRvclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcGFyYW0ge2FueX0gICAgICAgICAgICAgIHZhbHVlICAgICAgICAgdmFsdWUgb2YgZmllbGRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIGZvcm1bZmllbGROYW1lXS5lcnJvcnMgPSBmYWxzZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsaWRhdGVkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsaWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgZm9yIChsZXQgZm5hbWUgaW4gZm9ybSkge1xuICAgICAgICBpZiAoZm5hbWUgIT09IGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZm9ybVtmbmFtZV0uZXJyb3JzKSAmJlxuICAgICAgICAgICAgICAgIGZvcm1bZm5hbWVdLmVycm9ycy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvcm1bZm5hbWVdLmVycm9ycyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1bZm5hbWVdLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgZmllbGQgaGFzIGVycm9yc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAtIHZhbGlkLCBmYWxzZSAtaW52YWxpZFxuICoqL1xuZnVuY3Rpb24gaXNGaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzKTtcbn1cblxuLyoqXG4gKiBGb3JtIGxldmVsIHZhbGlkYXRvciBlcnJvciBpbiB0aGlzIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgZXJyb3JzICAgICAgICBsaXN0IG9mIGVycm9yc1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICoqL1xuZnVuY3Rpb24gc2V0Rm9ybUZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIGVycm9ycykge1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtRXJyb3JzID0gWy4uLmVycm9yc107XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmlucHV0U3RhcnRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmZvcm1MZXZlbEVycm9yID0gdHJ1ZTtcbiAgICByZXR1cm4gZm9ybTtcbn1cbi8qKlxuICogRm9ybSBsZXZlbCB2YWxpZGF0b3Igc3VjY2VzcyBpbiB0aGlzIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSkge1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtRXJyb3JzID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZm9ybUxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGZpZWxkcyBhbmQgZm9ybSBlcnJvciBsYWJlbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzICAgICAgcmVzdWx0cyBvZiB2YWxpZGF0aW9uXG4gKiovXG5mdW5jdGlvbiB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyhcbiAgICB7XG4gICAgICAgIGZvcm0sXG4gICAgICAgIGZvcm1FcnJvcnMsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0dXMsXG4gICAgfSAvKiBGb3JtVmFsaWRhdGlvblNlc3Npb24uZ2V0Q29tcGxldGVSZXN1bHQoKSAqL1xuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5mb3JtKSAmJiB2YWxpZGF0aW9uU3RhdHVzLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoLCAuLi52YWxpZGF0aW9uU3RhdHVzLmZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRpb25TdGF0dXMuZmllbGRzKSB7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXSkgJiZcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUZpZWxkSW52YWxpZChcbiAgICAgICAgICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0RmllbGRzVmlzaWJpbGl0eShmb3JtLCBmaWVsZHNMaXN0LCB2YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHNMaXN0KSkge1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtKS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGZvcm1bZmllbGROYW1lXS52aXNpYmxlID0gZmllbGRzTGlzdC5pbmNsdWRlcyhmaWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgPyB2YWxcbiAgICAgICAgICAgICAgICA6ICF2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXRGaWVsZFZhbHVlKGZvcm0sIGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobm90Q29tbW9uLm9iakhhcyhmb3JtLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaWVsZElzVmlzaWJsZUFuZEZpbGxlZChmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBub3RDb21tb24ub2JqSGFzKGZvcm0sIGZpZWxkTmFtZSkgJiZcbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdLmVuYWJsZWQgJiZcbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdLnZpc2libGUgJiZcbiAgICAgICAgdHlwZW9mIGZvcm1bZmllbGROYW1lXS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3REYXRhKGZpZWxkcywgZm9ybSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmaWVsZHMuZmxhdCgpLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoZmllbGRJc1Zpc2libGVBbmRGaWxsZWQoZm9ybSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBmb3JtW2ZpZWxkTmFtZV0udmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZmllbGRJbml0LFxuICAgIGluaXRGb3JtQnlGaWVsZCxcbiAgICBzZXRGaWVsZEludmFsaWQsXG4gICAgc2V0RmllbGRWYWxpZCxcbiAgICBpc0ZpZWxkVmFsaWQsXG4gICAgc2V0Rm9ybUZpZWxkSW52YWxpZCxcbiAgICBzZXRGb3JtRmllbGRWYWxpZCxcbiAgICB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyxcbiAgICBmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCxcbiAgICBzZXRGaWVsZHNWaXNpYmlsaXR5LFxuICAgIHNldEZpZWxkVmFsdWUsXG4gICAgY29sbGVjdERhdGEsXG59O1xuIiwiY29uc3QgZW1wdHlGaWVsZHNSZXN1bHRzID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgYWNjW2N1cnJdID0gW107XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcblxuY29uc3QgRklFTERTID0gW1wiZmllbGRzXCIsIFwiZm9ybVwiXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICAjY2xlYW4gPSB0cnVlO1xuICAgICNyZXN1bHQ7XG5cbiAgICBjb25zdHJ1Y3RvcihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy4jcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy4jcmVzdWx0KS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghRklFTERTLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4jcmVzdWx0W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjbGVhbiA9IHRoaXMuI3Jlc3VsdC5mb3JtLmVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNnZXRGaWVsZHNMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpZWxkRGlydHkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiNyZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IGNsZWFuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2xlYW47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldERlZmF1bHRSZXN1bHQoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRzOiBlbXB0eUZpZWxkc1Jlc3VsdHMoZGF0YSksXG4gICAgICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBlbXB0eUZpZWxkc1Jlc3VsdHMoZGF0YSksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0UmVwb3J0KCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLiNnZXRDb21wbGV0ZVJlc3VsdCgpKSk7XG4gICAgfVxuXG4gICAgZ2V0RGV0YWlsZWRSZXBvcnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLiNyZXN1bHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0ZpZWxkRGlydHkoZmllbGROYW1lKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKSAmJlxuICAgICAgICAgICAgdGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICB0aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXS5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Q29tcGxldGVSZXN1bHRGb3JGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgY29uc3QgZmllbGRSZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgZmllbGRSZXN1bHQucHVzaCguLi50aGlzLiNyZXN1bHQuZmllbGRzW2ZpZWxkTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgZmllbGRSZXN1bHQucHVzaCguLi50aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkUmVzdWx0O1xuICAgIH1cblxuICAgICNnZXRDb21wbGV0ZVJlc3VsdCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0Q29tcGxldGUgPSB7XG4gICAgICAgICAgICBjbGVhbjogdGhpcy4jY2xlYW4sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICAgICAgZm9ybTogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNnZXRGaWVsZHNMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmdldENvbXBsZXRlUmVzdWx0Rm9yRmllbGQoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q29tcGxldGUuZmllbGRzW2ZpZWxkTmFtZV0gPSBlcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Q29tcGxldGUuZm9ybSA9IFsuLi50aGlzLiNyZXN1bHQuZm9ybS5lcnJvcnNdO1xuICAgICAgICBpZiAocmVzdWx0Q29tcGxldGUuZm9ybS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRDb21wbGV0ZS5mb3JtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRDb21wbGV0ZTtcbiAgICB9XG5cbiAgICAjZ2V0RmllbGRzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXModGhpcy4jcmVzdWx0LmZpZWxkcyk7XG4gICAgICAgIGNvbnN0IGZpZWxkc0luRm9ybSA9IE9iamVjdC5rZXlzKHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkcyk7XG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChbLi4uZmllbGRzSW5Gb3JtLCAuLi5maWVsZHNdKV07XG4gICAgfVxufTtcbiIsIi8qKlxuKlx0VGVtcGxhdGUgb2YgZXJyb3IuanNcbipcdEZvciBidWlsZGluZyBmb3Igc3BlY2lmaWMgZW52aXJvbm1lbnQuXG4qXHROb2RlLmpzIG9yIEJyb3dzZXJcbipcdEBwYXJhbSB7c3RyaW5nfVx0ZW52XHRub2RlfGJyb3dzZXIgaW4gd2ljaCBlbnYgaXQgd2lsbCBiZSBydW5uaW5nXG4qXHRAcGFyYW0ge3N0cmluZ31cdHVybFx0VVJMIG9mIHJlcG9ydCBjb2xsZWN0b3JcbipcdEBwYXJhbSB7c3RyaW5nfVx0a2V5XHRrZXkgdG8gaW5kZXRpZmljYXRlIHJlcG9ydGVyXG4qL1xuLyoqXG4qIEVycm9yIHJlcG9ydGluZyB3aXRoIGZlYXR1cmVzLCBzYXZpbmcgYnJvd3NlciBpbmZvLCB1cmkgYW5kIHNvIG9uLlxuKiBAbW9kdWxlIG5vdC1lcnJvci9lcnJvclxuKi9cbmNsYXNzIG5vdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zID0ge30sIGVycm9yID0gbnVsbCl7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmFkb3B0KGVycm9yKTtcblx0XHR0aGlzLmZpbGwoKTtcblx0XHR0aGlzLmdldFRpbWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQqXHRBZG9wdGluZyBuYXRpdmUgZXJyb3Igb2JqZWN0XG5cdCpcdEBwYXJhbSB7RXJyb3J9XHRlcnJvciBcdEVycm9yIG9iamVjdFxuXHQqXHRAcmV0dXJuIHtub3RFcnJvcn1cdFx0Y2hhaW5hYmxlXG5cdCovXG5cdGFkb3B0KGVycm9yKXtcblx0XHRpZihlcnJvciBpbnN0YW5jZW9mIEVycm9yKXtcblx0XHRcdHRoaXMucGFyZW50ID0gZXJyb3I7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Z2V0U3RhY2soKXtcblx0XHRpZih0aGlzLnBhcmVudCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuc3RhY2s7XG5cdFx0fWVsc2V7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFjaztcblx0XHR9XG5cdH1cblxuXHRnZXREZXRhaWxzKCl7XG5cdFx0bGV0IHNyYyA9IHRoaXM7XG5cdFx0aWYodGhpcy5wYXJlbnQpe1xuXHRcdFx0c3JjID0gdGhpcy5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRjb2x1bW5OdW1iZXI6ICAgIFx0c3JjLmNvbHVtbk51bWJlcixcblx0XHRcdGZpbGVOYW1lOiAgICAgICAgXHRzcmMuZmlsZU5hbWUsXG5cdFx0XHRsaW5lTnVtYmVyOiAgICAgIFx0c3JjLmxpbmVOdW1iZXIsXG5cdFx0XHRuYW1lOiAgICAgICAgICAgIFx0c3JjLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiAgICAgICAgXHRzcmMubWVzc2FnZSxcblx0XHRcdHN0YWNrOiAgICAgICAgICBcdHNyYy5zdGFja1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0Klx0VXBkYXRpbmcgdGhpcy5lbnYuZGF0ZSBwcm9wZXJ0eVxuXHQqXHRAcmV0dXJuICB7b2JqZWN0fVx0e3RpbWVzdGFtcCwgb2Zmc2V0fVxuXHQqL1xuXHRnZXRUaW1lKCl7XG5cdFx0bGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdHRoaXMuZW52LmRhdGUgPSB7XG5cdFx0XHR0aW1lc3RhbXAgOiBkYXRlLmdldFRpbWUoKSxcblx0XHRcdG9mZnNldDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5lbnYuZGF0ZTtcblx0fVxuXG5cblx0LyoqXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KioqXHROb2RlLmpzIFNlY3Rpb25cblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKi9cblxuXHQvKipcblx0Klx0RmlsdGVyaW5nIG91dCBrZXkgYnkgYHdoaXRlYCBsaXN0XG5cdCpcdEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgaGFzaCB0byBiZSBjb3BpZWQgYWNjb3JkaW5nIGZpbHRlciBgd2hpdGVgIGxpc3Rcblx0Klx0QHBhcmFtIHthcnJheX0gZmlsdGVyIGFycmF5IG9mIHN0aW5nLCB3aGljaCByZXByZXNlbnRzIGtleXMgd2Ugd2FudCB0byBiZVxuXHQqXHRcdFx0XHRcdFx0Y29waWVkIGluIHJlc3VsdGluZyBvYmplY3QgZnJvbSBzb3VyY2Vcblx0Klx0QHJldHVybiB7b2JqZWN0fVx0XHR3aGl0ZSBsaXN0ZWQgaGFzaFxuXHQqL1xuXHRmaWx0ZXJFbnYob2JqZWN0LCBmaWx0ZXIpe1xuXHRcdGxldCByZXN1bHQgPSB7fTtcblx0XHRmb3IobGV0IHQgb2YgZmlsdGVyKXtcblx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHQpKXtcblx0XHRcdFx0cmVzdWx0W3RdID0gb2JqZWN0W3RdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCpcdENvbGxlY3RpbmcgaW5mb3JtYXRpb24gc3BlY2lmaWMgZm9yIE5vZGUuanMgVjhcblx0Klx0QHJldHVybiB7bm90RXJyb3J9XHRcdGNoYWluYWJsZVxuXHQqL1xuXHRmaWxsKCl7XG5cdFx0LyoqXG5cdFx0Klx0WW91IHdhbnQgc29tZSBmaWVsZHMgZnJvbSBlbnYgYnV0IG5vdCBhbGwsIGNhdXNlIHRoZXJlIGFyZSBwYXNzd29yZHNcblx0XHQqXHRmcm9tIGRiLCBhcGkga2V5cyBhbmQgZXRjXG5cdFx0Ki9cblx0XHR0aGlzLmVudiA9IHtcblx0XHRcdGJyb3dzZXI6IFx0ZmFsc2UsXG5cdFx0XHRub2RlOiBcdFx0dHJ1ZSxcblx0XHRcdHZlcnNpb25zOiBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLnZlcnNpb25zKSxcblx0XHRcdHZhcnM6IFx0XHR0aGlzLmZpbHRlckVudihwcm9jZXNzLmVudiwgdGhpcy5vcHRpb25zLndoaXRlbGlzdCB8fCBbJ05PREVfRU5WJ10pXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdEVycm9yO1xuXG4iLCJcbmNvbnN0IG5vdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci5ub2RlLmNqcycpO1xuXG5cbi8vcmVwb3J0YWJsZVxuY2xhc3Mgbm90VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgbm90RXJyb3J7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpZWxkcyA9IHt9LCBlcnIgPSBudWxsLCBwYXJhbXMgPSB7fSl7XG4gICAgc3VwZXIobWVzc2FnZSwge2ZpZWxkcywgcGFyYW1zfSwgZXJyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAqIFNldHMgaGFzaCBvZiBmaWVsZHMgZXJyb3JzIG1lc3NhZ2VzIGZvciB1c2FnZSBpbiBmb3Jtc1xuICAqXHRAcmV0dXJuIHtPYmplY3R9XHRoYXNoIG9mIGZpZWxkLT5lcnJvcnMgW2tleTpzdHJpbmddOiBBcnJheTxzdHJpbmc+XG4gICoqL1xuICBzZXRGaWVsZHNFcnJvcnMobWVzc2FnZXMpe1xuICAgIHRoaXMub3B0aW9ucy5maWVsZHMgPSBtZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAqIFJldHVybnMgaGFzaCBvZiBlcnJvcnNcbiAgKlx0QHJldHVybiB7T2JqZWN0fVx0aGFzaCBvZiBmaWVsZC0+ZXJyb3JzIFtrZXk6c3RyaW5nXTogQXJyYXk8c3RyaW5nPlxuICAqKi9cbiAgZ2V0RmllbGRzRXJyb3JzKCl7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWVsZHM7XG4gIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gbm90VmFsaWRhdGlvbkVycm9yO1xuXG4iLCIvKipcbiAqIFRlc3QgYXJndW1lbnQgdHlwZSB0byBiZSAnZnVuY3Rpb24nXG4gKiBAcGFyYW0ge2FueX0gIGZ1bmMgICAgcG9zc2libGUgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICBpZiB0aGlzIGlzIGEgZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGlzRnVuYyA9IChmdW5jKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhcmd1bWVudCBpcyBBc3luYyBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgaWYgdGhpcyBmdW5jdGlvbiBpcyBjb25zdHJ1Y3RlZCBhcyBBc3luY0Z1bmN0aW9uXG4gKiovXG5jb25zdCBpc0FzeW5jID0gKGZ1bmMpID0+IHtcbiAgICByZXR1cm4gZnVuYy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jRnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHByb2MsIHBhcmFtcykgPT4ge1xuICAgIGlmIChpc0Z1bmMocHJvYykpIHtcbiAgICAgICAgaWYgKGlzQXN5bmMocHJvYykpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jKC4uLnBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvYyguLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImNvbnN0IFZhbGlkYXRpb25SZXN1bHQgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5jb25zdCBub3RWYWlsZGF0aW9uRXJyb3IgPSByZXF1aXJlKFwibm90LWVycm9yL3NyYy92YWxpZGF0aW9uLmVycm9yLm5vZGUuY2pzXCIpO1xuY29uc3QgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG5jb25zdCBWYWxpZGF0aW9uU2Vzc2lvbiA9IGFzeW5jICh2YWxpZGF0b3JzLCBkYXRhKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gVmFsaWRhdGlvblJlc3VsdC5nZXREZWZhdWx0UmVzdWx0KGRhdGEpO1xuICAgIGF3YWl0IHZhbGlkYXRlRmllbGRzKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pO1xuICAgIGF3YWl0IHZhbGlkYXRlRm9ybSh7IHZhbGlkYXRvcnMsIGRhdGEsIHJlc3VsdCB9KTtcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRpb25SZXN1bHQocmVzdWx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblNlc3Npb247XG5cbmNvbnN0IHZhbGlkYXRlRmllbGRzID0gYXN5bmMgKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pID0+IHtcbiAgICBmb3IgKGxldCB0IGluIGRhdGEpIHtcbiAgICAgICAgYXdhaXQgdmFsaWRhdGVGaWVsZCh0LCBkYXRhW3RdLCB2YWxpZGF0b3JzLCByZXN1bHQpO1xuICAgIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGROYW1lLCB2YWx1ZSwgdmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgY29uc3QgZmllbGRWYWxpZGF0b3JzID0gZ2V0RmllbGRWYWxpZGF0b3JzKGZpZWxkTmFtZSwgdmFsaWRhdG9ycyk7XG4gICAgcmV0dXJuIGF3YWl0IHJ1bkZpZWxkVmFsaWRhdG9ycyhmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFZhbGlkYXRvcnMsIHJlc3VsdCk7XG59O1xuXG5jb25zdCBnZXRGaWVsZFZhbGlkYXRvcnMgPSAobmFtZSwgdmFsaWRhdG9ycykgPT4ge1xuICAgIHJldHVybiB2YWxpZGF0b3JzICYmIHZhbGlkYXRvcnMuZmllbGRzICYmIHZhbGlkYXRvcnMuZmllbGRzW25hbWVdXG4gICAgICAgID8gdmFsaWRhdG9ycy5maWVsZHNbbmFtZV1cbiAgICAgICAgOiBbXTtcbn07XG5cbmNvbnN0IHJ1bkZpZWxkVmFsaWRhdG9ycyA9IGFzeW5jIChmaWVsZE5hbWUsIHZhbHVlLCB2YWxpZGF0b3JzLCByZXN1bHQpID0+IHtcbiAgICBmb3IgKGxldCB2YWxpZGF0b3JSdWxlIG9mIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gYXdhaXQgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvclJ1bGVbXCJ2YWxpZGF0b3JcIl0sXG4gICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzZXRGaWVsZEVycm9yKGZpZWxkTmFtZSwgdmFsaWRhdG9yUnVsZS5tZXNzYWdlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIG5vdFZhaWxkYXRpb25FcnJvciB8fCAhdmFsaWRhdG9yUnVsZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIHZhbGlkYXRvclJ1bGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHNldEZpZWxkRXJyb3IgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZUZvcm0gPSBhc3luYyAoeyB2YWxpZGF0b3JzLCBkYXRhLCByZXN1bHQgfSkgPT4ge1xuICAgIGNvbnN0IGZvcm1WYWxpZGF0b3JzID0gZ2V0Rm9ybVZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgYXdhaXQgcnVuRm9ybVZhbGlkYXRvcnMoZGF0YSwgZm9ybVZhbGlkYXRvcnMsIHJlc3VsdCk7XG59O1xuXG5jb25zdCBnZXRGb3JtVmFsaWRhdG9ycyA9ICh2YWxpZGF0b3JzKSA9PiB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnMgJiYgdmFsaWRhdG9ycy5mb3JtID8gdmFsaWRhdG9ycy5mb3JtIDogW107XG59O1xuXG5jb25zdCBydW5Gb3JtVmFsaWRhdG9ycyA9IGFzeW5jIChkYXRhLCBmb3JtVmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgdmFsaWRhdG9yIG9mIGZvcm1WYWxpZGF0b3JzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB2YWxpZGF0b3IoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmIHR5cGVvZiBlLmdldEZpZWxkc0Vycm9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IGUuZ2V0RmllbGRzRXJyb3JzKCk7XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShmb3JtRXJyb3JzLmZvcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1FcnJvcnMoZm9ybUVycm9ycy5mb3JtLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMuZmllbGRzICYmXG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1GaWVsZHNFcnJvcnMoZm9ybUVycm9ycy5maWVsZHMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRXJyb3JzID0gKGVycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgZXJyb3JzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFkZEZvcm1FcnJvcihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGFkZEZvcm1FcnJvciA9IChlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmZvcm0uZXJyb3JzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRzRXJyb3JzID0gKGZpZWxkc0Vycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgZmllbGROYW1lIGluIGZpZWxkc0Vycm9ycykge1xuICAgICAgICBhZGRGb3JtRmllbGRFcnJvcnMoZmllbGROYW1lLCBmaWVsZHNFcnJvcnNbZmllbGROYW1lXSwgcmVzdWx0KTtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRFcnJvcnMgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2VzLCByZXN1bHQpID0+IHtcbiAgICBlcnJvck1lc3NhZ2VzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFkZEZvcm1GaWVsZEVycm9yKGZpZWxkTmFtZSwgZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRFcnJvciA9IChmaWVsZE5hbWUsIGVycm9yTWVzc2FnZSwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICByZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0ucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgIH1cbn07XG4iLCJjb25zdCBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyA9IChkYXRhLCB2YWxpZGF0b3JzTGliKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRvcnNMaWIgJiYgdmFsaWRhdG9yc0xpYi5maWVsZHMpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRvcnNMaWIuZmllbGRzW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSB2YWxpZGF0b3JzTGliLmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcblxuY29uc3QgY29tcG9zZUZvcm1WYWxpZGF0b3JzID0gKG5hbWUsIHZhbGlkYXRvcnNMaWIpID0+IHtcbiAgICBpZiAoIXZhbGlkYXRvcnNMaWIpIHJldHVybiBbXTtcbiAgICBpZiAodmFsaWRhdG9yc0xpYi5mb3JtcyAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnNMaWIuZm9ybXNbbmFtZV0pKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzTGliLmZvcm1zW25hbWVdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzTGliLmZvcm0pKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzTGliLmZvcm07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXBvc2VGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGNvbXBvc2VGb3JtVmFsaWRhdG9ycyxcbn07XG4iLCJjb25zdCB7XG4gICAgY29tcG9zZUZpZWxkc1ZhbGlkYXRvcnMsXG4gICAgY29tcG9zZUZvcm1WYWxpZGF0b3JzLFxufSA9IHJlcXVpcmUoXCIuL3J1bm5lci51dGlscy5qc1wiKTtcblxuY29uc3QgVmFsaWRhdGlvblNlc3Npb24gPSByZXF1aXJlKFwiLi9zZXNzaW9uLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgdmFsaWRhdGlvbiBydW5uZXIgZnVuY3Rpb24gZnJvbSBwcm92aWRlZCB2YWxpZGF0aW9uIHJ1bGVzIGxpYlxuICogQHBhcmFtIHtvYmplY3R9ICAgICB2YWxpZGF0aW9uTGliIG9iamVjdCBjb250YWluaW5nIGZpZWxkcyB2YWxpZGF0aW9uIHJ1bGVzIGFuZCBmb3JtIHNwZWNpZmljIHJ1bGVzXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IChkYXRhOiBvYmplY3QsIGZvcm1OYW1lOiBzdHJpbmcpPT5Qcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+XG4gKiovXG5jb25zdCBWYWxpZGF0aW9uUnVubmVyID0gKHZhbGlkYXRvcnNMaWIpID0+IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0aW9uIHNlc3Npb24gcnVubmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgICAgICBvYmplY3QgdG8gdmFsaWRhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybU5hbWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiovXG4gICAgcmV0dXJuIChkYXRhLCBmb3JtTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0ge1xuICAgICAgICAgICAgLy9maWVsZHMgc3BlY2lmaWMgdmFsaWRhdG9yc1xuICAgICAgICAgICAgZmllbGRzOiBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyhkYXRhLCB2YWxpZGF0b3JzTGliKSxcbiAgICAgICAgICAgIC8vZm9ybSBzcGVjaWZpYyB2YWxpZGF0b3JzXG4gICAgICAgICAgICBmb3JtOiBjb21wb3NlRm9ybVZhbGlkYXRvcnMoZm9ybU5hbWUsIHZhbGlkYXRvcnNMaWIpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblNlc3Npb24odmFsaWRhdG9ycywgZGF0YSk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblJ1bm5lcjtcbiIsImNvbnN0IGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzID0gKGZpZWxkVmFsaWRhdG9ycywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuIGZpZWxkVmFsaWRhdG9ycy5tYXAoKGZpZWxkUnVsZSkgPT5cbiAgICAgICAgYXVnbWVudEZpZWxkVmFsaWRhdG9yKGZpZWxkUnVsZSwgZ2V0VmFsaWRhdG9yRW52KVxuICAgICk7XG59O1xuXG5jb25zdCBhdWdtZW50RmllbGRWYWxpZGF0b3IgPSAocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgaWYgKHJ1bGUudmFsaWRhdG9yICYmIHR5cGVvZiBydWxlLnZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVWYWxpZGF0b3IgPSBydWxlLnZhbGlkYXRvcjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLi4ucnVsZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC52YWxpZGF0b3I7XG4gICAgICAgIHJlc3VsdC52YWxpZGF0b3IgPSAodmFsKSA9PiBydWxlVmFsaWRhdG9yKHZhbCwgZ2V0VmFsaWRhdG9yRW52KCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmNvbnN0IGF1Z21lbnRGb3JtVmFsaWRhdG9ycyA9IChydWxlcywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuIHJ1bGVzLm1hcCgocnVsZSkgPT4gYXVnbWVudEZvcm1WYWxpZGF0b3IocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSk7XG59O1xuXG5jb25zdCBhdWdtZW50Rm9ybVZhbGlkYXRvciA9IChydWxlLCBnZXRWYWxpZGF0b3JFbnYpID0+IHtcbiAgICByZXR1cm4gKHZhbCkgPT4gcnVsZSh2YWwsIGdldFZhbGlkYXRvckVudigpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGF1Z21lbnRGaWVsZFZhbGlkYXRvcixcbiAgICBhdWdtZW50Rm9ybVZhbGlkYXRvcnMsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3IsXG59O1xuIiwiY29uc3Qgb2JqSGFzID0gKG9iaiwgbmFtZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBuYW1lKTtcbn07XG5jb25zdCB7XG4gICAgYXVnbWVudEZpZWxkc1ZhbGlkYXRvcnMsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3JzLFxufSA9IHJlcXVpcmUoXCIuL2J1aWxkZXIudXRpbHNcIik7XG5cbi8qKlxuICogQHR5cGVkZWYgICB7b2JqZWN0fSAgICBub3RWYWxpZGF0aW9uU2NoZW1hXG4gKiBAcHJvcGVydHkgIHtvYmplY3R9ICAgIFtmaWVsZHNdXG4gKiBAcHJvcGVydHkgIHthcnJheX0gICAgIFtmb3JtXVxuICogQHByb3BlcnR5ICB7b2JqZWN0fSAgICBbZm9ybXNdXG4gKi9cblxuLyoqXG4gKiByZXR1cm5zIHZhbGlkIGVtcHR5IHZhbGlkYXRpb24gc2NoZW1lXG4gKlxuICogQHJldHVybiB7bm90VmFsaWRhdGlvblNjaGVtYX1cbiAqL1xuY29uc3QgZW1wdHlTY2hlbWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgZm9ybXM6IHt9LFxuICAgIH07XG59O1xuLyoqXG4gKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWxpZGF0b3JzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRWYWxpZGF0b3JFbnZcbiAqIEByZXR1cm4ge25vdFZhbGlkYXRpb25TY2hlbWF9XG4gKi9cbmNvbnN0IHZhbGlkYXRpb25CdWlsZGVyID0gKHZhbGlkYXRvcnMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9ycyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWxpZGF0b3JzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVNjaGVtZSgpO1xuICAgIH1cbiAgICBjb25zdCBhdWdtZW50ZWQgPSB7fTtcbiAgICBpZiAob2JqSGFzKHZhbGlkYXRvcnMsIFwiZmllbGRzXCIpKSB7XG4gICAgICAgIGF1Z21lbnRlZC5maWVsZHMgPSB0cmFuc2Zvcm1GaWVsZHNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgdmFsaWRhdG9ycy5maWVsZHMsXG4gICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9iakhhcyh2YWxpZGF0b3JzLCBcImZvcm1zXCIpKSB7XG4gICAgICAgIGF1Z21lbnRlZC5mb3JtcyA9IHRyYW5zZm9ybUZvcm1zVmFsaWRhdG9ycyhcbiAgICAgICAgICAgIHZhbGlkYXRvcnMuZm9ybXMsXG4gICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2JqSGFzKHZhbGlkYXRvcnMsIFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgYXVnbWVudGVkLmZvcm0gPSBhdWdtZW50Rm9ybVZhbGlkYXRvcnMoXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5mb3JtLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0aW9uQnVpbGRlcjtcblxuY29uc3QgdHJhbnNmb3JtRmllbGRzVmFsaWRhdG9ycyA9IChmaWVsZHMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGNvbnN0IGF1Z21lbnRlZCA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICBhdWdtZW50ZWRbZmllbGROYW1lXSA9IGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcblxuY29uc3QgdHJhbnNmb3JtRm9ybXNWYWxpZGF0b3JzID0gKGZvcm1zVmFsaWRhdG9ycywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgY29uc3QgYXVnbWVudGVkID0ge307XG4gICAgZm9yIChsZXQgZm9ybU5hbWUgaW4gZm9ybXNWYWxpZGF0b3JzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1zVmFsaWRhdG9yc1tmb3JtTmFtZV0pKSB7XG4gICAgICAgICAgICBhdWdtZW50ZWRbZm9ybU5hbWVdID0gYXVnbWVudEZvcm1WYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIGZvcm1zVmFsaWRhdG9yc1tmb3JtTmFtZV0sXG4gICAgICAgICAgICAgICAgZ2V0VmFsaWRhdG9yRW52XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdWdtZW50ZWQ7XG59O1xuIiwiY29uc3QgU2Vzc2lvbiA9IHJlcXVpcmUoXCIuL3Nlc3Npb25cIik7XG5jb25zdCBSdW5uZXIgPSByZXF1aXJlKFwiLi9ydW5uZXJcIik7XG5jb25zdCBCdWlsZGVyID0gcmVxdWlyZShcIi4vYnVpbGRlclwiKTtcbmNvbnN0IFJlc3VsdCA9IHJlcXVpcmUoXCIuL3Jlc3VsdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmFtZTogXCJub3QtdmFsaWRhdGlvblwiLFxuICAgIFNlc3Npb24sXG4gICAgUnVubmVyLFxuICAgIEJ1aWxkZXIsXG4gICAgUmVzdWx0LFxufTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2lucHV0L3VpLmxhYmVsLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xhYmVsXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtob3Jpem9udGFsXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY29udHJvbHNdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uLy4uL2VsZW1lbnRzL2V2ZW50cy50eXBlcycpLlVJRXZlbnRJbnB1dENoYW5nZUNhbGxiYWNrfSBvbmNoYW5nZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlc10gLSBmaWVsZCBzdHlsZSBtb2RpZmljYXRpb25cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNdIC0gLy9hZGRvbnNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNDZW50ZXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNSaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cGVkXSAtIC8vZ3JvdXAgZmxhZ1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRNdWx0aWxpbmVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXBlZFJpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRDZW50ZXJlZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgbGFiZWwgPSBcIlwiLFxuICAgICAgICBuYW1lID0gXCJnZW5lcmljIGZpZWxkXCIsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGhvcml6b250YWwgPSBmYWxzZSxcbiAgICAgICAgY29udHJvbHMgPSBbXSxcbiAgICAgICAgY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGFkZG9ucyA9IGZhbHNlLFxuICAgICAgICBhZGRvbnNDZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICBhZGRvbnNSaWdodCA9IGZhbHNlLFxuICAgICAgICBncm91cGVkID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRNdWx0aWxpbmUgPSBmYWxzZSxcbiAgICAgICAgZ3JvdXBlZFJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRDZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIGZvcm1GaWVsZFByZWZpeCA9IFwiZm9ybS1maWVsZC1cIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgZmllbGRDbGFzc2VzID0gJHN0YXRlKFwiXCIpO1xuICAgIGxldCBoaWRkZW4gPSAkc3RhdGUoZmFsc2UpO1xuICAgIGxldCBmaWVsZElkID0gJHN0YXRlKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IFwiIFwiICsgY2xhc3NlcztcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9ucyA/IFwiIGhhcy1hZGRvbnMgXCIgOiBcIlwiO1xuICAgICAgICBmaWVsZENsYXNzZXMgKz0gYWRkb25zQ2VudGVyZWQgPyBcIiBoYXMtYWRkb25zLWNlbnRlcmVkIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9uc1JpZ2h0ID8gXCIgaGFzLWFkZG9ucy1yaWdodCBcIiA6IFwiXCI7XG5cbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWQgPyBcIiBpcy1ncm91cGVkIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWRNdWx0aWxpbmUgPyBcIiBpcy1ncm91cGVkLW11bHRpbGluZSBcIiA6IFwiXCI7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBncm91cGVkUmlnaHQgPyBcIiBpcy1ncm91cGVkLXJpZ2h0IFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWRDZW50ZXJlZCA/IFwiIGlzLWdyb3VwZWQtY2VudGVyZWQgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICAgICAgY29udHJvbHMuZm9yRWFjaCgoY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm90SGlkZGVuID0gY29udHJvbHMuZmlsdGVyKFxuICAgICAgICAgICAgKGNvbnRyb2wpID0+IGNvbnRyb2wuY29tcG9uZW50ICE9PSBcIlVJSGlkZGVuXCJcbiAgICAgICAgKTtcbiAgICAgICAgaGlkZGVuID0gbm90SGlkZGVuLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgbGV0IHRtcCA9IGNvbnRyb2xzLm1hcCgoaXRtKSA9PiBpdG0uY29tcG9uZW50KS5qb2luKFwiX1wiKTtcbiAgICAgICAgZmllbGRJZCA9IGAke2Zvcm1GaWVsZFByZWZpeH0ke3RtcH0tJHtuYW1lfWA7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBoaWRkZW59XG4gICAgeyNlYWNoIGNvbnRyb2xzIGFzIGNvbnRyb2x9XG4gICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoY29udHJvbC5jb21wb25lbnQpfVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50IHsuLi5jb250cm9sfSB7b25jaGFuZ2V9IGZpZWxkbmFtZT17bmFtZX0gLz5cbiAgICB7L2VhY2h9XG57OmVsc2UgaWYgaG9yaXpvbnRhbH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtaG9yaXpvbnRhbCB7ZmllbGRDbGFzc2VzfSB7ZmllbGRJZH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkLWxhYmVsIGlzLW5vcm1hbFwiPlxuICAgICAgICAgICAgPFVJTGFiZWwgZm9yPXtmaWVsZElkfSBsYWJlbD17bGFiZWwgfHwgY29udHJvbHNbMF0ubGFiZWx9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQtYm9keVwiIGlkPXtmaWVsZElkfT5cbiAgICAgICAgICAgIHsjZWFjaCBjb250cm9scyBhcyBjb250cm9sfVxuICAgICAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50XzEgPSBDT01QT05FTlRTLmdldChjb250cm9sLmNvbXBvbmVudCl9XG4gICAgICAgICAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudF8xIHsuLi5jb250cm9sfSB7b25jaGFuZ2V9IGZpZWxkbmFtZT17bmFtZX0gLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG57OmVsc2V9XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkIHtmaWVsZENsYXNzZXN9IHtmaWVsZElkfVwiPlxuICAgICAgICB7I2VhY2ggY29udHJvbHMgYXMgY29udHJvbH1cbiAgICAgICAgICAgIDxVSUxhYmVsXG4gICAgICAgICAgICAgICAgZm9yPVwiZm9ybS1maWVsZC17Y29udHJvbC5jb21wb25lbnR9LXtuYW1lfVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e2NvbnRyb2wubGFiZWx9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnRfMiA9IENPTVBPTkVOVFMuZ2V0KGNvbnRyb2wuY29tcG9uZW50KX1cbiAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnRfMiB7Li4uY29udHJvbH0ge29uY2hhbmdlfSBmaWVsZG5hbWU9e25hbWV9IC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXBhZ2Vsb2FkZXJcIjtcbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vbG9jYWxlXCI7XG5cbiAgICBpbXBvcnQgVUlGaWVsZCBmcm9tIFwiLi9maWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgRm9ybUhlbHBlcnMgZnJvbSBcIi4vZm9ybS5oZWxwZXJzLmpzXCI7XG5cbiAgICAvL3ZhbGlkYXRpb24gc3RhdHVzXG4gICAgbGV0IGZvcm1FcnJvcnMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBmb3JtSGFzRXJyb3JzID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgZmllbGRzSGFzRXJyb3JzID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgc3VjY2VzcyA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgICAvL2lucHV0IGRhdGFcbiAgICAvL2Zvcm0gc3RydWN0dXJlIG9iamVjdFxuXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuXG4gICAgLy9maWVsZHMgbGlzdCBzdHJ1Y3R1cmVcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtmb3JtXSAtIHtcbltmaWVsZE5hbWU6IHN0cmluZ10gPT4gZGVzY3JpcHRpb246IG9iamVjdFxufVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddIC0gc3RhdGUgaWYgZm9ybSBsb2FkaW5nXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2FkZXJdIC0gcGFnZSAtIHdob2xlIHBhZ2VcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ZpZWxkc10gLSBlYWNoIGl0ZW0gaXMgYSByb3dcbmlmIGl0ZW0gaXMgYXJyYXksIHRoZW4gdGhlcmUgZmV3IGZpZWxkcyBpbiBhIHJvd1xuW1xuW25hbWUsIGFnZV0sXG5bZW1haWwsIHRlbGVwaG9uZV1cbmJpbyxcbmFncmVlZFxuXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbU1VDQ0VTU19URVhUXSAtIGZvcm0gcmVzdWx0IGxhYmVsc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbV0FJVElOR19URVhUXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdIC0gZm9ybSBsYWJlbHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1dHRvbnNGaXJzdF0gLSBpZiB5b3Ugd2FudCBidXR0b24gb24gdG9wXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaG9yaXpvbnRhbF0gLSBpZiBmb3JtIGZpZWxkcyBzaG91bGQgaGF2ZSBob3Jpem9udGFsIGxheW91dFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc3VibWl0XSAtIGJ1dHRvbnMgbGFiZWxzIGFuZCBhdmFpbGFiaWxpdHlcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2NhbmNlbF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZm9ybSA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIGxvYWRpbmcgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBsb2FkZXIgPSBcImNvbnRhaW5lclwiLFxuICAgICAgICBmaWVsZHMgPSBbXSxcbiAgICAgICAgU1VDQ0VTU19URVhUID0gXCLQntC/0LXRgNCw0YbQuNGPINC30LDQstC10YDRiNC10L3QsFwiLFxuICAgICAgICBXQUlUSU5HX1RFWFQgPSBcItCe0YLQv9GA0LDQstC60LAg0LTQsNC90L3Ri9GFINC90LAg0YHQtdGA0LLQtdGAXCIsXG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb24gPSBcIlwiLFxuICAgICAgICBidXR0b25zRmlyc3QgPSBmYWxzZSxcbiAgICAgICAgaG9yaXpvbnRhbCA9IGZhbHNlLFxuICAgICAgICBzdWJtaXQgPSB7XG4gICAgICAgICAgICBjYXB0aW9uOiBcItCe0YLQv9GA0LDQstC40YLRjFwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsID0ge1xuICAgICAgICAgICAgY2FwdGlvbjogXCLQndCw0LfQsNC0XCIsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBmb3JtSW52YWxpZCA9ICRkZXJpdmVkKGZvcm1IYXNFcnJvcnMgfHwgZmllbGRzSGFzRXJyb3JzKTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1IZWxwZXJzLmNvbGxlY3REYXRhKGZpZWxkcywgZm9ybSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEZpZWxkSW52YWxpZChmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpO1xuICAgICAgICBmaWVsZHNIYXNFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZFZhbGlkKGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRmllbGRWYWxpZChmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1IZWxwZXJzLmlzRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGb3JtRmllbGRJbnZhbGlkKGZpZWxkTmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIGZvcm0gPSBGb3JtSGVscGVycy5zZXRGb3JtRmllbGRJbnZhbGlkKGZvcm0sIGZpZWxkTmFtZSwgZXJyb3JzKTtcbiAgICAgICAgZGlzcGF0Y2goYGZpZWxkLmludmFsaWRgLCB7XG4gICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGb3JtRmllbGRWYWxpZChmaWVsZE5hbWUpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgIGRpc3BhdGNoKGBmaWVsZC52YWxpZGAsIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKFxuICAgICAgICB2YWxpZGF0aW9uU3RhdHVzIC8qIEZvcm1WYWxpZGF0aW9uU2Vzc2lvbi5nZXRDb21wbGV0ZVJlc3VsdCgpICovXG4gICAgKSB7XG4gICAgICAgIGZvcm1IYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgZmllbGRzSGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5mb3JtKSAmJlxuICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5mb3JtLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoLCAuLi52YWxpZGF0aW9uU3RhdHVzLmZvcm0pO1xuICAgICAgICAgICAgZm9ybUhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtRXJyb3JzLnNwbGljZSgwLCBmb3JtRXJyb3JzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybUVycm9ycyA9IGZvcm1FcnJvcnM7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICAgICAgZm9yIChsZXQgZmllbGROYW1lIG9mIE9iamVjdC5rZXlzKGZvcm0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZEludmFsaWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNIYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dTdWNjZXNzKCkge1xuICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNWaXNpYmlsaXR5KGZpZWxkc0xpc3QsIHZhbCkge1xuICAgICAgICBpZiAoRm9ybUhlbHBlcnMuc2V0RmllbGRzVmlzaWJpbGl0eShmb3JtLCBmaWVsZHNMaXN0LCB2YWwpKSB7XG4gICAgICAgICAgICBmb3JtID0gZm9ybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRWaXNpYmxlRmllbGRzKGZpZWxkc0xpc3QpIHtcbiAgICAgICAgc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0SW52aXNpYmxlRmllbGRzKGZpZWxkc0xpc3QpIHtcbiAgICAgICAgc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEZpZWxkVmFsdWUoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoRm9ybUhlbHBlcnMuc2V0RmllbGRWYWx1ZShmb3JtLCBmaWVsZE5hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgb25GaWVsZENoYW5nZSh7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGaWVsZChmaWVsZE5hbWUsIHByb3BzKSB7XG4gICAgICAgIGZvcm1bZmllbGROYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLmZvcm1bZmllbGROYW1lXSxcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtID0gZm9ybTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkZpZWxkQ2hhbmdlKGV2KSB7XG4gICAgICAgIGxldCBkYXRhID0gZXYuZGV0YWlsO1xuICAgICAgICBmb3JtW2RhdGEuZmllbGRdLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgZm9ybSA9IGZvcm07XG4gICAgICAgIGRpc3BhdGNoKFwiY2hhbmdlXCIsIGRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1Ym1pdEZvcm0oZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2goXCJzdWJtaXRcIiwgY29sbGVjdERhdGEoKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3RGb3JtKCkge1xuICAgICAgICBkaXNwYXRjaChcInJlamVjdFwiKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImZvcm0tY29udGFpbmVyXCI+XG4gICAgeyNpZiBsb2FkZXIgIT09IFwiaGlkZGVuXCJ9XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwie2xvYWRlciA9PT0gJ3BhZ2UnXG4gICAgICAgICAgICAgICAgPyAncGFnZWxvYWRlcidcbiAgICAgICAgICAgICAgICA6ICdjb250YWluZXJsb2FkZXInfSB7bG9hZGluZyA/ICdpcy1hY3RpdmUnIDogJyd9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPnskTE9DQUxFW1dBSVRJTkdfVEVYVF19PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBzdWNjZXNzfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uIGlzLXN1Y2Nlc3NcIj5cbiAgICAgICAgICAgIDxoMyBjbGFzcz1cImZvcm0tc3VjY2Vzcy1tZXNzYWdlXCI+eyRMT0NBTEVbU1VDQ0VTU19URVhUXX08L2gzPlxuICAgICAgICA8L2Rpdj5cbiAgICB7OmVsc2V9XG4gICAgICAgIHsjaWYgdGl0bGV9XG4gICAgICAgICAgICA8aDUgY2xhc3M9XCJ0aXRsZSBpcy01XCI+eyRMT0NBTEVbdGl0bGVdfTwvaDU+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8aDYgY2xhc3M9XCJzdWJ0aXRsZSBpcy02XCI+eyRMT0NBTEVbZGVzY3JpcHRpb25dfTwvaDY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgYnV0dG9uc0ZpcnN0fVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaXMtZ3JvdXBlZCBpcy1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgIHsjaWYgY2FuY2VsLmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIGlzLW91dGxpbmVkIHtjYW5jZWwuY2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17cmVqZWN0Rm9ybX0+eyRMT0NBTEVbY2FuY2VsLmNhcHRpb25dfTwvYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsjaWYgc3VibWl0LmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3N1Ym1pdEZvcm19XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Zm9ybUludmFsaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1wcmltYXJ5IGlzLWhvdmVyZWQge3N1Ym1pdC5jbGFzc2VzfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+eyRMT0NBTEVbc3VibWl0LmNhcHRpb25dfTwvYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsjaWYgZm9ybUVycm9ycy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlZGl0LWZvcm0tZXJyb3Igbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICB7Zm9ybUVycm9ycy5qb2luKFwiLCBcIil9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2lmfVxuXG4gICAgICAgIHsjZWFjaCBmaWVsZHMgYXMgZmllbGR9XG4gICAgICAgICAgICB7I2lmIEFycmF5LmlzQXJyYXkoZmllbGQpfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBmaWVsZCBhcyBzdWJmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtzdWJmaWVsZF0gJiYgZm9ybVtzdWJmaWVsZF0uY29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtzdWJmaWVsZF0udmlzaWJsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4ge2Zvcm1bc3ViZmllbGRdLmZpZWxkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2lzLScgKyBmb3JtW3N1YmZpZWxkXS5maWVsZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VUlGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzPXtbZm9ybVtzdWJmaWVsZF1dfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17b25GaWVsZENoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtzdWJmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aG9yaXpvbnRhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17Zm9ybVtzdWJmaWVsZF0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJmaWVsZCAne3N1YmZpZWxkfScgaXMgbm90IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHs6ZWxzZSBpZiBmb3JtW2ZpZWxkXSAmJiBmb3JtW2ZpZWxkXS5jb21wb25lbnR9XG4gICAgICAgICAgICAgICAgeyNpZiBmb3JtW2ZpZWxkXS52aXNpYmxlfVxuICAgICAgICAgICAgICAgICAgICA8VUlGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbHM9e1tmb3JtW2ZpZWxkXV19XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uRmllbGRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtob3Jpem9udGFsfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2Zvcm1bZmllbGRdLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbiBpcy1kYW5nZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgRmllbGQgJ3tmaWVsZH0nIGlzIG5vdCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG5cbiAgICAgICAgeyNpZiAhYnV0dG9uc0ZpcnN0fVxuICAgICAgICAgICAgeyNpZiBmb3JtRXJyb3JzLmxlbmd0aCA+IDB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVkaXQtZm9ybS1lcnJvciBub3RpZmljYXRpb24gaXMtZGFuZ2VyXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBmb3JtRXJyb3JzIGFzIGZvcm1FcnJvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW2Zvcm1FcnJvcl19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaXMtZ3JvdXBlZCBpcy1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgIHsjaWYgY2FuY2VsLmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIHtjYW5jZWwuY2xhc3NlcyA/IGNhbmNlbC5jbGFzc2VzIDogJyd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3JlamVjdEZvcm19PnskTE9DQUxFW2NhbmNlbC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7I2lmIHN1Ym1pdC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtzdWJtaXRGb3JtfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Zvcm1JbnZhbGlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBpcy1ob3ZlcmVkIHtzdWJtaXQuY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3VibWl0LmNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfVwiPnskTE9DQUxFW3N1Ym1pdC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIHsvaWZ9XG48L2Rpdj5cbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG5jb25zdCBERUZBVUxUX1JVTEVTID0ge1xuICAgIG5vdFJlYWRvbmx5KHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWRvbmx5OiAhdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWRvbmx5KHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWRvbmx5OiB2LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW5hYmxlKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiAhdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRpc2FibGUodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHYsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIG5vdEZvcm1SdWxlcyB7XG4gICAgc3RhdGljICNSVUxFUyA9IHsgLi4uREVGQVVMVF9SVUxFUyB9O1xuXG4gICAgc3RhdGljIGFkZChuYW1lLCBmdW5jKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyh0aGlzLiNSVUxFUywgbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuI1JVTEVTW25hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUobmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKHRoaXMuI1JVTEVTLCBuYW1lKSAmJlxuICAgICAgICAgICAgIU9iamVjdC5rZXlzKERFRkFVTFRfUlVMRVMpLmluY2x1ZGVzKG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuI1JVTEVTW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGV4ZWMocnVsZSwgbWFzdGVyLCBzbGF2ZXMsIHZhbHVlLCBmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNSVUxFU1tydWxlXSh2YWx1ZSwgbWFzdGVyLCBzbGF2ZXMsIGZvcm0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJub3QtdmFsaWRhdGlvblwiO1xuXG5pbXBvcnQgeyBWQVJJQU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbmltcG9ydCBMaWIgZnJvbSBcIi4uLy4uL2xpYi5qc1wiO1xuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vLi4vYmFzZVwiO1xuXG5pbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IEZvcm1IZWxwZXJzIGZyb20gXCIuL2Zvcm0uaGVscGVycy5qc1wiO1xuaW1wb3J0IFVJRm9ybUNvbXBvbmVudCBmcm9tIFwiLi9mb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IG5vdEZvcm1SdWxlcyBmcm9tIFwiLi9mb3JtLnJ1bGVzLmpzXCI7XG5cbmltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vY29uc3RcIjtcblxuY29uc3QgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIi5mb3JtXCI7XG5jb25zdCBERUZBVUxUX0FDVElPTl9OQU1FID0gXCJkZWZhdWx0XCI7XG5cbmNsYXNzIG5vdEZvcm0gZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvL1VJIHJlbmRlcmVyIGNvbXBvbmVudCBjbGFzcyBjb25zdHJ1Y3RvclxuICAgICN1aUNvbXBvbmVudCA9IG51bGw7XG4gICAgLy9mb3JtIHZhbGlkYXRpb25cbiAgICAjdmFsaWRhdGlvblJ1bm5lciA9IG51bGw7XG4gICAgLy91aSBjb21wb25lbnRcbiAgICAjZm9ybSA9IG51bGw7XG4gICAgLy9tb2RlbC5hY3Rpb25cbiAgICAjYWN0aW9uID0gREVGQVVMVF9BQ1RJT05fTkFNRTtcbiAgICAvL2ZpZWxkcyBzY2hlbWFzXG4gICAgI2ZpZWxkcyA9IG5ldyBMaWIoKTsgLy9maWVsZHMgb2YgVUlcbiAgICAvL3ZhcmlhbnRzIHNldHMgZm9yIHNlbGVjdCBtZW51cyBhbmQgc28gb25cbiAgICAjdmFyaWFudHMgPSBudWxsOyAvL3ZhcmlhbnRzIGZvciBVSVxuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgICBuYW1lID0gXCJEZWZhdWx0XCIsXG4gICAgICAgIG9wdGlvbnMgPSB7fSxcbiAgICAgICAgd29ya2luZyA9IHt9LFxuICAgICAgICBkYXRhID0ge30sXG4gICAgICAgIHVpID0gVUlGb3JtQ29tcG9uZW50LCAvL2RlZmF1bHQgVUlcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtuYW1lfUZvcm1gLFxuICAgICAgICAgICAgICAgIC4uLndvcmtpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiN2YXJpYW50cyA9IG5ldyBMaWIoVkFSSUFOVFMuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdWlDb21wb25lbnQgPSB1aTtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXMob3B0aW9ucywgXCJhY3Rpb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuI2FjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdEZvcm0oKTtcbiAgICB9XG5cbiAgICBpbml0Rm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImF1dG9Jbml0XCIsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRMaWJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImF1dG9SZW5kZXJcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0TGlicygpIHtcbiAgICAgICAgdGhpcy5pbml0RmllbGRzKCk7XG4gICAgICAgIHRoaXMuaW5pdFZhcmlhbnRzKCk7XG4gICAgICAgIHRoaXMuaW5pdFZhbGlkYXRvcigpO1xuICAgIH1cblxuICAgIHJlSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0TGlicygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgaW5pdEZpZWxkcygpIHtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSB0aGlzLmdldEZvcm1NYW5pZmVzdCgpO1xuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhtYW5pZmVzdCwgXCJmaWVsZHNcIikgJiYgdGhpcy4jZmllbGRzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy4jZmllbGRzLmltcG9ydChtYW5pZmVzdC5maWVsZHMpOyAvL2FsbCBmaWVsZHMgYXZhaWxhYmxlIGluIG1vZGVsIG1hbmlmZXN0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0VmFyaWFudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJ2YXJpYW50c1wiKSkge1xuICAgICAgICAgICAgdGhpcy4jdmFyaWFudHMuaW1wb3J0KHRoaXMuZ2V0T3B0aW9ucyhcInZhcmlhbnRzXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vY3JlYXRpbmcgdmFsaWRhdG9ycyBydW5uZXIgZm9yIHRoaXMgc3BlY2lmaWMgZm9ybVxuICAgIGluaXRWYWxpZGF0b3IoKSB7XG4gICAgICAgIHRoaXMuI3ZhbGlkYXRpb25SdW5uZXIgPSBSdW5uZXIodGhpcy5nZXRGb3JtVmFsaWRhdG9ycygpKTtcbiAgICB9XG5cbiAgICBpbml0VUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuI2dldEZvcm1Qcm9wcyh7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3Q6IHRoaXMuZ2V0Rm9ybU1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgZm9ybU9wdGlvbnM6IHRoaXMuZ2V0Rm9ybU9wdGlvbnMoKSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmdldEZvcm1EYXRhKCksXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9wczogdGhpcy5nZXRGb3JtSW5qZWN0ZWRQcm9wcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEZvcm1UYXJnZXRFbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUNoaWxkKHRhcmdldC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBuZXcgdGhpcy4jdWlDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jYmluZFVJRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlRm9ybSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlVUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuI2dldEZvcm1Qcm9wcyh7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3Q6IHRoaXMuZ2V0Rm9ybU1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgZm9ybU9wdGlvbnM6IHRoaXMuZ2V0Rm9ybU9wdGlvbnMoKSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmdldEZvcm1EYXRhKCksXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9wczogdGhpcy5nZXRGb3JtSW5qZWN0ZWRQcm9wcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLiRzZXQocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm0oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICNiaW5kVUlFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuI2Zvcm0uJG9uKFwiY2hhbmdlXCIsICgpID0+IHRoaXMudmFsaWRhdGVGb3JtKCkpO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcImNoYW5nZVwiLCAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBldi5kZXRhaWwpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGBjaGFuZ2UuJHtldi5kZXRhaWwuZmllbGR9YCwgZXYuZGV0YWlsLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2Zvcm0uJG9uKFwic3VibWl0XCIsIChldikgPT4gdGhpcy5zdWJtaXQoZXYuZGV0YWlsKSk7XG4gICAgICAgIHRoaXMuI2Zvcm0uJG9uKFwicmVqZWN0XCIsICgpID0+IHRoaXMucmVqZWN0KCkpO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcImVycm9yXCIsICh7IGRldGFpbCB9KSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBkZXRhaWwpKTtcbiAgICAgICAgdGhpcy4jYmluZE1hc3RlclNsYXZlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgI2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgbWFzdGVycyA9IHRoaXMuZ2V0T3B0aW9ucyhcIm1hc3RlcnNcIiwgZmFsc2UpO1xuICAgICAgICBpZiAoIW1hc3RlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtYXN0ZXIgaW4gbWFzdGVycykge1xuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBtYXN0ZXJzW21hc3Rlcl07XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlTmFtZSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVTbGF2ZXMgPSBydWxlc1tydWxlTmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy4jYWRkTWFzdGVyU2xhdmVFdmVudHMocnVsZU5hbWUsIG1hc3RlciwgcnVsZVNsYXZlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAjYWRkTWFzdGVyU2xhdmVFdmVudHMocnVsZSwgbWFzdGVyLCBzbGF2ZXMgPSBbXSkge1xuICAgICAgICB0aGlzLm9uKGBjaGFuZ2UuJHttYXN0ZXJ9YCwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNleGVjU2xhdmVSdWxlKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoYGNoYW5nZS4ke21hc3Rlcn1gLCB0aGlzLmdldEZvcm1EYXRhKClbbWFzdGVyXSk7XG4gICAgfVxuXG4gICAgI2V4ZWNTbGF2ZVJ1bGUocnVsZSwgbWFzdGVyLCBzbGF2ZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IG5vdEZvcm1SdWxlcy5leGVjKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIHNsYXZlcy5mb3JFYWNoKChzbGF2ZUZpZWxkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkKHNsYXZlRmllbGQsIGNtZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHZhbGlkYXRlRm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInJlYWRvbmx5XCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy4jdmFsaWRhdGlvblJ1bm5lcihcbiAgICAgICAgICAgICAgICB0aGlzLiNmb3JtLmNvbGxlY3REYXRhKCksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGb3JtQWN0aW9uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLnVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKHZhbGlkYXRpb25SZXN1bHQuZ2V0UmVwb3J0KCkpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LmNsZWFuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgdmFsaWRhdGlvblJlc3VsdC5nZXRSZXBvcnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHtcbiAgICAgICAgICAgICAgICBmb3JtOiBbVUlDb21tb24uRVJST1JfREVGQVVMVCwgZS5tZXNzYWdlXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLiNmb3JtICYmIHRoaXMuI2Zvcm0udXBkYXRlRm9ybVZhbGlkYXRpb25TdGF0dXMocmVwb3J0KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHJlcG9ydCk7XG4gICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3VibWl0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VibWl0XCIsIGRhdGEpO1xuICAgIH1cblxuICAgIHJlamVjdCgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVqZWN0XCIpO1xuICAgIH1cblxuICAgIC8vYmluZGluZyBldmVudCB0byBhY3R1YWwgVUlcbiAgICAkb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLiRvbiguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TG9hZGluZygpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG9hZGluZ1wiKTtcbiAgICAgICAgdGhpcy4jZm9ybS5zZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgcmVzZXRMb2FkaW5nKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJsb2FkZWRcIik7XG4gICAgICAgIHRoaXMuI2Zvcm0ucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0uJGRlc3Ryb3kgJiYgdGhpcy4jZm9ybS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jZm9ybS5kZXN0cm95ICYmIHRoaXMuI2Zvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jZm9ybSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdmFsaWRhdGlvblJ1bm5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpZWxkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI3ZhcmlhbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG51bGwpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YShudWxsKTtcbiAgICB9XG5cbiAgICAjZ2V0Rm9ybVByb3BzKHtcbiAgICAgICAgbWFuaWZlc3QsIC8vbW9kZWwgbWFuaWZlc3RcbiAgICAgICAgZm9ybU9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1aToge30sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICB9LCAvL3NvbWUgb3B0aW9uc1xuICAgICAgICBkYXRhID0gbnVsbCwgLy9pbml0aWFsIGRhdGEgZm9yIGZvcm1cbiAgICAgICAgaW5qZWN0ZWRQcm9wcyA9IHt9LFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy4jYWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1PcHRpb25zID09PSBcInVuZGVmaW5lZFwiIHx8IGZvcm1PcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1aToge30sXG4gICAgICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb3JtID0gRm9ybUhlbHBlcnMuaW5pdEZvcm1CeUZpZWxkKFxuICAgICAgICAgICAgLy9mb3JtIHNlZWQgb2JqZWN0XG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIC8qXG4gICAgICBGb3JtIHN0cnVjdHVyZVxuICAgICAgW1xuICAgICAgICAvL2VhY2ggaXRlbSBpcyBsaW5lIG9mIGZvcm1cbiAgICAgICAgLy9maWVsZCAtIGZpZWxkIHRha2VzIHdob2xlIGxpbmUgb2YgZm9ybVxuICAgICAgICAvL1tmaWVsZDEsIGZpZWxkMl0gLSBmZXcgZmllbGRzIGluIG9uZSBsaW5lXG4gICAgICAgIG5hbWVGaXJzdCwgbmFtZUxhc3RcbiAgICAgICAgW2FnZSwgY291bnRyeSwgbGFuZ3VhZ2VdLFxuICAgICAgICBbZW1haWwsIHRlbGVwaG9uZV1cbiAgICAgIF1cbiAgICAgICovXG4gICAgICAgICAgICBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0uZmllbGRzLCAvL2Zvcm0gZmllbGRzIHN0cnVjdHVyZVxuICAgICAgICAgICAgdGhpcy4jdmFyaWFudHMsIC8vdmFyaWFudHMgbGlicmFyeVxuICAgICAgICAgICAgdGhpcy4jZmllbGRzLCAvL2ZpZWxkcyBsaWJyYXJ5XG4gICAgICAgICAgICBmb3JtT3B0aW9ucy5maWVsZHMsIC8vZm9ybSB3aWRlIGZpZWxkcyBvcHRpb25zXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vaWYgbm8gYXV0byBpbml0IG9mIGZvcm0gc3RydWN0dXJlLCBzZXQgdG8gbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgbG9hZGluZzogIXRoaXMuZ2V0T3B0aW9ucyhcImF1dG9Jbml0XCIsIHRydWUpLFxuICAgICAgICAgICAgdGl0bGU6IG1hbmlmZXN0LmFjdGlvbnNbYWN0aW9uXS50aXRsZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBmaWVsZHM6IG1hbmlmZXN0LmFjdGlvbnNbYWN0aW9uXS5maWVsZHMsXG4gICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgLy9pbmplY3Rpbmcgb3B0aW9ucyB0byBVSSBmcm9tIHRvcCBsZXZlbCBpbnB1dFxuICAgICAgICAgICAgLi4uZm9ybU9wdGlvbnMudWksIC8vZm9ybSBVSSBvcHRpb25zXG4gICAgICAgICAgICAuLi5pbmplY3RlZFByb3BzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJuYW1lXCIpO1xuICAgIH1cblxuICAgIGdldEZvcm1BY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhY3Rpb247XG4gICAgfVxuXG4gICAgc2V0Rm9ybUFjdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCAmJiB2YWwgIT09IHRoaXMuI2FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy4jYWN0aW9uID0gdmFsO1xuICAgICAgICAgICAgdGhpcy4jZm9ybSAmJiB0aGlzLiNmb3JtLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluaXRGb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gREVGQVVMVF9TVEFUVVNfU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtU3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1FcnJvcnMocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgRm9ybSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAqKi9cbiAgICBzZXRGb3JtU3VjY2VzcygpIHtcbiAgICAgICAgdGhpcy4jZm9ybS5zaG93U3VjY2VzcygpO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdWNjZXNzXCIpO1xuICAgIH1cblxuICAgIHNldEZvcm1FcnJvcnMocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJyZWFkb25seVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBmb3JtOiBbXSxcbiAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgc3RhdHVzLmZvcm0ucHVzaChyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiYgT2JqZWN0LmtleXMocmVzdWx0LmVycm9ycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdHVzLmZpZWxkcyA9IHsgLi4ucmVzdWx0LmVycm9ycyB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Zvcm0udXBkYXRlRm9ybVZhbGlkYXRpb25TdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgc3RhdHVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhcmlhbnQgYnkgY29sbGVjdGlvbiBuYW1lIGFuZCBpdGVtIGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgbmFtZSAgbmFtZSBvZiB0aGUgdmFyaWFudHMgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gIGlkICAgIGl0ZW0gaWRlbnRpZmljYXRvclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgICAgICAgICAgIGl0ZW1cbiAgICAgKiovXG4gICAgZ2V0VmFyaWFudChuYW1lLCBpZCkge1xuICAgICAgICBsZXQgbGliID0gdGhpcy4jdmFyaWFudHMuZ2V0KG5hbWUpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbGliLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKioqXG4gICAgICogUmVkZWZpbmFibGUgZ2V0dGVyc1xuICAgICAqKi9cblxuICAgIGdldEZvcm1UYXJnZXRFbCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLmdldE9wdGlvbnMoXCJ0YXJnZXRcIiwgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IpO1xuICAgICAgICBpZiAodGFyZ2V0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEVsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXRFbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0RWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9ybSBwYXJlbnQgZWxlbWVudCBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1WYWxpZGF0b3JzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidmFsaWRhdG9yc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcInZhbGlkYXRvcnNcIiwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcInZhbGlkYXRvcnNcIik7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtTWFuaWZlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMuZ2V0TW9kZWxOYW1lKCk7XG4gICAgICAgIGlmIChtb2RlbE5hbWUgJiYgbm90Q29tbW9uLmdldEFwcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpLmdldEludGVyZmFjZU1hbmlmZXN0KG1vZGVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcIm1hbmlmZXN0XCIsIHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFwiLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNtaXNzaW5nT3ZlcnJpZGVXYXJuaW5nKFwibWFuaWZlc3RcIik7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtRGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGF0YSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNtaXNzaW5nT3ZlcnJpZGVXYXJuaW5nKFwiZGF0YVwiKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1PcHRpb25zKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJ1aVwiLCB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwgdW5kZWZpbmVkKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWk6IHRoaXMuZ2V0T3B0aW9ucyhcInVpXCIsIHt9KSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiLCB7fSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcIm9wdGlvbnNcIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVpOiB7fSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1JbmplY3RlZFByb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW5qZWN0ZWRcIiwge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGVtcHR5IG1lc3NhZ2VcbiAgICAgKiovXG4gICAgI21pc3NpbmdPdmVycmlkZVdhcm5pbmcobWlzc2luZykge1xuICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgYCR7bWlzc2luZ30gZm9yICR7dGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKX0gZm9ybSBpcyBub3QgZGVmaW5lZGBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtIG9wZXJhdGlvbnNcbiAgICAgKiovXG4gICAgY29sbGVjdERhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJyZWFkb25seVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy4jZm9ybS5jb2xsZWN0RGF0YSgpO1xuICAgICAgICB0aGlzLnNldERhdGEoeyAuLi5kYXRhIH0pOyAvL3VwZGF0ZSBpbiBpbm5lciBzdG9yZVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB1cGRhdGVGaWVsZChmaWVsZE5hbWUsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuI2Zvcm0udXBkYXRlRmllbGQoZmllbGROYW1lLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgZ2V0TW9kZWwobmFtZSwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZShuYW1lKShkYXRhIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZSgpKG5hbWUgfHwge30pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJmYWNlKG5hbWUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpLmdldEludGVyZmFjZShuYW1lIHx8IHRoaXMuZ2V0TW9kZWxOYW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGN1cnJlbnQgbW9kZWwgbmFtZVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TW9kZWxOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibW9kZWxcIik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RGb3JtO1xuIiwiPHNjcmlwdD5cblxuICBpbXBvcnQgVUlCdXR0b25zIGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZSc7XG5cbiAgaW1wb3J0IHtcbiAgICAgIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcixcbiAgICAgIG9uTW91bnRcbiAgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvd01vZGVzXVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW21vZGVdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZm9ybXNdXG4gICAqL1xuXG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGxldCB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQtZm9ybScsXG4gICAgICBzaG93TW9kZXMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAkYmluZGFibGUoJ2RlZmF1bHQnKSxcbiAgICAgIGZvcm1zID0gW11cbiAgfSA9ICRwcm9wcygpO1xuXG4gIGZ1bmN0aW9uIHNldE1vZGUodmFsKSB7XG4gICAgICBtb2RlID0gdmFsO1xuICAgICAgZGlzcGF0Y2goJ21vZGUnLCB2YWwpO1xuICAgICAgdXBkYXRlTW9kZXNCdXR0b25zKCk7XG4gIH1cblxuICBsZXQgRk9STVNfQlVUVE9OUyA9ICRzdGF0ZShbXSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlTW9kZXNCdXR0b25zKCkge1xuICAgICAgRk9STVNfQlVUVE9OUyA9IGZvcm1zLmZpbHRlcihmb3JtID0+IHtcbiAgICAgICAgICByZXR1cm4gKG1vZGUgIT09IGZvcm0ubW9kZSk7XG4gICAgICB9KS5tYXAoZm9ybSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGl0bGU6IGZvcm0udGl0bGUsXG4gICAgICAgICAgICAgIG91dGxpbmVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgIGFjdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNldE1vZGUoZm9ybS5tb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9KTtcbiAgfVxuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgICAgdXBkYXRlTW9kZXNCdXR0b25zKCk7XG4gIH0pO1xuXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImJsb2NrLWNvbnRhaW5lclwiIGlkPVwie25hbWV9LWZvcm0tc2V0XCI+XG4gIDxkaXYgY2xhc3M9XCJmb3JtLXBhcGVyXCIgIGlkPVwie25hbWV9LWZvcm0tc2V0LWNvbnRhaW5lclwiPjwvZGl2PlxuICB7I2lmIHNob3dNb2Rlc31cbiAgPFVJQnV0dG9ucyBjZW50ZXJlZD17dHJ1ZX0gYmluZDp2YWx1ZXM9e0ZPUk1TX0JVVFRPTlN9IGNsYXNzZXM9J210LTQnIC8+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuLi8uLi9iYXNlXCI7XG5cbmltcG9ydCBVSUZvcm1TZXRDb21wb25lbnQgZnJvbSBcIi4vZm9ybS5zZXQuc3ZlbHRlXCI7XG5pbXBvcnQgVUlGb3JtQ29tcG9uZW50IGZyb20gXCIuL2Zvcm0uc3ZlbHRlXCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCIuZm9ybS1zZXRcIjtcbmNvbnN0IERFRkFVTFRfRk9STV9TRVRfTkFNRSA9IFwiZm9ybS1zZXRcIjtcblxuY2xhc3Mgbm90Rm9ybVNldCBleHRlbmRzIG5vdEJhc2Uge1xuICAgICNmb3JtU2V0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAjZm9ybUNvbXBvbmVudCA9IG51bGw7XG5cbiAgICAjZm9ybSA9IG51bGw7XG4gICAgI2ZyYW1lID0gbnVsbDtcblxuICAgIC8qXG4gIG5ldyBub3RGb3JtU2V0KHtcbiAgICBvcHRpb25zOntcbiAgICAgIHRhcmdldDogZWwsXG4gICAgICBmb3JtczogW3tcbiAgICAgICAgbW9kZTogJ2Zvcm0xJyxcbiAgICAgICAgdGl0bGU6ICdGb3JtIDEnLFxuICAgICAgICBmb3JtOiBmb3JtQ29uc3RydWN0b3IxIC8vY3VzdG9tIGNvbnN0cnVjdG9yc1xuICAgICAgfSx7XG4gICAgICAgIG1vZGU6ICdmb3JtMicsXG4gICAgICAgIHRpdGxlOiAnRm9ybSAyJyxcbiAgICAgICAgcHJvcHM6IHt9ICAgICAgICAgICAgIC8vcGFyYW1zIHRvIGNyZWF0ZSBub3RGb3JtIGluc3RhbmNlXG4gICAgICB9LHtcbiAgICAgICAgbW9kZTogJ2Zvcm0zJyxcbiAgICAgICAgdGl0bGU6ICdGb3JtIDMnLFxuICAgICAgICBmb3JtOiBmb3JtQ29uc3RydWN0b3IzIC8vY3VzdG9tIGNvbnN0cnVjdG9yc1xuICAgICAgfV1cbiAgICB9XG4gIH0pO1xuICAqL1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIGZvcm1Db21wb25lbnQgPSBVSUZvcm1Db21wb25lbnQsXG4gICAgICAgIGZvcm1TZXRDb21wb25lbnQgPSBVSUZvcm1TZXRDb21wb25lbnQsXG4gICAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogREVGQVVMVF9GT1JNX1NFVF9OQU1FLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIHNob3dNb2RlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2Zvcm1Db21wb25lbnQgPSBmb3JtQ29tcG9uZW50O1xuICAgICAgICB0aGlzLiNmb3JtU2V0Q29tcG9uZW50ID0gZm9ybVNldENvbXBvbmVudDtcbiAgICAgICAgdGhpcy5zZXRGb3JtTW9kZSh0aGlzLmdldE9wdGlvbnMoXCJtb2RlXCIpKTtcbiAgICAgICAgdGhpcy5pbml0VUkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0YWxpemluZyBmb3JtIGZyYW1lIG1vZGUsIHdpdGggc3dpdGNoZXJzIGJldHdlZW4gbW9kZXNcbiAgICAgKiovXG4gICAgaW5pdFVJKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEZyYW1lVGFyZ2V0RWwoKTtcbiAgICAgICAgd2hpbGUgKHRhcmdldC5jaGlsZHJlbi5sZW5ndGgpIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gbmV3IHRoaXMuI2Zvcm1TZXRDb21wb25lbnQoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcHJvcHM6IHRoaXMuI2dldEZyYW1lUHJvcHMoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ZyYW1lLiRvbihcIm1vZGVcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1Nb2RlKGV2LmRldGFpbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9ybSgpO1xuICAgIH1cblxuICAgIHNldEZvcm1Nb2RlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNb2RlRXhpc3RzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlXCIsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwibW9kZVwiLCB0aGlzLmdldEZpcnN0TW9kZSgpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybU1vZGVJblVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVGb3JtTW9kZUluVUkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNmcmFtZSAmJiB0aGlzLmdldFdvcmtpbmcoXCJtb2RlXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZS4kc2V0KHsgbW9kZTogdGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGb3JtKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lGb3JtKCk7XG4gICAgICAgIGlmICh0aGlzLmdldFdvcmtpbmcoXCJtb2RlXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlckZvcm0oKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5nZXRGb3JtVGFyZ2V0RWwoKTtcbiAgICAgICAgY29uc3QgZm9ybUNvbmZpZyA9IHRoaXMuZ2V0Rm9ybUNvbmZpZygpO1xuICAgICAgICBpZiAoISh0YXJnZXRFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGZvcm1Db25maWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlcnJvciB3aGlsZSBmb3JtIHJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VNb2RlID0gKG1vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9ybU1vZGUobW9kZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZvcm1Db25maWcuZm9ybSkge1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldEVsLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVDaGlsZCh0YXJnZXRFbC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBuZXcgZm9ybUNvbmZpZy5mb3JtKHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7IHRhcmdldDogdGFyZ2V0RWwsIGNoYW5nZU1vZGUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1Db25maWcucHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBuZXcgdGhpcy4jZm9ybUNvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRFbCxcbiAgICAgICAgICAgICAgICAuLi5mb3JtQ29uZmlnLnByb3BzLFxuICAgICAgICAgICAgICAgIGNoYW5nZU1vZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiKS5maW5kKFxuICAgICAgICAgICAgKGZvcm0pID0+IGZvcm0ubW9kZSA9PT0gdGhpcy5nZXRGb3JtTW9kZSgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZGVzdHJveUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckVsID0gdGhpcy5nZXRGb3JtVGFyZ2V0RWwoKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lckVsKSB7XG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbmVyRWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2Zvcm0gJiYgdGhpcy4jZm9ybS4kZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy4jZm9ybS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Zvcm0gPSBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3lGcmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2ZyYW1lICYmIHRoaXMuI2ZyYW1lLiRkZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpc01vZGVFeGlzdHMobW9kZSkge1xuICAgICAgICBjb25zdCBmb3JtcyA9IHRoaXMuZ2V0T3B0aW9ucyhcImZvcm1zXCIsIFtdKTtcbiAgICAgICAgcmV0dXJuIGZvcm1zLnNvbWUoKGl0ZW0pID0+IGl0ZW0ubW9kZSA9PT0gbW9kZSk7XG4gICAgfVxuXG4gICAgZ2V0Rmlyc3RNb2RlKCkge1xuICAgICAgICBjb25zdCBmb3JtcyA9IHRoaXMuZ2V0T3B0aW9ucyhcImZvcm1zXCIsIFtdKTtcbiAgICAgICAgaWYgKGZvcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmb3Jtc1swXS5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuI2Zvcm1TZXRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNmb3JtQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXN0cm95Rm9ybSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lGcmFtZSgpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgIH1cblxuICAgIGdldEZyYW1lVGFyZ2V0RWwoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0T3B0aW9ucyhcInRhcmdldFwiLCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUik7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybSBzZXQgdGFyZ2V0IGlzIG5vdCBIVE1MRWxlbWVudCBvciBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtVGFyZ2V0RWwoKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldE9wdGlvbnMoXCJuYW1lXCIsIERFRkFVTFRfRk9STV9TRVRfTkFNRSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtuYW1lfS1mb3JtLXNldC1jb250YWluZXJgKTtcbiAgICB9XG5cbiAgICAjZ2V0RnJhbWVQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNob3dNb2RlczogdGhpcy5nZXRPcHRpb25zKFwic2hvd01vZGVzXCIsIHRydWUpLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5nZXRGb3JtTW9kZSgpLFxuICAgICAgICAgICAgZm9ybXM6IHRoaXMuZ2V0T3B0aW9ucyhcImZvcm1zXCIsIFtdKSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0T3B0aW9ucyhcIm5hbWVcIiwgREVGQVVMVF9GT1JNX1NFVF9OQU1FKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEZvcm1TZXQ7XG4iLCI8c2NyaXB0PlxuXG4gIGltcG9ydCB7TE9DQUxFfSBmcm9tICcuLi8uLi8uLi9sb2NhbGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZ29dXG4gICAqL1xuXG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGxldCB7IHJvb3QgPSAnJywgaXRlbXMgPSBbXSwgZ28gPSBudWxsIH0gPSAkcHJvcHMoKTtcblxuICBmdW5jdGlvbiBvbkNsaWNrKGV2KXtcbiAgICAgIGlmKHR5cGVvZiBnbyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBnbyhldi5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaHJlZik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxuYXYgY2xhc3M9XCJicmVhZGNydW1iXCIgYXJpYS1sYWJlbD1cImJyZWFkY3J1bWJzXCI+XG4gIDx1bD5cbiAgICB7I2VhY2ggaXRlbXMgYXMgbGluaywgaW5kZXh9XG4gICAgeyNpZiAoaXRlbXMubGVuZ3RoID09PSAoaW5kZXggKyAxKSkgfVxuICAgIDxsaSBjbGFzcz1cImlzLWFjdGl2ZVwiPjxhIGhyZWY9XCJ7cm9vdH17bGluay51cmx9XCIgZGF0YS1ocmVmPVwie2xpbmsudXJsfVwiIGFyaWEtY3VycmVudD1cInBhZ2VcIj57JExPQ0FMRVtsaW5rLnRpdGxlXX08L2E+PC9saT5cbiAgICB7OmVsc2UgfVxuICAgIHsjaWYgbGluay51cmwgPT09IGZhbHNlIH1cbiAgICA8bGkgY2xhc3M9XCJpcy1wbGFpbi1jcnVtYlwiPnskTE9DQUxFW2xpbmsudGl0bGVdfTwvbGk+XG4gICAgezplbHNlfVxuICAgIDxsaT48YSBocmVmPVwie3Jvb3R9e2xpbmsudXJsfVwiIGRhdGEtaHJlZj1cIntsaW5rLnVybH1cIiBvbmNsaWNrPXtvbkNsaWNrfT57JExPQ0FMRVtsaW5rLnRpdGxlXX08L2E+PC9saT5cbiAgICB7L2lmfVxuICAgIHsvaWZ9XG4gICAgey9lYWNofVxuICA8L3VsPlxuPC9uYXY+XG4iLCJjbGFzcyBub3RCcmVhZGNydW1ic3tcblxuICAgIHN0YXRpYyBVSUNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICBzdGF0aWMgdWkgPSBudWxsO1xuICAgIHN0YXRpYyBoZWFkID0gW107XG4gICAgc3RhdGljIHRhaWwgPSBbXTtcblxuICAgIHN0YXRpYyByZW5kZXIoe3RhcmdldCwgcm9vdCA9ICcnLCBuYXZpZ2F0ZX0pe1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICBpZihub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yKXtcbiAgICAgICAgICAgIHRoaXMudWkgPSBuZXcgbm90QnJlYWRjcnVtYnMuVUlDb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHByb3BzOntcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6ICB0aGlzLmdldEJyZWFkY3J1bWJzKCksXG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6ICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgZ286ICAgICAgbmF2aWdhdGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzZXRIZWFkKGhlYWQpe1xuICAgICAgICB0aGlzLmhlYWQuc3BsaWNlKDAsdGhpcy5oZWFkLmxlbmd0aCwuLi5oZWFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFRhaWwodGFpbCl7XG4gICAgICAgIHRoaXMudGFpbC5zcGxpY2UoMCwgdGhpcy50YWlsLmxlbmd0aCwuLi50YWlsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEJyZWFkY3J1bWJzKCl7XG4gICAgICAgIGxldCBjcnVtYnMgPSBbXTtcbiAgICAgICAgY3J1bWJzLnB1c2goLi4udGhpcy5oZWFkKTtcbiAgICAgICAgY3J1bWJzLnB1c2goLi4udGhpcy50YWlsKTtcbiAgICAgICAgcmV0dXJuIGNydW1icztcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlKCl7XG4gICAgICAgIGlmKHRoaXMudWkpe1xuICAgICAgICAgICAgdGhpcy51aS4kc2V0KHsgaXRlbXM6IHRoaXMuZ2V0QnJlYWRjcnVtYnMoKSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUoKXtcbiAgICAgICAgaWYgKHRoaXMudWkpIHtcbiAgICAgICAgICAgIHRoaXMudWkuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMudWkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RCcmVhZGNydW1icztcbiIsImltcG9ydCBVSUJyZWFkY3J1bWJzIGZyb20gJy4vdWkuYnJlYWRjcnVtYnMuc3ZlbHRlJztcbmltcG9ydCBub3RCcmVhZGNydW1icyBmcm9tICcuL2JyZWFkY3J1bWJzLmpzJztcblxubm90QnJlYWRjcnVtYnMuVUlDb25zdHJ1Y3RvciA9IFVJQnJlYWRjcnVtYnM7XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEJyZWFkY3J1bWJzO1xuIiwiaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbmltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvY29tbW9uLmpzXCI7XG5cbmNsYXNzIE1lbnUge1xuICAgIHN0YXRpYyBNQVhfVE9VQ0hfV0lEVEggPSAxMDIzO1xuXG4gICAgc3RhdGljIERFRkFVTFQgPSB7XG4gICAgICAgIHNlY3Rpb246IFwiYW55XCIsXG4gICAgICAgIHNlY3Rpb25UaXRsZTogXCLQnNC10L3RjlwiLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgLy9saW5rLCBidXR0b24sIGRyb3Bkb3duLCBjb21wb25lbnRcbiAgICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICAgIG9wZW46IGZhbHNlLFxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi9hcHAuanMnKS5kZWZhdWx0IHwgbnVsbH1cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIE1lbnVcbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwID0gbnVsbDtcbiAgICBzdGF0aWMgZGlyZWN0TmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgIHN0YXRpYyBtZW51O1xuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICBkaXJlY3ROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgbmF2aWdhdGU6ICh1cmxzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RpcmVjdE5hdmlnYXRpb24oKSAmJiB0aGlzLmFwcCkge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jID0gdGhpcy5hcHAuZ2V0V29ya2luZyhcInJvdXRlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5uYXZpZ2F0ZSh1cmxzLnNob3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5hc3NpZ24odXJscy5mdWxsKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGhpZGUoKSB7fVxuXG4gICAgc3RhdGljIGl0ZW1zID0gW107XG4gICAgc3RhdGljIHNlY3Rpb25zID0gW107XG4gICAgc3RhdGljIGxvY2F0aW9uO1xuICAgIHN0YXRpYyBpbnRlcnZhbDtcblxuICAgIHN0YXRpYyBzZXRBcHAoYXBwKSB7XG4gICAgICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE9wdGlvbnNQYXRoVG8od2hhdCkge1xuICAgICAgICByZXR1cm4gYG1lbnUuJHt0aGlzLm9wdGlvbnMudHlwZX0uJHt3aGF0fWA7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzRGlyZWN0TmF2aWdhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwXG4gICAgICAgICAgICA/IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwiZGlyZWN0TmF2aWdhdGlvblwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGlyZWN0TmF2aWdhdGlvblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnMuZGlyZWN0TmF2aWdhdGlvbjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJyYW5kOiB0aGlzLmFwcC5nZXRPcHRpb25zKFwiYnJhbmRcIiwgdGhpcy5vcHRpb25zLmJyYW5kKSxcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwiaXRlbXNcIiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pdGVtc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgc2VjdGlvbnM6IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcInNlY3Rpb25zXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VjdGlvbnNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRhcmdldFNlbGVjdG9yOiB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJ0YXJnZXRTZWxlY3RvclwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRhcmdldFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RvcjogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwidG9nZ2xlU2VsZWN0b3JcIiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50b2dnbGVTZWxlY3RvclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgb3BlbjogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwib3BlblwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9wZW5cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGRpcmVjdE5hdmlnYXRpb246IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcImRpcmVjdE5hdmlnYXRpb25cIiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kaXJlY3ROYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByb290OiB0aGlzLmFwcC5nZXRPcHRpb25zKFwicm91dGVyLnJvb3RcIiwgdGhpcy5vcHRpb25zLnJvb3QpLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlOiB0aGlzLm9wdGlvbnMubmF2aWdhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnQ6IHRoaXMuZ2V0Q29tcG9uZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRDb21wb25lbnQobmFtZSkge1xuICAgICAgICBpZiAoQ09NUE9ORU5UUy5jb250YWlucyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIENPTVBPTkVOVFMuZ2V0KG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGluaXRGaWVsZChsaXN0LCBmaWVsZHMgPSBbXSkge1xuICAgICAgICBsaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihpdGVtLCBmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVtmaWVsZF0gPSB0aGlzLkRFRkFVTFRbZmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaXRlbSwgXCJpdGVtc1wiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEZpZWxkKGl0ZW0uaXRlbXMsIGZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBzb3J0TGlzdChsaXN0KSB7XG4gICAgICAgIGxpc3Quc29ydCgoaXRlbTEsIGl0ZW0yKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpdGVtMSwgXCJpdGVtc1wiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydExpc3QoaXRlbTEuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaXRlbTIsIFwiaXRlbXNcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRMaXN0KGl0ZW0yLml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtMS5wcmlvcml0eSA9PT0gaXRlbTIucHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTEudGl0bGUgPiBpdGVtMi50aXRsZSA/IDEgOiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0xLnByaW9yaXR5IDwgaXRlbTIucHJpb3JpdHkgPyAxIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVEdWJsaWNhdGVzKHNlY3Rpb25zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHNlY3Rpb25zW2ldLnByaW9yaXR5O1xuICAgICAgICAgICAgc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWN0aW9uLmlkID09PSBzZWN0aW9uc1tpXS5pZDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChpdGVtLCBpbmR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucHJpb3JpdHkgPCBwcmlvcml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHkgPSBpdGVtLnByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25zLnNwbGljZShzZWN0aW9ucy5pbmRleE9mKGl0ZW0pLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zW2ldLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3Rpb25zO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlRGF0YSgpIHtcbiAgICAgICAgbGV0IGl0ZW1zID0gW107XG4gICAgICAgIGl0ZW1zLnB1c2goLi4udGhpcy5nZXRPcHRpb25zKCkuaXRlbXMpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgc2VjdGlvbnMucHVzaCguLi50aGlzLmdldE9wdGlvbnMoKS5zZWN0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5pbml0RmllbGQoc2VjdGlvbnMsIFtcInByaW9yaXR5XCJdKTtcbiAgICAgICAgdGhpcy5yZW1vdmVEdWJsaWNhdGVzKHNlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5pbml0RmllbGQoaXRlbXMsIFtcInByaW9yaXR5XCIsIFwic2VjdGlvblwiLCBcInR5cGVcIl0pO1xuICAgICAgICB0aGlzLnNvcnRMaXN0KHNlY3Rpb25zKTtcblxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiB0aGlzLkRFRkFVTFQuc2VjdGlvbixcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLkRFRkFVTFQuc2VjdGlvblRpdGxlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb3J0TGlzdChpdGVtcyk7XG5cbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgdGhpcy5tZW51LiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLm1lbnUgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVJbmRpY2F0b3Ioc2VjdGlvbklkLCBpdGVtSWQsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbihzZWN0aW9uSWQsIChzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZWN0aW9uLmluZGljYXRvci5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVJdGVtKGl0ZW1JZCwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uaW5kaWNhdG9yLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVUYWcoc2VjdGlvbklkLCBpdGVtSWQsIHRhZykge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlY3Rpb24oc2VjdGlvbklkLCAoc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgc2VjdGlvbi50YWcgPSB0YWc7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUl0ZW0oaXRlbUlkLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS50YWcgPSB0YWc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVTZWN0aW9uVGFnKHNlY3Rpb25JZCwgdGFnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbihzZWN0aW9uSWQsIChzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZWN0aW9uLnRhZyA9IHsgLi4uc2VjdGlvbi50YWcsIC4uLnRhZyB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlSXRlbVRhZyhpdGVtSWQsIHRhZykge1xuICAgICAgICB0aGlzLnVwZGF0ZUl0ZW0oaXRlbUlkLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS50YWcgPSB7IC4uLml0ZW0udGFnLCAuLi50YWcgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVNlY3Rpb24oc2VjdGlvbklkLCBwcm9jKSB7XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25zICYmIHNlY3Rpb25JZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBpbiB0aGlzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnNbc2VjdGlvbl0uaWQgIT09IHNlY3Rpb25JZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgcHJvYyh0aGlzLnNlY3Rpb25zW3NlY3Rpb25dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuJHNldCh7IHNlY3Rpb25zOiB0aGlzLnNlY3Rpb25zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVNlY3Rpb25JdGVtcyhzZWN0aW9uSWQsIHByb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMgJiYgc2VjdGlvbklkKSB7XG4gICAgICAgICAgICBsZXQgb2xkTGlzdCA9IHRoaXMuaXRlbXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgIChpdGVtKSA9PiBpdGVtLnNlY3Rpb24gPT09IHNlY3Rpb25JZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2Ygb2xkTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goLi4ucHJvYyhvbGRMaXN0KSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LiRzZXQoeyBpdGVtczogdGhpcy5pdGVtcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVJdGVtKGl0ZW1JZCwgcHJvYykge1xuICAgICAgICBpZiAoaXRlbUlkICYmIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmlkICE9PSBpdGVtSWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBwcm9jKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LiRzZXQoeyBpdGVtczogdGhpcy5pdGVtcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpc1RvdWNoKCkge1xuICAgICAgICByZXR1cm4gVUlDb21tb24uaXNNb2JpbGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFNlY3Rpb25Db21wb25lbnQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZW51O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW0gPSB7fSwgb25uYXZpZ2F0ZSA9ICgpID0+IHt9IH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25uYXZpZ2F0ZSh7XG4gICAgICAgICAgICBmdWxsOiBldi50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICAgIHNob3J0OiBldi50YXJnZXQuZGF0YXNldC5ocmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHR5cGVvZiBpdGVtLnVybCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVtLnVybCAhPT0gZmFsc2V9XG4gICAgPGxpIGNsYXNzPXtpdGVtLmNsYXNzZXN9PlxuICAgICAgICA8YSBocmVmPVwie3Jvb3R9e2l0ZW0udXJsfVwiIGRhdGEtaHJlZj17aXRlbS51cmx9IG9uY2xpY2s9e29uQ2xpY2t9PlxuICAgICAgICAgICAgeyRMT0NBTEVbaXRlbS50aXRsZV19XG4gICAgICAgICAgICB7I2lmIGl0ZW0udGFnfVxuICAgICAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0udGFnfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgaXRlbS5pbmRpY2F0b3J9XG4gICAgICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2E+XG4gICAgPC9saT5cbns6ZWxzZX1cbiAgICA8bGkgY2xhc3M9XCJpcy1uby1mb2xsb3ctc3VidGl0bGUge2l0ZW0uY2xhc3Nlc31cIj5cbiAgICAgICAgeyRMT0NBTEVbaXRlbS50aXRsZV19XG4gICAgICAgIHsjaWYgaXRlbS50YWd9XG4gICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ30gLz5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiBpdGVtLmluZGljYXRvcn1cbiAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0uaW5kaWNhdG9yfSAvPlxuICAgICAgICB7L2lmfVxuICAgIDwvbGk+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBjb25zdCBDTEFTU19JQ09OID0ge1xuICAgICAgICBPUEVORUQ6IFwiZmEtYW5nbGUtZG93blwiLFxuICAgICAgICBDTE9TRUQ6IFwiZmEtYW5nbGUtdXBcIixcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ljb25fb3BlbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaWNvbl9jbG9zZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2xvc2VkXSAgICByZXR1cm5zIGlmIHdlIHNob3VsZCBhcHBseSB0b2dnbGUgb3IgaWYgZmFsc2UgLSByZWplY3QgaXQgYW5kIHRvZ2dsZSBiYWNrd2FyZFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpY29uX29wZW5lZCA9IENMQVNTX0lDT04uT1BFTkVELFxuICAgICAgICBpY29uX2Nsb3NlZCA9IENMQVNTX0lDT04uQ0xPU0VELFxuICAgICAgICBjbG9zZWQsXG4gICAgICAgIG9udG9nZ2xlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNsb3NlZCA9ICFjbG9zZWQ7XG4gICAgICAgIGlmICghb250b2dnbGUoY2xvc2VkKSkge1xuICAgICAgICAgICAgY2xvc2VkID0gIWNsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzcGFuXG4gICAgY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLXRvZ2dsZS1zdWJtZW51IGlzLXB1bGxlZC1yaWdodFwiXG4gICAgb25jbGljaz17b25DbGlja31cbiAgICBvbmtleXVwPXtvbkNsaWNrfVxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIHRhYmluZGV4PVwiMFwiXG4+XG4gICAgPGkgY2xhc3M9XCJmYXMge2Nsb3NlZCA/IGljb25fY2xvc2VkIDogaWNvbl9vcGVuZWR9XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuPC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLmZvbnQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUYWcgZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IENPTVBPTkVOVFMgfSBmcm9tIFwiLi4vLi4vLi4vTElCLmpzXCI7XG4gICAgbGV0IHsgaXRlbSA9IHt9LCBjaGlsZHJlbiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtLmljb259XG4gICAgPFVJSWNvbiB7Li4uaXRlbS5pY29ufSAvPlxuezplbHNlIGlmIGl0ZW0udHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiBpdGVtLmNvbXBvbmVudCAmJiBDT01QT05FTlRTLmNvbnRhaW5zKGl0ZW0uY29tcG9uZW50KX1cbiAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IENPTVBPTkVOVFMuZ2V0KGl0ZW0uY29tcG9uZW50KX1cbiAgICA8U3ZlbHRlQ29tcG9uZW50IGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5wcm9wc30gLz5cbns6ZWxzZX1cbiAgICA8c3BhbiBjbGFzcz1cImlzLW5vLWxpbmtcIj57JExPQ0FMRVtpdGVtLnRpdGxlXX08L3NwYW4+XG57L2lmfVxueyNpZiBpdGVtLnRhZ31cbiAgICA8VUlUYWcgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ30gLz5cbnsvaWZ9XG57I2lmIGl0ZW0uaW5kaWNhdG9yfVxuICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0uaW5kaWNhdG9yfSAvPlxuey9pZn1cbntAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVpX2l0ZW1zIGZyb20gXCIuL3VpLml0ZW1zLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJU2lkZU1lbnVJdGVtV2l0aG91dENoaWxkcmVuIGZyb20gXCIuL3VpLml0ZW0ud2l0aG91dC5jaGlsZHJlbi5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVNpZGVNZW51VHJpZ2dlciBmcm9tIFwiLi91aS50cmlnZ2VyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVNpZGVNZW51SXRlbUxhYmVsIGZyb20gXCIuL3VpLml0ZW0ubGFiZWwuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nsb3NlZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25uYXZpZ2F0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW1zID0gW10sIGNsb3NlZCwgb25uYXZpZ2F0ZSA9ICgpID0+IHt9IH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGNyZWF0ZUNsb3NlZEl0ZW1zTGliID0gKGxzdCkgPT4ge1xuICAgICAgICBjb25zdCBsaWIgPSB7fTtcbiAgICAgICAgbHN0LmZvckVhY2goKGl0bSwgaW5kZXgpID0+IChsaWJbaW5kZXhdID0gaXRtLmNsb3NlZCkpO1xuICAgICAgICByZXR1cm4gbGliO1xuICAgIH07XG5cbiAgICBsZXQgY2xvc2VkQ2hpbGRyZW4gPSAkc3RhdGUoY3JlYXRlQ2xvc2VkSXRlbXNMaWIoaXRlbXMpKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25uYXZpZ2F0ZSh7XG4gICAgICAgICAgICBmdWxsOiBldi50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICAgIHNob3J0OiBldi50YXJnZXQuZGF0YXNldC5ocmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48dWwgY2xhc3M9XCJtZW51LWxpc3Qge2Nsb3NlZCA/ICdpcy1jbG9zZWQnIDogJyd9XCI+XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0sIGluZGV4fVxuICAgICAgICB7I2lmIGl0ZW0uaXRlbXMgJiYgaXRlbS5pdGVtcy5sZW5ndGh9XG4gICAgICAgICAgICA8bGkgY2xhc3M9XCJpcy1uby1mb2xsb3ctc3VidGl0bGUge2l0ZW0uY2xhc3Nlc31cIj5cbiAgICAgICAgICAgICAgICB7I2lmIHR5cGVvZiBpdGVtLnVybCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVtLnVybCAhPT0gZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmPVwie3Jvb3R9e2l0ZW0udXJsfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWhyZWY9e2l0ZW0udXJsfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaGFzLXN1Yml0ZW1zXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFVJU2lkZU1lbnVJdGVtTGFiZWwge2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51VHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNsb3NlZD17Y2xvc2VkQ2hpbGRyZW5baW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L1VJU2lkZU1lbnVJdGVtTGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51SXRlbUxhYmVsIHtpdGVtfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51VHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmQ6Y2xvc2VkPXtjbG9zZWRDaGlsZHJlbltpbmRleF19XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L1VJU2lkZU1lbnVJdGVtTGFiZWw+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8VWlfaXRlbXNcbiAgICAgICAgICAgICAgICAgICAge3Jvb3R9XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zPXtpdGVtLml0ZW1zfVxuICAgICAgICAgICAgICAgICAgICBiaW5kOmNsb3NlZD17Y2xvc2VkQ2hpbGRyZW5baW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICB7b25uYXZpZ2F0ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPFVJU2lkZU1lbnVJdGVtV2l0aG91dENoaWxkcmVuIHtyb290fSB7aXRlbX0ge29ubmF2aWdhdGV9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuPC91bD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUluZGljYXRvciBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJU2lkZU1lbnVJdGVtcyBmcm9tIFwiLi91aS5pdGVtcy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uLy4uL0xJQi5qc1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBzZWN0aW9uXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbm5hdmlnYXRlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBzZWN0aW9uLCBpdGVtcyA9IFtdLCByb290ID0gXCJcIiwgb25uYXZpZ2F0ZSA9ICgpID0+IHt9IH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBzZWN0aW9uSXRlbXMgPSAkZGVyaXZlZChcbiAgICAgICAgaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBzZWN0aW9uLmlkID09PSBpdGVtLnNlY3Rpb24pXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I2lmIHNlY3Rpb259XG4gICAgeyNpZiBzZWN0aW9uSXRlbXMubGVuZ3RoIHx8IHNlY3Rpb24uY29tcG9uZW50IHx8IHNlY3Rpb24udGFnIHx8IHNlY3Rpb24uaW5kaWNhdG9yfVxuICAgICAgICA8cCBjbGFzcz1cIm1lbnUtbGFiZWwge3NlY3Rpb24uY2xhc3Nlc31cIj5cbiAgICAgICAgICAgIHsjaWYgc2VjdGlvbi50eXBlID09PSBcImNvbXBvbmVudFwiICYmIHNlY3Rpb24uY29tcG9uZW50ICYmIENPTVBPTkVOVFMuY29udGFpbnMoc2VjdGlvbi5jb21wb25lbnQpfVxuICAgICAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoc2VjdGlvbi5jb21wb25lbnQpfVxuICAgICAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnQgaWQ9e3NlY3Rpb24uaWR9IHsuLi5zZWN0aW9uLnByb3BzfSAvPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHskTE9DQUxFW3NlY3Rpb24udGl0bGVdfVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgc2VjdGlvbi50YWd9XG4gICAgICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtzZWN0aW9uLmlkfSB7Li4uc2VjdGlvbi50YWd9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNpZiBzZWN0aW9uLmluZGljYXRvcn1cbiAgICAgICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e3NlY3Rpb24uaWR9IHsuLi5zZWN0aW9uLmluZGljYXRvcn0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvcD5cbiAgICB7L2lmfVxuey9pZn1cbnsjaWYgc2VjdGlvbkl0ZW1zLmxlbmd0aH1cbiAgICA8VUlTaWRlTWVudUl0ZW1zIHtyb290fSBpdGVtcz17c2VjdGlvbkl0ZW1zfSB7b25uYXZpZ2F0ZX0gLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSVNpZGVNZW51U2VjdGlvbiBmcm9tIFwiLi91aS5zZWN0aW9uLnN2ZWx0ZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzZWN0aW9uc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW25hdmlnYXRlID0gKCk9PnVuZGVmaW5lZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW1zID0gW10sIHNlY3Rpb25zID0gW10sIG5hdmlnYXRlID0gbnVsbCB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbmF2aWdhdGUoZXYpO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjZWFjaCBzZWN0aW9ucyBhcyBzZWN0aW9ufVxuICAgIDxVSVNpZGVNZW51U2VjdGlvbiB7c2VjdGlvbn0ge2l0ZW1zfSB7cm9vdH0gb25uYXZpZ2F0ZT17b25DbGlja30gLz5cbnsvZWFjaH1cbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBTaWRlTWVudVN0YXRlID0gd3JpdGFibGUoe1xuICAgIG9wZW46IHRydWUsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgU2lkZU1lbnVTdGF0ZTtcbiIsImltcG9ydCBNZW51IGZyb20gXCIuLi9tZW51LmpzXCI7XG5pbXBvcnQgVUlTaWRlTWVudSBmcm9tIFwiLi91aS5zaWRlLm1lbnUuc3ZlbHRlXCI7XG5cbmltcG9ydCBTaWRlTWVudVN0YXRlIGZyb20gXCIuL3N0b3JlLmpzXCI7XG5pbXBvcnQgeyBtb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgVFlQRSA9IFwic2lkZVwiO1xuXG5jbGFzcyBub3RTaWRlTWVudSBleHRlbmRzIE1lbnUge1xuICAgIHN0YXRpYyBuYXY7XG4gICAgc3RhdGljIG1haW47XG4gICAgc3RhdGljIGFzaWRlO1xuXG4gICAgc3RhdGljIERFRkFVTFQgPSB7XG4gICAgICAgIHNlY3Rpb246IFwiYW55XCIsXG4gICAgICAgIHNlY3Rpb25UaXRsZTogXCLQnNC10L3RjlwiLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICBkaXJlY3ROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgdHlwZTogVFlQRSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzZWN0aW9uczogW10sXG4gICAgICAgIHRhcmdldFNlbGVjdG9yOiBgIyR7VFlQRX0tbWVudWAsXG4gICAgICAgIHRvZ2dsZVNlbGVjdG9yOiBgLiR7VFlQRX0tbWVudS10b2dnbGVgLFxuICAgICAgICByb290OiBcIi9cIixcbiAgICAgICAgb3BlbjogdHJ1ZSxcbiAgICAgICAgbmF2aWdhdGU6ICh1cmxzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5lbWl0KFwidG9wLW5hdmJhci1idXJnZXI6dXBkYXRlXCIsIHsgY2xvc2VkOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlyZWN0TmF2aWdhdGlvbigpICYmIHRoaXMuYXBwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLmFwcC5nZXRXb3JraW5nKFwicm91dGVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLm5hdmlnYXRlKHVybHMuc2hvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmFzc2lnbih1cmxzLmZ1bGwpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBzdGF0aWMgcmVuZGVyKGFwcCkge1xuICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFwcChhcHApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZURhdGEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVUkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMubWVudS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVVSSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVVJKCkge1xuICAgICAgICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW51ID0gbW91bnQoVUlTaWRlTWVudSwge1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgICAgICAgICBzZWN0aW9uczogdGhpcy5zZWN0aW9ucyxcbiAgICAgICAgICAgICAgICByb290OiB0aGlzLmdldE9wdGlvbnMoKS5yb290LFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlOiB0aGlzLmdldE9wdGlvbnMoKS5uYXZpZ2F0ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluaXRTaXplUmVzcG9uc2UoKTtcblxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy51cGRhdGVNZW51QWN0aXZlSXRlbS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICB0aGlzLmJpbmRUb2dnbGUoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXRlbUlzQWN0aXZlKGl0ZW1VUkwpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvY2F0aW9uICsgXCIvXCIpLmluZGV4T2YoaXRlbVVSTCArIFwiL1wiKSA+IC0xO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVNZW51KCkge1xuICAgICAgICBBcnJheS5mcm9tKFxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3RvciArIFwiIGFcIilcbiAgICAgICAgKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVtSXNBY3RpdmUoaXRlbS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlTWVudUFjdGl2ZUl0ZW0oKSB7XG4gICAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGxhc3RMb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIGlmIChsYXN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh1cmwgIT09IGxhc3RMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdFNpemVSZXNwb25zZSgpIHtcbiAgICAgICAgdGhpcy5uYXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibmF2Lm5hdmJhclwiKTtcbiAgICAgICAgdGhpcy5hc2lkZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJhc2lkZVwiKTtcbiAgICAgICAgdGhpcy5tYWluID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1haW5cIik7XG4gICAgICAgIHRoaXMucmVzaXplQXNpZGVBbmRNYWluKHRoaXMuYXNpZGUsIHRoaXMubWFpbiwgdGhpcy5uYXYpO1xuICAgICAgICB0aGlzLnJlc2l6ZU1haW4odGhpcy5tYWluLCB0aGlzLmFzaWRlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemVNYWluLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoKS5vcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2l6ZU1haW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXNpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXMtYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLm1hcmdpbkxlZnQgPSBcIjBweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmFzaWRlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5tYWluLnN0eWxlLmhlaWdodCA9PT0gXCIwcHhcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFpbi5zdHlsZS5tYXJnaW5MZWZ0ID0gcmVjdC53aWR0aCArIHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZXNpemVBc2lkZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gdGhpcy5uYXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmFzaWRlLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHJlY3QuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5hc2lkZS5zdHlsZS5tYXJnaW5Ub3AgPSByZWN0LmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZXNpemVBc2lkZUFuZE1haW4oKSB7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5uYXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuYXNpZGUuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gcmVjdC5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIC8vdGhpcy5hc2lkZS5zdHlsZS5wYWRkaW5nVG9wID0gKHJlY3QuaGVpZ2h0KSArICdweCc7XG4gICAgICAgIC8vdGhpcy5tYWluLnN0eWxlLm1hcmdpblRvcCA9IChyZWN0LmhlaWdodCkgKyAncHgnO1xuICAgIH1cblxuICAgIHN0YXRpYyBiaW5kVG9nZ2xlKCkge1xuICAgICAgICBsZXQgZWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLmdldE9wdGlvbnMoKS50b2dnbGVTZWxlY3Rvcik7XG4gICAgICAgIEFycmF5LmZyb20oZWxzKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdG9nZ2xlKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC50b2dnbGUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaXplTWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaGlkZShlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5hc2lkZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC5hZGQoXCJpcy1jbG9zZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU1haW4oKTtcbiAgICAgICAgfVxuICAgICAgICBTaWRlTWVudVN0YXRlLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2hvdyhlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5hc2lkZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1jbG9zZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU1haW4oKTtcbiAgICAgICAgfVxuICAgICAgICBTaWRlTWVudVN0YXRlLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwub3BlbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc09wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hc2lkZS5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5hc2lkZS5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1jbG9zZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90U2lkZU1lbnU7XG4iLCI8c2NyaXB0PlxuICAgIC8qIGVzbGludCBzdmVsdGUvbm8tYXQtaHRtbC10YWdzOiAwICovXG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ljb25dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHVybCA9IFwiL1wiLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGljb24gPSB7XG4gICAgICAgICAgICBzcmM6IFwiaHR0cHM6Ly92aWEucGxhY2Vob2xkZXIuY29tLzU2eDI4XCIsXG4gICAgICAgICAgICB3aWR0aDogMjgsXG4gICAgICAgICAgICBoZWlnaHQ6IDU2LFxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48YSBjbGFzcz1cIm5hdmJhci1pdGVtXCIgaHJlZj17dXJsfT5cbiAgICA8VUlJY29uIHsuLi5pY29ufSAvPlxuICAgIHsjaWYgdGl0bGV9XG4gICAgICAgIHtAaHRtbCBgPHNwYW4gY2xhc3M9XCJuYXZiYXItaXRlbS1icmFuZC10aXRsZVwiPiR7dGl0bGV9PC9zcGFuPmB9XG4gICAgey9pZn1cbjwvYT5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7TE9DQUxFfSBmcm9tICcuLi8uLi8uLi8uLi9sb2NhbGUnO1xuXG4gIGltcG9ydCBVSUljb24gZnJvbSAnLi4vLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZSc7XG4gIGltcG9ydCBVSVRhZyBmcm9tICcuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLnRhZy5zdmVsdGUnO1xuICBpbXBvcnQgVUlJbmRpY2F0b3IgZnJvbSAnLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlJztcbiAgaW1wb3J0IHtDT01QT05FTlRTfSBmcm9tICcuLi8uLi8uLi9MSUIuanMnO1xuICBsZXQgeyBpdGVtIH0gPSAkcHJvcHMoKTtcbiAgLypcbiAgc3RyaW5nIHRpdGxlXG4gIG9iamVjdCBpY29uO1xuICBvYmplY3QgdGFnO1xuICBzdHJpbmcgdHlwZTtcbiAgQ2xhc3MgY29tcG9uZW50O1xuICBvYmplY3QgaW5kaWNhdG9yO1xuICBvYmplY3Qgb3B0aW9ucztcbiAgKi9cblxuXG48L3NjcmlwdD5cblxueyNpZiBpdGVtLmljb259XG48VUlJY29uIHsuLi5pdGVtLmljb259IC8+XG57OmVsc2UgaWYgKGl0ZW0udHlwZT09PSdjb21wb25lbnQnICYmIGl0ZW0uY29tcG9uZW50ICYmIENPTVBPTkVOVFMuY29udGFpbnMoaXRlbS5jb21wb25lbnQpKSB9XG57QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IENPTVBPTkVOVFMuZ2V0KGl0ZW0uY29tcG9uZW50KX1cbjxTdmVsdGVDb21wb25lbnRcbiAgaWQ9e2l0ZW0uaWR9XG4gIHsuLi5pdGVtLnByb3BzfVxuICAgLz5cbns6ZWxzZX1cbnskTE9DQUxFW2l0ZW0udGl0bGVdfVxuey9pZn1cblxueyNpZiBpdGVtLnRhZyB9XG48VUlUYWcgdG9wPXt0cnVlfSByaWdodD17dHJ1ZX0gc2l6ZT0nc21hbGwnIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS50YWd9PjwvVUlUYWc+XG57L2lmfVxuXG57I2lmIGl0ZW0uaW5kaWNhdG9yIH1cbjxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0uaW5kaWNhdG9yfSAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgVUlJdGVtQ29udGVudCBmcm9tIFwiLi91aS5pdGVtLmNvbnRlbnQuc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaGlkZGVuXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlc11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgcm9vdCA9IFwiXCIsIGl0ZW0gPSB7fSwgaGlkZGVuID0gXCJcIiwgY2xhc3NlcyA9IFwiXCIgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBkaXNwYXRjaChcImNsaWNrXCIsIHsgZXZlbnQsIGVsZW1lbnQ6IGl0ZW0gfSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbS5icmVha31cbiAgICA8aHIgY2xhc3M9XCJuYXZiYXItZGl2aWRlciB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiIC8+XG57L2lmfVxuXG57I2lmIGl0ZW0udXJsfVxuICAgIDxhXG4gICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW0ge2hpZGRlblxuICAgICAgICAgICAgPyBgaXMtaGlkZGVuLSR7aGlkZGVufWBcbiAgICAgICAgICAgIDogJyd9IHtpdGVtLmNsYXNzZXN9IHtjbGFzc2VzfSBcIlxuICAgICAgICBocmVmPVwie3Jvb3R9e2l0ZW0udXJsfVwiXG4gICAgICAgIGRhdGEtaHJlZj17aXRlbS51cmx9XG4gICAgPlxuICAgICAgICA8VUlJdGVtQ29udGVudCB7aXRlbX0gLz5cbiAgICA8L2E+XG57OmVsc2V9XG4gICAgPGRpdlxuICAgICAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICBvbmtleXVwPXtvbkNsaWNrfVxuICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtIHtoaWRkZW5cbiAgICAgICAgICAgID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gXG4gICAgICAgICAgICA6ICcnfSB7aXRlbS5jbGFzc2VzfSB7Y2xhc3Nlc31cIlxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICA+XG4gICAgICAgIDxVSUl0ZW1Db250ZW50IHtpdGVtfSAvPlxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgVUlJdGVtQ29udGVudCBmcm9tIFwiLi91aS5pdGVtLmNvbnRlbnQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSXRlbSBmcm9tIFwiLi91aS5pdGVtLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzZWN0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtoaWRkZW5dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaG92ZXJhYmxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Fycm93bGVzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgcm9vdCA9IFwiXCIsXG4gICAgICAgIHNlY3Rpb24gPSB7fSxcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgaGlkZGVuID0gXCJcIixcbiAgICAgICAgaG92ZXJhYmxlID0gdHJ1ZSxcbiAgICAgICAgYXJyb3dsZXNzID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBkaXNwYXRjaChcImNsaWNrXCIsIHsgZXZlbnQsIGVsZW1lbnQ6IHNlY3Rpb24gfSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXMubGVuZ3RofVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSBoYXMtZHJvcGRvd24ge2hvdmVyYWJsZVxuICAgICAgICAgICAgPyAnaXMtaG92ZXJhYmxlJ1xuICAgICAgICAgICAgOiAnJ30ge2hpZGRlbiA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YCA6ICcnfSBcIlxuICAgID5cbiAgICAgICAgPGFcbiAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICBjbGFzcz1cIm5hdmJhci1saW5rIHthcnJvd2xlc3MgPyAnaXMtYXJyb3dsZXNzJyA6ICcnfVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxVSUl0ZW1Db250ZW50IGl0ZW09e3NlY3Rpb259IC8+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1kcm9wZG93biB7cmlnaHQgPyAnaXMtcmlnaHQnIDogJyd9XCI+XG4gICAgICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgICAgICAgICAgICAgPFVJSXRlbSB7cm9vdH0ge2l0ZW19IG9uOmNsaWNrIC8+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuezplbHNlIGlmIHNlY3Rpb24udXJsfVxuICAgIDxhXG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW0ge2hpZGRlbiA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YCA6ICcnfSBcIlxuICAgICAgICBocmVmPVwie3Jvb3R9e3NlY3Rpb24udXJsfVwiXG4gICAgICAgIGRhdGEtaHJlZj17c2VjdGlvbi51cmx9XG4gICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgPlxuICAgICAgICA8VUlJdGVtQ29udGVudCBpdGVtPXtzZWN0aW9ufSAvPlxuICAgIDwvYT5cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW0ge2hpZGRlbiA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YCA6ICcnfSBcIlxuICAgICAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICBvbmtleXVwPXtvbkNsaWNrfVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICA+XG4gICAgICAgIDxVSUl0ZW1Db250ZW50IGl0ZW09e3NlY3Rpb259IC8+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBjb25zdCBDT01QT05FTlRfTkFNRSA9IFwidG9wLW5hdmJhci1idXJnZXJcIjtcblxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgU2lkZU1lbnVTdG9yZSBmcm9tIFwiLi4vc2lkZS9zdG9yZVwiO1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vblwiO1xuXG5cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZShlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2xvc2VkID0gIWNsb3NlZDtcbiAgICAgICAgZGlzcGF0Y2goXCJ0b2dnbGVcIiwge1xuICAgICAgICAgICAgY2xvc2VkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gQ09NUE9ORU5UX05BTUUgKyBcIjp1cGRhdGVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZXZlbnRzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbcmVnaXN0ZXJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2xvc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbb25VcGRhdGVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGV2ZW50cyA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIHJlZ2lzdGVyID0gbm90Q29tbW9uLnJlZ2lzdGVyV2lkZ2V0RXZlbnRzLmJpbmQobm90Q29tbW9uKSxcbiAgICAgICAgY2xvc2VkID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICBvblVwZGF0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjbG9zZWQgPSBkYXRhLmNsb3NlZDtcbiAgICAgICAgfVxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAoIW5vdENvbW1vbi5vYmpIYXMoZXZlbnRzLCBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpKSkge1xuICAgICAgICAgICAgZXZlbnRzW2dldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCldID0gb25VcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXIoZXZlbnRzKTtcbiAgICB9KTtcblxuICAgIFNpZGVNZW51U3RvcmUuc3Vic2NyaWJlKCh2YWwpID0+IHtcbiAgICAgICAgY2xvc2VkID0gIXZhbC5vcGVuO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxhXG4gICAgaHJlZlxuICAgIG9uY2xpY2s9e3RvZ2dsZX1cbiAgICByb2xlPVwiYnV0dG9uXCJcbiAgICBjbGFzcz1cIm5hdmJhci1idXJnZXIge2Nsb3NlZCA/ICcnIDogJ2lzLWFjdGl2ZSd9XCJcbiAgICBhcmlhLWxhYmVsPVwibWVudVwiXG4gICAgYXJpYS1leHBhbmRlZD1cImZhbHNlXCJcbiAgICBkYXRhLXRhcmdldD1cIm5hdmJhclwiXG4+XG4gICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG48L2E+XG4iLCI8IS0tIEBtaWdyYXRpb24tdGFzayBFcnJvciB3aGlsZSBtaWdyYXRpbmcgU3ZlbHRlIGNvZGU6IENhbid0IG1pZ3JhdGUgY29kZSB3aXRoIGJlZm9yZVVwZGF0ZS4gUGxlYXNlIG1pZ3JhdGUgYnkgaGFuZC4gLS0+XG48c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IFNpZGVNZW51IGZyb20gXCIuLi9zaWRlXCI7XG5cbiAgICBpbXBvcnQgVUlCcmFuZCBmcm9tIFwiLi91aS5icmFuZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJJdGVtIGZyb20gXCIuL3VpLml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFyU2VjdGlvbiBmcm9tIFwiLi91aS5zZWN0aW9uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhckJ1cmdlciBmcm9tIFwiLi91aS5idXJnZXIuc3ZlbHRlXCI7XG4gICAgXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VjdGlvbnNdIC0gaW1wb3J0IHsgYmVmb3JlVXBkYXRlIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbmF2aWdhdGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnJhbmRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvd0J1cmdlcl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidXJnZXJDb250cm9sc1NpZGVtZW51XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBzZWN0aW9ucyA9IFtdLFxuICAgICAgICBpdGVtcyA9IFtdLFxuICAgICAgICByb290ID0gXCJcIixcbiAgICAgICAgbmF2aWdhdGUgPSBudWxsLFxuICAgICAgICBicmFuZCA9IGZhbHNlLFxuICAgICAgICBzaG93QnVyZ2VyID0gdHJ1ZSxcbiAgICAgICAgYnVyZ2VyQ29udHJvbHNTaWRlbWVudSA9IHRydWVcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgbWVudUNsb3NlZCA9ICRzdGF0ZSh0cnVlKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soeyBkZXRhaWwgfSkge1xuICAgICAgICBsZXQgeyBldmVudCwgZWxlbWVudCB9ID0gZGV0YWlsO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihlbGVtZW50LCBcImFjdGlvblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuYWN0aW9uKGV2ZW50LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5hdmlnYXRlKHtcbiAgICAgICAgICAgICAgICBmdWxsOiBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIiksXG4gICAgICAgICAgICAgICAgc2hvcnQ6IGV2ZW50LmN1cnJlbnRUYXJnZXQuZGF0YXNldC5ocmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzZWN0aW9uc0l0ZW1zQ291bnQgPSB7fTtcbiAgICBsZXQgc2VjdGlvbnNJdGVtcyA9IHt9O1xuICAgIC8qXG4gICAgYmVmb3JlVXBkYXRlKCgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICAgICAgc2VjdGlvbnNJdGVtc1tzZWN0aW9uLmlkXSA9IGl0ZW1zLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodCkgPT4gdC5zZWN0aW9uID09PSBzZWN0aW9uLmlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VjdGlvbnNJdGVtc0NvdW50W3NlY3Rpb24uaWRdID0gaXRlbXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh0KSA9PiB0LnNlY3Rpb24gPT09IHNlY3Rpb24uaWRcbiAgICAgICAgICAgICkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG4qL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZUJ1cmdlcih7IGRldGFpbCB9KSB7XG4gICAgICAgIGlmIChidXJnZXJDb250cm9sc1NpZGVtZW51KSB7XG4gICAgICAgICAgICBTaWRlTWVudS50b2dnbGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKFwidG9nZ2xlQnVyZ2VyXCIsIGRldGFpbCk7XG4gICAgICAgICAgICBtZW51Q2xvc2VkID0gZGV0YWlsLmNsb3NlZDtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwibmF2YmFyLWJyYW5kXCI+XG4gICAgeyNpZiBicmFuZH1cbiAgICAgICAgPFVJQnJhbmQgey4uLmJyYW5kfSAvPlxuICAgIHsvaWZ9XG4gICAgeyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb24gKHNlY3Rpb24uaWQpfVxuICAgICAgICB7I2lmIHNlY3Rpb24uc2hvd09uVG91Y2h9XG4gICAgICAgICAgICA8VUlOYXZiYXJJdGVtXG4gICAgICAgICAgICAgICAgaGlkZGVuPVwiZGVza3RvcFwiXG4gICAgICAgICAgICAgICAgaXRlbT17c2VjdGlvbn1cbiAgICAgICAgICAgICAgICB7cm9vdH1cbiAgICAgICAgICAgICAgICBvbjpjbGljaz17b25DbGlja31cbiAgICAgICAgICAgIC8+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgeyNpZiBpdGVtLnNob3dPblRvdWNofVxuICAgICAgICAgICAgPFVJTmF2YmFySXRlbSBoaWRkZW49XCJkZXNrdG9wXCIge2l0ZW19IHtyb290fSBvbjpjbGljaz17b25DbGlja30gLz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG4gICAgeyNpZiBzaG93QnVyZ2VyfVxuICAgICAgICA8VUlOYXZiYXJCdXJnZXIgb246dG9nZ2xlPXt0b2dnbGVCdXJnZXJ9IC8+XG4gICAgey9pZn1cbjwvZGl2PlxuPGRpdiBpZD1cIm5hdmJhclwiIGNsYXNzPVwibmF2YmFyLW1lbnUge21lbnVDbG9zZWQgPyAnJyA6ICdpcy1hY3RpdmUnfVwiPlxuICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItc3RhcnRcIj5cbiAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW19XG4gICAgICAgICAgICB7I2lmIGl0ZW0ucGxhY2UgPT09IFwic3RhcnRcIn1cbiAgICAgICAgICAgICAgICA8VUlOYXZiYXJJdGVtIGhpZGRlbj1cInRvdWNoXCIge2l0ZW19IG9uOmNsaWNrPXtvbkNsaWNrfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItZW5kXCI+XG4gICAgICAgIHsjZWFjaCBzZWN0aW9ucyBhcyBzZWN0aW9uIChzZWN0aW9uLmlkKX1cbiAgICAgICAgICAgIHsjaWYgKHNlY3Rpb25zSXRlbXNDb3VudFtzZWN0aW9uLmlkXSB8fCBzZWN0aW9uLmluZGljYXRvciB8fCBzZWN0aW9uLnRhZykgJiYgc2VjdGlvbi5wbGFjZSA9PSBcImVuZFwifVxuICAgICAgICAgICAgICAgIDxVSU5hdmJhclNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbj17c2VjdGlvbi5oaWRkZW59XG4gICAgICAgICAgICAgICAgICAgIHtyb290fVxuICAgICAgICAgICAgICAgICAgICB7c2VjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgaXRlbXM9e3NlY3Rpb25zSXRlbXNbc2VjdGlvbi5pZF19XG4gICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG48L2Rpdj5cbiIsImltcG9ydCBNZW51IGZyb20gXCIuLi9tZW51LmpzXCI7XG5pbXBvcnQgVUlOYXZiYXJUb3AgZnJvbSBcIi4vdWkudG9wLnN2ZWx0ZVwiO1xuaW1wb3J0IHsgbW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbmNvbnN0IFRZUEUgPSBcInRvcFwiO1xuXG5jbGFzcyBub3RUb3BNZW51IGV4dGVuZHMgTWVudSB7XG4gICAgc3RhdGljIERFRkFVTFQgPSB7XG4gICAgICAgIHNlY3Rpb246IFwiYW55XCIsXG4gICAgICAgIHNlY3Rpb25UaXRsZTogXCLQnNC10L3RjlwiLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgLy9saW5rLCBidXR0b24sIGRyb3Bkb3duLCBjb21wb25lbnRcbiAgICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICAgIHBsYWNlOiBcIm1haW5cIixcbiAgICB9O1xuXG4gICAgc3RhdGljIG9wdGlvbnMgPSB7XG4gICAgICAgIGJyYW5kOiBmYWxzZSxcbiAgICAgICAgdHlwZTogVFlQRSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzZWN0aW9uczogW10sXG4gICAgICAgIHRhcmdldFNlbGVjdG9yOiBgIyR7VFlQRX0tbWVudWAsXG4gICAgICAgIHJvb3Q6IFwiL1wiLFxuICAgICAgICBkaXJlY3ROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgbmF2aWdhdGU6ICh1cmxzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RpcmVjdE5hdmlnYXRpb24oKSAmJiB0aGlzLmFwcCkge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jID0gdGhpcy5hcHAuZ2V0V29ya2luZyhcInJvdXRlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5uYXZpZ2F0ZSh1cmxzLnNob3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5hc3NpZ24odXJscy5mdWxsKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgc3RhdGljIHJlbmRlcihhcHApIHtcbiAgICAgICAgaWYgKGFwcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBcHAoYXBwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGlmICghdGhpcy5tZW51KSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3RvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZW51ID0gbW91bnQoVUlOYXZiYXJUb3AsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmQ6IHRoaXMuZ2V0T3B0aW9ucygpLmJyYW5kLFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnM6IHRoaXMuc2VjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHRoaXMuZ2V0T3B0aW9ucygpLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlOiB0aGlzLmdldE9wdGlvbnMoKS5uYXZpZ2F0ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51QWN0aXZlSXRlbS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIDIwMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVNZW51KHVybCkge1xuICAgICAgICBBcnJheS5mcm9tKFxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3RvciArIFwiIGFzaWRlLm1lbnUgYVwiXG4gICAgICAgICAgICApXG4gICAgICAgICkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGl0ZW0uaHJlZiA9PSB1cmwgfHxcbiAgICAgICAgICAgICAgICAodXJsLmhyZWYgJiYgdXJsLmhyZWYuaW5kZXhPZihpdGVtLmhyZWYpID09IDApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZU1lbnVBY3RpdmVJdGVtKCkge1xuICAgICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBsYXN0TG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uO1xuICAgICAgICBpZiAobGFzdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAodXJsICE9PSBsYXN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudSh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudSh1cmwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHRvZ2dsZSgpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgIGVsLmNsYXNzTGlzdC50b2dnbGUoXCJpcy1hY3RpdmVcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGhpZGUoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtYWN0aXZlXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRCdXJnZXJTdGF0ZShtZW51Q2xvc2VkKSB7XG4gICAgICAgIHRoaXMubWVudS4kc2V0KHtcbiAgICAgICAgICAgIG1lbnVDbG9zZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90VG9wTWVudTtcbiIsImNvbnN0IERFRkFVTFRfVFJBU0ZPUk1FUiA9IChyZXMpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd24ocmVzLCBcInN0YXR1c1wiKSAmJiBPYmplY3QuaGFzT3duKHJlcywgXCJyZXN1bHRcIilcbiAgICAgICAgPyByZXMucmVzdWx0XG4gICAgICAgIDogcmVzO1xufTtcblxuZXhwb3J0IHsgREVGQVVMVF9UUkFTRk9STUVSIH07XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IERFRkFVTFRfVFJBU0ZPUk1FUiB9IGZyb20gXCIuL2NvbnN0XCI7XG5leHBvcnQgZGVmYXVsdCAoeyBBQ1RJT04sIFRJVExFLCBVSUNvbnN0cnVjdG9yLCBkYXRhUHJvdmlkZXIsIGdvQmFjayB9KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzIHtcbiAgICAgICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBg0J/RgNC+0YHQvNC+0YLRgCBcIiR7VElUTEV9XCJgLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKEFDVElPTik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudWlbQUNUSU9OXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhkYXRhUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzQXN5bmMoZGF0YVByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCBkYXRhUHJvdmlkZXIocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFQcm92aWRlcihwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHsgLi4uZGF0YVByb3ZpZGVyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0VHJhbnNmb3JtZXIgPSBjb250cm9sbGVyLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIGAke0FDVElPTn0udHJhbnNmb3JtZXJgLFxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX1RSQVNGT1JNRVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXSA9IG5ldyBVSUNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogeyBwYXJhbXMsIC4uLnJlc3VsdFRyYW5zZm9ybWVyKGRhdGEpIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBhZnRlcjpyZW5kZXI6JHtBQ1RJT059YCk7XG4gICAgICAgICAgICAgICAgaWYgKGdvQmFjayAmJiBub3RDb21tb24uaXNGdW5jKGdvQmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dLm9uKFwicmVqZWN0XCIsICgpID0+IGdvQmFjaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuY29uc3QgUFJFTE9BREFCTEUgPSBbXCJjcmVhdGVcIiwgXCJ1cGRhdGVcIiwgXCJsaXN0XCIsIFwiZGVsZXRlXCIsIFwiZGV0YWlsc1wiXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1JVRFZhcmlhbnRzUHJlbG9hZGVyIHtcbiAgICBzdGF0aWMgYXN5bmMgcHJlbG9hZChjb250cm9sbGVyLCB0eXBlID0gXCJsaXN0XCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghUFJFTE9BREFCTEUuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJlbG9hZCA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0eXBlfS5wcmVsb2FkYCwge30pO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByZWxvYWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZCA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgcHJlbG9hZGAsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwcmVsb2FkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpYlByb3BzID0gT2JqZWN0LmtleXMocHJlbG9hZCk7XG4gICAgICAgICAgICAgICAgbGV0IHByb21zID0gW107XG4gICAgICAgICAgICAgICAgbGliUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW9kZWxOYW1lID0gbm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIocHJlbG9hZFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBNb2RlbCA9IGNvbnRyb2xsZXIubWFrZVttb2RlbE5hbWVdKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaChNb2RlbC4kbGlzdEFsbCgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21zKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpYlByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gbGliUHJvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0uc3RhdHVzID09PSBcIm9rXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocmVzdWx0c1tpXS5yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0c0xpc3QgPSByZXN1bHRzW2ldLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRzID0gcmVzdWx0c0xpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHZhcmlhbnRzLiR7dHlwZX0uJHtwcm9wTmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5sb2coXCJwcmVsb2FkIGZpbmlzaGVkXCIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImNvbnN0IERFRkFVTFRfQUNUSU9OID0gXCJsaXN0XCI7XG5cbmNsYXNzIG5vdENSVURSb3V0ZXIge1xuICAgIHN0YXRpYyBleHRyYWN0QWN0aW9uTmFtZShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IGFjdGlvbk5hbWUgPSBERUZBVUxUX0FDVElPTjtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbMF0gPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJjcmVhdGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5hY3Rpb25IYW5kbGVyRXhpc3RzKHBhcmFtc1swXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gcGFyYW1zWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJkZXRhaWxzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbMV0gPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJkZWxldGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zWzFdID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IFwidXBkYXRlXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBwYXJhbXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbk5hbWU7XG4gICAgfVxuXG4gICAgc3RhdGljIHJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IG5vdENSVURSb3V0ZXIuZXh0cmFjdEFjdGlvbk5hbWUoXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNldEN1cnJlbnRBY3Rpb24oYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5ydW5BY3Rpb24oYWN0aW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVURSb3V0ZXI7XG4iLCJpbXBvcnQgeyBVSVN1Y2Nlc3MsIFVJRXJyb3IgfSBmcm9tIFwiLi4vLi4vZWxlbWVudHMvbm90aWZpY2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENSVURNZXNzYWdlIHtcbiAgICBzdGF0aWMgZXJyb3IoY29udHJvbGxlciwgdGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRVSShcbiAgICAgICAgICAgIFwiX19tZXNzYWdlX19cIixcbiAgICAgICAgICAgIG5ldyBVSUVycm9yKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHsgdGl0bGUsIG1lc3NhZ2UgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHN1Y2Nlc3MoY29udHJvbGxlciwgdGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRVSShcbiAgICAgICAgICAgIFwiX19tZXNzYWdlX19cIixcbiAgICAgICAgICAgIG5ldyBVSVN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBwcm9wczogeyB0aXRsZSwgbWVzc2FnZSB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBub3RMb2NhbGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmltcG9ydCB7IG5vdEZvcm0gfSBmcm9tIFwiLi4vLi4vLi4vY29tcG9uZW50c1wiO1xuaW1wb3J0IHsgREVGQVVMVF9UUkFTRk9STUVSIH0gZnJvbSBcIi4uLy4uL2NvbnN0XCI7XG5pbXBvcnQgeyBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQgfSBmcm9tIFwiLi4vLi4vLi4vY29uc3RcIjtcbmltcG9ydCB7IG1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCA9IFwi0J/RgNC+0YHQvNC+0YLRgFwiO1xuXG4vKipcbiAqIEdlbmVyaWMgQ1JVRCBhY3Rpb24gY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvbiB7XG4gICAgc3RhdGljIGdldCBOQVZJR0FUSU9OX0RFTEFZKCkge1xuICAgICAgICByZXR1cm4gTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGJyZWFkY3J1bWJzIHRhaWwgdGVtcGxhdGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGRlYWZ1bHRCcmVhZGNydW1ic1RhaWwoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWJhcmFyeSBvZiBicmVhZGNydW1icyB0YWlscyBzdHJpbmdzIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBicmVhZGNydW1ic1RhaWxzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlc2V0OiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCxcbiAgICAgICAgICAgIHNldDogJ9Cf0YDQvtGB0LzQvtGC0YAsIFwiezp0aXRsZX1cIicsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZW1wbGF0ZSBvZiBicmVhZGNydW1icyB0YWlsXG4gICAgICogQHBhcmFtICAge3N0cmluZ30gICAgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIHRlbXBsYXRlIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRCcmVhZGNydW1ic1RhaWwobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnJlYWRjcnVtYnNUYWlscykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5zZWxlY3QoXG4gICAgICAgICAgICB0aGlzLmJyZWFkY3J1bWJzVGFpbHMsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGhpcy5kZWFmdWx0QnJlYWRjcnVtYnNUYWlsXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gQUNUSU9OIHRoaXMgY29udHJvbGxlciBhY3Rpb24gbmFtZSwgdXNlZCBpbiBVUklcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEFDVElPTigpIHtcbiAgICAgICAgcmV0dXJuIFwiZGV0YWlsc1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTiAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9HRVQoKSB7XG4gICAgICAgIHJldHVybiBcImdldFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX1BVVCgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2V0XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7b2JqZWN0fSBVSUNvbnN0cnVjdG9yICAgIGNvbnN0cnVjdG9yIG9mIFVJIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgVUlDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIG5vdEZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge2Z1bmN0aW9ufSAgIFRSQU5TRk9STUVSICAgICByZXNwb25zZS5yZXN1bHQgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gaWYgd2FudCB0byBjaGFuZ2UgaXQncyBzdHJ1Y3R1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRSQU5TRk9STUVSKCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9UUkFTRk9STUVSO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hbWUgb2YgbW9kZWwgaWRlbnRpZmljYWl0b24gZmllbGRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gICAgZGVmYXVsdCBpZCBmaWVsZCBuYW1lIGlzICdfaWQnXG4gICAgICovXG4gICAgc3RhdGljIGdldElkRmllbGQoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5pZEZpZWxkYCwgXCJfaWRcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvYWREYXRhUXVlcnkoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGlkRmllbGQgPSB0aGlzLmdldElkRmllbGQoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiB7IFtpZEZpZWxkXTogcGFyYW1zWzBdIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFByb21pc2Ugb2YgQVBJIHJlcG9uc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBhcnJheSBvZiBzdHJpbmdzIHBhcnNlZCBmcm9tIFVSSSBieSByb3V0ZXIgYW5kIHBhc3NlZCB0byBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9ICAgQVBJIHJlc3BvbnNlIHtzdGF0dXM6c3RyaW5nLCByZXN1bHQ6YW55LCBtZXNzYWdlOnN0cmluZywgZXJyb3JzOiB7W2ZpZWxkbmFtZV06Wy4uLmVycm9yTWVzc2FnZXNdfX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgbG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5sb2FkRGF0YVF1ZXJ5KGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNvbnRyb2xsZXIuZ2V0TW9kZWwocXVlcnkpW2AkJHthY3Rpb25OYW1lfWBdKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtb2RlbCBBUEkgYWN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gICAgbmV0d29yayBpbnRlcmZhY2UgbW9kZWwgYWN0aW9uIG5hbWUsIGZvciBBUEk7IGRlZmF1bHQ6IHRoaXMuTU9ERUxfQUNUSU9OX0dFVFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNb2RlbEFjdGlvbk5hbWUoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5nZXRPcHRpb25zKFxuICAgICAgICAgICAgYCR7dGhpcy5BQ1RJT059LmFjdGlvbk5hbWVgLFxuICAgICAgICAgICAgdGhpcy5NT0RFTF9BQ1RJT05fR0VUXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBicmVhZGNydW1icyB0YWlsLCB3aXRob3V0IHJlc3VsdCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcHJlc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0QnJlYWRjcnVtYnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmdldEJyZWFkY3J1bWJzVGFpbChcInByZXNldFwiKSxcbiAgICAgICAgICAgICAgICB1cmw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxBY3Rpb25VUkwocGFyYW1zWzBdLCBmYWxzZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VGl0bGUoY29udG9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBjb250b2xsZXIuZ2V0SXRlbVRpdGxlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBicmVhZGNydW1icyB0YWlsIHdpdGggcmVzcG9uc2UgZGV0YWlscywgYWthIHRpdGxlIG9mIGxvYWRlZCBpdGVtXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAgICAgQVBJIHJlc3BvbnNlIGluIHdyYXBwZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UucmVzdWx0ICBBUEkgcmVzcG9uc2UgcmVzdWx0XG4gICAgICovXG4gICAgc3RhdGljIHNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICBjb25zdCBicmVhZGNydW1ic1RhaWxUZW1wbGF0ZSA9IHRoaXMuZ2V0QnJlYWRjcnVtYnNUYWlsKFwic2V0XCIpO1xuICAgICAgICBjb250cm9sbGVyLnNldEJyZWFkY3J1bWJzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogYnJlYWRjcnVtYnNUYWlsVGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBub3RMb2NhbGUuZm9ybWF0KGJyZWFkY3J1bWJzVGFpbFRlbXBsYXRlLCB7IHRpdGxlIH0pXG4gICAgICAgICAgICAgICAgICAgIDogdGl0bGUsXG4gICAgICAgICAgICAgICAgdXJsOiBjb250cm9sbGVyLmdldE1vZGVsQWN0aW9uVVJMKHBhcmFtc1swXSwgZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHJlc3BvbnNlIG9uIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2Uuc3RhdHVzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgdHJ1ZSBpZiByZXNwb25zZSBpcyBiYWRcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNSZXNwb25zZUJhZChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gIXJlc3BvbnNlIHx8IHJlc3BvbnNlLnN0YXR1cyAhPT0gXCJva1wiO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRWYWxpZGF0b3JzKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjb250cm9sbGVyLmdldFZhbGlkYXRvcnMgJiYgY29udHJvbGxlci5nZXRWYWxpZGF0b3JzKCkpIHx8XG4gICAgICAgICAgICBjb250cm9sbGVyLmdldE9wdGlvbnMoXCJWYWxpZGF0b3JzXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvYmplY3Qgd2l0aCBhbGwgb3B0aW9ucyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSBVSSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgICAgIEFQSSByZXBvbnNlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgIHVpIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIHByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZGV0YWlsc0FjdGlvbk5hbWUgPSB0aGlzLmdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgbW9kZWw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBkZXRhaWxzQWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtjb250cm9sbGVyLmdldE5hbWUoKX0uJHt0aGlzLkFDVElPTn1Gb3JtYCxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB0aGlzLmdldFZhbGlkYXRvcnMoY29udHJvbGxlciksXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgdmFyaWFudHMuJHt0aGlzLkFDVElPTn1gLCB7fSksXG4gICAgICAgICAgICAgICAgbWFzdGVyczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5tYXN0ZXJzYCwge30pLFxuICAgICAgICAgICAgICAgIGluamVjdGVkOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059LmluamVjdGVkYCwge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuVFJBTlNGT1JNRVIocmVzcG9uc2UucmVzdWx0KSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoaXMgYWN0aW9uIFVJIGNvbXBvbmVudCBmcm9tIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICBpbnN0YW5jZSBvZiBVSSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VUkoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5nZXRVSSh0aGlzLkFDVElPTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBVSSBvZiB0aGlzIGFjdGlvbiBpbiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVpICAgICAgICAgICBpbnN0YW5jZSBvZiBVSSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VUkoY29udHJvbGxlciwgdWkpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRVSSh0aGlzLkFDVElPTiwgdWkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIHZpYSBgLiRzZXRgIG1ldGhvZCBgbG9hZGluZ2AgdG8gYHRydWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQG1lbWJlcm9mIENSVURHZW5lcmljQWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHNldFVJTG9hZGluZyhjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0VUkoY29udHJvbGxlcikuJHNldCh7IGxvYWRpbmc6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgdmlhIGAuJHNldGAgbWV0aG9kIGBsb2FkaW5nYCB0byBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQG1lbWJlcm9mIENSVURHZW5lcmljQWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHNldFVJTG9hZGVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5nZXRVSShjb250cm9sbGVyKS4kc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgdmlhIGAuJHNldGAgbWV0aG9kIGBlcnJvcmAgdG8gYG1lc3NhZ2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQHBhcmFtICAge0Vycm9yfSBtZXNzYWdlICAgICBlcnJvciBtZXNzYWdlXG4gICAgICogQG1lbWJlcm9mIENSVURHZW5lcmljQWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHNldFVJRXJyb3IoY29udHJvbGxlciwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmdldFVJKGNvbnRyb2xsZXIpLiRzZXQoeyBlcnJvcjogbWVzc2FnZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBldmVudHMgdG8gYWN0aW9uIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAgICAgQVBJIHJlc3BvbnNlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIuZ29CYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInJlamVjdFwiLCAoKSA9PiBjb250cm9sbGVyLmdvQmFjaygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnQgaGFuZGxlciBuYW1lZCBldmVudCB0byBVSS4gQ2hlY2tzIGRpZmZlcmVudCBiaW5kZXIgbm90YXRpb24gJG9uL29uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50ICAgICAgICBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgICBjYWxsYmFjayBmdW5jdGlvbiBvbiBldmVudFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB1aSA9IHRoaXMuZ2V0VUkoY29udHJvbGxlcik7XG4gICAgICAgIGlmICh1aS4kb24pIHtcbiAgICAgICAgICAgIHJldHVybiB1aS4kb24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkub24pIHtcbiAgICAgICAgICAgIHJldHVybiB1aS5vbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ1ZSwgaWYgVUkgb2YgdGhpcyBhY3Rpb24gYWxyZWFkeSBleGlzdHMsXG4gICAgICogZmFsc2UsIGlmIFVJIG9mIHRoaXMgYWN0aW9uIHdhc24ndCBleGlzdGVkIGFuZCBvdGhlciBVSXMgd2VyZSBkZXN0b3J5ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICB0cnVlIGlmIFVJIG9mIHRoaXMgYWN0aW9uIGV4aXN0cywgZmFsc2UgaWYgVUkgb2Ygb3RoZXIgd2FzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHN0YXRpYyBpc1VJUmVuZGVyZWQoY29udHJvbGxlcikge1xuICAgICAgICBpZiAodGhpcy5nZXRVSShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIHR3ZWFrVUlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVVJKHVpQ29tcG9uZW50LCBjb250cm9sbGVyLCByZXNwb25zZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyh1aUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3VudChcbiAgICAgICAgICAgICAgICB1aUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1aUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybWluZyBhY3Rpb24gcHJlcGFyYXRpb24gYW5kIHJlbmRlcnMgVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgc3RhcnRpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYmVmb3JlOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2lmIFVJIGZvciB0aGlzIGFjdGlvbiBleGlzdHMgZXhpdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVSVJlbmRlcmVkKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pbmRpY2F0aW5nIHRoYXQgd2UgYXJlIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgICAgIC8vcHJlbG9hZGluZyBmb3JtIHZhcmlhbnRzXG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnByZWxvYWRWYXJpYW50cyh0aGlzLkFDVElPTik7XG4gICAgICAgICAgICAvL3NldHRpbmcgaW5pdGlhbCBzdGF0ZSBvZiBicmVhZGNydW1icyB0YWlsXG4gICAgICAgICAgICB0aGlzLnByZXNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2xvYWRpbmcgZGF0YVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmxvYWREYXRhKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZSBpZiByZXNwb25zZSBpcyAnYmFkJ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNwb25zZUJhZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRpbmcgYnJlYWRjcnVtYnMgdGFpbCB3aXRoIG1vcmUgZGV0YWlscyBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLnNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9jcmVhdGluZyBhY3Rpb24gVUkgY29tcG9uZW50XG4gICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgdWlDb21wb25lbnQgPSB0aGlzLlVJQ29uc3RydWN0b3I7XG4gICAgICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgdWkgPSB0aGlzLmNyZWF0ZVVJKCk7XG4gICAgICAgICAgICB0aGlzLnNldFVJKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgLy9iaW5kIGV2ZW50cyB0byBVSVxuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSByZWFkeVxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBhZnRlcjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pbmZvcm1pbmcgYWJvdXQgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGV4Y2VwdGlvbjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIGUpO1xuICAgICAgICAgICAgLy9yZXBvcnRpbmcgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ29CYWNrQWZ0ZXJEZWxheShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ29CYWNrKHRoaXMuTkFWSUdBVElPTl9ERUxBWSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdvQmFjayhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ29CYWNrKDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREdlbmVyaWNBY3Rpb247XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb24gZnJvbSBcIi4vYWN0aW9uXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmNvbnN0IEFDVElPTiA9IFwiY3JlYXRlXCI7XG5jb25zdCBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCA9IFwi0KHQvtC30LTQsNC90LjQtVwiO1xuXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IGRlYWZ1bHRCcmVhZGNydW1ic1RhaWwoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IGJyZWFkY3J1bWJzVGFpbHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBBQ1RJT04oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT047XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX0dFVCgpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTiAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9QVVQoKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vY29udHJvbGxlci5jcnVkJyl9IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge2FueX0gICAgICAgICAgICAgICAgICAgICAgICAgW3BhcmFtc11cbiAgICAgKiBAcmV0dXJucyB7aW1wb3J0KCdub3Qtbm9kZS9zcmMvdHlwZXMnKS5ub3RBcHBSZXNwb25zZX1cbiAgICAgKi9cbiAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBsb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgZGVmRGF0YSA9IGNvbnRyb2xsZXIuY3JlYXRlRGVmYXVsdCgpO1xuICAgICAgICBpZiAoZGVmRGF0YS5nZXREYXRhKSB7XG4gICAgICAgICAgICBkZWZEYXRhID0gZGVmRGF0YS5nZXREYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgICAgICAgcmVzdWx0OiBkZWZEYXRhLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRUaXRsZShjb250b2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRvbGxlci5nZXRJdGVtVGl0bGUocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgbW9kZWw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IGAke2NvbnRyb2xsZXIuZ2V0TmFtZSgpfS4ke3RoaXMuQUNUSU9OfUZvcm1gLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IHRoaXMuZ2V0VmFsaWRhdG9ycyhjb250cm9sbGVyKSxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogY29udHJvbGxlci5nZXRPcHRpb25zKGB2YXJpYW50cy4ke3RoaXMuQUNUSU9OfWAsIHt9KSxcbiAgICAgICAgICAgICAgICBtYXN0ZXJzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059Lm1hc3RlcnNgLCB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogdGhpcy5UUkFOU0ZPUk1FUihyZXNwb25zZSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgZXZlbnRzIHRvIGFjdGlvbiBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Jlc3BvbnNlXSAgICAgQVBJIHJlc3BvbnNlXG4gICAgICovXG4gICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdGF0aWMgYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5nb0JhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwicmVqZWN0XCIsICgpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5nb0JhY2soY29udHJvbGxlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5vbkFjdGlvblN1Ym1pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnQoY29udHJvbGxlciwgXCJzdWJtaXRcIiwgYXN5bmMgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQodGhpcy5BQ1RJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5sb2FkRGF0YVF1ZXJ5KGNvbnRyb2xsZXIsIHBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLmV2LmRldGFpbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvQmFja0FmdGVyRGVsYXkoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENSVURHZW5lcmljQWN0aW9uQ3JlYXRlO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uQ3JlYXRlIGZyb20gXCIuL2dlbmVyaWMvY3JlYXRlXCI7XG5cbmNsYXNzIENSVURBY3Rpb25DcmVhdGUgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSB7fVxuXG5leHBvcnQgZGVmYXVsdCBDUlVEQWN0aW9uQ3JlYXRlO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uIGZyb20gXCIuL2FjdGlvblwiO1xuXG4vKipcbiAqIEdlbmVyaWMgQ1JVRCBEZXRhaWxzIGFjdGlvbiBjbGFzc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIENSVURHZW5lcmljQWN0aW9uUmVhZCBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICBzdGF0aWMgdHdlYWtVSU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLm9wdGlvbnMudWkgPSB7XG4gICAgICAgICAgICBzdWJtaXQ6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1pbmcgYWN0aW9uIHByZXBhcmF0aW9uIGFuZCByZW5kZXJzIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHN0YXJ0aW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGJlZm9yZTpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9pZiBVSSBmb3IgdGhpcyBhY3Rpb24gZXhpc3RzIGV4aXRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVUlSZW5kZXJlZChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaW5kaWNhdGluZyB0aGF0IHdlIGFyZSB3b3JraW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgICAgICAvL3ByZWxvYWRpbmcgZm9ybSB2YXJpYW50c1xuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHModGhpcy5BQ1RJT04pO1xuICAgICAgICAgICAgLy9zZXR0aW5nIGluaXRpYWwgc3RhdGUgb2YgYnJlYWRjcnVtYnMgdGFpbFxuICAgICAgICAgICAgdGhpcy5wcmVzZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9sb2FkaW5nIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5sb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2UgaWYgcmVzcG9uc2UgaXMgJ2JhZCdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2VCYWQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0aW5nIGJyZWFkY3J1bWJzIHRhaWwgd2l0aCBtb3JlIGRldGFpbHMgZnJvbSByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5zZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vY3JlYXRpbmcgYWN0aW9uIFVJIGNvbXBvbmVudFxuICAgICAgICAgICAgY29uc3QgdWlDb21wb25lbnQgPSB0aGlzLlVJQ29uc3RydWN0b3I7XG4gICAgICAgICAgICB0aGlzLnNldFVJKFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgbmV3IHVpQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vYmluZCBldmVudHMgdG8gVUlcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgcmVhZHlcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYWZ0ZXI6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCBlKTtcbiAgICAgICAgICAgIC8vcmVwb3J0aW5nIGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUlVER2VuZXJpY0FjdGlvblJlYWQ7XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb25SZWFkIGZyb20gXCIuL2dlbmVyaWMvcmVhZFwiO1xuXG4vKipcbiAqIENSVUQgYWN0aW9uIGRldGFpbHNcbiAqL1xuY2xhc3MgQ1JVREFjdGlvbkRldGFpbHMgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvblJlYWQge31cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREFjdGlvbkRldGFpbHM7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcbmltcG9ydCBDUlVER2VuZXJpY0FjdGlvbiBmcm9tIFwiLi9hY3Rpb25cIjtcblxuY29uc3QgREVGQVVMVF9CUkVBRENSVU1CX1RBSUwgPSBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDQvdC40LVcIjtcbi8qKlxuICogR2VuZXJpYyBDUlVEIFVwZGF0ZSBhY3Rpb24gY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGJyZWFkY3J1bWJzIHRhaWwgdGVtcGxhdGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGRlYWZ1bHRCcmVhZGNydW1ic1RhaWwoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWJhcmFyeSBvZiBicmVhZGNydW1icyB0YWlscyBzdHJpbmdzIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBicmVhZGNydW1ic1RhaWxzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlc2V0OiBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCxcbiAgICAgICAgICAgIHNldDogYCR7REVGQVVMVF9CUkVBRENSVU1CX1RBSUx9OiBcIns6dGl0bGV9XCJgLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gQUNUSU9OIHRoaXMgY29udHJvbGxlciBhY3Rpb24gbmFtZSwgdXNlZCBpbiBVUklcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEFDVElPTigpIHtcbiAgICAgICAgcmV0dXJuIFwidXBkYXRlXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT05fR0VUICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX0dFVCgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2V0UmF3XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT05fUFVUICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX1BVVCgpIHtcbiAgICAgICAgcmV0dXJuIFwidXBkYXRlXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvYmplY3Qgd2l0aCBhbGwgb3B0aW9ucyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSBVSSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgICAgIEFQSSByZXBvbnNlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgIHVpIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIHByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgbW9kZWw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLk1PREVMX0FDVElPTl9QVVQsIC8vd2lsbCBiZSB1c2VkIHRvIGdldCBmb3JtIGZpZWxkcyBpbmZvcm1hdGlvbiBmcm9tIG1hbmlmZXN0XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7Y29udHJvbGxlci5nZXROYW1lKCl9LiR7dGhpcy5BQ1RJT059Rm9ybWAsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogdGhpcy5nZXRWYWxpZGF0b3JzKGNvbnRyb2xsZXIpLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYHZhcmlhbnRzLiR7dGhpcy5BQ1RJT059YCwge30pLFxuICAgICAgICAgICAgICAgIHVpOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059LnVpYCwge30pLFxuICAgICAgICAgICAgICAgIGZpZWxkczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5maWVsZHNgLCB7fSksXG4gICAgICAgICAgICAgICAgbWFzdGVyczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5tYXN0ZXJzYCwge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuVFJBTlNGT1JNRVIobm90Q29tbW9uLnN0cmlwUHJveHkocmVzcG9uc2UucmVzdWx0KSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgZXZlbnRzIHRvIGFjdGlvbiBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Jlc3BvbnNlXSAgICAgQVBJIHJlc3BvbnNlXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIuZ29CYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInJlamVjdFwiLCAoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZ29CYWNrKGNvbnRyb2xsZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwic3VibWl0XCIsIGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KHRoaXMuQUNUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMubG9hZERhdGFRdWVyeShjb250cm9sbGVyLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi5ldi5kZXRhaWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb0JhY2tBZnRlckRlbGF5KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ1ZSwgaWYgVUkgb2YgdGhpcyBhY3Rpb24gYWxyZWFkeSBleGlzdHMsXG4gICAgICogZmFsc2UsIGlmIFVJIG9mIHRoaXMgYWN0aW9uIHdhc24ndCBleGlzdGVkIGFuZCBvdGhlciBVSXMgd2VyZSBkZXN0b3J5ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICB0cnVlIGlmIFVJIG9mIHRoaXMgYWN0aW9uIGV4aXN0cywgZmFsc2UgaWYgVUkgb2Ygb3RoZXIgd2FzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHN0YXRpYyBpc1VJUmVuZGVyZWQoY29udHJvbGxlcikge1xuICAgICAgICBpZiAodGhpcy5nZXRVSShjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybWluZyBhY3Rpb24gcHJlcGFyYXRpb24gYW5kIHJlbmRlcnMgVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgc3RhcnRpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYmVmb3JlOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIFtwYXJhbXNdKTtcbiAgICAgICAgICAgIC8vaWYgVUkgZm9yIHRoaXMgYWN0aW9uIGV4aXN0cyBleGl0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VJUmVuZGVyZWQoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2luZGljYXRpbmcgdGhhdCB3ZSBhcmUgd29ya2luZ1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICAgICAgLy9wcmVsb2FkaW5nIGZvcm0gdmFyaWFudHNcbiAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKHRoaXMuQUNUSU9OKTtcbiAgICAgICAgICAgIC8vc2V0dGluZyBpbml0aWFsIHN0YXRlIG9mIGJyZWFkY3J1bWJzIHRhaWxcbiAgICAgICAgICAgIHRoaXMucHJlc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vbG9hZGluZyBkYXRhXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlIGlmIHJlc3BvbnNlIGlzICdiYWQnXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jlc3BvbnNlQmFkKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cGRhdGluZyBicmVhZGNydW1icyB0YWlsIHdpdGggbW9yZSBkZXRhaWxzIGZyb20gcmVzcG9uc2VcbiAgICAgICAgICAgIHRoaXMuc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2NyZWF0aW5nIGFjdGlvbiBVSSBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbnN0IHVpQ29tcG9uZW50ID0gdGhpcy5VSUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy5zZXRVSShcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgIG5ldyB1aUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50d2Vha1VJT3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL2JpbmQgZXZlbnRzIHRvIFVJXG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHJlYWR5XG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGFmdGVyOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCBlKTtcbiAgICAgICAgICAgIC8vcmVwb3J0aW5nIGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZTtcbiIsImltcG9ydCBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSBmcm9tIFwiLi9nZW5lcmljL3VwZGF0ZVwiO1xuXG4vKipcbiAqIENSVUQgYWN0aW9uIHVwZGF0ZVxuICovXG5jbGFzcyBDUlVEQWN0aW9uVXBkYXRlIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGUge31cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREFjdGlvblVwZGF0ZTtcbiIsImltcG9ydCBub3RBY3Rpb25VSSBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9hY3Rpb24vYWN0aW9uLnVpLmpzXCI7XG5cbmNvbnN0IEFDVElPTiA9IFwiZGVsZXRlXCI7XG5jb25zdCBNT0RFTF9BQ1RJT04gPSBcImRlbGV0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUlVEQWN0aW9uRGVsZXRlIHtcbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudWlbQUNUSU9OXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXSA9IG5ldyBub3RBY3Rpb25VSSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDUlVERGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZXJTdHlsZTogXCJjb250YWluZXJcIixcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyVGl0bGU6IFwibm90LW5vZGU6Y3J1ZF9kZWxldGVfYWN0aW9uX3dhaXRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogYGNydWQtZGVsZXRlLWFjdGlvbi0ke3BhcmFtc1swXX1gLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCLQo9C00LDQu9C10L3QuNC1XCIsXG4gICAgICAgICAgICAgICAgICAgIHVybDogY29udHJvbGxlci5nZXRNb2RlbEFjdGlvblVSTChwYXJhbXNbMF0sIEFDVElPTiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlybShcItCj0LTQsNC70LjRgtGMINC30LDQv9C40YHRjD9cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVBY3Rpb25OYW1lID0gY29udHJvbGxlci5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICBgJHtBQ1RJT059LmFjdGlvbk5hbWVgLFxuICAgICAgICAgICAgICAgICAgICBNT0RFTF9BQ1RJT05cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVBY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IHBhcmFtc1swXSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5nb0xpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5nb0xpc3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBub3RUYWJsZSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzXCI7XG5cbmNvbnN0IEFDVElPTiA9IFwibGlzdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUlVEQWN0aW9uTGlzdCB7XG4gICAgc3RhdGljIHR3ZWFrQWN0aW9uc0xpc3QoY29udHJvbGxlciwgQUNUSU9OU19MSVNUKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7QUNUSU9OfS5jcmVhdGVBY3Rpb25gLCB0cnVlKSkge1xuICAgICAgICAgICAgQUNUSU9OU19MSVNULnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCh0L7Qt9C00LDRgtGMXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBjb250cm9sbGVyLmdvQ3JlYXRlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUNUSU9OU19MSVNUO1xuICAgIH1cblxuICAgIHN0YXRpYyB0d2Vha1VJT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvbnRyb2xsZXIuY3J1ZCcpLmRlZmF1bHR9IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbYWN0aW9ucz1bXCJkZXRhaWxzXCIsIFwidXBkYXRlXCIsIFwiZGVsZXRlXCJdXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gW3ByZXBlbmQ9W11dXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBbYXBwZW5kPVtdXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29ubHlJY29ucz10cnVlXVxuICAgICAqIEByZXR1cm4ge0FycmF5PG9iamVjdD59XG4gICAgICogQG1lbWJlcm9mIENSVURBY3Rpb25MaXN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUFjdGlvbnNCdXR0b25zKFxuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICBhY3Rpb25zID0gW1wiZGV0YWlsc1wiLCBcInVwZGF0ZVwiLCBcImRlbGV0ZVwiXSxcbiAgICAgICAgcHJlcGVuZCA9IFtdLFxuICAgICAgICBhcHBlbmQgPSBbXSxcbiAgICAgICAgb25seUljb25zID0gdHJ1ZVxuICAgICkge1xuICAgICAgICBjb25zdCBBQ1RJT05TID0ge1xuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb0RldGFpbHModmFsdWUsIGRlbGF5KSxcbiAgICAgICAgICAgICAgICAuLi4ob25seUljb25zXG4gICAgICAgICAgICAgICAgICAgID8geyBpY29uOiBcImNpcmNsZS1pbmZvXCIgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgdGl0bGU6IFwi0J/QvtC00YDQvtCx0L3QtdC1XCIgfSksXG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb1VwZGF0ZSh2YWx1ZSwgZGVsYXkpLFxuICAgICAgICAgICAgICAgIC4uLihvbmx5SWNvbnMgPyB7IGljb246IFwiZWRpdFwiIH0gOiB7IHRpdGxlOiBcItCY0LfQvNC10L3QuNGC0YxcIiB9KSxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb0RlbGV0ZSh2YWx1ZSwgZGVsYXkpLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgICAgIC4uLihvbmx5SWNvbnMgPyB7IGljb246IFwidHJhc2hcIiB9IDogeyB0aXRsZTogXCLQo9C00LDQu9C40YLRjFwiIH0pLFxuICAgICAgICAgICAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJvdXRsaW5lZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0aW9uc0J1dHRvbnMgPSBbLi4ucHJlcGVuZF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFjdGlvbnMpKSB7XG4gICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goKGFjdGlvbk5hbWUpID0+XG4gICAgICAgICAgICAgICAgYWN0aW9uc0J1dHRvbnMucHVzaChBQ1RJT05TW2FjdGlvbk5hbWVdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zQnV0dG9ucy5wdXNoKC4uLmFwcGVuZCk7XG4gICAgICAgIHJldHVybiBhY3Rpb25zQnV0dG9ucztcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmRpY2F0aW5nIHRoYXQgd2UgYXJlIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4oKTtcblxuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHMoQUNUSU9OKTtcblxuICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCLQodC/0LjRgdC+0LpcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjb250cm9sbGVyLmdldE1vZGVsVVJMKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci51aVtBQ1RJT05dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dID0gbmV3IG5vdFRhYmxlKFxuICAgICAgICAgICAgICAgIHRoaXMudHdlYWtVSU9wdGlvbnMoQ1JVREFjdGlvbkxpc3QucHJlcGFyZU9wdGlvbnMoY29udHJvbGxlcikpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoXG4gICAgICAgICAgICAgICAgYGFmdGVyOnJlbmRlcjoke0FDVElPTn1gLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnVpW0FDVElPTl1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7QUNUSU9OfWAsIHBhcmFtcywgZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBwcmVwYXJlT3B0aW9ucyhjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IERFRkFVTFRfT1BUSU9OU19UQUJMRSA9IHtcbiAgICAgICAgICAgIGludGVyZmFjZTogY29udHJvbGxlci5nZXRPcHRpb25zKGAke0FDVElPTn0uaW50ZXJmYWNlYCwge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZhY3Rvcnk6IGNvbnRyb2xsZXIuZ2V0SW50ZXJmYWNlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGZpZWxkczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2hvd1NlbGVjdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ2V0SXRlbUlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpZEZpZWxkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVsb2FkOiB7fSxcbiAgICAgICAgICAgIGZpbHRlclVJOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7QUNUSU9OfS5maWx0ZXJVSWApLFxuICAgICAgICAgICAgcGFnZXI6IHsgc2l6ZTogNTAsIHBhZ2U6IDAgfSxcbiAgICAgICAgICAgIHNvcnRlcjoge1xuICAgICAgICAgICAgICAgIGlkOiAtMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWx0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVpOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vZm9ybWluZyBhY3Rpb25zIGJ1dHRvbnMgbGlzdFxuICAgICAgICBsZXQgQUNUSU9OU19MSVNUID0gWy4uLmNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHtBQ1RJT059LmFjdGlvbnNgLCBbXSldO1xuICAgICAgICBBQ1RJT05TX0xJU1QgPSB0aGlzLnR3ZWFrQWN0aW9uc0xpc3QoY29udHJvbGxlciwgQUNUSU9OU19MSVNUKTtcbiAgICAgICAgLy9cbiAgICAgICAgY29uc3QgVEFCTEVfT1BUSU9OUyA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBlbmRsZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBBQ1RJT05TX0xJU1QsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhERUZBVUxUX09QVElPTlNfVEFCTEUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IG9wdFZhbCA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBgJHtBQ1RJT059LiR7a2V5fWAsXG4gICAgICAgICAgICAgICAgREVGQVVMVF9PUFRJT05TX1RBQkxFW2tleV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdFZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIFRBQkxFX09QVElPTlMub3B0aW9uc1trZXldID0gb3B0VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRBQkxFX09QVElPTlM7XG4gICAgfVxufVxuIiwiaW1wb3J0IENSVURBY3Rpb25DcmVhdGUgZnJvbSBcIi4vY3JlYXRlXCI7XG5pbXBvcnQgQ1JVREFjdGlvbkRldGFpbHMgZnJvbSBcIi4vZGV0YWlsc1wiO1xuaW1wb3J0IENSVURBY3Rpb25VcGRhdGUgZnJvbSBcIi4vdXBkYXRlXCI7XG5pbXBvcnQgQ1JVREFjdGlvbkRlbGV0ZSBmcm9tIFwiLi9kZWxldGVcIjtcbmltcG9ydCBDUlVEQWN0aW9uTGlzdCBmcm9tIFwiLi9saXN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGU6IENSVURBY3Rpb25DcmVhdGUsXG4gICAgZGV0YWlsczogQ1JVREFjdGlvbkRldGFpbHMsXG4gICAgdXBkYXRlOiBDUlVEQWN0aW9uVXBkYXRlLFxuICAgIGRlbGV0ZTogQ1JVREFjdGlvbkRlbGV0ZSxcbiAgICBsaXN0OiBDUlVEQWN0aW9uTGlzdCxcbn07XG4iLCJpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uL2VsZW1lbnRzL2NvbW1vblwiO1xuXG5pbXBvcnQgbm90QnJlYWRjcnVtYnMgZnJvbSBcIi4uL2NvbXBvbmVudHMvYnJlYWRjcnVtYnNcIjtcblxuaW1wb3J0IFVJTG9hZGVyIGZyb20gXCIuLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmxvYWRlci5zdmVsdGVcIjtcblxuaW1wb3J0IG5vdENvbnRyb2xsZXIgZnJvbSBcIi4uL2NvbnRyb2xsZXJcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG5pbXBvcnQgQ1JVRFZhcmlhbnRzUHJlbG9hZGVyIGZyb20gXCIuL3ZhcmlhbnRzLnByZWxvYWRlci5qc1wiO1xuaW1wb3J0IENSVURSb3V0ZXIgZnJvbSBcIi4vcm91dGVyLmpzXCI7XG5pbXBvcnQgQ1JVRE1lc3NhZ2UgZnJvbSBcIi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IENSVURBY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmltcG9ydCB7IG1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBCUkVBRENSVU1CUyA9IFtdO1xuY29uc3QgVElUTEVfRklFTERTX1BSSU9SSVRZID0gW1widGl0bGVcIiwgXCJsYWJlbFwiLCBcImlkXCIsIFwibmFtZVwiXTtcblxuY29uc3QgTE9BRElOR19TQ1JFRU5fVUlfTkFNRSA9IFwibG9hZGluZ19zY3JlZW5cIjtcblxuY2xhc3Mgbm90Q1JVRCBleHRlbmRzIG5vdENvbnRyb2xsZXIge1xuICAgICNhY3Rpb25zID0geyAuLi5DUlVEQWN0aW9ucyB9O1xuICAgICNyb3V0ZXIgPSBDUlVEUm91dGVyO1xuICAgICNwcmVsb2FkZXIgPSBDUlVEVmFyaWFudHNQcmVsb2FkZXI7XG5cbiAgICBUSVRMRV9GSUVMRFNfUFJJT1JJVFkgPSBUSVRMRV9GSUVMRFNfUFJJT1JJVFk7XG5cbiAgICBzdGF0aWMgRVJST1JfREVGQVVMVCA9IFVJQ29tbW9uLkVSUk9SX0RFRkFVTFQ7XG5cbiAgICBUT1BfQ0xBU1MgPSBbXCJib3hcIl07XG4gICAgTUFJTl9DTEFTUyA9IFtcImJveFwiXTtcbiAgICBCT1RUT01fQ0xBU1MgPSBbXCJib3hcIl07XG5cbiAgICBXU19DSEVDS19JTlRFUlZBTCA9IDIwMDtcblxuICAgIHN0YXRpYyBnZXQgTEFCRUxTKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBwbHVyYWw6IGAke3RoaXMuTU9EVUxFX05BTUV9OiR7dGhpcy5NT0RFTF9OQU1FfV9sYWJlbF9wbHVyYWxgLFxuICAgICAgICAgICAgc2luZ2xlOiBgJHt0aGlzLk1PRFVMRV9OQU1FfToke3RoaXMuTU9ERUxfTkFNRX1fbGFiZWxfc2luZ2xlYCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1lbnUoaXRlbUN1c3RvbVByb3BzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uOiB0aGlzLk1PRFVMRV9OQU1FLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLkxBQkVMUy5wbHVyYWwsXG4gICAgICAgICAgICAgICAgdXJsOiBgLyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX05BTUVcbiAgICAgICAgICAgICAgICApfS8ke25vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHRoaXMuTU9ERUxfTkFNRSl9YCxcbiAgICAgICAgICAgICAgICAuLi5pdGVtQ3VzdG9tUHJvcHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBhcHAsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHsgYWN0aW9ucywgcm91dGVyLCBwcmVsb2FkZXIgfSA9IHtcbiAgICAgICAgICAgIGFjdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJvdXRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlbG9hZGVyOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICApIHtcbiAgICAgICAgc3VwZXIoYXBwLCBgQ1JVRC4ke25hbWV9YCk7XG4gICAgICAgIGlmIChhY3Rpb25zKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLiNhY3Rpb25zID0geyAuLi50aGlzLiNhY3Rpb25zLCAuLi5hY3Rpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdXRlcikge1xuICAgICAgICAgICAgdGhpcy4jcm91dGVyID0gcm91dGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVsb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3ByZWxvYWRlciA9IHByZWxvYWRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpID0ge307XG4gICAgICAgIHRoaXMuZWxzID0ge307XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcIm5hbWVzXCIsIHtcbiAgICAgICAgICAgIG1vZHVsZTogXCJcIixcbiAgICAgICAgICAgIHBsdXJhbDogXCJwbHVyYWxcIixcbiAgICAgICAgICAgIHNpbmdsZTogXCJzaW5nbGVcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcbiAgICAgICAgICAgIFwiY29udGFpbmVyU2VsZWN0b3JcIixcbiAgICAgICAgICAgIHRoaXMuYXBwPy5nZXRPcHRpb25zKFwiY3J1ZC5jb250YWluZXJTZWxlY3RvclwiKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmJ1aWxkRnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIC8vbm90LW1vZHVsZS1uYW1lIC0+IFtub3QsbW9kdWxlLG5hbWVdXG4gICAgICAgIGNvbnN0IE1vZHVsZU5hbWVQYXJ0cyA9IHRoaXMuZ2V0TW9kdWxlTmFtZSgpLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgLy9bbm90LG1vZHVsZSxuYW1lXSAtPiBNb2R1bGVOYW1lXG4gICAgICAgIGNvbnN0IE1vZHVsZU5hbWUgPSAoXG4gICAgICAgICAgICBNb2R1bGVOYW1lUGFydHNbMF0gPT09IFwibm90XCJcbiAgICAgICAgICAgICAgICA/IE1vZHVsZU5hbWVQYXJ0cy5zcGxpY2UoMSlcbiAgICAgICAgICAgICAgICA6IE1vZHVsZU5hbWVQYXJ0c1xuICAgICAgICApXG4gICAgICAgICAgICAubWFwKG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIpXG4gICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgY29uc3Qgc2VydmljZU5hbWUgPSBgbnMke01vZHVsZU5hbWV9Q29tbW9uYDtcbiAgICAgICAgY29uc3QgQ29tbW9uTW9kdWxlU2VydmljZSA9IHRoaXMuYXBwPy5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgXCJ2YWxpZGF0b3JzXCIsXG4gICAgICAgICAgICBDb21tb25Nb2R1bGVTZXJ2aWNlLmF1Z21lbnRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZ2V0VmFsaWRhdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInZhbGlkYXRvcnNcIik7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGxldCBuZXdIZWFkID0gW107XG4gICAgICAgIGlmICh0aGlzLmdldE1vZHVsZU5hbWUoKSAmJiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lcy5tb2R1bGVcIikpIHtcbiAgICAgICAgICAgIG5ld0hlYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuZ2V0T3B0aW9ucyhcIm5hbWVzLm1vZHVsZVwiKSxcbiAgICAgICAgICAgICAgICB1cmw6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3SGVhZC5wdXNoKHtcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lcy5wbHVyYWxcIiksXG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0TW9kZWxVUkwoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIEJSRUFEQ1JVTUJTLnNwbGljZSgwLCBCUkVBRENSVU1CUy5sZW5ndGgsIC4uLm5ld0hlYWQpO1xuICAgICAgICBub3RCcmVhZGNydW1icy5zZXRIZWFkKEJSRUFEQ1JVTUJTKS5yZW5kZXIoe1xuICAgICAgICAgICAgcm9vdDogXCJcIixcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5lbHMudG9wLFxuICAgICAgICAgICAgbmF2aWdhdGU6ICh1cmwpID0+IHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpLm5hdmlnYXRlKHVybCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvdXRlKHRoaXMuZ2V0T3B0aW9ucyhcInBhcmFtc1wiKSk7XG4gICAgfVxuXG4gICAgc3RhcnRXaGVuV1NDbGllbnRSZWFkeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwPy5nZXRXU0NsaWVudCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHA/LmdldFdTQ2xpZW50KCkuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBcbiAgICAgICAgICAgICAgICAgICAgLmdldFdTQ2xpZW50KClcbiAgICAgICAgICAgICAgICAgICAgLm9uY2UoXCJjb25uZWN0ZWRcIiwgdGhpcy5zdGFydFdoZW5XU0NsaWVudFJlYWR5LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLnN0YXJ0V2hlbldTQ2xpZW50UmVhZHkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLldTX0NIRUNLX0lOVEVSVkFMXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QnJlYWRjcnVtYnModGFpbCkge1xuICAgICAgICBub3RCcmVhZGNydW1icy5zZXRUYWlsKHRhaWwpLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGJhY2tUb0xpc3QoKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5saW5rQmFja1RvTGlzdCgpKTtcbiAgICB9XG5cbiAgICBsaW5rQmFja1RvTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWxVUkwoKTtcbiAgICB9XG5cbiAgICBhZnRlckFjdGlvbihhY3Rpb24gPSBcImxpc3RcIikge1xuICAgICAgICBsZXQgbmF2QmFjayA9IHRoaXMuYXBwPy5nZXRPcHRpb25zKFwiY3J1ZC5uYXZpZ2F0ZUJhY2tBZnRlclwiLCBbXSk7XG4gICAgICAgIGlmIChuYXZCYWNrICYmIEFycmF5LmlzQXJyYXkobmF2QmFjaykgJiYgbmF2QmFjay5pbmRleE9mKGFjdGlvbikgPiAtMSkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYWNrVG9MaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBidWlsZEZyYW1lKCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgdGhpcy5hcHA/LmdldE9wdGlvbnMoXCJjcnVkLmNvbnRhaW5lclNlbGVjdG9yXCIsIFwiYm9keVwiKVxuICAgICAgICApO1xuICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbHMudG9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbHMudG9wLmlkID0gXCJjcnVkLXRvcFwiO1xuICAgICAgICB0aGlzLmdldEZyYW1lQ2xhc3NlcygpLlRPUF9DTEFTUy5mb3JFYWNoKChuYW1lKSA9PlxuICAgICAgICAgICAgdGhpcy5lbHMudG9wLmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5lbHMudG9wKTtcbiAgICAgICAgdGhpcy5lbHMubWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWxzLm1haW4uaWQgPSBcImNydWQtbWFpblwiO1xuICAgICAgICB0aGlzLmdldEZyYW1lQ2xhc3NlcygpLk1BSU5fQ0xBU1MuZm9yRWFjaCgobmFtZSkgPT5cbiAgICAgICAgICAgIHRoaXMuZWxzLm1haW4uY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICApO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmVscy5tYWluKTtcbiAgICAgICAgdGhpcy5lbHMuYm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbHMuYm90dG9tLmlkID0gXCJjcnVkLWJvdHRvbVwiO1xuICAgICAgICB0aGlzLmdldEZyYW1lQ2xhc3NlcygpLkJPVFRPTV9DTEFTUy5mb3JFYWNoKChuYW1lKSA9PlxuICAgICAgICAgICAgdGhpcy5lbHMuYm90dG9tLmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5lbHMuYm90dG9tKTtcbiAgICB9XG5cbiAgICBnZXRGcmFtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUT1BfQ0xBU1M6IHRoaXMuVE9QX0NMQVNTLFxuICAgICAgICAgICAgTUFJTl9DTEFTUzogdGhpcy5NQUlOX0NMQVNTLFxuICAgICAgICAgICAgQk9UVE9NX0NMQVNTOiB0aGlzLkJPVFRPTV9DTEFTUyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXRDb250YWluZXJUb3BFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHMudG9wO1xuICAgIH1cblxuICAgIGdldENvbnRhaW5lcklubmVyRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxzLm1haW47XG4gICAgfVxuXG4gICAgZ2V0Q29udGFpbmVyQm90dG9tRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxzLmJvdHRvbTtcbiAgICB9XG5cbiAgICBhc3luYyBwcmVsb2FkVmFyaWFudHModHlwZSA9IFwibGlzdFwiKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3ByZWxvYWRlci5wcmVsb2FkKHRoaXMsIHR5cGUpO1xuICAgIH1cblxuICAgIGdldFRpdGxlRnJvbUxpYihwcm9wTmFtZSwgaWQpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0Q3VycmVudEFjdGlvbigpO1xuICAgICAgICB0aGlzLmRlYnVnICYmXG4gICAgICAgICAgICB0aGlzLmRlYnVnKFxuICAgICAgICAgICAgICAgIFwibm90Q1JVRC5nZXRUaXRsZUZyb21MaWIgaXMgb2Jzb2xldGUsIHVzZSBub3RDUlVELmdldFByZWxvYWRlZFZhcmlhbnRUaXRsZShhY3Rpb25OYW1lLCBwcm9wTmFtZSwgaWQpXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByZWxvYWRlZFZhcmlhbnRUaXRsZShhY3Rpb25OYW1lLCBwcm9wTmFtZSwgaWQpO1xuICAgIH1cblxuICAgIGdldFByZWxvYWRlZFZhcmlhbnRzKGFjdGlvbk5hbWUsIHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoYHZhcmlhbnRzLiR7YWN0aW9uTmFtZX0uJHtwcm9wTmFtZX1gLCBbXSk7XG4gICAgfVxuXG4gICAgZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlKGFjdGlvbk5hbWUsIHByb3BOYW1lLCBpZCkge1xuICAgICAgICBjb25zdCB2YXJpYW50cyA9IHRoaXMuZ2V0UHJlbG9hZGVkVmFyaWFudHMoYWN0aW9uTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICBjb25zdCBpdGVtID0gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udGl0bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJdGVtVGl0bGUoaXRlbSkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0aGlzLlRJVExFX0ZJRUxEU19QUklPUklUWS5maW5kKChrZXkpID0+XG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGl0ZW0sIGtleSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bZmllbGROYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwoe30pLnRvRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJvdXRlKHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcm91dGVyLnJvdXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0KGUpO1xuICAgICAgICAgICAgdGhpcy5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uSGFuZGxlckV4aXN0cyhhY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLiNhY3Rpb25zKS5pbmNsdWRlcyhhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIHRoaXNbXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoYWN0aW9uTmFtZSldID09PVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJ1bkFjdGlvbihhY3Rpb25OYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuI2FjdGlvbnMpLmluY2x1ZGVzKGFjdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYWN0aW9uc1thY3Rpb25OYW1lXS5ydW4odGhpcywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzW1wicnVuXCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbk5hbWUpXSA9PT1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1wicnVuXCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbk5hbWUpXShcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE5vIHN1Y2ggYWN0aW9uOiAke2FjdGlvbk5hbWV9IGluIGNvbnRvbGxlciAke3RoaXMuZ2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBjcmVhdGUgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbZGVsYXk9MF0gbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb0NyZWF0ZShkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChcIlwiLCBcImNyZWF0ZVwiKSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50IGRldGFpbHMgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgaWQgICAgICAgICAgdGFyZ2V0IGRvY3VtZW50IGlkXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gIFtkZWxheT0wXSAgIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29EZXRhaWxzKGlkLCBkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChpZCwgXCJcIiksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50IHVwZGF0ZSBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBpZCAgICAgICAgICB0YXJnZXQgZG9jdW1lbnQgaWRcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgW2RlbGF5PTBdICAgbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb1VwZGF0ZShpZCwgZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29BZnRlckRlbGF5KHRoaXMuZ2V0TW9kZWxBY3Rpb25VUkwoaWQsIFwidXBkYXRlXCIpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENoYW5nZXMgbG9jYXRpb24gdG8gZG9jdW1lbnQgZGVsZXRlIHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgIGlkICAgICAgICAgIHRhcmdldCBkb2N1bWVudCBpZFxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvRGVsZXRlKGlkLCBkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChpZCwgXCJkZWxldGVcIiksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudHMgbGlzdCBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvTGlzdChkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbFVSTCgpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBkZWxheVxuICAgICAqL1xuICAgIGdvQWZ0ZXJEZWxheSh1cmwsIGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksICgpID0+IHRoaXMuJGRlc3Ryb3lVSSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudHMgbGlzdCBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvQmFjayhkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0xpc3QoZGVsYXkpO1xuICAgIH1cblxuICAgIGFzeW5jIG9uQWN0aW9uU3VibWl0KGFjdGlvbiwgaXRlbSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBhY3Rpb25VSSA9IHRoaXMudWlbYWN0aW9uXTtcbiAgICAgICAgaWYgKGFjdGlvblVJKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFjdGlvblVJLnNldExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRNb2RlbChpdGVtKVtgJCR7YWN0aW9ufWBdKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBhY3Rpb25VSS5wcm9jZXNzUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBhY3Rpb25VSS5wcm9jZXNzUmVzdWx0KGUpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhY3Rpb25VSS5yZXNldExvYWRpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5zYWZlLWZpbmFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3Rpb24gVUkgZG9lc250IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJGRlc3Ryb3lVSSgpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnVpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lVSUJ5TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3lVSUJ5TmFtZShuYW1lKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odGhpcy51aSwgbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3kgJiYgdGhpcy51aVtuYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy51aVtuYW1lXS5kZXN0cm95ICYmIHRoaXMudWlbbmFtZV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudWlbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzaG93RXJyb3JNZXNzYWdlKHJlcykge1xuICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IocmVzKTtcbiAgICAgICAgdGhpcy5hcHAgJiZcbiAgICAgICAgICAgIHRoaXMuYXBwLmVtaXQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwi0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlcy5tZXNzYWdlID8gcmVzLm1lc3NhZ2UgOiBVSUNvbW1vbi5FUlJPUl9ERUZBVUxULFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIENSVURNZXNzYWdlLmVycm9yKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIFwi0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsFwiLFxuICAgICAgICAgICAgcmVzLm1lc3NhZ2UgPyByZXMubWVzc2FnZSA6IFVJQ29tbW9uLkVSUk9SX0RFRkFVTFRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzaG93U3VjY2Vzc01lc3NhZ2UodGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5hcHAgJiYgdGhpcy5hcHAuZW1pdChcInN1Y2Nlc3NcIiwgeyB0aXRsZSwgbWVzc2FnZSB9KTtcbiAgICAgICAgQ1JVRE1lc3NhZ2Uuc3VjY2Vzcyh0aGlzLCB0aXRsZSwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgc2V0VUkobmFtZSwgdmFsLCBzaW5nbGVVSSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHNpbmdsZVVJKSB7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95VUkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpW25hbWVdID0gdmFsO1xuICAgIH1cblxuICAgIGdldFVJKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWlbbmFtZV07XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uVUkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpW3RoaXMuZ2V0Q3VycmVudEFjdGlvbigpXTtcbiAgICB9XG5cbiAgICByZW5kZXJMb2FkaW5nU2NyZWVuKCkge1xuICAgICAgICB0aGlzLnNldFVJKExPQURJTkdfU0NSRUVOX1VJX05BTUUsIHRoaXMuY3JlYXRlTG9hZGVyVUkoKSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlTG9hZGluZ1NjcmVlbigpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95VUlCeU5hbWUoTE9BRElOR19TQ1JFRU5fVUlfTkFNRSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTG9hZGVyVUkoKSB7XG4gICAgICAgIHJldHVybiBtb3VudChVSUxvYWRlciwge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RDUlVEO1xuIiwiY29uc3QgUk9VVEVfTElTVCA9IFwibGlzdFwiO1xuLyoqXG4gKiBSdW5zIGNvbnRyb2xsZXIgYWN0aW9uIGJ5IG5hbWUgdGhhdCBnZXRzIGZyb20gVVJJIHBhcmFtc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdENSVURQbGFpblJvdXRlciB7XG4gICAgc3RhdGljIERFRkFVTFRfUk9VVEUgPSBST1VURV9MSVNUO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlyc3QgaXRlbSBmcm9tIHBhcmFtcyBvciB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgYXJyYXkgb2Ygc3RyaW5ncyBwYXJzZWQgZnJvbSBVUkkgYnkgcm91dGUgcnVsZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBleHRyYWN0QWN0aW9uTmFtZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLkRFRkFVTFRfUk9VVEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBjb250cm9sbGVyIGFjdGlvbiBvciB0aHJvd3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIG5vdENvbnRyb2xsZXIgZGVzY2VuZGFudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyByb3V0ZShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmV4dHJhY3RBY3Rpb25OYW1lKHBhcmFtcyk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNldEN1cnJlbnRBY3Rpb24oYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5ydW5BY3Rpb24oYWN0aW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVURQbGFpblJvdXRlcjtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4vKipcbiAqIFJ1bnMgY29udHJvbGxlciBhY3Rpb24gYnkgbmFtZSB0aGF0IGdldHMgZnJvbSBVUkkgcGFyYW1zXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3Mgbm90Q1JVRFJvdXRlclN3aXRjaCB7XG4gICAgLyoqXG4gICAgICogVmFyaWFudHMgb2YgdGhpcyBhY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJvdXRlc1ZhcmlhbnRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICByb3V0ZU5hbWU6IEFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHZhcmlhbnQgbmFtZSBpcyB2YWxpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgIG5hbWUgb2Ygcm91dGUgdmFyaWFudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1JvdXRlVmFyaWFudFZhbGlkKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgIT09IFwiXCIgJiYgbm90Q29tbW9uLm9iakhhcyh0aGlzLnJvdXRlc1ZhcmlhbnRzLCBuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgd2hpY2ggb2Ygcm91dGVzIHZhcmlhbnQgc2hvdWxkIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBub3RDb250cm9sbGVyIGRlc2NlbmRhbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSAgICBwYXJhbXMgIHBhcmFtcyBwYXNzZWQgdG8gcm91dGVyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gICAgbmFtZSBvZiByb3V0ZSB2YXJpYW50XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGFzeW5jIGRldGVybWluZVJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgY29udHJvbGxlciBhY3Rpb24gb3IgdGhyb3dzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBub3RDb250cm9sbGVyIGRlc2NlbmRhbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcm91dGUoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gYXdhaXQgdGhpcy5kZXRlcm1pbmVSb3V0ZShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSb3V0ZVZhcmlhbnRWYWxpZChhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJBY3Rpb24gPSB0aGlzLnJvdXRlc1ZhcmlhbnRzW2FjdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNBc3luYyhyb3V0ZXJBY3Rpb24ucnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZXJBY3Rpb24ucnVuKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyQWN0aW9uLnJ1bihjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgTm8gc3VjaCBhY3Rpb246ICR7YWN0aW9uTmFtZX0gaW4gY29udG9sbGVyICR7Y29udHJvbGxlci5nZXRXb3JraW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVURSb3V0ZXJTd2l0Y2g7XG4iLCJpbXBvcnQgVUlHZW5lcmljU2VsZWN0b3IgZnJvbSBcIi4uLy4uL2VsZW1lbnRzL21vZGFsL3VpLmdlbmVyaWMuc2VsZWN0b3Iuc3ZlbHRlXCI7XG5pbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgZW1wdHlSZXN1bHQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGlzdDogW10sXG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBwYWdlOiAwLFxuICAgICAgICBwYWdlczogMCxcbiAgICAgICAgc2tpcDogMCxcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgbm90U2VydmljZU1vZGVsU2VhcmNoIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIG1vZGVsTmFtZSkge1xuICAgICAgICB0aGlzLm1vZGVsTmFtZSA9IG1vZGVsTmFtZTtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwO1xuICAgIH1cblxuICAgIGdldFNlYXJjaFJvdXRlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwibGlzdEFuZENvdW50XCI7XG4gICAgfVxuXG4gICAgZ2V0RGF0YUxvYWRSb3V0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcImdldFwiO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybVNlYXJjaFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0Lmxpc3QgPSByZXN1bHQubGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX2lkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgICAgICBpZDogaXRlbVtgJHt0aGlzLm1vZGVsTmFtZX1JRGBdLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLm5hbWUgfHwgaXRlbS50aXRsZSB8fCBpdGVtLmxhYmVsIHx8IGl0ZW0udXNlcm5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1TZWxlY3RlZFJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9pZDogcmVzdWx0Ll9pZCxcbiAgICAgICAgICAgIFtgJHt0aGlzLm1vZGVsTmFtZX1JRGBdOiByZXN1bHQuaWQsXG4gICAgICAgICAgICB0aXRsZTogcmVzdWx0LnRpdGxlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHNlYXJjaEJ5VGVybSh0ZXJtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGVybS52YWx1ZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmFwcC5nZXRNb2RlbCh0aGlzLm1vZGVsTmFtZSk7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2V0U2VhcmNoKHRlcm0udmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWxbYCQke3RoaXMuZ2V0U2VhcmNoUm91dGVOYW1lKCl9YF0oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBcIm9rXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU2VhcmNoUmVzdWx0KHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW5TZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBtb3VudChVSUdlbmVyaWNTZWxlY3Rvciwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbC4kb24oXCJ0ZXJtQ2hhbmdlXCIsIGFzeW5jICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlYXJjaEJ5VGVybShkZXRhaWwpO1xuICAgICAgICAgICAgICAgICAgICBlbC4kc2V0KHsgcmVzdWx0cyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVsLiRvbihcIm5leHRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5leHQgc2VsZWN0b3IgcmVzdWx0c1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVsLiRvbihcInByZXZcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInByZXYgc2VsZWN0b3IgcmVzdWx0c1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGVsLiRvbihcInJlamVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbC4kb24oXCJyZXNvbHZlXCIsICh7IGRldGFpbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMudHJhbnNmb3JtU2VsZWN0ZWRSZXN1bHQoZGV0YWlsKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkRGF0YShfaWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfaWQgJiYgX2lkLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLmFwcC5nZXRNb2RlbCh0aGlzLm1vZGVsTmFtZSwgeyBfaWQgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbFtcbiAgICAgICAgICAgICAgICAgICAgYCQke3RoaXMuZ2V0RGF0YUxvYWRSb3V0ZU5hbWUoKX1gXG4gICAgICAgICAgICAgICAgXSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFwib2tcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwLmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvL2ltcG9ydCAnYmFiZWwtcG9seWZpbGwvZGlzdC9wb2x5ZmlsbCc7XG5cbi8qXG4gIENvbW1vbiBmdW5jdGlvbnNcbiovXG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKlxuICBmcmFtZXdvcmsgd2lkZSBwYXJzZXIgZm9yIGRhdGEgYWNjZXNzXG4qL1xuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbmltcG9ydCBub3RSb3V0ZXIgZnJvbSBcIi4vcm91dGVyLmpzXCI7XG5cbmltcG9ydCAqIGFzIG5vdEFQSSBmcm9tIFwiLi9hcGlcIjtcbmltcG9ydCAqIGFzIG5vdFN0b3JlcyBmcm9tIFwiLi9zdG9yZXNcIjtcbi8qXG4gIGJhc2ljIGV2ZW50IGhhbmRsZXJzIGFuZCBjb3JlIGRhdGEgbW9kaWZpZXJzXG4qL1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuXG5pbXBvcnQgeyBDT01QT05FTlRTLCBGSUVMRFMsIFZBUklBTlRTIH0gZnJvbSBcIi4vTElCLmpzXCI7XG4vKlxuICBhcHBsaWNhdGlvbiBtYWluIGluZnJhc3RydWN0dXJlIHNldHRlclxuKi9cbmltcG9ydCBub3RBcHAgZnJvbSBcIi4vYXBwLmpzXCI7XG4vKlxuICB1c2VyIGNvbnRyb2xsZXJzXG4qL1xuaW1wb3J0IG5vdENvbnRyb2xsZXIgZnJvbSBcIi4vY29udHJvbGxlci5qc1wiO1xuaW1wb3J0IG5vdFJlY29yZCBmcm9tIFwiLi9yZWNvcmQuanNcIjsgLy8gIHdyYXBwZXIgZm9yIGRhdGEgd2l0aCBzZXJ2ZXIgbGl2ZSBpbnRlcmFjdGlvbnNcbmltcG9ydCBub3RJbnRlcmZhY2UgZnJvbSBcIi4vaW50ZXJmYWNlLmpzXCI7IC8vICB3cmFwcGVyIGZvciBkYXRhIHdpdGggc2VydmVyIGxpdmUgaW50ZXJhY3Rpb25zXG5cbmltcG9ydCB7XG4gICAgbm90VGFibGUsXG4gICAgVUlGb3JtLFxuICAgIG5vdEZvcm0sXG4gICAgbm90Rm9ybVNldCxcbiAgICBub3RGb3JtUnVsZXMsXG4gICAgbm90Rm9ybVV0aWxzLFxuICAgIG5vdEZvcm1IZWxwZXJzLFxuICAgIG5vdEJyZWFkY3J1bWJzLFxuICAgIG5vdFRvcE1lbnUsXG4gICAgbm90U2lkZU1lbnUsXG59IGZyb20gXCIuL2NvbXBvbmVudHNcIjtcblxuaW1wb3J0IGNyZWF0ZUNSVURBY3Rpb25VSVZpZXcgZnJvbSBcIi4vY3J1ZC9jcmVhdGUuY3J1ZC5hY3Rpb24udWkudmlldy5qc1wiO1xuaW1wb3J0IG5vdENSVUQgZnJvbSBcIi4vY3J1ZC9jb250cm9sbGVyLmNydWQuanNcIjtcbmltcG9ydCBub3RDUlVEUm91dGVyIGZyb20gXCIuL2NydWQvcm91dGVyLmpzXCI7XG5pbXBvcnQgbm90Q1JVRFJvdXRlclBsYWluIGZyb20gXCIuL2NydWQvcm91dGVyLnBsYWluLmpzXCI7XG5pbXBvcnQgbm90Q1JVRFJvdXRlclN3aXRjaCBmcm9tIFwiLi9jcnVkL3JvdXRlci5zd2l0Y2guanNcIjtcbmltcG9ydCBub3RTZXJ2aWNlTW9kZWxTZWFyY2ggZnJvbSBcIi4vY3J1ZC9zZWFyY2guc2VydmljZS5qc1wiO1xuXG5jb25zdCBuY0NSVUQgPSBub3RDUlVEOyAvL2xlZ2FjeSBhbGlhc1xuXG5leHBvcnQge1xuICAgIENPTVBPTkVOVFMsXG4gICAgRklFTERTLFxuICAgIFVJRm9ybSxcbiAgICBWQVJJQU5UUyxcbiAgICBuY0NSVUQsXG4gICAgY3JlYXRlQ1JVREFjdGlvblVJVmlldyxcbiAgICBub3RBUEksXG4gICAgbm90QXBwLFxuICAgIG5vdEJhc2UsXG4gICAgbm90QnJlYWRjcnVtYnMsXG4gICAgbm90Q1JVRCxcbiAgICBub3RDb21tb24sXG4gICAgbm90Q29udHJvbGxlcixcbiAgICBub3RGb3JtLFxuICAgIG5vdEZvcm1TZXQsXG4gICAgbm90Rm9ybVV0aWxzLFxuICAgIG5vdEZvcm1IZWxwZXJzLFxuICAgIG5vdEZvcm1SdWxlcyxcbiAgICBub3RJbnRlcmZhY2UsXG4gICAgbm90UGF0aCxcbiAgICBub3RSZWNvcmQsXG4gICAgbm90Um91dGVyLFxuICAgIG5vdENSVURSb3V0ZXIsXG4gICAgbm90Q1JVRFJvdXRlclBsYWluLFxuICAgIG5vdENSVURSb3V0ZXJTd2l0Y2gsXG4gICAgbm90U2VydmljZU1vZGVsU2VhcmNoLFxuICAgIG5vdFNpZGVNZW51LFxuICAgIG5vdFN0b3JlcyxcbiAgICBub3RUYWJsZSxcbiAgICBub3RUb3BNZW51LFxufTtcbiIsImltcG9ydCBcIi4vc2Nzcy9zdHlsZS5zY3NzXCI7XG5cbmltcG9ydCAqIGFzIHN2ZWx0ZSBmcm9tIFwic3ZlbHRlXCI7XG5cbmltcG9ydCAqIGFzIEVsZW1lbnRzIGZyb20gXCIuL2VsZW1lbnRzXCI7XG5cbmltcG9ydCAqIGFzIEZyYW1lIGZyb20gXCIuL2ZyYW1lXCI7XG5cbmltcG9ydCB7IExPQ0FMRSwgc2F5LCBub3RMb2NhbGUgfSBmcm9tIFwiLi9sb2NhbGVcIjtcblxuY29uc3QgTG9jYWxlID0geyBMT0NBTEUsIHNheSwgbm90TG9jYWxlIH07XG5jb25zdCBVSUNvbW1vbiA9IEVsZW1lbnRzLlVJQ29tbW9uO1xuXG5jb25zdCB7IG5vdENvbW1vbiwgQ09NUE9ORU5UUywgRklFTERTLCBWQVJJQU5UUywgbm90Rm9ybVV0aWxzIH0gPSBGcmFtZTtcblxuT2JqZWN0LmtleXMoRWxlbWVudHMpLmZvckVhY2goKGNvbXBvbmVudHNTZXROYW1lKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoRWxlbWVudHNbY29tcG9uZW50c1NldE5hbWVdKS5mb3JFYWNoKChjb21wb25lbnROYW1lKSA9PiB7XG4gICAgICAgIEZyYW1lLm5vdEZvcm1VdGlscy5hZGRDb21wb25lbnQoXG4gICAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgICAgRWxlbWVudHNbY29tcG9uZW50c1NldE5hbWVdW2NvbXBvbmVudE5hbWVdXG4gICAgICAgICk7XG4gICAgfSk7XG59KTtcblxuZXhwb3J0IHtcbiAgICBzdmVsdGUsXG4gICAgLy9VSVxuICAgIEVsZW1lbnRzLFxuICAgIFVJQ29tbW9uLFxuICAgIC8vYXBwbGljYXRpb24gZnJhbWV3b3JrXG4gICAgRnJhbWUsXG4gICAgLy9zaG9ydHMgZm9yIGNvbW1vbiBlbGVtZW50c1xuICAgIG5vdENvbW1vbixcbiAgICBub3RGb3JtVXRpbHMsXG4gICAgQ09NUE9ORU5UUyxcbiAgICBGSUVMRFMsXG4gICAgVkFSSUFOVFMsXG4gICAgLy9sb2NhbGl6YXRpb25cbiAgICBMb2NhbGUsXG4gICAgTE9DQUxFLFxuICAgIHNheSxcbiAgICBub3RMb2NhbGUsXG59O1xuIl0sIm5hbWVzIjpbInJ1biIsImJvbGQiLCJub3JtYWwiLCJ3LnN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlIiwiZ2V0IiwiZS5zdGF0ZV91bnNhZmVfbXV0YXRpb24iLCJ3Lmh5ZHJhdGlvbl9taXNtYXRjaCIsIncub3duZXJzaGlwX2ludmFsaWRfYmluZGluZyIsIncub3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24iLCJlLnN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkIiwiZS5zdGF0ZV9wcm90b3R5cGVfZml4ZWQiLCJ3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoIiwiZS5kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZiIsImUuZWZmZWN0X29ycGhhbiIsImUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCIsImUuZWZmZWN0X2luX3RlYXJkb3duIiwiaXNfbWljcm9fdGFza19xdWV1ZWQiLCJlLmVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQiLCJlLnN0YXRlX3Vuc2FmZV9sb2NhbF9yZWFkIiwiZS5ydW5lX291dHNpZGVfc3ZlbHRlIiwiZS5oeWRyYXRpb25fZmFpbGVkIiwidy5saWZlY3ljbGVfZG91YmxlX3VubW91bnQiLCJpbmRleCIsIncuaHlkcmF0aW9uX2h0bWxfY2hhbmdlZCIsImUuaW52YWxpZF9zbmlwcGV0Iiwidy5pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlciIsImNsc3giLCJfY2xzeCIsIncuaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkIiwibGluZWFyIiwiZS5iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUiLCJlLnByb3BzX3Jlc3RfcmVhZG9ubHkiLCJlLnByb3BzX2ludmFsaWRfdmFsdWUiLCJlLmxpZmVjeWNsZV9sZWdhY3lfb25seSIsImlucHV0VmFsdWVzRXh0cmFjdG9ycyIsIk9iamVjdCIsImZyZWV6ZSIsImNoZWNrYm94IiwiaW5wRWwiLCJkZWZhdWx0VmFsdWUiLCJ1bmRlZmluZWQiLCJoYXNPd24iLCJjaGVja2VkIiwidW5jaGVja2VkIiwidmFsdWUiLCJVSUNvbW1vbiIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsImV4dHJhY3RWYWx1ZUZyb21JbnB1dCIsInR5cGUiLCJvbklucHV0IiwiZmllbGQiLCJvbmNoYW5nZSIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsImlzRW50ZXJFdmVudCIsImUiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJvbmx5T25FbnRlciIsImNhbGxiYWNrIiwiaXNNb2JpbGUiLCJ0ZXN0TW9iaWxlIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIm1zTWF0Y2hNZWRpYSIsInRlc3RRdWVyeSIsImFyZ3VtZW50cyIsImxlbmd0aCIsIm1heF93aWR0aCIsIk1PQklMRV9XSURUSF9CUkVBS19QT0lOVCIsIm1hdGNoZXMiLCJyZW1vdmVCb2R5U2Nyb2xsIiwiZG9jdW1lbnQiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiU0NST0xMX0RJU0FCTEVSX0NMQVNTIiwicmVzdG9yZUJvZHlTY3JvbGwiLCJyZW1vdmUiLCJmb3JtYXRQaG9uZSIsInZhbCIsImZpbGxlciIsIkZJTExFUiIsInNsb3RzIiwiZGlnaXRzIiwicmVwbGFjZSIsImQiLCJ1bnNoaWZ0Iiwic3RhY2siLCJBcnJheSIsImZyb20iLCJmb3JFYWNoIiwiZGlnaXQiLCJzbG90IiwibGVucyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJ0IiwiZGlmIiwicGFyc2VJbnQiLCJzZXRNb25leVNpZ24iLCJNT05FWV9TSUdOIiwiZm9ybWF0UHJpY2UiLCJwcmljZSIsIm1ham9yIiwiTWF0aCIsImZsb29yIiwibWlub3IiLCJ0b1N0cmluZyIsImZvcm1hdExvY2FsZURhdGV0aW1lIiwiZHQiLCJvcHRzIiwiZGF0ZSIsInRpbWUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsInRvTG9jYWxlVGltZVN0cmluZyIsInRyeUZvcm1hdExvY2FsZURhdGVUaW1lIiwiRGF0ZSIsImZvcm1hdFRpbWVzdGFtcCIsInRpbWVzdGFtcCIsIm9mZnNldCIsIm9mZnNldExvY2FsIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJkZWx0YU9mZnNldCIsImxvY2FsRGF0ZVRpbWUiLCJ0b0xvY2FsZVN0cmluZyIsImRlY2xPZk51bSIsIm4iLCJ0ZXh0X2Zvcm1zIiwiYWJzIiwibjEiLCJodW1hbml6ZWRUaW1lRGlmZiIsImN1cnJlbnRUaW1lIiwiZ2V0VGltZSIsInNlYyIsInJvdW5kIiwidW5pdCIsIlRJTUUiLCJTRUNPTkRTIiwibWluIiwiTUlOVVRFUyIsImhvdXJzIiwiSE9VUlMiLCJzdHlsZXNPYmplY3RUb1N0cmluZyIsInN0eWxlcyIsImtleXMiLCJtYXAiLCJwcm9wIiwiam9pbiIsIl9kZWZpbmVQcm9wZXJ0eSIsInRvcCIsImJlaGF2aW9yIiwiJC51c2VyX2VmZmVjdCIsIiQuc2V0IiwiaW5pdERpY3QiLCJ0YXJnZXQiLCJoYW5kbGVyIiwiUmVmbGVjdCIsIlByb3h5IiwiY3JlYXRlTG9jYWxlIiwic3Vic2NyaWJlIiwic2V0IiwidXBkYXRlIiwid3JpdGFibGUiLCJyZXNldCIsIkxPQ0FMRSIsInRoaXMiLCJzcmMiLCJub3RQYXRoIiwicmVxdWlyZSQkMCIsImlzTWVyZ2VhYmxlT2JqZWN0IiwiaXNOb25OdWxsT2JqZWN0IiwiaXNTcGVjaWFsIiwic3RyaW5nVmFsdWUiLCJwcm90b3R5cGUiLCJjYWxsIiwiaXNSZWFjdEVsZW1lbnQiLCJjYW5Vc2VTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCIkJHR5cGVvZiIsImVtcHR5VGFyZ2V0IiwiaXNBcnJheSIsImNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIiwib3B0aW9uc0FyZ3VtZW50IiwiY2xvbmUiLCJkZWVwbWVyZ2UiLCJkZWZhdWx0QXJyYXlNZXJnZSIsInNvdXJjZSIsImNvbmNhdCIsImVsZW1lbnQiLCJtZXJnZU9iamVjdCIsImRlc3RpbmF0aW9uIiwic291cmNlSXNBcnJheSIsInRhcmdldElzQXJyYXkiLCJvcHRpb25zIiwiYXJyYXlNZXJnZSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJhbGwiLCJkZWVwbWVyZ2VBbGwiLCJhcnJheSIsIkVycm9yIiwicHJldiIsIm5leHQiLCJub3RDb21tb24iLCJpc0Vycm9yIiwic3RhdHVzIiwibXV0ZSIsIkVOVl9UWVBFIiwicGFkIiwiZ2V0VG9kYXlEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJvYmpIYXMiLCJvYmoiLCJuYW1lIiwiY29weU9iaiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInBhcnRDb3B5T2JqIiwibGlzdCIsInBhcnRPYmoiLCJpbmNsdWRlcyIsImNvbXBhcmVUd29BcnJheXMiLCJhIiwiYiIsImV2ZXJ5IiwiaXNGdW5jIiwiZnVuYyIsImlzQXN5bmMiLCJjb25zdHJ1Y3RvciIsImV4ZWN1dGVPYmplY3RGdW5jdGlvbiIsInBhcmFtcyIsInByb2MiLCJtYXBCaW5kIiwidG8iLCJpdGVtIiwiYmluZCIsImlzQ2xhc3MiLCJmbiIsInRlc3QiLCJkZXRlY3RUeXBlIiwidGVzdGllIiwiZGF0YSIsImxvY2FsSXNvRGF0ZSIsImxvY2FsSXNvU3RyaW5nIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldFRvZGF5IiwidG9kYXkiLCJiYWNrbG9nQWRkIiwibXNnIiwiYmFja2xvZyIsInB1c2giLCJkdW1wQmFja2xvZyIsInJvdyIsInNoaWZ0IiwiTE9HIiwibG9nTXNnIiwibm93IiwibG9nIiwiY3JlYXRlTG9nZ2VyIiwicHJlZml4IiwiZ2VuTG9nTXNnIiwiZXJyb3IiLCJnZW5Mb2dFcnJvciIsImRlYnVnIiwiZ2VuTG9nRGVidWciLCJyZXBvcnQiLCJpc0RldiIsIkRFVl9FTlYiLCJOT09QIiwibG9nRXJyb3IiLCJnZXRBcHAiLCJyZXBvcnRlciIsImdldFNlcnZpY2UiLCJjYXRjaCIsInRyYWNlIiwidHJpbUJhY2tzbGFzaCIsInN0ciIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJidWlsZFVSTCIsIm1vZHVsZSIsIm1vZGVsIiwiaWQiLCJhY3Rpb24iLCJ1cmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJmaWx0ZXIiLCJlbCIsImNhcGl0YWxpemVGaXJzdExldHRlciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJsb3dlckZpcnN0TGV0dGVyIiwic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJzdHJMZW5ndGhDYXAiLCJNQVhfVElUTEVfTEVOR1RIIiwiUE9TVF9GSVgiLCJzdWJzdHIiLCJlc2NhcGVIdG1sIiwidW5zYWZlIiwic3RhcnRBcHAiLCJzdGFydGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV4dGVuZEFwcENvbmZpZyIsImNvbmYiLCJjb25mMiIsImRlZXBNZXJnZSIsImFic29yYk1vZHVsZSIsImRlZmF1bHRDb25mIiwibW9kIiwidGFyZ2V0cyIsImhhc093blByb3BlcnR5Iiwic2VydmljZXMiLCJ1aXMiLCJ3Y3MiLCJtYW5pZmVzdCIsImNvbnRyb2xsZXJzIiwibm90RW52IiwiZGVmaW5lSWZOb3RFeGlzdHMiLCJyZWdpc3RlciIsInJlZ2lzdHJ5IiwibW92ZUl0ZW0iLCJvbGRfaW5kZXgiLCJuZXdfaW5kZXgiLCJpblJhbmdlIiwibnVtIiwic3BsaWNlIiwic3RyaXBQcm94eSIsImlzUHJveHkiLCJhc3NpZ24iLCJwaXBlIiwiZnVuY3MiLCJyZXN1bHQiLCJnZXRBUEkiLCJnZXRNYW5hZ2VyIiwic2V0TWFuYWdlciIsInYiLCJNQU5BR0VSIiwiZ2V0SlNPTiIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsIndhaXQiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCIsInJlZ2lzdGVyV2lkZ2V0RXZlbnRzIiwiZXZlbnRzIiwiZXZlbnROYW1lIiwib24iLCJuYXZpZ2F0ZSIsImdldFdvcmtpbmciLCJzZWxlY3QiLCJ2YXJpYW50c1NldCIsImRlZiIsIl9ub3RDb21tb24iLCJOT1RfRU5WX1RZUEUiLCJhYnNvcmJTZXJ2aWNlcyIsInNlcnYiLCJleHRlbmRXU0NsaWVudCIsIndzY05hbWUiLCJ3c2NPcHRpb25zIiwiY29ubmVjdGlvbiIsInJvdXRlciIsInJvdXRlcyIsIm1lc3NlbmdlciIsInJvdXRlVHlwZSIsImFic29yYldTQyIsIndzQ2xpZW50TmFtZSIsImFic29yYlVJcyIsInVpIiwiYWJzb3JiRmllbGRzIiwibm90TG9jYWxlIiwiX0V2ZW50RW1pdHRlciIsIl90aGlzIiwiX2NhbGxTdXBlciIsImRpY3QiLCJoZWxwZXJzIiwicmVzdG9yZUZyb21TdG9yYWdlIiwiX2luaGVyaXRzIiwiZm9ybWF0IiwicGFyc2VTdWJzIiwic2F5IiwicGhyYXNlIiwidG1wbCIsInNhdmVUb1N0b3JhZ2UiLCJlbWl0IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImdldEl0ZW0iLCJ2b2NhYnVsYXJ5IiwiRXZlbnRFbWl0dGVyIiwiJC5wcm9wIiwiJC5wcm94eSIsIiQuc2V0X3RleHQiLCIkLmRlcml2ZWQiLCJVSUJvb2xlYW4iLCIkLnN0YXRlIiwiJC5lYWNoIiwiJC5nZXQiLCIkLmJpbmRfdGhpcyIsIiQuc2V0X2NsYXNzIiwiJC5yZXN0X3Byb3BzIiwiJC50ZW1wbGF0ZV9lZmZlY3QiLCJvbkNsaWNrIiwiVUlCdXR0b24iLCJVSUJ1dHRvblN3aXRjaCIsIkRFRkFVTFRfU1RBVFVTX1NVQ0NFU1MiLCJOQVZJR0FUSU9OX0RFTEFZX1NIT1JUIiwiTkFWSUdBVElPTl9ERUxBWV9OT1JNQUwiLCJOQVZJR0FUSU9OX0RFTEFZX0xPTkciLCJOQVZJR0FUSU9OX0RFTEFZUyIsIlNIT1JUIiwiTk9STUFMIiwiTE9ORyIsIk5BVklHQVRJT05fREVMQVlfREVGQVVMVCIsInN0YXRlIiwiJC5zcHJlYWRfcHJvcHMiLCJVSUJ1dHRvbnMiLCJ0ZXh0IiwiJC5zZXRfYXR0cmlidXRlIiwiJC50b2dnbGVfY2xhc3MiLCJVSUltYWdlIiwiJC5tdXRhYmxlX3N0YXRlIiwiJC5tdXRhdGUiLCIkLmV2ZW50IiwiJC53aW5kb3ciLCIkLmFuaW1hdGlvbiIsIiQudHJhbnNpdGlvbiIsIiQuaHRtbCIsIiQuYmluZF92YWx1ZSIsIkxpYiIsInNlZWRMaWIiLCJfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyIsIl9saWIiLCJpbXBvcnQiLCJnZXRDb250ZW50IiwiY29tcCIsIm1vZGUiLCJjb250YWlucyIsIl9jbGFzc1ByaXZhdGVGaWVsZEdldCIsImJ1bGsiLCJmIiwiaXNFbXB0eSIsIkNPTVBPTkVOVFMiLCJGSUVMRFMiLCJWQVJJQU5UUyIsIlVJTGluayIsIlVJVGl0bGUiLCJVSUxpc3RJdGVtIiwiVUlMaXN0RW1wdHlQbGFjZWhvbGRlciIsIlVJTGlzdCIsIlVJRW5kbGVzc0xpc3RTaW1wbGVJdGVtIiwiVUlFbmRsZXNzTGlzdEVtcHR5UGxhY2Vob2xkZXIiLCJVSUVuZGxlc3NMaXN0TmF2aWdhdGlvbiIsIlVJQnV0dG9uc1N3aXRjaGVycyIsIlVJQnV0dG9uQ2xvc2UiLCJVSVNpbXBsZVNlYXJjaElucHV0IiwiVUlFbmRsZXNzTGlzdCIsIk1FVEFfTUVUSE9EX0lOSVQiLCJNRVRBX0RBVEEiLCJNRVRBX1dPUktJTkciLCJNRVRBX09QVElPTlMiLCJub3RCYXNlIiwiaW5wdXQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNldERhdGEiLCJzZXRXb3JraW5nIiwid29ya2luZyIsInNldE9wdGlvbnMiLCJpbmZvIiwic2V0Q29tbW9uIiwid2hhdCIsImFyZ3MiLCJnZXRDb21tb24iLCJnZXREYXRhIiwiZ2V0T3B0aW9ucyIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudCIsIk9QVF9NT0RFX0hJU1RPUlkiLCJPUFRfTU9ERV9IQVNIIiwiT1BUX0RFRkFVTFRfQ0hFQ0tfSU5URVJWQUwiLCJub3RSb3V0ZXIiLCJfbm90QmFzZSIsInJvb3QiLCJpbml0aWFsaXplZCIsImRlbGF5cyIsImRlbGF5X2RlZmF1bHQiLCJzZXREZWxheXMiLCJzZXREZWZhdWx0TmF2aWdhdGlvbkRlbGF5IiwiZGVsYXkiLCJkZWxheUFzTXMiLCJnZXREZWZhdWx0TmF2aWdhdGlvbkRlbGF5IiwibmF2aWdhdGVXaXRoRGVsYXkiLCJkb0JlZm9yZSIsIl90aGlzMiIsImhpc3RvcnkiLCJoYXNoIiwic2V0Um9vdCIsImNsZWFyU2xhc2hlcyIsInBhdGgiLCJyZSIsInJ1bGUiLCJhZGRMaXN0IiwicGFyYW0iLCJpIiwiciIsImZsdXNoIiwiaXNJbml0aWFsaXplZCIsInNldEluaXRpYWxpemVkIiwiZ2V0RnJhZ21lbnQiLCJmcmFnbWVudCIsImxvY2F0aW9uIiwiZGVjb2RlVVJJIiwicGF0aG5hbWUiLCJzZWFyY2giLCJtYXRjaCIsImhyZWYiLCJjaGVja0xvY2F0aW9uIiwiY3VycmVudCIsImluaXQiLCJjaGVjayIsImhyZWZDbGljayIsImdldFJvb3QiLCJsaXN0ZW4iLCJsb29wSW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJmYWlsQmFjayIsImZ1bGxSRSIsInJvdXRlIiwiYXBwbHkiLCJob3N0IiwicmVmcmVzaCIsInRpbWVvdXQiLCJfdGhpczMiLCJuZXdSb3V0ZSIsImdldEZ1bGxSb3V0ZSIsImxhc3RSb3V0ZSIsInB1c2hTdGF0ZSIsImdldEFsbExpbmtzIiwiYWxsRWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaiIsImF0dHMiLCJhdHRyaWJ1dGVzIiwibm9kZU5hbWUiLCJyZVJvdXRlRXhpc3RlZCIsImluaXRSZXJvdXRpbmciLCJnZXRBdHRyaWJ1dGUiLCJsaW5rIiwiX3RoaXM0Iiwibm90Um91dGVySW5pdGlhbGl6ZWQiLCJmdWxsTGluayIsInNldEF0dHJpYnV0ZSIsInByZXZlbnREZWZhdWx0IiwiTE9HX1BSRUZJWCIsIm5vdEFQSVF1ZXVlIiwiYnVzeSIsInF1ZXVlIiwiYnVzeVNpbmNlIiwiYWZ0ZXJFbXB0eSIsInN0YXJ0Iiwic3RvcCIsImludGVydmFsIiwiY2hlY2tRdWV1ZSIsIlFVRVVFX0NIRUNLX0lOVEVSVkFMIiwiaXNCdXN5Iiwic2V0QnVzeSIsInJ1bk5leHQiLCJzZXRGcmVlIiwiYWRkVG9RdWV1ZSIsInRhc2siLCJ0aXRsZSIsInJlc29sdmUiLCJNQVhfQlVTWV9USU1FIiwicmVqZWN0IiwiYWN0aW9uSXNRdWV1ZWQiLCJzb21lIiwicXVldWVkIiwicnVuSWZOb3RRdWV1ZWQiLCJub3RBUElPcHRpb25zIiwicnBzIiwicHJvdG9jb2wiLCJwb3J0Iiwibm90QVBJQ29ubmVjdGlvbiIsIm9ubGluZSIsImludCIsInBhdXNlIiwicmVzdW1lIiwiaXNPbmxpbmUiLCJvbkxpbmUiLCJjaGFuZ2VTdGF0ZSIsIkFMTCIsImV4aXN0IiwiY3JlYXRlIiwicHJvcHMiLCJyYXciLCJmaWx0ZXJlZCIsInNlbGVjdGVkIiwiZmFrZSIsIk1FVEFfSU5URVJGQUNFIiwiTUVUQV9NQVBfVE9fSU5URVJGQUNFIiwiREVGQVVMVF9BQ1RJT05fUFJFRklYIiwiT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSIsIkRFRkFVTFRfRklMVEVSIiwiREVGQVVMVF9TRUFSQ0giLCJERUZBVUxUX1JFVFVSTiIsIkRFRkFVTFRfUEFHRV9OVU1CRVIiLCJERUZBVUxUX1BBR0VfU0laRSIsIkRFRkFVTFRfV1NfUk9VVEVfQUNUSU9OX1NQTElUVEVSIiwibm90SW50ZXJmYWNlIiwicmV0dXJuIiwicGFnZXIiLCJzaXplIiwicGFnZSIsImluaXRBY3Rpb25zIiwiZ2V0QWN0aW9uc0NvdW50IiwiYWN0aW9ucyIsImdldEFjdGlvbnMiLCJhY3Rpb25OYW1lIiwiaW5pdEFjdGlvbiIsImhlYWRlcnMiLCJmaWxlVXBsb2FkIiwiZmlsZXMiLCJyZXF1ZXN0IiwicmVxdWVzdEhUVFAiLCJyZWNvcmQiLCJjb21wb3NpdGVEYXRhIiwiYWN0aW9uRGF0YSIsImdldEFjdGlvbkRhdGEiLCJyZXF1ZXN0UGFyYW1zIiwiY29sbGVjdFJlcXVlc3REYXRhIiwicmVxdWVzdFBhcmFtc0VuY29kZWQiLCJlbmNvZGVSZXF1ZXN0IiwiYXBpU2VydmVyVVJMIiwiZ2V0U2VydmVyVVJMIiwiZ2V0VVJMIiwiZmQiLCJGb3JtRGF0YSIsImFwcGVuZCIsIm1ldGhvZCIsIkFjY2VwdCIsInJlcXVlc3RXUyIsIldTIiwiZ2V0V1NDbGllbnQiLCJtZXNzYWdlTmFtZSIsImdldFdTUmVxdWVzdE5hbWUiLCJwYXlsb2FkIiwibWVzc2FnZSIsInNlbGVjdFRyYW5zcG9ydCIsIndzSXNVcCIsIndzIiwiY2xpZW50Iiwid3NDbGllbnQiLCJnZXRNb2RlbE5hbWUiLCJwYXJzZVBhcmFtcyIsImVuZCIsImxpbmUiLCJmaWVsZE5hbWUiLCJsZW4iLCJpbmQiLCJzdGFydFNsaWNlIiwiZW5kU2xpY2UiLCJwYXJzZUxpbmUiLCJwb3N0Rml4IiwibW9kZWxOYW1lIiwicCIsInJlcXVlc3REYXRhIiwiZGF0YVByb3ZpZGVyTmFtZSIsImdldElEIiwicmVzdWx0SWQiLCJwcmVmaXhlcyIsInByZSIsInNldEZpbmRCeSIsInNldEZpbHRlciIsImZpbHRlckRhdGEiLCJyZXNldEZpbHRlciIsImdldEZpbHRlciIsInNldFNlYXJjaCIsInNlYXJjaERhdGEiLCJyZXNldFNlYXJjaCIsImdldFNlYXJjaCIsInNldFNvcnRlciIsInNvcnRlckRhdGEiLCJyZXNldFNvcnRlciIsImdldFNvcnRlciIsInNldFJldHVybiIsInJldHVybkRhdGEiLCJyZXNldFJldHVybiIsImdldFJldHVybiIsInNldFBhZ2VOdW1iZXIiLCJwYWdlTnVtYmVyIiwic2V0UGFnZVNpemUiLCJwYWdlU2l6ZSIsInNldFBhZ2VyIiwiaXNOYU4iLCJyZXNldFBhZ2VyIiwiZ2V0UGFnZXIiLCJnZXRSZWNvcmQiLCJnZXREZWZhdWx0QXNQbGFpbk9iamVjdCIsImZpZWxkcyIsImRlZmF1bHQiLCJub3RSZWNvcmQiLCJpc1JlY29yZCIsImlzUHJvcGVydHkiLCJjcmVhdGVDb2xsZWN0aW9uIiwiaW50ZXJmYWNlVXAiLCJtYXBUb0ludGVyZmFjZSIsIm1hcFRvTWV0aG9kcyIsInRvRGVmYXVsdCIsInJlYyIsImFwcCIsIm1ldGhvZHMiLCJpdGVtcyIsImNvbGxlY3Rpb24iLCJhY3Rpb25VcCIsInNldEF0dHIiLCJzZXRBdHRycyIsIm9iamVjdFBhcnQiLCJnZXRBdHRyIiwicGxhaW4iLCJwcngiLCJnZXRBdHRycyIsImdldE1hbmlmZXN0IiwiT1BUX0NPTlRST0xMRVJfUFJFRklYIiwiT1BUX1JFQ09SRF9QUkVGSVgiLCJERUZBVUxUX1dTX0NMSUVOVF9OQU1FIiwibm90QXBwIiwiaW50ZXJmYWNlcyIsImluaXRDb250cm9sbGVyIiwiY3VycmVudENvbnRyb2xsZXIiLCJ3c2MiLCJ3c3MiLCJpbml0TWFuaWZlc3QiLCJzZXRJbnRlcmZhY2VNYW5pZmVzdCIsImluaXRSb3V0ZXIiLCJleGVjUm91dGVyIiwicm91dGllSW5wdXQiLCJyb3V0ZUJsb2NrIiwicGF0aHMiLCJzY2hlbWVzIiwiY29udHJvbGxlciIsInBhdGhTY2hlbWUiLCJiaW5kQ29udHJvbGxlciIsImdldEludGVyZmFjZU1hbmlmZXN0IiwidXBkYXRlSW50ZXJmYWNlcyIsImluaXRTZXJ2aWNlcyIsImNvbnRyb2xsZXJOYW1lIiwiY29udHJvbGxlclBhdGhTY2hlbWUiLCJnZXRDdXJyZW50Q29udHJvbGxlciIsInNldEN1cnJlbnRDb250cm9sbGVyIiwiY3RybCIsIm9sZEN0cmwiLCJjcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkiLCJyZWNvcmRNYW5pZmVzdCIsInJlY29yZERhdGEiLCJjbGVhckludGVyZmFjZXMiLCJtYW5pZmVzdHMiLCJyZWNvcmRNZXRob2RzIiwibmFtZUludCIsInNldEludGVyZmFjZSIsImdldFJlY29yZE5hbWUiLCJnZXRDb250cm9sbGVyTmFtZSIsIm1vZGVsRmFjdG9yeSIsImdldEludGVyZmFjZXMiLCJzZXRXU0NsaWVudCIsImdldEludGVyZmFjZSIsImdldE1vZGVsIiwic2V0U2VydmljZSIsInNlcnZOYW1lIiwic2VydlR5cGUiLCJnZXRDb25maWdSZWFkZXJGb3JNb2R1bGUiLCJtb2R1bGVOYW1lIiwibW9kQ29uZlBhdGgiLCJzdWJQYXRoIiwiZmFsbGJhY2siLCJtb2R1bGVDb25maWciLCJPUFRfREVGQVVMVF9BQ1RJT05fTkFNRSIsIk9QVF9ERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUiIsIk9QVF9ERUZBVUxUX1BMVVJBTF9OQU1FIiwiT1BUX0RFRkFVTFRfU0lOR0xFX05BTUUiLCJPUFRfREVGQVVMVF9NT0RVTEVfTkFNRSIsIk9QVF9ERUZBVUxUX0FVVE9fTkFNRSIsIm5vdENvbnRyb2xsZXIiLCJyZWFkeSIsInZpZXdzIiwibGlicyIsImVscyIsImNvbnRhaW5lclNlbGVjdG9yIiwibmFtZXMiLCJwbHVyYWwiLCJzaW5nbGUiLCJzZXRVUkxQcmVmaXgiLCJtYWtlIiwidWlOYW1lIiwiJGRlc3Ryb3kiLCJzZXRNb2RlbCIsInNldE1vZGVsTmFtZSIsImdldE1vZGVsSURGaWVsZE5hbWUiLCJzZXRNb2RlbElERmllbGROYW1lIiwic2V0UmVhZHkiLCJ1cGRhdGVBdXRvTmFtZSIsImdldFVSTFByZWZpeCIsInNldE1vZHVsZU5hbWUiLCJnZXRNb2R1bGVOYW1lIiwiZ2V0TW9kdWxlUHJlZml4IiwiZ2V0TW9kZWxVUkwiLCJnZXRNb2RlbEFjdGlvblVSTCIsInNldE5hbWUiLCJnZXROYW1lIiwicHJlbG9hZExpYiIsIiRsaXN0QWxsIiwiZXJyIiwib25BZnRlclJlbmRlciIsImdldEFjdGlvbk5hbWUiLCJnZXREZWZhdWx0QWN0aW9uTmFtZSIsInJvdXRlck5hbWUiLCJzdWJQYXJhbXMiLCJzZXRDdXJyZW50QWN0aW9uIiwiZ2V0Q3VycmVudEFjdGlvbiIsImdldEFwcE9wdGlvbnMiLCJnZXRNb2R1bGVPcHRpb25zIiwiZ2V0U2VydmljZXMiLCJnZXRDb21wb25lbnRzIiwiZ2V0Um91dGVyIiwibmF2aWdhdGVBY3Rpb24iLCJuYXZpZ2F0ZU1vZHVsZUFjdGlvbiIsIm5hdmlnYXRlTW9kZWxBY3Rpb24iLCJnZXRDb250cm9sbGVyUm91dGUiLCJwYXJhbXNDb3VudCIsIk1PRFVMRV9OQU1FIiwiTU9ERUxfTkFNRSIsImdldENvbnRyb2xsZXJSb3V0ZXMiLCJwYXJhbXNEZWVwIiwiZ2V0Um91dGVzIiwiUEFSQU1TX0xFTkdUSCIsImdldENvbW1vbk1lbnUiLCJjaGlsZENvbnN0cnVjdG9yIiwic2VjdGlvbiIsIkxBQkVMUyIsImdldE1lbnUiLCIkLmNsc3giLCJTdG9yZXMuZ2V0IiwiJC5iaW5kX2NoZWNrZWQiLCIkLnN0b3JlX211dGF0ZSIsIiQudW50cmFjayIsIkNPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYIiwiT1BUX0RFRkFVTFRfUEFHRV9TSVpFIiwiT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVIiLCJPUFRfREVGQVVMVF9QQUdFX1JBTkdFIiwiT1BUX0RFRkFVTFRfU09SVF9ESVJFQ1RJT04iLCJPUFRfREVGQVVMVF9TRUFSQ0giLCJPUFRfREVGQVVMVF9SRVRVUk4iLCJPUFRfREVGQVVMVF9DT01CSU5FRCIsIk9QVF9ERUZBVUxUX0NPTUJJTkVEX0FDVElPTiIsIk9QVF9ERUZBVUxUX0NPVU5UX0FDVElPTiIsIk9QVF9ERUZBVUxUX0xJU1RfQUNUSU9OIiwiT1BUX0RFRkFVTFRfU09SVF9GSUVMRCIsIk9QVF9GSUVMRF9OQU1FX1BSRV9QUk9DIiwiREVGQVVMVF9PUFRJT05TIiwiVUlUYWJsZSIsImxpbmtzIiwiZW5kbGVzcyIsImlkRmllbGQiLCJnZXRJdGVtSWQiLCJfaWQiLCJub3RUYWJsZSIsInJhbmRvbSIsInJlZmluZWQiLCJwYWdpbmF0aW9uIiwiY291bnQiLCJwYWdlcyIsInN0b3JlcyIsIlN0b3JlcyIsIm9uV29ya2luZ1VwZGF0ZSIsIm9uUmF3VXBkYXRlIiwib25GaWx0ZXJlZFVwZGF0ZSIsIm9uUmVmaW5lZFVwZGF0ZSIsIm9uU2VsZWN0ZWRVcGRhdGUiLCJvblN0YXRlVXBkYXRlIiwic2V0Q29tYmluZWRBY3Rpb25OYW1lIiwic29ydGVyIiwicmVuZGVyIiwidXBkYXRlRGF0YSIsInJlZmluZUZpbHRlcmVkIiwiY2xlYXJTZWxlY3RlZCIsIm9uU2VhcmNoQ2hhbmdlIiwib25Tb3J0ZXJDaGFuZ2UiLCJvbkZpbHRlckNoYW5nZSIsImdldFNlbGVjdGVkIiwib2JqZWN0Iiwic3RvcmUiLCJpbmR4IiwiZmluZEluZGV4Iiwic2VsZWN0QWxsIiwic2VsZWN0Tm9uZSIsInRhYmxlIiwidGFyZ2V0RWwiLCJmaWx0ZXJVSSIsImdldEhlbHBlcnMiLCJnZXRMaW5rcyIsInNob3dTZWxlY3QiLCJzaG93U2VhcmNoIiwic2hvd1NvcnQiLCIkb24iLCJkZXRhaWwiLCJnb1RvUGFnZSIsImdvVG9OZXh0IiwiZ29Ub1ByZXYiLCJfdGhpczUiLCJzZXRTdGF0ZSIsIl90aGlzNiIsImdldFN0YXRlIiwid2l0aG91dEludmFsaWRhdGlvbiIsImludmFsaWRhdGVEYXRhIiwiZ2V0RGVmYXVsdFBhZ2VOdW1iZXIiLCJnZXREZWZhdWx0UGFnZVNpemUiLCJnZXRTb3J0ZXJEaXJlY3Rpb24iLCJyZXQiLCJjbGVhckZpbHRlcmVkRGF0YSIsImNsZWFyUmF3RGF0YSIsImNsZWFyUmVmaW5lZERhdGEiLCJpc0xpdmUiLCJzZXRVcGRhdGluZyIsInNldFVwZGF0ZWQiLCJpZlVwZGF0aW5nIiwiZ2V0RGF0YUludGVyZmFjZSIsImZhY3RvcnkiLCJnZXRMb2FkRGF0YUFjdGlvbk5hbWUiLCJnZXRDb21iaW5lZEFjdGlvbk5hbWUiLCJnZXRDb3VudEFjdGlvbk5hbWUiLCJsb2FkRGF0YSIsInF1ZXJ5IiwibWF4IiwiZ29Ub0ZpcnN0IiwiZ29Ub0xhc3QiLCJ0ZXN0RGF0YUl0ZW0iLCJzdHJWYWx1ZSIsImsiLCJ0b0NvbXAiLCJnZXRSb3dzQ291bnQiLCJfdGhpczciLCJ1cGRhdGVQYWdpbmF0aW9uIiwiaXRlbXNDb3VudCIsIl90aGlzOCIsIml0ZW1zRnJvbSIsInBhZ2VzQ291bnQiLCJwYWdlc0Zyb20iLCJwYWdlc1RvIiwiaXRlbXNUbyIsImFjdGl2ZSIsIl90aGlzOSIsImZ1bGwiLCJwcm9jZXNzRGF0YSIsIl90aGlzMTAiLCJ0aGF0RmlsdGVyIiwiZmlsdGVyU2VhcmNoIiwidGhhdFNvcnRlciIsInNvcnQiLCJpdGVtMSIsIml0ZW0yIiwidDEiLCJzb3J0QnlGaWVsZCIsInQyIiwibG9jYWxlQ29tcGFyZSIsInNvcnREaXJlY3Rpb24iLCJsb2dnZXIiLCJjaGVja0ZpZWxkc05hbWVzIiwiZmllbGRJZCIsInBhdGhJZCIsInJlYWRGaWVsZFZhbHVlIiwiX3RoaXMxMSIsInByZXByb2Nlc3NlZCIsIkRFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SIiwiX3VpQ29tcG9uZW50IiwiV2Vha01hcCIsIl91aSIsIm5vdEFjdGlvblVJIiwiVUlBY3Rpb25Db250YWluZXIiLCJfY2xhc3NQcml2YXRlRmllbGRTZXQiLCJpbml0VUkiLCJnZXRUYXJnZXRFbCIsImNoaWxkcmVuIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwic2V0TG9hZGluZyIsInJlc2V0TG9hZGluZyIsInByb2Nlc3NSZXN1bHQiLCJzZXRGb3JtU3VjY2VzcyIsInNldEZvcm1FcnJvcnMiLCJzaG93U3VjY2VzcyIsImZvcm0iLCJlcnJvcnMiLCJzaG93RXJyb3IiLCJIVE1MRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJub3RGb3JtVXRpbHMiLCJhZGRDb21wb25lbnQiLCJhZGRWYXJpYW50cyIsImFkZEZpZWxkIiwiYWN0aW9uRmllbGRzSW5pdCIsInN1YkZpZWxkTmFtZSIsIkRFRkFVTFRfRklFTEQiLCJsYWJlbCIsInBsYWNlaG9sZGVyIiwiZW5hYmxlZCIsInZpc2libGUiLCJyZXF1aXJlZCIsInZhbGlkYXRlZCIsInZhbGlkIiwiZmllbGRJbml0IiwibXV0YXRpb24iLCJ2YXJpYW50c1NvdXJjZSIsInZhcmlhbnRzIiwiaW5pdEZvcm1CeUZpZWxkIiwiZm9ybUZpZWxkc09wdGlvbnMiLCJzdWJGb3JtRmllbGROYW1lIiwibXV0YXRpb25zIiwicmVhZG9ubHkiLCJzZXRGaWVsZEludmFsaWQiLCJzZXRGaWVsZFZhbGlkIiwiZm5hbWUiLCJpc0ZpZWxkVmFsaWQiLCJzZXRGb3JtRmllbGRJbnZhbGlkIiwiZm9ybUVycm9ycyIsImlucHV0U3RhcnRlZCIsImZvcm1MZXZlbEVycm9yIiwic2V0Rm9ybUZpZWxkVmFsaWQiLCJ1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyIsInZhbGlkYXRpb25TdGF0dXMiLCJzZXRGaWVsZHNWaXNpYmlsaXR5IiwiZmllbGRzTGlzdCIsInNldEZpZWxkVmFsdWUiLCJmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCIsImNvbGxlY3REYXRhIiwiZmxhdCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsIkRFRkFVTFRfUlVMRVMiLCJub3RSZWFkb25seSIsImVuYWJsZSIsImRpc2FibGVkIiwiZGlzYWJsZSIsIm5vdEZvcm1SdWxlcyIsIl9hc3NlcnRDbGFzc0JyYW5kIiwiX1JVTEVTIiwiXyIsImV4ZWMiLCJtYXN0ZXIiLCJzbGF2ZXMiLCJERUZBVUxUX0FDVElPTl9OQU1FIiwiX3ZhbGlkYXRpb25SdW5uZXIiLCJfZm9ybSIsIl9hY3Rpb24iLCJfZmllbGRzIiwiX3ZhcmlhbnRzIiwiX25vdEZvcm1fYnJhbmQiLCJXZWFrU2V0Iiwibm90Rm9ybSIsIlVJRm9ybUNvbXBvbmVudCIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsImluaXRGb3JtIiwiaW5pdExpYnMiLCJpbml0RmllbGRzIiwiaW5pdFZhcmlhbnRzIiwiaW5pdFZhbGlkYXRvciIsInJlSW5pdCIsInVwZGF0ZVVJIiwiZ2V0Rm9ybU1hbmlmZXN0IiwiUnVubmVyIiwiZ2V0Rm9ybVZhbGlkYXRvcnMiLCJfZ2V0Rm9ybVByb3BzIiwiZm9ybU9wdGlvbnMiLCJnZXRGb3JtT3B0aW9ucyIsImdldEZvcm1EYXRhIiwiaW5qZWN0ZWRQcm9wcyIsImdldEZvcm1JbmplY3RlZFByb3BzIiwiZ2V0Rm9ybVRhcmdldEVsIiwiX2JpbmRVSUV2ZW50cyIsInZhbGlkYXRlRm9ybSIsIiRzZXQiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiZ2V0Rm9ybUFjdGlvbiIsImdldFJlcG9ydCIsImNsZWFuIiwiRVJST1JfREVGQVVMVCIsInN1Ym1pdCIsInNldEZvcm1BY3Rpb24iLCJnZXRWYXJpYW50IiwibGliIiwiZmluZCIsIl9taXNzaW5nT3ZlcnJpZGVXYXJuaW5nIiwidXBkYXRlRmllbGQiLCJldiIsIl9iaW5kTWFzdGVyU2xhdmVFdmVudHMiLCJtYXN0ZXJzIiwicnVsZXMiLCJydWxlTmFtZSIsInJ1bGVTbGF2ZXMiLCJfYWRkTWFzdGVyU2xhdmVFdmVudHMiLCJfZXhlY1NsYXZlUnVsZSIsImNtZCIsInNsYXZlRmllbGQiLCJGb3JtSGVscGVycyIsImxvYWRpbmciLCJkZXNjcmlwdGlvbiIsIm1pc3NpbmciLCJERUZBVUxUX0ZPUk1fU0VUX05BTUUiLCJfZm9ybVNldENvbXBvbmVudCIsIl9mb3JtQ29tcG9uZW50IiwiX2ZyYW1lIiwiX25vdEZvcm1TZXRfYnJhbmQiLCJub3RGb3JtU2V0IiwiZm9ybUNvbXBvbmVudCIsImZvcm1TZXRDb21wb25lbnQiLCJVSUZvcm1TZXRDb21wb25lbnQiLCJzaG93TW9kZXMiLCJzZXRGb3JtTW9kZSIsImdldEZyYW1lVGFyZ2V0RWwiLCJfZ2V0RnJhbWVQcm9wcyIsInVwZGF0ZUZvcm0iLCJpc01vZGVFeGlzdHMiLCJnZXRGaXJzdE1vZGUiLCJ1cGRhdGVGb3JtTW9kZUluVUkiLCJnZXRGb3JtTW9kZSIsImRlc3Ryb3lGb3JtIiwicmVuZGVyRm9ybSIsImZvcm1Db25maWciLCJnZXRGb3JtQ29uZmlnIiwiY2hhbmdlTW9kZSIsImNvbnRhaW5lckVsIiwibGFzdENoaWxkIiwiZGVzdHJveUZyYW1lIiwiZm9ybXMiLCJub3RCcmVhZGNydW1icyIsIlVJQ29uc3RydWN0b3IiLCJnZXRCcmVhZGNydW1icyIsImdvIiwic2V0SGVhZCIsImhlYWQiLCJzZXRUYWlsIiwidGFpbCIsImNydW1icyIsIlVJQnJlYWRjcnVtYnMiLCJNZW51IiwiaGlkZSIsInNldEFwcCIsImdldE9wdGlvbnNQYXRoVG8iLCJpc0RpcmVjdE5hdmlnYXRpb24iLCJkaXJlY3ROYXZpZ2F0aW9uIiwiYnJhbmQiLCJzZWN0aW9ucyIsInRhcmdldFNlbGVjdG9yIiwidG9nZ2xlU2VsZWN0b3IiLCJvcGVuIiwiZ2V0Q29tcG9uZW50IiwiaW5pdEZpZWxkIiwiREVGQVVMVCIsInNvcnRMaXN0IiwicHJpb3JpdHkiLCJyZW1vdmVEdWJsaWNhdGVzIiwicHJlcGFyZURhdGEiLCJzZWN0aW9uVGl0bGUiLCJtZW51IiwidXBkYXRlSW5kaWNhdG9yIiwic2VjdGlvbklkIiwiaXRlbUlkIiwidXBkYXRlU2VjdGlvbiIsImluZGljYXRvciIsInVwZGF0ZUl0ZW0iLCJ1cGRhdGVUYWciLCJ0YWciLCJ1cGRhdGVTZWN0aW9uVGFnIiwidXBkYXRlSXRlbVRhZyIsInVwZGF0ZVNlY3Rpb25JdGVtcyIsIm9sZExpc3QiLCJpc1RvdWNoIiwiZ2V0U2VjdGlvbkNvbXBvbmVudCIsIl9NZW51IiwidXJscyIsInNob3J0IiwiVUlJY29uIiwiU2lkZU1lbnVTdGF0ZSIsIlRZUEUiLCJub3RTaWRlTWVudSIsImNyZWF0ZVVJIiwibW91bnQiLCJVSVNpZGVNZW51IiwiaW5pdFNpemVSZXNwb25zZSIsInVwZGF0ZU1lbnVBY3RpdmVJdGVtIiwiYmluZFRvZ2dsZSIsIml0ZW1Jc0FjdGl2ZSIsIml0ZW1VUkwiLCJ1cGRhdGVNZW51IiwibGFzdExvY2F0aW9uIiwibmF2IiwiYXNpZGUiLCJtYWluIiwicmVzaXplQXNpZGVBbmRNYWluIiwicmVzaXplTWFpbiIsInNob3ciLCJzdHlsZSIsImRpc3BsYXkiLCJtYXJnaW5MZWZ0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImhlaWdodCIsIndpZHRoIiwibGVmdCIsInJlc2l6ZUFzaWRlIiwiaW5uZXJIZWlnaHQiLCJtYXJnaW5Ub3AiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidG9nZ2xlIiwiaXNPcGVuIiwiX25vdFNpZGVNZW51IiwiY2xvc2VkIiwiU2lkZU1lbnVTdG9yZSIsIlNpZGVNZW51Iiwibm90VG9wTWVudSIsIlVJTmF2YmFyVG9wIiwic2V0QnVyZ2VyU3RhdGUiLCJtZW51Q2xvc2VkIiwiX25vdFRvcE1lbnUiLCJwbGFjZSIsIkRFRkFVTFRfVFJBU0ZPUk1FUiIsIkFDVElPTiIsIlRJVExFIiwiZGF0YVByb3ZpZGVyIiwiZ29CYWNrIiwiX2NsYXNzIiwic2V0QnJlYWRjcnVtYnMiLCJwcmVsb2FkVmFyaWFudHMiLCIkZGVzdHJveVVJIiwicmVzdWx0VHJhbnNmb3JtZXIiLCJnZXRDb250YWluZXJJbm5lckVsZW1lbnQiLCJzaG93RXJyb3JNZXNzYWdlIiwiUFJFTE9BREFCTEUiLCJDUlVEVmFyaWFudHNQcmVsb2FkZXIiLCJwcmVsb2FkIiwibGliUHJvcHMiLCJwcm9tcyIsIk1vZGVsIiwicmVzdWx0cyIsInByb3BOYW1lIiwicmVzdWx0c0xpc3QiLCJERUZBVUxUX0FDVElPTiIsIm5vdENSVURSb3V0ZXIiLCJleHRyYWN0QWN0aW9uTmFtZSIsImFjdGlvbkhhbmRsZXJFeGlzdHMiLCJydW5BY3Rpb24iLCJDUlVETWVzc2FnZSIsInNldFVJIiwiVUlFcnJvciIsInN1Y2Nlc3MiLCJVSVN1Y2Nlc3MiLCJERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCIsIkNSVURHZW5lcmljQWN0aW9uIiwicHJlc2V0IiwiZ2V0QnJlYWRjcnVtYnNUYWlsIiwiYnJlYWRjcnVtYnNUYWlscyIsImRlYWZ1bHRCcmVhZGNydW1ic1RhaWwiLCJnZXRJZEZpZWxkIiwibG9hZERhdGFRdWVyeSIsImdldE1vZGVsQWN0aW9uTmFtZSIsIk1PREVMX0FDVElPTl9HRVQiLCJwcmVzZXRCcmVhZGNydW1icyIsImdldFRpdGxlIiwiY29udG9sbGVyIiwiZ2V0SXRlbVRpdGxlIiwiYnJlYWRjcnVtYnNUYWlsVGVtcGxhdGUiLCJpc1Jlc3BvbnNlQmFkIiwiZ2V0VmFsaWRhdG9ycyIsInByZXBhcmVVSU9wdGlvbnMiLCJkZXRhaWxzQWN0aW9uTmFtZSIsInZhbGlkYXRvcnMiLCJpbmplY3RlZCIsIlRSQU5TRk9STUVSIiwiZ2V0VUkiLCJzZXRVSUxvYWRpbmciLCJzZXRVSUxvYWRlZCIsInNldFVJRXJyb3IiLCJiaW5kVUlFdmVudHMiLCJiaW5kVUlFdmVudCIsImlzVUlSZW5kZXJlZCIsInR3ZWFrVUlPcHRpb25zIiwidWlDb21wb25lbnQiLCJyZW5kZXJMb2FkaW5nU2NyZWVuIiwicmVtb3ZlTG9hZGluZ1NjcmVlbiIsImdvQmFja0FmdGVyRGVsYXkiLCJOQVZJR0FUSU9OX0RFTEFZIiwiQ1JVREdlbmVyaWNBY3Rpb25DcmVhdGUiLCJfQ1JVREdlbmVyaWNBY3Rpb24iLCJkZWZEYXRhIiwiY3JlYXRlRGVmYXVsdCIsIm9uQWN0aW9uU3VibWl0IiwiQ1JVREFjdGlvbkNyZWF0ZSIsIl9DUlVER2VuZXJpY0FjdGlvbkNyZSIsIkNSVURHZW5lcmljQWN0aW9uUmVhZCIsIkNSVURBY3Rpb25EZXRhaWxzIiwiX0NSVURHZW5lcmljQWN0aW9uUmVhIiwiQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGUiLCJNT0RFTF9BQ1RJT05fUFVUIiwiQ1JVREFjdGlvblVwZGF0ZSIsIl9DUlVER2VuZXJpY0FjdGlvblVwZCIsIk1PREVMX0FDVElPTiIsIkNSVURBY3Rpb25EZWxldGUiLCJsb2FkZXJBY3RpdmUiLCJsb2FkZXJTdHlsZSIsImxvYWRlclRpdGxlIiwiY29udGFpbmVyIiwiY29uZmlybSIsImRlbGV0ZUFjdGlvbk5hbWUiLCJnb0xpc3QiLCJDUlVEQWN0aW9uTGlzdCIsInR3ZWFrQWN0aW9uc0xpc3QiLCJBQ1RJT05TX0xJU1QiLCJnb0NyZWF0ZSIsImNyZWF0ZUFjdGlvbnNCdXR0b25zIiwicHJlcGVuZCIsIm9ubHlJY29ucyIsIkFDVElPTlMiLCJkZXRhaWxzIiwiZ29EZXRhaWxzIiwiaWNvbiIsImdvVXBkYXRlIiwiY29sb3IiLCJkZWxldGUiLCJnb0RlbGV0ZSIsImFjdGlvbnNCdXR0b25zIiwicHJlcGFyZU9wdGlvbnMiLCJERUZBVUxUX09QVElPTlNfVEFCTEUiLCJpbnRlcmZhY2UiLCJjb21iaW5lZCIsIlRBQkxFX09QVElPTlMiLCJvcHRWYWwiLCJCUkVBRENSVU1CUyIsIlRJVExFX0ZJRUxEU19QUklPUklUWSIsIkxPQURJTkdfU0NSRUVOX1VJX05BTUUiLCJfYWN0aW9ucyIsIl9yb3V0ZXIiLCJfcHJlbG9hZGVyIiwibm90Q1JVRCIsIl9ub3RDb250cm9sbGVyIiwicHJlbG9hZGVyIiwiQ1JVREFjdGlvbnMiLCJDUlVEUm91dGVyIiwiYnVpbGRGcmFtZSIsInNldFZhbGlkYXRvcnMiLCJNb2R1bGVOYW1lUGFydHMiLCJzcGxpdCIsIk1vZHVsZU5hbWUiLCJzZXJ2aWNlTmFtZSIsIkNvbW1vbk1vZHVsZVNlcnZpY2UiLCJhdWdtZW50VmFsaWRhdG9ycyIsIm5ld0hlYWQiLCJzdGFydFdoZW5XU0NsaWVudFJlYWR5IiwiaXNDb25uZWN0ZWQiLCJvbmNlIiwiV1NfQ0hFQ0tfSU5URVJWQUwiLCJiYWNrVG9MaXN0IiwibGlua0JhY2tUb0xpc3QiLCJhZnRlckFjdGlvbiIsIm5hdkJhY2siLCJiYWNrIiwiY3JlYXRlRWxlbWVudCIsImdldEZyYW1lQ2xhc3NlcyIsIlRPUF9DTEFTUyIsImFwcGVuZENoaWxkIiwiTUFJTl9DTEFTUyIsImJvdHRvbSIsIkJPVFRPTV9DTEFTUyIsImdldENvbnRhaW5lclRvcEVsZW1lbnQiLCJnZXRDb250YWluZXJCb3R0b21FbGVtZW50IiwiZ2V0VGl0bGVGcm9tTGliIiwiZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlIiwiZ2V0UHJlbG9hZGVkVmFyaWFudHMiLCJnb0FmdGVyRGVsYXkiLCJhY3Rpb25VSSIsImRlc3Ryb3lVSUJ5TmFtZSIsInNob3dTdWNjZXNzTWVzc2FnZSIsInNpbmdsZVVJIiwiZ2V0QWN0aW9uVUkiLCJjcmVhdGVMb2FkZXJVSSIsIlVJTG9hZGVyIiwiaXRlbUN1c3RvbVByb3BzIiwiUk9VVEVfTElTVCIsIm5vdENSVURQbGFpblJvdXRlciIsIkRFRkFVTFRfUk9VVEUiLCJub3RDUlVEUm91dGVyU3dpdGNoIiwiaXNSb3V0ZVZhcmlhbnRWYWxpZCIsInJvdXRlc1ZhcmlhbnRzIiwiZGV0ZXJtaW5lUm91dGUiLCJyb3V0ZXJBY3Rpb24iLCJlbXB0eVJlc3VsdCIsInNraXAiLCJub3RTZXJ2aWNlTW9kZWxTZWFyY2giLCJnZXRTZWFyY2hSb3V0ZU5hbWUiLCJnZXREYXRhTG9hZFJvdXRlTmFtZSIsInRyYW5zZm9ybVNlYXJjaFJlc3VsdCIsInVzZXJuYW1lIiwidHJhbnNmb3JtU2VsZWN0ZWRSZXN1bHQiLCJzZWFyY2hCeVRlcm0iLCJ0ZXJtIiwib3BlblNlbGVjdG9yIiwiVUlHZW5lcmljU2VsZWN0b3IiLCJjb25zb2xlIiwidW5tb3VudCIsIm5jQ1JVRCIsIkxvY2FsZSIsIkVsZW1lbnRzIiwiRnJhbWUiLCJjb21wb25lbnRzU2V0TmFtZSIsImNvbXBvbmVudE5hbWUiXSwibWFwcGluZ3MiOiI7OztBQUFBLFdBQWUsSUFBSTs7Q0NBbkI7Q0FDQTtDQUNPLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxPQUFPO0NBQzVCLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJO0NBRTNCLElBQUksZUFBZSxHQUFHLE1BQU0sQ0FBQyxjQUFjO0NBQzNDLElBQUksY0FBYyxHQUFHLE1BQU0sQ0FBQyx3QkFBd0I7Q0FDcEQsSUFBSSxlQUFlLEdBQUcsTUFBTSxDQUFDLHlCQUF5QjtDQUN0RCxJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxTQUFTO0NBQ3ZDLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQyxTQUFTO0NBQ3JDLElBQUksZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGNBQWM7O0NBRW5EO0NB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Q0FBQyxLQUFLLEVBQUUsRUFBRTtDQUM3QztDQUNBLEdBQUdDLDBCQUE0QixFQUFFO0NBQ2pDLEdBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0NBQy9CO0NBQ0EsR0FBRyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7Q0FDM0UsR0FBRyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNOztDQUU3QyxHQUFHLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Q0FDcEUsR0FBRyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUUsUUFBUSxJQUFJLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUM7O0NBRTFELEdBQUdBLDBCQUE0QixDQUFDLFFBQVEsQ0FBQztDQUN6Qzs7Q0FFQSxFQUFFLE9BQU8sSUFBSTtDQUNiOztDQUVBLENBQUMsT0FBTyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQztDQUMxQzs7Q0FFQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQSxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsUUFBUSxHQUFHLElBQUksRUFBRTtDQUM1RCxDQUFDLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7Q0FDbEQsRUFBRSxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FB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QUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQVEsU0FBU0MsTUFBSSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7O0NDOEIvVztDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ08sU0FBUyxJQUFJLENBQUMsS0FBSyxFQUFFO0NBQzVCLENBQUMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7Q0FDaEMsRUFBRSxPQUFPQyxNQUFLLENBQUMsS0FBSyxDQUFDO0NBQ3JCLEVBQUUsTUFBTTtDQUNSLEVBQUUsT0FBTyxLQUFLLElBQUksRUFBRTtDQUNwQjtDQUNBOztD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QUUsSUFBSSxJQUFJLEVBQUU7Q0FDWixHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Q0FDZDs7Q0FFQSxFQUFFLElBQUksR0FBRyxFQUFFO0NBQ1gsR0FBRyxJQUFJLE1BQU0sR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUMxQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztDQUNqQztDQUNBOztDQUVBLENBQUMsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEdBQUcsRUFBRTs7Q0FFekI7Q0FDQTtDQUNBO0NBQ0EsQ0FBQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQzs7Q0FFaEUsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLE1BQU07Q0FDNUI7Q0FDQTtDQUNBLEVBQUUsSUFBSSxFQUFFLEdBQUcsV0FBVyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO0NBQ3JDLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRTs7Q0FFdEIsRUFBRSxJQUFJLEtBQUssR0FBRyxFQUFFLEdBQUcsRUFBRTtDQUNyQixFQUFFLElBQUksUUFBUSx5QkFBeUIsQ0FBQyxPQUFPLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0NBQzNFLEVBQUUsSUFBSSxTQUFTLEdBQUcsRUFBRTs7Q0FFcEIsRUFBRSxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUU7Q0FDcEIsR0FBRyxJQUFJLEdBQUcsRUFBRTtDQUNaLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0NBRTlDLElBQUksS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxF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QUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBRTtDQUN0RCxDQUFDLElBQUksS0FBSyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQztDQUNuQyxDQUFDLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Q0FFM0IsQ0FBQyxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUMsU0FBUyxLQUFLLE1BQU0sR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDLFNBQVM7Q0FDbEUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7Q0FDaEUsQ0FBQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLO0NBQ2hDLENBQUMsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTTs7Q0FFbEMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxJQUFJLElBQUk7Q0FDeEQsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLElBQUk7Q0FDdEQsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsTUFBTSxHQUFHLFFBQVEsRUFBRSxHQUFHLE1BQU07O0NB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aUJBQWlCLEVBQUs7Q0FDakRsM0MsRUFBQUEsTUFBTSxDQUFDb0gsSUFBSSxDQUFDNHZDLFFBQVEsQ0FBQ0UsaUJBQWlCLENBQUMsQ0FBQyxDQUFDdnpDLE9BQU8sQ0FBQyxVQUFDd3pDLGFBQWEsRUFBSztDQUNoRUYsSUFBQUEsY0FBa0IsQ0FBQy9aLFlBQVksQ0FDM0JpYSxhQUFhLEVBQ2JILFFBQVEsQ0FBQ0UsaUJBQWlCLENBQUMsQ0FBQ0MsYUFBYSxDQUM3QyxDQUFDO0NBQ0wsR0FBQyxDQUFDO0NBQ04sQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDYwLDYyLDYzLDY0LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4XX0=
