var notBulma = (function (exports) {
	'use strict';

	var DEV = true;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * @template V
	 * @param {V} value
	 * @param {V | (() => V)} fallback
	 * @param {boolean} [lazy]
	 * @returns {V}
	 */
	function fallback(value, fallback, lazy = false) {
		return value === undefined
			? lazy
				? /** @type {() => V} */ (fallback)()
				: /** @type {V} */ (fallback)
			: value;
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */
	const LEGACY_DERIVED_PROP = 1 << 17;
	const INSPECT_EFFECT = 1 << 18;
	const HEAD_EFFECT = 1 << 19;
	const EFFECT_HAS_DERIVED = 1 << 20;

	const STATE_SYMBOL = Symbol('$state');
	const STATE_SYMBOL_METADATA = Symbol('$state metadata');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/** @import { Equals } from '#client' */
	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
	 * @returns {never}
	 */
	function bind_invalid_checkbox_value() {
		{
			const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		{
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Failed to hydrate the application
	 * @returns {never}
	 */
	function hydration_failed() {
		{
			const error = new Error(`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`
	 * @returns {never}
	 */
	function invalid_snippet() {
		{
			const error = new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%name%(...)` cannot be used in runes mode
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_legacy_only(name) {
		{
			const error = new Error(`lifecycle_legacy_only\n\`${name}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Rest element properties of `$props()` such as `%property%` are readonly
	 * @param {string} property
	 * @returns {never}
	 */
	function props_rest_readonly(property) {
		{
			const error = new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		{
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state
	 * @returns {never}
	 */
	function state_unsafe_local_read() {
		{
			const error = new Error(`state_unsafe_local_read\nReading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state\nhttps://svelte.dev/e/state_unsafe_local_read`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			const error = new Error(`state_unsafe_mutation\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const HYDRATION_START = '[';
	/** used to indicate that an `{:else}...` block was rendered */
	const HYDRATION_START_ELSE = '[!';
	const HYDRATION_END = ']';
	const HYDRATION_ERROR = {};

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold$1 = 'font-weight: bold';
	var normal$1 = 'font-weight: normal';

	/**
	 * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:
	 * 
	 * %properties%
	 * @param {string | undefined | null} [properties]
	 */
	function state_snapshot_uncloneable(properties) {
		{
			console.warn(`%c[svelte] state_snapshot_uncloneable\n%c${properties
			? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}`
			: 'Value cannot be cloned with `$state.snapshot` — the original value was returned'}\nhttps://svelte.dev/e/state_snapshot_uncloneable`, bold$1, normal$1);
		}
	}

	/** @import { Snapshot } from './types' */

	/**
	 * In dev, we keep track of which properties could not be cloned. In prod
	 * we don't bother, but we keep a dummy array around so that the
	 * signature stays the same
	 * @type {string[]}
	 */
	const empty = [];

	/**
	 * @template T
	 * @param {T} value
	 * @param {boolean} [skip_warning]
	 * @returns {Snapshot<T>}
	 */
	function snapshot(value, skip_warning = false) {
		if (!skip_warning) {
			/** @type {string[]} */
			const paths = [];

			const copy = clone(value, new Map(), '', paths);
			if (paths.length === 1 && paths[0] === '') {
				// value could not be cloned
				state_snapshot_uncloneable();
			} else if (paths.length > 0) {
				// some properties could not be cloned
				const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
				const excess = paths.length - slice.length;

				let uncloned = slice.map((path) => `- <value>${path}`).join('\n');
				if (excess > 0) uncloned += `\n- ...and ${excess} more`;

				state_snapshot_uncloneable(uncloned);
			}

			return copy;
		}

		return clone(value, new Map(), '', empty);
	}

	/**
	 * @template T
	 * @param {T} value
	 * @param {Map<T, Snapshot<T>>} cloned
	 * @param {string} path
	 * @param {string[]} paths
	 * @param {null | T} original The original value, if `value` was produced from a `toJSON` call
	 * @returns {Snapshot<T>}
	 */
	function clone(value, cloned, path, paths, original = null) {
		if (typeof value === 'object' && value !== null) {
			var unwrapped = cloned.get(value);
			if (unwrapped !== undefined) return unwrapped;

			if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value));
			if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value));

			if (is_array(value)) {
				var copy = /** @type {Snapshot<any>} */ (Array(value.length));
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var i = 0; i < value.length; i += 1) {
					var element = value[i];
					if (i in value) {
						copy[i] = clone(element, cloned, `${path}[${i}]` , paths);
					}
				}

				return copy;
			}

			if (get_prototype_of(value) === object_prototype) {
				/** @type {Snapshot<any>} */
				copy = {};
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var key in value) {
					// @ts-expect-error
					copy[key] = clone(value[key], cloned, `${path}.${key}` , paths);
				}

				return copy;
			}

			if (value instanceof Date) {
				return /** @type {Snapshot<T>} */ (structuredClone(value));
			}

			if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function') {
				return clone(
					/** @type {T & { toJSON(): any } } */ (value).toJSON(),
					cloned,
					`${path}.toJSON()` ,
					paths,
					// Associate the instance with the toJSON clone
					value
				);
			}
		}

		if (value instanceof EventTarget) {
			// can't be cloned
			return /** @type {Snapshot<T>} */ (value);
		}

		try {
			return /** @type {Snapshot<T>} */ (structuredClone(value));
		} catch (e) {
			{
				paths.push(path);
			}

			return /** @type {Snapshot<T>} */ (value);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value
	 * @param {string} attribute
	 * @param {string} html
	 * @param {string} value
	 */
	function hydration_attribute_changed(attribute, html, value) {
		{
			console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${attribute}\` attribute on \`${html}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`, bold, normal);
		}
	}

	/**
	 * The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value
	 * @param {string | undefined | null} [location]
	 */
	function hydration_html_changed(location) {
		{
			console.warn(`%c[svelte] hydration_html_changed\n%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : 'The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value'}\nhttps://svelte.dev/e/hydration_html_changed`, bold, normal);
		}
	}

	/**
	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
	 * @param {string | undefined | null} [location]
	 */
	function hydration_mismatch(location) {
		{
			console.warn(`%c[svelte] hydration_mismatch\n%c${'Hydration failed because the initial UI does not match what was rendered on the server'}\nhttps://svelte.dev/e/hydration_mismatch`, bold, normal);
		}
	}

	/**
	 * The `render` function passed to `createRawSnippet` should return HTML for a single element
	 */
	function invalid_raw_snippet_render() {
		{
			console.warn(`%c[svelte] invalid_raw_snippet_render\n%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element\nhttps://svelte.dev/e/invalid_raw_snippet_render`, bold, normal);
		}
	}

	/**
	 * Tried to unmount a component that was not mounted
	 */
	function lifecycle_double_unmount() {
		{
			console.warn(`%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
		}
	}

	/**
	 * %component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead
	 * @param {string | undefined | null} [component]
	 * @param {string | undefined | null} [owner]
	 */
	function ownership_invalid_mutation(component, owner) {
		{
			console.warn(`%c[svelte] ownership_invalid_mutation\n%c${component ? `${component} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : 'Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead'}\nhttps://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
		}
	}

	/** @import { ProxyMetadata } from '#client' */
	/** @typedef {{ file: string, line: number, column: number }} Location */


	/** @type {Record<string, Array<{ start: Location, end: Location, component: Function }>>} */
	const boundaries = {};

	const chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
	const firefox_pattern = /@(.+):(\d+):(\d+)$/;

	function get_stack() {
		const stack = new Error().stack;
		if (!stack) return null;

		const entries = [];

		for (const line of stack.split('\n')) {
			let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);

			if (match) {
				entries.push({
					file: match[1],
					line: +match[2],
					column: +match[3]
				});
			}
		}

		return entries;
	}

	/**
	 * Determines which `.svelte` component is responsible for a given state change
	 * @returns {Function | null}
	 */
	function get_component() {
		// first 4 lines are svelte internals; adjust this number if we change the internal call stack
		const stack = get_stack()?.slice(4);
		if (!stack) return null;

		for (let i = 0; i < stack.length; i++) {
			const entry = stack[i];
			const modules = boundaries[entry.file];
			if (!modules) {
				// If the first entry is not a component, that means the modification very likely happened
				// within a .svelte.js file, possibly triggered by a component. Since these files are not part
				// of the bondaries/component context heuristic, we need to bail in this case, else we would
				// have false positives when the .svelte.ts file provides a state creator function, encapsulating
				// the state and its mutations, and is being called from a component other than the one who
				// called the state creator function.
				if (i === 0) return null;
				continue;
			}

			for (const module of modules) {
				if (module.end == null) {
					return null;
				}
				if (module.start.line < entry.line && module.end.line > entry.line) {
					return module.component;
				}
			}
		}

		return null;
	}

	const ADD_OWNER = Symbol('ADD_OWNER');

	/**
	 * @param {any} object
	 * @param {any | null} owner
	 * @param {boolean} [global]
	 * @param {boolean} [skip_warning]
	 */
	function add_owner(object, owner, global = false, skip_warning = false) {
		if (object && !global) {
			const component = dev_current_component_function;
			const metadata = object[STATE_SYMBOL_METADATA];
			if (metadata && !has_owner(metadata, component)) {
				get_owner(metadata);
			}
		}

		add_owner_to_object(object, owner, new Set());
	}

	/**
	 * @param {ProxyMetadata | null} from
	 * @param {ProxyMetadata} to
	 */
	function widen_ownership(from, to) {
		if (to.owners === null) {
			return;
		}

		while (from) {
			if (from.owners === null) {
				to.owners = null;
				break;
			}

			for (const owner of from.owners) {
				to.owners.add(owner);
			}

			from = from.parent;
		}
	}

	/**
	 * @param {any} object
	 * @param {Function | null} owner If `null`, then the object is globally owned and will not be checked
	 * @param {Set<any>} seen
	 */
	function add_owner_to_object(object, owner, seen) {
		const metadata = /** @type {ProxyMetadata} */ (object?.[STATE_SYMBOL_METADATA]);

		if (metadata) {
			// this is a state proxy, add owner directly, if not globally shared
			if ('owners' in metadata && metadata.owners != null) {
				{
					metadata.owners = null;
				}
			}
		} else if (object && typeof object === 'object') {
			if (seen.has(object)) return;
			seen.add(object);
			if (ADD_OWNER in object && object[ADD_OWNER]) {
				// this is a class with state fields. we put this in a render effect
				// so that if state is replaced (e.g. `instance.name = { first, last }`)
				// the new state is also co-owned by the caller of `getContext`
				render_effect(() => {
					object[ADD_OWNER](owner);
				});
			} else {
				var proto = get_prototype_of(object);

				if (proto === Object.prototype) {
					// recurse until we find a state proxy
					for (const key in object) {
						if (Object.getOwnPropertyDescriptor(object, key)?.get) {
							// Similar to the class case; the getter could update with a new state
							let current = UNINITIALIZED;
							render_effect(() => {
								const next = object[key];
								if (current !== next) {
									current = next;
									add_owner_to_object(next, owner, seen);
								}
							});
						} else {
							add_owner_to_object(object[key], owner, seen);
						}
					}
				} else if (proto === Array.prototype) {
					// recurse until we find a state proxy
					for (let i = 0; i < object.length; i += 1) {
						add_owner_to_object(object[i], owner, seen);
					}
				}
			}
		}
	}

	/**
	 * @param {ProxyMetadata} metadata
	 * @param {Function} component
	 * @returns {boolean}
	 */
	function has_owner(metadata, component) {
		if (metadata.owners === null) {
			return true;
		}

		return (
			metadata.owners.has(component) ||
			// This helps avoid false positives when using HMR, where the component function is replaced
			(FILENAME in component &&
				[...metadata.owners].some(
					(owner) => /** @type {any} */ (owner)[FILENAME] === component[FILENAME]
				)) ||
			(metadata.parent !== null && has_owner(metadata.parent, component))
		);
	}

	/**
	 * @param {ProxyMetadata} metadata
	 * @returns {any}
	 */
	function get_owner(metadata) {
		return (
			metadata?.owners?.values().next().value ??
			get_owner(/** @type {ProxyMetadata} */ (metadata.parent))
		);
	}

	/**
	 * @param {ProxyMetadata} metadata
	 */
	function check_ownership(metadata) {

		const component = get_component();

		if (component && !has_owner(metadata, component)) {
			let original = get_owner(metadata);

			// @ts-expect-error
			if (original[FILENAME] !== component[FILENAME]) {
				// @ts-expect-error
				ownership_invalid_mutation(component[FILENAME], original[FILENAME]);
			} else {
				ownership_invalid_mutation();
			}
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/** @import { ComponentContext } from '#client' */


	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		const context_map = get_or_init_context_map('getContext');
		const result = /** @type {T} */ (context_map.get(key));
		return result;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map('setContext');

		{
			// When state is put into context, we treat as if it's global from now on.
			// We do for performance reasons (it's for example very expensive to call
			// getContext on a big object many times when part of a list component)
			// and danger of false positives.
			untrack(() => add_owner(context, null, true));
		}

		context_map.set(key, context);
		return context;
	}

	/**
	 * Checks whether a given `key` has been set in the context of a parent component.
	 * Must be called during component initialisation.
	 *
	 * @param {any} key
	 * @returns {boolean}
	 */
	function hasContext(key) {
		const context_map = get_or_init_context_map('hasContext');
		return context_map.has(key);
	}

	/**
	 * Retrieves the whole context map that belongs to the closest parent component.
	 * Must be called during component initialisation. Useful, for example, if you
	 * programmatically create a component and want to pass the existing context to it.
	 *
	 * @template {Map<any, any>} [T=Map<any, any>]
	 * @returns {T}
	 */
	function getAllContexts() {
		const context_map = get_or_init_context_map('getAllContexts');
		return /** @type {T} */ (context_map);
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		};

		if (legacy_mode_flag && !runes) {
			component_context.l = {
				s: null,
				u: null,
				r1: [],
				r2: source(false)
			};
		}

		{
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			{
				dev_current_component_function = context_stack_item.p?.function ?? null;
			}
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component(name);
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	let inspect_effects = new Set();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 */
	function state(v) {
		return push_derived_source(source(v));
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	function mutable_state(v, immutable = false) {
		return push_derived_source(mutable_source(v, immutable));
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function push_derived_source(source) {
		if (active_reaction !== null && !untracking && (active_reaction.f & DERIVED) !== 0) {
			if (derived_sources === null) {
				set_derived_sources([source]);
			} else {
				derived_sources.push(source);
			}
		}

		return source;
	}

	/**
	 * @template V
	 * @param {Value<V>} source
	 * @param {V} value
	 */
	function mutate(source, value) {
		set(
			source,
			untrack(() => get$3(source))
		);
		return value;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function set(source, value) {
		if (
			active_reaction !== null &&
			!untracking &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			// If the source was created locally within the current derived, then
			// we allow the mutation.
			(derived_sources === null || !derived_sources.includes(source))
		) {
			state_unsafe_mutation();
		}

		return internal_set(source, value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			source.v;
			source.v = value;
			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (inspect_effects.size > 0) {
				const inspects = Array.from(inspect_effects);
				var previously_flushing_effect = is_flushing_effect;
				set_is_flushing_effect(true);
				try {
					for (const effect of inspects) {
						// Mark clean inspect-effects as maybe dirty and then check their dirtiness
						// instead of just updating the effects - this way we avoid overfiring.
						if ((effect.f & CLEAN) !== 0) {
							set_signal_status(effect, MAYBE_DIRTY);
						}
						if (check_dirtiness(effect)) {
							update_effect(effect);
						}
					}
				} finally {
					set_is_flushing_effect(previously_flushing_effect);
				}
				inspect_effects.clear();
			}
		}

		return value;
	}

	/**
	 * @template {number | bigint} T
	 * @param {Source<T>} source
	 * @param {1 | -1} [d]
	 * @returns {T}
	 */
	function update(source, d = 1) {
		var value = get$3(source);
		var result = d === 1 ? value++ : value--;

		set(source, value);

		// @ts-expect-error
		return result;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if ((flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {boolean} value */
	function set_hydrating(value) {
		hydrating = value;
	}

	/**
	 * The node that is currently being hydrated. This starts out as the first node inside the opening
	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
	 * time we leave the block it is the closing comment, which serves as the block's anchor.
	 * @type {TemplateNode}
	 */
	let hydrate_node;

	/** @param {TemplateNode} node */
	function set_hydrate_node(node) {
		if (node === null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return (hydrate_node = node);
	}

	function hydrate_next() {
		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
	}

	/** @param {TemplateNode} node */
	function reset(node) {
		if (!hydrating) return;

		// If the node has remaining siblings, something has gone wrong
		if (get_next_sibling(hydrate_node) !== null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		hydrate_node = node;
	}

	function next(count = 1) {
		if (hydrating) {
			var i = count;
			var node = hydrate_node;

			while (i--) {
				node = /** @type {TemplateNode} */ (get_next_sibling(node));
			}

			hydrate_node = node;
		}
	}

	/**
	 * Removes all nodes starting at `hydrate_node` up until the next hydration end comment
	 */
	function remove_nodes() {
		var depth = 0;
		var node = hydrate_node;

		while (true) {
			if (node.nodeType === 8) {
				var data = /** @type {Comment} */ (node).data;

				if (data === HYDRATION_END) {
					if (depth === 0) return node;
					depth -= 1;
				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
					depth += 1;
				}
			}

			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
			node.remove();
			node = next;
		}
	}

	/** @import { ProxyMetadata, Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @param {ProxyMetadata | null} [parent]
	 * @param {Source<T>} [prev] dev mode only
	 * @returns {T}
	 */
	function proxy(value, parent = null, prev) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = source(0);

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', source(/** @type {any[]} */ (value).length));
		}

		/** @type {ProxyMetadata} */
		var metadata;

		{
			metadata = {
				parent,
				owners: null
			};

			{
				metadata.owners =
					parent === null
						? component_context !== null
							? new Set([component_context.function])
							: null
						: new Set();
			}
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = source(descriptor.value);
					sources.set(prop, s);
				} else {
					set(s, proxy(descriptor.value, metadata));
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(prop, source(UNINITIALIZED));
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL_METADATA) {
					return metadata;
				}

				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get$3(s);

					// In case of something like `foo = bar.map(...)`, foo would have ownership
					// of the array itself, while the individual items would have ownership
					// of the component that created bar. That means if we later do `foo[0].baz = 42`,
					// we could get a false-positive ownership violation, since the two proxies
					// are not connected to each other via the parent metadata relationship.
					// For this reason, we need to widen the ownership of the children
					// upon access when we detect they are not connected.
					{
						/** @type {ProxyMetadata | undefined} */
						var prop_metadata = v?.[STATE_SYMBOL_METADATA];
						if (prop_metadata && prop_metadata?.parent !== metadata) {
							widen_ownership(metadata, prop_metadata);
						}
					}

					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get$3(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL_METADATA) {
					return true;
				}

				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);
						sources.set(prop, s);
					}

					var value = get$3(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = source(UNINITIALIZED);
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = source(undefined);
						set(s, proxy(value, metadata));
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set(s, proxy(value, metadata));
				}

				{
					/** @type {ProxyMetadata | undefined} */
					var prop_metadata = value?.[STATE_SYMBOL_METADATA];
					if (prop_metadata && prop_metadata?.parent !== metadata) {
						widen_ownership(metadata, prop_metadata);
					}
					check_ownership(metadata);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get$3(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
			return value[STATE_SYMBOL];
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		// the following assignments improve perf of lookups on DOM nodes
		// @ts-expect-error
		element_prototype.__click = undefined;
		// @ts-expect-error
		element_prototype.__className = '';
		// @ts-expect-error
		element_prototype.__attributes = null;
		// @ts-expect-error
		element_prototype.__styles = null;
		// @ts-expect-error
		element_prototype.__e = undefined;

		// @ts-expect-error
		Text.prototype.__t = undefined;

		{
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		if (!hydrating) {
			return get_first_child(node);
		}

		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
		if (child === null) {
			child = hydrate_node.appendChild(create_text());
		} else if (is_text && child.nodeType !== 3) {
			var text = create_text();
			child?.before(text);
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(child);
		return child;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		if (!hydrating) {
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}

		// if an {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && hydrate_node?.nodeType !== 3) {
			var text = create_text();

			hydrate_node?.before(text);
			set_hydrate_node(text);
			return text;
		}

		return hydrate_node;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = hydrating ? hydrate_node : node;
		var last_sibling;

		while (count--) {
			last_sibling = next_sibling;
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		if (!hydrating) {
			return next_sibling;
		}

		var type = next_sibling?.nodeType;

		// if a sibling {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && type !== 3) {
			var text = create_text();
			// If the next sibling is `null` and we're handling text then it's because
			// the SSR content was empty for the text, so we need to generate a new text
			// node and insert it after the last sibling
			if (next_sibling === null) {
				last_sibling?.after(text);
			} else {
				next_sibling.before(text);
			}
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(next_sibling);
		return /** @type {TemplateNode} */ (next_sibling);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (null),
			wv: 0,
			parent: parent_derived ?? active_effect
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var is_root = (type & ROOT_EFFECT) !== 0;
		var parent_effect = active_effect;

		{
			// Ensure the parent is never an inspect effect
			while (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {
				parent_effect = parent_effect.parent;
			}
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent: is_root ? null : parent_effect,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0
		};

		{
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			var previously_flushing_effect = is_flushing_effect;

			try {
				set_is_flushing_effect(true);
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			} finally {
				set_is_flushing_effect(previously_flushing_effect);
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;

		if (!inert && !is_root && push) {
			if (parent_effect !== null) {
				push_effect(effect, parent_effect);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.effects ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		{
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		{
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return render_effect(fn);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean }} */
		var token = { effect: null, ran: false };
		context.l.r1.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			set(context.l.r2, true);
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			if (!get$3(context.l.r2)) return;

			// Run dirty `$:` statements
			for (var token of context.l.r1) {
				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (check_dirtiness(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}

			context.l.r2.v = false; // set directly to avoid rerunning this effect
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} thunks
	 * @returns {Effect}
	 */
	function template_effect(fn, thunks = [], d = derived) {
		const deriveds = thunks.map(d);
		const effect = () => fn(...deriveds.map(get$3));

		{
			define_property(effect, 'name', {
				value: '{expression}'
			});
		}

		return block(effect);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;
			destroy_effect(effect, remove_dom);
			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			/** @type {TemplateNode | null} */
			var node = effect.nodes_start;
			var end = effect.nodes_end;

			while (node !== null) {
				/** @type {TemplateNode | null} */
				var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

				node.remove();
				node = next;
			}

			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		{
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// Ensure the effect is marked as clean again so that any dirty child
		// effects can schedule themselves for execution
		if ((effect.f & CLEAN) === 0) {
			effect.f ^= CLEAN;
		}

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update
		if (check_dirtiness(effect)) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	// Fallback for when requestIdleCallback is not available
	const request_idle_callback =
		typeof requestIdleCallback === 'undefined'
			? (/** @type {() => void} */ cb) => setTimeout(cb, 1)
			: requestIdleCallback;

	let is_micro_task_queued$1 = false;
	let is_idle_task_queued = false;

	/** @type {Array<() => void>} */
	let current_queued_micro_tasks = [];
	/** @type {Array<() => void>} */
	let current_queued_idle_tasks = [];

	function process_micro_tasks() {
		is_micro_task_queued$1 = false;
		const tasks = current_queued_micro_tasks.slice();
		current_queued_micro_tasks = [];
		run_all(tasks);
	}

	function process_idle_tasks() {
		is_idle_task_queued = false;
		const tasks = current_queued_idle_tasks.slice();
		current_queued_idle_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (!is_micro_task_queued$1) {
			is_micro_task_queued$1 = true;
			queueMicrotask(process_micro_tasks);
		}
		current_queued_micro_tasks.push(fn);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_idle_task(fn) {
		if (!is_idle_task_queued) {
			is_idle_task_queued = true;
			request_idle_callback(process_idle_tasks);
		}
		current_queued_idle_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		if (is_micro_task_queued$1) {
			process_micro_tasks();
		}
		if (is_idle_task_queued) {
			process_idle_tasks();
		}
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	const FLUSH_MICROTASK = 0;
	const FLUSH_SYNC = 1;
	// Used for DEV time error handling
	/** @param {WeakSet<Error>} value */
	const handled_errors = new WeakSet();
	let is_throwing_error = false;

	// Used for controlling the flush of effects.
	let scheduler_mode = FLUSH_MICROTASK;
	// Used for handling scheduling
	let is_micro_task_queued = false;

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing_effect = false;
	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_flushing_effect(value) {
		is_flushing_effect = value;
	}

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	let flush_count = 0;
	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a derived, we record them so that we can safely allow
	 * local mutations to these sources without the side-effect error being invoked unnecessarily.
	 * @type {null | Source[]}
	 */
	let derived_sources = null;

	/**
	 * @param {Source[] | null} sources
	 */
	function set_derived_sources(sources) {
		derived_sources = sources;
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency
				if (is_disconnected || is_unowned_connected) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 */
	function propagate_error(error, effect) {
		/** @type {Effect | null} */
		var current = effect;

		while (current !== null) {
			if ((current.f & BOUNDARY_EFFECT) !== 0) {
				try {
					// @ts-expect-error
					current.fn(error);
					return;
				} catch {
					// Remove boundary flag from effect
					current.f ^= BOUNDARY_EFFECT;
				}
			}

			current = current.parent;
		}

		is_throwing_error = false;
		throw error;
	}

	/**
	 * @param {Effect} effect
	 */
	function should_rethrow_error(effect) {
		return (
			(effect.f & DESTROYED) === 0 &&
			(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)
		);
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 * @param {Effect | null} previous_effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, previous_effect, component_context) {
		if (is_throwing_error) {
			if (previous_effect === null) {
				is_throwing_error = false;
			}

			if (should_rethrow_error(effect)) {
				throw error;
			}

			return;
		}

		if (previous_effect !== null) {
			is_throwing_error = true;
		}

		if (
			component_context === null ||
			!(error instanceof Error) ||
			handled_errors.has(error)
		) {
			propagate_error(error, effect);
			return;
		}

		handled_errors.add(error);

		const component_stack = [];

		const effect_name = effect.fn?.name;

		if (effect_name) {
			component_stack.push(effect_name);
		}

		/** @type {ComponentContext | null} */
		let current_context = component_context;

		while (current_context !== null) {
			{
				/** @type {string} */
				var filename = current_context.function?.[FILENAME];

				if (filename) {
					const file = filename.split('/').pop();
					component_stack.push(file);
				}
			}

			current_context = current_context.p;
		}

		const indent = is_firefox ? '  ' : '\t';
		define_property(error, 'message', {
			value: error.message + `\n${component_stack.map((name) => `\n${indent}in ${name}`).join('')}\n`
		});
		define_property(error, 'component_stack', {
			value: component_stack
		});

		const stack = error.stack;

		// Filter out internal files from callstack
		if (stack) {
			const lines = stack.split('\n');
			const new_lines = [];
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				if (line.includes('svelte/src/internal')) {
					continue;
				}
				new_lines.push(line);
			}
			define_property(error, 'stack', {
				value: new_lines.join('\n')
			});
		}

		propagate_error(error, effect);

		if (should_rethrow_error(effect)) {
			throw error;
		}
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];
			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var prev_derived_sources = derived_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
		skip_reaction =
			(flags & UNOWNED) !== 0 &&
			(!is_flushing_effect || previous_reaction === null || previous_untracking);

		derived_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		read_version++;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null) {
				read_version++;
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			derived_sources = prev_derived_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var previous_component_context = component_context;

		active_effect = effect;

		{
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			var deps = effect.deps;

			// In DEV, we need to handle a case where $inspect.trace() might
			// incorrectly state a source dependency has not changed when it has.
			// That's beacuse that source was changed by the same effect, causing
			// the versions to match. We can avoid this by incrementing the version
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && deps !== null) ;

			if (DEV) {
				dev_effect_stack.push(effect);
			}
		} catch (error) {
			handle_error(error, effect, previous_effect, previous_component_context || effect.ctx);
		} finally {
			active_effect = previous_effect;

			{
				set_dev_current_component_function(previous_component_fn);
			}
		}
	}

	function log_effect_stack() {
		// eslint-disable-next-line no-console
		console.error(
			'Last ten effects were: ',
			dev_effect_stack.slice(-10).map((d) => d.fn)
		);
		dev_effect_stack = [];
	}

	function infinite_loop_guard() {
		if (flush_count > 1000) {
			flush_count = 0;
			try {
				effect_update_depth_exceeded();
			} catch (error) {
				{
					// stack is garbage, ignore. Instead add a console.error message.
					define_property(error, 'stack', {
						value: ''
					});
				}
				// Try and handle the error so it can be caught at a boundary, that's
				// if there's an effect available from when it was last scheduled
				if (last_scheduled_effect !== null) {
					{
						try {
							handle_error(error, last_scheduled_effect, null, null);
						} catch (e) {
							// Only log the effect stack if the error is re-thrown
							log_effect_stack();
							throw e;
						}
					}
				} else {
					{
						log_effect_stack();
					}
					throw error;
				}
			}
		}
		flush_count++;
	}

	/**
	 * @param {Array<Effect>} root_effects
	 * @returns {void}
	 */
	function flush_queued_root_effects(root_effects) {
		var length = root_effects.length;
		if (length === 0) {
			return;
		}
		infinite_loop_guard();

		var previously_flushing_effect = is_flushing_effect;
		is_flushing_effect = true;

		try {
			for (var i = 0; i < length; i++) {
				var effect = root_effects[i];

				if ((effect.f & CLEAN) === 0) {
					effect.f ^= CLEAN;
				}

				var collected_effects = process_effects(effect);
				flush_queued_effects(collected_effects);
			}
		} finally {
			is_flushing_effect = previously_flushing_effect;
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0) {
				try {
					if (check_dirtiness(effect)) {
						update_effect(effect);

						// Effects with no dependencies or teardown do not get added to the effect tree.
						// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
						// don't know if we need to keep them until they are executed. Doing the check
						// here (rather than in `update_effect`) allows us to skip the work for
						// immediate effects.
						if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
							if (effect.teardown === null) {
								// remove this effect from the graph
								unlink_effect(effect);
							} else {
								// keep the effect in the graph, but free up some memory
								effect.fn = null;
							}
						}
					}
				} catch (error) {
					handle_error(error, effect, null, effect.ctx);
				}
			}
		}
	}

	function process_deferred() {
		is_micro_task_queued = false;
		if (flush_count > 1001) {
			return;
		}
		const previous_queued_root_effects = queued_root_effects;
		queued_root_effects = [];
		flush_queued_root_effects(previous_queued_root_effects);

		if (!is_micro_task_queued) {
			flush_count = 0;
			last_scheduled_effect = null;
			{
				dev_effect_stack = [];
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		if (scheduler_mode === FLUSH_MICROTASK) {
			if (!is_micro_task_queued) {
				is_micro_task_queued = true;
				queueMicrotask(process_deferred);
			}
		}

		last_scheduled_effect = signal;

		var effect = signal;

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} effect
	 * @returns {Effect[]}
	 */
	function process_effects(effect) {
		/** @type {Effect[]} */
		var effects = [];

		var current_effect = effect.first;

		main_loop: while (current_effect !== null) {
			var flags = current_effect.f;
			var is_branch = (flags & BRANCH_EFFECT) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
			var sibling = current_effect.next;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & EFFECT) !== 0) {
					effects.push(current_effect);
				} else if (is_branch) {
					current_effect.f ^= CLEAN;
				} else {
					// Ensure we set the effect to be the active reaction
					// to ensure that unowned deriveds are correctly tracked
					// because we're flushing the current effect
					var previous_active_reaction = active_reaction;
					try {
						active_reaction = current_effect;
						if (check_dirtiness(current_effect)) {
							update_effect(current_effect);
						}
					} catch (error) {
						handle_error(error, current_effect, null, current_effect.ctx);
					} finally {
						active_reaction = previous_active_reaction;
					}
				}

				var child = current_effect.first;

				if (child !== null) {
					current_effect = child;
					continue;
				}
			}

			if (sibling === null) {
				let parent = current_effect.parent;

				while (parent !== null) {
					if (effect === parent) {
						break main_loop;
					}
					var parent_sibling = parent.next;
					if (parent_sibling !== null) {
						current_effect = parent_sibling;
						continue main_loop;
					}
					parent = parent.parent;
				}
			}

			current_effect = sibling;
		}

		return effects;
	}

	/**
	 * Internal version of `flushSync` with the option to not flush previous effects.
	 * Returns the result of the passed function, if given.
	 * @param {() => any} [fn]
	 * @returns {any}
	 */
	function flush_sync(fn) {
		var previous_scheduler_mode = scheduler_mode;
		var previous_queued_root_effects = queued_root_effects;

		try {
			infinite_loop_guard();

			/** @type {Effect[]} */
			const root_effects = [];

			scheduler_mode = FLUSH_SYNC;
			queued_root_effects = root_effects;
			is_micro_task_queued = false;

			flush_queued_root_effects(previous_queued_root_effects);

			var result = fn?.();

			flush_tasks();
			if (queued_root_effects.length > 0 || root_effects.length > 0) {
				flush_sync();
			}

			flush_count = 0;
			last_scheduled_effect = null;
			if (DEV) {
				dev_effect_stack = [];
			}

			return result;
		} finally {
			scheduler_mode = previous_scheduler_mode;
			queued_root_effects = previous_queued_root_effects;
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {
		await Promise.resolve();
		// By calling flush_sync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flush_sync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get$3(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			if (derived_sources !== null && derived_sources.includes(signal)) {
				state_unsafe_local_read();
			}
			var deps = active_reaction.deps;
			if (signal.rv < read_version) {
				signal.rv = read_version;
				// If the signal is accessing the same dependencies in the same
				// order as it did last time, increment `skipped_deps`
				// rather than updating `new_deps`, which creates GC cost
				if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
					skipped_deps++;
				} else if (new_deps === null) {
					new_deps = [signal];
				} else if (!skip_reaction || !new_deps.includes(signal)) {
					// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
					// an unowned derived because skip_reaction is true, then we need to ensure that
					// we don't have duplicates
					new_deps.push(signal);
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	const regex_return_characters = /\r/g;

	/**
	 * @param {string} str
	 * @returns {string}
	 */
	function hash(str) {
		str = str.replace(regex_return_characters, '');
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return (hash >>> 0).toString(36);
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject',
		novalidate: 'noValidate',
		allowfullscreen: 'allowFullscreen',
		disablepictureinpicture: 'disablePictureInPicture',
		disableremoteplayback: 'disableRemotePlayback'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** List of elements that require raw contents and should not have SSR comments put in them */
	const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);

	/** @param {string} name */
	function is_raw_text_element(name) {
		return RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name));
	}

	/**
	 * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
	 * @param {string | undefined} location
	 */
	function sanitize_location(location) {
		return location?.replace(/\//g, '/\u200b');
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	/**
	 * The child of a textarea actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLTextAreaElement} dom
	 * @returns {void}
	 */
	function remove_textarea_child(dom) {
		if (hydrating && get_first_child(dom) !== null) {
			clear_text_content(dom);
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { Location } from 'locate-character' */

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		// @ts-ignore
		if (dom === document.body || dom === window || dom === document) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated !== undefined &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {
			if (hydrating) {
				assign_nodes(hydrate_node, null);
				return hydrate_node;
			}

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text(value = '') {
		if (!hydrating) {
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}

		var node = hydrate_node;

		if (node.nodeType !== 3) {
			// if an {expression} is empty during SSR, we need to insert an empty text node
			node.before((node = create_text()));
			set_hydrate_node(node);
		}

		assign_nodes(node, node);
		return node;
	}

	function comment() {
		// we're not delegating to `template` here for performance reasons
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {
		if (hydrating) {
			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
			hydrate_next();
			return;
		}

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true — block effects should run their intro transitions —
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/** @param {boolean} value */
	function set_should_intro(value) {
		should_intro = value;
	}

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/**
	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {{} extends Props ? {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props?: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	} : {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	}} options
	 * @returns {Exports}
	 */
	function hydrate(component, options) {
		init_operations();
		options.intro = options.intro ?? false;
		const target = options.target;
		const was_hydrating = hydrating;
		const previous_hydrate_node = hydrate_node;

		try {
			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
			while (
				anchor &&
				(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
			) {
				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
			}

			if (!anchor) {
				throw HYDRATION_ERROR;
			}

			set_hydrating(true);
			set_hydrate_node(/** @type {Comment} */ (anchor));
			hydrate_next();

			const instance = _mount(component, { ...options, anchor });

			if (
				hydrate_node === null ||
				hydrate_node.nodeType !== 8 ||
				/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
			) {
				hydration_mismatch();
				throw HYDRATION_ERROR;
			}

			set_hydrating(false);

			return /**  @type {Exports} */ (instance);
		} catch (error) {
			if (error === HYDRATION_ERROR) {
				if (options.recover === false) {
					hydration_failed();
				}

				// If an error occured above, the operations might not yet have been initialised.
				init_operations();
				clear_text_content(target);

				set_hydrating(false);
				return mount(component, options);
			}

			throw error;
		} finally {
			set_hydrating(was_hydrating);
			set_hydrate_node(previous_hydrate_node);
		}
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}

				if (hydrating) {
					assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
				}

				should_intro = intro;
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};
				should_intro = true;

				if (hydrating) {
					/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
				}

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		{
			lifecycle_double_unmount();
		}

		return Promise.resolve();
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				const is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (!!condition === is_else) {
					// Hydration mismatch: remove everything inside the anchor and start fresh.
					// This could happen with `{#if browser}...{/if}`, for example
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else if (fn) {
					consequent_effect = branch(() => fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (fn) {
					alternate_effect = branch(() => fn(anchor));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * The row of a keyed each block that is currently updating. We track this
	 * so that `animate:` directives have something to attach themselves to
	 * @type {EachItem | null}
	 */
	let current_each_item = null;

	/** @param {EachItem | null} item */
	function set_current_each_item(item) {
		current_each_item = item;
	}

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index$d(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = hydrating
				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
				: parent_node.appendChild(create_text());
		}

		if (hydrating) {
			hydrate_next();
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		block(() => {
			var array = get$3(each_array);
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				var is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (is_else !== (length === 0)) {
					// hydration mismatch — remove the server-rendered DOM and start over
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			// this is separate to the previous block because `hydrating` might change
			if (hydrating) {
				/** @type {EachItem | null} */
				var prev = null;

				/** @type {EachItem} */
				var item;

				for (var i = 0; i < length; i++) {
					if (
						hydrate_node.nodeType === 8 &&
						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
					) {
						// The server rendered fewer items than expected,
						// so break out and continue appending non-hydrated items
						anchor = /** @type {Comment} */ (hydrate_node);
						mismatch = true;
						set_hydrating(false);
						break;
					}

					var value = array[i];
					var key = get_key(value, i);
					item = create_item(
						hydrate_node,
						state,
						prev,
						null,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
					state.items.set(key, item);

					prev = item;
				}

				// remove excess nodes
				if (length > 0) {
					set_hydrate_node(remove_nodes());
				}
			}

			if (!hydrating) {
				reconcile(array, state, anchor, render_fn, flags, get_key, get_collection);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get$3(each_array);
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags,
					get_collection
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection
	) {
		var previous_each_item = current_each_item;
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).debug = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		current_each_item = item;

		try {
			item.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
			current_each_item = previous_each_item;
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element} element
	 * @param {string | null} server_hash
	 * @param {string} value
	 */
	function check_hash(element, server_hash, value) {
		if (!server_hash || server_hash === hash(String(value ?? ''))) return;

		let location;

		// @ts-expect-error
		const loc = element.__svelte_meta?.loc;
		if (loc) {
			location = `near ${loc.file}:${loc.line}:${loc.column}`;
		} else if (dev_current_component_function?.[FILENAME]) {
			location = `in ${dev_current_component_function[FILENAME]}`;
		}

		hydration_html_changed(sanitize_location(location));
	}

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} svg
	 * @param {boolean} mathml
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg, mathml, skip_warning) {
		var anchor = node;

		var value = '';

		/** @type {Effect | undefined} */
		var effect;

		block(() => {
			if (value === (value = get_value() ?? '')) {
				if (hydrating) {
					hydrate_next();
				}
				return;
			}

			if (effect !== undefined) {
				destroy_effect(effect);
				effect = undefined;
			}

			if (value === '') return;

			effect = branch(() => {
				if (hydrating) {
					// We're deliberately not trying to repair mismatches between server and client,
					// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)
					var hash = /** @type {Comment} */ (hydrate_node).data;
					var next = hydrate_next();
					var last = next;

					while (
						next !== null &&
						(next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')
					) {
						last = next;
						next = /** @type {TemplateNode} */ (get_next_sibling(next));
					}

					if (next === null) {
						hydration_mismatch();
						throw HYDRATION_ERROR;
					}

					{
						check_hash(/** @type {Element} */ (next.parentNode), hash, value);
					}

					assign_nodes(hydrate_node, last);
					anchor = set_hydrate_node(next);
					return;
				}

				var html = value + '';

				// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
				// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
				/** @type {DocumentFragment | Element} */
				var node = create_fragment_from_html(html);

				assign_nodes(
					/** @type {TemplateNode} */ (get_first_child(node)),
					/** @type {TemplateNode} */ (node.lastChild)
				);

				{
					anchor.before(node);
				}
			});
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props[name === 'default' ? 'children' : name];
			is_interop = true;
		}

		if (slot_fn === undefined) {
			if (fallback_fn !== null) {
				fallback_fn(anchor);
			}
		} else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var anchor = node;

		/** @type {SnippetFn | null | undefined} */
		// @ts-ignore
		var snippet = noop;

		/** @type {Effect | null} */
		var snippet_effect;

		block(() => {
			if (snippet === (snippet = get_snippet())) return;

			if (snippet_effect) {
				destroy_effect(snippet_effect);
				snippet_effect = null;
			}

			if (snippet == null) {
				invalid_snippet();
			}

			snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Create a snippet programmatically
	 * @template {unknown[]} Params
	 * @param {(...params: Getters<Params>) => {
	 *   render: () => string
	 *   setup?: (element: Element) => void | (() => void)
	 * }} fn
	 * @returns {Snippet<Params>}
	 */
	function createRawSnippet(fn) {
		// @ts-expect-error the types are a lie
		return (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {
			var snippet = fn(...params);

			/** @type {Element} */
			var element;

			if (hydrating) {
				element = /** @type {Element} */ (hydrate_node);
				hydrate_next();
			} else {
				var html = snippet.render().trim();
				var fragment = create_fragment_from_html(html);
				element = /** @type {Element} */ (get_first_child(fragment));

				if ((get_next_sibling(element) !== null || element.nodeType !== 1)) {
					invalid_raw_snippet_render();
				}

				anchor.before(element);
			}

			const result = snippet.setup?.(element);
			assign_nodes(element, element);

			if (typeof result === 'function') {
				teardown(result);
			}
		};
	}

	/** @import { TemplateNode, Dom, Effect } from '#client' */

	/**
	 * @template P
	 * @template {(props: P) => void} C
	 * @param {TemplateNode} node
	 * @param {() => C} get_component
	 * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn
	 * @returns {void}
	 */
	function component(node, get_component, render_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {C} */
		var component;

		/** @type {Effect | null} */
		var effect;

		block(() => {
			if (component === (component = get_component())) return;

			if (effect) {
				pause_effect(effect);
				effect = null;
			}

			if (component) {
				effect = branch(() => render_fn(anchor, component));
			}
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
		let was_hydrating = hydrating;

		if (hydrating) {
			hydrate_next();
		}

		/** @type {string | null} */
		var tag;

		/** @type {string | null} */
		var current_tag;

		/** @type {null | Element} */
		var element = null;

		if (hydrating && hydrate_node.nodeType === 1) {
			element = /** @type {Element} */ (hydrate_node);
			hydrate_next();
		}

		var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);

		/** @type {Effect | null} */
		var effect;

		/**
		 * The keyed `{#each ...}` item block, if any, that this element is inside.
		 * We track this so we can set it when changing the element, allowing any
		 * `animate:` directive to bind itself to the correct block
		 */
		var each_item_block = current_each_item;

		block(() => {
			const next_tag = get_tag() || null;
			var ns = next_tag === 'svg' ? NAMESPACE_SVG : null;

			// Assumption: Noone changes the namespace but not the tag (what would that even mean?)
			if (next_tag === tag) return;

			// See explanation of `each_item_block` above
			var previous_each_item = current_each_item;
			set_current_each_item(each_item_block);

			if (effect) {
				if (next_tag === null) {
					// start outro
					pause_effect(effect, () => {
						effect = null;
						current_tag = null;
					});
				} else if (next_tag === current_tag) {
					// same tag as is currently rendered — abort outro
					resume_effect(effect);
				} else {
					// tag is changing — destroy immediately, render contents without intro transitions
					destroy_effect(effect);
					set_should_intro(false);
				}
			}

			if (next_tag && next_tag !== current_tag) {
				effect = branch(() => {
					element = hydrating
						? /** @type {Element} */ (element)
						: ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					assign_nodes(element, element);

					if (render_fn) {
						if (hydrating && is_raw_text_element(next_tag)) {
							// prevent hydration glitches
							element.append(document.createComment(''));
						}

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							hydrating ? get_first_child(element) : element.appendChild(create_text())
						);

						if (hydrating) {
							if (child_anchor === null) {
								set_hydrating(false);
							} else {
								set_hydrate_node(child_anchor);
							}
						}

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				});
			}

			tag = next_tag;
			if (tag) current_tag = tag;
			set_should_intro(true);

			set_current_each_item(previous_each_item);
		}, EFFECT_TRANSPARENT);

		if (was_hydrating) {
			set_hydrating(true);
			set_hydrate_node(anchor);
		}
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	/**
	 * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLInputElement} input
	 * @returns {void}
	 */
	function remove_input_defaults(input) {
		if (!hydrating) return;

		var already_removed = false;

		// We try and remove the default attributes later, rather than sync during hydration.
		// Doing it sync during hydration has a negative impact on performance, but deferring the
		// work in an idle task alleviates this greatly. If a form reset event comes in before
		// the idle callback, then we ensure the input defaults are cleared just before.
		var remove_defaults = () => {
			if (already_removed) return;
			already_removed = true;

			// Remove the attributes but preserve the values
			if (input.hasAttribute('value')) {
				var value = input.value;
				set_attribute(input, 'value', null);
				input.value = value;
			}

			if (input.hasAttribute('checked')) {
				var checked = input.checked;
				set_attribute(input, 'checked', null);
				input.checked = checked;
			}
		};

		// @ts-expect-error
		input.__on_r = remove_defaults;
		queue_idle_task(remove_defaults);
		add_form_reset_listener();
	}

	/**
	 * @param {Element} element
	 * @param {any} value
	 */
	function set_value(element, value) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (
			attributes.value ===
				(attributes.value =
					// treat null and undefined the same for the initial value
					value ?? undefined) ||
			// @ts-expect-error
			// `progress` elements always need their value set when it's `0`
			(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))
		) {
			return;
		}

		// @ts-expect-error
		element.value = value ?? '';
	}

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (hydrating) {
			attributes[attribute] = element.getAttribute(attribute);

			if (
				attribute === 'src' ||
				attribute === 'srcset' ||
				(attribute === 'href' && element.nodeName === 'LINK')
			) {
				{
					check_src_in_dev_hydration(element, attribute, value ?? '');
				}

				// If we reset these attributes, they would result in another network request, which we want to avoid.
				// We assume they are the same between client and server as checking if they are equal is expensive
				// (we can't just compare the strings as they can be different between client and server but result in the
				// same url, so we would need to create hidden anchor elements to compare them)
				return;
			}
		}

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'style' && '__styles' in element) {
			// reset styles to force style: directive to update
			element.__styles = {};
		}

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string, any> | undefined} prev
	 * @param {Record<string, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [preserve_attribute_case]
	 * @param {boolean} [is_custom_element]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		preserve_attribute_case = false,
		is_custom_element = false,
		skip_warning = false
	) {
		// If we're hydrating but the custom element is from Svelte, and it already scaffolded,
		// then it might run block logic in hydration mode, which we have to prevent.
		let is_hydrating_custom_element = hydrating && is_custom_element;
		if (is_hydrating_custom_element) {
			set_hydrating(false);
		}

		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		}

		if (css_hash !== undefined) {
			next.class = next.class ? next.class + ' ' + css_hash : css_hash;
		}

		var setters = get_setters(element);

		// @ts-expect-error
		var attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			var prev_value = current[key];
			if (value === prev_value) continue;

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style' && value != null) {
				element.style.cssText = value + '';
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {
				// @ts-ignore We're not running this for custom elements because __value is actually
				// how Lit stores the current value on the element, and messing with that would break things.
				element.value = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked — preserve
						let input = /** @type {HTMLInputElement} */ (element);
						const use_default = prev === undefined;
						if (name === 'value') {
							let previous = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = previous;
							// @ts-ignore
							input.value = input.__value = use_default ? previous : null;
						} else {
							let previous = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = previous;
							input.checked = use_default ? previous : false;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
				} else if (typeof value !== 'function') {
					set_attribute(element, name, value);
				}
			}
			if (key === 'style' && '__styles' in element) {
				// reset styles to force style: directive to update
				element.__styles = {};
			}
		}

		if (is_hydrating_custom_element) {
			set_hydrating(true);
		}

		return current;
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {any} element
	 * @param {string} attribute
	 * @param {string} value
	 */
	function check_src_in_dev_hydration(element, attribute, value) {
		if (attribute === 'srcset' && srcset_url_equal(element, value)) return;
		if (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;

		hydration_attribute_changed(
			attribute,
			element.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),
			String(value)
		);
	}

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
	}

	/** @param {string} srcset */
	function split_srcset(srcset) {
		return srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));
	}

	/**
	 * @param {HTMLSourceElement | HTMLImageElement} element
	 * @param {string} srcset
	 * @returns {boolean}
	 */
	function srcset_url_equal(element, srcset) {
		var element_urls = split_srcset(element.srcset);
		var urls = split_srcset(srcset);

		return (
			urls.length === element_urls.length &&
			urls.every(
				([url, width], i) =>
					width === element_urls[i][1] &&
					// We need to test both ways because Vite will create an a full URL with
					// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
					// relative URLs inside srcset are not automatically resolved to absolute URLs by
					// browsers (in contrast to img.src). This means both SSR and DOM code could
					// contain relative or absolute URLs.
					(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
			)
		);
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {string} value
	 * @param {string} [hash]
	 * @returns {void}
	 */
	function set_class(dom, value, hash) {
		// @ts-expect-error need to add __className to patched prototype
		var prev_class_name = dom.__className;
		var next_class_name = to_class(value, hash);

		if (hydrating && dom.className === next_class_name) {
			// In case of hydration don't reset the class as it's already correct.
			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		} else if (
			prev_class_name !== next_class_name ||
			(hydrating && dom.className !== next_class_name)
		) {
			// Removing the attribute when the value is only an empty string causes
			// peformance issues vs simply making the className an empty string. So
			// we should only remove the class if the the value is nullish.
			if (value == null && !hash) {
				dom.removeAttribute('class');
			} else {
				dom.className = next_class_name;
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		}
	}

	/**
	 * @template V
	 * @param {V} value
	 * @param {string} [hash]
	 * @returns {string | V}
	 */
	function to_class(value, hash) {
		return (value == null ? '' : value) + (hash ? ' ' + hash : '');
	}

	/**
	 * @param {Element} dom
	 * @param {string} class_name
	 * @param {boolean} value
	 * @returns {void}
	 */
	function toggle_class(dom, class_name, value) {
		if (value) {
			if (dom.classList.contains(class_name)) return;
			dom.classList.add(class_name);
		} else {
			if (!dom.classList.contains(class_name)) return;
			dom.classList.remove(class_name);
		}
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @returns {void}
	 */
	function run_tasks() {
		// use `raf.now()` instead of the `requestAnimationFrame` callback argument, because
		// otherwise things can get wonky https://github.com/sveltejs/svelte/pull/14541
		const now = raf.now();

		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		without_reactive_context(() => {
			element.dispatchEvent(new CustomEvent(type));
		});
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear$1 = (t) => t;

	/**
	 * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager
	 * and attaches it to the block, so that moves can be animated following reconciliation.
	 * @template P
	 * @param {Element} element
	 * @param {() => AnimateFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 */
	function animation(element, get_fn, get_params) {
		var item = /** @type {EachItem} */ (current_each_item);

		/** @type {DOMRect} */
		var from;

		/** @type {DOMRect} */
		var to;

		/** @type {Animation | undefined} */
		var animation;

		/** @type {null | { position: string, width: string, height: string, transform: string }} */
		var original_styles = null;

		item.a ??= {
			element,
			measure() {
				from = this.element.getBoundingClientRect();
			},
			apply() {
				animation?.abort();

				to = this.element.getBoundingClientRect();

				if (
					from.left !== to.left ||
					from.right !== to.right ||
					from.top !== to.top ||
					from.bottom !== to.bottom
				) {
					const options = get_fn()(this.element, { from, to }, get_params?.());

					animation = animate(this.element, options, undefined, 1, () => {
						animation?.abort();
						animation = undefined;
					});
				}
			},
			fix() {
				// If an animation is already running, transforming the element is likely to fail,
				// because the styles applied by the animation take precedence. In the case of crossfade,
				// that means the `translate(...)` of the crossfade transition overrules the `translate(...)`
				// we would apply below, leading to the element jumping somewhere to the top left.
				if (element.getAnimations().length) return;

				// It's important to destructure these to get fixed values - the object itself has getters,
				// and changing the style to 'absolute' can for example influence the width.
				var { position, width, height } = getComputedStyle(element);

				if (position !== 'absolute' && position !== 'fixed') {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					original_styles = {
						position: style.position,
						width: style.width,
						height: style.height,
						transform: style.transform
					};

					style.position = 'absolute';
					style.width = width;
					style.height = height;
					var to = element.getBoundingClientRect();

					if (from.left !== to.left || from.top !== to.top) {
						var transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`;
						style.transform = style.transform ? `${style.transform} ${transform}` : transform;
					}
				}
			},
			unfix() {
				if (original_styles) {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					style.position = original_styles.position;
					style.width = original_styles.width;
					style.height = original_styles.height;
					style.transform = original_styles.transform;
				}
			}
		};

		// in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called
		// when an animation manager already exists, if the tag changes. in that case, we need to
		// swap out the element rather than creating a new manager, in case it happened at the same
		// moment as a reconciliation
		item.a.element = element;
	}

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = 'both' ;

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/**
		 * The default overflow style, stashed so we can revert changes during the transition
		 * that are necessary to work around a Safari <18 bug
		 * TODO 6.0 remove this, if older versions of Safari have died out enough
		 */
		var overflow = element.style.overflow;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			var previous_reaction = active_reaction;
			var previous_effect = active_effect;
			set_active_reaction(null);
			set_active_effect(null);
			try {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			} finally {
				set_active_reaction(previous_reaction);
				set_active_effect(previous_effect);
			}
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;

					element.style.overflow = overflow;
				});
			},
			out(fn) {

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value — `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear$1 } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		var animation = element.animate(keyframes, { duration: delay });

		animation.onfinish = () => {
			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				/**
				 * Whether or not the CSS includes `overflow: hidden`, in which case we need to
				 * add it as an inline style to work around a Safari <18 bug
				 * TODO 6.0 remove this, if possible
				 */
				var needs_overflow_hidden = false;

				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css_to_keyframe(css(t, 1 - t));
						keyframes.push(styles);

						needs_overflow_hidden ||= styles.overflow === 'hidden';
					}
				}

				if (needs_overflow_hidden) {
					/** @type {HTMLElement} */ (element).style.overflow = 'hidden';
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var runes = is_runes();

		listen_to_event_and_reset_event(input, 'input', (is_reset) => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,
			// because we use mutable state which ensures the render effect always runs)
			if (runes && value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			(hydrating && input.defaultValue !== input.value) ||
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);
		}

		render_effect(() => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			var value = get();

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			(hydrating && input.defaultChecked !== input.checked) ||
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Makes an `export`ed (non-prop) variable available on the `$$props` object
	 * so that consumers can do `bind:x` on the component.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} prop
	 * @param {V} value
	 * @returns {void}
	 */
	function bind_prop(props, prop, value) {
		var desc = get_descriptor(props, prop);

		if (desc && desc.set) {
			props[prop] = value;
			teardown(() => {
				props[prop] = null;
			});
		}
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} [mounting]
	 */
	function select_option(select, value, mounting) {
		if (select.multiple) {
			return select_options(select, value);
		}

		for (var option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {() => V} [get_value]
	 */
	function init_select(select, get_value) {
		let mounting = true;
		effect(() => {
			if (get_value) {
				select_option(select, untrack(get_value), mounting);
			}
			mounting = false;

			var observer = new MutationObserver(() => {
				// @ts-ignore
				var value = select.__value;
				select_option(select, value);
				// Deliberately don't update the potential binding value,
				// the model should be preserved unless explicitly changed
			});

			observer.observe(select, {
				// Listen to option element changes
				childList: true,
				subtree: true, // because of <optgroup>
				// Listen to option element value attribute changes
				// (doesn't get notified of select value changes,
				// because that property is not reflected as an attribute)
				attributes: true,
				attributeFilter: ['value']
			});

			return () => {
				observer.disconnect();
			};
		});
	}

	/**
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 */
	function select_options(select, value) {
		for (var option of select.options) {
			// @ts-ignore
			option.selected = ~value.indexOf(get_option_value(option));
		}
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = get_parts?.() || [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/** @import { ActionReturn } from 'svelte/action' */

	/**
	 * Substitute for the `preventDefault` event modifier
	 * @deprecated
	 * @param {(event: Event, ...args: Array<unknown>) => void} fn
	 * @returns {(event: Event, ...args: unknown[]) => void}
	 */
	function preventDefault(fn) {
		return function (...args) {
			var event = /** @type {Event} */ (args[0]);
			event.preventDefault();
			// @ts-ignore
			return fn?.apply(this, args);
		};
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get$3(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get$3(signal);
		}

		props();
	}

	/**
	 * @this {any}
	 * @param {Record<string, unknown>} $$props
	 * @param {Event} event
	 * @returns {void}
	 */
	function bubble_event($$props, event) {
		var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[
			event.type
		];

		var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];

		for (var fn of callbacks) {
			// Preserve "this" context
			fn.call(this, event);
		}
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * @template T
	 * @param {Readable<T>} store
	 * @returns {T}
	 */
	function get$2(store) {
		let value;
		subscribe_to_store(store, (_) => (value = _))();
		// @ts-expect-error
		return value;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	let IS_UNMOUNTED = Symbol();

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		// if the component that setup this is already unmounted we don't want to register a subscription
		if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		// if the component that setup this stores is already unmounted the source will be out of sync
		// so we just use the `get` for the stores, less performant but it avoids to create a memory leak
		// and it will keep the value consistent
		if (store && IS_UNMOUNTED in stores) {
			return get$2(store);
		}

		return get$3(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {[StoreReferencesContainer, ()=>void]}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		function cleanup() {
			teardown(() => {
				for (var store_name in stores) {
					const ref = stores[store_name];
					ref.unsubscribe();
				}
				define_property(stores, IS_UNMOUNTED, {
					enumerable: false,
					value: true
				});
			});
		}

		return [stores, cleanup];
	}

	/**
	 * Updates a store with a new value.
	 * @param {Store<V>} store  the store to update
	 * @param {any} expression  the expression that mutates the store
	 * @param {V} new_value  the new store value
	 * @template V
	 */
	function store_mutate(store, expression, new_value) {
		store.set(new_value);
		return expression;
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Source } from './types.js' */

	/**
	 * @param {((value?: number) => number)} fn
	 * @param {1 | -1} [d]
	 * @returns {number}
	 */
	function update_prop(fn, d = 1) {
		const value = fn();
		fn(value + d);
		return value;
	}

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {
			{
				// TODO should this happen in prod too?
				props_rest_readonly(`${target.name}.${String(key)}`);
			}

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			{ props, exclude, name, other: {}, to_proxy: [] } ,
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for legacy $$restProps and $$props
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}
	 */
	const legacy_rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			get$3(target.version);
			return key in target.special ? target.special[key]() : target.props[key];
		},
		set(target, key, value) {
			if (!(key in target.special)) {
				// Handle props that can temporarily get out of sync with the parent
				/** @type {Record<string, (v?: unknown) => unknown>} */
				target.special[key] = prop(
					{
						get [key]() {
							return target.props[key];
						}
					},
					/** @type {string} */ (key),
					PROPS_IS_UPDATED
				);
			}

			target.special[key](value);
			update(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun
			return true;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		deleteProperty(target, key) {
			// Svelte 4 allowed for deletions on $$restProps
			if (target.exclude.includes(key)) return true;
			target.exclude.push(key);
			update(target.version);
			return true;
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @returns {Record<string, unknown>}
	 */
	function legacy_rest_props(props, exclude) {
		return new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @template {Record<string | symbol, unknown>} T
	 * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
		var is_store_sub = false;
		var prop_value;

		if (bindable) {
			[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			prop_value = /** @type {V} */ (props[key]);
		}

		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

		var setter =
			(bindable &&
				(get_descriptor(props, key)?.set ??
					(is_entry_props && key in props && ((v) => (props[key] = v))))) ||
			undefined;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;
		var fallback_used = false;

		var get_fallback = () => {
			fallback_used = true;
			if (fallback_dirty) {
				fallback_dirty = false;
				if (lazy) {
					fallback_value = untrack(/** @type {() => V} */ (fallback));
				} else {
					fallback_value = /** @type {V} */ (fallback);
				}
			}

			return fallback_value;
		};

		if (prop_value === undefined && fallback !== undefined) {
			if (setter && runes) {
				props_invalid_value(key);
			}

			prop_value = get_fallback();
			if (setter) setter(prop_value);
		}

		/** @type {() => V} */
		var getter;
		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				fallback_used = false;
				return value;
			};
		} else {
			// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
			// Replicate that behavior through using a derived
			var derived_getter = (immutable ? derived : derived_safe_equal)(
				() => /** @type {V} */ (props[key])
			);
			derived_getter.f |= LEGACY_DERIVED_PROP;
			getter = () => {
				var value = get$3(derived_getter);
				if (value !== undefined) fallback_value = /** @type {V} */ (undefined);
				return value === undefined ? fallback_value : value;
			};
		}

		// easy mode — prop is never written to
		if ((flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// intermediate mode — prop is written to, but the parent component had
		// `bind:foo` which means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					// We don't want to notify if the value was mutated and the parent is in runes mode.
					// In that case the state proxy (if it exists) should take care of the notification.
					// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
					// has changed because the parent will not be able to detect the change otherwise.
					if (!runes || !mutation || legacy_parent || is_store_sub) {
						/** @type {Function} */ (setter)(mutation ? getter() : value);
					}
					return value;
				} else {
					return getter();
				}
			};
		}

		// hard mode. this is where it gets ugly — the value in the child should
		// synchronize with the parent, but it should also be possible to temporarily
		// set the value to something else locally.
		var from_child = false;

		// The derived returns the current value. The underlying mutable
		// source is written to from various places to persist this value.
		var inner_current_value = mutable_source(prop_value);
		var current_value = derived(() => {
			var parent_value = getter();
			var child_value = get$3(inner_current_value);

			if (from_child) {
				from_child = false;
				return child_value;
			}
			return (inner_current_value.v = parent_value);
		});

		if (!immutable) current_value.equals = safe_equals;

		return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {

			if (arguments.length > 0) {
				const new_value = mutation ? get$3(current_value) : runes && bindable ? proxy(value) : value;

				if (!current_value.equals(new_value)) {
					from_child = true;
					set(inner_current_value, new_value);
					// To ensure the fallback value is consistent when used with proxies, we
					// update the local fallback_value, but only if the fallback is actively used
					if (fallback_used && fallback_value !== undefined) {
						fallback_value = new_value;
					}
					untrack(() => get$3(current_value)); // force a synchronisation immediately
				}

				return value;
			}
			return get$3(current_value);
		};
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	{
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside [server-side components](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onMount');
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onDestroy');
		}

		onMount(() => () => untrack(fn));
	}

	/**
	 * @template [T=any]
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {any}params_0
	 * @returns {CustomEvent<T>}
	 */
	function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events)
	 * @template {Record<string, any>} [EventMap = any]
	 * @returns {EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const active_component_context = component_context;
		if (active_component_context === null) {
			lifecycle_outside_component('createEventDispatcher');
		}

		return (type, detail, options) => {
			const events = /** @type {Record<string, Function | Function[]>} */ (
				active_component_context.s.$$events
			)?.[/** @type {any} */ (type)];

			if (events) {
				const callbacks = is_array(events) ? events.slice() : [events];
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = create_custom_event(/** @type {string} */ (type), detail, options);
				for (const fn of callbacks) {
					fn.call(active_component_context.x, event);
				}
				return !event.defaultPrevented;
			}

			return true;
		};
	}

	// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`.
	 *
	 * In runes mode use `$effect.pre` instead.
	 *
	 * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('beforeUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('beforeUpdate');
		}

		init_update_callbacks(component_context).b.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`.
	 *
	 * In runes mode use `$effect` instead.
	 *
	 * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('afterUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('afterUpdate');
		}

		init_update_callbacks(component_context).a.push(fn);
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/**
	 * Synchronously flushes any pending state changes and those that result from it.
	 * @param {() => void} [fn]
	 * @returns {void}
	 */
	function flushSync(fn) {
		flush_sync(fn);
	}

	var indexClient = /*#__PURE__*/Object.freeze({
		__proto__: null,
		afterUpdate: afterUpdate,
		beforeUpdate: beforeUpdate,
		createEventDispatcher: createEventDispatcher,
		createRawSnippet: createRawSnippet,
		flushSync: flushSync,
		getAllContexts: getAllContexts,
		getContext: getContext,
		hasContext: hasContext,
		hydrate: hydrate,
		mount: mount,
		onDestroy: onDestroy,
		onMount: onMount,
		setContext: setContext,
		tick: tick,
		unmount: unmount,
		untrack: untrack
	});

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);

	function _assertClassBrand(e, t, n) {
	  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
	  throw new TypeError("Private element is not present on this object");
	}
	function _assertThisInitialized(e) {
	  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  return e;
	}
	function _callSuper(t, o, e) {
	  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
	}
	function _checkPrivateRedeclaration(e, t) {
	  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	function _classCallCheck(a, n) {
	  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}
	function _classPrivateFieldGet2(s, a) {
	  return s.get(_assertClassBrand(s, a));
	}
	function _classPrivateFieldInitSpec(e, t, a) {
	  _checkPrivateRedeclaration(e, t), t.set(e, a);
	}
	function _classPrivateFieldSet2(s, a, r) {
	  return s.set(_assertClassBrand(s, a), r), r;
	}
	function _classPrivateMethodInitSpec(e, a) {
	  _checkPrivateRedeclaration(e, a), a.add(e);
	}
	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: false
	  }), e;
	}
	function _defineProperty(e, r, t) {
	  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: true,
	    configurable: true,
	    writable: true
	  }) : e[r] = t, e;
	}
	function _getPrototypeOf(t) {
	  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
	    return t.__proto__ || Object.getPrototypeOf(t);
	  }, _getPrototypeOf(t);
	}
	function _inherits(t, e) {
	  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	  t.prototype = Object.create(e && e.prototype, {
	    constructor: {
	      value: t,
	      writable: true,
	      configurable: true
	    }
	  }), Object.defineProperty(t, "prototype", {
	    writable: false
	  }), e && _setPrototypeOf(t, e);
	}
	function _isNativeReflectConstruct() {
	  try {
	    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	  } catch (t) {}
	  return (_isNativeReflectConstruct = function () {
	    return !!t;
	  })();
	}
	function _possibleConstructorReturn(t, e) {
	  if (e && ("object" == typeof e || "function" == typeof e)) return e;
	  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	  return _assertThisInitialized(t);
	}
	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}

	const inputValuesExtractors = Object.freeze({
	  checkbox: function (inpEl, defaultValue = undefined) {
	    if (typeof defaultValue == "object" && Object.hasOwn(defaultValue, "checked") && Object.hasOwn(defaultValue, "unchecked")) {
	      return inpEl.checked ? defaultValue.checked : defaultValue.unchecked;
	    } else if (Object.hasOwn(inpEl, "value") && typeof inpEl.value !== "undefined") {
	      return inpEl.checked ? inpEl.value : false;
	    } else {
	      return inpEl.checked;
	    }
	  }
	});

	/**
	 * Collection of common to UI functions and properties
	 *
	 * @class UICommon
	 */
	let UICommon$1 = /*#__PURE__*/function () {
	  function UICommon() {
	    _classCallCheck(this, UICommon);
	  }
	  return _createClass(UICommon, null, [{
	    key: "inputValuesExtractors",
	    get: function () {
	      return inputValuesExtractors;
	    }
	  }, {
	    key: "extractValueFromInput",
	    value: function extractValueFromInput(inpEl, defaultValue = undefined) {
	      if (!inpEl) return defaultValue;
	      if (Object.hasOwn(UICommon.inputValuesExtractors, inpEl.type)) {
	        return UICommon.inputValuesExtractors[inpEl.type](inpEl, defaultValue);
	      }
	      return inpEl.value;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string}      field    field name
	     * @param {import('./events.types').UIEventInputChangeCallback}    onchange
	     * @param {any}         [defaultValue=undefined]
	     * @param {object}      [additional = {}]
	     * @return {import('./events.types').UIEventCallback}
	     * @memberof UICommon
	     */
	  }, {
	    key: "onInput",
	    value: function onInput(field, onchange, defaultValue = undefined, additional = {}) {
	      if (typeof onchange !== "function") {
	        return undefined;
	      }
	      return function (event) {
	        typeof event?.preventDefault === "function" && event?.preventDefault();
	        const value = UICommon.extractValueFromInput(event?.currentTarget, defaultValue);
	        return onchange({
	          field,
	          value
	        }, event, additional);
	      };
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {KeyboardEvent} e
	     * @memberof UICommon
	     */
	  }, {
	    key: "isEnterEvent",
	    value: function isEnterEvent(e) {
	      return e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.shiftKey;
	    }
	  }, {
	    key: "onlyOnEnter",
	    value: function onlyOnEnter(callback) {
	      return function (e) {
	        if (UICommon.isEnterEvent(e)) {
	          return callback(e);
	        } else {
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "isMobile",
	    value: function isMobile() {
	      const testMobile = window.matchMedia || window.msMatchMedia;
	      if (testMobile) {
	        let testQuery = "(pointer:coarse)";
	        if (arguments.length) {
	          const max_width = typeof arguments[0] === "boolean" ? this.MOBILE_WIDTH_BREAK_POINT : arguments[0];
	          testQuery = `only screen and (max-width: ${max_width}px)`;
	        }
	        return testMobile(testQuery).matches;
	      }
	      return false;
	    }
	  }, {
	    key: "removeBodyScroll",
	    value: function removeBodyScroll() {
	      document.body.classList.add(this.SCROLL_DISABLER_CLASS);
	    }
	  }, {
	    key: "restoreBodyScroll",
	    value: function restoreBodyScroll() {
	      document.body.classList.remove(this.SCROLL_DISABLER_CLASS);
	    }

	    /**
	     *  Reformats input from any string to strict phone format
	     *  @param {string}    val    free style phone number
	     *  @param {string}    [filler=UICommon.FILLER]    free style phone number
	     *  @returns {string}          phone number
	     **/
	  }, {
	    key: "formatPhone",
	    value: function formatPhone(val, filler = this.FILLER) {
	      //starting from 11 digits in phone number
	      const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];
	      let digits = val.replace(/\D/g, "");
	      //if there are more, move them to country code slot
	      if (digits.length > 11) {
	        let d = digits.length - 11;
	        while (d > 0) {
	          d--;
	          slots.unshift(1);
	        }
	      }
	      let stack = ["", "", "", "", ""];
	      Array.from(digits).forEach(function (digit, index) {
	        let slot = slots[index];
	        stack[slot - 1] = stack[slot - 1] + digit;
	      });
	      //creating map of parts lengths
	      const lens = slots.reduce(function (acc, curr) {
	        if (typeof acc[curr] === "undefined") {
	          acc[curr] = 1;
	        } else {
	          acc[curr] += 1;
	        }
	        return acc;
	      }, {});
	      //fill empty positions with filler (_)
	      for (let t in stack) {
	        let dif = lens[parseInt(t) + 1] - stack[t].length;
	        while (dif > 0) {
	          stack[t] = stack[t] + filler;
	          dif--;
	        }
	      }
	      return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;
	    }
	  }, {
	    key: "setMoneySign",
	    value: function setMoneySign(val) {
	      this.MONEY_SIGN = val;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {number} price
	     * @return {string}
	     * @memberof UICommon
	     */
	  }, {
	    key: "formatPrice",
	    value: function formatPrice(price) {
	      let major = Math.floor(price / 100),
	        minor = price % 100;
	      return `${this.MONEY_SIGN}${major.toString()}.${minor.toString()}`;
	    }
	  }, {
	    key: "formatLocaleDatetime",
	    value: function formatLocaleDatetime(dt, opts = {
	      date: true,
	      time: true
	    }) {
	      const date = dt.toLocaleDateString(window.navigator.language);
	      const time = dt.toLocaleTimeString(window.navigator.language);
	      if (opts.date && opts.time) {
	        return `${date} ${time}`;
	      } else if (opts.date && !opts.time) {
	        return date;
	      } else {
	        return time;
	      }
	    }
	  }, {
	    key: "tryFormatLocaleDateTime",
	    value: function tryFormatLocaleDateTime(value, opts = {
	      date: true,
	      time: true
	    }) {
	      if (typeof value == "string" || typeof value == "number") {
	        const dt = new Date(value);
	        return UICommon.formatLocaleDatetime(dt, opts);
	      } else if (typeof value == "object") {
	        return UICommon.formatLocaleDatetime(value, opts);
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "formatTimestamp",
	    value: function formatTimestamp(timestamp, offset = 0) {
	      let offsetLocal = new Date().getTimezoneOffset();
	      let deltaOffset = (offsetLocal - offset) * 60 * 1000;
	      let localDateTime = new Date(parseInt(timestamp) - deltaOffset);
	      return localDateTime.toLocaleString(window.navigator.language);
	    }
	  }, {
	    key: "declOfNum",
	    value: function declOfNum(n, text_forms) {
	      n = Math.abs(n) % 100;
	      let n1 = n % 10;
	      if (n > 10 && n < 20) {
	        return text_forms[2];
	      }
	      if (n1 > 1 && n1 < 5) {
	        return text_forms[1];
	      }
	      if (n1 == 1) {
	        return text_forms[0];
	      }
	      return text_forms[2];
	    }
	  }, {
	    key: "humanizedTimeDiff",
	    value: function humanizedTimeDiff(date /* unix time */) {
	      let currentTime = new Date().getTime();
	      let sec = Math.round((currentTime - date) / 1000);
	      let unit;
	      if (sec < 60) {
	        unit = this.declOfNum(sec, this.TIME.SECONDS);
	        return `${sec} ${unit} назад`;
	      } else if (sec < 3600) {
	        let min = Math.floor(sec / 60);
	        unit = this.declOfNum(min, this.TIME.MINUTES);
	        return `${min} ${unit} назад`;
	      } else {
	        let hours = Math.floor(sec / (60 * 60));
	        unit = this.declOfNum(hours, this.TIME.HOURS);
	        return `${hours} ${unit} назад`;
	      }
	    }
	  }, {
	    key: "stylesObjectToString",
	    value: function stylesObjectToString(styles = {}) {
	      if (typeof styles === "object") {
	        Object.keys(styles).map(function (prop) {
	          return `${prop}: ${styles.prop};`;
	        }).join("");
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "stringOrNumber",
	    value: function stringOrNumber(val) {
	      return ["string", "number"].indexOf(typeof val) > -1;
	    }
	  }, {
	    key: "stringsOfNumbers",
	    value: function stringsOfNumbers(list) {
	      return list.every(this.stringOrNumber);
	    }
	  }]);
	}();
	_defineProperty(UICommon$1, "CLEAR_MACRO", "__CLEAR__");
	_defineProperty(UICommon$1, "ERROR_DEFAULT", "Что пошло не так.");
	_defineProperty(UICommon$1, "DEFAULT_REDIRECT_TIMEOUT", 3000);
	_defineProperty(UICommon$1, "CLASS_OK", "is-success");
	_defineProperty(UICommon$1, "CLASS_ERR", "is-danger");
	_defineProperty(UICommon$1, "SCROLL_DISABLER_CLASS", "remove-scroll");
	_defineProperty(UICommon$1, "FILLER", "_");
	_defineProperty(UICommon$1, "SCROLL_OPTIONS", {
	  top: 0,
	  behavior: "smooth"
	});
	_defineProperty(UICommon$1, "MOBILE_WIDTH_BREAK_POINT", 760);
	_defineProperty(UICommon$1, "MONEY_SIGN", "&#8381;");
	_defineProperty(UICommon$1, "TIME", {
	  SECONDS: ["секунду", "секунды", "секунд"],
	  MINUTES: ["минуту", "минуты", "минут"],
	  HOURS: ["час", "часа", "часов"]
	});

	var root$Q = template(`<div><!></div>`);

	function Ui_block($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string}   [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'children'
			]);

		var div = root$Q();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => attributes = set_attributes(div, attributes, {
			class: `block ${classes() ?? ''}`,
			...others
		}));

		append($$anchor, div);
	}

	function Ui_block_inner_vertical($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const DEFAULT_CLASSES_INNER = "block-inner-vertical";
		let classesInner = state(DEFAULT_CLASSES_INNER);

		user_effect(() => {
			set(classesInner, `block-inner-vertical ${classes()}`);
		});

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);

		Ui_block($$anchor, {
			get id() {
				return id();
			},
			get class() {
				return get$3(classesInner);
			},
			get onclick() {
				return onclick();
			},
			onkeyup: onKeyUp,
			get role() {
				return role();
			},
			get tabIndex() {
				return tabIndex();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				snippet(node, () => $$props.children ?? noop);
				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$P = template(`<div><!></div>`);

	function Ui_box($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$P();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_class(div, `box ${classes() ?? ''} `);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root$O = template(`<div><!></div>`);

	function Ui_content($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$O();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_class(div, `content ${classes() ?? ''}`);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root$N = template(`<div><!></div>`);

	function Ui_clickable_div($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 3, ""),
			preventDefault = prop($$props, 'preventDefault', 3, true),
			click = prop($$props, 'click', 3, true),
			enter = prop($$props, 'enter', 3, true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'preventDefault',
				'click',
				'enter',
				'callback',
				'children'
			]);

		const mouseEvent = (e) => {
			preventDefault() && e.preventDefault();
			$$props.callback(e);
		};

		const keyboardEvent = (e) => {
			preventDefault() && e.preventDefault();

			if (e && e.key == "Enter") {
				$$props.callback(e);
			}
		};

		var div = root$N();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children);
		reset(div);

		template_effect(() => attributes = set_attributes(div, attributes, {
			class: classes(),
			role: 'button',
			tabindex: '0',
			onkeyup: enter() ? keyboardEvent : undefined,
			onclick: click() ? mouseEvent : undefined,
			...others
		}));

		append($$anchor, div);
		pop();
	}

	var index$c = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBlock: Ui_block,
		UIBlockInnerVertical: Ui_block_inner_vertical,
		UIBox: Ui_box,
		UIClickableDiv: Ui_clickable_div,
		UIContent: Ui_content
	});

	function initDict(target = {}) {
	  const handler = {
	    get: function (target, prop) {
	      if (!Object.hasOwn(target, prop)) {
	        return prop;
	      }
	      return Reflect.get(...arguments);
	    }
	  };
	  return new Proxy(target, handler);
	}
	function createLocale() {
	  const {
	    subscribe,
	    set,
	    update
	  } = writable(initDict());
	  return {
	    subscribe,
	    update,
	    set: function (val) {
	      set(initDict(val));
	    },
	    reset: function () {
	      return set(initDict());
	    }
	  };
	}
	const LOCALE = createLocale();

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EventEmitter$2 = {exports: {}};

	/*!
	 * EventEmitter v5.2.9 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - https://oli.me.uk/
	 * @preserve
	 */
	var EventEmitter$1 = EventEmitter$2.exports;

	var hasRequiredEventEmitter;

	function requireEventEmitter () {
		if (hasRequiredEventEmitter) return EventEmitter$2.exports;
		hasRequiredEventEmitter = 1;
		(function (module) {
	(function (exports) {

			    /**
			     * Class for managing events.
			     * Can be extended to provide event functionality in other classes.
			     *
			     * @class EventEmitter Manages event registering and emitting.
			     */
			    function EventEmitter() {}

			    // Shortcuts to improve speed and size
			    var proto = EventEmitter.prototype;
			    var originalGlobalValue = exports.EventEmitter;

			    /**
			     * Finds the index of the listener for the event in its storage array.
			     *
			     * @param {Function[]} listeners Array of listeners to search through.
			     * @param {Function} listener Method to look for.
			     * @return {Number} Index of the specified listener, -1 if not found
			     * @api private
			     */
			    function indexOfListener(listeners, listener) {
			        var i = listeners.length;
			        while (i--) {
			            if (listeners[i].listener === listener) {
			                return i;
			            }
			        }

			        return -1;
			    }

			    /**
			     * Alias a method while keeping the context correct, to allow for overwriting of target method.
			     *
			     * @param {String} name The name of the target method.
			     * @return {Function} The aliased method
			     * @api private
			     */
			    function alias(name) {
			        return function aliasClosure() {
			            return this[name].apply(this, arguments);
			        };
			    }

			    /**
			     * Returns the listener array for the specified event.
			     * Will initialise the event object and listener arrays if required.
			     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
			     * Each property in the object response is an array of listener functions.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Function[]|Object} All listener functions for the event.
			     */
			    proto.getListeners = function getListeners(evt) {
			        var events = this._getEvents();
			        var response;
			        var key;

			        // Return a concatenated array of all matching events if
			        // the selector is a regular expression.
			        if (evt instanceof RegExp) {
			            response = {};
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    response[key] = events[key];
			                }
			            }
			        }
			        else {
			            response = events[evt] || (events[evt] = []);
			        }

			        return response;
			    };

			    /**
			     * Takes a list of listener objects and flattens it into a list of listener functions.
			     *
			     * @param {Object[]} listeners Raw listener objects.
			     * @return {Function[]} Just the listener functions.
			     */
			    proto.flattenListeners = function flattenListeners(listeners) {
			        var flatListeners = [];
			        var i;

			        for (i = 0; i < listeners.length; i += 1) {
			            flatListeners.push(listeners[i].listener);
			        }

			        return flatListeners;
			    };

			    /**
			     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Object} All listener functions for an event in an object.
			     */
			    proto.getListenersAsObject = function getListenersAsObject(evt) {
			        var listeners = this.getListeners(evt);
			        var response;

			        if (listeners instanceof Array) {
			            response = {};
			            response[evt] = listeners;
			        }

			        return response || listeners;
			    };

			    function isValidListener (listener) {
			        if (typeof listener === 'function' || listener instanceof RegExp) {
			            return true
			        } else if (listener && typeof listener === 'object') {
			            return isValidListener(listener.listener)
			        } else {
			            return false
			        }
			    }

			    /**
			     * Adds a listener function to the specified event.
			     * The listener will not be added if it is a duplicate.
			     * If the listener returns true then it will be removed after it is called.
			     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListener = function addListener(evt, listener) {
			        if (!isValidListener(listener)) {
			            throw new TypeError('listener must be a function');
			        }

			        var listeners = this.getListenersAsObject(evt);
			        var listenerIsWrapped = typeof listener === 'object';
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
			                listeners[key].push(listenerIsWrapped ? listener : {
			                    listener: listener,
			                    once: false
			                });
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of addListener
			     */
			    proto.on = alias('addListener');

			    /**
			     * Semi-alias of addListener. It will add a listener that will be
			     * automatically removed after its first execution.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addOnceListener = function addOnceListener(evt, listener) {
			        return this.addListener(evt, {
			            listener: listener,
			            once: true
			        });
			    };

			    /**
			     * Alias of addOnceListener.
			     */
			    proto.once = alias('addOnceListener');

			    /**
			     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
			     * You need to tell it what event names should be matched by a regex.
			     *
			     * @param {String} evt Name of the event to create.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvent = function defineEvent(evt) {
			        this.getListeners(evt);
			        return this;
			    };

			    /**
			     * Uses defineEvent to define multiple events.
			     *
			     * @param {String[]} evts An array of event names to define.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvents = function defineEvents(evts) {
			        for (var i = 0; i < evts.length; i += 1) {
			            this.defineEvent(evts[i]);
			        }
			        return this;
			    };

			    /**
			     * Removes a listener function from the specified event.
			     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to remove the listener from.
			     * @param {Function} listener Method to remove from the event.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListener = function removeListener(evt, listener) {
			        var listeners = this.getListenersAsObject(evt);
			        var index;
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key)) {
			                index = indexOfListener(listeners[key], listener);

			                if (index !== -1) {
			                    listeners[key].splice(index, 1);
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of removeListener
			     */
			    proto.off = alias('removeListener');

			    /**
			     * Adds listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
			     * You can also pass it a regular expression to add the array of listeners to all events that match it.
			     * Yeah, this function does quite a bit. That's probably a bad thing.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListeners = function addListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(false, evt, listeners);
			    };

			    /**
			     * Removes listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be removed.
			     * You can also pass it a regular expression to remove the listeners from all events that match it.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListeners = function removeListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(true, evt, listeners);
			    };

			    /**
			     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
			     * The first argument will determine if the listeners are removed (true) or added (false).
			     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be added/removed.
			     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
			     *
			     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
			        var i;
			        var value;
			        var single = remove ? this.removeListener : this.addListener;
			        var multiple = remove ? this.removeListeners : this.addListeners;

			        // If evt is an object then pass each of its properties to this method
			        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			            for (i in evt) {
			                if (evt.hasOwnProperty(i) && (value = evt[i])) {
			                    // Pass the single listener straight through to the singular method
			                    if (typeof value === 'function') {
			                        single.call(this, i, value);
			                    }
			                    else {
			                        // Otherwise pass back to the multiple function
			                        multiple.call(this, i, value);
			                    }
			                }
			            }
			        }
			        else {
			            // So evt must be a string
			            // And listeners must be an array of listeners
			            // Loop over it and pass each one to the multiple method
			            i = listeners.length;
			            while (i--) {
			                single.call(this, evt, listeners[i]);
			            }
			        }

			        return this;
			    };

			    /**
			     * Removes all listeners from a specified event.
			     * If you do not specify an event then all listeners will be removed.
			     * That means every event will be emptied.
			     * You can also pass a regex to remove all events that match it.
			     *
			     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeEvent = function removeEvent(evt) {
			        var type = typeof evt;
			        var events = this._getEvents();
			        var key;

			        // Remove different things depending on the state of evt
			        if (type === 'string') {
			            // Remove all listeners for the specified event
			            delete events[evt];
			        }
			        else if (evt instanceof RegExp) {
			            // Remove all events matching the regex.
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    delete events[key];
			                }
			            }
			        }
			        else {
			            // Remove all listeners in all events
			            delete this._events;
			        }

			        return this;
			    };

			    /**
			     * Alias of removeEvent.
			     *
			     * Added to mirror the node API.
			     */
			    proto.removeAllListeners = alias('removeEvent');

			    /**
			     * Emits an event of your choice.
			     * When emitted, every listener attached to that event will be executed.
			     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
			     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
			     * So they will not arrive within the array on the other side, they will be separate.
			     * You can also pass a regular expression to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {Array} [args] Optional array of arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emitEvent = function emitEvent(evt, args) {
			        var listenersMap = this.getListenersAsObject(evt);
			        var listeners;
			        var listener;
			        var i;
			        var key;
			        var response;

			        for (key in listenersMap) {
			            if (listenersMap.hasOwnProperty(key)) {
			                listeners = listenersMap[key].slice(0);

			                for (i = 0; i < listeners.length; i++) {
			                    // If the listener returns true then it shall be removed from the event
			                    // The function is executed either with a basic call or an apply if there is an args array
			                    listener = listeners[i];

			                    if (listener.once === true) {
			                        this.removeListener(evt, listener.listener);
			                    }

			                    response = listener.listener.apply(this, args || []);

			                    if (response === this._getOnceReturnValue()) {
			                        this.removeListener(evt, listener.listener);
			                    }
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of emitEvent
			     */
			    proto.trigger = alias('emitEvent');

			    /**
			     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
			     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {...*} Optional additional arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emit = function emit(evt) {
			        var args = Array.prototype.slice.call(arguments, 1);
			        return this.emitEvent(evt, args);
			    };

			    /**
			     * Sets the current value to check against when executing listeners. If a
			     * listeners return value matches the one set here then it will be removed
			     * after execution. This value defaults to true.
			     *
			     * @param {*} value The new value to check for when executing listeners.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.setOnceReturnValue = function setOnceReturnValue(value) {
			        this._onceReturnValue = value;
			        return this;
			    };

			    /**
			     * Fetches the current value to check against when executing listeners. If
			     * the listeners return value matches this one then it should be removed
			     * automatically. It will return true by default.
			     *
			     * @return {*|Boolean} The current value to check for or the default, true.
			     * @api private
			     */
			    proto._getOnceReturnValue = function _getOnceReturnValue() {
			        if (this.hasOwnProperty('_onceReturnValue')) {
			            return this._onceReturnValue;
			        }
			        else {
			            return true;
			        }
			    };

			    /**
			     * Fetches the events object and creates one if required.
			     *
			     * @return {Object} The events storage object.
			     * @api private
			     */
			    proto._getEvents = function _getEvents() {
			        return this._events || (this._events = {});
			    };

			    /**
			     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
			     *
			     * @return {Function} Non conflicting EventEmitter class.
			     */
			    EventEmitter.noConflict = function noConflict() {
			        exports.EventEmitter = originalGlobalValue;
			        return EventEmitter;
			    };

			    // Expose the class either via AMD, CommonJS or the global object
			    if (module.exports){
			        module.exports = EventEmitter;
			    }
			    else {
			        exports.EventEmitter = EventEmitter;
			    }
			}(typeof window !== 'undefined' ? window : EventEmitter$1 || {})); 
		} (EventEmitter$2));
		return EventEmitter$2.exports;
	}

	var EventEmitterExports = requireEventEmitter();
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(EventEmitterExports);

	/*
		:property.sub1.func().funcProp
		 = return funcProp of function result of sub1 property of property of object
		:{::helperVal}.sub
		 = return sub property of object property with name retrieved from helperVal property of helpers object
		:{::helperFunc()}.sub
		= return sub property of object property with name retrieved from helperVal function result of helpers object.
		if helpersFunx return 'car' then source path becomes :car.sub

	*/

	var src$1;
	var hasRequiredSrc$1;

	function requireSrc$1 () {
		if (hasRequiredSrc$1) return src$1;
		hasRequiredSrc$1 = 1;
		const SUB_PATH_START = "{",
		    SUB_PATH_END = "}",
		    PATH_SPLIT = ".",
		    PATH_START_OBJECT = ":",
		    PATH_START_HELPERS = "::",
		    FUNCTION_MARKER = "()",
		    MAX_DEEP = 10;

		/**
		 * Set of tools to use notPath property access notation
		 * : is for item
		 * :: is for helpers
		 * {} subpath
		 * . path splitter
		 * () function and should be executed with params (item, helper | undefined)
		 * sub-paths will be parsed and replaced by results in source path
		 */
		class notPath {
		    static get SUB_PATH_START() {
		        return SUB_PATH_START;
		    }
		    static get SUB_PATH_END() {
		        return SUB_PATH_END;
		    }
		    static get PATH_SPLIT() {
		        return PATH_SPLIT;
		    }
		    static get PATH_START_OBJECT() {
		        return PATH_START_OBJECT;
		    }
		    static get PATH_START_HELPERS() {
		        return PATH_START_HELPERS;
		    }
		    static get FUNCTION_MARKER() {
		        return FUNCTION_MARKER;
		    }
		    static get MAX_DEEP() {
		        return MAX_DEEP;
		    }

		    /*
				input ':{::helperVal}.sub'
				return ::helperVal
			*/

		    /**
		     * Returns first subpath in path
		     * if subpath not closed will return it anyway
		     * @param {string} path path in string notation
		     * @return {string|null} subpath or null if no sub path were found
		     */
		    static findNextSubPath(path) {
		        let subPath = "",
		            find = false;
		        for (let i = 0; i < path.length; i++) {
		            if (path[i] === SUB_PATH_START) {
		                find = true;
		                subPath = "";
		            } else {
		                if (path[i] === SUB_PATH_END && find) {
		                    return subPath;
		                } else {
		                    subPath += path[i];
		                }
		            }
		        }
		        return find ? subPath : null;
		    }

		    /**
		     * Replace sub-path in parent path by parsed version
		     * @param {string} path path to process
		     * @param {string} sub sub path to replace
		     * @param {string} parsed parsed sub path
		     * @return {string} parsed path
		     */

		    static replaceSubPath(path, sub, parsed) {
		        let subf = SUB_PATH_START + sub + SUB_PATH_END,
		            i = 0;
		        while (path.indexOf(subf) > -1 && i < MAX_DEEP) {
		            path = path.replace(subf, parsed);
		            i++;
		        }
		        return path;
		    }

		    /**
		     * Parses path while there any sub-paths
		     * @param {string} path raw unparsed path
		     * @param {object} item data
		     * @param {object} helpers helpers
		     * @return {string} parsed path
		     */
		    static parseSubs(path, item, helpers) {
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            i++;
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		        }
		        return path;
		    }

		    /**
		     * Get property value
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} [helpers] helpers object
		     */

		    static get(path, item, helpers = undefined) {
		        switch (path) {
		            case PATH_START_OBJECT:
		                return item;
		            case PATH_START_HELPERS:
		                return helpers;
		        }
		        path = this.parseSubs(path, item, helpers);
		        return this.getValueByPath(
		            path.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		            path,
		            item,
		            helpers
		        );
		    }

		    /**
		     * Set property value
		     * @param {string}  path path to property
		     * @param {object}  item item object
		     * @param {object}  helpers         helpers object if 4 arguments or attrValue if only 3 provided
		     * @param {any}     [attrValue]     value we want to assign
		     */

		    static set(path, item, helpers, attrValue = undefined) {
		        if (arguments.length === 3) {
		            attrValue = helpers;
		            helpers = undefined;
		        }
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		            i++;
		        }
		        this.setValueByPath(item, path, attrValue);
		        if (
		            item.isRecord &&
		            this.normilizePath(path).length > 1 &&
		            item.__isActive
		        ) {
		            item.trigger("change", item, path, attrValue);
		        }
		    }

		    /**
		     * Set target property to null
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} helpers helpers object
		     */

		    static unset(path, item, helpers) {
		        this.set(path, item, helpers, null);
		    }

		    /**
		     * Parses step key, transforms it to end-form
		     * @param {string} step not parsed step key
		     * @param {object} item item object
		     * @param {object} helper helpers object
		     * @return {string|number} parsed step key
		     */

		    static parsePathStep(step, item, helper) {
		        let rStep = null;
		        if (step.indexOf(PATH_START_HELPERS) === 0 && helper) {
		            rStep = step.replace(PATH_START_HELPERS, "");
		            if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                rStep = rStep.replace(FUNCTION_MARKER, "");
		                if (Object.prototype.hasOwnProperty.call(helper, rStep)) {
		                    return helper[rStep](item, undefined);
		                }
		            } else {
		                return helper[rStep];
		            }
		        } else {
		            if (step.indexOf(PATH_START_OBJECT) === 0 && item) {
		                rStep = step.replace(PATH_START_OBJECT, "");
		                if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                    rStep = rStep.replace(FUNCTION_MARKER, "");
		                    if (Object.prototype.hasOwnProperty.call(item, rStep)) {
		                        return item[rStep](item, undefined);
		                    }
		                } else {
		                    return item[rStep];
		                }
		            }
		        }
		        return step;
		    }

		    //::fieldName.result
		    //{}
		    //{fieldName: 'targetRecordField'}
		    ////['targetRecordField', 'result']
		    /**
		     * Transforms path with sub paths to path without
		     * @param {string|array} path path to target property
		     * @param {object} item item object
		     * @param {object} helper helper object
		     * @return {array} parsed path
		     **/
		    static parsePath(path, item, helper) {
		        if (!Array.isArray(path)) {
		            path = path.split(PATH_SPLIT);
		        }
		        for (var i = 0; i < path.length; i++) {
		            path[i] = this.parsePathStep(path[i], item, helper);
		        }
		        return path;
		    }

		    /**
		     * Transforms path from string notation to array of keys
		     * @param {string|array} path  input path, if array does nothing
		     * @return {array} path in array notation
		     */

		    static normilizePath(path) {
		        if (Array.isArray(path)) {
		            return path;
		        } else {
		            while (path.indexOf(PATH_START_OBJECT) > -1) {
		                path = path.replace(PATH_START_OBJECT, "");
		            }
		            return path.split(PATH_SPLIT);
		        }
		    }

		    /*
				small = ["todo"],
				big = ["todo", "length"]
				return true;

			*/

		    /**
		     * Identifies if first path includes second, compared from start,
		     * no floating start position inside ['join', 'me'], ['me']
		     * will result in false
		     * @param {array} big where we will search
		     * @param {array} small what we will search
		     * @return {boolean} if we succeed
		     */

		    static ifFullSubPath(big, small) {
		        if (big.length < small.length) {
		            return false;
		        }
		        for (let t = 0; t < small.length; t++) {
		            if (small[t] !== big[t]) {
		                return false;
		            }
		        }
		        return true;
		    }

		    /**
		     * Getter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be used as getter
		     * @param {string|array} attrPath path to property
		     * @param {object} item supporting data
		     * @param {helpers} object  supporting helpers
		     */

		    static getValueByPath(object, attrPath, item, helpers) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift(),
		            isFunction = attrName.indexOf(FUNCTION_MARKER) > -1;
		        if (isFunction) {
		            attrName = attrName.replace(FUNCTION_MARKER, "");
		        }
		        if (
		            (typeof object === "object" || typeof object === "function") &&
		            typeof object !== "undefined" &&
		            object !== null &&
		            typeof object[attrName] !== "undefined" &&
		            object[attrName] !== null
		        ) {
		            let newObj = isFunction
		                ? object[attrName]({
		                      item,
		                      helpers,
		                  })
		                : object[attrName];
		            if (attrPath.length > 0) {
		                return this.getValueByPath(newObj, attrPath, item, helpers);
		            } else {
		                return newObj;
		            }
		        } else {
		            return undefined;
		        }
		    }

		    /**
		     * Setter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be modified
		     * @param {string|array} attrPath path to property
		     * @param {any} attrValue  value to assign
		     */

		    static setValueByPath(object, attrPath, attrValue) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift();
		        if (attrPath.length > 0) {
		            if (!Object.prototype.hasOwnProperty.call(object, attrName)) {
		                object[attrName] = {};
		            }
		            this.setValueByPath(object[attrName], attrPath, attrValue);
		        } else {
		            object[attrName] = attrValue;
		        }
		    }

		    /**
		     * Joins passed in strings with PATH_SPLIT
		     * @param {string} arguments path to be glued
		     * @return {string} composite path
		     */

		    static join() {
		        let args = Array.prototype.slice.call(arguments);
		        return args.join(PATH_SPLIT);
		    }
		}

		src$1 = notPath;
		return src$1;
	}

	var notPath$1;
	var hasRequiredNotPath;

	function requireNotPath () {
		if (hasRequiredNotPath) return notPath$1;
		hasRequiredNotPath = 1;
		notPath$1 = requireSrc$1();
		return notPath$1;
	}

	var notPathExports = requireNotPath();
	var notPath = /*@__PURE__*/getDefaultExportFromCjs(notPathExports);

	var _notCommon;

	/*
	https://github.com/TehShrike/is-mergeable-object

	Included for convinience only. All rights belongs to their authors and etc.
	start of my code marked.

	*/

	let isMergeableObject = function isMergeableObject(value) {
	  return isNonNullObject(value) && !isSpecial(value);
	};
	function isNonNullObject(value) {
	  return !!value && typeof value === "object";
	}
	function isSpecial(value) {
	  var stringValue = Object.prototype.toString.call(value);
	  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
	function isReactElement(value) {
	  return value.$$typeof === REACT_ELEMENT_TYPE;
	}

	/*
	https://github.com/KyleAMathews/deepmerge

	The MIT License (MIT)

	Copyright (c) 2012 Nicholas Fisher

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	function emptyTarget(val) {
	  return Array.isArray(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	  const clone = !optionsArgument || optionsArgument.clone !== false;
	  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
	}
	function defaultArrayMerge(target, source, optionsArgument) {
	  return target.concat(source).map(function (element) {
	    return cloneUnlessOtherwiseSpecified(element, optionsArgument);
	  });
	}
	function mergeObject(target, source, optionsArgument) {
	  const destination = {};
	  if (isMergeableObject(target)) {
	    Object.keys(target).forEach(function (key) {
	      destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);
	    });
	  }
	  Object.keys(source).forEach(function (key) {
	    if (!isMergeableObject(source[key]) || !target[key]) {
	      destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);
	    } else {
	      destination[key] = deepmerge(target[key], source[key], optionsArgument);
	    }
	  });
	  return destination;
	}
	function deepmerge(target, source, optionsArgument) {
	  const sourceIsArray = Array.isArray(source);
	  const targetIsArray = Array.isArray(target);
	  const options = optionsArgument || {
	    arrayMerge: defaultArrayMerge
	  };
	  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
	  if (!sourceAndTargetTypesMatch) {
	    return cloneUnlessOtherwiseSpecified(source, optionsArgument);
	  } else if (sourceIsArray) {
	    const arrayMerge = options.arrayMerge || defaultArrayMerge;
	    return arrayMerge(target, source, optionsArgument);
	  } else {
	    return mergeObject(target, source, optionsArgument);
	  }
	}
	deepmerge.all = function deepmergeAll(array, optionsArgument) {
	  if (!Array.isArray(array)) {
	    throw new Error("first argument should be an array");
	  }
	  return array.reduce(function (prev, next) {
	    return deepmerge(prev, next, optionsArgument);
	  }, {});
	};

	/**
	 *  Collection of common functions
	 *  @class
	 */
	let notCommon$1 = /*#__PURE__*/function () {
	  function notCommon() {
	    _classCallCheck(this, notCommon);
	  }
	  return _createClass(notCommon, null, [{
	    key: "isError",
	    value:
	    /**
	     *  @static {function} isError  function to perform object test, if it's an error object or not
	     * @param   {object}    e   object to test
	     */
	    function isError(e) {
	      return e instanceof Error ||
	      // @ts-ignore
	      Object.hasOwn(e, "status") && e.status === "error";
	    }
	  }, {
	    key: "mute",
	    value: function mute() {
	      notCommon.ENV_TYPE = "production";
	    }
	  }, {
	    key: "pad",
	    value: function pad(n) {
	      return n < 10 ? "0" + n : n;
	    }
	    /**
	     *  Returns today Date object without hours, minutes, seconds
	     *  @return {number}  current date with 00:00:00 in ms of unix time
	     */
	  }, {
	    key: "getTodayDate",
	    value: function getTodayDate() {
	      let t = new Date();
	      return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
	    }

	    /**
	     *  Returns true if object has field of name
	     *   @param   {object}    obj    some object
	     *  @param  {string}    name  field name
	     *  @return {boolean}          if object contains field with name
	     **/
	  }, {
	    key: "objHas",
	    value: function objHas(obj, name) {
	      // @ts-ignore
	      return Object.hasOwn(obj, name);
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "copyObj",
	    value: function copyObj(obj) {
	      return JSON.parse(JSON.stringify(obj));
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "partCopyObj",
	    value: function partCopyObj(obj, list) {
	      let partObj = Object.keys(obj).reduce(function (prev, curr) {
	        if (list.includes(curr)) {
	          prev[curr] = obj[curr];
	        }
	        return prev;
	      }, {});
	      return JSON.parse(JSON.stringify(partObj));
	    }
	  }, {
	    key: "compareTwoArrays",
	    value: function compareTwoArrays(a, b) {
	      return a.length === b.length && a.every(function (element, index) {
	        return element === b[index];
	      });
	    }

	    /**
	     * Test argument type to be 'function'
	     * @param {any}  func    possible function
	     * @return {boolean}     if this is a function
	     **/
	  }, {
	    key: "isFunc",
	    value: function isFunc(func) {
	      return typeof func === "function";
	    }

	    /**
	     * Returns true if argument is Async function
	     * @param {function} func  to test
	     * @return {boolean}       if this function is constructed as AsyncFunction
	     **/
	  }, {
	    key: "isAsync",
	    value: function isAsync(func) {
	      return func.constructor.name === "AsyncFunction";
	    }

	    /**
	     *  Executes method of object in appropriate way inside Promise
	     * @param {object}   obj     original object
	     * @param {string}   name    method name to execute
	     * @param {Array}     params  array of params
	     * @return {Promise}          results of method execution
	     **/
	  }, {
	    key: "executeObjectFunction",
	    value: async function executeObjectFunction(obj, name, params) {
	      if (obj) {
	        // @ts-ignore
	        const proc = notPath.get(":" + name, obj);
	        if (notCommon.isFunc(proc)) {
	          if (notCommon.isAsync(proc)) {
	            return await proc(...params);
	          } else {
	            return proc(...params);
	          }
	        }
	      }
	    }

	    /**
	     *  Executes method of object in apropriate way inside Promise
	     * @param {Object}   from     original object
	     * @param {Object}   to    method name to execute
	     * @param {Array}     list  array of params
	     * @return {undefined}          results of method execution
	     **/
	  }, {
	    key: "mapBind",
	    value: function mapBind(from, to, list) {
	      list.forEach(function (item) {
	        if (typeof from[item] === "function") {
	          to[item] = from[item].bind(from);
	        }
	      });
	    }
	  }, {
	    key: "isClass",
	    value: function isClass(fn) {
	      return /^\s*class/.test(fn.toString());
	    }
	  }, {
	    key: "detectType",
	    value: function detectType(testie) {
	      if (typeof testie !== "function") {
	        return typeof testie;
	      } else {
	        if (notCommon.isClass(testie)) {
	          return "class";
	        } else {
	          return "function";
	        }
	      }
	    }

	    //Проверка является ли переменная массивом
	  }, {
	    key: "isArray",
	    value: function isArray(data) {
	      return typeof data == "object" && data instanceof Array;
	    }
	  }, {
	    key: "localIsoDate",
	    value: function localIsoDate(date) {
	      date = date || new Date();
	      let localIsoString = date.getFullYear() + "-" + notCommon.pad(date.getMonth() + 1) + "-" + notCommon.pad(date.getDate()) + "T" + notCommon.pad(date.getHours()) + ":" + notCommon.pad(date.getMinutes()) + ":" + notCommon.pad(date.getSeconds());
	      return localIsoString;
	    }
	  }, {
	    key: "getToday",
	    value: function getToday() {
	      let today = new Date();
	      let date = today.getFullYear() + "-" + notCommon.pad(today.getMonth() + 1) + "-" + notCommon.pad(today.getDate());
	      return date;
	    }
	  }, {
	    key: "backlogAdd",
	    value: function backlogAdd(msg, type = "log") {
	      if (notCommon.get("backlog") === true) {
	        notCommon.backlog.push({
	          msg,
	          type
	        });
	      }
	    }
	  }, {
	    key: "dumpBacklog",
	    value: function dumpBacklog() {
	      while (notCommon.backlog.length) {
	        let row = notCommon.backlog.shift();
	        window[notCommon.LOG][row.type](...row.msg);
	      }
	    }
	  }, {
	    key: "logMsg",
	    value: function logMsg() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].log(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "log");
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      notCommon.logMsg(...arguments);
	    }
	  }, {
	    key: "createLogger",
	    value: function createLogger(prefix) {
	      return {
	        log: notCommon.genLogMsg(prefix),
	        error: notCommon.genLogError(prefix),
	        debug: notCommon.genLogDebug(prefix),
	        report: notCommon.report
	      };
	    }

	    //Генерация метода вывода сообщений в консоль с указанием префикса.
	  }, {
	    key: "genLogMsg",
	    value: function genLogMsg(prefix) {
	      return function () {
	        //not arrow bc of arguments special var is not available in arrow functions
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].log(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "log");
	      };
	    }

	    /**
	     * Определяет является ли окружение окружением разработки
	     * @returns  {boolean} true если это запущено в окружении разработки
	     **/
	  }, {
	    key: "isDev",
	    value: function isDev() {
	      return notCommon.ENV_TYPE === notCommon.DEV_ENV;
	    }
	  }, {
	    key: "debug",
	    value: function debug() {
	      if (notCommon.isDev()) {
	        return notCommon.logMsg(...arguments);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "genLogDebug",
	    value: function genLogDebug(prefix) {
	      if (notCommon.isDev()) {
	        return notCommon.genLogMsg(prefix);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      notCommon.logError(...arguments);
	    }

	    //Функция вывода сообщения об ошибке
	  }, {
	    key: "logError",
	    value: function logError() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].error(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "error");
	    }
	  }, {
	    key: "genLogError",
	    value: function genLogError(prefix) {
	      return function () {
	        //do not change to arrow function, bc of arguments
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].error(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "error");
	      };
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon.getApp()) {
	        let reporter = notCommon.getApp().getService("nsErrorReporter");
	        if (reporter) {
	          reporter.report(e).catch(notCommon.error);
	        }
	      } else {
	        if (!notCommon.get("production")) {
	          notCommon.error(...arguments);
	        }
	      }
	    }
	  }, {
	    key: "trace",
	    value: function trace() {
	      if (!notCommon.get("production")) {
	        notCommon.trace(...arguments);
	      }
	    }
	  }, {
	    key: "trimBackslash",
	    value: function trimBackslash(str) {
	      if (str.indexOf("/") === 0) {
	        str = str.substring(1);
	      }
	      if (str[str.length - 1] === "/") {
	        str = str.substring(0, str.length - 1);
	      }
	      return str;
	    }

	    /**
	     *  Builds URL with structure like prefix/module/model/id/action
	     * If some part absent or set to false it will be excluded from result
	     *  @param {object} urlParts
	     *  @param {string} [urlParts.prefix='']
	     *  @param {string} [urlParts.module='']
	     *  @param {string} [urlParts.model='']
	     *  @param {string} [urlParts.id='']
	     *  @param {string} [urlParts.action='']
	     *  @return {string}  url path
	     */
	  }, {
	    key: "buildURL",
	    value: function buildURL({
	      prefix,
	      module,
	      model,
	      id,
	      action
	    } = {
	      prefix: "",
	      module: "",
	      model: "",
	      id: "",
	      action: ""
	    }) {
	      let url = ["/"];
	      if (prefix) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(prefix)));
	      }
	      if (module) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(module)));
	      }
	      if (model) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(model)));
	      }
	      if (id) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(id)));
	      }
	      if (action) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(action)));
	      }
	      url = url.filter(function (el) {
	        return el !== "";
	      });
	      return url.join("/").replace(/\/\//g, "/");
	    }
	  }, {
	    key: "capitalizeFirstLetter",
	    value: function capitalizeFirstLetter(name) {
	      return name.charAt(0).toUpperCase() + name.slice(1);
	    }
	  }, {
	    key: "lowerFirstLetter",
	    value: function lowerFirstLetter(string) {
	      return string.charAt(0).toLowerCase() + string.slice(1);
	    }
	  }, {
	    key: "strLengthCap",
	    value: function strLengthCap(str, MAX_TITLE_LENGTH = 50, POST_FIX = "...") {
	      if (typeof str === "string" && str.length > MAX_TITLE_LENGTH) {
	        return str.substr(0, MAX_TITLE_LENGTH) + POST_FIX;
	      } else {
	        return str;
	      }
	    }
	  }, {
	    key: "escapeHtml",
	    value: function escapeHtml(unsafe) {
	      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
	    }
	  }, {
	    key: "startApp",
	    value: function startApp(starter) {
	      document.addEventListener("DOMContentLoaded", starter);
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon.get("app");
	    }
	  }, {
	    key: "extendAppConfig",
	    value: function extendAppConfig(conf, conf2) {
	      return notCommon.deepMerge(conf, conf2);
	    }
	  }, {
	    key: "absorbModule",
	    value: function absorbModule() {
	      let defaultConf,
	        //app options
	        mod,
	        //module options
	        targets = {}; //various collections
	      if (arguments.length == 1) {
	        targets = {
	          ...arguments[0]
	        };
	        if (Object.hasOwnProperty.call(arguments[0], "defaultConf")) {
	          defaultConf = arguments[0].defaultConf;
	          delete targets.defaultConf;
	        }
	        if (Object.hasOwnProperty.call(arguments[0], "mod")) {
	          mod = arguments[0].mod;
	          delete targets.mod;
	        }
	      } else {
	        notCommon.log("WARNING: absorbModule format obsoleted, use object {defaultConf, mod, services, uis, wsc, etc}");
	        defaultConf = arguments[0];
	        mod = arguments[1];
	        if (arguments.length > 2) {
	          targets.services = arguments[2];
	        }
	        if (arguments.length > 3) {
	          targets.uis = arguments[3];
	        }
	        if (arguments.length > 4) {
	          targets.wcs = arguments[4];
	        }
	      }
	      for (let prop in mod) {
	        //add manifest to other
	        if (prop === "manifest") {
	          defaultConf = notCommon.extendAppConfig(defaultConf, mod.manifest);
	          continue;
	        }
	        if (typeof notCommon.get(`absorb.${prop}`) === "function") {
	          // @ts-ignore
	          if (!Object.hasOwn(targets, prop)) {
	            targets[prop] = {};
	            notCommon.log(`WARNING: no accamulator object provided for '${prop}' collection`);
	          }
	          notCommon.get(`absorb.${prop}`)(targets[prop], mod[prop]);
	        } else if (prop.indexOf("nc") === 0) {
	          // @ts-ignore
	          if (!Object.hasOwn(defaultConf, "controllers")) {
	            defaultConf.controllers = {};
	          }
	          defaultConf.controllers[prop] = mod[prop];
	        } else {
	          //in case of some other stuff presented, isolating it in special var
	          // @ts-ignore
	          if (!Object.hasOwn(window, "notEnv")) {
	            // @ts-ignore
	            window.notEnv = {};
	          }
	          // @ts-ignore
	          window.notEnv[prop] = mod[prop];
	        }
	      }
	      return defaultConf;
	    }
	  }, {
	    key: "defineIfNotExists",
	    value: function defineIfNotExists(obj, key, defaultValue) {
	      // @ts-ignore
	      if (!Object.hasOwn(obj, key)) {
	        obj[key] = defaultValue;
	      }
	    }
	  }, {
	    key: "register",
	    value: function register(key, val) {
	      notCommon.registry[key] = val;
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      // @ts-ignore
	      return Object.hasOwn(notCommon.registry, key) ? notCommon.registry[key] : null;
	    }

	    /**
	     * Moves item inside array from old_index to new_index
	     * @static
	     * @param {Array<any>} array
	     * @param {number} old_index
	     * @param {number} new_index
	     * @memberof notCommon
	     */
	  }, {
	    key: "moveItem",
	    value: function moveItem(array, old_index, new_index) {
	      const inRange = function (num) {
	        return num < array.length && num > -1;
	      };
	      if (inRange(new_index) && inRange(old_index)) {
	        array.splice(new_index, 0, array.splice(old_index, 1)[0]);
	      }
	    }
	  }, {
	    key: "stripProxy",
	    value: function stripProxy(obj) {
	      if (typeof obj !== "undefined" && obj !== null) {
	        if (obj.isProxy) {
	          if (Array.isArray(obj)) {
	            obj = Array.from(obj);
	          } else {
	            obj = Object.assign({}, obj);
	          }
	          for (let t in obj) {
	            // @ts-ignore
	            if (Object.hasOwn(obj, t)) {
	              obj[t] = notCommon.stripProxy(obj[t]);
	            }
	          }
	        }
	      }
	      return obj;
	    }
	  }, {
	    key: "pipe",
	    value: function pipe(data /* feed data */, funcs /* functions array */) {
	      let result;
	      for (let func of funcs) {
	        result = func(result || data);
	      }
	      return result;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string} type
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getAPI",
	    value: function getAPI(type) {
	      return notCommon.getManager()?.getAPI(type) ?? null;
	    }
	  }, {
	    key: "setManager",
	    value: function setManager(v) {
	      notCommon.MANAGER = v;
	    }

	    /**
	     *
	     *
	     * @static
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getManager",
	    value: function getManager() {
	      return notCommon.MANAGER;
	    }
	  }, {
	    key: "getJSON",
	    value: function getJSON(url) {
	      return fetch(url).then(function (response) {
	        return response.json();
	      });
	    }
	  }, {
	    key: "wait",
	    value: function wait(sec) {
	      return new Promise(function (res) {
	        setTimeout(res, sec * 1000);
	      });
	    }
	  }, {
	    key: "registerWidgetEvents",
	    value: function registerWidgetEvents(events) {
	      if (notCommon.getApp()) {
	        Object.keys(events).forEach(function (eventName) {
	          notCommon.getApp().on(eventName, events[eventName]);
	        });
	      }
	    }
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      notCommon.getApp() && notCommon.getApp().getWorking("router").navigate(url);
	    }
	  }, {
	    key: "select",
	    value: function select(variantsSet, value, def) {
	      if (variantsSet && typeof variantsSet == "object" && notCommon.objHas(variantsSet, value) && typeof variantsSet[value] !== "undefined" && variantsSet[value] !== null) {
	        return variantsSet[value];
	      } else {
	        return def;
	      }
	    }
	  }]);
	}();
	_notCommon = notCommon$1;
	/**
	 *  @static {Object} [MANAGER=null]  application manager, in some cases used to control initialization routine
	 */
	_defineProperty(notCommon$1, "MANAGER", null);
	/**
	 *  @static {string} [LOG="console"]  logger, window[LOG]
	 */
	_defineProperty(notCommon$1, "LOG", "console");
	/**
	 *  @static {function} deepMerge  function to perform deep merges of objects
	 */
	_defineProperty(notCommon$1, "deepMerge", deepmerge);
	_defineProperty(notCommon$1, "TZ_OFFSET", new Date().getTimezoneOffset() / 60 * -1);
	_defineProperty(notCommon$1, "DEV_ENV", "production");
	// @ts-ignore
	_defineProperty(notCommon$1, "ENV_TYPE", window.NOT_ENV_TYPE ?? _notCommon.DEV_ENV);
	_defineProperty(notCommon$1, "NOOP", function () {});
	_defineProperty(notCommon$1, "backlog", []);
	_defineProperty(notCommon$1, "registry", {});
	function absorbServices(target, src) {
	  if (target) {
	    for (let serv in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, serv)) {
	        notCommon$1.logError(`services property duplication ${serv}`);
	      }
	      target[serv] = src[serv];
	    }
	  }
	}
	function extendWSClient(wcs, wscName, wscOptions) {
	  // @ts-ignore
	  if (!Object.hasOwn(wcs, wscName)) {
	    wcs[wscName] = {
	      connection: {},
	      router: {
	        routes: {}
	      },
	      messenger: {}
	    };
	  }
	  let target = wcs[wscName];
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "router")) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions.router, "routes")) {
	      for (let routeType in wscOptions.router.routes) {
	        // @ts-ignore
	        if (!Object.hasOwn(target.router.routes, routeType)) {
	          target.router.routes[routeType] = {};
	        }
	        Object.assign(target.router.routes[routeType], {
	          ...wscOptions.router.routes[routeType]
	        });
	      }
	    }
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "messenger")) {
	    Object.assign(target.messenger, {
	      ...wscOptions.messenger
	    });
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "connection")) {
	    Object.assign(target.connection, {
	      ...wscOptions.connection
	    });
	  }
	  for (let t of ["name", "getToken", "logger", "identity", "credentials"]) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions, t)) {
	      target[t] = wscOptions[t];
	    }
	  }
	}
	function absorbWSC(target, src) {
	  if (target) {
	    for (let wsClientName in src) {
	      extendWSClient(target, wsClientName, src[wsClientName]);
	    }
	  }
	}
	function absorbUIs(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`uis property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	function absorbFields(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`fields property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	notCommon$1.register("absorb.wsc", absorbWSC);
	notCommon$1.register("absorb.services", absorbServices);
	notCommon$1.register("absorb.uis", absorbUIs);
	notCommon$1.register("absorb.uis", absorbFields);

	/**
	 * strings localization and formating model
	 * @class
	 */
	let notLocale = /*#__PURE__*/function (_EventEmitter) {
	  function notLocale() {
	    var _this;
	    _classCallCheck(this, notLocale);
	    _this = _callSuper(this, notLocale);
	    _this.dict = {}; //dictionary of phrases
	    _this.helpers = {}; //additional helper functions and constants
	    let dict = _this.restoreFromStorage();
	    if (dict) {
	      _this.set(dict);
	    }
	    return _this;
	  }

	  /**
	   * String format should comply notPath standart.
	   * {path_to_access} - is
	   * : - is used to access to params
	   * :: - is used to access to helpers
	   * Welcome, {:where}! - will replace {:where} with content of params.where
	   * Welcome, {::where}! - will replace {:where} with content of this.helpers.where
	   * () - after path is to invoke function of target object
	   * Welcome, {::where()}! - will try to exec this.helpers.where(params, undefined)
	   * @param    {string}  str         localized string template with mark to include data
	   * @param    {object}  params      params to use in string
	   * @returns  {string}              localized version of string with
	   */
	  _inherits(notLocale, _EventEmitter);
	  return _createClass(notLocale, [{
	    key: "format",
	    value: function format(str, params) {
	      return notPath.parseSubs(str, params, this.helpers);
	    }

	    /**
	     * Return localized version of string with injected data from provided object
	     * may also use Locale.helpers as source of data
	     * @param {string}   phrase    name of string to localize
	     * @param {object}   params    object with data to inject in phrase template
	     * @return {string}            localized string with injected data
	     */
	  }, {
	    key: "say",
	    value: function say(phrase, params = false) {
	      try {
	        if (notCommon$1.objHas(this.dict, phrase)) {
	          let tmpl = this.dict[phrase],
	            result = "";
	          if (params) {
	            result = this.format(tmpl, params);
	          } else {
	            result = tmpl;
	          }
	          return result;
	        } else {
	          throw new Error(`Unknown locale phrase: ${phrase}`);
	        }
	      } catch (e) {
	        notCommon$1.debug(e);
	        return phrase;
	      }
	    }

	    /**
	     * Setting new dictionary. triggers event 'change'
	     * @param {object}     dict      vocabulary of phrases and templates
	     **/
	  }, {
	    key: "set",
	    value: function set(dict) {
	      LOCALE.set(dict);
	      this.saveToStorage(dict);
	      this.dict = Object.assign({}, {
	        ...dict
	      });
	      this.emit("change");
	    }
	  }, {
	    key: "saveToStorage",
	    value: function saveToStorage(dict) {
	      if (window.localStorage) {
	        try {
	          return window.localStorage.setItem("dictionary", JSON.stringify(dict));
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "restoreFromStorage",
	    value: function restoreFromStorage() {
	      if (window.localStorage) {
	        try {
	          let str = window.localStorage.getItem("dictionary");
	          if (str) {
	            let dict = JSON.parse(str);
	            return dict;
	          } else {
	            return false;
	          }
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }

	    /**
	     * Returns writable store of phrases
	     * @return {object}  writable store
	     */
	  }, {
	    key: "vocabulary",
	    value: function vocabulary() {
	      return LOCALE;
	    }
	  }]);
	}(EventEmitter);
	var notLocale$1 = new notLocale();

	const say = notLocale$1.say.bind(notLocale$1);

	var root_1$u = template(`<span> </span>`);

	function Ui_tag($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "tagId"]                                  if we want to address this tag, as tag-{id}:{eventName}, ex. tag-tagId:update
		 * @property {string}   [title = "tag"]                                 tag title
		 * @property {string}   [color = "info"]                                bulma color
		 * @property {string}   [size = "normal"]                               bulma size
		 * @property {string}   [padding = "normal"]                            size of left/right paddings (small = 0.5em, normal = 1em, big = 1.5em, large = 2em), class names is is-padded-{padding}
		 * @property {boolean}  [bold = false]                                  title styling
		 * @property {boolean}  [right = false]                                 tag positioning on the right, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [left = false]                                  tag positioning on the left, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [top = false]                                   tag positioning on the top, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [bottom = false]                                tag positioning on the bottom, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {string}   [class  = ""]                                   additional css classes list
		 * @property {object}   [events = {}]                                   list of events {name:callback}
		 * @property {function} [register = notCommon.registerWidgetEvents]     register event handlers
		 * @property {function} [onUpdate = (data) => title = data.title;]
		 * @property {function} [action]                                        onclick/onkeydown callback
		 * @property {object}   [vars = {}]                                     css vars list
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "tagId"),
			title = prop($$props, 'title', 7, "tag"),
			color = prop($$props, 'color', 3, "info"),
			size = prop($$props, 'size', 3, "normal"),
			padding = prop($$props, 'padding', 3, "normal"),
			bold = prop($$props, 'bold', 3, false),
			right = prop($$props, 'right', 3, false),
			left = prop($$props, 'left', 3, false),
			top = prop($$props, 'top', 3, false),
			bottom = prop($$props, 'bottom', 3, false),
			classes = prop($$props, 'class', 3, ""),
			events = prop($$props, 'events', 23, () => ({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "title")) {
					title(data.title);
				}
			}),
			vars = prop($$props, 'vars', 19, () => ({})),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		let sided = derived(() => right() || left() || top() || bottom());
		let hCentered = derived(() => !right() && !left() && get$3(sided));
		let vCentered = derived(() => !bottom() && !top() && get$3(sided));

		function getStandartUpdateEventName() {
			return `tag-${id()}:update`;
		}

		let style = state("");

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events()[getStandartUpdateEventName()] = onUpdate();
			}

			register()(events());
		});

		user_effect(() => {
			set(style, proxy(Object.keys(snapshot(vars())).map((varName) => {
				return `${varName}: ${vars()[varName]};`;
			}).join("")));
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$u();

				span.__keydown = function (...$$args) {
					($$props.action ? $$props.action : undefined)?.apply(this, $$args);
				};

				span.__click = function (...$$args) {
					($$props.action ? $$props.action : undefined)?.apply(this, $$args);
				};

				var text = child(span, true);

				reset(span);

				template_effect(() => {
					set_attribute(span, 'role', role());
					set_attribute(span, 'tabindex', tabIndex());
					set_attribute(span, 'id', `tag-${id() ?? ''}`);

					set_class(span, `
  tag
  ${(padding() !== 'normal' ? `is-padded-${padding()}` : '') ?? ''}
  is-${size() ?? ''}
  is-${color() ?? ''}  
  ${classes() ?? ''}`);

					set_attribute(span, 'style', get$3(style));
					toggle_class(span, 'is-clickable', $$props.action);
					toggle_class(span, 'has-text-weight-bold', bold());
					toggle_class(span, 'is-vertical-centered', get$3(vCentered));
					toggle_class(span, 'is-horizontal-centered', get$3(hCentered));
					toggle_class(span, 'is-sided', get$3(sided));
					toggle_class(span, 'is-sided-right', right());
					toggle_class(span, 'is-sided-left', left());
					toggle_class(span, 'is-sided-top', top());
					toggle_class(span, 'is-sided-bottom', bottom());
					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['keydown', 'click']);

	function Ui_boolean($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_TRUE = "not-node:booleans_true"]
		 * @property {string} [LC_FALSE = "not-node:booleans_false"]
		 * @property {any} value
		 * @property {boolean} [inverted = false]
		 */
		/** @type {Props} */
		let LC_TRUE = prop($$props, 'LC_TRUE', 3, "not-node:booleans_true"),
			LC_FALSE = prop($$props, 'LC_FALSE', 3, "not-node:booleans_false"),
			inverted = prop($$props, 'inverted', 3, false);

		const FALSE_VALUE = {
			title: LC_FALSE(),
			color: inverted() ? "success" : "danger"
		};

		const TRUE_VALUE = {
			title: LC_TRUE(),
			color: inverted() ? "danger" : "success"
		};

		//if inverted === true, inverts value
		let tagValue = derived(() => $$props.value ? TRUE_VALUE : FALSE_VALUE);

		Ui_tag($$anchor, spread_props(() => get$3(tagValue)));
	}

	var root$M = template(`<span class="label"> <!></span>`);

	function Ui_boolean_labeled($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		/**
		 * @typedef {Object} Props
		 * @property {boolean} value
		 * @property {boolean} [inverted = false]
		 * @property {string} label
		 */
		/** @type {Props} */
		let inverted = prop($$props, 'inverted', 3, false);
		var span = root$M();
		var text = child(span);
		var node = sibling(text);

		Ui_boolean(node, {
			get value() {
				return $$props.value;
			},
			get inverted() {
				return inverted();
			}
		});

		reset(span);
		template_effect(() => set_text(text, `${$LOCALE()[$$props.label] ?? ''}: `));
		append($$anchor, span);
		pop();
		$$cleanup();
	}

	function Ui_booleans($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {array}    values
		 * @property {boolean}  [inverted = false]
		 * @property {function}      [componentConstructor = UIBoolean]
		 * @property {function} [itemRenderer]                          if supplied will be used instead of componentConstructor
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			inverted = prop($$props, 'inverted', 3, false),
			ItemConstructor = prop($$props, 'componentConstructor', 3, Ui_boolean);

		let _values = state(proxy([]));

		onMount(() => {
			if (typeof values() === "boolean") {
				set(_values, proxy([{ value: values() }]));
			} else if (Array.isArray(values())) {
				if (values().every((itm) => typeof itm === "boolean")) {
					set(_values, proxy(values().map((itm) => {
						return { value: itm };
					})));
				} else {
					set(_values, proxy([...values()]));
				}
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, () => get$3(_values), index$d, ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent = ($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							snippet(node_3, () => $$props.itemRenderer, () => get$3(item), () => index);
							append($$anchor, fragment_3);
						};

						var alternate = ($$anchor) => {
							var fragment_4 = comment();
							var node_4 = first_child(fragment_4);
							const expression = derived(() => inverted() || get$3(item).inverted);

							component(node_4, ItemConstructor, ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$3(item), {
									get inverted() {
										return get$3(expression);
									}
								}));
							});

							append($$anchor, fragment_4);
						};

						if_block(node_2, ($$render) => {
							if ($$props.itemRenderer) $$render(consequent); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$3(_values).length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function toggleView(_, hidden) {
		hidden(!hidden());
	}

	async function copyContent(
		__1,
		value,
		tooltip,
		contentCopied,
		tooltipTarget,
		tooltipText,
		tooltipTTL,
		$$props
	) {
		try {
			await navigator.clipboard.writeText(value());

			if (tooltip()) {
				set(contentCopied, true);
				get$3(tooltipTarget).dataset.tooltip = tooltipText();

				setTimeout(
					() => {
						set(contentCopied, false);
						get$3(tooltipTarget).removeAttribute("data-tooltip");
					},
					tooltipTTL()
				);
			}
		} catch(err) {
			$$props.onerror && $$props.onerror(err);
		}
	}

	var root_1$t = template(`<span role="button" tabindex="0"><i></i></span>`);
	var root_2$l = template(`<span class="icon is-small is-right is-clickable is-vertical-middle" role="button" tabindex="0"><i></i></span>`);
	var root$L = template(`<span> </span> <!> <!>`, 1);

	function Ui_censored($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [hidden = true]
		 * @property {boolean}  [showable = true]
		 * @property {boolean}  [copiable = true]
		 * @property {string}   [copyIcon = 'copy']
		 * @property {string}   [showIcon = 'eye']
		 * @property {string}   [hideIcon = 'eye-slash']
		 * @property {number}   [maxLength = 20]
		 * @property {string}   [shadowClass = "has-background-primary-90"]
		 * @property {boolean}  [tooltip = true]
		 * @property {number}   [tooltipTTL = 2000]
		 * @property {string}   [tooltipText = "Скопировано в буфер"]
		 * @property {string}   [tooltipClass = "has-tooltip-info"]
		 * @property {string}   [value = ""]
		 * @property {function} [onerror]
		 */
		/** @type {Props} */
		let hidden = prop($$props, 'hidden', 15, true),
			showable = prop($$props, 'showable', 3, true),
			copiable = prop($$props, 'copiable', 3, true),
			copyIcon = prop($$props, 'copyIcon', 3, "copy"),
			showIcon = prop($$props, 'showIcon', 3, "eye"),
			hideIcon = prop($$props, 'hideIcon', 3, "eye-slash"),
			maxLength = prop($$props, 'maxLength', 3, 20),
			shadowClass = prop($$props, 'shadowClass', 3, "has-background-primary-90"),
			tooltip = prop($$props, 'tooltip', 3, true),
			tooltipTTL = prop($$props, 'tooltipTTL', 3, 2000),
			tooltipText = prop($$props, 'tooltipText', 3, "Скопировано в буфер"),
			tooltipClass = prop($$props, 'tooltipClass', 3, "has-tooltip-info"),
			value = prop($$props, 'value', 3, "");

		let contentCopied = state(false),
			tooltipActive = derived(() => tooltip() && get$3(contentCopied)),
			tooltipTarget = state(undefined);

		var fragment = root$L();
		var span = first_child(fragment);
		var text = child(span, true);

		reset(span);

		var node = sibling(span, 2);

		{
			var consequent = ($$anchor) => {
				var span_1 = root_1$t();

				span_1.__click = [
					copyContent,
					value,
					tooltip,
					contentCopied,
					tooltipTarget,
					tooltipText,
					tooltipTTL,
					$$props
				];

				span_1.__keydown = [
					copyContent,
					value,
					tooltip,
					contentCopied,
					tooltipTarget,
					tooltipText,
					tooltipTTL,
					$$props
				];

				var i = child(span_1);

				reset(span_1);
				bind_this(span_1, ($$value) => set(tooltipTarget, $$value), () => get$3(tooltipTarget));

				template_effect(() => {
					set_class(span_1, "icon is-small is-right is-clickable " + (get$3(tooltipActive) ? ` ${tooltipClass()} ` : "") + " is-vertical-middle");
					set_class(i, `fas fa-${copyIcon() ?? ''}`);
				});

				append($$anchor, span_1);
			};

			if_block(node, ($$render) => {
				if (copiable()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var span_2 = root_2$l();

				span_2.__click = [toggleView, hidden];
				span_2.__keydown = [toggleView, hidden];

				var i_1 = child(span_2);

				reset(span_2);
				template_effect(() => set_class(i_1, `fas fa-${(hidden() ? showIcon() : hideIcon()) ?? ''}`));
				append($$anchor, span_2);
			};

			if_block(node_1, ($$render) => {
				if (showable()) $$render(consequent_1);
			});
		}

		template_effect(() => {
			set_class(span, (hidden() ? "is-censored " + shadowClass() : "") + " is-vertical-middle ");
			set_attribute(span, 'style', `display:inline-block; width: ${maxLength()}rem; height: var(--bulma-size-medium); overflow-x:hidden;`);
			set_text(text, hidden() ? "" : value());
		});

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keydown']);

	var root$K = template(`<span> </span>`);

	function Ui_indicator($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "tagId"] - if we want to address this indicator
		 * @property {string}   [state = "light"]
		 * @property {string}   [size = "normal"]
		 * @property {any}      [labels = {black, dark, light, white, primary, link, info, success, warning, danger}]
		 * @property {string}   [class = "max-1"]
		 * @property {string}   [padding = "normal"]
		 * @property {boolean}  [bold = false]
		 * @property {boolean}  [right = false]
		 * @property {boolean}  [left = left]
		 * @property {boolean}  [top = false]
		 * @property {boolean}  [bottom = false]
		 * @property {any}      [events = {}]
		 * @property {any}      [register = notCommon.registerWidgetEvents] - register event handlers
		 * @property {any}      [onUpdate = (data) => currentState = data.state]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "tagId"),
			currentState = prop($$props, 'state', 15, "light"),
			size = prop($$props, 'size', 3, "normal"),
			labels = prop($$props, 'labels', 19, () => ({
				black: "black",
				dark: "dark",
				light: "light",
				white: "white",
				primary: "primary",
				link: "link",
				info: "info",
				success: "success",
				warning: "warning",
				danger: "danger"
			})),
			classes = prop($$props, 'class', 3, "mx-1"),
			padding = prop($$props, 'padding', 3, "normal"),
			bold = prop($$props, 'bold', 3, false),
			right = prop($$props, 'right', 3, false),
			left = prop($$props, 'left', 3, false),
			top = prop($$props, 'top', 3, false),
			bottom = prop($$props, 'bottom', 3, false),
			events = prop($$props, 'events', 31, () => proxy({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "state")) {
					currentState(data.state);
				}
			});

		function getStandartUpdateEventName() {
			return `indicator-${id()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		let sided = derived(() => right() || left() || top() || bottom());
		var span = root$K();
		var text = child(span, true);

		reset(span);

		template_effect(() => {
			set_class(span, `tag is-${size() ?? ''} ${(padding() !== 'normal' ? `is-padded-${padding()}` : '') ?? ''} is-${currentState() ?? ''} ${classes() ?? ''}`);
			toggle_class(span, 'has-text-weight-bold', bold());
			toggle_class(span, 'is-sided', get$3(sided));
			toggle_class(span, 'is-sided-right', right());
			toggle_class(span, 'is-sided-left', left());
			toggle_class(span, 'is-sided-top', top());
			toggle_class(span, 'is-sided-bottom', bottom());
			set_text(text, labels()[currentState()]);
		});

		append($$anchor, span);
		pop();
	}

	var root_3$i = template(`<span class="title"> </span>`);
	var root_1$s = template(`<div><!></div>`);

	function Ui_loader($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		//hidden - no loader
		//container - parent container of form
		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [loading = false]       state if form loading
		 * @property {string}   [size = 'container']    (page, container, hidden)
		 * @property {string}   [title = 'Waiting...']  LC string
		 * @property {number}   [ttl]                   time to live, will be closed after ttl ms
		 * @property {snippet}  [children]              snippets may be provided
		 */
		/** @type {Props} */
		let loading = prop($$props, 'loading', 7, false),
			size = prop($$props, 'size', 3, "container"),
			title = prop($$props, 'title', 3, "Waiting...");

		let ttlTimer;

		onMount(() => {
			if ($$props.ttl) {
				ttlTimer = setTimeout(
					() => {
						loading(false);
						$$props.onreject();
					},
					$$props.ttl
				);
			}
		});

		onDestroy(() => {
			if (ttlTimer) {
				clearTimeout(ttlTimer);
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$s();
				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						snippet(node_2, () => $$props.children ?? noop);
						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var span = root_3$i();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span);
					};

					if_block(node_1, ($$render) => {
						if ($$props.children) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(div);

				template_effect(() => {
					set_class(div, clsx(size() === "page" ? "pageloader" : "containerloader"));
					toggle_class(div, 'is-active', loading());
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (size() !== "hidden") $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$J = template(`<option> </option>`);

	function Ui_select_option($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		var option = root$J();
		var option_value = {};
		var text = child(option, true);

		reset(option);

		template_effect(() => {
			if (option_value !== (option_value = $$props.value)) {
				option.value = null == (option.__value = $$props.value) ? '' : $$props.value;
			}

			set_selected(option, $$props.selected);
			set_text(text, $LOCALE()[$$props.title]);
		});

		append($$anchor, option);
		pop();
		$$cleanup();
	}

	var root_3$h = template(`<span class="mr-2"> </span>`);
	var root_5$a = template(`<span class="mr-2"> </span>`);
	var root_6$c = template(`<div><select><!><!></select></div>`);

	function Ui_select($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [value]
		 * @property {any}      [variants]
		 * @property {string} [placeholder = ""]
		 * @property {boolean}  [emptyValueEnabled = true]
		 * @property {string|number}  [emptyValue]
		 * @property {string} [emptyValueTitle = "no-selection"]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {string} [size]
		 * @property {string} [color]
		 * @property {boolean} [valid]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, ""),
			variants = prop($$props, 'variants', 19, () => []);
			prop($$props, 'placeholder', 3, "");
			let emptyValueTitle = prop($$props, 'emptyValueTitle', 3, "no-selection"),
			emptyValueEnabled = prop($$props, 'emptyValueEnabled', 3, true),
			emptyValue = prop($$props, 'emptyValue', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "select"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'placeholder',
				'emptyValueTitle',
				'emptyValueEnabled',
				'emptyValue',
				'fieldname',
				'required',
				'readonly',
				'size',
				'color',
				'loading',
				'valid',
				'class',
				'onchange'
			]);

		let selectedVariants = state(proxy([]));

		function filterSelectedVariants(variant) {
			if (value()) {
				return value() == variant.id;
			} else {
				return false;
			}
		}

		function checkOnClearMacro(newValue) {
			if (newValue === UICommon$1.CLEAR_MACRO) {
				value("");
			} else {
				value(newValue);
			}
		}

		function alreadyProcessed(newValue) {
			if (Array.isArray(newValue) && Array.isArray(value())) {
				if (notCommon$1.compareTwoArrays(value(), newValue)) {
					return true;
				}
			} else {
				if (newValue === value()) {
					return true;
				}
			}

			return false;
		}

		function onInput(ev) {
			const data = {
				field: fieldname(),
				value: ev.currentTarget.value
			};

			if (alreadyProcessed(data.value)) {
				return;
			}

			checkOnClearMacro(data.value);
			onchange()(data);
		}

		user_effect(() => {
			set(selectedVariants, proxy(Array.isArray(variants()) ? variants().filter(filterSelectedVariants) : []));
		});

		let invalid = derived(() => !valid());

		onMount(() => {
			if (readonly()) return;

			if (!value()) {
				if (emptyValueEnabled() && variants().length) {
					value(variants()[0].id);

					onchange()({
						field: fieldname(),
						value: variants()[0].id
					});
				}
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$3(selectedVariants), index$d, ($$anchor, selectedVariant) => {
							var span = root_3$h();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$3(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var span_1 = root_5$a();
								var text_1 = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
								append($$anchor, span_1);
							};

							if_block(
								node_3,
								($$render) => {
									if (emptyValueEnabled()) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var div = root_6$c();
				var select = child(div);
				let attributes;

				init_select(select, () => attributes.value);

				var node_4 = child(select);

				{
					var consequent_3 = ($$anchor) => {
						Ui_select_option($$anchor, {
							get value() {
								return emptyValue();
							},
							get title() {
								return emptyValueTitle();
							}
						});
					};

					if_block(node_4, ($$render) => {
						if (emptyValueEnabled()) $$render(consequent_3);
					});
				}

				var node_5 = sibling(node_4);

				each(node_5, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					const expression = derived(() => value() == get$3(variant).id);

					Ui_select_option($$anchor, {
						get value() {
							return get$3(variant).id;
						},
						get selected() {
							return get$3(expression);
						},
						get title() {
							return get$3(variant).title;
						}
					});
				});

				reset(select);
				reset(div);

				template_effect(() => {
					set_class(div, `select ${($$props.loading ? `is-loading` : '') ?? ''} ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`);

					attributes = set_attributes(select, attributes, {
						id: `form-field-select-${fieldname() ?? ''}`,
						name: fieldname(),
						oninput: onInput,
						onblur: onInput,
						readonly: readonly(),
						required: required(),
						invalid: get$3(invalid),
						size: $$props.size,
						...others
					});

					if ('value' in attributes) {
						select_option(select, attributes.value);
					}
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_2); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function onClick$7(event, onclick, $$props, action) {
		event.stopPropagation();
		onclick() && onclick()({ event, value: $$props.value });
		return action() && action()(event, $$props.value);
	}

	var root_4$f = template(`<span class="icon"><i></i></span>`);
	var root_5$9 = template(`<span> </span>`);
	var root_6$b = template(`<span class="icon"><i></i></span>`);
	var root_3$g = template(`<!> <!> <!>`, 1);
	var root$I = template(`<button><!></button>`);

	function Ui_button($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [action]
		 * @property {function} [onclick]
		 * @property {any} value
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			state = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			style = prop($$props, 'style', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			icon = prop($$props, 'icon', 3, false),
			iconSide = prop($$props, 'iconSide', 3, "right"),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			}),
			action = prop($$props, 'action', 3, () => {
				return true;
			});

		var button = root$I();

		button.__click = [onClick$7, onclick, $$props, action];

		var node = child(button);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_4 = ($$anchor) => {
						var fragment_2 = root_3$g();
						var node_3 = first_child(fragment_2);

						{
							var consequent_1 = ($$anchor) => {
								var span = root_4$f();
								var i = child(span);

								reset(span);
								template_effect(() => set_class(i, `fas fa-${icon() ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`));
								append($$anchor, span);
							};

							if_block(node_3, ($$render) => {
								if (iconSide() === "left") $$render(consequent_1);
							});
						}

						var node_4 = sibling(node_3, 2);

						{
							var consequent_2 = ($$anchor) => {
								var span_1 = root_5$9();
								var text = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text, $LOCALE()[title()]));
								append($$anchor, span_1);
							};

							if_block(node_4, ($$render) => {
								if (title()) $$render(consequent_2);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_3 = ($$anchor) => {
								var span_2 = root_6$b();
								var i_1 = child(span_2);

								reset(span_2);
								template_effect(() => set_class(i_1, `fas fa-${icon() ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`));
								append($$anchor, span_2);
							};

							if_block(node_5, ($$render) => {
								if (iconSide() === "right") $$render(consequent_3);
							});
						}

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[title()]));
						append($$anchor, text_1);
					};

					if_block(
						node_2,
						($$render) => {
							if (icon()) $$render(consequent_4); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		reset(button);

		template_effect(() => {
			button.disabled = disabled();
			set_attribute(button, 'type', type() ? type() : "");
			set_attribute(button, 'style', style());

			set_class(button, `
  button
  ${classes() ?? ''}
  ${(state() ? `is-${state()}` : '') ?? ''}
  ${(inverted() ? `is-inverted` : '') ?? ''}
  ${(outlined() ? `is-outlined` : '') ?? ''}
  ${(raised() ? `is-raised` : '') ?? ''}
  ${(rounded() ? `is-rounded` : '') ?? ''}
  ${(light() ? `is-light` : '') ?? ''}
  ${(loading() ? `is-loading` : '') ?? ''}
  ${(color() ? `is-${color()}` : '') ?? ''}
  ${(size() ? `is-${size()}` : '') ?? ''}
  `);
		});

		append($$anchor, button);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	function onClick$6(event, onclick, $$props) {
		event.stopPropagation();
		onclick() && onclick()({ event, value: $$props.value });
	}

	var root$H = template(`<button></button>`);

	function Ui_button_close($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [ariaLabel = "delete button"]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {function} [onclick]
		 * @property {any} value
		 */
		/** @type {Props} */
		let ariaLabel = prop($$props, 'ariaLabel', 3, "delete button");
			prop($$props, 'light', 3, false);
			prop($$props, 'loading', 3, false);
			prop($$props, 'raised', 3, false);
			prop($$props, 'outlined', 3, false);
			prop($$props, 'inverted', 3, false);
			prop($$props, 'rounded', 3, false);
			let disabled = prop($$props, 'disabled', 3, false);
			prop($$props, 'state', 3, "");
			prop($$props, 'color', 3, "");
			let size = prop($$props, 'size', 3, ""),
			style = prop($$props, 'style', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			});

		var button = root$H();

		button.__click = [onClick$6, onclick, $$props];

		template_effect(() => {
			set_attribute(button, 'aria-label', ariaLabel());
			button.disabled = disabled();
			set_attribute(button, 'style', style());

			set_class(button, `
  delete
  ${classes() ?? ''}  
  ${(size() ? `is-${size()}` : '') ?? ''}
  `);
		});

		append($$anchor, button);
		pop();
	}

	delegate(['click']);

	var root$G = template(`<div></div>`);

	function Ui_buttons($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {Array<object>} [values = []]
		 * @property {boolean} [centered = false]
		 * @property {boolean} [right = false]
		 * @property {string} [class = '']
		 * @property {import('svelte').Component} [buttonComponent = UIButton]
		 * @property {import('../events.types').UIEventInputChangeCallback} [action = ()=>true]
		 * @property {import('../events.types').UIEventCallback} [onclick = ()=>true]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			classes = prop($$props, 'class', 3, ""),
			SvelteComponent = prop($$props, 'buttonComponent', 3, Ui_button),
			action = prop($$props, 'action', 3, () => {
				return true;
			}),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			});

		let _values = state(proxy([]));

		user_effect(() => {
			set(_values, proxy(values().map((itm) => {
				if (isNaN(itm.id)) {
					itm.id = Math.round(Math.random() * 100);
				}

				return itm;
			})));
		});

		var div = root$G();

		each(div, 21, () => get$3(_values), (item) => item.id, ($$anchor, item, $$index) => {
			var fragment = comment();
			var node = first_child(fragment);

			component(node, SvelteComponent, ($$anchor, $$component) => {
				$$component($$anchor, spread_props(
					{
						get action() {
							return action();
						},
						get onclick() {
							return onclick();
						}
					},
					() => get$3(item),
					{
						get value() {
							return get$3(item).value;
						},
						set value($$value) {
							(get$3(item).value = $$value);
						}
					}
				));
			});

			append($$anchor, fragment);
		});

		reset(div);

		template_effect(() => {
			set_class(div, `buttons has-addons ${classes() ?? ''}`);
			toggle_class(div, 'is-right', right());
			toggle_class(div, 'is-centered', centered());
		});

		append($$anchor, div);
		pop();
	}

	var root$F = template(`<div><div class="column"><!></div> <div class="column"><!></div> <div class="column"><!></div></div>`);

	function Ui_buttons_row($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {any} [left]
		 * @property {any} [center]
		 * @property {any} [right]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			left = prop($$props, 'left', 19, () => []),
			center = prop($$props, 'center', 19, () => []),
			right = prop($$props, 'right', 19, () => []);

		var div = root$F();
		var div_1 = child(div);
		var node = child(div_1);

		Ui_buttons(node, {
			get values() {
				return left();
			}
		});

		reset(div_1);

		var div_2 = sibling(div_1, 2);
		var node_1 = child(div_2);

		Ui_buttons(node_1, {
			get values() {
				return center();
			},
			centered: true
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);
		var node_2 = child(div_3);

		Ui_buttons(node_2, {
			get values() {
				return right();
			},
			right: true
		});

		reset(div_3);
		reset(div);
		template_effect(() => set_class(div, `columns ${classes() ?? ''}`));
		append($$anchor, div);
	}

	function Ui_button_switch($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [uiOff]
		 * @property {function} [uiOn]
		 * @property {function} [action]
		 * @property {any} value
		 * @property {boolean} [selected]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			activeState = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			icon = prop($$props, 'icon', 3, false),
			iconSide = prop($$props, 'iconSide', 3, "right"),
			uiOff = prop($$props, 'uiOff', 3, () => {
				return { color: "" };
			}),
			uiOn = prop($$props, 'uiOn', 3, () => {
				return { color: "success" };
			}),
			action = prop($$props, 'action', 3, () => {
				return !selected();
			}),
			onclick = prop($$props, 'onclick', 3, () => {}),
			onchange = prop($$props, 'onchange', 3, () => {}),
			selected = prop($$props, 'selected', 15, false);

		let childProps = state(proxy({
			title: title(),
			light: light(),
			loading: loading(),
			raised: raised(),
			outlined: outlined(),
			inverted: inverted(),
			rounded: rounded(),
			disabled: disabled(),
			type: type(),
			color: color(),
			size: size(),
			class: classes(),
			icon: icon(),
			iconSide: iconSide(),
			value: $$props.value
		}));

		let uiElement = state(undefined);

		onMount(() => {
			updateUI();
		});

		function onClick(event) {
			selected(action()(event, $$props.value, selected()));
			updateUI();

			onclick()({
				value: $$props.value,
				selected: selected()
			});

			onchange()({
				value: $$props.value,
				selected: selected()
			});
		}

		function updateUI() {
			if (get$3(uiElement)) {
				const propsChanges = selected() ? uiOn()($$props.value, selected()) : uiOff()($$props.value, selected());

				Object.keys(propsChanges).forEach((key) => {
					get$3(childProps)[key] = propsChanges[key];
				});

				set(childProps, proxy(get$3(childProps)));
			}
		}

		user_effect(() => {
			if (typeof selected() !== "undefined") updateUI();
		});

		bind_this(
			Ui_button($$anchor, spread_props(() => get$3(childProps), {
				get state() {
					return activeState();
				},
				onclick: onClick
			})),
			($$value) => set(uiElement, proxy($$value)),
			() => get$3(uiElement)
		);

		return pop({ updateUI });
	}

	var root$E = template(`<div></div>`);

	function Ui_buttons_switchers($$anchor, $$props) {
		push($$props, true);

		const uis = {};

		function updateItemUI(item) {
			uis[item.id].updateUI();
		}

		const defaultAction = (ev, value, selected) => {
			const countOfSelected = countSelected();

			if (countOfSelected === min() && selected) {
				return selected;
			}

			if (countOfSelected === max() && selected !== true) {
				return selected;
			}

			const indexOfCurrent = _values.findIndex((itm) => itm.value === value);
			let newSelected = selected;

			if (indexOfCurrent > -1) {
				newSelected = !newSelected;

				const cnt = countSelected() + (newSelected ? 1 : -1);

				if (min()) {
					if (cnt < min()) {
						selectUpToMin(cnt, indexOfCurrent);
					}
				}

				if (max()) {
					if (max() < cnt) {
						deselectDownToMin(cnt, indexOfCurrent);
					}
				}

				return newSelected;
			}

			return newSelected;
		};

		/**
		 * @typedef {Object} Props
		 * @property {array<object>} [values]
		 * @property {boolean} [centered]
		 * @property {boolean} [right]
		 * @property {string} [class]
		 * @property {import('svelte').Component}      [buttonComponent = UIButtonSwitch]
		 * @property {object}   [buttonProps = {}]
		 * @property {function} [action = (event, value, selected) => boolean]  fires on button switch click, returns new state of selected
		 * @property {function} [onclick]
		 * @property {function} [onchange]
		 * @property {number} [min = 0]
		 * @property {number} [max = 100]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 23, () => []),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			classes = prop($$props, 'class', 3, ""),
			buttonComponent = prop($$props, 'buttonComponent', 3, Ui_button_switch),
			buttonProps = prop($$props, 'buttonProps', 19, () => ({})),
			action = prop($$props, 'action', 3, defaultAction),
			onclick = prop($$props, 'onclick', 3, () => true),
			onchange = prop($$props, 'onchange', 3, () => true),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100);
		let _values = proxy(values());

		function onChange() {
			values(snapshot(_values));

			const selected = values().filter((itm) => itm.selected);
			const selectedIds = selected.map((itm) => itm.id);
			const selectedCount = selectedIds.length;

			onchange() && onchange()({
				values: values(),
				selected,
				selectedIds,
				selectedCount
			});
		}

		function selectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = true;
				updateItemUI(itm);
			});

			onChange();
		}

		function deselectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = false;
				updateItemUI(itm);
			});

			onChange();
		}

		onMount(() => {
			const selectedCount = countSelected();

			if (min() && selectedCount < min()) {
				selectUpToMin(selectedCount, -1);
			}
		});

		function addToHistory(id) {
		}

		function countSelected() {
			const countOfSelected = _values.filter((btn) => {
				return btn.selected;
			}).length;

			return countOfSelected;
		}

		function toggleFirstSuited(toValue) {
			const index = _values.findIndex((itm) => !toValue == itm.selected);

			if (index > -1) {
				_values[index].selected = toValue;
				updateItemUI(_values[index]);
			}
		}

		function selectUpToMin(cnt, indexOfCurrent) {
			let delta = min() - cnt;

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (!_values[t].selected) {
					_values[t].selected = true;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function deselectDownToMin(cnt, indexOfCurrent) {
			let delta = cnt - max();

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (_values[t].selected) {
					_values[t].selected = false;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function updateUI() {
			Object.keys(uis).forEach((itemId) => {
				if (uis[itemId]) {
					uis[itemId].updateUI && uis[itemId].updateUI();
				}
			});
		}

		var div = root$E();

		each(div, 23, () => _values, (item) => item.id, ($$anchor, item, index) => {
			var fragment = comment();
			const SvelteComponent = derived(buttonComponent);
			var node = first_child(fragment);

			component(node, () => get$3(SvelteComponent), ($$anchor, $$component) => {
				bind_this(
					$$component($$anchor, spread_props(
						{
							get action() {
								return action();
							}
						},
						() => get$3(item),
						buttonProps,
						{
							get onclick() {
								return onclick();
							},
							onchange: onChange,
							get selected() {
								return _values[get$3(index)].selected;
							},
							set selected($$value) {
								_values[get$3(index)].selected = $$value;
							}
						}
					)),
					($$value, item) => uis[item.id] = $$value,
					(item) => uis?.[item.id],
					() => [get$3(item)]
				);
			});

			append($$anchor, fragment);
		});

		reset(div);
		template_effect(() => set_class(div, `buttons has-addons ${(centered() ? 'is-centered' : '') ?? ''} ${(right() ? 'is-right' : '') ?? ''} ${classes() ?? ''}`));
		append($$anchor, div);

		return pop({
			selectAll,
			deselectAll,
			addToHistory,
			countSelected,
			toggleFirstSuited,
			selectUpToMin,
			deselectDownToMin,
			updateUI
		});
	}

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIButton: Ui_button,
		UIButtonClose: Ui_button_close,
		UIButtonSwitch: Ui_button_switch,
		UIButtons: Ui_buttons,
		UIButtonsRow: Ui_buttons_row,
		UIButtonsSwitchers: Ui_buttons_switchers
	});

	var root$D = template(`<div><!></div>`);

	function Ui_field($$anchor, $$props) {
		let grouped = prop($$props, 'grouped', 3, false),
			addons = prop($$props, 'addons', 3, false),
			multiline = prop($$props, 'multiline', 3, false),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'grouped',
				'addons',
				'multiline',
				'class',
				'children'
			]);

		var div = root$D();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children);
		reset(div);

		template_effect(() => {
			attributes = set_attributes(div, attributes, {
				class: `field ${classes() ?? ''}`,
				...others
			});

			toggle_class(div, 'has-addons', addons());
			toggle_class(div, 'is-grouped', grouped());
			toggle_class(div, 'is-multiline', multiline());
		});

		append($$anchor, div);
	}

	var root$C = template(`<p><!></p>`);

	function Ui_control($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class='']
		 * @property {boolean} [hasIconsLeft=false]
		 * @property {boolean} [hasIconsRight=false]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			hasIconsLeft = prop($$props, 'hasIconsLeft', 3, false),
			hasIconsRight = prop($$props, 'hasIconsRight', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'hasIconsLeft',
				'hasIconsRight',
				'children'
			]);

		var p = root$C();
		let attributes;
		var node = child(p);

		snippet(node, () => $$props.children ?? noop);
		reset(p);

		template_effect(() => {
			attributes = set_attributes(p, attributes, {
				class: `control ${classes() ?? ''}`,
				...others
			});

			toggle_class(p, 'has-icons-left', hasIconsLeft());
			toggle_class(p, 'has-icons-right', hasIconsRight());
		});

		append($$anchor, p);
	}

	var root_4$e = template(`<!> <!>`, 1);

	function Ui_select_from_model_on_demand_inline($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_API_MODEL_GETTER = (
			modelName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch
		) => {
			return notCommon$1.getApp().getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
		};

		const DEFAULT_API_REQUEST = (apiModel, actionName) => {
			return apiModel[`$` + actionName]();
		};

		/**
		 * @typedef {Object} Props
		 * @property {string}   value                                       id of selected variant
		 * @property {array}    [variants = []]                             list of variants
		 * @property {boolean}  [loaded = false]                            true if we already loaded variants from server via API
		 * @property {string}   [placeholder = "empty select item"]         placeholder title
		 * @property {string}   [fieldname = "selectFromModel"]             this input fieldname
		 * @property {string}   [modelName = ""]                            API modelName
		 * @property {string}   [actionName = ""]                           API actionName
		 * @property {object}   [actionFilter = {}]                         API filtering rules
		 * @property {object}   [actionSorter = {}]                         API sorting rules
		 * @property {object}   [actionPager = {}]                          API pager state
		 * @property {object}   [actionSearch = undefined]                  API search string
		 * @property {string}   [optionId = ":_id"]                         variant object id field name
		 * @property {string}   [optionTitle = ":title"]                    variant object title field name
		 * @property {boolean}  [required = false]                          field is required
		 * @property {boolean}  [readonly = false]                          field is reaonly
		 * @property {number}   [size]                                      how many variants would be visible at once, default: 1
		 * @property {boolean}  [valid = true]                              field is valid
		 * @property {function} [onreject = () => false]                    callback on reject of selection process
		 * @property {function} [onresolve = () => true]                    callback on resolve of selection process
		 * @property {function} [onerror = () => true]                      callback on error
		 */
		/** @type {Props} */
		let variants = prop($$props, 'variants', 23, () => []),
			loaded = prop($$props, 'loaded', 7, false),
			placeholder = prop($$props, 'placeholder', 3, "empty select item"),
			fieldname = prop($$props, 'fieldname', 3, "selectFromModel"),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			apiModelGetter = prop($$props, 'apiModelGetter', 3, DEFAULT_API_MODEL_GETTER),
			apiRequest = prop($$props, 'apiRequest', 3, DEFAULT_API_REQUEST),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			onreject = prop($$props, 'onreject', 3, () => false),
			onresolve = prop($$props, 'onresolve', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => true);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let disabled = derived(() => !loaded());
		let componentState = state("hidden");
		let resultsList = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const response = await apiRequest()(apiModelGetter()(modelName(), actionFilter(), actionSorter(), actionPager(), actionSearch()), actionName());

				if (notCommon$1.isError(response)) {
					loaded(false);
					onerror()(response.errors || [response.message]);
				} else {
					resultsList = response.result;

					variants(resultsList.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					}));

					loaded(true);
				}
			}
		});

		let resolvedValue;

		function onModelChanged({ value: selectedValue }) {
			if (resultsList.length > variants().length) {
				resolvedValue = resultsList.find((item) => notPath.get(optionId(), item) == selectedValue);
			} else {
				resolvedValue = variants().find((item) => item.id == selectedValue);
			}
		}

		const ACTIONS = {
			add: {
				color: "primary",
				icon: "plus",
				action() {
					set(componentState, "show");
				}
			},
			resolve: {
				icon: "check",
				color: "primary",
				action() {
					set(componentState, "hidden");

					onresolve()({
						field: fieldname(),
						value: snapshot(resolvedValue)
					});
				}
			},
			reject: {
				icon: "xmark",
				color: "danger",
				action() {
					set(componentState, "hidden");
					onreject()();
				}
			}
		};

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_button($$anchor, spread_props(() => ACTIONS.add));
			};

			var alternate = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_field($$anchor, {
							addons: true,
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_4$e();
								var node_2 = first_child(fragment_4);

								Ui_control(node_2, {
									children: ($$anchor, $$slotProps) => {
										Ui_select($$anchor, {
											get value() {
												return $$props.value;
											},
											get variants() {
												return variants();
											},
											get placeholder() {
												return placeholder();
											},
											get fieldname() {
												return fieldname();
											},
											get required() {
												return required();
											},
											get readonly() {
												return readonly();
											},
											get disabled() {
												return get$3(disabled);
											},
											get size() {
												return $$props.size;
											},
											get color() {
												return $$props.color;
											},
											get valid() {
												return valid();
											},
											onchange: onModelChanged
										});
									},
									$$slots: { default: true }
								});

								var node_3 = sibling(node_2, 2);

								Ui_control(node_3, {
									children: ($$anchor, $$slotProps) => {
										const expression = derived(() => [ACTIONS.resolve, ACTIONS.reject]);

										Ui_buttons($$anchor, {
											get values() {
												return get$3(expression);
											}
										});
									},
									$$slots: { default: true }
								});

								append($$anchor, fragment_4);
							},
							$$slots: { default: true }
						});
					};

					if_block(
						node_1,
						($$render) => {
							if (get$3(componentState) == "show") $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (get$3(componentState) === "hidden") $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_select_from_model_with_search_modal($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_SERVICE_GETTER = (serviceName) => {
			if (!serviceName) throw new Error("serviceName is not set");
			return notCommon$1.getApp().getService(serviceName);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string|number}   value
		 * @property {string}   [icon = '']
		 * @property {string}   [fieldname = '']
		 * @property {boolean}  [readonly = false]
		 * @property {string}   [serviceName = ''] - Set this, as ns[ModelName], should be registered in notApp
		 * @property {string}   [serviceOpenSelectorMethod = "openSelector"] - Set this
		 * @property {string}   [serviceLoadDataMethod = "loadData"] - Set this
		 * @property {object}   [modelData = null]
		 * @property {boolean}  [loading = false]
		 * @property {function} [selectedModelTitleFormatter = (data) => data._id]
		 * @property {function} [serviceGetter = (serviceName)=>notCommon.getApp().getService(serviceName)]
		 * @property {string}   [loadingLabel = "not-node:loading_label"]
		 * @property {string}   [isEmptyLabel = "not-node:field_value_is_empty_placeholder"]
		 * @property {function} [onchange = () => true]
		 * @property {object}   [openSelectorButtonProps = {}]
		 * @property {object}   [resetButtonProps = {}]
		 * @property {object}   [emptyButtonProps = {}]
		 * @property {object}   [valueButtonProps = {}]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15),
			icon = prop($$props, 'icon', 3, "search"),
			fieldname = prop($$props, 'fieldname', 3, ""),
			readonly = prop($$props, 'readonly', 3, false),
			serviceName = prop($$props, 'serviceName', 3, ""),
			serviceOpenSelectorMethod = prop($$props, 'serviceOpenSelectorMethod', 3, "openSelector"),
			serviceLoadDataMethod = prop($$props, 'serviceLoadDataMethod', 3, "loadData"),
			modelData = prop($$props, 'modelData', 15, null),
			loading = prop($$props, 'loading', 15, false),
			selectedModelTitleFormatter = prop($$props, 'selectedModelTitleFormatter', 3, (data) => `${data._id}`),
			serviceGetter = prop($$props, 'serviceGetter', 3, DEFAULT_SERVICE_GETTER),
			loadingLabel = prop($$props, 'loadingLabel', 3, "not-node:loading_label"),
			isEmptyLabel = prop($$props, 'isEmptyLabel', 3, "not-node:field_value_is_empty_placeholder"),
			onchange = prop($$props, 'onchange', 3, () => true),
			openSelectorButtonProps = prop($$props, 'openSelectorButtonProps', 19, () => ({})),
			resetButtonProps = prop($$props, 'resetButtonProps', 19, () => ({})),
			emptyButtonProps = prop($$props, 'emptyButtonProps', 19, () => ({})),
			valueButtonProps = prop($$props, 'valueButtonProps', 19, () => ({}));

		function openModelSearchAndSelect() {
			if (!serviceOpenSelectorMethod()) {
				throw new Error("serviceOpenSelectorMethod is not set");
			}

			const service = serviceGetter()(serviceName());

			service[serviceOpenSelectorMethod()]().then((result) => {
				value(result._id);
				modelData(result);
				return value();
			}).then((value) => {
				onchange()({
					field: fieldname(),
					value,
					data: modelData()
				});
			}).catch((e) => {
				notCommon$1.report(e);
			});
		}

		function resetSelectedModel() {
			value(undefined);
			modelData(null);
			onchange()({ field: fieldname(), value: value() });
		}

		async function loadModelData() {
			try {
				if (!modelData() && value()) {
					loading(true);
					modelData(await getService()[serviceLoadDataMethod()](value()));
				}
			} catch(e) {
				notCommon$1.report(e);
			} finally {
				loading(false);
			}
		}

		onMount(() => {
			loadModelData();
		});

		const AVAILABLE_BUTTONS = [
			{
				id: 1,
				action: openModelSearchAndSelect,
				icon: icon(),
				color: "warning",
				...openSelectorButtonProps()
			},
			{
				id: 2,
				action: resetSelectedModel,
				icon: "times",
				color: "danger",
				...resetButtonProps()
			}
		];

		function getModelButton() {
			if (loading()) {
				return {
					disabled: true,
					loading: loading(),
					title: loadingLabel()
				};
			} else {
				if (modelData()) {
					return {
						disabled: readonly(),
						action: openModelSearchAndSelect,
						title: selectedModelTitleFormatter()(modelData()),
						...valueButtonProps()
					};
				} else {
					return {
						disabled: true,
						title: isEmptyLabel(),
						...emptyButtonProps()
					};
				}
			}
		}

		let VISIBLE_BUTTONS = state(proxy([]));

		user_effect(() => {
			if (value()) {
				set(VISIBLE_BUTTONS, proxy([
					getModelButton(),
					...readonly() ? [] : AVAILABLE_BUTTONS
				]));
			} else {
				set(VISIBLE_BUTTONS, proxy([
					getModelButton(),
					...readonly() ? [] : [AVAILABLE_BUTTONS[0]]
				]));
			}
		});

		Ui_control($$anchor, {
			children: ($$anchor, $$slotProps) => {
				Ui_buttons($$anchor, {
					get values() {
						return get$3(VISIBLE_BUTTONS);
					},
					class: "is-no-flex-wrap"
				});
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$B = template(`<progress> </progress>`);

	function Ui_progress($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any}      value
		 * @property {number}   [max = 100]
		 * @property {string}   [color = ""]
		 * @property {string}   [size = ""]
		 * @property {string}   [class = ""]
		 **/
		/** @type {Props} */
		let max = prop($$props, 'max', 3, 100),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, "");

		var progress = root$B();
		var text = child(progress);

		reset(progress);

		template_effect(() => {
			set_class(progress, `
  progress
  ${classes() ?? ''}
  ${(color() ? `is-${color()}` : '') ?? ''}
  ${(size() ? `is-${size()}` : '') ?? ''}`);

			set_value(progress, $$props.value);
			set_attribute(progress, 'max', max());
			set_text(text, `${$$props.value ?? ''}%`);
		});

		append($$anchor, progress);
	}

	function Ui_show_one_from_list($$anchor, $$props) {
		push($$props, true);

		const defaultFilter = (value) => value[idFieldName()] === $$props.id;

		/**
		 * @typedef {Object} Props
		 * @property {string|number}    id                          id of active item
		 * @property {array}            [values = []]               list of items
		 * @property {function}         UIComponent                 component to show active item
		 * @property {function}         component                   snippet to show active item
		 * @property {function}         UIPlaceholder               placeholder if active is unset
		 * @property {function}         placeholder                 snippet to show placeholder
		 * @property {object}           [placeholderProps = {}]     placeholder props
		 * @property {object}           [active = {}]               current active element
		 * @property {string}           [idFieldName = "_id"]       name of item property used as identificator
		 * @property {function}         [filter = (value) => value[idFieldName] === id] filtering function to select active item. default is to search for item with selected id
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			active = prop($$props, 'active', 31, () => proxy({})),
			idFieldName = prop($$props, 'idFieldName', 3, "_id"),
			filter = prop($$props, 'filter', 3, defaultFilter);

		user_effect(() => {
			active(Array.isArray(values()) && values().length && typeof $$props.id !== "undefined" ? values().find(filter() || defaultFilter) : undefined);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						snippet(node_2, () => $$props.component, active);
						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var fragment_4 = comment();
								var node_4 = first_child(fragment_4);

								component(node_4, () => $$props.UIComponent, ($$anchor, $$component) => {
									$$component($$anchor, spread_props(active));
								});

								append($$anchor, fragment_4);
							};

							if_block(
								node_3,
								($$render) => {
									if ($$props.UIComponent) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if ($$props.component) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_2 = ($$anchor) => {
				var fragment_5 = comment();
				var node_5 = first_child(fragment_5);

				{
					var consequent_5 = ($$anchor) => {
						var fragment_6 = comment();
						var node_6 = first_child(fragment_6);

						{
							var consequent_3 = ($$anchor) => {
								var fragment_7 = comment();
								var node_7 = first_child(fragment_7);

								snippet(node_7, () => $$props.placeholder, () => $$props.placeholderProps);
								append($$anchor, fragment_7);
							};

							var alternate_1 = ($$anchor) => {
								var fragment_8 = comment();
								var node_8 = first_child(fragment_8);

								{
									var consequent_4 = ($$anchor) => {
										var fragment_9 = comment();
										var node_9 = first_child(fragment_9);

										component(node_9, () => $$props.UIPlaceholder, ($$anchor, $$component) => {
											$$component($$anchor, spread_props(() => $$props.placeholderProps));
										});

										append($$anchor, fragment_9);
									};

									if_block(
										node_8,
										($$render) => {
											if ($$props.UIPlaceholder) $$render(consequent_4);
										},
										true
									);
								}

								append($$anchor, fragment_8);
							};

							if_block(node_6, ($$render) => {
								if ($$props.placeholder) $$render(consequent_3); else $$render(alternate_1, false);
							});
						}

						append($$anchor, fragment_6);
					};

					if_block(
						node_5,
						($$render) => {
							if ($$props.UIPlaceholder) $$render(consequent_5);
						},
						true
					);
				}

				append($$anchor, fragment_5);
			};

			if_block(node, ($$render) => {
				if (active()) $$render(consequent_2); else $$render(alternate_2, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$A = template(`<div><!> <!></div> <!>`, 1);

	function Ui_tag_value($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "taggedValueId"] - if we want to address this tag
		 * @property {object}   title
		 * @property {object}   value
		 * @property {array}    [actions = []]
		 * @property {string}   [class = '']
		 * @property {any}      [actionsGroupContructor = UIButtons]
		 * @property {any}      [actionsGroupProps = {}]
		 * @property {boolean}  [readonly = false]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "taggedValueId"),
			actions = prop($$props, 'actions', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			ActionsGroupContructor = prop($$props, 'actionsGroupContructor', 3, Ui_buttons),
			actionsGroupProps = prop($$props, 'actionsGroupProps', 19, () => ({})),
			readonly = prop($$props, 'readonly', 3, false);

		var fragment = root$A();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.title));
			};

			if_block(node, ($$render) => {
				if ($$props.title) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.value));
			};

			if_block(node_1, ($$render) => {
				if ($$props.value) $$render(consequent_1);
			});
		}

		reset(div);

		var node_2 = sibling(div, 2);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				component(node_3, ActionsGroupContructor, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(
						{
							get values() {
								return actions();
							}
						},
						actionsGroupProps
					));
				});

				append($$anchor, fragment_3);
			};

			if_block(node_2, ($$render) => {
				if (!readonly() && actions() && actions().length) $$render(consequent_2);
			});
		}

		template_effect(() => {
			set_class(div, `tags has-addons ${classes() ?? ''}`);
			set_attribute(div, 'id', id());
		});

		append($$anchor, fragment);
		pop();
	}

	enable_legacy_mode_flag();

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/


	/**
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/** @import { FlipParams, AnimationConfig } from './public.js' */

	/**
	 * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.
	 * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).
	 *
	 * @param {Element} node
	 * @param {{ from: DOMRect; to: DOMRect }} fromTo
	 * @param {FlipParams} params
	 * @returns {AnimationConfig}
	 */
	function flip(node, { from, to }, params = {}) {
		var { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;

		var style = getComputedStyle(node);

		// find the transform origin, expressed as a pair of values between 0 and 1
		var transform = style.transform === 'none' ? '' : style.transform;
		var [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
		ox /= node.clientWidth;
		oy /= node.clientHeight;

		// calculate effect of parent transforms and zoom
		var zoom = get_zoom(node); // https://drafts.csswg.org/css-viewport/#effective-zoom
		var sx = node.clientWidth / to.width / zoom;
		var sy = node.clientHeight / to.height / zoom;

		// find the starting position of the transform origin
		var fx = from.left + from.width * ox;
		var fy = from.top + from.height * oy;

		// find the ending position of the transform origin
		var tx = to.left + to.width * ox;
		var ty = to.top + to.height * oy;

		// find the translation at the start of the transform
		var dx = (fx - tx) * sx;
		var dy = (fy - ty) * sy;

		// find the relative scale at the start of the transform
		var dsx = from.width / to.width;
		var dsy = from.height / to.height;

		return {
			delay,
			duration: typeof duration === 'function' ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
			easing,
			css: (t, u) => {
				var x = u * dx;
				var y = u * dy;
				var sx = t + u * dsx;
				var sy = t + u * dsy;

				return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
			}
		};
	}

	/**
	 * @param {Element} element
	 */
	function get_zoom(element) {
		if ('currentCSSZoom' in element) {
			return /** @type {number} */ (element.currentCSSZoom);
		}

		/** @type {Element | null} */
		var current = element;
		var zoom = 1;

		while (current !== null) {
			zoom *= +getComputedStyle(current).zoom;
			current = /** @type {Element | null} */ (current.parentElement);
		}

		return zoom;
	}

	/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */


	/** @param {number} x */
	const linear = (x) => x;

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * @param {Element} node
	 * @param {FadeParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = linear } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	var root_1$r = template(`<option selected class="svelte-75ckfb"> </option>`);
	var root_4$d = template(`<option selected class="svelte-75ckfb"> </option>`);
	var root_7$3 = template(`<div class="tags has-addons svelte-75ckfb"><span class="tag svelte-75ckfb"> </span> <span class="tag is-delete svelte-75ckfb"></span></div>`);
	var root_6$a = template(`<div class="svelte-75ckfb"><!></div>`);
	var root_8$2 = template(`<span class="autocomplete-clear-button svelte-75ckfb"><!></span>`);
	var root_11$2 = template(`<div class="autocomplete-list-item svelte-75ckfb"><!></div>`);
	var root_17 = template(`<div class="autocomplete-list-item-no-results svelte-75ckfb"> </div>`);
	var root_9$1 = template(`<!> <!> <!>`, 1);
	var root_19$2 = template(`<div class="autocomplete-list-item-loading svelte-75ckfb"><!></div>`);
	var root_22$1 = template(`<div class="autocomplete-list-item-create svelte-75ckfb"><!></div>`);
	var root_25 = template(`<div class="autocomplete-list-item-no-results svelte-75ckfb"><!></div>`);
	var root$z = template(`<div><select class="svelte-75ckfb"><!></select> <div class="input-container svelte-75ckfb"><!> <input> <!></div> <div><!></div></div>`);

	function SimpleAutocomplete($$anchor, $$props) {
		const $$sanitized_props = legacy_rest_props($$props, [
			'children',
			'$$slots',
			'$$events',
			'$$legacy'
		]);

		const $$restProps = legacy_rest_props($$sanitized_props, [
			'highlightFilter',
			'items',
			'searchFunction',
			'labelFieldName',
			'keywordsFieldName',
			'valueFieldName',
			'labelFunction',
			'keywordsFunction',
			'valueFunction',
			'keywordsCleanFunction',
			'textCleanFunction',
			'beforeChange',
			'onChange',
			'onFocus',
			'onBlur',
			'onCreate',
			'selectFirstIfEmpty',
			'minCharactersToSearch',
			'maxItemsToShowInList',
			'multiple',
			'create',
			'ignoreAccents',
			'matchAllKeywords',
			'sortByMatchedKeywords',
			'itemFilterFunction',
			'itemSortFunction',
			'lock',
			'delay',
			'localFiltering',
			'localSorting',
			'cleanUserText',
			'lowercaseKeywords',
			'closeOnBlur',
			'orderableSelection',
			'hideArrow',
			'showClear',
			'clearText',
			'showLoadingIndicator',
			'noResultsText',
			'loadingText',
			'moreItemsText',
			'createText',
			'placeholder',
			'className',
			'inputClassName',
			'inputId',
			'name',
			'selectName',
			'selectId',
			'title',
			'html5autocomplete',
			'autocompleteOffValue',
			'readonly',
			'dropdownClassName',
			'disabled',
			'noInputStyles',
			'required',
			'debug',
			'tabindex',
			'selectedItem',
			'value',
			'highlightedItem',
			'text'
		]);

		push($$props, false);

		const showList = mutable_state();
		const hasSelection = mutable_state();
		const clearable = mutable_state();
		const locked = mutable_state();
		let items = prop($$props, 'items', 28, () => []);
		let searchFunction = prop($$props, 'searchFunction', 8, false);
		let labelFieldName = prop($$props, 'labelFieldName', 8, undefined);
		let keywordsFieldName = prop($$props, 'keywordsFieldName', 24, labelFieldName);
		let valueFieldName = prop($$props, 'valueFieldName', 8, undefined);

		let labelFunction = prop($$props, 'labelFunction', 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return labelFieldName() ? item[labelFieldName()] : item;
		});

		let keywordsFunction = prop($$props, 'keywordsFunction', 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return keywordsFieldName() ? item[keywordsFieldName()] : labelFunction()(item);
		});

		let valueFunction = prop($$props, 'valueFunction', 8, function (item, forceSingle = false) {
			if (item === undefined || item === null) {
				return item;
			}

			if (!multiple() || forceSingle) {
				return valueFieldName() ? item[valueFieldName()] : item;
			} else {
				return item.map((i) => valueFieldName() ? i[valueFieldName()] : i);
			}
		});

		let keywordsCleanFunction = prop($$props, 'keywordsCleanFunction', 8, function (keywords) {
			return keywords;
		});

		let textCleanFunction = prop($$props, 'textCleanFunction', 8, function (userEnteredText) {
			return userEnteredText;
		});

		let beforeChange = prop($$props, 'beforeChange', 8, function (oldSelectedItem, newSelectedItem) {
			return true;
		});

		let onChange = prop($$props, 'onChange', 8, function (newSelectedItem) {});
		let onFocus = prop($$props, 'onFocus', 8, function () {});
		let onBlur = prop($$props, 'onBlur', 8, function () {});

		let onCreate = prop($$props, 'onCreate', 8, function (text) {
			if (debug()) {
				console.log("onCreate: " + text);
			}
		});

		let selectFirstIfEmpty = prop($$props, 'selectFirstIfEmpty', 8, false);
		let minCharactersToSearch = prop($$props, 'minCharactersToSearch', 8, 1);
		let maxItemsToShowInList = prop($$props, 'maxItemsToShowInList', 8, 0);
		let multiple = prop($$props, 'multiple', 8, false);
		let create = prop($$props, 'create', 8, false);
		let ignoreAccents = prop($$props, 'ignoreAccents', 8, true);
		let matchAllKeywords = prop($$props, 'matchAllKeywords', 8, true);
		let sortByMatchedKeywords = prop($$props, 'sortByMatchedKeywords', 8, false);
		let itemFilterFunction = prop($$props, 'itemFilterFunction', 8, undefined);
		let itemSortFunction = prop($$props, 'itemSortFunction', 8, undefined);
		let lock = prop($$props, 'lock', 8, false);
		let delay = prop($$props, 'delay', 8, 0);
		let localFiltering = prop($$props, 'localFiltering', 8, true);
		let localSorting = prop($$props, 'localSorting', 8, true);
		let cleanUserText = prop($$props, 'cleanUserText', 8, true);
		let lowercaseKeywords = prop($$props, 'lowercaseKeywords', 8, true);
		let closeOnBlur = prop($$props, 'closeOnBlur', 8, false);
		let orderableSelection = prop($$props, 'orderableSelection', 8, false);
		let hideArrow = prop($$props, 'hideArrow', 8, false);
		let showClear = prop($$props, 'showClear', 8, false);
		let clearText = prop($$props, 'clearText', 8, "&#10006;");
		let showLoadingIndicator = prop($$props, 'showLoadingIndicator', 8, false);
		let noResultsText = prop($$props, 'noResultsText', 8, "No results found");
		let loadingText = prop($$props, 'loadingText', 8, "Loading results...");
		let moreItemsText = prop($$props, 'moreItemsText', 8, "items not shown");
		let createText = prop($$props, 'createText', 8, "Not found, add anyway?");
		let placeholder = prop($$props, 'placeholder', 8, undefined);
		let className = prop($$props, 'className', 8, undefined);
		let inputClassName = prop($$props, 'inputClassName', 8, undefined);
		let inputId = prop($$props, 'inputId', 8, undefined);
		let name = prop($$props, 'name', 8, undefined);
		let selectName = prop($$props, 'selectName', 8, undefined);
		let selectId = prop($$props, 'selectId', 8, undefined);
		let title = prop($$props, 'title', 8, undefined);
		let html5autocomplete = prop($$props, 'html5autocomplete', 8, undefined);
		let autocompleteOffValue = prop($$props, 'autocompleteOffValue', 8, "off");
		let readonly = prop($$props, 'readonly', 8, undefined);
		let dropdownClassName = prop($$props, 'dropdownClassName', 8, undefined);
		let disabled = prop($$props, 'disabled', 8, false);
		let noInputStyles = prop($$props, 'noInputStyles', 8, false);
		let required = prop($$props, 'required', 8, null);
		let debug = prop($$props, 'debug', 8, false);
		let tabindex = prop($$props, 'tabindex', 8, 0);
		let selectedItem = prop($$props, 'selectedItem', 28, () => multiple() ? [] : undefined);
		let value = prop($$props, 'value', 12, undefined);
		let highlightedItem = prop($$props, 'highlightedItem', 12, undefined);
		// --- Internal State ----
		const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);
		// HTML elements
		let input = mutable_state();
		let list = mutable_state();
		let inputContainer = mutable_state();
		// UI state
		let opened = mutable_state(false);
		let loading = mutable_state(false);
		let highlightIndex = mutable_state(-1);
		let text$1 = prop($$props, 'text', 12, undefined);
		let filteredTextLength = mutable_state(0);
		// view model
		let filteredListItems = mutable_state();
		let listItems = [];
		// requests/responses counters
		let lastRequestId = 0;
		let lastResponseId = 0;
		// other state
		let inputDelayTimeout;
		let setPositionOnNextUpdate = mutable_state(false);

		// --- Lifecycle events ---
		afterUpdate(() => {
			if (get$3(setPositionOnNextUpdate)) {
				setScrollAwareListPosition();
			}

			set(setPositionOnNextUpdate, false);
		});

		// --- Functions ---
		function safeFunction(theFunction, argument) {
			if (typeof theFunction !== "function") {
				console.error("Not a function: " + theFunction + ", argument: " + argument);
				return undefined;
			}

			let result;

			try {
				result = theFunction(argument);
			} catch(error) {
				console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
			}

			return result;
		}

		function safeStringFunction(theFunction, argument) {
			let result = safeFunction(theFunction, argument);

			if (result === undefined || result === null) {
				result = "";
			}

			if (typeof result !== "string") {
				result = result.toString();
			}

			return result;
		}

		function safeLabelFunction(item) {
			// console.log("labelFunction: " + labelFunction);
			// console.log("safeLabelFunction, item: " + item);
			return safeStringFunction(labelFunction(), item);
		}

		function safeKeywordsFunction(item) {
			// console.log("safeKeywordsFunction");
			const keywords = safeStringFunction(keywordsFunction(), item);
			let result = safeStringFunction(keywordsCleanFunction(), keywords);

			result = lowercaseKeywords() ? result.toLowerCase().trim() : result;

			if (ignoreAccents()) {
				result = removeAccents(result);
			}

			if (debug()) {
				console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
			}

			return result;
		}

		function prepareListItems() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete prepare list ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Prepare items to search");
				console.log("items: " + JSON.stringify(items()));
			}

			if (!Array.isArray(items())) {
				console.warn("Autocomplete items / search function did not return array but", items());
				items([]);
			}

			const length = items() ? items().length : 0;

			listItems = new Array(length);

			if (length > 0) {
				items().forEach((item, i) => {
					const listItem = getListItem(item);

					if (listItem === undefined) {
						console.log("Undefined item for: ", item);
					}

					listItems[i] = listItem;
				});
			}

			set(filteredListItems, listItems);

			if (debug()) {
				console.log(listItems.length + " items to search");
				console.timeEnd(timerId);
			}
		}

		function getListItem(item) {
			return {
				// keywords representation of the item
				keywords: localFiltering() ? safeKeywordsFunction(item) : [],
				// item label
				label: safeLabelFunction(item),
				// store reference to the origial item
				item
			};
		}

		function onSelectedItemChanged() {
			value(valueFunction()(selectedItem()));

			if (selectedItem() && !multiple()) {
				text$1(safeLabelFunction(selectedItem()));
			}

			set(filteredListItems, listItems);
			onChange()(selectedItem());
		}

		function prepareUserEnteredText(userEnteredText) {
			if (userEnteredText === undefined || userEnteredText === null) {
				return "";
			}

			if (!cleanUserText()) {
				return userEnteredText;
			}

			const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
			const cleanUserEnteredText = safeStringFunction(textCleanFunction(), textFiltered);
			const textTrimmed = lowercaseKeywords() ? cleanUserEnteredText.toLowerCase().trim() : cleanUserEnteredText.trim();

			return textTrimmed;
		}

		function numberOfMatches(listItem, searchWords) {
			if (!listItem) {
				return 0;
			}

			const itemKeywords = listItem.keywords;
			let matches = 0;

			searchWords.forEach((searchWord) => {
				if (itemKeywords.includes(searchWord)) {
					matches++;
				}
			});

			return matches;
		}

		async function search() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete search ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Searching user entered text: '" + text$1() + "'");
			}

			let textFiltered = prepareUserEnteredText(text$1());

			if (minCharactersToSearch() > 1 && textFiltered.length < minCharactersToSearch()) {
				textFiltered = "";
			}

			set(filteredTextLength, textFiltered.length);

			if (debug()) {
				console.log("Changed user entered text '" + text$1() + "' into '" + textFiltered + "'");
			}

			// if no search text load all items
			if (textFiltered === "") {
				if (searchFunction()) {
					// we will need to rerun the search
					items([]);

					if (debug()) {
						console.log("User entered text is empty clear list of items");
					}
				} else {
					set(filteredListItems, listItems);

					if (debug()) {
						console.log("User entered text is empty set the list of items to all items");
					}
				}

				if (closeIfMinCharsToSearchReached()) {
					if (debug()) {
						console.timeEnd(timerId);
					}

					return;
				}
			}

			if (!searchFunction()) {
				// internal search
				processListItems(textFiltered);
			} else {
				// external search which provides items
				lastRequestId = lastRequestId + 1;

				const currentRequestId = lastRequestId;

				set(loading, true);

				// searchFunction is a generator
				if (searchFunction().constructor.name === "AsyncGeneratorFunction") {
					for await (const chunk of searchFunction()(textFiltered, maxItemsToShowInList())) {
						// a chunk of an old response: throw it away
						if (currentRequestId < lastResponseId) {
							return false;
						}

						// a chunk for a new response: reset the item list
						if (currentRequestId > lastResponseId) {
							items([]);
						}

						lastResponseId = currentRequestId;
						items([...items(), ...chunk]);
						processListItems(textFiltered);
					}

					// there was nothing in the chunk
					if (lastResponseId < currentRequestId) {
						lastResponseId = currentRequestId;
						items([]);
						processListItems(textFiltered);
					}
				} else // searchFunction is a regular function
				{
					let result = await searchFunction()(textFiltered, maxItemsToShowInList());

					// If a response to a newer request has been received
					// while responses to this request were being loaded,
					// then we can just throw away this outdated results.
					if (currentRequestId < lastResponseId) {
						return false;
					}

					lastResponseId = currentRequestId;
					items(result);
					processListItems(textFiltered);
				}

				set(loading, false);
			}

			if (debug()) {
				console.timeEnd(timerId);
				console.log("Search found " + get$3(filteredListItems).length + " items");
			}
		}

		function defaultItemFilterFunction(listItem, searchWords) {
			const matches = numberOfMatches(listItem, searchWords);

			if (matchAllKeywords()) {
				return matches >= searchWords.length;
			} else {
				return matches > 0;
			}
		}

		function defaultItemSortFunction(obj1, obj2, searchWords) {
			return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
		}

		function processListItems(textFiltered) {
			// cleans, filters, orders, and highlights the list items
			prepareListItems();

			const textFilteredWithoutAccents = ignoreAccents() ? removeAccents(textFiltered) : textFiltered;
			const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter((word) => word !== "");
			// local search
			let tempfilteredListItems;

			if (localFiltering()) {
				if (itemFilterFunction()) {
					tempfilteredListItems = listItems.filter((item) => itemFilterFunction()(item.item, searchWords));
				} else {
					tempfilteredListItems = listItems.filter((item) => defaultItemFilterFunction(item, searchWords));
				}

				if (localSorting()) {
					if (itemSortFunction()) {
						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction()(item1.item, item2.item, searchWords));
					} else {
						if (sortByMatchedKeywords()) {
							tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
						}
					}
				}
			} else {
				tempfilteredListItems = listItems;
			}

			const hlfilter = highlightFilter(searchWords, "label");

			set(filteredListItems, tempfilteredListItems.map(hlfilter));
			closeIfMinCharsToSearchReached();
			return true;
		}

		// $: text, search();
		function afterCreate(createdItem) {
			let listItem;

			if (debug()) {
				console.log("createdItem", createdItem);
			}

			if ("undefined" !== typeof createdItem) {
				prepareListItems();
				set(filteredListItems, listItems);

				let index = findItemIndex(createdItem, get$3(filteredListItems));

				// if the items array was not updated, add the created item manually
				if (index <= 0) {
					items([createdItem]);
					prepareListItems();
					set(filteredListItems, listItems);
					index = 0;
				}

				if (index >= 0) {
					set(highlightIndex, index);
					listItem = get$3(filteredListItems)[get$3(highlightIndex)];
				}
			}

			return listItem;
		}

		function selectListItem(listItem) {
			if (debug()) {
				console.log("selectListItem", listItem);
			}

			if ("undefined" === typeof listItem && create()) {
				// allow undefined items if create is enabled
				const createdItem = onCreate()(text$1());

				if ("undefined" !== typeof createdItem) {
					if (typeof createdItem.then === "function") {
						createdItem.then((newItem) => {
							if ("undefined" !== typeof newItem) {
								const newListItem = afterCreate(newItem);

								if ("undefined" !== typeof newListItem) {
									selectListItem(newListItem);
								}
							}
						});

						return true;
					} else {
						listItem = afterCreate(createdItem);
					}
				}
			}

			if ("undefined" === typeof listItem) {
				if (debug()) {
					console.log(`listItem is undefined. Can not select.`);
				}

				return false;
			}

			if (get$3(locked)) {
				return true;
			}

			const newSelectedItem = listItem.item;

			if (beforeChange()(selectedItem(), newSelectedItem)) {
				// simple selection
				if (!multiple()) {
					selectedItem(undefined); // triggers change even if the the same item is selected
					selectedItem(newSelectedItem);
				} else // first selection of multiple ones
				if (!selectedItem()) {
					selectedItem([newSelectedItem]);
				} else // selecting something already selected => unselect it
				if (selectedItem().includes(newSelectedItem)) {
					selectedItem(selectedItem().filter((i) => i !== newSelectedItem));
				} else // adds the element to the selection
				{
					selectedItem([...selectedItem(), newSelectedItem]);
				}
			}

			return true;
		}

		function selectItem() {
			if (debug()) {
				console.log("selectItem", get$3(highlightIndex));
			}

			const listItem = get$3(filteredListItems)[get$3(highlightIndex)];

			if (selectListItem(listItem)) {
				if (debug()) {
					console.log("selectListItem true, closing");
				}

				close();

				if (multiple()) {
					text$1("");
					get$3(input).focus();
				}
			} else {
				if (debug()) {
					console.log("selectListItem false, not closing");
				}
			}
		}

		function up() {
			if (debug()) {
				console.log("up");
			}

			open();

			if (get$3(highlightIndex) > 0) {
				update(highlightIndex, -1);
			}

			highlight();
		}

		function down() {
			if (debug()) {
				console.log("down");
			}

			open();

			if (get$3(highlightIndex) < get$3(filteredListItems).length - 1) {
				update(highlightIndex);
			}

			highlight();
		}

		function highlight() {
			if (debug()) {
				console.log("highlight");
			}

			const query = ".selected";

			if (debug()) {
				console.log("Seaching DOM element: " + query + " in " + get$3(list));
			}

			/**
			 * @param {Element} el
			 */
			const el = get$3(list) && get$3(list).querySelector(query);

			if (el) {
				if (typeof el.scrollIntoViewIfNeeded === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoViewIfNeeded();
				} else if (el.scrollIntoView === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoView();
				} else {
					if (debug()) {
						console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
					}
				}
			} else {
				if (debug()) {
					console.warn("Selected item not found to scroll into view");
				}
			}
		}

		function onListItemClick(listItem) {
			if (debug()) {
				console.log("onListItemClick");
			}

			if (selectListItem(listItem)) {
				close();

				if (multiple()) {
					text$1("");
					get$3(input).focus();
				}
			}
		}

		function onDocumentClick(e) {
			if (debug()) {
				console.log("onDocumentClick");
			}

			if (e.composedPath().some((path) => path.classList && path.classList.contains(uniqueId))) {
				if (debug()) {
					console.log("onDocumentClick inside");
				}

				// resetListToAllItemsAndOpen();
				highlight();
			} else {
				if (debug()) {
					console.log("onDocumentClick outside");
				}

				close();
			}
		}

		function onKeyDown(e) {
			if (debug()) {
				console.log("onKeyDown");
			}

			let key = e.key;

			if (key === "Tab" && e.shiftKey) key = "ShiftTab";

			const fnmap = {
				Tab: get$3(opened) ? close : null,
				ShiftTab: get$3(opened) ? close : null,
				ArrowDown: down.bind(this),
				ArrowUp: up.bind(this),
				Escape: onEsc.bind(this),
				Backspace: multiple() && get$3(hasSelection) && !text$1() ? onBackspace.bind(this) : null
			};

			const fn = fnmap[key];

			if (typeof fn === "function") {
				fn(e);
			}
		}

		function onKeyPress(e) {
			if (debug()) {
				console.log("onKeyPress");
			}

			if (e.key === "Enter") {
				onEnter(e);
			}
		}

		function onEnter(e) {
			if (get$3(opened)) {
				e.preventDefault();
				selectItem();
			}
		}

		function onInput(e) {
			if (debug()) {
				console.log("onInput");
			}

			text$1(e.target.value);

			if (inputDelayTimeout) {
				clearTimeout(inputDelayTimeout);
			}

			if (delay()) {
				inputDelayTimeout = setTimeout(processInput, delay());
			} else {
				processInput();
			}
		}

		function unselectItem(tag) {
			if (debug()) {
				console.log("unselectItem", tag);
			}

			selectedItem(selectedItem().filter((i) => i !== tag));
			get$3(input).focus();
		}

		function processInput() {
			if (search()) {
				set(highlightIndex, 0);
				open();
			}
		}

		function onInputClick() {
			if (debug()) {
				console.log("onInputClick");
			}

			resetListToAllItemsAndOpen();
		}

		function onEsc(e) {
			if (debug()) {
				console.log("onEsc");
			}

			//if (text) return clear();
			e.stopPropagation();

			if (get$3(opened)) {
				get$3(input).focus();
				close();
			}
		}

		function onBackspace(e) {
			if (debug()) {
				console.log("onBackspace");
			}

			unselectItem(selectedItem()[selectedItem().length - 1]);
		}

		function onFocusInternal() {
			if (debug()) {
				console.log("onFocus");
			}

			onFocus()();
			resetListToAllItemsAndOpen();
		}

		function onBlurInternal() {
			if (debug()) {
				console.log("onBlur");
			}

			if (closeOnBlur()) {
				close();
			}

			onBlur()();
		}

		function resetListToAllItemsAndOpen() {
			if (debug()) {
				console.log("resetListToAllItemsAndOpen");
			}

			if (searchFunction() && !listItems.length) {
				search();
			} else if (!text$1()) {
				set(filteredListItems, listItems);
			}

			open();

			// find selected item
			if (selectedItem()) {
				if (debug()) {
					console.log("Searching currently selected item: " + JSON.stringify(selectedItem()));
				}

				const index = findItemIndex(selectedItem(), get$3(filteredListItems));

				if (index >= 0) {
					set(highlightIndex, index);
					highlight();
				}
			}
		}

		function findItemIndex(item, items) {
			if (debug()) {
				console.log("Finding index for item", item);
			}

			let index = -1;

			for (let i = 0; i < items.length; i++) {
				const listItem = items[i];

				if ("undefined" === typeof listItem) {
					if (debug()) {
						console.log(`listItem ${i} is undefined. Skipping.`);
					}

					continue;
				}

				if (debug()) {
					console.log("Item " + i + ": " + JSON.stringify(listItem));
				}

				if (item === listItem.item) {
					index = i;
					break;
				}
			}

			if (debug()) {
				if (index >= 0) {
					console.log("Found index for item: " + index);
				} else {
					console.warn("Not found index for item: " + item);
				}
			}

			return index;
		}

		function open() {
			if (debug()) {
				console.log("open");
			}

			// check if the search text has more than the min chars required
			if (get$3(locked) || notEnoughSearchText()) {
				return;
			}

			set(setPositionOnNextUpdate, true);
			set(opened, true);
		}

		function close() {
			if (debug()) {
				console.log("close");
			}

			set(opened, false);
			set(loading, false);

			if (!text$1() && selectFirstIfEmpty()) {
				set(highlightIndex, 0);
				selectItem();
			}
		}

		function notEnoughSearchText() {
			return minCharactersToSearch() > 0 && get$3(filteredTextLength) < minCharactersToSearch() && (// When no searchFunction is defined, the menu should always open when the input is focused
			searchFunction() || get$3(filteredTextLength) > 0);
		}

		function closeIfMinCharsToSearchReached() {
			if (notEnoughSearchText()) {
				close();
				return true;
			}

			return false;
		}

		function clear() {
			if (debug()) {
				console.log("clear");
			}

			text$1("");
			selectedItem(multiple() ? [] : undefined);

			setTimeout(() => {
				get$3(input).focus();
			});
		}

		function highlightFilter(keywords, field) {
			return (item) => {
				let label = item[field];
				const newItem = Object.assign({ highlighted: undefined }, item);

				newItem.highlighted = label;

				const labelLowercase = label.toLowerCase();
				const labelLowercaseNoAc = ignoreAccents() ? removeAccents(labelLowercase) : labelLowercase;

				if (keywords && keywords.length) {
					const positions = [];

					for (let i = 0; i < keywords.length; i++) {
						let keyword = keywords[i];

						if (ignoreAccents()) {
							keyword = removeAccents(keyword);
						}

						const keywordLen = keyword.length;
						let pos1 = 0;

						do {
							pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

							if (pos1 >= 0) {
								let pos2 = pos1 + keywordLen;

								positions.push([pos1, pos2]);
								pos1 = pos2;
							}
						} while (pos1 !== -1);
					}

					if (positions.length > 0) {
						const keywordPatterns = new Set();

						for (let i = 0; i < positions.length; i++) {
							const pair = positions[i];
							const pos1 = pair[0];
							const pos2 = pair[1];
							const keywordPattern = labelLowercase.substring(pos1, pos2);

							keywordPatterns.add(keywordPattern);
						}

						for (let keywordPattern of keywordPatterns) {
							// FIXME pst: workarond for wrong replacement <b> tags
							if (keywordPattern === "b") {
								continue;
							}

							const reg = new RegExp("(" + keywordPattern + ")", "ig");
							const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");

							newItem.highlighted = newHighlighted;
						}
					}
				}

				return newItem;
			};
		}

		function removeAccents(str) {
			return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
		}

		function isConfirmed(listItem) {
			if (!selectedItem()) {
				return false;
			}

			if (multiple()) {
				return selectedItem().includes(listItem);
			} else {
				return listItem === selectedItem();
			}
		}

		let draggingOver = mutable_state(false);

		function dragstart(event, index) {
			if (orderableSelection()) {
				event.dataTransfer.setData("source", index);
			}
		}

		function dragover(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, index);
			}
		}

		function dragleave(event, index) {
			if (orderableSelection()) {
				set(draggingOver, false);
			}
		}

		function drop(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, false);

				let from = parseInt(event.dataTransfer.getData("source"));
				let to = index;

				if (from != to) {
					moveSelectedItem(from, to);
				}
			}
		}

		function moveSelectedItem(from, to) {
			let newSelection = [...selectedItem()];

			if (from < to) {
				newSelection.splice(to + 1, 0, newSelection[from]);
				newSelection.splice(from, 1);
			} else {
				newSelection.splice(to, 0, newSelection[from]);
				newSelection.splice(from + 1, 1);
			}

			selectedItem(newSelection);
		}

		function setScrollAwareListPosition() {
			const { height: viewPortHeight } = window.visualViewport;
			const { bottom: inputButtom, height: inputHeight } = get$3(inputContainer).getBoundingClientRect();
			const { height: listHeight } = get$3(list).getBoundingClientRect();

			if (inputButtom + listHeight > viewPortHeight) {
				mutate(list, get$3(list).style.top = `-${inputHeight + listHeight}px`);
			} else {
				mutate(list, get$3(list).style.top = "0px");
			}
		}

		legacy_pre_effect(
			() => (
				deep_read_state(items()),
				deep_read_state(searchFunction())
			),
			() => {
				(
					items(),
					searchFunction() || prepareListItems()
				);
			}
		);

		legacy_pre_effect(() => (deep_read_state(selectedItem())), () => {
			(
				selectedItem(),
				onSelectedItemChanged()
			);
		});

		legacy_pre_effect(
			() => (
				get$3(filteredListItems),
				get$3(highlightIndex)
			),
			() => {
				highlightedItem(get$3(filteredListItems) && get$3(highlightIndex) && get$3(highlightIndex) >= 0 && get$3(highlightIndex) < get$3(filteredListItems).length ? get$3(filteredListItems)[get$3(highlightIndex)].item : null);
			}
		);

		legacy_pre_effect(
			() => (
				get$3(opened),
				deep_read_state(items()),
				get$3(filteredTextLength)
			),
			() => {
				set(showList, get$3(opened) && (items() && items().length > 0 || get$3(filteredTextLength) > 0));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(multiple()),
				deep_read_state(selectedItem())
			),
			() => {
				set(hasSelection, multiple() && selectedItem() && selectedItem().length > 0 || !multiple() && selectedItem());
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(showClear()),
				deep_read_state(lock()),
				deep_read_state(multiple()),
				get$3(hasSelection)
			),
			() => {
				set(clearable, showClear() || (lock() || multiple()) && get$3(hasSelection));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(lock()),
				get$3(hasSelection)
			),
			() => {
				set(locked, lock() && get$3(hasSelection));
			}
		);

		legacy_pre_effect_reset();
		init();

		var div = root$z();

		event('click', $window, onDocumentClick);
		event('scroll', $window, () => set(setPositionOnNextUpdate, true));

		var select = child(div);
		var node = child(select);

		{
			var consequent = ($$anchor) => {
				var option = root_1$r();
				var option_value = {};
				var text_1 = child(option, true);

				reset(option);

				template_effect(
					($0, $1) => {
						if (option_value !== (option_value = $0)) {
							option.value = null == (option.__value = $0) ? '' : $0;
						}

						set_text(text_1, $1);
					},
					[
						() => valueFunction()(selectedItem(), true),
						() => safeLabelFunction(selectedItem())
					],
					derived_safe_equal
				);

				append($$anchor, option);
			};

			var alternate = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 1, selectedItem, index$d, ($$anchor, i) => {
							var option_1 = root_4$d();
							var option_1_value = {};
							var text_2 = child(option_1, true);

							reset(option_1);

							template_effect(
								($0, $1) => {
									if (option_1_value !== (option_1_value = $0)) {
										option_1.value = null == (option_1.__value = $0) ? '' : $0;
									}

									set_text(text_2, $1);
								},
								[
									() => valueFunction()(get$3(i), true),
									() => safeLabelFunction(get$3(i))
								],
								derived_safe_equal
							);

							append($$anchor, option_1);
						});

						append($$anchor, fragment_1);
					};

					if_block(
						node_1,
						($$render) => {
							if (multiple() && get$3(hasSelection)) $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment);
			};

			if_block(node, ($$render) => {
				if (!multiple() && get$3(hasSelection)) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(select);

		var div_1 = sibling(select, 2);
		var node_3 = child(div_1);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_2 = comment();
				var node_4 = first_child(fragment_2);

				each(node_4, 11, selectedItem, (tagItem) => valueFunction()(tagItem, true), ($$anchor, tagItem, i) => {
					var div_2 = root_6$a();

					set_attribute(div_2, 'draggable', true);

					var node_5 = child(div_2);
					const expression = derived_safe_equal(() => safeLabelFunction(get$3(tagItem)));

					slot(
						node_5,
						$$props,
						'tag',
						{
							get label() {
								return get$3(expression);
							},
							get item() {
								return get$3(tagItem);
							},
							unselectItem
						},
						($$anchor) => {
							var div_3 = root_7$3();
							var span = child(div_3);
							var text_3 = child(span, true);

							reset(span);

							var span_1 = sibling(span, 2);
							var event_handler = derived(() => unselectItem(get$3(tagItem)));

							reset(div_3);

							template_effect(
								($0) => set_text(text_3, $0),
								[
									() => safeLabelFunction(get$3(tagItem))
								],
								derived_safe_equal
							);

							event('click', span_1, preventDefault(function (...$$args) {
								get$3(event_handler)?.apply(this, $$args);
							}));

							event('keypress', span_1, preventDefault((e) => {
								e.key == "Enter" && unselectItem(get$3(tagItem));
							}));

							append($$anchor, div_3);
						}
					);

					reset(div_2);
					template_effect(() => toggle_class(div_2, 'is-active', get$3(draggingOver) === get$3(i)));
					animation(div_2, () => flip, () => ({ duration: 200 }));
					transition(3, div_2, () => fade, () => ({ duration: 200 }));
					event('dragstart', div_2, (event) => dragstart(event, get$3(i)));
					event('dragover', div_2, (event) => dragover(event, get$3(i)));
					event('dragleave', div_2, (event) => dragleave(event, get$3(i)));
					event('drop', div_2, (event) => drop(event, get$3(i)));
					append($$anchor, div_2);
				});

				append($$anchor, fragment_2);
			};

			if_block(node_3, ($$render) => {
				if (multiple() && get$3(hasSelection)) $$render(consequent_2);
			});
		}

		var input_1 = sibling(node_3, 2);

		remove_input_defaults(input_1);

		let attributes;

		bind_this(input_1, ($$value) => set(input, $$value), () => get$3(input));

		var node_6 = sibling(input_1, 2);

		{
			var consequent_3 = ($$anchor) => {
				var span_2 = root_8$2();
				var node_7 = child(span_2);

				html(node_7, clearText);
				reset(span_2);
				event('click', span_2, clear);

				event('keypress', span_2, (e) => {
					e.key == "Enter" && clear();
				});

				append($$anchor, span_2);
			};

			if_block(node_6, ($$render) => {
				if (get$3(clearable)) $$render(consequent_3);
			});
		}

		reset(div_1);
		bind_this(div_1, ($$value) => set(inputContainer, $$value), () => get$3(inputContainer));

		var div_4 = sibling(div_1, 2);
		var node_8 = child(div_4);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_3 = root_9$1();
				var node_9 = first_child(fragment_3);

				slot(
					node_9,
					$$props,
					'dropdown-header',
					{
						get nbItems() {
							return get$3(filteredListItems).length;
						},
						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					null
				);

				var node_10 = sibling(node_9, 2);

				each(node_10, 1, () => get$3(filteredListItems), index$d, ($$anchor, listItem, i) => {
					var fragment_4 = comment();
					var node_11 = first_child(fragment_4);

					{
						var consequent_5 = ($$anchor) => {
							var div_5 = root_11$2();
							var node_12 = child(div_5);

							slot(
								node_12,
								$$props,
								'item',
								{
									get item() {
										return get$3(listItem).item;
									},
									get label() {
										return get$3(listItem).highlighted ? get$3(listItem).highlighted : get$3(listItem).label;
									}
								},
								($$anchor) => {
									var fragment_5 = comment();
									var node_13 = first_child(fragment_5);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_6 = comment();
											var node_14 = first_child(fragment_6);

											html(node_14, () => get$3(listItem).highlighted);
											append($$anchor, fragment_6);
										};

										var alternate_1 = ($$anchor) => {
											var fragment_7 = comment();
											var node_15 = first_child(fragment_7);

											html(node_15, () => get$3(listItem).label);
											append($$anchor, fragment_7);
										};

										if_block(node_13, ($$render) => {
											if (get$3(listItem).highlighted) $$render(consequent_4); else $$render(alternate_1, false);
										});
									}

									append($$anchor, fragment_5);
								}
							);

							reset(div_5);

							template_effect(
								($0) => {
									toggle_class(div_5, 'selected', i === get$3(highlightIndex));
									toggle_class(div_5, 'confirmed', $0);
								},
								[
									() => isConfirmed(get$3(listItem).item)
								],
								derived_safe_equal
							);

							event('click', div_5, () => onListItemClick(get$3(listItem)));

							event('keypress', div_5, (e) => {
								e.key == "Enter" && onListItemClick(get$3(listItem));
							});

							event('pointerenter', div_5, () => {
								set(highlightIndex, i);
							});

							append($$anchor, div_5);
						};

						if_block(node_11, ($$render) => {
							if (get$3(listItem) && (maxItemsToShowInList() <= 0 || i < maxItemsToShowInList())) $$render(consequent_5);
						});
					}

					append($$anchor, fragment_4);
				});

				var node_16 = sibling(node_10, 2);

				slot(
					node_16,
					$$props,
					'dropdown-footer',
					{
						get nbItems() {
							return get$3(filteredListItems).length;
						},
						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					($$anchor) => {
						var fragment_8 = comment();
						var node_17 = first_child(fragment_8);

						{
							var consequent_7 = ($$anchor) => {
								var fragment_9 = comment();
								var node_18 = first_child(fragment_9);

								{
									var consequent_6 = ($$anchor) => {
										var div_6 = root_17();
										var text_4 = child(div_6);

										reset(div_6);

										template_effect(() => set_text(text_4, `...${get$3(filteredListItems).length - maxItemsToShowInList() ?? ''}
              ${moreItemsText() ?? ''}`));

										append($$anchor, div_6);
									};

									if_block(node_18, ($$render) => {
										if (moreItemsText()) $$render(consequent_6);
									});
								}

								append($$anchor, fragment_9);
							};

							if_block(node_17, ($$render) => {
								if (maxItemsToShowInList() > 0 && get$3(filteredListItems).length > maxItemsToShowInList()) $$render(consequent_7);
							});
						}

						append($$anchor, fragment_8);
					}
				);

				append($$anchor, fragment_3);
			};

			var alternate_4 = ($$anchor) => {
				var fragment_10 = comment();
				var node_19 = first_child(fragment_10);

				{
					var consequent_9 = ($$anchor) => {
						var div_7 = root_19$2();
						var node_20 = child(div_7);

						slot(
							node_20,
							$$props,
							'loading',
							{
								get loadingText() {
									return loadingText();
								}
							},
							($$anchor) => {
								var text_5 = text();

								template_effect(() => set_text(text_5, loadingText()));
								append($$anchor, text_5);
							}
						);

						reset(div_7);
						append($$anchor, div_7);
					};

					var alternate_3 = ($$anchor) => {
						var fragment_12 = comment();
						var node_21 = first_child(fragment_12);

						{
							var consequent_10 = ($$anchor) => {
								var div_8 = root_22$1();
								var node_22 = child(div_8);

								slot(
									node_22,
									$$props,
									'create',
									{
										get createText() {
											return createText();
										}
									},
									($$anchor) => {
										var text_6 = text();

										template_effect(() => set_text(text_6, createText()));
										append($$anchor, text_6);
									}
								);

								reset(div_8);
								event('click', div_8, selectItem);

								event('keypress', div_8, (e) => {
									e.key == "Enter" && selectItem();
								});

								append($$anchor, div_8);
							};

							var alternate_2 = ($$anchor) => {
								var fragment_14 = comment();
								var node_23 = first_child(fragment_14);

								{
									var consequent_11 = ($$anchor) => {
										var div_9 = root_25();
										var node_24 = child(div_9);

										slot(
											node_24,
											$$props,
											'no-results',
											{
												get noResultsText() {
													return noResultsText();
												}
											},
											($$anchor) => {
												var text_7 = text();

												template_effect(() => set_text(text_7, noResultsText()));
												append($$anchor, text_7);
											}
										);

										reset(div_9);
										append($$anchor, div_9);
									};

									if_block(
										node_23,
										($$render) => {
											if (noResultsText()) $$render(consequent_11);
										},
										true
									);
								}

								append($$anchor, fragment_14);
							};

							if_block(
								node_21,
								($$render) => {
									if (create()) $$render(consequent_10); else $$render(alternate_2, false);
								},
								true
							);
						}

						append($$anchor, fragment_12);
					};

					if_block(
						node_19,
						($$render) => {
							if (get$3(loading) && loadingText()) $$render(consequent_9); else $$render(alternate_3, false);
						},
						true
					);
				}

				append($$anchor, fragment_10);
			};

			if_block(node_8, ($$render) => {
				if (get$3(filteredListItems) && get$3(filteredListItems).length > 0) $$render(consequent_8); else $$render(alternate_4, false);
			});
		}

		reset(div_4);
		bind_this(div_4, ($$value) => set(list, $$value), () => get$3(list));
		reset(div);

		template_effect(() => {
			set_class(div, `${(className() ? className() : '') ?? ''} autocomplete select is-fullwidth ${uniqueId ?? ''} svelte-75ckfb`);
			toggle_class(div, 'hide-arrow', hideArrow() || !items().length);
			toggle_class(div, 'is-multiple', multiple());
			toggle_class(div, 'show-clear', get$3(clearable));
			toggle_class(div, 'is-loading', showLoadingIndicator() && get$3(loading));
			set_attribute(select, 'name', selectName());
			set_attribute(select, 'id', selectId());
			select.multiple = multiple();

			attributes = set_attributes(
				input_1,
				attributes,
				{
					type: 'text',
					class: `${(inputClassName() ? inputClassName() : '') ?? ''} ${(noInputStyles() ? '' : 'input autocomplete-input') ?? ''}`,
					id: inputId() ? inputId() : "",
					autocomplete: html5autocomplete() ? "on" : autocompleteOffValue(),
					placeholder: placeholder(),
					name: name(),
					disabled: disabled(),
					required: required(),
					title: title(),
					readonly: readonly() || get$3(locked),
					tabindex: tabindex(),
					...$$restProps
				},
				'svelte-75ckfb'
			);

			set_class(div_4, `${(dropdownClassName() ? dropdownClassName() : '') ?? ''} autocomplete-list ${(get$3(showList) ? '' : 'hidden') ?? ''}
    is-fullwidth svelte-75ckfb`);
		});

		bind_value(input_1, text$1);
		event('input', input_1, onInput);
		event('focus', input_1, onFocusInternal);
		event('blur', input_1, onBlurInternal);
		event('keydown', input_1, onKeyDown);
		event('click', input_1, onInputClick);
		event('keypress', input_1, onKeyPress);
		event('dragover', input_1, (event) => dragover(event, selectedItem().length - 1));
		event('drop', input_1, (event) => drop(event, selectedItem().length - 1));
		append($$anchor, div);
		bind_prop($$props, 'highlightFilter', highlightFilter);
		return pop({ highlightFilter });
	}

	var root_1$q = template(`<p> </p>`);
	var root_2$k = template(`<input>`);

	function Ui_textfield($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "textfield"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			size = prop($$props, 'size', 3, "normal"),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'required',
				'disabled',
				'size',
				'readonly',
				'valid',
				'color',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$q();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$k();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-textfield-${fieldname() ?? ''}`,
					class: `input ${(size() ? `is-${size()}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'text',
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_3$f = template(`<p> </p>`);

	function Ui_autocomplete($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * More properties at https://github.com/pstanoev/simple-svelte-autocomplete#properties
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {string} [placeholder = '']
		 * @property {string} [fieldname = 'autocomplete']
		 * @property {boolean} [disabled = false]
		 * @property {boolean} [readonly = false]
		 * @property {boolean} [required = false]
		 * @property {boolean} [valid = true]
		 * @property {function} [onchange]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "autocomplete"),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			required = prop($$props, 'required', 3, false),
			valid = prop($$props, 'valid', 3, true),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'disabled',
				'readonly',
				'required',
				'valid',
				'onchange'
			]);

		let invalid = derived(() => !valid());

		function onChange(val) {
			if (onchange()) {
				onchange()({
					value: snapshot(val),
					field: fieldname()
				});
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				const expression = derived(() => value() ? value().title : "");

				Ui_textfield($$anchor, spread_props(
					{
						get value() {
							return get$3(expression);
						},
						get fieldname() {
							return fieldname();
						},
						get placeholder() {
							return placeholder();
						}
					},
					() => others
				));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var p = root_3$f();
						var text = child(p, true);

						reset(p);
						template_effect(() => set_text(text, value() ? value()?.title ?? "" : ""));
						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						SimpleAutocomplete($$anchor, spread_props(
							{
								onChange,
								get placeholder() {
									return $LOCALE()[placeholder()];
								},
								get valid() {
									return valid();
								},
								get invalid() {
									return get$3(invalid);
								},
								get required() {
									return required();
								}
							},
							() => others,
							{
								get selectedItem() {
									return value();
								},
								set selectedItem($$value) {
									value($$value);
								}
							}
						));
					};

					if_block(
						node_1,
						($$render) => {
							if (readonly()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (disabled()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$y = template(`<input>`);

	function Ui_color($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "color"),
			disabled = prop($$props, 'disabled', 3, false),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'size',
				'color',
				'disabled',
				'required',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var input = root$y();

		remove_input_defaults(input);

		let attributes;

		template_effect(() => attributes = set_attributes(input, attributes, {
			id: `form-field-color-${fieldname() ?? ''}`,
			class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
			type: 'color',
			name: fieldname(),
			invalid: get$3(invalid),
			required: required(),
			readonly: readonly(),
			disabled: disabled(),
			placeholder: $LOCALE()[placeholder()],
			autocomplete: fieldname(),
			'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
			'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
			...optionalProps,
			...others
		}));

		bind_value(input, value);
		append($$anchor, input);
		pop();
		$$cleanup();
	}

	var root$x = template(`<label><!></label>`);

	function Ui_label($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} for
		 * @property {string} [label='label']
		 * @property {string} [class = '']
		 */
		/** @type {Props} */
		let label = prop($$props, 'label', 3, "label"),
			labelClass = prop($$props, 'class', 3, "");

		var label_1 = root$x();
		var node = child(label_1);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var text$1 = text();

				template_effect(() => set_text(text$1, label() ? $LOCALE()[label()] : ""));
				append($$anchor, text$1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(label_1);

		template_effect(() => {
			set_class(label_1, `label ${labelClass() ?? ''}`);
			set_attribute(label_1, 'for', $$props.for);
		});

		append($$anchor, label_1);
		pop();
		$$cleanup();
	}

	var root_3$e = template(`<input> `, 1);

	function Ui_checkbox($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, false),
			label = prop($$props, 'label', 3, "checkbox"),
			fieldname = prop($$props, 'fieldname', 3, "checkbox"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			labelClass = prop($$props, 'labelClass', 3, "checkbox"),
			reactOn = prop($$props, 'reactOn', 19, () => ["onchange", "oninput"]),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'label',
				'fieldname',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class',
				'labelClass',
				'reactOn'
			]);

		let invalid = derived(() => !valid());
		const id = `form-field-checkbox-${fieldname()}`;
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange, undefined, { id: $$props?.id });

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		Ui_label($$anchor, {
			get class() {
				return labelClass();
			},
			get disabled() {
				return disabled();
			},
			for: id,
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_boolean($$anchor, {
							get LC_TRUE() {
								return label();
							},
							get LC_FALSE() {
								return label();
							},
							get value() {
								return value();
							}
						});
					};

					var alternate = ($$anchor) => {
						var fragment_3 = root_3$e();
						var input = first_child(fragment_3);

						remove_input_defaults(input);

						let attributes;
						var text = sibling(input);

						template_effect(() => {
							attributes = set_attributes(input, attributes, {
								id,
								class: classes(),
								type: 'checkbox',
								name: fieldname(),
								required: required(),
								readonly: readonly(),
								invalid: get$3(invalid),
								disabled: disabled(),
								'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
								'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
								...optionalProps,
								...others
							});

							set_text(text, ` ${$LOCALE()[label()] ?? ''}`);
						});

						bind_checked(input, value);
						append($$anchor, fragment_3);
					};

					if_block(node, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	function Ui_checkbox_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 27, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "checkbox-list"),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'fieldname'
			]);

		function onchange(data, ev, additional) {
			if (!additional) {
				return;
			}

			if (data.value) {
				if (!value().includes(additional.id)) {
					value().push(additional.id);
				}
			} else {
				if (value().includes(additional.id)) {
					value().splice(value().indexOf(additional.id), 1);
				}
			}

			$$props?.onchange(
				{
					field: fieldname(),
					value: snapshot(value())
				},
				ev,
				additional
			);
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, variants, (item) => item.id, ($$anchor, item) => {
			const expression = derived(() => `${fieldname()}-${get$3(item).id}`);
			const expression_1 = derived(() => value().includes(get$3(item).id));

			Ui_checkbox($$anchor, spread_props(() => others, () => get$3(item), {
				get fieldname() {
					return get$3(expression);
				},
				get value() {
					return get$3(expression_1);
				},
				onchange
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$p = template(`<p><time> </time></p>`);
	var root_2$j = template(`<input>`);

	function Ui_date($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy(new Date())),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "datetime"),
			pattern = prop($$props, 'pattern', 3, "d{4}-d{2}-d{2}"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'pattern',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		onMount(() => {
			if (value() instanceof Date) {
				value(value().toISOString().split("T")[0]);
			} else if (value().indexOf("T") > 0) {
				value(value().split("T")[0]);
			}
		});

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$p();
				var time = child(p);
				var text = child(time, true);

				reset(time);
				reset(p);

				template_effect(
					($0) => {
						set_attribute(time, 'datetime', value());
						set_text(text, $0);
					},
					[
						() => UICommon$1.tryFormatLocaleDateTime(value())
					]
				);

				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$j();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-date-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'date',
					name: fieldname(),
					invalid: get$3(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					pattern: pattern(),
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$i = template(`<p> </p>`);
	var root_3$d = template(`<input>`);

	function Ui_datetime_in_tz($$anchor, $$props) {
		push($$props, true);

		function removeMsFromDate(isoDate, markAsZULU = false) {
			return isoDate.split(".")[0] + (markAsZULU ? "" : "Z");
		}

		function removeSecFromDate(isoDate, markAsZULU = false) {
			return isoDate.slice(0, isoDate.lastIndexOf(":")) + (markAsZULU ? "" : "Z");
		}

		function shiftDatetime(isoDate, shift) {
			try {
				const dateUtc = new Date(markAsZULU(isoDate)).getTime();
				const offset = shift * -60000;

				if (dateIsValid(dateUtc + offset)) {
					const newDate = new Date(dateUtc + offset);
					const newIsoDate = newDate.toISOString();

					return removeSecFromDate(removeMsFromDate(newIsoDate, true), true);
				}
			} catch {
				return;
			}
		}

		function markAsZULU(dateString) {
			return dateString && dateString.at(-1) !== "Z" ? dateString + "Z" : dateString;
		}

		function humanReadable(isoDate) {
			return UICommon$1.tryFormatLocaleDateTime(isoDate);
		}

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, 'fieldname', 3, "datetimeInTZ"),
			value = prop($$props, 'value', 31, () => proxy(removeSecFromDate(removeMsFromDate(new Date().toISOString())))),
			timezoneOffset = prop($$props, 'timezoneOffset', 3, 0);
			prop($$props, 'human', 3, true);
			let required = prop($$props, 'required', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'fieldname',
				'value',
				'timezoneOffset',
				'human',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class',
				'onchange'
			]);

		let shiftedValue = state(undefined),
			prevShiftedValue;

		const setShifted = (val) => {
			if (dateIsValid(val)) {
				prevShiftedValue = get$3(shiftedValue);
				set(shiftedValue, proxy(val));
			}
		};

		const resetShiftedValue = () => {
			set(shiftedValue, proxy(prevShiftedValue));
		};

		onMount(() => {
			setShifted(shiftDatetime(value(), timezoneOffset()));
		});

		const dateIsValid = (date) => {
			try {
				new Date(date);
				return true;
			} catch {
				return false;
			}
		};

		const changed = () => value() !== shiftDatetime(get$3(shiftedValue), -timezoneOffset());

		const dispatchChange = () => {
			setShifted(get$3(shiftedValue));
			value(markAsZULU(shiftDatetime(get$3(shiftedValue), -timezoneOffset())));

			onchange()({
				field: fieldname(),
				value: snapshot(value())
			});
		};

		function onChange(ev) {
			if (ev.currentTarget.value && get$3(shiftedValue) && dateIsValid(get$3(shiftedValue))) {
				if (changed()) {
					dispatchChange();
				}

				return true;
			} else {
				resetShiftedValue();
			}

			return false;
		}

		let invalid = derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var p = root_2$i();
						var text = child(p, true);

						reset(p);

						template_effect(($0) => set_text(text, $0), [
							() => humanReadable(get$3(shiftedValue))
						]);

						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						var input = root_3$d();

						remove_input_defaults(input);

						let attributes;

						template_effect(() => attributes = set_attributes(input, attributes, {
							id: `form-field-datetime-in-timezone-${fieldname() ?? ''}`,
							class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
							type: 'datetime-local',
							name: fieldname(),
							invalid: get$3(invalid),
							disabled: disabled(),
							required: required(),
							readonly: readonly(),
							autocomplete: fieldname(),
							onchange: onChange,
							onblur: onChange,
							oninput: onChange,
							'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
							'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
							...others
						}));

						bind_value(input, () => get$3(shiftedValue), ($$value) => set(shiftedValue, $$value));
						append($$anchor, input);
					};

					if_block(node_1, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$3(shiftedValue)) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$o = template(`<p> </p>`);
	var root_2$h = template(`<input>`);

	function Ui_email($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "email"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$o();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$h();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-email-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'email',
					name: fieldname(),
					invalid: get$3(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$w = template(`<input type="hidden">`);

	function Ui_hidden($$anchor, $$props) {
		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			fieldname = prop($$props, 'fieldname', 3, "hidden"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'fieldname',
				'required',
				'readonly'
			]);

		var input = root$w();

		remove_input_defaults(input);

		template_effect(() => {
			set_attribute(input, 'id', `form-field-hidden-${fieldname() ?? ''}`);
			input.required = required();
			input.readOnly = readonly();
			set_attribute(input, 'name', fieldname());
			set_attribute(input, 'others', others);
		});

		bind_value(input, value);
		append($$anchor, input);
	}

	var root_1$n = template(`<p> </p>`);
	var root_2$g = template(`<textarea></textarea>`);

	function Ui_textarea($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "textarea"),
			rows = prop($$props, 'rows', 3, 10),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'rows',
				'size',
				'color',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$n();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var textarea = root_2$g();

				remove_textarea_child(textarea);

				let attributes;

				template_effect(() => attributes = set_attributes(textarea, attributes, {
					id: `form-field-textarea-${fieldname() ?? ''}`,
					class: `textarea ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					placeholder: $LOCALE()[placeholder()],
					rows: rows(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(textarea, value);
				append($$anchor, textarea);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_json_area($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy({})),
			fieldname = prop($$props, 'fieldname', 3, "jsonarea"),
			valid = prop($$props, 'valid', 15, true),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => {}),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur"]),
			colorValid = prop($$props, 'colorValid', 3, "success"),
			colorInvalid = prop($$props, 'colorInvalid', 3, "danger"),
			validationDelay = prop($$props, 'validationDelay', 3, 1000),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'fieldname',
				'valid',
				'onchange',
				'onerror',
				'reactOn',
				'colorValid',
				'colorInvalid',
				'validationDelay'
			]);

		let _value = state("{}");

		onMount(() => {
			try {
				set(_value, proxy(JSON.stringify(snapshot(value()), null, 4)));
			} catch {
				set(_value, "{}");
			}
		});

		let delayedValidation;

		function onChange(val) {
			try {
				value(JSON.parse(val));
				valid(true);

				onchange()({
					field: fieldname(),
					value: snapshot(value())
				});
			} catch(error) {
				valid(false);
				onerror()(error);
			}

			return true;
		}

		function delayedOnChange(data) {
			const { value: val } = data;

			if (delayedValidation) {
				clearTimeout(delayedValidation);
			}

			delayedValidation = setTimeout(
				() => {
					onChange(val);
				},
				validationDelay()
			);
		}

		let color = derived(() => valid() ? colorValid() : colorInvalid());

		Ui_textarea($$anchor, spread_props(
			{
				get fieldname() {
					return fieldname();
				},
				onchange: delayedOnChange,
				get reactOn() {
					return reactOn();
				},
				get valid() {
					return valid();
				},
				get color() {
					return get$3(color);
				}
			},
			() => others,
			{
				get value() {
					return get$3(_value);
				},
				set value($$value) {
					set(_value, proxy($$value));
				}
			}
		));

		pop();
	}

	var _lib = /*#__PURE__*/new WeakMap();
	let Lib = /*#__PURE__*/function () {
	  function Lib(seedLib) {
	    _classCallCheck(this, Lib);
	    _classPrivateFieldInitSpec(this, _lib, {});
	    if (seedLib instanceof Lib) {
	      this.import(seedLib.getContent());
	    }
	  }

	  /**
	   *
	   * @params {string}  mode what to do if element exists [replace|add|skip]
	   */
	  return _createClass(Lib, [{
	    key: "add",
	    value: function add(name, comp, mode = "replace") {
	      if (this.contains(name)) {
	        if (mode === "replace") {
	          _classPrivateFieldGet2(_lib, this)[name] = comp;
	        } else if (mode === "add") {
	          _classPrivateFieldGet2(_lib, this)[name] = Object.assign(_classPrivateFieldGet2(_lib, this)[name], comp);
	        }
	      } else {
	        _classPrivateFieldGet2(_lib, this)[name] = comp;
	      }
	    }
	  }, {
	    key: "get",
	    value: function get(name) {
	      return _classPrivateFieldGet2(_lib, this)[name];
	    }
	  }, {
	    key: "contains",
	    value: function contains(name) {
	      return Object.hasOwn(_classPrivateFieldGet2(_lib, this), name);
	    }
	  }, {
	    key: "import",
	    value: function _import(bulk, mode = "replace") {
	      for (let f in bulk) {
	        this.add(f, bulk[f], mode);
	      }
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return Object.keys(_classPrivateFieldGet2(_lib, this)).length === 0;
	    }
	  }, {
	    key: "getContent",
	    value: function getContent() {
	      return {
	        ..._classPrivateFieldGet2(_lib, this)
	      };
	    }
	  }]);
	}();

	/*
	 * Библиотека UI конструкторов
	 */

	const COMPONENTS$1 = new Lib();
	const FIELDS$1 = new Lib();
	const VARIANTS$1 = new Lib();

	var root$v = template(`<!> <!>`, 1);

	function Ui_title($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = `title-${Math.random()}`]
		 * @property {string}   [title = '']
		 * @property {string}   [subtitle]
		 * @property {number}   [size = 1]
		 * @property {number}   [subsize]
		 * @property {boolean}  [spaced = false]
		 * @property {string}   [align = 'left']
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 19, () => `title-${Math.random()}`),
			title = prop($$props, 'title', 3, ""),
			size = prop($$props, 'size', 3, 1),
			spaced = prop($$props, 'spaced', 3, false),
			align = prop($$props, 'align', 3, "left");

		const scrollToTop = (options = UICommon$1.SCROLL_OPTIONS) => {
			setTimeout(
				() => {
					document.getElementById(id()).scrollIntoView(options);
				},
				100
			);
		};

		let size2 = derived(() => $$props.subsize ? $$props.subsize : parseInt(size()) < 6 ? parseInt(size()) + 1 : size());
		let spacedStyle = derived(() => spaced() ? "has-text-justified" : "");
		let resultTitle = derived(() => `<h${size()} id="${id()}" style="text-align: ${align()};" class="title ${get$3(spacedStyle)} is-${size()}">${$LOCALE()[title()]}</h${size()}>`);
		let resultSubtitle = derived(() => `<h${get$3(size2)} id="${id()}" style="text-align: ${align()};" class="subtitle is-${get$3(size2)}">${$LOCALE()[$$props.subtitle]}</h${get$3(size2)}>`);
		var fragment = root$v();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				html(node_1, () => get$3(resultTitle));
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_3 = first_child(fragment_2);

				html(node_3, () => get$3(resultSubtitle));
				append($$anchor, fragment_2);
			};

			if_block(node_2, ($$render) => {
				if ($$props.subtitle) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);

		var $$pop = pop({ scrollToTop });

		$$cleanup();
		return $$pop;
	}

	function Ui_list_empty_placeholder($$anchor, $$props) {
		/**
		 * @typedef {object}    Props
		 * @property {string}   [title = "not-node:empty_list_placeholder"]
		 * @property {number}   [size = 4]
		 * @property {string}   [align = 'center']
		 */
		/**
		 * @type Props
		 */
		let title = prop($$props, 'title', 3, "not-node:empty_list_placeholder"),
			size = prop($$props, 'size', 3, 4),
			align = prop($$props, 'align', 3, "center"),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'title',
				'size',
				'align'
			]);

		Ui_title($$anchor, spread_props(
			{
				get title() {
					return title();
				},
				get size() {
					return size();
				},
				get align() {
					return align();
				}
			},
			() => others
		));
	}

	var root_1$m = template(`<span class="icon"><i></i></span>`);
	var root_4$c = template(`<span> </span>`);
	var root_2$f = template(`<!> <!> <!> <!>`, 1);
	var root_6$9 = template(` <!>`, 1);
	var root$u = template(`<a><!></a>`);

	function Ui_link($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		const sideIcon = ($$anchor) => {
			var span = root_1$m();
			var i = child(span);

			reset(span);
			template_effect(() => set_class(i, `fas fa-${$$props.icon ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`));
			append($$anchor, span);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [title] - attributes
		 * @property {string} [url]
		 * @property {any} download
		 * @property {string} [target]
		 * @property {any} rel
		 * @property {boolean} [light] - visual
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [button]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon] - icons
		 * @property {string} [iconSide]
		 * @property {any} [action]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			url = prop($$props, 'url', 3, ""),
			target = prop($$props, 'target', 3, "_blank"),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			button = prop($$props, 'button', 3, true),
			activeState = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			iconSide = prop($$props, 'iconSide', 3, "right");

		var a = root$u();

		a.__click = function (...$$args) {
			($$props.action || $$props.onclick)?.apply(this, $$args);
		};

		var node = child(a);

		{
			var consequent_3 = ($$anchor) => {
				var fragment = root_2$f();
				var node_1 = first_child(fragment);

				{
					var consequent = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_1, ($$render) => {
						if (iconSide() === "left") $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						var span_1 = root_4$c();
						var text = child(span_1, true);

						reset(span_1);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span_1);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_1);
					});
				}

				var node_3 = sibling(node_2, 2);

				snippet(node_3, () => $$props.children ?? noop);

				var node_4 = sibling(node_3, 2);

				{
					var consequent_2 = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_4, ($$render) => {
						if (iconSide() === "right") $$render(consequent_2);
					});
				}

				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = root_6$9();
				var text_1 = first_child(fragment_3, true);
				var node_5 = sibling(text_1);

				snippet(node_5, () => $$props.children ?? noop);
				template_effect(() => set_text(text_1, $LOCALE()[title()]));
				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if ($$props.icon) $$render(consequent_3); else $$render(alternate, false);
			});
		}

		reset(a);

		template_effect(() => {
			set_attribute(a, 'href', url());
			set_attribute(a, 'target', target());
			set_attribute(a, 'download', $$props.download);
			set_attribute(a, 'rel', $$props.rel);
			set_class(a, `${classes() ?? ''} ${(activeState() ? `is-${activeState()}` : '') ?? ''} ${(color() ? `is-${color()}` : '') ?? ''} ${(type() ? `is-${type()}` : '') ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`);
			toggle_class(a, 'button', button());
			toggle_class(a, 'is-light', light());
			toggle_class(a, 'is-inverted', inverted());
			toggle_class(a, 'is-outlined', outlined());
			toggle_class(a, 'is-raised', raised());
			toggle_class(a, 'is-rounded', rounded());
			toggle_class(a, 'is-loading', loading());
		});

		append($$anchor, a);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root_3$c = template(`<div><p class="control"><!></p></div>`);
	var root_4$b = template(`<div><!></div>`);

	function Ui_links($$anchor, $$props) {
		const listLinks = ($$anchor) => {
			var fragment = comment();
			var node = first_child(fragment);

			each(node, 17, values, (item) => item.id, ($$anchor, item) => {
				Ui_link($$anchor, spread_props(() => get$3(item), itemsProps));
			});

			append($$anchor, fragment);
		};

		/**
		 * @typedef {Object} Props
		 * @property {array}  [values=[]]
		 * @property {string} [classes='']
		 * @property {boolean} [centered=false]
		 * @property {boolean} [right=false]
		 * @property {boolean} [joined = false]
		 * @property {object}   [itemsProps = {}]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			joined = prop($$props, 'joined', 3, true),
			itemsProps = prop($$props, 'itemsProps', 19, () => ({}));

		var fragment_2 = comment();
		var node_1 = first_child(fragment_2);

		{
			var consequent = ($$anchor) => {
				var div = root_3$c();
				var p = child(div);
				var node_2 = child(p);

				listLinks(node_2);
				reset(p);
				reset(div);

				template_effect(() => {
					set_class(div, `field has-addons ${classes() ?? ''}`);
					toggle_class(div, 'is-centered', centered());
					toggle_class(div, 'is-right', right());
				});

				append($$anchor, div);
			};

			var alternate = ($$anchor) => {
				var div_1 = root_4$b();
				var node_3 = child(div_1);

				listLinks(node_3);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, `buttons ${classes() ?? ''}`);
					toggle_class(div_1, 'is-centered', centered());
					toggle_class(div_1, 'is-right', right());
				});

				append($$anchor, div_1);
			};

			if_block(node_1, ($$render) => {
				if (joined()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment_2);
	}

	var root_1$l = template(`<!> <!>`, 1);
	var root_19$1 = template(`<figure class="image is-64x64"><img class="is-rounded"></figure>`);
	var root_24$1 = template(`<div class="list-item-controls"><!> <!></div>`);
	var root$t = template(`<div><!> <!> <!></div>`);

	function Ui_list_item($$anchor, $$props) {
		push($$props, true);

		const itemContent = ($$anchor) => {
			var fragment = root_1$l();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					snippet(node_1, () => $$props.titleRenderer, () => paramsSet);
					append($$anchor, fragment_1);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent_2 = ($$anchor) => {
							const expression = derived(() => callbackTemplate($$props.onclickTitle));

							Ui_clickable_div($$anchor, {
								class: 'list-item-title',
								get callback() {
									return get$3(expression);
								},
								children: ($$anchor, $$slotProps) => {
									var fragment_4 = comment();
									var node_3 = first_child(fragment_4);

									{
										var consequent_1 = ($$anchor) => {
											var fragment_5 = comment();
											var node_4 = first_child(fragment_5);

											component(node_4, UITitleComponent, ($$anchor, $$component) => {
												$$component($$anchor, spread_props(() => get$3(titleProps), titleComponentProps, { onchange }));
											});

											append($$anchor, fragment_5);
										};

										var alternate = ($$anchor) => {
											var text$1 = text();

											template_effect(() => set_text(text$1, $$props.title));
											append($$anchor, text$1);
										};

										if_block(node_3, ($$render) => {
											if (UITitleComponent()) $$render(consequent_1); else $$render(alternate, false);
										});
									}

									append($$anchor, fragment_4);
								},
								$$slots: { default: true }
							});
						};

						if_block(
							node_2,
							($$render) => {
								if ($$props.title) $$render(consequent_2);
							},
							true
						);
					}

					append($$anchor, fragment_2);
				};

				if_block(node, ($$render) => {
					if ($$props.titleRenderer) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			var node_5 = sibling(node, 2);

			{
				var consequent_3 = ($$anchor) => {
					var fragment_7 = comment();
					var node_6 = first_child(fragment_7);

					snippet(node_6, () => $$props.descriptionRenderer, () => paramsSet);
					append($$anchor, fragment_7);
				};

				var alternate_3 = ($$anchor) => {
					var fragment_8 = comment();
					var node_7 = first_child(fragment_8);

					{
						var consequent_5 = ($$anchor) => {
							const expression_1 = derived(() => callbackTemplate($$props.onclickDescription));

							Ui_clickable_div($$anchor, {
								class: 'list-item-description',
								get callback() {
									return get$3(expression_1);
								},
								children: ($$anchor, $$slotProps) => {
									var fragment_10 = comment();
									var node_8 = first_child(fragment_10);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_11 = comment();
											var node_9 = first_child(fragment_11);

											component(node_9, () => $$props.descriptionComponent, ($$anchor, $$component) => {
												$$component($$anchor, spread_props(() => get$3(descriptionProps), descriptionComponentProps, {
													onchange,
													get onclick() {
														return $$props.onclick;
													}
												}));
											});

											append($$anchor, fragment_11);
										};

										var alternate_2 = ($$anchor) => {
											var text_1 = text();

											template_effect(() => set_text(text_1, $$props.description));
											append($$anchor, text_1);
										};

										if_block(node_8, ($$render) => {
											if ($$props.descriptionComponent) $$render(consequent_4); else $$render(alternate_2, false);
										});
									}

									append($$anchor, fragment_10);
								},
								$$slots: { default: true }
							});
						};

						if_block(
							node_7,
							($$render) => {
								if ($$props.description) $$render(consequent_5);
							},
							true
						);
					}

					append($$anchor, fragment_8);
				};

				if_block(node_5, ($$render) => {
					if ($$props.descriptionRenderer) $$render(consequent_3); else $$render(alternate_3, false);
				});
			}

			append($$anchor, fragment);
		};

		/**
		 * @typedef {Object} Props
		 * @property {number}   index
		 * @property {string|object} title
		 * @property {string|object} description
		 * @property {array} [actions = []]
		 * @property {array} [links = []]
		 * @property {array} [listActions = []]
		 * @property {array} [listLinks = []]
		 * @property {string} [class = '']
		 * @property {string} [commonClass = '']
		 * @property {string|object} [image = '']
		 * @property {object} value - value of item, will be passed to event handlers
		 * @property {string|number} [index = -1] - index in array 0-length
		 * @property {boolean} [first = false] - if first
		 * @property {boolean} [last = false] - if last
		 * @property {function} [titleComponent = UITitle] - customization
		 * @property {object} [titleComponentProps]
		 * @property {function} [descriptionComponent]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [imageComponent]
		 * @property {object} [imageComponentProps = {}]
		 * @property {function} [onclick]
		 * @property {function} [onclickTitle]
		 * @property {function} [onclickDescription]
		 * @property {function} [onclickImage]
		 * @property {function} [onclickContent]
		 */
		/** @type {Props} */
		let actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			listActions = prop($$props, 'listActions', 19, () => []),
			listLinks = prop($$props, 'listLinks', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			commonClass = prop($$props, 'commonClass', 3, ""),
			image = prop($$props, 'image', 3, ""),
			index = prop($$props, 'index', 19, () => -1),
			first = prop($$props, 'first', 3, false),
			last = prop($$props, 'last', 3, false),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			UITitleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({}));
			prop($$props, 'imageComponentProps', 19, () => ({}));

		function onClick() {
			$$props.onclick && $$props.onclick($$props.value);
		}

		let allActions = state(proxy([]));
		let allLinks = state(proxy([]));

		const callbackTemplate = (callback) => {
			return () => {
				if (callback) {
					onClick();
					callback && callback($$props.value);
				}
			};
		};

		user_effect(() => {
			set(allActions, proxy([...actions(), ...listActions()].map((btn, index) => {
				return {
					...btn,
					id: index,
					action: btn.action ? () => btn.action($$props.value) : undefined
				};
			})));

			set(allLinks, proxy([...links(), ...listLinks()].map((link, index) => {
				link.id = index;
				return link;
			})));
		});

		const paramsSet = {
			title: $$props.title,
			description: $$props.description,
			image: image(),
			value: $$props.value,
			index: index()
		};

		const clickableItemElementAttributes = {
			role: "button",
			tabindex: "0",
			onclick: onClick,
			onkeyup: (e) => {
				if (e && e.key == "Enter") {
					onClick();
				}
			}
		};

		const additionalElementAttributes = $$props.onclick ? clickableItemElementAttributes : {};
		let imageProps = state(proxy({}));
		let titleProps = state(proxy({}));
		let descriptionProps = state(proxy({}));

		user_effect(() => {
			if (typeof image() === "object") {
				set(imageProps, proxy({ ...image() }));
			} else {
				set(imageProps, proxy({ image: image() }));
			}
		});

		user_effect(() => {
			if (typeof $$props.title === "object") {
				set(titleProps, proxy({ ...$$props.title }));
			} else {
				set(titleProps, proxy({ title: $$props.title }));
			}
		});

		user_effect(() => {
			if (typeof $$props.description === "object") {
				set(descriptionProps, proxy({ ...$$props.description }));
			} else {
				set(descriptionProps, proxy({ description: $$props.description }));
			}
		});

		var div = root$t();
		let attributes;
		var node_10 = child(div);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_13 = comment();
				var node_11 = first_child(fragment_13);

				{
					var consequent_6 = ($$anchor) => {
						var fragment_14 = comment();
						var node_12 = first_child(fragment_14);

						snippet(node_12, () => $$props.imageRenderer, () => paramsSet);
						append($$anchor, fragment_14);
					};

					var alternate_5 = ($$anchor) => {
						const expression_2 = derived(() => callbackTemplate($$props.onclickImage));

						Ui_clickable_div($$anchor, {
							class: 'list-item-image',
							get callback() {
								return get$3(expression_2);
							},
							children: ($$anchor, $$slotProps) => {
								var fragment_16 = comment();
								var node_13 = first_child(fragment_16);

								{
									var consequent_7 = ($$anchor) => {
										var fragment_17 = comment();
										var node_14 = first_child(fragment_17);

										component(node_14, () => $$props.imageComponent, ($$anchor, $$component) => {
											$$component($$anchor, spread_props(() => get$3(imageProps)));
										});

										append($$anchor, fragment_17);
									};

									var alternate_4 = ($$anchor) => {
										var figure = root_19$1();
										var img = child(figure);

										reset(figure);

										template_effect(() => {
											set_attribute(img, 'src', image());
											set_attribute(img, 'alt', $$props.title ? $$props.title?.title || $$props.title : image());
										});

										append($$anchor, figure);
									};

									if_block(node_13, ($$render) => {
										if ($$props.imageComponent) $$render(consequent_7); else $$render(alternate_4, false);
									});
								}

								append($$anchor, fragment_16);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_11, ($$render) => {
						if ($$props.imageRenderer) $$render(consequent_6); else $$render(alternate_5, false);
					});
				}

				append($$anchor, fragment_13);
			};

			if_block(node_10, ($$render) => {
				if (image()) $$render(consequent_8);
			});
		}

		var node_15 = sibling(node_10, 2);

		{
			var consequent_9 = ($$anchor) => {
				var fragment_18 = comment();
				var node_16 = first_child(fragment_18);

				component(node_16, () => $$props.listItemContentComponent, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(listItemContentComponentProps, {
						children: ($$anchor, $$slotProps) => {
							itemContent($$anchor);
						},
						$$slots: { default: true }
					}));
				});

				append($$anchor, fragment_18);
			};

			var alternate_6 = ($$anchor) => {
				const expression_3 = derived(() => callbackTemplate($$props.onclickContent));

				Ui_clickable_div($$anchor, {
					class: 'list-item-content',
					get callback() {
						return get$3(expression_3);
					},
					children: ($$anchor, $$slotProps) => {
						itemContent($$anchor);
					},
					$$slots: { default: true }
				});
			};

			if_block(node_15, ($$render) => {
				if ($$props.listItemContentComponent) $$render(consequent_9); else $$render(alternate_6, false);
			});
		}

		var node_17 = sibling(node_15, 2);

		{
			var consequent_12 = ($$anchor) => {
				var div_1 = root_24$1();
				var node_18 = child(div_1);

				{
					var consequent_10 = ($$anchor) => {
						Ui_buttons($$anchor, {
							get values() {
								return get$3(allActions);
							},
							right: true
						});
					};

					if_block(node_18, ($$render) => {
						if (get$3(allActions) && get$3(allActions).length) $$render(consequent_10);
					});
				}

				var node_19 = sibling(node_18, 2);

				{
					var consequent_11 = ($$anchor) => {
						Ui_links($$anchor, {
							get values() {
								return get$3(allLinks);
							},
							right: true
						});
					};

					if_block(node_19, ($$render) => {
						if (get$3(allLinks) && get$3(allLinks).length) $$render(consequent_11);
					});
				}

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_17, ($$render) => {
				if (get$3(allActions) && get$3(allActions).length || get$3(allLinks) && get$3(allLinks).length) $$render(consequent_12);
			});
		}

		reset(div);

		template_effect(() => {
			attributes = set_attributes(div, attributes, {
				...additionalElementAttributes,
				class: `list-item ${classes() ?? ''} ${commonClass() ?? ''} ${`list-item-at-${index()}` ?? ''}`
			});

			toggle_class(div, 'is-clickable', $$props.onclick);
			toggle_class(div, 'list-item-last', last());
			toggle_class(div, 'list-item-first', first());
			toggle_class(div, 'list-item-odd', index() % 2 === 1);
			toggle_class(div, 'list-item-even', index() % 2 === 0);
		});

		append($$anchor, div);
		pop();
	}

	function Ui_list_block($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [idFieldName = "id"]
		 * @property {array}    [items = []]
		 * @property {array}    [actions = []]
		 * @property {array}    [links = []]
		 * @property {string}   [itemClass = ""]
		 * @property {object}   [listItemContentComponent]
		 * @property {object}   [listItemContentComponentProps = {}]
		 * @property {function} [listItemRenderer]
		 * @property {function} [listItemComponent = UIListItem]
		 * @property {object}   [listItemComponentProps = {}]
		 * @property {function} [titleRenderer]
		 * @property {function} [titleComponent = UITitle]
		 * @property {object}   [titleComponentProps = { size: 6 }]
		 * @property {function} [descriptionRenderer]
		 * @property {function} [descriptionComponent]
		 * @property {object}   [descriptionComponentProps = {}]
		 * @property {function} [imageRenderer]
		 * @property {function} imageComponent
		 * @property {object}   [imageComponentProps = {}]
		 * @property {function} [onclick]
		 * @property {function} [onclickContent]
		 * @property {function} [onclickDescription]
		 * @property {function} [onclickImage]
		 * @property {function} [onclickTitle]
		 */
		/** @type {Props} */
		let idFieldName = prop($$props, 'idFieldName', 3, "id"),
			items = prop($$props, 'items', 19, () => []),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			itemClass = prop($$props, 'itemClass', 3, ""),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			UIListItemComponent = prop($$props, 'listItemComponent', 3, Ui_list_item),
			listItemComponentProps = prop($$props, 'listItemComponentProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 19, items, (item) => item[idFieldName()], ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent = ($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							snippet(node_3, () => $$props.listItemRenderer, () => get$3(item), () => get$3(index));
							append($$anchor, fragment_3);
						};

						var alternate = ($$anchor) => {
							var fragment_4 = comment();
							var node_4 = first_child(fragment_4);
							const expression = derived(() => get$3(index) === 0);
							const expression_1 = derived(() => get$3(index) === items().length - 1);

							component(node_4, UIListItemComponent, ($$anchor, $$component) => {
								$$component($$anchor, spread_props(
									listItemComponentProps,
									{
										get listItemContentComponent() {
											return $$props.listItemContentComponent;
										},
										get listItemContentComponentProps() {
											return listItemContentComponentProps();
										},
										get titleRenderer() {
											return $$props.titleRenderer;
										},
										get titleComponent() {
											return titleComponent();
										},
										get titleComponentProps() {
											return titleComponentProps();
										},
										get descriptionRenderer() {
											return $$props.descriptionRenderer;
										},
										get descriptionComponent() {
											return $$props.descriptionComponent;
										},
										get descriptionComponentProps() {
											return descriptionComponentProps();
										},
										get imageRenderer() {
											return $$props.imageRenderer;
										},
										get imageComponent() {
											return $$props.imageComponent;
										},
										get imageComponentProps() {
											return imageComponentProps();
										}
									},
									() => items()[get$3(index)],
									{
										get listActions() {
											return actions();
										},
										get listLinks() {
											return links();
										},
										get value() {
											return items()[get$3(index)].value;
										},
										get commonClass() {
											return itemClass();
										},
										get index() {
											return get$3(index);
										},
										get first() {
											return get$3(expression);
										},
										get last() {
											return get$3(expression_1);
										},
										get onclick() {
											return $$props.onclick;
										},
										get onclickContent() {
											return $$props.onclickContent;
										},
										get onclickDescription() {
											return $$props.onclickDescription;
										},
										get onclickImage() {
											return $$props.onclickImage;
										},
										get onclickTitle() {
											return $$props.onclickTitle;
										}
									}
								));
							});

							append($$anchor, fragment_4);
						};

						if_block(node_2, ($$render) => {
							if ($$props.listItemRenderer) $$render(consequent); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$k = template(`<div><!></div>`);

	function Ui_list($$anchor, $$props) {
		push($$props, true);

		//customization
		/**
		 * @typedef {Object} Props
		 * @property {string} [class = ""]
		 * @property {array} [items = []]
		 * @property {array} [actions = []]
		 * @property {array} [links = []]
		 * @property {boolean} [actionsVisible = false]
		 * @property {boolean} [itemsHoverable = false]
		 * @property {boolean} [overflowEllipsis = false]
		 * @property {boolean} [hiddenImages = false]
		 * @property {string} [itemClass = '']
		 * @property {number} itemLength
		 * @property {string} [idFieldName = 'id']
		 * @property {function} [emptyListPlaceholderComponent = UIListEmptyPlaceholder] - empty
		 * @property {object} [emptyListPlaceholderComponentProps = {}]
		 * @property {function} [listItemComponent = UIListItem] - item
		 * @property {object} [listItemComponentProps = {}]
		 * @property {function} [titleComponent = UITitle] - item parts
		 * @property {object} [titleComponentProps = {size: 6}]
		 * @property {function} [descriptionComponent]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [imageComponent]
		 * @property {object} [imageComponentProps = {}]
		 * @property {function} [onchange]                  callback
		 * @property {function} [onclick]                   callback
		 * @property {function} [onclickContent]            callback
		 * @property {function} [onclickDescription]        callback
		 * @property {function} [onclickImage]              callback
		 * @property {function} [onclickTitle]              callback
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			actionsVisible = prop($$props, 'actionsVisible', 3, false),
			itemsHoverable = prop($$props, 'itemsHoverable', 3, false),
			overflowEllipsis = prop($$props, 'overflowEllipsis', 3, false),
			hiddenImages = prop($$props, 'hiddenImages', 3, false),
			itemClass = prop($$props, 'itemClass', 3, ""),
			idFieldName = prop($$props, 'idFieldName', 3, "id"),
			UIEmptyListPlaceholderComponent = prop($$props, 'emptyListPlaceholderComponent', 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, 'emptyListPlaceholderComponentProps', 19, () => ({})),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			listItemComponent = prop($$props, 'listItemComponent', 3, Ui_list_item),
			listItemComponentProps = prop($$props, 'listItemComponentProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$k();
				var node_1 = child(div);

				Ui_list_block(node_1, {
					get items() {
						return items();
					},
					get itemClass() {
						return itemClass();
					},
					get listItemContentComponent() {
						return $$props.listItemContentComponent;
					},
					get listItemContentComponentProps() {
						return listItemContentComponentProps();
					},
					get listItemRenderer() {
						return $$props.listItemRenderer;
					},
					get listItemComponent() {
						return listItemComponent();
					},
					get listItemComponentProps() {
						return listItemComponentProps();
					},
					get idFieldName() {
						return idFieldName();
					},
					get titleRenderer() {
						return $$props.titleRenderer;
					},
					get titleComponent() {
						return titleComponent();
					},
					get titleComponentProps() {
						return titleComponentProps();
					},
					get descriptionRenderer() {
						return $$props.descriptionRenderer;
					},
					get descriptionComponent() {
						return $$props.descriptionComponent;
					},
					get descriptionComponentProps() {
						return descriptionComponentProps();
					},
					get imageRenderer() {
						return $$props.imageRenderer;
					},
					get imageComponent() {
						return $$props.imageComponent;
					},
					get imageComponentProps() {
						return imageComponentProps();
					},
					get actions() {
						return actions();
					},
					get links() {
						return links();
					},
					get onchange() {
						return $$props.onchange;
					},
					get onclick() {
						return $$props.onclick;
					},
					get onclickContent() {
						return $$props.onclickContent;
					},
					get onclickDescription() {
						return $$props.onclickDescription;
					},
					get onclickImage() {
						return $$props.onclickImage;
					},
					get onclickTitle() {
						return $$props.onclickTitle;
					}
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, 'style', $$props.itemLength ? `--length: ${$$props.itemLength};` : "");
					set_class(div, `list ${classes() ?? ''}`);
					toggle_class(div, 'has-visible-pointer-controls', actionsVisible());
					toggle_class(div, 'has-hoverable-list-items', itemsHoverable());
					toggle_class(div, 'has-overflow-ellipsis', overflowEllipsis());
					toggle_class(div, 'has-hidden-images', hiddenImages());
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_2 = comment();
						var node_3 = first_child(fragment_2);

						snippet(node_3, () => $$props.emptyListRenderer, emptyListPlaceholderComponentProps);
						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_4 = first_child(fragment_3);

						component(node_4, UIEmptyListPlaceholderComponent, ($$anchor, $$component) => {
							$$component($$anchor, spread_props(emptyListPlaceholderComponentProps));
						});

						append($$anchor, fragment_3);
					};

					if_block(
						node_2,
						($$render) => {
							if ($$props.emptyListRenderer) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$s = template(`<!> <!>`, 1);

	function Ui_list_of_models($$anchor, $$props) {
		push($$props, true);

		//field props
		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted] - svelte-ignore unused-export-let
		 * @property {any} [value]
		 * @property {string} [placeholder]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid] - validation
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 * @property {string} [modelName] - model bindings
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId] - presentation
		 * @property {string} [optionTitle]
		 * @property {string} [selectorUI] - selector UI to add new item to list
		 * @property {any} [selectorUIProps]
		 * @property {string} [itemUI] - list item UI to present in readonly or editable variants
		 * @property {any} [itemUIProps]
		 * @property {any} [transformValueItemToListItem]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 23, () => []),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "selectFromModel"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false);
			prop($$props, 'multiple', 3, false);
			prop($$props, 'size', 3, 8);
			let valid = prop($$props, 'valid', 3, true),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			selectorUI = prop($$props, 'selectorUI', 3, "UISelectFromModelOnDemandInline"),
			selectorUIProps = prop($$props, 'selectorUIProps', 19, () => ({})),
			itemUI = prop($$props, 'itemUI', 3, "UIListItem"),
			itemUIProps = prop($$props, 'itemUIProps', 19, () => ({})),
			transformValueItemToListItem = prop($$props, 'transformValueItemToListItem', 3, (item) => {
				return item
					? {
						id: item._id,
						title: item.title,
						description: item.description,
						value: item
					}
					: undefined;
			});

		let items = state(proxy([]));

		const transformValueToItems = (val) => {
			return Array.isArray(val) ? val.map(transformValueItemToListItem()) : [];
		};

		function addItem(item) {
			if (!Array.isArray(snapshot(value()))) {
				value([]);
			}

			value().push(item);
			set(items, proxy(transformValueToItems(value())));
		}

		const getItemIndexInValue = (listItem) => {
			return value().findIndex((valueItem) => valueItem.id === listItem.id);
		};

		const ACTIONS = [
			{
				action(listItem) {
					const itemIndex = getItemIndexInValue(listItem);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex - 1);
						value(valCopy);
						set(items, proxy(transformValueToItems(value())));
					}
				},
				title: "",
				icon: "arrow-up",
				color: "normal"
			},
			{
				action: (listItem) => {
					const itemIndex = getItemIndexInValue(listItem);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex + 1);
						value(valCopy);
						set(items, proxy(transformValueToItems(value())));
					}
				},
				title: "",
				icon: "arrow-down",
				color: "normal"
			},
			{
				action: (listItem) => {
					const itemIndex = getItemIndexInValue(listItem);

					if (itemIndex > -1) {
						value().splice(itemIndex, 1);
						set(items, proxy(transformValueToItems(value())));
					}
				},
				title: "",
				icon: "trash",
				color: "danger"
			}
		];

		var fragment = root$s();
		var node = first_child(fragment);
		const expression = derived(() => COMPONENTS$1.get(itemUI()));

		Ui_list(node, spread_props(
			{
				get listItemComponent() {
					return get$3(expression);
				}
			},
			itemUIProps,
			{
				get items() {
					return get$3(items);
				},
				actions: ACTIONS
			}
		));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				const SvelteComponent = derived(() => COMPONENTS$1.get(selectorUI()));
				var node_2 = first_child(fragment_1);

				component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(selectorUIProps, {
						get modelName() {
							return modelName();
						},
						get actionName() {
							return actionName();
						},
						get actionFilter() {
							return actionFilter();
						},
						get actionSorter() {
							return actionSorter();
						},
						get actionPager() {
							return actionPager();
						},
						get actionSearch() {
							return actionSearch();
						},
						get optionId() {
							return optionId();
						},
						get optionTitle() {
							return optionTitle();
						},
						get placeholder() {
							return placeholder();
						},
						get fieldname() {
							return fieldname();
						},
						get required() {
							return required();
						},
						multiple: false,
						get valid() {
							return valid();
						},
						onresolve: (e) => addItem(e.value)
					}));
				});

				append($$anchor, fragment_1);
			};

			if_block(node_1, ($$render) => {
				if (!readonly()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$r = template(`<div><!></div>`);

	function Ui_column($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {boolean} [narrow=false]
		 * @property {any} size
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			narrow = prop($$props, 'narrow', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'size',
				'narrow',
				'children'
			]);

		var div = root$r();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			attributes = set_attributes(div, attributes, {
				class: `column ${classes() ?? ''} ${($$props.size ? `is-${$$props.size}` : '') ?? ''}`,
				...others
			});

			toggle_class(div, 'is-narrow', narrow());
		});

		append($$anchor, div);
	}

	var root$q = template(`<div><!></div>`);

	function Ui_columns($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'children'
			]);

		var div = root$q();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => attributes = set_attributes(div, attributes, {
			class: `columns ${classes() ?? ''}`,
			...others
		}));

		append($$anchor, div);
	}

	var root$p = template(`<div><!></div>`);

	function Ui_container($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class = '']
		 * @property {string} [title = '']
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {boolean} [widescreen=false]
		 * @property {boolean} [fullhd=false]
		 * @property {boolean} [maxDesktop=false]
		 * @property {boolean} [maxWidescreen=false]
		 * @property {boolean} [fluid = false]
		 * @property {import('svelte').Snippet} [children]
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			title = prop($$props, 'title', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0"),
			widescreen = prop($$props, 'widescreen', 3, false),
			fullhd = prop($$props, 'fullhd', 3, false),
			maxDesktop = prop($$props, 'maxDesktop', 3, false),
			maxWidescreen = prop($$props, 'maxWidescreen', 3, false),
			fluid = prop($$props, 'fluid', 3, false);

		var div = root$p();

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_attribute(div, 'title', title());
			set_class(div, `container ${classes() ?? ''}`);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
			toggle_class(div, 'is-widescreen', widescreen());
			toggle_class(div, 'is-fullhd', fullhd());
			toggle_class(div, 'is-max-desktop', maxDesktop());
			toggle_class(div, 'is-max-widescreen', maxWidescreen());
			toggle_class(div, 'is-fluid', fluid());
		});

		append($$anchor, div);
	}

	delegate(['click', 'keyup']);

	var root$o = template(`<footer><!></footer>`);

	function Ui_footer($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, "");

		var footer = root$o();
		var node = child(footer);

		snippet(node, () => $$props.children ?? noop);
		reset(footer);

		template_effect(() => {
			set_attribute(footer, 'id', id());
			set_class(footer, `footer ${classes() ?? ''} `);
		});

		append($$anchor, footer);
	}

	var root$n = template(`<section><!></section>`);

	function Ui_section$2($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class]
		 * @property {string} [role="button"]
		 * @property {number} [tabIndex = 0]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		var section = root$n();

		section.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		section.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(section);

		snippet(node, () => $$props.children ?? noop);
		reset(section);

		template_effect(() => {
			set_attribute(section, 'id', id());
			set_class(section, `section ${classes() ?? ''}`);
			set_attribute(section, 'role', role());
			set_attribute(section, 'tabindex', tabIndex());
		});

		append($$anchor, section);
	}

	delegate(['click', 'keyup']);

	function Ui_level_item($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [tag]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let tag = prop($$props, 'tag', 3, "div");
		var fragment = comment();
		var node = first_child(fragment);

		element(node, tag, false, ($$element, $$anchor) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					snippet(node_2, () => $$props.children ?? noop);
					append($$anchor, fragment_2);
				};

				var alternate = ($$anchor) => {};

				if_block(node_1, ($$render) => {
					if ($$props.children) $$render(consequent); else $$render(alternate, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$m = template(`<nav class="level"><div class="level-left"><!></div> <div class="level-right"><!></div></nav>`);

	function Ui_level($$anchor, $$props) {
		var nav = root$m();
		var div = child(nav);
		var node = child(div);

		snippet(node, () => $$props.left ?? noop);
		reset(div);

		var div_1 = sibling(div, 2);
		var node_1 = child(div_1);

		snippet(node_1, () => $$props.right ?? noop);
		reset(div_1);
		reset(nav);
		append($$anchor, nav);
	}

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIColumn: Ui_column,
		UIColumns: Ui_columns,
		UIContainer: Ui_container,
		UIFooter: Ui_footer,
		UILevel: Ui_level,
		UILevelItem: Ui_level_item,
		UISection: Ui_section$2
	});

	var root_1$j = template(`<p> </p>`);
	var root_2$e = template(`<input>`);

	function Ui_number($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, 0),
			placeholder = prop($$props, 'placeholder', 3, "0.0"),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100),
			step = prop($$props, 'step', 3, 1),
			fieldname = prop($$props, 'fieldname', 3, "number"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'min',
				'max',
				'step',
				'fieldname',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$j();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$e();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-number-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'number',
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					min: min(),
					max: max(),
					step: step(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$d = template(`<!> <!> <!>`, 1);
	var root_8$1 = template(`<!> <!> <!>`, 1);
	var root$l = template(`<!> <!> <!>`, 1);

	function Ui_named_numbers_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, 'fieldname', 3, "numbers_list"),
			value = prop($$props, 'value', 23, () => ({})),
			defaultItemTitle = prop($$props, 'defaultItemTitle', 3, ""),
			defaultItemValue = prop($$props, 'defaultItemValue', 3, 0),
			label = prop($$props, 'label', 3, "named numbers list"),
			labelSize = prop($$props, 'labelSize', 3, 5),
			placeholder = prop($$props, 'placeholder', 3, "new item"),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false);
			prop($$props, 'required', 3, true);
			prop($$props, 'valid', 3, true);
			let onchange = prop($$props, 'onchange', 3, () => true),
			classes = prop($$props, 'class', 3, "");

		const createNewVal = () => {
			return {
				id: defaultItemTitle(),
				number: defaultItemValue()
			};
		};

		let newVal = state(proxy(createNewVal()));

		const transformObjectToList = () => {
			return Object.keys(value()).map((name) => {
				return {
					id: name,
					title: name,
					number: value()[name]
				};
			});
		};

		let list = state(proxy(transformObjectToList()));

		function remove(id) {
			if (notCommon$1.objHas(value(), id)) {
				delete value()[id];
				value(value());
				set(list, proxy(transformObjectToList()));
				onchange()({ value: value(), field: fieldname() });
			}
		}

		function add() {
			const id = get$3(newVal).id.trim();
			const number = parseInt(get$3(newVal).number);

			if (id && id !== "" && !isNaN(number) && !notCommon$1.objHas(value(), id)) {
				value()[id] = number;
			}

			set(list, proxy(transformObjectToList()));

			onchange()({
				value: snapshot(value()),
				field: fieldname()
			});

			set(newVal, proxy(createNewVal()));
		}

		var fragment = root$l();
		var node = first_child(fragment);

		Ui_title(node, {
			get title() {
				return label();
			},
			get size() {
				return labelSize();
			}
		});

		var node_1 = sibling(node, 2);

		each(node_1, 17, () => get$3(list), (item) => item.id, ($$anchor, item) => {
			Ui_columns($$anchor, {
				get class() {
					return classes();
				},
				get disabled() {
					return disabled();
				},
				children: ($$anchor, $$slotProps) => {
					var fragment_2 = root_2$d();
					var node_2 = first_child(fragment_2);

					Ui_column(node_2, {
						classes: 'is-6',
						children: ($$anchor, $$slotProps) => {
							next();

							var text$1 = text();

							template_effect(() => set_text(text$1, get$3(item).title));
							append($$anchor, text$1);
						},
						$$slots: { default: true }
					});

					var node_3 = sibling(node_2, 2);

					Ui_column(node_3, {
						classes: 'is-4',
						children: ($$anchor, $$slotProps) => {
							next();

							var text_1 = text();

							template_effect(() => set_text(text_1, get$3(item).number));
							append($$anchor, text_1);
						},
						$$slots: { default: true }
					});

					var node_4 = sibling(node_3, 2);

					{
						var consequent = ($$anchor) => {
							Ui_column($$anchor, {
								classes: 'is-2',
								children: ($$anchor, $$slotProps) => {
									Ui_button($$anchor, {
										icon: "minus",
										action: () => remove(get$3(item).id)
									});
								},
								$$slots: { default: true }
							});
						};

						if_block(node_4, ($$render) => {
							if (!readonly()) $$render(consequent);
						});
					}

					append($$anchor, fragment_2);
				},
				$$slots: { default: true }
			});
		});

		var node_5 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_columns($$anchor, {
					get class() {
						return classes();
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_8 = root_8$1();
						var node_6 = first_child(fragment_8);

						Ui_column(node_6, {
							classes: 'is-6',
							children: ($$anchor, $$slotProps) => {
								Ui_textfield($$anchor, {
									get placeholder() {
										return placeholder();
									},
									required: false,
									get value() {
										return get$3(newVal).id;
									},
									set value($$value) {
										get$3(newVal).id = $$value;
									}
								});
							},
							$$slots: { default: true }
						});

						var node_7 = sibling(node_6, 2);

						Ui_column(node_7, {
							classes: 'is-4',
							children: ($$anchor, $$slotProps) => {
								Ui_number($$anchor, {
									get value() {
										return get$3(newVal).number;
									},
									set value($$value) {
										get$3(newVal).number = $$value;
									}
								});
							},
							$$slots: { default: true }
						});

						var node_8 = sibling(node_7, 2);

						Ui_column(node_8, {
							classes: 'is-2',
							children: ($$anchor, $$slotProps) => {
								Ui_button($$anchor, { icon: "plus", action: () => add() });
							},
							$$slots: { default: true }
						});

						append($$anchor, fragment_8);
					},
					$$slots: { default: true }
				});
			};

			if_block(node_5, ($$render) => {
				if (!readonly()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$k = template(`<input>`);

	function Ui_password($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "password"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var input = root$k();

		remove_input_defaults(input);

		let attributes;

		template_effect(() => attributes = set_attributes(input, attributes, {
			id: `form-field-password-${fieldname() ?? ''}`,
			class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
			type: 'password',
			name: fieldname(),
			invalid: get$3(invalid),
			required: required(),
			readonly: readonly(),
			disabled: disabled(),
			placeholder: $LOCALE()[placeholder()],
			autocomplete: fieldname(),
			'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
			'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
			...optionalProps,
			...others
		}));

		bind_value(input, value);
		append($$anchor, input);
		pop();
		$$cleanup();
	}

	var root_1$i = template(`<figure><img></figure>`);
	var root_2$c = template(`<a><!></a>`);

	function Ui_image($$anchor, $$props) {
		const imageFigure = ($$anchor) => {
			var figure = root_1$i();
			var img = child(figure);

			img.__click = function (...$$args) {
				onclick()?.apply(this, $$args);
			};

			img.__keyup = function (...$$args) {
				onkeyup()?.apply(this, $$args);
			};

			reset(figure);

			template_effect(
				($0) => {
					set_class(figure, `image ${classes() ?? ''} ${$0 ?? ''}`);
					set_attribute(figure, 'style', ($$props.width ? `width: ${$$props.width};` : "") + ($$props.height ? `height: ${$$props.height};` : ""));
					toggle_class(figure, 'is-contained', contained());
					toggle_class(figure, 'is-covered', covered());
					toggle_class(figure, 'is-clickable', onclick() && $$props.pointable !== false || $$props.pointable);
					set_attribute(img, 'alt', $$props.alt || $$props.title);
					set_attribute(img, 'title', $$props.title);
					set_attribute(img, 'src', $$props.url || $$props.image);
					set_attribute(img, 'crossorigin', cors());
				},
				[
					() => !$$props.width && !$$props.height ? isNaN(size()) ? `is-${size()}` : `is-${size()}x${size()}` : ''
				]
			);

			append($$anchor, figure);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [urlFull]
		 * @property {string} url
		 * @property {string} image
		 * @property {string} [title]
		 * @property {string} [alt]
		 * @property {string} [cors='anonymous']
		 * @property {number} [size = 64]
		 * @property {number} [height]
		 * @property {number} [width]
		 * @property {boolean} [contained=false]
		 * @property {boolean} [covered=false]
		 * @property {boolean} [pointable]
		 * @property {string} [class = '']
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let cors = prop($$props, 'cors', 3, "anonymous"),
			size = prop($$props, 'size', 3, 64),
			contained = prop($$props, 'contained', 3, false),
			covered = prop($$props, 'covered', 3, false),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, undefined),
			onkeyup = prop($$props, 'onkeyup', 3, undefined);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var a = root_2$c();

				a.__click = function (...$$args) {
					onclick()?.apply(this, $$args);
				};

				var node_1 = child(a);

				imageFigure(node_1);
				reset(a);

				template_effect(() => {
					set_attribute(a, 'href', $$props.urlFull);
					set_attribute(a, 'title', $$props.title || $$props.alt);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				imageFigure($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.urlFull) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
	}

	delegate(['click', 'keyup']);

	function Ui_radio_buttons($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {any} [variants] - [
		array of groups
		{
		id:number,
		title:string|object,
		image:string|object,
		variants = [
		array of values variants in group
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}]
		}
		]
		 * @property {any} value - multiple && multiple in group
		{
		array of arrays of selected values in group
		if no selection group should be empty array
		[groupId]: [...variantsId]
		}
		multiple && one in group
		{
		[groupId]: variantId
		}
		only one (not multiple && one in group)
		{
		group: groupId
		value: variantId
		}
		 * @property {any} title
		 * @property {any} image
		 * @property {any} [buttonProps]
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [getUIItem]
		 * @property {any} [getDefaultItemSublime]
		 * @property {any} [uiOn]
		 * @property {any} [uiOff]
		 */
		/** @type {Props} */
		let fieldname = prop($$props, 'fieldname', 3, "radio-buttons"),
			variants = prop($$props, 'variants', 19, () => []),
			value = prop($$props, 'value', 7),
			buttonProps = prop($$props, 'buttonProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			listComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({})),
			returnVariant = prop($$props, 'returnVariant', 3, false);
			prop($$props, 'getUIItem', 3, (valueId) => {
				return variantsButtons.find((btnVal) => btnVal.value === valueId);
			});
			let UIItemHasValue = prop($$props, 'UIItemHasValue', 3, (item, val) => {
				return item.value == val;
			}),
			getDefaultItemSublime = prop($$props, 'getDefaultItemSublime', 3, () => {
				return variants()[0].value;
			}),
			uiOn = prop($$props, 'uiOn', 3, (item) => {
				item.color = "success";
				return item;
			}),
			uiOff = prop($$props, 'uiOff', 3, (item) => {
				item.color = "";
				return item;
			}),
			onchange = prop($$props, 'onchange', 3, () => true);

		onMount(() => {
			initVariantsButton();
			selectDefault();
		});

		let variantsButtons = [],
			listItems = state(proxy([]));

		function initVariantsButton() {
			variantsButtons = variants().map((variant) => {
				return { ...buttonProps(), ...variant };
			});

			set(listItems, proxy([
				{
					id: 0,
					title: $$props.title,
					image: $$props.image,
					description: { values: variantsButtons }
				}
			]));
		}

		const getCurrentVariant = () => {
			snapshot(value());

			return variants().find((va) => va.value === value());
		};

		//
		function toggle(selectedValue) {
			let ui = { on: undefined, off: undefined };

			//
			if (typeof value() !== "undefined") {
				ui.off = value();
			}

			if (typeof selectedValue !== "undefined") {
				ui.on = selectedValue;
			}

			value(selectedValue);
			updateUI(ui);

			//
			onchange()({
				field: fieldname(),
				value: returnVariant() ? getCurrentVariant() : snapshot(value())
			});
		}

		//
		function updateUI(changes) {
			for (let t in variantsButtons) {
				if (typeof changes.off !== "undefined" && UIItemHasValue()(variantsButtons[t], changes.off)) {
					variantsButtons[t] = uiOff()(variantsButtons[t]);
				}

				if (typeof changes.on !== "undefined" && UIItemHasValue()(variantsButtons[t], changes.on)) {
					variantsButtons[t] = uiOn()(variantsButtons[t]);
				}
			}

			get$3(listItems)[0].description.values = variantsButtons;
		}

		//
		function selectDefault() {
			if (variants().length > 0) {
				if (typeof value() === "undefined") {
					const defValue = getDefaultItemSublime()();

					toggle(defValue);
				} else {
					updateUI({ on: value() });
				}
			}
		}

		const SvelteComponent = derived(listComponent);
		var fragment = comment();
		var node = first_child(fragment);

		const expression = derived(() => ({
			...descriptionComponentProps(),
			action(event, value) {
				toggle(value);
			}
		}));

		component(node, () => get$3(SvelteComponent), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get items() {
					return get$3(listItems);
				},
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$3(expression);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$h = template(`<p> </p>`);
	var root_4$a = template(`<option></option>`);
	var root_3$b = template(`<datalist></datalist>`);
	var root_2$b = template(`<input> <output> </output> <!>`, 1);

	function Ui_range($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, 10),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100),
			step = prop($$props, 'step', 3, 1),
			tickmarks = prop($$props, 'tickmarks', 3, false),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "range"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'min',
				'max',
				'step',
				'tickmarks',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$h();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var fragment_1 = root_2$b();
				var input = first_child(fragment_1);

				remove_input_defaults(input);

				let attributes;
				var output = sibling(input, 2);
				var text_1 = child(output, true);

				reset(output);

				var node_1 = sibling(output, 2);

				{
					var consequent_1 = ($$anchor) => {
						var datalist = root_3$b();

						each(datalist, 21, tickmarks, index$d, ($$anchor, tickmark) => {
							var option = root_4$a();
							var option_value = {};

							template_effect(() => {
								if (option_value !== (option_value = get$3(tickmark).value)) {
									option.value = null == (option.__value = get$3(tickmark).value) ? '' : get$3(tickmark).value;
								}

								set_attribute(option, 'label', get$3(tickmark).label);
							});

							append($$anchor, option);
						});

						reset(datalist);
						template_effect(() => set_attribute(datalist, 'id', `form-field-range-${fieldname() ?? ''}-tickmarks`));
						append($$anchor, datalist);
					};

					if_block(node_1, ($$render) => {
						if (Array.isArray(tickmarks()) && tickmarks().length) $$render(consequent_1);
					});
				}

				template_effect(() => {
					attributes = set_attributes(input, attributes, {
						id: `form-field-range-${fieldname() ?? ''}`,
						class: `input big-number slider has-output ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''}  ${classes() ?? ''}`,
						type: 'range',
						name: fieldname(),
						min: min(),
						max: max(),
						step: step(),
						list: `form-field-range-${fieldname() ?? ''}-tickmarks`,
						invalid: get$3(invalid),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					});

					set_attribute(output, 'for', `form-field-range-${fieldname() ?? ''}`);
					set_text(text_1, value());
				});

				bind_value(input, value);
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_3$a = template(`<span class="mr-2"> </span>`);
	var root_5$8 = template(`<span class="mr-2"> </span>`);
	var root_6$8 = template(`<div><select><!><!></select></div>`);

	function Ui_select_multiple($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [value = []]
		 * @property {any}      [variants = []]
		 * @property {string} [placeholder = ""]
		 * @property {boolean}  [emptyValueEnabled = true]
		 * @property {string|number}  [emptyValue]
		 * @property {string} [emptyValueTitle = "no-selection"]
		 * @property {string} [fieldname="select-multiple"]
		 * @property {boolean} [required = true]
		 * @property {boolean} [readonly = false]
		 * @property {number} [rows = 8]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {boolean} [valid = true]
		 * @property {string}   [class = ""]
		 * @property {function} [onchange = ({value:array of string|number, field:string, variants:array of object})=>true]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 23, () => []),
			variants = prop($$props, 'variants', 19, () => []);
			prop($$props, 'placeholder', 3, "");
			let emptyValueTitle = prop($$props, 'emptyValueTitle', 3, "no-selection"),
			emptyValueEnabled = prop($$props, 'emptyValueEnabled', 3, true),
			fieldname = prop($$props, 'fieldname', 3, "select-multiple"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			rows = prop($$props, 'rows', 3, 8),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'placeholder',
				'emptyValueTitle',
				'emptyValueEnabled',
				'emptyValue',
				'fieldname',
				'required',
				'readonly',
				'rows',
				'color',
				'size',
				'valid',
				'class',
				'onchange'
			]);

		let lastValue = snapshot(value());

		function isClearValueMacro(plainValue) {
			return plainValue.includes(UICommon$1.CLEAR_MACRO);
		}

		function getSelectedOptionsValues(ev) {
			return Array.from(ev.selectedOptions).map((el) => typeof el.__value !== "undefined" ? el.__value : el.value);
		}

		function getEmptyValue() {
			return typeof $$props.emptyValue === "undefined" ? UICommon$1.CLEAR_MACRO : $$props.emptyValue;
		}

		function idToVariant(id) {
			return variants().find((variant) => variant.id == id);
		}

		function valueIdsToVariants() {
			const ev = getEmptyValue();

			return value().filter((id) => id !== ev).map(idToVariant);
		}

		function onInput(ev) {
			let selectedIds = getSelectedOptionsValues(ev.currentTarget);

			if (isClearValueMacro(selectedIds)) {
				selectedIds = [];
			}

			const newValue = selectedIds;

			value(selectedIds);

			if (notCommon$1.compareTwoArrays(newValue, lastValue)) {
				return;
			}

			lastValue = newValue;

			onchange()({
				value: newValue,
				field: fieldname(),
				variants: valueIdsToVariants()
			});
		}

		let selectedVariants = derived(() => value() && Array.isArray(value()) ? valueIdsToVariants(value()) : []);
		let invalid = derived(() => !valid());
		let UI_CLASSES = derived(() => [$$props.size, $$props.color].filter((val) => val).map((val) => `is-${val}`).join(" "));
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$3(selectedVariants), index$d, ($$anchor, selectedVariant) => {
							var span = root_3$a();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$3(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var span_1 = root_5$8();
								var text_1 = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
								append($$anchor, span_1);
							};

							if_block(
								node_3,
								($$render) => {
									if (emptyValueEnabled()) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if (value() && Array.isArray(value()) && value().length) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var div = root_6$8();
				var select = child(div);
				let attributes;

				init_select(select, () => attributes.value);

				var node_4 = child(select);

				{
					var consequent_3 = ($$anchor) => {
						const expression = derived(() => typeof $$props.emptyValue === "undefined" ? UICommon$1.CLEAR_MACRO : $$props.emptyValue);

						Ui_select_option($$anchor, {
							get value() {
								return get$3(expression);
							},
							get title() {
								return emptyValueTitle();
							}
						});
					};

					if_block(node_4, ($$render) => {
						if (emptyValueEnabled()) $$render(consequent_3);
					});
				}

				var node_5 = sibling(node_4);

				each(node_5, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					Ui_select_option($$anchor, {
						get value() {
							return get$3(variant).id;
						},
						get title() {
							return get$3(variant).title;
						}
					});
				});

				reset(select);
				reset(div);

				template_effect(() => {
					set_class(div, `select is-multiple ${get$3(UI_CLASSES) ?? ''} ${classes() ?? ''} `);

					attributes = set_attributes(select, attributes, {
						multiple: 'true',
						id: `form-field-select-${fieldname() ?? ''}`,
						name: fieldname(),
						oninput: onInput,
						onchange: onInput,
						onblur: onInput,
						value: value(),
						readonly: readonly(),
						required: required(),
						invalid: get$3(invalid),
						size: rows(),
						...others
					});

					if ('value' in attributes) {
						select_option(select, attributes.value);
					}
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_2); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	const DEFAULT_STATUS_SUCCESS = "ok";
	const NAVIGATION_DELAY_SHORT = 500;
	const NAVIGATION_DELAY_NORMAL = 1500;
	const NAVIGATION_DELAY_LONG = 5000;
	const NAVIGATION_DELAYS = {
	  SHORT: NAVIGATION_DELAY_SHORT,
	  NORMAL: NAVIGATION_DELAY_NORMAL,
	  LONG: NAVIGATION_DELAY_LONG
	};
	const NAVIGATION_DELAY_DEFAULT = NAVIGATION_DELAY_NORMAL;

	function Ui_select_from_model($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_API_MODEL_GETTER = (
			modelName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch
		) => {
			return notCommon$1.getApp().getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
		};

		const DEFAULT_API_REQUEST = (apiModel, actionName) => {
			return apiModel[`$` + actionName]();
		};

		/**
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {string} [placeholder]
		 * @property {string} [emptyValueTitle]
		 * @property {string} [emptyValue]
		 * @property {boolean} [emptyValueEnabled]
		 * @property {string} [fieldname]
		 * @property {string} [modelName]
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId]
		 * @property {string} [optionTitle]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [returnVariant]
		 * @property {function} [onchange = ({value:array of string|number, field:string, variants:array of object})=>true]
		 * @property {function} [onerror = (message:string):void]
		 */
		/** @type {Props} */
		let modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			disabled = prop($$props, 'disabled', 3, false),
			apiModelGetter = prop($$props, 'apiModelGetter', 3, DEFAULT_API_MODEL_GETTER),
			apiRequest = prop($$props, 'apiRequest', 3, DEFAULT_API_REQUEST),
			returnVariant = prop($$props, 'returnVariant', 3, false),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => {}),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'modelName',
				'actionName',
				'actionFilter',
				'actionSorter',
				'actionPager',
				'actionSearch',
				'optionId',
				'optionTitle',
				'disabled',
				'apiModelGetter',
				'apiRequest',
				'returnVariant',
				'class',
				'onchange',
				'onerror'
			]);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let loaded = state(false);
		let variants = state(proxy([]));
		let resultsList = [];
		let uiDisabled = derived(() => disabled() || !get$3(loaded));

		onMount(async () => {
			if (argumentsSetProvided()) {
				const response = await apiRequest()(apiModelGetter()(modelName(), actionFilter(), actionSorter(), actionPager(), actionSearch()), actionName());

				if (notCommon$1.isError(response)) {
					set(loaded, false);
					onerror()(response.errors || [response.message]);
				} else {
					resultsList = response.result;

					set(variants, proxy(resultsList.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					})));

					set(loaded, true);
				}
			}
		});

		function onChange(data) {
			if (returnVariant()) {
				onchange()({
					...data,
					value: get$3(variants).find((itm) => itm.id === data.value)
				});
			} else {
				onchange()(data);
			}
		}

		const expression = derived(() => !get$3(loaded));

		Ui_select($$anchor, spread_props(
			{
				get value() {
					return $$props.value;
				},
				get variants() {
					return get$3(variants);
				},
				get class() {
					return classes();
				},
				get disabled() {
					return get$3(uiDisabled);
				},
				onchange: onChange,
				get loading() {
					return get$3(expression);
				}
			},
			() => others
		));

		pop();
	}

	var root_2$a = template(`<!> <input> <label class="label"><!></label>`, 1);

	function Ui_switch$1($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, false),
			label = prop($$props, 'label', 3, ""),
			hideLabel = prop($$props, 'hideLabel', 3, false),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "switch"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur", "oninput"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'label',
				'hideLabel',
				'placeholder',
				'fieldname',
				'size',
				'color',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_boolean($$anchor, {
					get LC_TRUE() {
						return label();
					},
					get LC_FALSE() {
						return label();
					},
					get value() {
						return value();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = root_2$a();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_boolean($$anchor, { value: false });
					};

					if_block(node_1, ($$render) => {
						if (!label() && !hideLabel()) $$render(consequent_1);
					});
				}

				var input = sibling(node_1, 2);

				remove_input_defaults(input);

				let attributes;
				var label_1 = sibling(input, 2);
				var node_2 = child(label_1);

				{
					var consequent_3 = ($$anchor) => {
						var fragment_4 = comment();
						var node_3 = first_child(fragment_4);

						{
							var consequent_2 = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[label()]));
								append($$anchor, text$1);
							};

							var alternate = ($$anchor) => {
								Ui_boolean($$anchor, { value: false });
							};

							if_block(node_3, ($$render) => {
								if (label()) $$render(consequent_2); else $$render(alternate, false);
							});
						}

						append($$anchor, fragment_4);
					};

					if_block(node_2, ($$render) => {
						if (!hideLabel()) $$render(consequent_3);
					});
				}

				reset(label_1);

				template_effect(() => {
					attributes = set_attributes(input, attributes, {
						id: `form-field-switch-${fieldname() ?? ''}`,
						class: `switch ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
						type: 'checkbox',
						name: fieldname(),
						placeholder: $LOCALE()[placeholder()],
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						invalid: get$3(invalid),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					});

					set_attribute(label_1, 'for', `form-field-switch-${fieldname() ?? ''}`);
				});

				bind_checked(input, value);
				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$9 = template(`<div class="switch-list-item"><input> <!></div>`);

	function Ui_switch_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "switch"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur", "oninput"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, " is-rounded "),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'fieldname',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class',
				'onchange'
			]);

		function addId(varId) {
			if (!value().includes(varId)) {
				value().push(varId);
				value(value());
			}
		}

		function remId(varId) {
			if (value().includes(varId)) {
				value().splice(value().indexOf(varId), 1);
				value(value());
			}
		}

		function onChange(eventData, ev) {
			const varId = ev.target.id.split("-variant-").at(-1);

			ev.target.checked ? addId(varId) : remId(varId);

			let data = {
				field: fieldname(),
				value: snapshot(value())
			};

			onchange()(data);
			return true;
		}

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), onChange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var text$1 = text();

						template_effect(($0) => set_text(text$1, $0), [
							() => variants().filter((variant) => value().includes(variant.id)).map((variant) => variant.title).join(", ")
						]);

						append($$anchor, text$1);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = comment();
				var node_2 = first_child(fragment_3);

				each(node_2, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					var div = root_4$9();
					var input = child(div);

					remove_input_defaults(input);

					let attributes;
					var node_3 = sibling(input, 2);

					Ui_label(node_3, {
						class: 'label',
						get for() {
							return `form-field-switch-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`;
						},
						get label() {
							return get$3(variant).title;
						}
					});

					reset(div);

					template_effect(
						($0) => attributes = set_attributes(input, attributes, {
							type: 'checkbox',
							class: `switch ${classes() ?? ''} ${(get$3(variant).type ? `is-${get$3(variant).type}` : '') ?? ''}`,
							id: `form-field-switch-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							checked: $0,
							name: fieldname(),
							disabled: disabled(),
							required: required(),
							readonly: readonly(),
							invalid: get$3(invalid),
							'aria-controls': `input-field-helper-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							'aria-describedby': `input-field-helper-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							...optionalProps,
							...others
						}),
						[
							() => value().includes(get$3(variant).id)
						]
					);

					append($$anchor, div);
				});

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function remove(e, value, changeEvent) {
		e && e.preventDefault();

		let id = e.currentTarget.dataset.id;

		if (value().includes(id)) {
			value().splice(value().indexOf(id), 1);
			value(value());
			changeEvent();
		}

		return false;
	}

	var root_4$8 = template(`<button aria-label="delete button" class="delete is-small"></button>`);
	var root_3$9 = template(`<span> <!></span>`);
	var root_6$7 = template(`<div class="select is-small"><select><!><!></select></div> <!>`, 1);
	var root_1$g = template(`<!> <!>`, 1);

	function Ui_tag_select($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		onMount(() => {
			clearValueFromDeadVariants();
		});

		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_ADD = "not-node:add_label"]
		 * @property {string} [LC_SELECT_FROM_LIST = "not-node:select_from_list_label"]
		 * @property {array<string|number>} [value] - list of item ids
		 * @property {array<object>} [variants]
		 * @property {string} [fieldname = 'tag']
		 * @property {boolean} [readonly = false] - export let required = true;
		 * @property {boolean} [valid = true]
		 * @property {function} [beforeAdd]
		 * @property {function} [getItemId]
		 * @property {function} [getItemTitle]
		 * @property {function} [getItemType]
		 * @property {function} [buildItem]
		 */
		/** @type {Props} */
		let LC_ADD = prop($$props, 'LC_ADD', 3, "not-node:add_label"),
			LC_SELECT_FROM_LIST = prop($$props, 'LC_SELECT_FROM_LIST', 3, "not-node:select_from_list_label"),
			value = prop($$props, 'value', 31, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "tag"),
			readonly = prop($$props, 'readonly', 3, false);
			prop($$props, 'valid', 3, true);
			let beforeAdd = prop($$props, 'beforeAdd', 3, () => /*variant, variants*/ {
				return true;
			}),
			getItemId = prop($$props, 'getItemId', 3, (variant) => {
				return variant.id;
			}),
			getItemTitle = prop($$props, 'getItemTitle', 3, (variant) => {
				return variant.title;
			}),
			getItemType = prop($$props, 'getItemType', 3, (variant) => {
				return variant?.type ?? "info";
			}),
			buildItem = prop($$props, 'buildItem', 3, (variant) => {
				return {
					id: getItemId()(variant),
					title: getItemTitle()(variant),
					type: getItemType()(variant)
				};
			}),
			classes = prop($$props, 'class', 3, "");

		function variantIdToVariant(id) {
			return variants().find((variant) => getItemId()(variant) == id);
		}

		function changeEvent() {
			$$props.onchange({ field: fieldname(), value: value() });
		}

		function add(e) {
			e && e.preventDefault();

			let id = e.currentTarget.parentNode.querySelector("select").value;
			const variant = variantIdToVariant(id);

			if (!variant) {
				return false;
			}

			if (!beforeAdd()(variant, variants())) {
				return false;
			}

			if (id && value().indexOf(id) === -1) {
				value().push(id);
				value(value());
				changeEvent();
			}

			return false;
		}

		function clearValueFromDeadVariants() {
			value(value().filter(variantIdToVariant));
			return value();
		}

		/*
		item = {
		  id,        //unique
		  title,     //some text
		  type       //for coloring items, usual html template names danger, success, etc
		}
		*/
		let items = derived(() => value().map(variantIdToVariant).filter((variant) => variant).map(buildItem()));

		Ui_columns($$anchor, {
			get class() {
				return classes();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$g();
				var node = first_child(fragment_1);

				Ui_column(node, {
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, () => get$3(items), (item) => item.id, ($$anchor, item) => {
							var span = root_3$9();
							var text = child(span);
							var node_2 = sibling(text);

							{
								var consequent = ($$anchor) => {
									var button = root_4$8();

									button.__click = [remove, value, changeEvent];
									template_effect(() => set_attribute(button, 'data-id', get$3(item).id));
									append($$anchor, button);
								};

								if_block(node_2, ($$render) => {
									if (!readonly()) $$render(consequent);
								});
							}

							reset(span);

							template_effect(() => {
								set_class(span, `mx-1 tag is-${get$3(item).type ?? ''}`);
								set_text(text, `${$LOCALE()[get$3(item).title] ?? ''} `);
							});

							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});

				var node_3 = sibling(node, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_column($$anchor, {
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_6$7();
								var div = first_child(fragment_4);
								var select = child(div);
								var node_4 = child(select);

								Ui_select_option(node_4, {
									value: -1,
									selected: true,
									get title() {
										return LC_SELECT_FROM_LIST();
									}
								});

								var node_5 = sibling(node_4);

								each(node_5, 17, variants, index$d, ($$anchor, variant) => {
									Ui_select_option($$anchor, {
										get value() {
											return get$3(variant).id;
										},
										get title() {
											return get$3(variant).title;
										}
									});
								});

								reset(select);
								reset(div);

								var node_6 = sibling(div, 2);

								Ui_button(node_6, {
									color: "primary",
									size: "small",
									action: add,
									get title() {
										return LC_ADD();
									}
								});

								append($$anchor, fragment_4);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_3, ($$render) => {
						if (!readonly()) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root_1$f = template(`<p> </p>`);
	var root_2$9 = template(`<input>`);

	function Ui_telephone($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, "+7 987 654-32-10"),
			pattern = prop($$props, 'pattern', 3, "\\+[0-9]{1,3}\\s+[0-9]{3}\\s+[0-9]{3}-[0-9]{2}-[0-9]{2}"),
			fieldname = prop($$props, 'fieldname', 3, "telephone"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'pattern',
				'fieldname',
				'required',
				'disabled',
				'readonly',
				'color',
				'size',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$f();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$9();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-telephone-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'tel',
					name: fieldname(),
					pattern: pattern(),
					invalid: get$3(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIAutocomplete: Ui_autocomplete,
		UICheckbox: Ui_checkbox,
		UICheckboxList: Ui_checkbox_list,
		UIColor: Ui_color,
		UIControl: Ui_control,
		UIDate: Ui_date,
		UIDatetimeInTZ: Ui_datetime_in_tz,
		UIEmail: Ui_email,
		UIField: Ui_field,
		UIHidden: Ui_hidden,
		UIJSONArea: Ui_json_area,
		UILabel: Ui_label,
		UIListOfModels: Ui_list_of_models,
		UINamedNumbersList: Ui_named_numbers_list,
		UINumber: Ui_number,
		UIPassword: Ui_password,
		UIRadioButtons: Ui_radio_buttons,
		UIRange: Ui_range,
		UISelect: Ui_select,
		UISelectFromModel: Ui_select_from_model,
		UISelectMultiple: Ui_select_multiple,
		UISelectOption: Ui_select_option,
		UISwitch: Ui_switch$1,
		UISwitchList: Ui_switch_list,
		UITagSelect: Ui_tag_select,
		UITelephone: Ui_telephone,
		UITextarea: Ui_textarea,
		UITextfield: Ui_textfield
	});

	function Ui_tag_value_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {object}    Props
		 * @property {array}    values = []
		 * @property {boolean}  [grouped = true]
		 * @property {boolean}  [multiline = true]
		 */
		/**
		 * @type   Props
		 */
		let values = prop($$props, 'values', 19, () => []),
			grouped = prop($$props, 'grouped', 3, true),
			multiline = prop($$props, 'multiline', 3, true);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_field($$anchor, {
					get grouped() {
						return grouped();
					},
					get multiline() {
						return multiline();
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, values, index$d, ($$anchor, tagValueProps) => {
							Ui_control($$anchor, {
								children: ($$anchor, $$slotProps) => {
									Ui_tag_value($$anchor, spread_props(() => get$3(tagValueProps)));
								},
								$$slots: { default: true }
							});
						});

						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});
			};

			if_block(node, ($$render) => {
				if (values().length) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_3$8 = template(`<span> </span> `, 1);
	var root_1$e = template(`<p><!></p>`);

	function Ui_errors_list($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {array<string>}  [errors = []]
		 * @property {boolean} [show = false]
		 * @property {string} [class = '']
		 * @property {string} [id = 'errors-list']
		 */
		/** @type {Props} */
		let errors = prop($$props, 'errors', 19, () => []),
			show = prop($$props, 'show', 3, false),
			classes = prop($$props, 'class', 3, ""),
			id = prop($$props, 'id', 3, "errors-list");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var p = root_1$e();
				var node_1 = child(p);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 17, errors, index$d, ($$anchor, error, index) => {
							var fragment_2 = root_3$8();
							var span = first_child(fragment_2);
							var text = child(span, true);

							reset(span);

							var text_1 = sibling(span, 1, true);

							template_effect(() => {
								set_text(text, $LOCALE()[get$3(error)]);
								set_text(text_1, index < errors().length - 1 ? ", " : "");
							});

							append($$anchor, fragment_2);
						});

						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var text_2 = text(' ');

						append($$anchor, text_2);
					};

					if_block(node_1, ($$render) => {
						if (show()) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(p);

				template_effect(() => {
					set_class(p, `help ${classes() ?? ''}`);
					set_attribute(p, 'id', id());
				});

				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if (Array.isArray(errors()) && errors().length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_1$d = template(`<p><strong> </strong> <small>@</small> <strong> </strong></p>`);
	var root$j = template(`<article class="media"><figure class="media-left"><p class="image is-32x32"><img></p></figure> <div class="media-content"><!></div></article>`);

	function Ui_user_card($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [id = "userCard"]
		 * @property {string}       [image = "https://bulma.io/images/placeholders/32x32.png"]
		 * @property {string}       [username = "John Doe"]
		 * @property {string}       [role = "admin"]
		 * @property {object}       [events = {}]
		 * @property {function}     [register = notCommon.registerWidgetEvents] - register event handlers
		 * @property {function}     [onUpdate = (data)=> {username=data.username; role = data.role;}]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "userCard"),
			image = prop($$props, 'image', 3, "https://bulma.io/images/placeholders/32x32.png"),
			username = prop($$props, 'username', 7, "John Doe"),
			role = prop($$props, 'role', 7, "admin"),
			events = prop($$props, 'events', 23, () => ({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "username")) {
					username(data.username);
				}

				if (Object.hasOwn(data, "role")) {
					role(data.role);
				}
			});

		function getCompId() {
			return `usercard-${id()}`;
		}

		function getStandartUpdateEventName() {
			return `${getCompId()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events()[getStandartUpdateEventName()] = onUpdate();
			}

			register()(events());
		});

		var article = root$j();
		var figure = child(article);
		var p = child(figure);
		var img = child(p);

		reset(p);
		reset(figure);

		var div = sibling(figure, 2);
		var node = child(div);

		Ui_content(node, {
			children: ($$anchor, $$slotProps) => {
				var p_1 = root_1$d();
				var strong = child(p_1);
				var text = child(strong, true);

				reset(strong);

				var strong_1 = sibling(strong, 4);
				var text_1 = child(strong_1, true);

				reset(strong_1);
				reset(p_1);

				template_effect(() => {
					set_text(text, username());
					set_text(text_1, role());
				});

				append($$anchor, p_1);
			},
			$$slots: { default: true }
		});

		reset(div);
		reset(article);

		template_effect(
			($0) => {
				set_attribute(article, 'id', $0);
				set_attribute(img, 'src', image());
				set_attribute(img, 'alt', username());
			},
			[getCompId]
		);

		append($$anchor, article);
		return pop({ getCompId, getStandartUpdateEventName });
	}

	var root_1$c = template(`<span><span><i></i> <span> </span></span></span>`);
	var root_2$8 = template(`<span><i></i></span>`);

	function Ui_icon_font($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""]
		 * @property {string} [font = ""]
		 * @property {string} [size = ""]
		 * @property {string} [side = ""]
		 * @property {string} [class = ""]
		 * @property {boolean} [pointable = false]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			font = prop($$props, 'font', 3, ""),
			side = prop($$props, 'side', 3, ""),
			size = prop($$props, 'size', 3, ""),
			pointable = prop($$props, 'pointable', 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$c();
				var span_1 = child(span);
				var i = child(span_1);
				var span_2 = sibling(i, 2);
				var text = child(span_2, true);

				reset(span_2);
				reset(span_1);
				reset(span);

				template_effect(() => {
					set_class(span, `icon-text ${(pointable() ? 'is-clickable' : '') ?? ''}`);
					set_class(span_1, `icon ${(size() ? `is-${size()}` : '') ?? ''}`);

					set_class(i, `is-title-icon fas
      fa-${font() ?? ''}
      ${(size() == 'medium' ? 'fa-lg' : '') ?? ''}
      ${(size() == 'large' ? 'fa-2x' : '') ?? ''}
      `);

					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			var alternate = ($$anchor) => {
				var span_3 = root_2$8();
				var i_1 = child(span_3);

				reset(span_3);

				template_effect(() => {
					set_class(span_3, `
        ${(pointable() ? 'is-clickable' : '') ?? ''}
        ${(side() ? `is-${side()}` : '') ?? ''}
        icon ${(size() ? `is-${size()}` : '') ?? ''} ${(size() == 'medium' ? 'fa-lg' : '') ?? ''}
${(size() == 'large' ? 'fa-2x' : '') ?? ''}`);

					set_class(i_1, `fas fa-${font() ?? ''}`);
				});

				append($$anchor, span_3);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$7 = template(`<!> <!>`, 1);

	function Ui_simple_search_input($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string}   [placeholder = 'not-node:field_search_placeholder']
		 * @property {string}   [term = '']
		 * @property {string}   [fieldname = 'searchTermInput']
		 * @property {string}   [icon = 'search']
		 * @property {function} [onchange]
		 */
		/** @type {Props} */
		let placeholder = prop($$props, 'placeholder', 3, "not-node:field_search_placeholder"),
			term = prop($$props, 'term', 15, ""),
			fieldname = prop($$props, 'fieldname', 3, "searchTermInput"),
			icon = prop($$props, 'icon', 3, "search"),
			iconSide = prop($$props, 'iconSide', 3, "left"),
			size = prop($$props, 'size', 3, "normal"),
			required = prop($$props, 'required', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'placeholder',
				'term',
				'fieldname',
				'icon',
				'iconSide',
				'size',
				'required'
			]);

		let hasIconsLeft = derived(() => icon() && iconSide() === "left");
		let hasIconsRight = derived(() => icon() && iconSide() === "right");

		Ui_columns($$anchor, {
			role: 'none',
			children: ($$anchor, $$slotProps) => {
				Ui_column($$anchor, {
					role: 'none',
					children: ($$anchor, $$slotProps) => {
						Ui_field($$anchor, {
							children: ($$anchor, $$slotProps) => {
								Ui_control($$anchor, {
									get hasIconsLeft() {
										return get$3(hasIconsLeft);
									},
									get hasIconsRight() {
										return get$3(hasIconsRight);
									},
									children: ($$anchor, $$slotProps) => {
										var fragment_4 = root_4$7();
										var node = first_child(fragment_4);

										Ui_textfield(node, spread_props(
											{
												get placeholder() {
													return placeholder();
												},
												get fieldname() {
													return fieldname();
												},
												get required() {
													return required();
												},
												get size() {
													return size();
												},
												role: "searchbox"
											},
											() => others,
											{
												get value() {
													return term();
												},
												set value($$value) {
													term($$value);
												}
											}
										));

										var node_1 = sibling(node, 2);

										{
											var consequent = ($$anchor) => {
												Ui_icon_font($$anchor, {
													get font() {
														return icon();
													},
													get side() {
														return iconSide();
													}
												});
											};

											if_block(node_1, ($$render) => {
												if (icon()) $$render(consequent);
											});
										}

										append($$anchor, fragment_4);
									},
									$$slots: { default: true }
								});
							},
							$$slots: { default: true }
						});
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});
	}

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBoolean: Ui_boolean,
		UIBooleanLabeled: Ui_boolean_labeled,
		UIBooleans: Ui_booleans,
		UICensored: Ui_censored,
		UIErrorsList: Ui_errors_list,
		UIIndicator: Ui_indicator,
		UILoader: Ui_loader,
		UIProgress: Ui_progress,
		UISelectFromModelOnDemandInline: Ui_select_from_model_on_demand_inline,
		UISelectFromModelWithSearchModal: Ui_select_from_model_with_search_modal,
		UIShowOneFromList: Ui_show_one_from_list,
		UISimpleSearchInput: Ui_simple_search_input,
		UITag: Ui_tag,
		UITagValue: Ui_tag_value,
		UITagValueList: Ui_tag_value_list,
		UITitle: Ui_title,
		UIUserCard: Ui_user_card
	});

	function Ui_form_input_errors($$anchor, $$props) {
		push($$props, true);

		let id = prop($$props, 'id', 3, "generic-field"),
			classes = prop($$props, 'class', 3, "");

		let allErrors = state(proxy([]));
		let showErrors = state(true);

		user_effect(() => {
			set(allErrors, proxy([
				...Array.isArray($$props.errors) ? $$props.errors : [],
				...Array.isArray($$props.formErrors) ? $$props.formErrors : []
			]));

			set(showErrors, proxy($$props.inputStarted && $$props.validated && !$$props.valid));
		});

		Ui_errors_list($$anchor, {
			get show() {
				return get$3(showErrors);
			},
			get errors() {
				return get$3(allErrors);
			},
			get class() {
				return classes();
			},
			get id() {
				return id();
			}
		});

		pop();
	}

	var root$i = template(`<span class="is-tag-container"><!> <!></span>`);

	function Ui_icon_button_with_tag($$anchor, $$props) {
		push($$props, true);

		let button = prop($$props, 'button', 19, () => ({})),
			tag = prop($$props, 'tag', 19, () => ({}));

		let vars = state(proxy({}));

		let tagPosition = {
			left: !!$$props.left,
			right: !!$$props.right,
			top: !!$$props.top,
			bottom: !!$$props.bottom
		};

		onMount(() => {
			if ($$props.left) {
				get$3(vars)[`--siding-left-size`] = $$props.left;
			}

			if ($$props.right) {
				get$3(vars)["--siding-right-size"] = $$props.right;
			}

			if ($$props.top) {
				get$3(vars)["--siding-top-size"] = $$props.top;
			}

			if ($$props.bottom) {
				get$3(vars)["--siding-bottom-size"] = $$props.bottom;
			}

			set(vars, proxy(get$3(vars)));
		});

		var span = root$i();
		var node = child(span);

		Ui_button(node, spread_props(button));

		var node_1 = sibling(node, 2);

		Ui_tag(node_1, spread_props(
			tag,
			{
				get vars() {
					return get$3(vars);
				}
			},
			tagPosition
		));

		reset(span);
		append($$anchor, span);
		pop();
	}

	var root$h = template(`<div><!></div>`);

	function Ui_icon_floating($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [trigger] - export let direction = 'left';  //left/right/top/bottom/around
		 */
		/** @type {Props} */
		let trigger = prop($$props, 'trigger', 19, () => ({
				title: "Click me!",
				icon: "plus",
				color: "primary",
				size: "medium",
				onclick: () => true
			})),
			top = prop($$props, 'top', 3, "2em"),
			left = prop($$props, 'left', 3, "2em"),
			classes = prop($$props, 'class', 3, "");

		let positionStyle = state("");

		onMount(() => {
			set(positionStyle, "");

			if (top()) {
				set(positionStyle, get$3(positionStyle) + `top: ${top()};`);
			}

			if (left()) {
				set(positionStyle, get$3(positionStyle) + `left: ${left()};`);
			}

			if ($$props.right) {
				set(positionStyle, get$3(positionStyle) + `right: ${$$props.right};`);
			}

			if ($$props.bottom) {
				set(positionStyle, get$3(positionStyle) + `bottom: ${$$props.bottom};`);
			}
		});

		var div = root$h();
		var node = child(div);

		Ui_button(node, spread_props(trigger));
		reset(div);

		template_effect(() => {
			set_class(div, `is-absolute ${classes() ?? ''}`);
			set_attribute(div, 'style', get$3(positionStyle));
		});

		append($$anchor, div);
		pop();
	}

	var root_3$7 = template(`<span class="icon"><!></span>`);
	var root_5$7 = template(`<figure><img></figure>`);

	function Ui_icon($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""] - font icon title
		 * @property {string} [size = ""]  - font icon size
		 * @property {string} [font = ""] - font icon name
		 * @property {string} [svg = ""] - svg icon
		 * @property {string} [src = ""] - image icon
		 * @property {number|string} width
		 * @property {number|string} height
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			size = prop($$props, 'size', 3, ""),
			font = prop($$props, 'font', 3, ""),
			svg = prop($$props, 'svg', 3, ""),
			src = prop($$props, 'src', 3, "");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return font();
					},
					get size() {
						return size();
					},
					get title() {
						return title();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var span = root_3$7();
						var node_2 = child(span);

						html(node_2, svg);
						reset(span);
						append($$anchor, span);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								var figure = root_5$7();
								var img = child(figure);

								reset(figure);

								template_effect(() => {
									set_class(figure, `image ${($$props.width && $$props.height ? `is-${$$props.width}x${$$props.height}` : '') ?? ''} `);
									set_attribute(img, 'src', src());
									set_attribute(img, 'title', title());
									set_attribute(img, 'alt', title());
									set_attribute(img, 'width', $$props.width);
									set_attribute(img, 'height', $$props.height);
								});

								append($$anchor, figure);
							};

							if_block(
								node_3,
								($$render) => {
									if (src()) $$render(consequent_2);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (svg()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (font()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
	}

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIIcon: Ui_icon,
		UIIconButtonWithTag: Ui_icon_button_with_tag,
		UIIconFloating: Ui_icon_floating,
		UIIconFont: Ui_icon_font
	});

	function Ui_form_input_validated_icon($$anchor, $$props) {
		let side = prop($$props, 'side', 3, "right"),
			size = prop($$props, 'size', 3, "small");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				const expression = derived(() => $$props.valid ? "check" : "exclamation-triangle");

				Ui_icon_font($$anchor, {
					get font() {
						return get$3(expression);
					},
					get side() {
						return side();
					},
					get size() {
						return size();
					}
				});
			};

			if_block(node, ($$render) => {
				if ($$props.validated === true) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root$g = template(`<!> <!> <!>`, 1);

	function Ui_form_input($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any} [value]
		 * @property {boolean} [readonly]
		 * @property {object}  UIInput
		 * @property {string} fieldtype
		 * @property {string} fieldname
		 * @property {string} [fieldnamePrefix = "form-field-"]
		 * @property {string} [icon]
		 * @property {string} [iconSide = 'left']
		 * @property {string} [iconSize= 'small']
		 * @property {boolean} [valid = true]
		 * @property {boolean} [validated = false]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, "");
			prop($$props, 'fieldnamePrefix', 3, "form-field-");
			let valid = prop($$props, 'valid', 3, true),
			validated = prop($$props, 'validated', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'readonly',
				'UIInput',
				'label',
				'fieldtype',
				'fieldname',
				'fieldnamePrefix',
				'icon',
				'valid',
				'validated'
			]);

		var fragment = root$g();
		var node = first_child(fragment);

		component(node, () => $$props.UIInput, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(
				{
					get fieldtype() {
						return $$props.fieldtype;
					},
					get fieldname() {
						return $$props.fieldname;
					},
					get valid() {
						return valid();
					},
					get readonly() {
						return $$props.readonly;
					}
				},
				() => others,
				{
					get value() {
						return value();
					},
					set value($$value) {
						value($$value);
					}
				}
			));
		});

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return $$props.icon;
					},
					side: iconSide,
					size: iconSize
				});
			};

			if_block(node_1, ($$render) => {
				if ($$props.icon) $$render(consequent);
			});
		}

		var node_2 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_form_input_validated_icon($$anchor, {
					get validated() {
						return validated();
					},
					get valid() {
						return valid();
					}
				});
			};

			if_block(node_2, ($$render) => {
				if (!$$props.readonly) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
	}

	var root_4$6 = template(`<!> <!>`, 1);
	var root_6$6 = template(` <!>`, 1);
	var root$f = template(`<!> <!>`, 1);

	function Ui_form_control($$anchor, $$props) {
		const control = ($$anchor) => {
			Ui_control($$anchor, {
				get class() {
					return get$3(iconClasses);
				},
				children: ($$anchor, $$slotProps) => {
					Ui_form_input($$anchor, spread_props(
						{
							get UIInput() {
								return $$props.UIInput;
							},
							get placeholder() {
								return placeholder();
							},
							get fieldtype() {
								return $$props.fieldtype;
							},
							get fieldname() {
								return $$props.fieldname;
							},
							get fieldnamePrefix() {
								return fieldnamePrefix();
							},
							get icon() {
								return icon();
							},
							get iconSide() {
								return iconSide();
							},
							get iconSize() {
								return iconSize();
							},
							get required() {
								return required();
							},
							get readonly() {
								return readonly();
							},
							get disabled() {
								return disabled();
							},
							get inputStarted() {
								return inputStarted();
							},
							get validated() {
								return validated();
							},
							get valid() {
								return valid();
							},
							get onchange() {
								return onchange();
							},
							get onerror() {
								return onerror();
							}
						},
						() => others,
						{
							get value() {
								return value();
							},
							set value($$value) {
								value($$value);
							}
						}
					));
				},
				$$slots: { default: true }
			});
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted]
		 * @property {boolean} [value]
		 * @property {string} [label]
		 * @property {string} [placeholder]
		 * @property {string} fieldname
		 * @property {string} fieldtype
		 * @property {string} [icon]
		 * @property {string} [iconSide]
		 * @property {string} [iconSize]
		 * @property {boolean} [required = false]
		 * @property {boolean} [readonly]
		 * @property {boolean} [disabled]
		 * @property {import('../events.types').UIEventInputChangeCallback} [onchange]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, ""),
			inputStarted = prop($$props, 'inputStarted', 3, false),
			labelVertical = prop($$props, 'labelVertical', 3, true),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldnamePrefix = prop($$props, 'fieldnamePrefix', 3, "form-field-"),
			icon = prop($$props, 'icon', 3, ""),
			iconSide = prop($$props, 'iconSide', 3, "left"),
			iconSize = prop($$props, 'iconSize', 3, "small"),
			required = prop($$props, 'required', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			validated = prop($$props, 'validated', 3, false),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => true),
			formErrors = prop($$props, 'formErrors', 19, () => []),
			errors = prop($$props, 'errors', 19, () => []),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'UIInput',
				'inputStarted',
				'label',
				'labelVertical',
				'placeholder',
				'fieldtype',
				'fieldname',
				'fieldnamePrefix',
				'icon',
				'iconSide',
				'iconSize',
				'required',
				'readonly',
				'disabled',
				'valid',
				'validated',
				'onchange',
				'onerror',
				'formErrors',
				'errors'
			]);

		let iconClasses = derived(() => (icon() ? " has-icons-left " : "") + " has-icons-right ");
		var fragment_2 = root$f();
		var node = first_child(fragment_2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_1 = first_child(fragment_3);

				{
					var consequent = ($$anchor) => {
						var fragment_4 = root_4$6();
						var node_2 = first_child(fragment_4);

						Ui_label(node_2, {
							get class() {
								return $$props.fieldtype;
							},
							get for() {
								return `${fieldnamePrefix() ?? ''}${$$props.fieldtype ?? ''}-${$$props.fieldname ?? ''}`;
							},
							get label() {
								return $$props.label;
							}
						});

						var node_3 = sibling(node_2, 2);

						control(node_3);
						append($$anchor, fragment_4);
					};

					var alternate = ($$anchor) => {
						Ui_label($$anchor, {
							get class() {
								return $$props.fieldtype;
							},
							get for() {
								return `${fieldnamePrefix() ?? ''}${$$props.fieldtype ?? ''}-${$$props.fieldname ?? ''}`;
							},
							children: ($$anchor, $$slotProps) => {
								next();

								var fragment_6 = root_6$6();
								var text = first_child(fragment_6);
								var node_4 = sibling(text);

								control(node_4);
								template_effect(() => set_text(text, `${$$props.label ?? ''}: `));
								append($$anchor, fragment_6);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_1, ($$render) => {
						if (labelVertical()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_3);
			};

			var alternate_1 = ($$anchor) => {
				control($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.label) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		var node_5 = sibling(node, 2);

		Ui_form_input_errors(node_5, {
			get inputStarted() {
				return inputStarted();
			},
			get validated() {
				return validated();
			},
			get valid() {
				return valid();
			},
			get errors() {
				return errors();
			},
			get formErrors() {
				return formErrors();
			},
			get id() {
				return `input-field-helper-${$$props.fieldname ?? ''}`;
			}
		});

		append($$anchor, fragment_2);
	}

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIFormControl: Ui_form_control,
		UIFormInput: Ui_form_input,
		UIFormInputErrors: Ui_form_input_errors,
		UIFormInputValidatedIcon: Ui_form_input_validated_icon
	});

	function Ui_images($$anchor, $$props) {
		let values = prop($$props, 'values', 19, () => []),
			override = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'values']);

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.url, ($$anchor, item) => {
			Ui_image($$anchor, spread_props(() => get$3(item), () => override));
		});

		append($$anchor, fragment);
	}

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIImage: Ui_image,
		UIImages: Ui_images
	});

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UILink: Ui_link,
		UILinks: Ui_links
	});

	function Ui_endless_list_navigation($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {number}   [page]                - current page
		 * @property {number}   [pages]               - total count of pages
		 * @property {any}      [buttonsRowComponent = UIButtonsRow] - buttons row ui svelte component
		 * @property {object}   [buttonsRowComponentProps]   - buttons row component properties
		 * @property {object}   [buttonPrevProps]   - prev button ui component properties
		 * @property {object}   [buttonProgressProps]   - center/progress button ui component properties
		 * @property {object}   [buttonNextProps]   - next button ui component properties
		 * @property {function} [onnext]            - callback on next
		 * @property {function} [onprev]            - callback on prev
		 * @property    {string}    [progressTitleStart = '']  - prefix of progress button title
		 * @property    {string}    [progressTitleDelimiter = ' / ']  - text that breaks numbers of current page and total count of pages
		 * @property    {string}    [progressTitleEnd = '']  - suffix of progress button title
		 */
		/** @type {Props} */
		let page = prop($$props, 'page', 7, 0),
			pages = prop($$props, 'pages', 3, 0),
			UIButtonsRowComponent = prop($$props, 'buttonsRowComponent', 3, Ui_buttons_row),
			buttonsRowComponentProps = prop($$props, 'buttonsRowComponentProps', 19, () => ({})),
			buttonPrevProps = prop($$props, 'buttonPrevProps', 19, () => ({
				title: "not-node:list_navigation_prev_button_label"
			})),
			buttonProgressProps = prop($$props, 'buttonProgressProps', 19, () => ({})),
			buttonNextProps = prop($$props, 'buttonNextProps', 19, () => ({
				title: "not-node:list_navigation_next_button_label"
			})),
			onprev = prop($$props, 'onprev', 3, () => {
				page() > 0 && update_prop(page, -1);
			}),
			onnext = prop($$props, 'onnext', 3, () => {
				page() < pages() - 1 && update_prop(page);
			}),
			progressTitleStart = prop($$props, 'progressTitleStart', 3, ""),
			progressTitleDelimiter = prop($$props, 'progressTitleDelimiter', 3, " / "),
			progressTitleEnd = prop($$props, 'progressTitleEnd', 3, "");

		let currentPage = derived(() => page() + 1);
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);
				const expression = derived(() => get$3(currentPage) > 1
					? [
						{
							...buttonPrevProps(),
							action: onprev()
						}
					]
					: []);
				const expression_1 = derived(() => pages() > 1
					? [
						{
							...buttonProgressProps(),
							title: `${progressTitleStart()}${get$3(currentPage)}${progressTitleDelimiter()}${pages()}${progressTitleEnd()}`,
							disabled: true
						}
					]
					: []);
				const expression_2 = derived(() => get$3(currentPage) < pages()
					? [
						{
							...buttonNextProps(),
							action: onnext()
						}
					]
					: []);

				component(node_1, UIButtonsRowComponent, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(buttonsRowComponentProps, {
						get left() {
							return get$3(expression);
						},
						get center() {
							return get$3(expression_1);
						},
						get right() {
							return get$3(expression_2);
						}
					}));
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (pages() > 0) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root_1$b = template(`<span> </span>`);

	function Ui_endless_list_simple_item($$anchor, $$props) {
		push($$props, true);

		function click(e) {
			e.preventDefault();

			$$props.onclick({
				_id: $$props._id,
				id: $$props.id,
				title: $$props.title
			});

			return false;
		}

		Ui_box($$anchor, {
			onclick: click,
			onkeyup: click,
			class: 'list-item-selectable',
			children: ($$anchor, $$slotProps) => {
				var span = root_1$b();
				var text = child(span, true);

				reset(span);
				template_effect(() => set_text(text, $$props.title));
				append($$anchor, span);
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$e = template(`<!> <!>`, 1);

	function Ui_endless_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [data]
		 * @property {any} [itemComponent = UIEndlessListSimpleItem] - list element
		 * @property {any} [itemComponentProps]
		 * @property {any} [emptyListPlaceholderComponent = UIEndlessListEmptyPlaceholder] - if list is empty
		 * @property {any} [emptyListPlaceholderComponentProps]
		 * @property {any} [listNavigationComponent = UIEndlessListNavigation] - prev and next block
		 * @property {any} [listNavigationComponentProps]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			data = prop($$props, 'data', 31, () => proxy({
				list: [],
				skip: 0,
				count: 0,
				page: 0,
				pages: 0
			})),
			UIItemComponent = prop($$props, 'itemComponent', 3, Ui_endless_list_simple_item),
			itemComponentProps = prop($$props, 'itemComponentProps', 19, () => ({})),
			UIEmptyListPlaceholder = prop($$props, 'emptyListPlaceholderComponent', 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, 'emptyListPlaceholderComponentProps', 19, () => ({})),
			UINavigationComponent = prop($$props, 'listNavigationComponent', 3, Ui_endless_list_navigation),
			listNavigationComponentProps = prop($$props, 'listNavigationComponentProps', 19, () => ({}));

		var fragment = root$e();
		var node = first_child(fragment);

		Ui_block(node, {
			get class() {
				return classes();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 19, () => data().list, (item) => item.id, ($$anchor, item, index) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							{
								var consequent = ($$anchor) => {
									var fragment_4 = comment();
									var node_4 = first_child(fragment_4);

									snippet(node_4, () => $$props.itemRenderer, () => get$3(item), () => get$3(index));
									append($$anchor, fragment_4);
								};

								var alternate = ($$anchor) => {
									var fragment_5 = comment();
									var node_5 = first_child(fragment_5);

									component(node_5, UIItemComponent, ($$anchor, $$component) => {
										$$component($$anchor, spread_props(
											{
												get onclick() {
													return $$props.onselect;
												}
											},
											itemComponentProps,
											() => get$3(item)
										));
									});

									append($$anchor, fragment_5);
								};

								if_block(node_3, ($$render) => {
									if ($$props.itemRenderer) $$render(consequent); else $$render(alternate, false);
								});
							}

							append($$anchor, fragment_3);
						});

						append($$anchor, fragment_2);
					};

					var alternate_1 = ($$anchor) => {
						var fragment_6 = comment();
						var node_6 = first_child(fragment_6);

						component(node_6, UIEmptyListPlaceholder, ($$anchor, $$component) => {
							$$component($$anchor, spread_props(emptyListPlaceholderComponentProps));
						});

						append($$anchor, fragment_6);
					};

					if_block(node_1, ($$render) => {
						if (data()?.list?.length) $$render(consequent_1); else $$render(alternate_1, false);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		var node_7 = sibling(node, 2);

		component(node_7, UINavigationComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listNavigationComponentProps, {
				get onprev() {
					return $$props.onprev;
				},
				get onnext() {
					return $$props.onnext;
				},
				get page() {
					return data().page;
				},
				set page($$value) {
					data(data().page = $$value, true);
				},
				get pages() {
					return data().pages;
				},
				set pages($$value) {
					data(data().pages = $$value, true);
				},
				get skip() {
					return data().skip;
				},
				set skip($$value) {
					data(data().skip = $$value, true);
				},
				get count() {
					return data().count;
				},
				set count($$value) {
					data(data().count = $$value, true);
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	function Ui_list_select($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [fieldname = "list-select"]                             field name
		 * @property {boolean}      [multiple = false]                                      if want not one variant selected
		 * @property {boolean}      [atLeastOne = true]                                     no empty result
		 * @property {array<import('./types.js').Variants>} [variants = []]           variants to select from
		 * @property {array<object>} value                                                  [...selectedItemsValues]
		 * @property {array<string|number>} [selectedVariantsIds = []]                      [...selectedItemsIds]
		 * @property {function}     [titleComponent = UITitle]
		 * @property {object}       [titleComponentProps= { size: 5 }]
		 * @property {function}     [imageComponent = UIImage]
		 * @property {object}       [imageComponentProps= { covered: true }]
		 * @property {function}     [listComponent = UIList]
		 * @property {object}       [listComponentProps = {actionsVisible: true}]
		 * @property {function}     [sublimeValue = (value) => value.id]
		 * @property {function}     [updateVariant = (valueId, props, toggleTitle) => void]
		 * @property {function}     [getItemIndex = (items, valueId) => number]
		 * @property {function}     [getItem = (items, { valueId }) => object]
		 * @property {function}     [getItemValue = (items, { valueId }) => object]
		 * @property {function}     [getDefaultItemSublime = (items) => string]
		 * @property {function}     [updateVariant = (items, valueId, props, toggleTitle) => void]
		 * @property {function}     [uiOn = (items, { valueId }) => void]
		 * @property {function}     [uiOff = (items, { valueId }) => void]
		 * @property {function}     [extendVariantToItemList = (item) => object]
		 */
		let items = state(proxy([]));

		/** @type {Props} */
		let fieldname = prop($$props, 'fieldname', 3, "list-select"),
			multiple = prop($$props, 'multiple', 3, false),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			variants = prop($$props, 'variants', 19, () => []),
			value = prop($$props, 'value', 23, () => []),
			selectedVariantsIds = prop($$props, 'selectedVariantsIds', 23, () => []),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({ actionsVisible: true })),
			sublimeValue = prop($$props, 'sublimeValue', 3, (value) => value.id),
			getItemIndex = prop($$props, 'getItemIndex', 3, (items, valueId) => items.findIndex((val) => val.value.id === valueId)),
			getItem = prop($$props, 'getItem', 3, (items, { valueId }) => {
				const index = getItemIndex()(items, valueId);

				//returns variants by its id
				return index > -1 ? items.find((btnVal) => btnVal.value.id === valueId) : undefined;
			}),
			getItemValue = prop($$props, 'getItemValue', 3, (items, { valueId }) => {
				// returns variant's value by id of variant
				const item = getItem()(items, { valueId });

				return item ? item.value : undefined;
			}),
			getDefaultItemSublime = prop($$props, 'getDefaultItemSublime', 3, (items) => {
				return items && items.length ? items[0].id : undefined;
			}),
			updateVariant = prop($$props, 'updateVariant', 3, (items, valueId, itemProps, buttonProps) => {
				const index = getItemIndex()(items, valueId);

				if (index === -1) {
					return;
				}

				Object.keys(itemProps).forEach((key) => {
					items[index][key] = itemProps[key];
				});

				if (Array.isArray(items[index].actions) && items[index].actions.length) {
					Object.keys(buttonProps).forEach((key) => {
						items[index].actions[0][key] = buttonProps[key];
					});
				}
			}),
			uiOn = prop($$props, 'uiOn', 3, (items, { valueId }) => {
				updateVariant()(items, valueId, { class: "has-background-success" }, {
					title: "not-node:booleans_true",
					color: "success"
				});
			}),
			uiOff = prop($$props, 'uiOff', 3, (items, { valueId }) => {
				updateVariant()(items, valueId, { class: "" }, {
					title: "not-node:booleans_false",
					color: "danger"
				});
			}),
			extendVariantToItemList = prop($$props, 'extendVariantToItemList', 3, (itm) => {
				const res = { ...itm };

				res.actions = [
					{
						title: "not-node:booleans_false",
						color: "danger",
						light: true,
						action: toggle
					}
				];

				return res;
			}),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'fieldname',
				'multiple',
				'atLeastOne',
				'variants',
				'value',
				'selectedVariantsIds',
				'titleComponentProps',
				'imageComponent',
				'imageComponentProps',
				'listComponent',
				'listComponentProps',
				'sublimeValue',
				'getItemIndex',
				'getItem',
				'getItemValue',
				'getDefaultItemSublime',
				'updateVariant',
				'uiOn',
				'uiOff',
				'extendVariantToItemList',
				'onchange'
			]);

		onMount(() => {
			set(items, proxy(variants().map(extendVariantToItemList())));

			if (value() && Array.isArray(value())) {
				if (atLeastOne() && value().length) {
					value().forEach((itemValue) => {
						let ui = updateSelected(itemValue);

						updateUI(ui);
					});
				}

				return;
			}

			selectDefault();
		});

		//
		function countOfSelected() {
			return Array.isArray(value()) ? selectedVariantsIds().length : 0;
		}

		const notLastOne = () => !(atLeastOne() && countOfSelected() === 1);

		//
		function updateSelected(detail) {
			const valueId = sublimeValue()(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (!Array.isArray(selectedVariantsIds())) {
				selectedVariantsIds([]);
			}

			if (multiple()) {
				if (selectedVariantsIds().includes(valueId)) {
					if (notLastOne()) {
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
						ui.off = { valueId };
					}
				} else {
					selectedVariantsIds().push(valueId);
					ui.on = { valueId };
				}
			} else {
				if (atLeastOne()) {
					if (!selectedVariantsIds().includes(valueId)) {
						if (countOfSelected() > 0) {
							ui.off = { valueId: selectedVariantsIds().pop() };
						}

						ui.on = { valueId };
						selectedVariantsIds([valueId]);
					}
				} else {
					if (selectedVariantsIds().includes(valueId)) {
						ui.off = { valueId };
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
					} else {
						ui.on = { valueId };
						selectedVariantsIds().push(valueId);
					}
				}
			}

			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);

			updateUI(ui);
			//
			updateValue();

			//
			$$props.onchange({
				field: fieldname(),
				value: snapshot(value()),
				ids: snapshot(selectedVariantsIds())
			});
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(get$3(items), changes.off);
			}

			if (changes.on) {
				uiOn()(get$3(items), changes.on);
			}
		}

		//
		function updateValue() {
			let newVal = [];

			if (typeof selectedVariantsIds() !== "undefined" && Array.isArray(selectedVariantsIds())) {
				newVal = selectedVariantsIds().filter((val) => typeof val !== "undefined").map((valueId) => getItemValue()(get$3(items), { valueId }));
			}

			value(newVal);
		}

		//
		function selectDefault() {
			if (atLeastOne() && get$3(items).length > 0) {
				const defValueId = getDefaultItemSublime()(get$3(items));

				if (defValueId) {
					toggle({ id: defValueId });
				}
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		component(node, UIListComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(
				{
					get titleComponentProps() {
						return titleComponentProps();
					},
					get imageComponent() {
						return imageComponent();
					},
					get imageComponentProps() {
						return imageComponentProps();
					}
				},
				() => others,
				listComponentProps,
				{
					get items() {
						return get$3(items);
					}
				}
			));
		});

		append($$anchor, fragment);
		pop();
	}

	/**
	 * Collection of static methods to work with SelectorGroups objects
	 *
	 * @class ListGroupsUITreeDTO
	 */
	let ListGroupsUITreeDTO = /*#__PURE__*/function () {
	  function ListGroupsUITreeDTO() {
	    _classCallCheck(this, ListGroupsUITreeDTO);
	  }
	  return _createClass(ListGroupsUITreeDTO, null, [{
	    key: "convertGroupTitle",
	    value:
	    /**
	     *
	     * Returns title field from object as string
	     * @static
	     * @param {Object}  val
	     * @param {string}  val.title
	     * @return {string}
	     * @memberof ListGroupsUITreeDTO
	     */
	    function convertGroupTitle({
	      title
	    }) {
	      return title;
	    } //refactored

	    /**
	     *
	     * Returns image field from object as string
	     * @static
	     * @param {Object}  val
	     * @param {string}  val.image
	     * @return {string}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertGroupImage",
	    value: function convertGroupImage({
	      image
	    }) {
	      return image;
	    } //refactored

	    /**
	     * Converts variant object to selector item object
	     *
	     * @static
	     * @param {import('../../types.js').Variant} variant
	     * @return {import('../../types.js').SelectorItem}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertVariant",
	    value: function convertVariant(variant, groupId) {
	      return {
	        id: variant.id,
	        title: variant.title,
	        value: {
	          valueId: variant.id,
	          groupId
	        } //what we will sublime
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').VariantsGroup} group
	     * @return {import('../../types.js').SelectorGroup}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertVariantsGroup",
	    value: function convertVariantsGroup(group) {
	      var _this = this;
	      return {
	        id: group.id,
	        title: this.convertGroupTitle(group),
	        image: this.convertGroupImage(group),
	        description: {
	          values: group.variants.map(function (itm) {
	            return _this.convertVariant(itm, group.id);
	          })
	        }
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').VariantsGroups} variants
	     * @return {import('../../types.js').SelectorGroups}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "buildSelectorItemsFromVariants",
	    value: function buildSelectorItemsFromVariants(variants) {
	      var _this2 = this;
	      return variants.map(function (itm) {
	        return _this2.convertVariantsGroup(itm);
	      });
	    } //refactored

	    /**
	     *
	     * Returns {group: number, id: number} as SelectedVariant type {groupId: string|number, valueId: string|number}
	     * @static
	     * @param   {object} value
	     * @return  {import('../../types.js').SelectedVariant}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "sublimeValue",
	    value: function sublimeValue(value) {
	      return {
	        groupId: value.group || value.groupId,
	        valueId: value.id || value.valueId
	      };
	    } //refactored

	    /**
	     * Returns index of group in array by groupId or undefined if its not found
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} groupId
	     * @static
	     * @returns {number|undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroupIndex",
	    value: function getSelectorGroupIndex(selectorGroupsItems, groupId) {
	      const index = selectorGroupsItems.findIndex(function (group) {
	        return group.id === groupId;
	      });
	      return index > -1 ? index : undefined;
	    } //refactored

	    /**
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} index
	     * @return {import('../../types.js').SelectorGroup}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroup",
	    value: function getSelectorGroup(selectorGroupsItems, index) {
	      return selectorGroupsItems[index];
	    } //refactored

	    /**
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroup} group
	     * @return {boolean}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "selectorGroupHasVariants",
	    value: function selectorGroupHasVariants(group) {
	      return group && group.description && Array.isArray(group.description.values);
	    } //refactored

	    /**
	     *
	     *
	     * @param {import('../../types.js').SelectorGroup} group
	     * @return {import("../../types.js").SelectorItems}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroupVariants",
	    value: function getSelectorGroupVariants(group) {
	      return group.description.values;
	    }

	    /**
	     * Returns comparation function, (val: SelectorItem)=>boolean,
	     * which checks if val has specified variantId
	     *
	     * @static
	     * @param {import('../../types.js').VariantId} variantId
	     * @return {function}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "compareSelectorGroupValueIdWith",
	    value: function compareSelectorGroupValueIdWith(variantId) {
	      return function (val) {
	        return val?.value?.valueId === variantId;
	      };
	    } //refactored

	    /**
	     * Returns index of item in group by groupIndex and item valueId or undefined if its not found
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} groupIndex
	     * @param {import('../../types.js').VariantId} valueId
	     * @returns {number|undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItemIndex",
	    value: function getSelectorItemIndex(selectorGroupsItems, groupIndex, valueId) {
	      const group = this.getSelectorGroup(selectorGroupsItems, groupIndex);
	      if (!this.selectorGroupHasVariants(group)) {
	        return undefined;
	      }
	      const itemIndex = this.getSelectorGroupVariants(group).findIndex(this.compareSelectorGroupValueIdWith(valueId));
	      return itemIndex > -1 ? itemIndex : undefined;
	    } //refactored

	    /**
	     * Returns {groupIndex: number, itemIndex: number} or undefined from VariantsGroups by groupId, valueId
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').VariantId} groupId
	     * @param {import('../../types.js').VariantId} valueId
	     * @return {import('../../types.js').ItemIndexes | undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItemIndexes",
	    value: function getSelectorItemIndexes(selectorGroupsItems, groupId, valueId) {
	      const groupIndex = this.getSelectorGroupIndex(selectorGroupsItems, groupId);
	      if (groupIndex === -1 || typeof groupIndex === "undefined") {
	        return undefined;
	      }
	      const itemIndex = this.getSelectorItemIndex(selectorGroupsItems, groupIndex, valueId);
	      if (itemIndex === -1 || typeof itemIndex === "undefined") {
	        return undefined;
	      }
	      return {
	        groupIndex,
	        itemIndex
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups}   selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}       itemIds
	     * @return {import('../../types.js').SelectorItem}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItem",
	    value: function getSelectorItem(selectorGroupsItems, itemIds) {
	      /** @type {import('../../types.js').ItemIndexes | undefined} */
	      const indexes = this.getSelectorItemIndexes(selectorGroupsItems, itemIds.groupId, itemIds.valueId);
	      if (indexes) {
	        const group = this.getSelectorGroup(selectorGroupsItems, indexes.groupIndex);
	        if (!this.selectorGroupHasVariants(group)) {
	          return undefined;
	        }
	        const groupVariants = this.getSelectorGroupVariants(group);
	        return groupVariants[indexes.itemIndex];
	      }
	      return undefined;
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @return {import('../../types.js').SelectedVariant | undefined}
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "getDefaultSelectorItemSublime",
	    value: function getDefaultSelectorItemSublime(selectorGroupsItems) {
	      if (selectorGroupsItems && selectorGroupsItems.length && this.selectorGroupHasVariants(selectorGroupsItems[0])) {
	        const groupId = selectorGroupsItems[0].id;
	        const valueId = selectorGroupsItems[0].description.values[0]?.value?.valueId;
	        if (UICommon$1.stringsOfNumbers([groupId, valueId])) {
	          return {
	            groupId,
	            valueId
	          };
	        }
	      }
	      return undefined;
	    } //refactored

	    /**
	     * Changes selector items
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds} itemIds
	     * @param {object} itemProps
	     * @param {object} actionsUIProps
	     * @return {undefined}
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "updateSelectorItem",
	    value: function updateSelectorItem(selectorGroupsItems, itemIds, itemProps, actionsUIProps) {
	      const indexes = this.getSelectorItemIndexes(selectorGroupsItems, itemIds.groupId, itemIds.valueId);
	      if (typeof indexes === "undefined") {
	        return;
	      }
	      Object.keys(itemProps).forEach(function (key) {
	        selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex][key] = itemProps[key];
	      });
	      if (Array.isArray(selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex].actions) && selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex].actions.length) {
	        Object.keys(uiProps).forEach(function (key) {
	          selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex][0][key] = actionsUIProps[key];
	        });
	      }
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}   itemIds
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "uiOn",
	    value: function uiOn(selectorGroupsItems, itemIds) {
	      this.updateSelectorItem(selectorGroupsItems, itemIds, {
	        ...this.UI_PROPS_DELTA_ON
	      }, {
	        ...this.UI_PROPS_DELTA_ON_ACTION
	      });
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}   itemIds
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "uiOff",
	    value: function uiOff(selectorGroupsItems, itemIds) {
	      this.updateSelectorItem(selectorGroupsItems, itemIds, {
	        ...this.UI_PROPS_DELTA_OFF
	      }, {
	        ...this.UI_PROPS_DELTA_OFF_ACTION
	      });
	    } //refactored
	  }, {
	    key: "syncUIWithValue",
	    value: function syncUIWithValue(selectorGroups, itemInValue) {
	      for (const group of selectorGroups) {
	        const items = this.getSelectorGroupVariants(group);
	        for (const item of items) {
	          const itemIds = {
	            groupId: group.id,
	            valueId: item.id
	          };
	          if (itemInValue(itemIds)) {
	            this.uiOn(selectorGroups, itemIds);
	          } else {
	            this.uiOff(selectorGroups, itemIds);
	          }
	        }
	      }
	      return selectorGroups;
	    }
	  }]);
	}();
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_ON", {
	  class: "has-background-success"
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_OFF", {
	  class: ""
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_ON_ACTION", {
	  title: "not-node:booleans_true",
	  color: "success"
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_OFF_ACTION", {
	  title: "not-node:booleans_false",
	  color: "danger"
	});

	let ListGroupsValueDTOMultipleBehaviour = /*#__PURE__*/function () {
	  function ListGroupsValueDTOMultipleBehaviour() {
	    _classCallCheck(this, ListGroupsValueDTOMultipleBehaviour);
	  }
	  return _createClass(ListGroupsValueDTOMultipleBehaviour, null, [{
	    key: "countItemsInValue",
	    value: function countItemsInValue(value) {
	      if (value) {
	        return Object.values(value).reduce(function (a, b) {
	          return a += b.length;
	        }, 0);
	      } else {
	        return 0;
	      }
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value) {
	      return typeof value === "object" && Object.values(value).every(this.groupItemsIsValid) ? value : {};
	    }
	  }, {
	    key: "groupItemsIsValid",
	    value: function groupItemsIsValid(groupItems) {
	      if (!Array.isArray(groupItems)) {
	        return false;
	      }
	      return groupItems.every(function (itm) {
	        return UICommon$1.stringOrNumber(itm);
	      });
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item) {
	      return Object.hasOwn(value, item.groupId) && value[item.groupId].includes(item.valueId);
	    }
	  }, {
	    key: "clearFromEmptyGroups",
	    value: function clearFromEmptyGroups(value) {
	      var _this = this;
	      Object.keys(value).forEach(function (key) {
	        if (_this.groupIsEmpty(value[key])) {
	          delete value[key];
	        }
	      });
	    }
	  }, {
	    key: "groupIsEmpty",
	    value: function groupIsEmpty(group) {
	      if (group && Array.isArray(group)) {
	        if (group.length === 0) {
	          return true;
	        }
	      } else {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "groupIsFull",
	    value: function groupIsFull(valueGroup, variantsGroup) {
	      return valueGroup.length === variantsGroup?.variants?.length;
	    }
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      if (options.atLeastOne && this.countItemsInValue(value) === 1) {
	        return;
	      }
	      value[item.groupId].splice(value[item.groupId].indexOf(item.valueId), 1);
	      this.clearFromEmptyGroups(value, options);
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {*} value
	     * @param {*} item
	     * @param {import('../../types.js').ListGroupsOptions} options
	     * @memberof ListGroupsValueDTOMultipleBehaviour
	     */
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item, options) {
	      if (options.onlyOnePerGroup) {
	        value[item.groupId] = [item.valueId];
	      } else {
	        if (!value[item.groupId] || !Array.isArray(value[item.groupId])) {
	          value[item.groupId] = [item.valueId];
	        } else {
	          if (!value[item.groupId].includes(item.valueId)) {
	            value[item.groupId].push(item.valueId);
	          }
	        }
	      }
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll(variants, value, options) {
	      var _this2 = this;
	      variants.forEach(function (variantsGroup) {
	        variantsGroup.variants.forEach(function (variant) {
	          _this2.addItemToValue(value, {
	            valueId: variant.id,
	            groupId: variantsGroup.id
	          }, options);
	        });
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone(variants, value, options) {
	      Object.keys(value).forEach(function (groupId) {
	        delete value[groupId];
	      });
	    }
	  }, {
	    key: "selectAllInGroup",
	    value: function selectAllInGroup(variants, value, groupId, options) {
	      var _this3 = this;
	      if (!UICommon$1.stringOrNumber(groupId)) {
	        return;
	      }
	      const variantsGroup = variants.find(function (itm) {
	        return itm.id == groupId;
	      });
	      if (!variantsGroup || !variantsGroup.variants || !Array.isArray(variantsGroup.variants)) {
	        return;
	      }
	      variantsGroup.variants.forEach(function (variant) {
	        _this3.addItemToValue(value, {
	          groupId,
	          valueId: variant.id
	        });
	      });
	    }
	  }, {
	    key: "selectNoneInGroup",
	    value: function selectNoneInGroup(variants, value, groupId, options) {
	      if (value[groupId]) {
	        delete value[groupId];
	      }
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      var _this4 = this;
	      const result = {};
	      variants.forEach(function (group) {
	        if (_this4.groupIsEmpty(group.id)) return;
	        group.variants.forEach(function (variant) {
	          if (_this4.itemInValue(value, {
	            groupId: group.id,
	            valueId: variant.id
	          })) {
	            if (Array.isArray(result[group.id])) {
	              result[group.id].push(variant);
	            } else {
	              result[group.id] = [variant];
	            }
	          }
	        });
	      });
	      return result;
	    }
	  }]);
	}();

	let ListGroupsValueDTOSingleBehaviour = /*#__PURE__*/function () {
	  function ListGroupsValueDTOSingleBehaviour() {
	    _classCallCheck(this, ListGroupsValueDTOSingleBehaviour);
	  }
	  return _createClass(ListGroupsValueDTOSingleBehaviour, null, [{
	    key: "countItemsInValue",
	    value: function countItemsInValue(value) {
	      return value && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) ? 1 : 0;
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value) {
	      return value && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) ? value : {
	        valueId: undefined,
	        groupId: undefined
	      };
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item) {
	      return Object.hasOwn(value, "groupId") && Object.hasOwn(value, "valueId") && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) && value.groupId == item.groupId && value.valueId == item.valueId;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {*} value
	     * @param {*} item
	     * @param {import('../../types.js').ListGroupsOptions} options
	     * @memberof ListGroupsValueDTOSingleBehaviour
	     */
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      if (!options.atLeastOne) {
	        value[item.groupId].splice(value[item.groupId].indexOf(item.valueId), 1);
	      }
	    }
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item) {
	      if (typeof value === "undefined") {
	        value = this.initValue();
	      }
	      value.valueId = item.valueId;
	      value.groupId = item.groupId;
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      if (this.countItemsInValue(value)) {
	        return variants.find(function (group) {
	          return group.id === value.groupId;
	        }).variants.find(function (variant) {
	          return variant.id === value.valueId;
	        });
	      } else {
	        return {};
	      }
	    }
	  }]);
	}();

	let ListGroupsValueDTO = /*#__PURE__*/function () {
	  function ListGroupsValueDTO() {
	    _classCallCheck(this, ListGroupsValueDTO);
	  }
	  return _createClass(ListGroupsValueDTO, null, [{
	    key: "behaviour",
	    value: function behaviour(options) {
	      return options.multiple ? ListGroupsValueDTOMultipleBehaviour : ListGroupsValueDTOSingleBehaviour;
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value, options) {
	      return this.behaviour(options).initValue(value);
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item, options) {
	      return this.behaviour(options).itemInValue(value, item, options);
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectedValues} value
	     * @param {Object} item
	     * @param {ListGroupsOptions} options
	     * @memberof ListGroupsValueDTO
	     */
	  }, {
	    key: "toggle",
	    value: function toggle(value, item, options) {
	      if (this.itemInValue(value, item, options)) {
	        this.removeItemFromValue(value, item, options);
	      } else {
	        this.addItemToValue(value, item, options);
	      }
	    }
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      this.behaviour(options).removeItemFromValue(value, item, options);
	    }
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item, options) {
	      this.behaviour(options).addItemToValue(value, item, options);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll(variants, value, options) {
	      this.behaviour(options).selectAll(variants, value, options);
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone(variants, value, options) {
	      this.behaviour(options).selectNone(variants, value, options);
	    }
	  }, {
	    key: "selectAllInGroup",
	    value: function selectAllInGroup(variants, value, groupId, options) {
	      this.behaviour(options).selectAllInGroup(variants, value, groupId, options);
	    }
	  }, {
	    key: "selectNoneInGroup",
	    value: function selectNoneInGroup(variants, value, groupId, options) {
	      this.behaviour(options).selectNoneInGroup(variants, value, groupId, options);
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      return this.behaviour(options).valueAsVariants(value, variants);
	    }
	  }]);
	}();

	function Ui_list_select_with_groups($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [fieldname = "list-select"]                             field name
		 * @property {function}     [onchange]  callback on value change event
		 * @property {array<import('./types.js').VariantsGroups>}   [variants = []]           variants to select from
		 * @property {array<import('./types.js').SelectedValues}  [variantsSelected] - multiple && multiple in group
		 * @property {array<import('./types.js').SelectedVariants}  value - {[groupId]: [...valuesOfSelectedItems]}
		 * @property {object}       [behaviourUI = ListGroupsUITreeDTO]
		 * @property {object}       [behaviourValue = ListGroupsValueDTO]
		 * @property {boolean}      [multiple = false]                                      if want not one variant selected
		 * @property {boolean}      [onlyOnePerGroup = true]
		 * @property {boolean}      [atLeastOne = true]                                     no empty result
		 * @property {function}     [titleComponent = UITitle]
		 * @property {object}       [titleComponentProps= { size: 5 }]
		 * @property {function}     [imageComponent = UIImage]
		 * @property {object}       [imageComponentProps= { covered: true }]
		 * @property {function}     [descriptionComponent = UIButtons]
		 * @property {object}       [descriptionComponentProps = {}]
		 * @property {function}     [listComponent = UIList]
		 * @property {object}       [listComponentProps = {}]
		 */
		let selectorGroups = state(proxy([]));

		/** @type {Props} */
		let onchange = prop($$props, 'onchange', 3, () => true),
			fieldname = prop($$props, 'fieldname', 3, "list-select-tags"),
			variants = prop($$props, 'variants', 19, () => []),
			variantsSelected = prop($$props, 'variantsSelected', 23, () => ({})),
			value = prop($$props, 'value', 7),
			behaviourUI = prop($$props, 'behaviourUI', 3, ListGroupsUITreeDTO),
			behaviourValue = prop($$props, 'behaviourValue', 3, ListGroupsValueDTO),
			multiple = prop($$props, 'multiple', 3, false),
			onlyOnePerGroup = prop($$props, 'onlyOnePerGroup', 3, true),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({}));

		function updateUI() {
			set(selectorGroups, proxy(behaviourUI().syncUIWithValue(get$3(selectorGroups), (itemIds) => behaviourValue().itemInValue(value(), itemIds, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}))));
		}

		onMount(() => {
			set(selectorGroups, proxy(behaviourUI().buildSelectorItemsFromVariants(variants())));

			value(behaviourValue().initValue(value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}));

			updateUI();
		});

		const valueAsVariants = () => behaviourValue().valueAsVariants(value(), variants());

		function triggerChange() {
			variantsSelected(valueAsVariants());
			onchange()({ field: fieldname(), value: value() });
		}

		const toggleItem = (itemValue) => {
			behaviourValue().toggle(value(), itemValue, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		var fragment = comment();
		var node = first_child(fragment);

		const expression = derived(() => ({
			action(event, itemValue) {
				toggleItem(itemValue);
			},
			...descriptionComponentProps()
		}));

		component(node, UIListComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$3(expression);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return get$3(selectorGroups);
				}
			}));
		});

		append($$anchor, fragment);
		return pop({ valueAsVariants, toggleItem });
	}

	var root$d = template(`<!> <!>`, 1);

	function Ui_list_select_buttons_with_groups($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {function} [onchange]  callback on value change event
		 * @property {string} [fieldname="list-select-tags"]
		 * @property {import('../types').VariantsGroups} [variants = []] -
		 * @property {import('../types').SelectedValues} [variantsSelected = {}] - multiple && multiple in group
		 * @property {import('../types').SelectedVariants} [value = []]
		 * @property {object} [behaviourUI = ListGroupsUITreeDTO]
		 * @property {object} [behaviourValue = ListGroupsValueDTO]
		 * @property {boolean} [multiple = true]
		 * @property {boolean} [onlyOnePerGroup = true]
		 * @property {boolean} [atLeastOne = true]
		 * @property {function} [titleComponent = UITitle]
		 * @property {object} [titleComponentProps = { size: 5}]
		 * @property {function} [imageComponent = UIImage]
		 * @property {object} [imageComponentProps = { covered: true }]
		 * @property {function} [descriptionComponent = UIButtonsSwitchers]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [listComponent = UIList]
		 * @property {object} [listComponentProps = {}]
		 * @property {Array<string>} [actionsList=["selectAll", "selectNone"]]
		 */
		/** @type {Props} */
		let onchange = prop($$props, 'onchange', 3, () => true),
			fieldname = prop($$props, 'fieldname', 3, "list-select-tags"),
			variants = prop($$props, 'variants', 19, () => []),
			variantsSelected = prop($$props, 'variantsSelected', 23, () => ({})),
			value = prop($$props, 'value', 7),
			behaviourUI = prop($$props, 'behaviourUI', 3, ListGroupsUITreeDTO),
			behaviourValue = prop($$props, 'behaviourValue', 3, ListGroupsValueDTO),
			multiple = prop($$props, 'multiple', 3, true),
			onlyOnePerGroup = prop($$props, 'onlyOnePerGroup', 3, true),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons_switchers),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({})),
			actionsList = prop($$props, 'actionsList', 19, () => ["selectAll", "selectNone"]);

		//
		const AVAILABLE_ACTIONS = {
			selectAll: {
				title: "Выбрать все",
				color: "success",
				action() {
					selectAll();
				}
			},
			selectNone: {
				title: "Снять выделение со всех",
				color: "",
				action() {
					selectNone();
				}
			}
		};

		let ACTIONS = state(proxy([]));
		let selectorGroups = state(proxy([]));

		function updateUI() {
			set(selectorGroups, proxy(behaviourUI().syncUIWithValue(get$3(selectorGroups), (itemIds) => behaviourValue().itemInValue(value(), itemIds, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}))));
		}

		const valueAsVariants = () => behaviourValue().valueAsVariants(value(), variants());

		function triggerChange() {
			variantsSelected(valueAsVariants());
			onchange()({ field: fieldname(), value: value() });
		}

		onMount(() => {
			actionsList().forEach((name) => {
				Object.hasOwn(AVAILABLE_ACTIONS, name) ? get$3(ACTIONS).push(AVAILABLE_ACTIONS[name]) : false;
			});

			set(ACTIONS, proxy(get$3(ACTIONS)));
			set(selectorGroups, proxy(behaviourUI().buildSelectorItemsFromVariants(variants())));
			value(behaviourValue().initValue(value(), { multiple: multiple() }));
			updateUI();
		});

		const selectAll = () => {
			behaviourValue().selectAll(variants(), value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectNone = () => {
			behaviourValue().selectNone(variants(), value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectAllInGroup = (groupId) => {
			behaviourValue().selectAllInGroup(variants(), value(), groupId, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectNoneInGroup = (groupId) => {
			behaviour.selectNoneInGroup(variants(), value(), groupId, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const toggleItem = (itemValue) => {
			behaviourValue().toggle(value(), itemValue, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		var fragment = root$d();
		var node = first_child(fragment);

		Ui_buttons(node, {
			get values() {
				return get$3(ACTIONS);
			},
			centered: true
		});

		var node_1 = sibling(node, 2);

		const expression = derived(() => ({
			action(event, itemValue) {
				toggleItem(itemValue);
			},
			...descriptionComponentProps()
		}));

		component(node_1, UIListComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$3(expression);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return get$3(selectorGroups);
				}
			}));
		});

		append($$anchor, fragment);

		return pop({
			valueAsVariants,
			selectAll,
			selectNone,
			selectAllInGroup,
			selectNoneInGroup,
			toggleItem
		});
	}

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIEndlessList: Ui_endless_list,
		UIEndlessListNavigation: Ui_endless_list_navigation,
		UIEndlessListSimpleItem: Ui_endless_list_simple_item,
		UIList: Ui_list,
		UIListBlock: Ui_list_block,
		UIListEmptyPlaceholder: Ui_list_empty_placeholder,
		UIListItem: Ui_list_item,
		UIListSelect: Ui_list_select,
		UIListSelectButtonsWithGroups: Ui_list_select_buttons_with_groups,
		UIListSelectWithGroups: Ui_list_select_with_groups
	});

	function overlayClick(e, closeOnClick, closeOverlay) {
		if (closeOnClick()) {
			closeOverlay(e);
		}
	}

	var root_1$a = template(`<div><!> <!></div>`);

	function Ui_overlay($$anchor, $$props) {
		push($$props, true);

		let overflowSave = state("");

		const defaultCloseButtonProps = {
			class: "is-absolute is-sided-right is-sided-top",
			style: "--siding-right-size: 2rem; --siding-top-size: 2rem",
			size: "normal"
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [closeButton = false]
		 * @property {object}   [closeButtonProps = defaultCloseButtonProps]
		 * @property {boolean}  [show = true]
		 * @property {boolean}  [closeOnClick = true]
		 * @property {number}   [layer = 1]
		 * @property {string}   [class = ""]
		 * @property {number}   [zIndexStep = 1000]
		 * @property {string}   [role = 'button']
		 * @property {string}   [tabIndex = 'button']
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let closeButton = prop($$props, 'closeButton', 3, false),
			closeButtonProps = prop($$props, 'closeButtonProps', 3, defaultCloseButtonProps),
			show = prop($$props, 'show', 7, true),
			closeOnClick = prop($$props, 'closeOnClick', 3, true),
			layer = prop($$props, 'layer', 3, 1),
			classes = prop($$props, 'class', 3, ""),
			onreject = prop($$props, 'onreject', 3, () => false),
			zIndexStep = prop($$props, 'zIndexStep', 3, 1000),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		function closeButtonClick() {
			rejectOverlay();
		}

		function closeOverlay(e) {
			try {
				if (e && e.originalTarget) {
					const target = e.originalTarget;

					if (target.classList && target.classList.contains("is-overlay")) {
						rejectOverlay();
					}
				} //eslint-disable-next-line no-empty
			} catch {}
		}

		function rejectOverlay(data = {}) {
			show(false);
			onreject()(data);
		}

		onMount(() => {
			set(overflowSave, proxy(document.body.style.overflow));

			if (show()) {
				document.body.style.overflow = "hidden";
			} else {
				document.body.style.overflow = get$3(overflowSave);
			}
		});

		onDestroy(() => {
			document.body.style.overflow = get$3(overflowSave);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$a();

				div.__click = [overlayClick, closeOnClick, closeOverlay];
				div.__keyup = [overlayClick, closeOnClick, closeOverlay];

				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						Ui_button_close($$anchor, spread_props(closeButtonProps, { onclick: closeButtonClick }));
					};

					if_block(node_1, ($$render) => {
						if (closeButton()) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				snippet(node_2, () => $$props.children ?? noop);
				reset(div);

				template_effect(() => {
					set_class(div, `is-overlay not-overlay ${classes() ?? ''}`);
					set_attribute(div, 'role', role());
					set_attribute(div, 'tabindex', tabIndex());
					set_attribute(div, 'style', `z-index: ${zIndexStep() * layer() ?? ''};`);
				});

				transition(3, div, () => fade);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_5$6 = template(`<!> <!> <!> <!>`, 1);
	var root_3$6 = template(`<!> <!> <!>`, 1);

	function Ui_modal($$anchor, $$props) {
		const buttons = ($$anchor, $$arg0) => {
			let moreClassess = derived_safe_equal(() => fallback($$arg0?.(), ""));
			const expression = derived(() => buttonsClass() || get$3(moreClassess));
			const expression_1 = derived(() => closeButton() ? [closeButton()] : []);
			const expression_2 = derived(() => applyButton() ? [applyButton()] : []);

			Ui_buttons_row($$anchor, {
				get class() {
					return get$3(expression);
				},
				get left() {
					return get$3(expression_1);
				},
				get right() {
					return get$3(expression_2);
				}
			});
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [buttonsPosition = "bottom"]           top, topOfContent, bottom
		 * @property {boolean} [fullscreen = false]
		 * @property {boolean} [closeButton = false]
		 * @property {boolean} [applyButton = false]
		 * @property {number} [titleSize = 2]
		 * @property {boolean} [show = false]
		 * @property {boolean} [loading = false]
		 * @property {string} [title= "Modal window"]
		 * @property {string} [subtitle = ""]
		 * @property {string} [class = ""]
		 * @property {string} [overlayClass = ""]
		 * @property {string} [buttonsClass = ""]
		 * @property {string} [WAITING_TEXT = "Обработка"]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let buttonsPosition = prop($$props, 'buttonsPosition', 3, "bottom"),
			fullscreen = prop($$props, 'fullscreen', 3, false),
			closeButton = prop($$props, 'closeButton', 3, false),
			applyButton = prop($$props, 'applyButton', 3, false),
			titleSize = prop($$props, 'titleSize', 3, 2),
			show = prop($$props, 'show', 3, false),
			loading = prop($$props, 'loading', 3, false),
			title = prop($$props, 'title', 3, "Modal window"),
			subtitle = prop($$props, 'subtitle', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			overlayClass = prop($$props, 'overlayClass', 3, ""),
			buttonsClass = prop($$props, 'buttonsClass', 3, ""),
			WAITING_TEXT = prop($$props, 'WAITING_TEXT', 3, "Обработка");

		Ui_overlay($$anchor, {
			get show() {
				return show();
			},
			closeOnClick: false,
			closeButton: false,
			get class() {
				return overlayClass();
			},
			children: ($$anchor, $$slotProps) => {
				const expression_3 = derived(() => `${classes()} ${fullscreen() ? "is-fullscreen" : ""}`);

				Ui_box($$anchor, {
					get class() {
						return get$3(expression_3);
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_3 = root_3$6();
						var node = first_child(fragment_3);

						{
							var consequent = ($$anchor) => {
								buttons($$anchor, () => "");
							};

							if_block(node, ($$render) => {
								if (buttonsPosition() === "top") $$render(consequent);
							});
						}

						var node_1 = sibling(node, 2);

						Ui_title(node_1, {
							get size() {
								return titleSize();
							},
							get title() {
								return title();
							},
							get subtitle() {
								return subtitle();
							}
						});

						var node_2 = sibling(node_1, 2);

						Ui_content(node_2, {
							children: ($$anchor, $$slotProps) => {
								var fragment_5 = root_5$6();
								var node_3 = first_child(fragment_5);

								Ui_loader(node_3, {
									size: 'page',
									get loading() {
										return loading();
									},
									get title() {
										return WAITING_TEXT();
									}
								});

								var node_4 = sibling(node_3, 2);

								{
									var consequent_1 = ($$anchor) => {
										buttons($$anchor, () => "");
									};

									if_block(node_4, ($$render) => {
										if (buttonsPosition() === "topOfContent") $$render(consequent_1);
									});
								}

								var node_5 = sibling(node_4, 2);

								snippet(node_5, () => $$props.children ?? noop);

								var node_6 = sibling(node_5, 2);

								{
									var consequent_2 = ($$anchor) => {
										buttons($$anchor, () => `is-mobile ${fullscreen() ? "is-footer" : ""}`);
									};

									if_block(node_6, ($$render) => {
										if (buttonsPosition() === "bottom") $$render(consequent_2);
									});
								}

								append($$anchor, fragment_5);
							},
							$$slots: { default: true }
						});

						append($$anchor, fragment_3);
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});
	}

	var root_2$7 = template(`<!> <!> <!>`, 1);

	function Ui_generic_selector($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef     {Object} Props
		 * @property    {boolean}   [show]
		 * @property    {boolean}   [showSearch = true]
		 * @property    {string}    [term]
		 * @property    {(fullscreen|wide|normal|narrow)} [size]   100vw, 75vw, 50vw, 25vw
		 * @property    {any}       [inputComponent]
		 * @property    {object}    [inputComponentProps]
		 * @property    {any}       [outputComponent]
		 * @property    {object}    [outputComponentProps]
		 * @property    {object}    [buttonsProps = { centered: true, class: "mt-5",}]
		 * @property    {object}    [results]
		 * @property    {function}  [onprev]
		 * @property    {function}  [onnext]
		 * @property    {function}  [onchange]
		 * @property    {function}  [onreject]
		 * @property    {function}  [onresolve]
		 */
		/** @type {Props} */
		let show = prop($$props, 'show', 3, true),
			showSearch = prop($$props, 'showSearch', 3, true),
			term = prop($$props, 'term', 15, ""),
			size = prop($$props, 'size', 3, "narrow"),
			UIInputComponent = prop($$props, 'inputComponent', 3, Ui_simple_search_input),
			inputComponentProps = prop($$props, 'inputComponentProps', 19, () => ({})),
			UIOutputComponent = prop($$props, 'outputComponent', 3, Ui_endless_list),
			outputComponentProps = prop($$props, 'outputComponentProps', 19, () => ({})),
			buttonsProps = prop($$props, 'buttonsProps', 19, () => ({ centered: true, class: "mt-5" })),
			rejectButtonProps = prop($$props, 'rejectButtonProps', 19, () => ({})),
			results = prop($$props, 'results', 31, () => proxy({
				list: [],
				page: 0,
				pages: 0,
				skip: 0,
				count: 0
			}));

		const buttons = [
			{
				title: $LOCALE()["not-node:button_cancel_label"],
				action: $$props.onreject,
				...rejectButtonProps()
			}
		];

		Ui_overlay($$anchor, {
			get onreject() {
				return $$props.onreject;
			},
			get show() {
				return show();
			},
			closeOnClick: true,
			closeButton: false,
			children: ($$anchor, $$slotProps) => {
				Ui_box($$anchor, {
					get class() {
						return `modal-selector ${size() ?? ''}`;
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = root_2$7();
						var node = first_child(fragment_2);

						{
							var consequent = ($$anchor) => {
								var fragment_3 = comment();
								var node_1 = first_child(fragment_3);

								component(node_1, UIInputComponent, ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get onchange() {
												return $$props.onchange;
											}
										},
										inputComponentProps,
										{
											get term() {
												return term();
											},
											set term($$value) {
												term($$value);
											}
										}
									));
								});

								append($$anchor, fragment_3);
							};

							if_block(node, ($$render) => {
								if (showSearch()) $$render(consequent);
							});
						}

						var node_2 = sibling(node, 2);

						component(node_2, UIOutputComponent, ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get onprev() {
										return $$props.onprev;
									},
									get onnext() {
										return $$props.onnext;
									},
									get onselect() {
										return $$props.onresolve;
									},
									class: 'has-height-up-to-60 overflow-scroll'
								},
								outputComponentProps,
								{
									get itemRenderer() {
										return $$props.itemRenderer;
									},
									get data() {
										return results();
									},
									set data($$value) {
										results($$value);
									}
								}
							));
						});

						var node_3 = sibling(node_2, 2);

						Ui_buttons(node_3, spread_props(buttonsProps, { values: buttons }));
						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIGenericSelector: Ui_generic_selector,
		UIModal: Ui_modal,
		UIOverlay: Ui_overlay
	});

	var root_2$6 = template(`<p> </p>`);
	var root_4$5 = template(`<p> </p>`);
	var root$c = template(`<article><div class="message-header"><!></div> <div class="message-body"><!></div></article>`);

	function Ui_message($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let classes = prop($$props, 'class', 3, "");
		var article = root$c();
		var div = child(article);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.titleSnip, () => $$props.title);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var p = root_2$6();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, $LOCALE()[$$props.title]));
				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if ($$props.titleSnip) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var node_2 = child(div_1);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_3 = first_child(fragment_1);

				snippet(node_3, () => $$props.messageSnip, () => $$props.message);
				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var p_1 = root_4$5();
				var text_1 = child(p_1, true);

				reset(p_1);
				template_effect(() => set_text(text_1, $LOCALE()[$$props.message]));
				append($$anchor, p_1);
			};

			if_block(node_2, ($$render) => {
				if ($$props.messageSnip) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		reset(div_1);
		reset(article);
		template_effect(() => set_class(article, `message ${classes() ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''}`));
		append($$anchor, article);
		pop();
		$$cleanup();
	}

	function Ui_error($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 19, () => UICommon$1.CLASS_ERR),
			props = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class']);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	function Ui_success($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 19, () => UICommon$1.CLASS_OK),
			props = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class']);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	var root_1$9 = template(`<div><p> </p> <!></div>`);

	function Ui_cookie_notification($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [show = false]
		 * @property {string} [message]
		 * @property {string} [agree]
		 */
		/** @type {Props} */
		let show = prop($$props, 'show', 15, false),
			message = prop($$props, 'message', 3, "Для улучшения работы сайта и его взаимодействия с пользователями мы используем файлы cookie. Продолжая работу с сайтом, Вы разрешаете использование cookie-файлов. Вы всегда можете отключить файлы cookie в настройках Вашего браузера."),
			agree = prop($$props, 'agree', 3, "Хорошо"),
			cooldown = prop($$props, 'cooldown', 3, 31536000000),
			lsKey = prop($$props, 'lsKey', 3, "cookie_date"),
			id = prop($$props, 'id', 3, "cookie_notification");

		onMount(() => {
			let cookieDate = localStorage.getItem(lsKey());

			if (!cookieDate || +cookieDate + cooldown() < Date.now()) {
				show(true);
			}
		});

		function accept() {
			localStorage.setItem(lsKey(), Date.now());
			show(false);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$9();
				var p = child(div);
				var text$1 = child(p, true);

				reset(p);

				var node_1 = sibling(p, 2);

				Ui_button(node_1, {
					onclick: accept,
					color: 'success',
					class: 'cookie_accept',
					children: ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[agree()]));
						append($$anchor, text_1);
					},
					$$slots: { default: true }
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, 'id', id());
					set_text(text$1, $LOCALE()[message()]);
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UICookieNotification: Ui_cookie_notification,
		UIError: Ui_error,
		UIMessage: Ui_message,
		UISuccess: Ui_success
	});

	//block elements

	var Elements = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Blocks: index$c,
		Buttons: index$b,
		Forms: index$6,
		Icons: index$7,
		Images: index$5,
		Inputs: index$9,
		Layouts: index$a,
		Links: index$4,
		Lists: index$3,
		Modals: index$2,
		Notifications: index$1,
		UICommon: UICommon$1,
		Various: index$8
	});

	const META_METHOD_INIT = Symbol("init"),
	  META_DATA = Symbol("data"),
	  META_WORKING = Symbol("working"),
	  META_OPTIONS = Symbol("options");
	let notBase = /*#__PURE__*/function (_EventEmitter) {
	  function notBase(input) {
	    var _this;
	    _classCallCheck(this, notBase);
	    _this = _callSuper(this, notBase);
	    _this[META_DATA] = {};
	    _this[META_WORKING] = {};
	    _this[META_OPTIONS] = {};
	    _this[META_METHOD_INIT](input);
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notBase, _EventEmitter);
	  return _createClass(notBase, [{
	    key: META_METHOD_INIT,
	    value: function (input) {
	      if (!input) {
	        input = {};
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "data")) {
	        this.setData(input.data);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "working")) {
	        this.setWorking(input.working);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "options")) {
	        this.setOptions(input.options);
	      }
	      this.log = notCommon$1.genLogMsg(this.getWorking("name"));
	      this.info = this.log;
	      this.debug = notCommon$1.genLogDebug(this.getWorking("name"));
	      this.error = notCommon$1.genLogError(this.getWorking("name"));
	    }
	  }, {
	    key: "setCommon",
	    value: function setCommon(what, args) {
	      switch (args.length) {
	        case 1:
	          {
	            /* set collection */
	            what = args[0];
	            break;
	          }
	        case 2:
	          {
	            /* set collection element */
	            notPath.set(args[0] /* path */, what /* collection */, undefined /* helpers */, args[1] /* value */);
	            break;
	          }
	      }
	      return this;
	    }
	  }, {
	    key: "getCommon",
	    value: function getCommon(what, args) {
	      switch (args.length) {
	        /* if we want get data by path */
	        case 1:
	          {
	            return notPath.get(args[0], what);
	          }
	        /* if we want get data by path with default value */
	        case 2:
	          {
	            let res = notPath.get(args[0], what);
	            if (res === undefined) {
	              /* no data, return default value */
	              return args[1];
	            } else {
	              /* data, return it */
	              return res;
	            }
	          }
	        /* return full collection */
	        default:
	          {
	            return what;
	          }
	      }
	    }

	    /*
	    CORE OBJECT
	      DATA - information
	      OPTIONS - how to work
	      WORKING - temporarily generated in proccess
	    */
	  }, {
	    key: "setData",
	    value: function setData() {
	      if (arguments.length === 1) {
	        this[META_DATA] = arguments[0];
	      } else {
	        this.setCommon(this.getData(), arguments);
	      }
	      this.emit("change");
	      return this;
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.getCommon(this[META_DATA], arguments);
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions() {
	      if (arguments.length === 1) {
	        this[META_OPTIONS] = arguments[0];
	      } else {
	        this.setCommon(this.getOptions(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      return this.getCommon(this[META_OPTIONS], arguments);
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking() {
	      if (arguments.length === 1) {
	        this[META_WORKING] = arguments[0];
	      } else {
	        this.setCommon(this.getWorking(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking() {
	      return this.getCommon(this[META_WORKING], arguments);
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon$1.report) {
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removeEvent();
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	      this.emit("destroy");
	    }
	  }]);
	}(EventEmitter);

	const OPT_MODE_HISTORY = Symbol("history"),
	  OPT_MODE_HASH = Symbol("hash"),
	  OPT_DEFAULT_CHECK_INTERVAL = 50;
	let notRouter = /*#__PURE__*/function (_notBase) {
	  function notRouter() {
	    var _this;
	    _classCallCheck(this, notRouter);
	    _this = _callSuper(this, notRouter, [{
	      working: {
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/",
	        //always in slashes /user/, /, /input/. and no /user or input/level
	        initialized: false,
	        delays: NAVIGATION_DELAYS,
	        delay_default: NAVIGATION_DELAY_DEFAULT
	      }
	    }]);
	    _defineProperty(_this, "host", "");
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Set object with named delays
	   * @param {Object.<string, number>} delays
	   * @returns {notRouter}
	   */
	  _inherits(notRouter, _notBase);
	  return _createClass(notRouter, [{
	    key: "setDelays",
	    value: function setDelays(delays) {
	      this.setWorking("delays", delays);
	      return this;
	    }

	    /**
	     * Set default navigation delay, provided as name of one of `delays` or in number form
	     * @param {string|number} delay
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setDefaultNavigationDelay",
	    value: function setDefaultNavigationDelay(delay) {
	      this.setWorking("delay_default", this.delayAsMs(delay));
	      return this;
	    }

	    /**
	     * Returns number of ms, if not set returns NAVIGATION_DELAY_DEFAULT
	     * @returns {number}
	     */
	  }, {
	    key: "getDefaultNavigationDelay",
	    value: function getDefaultNavigationDelay() {
	      return this.getWorking(`delay_default`, NAVIGATION_DELAY_DEFAULT);
	    }

	    /**
	     *  Ensures that delay is in ms, if its provided as name of alias, searches for it and returns, if not found - returns working default_delay
	     * @param {string|number} delay    name of delay alias or number of ms
	     * @returns {number}               delay in ms
	     */
	  }, {
	    key: "delayAsMs",
	    value: function delayAsMs(delay) {
	      if (typeof delay === "number") {
	        return delay;
	      } else {
	        if (typeof delay === "string" && delay.length > 0) {
	          return this.getWorking(`delays.${delay}`, this.getDefaultNavigationDelay());
	        } else {
	          return this.getDefaultNavigationDelay();
	        }
	      }
	    }

	    /**
	     *
	     *  @param {string}              url     we go to url
	     *  @param {string|number}       delay   name of delay alias or number of ms
	     *  @returns {NodeJS.Timeout}            timeout identificator
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay, doBefore) {
	      var _this2 = this;
	      return setTimeout(function () {
	        typeof doBefore === "function" && doBefore();
	        _this2.navigate(url);
	      }, this.delayAsMs(delay));
	    }

	    /**
	     * Use browser History API
	     */
	  }, {
	    key: "history",
	    value: function history() {
	      this.setWorking("mode", OPT_MODE_HISTORY);
	    }

	    /**
	     * Use hash part as container for location information
	     */
	  }, {
	    key: "hash",
	    value: function hash() {
	      this.setWorking("mode", OPT_MODE_HASH);
	    }

	    /**
	     * root should start and end with
	     * @param {string} root
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setRoot",
	    value: function setRoot(root) {
	      this.setWorking("root", root && root !== "/" ? "/" + this.clearSlashes(root) + "/" : "/");
	      return this;
	    }

	    /**
	     * clear first and last slashes from string
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "clearSlashes",
	    value: function clearSlashes(path) {
	      return path.toString().replace(/\/$/, "").replace(/^\//, "");
	    }
	  }, {
	    key: "add",
	    value: function add(re, handler) {
	      if (typeof re == "function") {
	        handler = re;
	        re = "";
	      }
	      let rule = {
	        re: re,
	        handler: handler
	      };
	      this.getWorking("routes").push(rule);
	      return this;
	    }
	  }, {
	    key: "addList",
	    value: function addList(list) {
	      for (let t in list) {
	        this.add(t, list[t]);
	      }
	      return this;
	    }
	  }, {
	    key: "remove",
	    value: function remove(param) {
	      for (var i = 0, r; i < this.getWorking("routes").length, r = this.getWorking("routes")[i]; i++) {
	        if (r.handler === param || r.re === param) {
	          this.getWorking("routes").splice(i, 1);
	          return this;
	        }
	      }
	      return this;
	    }
	  }, {
	    key: "flush",
	    value: function flush() {
	      this.setWorking({
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/"
	      });
	      return this;
	    }
	  }, {
	    key: "isInitialized",
	    value: function isInitialized() {
	      return this.getWorking("initialized");
	    }
	  }, {
	    key: "setInitialized",
	    value: function setInitialized(val = true) {
	      return this.setWorking("initialized", val);
	    }
	  }, {
	    key: "getFragment",
	    value: function getFragment() {
	      var fragment = "";
	      if (this.getWorking("mode") === OPT_MODE_HISTORY) {
	        if (!location) return "";
	        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
	        fragment = fragment.replace(/\?(.*)$/, "");
	        fragment = this.getWorking("root") != "/" ? fragment.replace(this.getWorking("root"), "") : fragment;
	      } else {
	        if (!window) return "";
	        var match = window.location.href.match(/#(.*)$/);
	        fragment = match ? match[1] : "";
	      }
	      return this.clearSlashes(fragment);
	    }
	  }, {
	    key: "checkLocation",
	    value: function checkLocation() {
	      let current = this.getWorking("current"),
	        fragment = this.getFragment(),
	        init = this.isInitialized();
	      if (current !== fragment || !init) {
	        this.setWorking("current", fragment);
	        this.check(fragment);
	        this.setInitialized(true);
	      }
	    }
	  }, {
	    key: "hrefClick",
	    value: function hrefClick() {
	      //console.log(...arguments);
	    }
	  }, {
	    key: "getRoot",
	    value: function getRoot() {
	      return this.getWorking("root");
	    }
	  }, {
	    key: "listen",
	    value: function listen(loopInterval = OPT_DEFAULT_CHECK_INTERVAL) {
	      this.setWorking("current", "notInitialized");
	      clearInterval(this.getWorking("interval"));
	      this.setWorking("interval", setInterval(this.checkLocation.bind(this), loopInterval));
	      window.addEventListener("popstate", this.hrefClick.bind(this));
	      return this;
	    }
	  }, {
	    key: "check",
	    value: function check(f) {
	      let fragment = f || this.getFragment(),
	        failBack = null;
	      for (let i = 0; i < this.getWorking("routes").length; i++) {
	        let path = this.getWorking("root") + this.getWorking("routes")[i].re,
	          fullRE = this.clearSlashes(decodeURI(path)),
	          match = fragment.match(fullRE);
	        if (match && match.length) {
	          if (fullRE === "") {
	            match.shift();
	            failBack = {
	              route: this.getWorking("routes")[i],
	              match
	            };
	          } else {
	            match.shift();
	            this.getWorking("routes")[i].handler.apply(this.host || {}, match);
	            this.emit("afterRoute", this.getWorking("routes")[i]);
	            return this;
	          }
	        }
	      }
	      if (failBack) {
	        failBack.route.handler.apply(this.host || {}, failBack.match);
	        this.emit("afterRoute", failBack.route);
	      }
	      return this;
	    }

	    /**
	     *  Refreshes page
	     * @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      var _this3 = this;
	      if (timeout > 0) {
	        setTimeout(function () {
	          return _this3.refresh();
	        }, timeout);
	      } else {
	        this.check(this.getWorking("current"));
	      }
	    }

	    /**
	     * Changes locations
	     * @param {string} path
	     * @returns
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(path) {
	      path = path ? path : "";
	      switch (this.getWorking("mode")) {
	        case OPT_MODE_HISTORY:
	          {
	            const newRoute = this.getFullRoute(path);
	            if (newRoute === this.lastRoute) {
	              this.refresh();
	            } else {
	              this.lastRoute = newRoute;
	              history.pushState(null, "", this.lastRoute);
	            }
	            break;
	          }
	        case OPT_MODE_HASH:
	          {
	            window.location.href.match(/#(.*)$/);
	            window.location.href = window.location.href.replace(/#(.*)$/, "") + "#" + path;
	            break;
	          }
	      }
	      return this;
	    }

	    /**
	     *  returns app root + path
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "getFullRoute",
	    value: function getFullRoute(path = "") {
	      path = this.clearSlashes(path);
	      const root = this.getWorking("root");
	      if (root !== "/") {
	        if (path.indexOf(root.substring(1)) === 0) {
	          return "/" + path;
	        }
	      }
	      return this.getWorking("root") + this.clearSlashes(path);
	    }

	    /**
	     * Returns all links with n-href attribute
	     * @returns {Array<HTMLAnchorElement>}
	     */
	  }, {
	    key: "getAllLinks",
	    value: function getAllLinks() {
	      const allElements = document.body.querySelectorAll("a");
	      let list = [];
	      for (let j = 0; j < allElements.length; j++) {
	        for (let i = 0, atts = allElements[j].attributes, n = atts.length; i < n; i++) {
	          if (atts[i].nodeName.indexOf("n-href") === 0) {
	            list.push(allElements[j]);
	            break;
	          }
	        }
	      }
	      return list;
	    }

	    /**
	     * Reroute all links(anchor tags) with n-href attribute.
	     * Disable navigation to href.
	     * @returns {notRouter}
	     */
	  }, {
	    key: "reRouteExisted",
	    value: function reRouteExisted() {
	      const list = this.getAllLinks();
	      for (let t = 0; t < list.length; t++) {
	        this.initRerouting(list[t], list[t].getAttribute("n-href"));
	      }
	      return this;
	    }

	    /**
	     * If `el` is not initialized, adds onclick listener to navigate to `link` location.
	     * Disables default navigation to href.
	     * @param {HTMLAnchorElement}   el
	     * @param {string}              link
	     * @returns
	     */
	  }, {
	    key: "initRerouting",
	    value: function initRerouting(el, link) {
	      var _this4 = this;
	      // @ts-ignore
	      if (!el.notRouterInitialized) {
	        let fullLink = this.getFullRoute(link);
	        el.setAttribute("href", fullLink);
	        el.addEventListener("click", function (e) {
	          e.preventDefault();
	          _this4.navigate(link);
	          return false;
	        });
	        // @ts-ignore
	        el.notRouterInitialized = true;
	      }
	      return this;
	    }
	  }]);
	}(notBase);
	var notRouter$1 = new notRouter();

	const LOG_PREFIX$1 = "APIQuee";
	let notAPIQueue = /*#__PURE__*/function (_notBase) {
	  function notAPIQueue(options = {}) {
	    var _this;
	    _classCallCheck(this, notAPIQueue);
	    _this = _callSuper(this, notAPIQueue, [{
	      working: {
	        name: options.name ? options.name : LOG_PREFIX$1
	      },
	      options
	    }]);
	    _this.busy = false;
	    _this.queue = [];
	    _this.busySince = -1;
	    _this.afterEmpty = undefined;
	    _this.start();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIQueue, _notBase);
	  return _createClass(notAPIQueue, [{
	    key: "stop",
	    value: function stop() {
	      if (this.interval) {
	        clearInterval(this.interval);
	        this.interval = undefined;
	        this.busy = false;
	        this.busySince = -1;
	      }
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      this.stop();
	      this.interval = setInterval(this.checkQueue.bind(this), this.QUEUE_CHECK_INTERVAL);
	    }
	  }, {
	    key: "checkQueue",
	    value: function checkQueue() {
	      var _this2 = this;
	      if (!this.isEmpty() && !this.isBusy()) {
	        this.setBusy().runNext().then(this.setFree.bind(this)).catch(function (e) {
	          _this2.error && _this2.error(e);
	          _this2.setFree();
	        });
	      } else {
	        if (!this.isBusy()) {
	          if (this.afterEmpty) {
	            let t = this.afterEmpty;
	            this.afterEmpty = undefined;
	            t();
	          }
	        }
	      }
	    }
	  }, {
	    key: "addToQueue",
	    value: function addToQueue(task) {
	      this.queue.push(task);
	    }
	  }, {
	    key: "runNext",
	    value: function runNext() {
	      let list = this.queue.map(function (action) {
	        return action.title;
	      }).join(", ");
	      this.debug && this.debug(`tasks [${list}]`);
	      let task = this.queue.shift();
	      if (!notCommon$1.isFunc(task.action)) {
	        this.error && this.error("В задании нет исполнимой части, action не функция", task.title);
	        return Promise.resolve();
	      }
	      if (!notCommon$1.isFunc(task.resolve)) {
	        this.error && this.error("В задании нет возвратной части, resolve не функция", task.title);
	        return task.action();
	      }
	      return task.action().then(task.resolve);
	    }
	  }, {
	    key: "isBusy",
	    value: function isBusy() {
	      let busy = !!this.busy,
	        now = Date.now() / 1000;
	      if (busy && this.busySince > -1) {
	        if (now - this.busySince > notAPIQueue.MAX_BUSY_TIME) {
	          this.setFree();
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "setBusy",
	    value: function setBusy() {
	      this.busy = true;
	      this.busySince = Date.now() / 1000;
	      return this;
	    }
	  }, {
	    key: "setFree",
	    value: function setFree() {
	      this.busy = false;
	      this.busySince = -1;
	      return this;
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return this.queue.length === 0;
	    }

	    /**
	     * Исполнитель запросов
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @returns    {Promise}    результат функции
	     **/
	  }, {
	    key: "run",
	    value: function run(action, afterEmpty = undefined, title = "") {
	      var _this3 = this;
	      if (afterEmpty && typeof this.afterEmpty === "undefined") {
	        this.afterEmpty = afterEmpty;
	      }
	      return new Promise(function (resolve, reject) {
	        try {
	          _this3.addToQueue({
	            action,
	            resolve,
	            title
	          });
	        } catch (e) {
	          _this3.error && _this3.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "actionIsQueued",
	    value: function actionIsQueued(title) {
	      return this.queue.some(function (queued) {
	        return queued.title == title;
	      });
	    }

	    /**
	     *
	     *
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @return    {Promise}
	     * @memberof notAPIQueue
	     */
	  }, {
	    key: "runIfNotQueued",
	    value: function runIfNotQueued(action, afterEmpty = undefined, title = "") {
	      if (this.actionIsQueued(title)) {
	        return Promise.resolve();
	      } else {
	        return this.run(action, afterEmpty, title);
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIQueue, "QUEUE_CHECK_INTERVAL", 100);
	_defineProperty(notAPIQueue, "MAX_BUSY_TIME", 300);

	let notAPIOptions = {
	  rps: 50,
	  protocol: 'http',
	  host: 'localhost',
	  port: 9000
	};

	const LOG_PREFIX = 'APIConnection';
	let notAPIConnection = /*#__PURE__*/function (_notBase) {
	  function notAPIConnection(options) {
	    var _this;
	    _classCallCheck(this, notAPIConnection);
	    _this = _callSuper(this, notAPIConnection, [{
	      options,
	      working: {
	        name: options.name ? options.name : LOG_PREFIX
	      }
	    }]);
	    _this.online = null;
	    _this.run();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIConnection, _notBase);
	  return _createClass(notAPIConnection, [{
	    key: "run",
	    value: function run() {
	      this.int = window.setInterval(this.check.bind(this), 1000);
	    }
	  }, {
	    key: "pause",
	    value: function pause() {
	      window.clearInterval(this.int);
	    }
	  }, {
	    key: "resume",
	    value: function resume() {
	      this.run();
	    }
	  }, {
	    key: "isOnline",
	    value: function isOnline() {
	      return window.navigator.onLine;
	    }
	  }, {
	    key: "check",
	    value: function check() {
	      let t = this.isOnline();
	      if (this.online !== null) {
	        if (this.online !== t) {
	          this.changeState(t);
	        }
	      }
	      this.online = t;
	    }
	  }, {
	    key: "changeState",
	    value: function changeState(online = false) {
	      if (online) {
	        this.emit('online');
	      } else {
	        this.emit('offline');
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIConnection, "int", void 0);
	_defineProperty(notAPIConnection, "online", void 0);

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		notAPIConnection: notAPIConnection,
		notAPIOptions: notAPIOptions,
		notAPIQueue: notAPIQueue
	});

	const ALL$1 = {};
	function exist$1(key) {
	  return notCommon$1.objHas(ALL$1, key);
	}
	function get$1(key) {
	  if (exist$1(key)) {
	    return ALL$1[key];
	  } else {
	    return false;
	  }
	}
	function create$1(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist$1(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL$1[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL$1[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL$1[key];
	}

	/**
	 * Creates object that is fake Store
	 * Some time this is useful when you need to initialize local var,
	 * before you could get actual Stores from central storage by its ID
	 *	@params {mixed} val 	data of type that is actual storage will contain
	 * @returns {Object}
	 */

	function fake(val) {
	  return {
	    subscribe(f) {
	      f(val);
	      return function () {};
	    },
	    set() {}
	  };
	}

	var stores = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		fake: fake,
		get: get$1
	});

	const //record
	  META_INTERFACE = Symbol('interface'),
	  META_MAP_TO_INTERFACE = ['getActionsCount', 'getActions', 'setFindBy', 'resetFilter', 'setFilter', 'getFilter', 'setSorter', 'getSorter', 'resetSorter', 'setPageNumber', 'setPageSize', 'setPager', 'setReturn', 'setSearch', 'getSearch', 'resetSearch', 'resetPager', 'getPager', 'addFormFieldType', 'addFormField', 'getFieldTypes', 'getActionFormFields'],
	  DEFAULT_ACTION_PREFIX$1 = '$';

	const OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY = ["_id", "id", "ID"],
	  DEFAULT_FILTER = {},
	  DEFAULT_SEARCH = "",
	  DEFAULT_RETURN = {},
	  DEFAULT_PAGE_NUMBER = 0,
	  DEFAULT_PAGE_SIZE = 10,
	  DEFAULT_ACTION_PREFIX = "$",
	  DEFAULT_WS_ROUTE_ACTION_SPLITTER = "//";
	let notInterface = /*#__PURE__*/function (_notBase) {
	  function notInterface(manifest, options) {
	    var _this;
	    _classCallCheck(this, notInterface);
	    _this = _callSuper(this, notInterface, [{
	      working: {
	        name: "network interface for: " + (manifest.model ? manifest.model : "unknown"),
	        filter: DEFAULT_FILTER,
	        search: DEFAULT_SEARCH,
	        return: DEFAULT_RETURN,
	        pager: {
	          size: DEFAULT_PAGE_SIZE,
	          page: DEFAULT_PAGE_NUMBER
	        }
	      },
	      options
	    }]);
	    _this.manifest = manifest;
	    _this.initActions();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notInterface, _notBase);
	  return _createClass(notInterface, [{
	    key: "initActions",
	    value: function initActions() {
	      if (this.getActionsCount() > 0) {
	        let actions = this.getActions();
	        for (let actionName in actions) {
	          this.initAction(actionName);
	        }
	      }
	    }
	  }, {
	    key: "initAction",
	    value: function initAction(actionName) {
	      var _this2 = this;
	      if (!notCommon$1.objHas(this, DEFAULT_ACTION_PREFIX + actionName)) {
	        this[DEFAULT_ACTION_PREFIX + actionName] = function (opts, headers, fileUpload = false, files) {
	          return _this2.request(_this2, actionName, opts, headers, fileUpload, files);
	        };
	      }
	    }
	  }, {
	    key: "requestHTTP",
	    value: function requestHTTP(record, actionName, params, headers = {}, fileUpload = false, files) {
	      try {
	        let compositeData = Object.assign({}, record.getData && typeof record.getData === "function" ? record.getData() : record, params);
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData),
	          requestParamsEncoded = this.encodeRequest(requestParams),
	          //id = this.getID(compositeData, actionData, actionName),
	          apiServerURL = this.getServerURL(),
	          url = this.getURL(compositeData, actionData, actionName),
	          opts = {};
	        if (fileUpload) {
	          url = this.getURL(params, actionData, actionName);
	          const fd = new FormData();
	          fd.append("file", files);
	          opts.body = fd;
	        } else {
	          if (["OPTIONS", "GET"].indexOf(actionData.method.toUpperCase()) === -1) {
	            opts = {
	              method: actionData.method,
	              body: JSON.stringify(record.getData && typeof record.getData === "function" ? record.getData() : record),
	              headers: {
	                Accept: "application/json",
	                "Content-Type": "application/json"
	              }
	            };
	          }
	        }
	        opts.method = actionData.method.toUpperCase();
	        if (headers && Object.keys(headers).length) {
	          opts.headers = headers;
	        }
	        return fetch(apiServerURL + url + requestParamsEncoded, opts).then(function (response) {
	          return response.json();
	        });
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "requestWS",
	    value: function requestWS(record, actionName) {
	      try {
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData);
	        const WS = notCommon$1.getApp().getWSClient();
	        const messageName = this.getWSRequestName(actionName);
	        const payload = Object.assign({}, requestParams, record.getData());
	        if (notCommon$1.objHas(actionData, "type") && typeof actionData.type === "string" && actionData.type.length && actionData.type !== "request") {
	          return WS.message(actionData.type, messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        } else {
	          return WS.request(messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        }
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "request",
	    value: function request() {
	      let actionData = this.getActionData(arguments[1]);
	      switch (this.selectTransport(actionData)) {
	        case "ws":
	          return this.requestWS(...arguments);
	        case "http":
	          return this.requestHTTP(...arguments);
	        default:
	          throw new Error("Offline");
	      }
	    }
	  }, {
	    key: "wsIsUp",
	    value: function wsIsUp(actionData) {
	      if (actionData.ws === true) {
	        let client;
	        if (notCommon$1.objHas(actionData, "wsClient") && actionData.wsClient) {
	          client = notCommon$1.getApp().getWSClient(actionData.wsClient);
	        } else {
	          client = notCommon$1.getApp().getWSClient();
	        }
	        if (client) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "selectTransport",
	    value: function selectTransport(actionData) {
	      if (this.wsIsUp(actionData)) {
	        return "ws"; //for ws/wss
	      }
	      if (notCommon$1.objHas(actionData, "method")) {
	        return "http"; //for http/https
	      }
	      return false; //for offline
	    }
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this && this.manifest ? this.manifest.model : null;
	    }
	  }, {
	    key: "getActionData",
	    value: function getActionData(actionName) {
	      return this.getActions() && this.getActions()[actionName] ? this.getActions()[actionName] : null;
	    }
	  }, {
	    key: "getActionsCount",
	    value: function getActionsCount() {
	      return this.getActions() ? Object.keys(this.getActions()).length : 0;
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.manifest && this.manifest.actions ? this.manifest.actions : {};
	    }
	  }, {
	    key: "parseParams",
	    value: function parseParams(start, end, line, record) {
	      let fieldName = "";
	      let len = start.length;
	      while (line.indexOf(start) > -1) {
	        let ind = line.indexOf(start);
	        let startSlice = ind + len;
	        let endSlice = line.indexOf(end);
	        if (ind > endSlice) {
	          break;
	        }
	        fieldName = line.slice(startSlice, endSlice);
	        if (fieldName == "") break;
	        this.log && this.log(start + fieldName + end, notPath.get(fieldName, record));
	        line = line.replace(start + fieldName + end, notPath.get(fieldName, record));
	      }
	      return line;
	    }
	  }, {
	    key: "parseLine",
	    value: function parseLine(line, record, actionName) {
	      line = line.replace(":modelName", this.manifest.model);
	      line = line.replace(":actionName", actionName);
	      line = this.parseParams(":record[", "]", line, record);
	      line = this.parseParams(":", "?", line, record);
	      return line;
	    }
	  }, {
	    key: "getURL",
	    value: function getURL(record, actionData, actionName) {
	      var line = this.parseLine(this.manifest.url, record, actionName) + (notCommon$1.objHas(actionData, "postFix") ? this.parseLine(actionData.postFix, record, actionName) : "");
	      return line;
	    }
	  }, {
	    key: "getServerURL",
	    value: function getServerURL() {
	      return notCommon$1.getApp() ? notCommon$1.getApp().getOptions("api.server.url", "") : "";
	    }
	  }, {
	    key: "getWSRequestName",
	    value: function getWSRequestName(actionName) {
	      const modelName = this.manifest.model;
	      return `${modelName}${DEFAULT_WS_ROUTE_ACTION_SPLITTER}${actionName}`;
	    }
	  }, {
	    key: "encodeRequest",
	    value: function encodeRequest(data) {
	      let p = "?";
	      for (let t in data) {
	        if (typeof data[t] !== "undefined" && data[t] !== null) {
	          p += encodeURIComponent(t) + "=" + encodeURIComponent(data[t].constructor === Object ? JSON.stringify(data[t]) : data[t]) + "&";
	        }
	      }
	      //for test purpose only, special test server needed
	      if (this.getOptions("test")) {
	        p += "&test=1";
	        if (this.getOptions("test.session")) {
	          p += "&session=" + this.getOptions("test.session");
	        }
	        if (this.getOptions("test.session")) {
	          p += "&role=" + this.getOptions("test.role");
	        }
	      }
	      return p;
	    }
	  }, {
	    key: "collectRequestData",
	    value: function collectRequestData(actionData) {
	      let requestData = {};
	      if (notCommon$1.objHas(actionData, "data") && Array.isArray(actionData.data)) {
	        for (let i = 0; i < actionData.data.length; i++) {
	          let dataProviderName = "get" + notCommon$1.capitalizeFirstLetter(actionData.data[i]);
	          if (this[dataProviderName] && typeof this[dataProviderName] === "function") {
	            let data = this[dataProviderName](),
	              res = {};
	            if (["pager", "sorter", "filter", "search", "return"].indexOf(actionData.data[i]) > -1) {
	              res[actionData.data[i]] = data;
	            } else {
	              res = data;
	            }
	            requestData = Object.assign(requestData, res);
	          }
	        }
	      }
	      return requestData;
	    }
	  }, {
	    key: "getID",
	    value: function getID(record, actionData) {
	      let resultId,
	        list = OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY,
	        prefixes = ["", this.manifest.model];
	      if (notCommon$1.objHas(actionData, "index") && actionData.index) {
	        list = [actionData.index].concat(OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY);
	      }
	      for (let pre of prefixes) {
	        for (let t of list) {
	          if (notCommon$1.objHas(record, pre + t)) {
	            resultId = record[pre + t];
	            break;
	          }
	        }
	      }
	      return resultId;
	    }
	  }, {
	    key: "setFindBy",
	    value: function setFindBy(key, value) {
	      var obj = {};
	      obj[key] = value;
	      return this.setFilter(obj);
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(filterData = DEFAULT_FILTER) {
	      this.setWorking("filter", filterData);
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      return this.setFilter();
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getWorking("filter");
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(searchData = DEFAULT_SEARCH) {
	      this.setWorking("search", searchData);
	      return this;
	    }
	  }, {
	    key: "resetSearch",
	    value: function resetSearch() {
	      return this.setSearch();
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      return this.getWorking("search");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(sorterData) {
	      this.setWorking("sorter", sorterData);
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter() {
	      return this.setSorter({});
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(returnData = DEFAULT_RETURN) {
	      this.setWorking("return", returnData);
	      return this;
	    }
	  }, {
	    key: "resetReturn",
	    value: function resetReturn() {
	      return this.setReturn({});
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setPageNumber",
	    value: function setPageNumber(pageNumber) {
	      this.setWorking("pager.page", pageNumber);
	      return this;
	    }
	  }, {
	    key: "setPageSize",
	    value: function setPageSize(pageSize) {
	      this.setWorking("pager.size", pageSize);
	      return this;
	    }

	    //pageSize = DEFAULT_PAGE_SIZE, pageNumber = DEFAULT_PAGE_NUMBER
	  }, {
	    key: "setPager",
	    value: function setPager() {
	      if ((arguments.length < 2 || isNaN(arguments[0]) || isNaN(arguments[1])) && arguments[0].constructor === Object && notCommon$1.objHas(arguments[0], "page") && notCommon$1.objHas(arguments[0], "size")) {
	        const pager = arguments[0];
	        this.setWorking("pager", {
	          size: pager.size || DEFAULT_PAGE_SIZE,
	          page: pager.page || DEFAULT_PAGE_NUMBER
	        });
	      } else if (arguments.length === 2 && !isNaN(arguments[0]) && !isNaN(arguments[1])) {
	        this.setWorking("pager", {
	          size: arguments[0] || DEFAULT_PAGE_SIZE,
	          page: arguments[1] || DEFAULT_PAGE_NUMBER
	        });
	      }
	      return this;
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      return this.setPager();
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getWorking("pager");
	    }
	  }, {
	    key: "getRecord",
	    value: function getRecord() {
	      this.getData();
	    }
	  }, {
	    key: "getDefaultAsPlainObject",
	    value: function getDefaultAsPlainObject() {
	      if (!this.manifest || !this.manifest.fields) {
	        return {};
	      }
	      const result = {};
	      for (const fieldName of Object.keys(this.manifest.fields)) {
	        if (Object.hasOwn(this.manifest.fields[fieldName], "default")) {
	          const defaultValue = this.manifest.fields[fieldName].default;
	          if (Array.isArray(defaultValue)) {
	            result[fieldName] = [...defaultValue];
	          } else if (typeof defaultValue === "object") {
	            result[fieldName] = {
	              ...defaultValue
	            };
	          } else {
	            result[fieldName] = defaultValue;
	          }
	        }
	      }
	      return result;
	    }
	  }]);
	}(notBase);

	let notRecord = /*#__PURE__*/function (_notBase) {
	  function notRecord(manifest, item) {
	    var _this;
	    _classCallCheck(this, notRecord);
	    _this = _callSuper(this, notRecord);
	    if (typeof item === "undefined" || item === null || typeof item !== "object") {
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && item.isProxy) {
	      notCommon$1.error("this is Proxy item");
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && (item.isRecord || item.isProperty)) {
	      return _possibleConstructorReturn(_this, item);
	    } else {
	      if (Array.isArray(item)) {
	        return _possibleConstructorReturn(_this, _this.createCollection(manifest, item));
	      }
	    }
	    _this.setOptions({});
	    _this[META_INTERFACE] = new notInterface(manifest, {});
	    _this.setData(item);
	    _this.interfaceUp();
	    _this.mapToInterface();
	    _this.mapToMethods();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notRecord, _notBase);
	  return _createClass(notRecord, [{
	    key: "toDefault",
	    value: function toDefault() {
	      return this.setData(this[META_INTERFACE].getDefaultAsPlainObject());
	    }
	  }, {
	    key: "mapToInterface",
	    value: function mapToInterface() {
	      let rec = this;
	      for (let t of META_MAP_TO_INTERFACE) {
	        if (this[META_INTERFACE][t] && typeof this[META_INTERFACE][t] === "function") {
	          this[t] = function () {
	            let res = rec[META_INTERFACE][t](...arguments);
	            return res == rec[META_INTERFACE] ? rec : res;
	          };
	        }
	      }
	    }
	  }, {
	    key: "mapToMethods",
	    value: function mapToMethods() {
	      let manifest = this[META_INTERFACE].manifest,
	        app = notCommon$1.getApp(),
	        methods = {};
	      if (manifest.methods) {
	        methods = manifest.methods;
	      } else if (app) {
	        methods = app.getOptions(["models", this[META_INTERFACE].manifest.model].join("."), {});
	      }
	      if (methods) {
	        for (let t in methods) {
	          if (Object.hasOwn(methods, t)) {
	            this[t] = methods[t];
	          }
	        }
	      }
	    }
	  }, {
	    key: "createCollection",
	    value: function createCollection(manifest, items) {
	      var collection = [];
	      for (var i = 0; i < items.length; i++) {
	        collection.push(new notRecord(manifest, items[i]));
	      }
	      return collection;
	    }
	  }, {
	    key: "interfaceUp",
	    value: function interfaceUp() {
	      if (this[META_INTERFACE].getActionsCount() > 0) {
	        let actions = this[META_INTERFACE].getActions();
	        for (let i in actions) {
	          this.actionUp(i, actions[i]);
	        }
	      }
	    }
	  }, {
	    key: "actionUp",
	    value: function actionUp(index) {
	      var _this2 = this;
	      if (!Object.hasOwn(this, [DEFAULT_ACTION_PREFIX$1 + index])) {
	        this[DEFAULT_ACTION_PREFIX$1 + index] = function (...params) {
	          return _this2[META_INTERFACE].request(_this2, index, ...params);
	        };
	      }
	    }
	    /*
	    -> 'path.to.key', valueOfKey
	    <- ok, with one onChange event triggered
	    */
	  }, {
	    key: "setAttr",
	    value: function setAttr(key, value) {
	      return this.setData(key, value);
	    }

	    /*
	    ->
	    {
	    'keyPath': value,
	    'key.subPath': value2,
	    'keyPath.0.title': value3
	    }
	    <- ok, with bunch of onChange events triggered
	    */
	  }, {
	    key: "setAttrs",
	    value: function setAttrs(objectPart) {
	      //notCommon.log('setAttrs', objectPart, Object.keys(objectPart));
	      if (objectPart && typeof objectPart === "object" && Object.keys(objectPart).length > 0) {
	        for (let path in objectPart) {
	          //notCommon.log('setAttrs one to go', path);
	          this.setAttr(path, objectPart[path]);
	        }
	      }
	    }

	    /*
	    -> 'pathToKey'
	    <- value1
	    */
	  }, {
	    key: "getAttr",
	    value: function getAttr(what, plain = false) {
	      let prx = this.getData(what, {});
	      if (plain) {
	        return notCommon$1.stripProxy(prx);
	      } else {
	        return prx;
	      }
	    }

	    /*
	    -> ['pathToKey', 'path.to.key', 'simpleKey',...]
	    <- [value1, value2, value3,...]
	    */
	  }, {
	    key: "getAttrs",
	    value: function getAttrs(what) {
	      let result = [];
	      if (what && what.length > 0) {
	        for (let path of what) {
	          result.push(this.getAttr(path));
	        }
	      }
	      return result;
	    }
	  }, {
	    key: "getManifest",
	    value: function getManifest() {
	      if (this[META_INTERFACE]) {
	        return this[META_INTERFACE].manifest;
	      } else {
	        return {};
	      }
	    }
	  }, {
	    key: "setItem",
	    value: function setItem(item) {
	      this.setData(item);
	      return this;
	    }
	  }]);
	}(notBase);

	/**
	 * @const {string} [OPT_CONTROLLER_PREFIX = "nc"] controller names prefix nc aka NotController
	 */
	const OPT_CONTROLLER_PREFIX = "nc";
	/**
	 * @const {string} [OPT_RECORD_PREFIX = "nr"] record names prefix nr aka NotRecord
	 */
	const OPT_RECORD_PREFIX = "nr";
	/**
	 * @const {string} [DEFAULT_WS_CLIENT_NAME = "main"] default name of WS client
	 */
	const DEFAULT_WS_CLIENT_NAME = "main";

	/**
	 * Class of application
	 * @class
	 */
	let notApp = /*#__PURE__*/function (_notBase) {
	  /**
	   * @class
	   * @param {object} options              application options
	   * @param {string} options.name         name
	   * @param {object} options.controllers  controllers
	   * @param {string}  options.manifestURL URL of network manifest with all available models/actions/fields requests options
	   */
	  function notApp(options) {
	    var _this;
	    _classCallCheck(this, notApp);
	    _this = _callSuper(this, notApp, [{
	      working: {
	        name: options.name,
	        interfaces: {},
	        controllers: notCommon$1.objHas(options, "controllers") ? options.controllers : {},
	        initController: null,
	        currentController: null,
	        uis: {},
	        wsc: {},
	        wss: {},
	        services: {}
	      },
	      options
	    }]);
	    _this?.log && _this.log("start app");
	    notCommon$1.register("app", _this);
	    _this.initManifest();
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Initializes application according to network manifest, which is retrieved from server
	   */
	  _inherits(notApp, _notBase);
	  return _createClass(notApp, [{
	    key: "initManifest",
	    value: function initManifest() {
	      var _this2 = this;
	      notCommon$1.getJSON(this.getOptions("manifestURL")).then(function (manifest) {
	        return _this2.setInterfaceManifest(manifest);
	      }).catch(function (e) {
	        return notCommon$1.report(e);
	      });
	    }

	    /**
	     * One page routing initialization
	     */
	  }, {
	    key: "initRouter",
	    value: function initRouter() {
	      this.setWorking("router", notRouter$1);
	      this.getWorking("router").setRoot(this.getOptions("router.root"));
	      notRouter$1.reRouteExisted();
	    }

	    /**
	     * Creates all the routes handlers and pushes them into router
	     */
	  }, {
	    key: "execRouter",
	    value: function execRouter() {
	      var routieInput = {};
	      for (let t = 0; t < this.getOptions("router.manifest").length; t++) {
	        let routeBlock = this.getOptions("router.manifest")[t],
	          paths = routeBlock.paths,
	          schemes = routeBlock.schemes,
	          controller = routeBlock.controller;
	        for (let i = 0; i < paths.length; i++) {
	          let pathScheme = schemes && Array.isArray(schemes) && schemes.length > i ? schemes[i] : false;
	          routieInput[paths[i]] = this.bindController(controller, pathScheme);
	        }
	      }
	      this.getWorking("router").addList(routieInput).listen(); //.navigate(this.getOptions('router.index'));
	    }

	    /**
	     * Sets interface manifest option
	     * @param {object}  manifest    interface manifest
	     */
	  }, {
	    key: "setInterfaceManifest",
	    value: function setInterfaceManifest(manifest) {
	      Object.freeze(manifest);
	      this.setOptions("interfaceManifest", manifest);
	      this.initRouter();
	      this.update();
	    }

	    /**
	     * returns constructor of interface model
	     * @param {string}  modelName   model name
	     * @returns {object}    interface model constructor
	     */
	  }, {
	    key: "getInterfaceManifest",
	    value: function getInterfaceManifest(modelName) {
	      if (modelName) {
	        return this.getOptions("interfaceManifest")[modelName];
	      } else {
	        return this.getOptions("interfaceManifest");
	      }
	    }

	    /**
	     * Updating Application, reloads interfaces, init controller launched, start again
	     */
	  }, {
	    key: "update",
	    value: function update() {
	      //нужно инициализировать
	      //модели полученными интерфейсами
	      this.updateInterfaces();
	      //иницилицировать и запустить контроллер инициализации
	      this.initController();
	      this.startApp();
	    }

	    /**
	     * Initialization of services, startup of routing
	     */
	  }, {
	    key: "startApp",
	    value: function startApp() {
	      this.initServices();
	      //создать контроллеры
	      //роутер и привязать к нему контроллеры
	      this.execRouter();
	      this.emit("afterStarted", this);
	    }

	    /**
	     *
	     * @param {object} controllerName controller constructor
	     * @param {string[]} controllerPathScheme
	     * @returns {function} function creates new controller instance and pass in notApp instance, arguments from router parser and pathScheme
	     */
	  }, {
	    key: "bindController",
	    value: function bindController(controllerName, controllerPathScheme) {
	      let app = this;
	      return function () {
	        new controllerName(app, arguments, controllerPathScheme);
	      };
	    }

	    /**
	     * Initializes 'initialization' controller which is runs once,
	     * to perform custom initializations routines by application code
	     */
	  }, {
	    key: "initController",
	    value: function initController() {
	      if (typeof this.getOptions("initController") !== "undefined") {
	        let initController = this.getOptions("initController");
	        this.setWorking("initController", new initController(this));
	      }
	    }

	    /**
	     * Returns working controller
	     * @returns {object} working controller
	     */
	  }, {
	    key: "getCurrentController",
	    value: function getCurrentController() {
	      return this.getWorking("currentController");
	    }

	    /**
	     * Destroyes working controller then sets provided as working
	     * @param {object} ctrl controller instance
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "setCurrentController",
	    value: function setCurrentController(ctrl) {
	      let oldCtrl = this.getCurrentController();
	      if (oldCtrl && oldCtrl.destroy) {
	        oldCtrl.destroy();
	      }
	      this.setWorking("currentController", ctrl);
	      return this;
	    }

	    /**
	     * Creates arrow function: (modelInitData = {}) => notRecord
	     * Factory that creates notRecord instances with binded
	     * recordManifest and provided data to initialize record
	     * @param {Object} recordManifest
	     * @return {function}
	     * @memberof notApp
	     */
	  }, {
	    key: "createInterfaceModelFactory",
	    value: function createInterfaceModelFactory(recordManifest) {
	      return function (recordData) {
	        return new notRecord(recordManifest, recordData);
	      };
	    }

	    /**
	     * Clears interfaces, recreates all according to Options.interafaceManifest
	     */
	  }, {
	    key: "updateInterfaces",
	    value: function updateInterfaces() {
	      this.clearInterfaces();
	      let manifests = this.getOptions("interfaceManifest");
	      if (manifests) {
	        for (let name in manifests) {
	          let recordManifest = manifests[name],
	            recordMethods = this.getOptions(["models", name].join("."), {});
	          recordManifest.methods = recordMethods;
	          const nameInt = this.createInterfaceModelFactory(recordManifest);
	          this.setInterface(name, nameInt);
	        }
	      }
	    }

	    /**
	     * Converts interface name (modelName) to standartizied prefixModelName
	     * @param {string} name interface model name
	     * @returns {string}    not record name
	     */
	  }, {
	    key: "getRecordName",
	    value: function getRecordName(name) {
	      return OPT_RECORD_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Converts controller name (controllerName) to standartizied prefixControllerName
	     * @param {string} name controller name
	     * @returns {string}    not controller name
	     */
	  }, {
	    key: "getControllerName",
	    value: function getControllerName(name) {
	      return OPT_CONTROLLER_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Sets named interface factory function
	     *
	     * @param {string} name
	     * @param {function} modelFactory
	     * @return {notApp}
	     * @memberof notApp
	     */
	  }, {
	    key: "setInterface",
	    value: function setInterface(name, modelFactory) {
	      return this.setWorking(`interfaces.${name}`, modelFactory);
	    }

	    /**
	     * Returns all network interfaces
	     * @returns {object} all network insterfaces
	     */
	  }, {
	    key: "getInterfaces",
	    value: function getInterfaces() {
	      return this.getWorking("interfaces");
	    }

	    /**
	     * Sets interfaces list clear
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "clearInterfaces",
	    value: function clearInterfaces() {
	      this.setWorking("interfaces", {});
	      return this;
	    }

	    /**
	     * Sets WebSockets client
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME] name of client
	     * @param {object} wsc  notWSClient instance
	     * @returns {object} notApp instance
	     */
	    // @ts-ignore
	  }, {
	    key: "setWSClient",
	    value: function setWSClient(name = DEFAULT_WS_CLIENT_NAME, wsc) {
	      return this.setWorking(`wsc.${name}`, wsc);
	    }

	    /**
	     * Returns web sockets client instance by name
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME]
	     * @returns {object} instance of notWSClient
	     */
	  }, {
	    key: "getWSClient",
	    value: function getWSClient(name = DEFAULT_WS_CLIENT_NAME) {
	      return this.getWorking(`wsc.${name}`);
	    }

	    /**
	     * returns network interface class initializator
	     * @param {string} name name of network interface
	     * @returns {function} interface class initializator
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name) {
	      return this.getInterfaces()[name];
	    }

	    /**
	     * Returns network interface (model) initialized with provided data
	     * @param {string} name interface(modelName)
	     * @param {object} [data={}]    model data
	     * @returns network interface initializes with provided data
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data = {}) {
	      return this.getInterface(name)(data);
	    }

	    /**
	     * Sets service
	     * @param {string} name name of the service
	     * @param {object|function} val service
	     */
	  }, {
	    key: "setService",
	    value: function setService(name, val) {
	      return this.setWorking(`services.${name}`, val);
	    }

	    /**
	     * Returns service
	     * @param {string} name name of the service
	     * @returns {object|function} service
	     */
	  }, {
	    key: "getService",
	    value: function getService(name) {
	      return this.getWorking(`services.${name}`);
	    }

	    /**
	     * Initializes all provided services
	     */
	  }, {
	    key: "initServices",
	    value: function initServices() {
	      if (this.getOptions("services")) {
	        for (let servName in this.getOptions("services")) {
	          try {
	            let serv = this.getOptions(`services.${servName}`);
	            const servType = notCommon$1.detectType(serv);
	            switch (servType) {
	              case "function":
	              case "class":
	                this.setService(servName, new serv(this));
	                break;
	              default:
	                this.setService(servName, serv);
	            }
	          } catch (e) {
	            this?.error && this.error(`Service (${servName}) init error`, e);
	          }
	        }
	      }
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} moduleName   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "getConfigReaderForModule",
	    value: function getConfigReaderForModule(moduleName = "") {
	      var _this3 = this;
	      const modConfPath = ["modules", moduleName].join(".");
	      return {
	        get: function (subPath, fallback) {
	          if (subPath && typeof subPath == "string" && subPath.length) {
	            return _this3.getOptions([modConfPath, subPath].join("."), fallback);
	          } else {
	            return _this3.getOptions(modConfPath, fallback);
	          }
	        }
	      };
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} [moduleName='']   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "moduleConfig",
	    value: function moduleConfig(moduleName = "") {
	      return this.getConfigReaderForModule(moduleName);
	    }
	  }]);
	}(notBase);
	/**
	 *  @static {function} DEFAULT_WS_CLIENT_NAME  function to perform deep merges of objects
	 */
	_defineProperty(notApp, "DEFAULT_WS_CLIENT_NAME", DEFAULT_WS_CLIENT_NAME);

	/**
	 * @const {string}  [OPT_DEFAULT_ACTION_NAME = "default"]      default action name
	 */
	const OPT_DEFAULT_ACTION_NAME = "default";

	/**
	 * @const {string}  [OPT_DEFAULT_CONTAINER_SELECTOR = "main.content"]  selector of container HTML
	 *                          element
	 */
	const OPT_DEFAULT_CONTAINER_SELECTOR = "main.content";

	/**
	 * @const {string}  [OPT_DEFAULT_PLURAL_NAME = "Models"]  default plural name of entities
	 */
	const OPT_DEFAULT_PLURAL_NAME = "Models";

	/**
	 * @const {string}  [OPT_DEFAULT_SINGLE_NAME = "Model"]  default single name of entities
	 */
	const OPT_DEFAULT_SINGLE_NAME = "Model";

	/**
	 * @const {string}  [OPT_DEFAULT_MODULE_NAME="main"]  default module name
	 */
	const OPT_DEFAULT_MODULE_NAME = "main";

	/**
	 * @const {boolean}  [OPT_DEFAULT_AUTO_NAME = true]  if shoould be used auto name generator
	 */
	const OPT_DEFAULT_AUTO_NAME = true;

	/**
	 *  Basic class for user controller
	 *  @extends notBase
	 */
	let notController = /*#__PURE__*/function (_notBase) {
	  /**
	   *  @class
	   *  @param {import('./app.js').default} app
	   *  @param  {string}    name
	   */
	  function notController(app, name) {
	    var _this;
	    _classCallCheck(this, notController);
	    _this = _callSuper(this, notController, [{}]);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "els", void 0);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "make", void 0);
	    /**
	     *
	     * @type    {null|import('./app.js').default}
	     * @memberof notController
	     */
	    _defineProperty(_this, "app", void 0);
	    _this.app = app;
	    _this.app.setCurrentController(_this);
	    _this.setWorking({
	      name,
	      ready: false,
	      views: {},
	      libs: {},
	      helpers: {}
	    });
	    _this.ui = {};
	    _this.els = {};
	    _this.setData({});
	    _this.setOptions({
	      moduleName: OPT_DEFAULT_MODULE_NAME,
	      containerSelector: OPT_DEFAULT_CONTAINER_SELECTOR,
	      prefix: app.getOptions("paths.module"),
	      names: {
	        plural: OPT_DEFAULT_PLURAL_NAME,
	        single: OPT_DEFAULT_SINGLE_NAME
	      }
	    });
	    _this.setURLPrefix(app.getOptions("router.root"));
	    /*
	    сразу делаем доступными модели notRecord из nc`ControllerName` будут доступны как this.nr`ModelName`
	    */
	    let interfaces = app.getInterfaces();
	    _this.make = {};
	    for (let t in interfaces) {
	      // @ts-ignore
	      if (Object.hasOwn(interfaces, t)) {
	        _this.make[t] = interfaces[t];
	      }
	    }
	    _this.on("destroy", function () {
	      _this.app = null;
	      for (let uiName in _this.ui) {
	        _this.ui[uiName].destroy && _this.ui[uiName].destroy();
	        _this.ui[uiName].$destroy && _this.ui[uiName].$destroy();
	        _this.ui[uiName] = null;
	      }
	      _this.els = null;
	      _this.make = null;
	    });
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   *  Returns current notApp
	   *  @return {import('./app.js').default}
	   */
	  _inherits(notController, _notBase);
	  return _createClass(notController, [{
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }

	    /**
	     *  Sets default controller model
	     *  @param {import('./record.js')}  model  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModel",
	    value: function setModel(model) {
	      this.setWorking("model", model);
	      return this;
	    }

	    /**
	     *  If zero or one argument provided this modelName instance will be returned
	     *  If two provided and first is a string than instance of name will be returned initialized with second object param or empty object
	     *  @param {string|object}      [name]    modelName of instance to return or initial data for instance
	     *  @param {object}             [data]    model data
	     *  @return {import('./record.js').default}
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        const int = this.getInterface(name);
	        return int && int(data || {});
	      } else {
	        const int = this.getInterface();
	        return int && int(name || {});
	      }
	    }

	    /**
	     * Returns controller interface if name is not specified or interface of specified
	     *
	     * @param {string} [name=""]
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = "") {
	      return this.app?.getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getWorking("modelName");
	    }
	    /**
	     *  Sets default controller model name
	     *  @param {string}  modelName  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelName",
	    value: function setModelName(modelName) {
	      this.setWorking("modelName", notCommon$1.lowerFirstLetter(modelName));
	      return this;
	    }

	    /**
	     *  Returns current model primary ID field name
	     *  @return {import('./record.js')}
	     */
	  }, {
	    key: "getModelIDFieldName",
	    value: function getModelIDFieldName() {
	      return this.getWorking("modelIDFieldName", "_id");
	    }

	    /**
	     *  Sets current model primary ID field name
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelIDFieldName",
	    value: function setModelIDFieldName(val = "_id") {
	      return this.setWorking("modelIDFieldName", val);
	    }

	    /**
	     *  Marks this controller as ready
	     *  emits "ready"/"busy" events
	     *  @param {Boolean}  val  true/false
	     */
	  }, {
	    key: "setReady",
	    value: function setReady(val = true) {
	      this.setWorking("ready", val);
	      val ? this.emit("ready") : this.emit("busy");
	    }

	    /**
	     *  Sets module URL prefix
	     *  @param {string} val URL prefix
	     *  @return {notController} this
	     */
	  }, {
	    key: "setURLPrefix",
	    value: function setURLPrefix(val) {
	      this.setOptions("urlPrefix", val);
	      this.updateAutoName();
	      return this;
	    }

	    /**
	     *  Returns module url prefix
	     *  @return  {string} prefix
	     */
	  }, {
	    key: "getURLPrefix",
	    value: function getURLPrefix() {
	      return this.getOptions("urlPrefix");
	    }

	    /**
	     *  Sets module name
	     *  @param {string} val name of the module
	     *  @return {notController} this
	     */
	  }, {
	    key: "setModuleName",
	    value: function setModuleName(val) {
	      this.setOptions("moduleName", notCommon$1.lowerFirstLetter(val));
	      this.updateAutoName();
	      return this;
	    }
	    /**
	     *  Returns module name
	     *  @return  {string} module name
	     */
	  }, {
	    key: "getModuleName",
	    value: function getModuleName() {
	      return this.getOptions("moduleName");
	    }

	    /**
	     *  Returns this module path prefix
	     *  @return {string}  path to module dir
	     */
	  }, {
	    key: "getModulePrefix",
	    value: function getModulePrefix() {
	      return [notCommon$1.getApp().getOptions("paths.modules"), this.getModuleName()].join("/");
	    }

	    /**
	     *  Returns this model URL with URL prefix
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelURL",
	    value: function getModelURL() {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName()
	      });
	    }

	    /**
	     *  Returns this model action URL with URL prefix
	     * @param  {string}   id       some identificator of model
	     * @param  {string}   action   action name
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelActionURL",
	    value: function getModelActionURL(id, action = "") {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName(),
	        id,
	        action
	      });
	    }

	    /**
	     * Creates url from value content
	     * @param {object}  val
	     **/
	  }, {
	    key: "buildURL",
	    value: function buildURL(val) {
	      return notCommon$1.buildURL(val);
	    }

	    /**
	     *  Updates working name
	     *  @return {notController} this
	     */
	  }, {
	    key: "updateAutoName",
	    value: function updateAutoName() {
	      if (this.getOptions("autoName", OPT_DEFAULT_AUTO_NAME)) ;
	      return this;
	    }

	    /**
	     *  Sets object name
	     *  @param {string} val name of the object
	     *  @return {notController} this
	     */
	  }, {
	    key: "setName",
	    value: function setName(val) {
	      this.setWorking("name", val);
	      this.setOptions("autoName", false);
	      return this;
	    }

	    /**
	     *  Gets object name
	     *  @return {string}
	     */
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }

	    /**
	     *  Preload records from server, using listAll method,
	     *  returns Promise
	     *  @param {object}  list  map of preloaded records
	     *  @return {Promise}
	     */
	  }, {
	    key: "preloadLib",
	    value: function preloadLib(list = {}) {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        if (typeof list !== "object") {
	          resolve(undefined);
	        } else {
	          _this2.setWorking("loading", []);
	          for (let t in list) {
	            _this2.getWorking("loading").push(list[t]);
	            _this2.make[list[t]]({}).$listAll().then(function (data) {
	              if (!_this2.getOptions("libs")) {
	                _this2.setOptions("libs", {});
	              }
	              _this2.getOptions("libs")[t] = data;
	              if (_this2.getWorking("loading").indexOf(list[t]) > -1) {
	                _this2.getWorking("loading").splice(_this2.getWorking("loading").indexOf(list[t]), 1);
	              }
	              if (_this2.getWorking("loading").length === 0) {
	                resolve(undefined);
	              }
	            }).catch(function (err) {
	              _this2.report(err);
	              reject();
	            });
	          }
	          if (_this2.getWorking("loading").length === 0) {
	            resolve(undefined);
	          }
	        }
	      });
	    }

	    /**
	     * emits afterRender event
	     */
	  }, {
	    key: "onAfterRender",
	    value: function onAfterRender() {
	      this.emit("afterRender");
	    }

	    /**
	     *  Transform route name in action name
	     *  @param {String}   name tranform action name
	     *  @return {String}
	     */
	  }, {
	    key: "getActionName",
	    value: function getActionName(name = OPT_DEFAULT_ACTION_NAME) {
	      return "run" + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     *  Get default controller action name
	     *  @return {String} default action from options
	     */
	  }, {
	    key: "getDefaultActionName",
	    value: function getDefaultActionName() {
	      return this.getActionName(this.getOptions("defaultAction", OPT_DEFAULT_ACTION_NAME));
	    }

	    /**
	     *  Route params into specific run[Route_name] function
	     *  @param {array}   params   controller input params
	     *  @return {undefined}
	     */
	  }, {
	    key: "route",
	    value: function route(params) {
	      let [routerName, ...subParams] = params,
	        actionName = this.getActionName(routerName ? routerName : OPT_DEFAULT_ACTION_NAME);
	      if (typeof this[actionName] === "function") {
	        this.setCurrentAction(actionName);
	        this[actionName](subParams);
	      } else if (this[this.getDefaultActionName()]) {
	        this.setCurrentAction(this.getDefaultActionName());
	        this[this.getDefaultActionName()](subParams);
	      } else {
	        this.setCurrentAction(undefined);
	        this.error && this.error("No action in router", params);
	      }
	    }

	    /**
	     * Sets working action
	     * @params {string} actionName current action name
	     */
	  }, {
	    key: "setCurrentAction",
	    value: function setCurrentAction(actionName) {
	      this.setWorking("action", actionName);
	    }

	    /**
	     * Gets working action
	     * @returns {string} current action name
	     */
	  }, {
	    key: "getCurrentAction",
	    value: function getCurrentAction() {
	      return this.getWorking("action");
	    }

	    /**
	     *  Return application options
	     *  @return {object}
	     */
	  }, {
	    key: "getAppOptions",
	    value: function getAppOptions() {
	      try {
	        return this.getApp().getOptions();
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module options
	     *  @param  {string}   [moduleName]    name of the module which options requested
	     *  @return {object}
	     */
	  }, {
	    key: "getModuleOptions",
	    value: function getModuleOptions(moduleName) {
	      try {
	        return this.getApp().getOptions(["modules", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module services
	     *  @param  {string}   moduleName    name of the module which services requested
	     *  @return {object}
	     */
	  }, {
	    key: "getServices",
	    value: function getServices(moduleName) {
	      try {
	        return this.getApp().getOptions(["services", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module components
	     *  @param  {string}   moduleName    name of the module which components requested
	     *  @return {object}
	     */
	  }, {
	    key: "getComponents",
	    value: function getComponents(moduleName) {
	      try {
	        return this.getApp().getOptions(["components", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Refreshes current URL, re-run all action
	     *  @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      this.app?.getWorking("router").refresh(timeout);
	    }

	    /**
	     * Returns path pattern for router
	     * @params {number} [0] paramsCount   number of params
	     * @return {string}  pattern for controller supported url
	     */
	  }, {
	    key: "getRouter",
	    value:
	    /**
	     * Returns Application router
	     * @returns {import('./router.js').default}
	     */
	    function getRouter() {
	      return this.app?.getWorking("router");
	    }

	    /**
	     * Changes location to `url` after `delay` ms
	     * @param {string} url
	     * @param {number|string}   delay   number in ms or name of delay
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay = NAVIGATION_DELAY_DEFAULT, doBefore = function () {}) {
	      return this.getRouter().navigateWithDelay(url, delay, doBefore);
	    }

	    /**
	     * Changes location to `url`
	     * @param {string} url
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      return this.getRouter().navigate(url);
	    }

	    /**
	     *  Navigating to this controller main model `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateAction",
	    value: function navigateAction(id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), this.getModelName(), id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to this controller module model of `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModelAction",
	    value: function navigateModelAction(modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), modelName, id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to `moduleName` `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} moduleName
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModuleAction",
	    value: function navigateModuleAction(moduleName, modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      if (delay) {
	        return this.getRouter().navigateWithDelay(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }), delay, doBefore);
	      } else {
	        return this.getRouter().navigate(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }));
	      }
	    }

	    /**
	     * Creates menu item from child class constructor
	     *
	     * @static
	     * @param {notController} childConstructor
	     * @return {Array<import('./types.js').NavigationItem>}
	     * @memberof notController
	     */
	  }], [{
	    key: "MODULE_NAME",
	    get:
	    /**
	     *  @static {string} MODULE_NAME  name of module
	     */
	    function () {
	      return OPT_DEFAULT_MODULE_NAME;
	    }
	    /**
	     *  @static {string} MODEL_NAME  name of model
	     */
	  }, {
	    key: "MODEL_NAME",
	    get: function () {
	      return "ModelName";
	    }
	  }, {
	    key: "LABELS",
	    get: function () {
	      return {
	        plural: `${OPT_DEFAULT_MODULE_NAME}:model_label_plural`,
	        single: `${OPT_DEFAULT_MODULE_NAME}:model_label_single`
	      };
	    }
	  }, {
	    key: "getControllerRoute",
	    value: function getControllerRoute(paramsCount = 0) {
	      let path = [];
	      if (this.MODULE_NAME && this.MODULE_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODULE_NAME));
	      }
	      if (this.MODEL_NAME && this.MODEL_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODEL_NAME));
	      }
	      path = [path.join("/")];
	      for (let i = 0; i < paramsCount; i++) {
	        path.push("/([^/]+)");
	      }
	      return path.join("");
	    }

	    /**
	     * Returns path patterns for router
	     * @params {number} [0] paramsDeep   how many paths with params in the end
	     * @return {string[]}  patterns for controller supported url in order of simplification
	     */
	  }, {
	    key: "getControllerRoutes",
	    value: function getControllerRoutes(paramsDeep = 0) {
	      let routes = [this.getControllerRoute(0)];
	      for (let i = 0; i < paramsDeep; i++) {
	        routes.unshift(this.getControllerRoute(i + 1));
	      }
	      return routes;
	    }

	    /**
	     * Returns router rule.
	     * @returns {Object} router rule {paths:String[], controller:notController}
	     */
	  }, {
	    key: "getRoutes",
	    value: function getRoutes() {
	      return {
	        paths: this.getControllerRoutes(this.PARAMS_LENGTH),
	        controller: this
	      };
	    }
	  }, {
	    key: "getCommonMenu",
	    value: function getCommonMenu(childConstructor) {
	      return [{
	        // @ts-ignore
	        section: childConstructor.MODULE_NAME,
	        // @ts-ignore
	        title: childConstructor.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(
        // @ts-ignore
        childConstructor.MODULE_NAME
        // @ts-ignore
        )}/${notCommon$1.lowerFirstLetter(childConstructor.MODEL_NAME)}`
	      }];
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu() {}
	  }]);
	}(notBase);
	/**
	 *  @static {number} PARAMS_LENGTH  number of params in URL path
	 */
	_defineProperty(notController, "PARAMS_LENGTH", 2);

	const ALL = {};
	function exist(key) {
	  return Object.hasOwn(ALL, key);
	}
	function get(key) {
	  if (exist(key)) {
	    return ALL[key];
	  } else {
	    return false;
	  }
	}
	function create(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL[key];
	}

	function onInput(ev, id, fieldname, dispatch) {
		let data = {
			id: id(),
			field: fieldname(),
			value: ev.target.type === 'checkbox' ? ev.target.checked : ev.target.value
		};

		dispatch('change', data);
		return true;
	}

	var root$b = template(`<input type="checkbox"> <label class="label"></label>`, 1);

	function Ui_switch($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {boolean} [value]
		 * @property {string} [fieldname]
		 * @property {boolean} [disabled]
		 * @property {boolean} [readonly]
		 * @property {string} [styling]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ''),
			value = prop($$props, 'value', 15, false),
			fieldname = prop($$props, 'fieldname', 3, 'switch'),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			styling = prop($$props, 'styling', 3, " is-rounded is-success ");

		var fragment = root$b();
		var input = first_child(fragment);

		remove_input_defaults(input);
		input.__input = [onInput, id, fieldname, dispatch];

		var label = sibling(input, 2);

		template_effect(() => {
			set_class(input, `switch ${styling() ?? ''}`);
			set_attribute(input, 'id', `edit-table-row-cell-inline-switch-${fieldname() ?? ''}-${id() ?? ''}`);
			set_attribute(input, 'name', fieldname());
			input.readOnly = readonly();
			input.disabled = disabled();
			set_attribute(label, 'for', `edit-table-row-cell-inline-switch-${fieldname() ?? ''}-${id() ?? ''}`);
		});

		bind_checked(input, value);
		append($$anchor, fragment);
		pop();
	}

	delegate(['input']);

	var root_3$5 = template(`<a> </a>`);
	var root_2$5 = template(`<div class="mx-1 tags has-addons svelte-38rpfk"><span class="tag"> </span> <span><!></span></div>`);
	var root_6$5 = template(`<a> </a>`);
	var root_5$5 = template(`<span><!></span>`);

	function Ui_tags($$anchor, $$props) {
		/*
		  import { createEventDispatcher } from 'svelte';
		  let dispatch = createEventDispatcher();
		*/
		/**
		 * @typedef {Object} Props
		 * @property {any} [values] - item = {
		id,        //unique
		title,     //some text
		value,      //for double tags
		color       //coloring
		}
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []);
		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.id, ($$anchor, item) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var div = root_2$5();
					var span = child(div);
					var text$1 = child(span, true);

					reset(span);

					var span_1 = sibling(span, 2);
					var node_2 = child(span_1);

					{
						var consequent = ($$anchor) => {
							var a = root_3$5();
							var text_1 = child(a, true);

							reset(a);

							template_effect(() => {
								set_attribute(a, 'href', get$3(item).url);
								set_class(a, clsx(get$3(item).urlCustomClasses), 'svelte-38rpfk');
								set_text(text_1, get$3(item).value);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							var text_2 = text();

							template_effect(() => set_text(text_2, get$3(item).value));
							append($$anchor, text_2);
						};

						if_block(node_2, ($$render) => {
							if (get$3(item).url) $$render(consequent); else $$render(alternate, false);
						});
					}

					reset(span_1);
					reset(div);

					template_effect(() => {
						set_text(text$1, get$3(item).title);
						set_class(span_1, `tag is-${get$3(item).color ?? ''} ${get$3(item).customClasses ?? ''} svelte-38rpfk`);
					});

					append($$anchor, div);
				};

				var alternate_2 = ($$anchor) => {
					var span_2 = root_5$5();
					var node_3 = child(span_2);

					{
						var consequent_2 = ($$anchor) => {
							var a_1 = root_6$5();
							var text_3 = child(a_1, true);

							reset(a_1);

							template_effect(() => {
								set_attribute(a_1, 'href', get$3(item).url);
								set_class(a_1, clsx(get$3(item).urlCustomClasses), 'svelte-38rpfk');
								set_text(text_3, get$3(item).title);
							});

							append($$anchor, a_1);
						};

						var alternate_1 = ($$anchor) => {
							var text_4 = text();

							template_effect(() => set_text(text_4, get$3(item).title));
							append($$anchor, text_4);
						};

						if_block(node_3, ($$render) => {
							if (get$3(item).url) $$render(consequent_2); else $$render(alternate_1, false);
						});
					}

					reset(span_2);
					template_effect(() => set_class(span_2, `mx-1 tag is-${get$3(item).color ?? ''} ${get$3(item).customClasses ?? ''} svelte-38rpfk`));
					append($$anchor, span_2);
				};

				if_block(node_1, ($$render) => {
					if (Object.hasOwn(get$3(item), "value")) $$render(consequent_1); else $$render(alternate_2, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$a = template(`<td><!></td>`);

	function NotTableCell($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let title = state("");

		onMount(() => {
			if (typeof field().type === "undefined") {
				if (Object.hasOwn(field(), "titlePath")) {
					set(title, proxy(notPath.get(field().titlePath, item(), helpers())));
				} else if (Object.hasOwn(field(), "titleComposer") && typeof field().titleComposer === "function") {
					set(title, proxy(field().titleComposer(item(), helpers())));
				} else {
					set(title, proxy(notPath.get(field().path, item(), helpers())));
				}
			}
		});

		let getItemId = prop($$props, 'getItemId', 3, (item) => item._id),
			field = prop($$props, 'field', 19, () => ({})),
			item = prop($$props, 'item', 19, () => ({})),
			helpers = prop($$props, 'helpers', 19, () => ({}));

		var td = root$a();
		var node = child(td);

		{
			var consequent = ($$anchor) => {
				const expression = derived(() => notPath.get(field().path, item(), helpers()));

				Ui_links($$anchor, {
					get values() {
						return get$3(expression);
					}
				});
			};

			var alternate_7 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						const expression_1 = derived(() => notPath.get(field().path, item(), helpers()));

						Ui_buttons($$anchor, {
							get values() {
								return get$3(expression_1);
							}
						});
					};

					var alternate_6 = ($$anchor) => {
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								const expression_2 = derived(() => notPath.get(field().path, item(), helpers()));

								Ui_images($$anchor, {
									get values() {
										return get$3(expression_2);
									}
								});
							};

							var alternate_5 = ($$anchor) => {
								var fragment_5 = comment();
								var node_3 = first_child(fragment_5);

								{
									var consequent_3 = ($$anchor) => {
										const expression_3 = derived(() => notPath.get(field().path, item(), helpers()));

										Ui_booleans($$anchor, {
											get values() {
												return get$3(expression_3);
											}
										});
									};

									var alternate_4 = ($$anchor) => {
										var fragment_7 = comment();
										var node_4 = first_child(fragment_7);

										{
											var consequent_4 = ($$anchor) => {
												const expression_4 = derived(() => notPath.get(field().path, item(), helpers()));

												Ui_tags($$anchor, {
													get values() {
														return get$3(expression_4);
													}
												});
											};

											var alternate_3 = ($$anchor) => {
												var fragment_9 = comment();
												var node_5 = first_child(fragment_9);

												{
													var consequent_5 = ($$anchor) => {
														const expression_5 = derived(() => getItemId()(item()));
														const expression_6 = derived(() => notPath.get(field().path, item(), helpers()));

														Ui_switch($$anchor, {
															get id() {
																return get$3(expression_5);
															},
															get fieldname() {
																return field().path;
															},
															get value() {
																return get$3(expression_6);
															},
															get disabled() {
																return field().disabled;
															},
															get readonly() {
																return field().readonly;
															},
															$$events: {
																change(...$$args) {
																	field().onChange?.apply(this, $$args);
																}
															}
														});
													};

													var alternate_2 = ($$anchor) => {
														var fragment_11 = comment();
														var node_6 = first_child(fragment_11);

														{
															var consequent_6 = ($$anchor) => {
																var fragment_12 = comment();
																var node_7 = first_child(fragment_12);
																const expression_7 = derived(() => getItemId()(item()));
																const expression_8 = derived(() => notPath.get(field().path, item(), helpers()));

																component(node_7, () => field().component, ($$anchor, $$component) => {
																	$$component($$anchor, spread_props(
																		{
																			get id() {
																				return get$3(expression_7);
																			},
																			get fieldname() {
																				return field().path;
																			},
																			get disabled() {
																				return field().disabled;
																			},
																			get readonly() {
																				return field().readonly;
																			},
																			get value() {
																				return get$3(expression_8);
																			}
																		},
																		() => field().options,
																		{
																			$$events: {
																				change(...$$args) {
																					field().onChange?.apply(this, $$args);
																				}
																			}
																		}
																	));
																});

																append($$anchor, fragment_12);
															};

															var alternate_1 = ($$anchor) => {
																var fragment_13 = comment();
																var node_8 = first_child(fragment_13);

																{
																	var consequent_7 = ($$anchor) => {
																		var text$1 = text();

																		template_effect(($0) => set_text(text$1, $0), [
																			() => notCommon$1.strLengthCap(notPath.get(field().path, item(), helpers()), field().maxLength)
																		]);

																		append($$anchor, text$1);
																	};

																	var alternate = ($$anchor) => {
																		var text_1 = text();

																		template_effect(($0) => set_text(text_1, $0), [
																			() => $LOCALE()[notPath.get(field().path, item(), helpers())]
																		]);

																		append($$anchor, text_1);
																	};

																	if_block(
																		node_8,
																		($$render) => {
																			if (field() && typeof field() !== "undefined" && !isNaN(field().maxLength) && field().maxLength) $$render(consequent_7); else $$render(alternate, false);
																		},
																		true
																	);
																}

																append($$anchor, fragment_13);
															};

															if_block(
																node_6,
																($$render) => {
																	if (field().component) $$render(consequent_6); else $$render(alternate_1, false);
																},
																true
															);
														}

														append($$anchor, fragment_11);
													};

													if_block(
														node_5,
														($$render) => {
															if (field().type === "switch") $$render(consequent_5); else $$render(alternate_2, false);
														},
														true
													);
												}

												append($$anchor, fragment_9);
											};

											if_block(
												node_4,
												($$render) => {
													if (field().type === "tag") $$render(consequent_4); else $$render(alternate_3, false);
												},
												true
											);
										}

										append($$anchor, fragment_7);
									};

									if_block(
										node_3,
										($$render) => {
											if (field().type === "boolean") $$render(consequent_3); else $$render(alternate_4, false);
										},
										true
									);
								}

								append($$anchor, fragment_5);
							};

							if_block(
								node_2,
								($$render) => {
									if (field().type === "image") $$render(consequent_2); else $$render(alternate_5, false);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (field().type === "button") $$render(consequent_1); else $$render(alternate_6, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (field().type === "link") $$render(consequent); else $$render(alternate_7, false);
			});
		}

		reset(td);

		template_effect(() => {
			set_class(td, (field().hideOnMobile ? " is-hidden-touch " : "") + (field().classes ? ` ${field().classes} ` : ""));
			set_attribute(td, 'title', get$3(title));
		});

		append($$anchor, td);
		pop();
		$$cleanup();
	}

	function onRowSelect(
		e,
		dispatch,
		itemId,
		$selectedList,
		selectedList
	) {
		e.preventDefault();

		dispatch('rowSelectChange', {
			id: get$3(itemId),
			selected: $selectedList()[get$3(itemId)]
		});

		return false;
	}

	var root_1$8 = template(`<td><input type="checkbox" placeholder=""></td>`);
	var root$9 = template(`<tr><!><!></tr>`);

	function NotTableRow($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $selectedList = () => store_get(selectedList, '$selectedList', $$stores);
		let dispatch = createEventDispatcher();

		let itemId = state(undefined),
			selectedList;

		onMount(() => {
			set(itemId, proxy(getItemId()(item())));
			selectedList = get($$props.id).selected;
		});

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} [item]
		 * @property {any} [helpers]
		 * @property {any} [fields]
		 * @property {boolean} [showSelect]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let item = prop($$props, 'item', 19, () => ({})),
			helpers = prop($$props, 'helpers', 19, () => ({})),
			fields = prop($$props, 'fields', 19, () => []),
			showSelect = prop($$props, 'showSelect', 3, false),
			getItemId = prop($$props, 'getItemId', 3, () => {});

		var tr = root$9();
		var node = child(tr);

		{
			var consequent = ($$anchor) => {
				var td = root_1$8();
				var input = child(td);

				remove_input_defaults(input);

				input.__change = [
					onRowSelect,
					dispatch,
					itemId,
					$selectedList,
					selectedList
				];

				reset(td);

				template_effect(
					($0) => {
						set_attribute(input, 'id', `table-row-select-${$0 ?? ''}`);
						set_attribute(input, 'data-id', $0);
						set_attribute(input, 'name', `row_selected_${$0 ?? ''}`);
					},
					[() => getItemId()(item())]
				);

				bind_checked(input, () => $selectedList()[get$3(itemId)], ($$value) => store_mutate(selectedList, untrack($selectedList)[get$3(itemId)] = $$value, untrack($selectedList)));
				append($$anchor, td);
			};

			if_block(node, ($$render) => {
				if (showSelect() && $selectedList()) $$render(consequent);
			});
		}

		var node_1 = sibling(node);

		each(node_1, 17, fields, index$d, ($$anchor, field) => {
			NotTableCell($$anchor, {
				get field() {
					return get$3(field);
				},
				get helpers() {
					return helpers();
				},
				get item() {
					return item();
				},
				get getItemId() {
					return getItemId();
				}
			});
		});

		reset(tr);
		append($$anchor, tr);
		pop();
		$$cleanup();
	}

	delegate(['change']);

	function onSearchInput(ev, dispatch) {
		try {
			let data = ev.currentTarget.value.trim();

			dispatch("searchChange", data);
		} catch {
			return;
		}
	}

	function goPrev(_, dispatch) {
		dispatch("goToPrevPage");
	}

	function goNext(__1, dispatch) {
		dispatch("goToNextPage");
	}

	function goTo(e, dispatch) {
		e.preventDefault();

		let el = e.target;

		dispatch("goToPage", parseInt(el.dataset.page));
		return false;
	}

	function onSelectAll(__2, $$props, items, getItemId, selectAll) {
		get($$props.id).selected.update((value) => {
			items().forEach((item) => {
				value[getItemId()(item)] = selectAll();
			});

			return value;
		});
	}

	var root_1$7 = template(`<div class="field is-grouped"><!></div>`);
	var root_2$4 = template(`<div class="field is-grouped"><!></div>`);
	var root_5$4 = template(`<div class="field"><div class="control"><input class="input" type="text" placeholder="Поиск"></div></div>`);
	var root_6$4 = template(`<th><input type="checkbox" id="table-row-select-page" placeholder="" name="row_selected_all"></th>`);
	var root_7$2 = template(`<th><!></th>`);
	var root_14$1 = template(`<a href="" class="pagination-link is-current" aria-current="page"> </a>`);
	var root_15$1 = template(`<a href="" class="pagination-link"> </a>`);
	var root_13 = template(`<li><!></li>`);
	var root_11$1 = template(`<nav class="pagination is-centered" aria-label="pagination"><a href="" class="pagination-previous">Назад</a> <a href="" class="pagination-next">Вперед</a> <ul class="pagination-list"><!></ul></nav>`);
	var root$8 = template(`<!> <!> <!> <table class="table"><thead><tr><!><!></tr></thead><tbody></tbody></table> <!>`, 1);

	function NotTable($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} filterUI
		 * @property {any} [helpers]
		 * @property {any} [state]
		 * @property {any} [filter]
		 * @property {any} [sorter]
		 * @property {any} [fields]
		 * @property {any} [selected]
		 * @property {any} [items]
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {string} [search]
		 * @property {boolean} [showSearch]
		 * @property {boolean} [showSelect]
		 * @property {boolean} [selectAll]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let helpers = prop($$props, 'helpers', 19, () => ({})),
			state = prop($$props, 'state', 31, () => proxy({})),
			filter = prop($$props, 'filter', 31, () => proxy({})),
			sorter = prop($$props, 'sorter', 31, () => proxy({})),
			fields = prop($$props, 'fields', 19, () => []),
			selected = prop($$props, 'selected', 31, () => proxy({})),
			items = prop($$props, 'items', 31, () => proxy([])),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			search = prop($$props, 'search', 15, ""),
			showSearch = prop($$props, 'showSearch', 3, true),
			showSelect = prop($$props, 'showSelect', 3, true),
			selectAll = prop($$props, 'selectAll', 15, false),
			getItemId = prop($$props, 'getItemId', 3, (item) => item._id);

		onMount(() => {
			if (showSelect()) {
				get($$props.id).selected.subscribe((value) => {
					selected(value);
				});
			}

			get($$props.id).refined.subscribe((value) => {
				items(value);

				if (showSelect()) {
					for (let itemId in selected()) {
						if (!items().some((item) => getItemId()(item) === itemId)) {
							delete selected()[itemId];
						} else {
							if (!Object.hasOwn(selected(), itemId)) {
								selected(selected()[itemId] = false, true);
							}
						}
					}

					selected(selected());
				}
			});

			get($$props.id).state.subscribe((value) => {
				state(value);
			});
		});

		function onSearchChange({ detail }) {
			try {
				dispatch("searchChange", detail);
			} catch {
				return;
			}
		}

		function onFilterChange({ detail }) {
			try {
				dispatch("filterChange", detail);
			} catch {
				return;
			}
		}

		function onFieldHeadClick(field) {
			const propPath = field.path.substring(1);

			if (Object.hasOwn(sorter(), propPath)) {
				sorter(sorter()[propPath] = parseInt(sorter()[propPath]) * -1, true);
			} else {
				sorter({ [propPath]: 1 });
			}

			dispatch("sorterChange", sorter());
		}

		var fragment = root$8();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$7();
				var node_1 = child(div);

				Ui_links(node_1, {
					get values() {
						return links();
					}
				});

				reset(div);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (links().length) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_1 = root_2$4();
				var node_3 = child(div_1);

				Ui_buttons(node_3, {
					get values() {
						return actions();
					}
				});

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_2, ($$render) => {
				if (actions().length) $$render(consequent_1);
			});
		}

		var node_4 = sibling(node_2, 2);

		{
			var consequent_3 = ($$anchor) => {
				var fragment_1 = comment();
				var node_5 = first_child(fragment_1);

				{
					var consequent_2 = ($$anchor) => {
						var fragment_2 = comment();
						const SvelteComponent = derived(() => $$props.filterUI);
						var node_6 = first_child(fragment_2);

						component(node_6, () => get$3(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, {
								get filter() {
									return filter();
								},
								set filter($$value) {
									filter($$value);
								},
								$$events: {
									change: onFilterChange,
									searchChange: onSearchChange
								}
							});
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_5$4();
						var div_3 = child(div_2);
						var input = child(div_3);

						remove_input_defaults(input);
						input.__input = [onSearchInput, dispatch];
						reset(div_3);
						reset(div_2);
						bind_value(input, search);
						append($$anchor, div_2);
					};

					if_block(node_5, ($$render) => {
						if ($$props.filterUI) $$render(consequent_2); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node_4, ($$render) => {
				if (showSearch()) $$render(consequent_3);
			});
		}

		var table = sibling(node_4, 2);
		var thead = child(table);
		var tr = child(thead);
		var node_7 = child(tr);

		{
			var consequent_4 = ($$anchor) => {
				var th = root_6$4();
				var input_1 = child(th);

				remove_input_defaults(input_1);

				input_1.__change = [
					onSelectAll,
					$$props,
					items,
					getItemId,
					selectAll
				];

				reset(th);
				bind_checked(input_1, selectAll);
				append($$anchor, th);
			};

			if_block(node_7, ($$render) => {
				if (showSelect()) $$render(consequent_4);
			});
		}

		var node_8 = sibling(node_7);

		each(node_8, 17, fields, index$d, ($$anchor, field) => {
			var th_1 = root_7$2();
			const propPath = derived(() => get$3(field).path.substring(1));
			var event_handler = derived(() => onFieldHeadClick(get$3(field)));

			th_1.__click = function (...$$args) {
				get$3(event_handler)?.apply(this, $$args);
			};

			var node_9 = child(th_1);

			{
				var consequent_5 = ($$anchor) => {
					const expression = derived(() => sorter()[get$3(propPath)] > 0 ? "sort-up" : "sort-down");

					Ui_icon_font($$anchor, {
						get font() {
							return get$3(expression);
						},
						get title() {
							return get$3(field).title;
						},
						pointable: true
					});
				};

				var alternate_1 = ($$anchor) => {
					var text$1 = text();

					template_effect(() => set_text(text$1, $LOCALE()[get$3(field).title]));
					append($$anchor, text$1);
				};

				if_block(node_9, ($$render) => {
					if (get$3(field).sortable && Object.hasOwn(sorter(), get$3(propPath))) $$render(consequent_5); else $$render(alternate_1, false);
				});
			}

			reset(th_1);
			template_effect(() => set_class(th_1, (get$3(field).hideOnMobile ? " is-hidden-touch" : "") + (get$3(field).sortable ? " is-clickable" : "")));
			append($$anchor, th_1);
		});

		reset(tr);
		reset(thead);

		var tbody = sibling(thead);

		each(tbody, 21, items, (item) => item._id, ($$anchor, item) => {
			NotTableRow($$anchor, {
				get id() {
					return $$props.id;
				},
				get item() {
					return get$3(item);
				},
				get fields() {
					return fields();
				},
				get helpers() {
					return helpers();
				},
				get showSelect() {
					return showSelect();
				},
				get getItemId() {
					return getItemId();
				},
				$$events: {
					rowSelectChange($$arg) {
						bubble_event.call(this, $$props, $$arg);
					}
				}
			});
		});

		reset(tbody);
		reset(table);

		var node_10 = sibling(table, 2);

		{
			var consequent_8 = ($$anchor) => {
				var nav = root_11$1();
				var a = child(nav);

				a.__click = [goPrev, dispatch];

				var a_1 = sibling(a, 2);

				a_1.__click = [goNext, dispatch];

				var ul = sibling(a_1, 2);
				var node_11 = child(ul);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_6 = comment();
						var node_12 = first_child(fragment_6);

						each(node_12, 17, () => state().pagination.pages.list, index$d, ($$anchor, page) => {
							var li = root_13();
							var node_13 = child(li);

							{
								var consequent_6 = ($$anchor) => {
									var a_2 = root_14$1();
									var text_1 = child(a_2, true);

									reset(a_2);

									template_effect(() => {
										set_attribute(a_2, 'aria-label', `Страница ${get$3(page).index ?? ''}`);
										set_text(text_1, get$3(page).index + 1);
									});

									append($$anchor, a_2);
								};

								var alternate_2 = ($$anchor) => {
									var a_3 = root_15$1();

									a_3.__click = [goTo, dispatch];

									var text_2 = child(a_3, true);

									reset(a_3);

									template_effect(() => {
										set_attribute(a_3, 'aria-label', `Страница ${get$3(page).index ?? ''}`);
										set_attribute(a_3, 'data-page', get$3(page).index);
										set_text(text_2, get$3(page).index + 1);
									});

									append($$anchor, a_3);
								};

								if_block(node_13, ($$render) => {
									if (get$3(page).active) $$render(consequent_6); else $$render(alternate_2, false);
								});
							}

							reset(li);
							append($$anchor, li);
						});

						append($$anchor, fragment_6);
					};

					if_block(node_11, ($$render) => {
						if (state().pagination && state().pagination.pages && state().pagination.pages.list) $$render(consequent_7);
					});
				}

				reset(ul);
				reset(nav);
				append($$anchor, nav);
			};

			if_block(node_10, ($$render) => {
				if (state()?.pagination?.pages?.list.length > 1) $$render(consequent_8);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['input', 'change', 'click']);

	const CONST_ID_DUBLICATE_POSTFIX = "__dublicate__";
	const OPT_DEFAULT_PAGE_SIZE = 20,
	  OPT_DEFAULT_PAGE_NUMBER = 0,
	  OPT_DEFAULT_PAGE_RANGE = 6,
	  OPT_DEFAULT_SORT_DIRECTION = 1,
	  OPT_DEFAULT_SEARCH = "",
	  OPT_DEFAULT_RETURN = {},
	  OPT_DEFAULT_COMBINED = false,
	  OPT_DEFAULT_COMBINED_ACTION = "listAndCount",
	  OPT_DEFAULT_COUNT_ACTION = "count",
	  OPT_DEFAULT_LIST_ACTION = "list",
	  OPT_DEFAULT_SORT_FIELD = "_id",
	  OPT_FIELD_NAME_PRE_PROC = "preprocessor";
	const DEFAULT_OPTIONS = {
	  ui: NotTable,
	  links: [],
	  actions: [],
	  endless: false,
	  idField: "_id",
	  getItemId: function (item) {
	    return item._id;
	  }
	};
	let notTable = /*#__PURE__*/function (_EventEmitter) {
	  function notTable(input = {}) {
	    var _this;
	    _classCallCheck(this, notTable);
	    _this = _callSuper(this, notTable);
	    _this.id = "table-" + Math.random();
	    _this.options = {
	      ...DEFAULT_OPTIONS,
	      ...(input.options ? input.options : {})
	    };
	    _this.ui = {};
	    _this.data = {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {}
	    };
	    _this.state = {
	      pagination: {
	        items: {
	          count: 0,
	          from: 0,
	          to: 0
	        },
	        pages: {
	          count: 0,
	          from: 0,
	          to: 0,
	          current: 0,
	          list: []
	        }
	      }
	    };
	    _this.working = {};
	    _this.stores = create(_this.id, {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {},
	      state: _this.state,
	      working: _this.working
	    });
	    _this.stores.working.subscribe(_this.onWorkingUpdate.bind(_this));
	    //полученные из сети
	    _this.stores.raw.subscribe(_this.onRawUpdate.bind(_this));
	    //применены фильтры, сортировки и т.д.
	    _this.stores.filtered.subscribe(_this.onFilteredUpdate.bind(_this));
	    //урезаны до минимального набора, точно соотвествующего табличному формату
	    _this.stores.refined.subscribe(_this.onRefinedUpdate.bind(_this));
	    //словарь с идентификаторами выбранных строк
	    _this.stores.selected.subscribe(_this.onSelectedUpdate.bind(_this));
	    //pagination, items information
	    _this.stores.state.subscribe(_this.onStateUpdate.bind(_this));
	    if (notCommon$1.objHas(input, "data") && Array.isArray(input.data)) {
	      _this.stores.raw.update(function (val) {
	        val = input.data;
	        return val;
	      });
	    }
	    _this.setCombinedActionName(_this.getOptions("interface.combinedAction", OPT_DEFAULT_COMBINED_ACTION));
	    if (notCommon$1.objHas(_this.options, "filter")) {
	      _this.setFilter(_this.options.filter, true);
	    } else {
	      _this.resetFilter();
	    }
	    if (notCommon$1.objHas(_this.options, "pager")) {
	      _this.setPager(_this.options.pager, true);
	    } else {
	      _this.resetPager();
	    }
	    if (notCommon$1.objHas(_this.options, "sorter")) {
	      _this.setSorter(_this.options.sorter, true);
	    } else {
	      _this.resetSorter(true);
	    }
	    if (notCommon$1.objHas(_this.options, "return")) {
	      _this.setReturn(_this.options.return);
	    } else {
	      _this.setReturn();
	    }
	    if (notCommon$1.objHas(_this.options, "search")) {
	      _this.setSearch(_this.options.search, true);
	    } else {
	      _this.setSearch();
	    }
	    _this.render();
	    _this.updateData();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notTable, _EventEmitter);
	  return _createClass(notTable, [{
	    key: "onWorkingUpdate",
	    value: function onWorkingUpdate(val) {
	      this.working = val;
	      return val;
	    }
	  }, {
	    key: "onRawUpdate",
	    value: function onRawUpdate(val) {
	      this.data.raw = val;
	      return val;
	    }
	  }, {
	    key: "onFilteredUpdate",
	    value: function onFilteredUpdate(val) {
	      this.data.filtered = val;
	      this.refineFiltered();
	      return val;
	    }
	  }, {
	    key: "onRefinedUpdate",
	    value: function onRefinedUpdate(val) {
	      this.data.refined = val;
	      this.clearSelected();
	      return val;
	    }
	  }, {
	    key: "onStateUpdate",
	    value: function onStateUpdate(val) {
	      this.state = val;
	      return val;
	    }
	  }, {
	    key: "onSearchChange",
	    value: function onSearchChange(line) {
	      if (line.length > 3) {
	        this.setSearch(line);
	      } else {
	        this.setSearch();
	      }
	    }
	  }, {
	    key: "onSorterChange",
	    value: function onSorterChange(sorter) {
	      if (sorter) {
	        this.setSorter(sorter);
	      } else {
	        this.resetSorter();
	      }
	    }
	  }, {
	    key: "onFilterChange",
	    value: function onFilterChange({
	      filter,
	      actionName
	    }) {
	      if (actionName.indexOf(OPT_DEFAULT_COMBINED_ACTION) === 0) {
	        this.setCombinedActionName(actionName);
	      }
	      if (filter) {
	        this.setFilter(filter);
	      } else {
	        this.resetFilter();
	      }
	    }
	  }, {
	    key: "onSelectedUpdate",
	    value: function onSelectedUpdate(val) {
	      this.data.selected = val;
	    }
	  }, {
	    key: "clearSelected",
	    value: function clearSelected() {
	      this.data.selected = {};
	    }
	  }, {
	    key: "getSelected",
	    value: function getSelected(object = false, store = "refined") {
	      let res = [];
	      for (let id in this.data.selected) {
	        if (this.data.selected[id]) {
	          if (object) {
	            let indx = this.data[store].findIndex(function (item) {
	              return item._id === id;
	            });
	            if (indx > -1) {
	              res.push(this.data[store][indx]);
	            }
	          } else {
	            res.push(id);
	          }
	        }
	      }
	      return res;
	    }
	  }, {
	    key: "getItemId",
	    value: function getItemId(item) {
	      return this.getOptions("getItemId", DEFAULT_OPTIONS.getItemId)(item);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll() {
	      var _this2 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this2.data.filtered.forEach(function (item) {
	          value[_this2.getItemId(item)] = true;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone() {
	      var _this3 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this3.data.filtered.forEach(function (item) {
	          value[_this3.getItemId(item)] = false;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;
	      if (!this.ui.table) {
	        this.ui.table = new this.options.ui({
	          target: this.options.targetEl,
	          props: {
	            filterUI: this.getOptions("filterUI", undefined),
	            id: this.id,
	            helpers: Object.assign({}, this.getHelpers()),
	            fields: this.getOptions("fields"),
	            actions: this.getActions(),
	            links: this.getLinks(),
	            search: "",
	            showSelect: this.getOptions("showSelect"),
	            showSearch: this.getOptions("showSearch"),
	            showSort: this.getOptions("showSort"),
	            idField: this.getOptions("idField"),
	            getItemId: this.getOptions("getItemId"),
	            filter: this.getFilter()
	          }
	        });
	      }
	      this.ui.table.$on("searchChange", function (e) {
	        return _this4.onSearchChange(e.detail);
	      });
	      this.ui.table.$on("sorterChange", function (e) {
	        return _this4.onSorterChange(e.detail);
	      });
	      this.ui.table.$on("filterChange", function (e) {
	        return _this4.onFilterChange(e.detail);
	      });
	      this.ui.table.$on("goToPage", function (e) {
	        return _this4.goToPage(e.detail);
	      });
	      this.ui.table.$on("goToNextPage", function () {
	        return _this4.goToNext();
	      });
	      this.ui.table.$on("goToPrevPage", function () {
	        return _this4.goToPrev();
	      });
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.getOptions("actions", []);
	    }
	  }, {
	    key: "getLinks",
	    value: function getLinks() {
	      return this.getOptions("links", []);
	    }
	  }, {
	    key: "getHelpers",
	    value: function getHelpers() {
	      return this.options.helpers || {};
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking(key, value) {
	      var _this5 = this;
	      this.stores.working.update(function (val) {
	        notPath.set(key, val, _this5.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking(key, def) {
	      let res = notPath.get(key, this.working, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setState",
	    value: function setState(key, value) {
	      var _this6 = this;
	      this.stores.state.update(function (val) {
	        notPath.set(key, val, _this6.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getState",
	    value: function getState(key, def) {
	      let res = notPath.get(key, this.state, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(key, value) {
	      notPath.set(key, this.options, this.getHelpers(), value);
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions(key, def) {
	      let res = notPath.get(key, this.options, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(hash, withoutInvalidation = false) {
	      this.setState("filter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      this.setState("filter", {});
	      return this;
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getState("filter");
	    }
	  }, {
	    key: "setPager",
	    value: function setPager(hash, withoutInvalidation = false) {
	      this.setState("pager", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getDefaultPageNumber",
	    value: function getDefaultPageNumber() {
	      return isNaN(this.getOptions("pager.page")) ? OPT_DEFAULT_PAGE_NUMBER : this.getOptions("pager.page");
	    }
	  }, {
	    key: "getDefaultPageSize",
	    value: function getDefaultPageSize() {
	      return isNaN(this.getOptions("pager.size")) ? OPT_DEFAULT_PAGE_SIZE : this.getOptions("pager.size");
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      this.setState("pager", {
	        size: this.getDefaultPageSize(),
	        page: this.getDefaultPageNumber()
	      });
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getState("pager");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(hash, withoutInvalidation = false) {
	      this.setWorking("sorter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter(withoutInvalidation = false) {
	      let t = {};
	      t[OPT_DEFAULT_SORT_FIELD] = OPT_DEFAULT_SORT_DIRECTION;
	      return this.setSorter(t, withoutInvalidation);
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "getSorterDirection",
	    value: function getSorterDirection() {
	      try {
	        let names = Object.keys(this.getSorter());
	        return this.getSorter()[names[0]];
	      } catch {
	        return OPT_DEFAULT_SORT_DIRECTION;
	      }
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      let search = typeof this.getWorking("search") !== "undefined" && this.getWorking("search") !== null;
	      return search ? this.getWorking("search") : "";
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(line = OPT_DEFAULT_SEARCH, withoutInvalidation = false) {
	      this.setWorking("search", line);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(ret = OPT_DEFAULT_RETURN) {
	      this.setWorking("return", ret);
	      return this;
	    }
	  }, {
	    key: "clearFilteredData",
	    value: function clearFilteredData() {
	      this.stores.filtered.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRawData",
	    value: function clearRawData() {
	      this.stores.raw.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRefinedData",
	    value: function clearRefinedData() {
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "invalidateData",
	    value: function invalidateData() {
	      //clearing filtered and sorted
	      this.clearFilteredData();
	      //in case live loading from server
	      if (this.isLive()) {
	        //clearing loaded data
	        this.clearRawData();
	      }
	      //resset pager anyway
	      this.resetPager();
	    }
	  }, {
	    key: "isLive",
	    value: function isLive() {
	      return this.getOptions("interface") && this.getOptions("interface.factory");
	    }
	  }, {
	    key: "setUpdating",
	    value: function setUpdating() {
	      this.setState("updating", true);
	    }
	  }, {
	    key: "setUpdated",
	    value: function setUpdated() {
	      this.setState("updating", false);
	    }
	  }, {
	    key: "ifUpdating",
	    value: function ifUpdating() {
	      return this.getState("updating");
	    }
	  }, {
	    key: "getDataInterface",
	    value: function getDataInterface() {
	      let factory = this.getOptions("interface.factory");
	      if (typeof factory === "function") {
	        return factory({});
	      } else {
	        return factory;
	      }
	    }
	  }, {
	    key: "getLoadDataActionName",
	    value: function getLoadDataActionName() {
	      return this.getOptions("interface.listAction") ? this.getOptions("interface.listAction") : OPT_DEFAULT_LIST_ACTION;
	    }
	  }, {
	    key: "setCombinedActionName",
	    value: function setCombinedActionName(actionName = OPT_DEFAULT_COUNT_ACTION) {
	      this.setWorking("interface.combinedAction", actionName);
	    }
	  }, {
	    key: "getCombinedActionName",
	    value: function getCombinedActionName() {
	      return this.getWorking("interface.combinedAction") ? this.getWorking("interface.combinedAction") : OPT_DEFAULT_COMBINED_ACTION;
	    }
	  }, {
	    key: "getCountActionName",
	    value: function getCountActionName() {
	      return this.getOptions("interface.countAction") ? this.getOptions("interface.countAction") : OPT_DEFAULT_COUNT_ACTION;
	    }
	  }, {
	    key: "loadData",
	    value: function loadData() {
	      //load from server
	      let query = this.getDataInterface().setFilter(this.getFilter()).setSorter(this.getSorter()).setReturn(this.getReturn()).setSearch(this.getSearch()).setPager(this.getPager()),
	        actionName;
	      if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	        actionName = this.getCombinedActionName();
	      } else {
	        actionName = this.getLoadDataActionName();
	      }
	      return query["$" + actionName]();
	    }
	  }, {
	    key: "goToNext",
	    value: function goToNext() {
	      let next = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") + 1;
	      this.setState("pager.page", Math.min(next, this.getState("pagination.pages.to")));
	      this.updateData();
	    }
	  }, {
	    key: "goToPrev",
	    value: function goToPrev() {
	      let prev = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") - 1;
	      this.setState("pager.page", Math.max(prev, this.getState("pagination.pages.from")));
	      this.updateData();
	    }
	  }, {
	    key: "goToFirst",
	    value: function goToFirst() {
	      this.setState("pager.page", this.getState("pagination.pages.from"));
	      this.updateData();
	    }
	  }, {
	    key: "goToLast",
	    value: function goToLast() {
	      this.setState("pager.page", this.getState("pagination.pages.to"));
	      this.updateData();
	    }
	  }, {
	    key: "goToPage",
	    value: function goToPage(pageNumber) {
	      this.setState("pager.page", pageNumber);
	      this.updateData();
	    }
	  }, {
	    key: "testDataItem",
	    value: function testDataItem(item) {
	      var strValue = this.getSearch().toLowerCase();
	      for (var k in item) {
	        var toComp = item[k].toString().toLowerCase();
	        if (toComp.indexOf(strValue) > -1) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "getRowsCount",
	    value: function getRowsCount() {
	      var _this7 = this;
	      let query = this.getDataInterface().setFilter(this.getFilter());
	      return query["$" + this.getCountActionName()]().then(function (data) {
	        _this7.updatePagination(data.count);
	      }).catch(function (e) {
	        _this7.error(e);
	      });
	    }
	  }, {
	    key: "updatePagination",
	    value: function updatePagination(itemsCount) {
	      var _this8 = this;
	      this.log("update pagination", itemsCount);
	      this.state.pagination.pages.list.splice(0, this.state.pagination.pages.list.length);
	      let itemsFrom = (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER) * this.getPager().size + 1,
	        pagesCount = itemsCount % this.getPager().size ? Math.floor(itemsCount / this.getPager().size) + 1 : Math.round(itemsCount / this.getPager().size),
	        pagesFrom = Math.max(OPT_DEFAULT_PAGE_NUMBER, this.getPager().page - OPT_DEFAULT_PAGE_RANGE),
	        pagesTo = Math.min(pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER), this.getPager().page + OPT_DEFAULT_PAGE_RANGE),
	        list = [],
	        itemsTo = Math.min(itemsFrom + this.getPager().size - 1, itemsCount);
	      for (let t = pagesFrom; t <= pagesTo; t++) {
	        list.push({
	          index: t,
	          active: t === this.getPager().page
	        });
	      }
	      this.stores.state.update(function (val) {
	        _this8.log("update pagination", val);
	        val.pagination.items.count = itemsCount;
	        val.pagination.items.from = itemsFrom;
	        val.pagination.items.to = itemsTo;
	        val.pagination.pages.count = pagesCount;
	        val.pagination.pages.from = pagesFrom;
	        val.pagination.pages.to = pagesTo;
	        val.pagination.pages.current = _this8.getPager().page;
	        val.pagination.pages.list.splice(0, val.pagination.pages.list.length, ...list);
	        return val;
	      });
	    }
	  }, {
	    key: "updateData",
	    value: function updateData() {
	      var _this9 = this;
	      if (this.isLive()) {
	        if (this.ifUpdating()) {
	          return;
	        }
	        if (!this.getOptions("endless", false)) {
	          this.clearRawData();
	        }
	        this.setUpdating();
	        if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	          this.loadData().then(function (data) {
	            let full = notCommon$1.objHas(data, "status") && notCommon$1.objHas(data, "result");
	            _this9.stores.filtered.update(function (val) {
	              if (!_this9.getOptions("endless", false)) {
	                _this9.clearFilteredData();
	              }
	              if (full) {
	                val.push(...data.result.list);
	              } else {
	                if (notCommon$1.objHas(data, "list") && Array.isArray(data.list)) {
	                  val.push(...data.list);
	                } else if (Array.isArray(data)) {
	                  val.push(...data);
	                }
	              }
	              return val;
	            });
	            _this9.setWorking("lastCount", full ? data.result.count : data.count);
	          }).then(function () {
	            _this9.updatePagination(_this9.getWorking("lastCount"));
	          }).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        } else {
	          this.loadData().then(function (data) {
	            _this9.stores.filtered.update(function (val) {
	              val.push(...data);
	              return val;
	            });
	          }).then(this.getRowsCount.bind(this)).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        }
	      } else {
	        //local magic
	        this.setUpdating();
	        this.processData();
	        this.setUpdated();
	      }
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.data;
	    }
	  }, {
	    key: "processData",
	    value: function processData() {
	      var _this10 = this;
	      let thatFilter = this.getFilter();
	      //this.getData('rows').__setPassive;
	      this.log(this.getData());
	      if (typeof thatFilter !== "undefined" && thatFilter !== null && typeof thatFilter.filterSearch !== "undefined" && thatFilter.filterSearch !== null && thatFilter.filterSearch.length > 0) {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this10.data.raw.filter(_this10.testDataItem.bind(_this10)));
	          return val;
	        });
	      } else {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this10.data.raw);
	          return val;
	        });
	      }
	      ////sorter
	      let thatSorter = this.getSorter();
	      if (typeof thatSorter !== "undefined" && thatSorter !== null) {
	        this.stores.filtered.update(function (val) {
	          val.sort(function (item1, item2) {
	            let t1 = notPath.get(thatSorter.sortByField, item1, {}),
	              t2 = notPath.get(thatSorter.sortByField, item2, {});
	            if (isNaN(t1)) {
	              if (typeof t1 !== "undefined" && typeof t2 !== "undefined" && t1.localeCompare) {
	                return t1.localeCompare() * -thatSorter.sortDirection;
	              } else {
	                return 0;
	              }
	            } else {
	              return (t1 < t2 ? 1 : -1) * thatSorter.sortDirection;
	            }
	          });
	          return val;
	        });
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      if (this.options.logger) {
	        this.options.logger.error(...arguments);
	      }
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      if (this.options.logger) {
	        this.options.logger.log(...arguments);
	      }
	    }
	  }, {
	    key: "checkFieldsNames",
	    value: function checkFieldsNames() {
	      const fieldId = this.getOptions("idField");
	      const pathId = ":" + fieldId;
	      let fields = this.getOptions("fields", []);
	      fields.forEach(function (field) {
	        if (pathId === field.path) {
	          field.path = field.path + CONST_ID_DUBLICATE_POSTFIX;
	        }
	      });
	    }
	  }, {
	    key: "readFieldValue",
	    value: function readFieldValue(path, item, helpers) {
	      if (path.indexOf(CONST_ID_DUBLICATE_POSTFIX) > -1) {
	        const fieldId = this.getOptions("idField");
	        const pathId = ":" + fieldId;
	        return notPath.get(pathId, item, helpers);
	      } else {
	        return notPath.get(path, item, helpers);
	      }
	    }
	  }, {
	    key: "refineFiltered",
	    value: function refineFiltered() {
	      var _this11 = this;
	      let result = [];
	      this.checkFieldsNames();
	      this.data.filtered.forEach(function (item, index) {
	        let refined = {};
	        if (_this11.getOptions("idField")) {
	          refined[_this11.getOptions("idField")] = item[_this11.getOptions("idField")];
	        }
	        _this11.getOptions("fields", []).forEach(function (field) {
	          let preprocessed = null,
	            val = _this11.readFieldValue(field.path, item, _this11.getOptions("helpers"));
	          if (notCommon$1.objHas(field, OPT_FIELD_NAME_PRE_PROC)) {
	            try {
	              preprocessed = field[OPT_FIELD_NAME_PRE_PROC](val, item, index);
	            } catch (e) {
	              _this11.error("Error while preprocessing cell value", val, item, index);
	              _this11.error(e);
	            }
	            notPath.set(field.path, refined, preprocessed);
	          } else {
	            notPath.set(field.path, refined, val);
	          }
	        });
	        result.push(refined);
	      });
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length, ...result);
	        return val;
	      });
	    }
	  }, {
	    key: "$destroy",
	    value: function $destroy() {
	      for (let name in this.ui) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        delete this.ui[name];
	      }
	    }
	  }]);
	}(EventEmitter);

	var root_1$6 = template(`<!> <!>`, 1);
	var root$7 = template(`<!> <!>`, 1);

	function Ui_action_container($$anchor, $$props) {
		push($$props, true);

		//hidden - no loader
		//container - parent container of form
		let success = state(false);
		let error = state(false);

		/**
		 * @typedef {Object} Props
		 * @property {any} [container]
		 * @property {string} [loaderTitle]
		 * @property {boolean} [loaderActive] - state if form loading
		 * @property {string} [loaderSize] - page - whole page
		 * @property {string} [successTitle]
		 * @property {string} [successMessage]
		 * @property {string} [errorTitle]
		 * @property {string} [errorMessage]
		 */
		/** @type {Props} */
		let container = prop($$props, 'container', 19, () => ({})),
			loaderTitle = prop($$props, 'loaderTitle', 15, "Отправка данных на сервер"),
			loaderActive = prop($$props, 'loaderActive', 15, false),
			loaderSize = prop($$props, 'loaderSize', 15, "container"),
			successTitle = prop($$props, 'successTitle', 15, "OK"),
			successMessage = prop($$props, 'successMessage', 15, ""),
			errorTitle = prop($$props, 'errorTitle', 15, "Error"),
			errorMessage = prop($$props, 'errorMessage', 15, "");

		function showSuccess(title, message) {
			set(error, false);
			set(success, true);

			if (message != undefined) {
				successMessage(message);
			}

			if (title != undefined) {
				successTitle(title);
			}
		}

		function showError(title, message) {
			set(success, false);
			set(error, true);

			if (message != undefined) {
				errorMessage(message);
			}

			if (title != undefined) {
				errorTitle(title);
			}
		}

		function setLoading() {
			loaderActive(true);
			set(success, false);
			set(error, false);
		}

		function resetLoading() {
			loaderActive(false);
		}

		function hideAll() {
			loaderActive(false);
			set(success, false);
			set(error, false);
		}

		var fragment = root$7();
		var node = first_child(fragment);

		Ui_loader(node, {
			get loading() {
				return loaderActive();
			},
			set loading($$value) {
				loaderActive($$value);
			},
			get title() {
				return loaderTitle();
			},
			set title($$value) {
				loaderTitle($$value);
			},
			get size() {
				return loaderSize();
			},
			set size($$value) {
				loaderSize($$value);
			}
		});

		var node_1 = sibling(node, 2);

		Ui_container(node_1, spread_props(container, {
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$6();
				var node_2 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_error($$anchor, {
							get title() {
								return errorTitle();
							},
							set title($$value) {
								errorTitle($$value);
							},
							get message() {
								return errorMessage();
							},
							set message($$value) {
								errorMessage($$value);
							}
						});
					};

					if_block(node_2, ($$render) => {
						if (get$3(error)) $$render(consequent);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_success($$anchor, {
							get title() {
								return successTitle();
							},
							set title($$value) {
								successTitle($$value);
							},
							get message() {
								return successMessage();
							},
							set message($$value) {
								successMessage($$value);
							}
						});
					};

					if_block(node_3, ($$render) => {
						if (get$3(success)) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		}));

		append($$anchor, fragment);

		return pop({
			showSuccess,
			showError,
			setLoading,
			resetLoading,
			hideAll
		});
	}

	const DEFAULT_CONTAINER_SELECTOR$2 = ".container";
	var _uiComponent$1 = /*#__PURE__*/new WeakMap();
	var _ui = /*#__PURE__*/new WeakMap();
	let notActionUI = /*#__PURE__*/function (_notBase) {
	  function notActionUI({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data = {},
	    ui = Ui_action_container //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notActionUI);
	    _this = _callSuper(this, notActionUI, [{
	      working: {
	        name: `${name}ActionUI`,
	        ...working
	      },
	      options,
	      data
	    }]);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent$1, null);
	    _classPrivateFieldInitSpec(_this, _ui, null);
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent$1, _this, ui);
	    _this.initUI();
	    return _this;
	  }
	  _inherits(notActionUI, _notBase);
	  return _createClass(notActionUI, [{
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const target = this.getTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_ui, this, new (_classPrivateFieldGet2(_uiComponent$1, this))({
	          target,
	          props: this.getOptions()
	        }));
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_ui, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_ui, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_ui, this)) {
	        _classPrivateFieldGet2(_ui, this).$destroy && _classPrivateFieldGet2(_ui, this).$destroy();
	        _classPrivateFieldGet2(_ui, this).destroy && _classPrivateFieldGet2(_ui, this).destroy();
	        _classPrivateFieldSet2(_ui, this, null);
	      }
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_ui, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_ui, this).showError(status);
	      this.emit("error", status);
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getTargetEl",
	    value: function getTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$2);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("ActionUI parent element is not defined");
	      }
	    }
	  }]);
	}(notBase);

	let notFormUtils$1 = /*#__PURE__*/function () {
	  function notFormUtils() {
	    _classCallCheck(this, notFormUtils);
	  }
	  return _createClass(notFormUtils, null, [{
	    key: "addComponent",
	    value: function addComponent(name, value) {
	      COMPONENTS$1.add(name, value);
	    }
	  }, {
	    key: "addVariants",
	    value: function addVariants(name, value) {
	      VARIANTS$1.add(name, value);
	    }
	  }, {
	    key: "addField",
	    value: function addField(name, field) {
	      FIELDS$1.add(name, field);
	    }
	  }, {
	    key: "actionFieldsInit",
	    value: function actionFieldsInit(fieldName, options, data) {
	      var _this = this;
	      if (Array.isArray(fieldName)) {
	        fieldName.forEach(function (subFieldName) {
	          _this.actionFieldsInit(subFieldName, options, data);
	        });
	      } else {
	        if (!notCommon$1.objHas(options, "fields")) {
	          options.fields = {};
	        }
	        if (!notCommon$1.objHas(options.fields, fieldName)) {
	          options.fields[fieldName] = {};
	        }
	        //copying initial data
	        if (typeof data !== "undefined" && data !== null && typeof data[fieldName] !== "undefined" && data[fieldName] !== null) {
	          options.fields[fieldName].value = data[fieldName];
	        }
	      }
	    }
	  }]);
	}();
	_defineProperty(notFormUtils$1, "validator", null);

	const DEFAULT_FIELD = {
	  label: "",
	  placeholder: "",
	  enabled: true,
	  visible: true,
	  required: true,
	  validated: false,
	  valid: false,
	  errors: false
	};

	/**
	 * Creates field manifest
	 * @param {string} type      name/type of the field
	 * @param {Object} mutation  mutation to manifest from library
	 * @param {Object} VARIANTS  store which contains named lists of field value variants
	 * @param {Object} FIELDS    store which contains named lists of field manifests
	 * @return {Object}          field manifest
	 **/
	function fieldInit(type, mutation = {}, VARIANTS, FIELDS) {
	  let field = {
	    ...DEFAULT_FIELD
	  };
	  //getting field core manifest
	  if (FIELDS.contains(type)) {
	    field = {
	      ...field,
	      ...FIELDS.get(type)
	    };
	  }
	  //adding mutations
	  if (mutation) {
	    field = {
	      ...field,
	      ...mutation
	    };
	  }
	  //adding variants list to field from VARIANTS store
	  if (notCommon$1.objHas(field, "variantsSource") && VARIANTS.contains(field.variantsSource)) {
	    field.variants = VARIANTS.get(field.variantsSource);
	  } else {
	    if (!field.variants || field.variants.length === 0) {
	      field.variants = [];
	    }
	  }
	  return field;
	}

	/**
	 * Initialization of form structure object
	 * @param {object}               form          form structure object
	 * @param {string|Array<string>} fieldName     name of the field type if string, array of strings = subform
	 * @param {Object}               VARIANTS      store which contains named lists of field value variants
	 * @param {Object}               FIELDS        store which contains named lists of field manifests
	 * @param {Object}               formFieldsOptions   form wide options
	 * @returns {Object}                           form structure object
	 **/
	function initFormByField(form = {}, fieldName = [], VARIANTS, FIELDS, formFieldsOptions, data) {
	  if (Array.isArray(fieldName)) {
	    fieldName.forEach(function (subFormFieldName) {
	      return initFormByField(form, subFormFieldName, VARIANTS, FIELDS, formFieldsOptions, data);
	    });
	  } else {
	    let opts = {};
	    if (formFieldsOptions && notCommon$1.objHas(formFieldsOptions, "mutations") && notCommon$1.objHas(formFieldsOptions.mutations, fieldName)) {
	      opts = formFieldsOptions.mutations[fieldName]; //option mutation for field
	    }
	    if (data && notCommon$1.objHas(data, fieldName)) {
	      opts.value = data[fieldName];
	    }
	    form[fieldName] = fieldInit(fieldName, opts, VARIANTS, FIELDS);
	    //if form readonly, marking every field as readonly
	    if (formFieldsOptions && formFieldsOptions.readonly) {
	      form[fieldName].readonly = true;
	    }
	  }
	  return form;
	}

	/**
	 *  Marking field as invalid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFieldInvalid(form, fieldName, value, errors) {
	  form[fieldName].errors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].valid = false;
	  form[fieldName].value = value;
	  return form;
	}

	/**
	 *  Marking field as valid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @return {Object}                        form structure object
	 **/
	function setFieldValid(form, fieldName, value) {
	  form[fieldName].errors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].value = value;
	  for (let fname in form) {
	    if (fname !== fieldName) {
	      if (Array.isArray(form[fname].errors) && form[fname].errors.length === 0) {
	        form[fname].errors = false;
	      }
	      if (form[fname].errors !== false) {
	        break;
	      }
	    }
	  }
	  return form;
	}

	/**
	 * Checks if field has errors
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @returns {boolean}                      true - valid, false -invalid
	 **/
	function isFieldValid(form, fieldName) {
	  return !Array.isArray(form[fieldName].errors);
	}

	/**
	 * Form level validator error in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldInvalid(form, fieldName, errors) {
	  form[fieldName].formErrors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].inputStarted = true;
	  form[fieldName].valid = false;
	  form[fieldName].formLevelError = true;
	  return form;
	}
	/**
	 * Form level validator success in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldValid(form, fieldName) {
	  form[fieldName].formErrors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].formLevelError = false;
	  return form;
	}

	/**
	 * Updates fields and form error labels
	 * @param {Object}           form                  form structure object
	 * @param {Object}           validationStatus      results of validation
	 **/
	function updateFormValidationStatus({
	  form,
	  formErrors,
	  validationStatus
	} /* FormValidationSession.getCompleteResult() */) {
	  if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
	    formErrors.splice(0, formErrors.length, ...validationStatus.form);
	  } else {
	    formErrors.splice(0, formErrors.length);
	  }
	  if (validationStatus.fields) {
	    for (let fieldName in validationStatus.fields) {
	      if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
	        setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
	      } else {
	        setFormFieldValid(form, fieldName);
	      }
	    }
	  }
	}
	function setFieldsVisibility(form, fieldsList, val) {
	  if (Array.isArray(fieldsList)) {
	    Object.keys(form).forEach(function (fieldName) {
	      form[fieldName].visible = fieldsList.includes(fieldName) ? val : !val;
	    });
	    return true;
	  }
	  return false;
	}
	function setFieldValue(form, fieldName, value) {
	  if (notCommon$1.objHas(form, fieldName)) {
	    form[fieldName].value = value;
	    return true;
	  }
	  return false;
	}
	function fieldIsVisibleAndFilled(form, fieldName) {
	  return notCommon$1.objHas(form, fieldName) && form[fieldName].enabled && form[fieldName].visible && typeof form[fieldName].value !== "undefined";
	}
	function collectData(fields, form) {
	  let result = {};
	  fields.flat().forEach(function (fieldName) {
	    if (fieldIsVisibleAndFilled(form, fieldName)) {
	      result[fieldName] = form[fieldName].value;
	    }
	  });
	  return result;
	}
	var FormHelpers = {
	  fieldInit,
	  initFormByField,
	  setFieldInvalid,
	  setFieldValid,
	  isFieldValid,
	  setFormFieldInvalid,
	  setFormFieldValid,
	  updateFormValidationStatus,
	  fieldIsVisibleAndFilled,
	  setFieldsVisibility,
	  setFieldValue,
	  collectData
	};

	var result;
	var hasRequiredResult;

	function requireResult () {
		if (hasRequiredResult) return result;
		hasRequiredResult = 1;
		const emptyFieldsResults = (data) => {
		    return Object.keys(data).reduce((acc, curr) => {
		        acc[curr] = [];
		        return acc;
		    }, {});
		};

		const FIELDS = ["fields", "form"];

		result = class ValidationResult {
		    #clean = true;
		    #result;

		    constructor(result) {
		        this.#result = JSON.parse(JSON.stringify(result));
		        Object.keys(this.#result).forEach((fieldName) => {
		            if (!FIELDS.includes(fieldName)) {
		                delete this.#result[fieldName];
		            }
		        });
		        this.#clean = this.#result.form.errors.length === 0;
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            if (this.isFieldDirty(fieldName)) {
		                this.#clean = false;
		            }
		        }
		    }

		    destroy() {
		        this.#result = undefined;
		    }

		    get clean() {
		        return this.#clean;
		    }

		    static getDefaultResult(data) {
		        return {
		            fields: emptyFieldsResults(data),
		            form: {
		                fields: emptyFieldsResults(data),
		                errors: [],
		                exceptions: [],
		            },
		        };
		    }

		    getReport() {
		        return JSON.parse(JSON.stringify(this.#getCompleteResult()));
		    }

		    getDetailedReport() {
		        if (typeof this.#result === "object") {
		            return JSON.parse(JSON.stringify(this.#result));
		        } else {
		            return undefined;
		        }
		    }

		    isFieldDirty(fieldName) {
		        if (
		            Array.isArray(this.#result.fields[fieldName]) &&
		            this.#result.fields[fieldName].length
		        ) {
		            return true;
		        }
		        if (
		            Array.isArray(this.#result.form.fields[fieldName]) &&
		            this.#result.form.fields[fieldName].length
		        ) {
		            return true;
		        }
		        return false;
		    }

		    getCompleteResultForField(fieldName) {
		        const fieldResult = [];
		        if (Array.isArray(this.#result.fields[fieldName])) {
		            fieldResult.push(...this.#result.fields[fieldName]);
		        }
		        if (Array.isArray(this.#result.form.fields[fieldName])) {
		            fieldResult.push(...this.#result.form.fields[fieldName]);
		        }
		        return fieldResult;
		    }

		    #getCompleteResult() {
		        const resultComplete = {
		            clean: this.#clean,
		            fields: {},
		            form: [],
		        };
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            const errors = this.getCompleteResultForField(fieldName);
		            if (errors.length) {
		                resultComplete.fields[fieldName] = errors;
		            }
		        }
		        resultComplete.form = [...this.#result.form.errors];
		        if (resultComplete.form.length === 0) {
		            delete resultComplete.form;
		        }
		        return resultComplete;
		    }

		    #getFieldsList() {
		        const fields = Object.keys(this.#result.fields);
		        const fieldsInForm = Object.keys(this.#result.form.fields);
		        return [...new Set([...fieldsInForm, ...fields])];
		    }
		};
		return result;
	}

	/**
	*	Template of error.js
	*	For building for specific environment.
	*	Node.js or Browser
	*	@param {string}	env	node|browser in wich env it will be running
	*	@param {string}	url	URL of report collector
	*	@param {string}	key	key to indetificate reporter
	*/

	var error_node;
	var hasRequiredError_node;

	function requireError_node () {
		if (hasRequiredError_node) return error_node;
		hasRequiredError_node = 1;
		/**
		* Error reporting with features, saving browser info, uri and so on.
		* @module not-error/error
		*/
		class notError extends Error {
			constructor(message, options = {}, error = null){
				super(message);
				this.options = options;
				this.adopt(error);
				this.fill();
				this.getTime();
				return this;
			}

			/**
			*	Adopting native error object
			*	@param {Error}	error 	Error object
			*	@return {notError}		chainable
			*/
			adopt(error){
				if(error instanceof Error){
					this.parent = error;
				}
				return this;
			}

			getStack(){
				if(this.parent){
					return this.parent.stack;
				}else {
					return this.stack;
				}
			}

			getDetails(){
				let src = this;
				if(this.parent){
					src = this.parent;
				}
				return {
					columnNumber:    	src.columnNumber,
					fileName:        	src.fileName,
					lineNumber:      	src.lineNumber,
					name:            	src.name,
					message:        	src.message,
					stack:          	src.stack
				};
			}

			/**
			*	Updating this.env.date property
			*	@return  {object}	{timestamp, offset}
			*/
			getTime(){
				let date = new Date();
				this.env.date = {
					timestamp : date.getTime(),
					offset: date.getTimezoneOffset()
				};
				return this.env.date;
			}


			/**
			******************************************************************************************************
			******************************************************************************************************
			***	Node.js Section
			******************************************************************************************************
			******************************************************************************************************
			**/

			/**
			*	Filtering out key by `white` list
			*	@param {object} object hash to be copied according filter `white` list
			*	@param {array} filter array of sting, which represents keys we want to be
			*						copied in resulting object from source
			*	@return {object}		white listed hash
			*/
			filterEnv(object, filter){
				let result = {};
				for(let t of filter){
					if(Object.prototype.hasOwnProperty.call(object, t)){
						result[t] = object[t];
					}
				}
				return result;
			}

			/**
			*	Collecting information specific for Node.js V8
			*	@return {notError}		chainable
			*/
			fill(){
				/**
				*	You want some fields from env but not all, cause there are passwords
				*	from db, api keys and etc
				*/
				this.env = {
					browser: 	false,
					node: 		true,
					versions: Object.assign({}, process.versions),
					vars: 		this.filterEnv(process.env, this.options.whitelist || ['NODE_ENV'])
				};
				return this;
			}


		}


		error_node = notError;
		return error_node;
	}

	var validation_error_node;
	var hasRequiredValidation_error_node;

	function requireValidation_error_node () {
		if (hasRequiredValidation_error_node) return validation_error_node;
		hasRequiredValidation_error_node = 1;
		const notError = requireError_node();


		//reportable
		class notValidationError extends notError{
		  constructor(message, fields = {}, err = null, params = {}){
		    super(message, {fields, params}, err);
		    return this;
		  }

		  /**
		  * Sets hash of fields errors messages for usage in forms
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  setFieldsErrors(messages){
		    this.options.fields = messages;
		  }

		  /**
		  * Returns hash of errors
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  getFieldsErrors(){
		    return this.options.fields;
		  }

		}


		validation_error_node = notValidationError;
		return validation_error_node;
	}

	/**
	 * Test argument type to be 'function'
	 * @param {any}  func    possible function
	 * @return {boolean}     if this is a function
	 **/

	var common;
	var hasRequiredCommon;

	function requireCommon () {
		if (hasRequiredCommon) return common;
		hasRequiredCommon = 1;
		const isFunc = (func) => {
		    return typeof func === "function";
		};

		/**
		 * Returns true if argument is Async function
		 * @param {function} func  to test
		 * @return {boolean}       if this function is constructed as AsyncFunction
		 **/
		const isAsync = (func) => {
		    return func.constructor.name === "AsyncFunction";
		};

		common = async (proc, params) => {
		    if (isFunc(proc)) {
		        if (isAsync(proc)) {
		            return await proc(...params);
		        } else {
		            return proc(...params);
		        }
		    }
		};
		return common;
	}

	var session;
	var hasRequiredSession;

	function requireSession () {
		if (hasRequiredSession) return session;
		hasRequiredSession = 1;
		const ValidationResult = requireResult();
		const notVaildationError = requireValidation_error_node();
		const executeObjectFunction = requireCommon();

		const ValidationSession = async (validators, data) => {
		    const result = ValidationResult.getDefaultResult(data);
		    await validateFields({ validators, data, result });
		    await validateForm({ validators, data, result });
		    return new ValidationResult(result);
		};

		session = ValidationSession;

		const validateFields = async ({ validators, data, result }) => {
		    for (let t in data) {
		        await validateField(t, data[t], validators, result);
		    }
		};

		const validateField = async (fieldName, value, validators, result) => {
		    const fieldValidators = getFieldValidators(fieldName, validators);
		    return await runFieldValidators(fieldName, value, fieldValidators, result);
		};

		const getFieldValidators = (name, validators) => {
		    return validators && validators.fields && validators.fields[name]
		        ? validators.fields[name]
		        : [];
		};

		const runFieldValidators = async (fieldName, value, validators, result) => {
		    for (let validatorRule of validators) {
		        try {
		            const valid = await executeObjectFunction(
		                validatorRule["validator"],
		                [value]
		            );
		            if (!valid) {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        } catch (e) {
		            if (e instanceof notVaildationError || !validatorRule.message) {
		                setFieldError(fieldName, e.message, result);
		            } else {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        }
		    }
		};

		const setFieldError = (fieldName, errorMessage, result) => {
		    if (!result.fields[fieldName].includes(errorMessage)) {
		        result.fields[fieldName].push(errorMessage);
		    }
		};

		const validateForm = async ({ validators, data, result }) => {
		    const formValidators = getFormValidators(validators);
		    await runFormValidators(data, formValidators, result);
		};

		const getFormValidators = (validators) => {
		    return validators && validators.form ? validators.form : [];
		};

		const runFormValidators = async (data, formValidators, result) => {
		    for (let validator of formValidators) {
		        try {
		            await validator(data);
		        } catch (e) {
		            if (e && typeof e.getFieldsErrors === "function") {
		                const formErrors = e.getFieldsErrors();
		                Array.isArray(formErrors.form) &&
		                    addFormErrors(formErrors.form, result);
		                formErrors.fields &&
		                    addFormFieldsErrors(formErrors.fields, result);
		            } else {
		                throw e;
		            }
		        }
		    }
		};

		const addFormErrors = (errors, result) => {
		    errors.forEach((error) => {
		        addFormError(error, result);
		    });
		};

		const addFormError = (errorMessage, result) => {
		    if (!result.form.errors.includes(errorMessage)) {
		        result.form.errors.push(errorMessage);
		    }
		};

		const addFormFieldsErrors = (fieldsErrors, result) => {
		    for (let fieldName in fieldsErrors) {
		        addFormFieldErrors(fieldName, fieldsErrors[fieldName], result);
		    }
		};

		const addFormFieldErrors = (fieldName, errorMessages, result) => {
		    errorMessages.forEach((error) => {
		        addFormFieldError(fieldName, error, result);
		    });
		};

		const addFormFieldError = (fieldName, errorMessage, result) => {
		    if (!Array.isArray(result.form.fields[fieldName])) {
		        result.form.fields[fieldName] = [];
		    }
		    if (!result.form.fields[fieldName].includes(errorMessage)) {
		        result.form.fields[fieldName].push(errorMessage);
		    }
		};
		return session;
	}

	var runner_utils;
	var hasRequiredRunner_utils;

	function requireRunner_utils () {
		if (hasRequiredRunner_utils) return runner_utils;
		hasRequiredRunner_utils = 1;
		const composeFieldsValidators = (data, validatorsLib) => {
		    if (validatorsLib && validatorsLib.fields) {
		        const list = Object.keys(data);
		        const result = {};
		        list.forEach((fieldName) => {
		            if (Array.isArray(validatorsLib.fields[fieldName])) {
		                result[fieldName] = validatorsLib.fields[fieldName];
		            }
		        });
		        return result;
		    } else {
		        return {};
		    }
		};

		const composeFormValidators = (name, validatorsLib) => {
		    if (!validatorsLib) return [];
		    if (validatorsLib.forms && Array.isArray(validatorsLib.forms[name])) {
		        return validatorsLib.forms[name];
		    }
		    if (Array.isArray(validatorsLib.form)) {
		        return validatorsLib.form;
		    }
		    return [];
		};

		runner_utils = {
		    composeFieldsValidators,
		    composeFormValidators,
		};
		return runner_utils;
	}

	var runner;
	var hasRequiredRunner;

	function requireRunner () {
		if (hasRequiredRunner) return runner;
		hasRequiredRunner = 1;
		const {
		    composeFieldsValidators,
		    composeFormValidators,
		} = requireRunner_utils();

		const ValidationSession = requireSession();

		/**
		 * Creates validation runner function from provided validation rules lib
		 * @param {object}     validationLib object containing fields validation rules and form specific rules
		 * @returns {function} (data: object, formName: string)=>Promise<ValidationResult>
		 **/
		const ValidationRunner = (validatorsLib) => {
		    /**
		     * Validation session runner
		     * @param {object} data      object to validate
		     * @param {string} formName
		     * @returns {Promise}
		     **/
		    return (data, formName) => {
		        const validators = {
		            //fields specific validators
		            fields: composeFieldsValidators(data, validatorsLib),
		            //form specific validators
		            form: composeFormValidators(formName, validatorsLib),
		        };
		        return ValidationSession(validators, data);
		    };
		};

		runner = ValidationRunner;
		return runner;
	}

	var builder_utils;
	var hasRequiredBuilder_utils;

	function requireBuilder_utils () {
		if (hasRequiredBuilder_utils) return builder_utils;
		hasRequiredBuilder_utils = 1;
		const augmentFieldsValidators = (fieldValidators, getValidatorEnv) => {
		    return fieldValidators.map((fieldRule) =>
		        augmentFieldValidator(fieldRule, getValidatorEnv)
		    );
		};

		const augmentFieldValidator = (rule, getValidatorEnv) => {
		    if (rule.validator && typeof rule.validator === "function") {
		        const ruleValidator = rule.validator;
		        const result = {
		            ...rule,
		        };
		        delete result.validator;
		        result.validator = (val) => ruleValidator(val, getValidatorEnv());
		        return result;
		    }
		    return rule;
		};

		const augmentFormValidators = (rules, getValidatorEnv) => {
		    return rules.map((rule) => augmentFormValidator(rule, getValidatorEnv));
		};

		const augmentFormValidator = (rule, getValidatorEnv) => {
		    return (val) => rule(val, getValidatorEnv());
		};

		builder_utils = {
		    augmentFieldsValidators,
		    augmentFieldValidator,
		    augmentFormValidators,
		    augmentFormValidator,
		};
		return builder_utils;
	}

	var builder;
	var hasRequiredBuilder;

	function requireBuilder () {
		if (hasRequiredBuilder) return builder;
		hasRequiredBuilder = 1;
		const objHas = (obj, name) => {
		    return Object.prototype.hasOwnProperty.call(obj, name);
		};
		const {
		    augmentFieldsValidators,
		    augmentFormValidators,
		} = requireBuilder_utils();

		/**
		 * @typedef   {object}    notValidationSchema
		 * @property  {object}    [fields]
		 * @property  {array}     [form]
		 * @property  {object}    [forms]
		 */

		/**
		 * returns valid empty validation scheme
		 *
		 * @return {notValidationSchema}
		 */
		const emptyScheme = () => {
		    return {
		        fields: {},
		        forms: {},
		    };
		};
		/**
		 *
		 *
		 * @param {object} validators
		 * @param {function} getValidatorEnv
		 * @return {notValidationSchema}
		 */
		const validationBuilder = (validators, getValidatorEnv) => {
		    if (typeof validators === "undefined" || validators === null) {
		        return emptyScheme();
		    }
		    const augmented = {};
		    if (objHas(validators, "fields")) {
		        augmented.fields = transformFieldsValidators(
		            validators.fields,
		            getValidatorEnv
		        );
		    }
		    if (objHas(validators, "forms")) {
		        augmented.forms = transformFormsValidators(
		            validators.forms,
		            getValidatorEnv
		        );
		    } else {
		        if (objHas(validators, "form")) {
		            augmented.form = augmentFormValidators(
		                validators.form,
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		builder = validationBuilder;

		const transformFieldsValidators = (fields, getValidatorEnv) => {
		    const augmented = {};
		    for (let fieldName in fields) {
		        if (Array.isArray(fields[fieldName])) {
		            augmented[fieldName] = augmentFieldsValidators(
		                fields[fieldName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		const transformFormsValidators = (formsValidators, getValidatorEnv) => {
		    const augmented = {};
		    for (let formName in formsValidators) {
		        if (Array.isArray(formsValidators[formName])) {
		            augmented[formName] = augmentFormValidators(
		                formsValidators[formName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};
		return builder;
	}

	var src;
	var hasRequiredSrc;

	function requireSrc () {
		if (hasRequiredSrc) return src;
		hasRequiredSrc = 1;
		const Session = requireSession();
		const Runner = requireRunner();
		const Builder = requireBuilder();
		const Result = requireResult();

		src = {
		    name: "not-validation",
		    Session,
		    Runner,
		    Builder,
		    Result,
		};
		return src;
	}

	var srcExports = requireSrc();

	var root_4$4 = template(`<div><div class="field-label is-normal"><!></div> <div class="field-body"></div></div>`);
	var root_7$1 = template(`<!> <!>`, 1);
	var root_6$3 = template(`<div></div>`);

	function Field($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [label]
		 * @property {string} [name]
		 * @property {boolean} [readonly]
		 * @property {boolean} [horizontal]
		 * @property {any} [controls]
		 * @property {import('../../../elements/events.types').UIEventInputChangeCallback} onchange
		 * @property {string} [classes] - field style modification
		 * @property {boolean} [addons] - //addons
		 * @property {boolean} [addonsCentered]
		 * @property {boolean} [addonsRight]
		 * @property {boolean} [grouped] - //group flag
		 * @property {boolean} [groupedMultiline]
		 * @property {boolean} [groupedRight]
		 * @property {boolean} [groupedCentered]
		 */
		/** @type {Props} */
		let label = prop($$props, 'label', 3, ""),
			name = prop($$props, 'name', 3, "generic field"),
			readonly = prop($$props, 'readonly', 3, false),
			horizontal = prop($$props, 'horizontal', 3, false),
			controls = prop($$props, 'controls', 19, () => []),
			classes = prop($$props, 'classes', 3, ""),
			addons = prop($$props, 'addons', 3, false),
			addonsCentered = prop($$props, 'addonsCentered', 3, false),
			addonsRight = prop($$props, 'addonsRight', 3, false),
			grouped = prop($$props, 'grouped', 3, false),
			groupedMultiline = prop($$props, 'groupedMultiline', 3, false),
			groupedRight = prop($$props, 'groupedRight', 3, false),
			groupedCentered = prop($$props, 'groupedCentered', 3, false),
			onchange = prop($$props, 'onchange', 3, () => true),
			formFieldPrefix = prop($$props, 'formFieldPrefix', 3, "form-field-");

		let fieldClasses = state("");
		let hidden = state(false);
		let fieldId = state(undefined);

		onMount(() => {
			set(fieldClasses, get$3(fieldClasses) + (" " + classes()));
			set(fieldClasses, get$3(fieldClasses) + (addons() ? " has-addons " : ""));
			set(fieldClasses, get$3(fieldClasses) + (addonsCentered() ? " has-addons-centered " : ""));
			set(fieldClasses, get$3(fieldClasses) + (addonsRight() ? " has-addons-right " : ""));
			set(fieldClasses, get$3(fieldClasses) + (grouped() ? " is-grouped " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedMultiline() ? " is-grouped-multiline " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedRight() ? " is-grouped-right " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedCentered() ? " is-grouped-centered " : ""));

			if (readonly()) {
				controls().forEach((control) => {
					control.readonly = true;
				});
			}

			let notHidden = controls().filter((control) => control.component !== "UIHidden");

			set(hidden, notHidden.length === 0);

			let tmp = controls().map((itm) => itm.component).join("_");

			set(fieldId, `${formFieldPrefix()}${tmp}-${name()}`);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, controls, index$d, ($$anchor, control) => {
					var fragment_2 = comment();
					const SvelteComponent = derived(() => COMPONENTS$1.get(get$3(control).component));
					var node_2 = first_child(fragment_2);

					component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
						$$component($$anchor, spread_props(() => get$3(control), {
							get onchange() {
								return onchange();
							},
							get fieldname() {
								return name();
							}
						}));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				{
					var consequent_1 = ($$anchor) => {
						var div = root_4$4();
						var div_1 = child(div);
						var node_4 = child(div_1);
						const expression = derived(() => label() || controls()[0].label);

						Ui_label(node_4, {
							get for() {
								return get$3(fieldId);
							},
							get label() {
								return get$3(expression);
							}
						});

						reset(div_1);

						var div_2 = sibling(div_1, 2);

						each(div_2, 21, controls, index$d, ($$anchor, control) => {
							var fragment_4 = comment();
							const SvelteComponent_1 = derived(() => COMPONENTS$1.get(get$3(control).component));
							var node_5 = first_child(fragment_4);

							component(node_5, () => get$3(SvelteComponent_1), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$3(control), {
									get onchange() {
										return onchange();
									},
									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_4);
						});

						reset(div_2);
						reset(div);

						template_effect(() => {
							set_class(div, `field is-horizontal ${get$3(fieldClasses) ?? ''} ${get$3(fieldId) ?? ''}`);
							set_attribute(div_2, 'id', get$3(fieldId));
						});

						append($$anchor, div);
					};

					var alternate = ($$anchor) => {
						var div_3 = root_6$3();

						each(div_3, 21, controls, index$d, ($$anchor, control) => {
							var fragment_5 = root_7$1();
							const SvelteComponent_2 = derived(() => COMPONENTS$1.get(get$3(control).component));
							var node_6 = first_child(fragment_5);

							Ui_label(node_6, {
								get for() {
									return `form-field-${get$3(control).component ?? ''}-${name() ?? ''}`;
								},
								get label() {
									return get$3(control).label;
								}
							});

							var node_7 = sibling(node_6, 2);

							component(node_7, () => get$3(SvelteComponent_2), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$3(control), {
									get onchange() {
										return onchange();
									},
									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_5);
						});

						reset(div_3);
						template_effect(() => set_class(div_3, `field ${get$3(fieldClasses) ?? ''} ${get$3(fieldId) ?? ''}`));
						append($$anchor, div_3);
					};

					if_block(
						node_3,
						($$render) => {
							if (horizontal()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (get$3(hidden)) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function submitForm(e, dispatch, collectData) {
		e && e.preventDefault();
		dispatch("submit", collectData());
		return false;
	}

	function rejectForm(_, dispatch) {
		dispatch("reject");
	}

	var root_1$5 = template(`<div><span class="title"> </span></div>`);
	var root_2$3 = template(`<div class="notification is-success"><h3 class="form-success-message"> </h3></div>`);
	var root_4$3 = template(`<h5 class="title is-5"> </h5>`);
	var root_5$3 = template(`<h6 class="subtitle is-6"> </h6>`);
	var root_7 = template(`<button> </button>`);
	var root_8 = template(`<button> </button>`);
	var root_9 = template(`<div class="edit-form-error notification is-danger"> </div>`);
	var root_6$2 = template(`<div class="buttons is-grouped is-centered"><!> <!></div> <!>`, 1);
	var root_14 = template(`<div><!></div>`);
	var root_15 = template(`<div class="column notification is-danger"> </div>`);
	var root_11 = template(`<div class="columns"></div>`);
	var root_19 = template(`<div class="notification is-danger"> </div>`);
	var root_22 = template(`<span> </span>`);
	var root_21 = template(`<div class="edit-form-error notification is-danger"></div>`);
	var root_23 = template(`<button> </button>`);
	var root_24 = template(`<button> </button>`);
	var root_20 = template(`<!> <div class="buttons is-grouped is-centered"><!> <!></div>`, 1);
	var root_3$4 = template(`<!> <!> <!> <!> <!>`, 1);
	var root$6 = template(`<div class="form-container"><!> <!></div>`);

	function Form($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let dispatch = createEventDispatcher();
		//validation status
		let formErrors = state(proxy([]));
		let formHasErrors = state(false);
		let fieldsHasErrors = state(false);
		let success = state(false);

		//input data
		//form structure object
		//hidden - no loader
		//container - parent container of form
		//fields list structure
		/**
		 * @typedef {Object} Props
		 * @property {any} [form] - {
		[fieldName: string] => description: object
		}
		 * @property {boolean} [loading] - state if form loading
		 * @property {string} [loader] - page - whole page
		 * @property {any} [fields] - each item is a row
		if item is array, then there few fields in a row
		[
		[name, age],
		[email, telephone]
		bio,
		agreed
		]
		 * @property {string} [SUCCESS_TEXT] - form result labels
		 * @property {string} [WAITING_TEXT]
		 * @property {string} [title] - form labels
		 * @property {string} [description]
		 * @property {boolean} [buttonsFirst] - if you want button on top
		 * @property {boolean} [horizontal] - if form fields should have horizontal layout
		 * @property {any} [submit] - buttons labels and availability
		 * @property {any} [cancel]
		 */
		/** @type {Props} */
		let form = prop($$props, 'form', 31, () => proxy({})),
			loading = prop($$props, 'loading', 15, false),
			loader = prop($$props, 'loader', 3, "container"),
			fields = prop($$props, 'fields', 19, () => []),
			SUCCESS_TEXT = prop($$props, 'SUCCESS_TEXT', 3, "Операция завершена"),
			WAITING_TEXT = prop($$props, 'WAITING_TEXT', 3, "Отправка данных на сервер"),
			title = prop($$props, 'title', 3, ""),
			description = prop($$props, 'description', 3, ""),
			buttonsFirst = prop($$props, 'buttonsFirst', 3, false),
			horizontal = prop($$props, 'horizontal', 3, false),
			submit = prop($$props, 'submit', 19, () => ({ caption: "Отправить", enabled: true })),
			cancel = prop($$props, 'cancel', 19, () => ({ caption: "Назад", enabled: true }));

		let formInvalid = derived(() => get$3(formHasErrors) || get$3(fieldsHasErrors));

		function collectData() {
			return FormHelpers.collectData(fields(), form());
		}

		function setFieldInvalid(fieldName, value, errors) {
			form(FormHelpers.setFieldInvalid(form(), fieldName, value, errors));
			set(fieldsHasErrors, true);
		}

		function setFieldValid(fieldName, value) {
			form(FormHelpers.setFieldValid(form(), fieldName, value));
		}

		function isFieldValid(fieldName) {
			return FormHelpers.isFieldValid(form(), fieldName);
		}

		function setFormFieldInvalid(fieldName, errors) {
			form(FormHelpers.setFormFieldInvalid(form(), fieldName, errors));
			dispatch(`field.invalid`, { fieldName });
		}

		function setFormFieldValid(fieldName) {
			form(FormHelpers.setFormFieldValid(form(), fieldName));
			dispatch(`field.valid`, { fieldName });
		}

		function updateFormValidationStatus(
			validationStatus /* FormValidationSession.getCompleteResult() */
		) {
			set(formHasErrors, false);
			set(fieldsHasErrors, false);

			if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
				get$3(formErrors).splice(0, get$3(formErrors).length, ...validationStatus.form);
				set(formHasErrors, true);
			} else {
				get$3(formErrors).splice(0, get$3(formErrors).length);
			}

			set(formErrors, proxy(get$3(formErrors)));

			if (validationStatus.fields) {
				for (let fieldName of Object.keys(form())) {
					if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
						FormHelpers.setFormFieldInvalid(form(), fieldName, validationStatus.fields[fieldName]);
						set(fieldsHasErrors, true);
					} else {
						FormHelpers.setFormFieldValid(form(), fieldName);
					}
				}
			}
		}

		function showSuccess() {
			set(success, true);
		}

		function setLoading() {
			loading(true);
		}

		function resetLoading() {
			loading(false);
		}

		function setFieldsVisibility(fieldsList, val) {
			if (FormHelpers.setFieldsVisibility(form(), fieldsList, val)) {
				form(form());
			}
		}

		function setVisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, true);
		}

		function setInvisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, false);
		}

		function setFieldValue(fieldName, value) {
			if (FormHelpers.setFieldValue(form(), fieldName, value)) {
				onFieldChange({ detail: { field: fieldName, value } });
			}
		}

		function updateField(fieldName, props) {
			form(form()[fieldName] = { ...form()[fieldName], ...props }, true);
			form(form());
		}

		function onFieldChange(ev) {
			let data = ev.detail;

			form(form()[data.field].value = data.value, true);
			form(form());
			dispatch("change", data);
		}

		var div = root$6();
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var div_1 = root_1$5();
				var span = child(div_1);
				var text = child(span, true);

				reset(span);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, `${(loader() === 'page' ? 'pageloader' : 'containerloader') ?? ''} ${(loading() ? 'is-active' : '') ?? ''}`);
					set_text(text, $LOCALE()[WAITING_TEXT()]);
				});

				append($$anchor, div_1);
			};

			if_block(node, ($$render) => {
				if (loader() !== "hidden") $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_2 = root_2$3();
				var h3 = child(div_2);
				var text_1 = child(h3, true);

				reset(h3);
				reset(div_2);
				template_effect(() => set_text(text_1, $LOCALE()[SUCCESS_TEXT()]));
				append($$anchor, div_2);
			};

			var alternate_3 = ($$anchor) => {
				var fragment = root_3$4();
				var node_2 = first_child(fragment);

				{
					var consequent_2 = ($$anchor) => {
						var h5 = root_4$3();
						var text_2 = child(h5, true);

						reset(h5);
						template_effect(() => set_text(text_2, $LOCALE()[title()]));
						append($$anchor, h5);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_2);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_3 = ($$anchor) => {
						var h6 = root_5$3();
						var text_3 = child(h6, true);

						reset(h6);
						template_effect(() => set_text(text_3, $LOCALE()[description()]));
						append($$anchor, h6);
					};

					if_block(node_3, ($$render) => {
						if (description()) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_1 = root_6$2();
						var div_3 = first_child(fragment_1);
						var node_5 = child(div_3);

						{
							var consequent_4 = ($$anchor) => {
								var button = root_7();

								button.__click = [rejectForm, dispatch];

								var text_4 = child(button, true);

								reset(button);

								template_effect(() => {
									set_class(button, `button is-outlined ${cancel().classes ?? ''}`);
									set_text(text_4, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button);
							};

							if_block(node_5, ($$render) => {
								if (cancel().enabled) $$render(consequent_4);
							});
						}

						var node_6 = sibling(node_5, 2);

						{
							var consequent_5 = ($$anchor) => {
								var button_1 = root_8();

								button_1.__click = [submitForm, dispatch, collectData];

								var text_5 = child(button_1, true);

								reset(button_1);

								template_effect(() => {
									button_1.disabled = get$3(formInvalid);
									set_class(button_1, `button is-primary is-hovered ${submit().classes ?? ''}`);
									set_text(text_5, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_1);
							};

							if_block(node_6, ($$render) => {
								if (submit().enabled) $$render(consequent_5);
							});
						}

						reset(div_3);

						var node_7 = sibling(div_3, 2);

						{
							var consequent_6 = ($$anchor) => {
								var div_4 = root_9();
								var text_6 = child(div_4, true);

								reset(div_4);
								template_effect(($0) => set_text(text_6, $0), [() => get$3(formErrors).join(", ")]);
								append($$anchor, div_4);
							};

							if_block(node_7, ($$render) => {
								if (get$3(formErrors).length > 0) $$render(consequent_6);
							});
						}

						append($$anchor, fragment_1);
					};

					if_block(node_4, ($$render) => {
						if (buttonsFirst()) $$render(consequent_7);
					});
				}

				var node_8 = sibling(node_4, 2);

				each(node_8, 17, fields, index$d, ($$anchor, field) => {
					var fragment_2 = comment();
					var node_9 = first_child(fragment_2);

					{
						var consequent_10 = ($$anchor) => {
							var div_5 = root_11();

							each(div_5, 21, () => get$3(field), index$d, ($$anchor, subfield) => {
								var fragment_3 = comment();
								var node_10 = first_child(fragment_3);

								{
									var consequent_9 = ($$anchor) => {
										var fragment_4 = comment();
										var node_11 = first_child(fragment_4);

										{
											var consequent_8 = ($$anchor) => {
												var div_6 = root_14();
												var node_12 = child(div_6);
												const expression = derived(() => [form()[get$3(subfield)]]);

												Field(node_12, {
													get controls() {
														return get$3(expression);
													},
													get name() {
														return get$3(subfield);
													},
													get horizontal() {
														return horizontal();
													},
													get label() {
														return form()[get$3(subfield)].label;
													},
													$$events: { change: onFieldChange }
												});

												reset(div_6);
												template_effect(() => set_class(div_6, `column ${(form()[get$3(subfield)].fieldSize ? 'is-' + form()[get$3(subfield)].fieldSize : '') ?? ''} `));
												append($$anchor, div_6);
											};

											if_block(node_11, ($$render) => {
												if (form()[get$3(subfield)].visible) $$render(consequent_8);
											});
										}

										append($$anchor, fragment_4);
									};

									var alternate = ($$anchor) => {
										var div_7 = root_15();
										var text_7 = child(div_7);

										reset(div_7);
										template_effect(() => set_text(text_7, `Subfield '${get$3(subfield) ?? ''}' is not registered`));
										append($$anchor, div_7);
									};

									if_block(node_10, ($$render) => {
										if (form()[get$3(subfield)] && form()[get$3(subfield)].component) $$render(consequent_9); else $$render(alternate, false);
									});
								}

								append($$anchor, fragment_3);
							});

							reset(div_5);
							append($$anchor, div_5);
						};

						var alternate_2 = ($$anchor) => {
							var fragment_5 = comment();
							var node_13 = first_child(fragment_5);

							{
								var consequent_12 = ($$anchor) => {
									var fragment_6 = comment();
									var node_14 = first_child(fragment_6);

									{
										var consequent_11 = ($$anchor) => {
											const expression_1 = derived(() => [form()[get$3(field)]]);

											Field($$anchor, {
												get controls() {
													return get$3(expression_1);
												},
												get name() {
													return get$3(field);
												},
												get horizontal() {
													return horizontal();
												},
												get label() {
													return form()[get$3(field)].label;
												},
												$$events: { change: onFieldChange }
											});
										};

										if_block(node_14, ($$render) => {
											if (form()[get$3(field)].visible) $$render(consequent_11);
										});
									}

									append($$anchor, fragment_6);
								};

								var alternate_1 = ($$anchor) => {
									var div_8 = root_19();
									var text_8 = child(div_8);

									reset(div_8);
									template_effect(() => set_text(text_8, `Field '${get$3(field) ?? ''}' is not registered`));
									append($$anchor, div_8);
								};

								if_block(
									node_13,
									($$render) => {
										if (form()[get$3(field)] && form()[get$3(field)].component) $$render(consequent_12); else $$render(alternate_1, false);
									},
									true
								);
							}

							append($$anchor, fragment_5);
						};

						if_block(node_9, ($$render) => {
							if (Array.isArray(get$3(field))) $$render(consequent_10); else $$render(alternate_2, false);
						});
					}

					append($$anchor, fragment_2);
				});

				var node_15 = sibling(node_8, 2);

				{
					var consequent_16 = ($$anchor) => {
						var fragment_8 = root_20();
						var node_16 = first_child(fragment_8);

						{
							var consequent_13 = ($$anchor) => {
								var div_9 = root_21();

								each(div_9, 21, () => get$3(formErrors), index$d, ($$anchor, formError) => {
									var span_1 = root_22();
									var text_9 = child(span_1, true);

									reset(span_1);
									template_effect(() => set_text(text_9, $LOCALE()[get$3(formError)]));
									append($$anchor, span_1);
								});

								reset(div_9);
								append($$anchor, div_9);
							};

							if_block(node_16, ($$render) => {
								if (get$3(formErrors).length > 0) $$render(consequent_13);
							});
						}

						var div_10 = sibling(node_16, 2);
						var node_17 = child(div_10);

						{
							var consequent_14 = ($$anchor) => {
								var button_2 = root_23();

								button_2.__click = [rejectForm, dispatch];

								var text_10 = child(button_2, true);

								reset(button_2);

								template_effect(() => {
									set_class(button_2, `button ${(cancel().classes ? cancel().classes : '') ?? ''}`);
									set_text(text_10, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button_2);
							};

							if_block(node_17, ($$render) => {
								if (cancel().enabled) $$render(consequent_14);
							});
						}

						var node_18 = sibling(node_17, 2);

						{
							var consequent_15 = ($$anchor) => {
								var button_3 = root_24();

								button_3.__click = [submitForm, dispatch, collectData];

								var text_11 = child(button_3, true);

								reset(button_3);

								template_effect(() => {
									button_3.disabled = get$3(formInvalid);
									set_class(button_3, `button is-primary is-hovered ${(submit().classes ? submit().classes : '') ?? ''}`);
									set_text(text_11, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_3);
							};

							if_block(node_18, ($$render) => {
								if (submit().enabled) $$render(consequent_15);
							});
						}

						reset(div_10);
						append($$anchor, fragment_8);
					};

					if_block(node_15, ($$render) => {
						if (!buttonsFirst()) $$render(consequent_16);
					});
				}

				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (get$3(success)) $$render(consequent_1); else $$render(alternate_3, false);
			});
		}

		reset(div);
		append($$anchor, div);

		var $$pop = pop({
			collectData,
			setFieldInvalid,
			setFieldValid,
			isFieldValid,
			setFormFieldInvalid,
			setFormFieldValid,
			updateFormValidationStatus,
			showSuccess,
			setLoading,
			resetLoading,
			setFieldsVisibility,
			setVisibleFields,
			setInvisibleFields,
			setFieldValue,
			updateField
		});

		$$cleanup();
		return $$pop;
	}

	delegate(['click']);

	const DEFAULT_RULES = {
	  notReadonly(v) {
	    return {
	      readonly: !v
	    };
	  },
	  readonly(v) {
	    return {
	      readonly: v
	    };
	  },
	  enable(v) {
	    return {
	      disabled: !v
	    };
	  },
	  disable(v) {
	    return {
	      disabled: v
	    };
	  }
	};
	let notFormRules = /*#__PURE__*/function () {
	  function notFormRules() {
	    _classCallCheck(this, notFormRules);
	  }
	  return _createClass(notFormRules, null, [{
	    key: "add",
	    value: function add(name, func) {
	      if (!notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name)) {
	        _assertClassBrand(notFormRules, this, _RULES)._[name] = func;
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove(name) {
	      if (notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name) && !Object.keys(DEFAULT_RULES).includes(name)) {
	        delete _assertClassBrand(notFormRules, this, _RULES)._[name];
	      }
	    }
	  }, {
	    key: "exec",
	    value: function exec(rule, master, slaves, value, form) {
	      return _assertClassBrand(notFormRules, this, _RULES)._[rule](value, master, slaves, form);
	    }
	  }]);
	}();
	var _RULES = {
	  _: {
	    ...DEFAULT_RULES
	  }
	};

	const DEFAULT_CONTAINER_SELECTOR$1 = ".form";
	const DEFAULT_ACTION_NAME = "default";
	var _uiComponent = /*#__PURE__*/new WeakMap();
	var _validationRunner = /*#__PURE__*/new WeakMap();
	var _form$1 = /*#__PURE__*/new WeakMap();
	var _action = /*#__PURE__*/new WeakMap();
	var _fields = /*#__PURE__*/new WeakMap();
	var _variants = /*#__PURE__*/new WeakMap();
	var _notForm_brand = /*#__PURE__*/new WeakSet();
	let notForm = /*#__PURE__*/function (_notBase) {
	  //variants for UI

	  function notForm({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data: _data = {},
	    ui = Form //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notForm);
	    _this = _callSuper(this, notForm, [{
	      working: {
	        name: `${name}Form`,
	        ...working
	      },
	      options,
	      data: _data
	    }]);
	    _classPrivateMethodInitSpec(_this, _notForm_brand);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent, null);
	    //form validation
	    _classPrivateFieldInitSpec(_this, _validationRunner, null);
	    //ui component
	    _classPrivateFieldInitSpec(_this, _form$1, null);
	    //model.action
	    _classPrivateFieldInitSpec(_this, _action, DEFAULT_ACTION_NAME);
	    //fields schemas
	    _classPrivateFieldInitSpec(_this, _fields, new Lib());
	    //fields of UI
	    //variants sets for select menus and so on
	    _classPrivateFieldInitSpec(_this, _variants, null);
	    _classPrivateFieldSet2(_variants, _this, new Lib(VARIANTS$1.getContent()));
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent, _this, ui);
	    if (notCommon$1.objHas(options, "action")) {
	      _classPrivateFieldSet2(_action, _this, options.action);
	    }
	    _this.initForm();
	    return _this;
	  }
	  _inherits(notForm, _notBase);
	  return _createClass(notForm, [{
	    key: "initForm",
	    value: function initForm() {
	      if (this.getOptions("autoInit", true)) {
	        this.initLibs();
	      }
	      if (this.getOptions("autoRender", true)) {
	        this.initUI();
	      }
	    }
	  }, {
	    key: "initLibs",
	    value: function initLibs() {
	      this.initFields();
	      this.initVariants();
	      this.initValidator();
	    }
	  }, {
	    key: "reInit",
	    value: function reInit() {
	      this.initLibs();
	      this.updateUI();
	      this.resetLoading();
	    }
	  }, {
	    key: "initFields",
	    value: function initFields() {
	      const manifest = this.getFormManifest();
	      if (notCommon$1.objHas(manifest, "fields") && _classPrivateFieldGet2(_fields, this).isEmpty()) {
	        _classPrivateFieldGet2(_fields, this).import(manifest.fields); //all fields available in model manifest
	      }
	    }
	  }, {
	    key: "initVariants",
	    value: function initVariants() {
	      if (this.getOptions("variants")) {
	        _classPrivateFieldGet2(_variants, this).import(this.getOptions("variants"));
	      }
	    }

	    //creating validators runner for this specific form
	  }, {
	    key: "initValidator",
	    value: function initValidator() {
	      _classPrivateFieldSet2(_validationRunner, this, srcExports.Runner(this.getFormValidators()));
	    }
	  }, {
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        const target = this.getFormTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_form$1, this, new (_classPrivateFieldGet2(_uiComponent, this))({
	          target,
	          props
	        }));
	        _assertClassBrand(_notForm_brand, this, _bindUIEvents).call(this);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "updateUI",
	    value: function updateUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        _classPrivateFieldGet2(_form$1, this).$set(props);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "validateForm",
	    value: async function validateForm() {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      try {
	        const validationResult = await _classPrivateFieldGet2(_validationRunner, this).call(this, _classPrivateFieldGet2(_form$1, this).collectData(), this.getFormAction());
	        _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(validationResult.getReport());
	        if (!validationResult.clean) {
	          this.emit("error", validationResult.getReport());
	        }
	      } catch (e) {
	        const report = {
	          form: [UICommon$1.ERROR_DEFAULT, e.message]
	        };
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(report);
	        this.emit("error", report);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "submit",
	    value: function submit(data) {
	      this.emit("submit", data);
	    }
	  }, {
	    key: "reject",
	    value: function reject() {
	      this.emit("reject");
	    }

	    //binding event to actual UI
	  }, {
	    key: "$on",
	    value: function $on() {
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$on(...arguments);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_form$1, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_form$1, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$destroy && _classPrivateFieldGet2(_form$1, this).$destroy();
	        _classPrivateFieldGet2(_form$1, this).destroy && _classPrivateFieldGet2(_form$1, this).destroy();
	        _classPrivateFieldSet2(_form$1, this, null);
	      }
	      _classPrivateFieldSet2(_validationRunner, this, null);
	      _classPrivateFieldSet2(_action, this, null);
	      _classPrivateFieldSet2(_fields, this, null);
	      _classPrivateFieldSet2(_variants, this, null);
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }
	  }, {
	    key: "getFormAction",
	    value: function getFormAction() {
	      return _classPrivateFieldGet2(_action, this);
	    }
	  }, {
	    key: "setFormAction",
	    value: function setFormAction(val) {
	      if (val && val !== _classPrivateFieldGet2(_action, this)) {
	        _classPrivateFieldSet2(_action, this, val);
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).$destroy();
	        this.initForm();
	      }
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_form$1, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(status);
	      this.emit("error", status);
	    }

	    /**
	     * Returns variant by collection name and item id
	     * @param {string}         name  name of the variants collection
	     * @param {string|number}  id    item identificator
	     * @returns {object}             item
	     **/
	  }, {
	    key: "getVariant",
	    value: function getVariant(name, id) {
	      let lib = _classPrivateFieldGet2(_variants, this).get(name);
	      let result = lib.find(function (item) {
	        return item.id === id;
	      });
	      if (result) {
	        return result;
	      }
	      return null;
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$1);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("Form parent element is not defined");
	      }
	    }
	  }, {
	    key: "getFormValidators",
	    value: function getFormValidators() {
	      if (this.getOptions("validators")) {
	        return this.getOptions("validators", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "validators");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormManifest",
	    value: function getFormManifest() {
	      const modelName = this.getModelName();
	      if (modelName && notCommon$1.getApp()) {
	        return notCommon$1.getApp().getInterfaceManifest(modelName);
	      }
	      if (this.getOptions("manifest", undefined)) {
	        return this.getOptions("manifest", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "manifest");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormData",
	    value: function getFormData() {
	      if (this.getData()) {
	        return this.getData();
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "data");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormOptions",
	    value: function getFormOptions() {
	      if (this.getOptions("ui", undefined) || this.getOptions("fields", undefined)) {
	        return {
	          ui: this.getOptions("ui", {}),
	          fields: this.getOptions("fields", {})
	        };
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "options");
	        return {
	          ui: {},
	          fields: {}
	        };
	      }
	    }
	  }, {
	    key: "getFormInjectedProps",
	    value: function getFormInjectedProps() {
	      return this.getOptions("injected", {});
	    }

	    /**
	     * Override empty message
	     **/
	  }, {
	    key: "collectData",
	    value:
	    /**
	     * Form operations
	     **/
	    function collectData() {
	      if (this.getOptions("readonly", false)) {
	        return this.getData();
	      }
	      const data = _classPrivateFieldGet2(_form$1, this).collectData();
	      this.setData({
	        ...data
	      }); //update in inner store
	      return data;
	    }
	  }, {
	    key: "updateField",
	    value: function updateField(fieldName, props) {
	      _classPrivateFieldGet2(_form$1, this).updateField(fieldName, props);
	    }
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        return this.getInterface(name)(data || {});
	      } else {
	        return this.getInterface()(name || {});
	      }
	    }
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = false) {
	      return notCommon$1.getApp().getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getOptions("model");
	    }
	  }]);
	}(notBase);
	function _bindUIEvents() {
	  var _this2 = this;
	  _classPrivateFieldGet2(_form$1, this).$on("change", function () {
	    return _this2.validateForm();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("change", function (ev) {
	    _this2.emit("change", ev.detail);
	    _this2.emit(`change.${ev.detail.field}`, ev.detail.value);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("submit", function (ev) {
	    return _this2.submit(ev.detail);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("reject", function () {
	    return _this2.reject();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("error", function ({
	    detail
	  }) {
	    return _this2.emit("error", detail);
	  });
	  _assertClassBrand(_notForm_brand, this, _bindMasterSlaveEvents).call(this);
	}
	function _bindMasterSlaveEvents() {
	  const masters = this.getOptions("masters", false);
	  if (!masters) {
	    return;
	  }
	  for (let master in masters) {
	    const rules = masters[master];
	    for (let ruleName in rules) {
	      const ruleSlaves = rules[ruleName];
	      _assertClassBrand(_notForm_brand, this, _addMasterSlaveEvents).call(this, ruleName, master, ruleSlaves);
	    }
	  }
	}
	function _addMasterSlaveEvents(rule, master, slaves = []) {
	  var _this3 = this;
	  this.on(`change.${master}`, function (value) {
	    _assertClassBrand(_notForm_brand, _this3, _execSlaveRule).call(_this3, rule, master, slaves, value);
	  });
	  this.emit(`change.${master}`, this.getFormData()[master]);
	}
	function _execSlaveRule(rule, master, slaves, value) {
	  var _this4 = this;
	  const cmd = notFormRules.exec(rule, master, slaves, value, this);
	  slaves.forEach(function (slaveField) {
	    _this4.updateField(slaveField, cmd);
	  });
	}
	function _getFormProps({
	  manifest,
	  //model manifest
	  formOptions = {
	    ui: {},
	    fields: {}
	  },
	  //some options
	  data = null,
	  //initial data for form
	  injectedProps = {}
	}) {
	  const action = _classPrivateFieldGet2(_action, this);
	  if (typeof formOptions === "undefined" || formOptions === null) {
	    formOptions = {
	      ui: {},
	      fields: {}
	    };
	  }
	  const form = FormHelpers.initFormByField(
	  //form seed object
	  {},
	  /*
	  Form structure
	  [
	  //each item is line of form
	  //field - field takes whole line of form
	  //[field1, field2] - few fields in one line
	  nameFirst, nameLast
	  [age, country, language],
	  [email, telephone]
	  ]
	  */
	  manifest.actions[action].fields,
	  //form fields structure
	  _classPrivateFieldGet2(_variants, this),
	  //variants library
	  _classPrivateFieldGet2(_fields, this),
	  //fields library
	  formOptions.fields,
	  //form wide fields options
	  data);
	  return {
	    //if no auto init of form structure, set to loading state
	    loading: !this.getOptions("autoInit", true),
	    title: manifest.actions[action].title,
	    description: manifest.actions[action].description,
	    fields: manifest.actions[action].fields,
	    form,
	    //injecting options to UI from top level input
	    ...formOptions.ui,
	    //form UI options
	    ...injectedProps
	  };
	}
	function _missingOverrideWarning(missing) {
	  this.error(`${missing} for ${this.getWorking("name")} form is not defined`);
	}

	var root$5 = template(`<div class="block-container"><div class="form-paper"></div> <!></div>`);

	function Form_set($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [name]
		 * @property {boolean} [showModes]
		 * @property {string} [mode]
		 * @property {any} [forms]
		 */
		/** @type {Props} */
		let name = prop($$props, 'name', 3, 'default-form'),
			showModes = prop($$props, 'showModes', 3, false),
			mode = prop($$props, 'mode', 15, 'default'),
			forms = prop($$props, 'forms', 19, () => []);

		function setMode(val) {
			mode(val);
			dispatch('mode', val);
			updateModesButtons();
		}

		let FORMS_BUTTONS = state(proxy([]));

		function updateModesButtons() {
			set(FORMS_BUTTONS, proxy(forms().filter((form) => {
				return mode() !== form.mode;
			}).map((form) => {
				return {
					title: form.title,
					outlined: true,
					type: 'link',
					action() {
						setMode(form.mode);
					}
				};
			})));
		}

		onMount(() => {
			updateModesButtons();
		});

		var div = root$5();
		var div_1 = child(div);
		var node = sibling(div_1, 2);

		{
			var consequent = ($$anchor) => {
				Ui_buttons($$anchor, {
					centered: true,
					classes: 'mt-4',
					get values() {
						return get$3(FORMS_BUTTONS);
					},
					set values($$value) {
						set(FORMS_BUTTONS, proxy($$value));
					}
				});
			};

			if_block(node, ($$render) => {
				if (showModes()) $$render(consequent);
			});
		}

		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', `${name() ?? ''}-form-set`);
			set_attribute(div_1, 'id', `${name() ?? ''}-form-set-container`);
		});

		append($$anchor, div);
		pop();
	}

	const DEFAULT_CONTAINER_SELECTOR = ".form-set";
	const DEFAULT_FORM_SET_NAME = "form-set";
	var _formSetComponent = /*#__PURE__*/new WeakMap();
	var _formComponent = /*#__PURE__*/new WeakMap();
	var _form = /*#__PURE__*/new WeakMap();
	var _frame = /*#__PURE__*/new WeakMap();
	var _notFormSet_brand = /*#__PURE__*/new WeakSet();
	let notFormSet = /*#__PURE__*/function (_notBase) {
	  /*
	  new notFormSet({
	  options:{
	    target: el,
	    forms: [{
	      mode: 'form1',
	      title: 'Form 1',
	      form: formConstructor1 //custom constructors
	    },{
	      mode: 'form2',
	      title: 'Form 2',
	      props: {}             //params to create notForm instance
	    },{
	      mode: 'form3',
	      title: 'Form 3',
	      form: formConstructor3 //custom constructors
	    }]
	  }
	  });
	  */

	  function notFormSet({
	    options = {},
	    formComponent = Form,
	    formSetComponent = Form_set
	  }) {
	    var _this;
	    _classCallCheck(this, notFormSet);
	    _this = _callSuper(this, notFormSet, [{
	      options: {
	        name: DEFAULT_FORM_SET_NAME,
	        mode: "default",
	        showModes: true,
	        ...options
	      }
	    }]);
	    _classPrivateMethodInitSpec(_this, _notFormSet_brand);
	    _classPrivateFieldInitSpec(_this, _formSetComponent, null);
	    _classPrivateFieldInitSpec(_this, _formComponent, null);
	    _classPrivateFieldInitSpec(_this, _form, null);
	    _classPrivateFieldInitSpec(_this, _frame, null);
	    _classPrivateFieldSet2(_formComponent, _this, formComponent);
	    _classPrivateFieldSet2(_formSetComponent, _this, formSetComponent);
	    _this.setFormMode(_this.getOptions("mode"));
	    _this.initUI();
	    return _this;
	  }

	  /**
	   * Initalizing form frame mode, with switchers between modes
	   **/
	  _inherits(notFormSet, _notBase);
	  return _createClass(notFormSet, [{
	    key: "initUI",
	    value: function initUI() {
	      var _this2 = this;
	      const target = this.getFrameTargetEl();
	      while (target.children.length) target.removeChild(target.firstChild);
	      _classPrivateFieldSet2(_frame, this, new (_classPrivateFieldGet2(_formSetComponent, this))({
	        target,
	        props: _assertClassBrand(_notFormSet_brand, this, _getFrameProps).call(this)
	      }));
	      _classPrivateFieldGet2(_frame, this).$on("mode", function (ev) {
	        _this2.setFormMode(ev.detail);
	        _this2.updateForm();
	      });
	      this.updateForm();
	    }
	  }, {
	    key: "setFormMode",
	    value: function setFormMode(name) {
	      if (this.isModeExists(name)) {
	        this.setWorking("mode", name);
	      } else {
	        this.setWorking("mode", this.getFirstMode());
	        this.updateFormModeInUI();
	      }
	    }
	  }, {
	    key: "updateFormModeInUI",
	    value: function updateFormModeInUI() {
	      if (_classPrivateFieldGet2(_frame, this) && this.getWorking("mode") !== null) {
	        _classPrivateFieldGet2(_frame, this).$set({
	          mode: this.getWorking("mode")
	        });
	      }
	    }
	  }, {
	    key: "getFormMode",
	    value: function getFormMode() {
	      return this.getWorking("mode");
	    }
	  }, {
	    key: "updateForm",
	    value: function updateForm() {
	      this.destroyForm();
	      if (this.getWorking("mode") !== null) {
	        this.renderForm();
	      }
	    }
	  }, {
	    key: "renderForm",
	    value: function renderForm() {
	      var _this3 = this;
	      const targetEl = this.getFormTargetEl();
	      const formConfig = this.getFormConfig();
	      if (!(targetEl instanceof HTMLElement && formConfig)) {
	        throw new Error("error while form rendering");
	      }
	      const changeMode = function (mode) {
	        _this3.setFormMode(mode);
	        _this3.updateForm();
	      };
	      if (formConfig.form) {
	        while (targetEl.children.length) targetEl.removeChild(targetEl.firstChild);
	        _classPrivateFieldSet2(_form, this, new formConfig.form({
	          options: {
	            target: targetEl,
	            changeMode
	          }
	        }));
	      } else if (formConfig.props) {
	        _classPrivateFieldSet2(_form, this, new (_classPrivateFieldGet2(_formComponent, this))({
	          target: targetEl,
	          ...formConfig.props,
	          changeMode
	        }));
	      }
	    }
	  }, {
	    key: "getFormConfig",
	    value: function getFormConfig() {
	      var _this4 = this;
	      return this.getOptions("forms").find(function (form) {
	        return form.mode === _this4.getFormMode();
	      });
	    }
	  }, {
	    key: "destroyForm",
	    value: function destroyForm() {
	      const containerEl = this.getFormTargetEl();
	      if (containerEl) {
	        while (containerEl.firstChild) {
	          containerEl.removeChild(containerEl.lastChild);
	        }
	      }
	      if (_classPrivateFieldGet2(_form, this) && _classPrivateFieldGet2(_form, this).$destroy) {
	        _classPrivateFieldGet2(_form, this).$destroy();
	      }
	      _classPrivateFieldSet2(_form, this, null);
	    }
	  }, {
	    key: "destroyFrame",
	    value: function destroyFrame() {
	      if (_classPrivateFieldGet2(_frame, this) && _classPrivateFieldGet2(_frame, this).$destroy) {
	        _classPrivateFieldGet2(_frame, this).$destroy();
	      }
	      _classPrivateFieldSet2(_frame, this, null);
	    }
	  }, {
	    key: "isModeExists",
	    value: function isModeExists(mode) {
	      const forms = this.getOptions("forms", []);
	      return forms.some(function (item) {
	        return item.mode === mode;
	      });
	    }
	  }, {
	    key: "getFirstMode",
	    value: function getFirstMode() {
	      const forms = this.getOptions("forms", []);
	      if (forms.length > 0) {
	        return forms[0].mode;
	      }
	      return null;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      _classPrivateFieldSet2(_formSetComponent, this, null);
	      _classPrivateFieldSet2(_formComponent, this, null);
	      this.destroyForm();
	      this.destroyFrame();
	      this.setData(null);
	      this.setOptions(null);
	      this.setWorking(null);
	    }
	  }, {
	    key: "getFrameTargetEl",
	    value: function getFrameTargetEl() {
	      const target = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR);
	      if (target instanceof HTMLElement) {
	        return target;
	      } else if (typeof target === "string") {
	        return document.querySelector(target);
	      } else {
	        throw new Error("form set target is not HTMLElement or string");
	      }
	    }
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const name = this.getOptions("name", DEFAULT_FORM_SET_NAME);
	      return document.querySelector(`#${name}-form-set-container`);
	    }
	  }]);
	}(notBase);
	function _getFrameProps() {
	  return {
	    showModes: this.getOptions("showModes", true),
	    mode: this.getFormMode(),
	    forms: this.getOptions("forms", []),
	    name: this.getOptions("name", DEFAULT_FORM_SET_NAME)
	  };
	}

	function onClick$5(ev, go) {
		if (typeof go() === 'function') {
			ev.preventDefault();
			go()(ev.currentTarget.dataset.href);
			return false;
		} else {
			return true;
		}
	}

	var root_3$3 = template(`<li class="is-active"><a aria-current="page"> </a></li>`);
	var root_5$2 = template(`<li class="is-plain-crumb"> </li>`);
	var root_6$1 = template(`<li><a> </a></li>`);
	var root_1$4 = template(`<nav class="breadcrumb" aria-label="breadcrumbs"><ul></ul></nav>`);

	function Ui_breadcrumbs($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [go]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ''),
			items = prop($$props, 'items', 19, () => []),
			go = prop($$props, 'go', 3, null);

		var nav = root_1$4();
		var ul = child(nav);

		each(ul, 21, items, index$d, ($$anchor, link, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var li = root_3$3();
					var a = child(li);
					var text = child(a, true);

					reset(a);
					reset(li);

					template_effect(() => {
						set_attribute(a, 'href', `${root() ?? ''}${get$3(link).url ?? ''}`);
						set_attribute(a, 'data-href', get$3(link).url);
						set_text(text, $LOCALE()[get$3(link).title]);
					});

					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					{
						var consequent_1 = ($$anchor) => {
							var li_1 = root_5$2();
							var text_1 = child(li_1, true);

							reset(li_1);
							template_effect(() => set_text(text_1, $LOCALE()[get$3(link).title]));
							append($$anchor, li_1);
						};

						var alternate = ($$anchor) => {
							var li_2 = root_6$1();
							var a_1 = child(li_2);

							a_1.__click = [onClick$5, go];

							var text_2 = child(a_1, true);

							reset(a_1);
							reset(li_2);

							template_effect(() => {
								set_attribute(a_1, 'href', `${root() ?? ''}${get$3(link).url ?? ''}`);
								set_attribute(a_1, 'data-href', get$3(link).url);
								set_text(text_2, $LOCALE()[get$3(link).title]);
							});

							append($$anchor, li_2);
						};

						if_block(node_1, ($$render) => {
							if (get$3(link).url === false) $$render(consequent_1); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_1);
				};

				if_block(node, ($$render) => {
					if (items().length === index + 1) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		reset(nav);
		append($$anchor, nav);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	let local_ui_props = state(proxy({}));
	let notBreadcrumbs = /*#__PURE__*/function () {
	  function notBreadcrumbs() {
	    _classCallCheck(this, notBreadcrumbs);
	  }
	  return _createClass(notBreadcrumbs, null, [{
	    key: "initUIProps",
	    value: function initUIProps(root, navigate) {
	      set(local_ui_props, proxy({
	        items: this.getBreadcrumbs(),
	        root,
	        go: navigate
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render({
	      target,
	      root = "",
	      navigate
	    }) {
	      this.remove();
	      if (notBreadcrumbs.UIConstructor) {
	        this.initUIProps(root, navigate);
	        this.ui = mount(notBreadcrumbs.UIConstructor, {
	          target,
	          props: get$3(local_ui_props)
	        });
	      }
	      return this;
	    }
	  }, {
	    key: "setHead",
	    value: function setHead(head) {
	      this.head.splice(0, this.head.length, ...head);
	      return this;
	    }
	  }, {
	    key: "setTail",
	    value: function setTail(tail) {
	      this.tail.splice(0, this.tail.length, ...tail);
	      return this;
	    }
	  }, {
	    key: "getBreadcrumbs",
	    value: function getBreadcrumbs() {
	      let crumbs = [];
	      crumbs.push(...this.head);
	      crumbs.push(...this.tail);
	      return crumbs;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.ui) {
	        get$3(local_ui_props).items = this.getBreadcrumbs();
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.ui) {
	        umount(this.ui);
	        this.ui = null;
	      }
	      return this;
	    }
	  }]);
	}();
	_defineProperty(notBreadcrumbs, "UIConstructor", null);
	_defineProperty(notBreadcrumbs, "ui", null);
	_defineProperty(notBreadcrumbs, "head", []);
	_defineProperty(notBreadcrumbs, "tail", []);

	notBreadcrumbs.UIConstructor = Ui_breadcrumbs;

	var _Menu;
	let Menu = /*#__PURE__*/function () {
	  function Menu() {
	    _classCallCheck(this, Menu);
	  }
	  return _createClass(Menu, null, [{
	    key: "hide",
	    value: function hide() {}
	  }, {
	    key: "setApp",
	    value: function setApp(app) {
	      if (!this.app) {
	        this.app = app;
	      }
	      return this;
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(options) {
	      this.options = {
	        ...this.options,
	        ...options
	      };
	      return this;
	    }
	  }, {
	    key: "getOptionsPathTo",
	    value: function getOptionsPathTo(what) {
	      return `menu.${this.options.type}.${what}`;
	    }
	  }, {
	    key: "isDirectNavigation",
	    value: function isDirectNavigation() {
	      return this.app ? this.app.getOptions(this.getOptionsPathTo("directNavigation"), this.options.directNavigation) : this.options.directNavigation;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      if (this.app) {
	        return {
	          brand: this.app.getOptions("brand", this.options.brand),
	          items: this.app.getOptions(this.getOptionsPathTo("items"), this.options.items),
	          sections: this.app.getOptions(this.getOptionsPathTo("sections"), this.options.sections),
	          targetSelector: this.app.getOptions(this.getOptionsPathTo("targetSelector"), this.options.targetSelector),
	          toggleSelector: this.app.getOptions(this.getOptionsPathTo("toggleSelector"), this.options.toggleSelector),
	          open: this.app.getOptions(this.getOptionsPathTo("open"), this.options.open),
	          directNavigation: this.app.getOptions(this.getOptionsPathTo("directNavigation"), this.options.directNavigation),
	          root: this.app.getOptions("router.root", this.options.root),
	          navigate: this.options.navigate.bind(this),
	          getComponent: this.getComponent.bind(this)
	        };
	      } else {
	        return this.options;
	      }
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(name) {
	      if (COMPONENTS$1.contains(name)) {
	        return COMPONENTS$1.get(name);
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "initField",
	    value: function initField(list, fields = []) {
	      var _this = this;
	      list.forEach(function (item) {
	        fields.forEach(function (field) {
	          if (!Object.hasOwn(item, field)) {
	            item[field] = _this.DEFAULT[field];
	          }
	        });
	        if (Object.hasOwn(item, "items")) {
	          _this.initField(item.items, fields);
	        }
	      });
	    }
	  }, {
	    key: "sortList",
	    value: function sortList(list) {
	      var _this2 = this;
	      list.sort(function (item1, item2) {
	        if (Object.hasOwn(item1, "items")) {
	          _this2.sortList(item1.items);
	        }
	        if (Object.hasOwn(item2, "items")) {
	          _this2.sortList(item2.items);
	        }
	        if (item1.priority === item2.priority) {
	          return item1.title > item2.title ? 1 : -1;
	        } else {
	          return item1.priority < item2.priority ? 1 : -1;
	        }
	      });
	    }
	  }, {
	    key: "removeDublicates",
	    value: function removeDublicates(sections) {
	      for (let i = 0; i < sections.length; i++) {
	        let priority = sections[i].priority;
	        sections.filter(function (section) {
	          return section.id === sections[i].id;
	        }).forEach(function (item, indx) {
	          if (indx === 0) {
	            return;
	          }
	          if (item.priority < priority) {
	            priority = item.priority;
	          }
	          sections.splice(sections.indexOf(item), 1);
	        });
	        sections[i].priority = priority;
	      }
	      return sections;
	    }
	  }, {
	    key: "prepareData",
	    value: function prepareData() {
	      let items = [];
	      items.push(...this.getOptions().items);
	      let sections = [];
	      sections.push(...this.getOptions().sections);
	      this.initField(sections, ["priority"]);
	      this.removeDublicates(sections);
	      this.initField(items, ["priority", "section", "type"]);
	      this.sortList(sections);
	      sections.push({
	        id: this.DEFAULT.section,
	        title: this.DEFAULT.sectionTitle
	      });
	      this.sortList(items);
	      this.sections = sections;
	      this.items = items;
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.menu) {
	        this.menu.$destroy();
	        this.menu = null;
	        clearInterval(this.interval);
	      }
	    }
	  }, {
	    key: "updateIndicator",
	    value: function updateIndicator(sectionId, itemId, state) {
	      this.updateSection(sectionId, function (section) {
	        section.indicator.state = state;
	      });
	      this.updateItem(itemId, function (item) {
	        item.indicator.state = state;
	      });
	    }
	  }, {
	    key: "updateTag",
	    value: function updateTag(sectionId, itemId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = tag;
	      });
	      this.updateItem(itemId, function (item) {
	        item.tag = tag;
	      });
	    }
	  }, {
	    key: "updateSectionTag",
	    value: function updateSectionTag(sectionId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = {
	          ...section.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateItemTag",
	    value: function updateItemTag(itemId, tag) {
	      this.updateItem(itemId, function (item) {
	        item.tag = {
	          ...item.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateSection",
	    value: function updateSection(sectionId, proc) {
	      if (this.sections && sectionId) {
	        for (let section in this.sections) {
	          if (this.sections[section].id !== sectionId) continue;
	          proc(this.sections[section]);
	        }
	        if (this.menu) {
	          this.menu.$set({
	            sections: this.sections
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateSectionItems",
	    value: function updateSectionItems(sectionId, proc) {
	      if (this.sections && sectionId) {
	        let oldList = this.items.filter(function (item) {
	          return item.section === sectionId;
	        });
	        for (let i of oldList) {
	          this.items.splice(this.items.indexOf(i), 1);
	        }
	        this.items.push(...proc(oldList));
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateItem",
	    value: function updateItem(itemId, proc) {
	      if (itemId && this.items) {
	        this.items.forEach(function (item) {
	          if (item.id !== itemId) return;
	          proc(item);
	        });
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "isTouch",
	    value: function isTouch() {
	      return UICommon$1.isMobile(true);
	    }
	  }, {
	    key: "getSectionComponent",
	    value: function getSectionComponent() {}
	  }]);
	}();
	_Menu = Menu;
	_defineProperty(Menu, "MAX_TOUCH_WIDTH", 1023);
	_defineProperty(Menu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  open: false
	});
	/**
	 *
	 * @type {import('../../app.js').default | null}
	 * @static
	 * @memberof Menu
	 */
	_defineProperty(Menu, "app", null);
	_defineProperty(Menu, "directNavigation", false);
	_defineProperty(Menu, "menu", void 0);
	_defineProperty(Menu, "options", {
	  directNavigation: false,
	  navigate: function (urls) {
	    _Menu.hide();
	    if (!_Menu.isDirectNavigation() && _Menu.app) {
	      let func = _Menu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});
	_defineProperty(Menu, "items", []);
	_defineProperty(Menu, "sections", []);
	_defineProperty(Menu, "location", void 0);
	_defineProperty(Menu, "interval", void 0);

	function onClick$4(ev, onnavigate) {
		ev.preventDefault();

		onnavigate()({
			full: ev.target.getAttribute("href"),
			short: ev.target.dataset.href
		});

		return false;
	}

	var root_2$2 = template(`<li><a> <!> <!></a></li>`);
	var root_5$1 = template(`<li> <!> <!></li>`);

	function Ui_item_without_children($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			item = prop($$props, 'item', 19, () => ({})),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var li = root_2$2();
				var a = child(li);

				a.__click = [onClick$4, onnavigate];

				var text = child(a);
				var node_1 = sibling(text);

				{
					var consequent = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_1, ($$render) => {
						if (item().tag) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_2, ($$render) => {
						if (item().indicator) $$render(consequent_1);
					});
				}

				reset(a);
				reset(li);

				template_effect(() => {
					set_class(li, clsx(item().classes));
					set_attribute(a, 'href', `${root() ?? ''}${item().url ?? ''}`);
					set_attribute(a, 'data-href', item().url);
					set_text(text, `${$LOCALE()[item().title] ?? ''} `);
				});

				append($$anchor, li);
			};

			var alternate = ($$anchor) => {
				var li_1 = root_5$1();
				var text_1 = child(li_1);
				var node_3 = sibling(text_1);

				{
					var consequent_3 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_3, ($$render) => {
						if (item().tag) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_4 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_4, ($$render) => {
						if (item().indicator) $$render(consequent_4);
					});
				}

				reset(li_1);

				template_effect(() => {
					set_class(li_1, `is-no-follow-subtitle ${item().classes ?? ''}`);
					set_text(text_1, `${$LOCALE()[item().title] ?? ''} `);
				});

				append($$anchor, li_1);
			};

			if_block(node, ($$render) => {
				if (typeof item().url !== "undefined" && item().url !== false) $$render(consequent_2); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	function onClick$3(e, closed, ontoggle) {
		e && e.preventDefault() && e.stopPropagation();
		closed(!closed());

		if (!ontoggle()(closed())) {
			closed(!closed());
		}

		return false;
	}

	var root$4 = template(`<span class="icon is-small is-toggle-submenu is-pulled-right" role="button" tabindex="0"><i aria-hidden="true"></i></span>`);

	function Ui_trigger($$anchor, $$props) {
		push($$props, true);

		const CLASS_ICON = {
			OPENED: "fa-angle-down",
			CLOSED: "fa-angle-up"
		};

		/**
		 * @typedef {Object} Props
		 * @property {any} [icon_opened]
		 * @property {any} [icon_closed]
		 * @property {boolean} [closed]    returns if we should apply toggle or if false - reject it and toggle backward
		 */
		/** @type {Props} */
		let icon_opened = prop($$props, 'icon_opened', 19, () => CLASS_ICON.OPENED),
			icon_closed = prop($$props, 'icon_closed', 19, () => CLASS_ICON.CLOSED),
			closed = prop($$props, 'closed', 7),
			ontoggle = prop($$props, 'ontoggle', 3, () => {
				return true;
			});

		var span = root$4();

		span.__click = [onClick$3, closed, ontoggle];
		span.__keyup = [onClick$3, closed, ontoggle];

		var i = child(span);

		reset(span);
		template_effect(() => set_class(i, `fas ${(closed() ? icon_closed() : icon_opened()) ?? ''}`));
		append($$anchor, span);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_4$2 = template(`<span class="is-no-link"> </span>`);
	var root$3 = template(`<!> <!> <!> <!>`, 1);

	function Ui_item_label($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let item = prop($$props, 'item', 19, () => ({}));
		var fragment = root$3();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, spread_props(() => item().icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent = derived(() => COMPONENTS$1.get(item().component));
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get id() {
										return item().id;
									}
								},
								() => item().props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var span = root_4$2();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[item().title]));
						append($$anchor, span);
					};

					if_block(
						node_1,
						($$render) => {
							if (item().type === "component" && item().component && COMPONENTS$1.contains(item().component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (item().icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().tag
				));
			};

			if_block(node_3, ($$render) => {
				if (item().tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().indicator
				));
			};

			if_block(node_4, ($$render) => {
				if (item().indicator) $$render(consequent_3);
			});
		}

		var node_5 = sibling(node_4, 2);

		snippet(node_5, () => $$props.children ?? noop);
		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function onClick$2(ev, onnavigate) {
		ev.preventDefault();

		onnavigate()({
			full: ev.target.getAttribute("href"),
			short: ev.target.dataset.href
		});

		return false;
	}

	var root_4$1 = template(`<a class="has-subitems"><!></a>`);
	var root_3$2 = template(`<li><!> <!></li>`);
	var root_1$3 = template(`<ul></ul>`);

	function Ui_items_1($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {boolean} [closed]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		const createClosedItemsLib = (lst) => {
			const lib = {};

			lst.forEach((itm, index) => lib[index] = itm.closed);
			return lib;
		};

		let closedChildren = proxy(createClosedItemsLib(items()));
		var ul = root_1$3();

		each(ul, 21, items, index$d, ($$anchor, item, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent_1 = ($$anchor) => {
					var li = root_3$2();
					var node_1 = child(li);

					{
						var consequent = ($$anchor) => {
							var a = root_4$1();

							a.__click = [onClick$2, onnavigate];

							var node_2 = child(a);

							Ui_item_label(node_2, {
								get item() {
									return get$3(item);
								},
								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},
										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},
								$$slots: { default: true }
							});

							reset(a);

							template_effect(() => {
								set_attribute(a, 'href', `${root() ?? ''}${get$3(item).url ?? ''}`);
								set_attribute(a, 'data-href', get$3(item).url);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							Ui_item_label($$anchor, {
								get item() {
									return get$3(item);
								},
								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},
										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},
								$$slots: { default: true }
							});
						};

						if_block(node_1, ($$render) => {
							if (typeof get$3(item).url !== "undefined" && get$3(item).url !== false) $$render(consequent); else $$render(alternate, false);
						});
					}

					var node_3 = sibling(node_1, 2);

					Ui_items_1(node_3, {
						get root() {
							return root();
						},
						get items() {
							return get$3(item).items;
						},
						get onnavigate() {
							return onnavigate();
						},
						get closed() {
							return closedChildren[index];
						},
						set closed($$value) {
							closedChildren[index] = $$value;
						}
					});

					reset(li);
					template_effect(() => set_class(li, `is-no-follow-subtitle ${get$3(item).classes ?? ''}`));
					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					Ui_item_without_children($$anchor, {
						get root() {
							return root();
						},
						get item() {
							return get$3(item);
						},
						get onnavigate() {
							return onnavigate();
						}
					});
				};

				if_block(node, ($$render) => {
					if (get$3(item).items && get$3(item).items.length) $$render(consequent_1); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		template_effect(() => set_class(ul, `menu-list ${($$props.closed ? 'is-closed' : '') ?? ''}`));
		append($$anchor, ul);
		pop();
	}

	delegate(['click']);

	var root_3$1 = template(`<p><!> <!> <!></p>`);
	var root_1$2 = template(`<!> <!>`, 1);

	function Ui_section$1($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {any}      section
		 * @property {any}      [items]
		 * @property {string}   [root]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		let sectionItems = derived(() => items().filter((item) => $$props.section.id === item.section));
		var fragment = root_1$2();
		var node = first_child(fragment);

		{
			var consequent_4 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_3 = ($$anchor) => {
						var p = root_3$1();
						var node_2 = child(p);

						{
							var consequent = ($$anchor) => {
								var fragment_2 = comment();
								const SvelteComponent = derived(() => COMPONENTS$1.get($$props.section.component));
								var node_3 = first_child(fragment_2);

								component(node_3, () => get$3(SvelteComponent), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get id() {
												return $$props.section.id;
											}
										},
										() => $$props.section.props
									));
								});

								append($$anchor, fragment_2);
							};

							var alternate = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[$$props.section.title]));
								append($$anchor, text$1);
							};

							if_block(node_2, ($$render) => {
								if ($$props.section.type === "component" && $$props.section.component && COMPONENTS$1.contains($$props.section.component)) $$render(consequent); else $$render(alternate, false);
							});
						}

						var node_4 = sibling(node_2, 2);

						{
							var consequent_1 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.tag
								));
							};

							if_block(node_4, ($$render) => {
								if ($$props.section.tag) $$render(consequent_1);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_2 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.indicator
								));
							};

							if_block(node_5, ($$render) => {
								if ($$props.section.indicator) $$render(consequent_2);
							});
						}

						reset(p);
						template_effect(() => set_class(p, `menu-label ${$$props.section.classes ?? ''}`));
						append($$anchor, p);
					};

					if_block(node_1, ($$render) => {
						if (get$3(sectionItems).length || $$props.section.component || $$props.section.tag || $$props.section.indicator) $$render(consequent_3);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.section) $$render(consequent_4);
			});
		}

		var node_6 = sibling(node, 2);

		{
			var consequent_5 = ($$anchor) => {
				Ui_items_1($$anchor, {
					get root() {
						return root();
					},
					get items() {
						return get$3(sectionItems);
					},
					get onnavigate() {
						return onnavigate();
					}
				});
			};

			if_block(node_6, ($$render) => {
				if (get$3(sectionItems).length) $$render(consequent_5);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_side_menu($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [sections]
		 * @property {any} [navigate = ()=>undefined]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			sections = prop($$props, 'sections', 19, () => []),
			navigate = prop($$props, 'navigate', 3, null);

		function onClick(ev) {
			if (typeof navigate() === "function") {
				navigate()(ev);
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, sections, index$d, ($$anchor, section) => {
			Ui_section$1($$anchor, {
				get section() {
					return get$3(section);
				},
				get items() {
					return items();
				},
				get root() {
					return root();
				},
				onnavigate: onClick
			});
		});

		append($$anchor, fragment);
		pop();
	}

	const SideMenuState = writable({
	  open: true
	});

	var _notSideMenu;
	const TYPE$1 = "side";
	let notSideMenu = /*#__PURE__*/function (_Menu) {
	  function notSideMenu() {
	    _classCallCheck(this, notSideMenu);
	    return _callSuper(this, notSideMenu, arguments);
	  }
	  _inherits(notSideMenu, _Menu);
	  return _createClass(notSideMenu, null, [{
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        this.createUI();
	      }
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.menu) {
	        this.menu.$destroy();
	        this.createUI();
	      }
	    }
	  }, {
	    key: "createUI",
	    value: function createUI() {
	      let target = document.querySelector(this.getOptions().targetSelector);
	      if (!target) {
	        return;
	      }
	      this.menu = mount(Ui_side_menu, {
	        target,
	        props: {
	          items: this.items,
	          sections: this.sections,
	          root: this.getOptions().root,
	          navigate: this.getOptions().navigate
	        }
	      });
	      this.initSizeResponse();
	      this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	      this.bindToggle();
	    }
	  }, {
	    key: "itemIsActive",
	    value: function itemIsActive(itemURL) {
	      return (this.location + "/").indexOf(itemURL + "/") > -1;
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu() {
	      var _this = this;
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " a")).forEach(function (item) {
	        if (_this.itemIsActive(item.getAttribute("href"))) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu();
	        }
	      } else {
	        this.location = url;
	        this.updateMenu();
	      }
	    }
	  }, {
	    key: "initSizeResponse",
	    value: function initSizeResponse() {
	      this.nav = document.querySelector("nav.navbar");
	      this.aside = document.querySelector("aside");
	      this.main = document.querySelector("main");
	      this.resizeAsideAndMain(this.aside, this.main, this.nav);
	      this.resizeMain(this.main, this.aside);
	      window.addEventListener("resize", this.resizeMain.bind(this));
	      if (this.isTouch()) {
	        if (this.getOptions().open) {
	          this.show();
	        } else {
	          this.hide();
	        }
	      }
	    }
	  }, {
	    key: "resizeMain",
	    value: function resizeMain() {
	      if (this.isTouch()) {
	        if (this.aside.classList.contains("is-active")) {
	          this.main.style.display = "none";
	        } else {
	          this.main.style.display = "block";
	          this.main.style.marginLeft = "0px";
	        }
	      } else {
	        let rect = this.aside.getBoundingClientRect();
	        this.main.style.display = "block";
	        if (this.main.style.height === "0px") {
	          this.main.style.height = "auto";
	        }
	        this.main.style.marginLeft = rect.width + rect.left + "px";
	      }
	    }
	  }, {
	    key: "resizeAside",
	    value: function resizeAside() {
	      if (this.aside.style.display !== "none") {
	        let rect = this.nav.getBoundingClientRect();
	        this.aside.style.height = window.innerHeight - rect.height + "px";
	        this.aside.style.marginTop = rect.height + "px";
	      }
	    }
	  }, {
	    key: "resizeAsideAndMain",
	    value: function resizeAsideAndMain() {
	      let rect = this.nav.getBoundingClientRect();
	      this.aside.style.height = window.innerHeight - rect.height + "px";
	      //this.aside.style.paddingTop = (rect.height) + 'px';
	      //this.main.style.marginTop = (rect.height) + 'px';
	    }
	  }, {
	    key: "bindToggle",
	    value: function bindToggle() {
	      var _this2 = this;
	      let els = document.querySelectorAll(this.getOptions().toggleSelector);
	      Array.from(els).forEach(function (el) {
	        el.removeEventListener("click", _this2.toggle.bind(_this2));
	        el.addEventListener("click", _this2.toggle.bind(_this2));
	      });
	    }
	  }, {
	    key: "toggle",
	    value: function toggle(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.toggle("is-active");
	        } else {
	          this.aside.classList.toggle("is-closed");
	        }
	        this.resizeMain();
	      }
	      return false;
	    }
	  }, {
	    key: "hide",
	    value: function hide(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.remove("is-active");
	        } else {
	          this.aside.classList.add("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = false;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "show",
	    value: function show(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.add("is-active");
	        } else {
	          this.aside.classList.remove("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = true;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "isOpen",
	    value: function isOpen() {
	      if (this.aside) {
	        if (this.isTouch()) {
	          return this.aside.classList.contains("is-active");
	        } else {
	          return !this.aside.classList.contains("is-closed");
	        }
	      } else {
	        return true;
	      }
	    }
	  }]);
	}(Menu);
	_notSideMenu = notSideMenu;
	_defineProperty(notSideMenu, "nav", void 0);
	_defineProperty(notSideMenu, "main", void 0);
	_defineProperty(notSideMenu, "aside", void 0);
	_defineProperty(notSideMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  open: true,
	  type: "link"
	});
	_defineProperty(notSideMenu, "options", {
	  directNavigation: false,
	  type: TYPE$1,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE$1}-menu`,
	  toggleSelector: `.${TYPE$1}-menu-toggle`,
	  root: "/",
	  open: true,
	  navigate: function (urls) {
	    if (_notSideMenu.isTouch()) {
	      _notSideMenu.hide();
	      _notSideMenu.app && _notSideMenu.app.emit("top-navbar-burger:update", {
	        closed: true
	      });
	    }
	    if (!_notSideMenu.isDirectNavigation() && _notSideMenu.app) {
	      let func = _notSideMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	var root$2 = template(`<a class="navbar-item"><!> <!></a>`);

	function Ui_brand($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [url]
		 * @property {string} [title]
		 * @property {any} [icon]
		 */
		/** @type {Props} */
		let url = prop($$props, 'url', 3, "/"),
			title = prop($$props, 'title', 3, ""),
			icon = prop($$props, 'icon', 19, () => ({
				src: "https://via.placeholder.com/56x28",
				width: 28,
				height: 56
			}));

		var a = root$2();
		var node = child(a);

		Ui_icon(node, spread_props(icon));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_2 = first_child(fragment);

				html(node_2, () => `<span class="navbar-item-brand-title">${title()}</span>`);
				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		reset(a);
		template_effect(() => set_attribute(a, 'href', url()));
		append($$anchor, a);
	}

	var root$1 = template(`<!> <!> <!>`, 1);

	function Ui_item_content($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		var fragment = root$1();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon($$anchor, spread_props(() => $$props.item.icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent = derived(() => COMPONENTS$1.get($$props.item.component));
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get id() {
										return $$props.item.id;
									}
								},
								() => $$props.item.props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, $LOCALE()[$$props.item.title]));
						append($$anchor, text$1);
					};

					if_block(
						node_1,
						($$render) => {
							if ($$props.item.type === 'component' && $$props.item.component && COMPONENTS$1.contains($$props.item.component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if ($$props.item.icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						top: true,
						right: true,
						size: 'small',
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.tag
				));
			};

			if_block(node_3, ($$render) => {
				if ($$props.item.tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.indicator
				));
			};

			if_block(node_4, ($$render) => {
				if ($$props.item.indicator) $$render(consequent_3);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function onClick$1(event, dispatch, item) {
		dispatch("click", { event, element: item() });
	}

	var root_2$1 = template(`<hr>`);
	var root_3 = template(`<a><!></a>`);
	var root_4 = template(`<div role="button" tabindex="0"><!></div>`);
	var root_1$1 = template(`<!> <!>`, 1);

	function Ui_item($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 * @property {string} [hidden]
		 * @property {string} [classes]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			item = prop($$props, 'item', 19, () => ({})),
			hidden = prop($$props, 'hidden', 3, ""),
			classes = prop($$props, 'classes', 3, "");

		var fragment = root_1$1();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var hr = root_2$1();

				template_effect(() => set_class(hr, `navbar-divider ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `));
				append($$anchor, hr);
			};

			if_block(node, ($$render) => {
				if (item().break) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var a = root_3();

				a.__click = [onClick$1, dispatch, item];

				var node_2 = child(a);

				Ui_item_content(node_2, {
					get item() {
						return item();
					}
				});

				reset(a);

				template_effect(() => {
					set_class(a, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} ${item().classes ?? ''} ${classes() ?? ''} `);
					set_attribute(a, 'href', `${root() ?? ''}${item().url ?? ''}`);
					set_attribute(a, 'data-href', item().url);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				var div = root_4();

				div.__click = [onClick$1, dispatch, item];
				div.__keyup = [onClick$1, dispatch, item];

				var node_3 = child(div);

				Ui_item_content(node_3, {
					get item() {
						return item();
					}
				});

				reset(div);
				template_effect(() => set_class(div, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} ${item().classes ?? ''} ${classes() ?? ''}`));
				append($$anchor, div);
			};

			if_block(node_1, ($$render) => {
				if (item().url) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	function onClick(event, dispatch, section) {
		dispatch("click", { event, element: section() });
	}

	var root_2 = template(`<div><a href=""><!></a> <div></div></div>`);
	var root_5 = template(`<a><!></a>`);
	var root_6 = template(`<div role="button" tabindex="0"><!></div>`);

	function Ui_section($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [section]
		 * @property {any} [items]
		 * @property {string} [hidden]
		 * @property {boolean} [hoverable]
		 * @property {boolean} [arrowless]
		 * @property {boolean} [right]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			section = prop($$props, 'section', 19, () => ({})),
			items = prop($$props, 'items', 19, () => []),
			hidden = prop($$props, 'hidden', 3, ""),
			hoverable = prop($$props, 'hoverable', 3, true),
			arrowless = prop($$props, 'arrowless', 3, false),
			right = prop($$props, 'right', 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_2();
				var a = child(div);

				a.__click = [onClick, dispatch, section];

				var node_1 = child(a);

				Ui_item_content(node_1, {
					get item() {
						return section();
					}
				});

				reset(a);

				var div_1 = sibling(a, 2);

				each(div_1, 21, items, (item) => item.id, ($$anchor, item) => {
					Ui_item($$anchor, {
						get root() {
							return root();
						},
						get item() {
							return get$3(item);
						},
						$$events: {
							click($$arg) {
								bubble_event.call(this, $$props, $$arg);
							}
						}
					});
				});

				reset(div_1);
				reset(div);

				template_effect(() => {
					set_class(div, `navbar-item has-dropdown ${(hoverable() ? 'is-hoverable' : '') ?? ''} ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `);
					set_class(a, `navbar-link ${(arrowless() ? 'is-arrowless' : '') ?? ''}`);
					set_class(div_1, `navbar-dropdown ${(right() ? 'is-right' : '') ?? ''}`);
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_2 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var a_1 = root_5();

						a_1.__click = [onClick, dispatch, section];

						var node_3 = child(a_1);

						Ui_item_content(node_3, {
							get item() {
								return section();
							}
						});

						reset(a_1);

						template_effect(() => {
							set_class(a_1, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `);
							set_attribute(a_1, 'href', `${root() ?? ''}${section().url ?? ''}`);
							set_attribute(a_1, 'data-href', section().url);
						});

						append($$anchor, a_1);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_6();

						div_2.__click = [onClick, dispatch, section];
						div_2.__keyup = [onClick, dispatch, section];

						var node_4 = child(div_2);

						Ui_item_content(node_4, {
							get item() {
								return section();
							}
						});

						reset(div_2);
						template_effect(() => set_class(div_2, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `));
						append($$anchor, div_2);
					};

					if_block(
						node_2,
						($$render) => {
							if (section().url) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	function toggle(e, closed, dispatch) {
		e.preventDefault();
		closed(!closed());
		dispatch("toggle", { closed: closed() });
		return false;
	}

	var root = template(`<a href="" role="button" aria-label="menu" aria-expanded="false" data-target="navbar"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a>`);

	function Ui_burger($$anchor, $$props) {
		push($$props, true);

		const COMPONENT_NAME = "top-navbar-burger";
		const dispatch = createEventDispatcher();

		function getStandartUpdateEventName() {
			return COMPONENT_NAME + ":update";
		}

		/**
		 * @typedef {Object} Props
		 * @property {any} [events]
		 * @property {any} [register]
		 * @property {boolean} [closed]
		 * @property {any} [onUpdate]
		 */
		/** @type {Props} */
		let events = prop($$props, 'events', 31, () => proxy({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			closed = prop($$props, 'closed', 15, true),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				closed(data.closed);
			});

		onMount(() => {
			if (!notCommon$1.objHas(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		SideMenuState.subscribe((val) => {
			closed(!val.open);
			return val;
		});

		var a = root();

		a.__click = [toggle, closed, dispatch];
		template_effect(() => set_class(a, `navbar-burger ${(closed() ? '' : 'is-active') ?? ''}`));
		append($$anchor, a);
		pop();
	}

	delegate(['click']);

	var root_1 = template(`<div class="navbar-brand"><!> <!> <!> <!></div> <div id="navbar"><div class="navbar-start"></div> <div class="navbar-end"></div></div>`, 1);

	function Ui_top($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} [sections] - import { beforeUpdate } from "svelte";
		 * @property {any} [items]
		 * @property {string} [root]
		 * @property {any} [navigate]
		 * @property {boolean} [brand]
		 * @property {boolean} [showBurger]
		 * @property {boolean} [burgerControlsSidemenu]
		 */
		/** @type {Props} */
		let sections = prop($$props, 'sections', 19, () => []),
			items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			navigate = prop($$props, 'navigate', 3, null),
			brand = prop($$props, 'brand', 3, false),
			showBurger = prop($$props, 'showBurger', 3, true),
			burgerControlsSidemenu = prop($$props, 'burgerControlsSidemenu', 3, true);

		let menuClosed = state(true);

		function onClick({ detail }) {
			let { event, element } = detail;

			if (Object.hasOwn(element, "action")) {
				return element.action(event, element);
			}

			event.preventDefault();

			if (typeof navigate() === "function") {
				navigate()({
					full: event.currentTarget.getAttribute("href"),
					short: event.currentTarget.dataset.href
				});
			}

			return false;
		}

		let sectionsItemsCount = {};
		let sectionsItems = {};

		/*
		beforeUpdate(() => {
		    for (let section of sections) {
		        sectionsItems[section.id] = items.filter(
		            (t) => t.section === section.id
		        );
		        sectionsItemsCount[section.id] = items.filter(
		            (t) => t.section === section.id
		        ).length;
		    }
		});
		*/
		function toggleBurger({ detail }) {
			if (burgerControlsSidemenu()) {
				notSideMenu.toggle();
			} else {
				dispatch("toggleBurger", detail);
				set(menuClosed, proxy(detail.closed));
			}
		}

		var fragment = root_1();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_brand($$anchor, spread_props(brand));
			};

			if_block(node, ($$render) => {
				if (brand()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		each(node_1, 17, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_2 = comment();
			var node_2 = first_child(fragment_2);

			{
				var consequent_1 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'desktop',
						get item() {
							return get$3(section);
						},
						get root() {
							return root();
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_2, ($$render) => {
					if (get$3(section).showOnTouch) $$render(consequent_1);
				});
			}

			append($$anchor, fragment_2);
		});

		var node_3 = sibling(node_1, 2);

		each(node_3, 17, items, (item) => item.id, ($$anchor, item) => {
			var fragment_4 = comment();
			var node_4 = first_child(fragment_4);

			{
				var consequent_2 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'desktop',
						get item() {
							return get$3(item);
						},
						get root() {
							return root();
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_4, ($$render) => {
					if (get$3(item).showOnTouch) $$render(consequent_2);
				});
			}

			append($$anchor, fragment_4);
		});

		var node_5 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_burger($$anchor, { $$events: { toggle: toggleBurger } });
			};

			if_block(node_5, ($$render) => {
				if (showBurger()) $$render(consequent_3);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var div_2 = child(div_1);

		each(div_2, 21, items, index$d, ($$anchor, item) => {
			var fragment_7 = comment();
			var node_6 = first_child(fragment_7);

			{
				var consequent_4 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'touch',
						get item() {
							return get$3(item);
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_6, ($$render) => {
					if (get$3(item).place === "start") $$render(consequent_4);
				});
			}

			append($$anchor, fragment_7);
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);

		each(div_3, 21, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_9 = comment();
			var node_7 = first_child(fragment_9);

			{
				var consequent_5 = ($$anchor) => {
					Ui_section($$anchor, {
						right: true,
						get hidden() {
							return get$3(section).hidden;
						},
						get root() {
							return root();
						},
						get section() {
							return get$3(section);
						},
						get items() {
							return sectionsItems[get$3(section).id];
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_7, ($$render) => {
					if ((sectionsItemsCount[get$3(section).id] || get$3(section).indicator || get$3(section).tag) && get$3(section).place == "end") $$render(consequent_5);
				});
			}

			append($$anchor, fragment_9);
		});

		reset(div_3);
		reset(div_1);
		template_effect(() => set_class(div_1, `navbar-menu ${(get$3(menuClosed) ? '' : 'is-active') ?? ''}`));
		append($$anchor, fragment);
		pop();
	}

	var _notTopMenu;
	const TYPE = "top";
	let notTopMenu = /*#__PURE__*/function (_Menu) {
	  function notTopMenu() {
	    _classCallCheck(this, notTopMenu);
	    return _callSuper(this, notTopMenu, arguments);
	  }
	  _inherits(notTopMenu, _Menu);
	  return _createClass(notTopMenu, null, [{
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        let target = document.querySelector(this.getOptions().targetSelector);
	        if (!target) {
	          return;
	        }
	        this.menu = mount(Ui_top, {
	          target,
	          props: {
	            brand: this.getOptions().brand,
	            items: this.items,
	            sections: this.sections,
	            root: this.getOptions().root,
	            navigate: this.getOptions().navigate
	          }
	        });
	        this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	      }
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu(url) {
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " aside.menu a")).forEach(function (item) {
	        if (item.href == url || url.href && url.href.indexOf(item.href) == 0) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu(url);
	        }
	      } else {
	        this.location = url;
	        this.updateMenu(url);
	      }
	    }
	  }, {
	    key: "toggle",
	    value: function toggle() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.toggle("is-active");
	    }
	  }, {
	    key: "hide",
	    value: function hide() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.remove("is-active");
	    }
	  }, {
	    key: "setBurgerState",
	    value: function setBurgerState(menuClosed) {
	      this.menu.$set({
	        menuClosed
	      });
	    }
	  }]);
	}(Menu);
	_notTopMenu = notTopMenu;
	_defineProperty(notTopMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  place: "main"
	});
	_defineProperty(notTopMenu, "options", {
	  brand: false,
	  type: TYPE,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE}-menu`,
	  root: "/",
	  directNavigation: false,
	  navigate: function (urls) {
	    _notTopMenu.hide();
	    if (!_notTopMenu.isDirectNavigation() && _notTopMenu.app) {
	      let func = _notTopMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	const DEFAULT_TRASFORMER = function (res) {
	  // @ts-ignore
	  return Object.hasOwn(res, "status") && Object.hasOwn(res, "result") ? res.result : res;
	};

	var create_crud_action_ui_view = (function ({
	  ACTION,
	  TITLE,
	  UIConstructor,
	  dataProvider,
	  goBack
	}) {
	  return /*#__PURE__*/function () {
	    function _class() {
	      _classCallCheck(this, _class);
	    }
	    return _createClass(_class, null, [{
	      key: "run",
	      value: async function run(controller, params) {
	        try {
	          controller.setBreadcrumbs([{
	            title: `Просмотр "${TITLE}"`
	          }]);
	          await controller.preloadVariants(ACTION);
	          if (controller.ui[ACTION]) {
	            return;
	          } else {
	            controller.$destroyUI();
	          }
	          let data = {};
	          if (dataProvider) {
	            if (notCommon$1.isFunc(dataProvider)) {
	              if (notCommon$1.isAsync(dataProvider)) {
	                data = await dataProvider(params);
	              } else {
	                data = dataProvider(params);
	              }
	            } else {
	              data = {
	                ...dataProvider
	              };
	            }
	          }
	          const resultTransformer = controller.getOptions(`${ACTION}.transformer`, DEFAULT_TRASFORMER);
	          controller.ui[ACTION] = new UIConstructor({
	            target: controller.getContainerInnerElement(),
	            props: {
	              params,
	              ...resultTransformer(data)
	            }
	          });
	          controller.emit(`after:render:${ACTION}`);
	          if (goBack && notCommon$1.isFunc(goBack)) {
	            controller.ui[ACTION].on("reject", function () {
	              return goBack();
	            });
	          }
	        } catch (e) {
	          controller.report(e);
	          controller.showErrorMessage(e);
	        }
	      }
	    }]);
	  }();
	});

	const PRELOADABLE = ["create", "update", "list", "delete", "details"];
	let CRUDVariantsPreloader = /*#__PURE__*/function () {
	  function CRUDVariantsPreloader() {
	    _classCallCheck(this, CRUDVariantsPreloader);
	  }
	  return _createClass(CRUDVariantsPreloader, null, [{
	    key: "preload",
	    value: async function preload(controller, type = "list") {
	      try {
	        if (!PRELOADABLE.includes(type)) {
	          return;
	        }
	        let preload = controller.getOptions(`${type}.preload`, {});
	        if (Object.keys(preload).length == 0) {
	          preload = controller.getOptions(`preload`, {});
	        }
	        if (Object.keys(preload).length > 0) {
	          let libProps = Object.keys(preload);
	          let proms = [];
	          libProps.forEach(function (prop) {
	            let modelName = notCommon$1.lowerFirstLetter(preload[prop]);
	            let Model = controller.make[modelName]({});
	            proms.push(Model.$listAll());
	          });
	          let results = await Promise.all(proms);
	          for (let i = 0; i < libProps.length; i++) {
	            const propName = libProps[i];
	            if (results[i].status === "ok" && Array.isArray(results[i].result)) {
	              const resultsList = results[i].result;
	              const variants = resultsList.map(function (item) {
	                return {
	                  id: item._id,
	                  title: item.title
	                };
	              });
	              controller.setOptions(`variants.${type}.${propName}`, variants);
	            }
	          }
	        }
	        controller.log("preload finished");
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const DEFAULT_ACTION = "list";
	let notCRUDRouter = /*#__PURE__*/function () {
	  function notCRUDRouter() {
	    _classCallCheck(this, notCRUDRouter);
	  }
	  return _createClass(notCRUDRouter, null, [{
	    key: "extractActionName",
	    value: function extractActionName(controller, params) {
	      let actionName = DEFAULT_ACTION;
	      if (params.length === 1) {
	        if (params[0] === "create") {
	          actionName = "create";
	        } else if (controller.actionHandlerExists(params[0])) {
	          actionName = params[0];
	        } else {
	          actionName = "details";
	        }
	      } else if (params.length > 1) {
	        if (params[1] === "delete") {
	          actionName = "delete";
	        } else if (params[1] === "update") {
	          actionName = "update";
	        } else {
	          actionName = params[1];
	        }
	      }
	      return actionName;
	    }
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = notCRUDRouter.extractActionName(controller, params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	let CRUDMessage = /*#__PURE__*/function () {
	  function CRUDMessage() {
	    _classCallCheck(this, CRUDMessage);
	  }
	  return _createClass(CRUDMessage, null, [{
	    key: "error",
	    value: function error(controller, title, message) {
	      controller.setUI("__message__", new Ui_error({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }, {
	    key: "success",
	    value: function success(controller, title, message) {
	      controller.setUI("__message__", new Ui_success({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }]);
	}();

	const DEFAULT_BREADCRUMB_TAIL$2 = "Просмотр";

	/**
	 * Generic CRUD action class
	 * @class
	 */
	let CRUDGenericAction = /*#__PURE__*/function () {
	  function CRUDGenericAction() {
	    _classCallCheck(this, CRUDGenericAction);
	  }
	  return _createClass(CRUDGenericAction, null, [{
	    key: "NAVIGATION_DELAY",
	    get: function () {
	      return NAVIGATION_DELAY_DEFAULT;
	    }
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	  }, {
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$2;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL$2,
	        set: 'Просмотр, "{:title}"'
	      };
	    }

	    /**
	     * Returns template of breadcrumbs tail
	     * @param   {string}    name
	     * @returns {string}    template string
	     */
	  }, {
	    key: "getBreadcrumbsTail",
	    value: function getBreadcrumbsTail(name) {
	      if (!this.breadcrumbsTails) {
	        return "";
	      }
	      return notCommon$1.select(this.breadcrumbsTails, name, this.deafultBreadcrumbsTail);
	    }
	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "details";
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {object} UIConstructor    constructor of UI component
	     */
	  }, {
	    key: "UIConstructor",
	    get: function () {
	      return notForm;
	    }
	    /**
	     * @static {function}   TRANSFORMER     response.result transformation function if want to change it's structure
	     */
	  }, {
	    key: "TRANSFORMER",
	    get: function () {
	      return DEFAULT_TRASFORMER;
	    }
	    /**
	     * Returns name of model identificaiton field
	     * @param {object} controller instance of controller
	     * @returns {string}    default id field name is '_id'
	     */
	  }, {
	    key: "getIdField",
	    value: function getIdField(controller) {
	      return controller.getOptions(`${this.ACTION}.idField`, "_id");
	    }
	  }, {
	    key: "loadDataQuery",
	    value: function loadDataQuery(controller, params) {
	      const idField = this.getIdField(controller);
	      return {
	        [idField]: params[0]
	      };
	    }

	    /**
	     * Return Promise of API reponse
	     * @param {object} controller instance of controller
	     * @param {string[]} params     array of strings parsed from URI by router and passed to controller
	     * @returns {Promise}   API response {status:string, result:any, message:string, errors: {[fieldname]:[...errorMessages]}}
	     */
	  }, {
	    key: "loadData",
	    value: async function loadData(controller, params) {
	      const query = this.loadDataQuery(controller, params);
	      const actionName = this.getModelActionName(controller);
	      return await controller.getModel(query)[`$${actionName}`]();
	    }

	    /**
	     * Returns model API action name
	     * @param {object} controller instance of controller
	     * @returns {string}    network interface model action name, for API; default: this.MODEL_ACTION_GET
	     */
	  }, {
	    key: "getModelActionName",
	    value: function getModelActionName(controller) {
	      return controller.getOptions(`${this.ACTION}.actionName`, this.MODEL_ACTION_GET);
	    }

	    /**
	     * Sets breadcrumbs tail, without result details
	     * @param {object} controller instance of controller
	     * @param {string[]} params     list of route params
	     */
	  }, {
	    key: "presetBreadcrumbs",
	    value: function presetBreadcrumbs(controller, params) {
	      controller.setBreadcrumbs([{
	        title: this.getBreadcrumbsTail("preset"),
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response.result);
	    }

	    /**
	     * Sets breadcrumbs tail with response details, aka title of loaded item
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response in wrapper
	     * @param {object} response.result  API response result
	     */
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(controller, params, response) {
	      const title = this.getTitle(controller, params, response);
	      const breadcrumbsTailTemplate = this.getBreadcrumbsTail("set");
	      controller.setBreadcrumbs([{
	        title: breadcrumbsTailTemplate ? notLocale$1.format(breadcrumbsTailTemplate, {
	          title
	        }) : title,
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }

	    /**
	     * Checks response on success
	     * @param {object} response
	     * @param {string} response.status
	     * @returns {boolean}   true if response is bad
	     */
	  }, {
	    key: "isResponseBad",
	    value: function isResponseBad(response) {
	      return !response || response.status !== "ok";
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators(controller) {
	      return controller.getValidators && controller.getValidators() || controller.getOptions("Validators");
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const detailsActionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: detailsActionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          fields: {
	            readonly: true
	          },
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	          injected: controller.getOptions(`${this.ACTION}.injected`, {})
	        },
	        data: this.TRANSFORMER(response.result)
	      };
	    }

	    /**
	     * Returns instance of this action UI component from controller
	     * @param {object} controller   instance of controller
	     * @returns {object}    instance of UI component
	     */
	  }, {
	    key: "getUI",
	    value: function getUI(controller) {
	      return controller.getUI(this.ACTION);
	    }

	    /**
	     * Sets UI of this action in controller
	     * @param {object} controller   instance of controller
	     * @param {object} ui           instance of UI component
	     */
	  }, {
	    key: "setUI",
	    value: function setUI(controller, ui) {
	      controller.setUI(this.ACTION, ui);
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `true`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoading",
	    value: function setUILoading(controller) {
	      this.getUI(controller).$set({
	        loading: true
	      });
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `false`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoaded",
	    value: function setUILoaded(controller) {
	      this.getUI(controller).$set({
	        loading: false
	      });
	    }

	    /**
	     *  Sets via `.$set` method `error` to `message`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @param   {Error} message     error message
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUIError",
	    value: function setUIError(controller, message) {
	      this.getUI(controller).$set({
	        error: message
	      });
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return controller.goBack();
	        });
	      }
	    }

	    /**
	     * Bind event handler named event to UI. Checks different binder notation $on/on
	     * @param {object} controller   instance of controller
	     * @param {string} event        event name
	     * @param {function} callback   callback function on event
	     * @returns
	     */
	  }, {
	    key: "bindUIEvent",
	    value: function bindUIEvent(controller, event, callback) {
	      const ui = this.getUI(controller);
	      if (ui.$on) {
	        return ui.$on(event, callback);
	      }
	      if (ui.on) {
	        return ui.on(event, callback);
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }
	  }, {
	    key: "createUI",
	    value: function createUI(uiComponent, controller, response) {
	      if (notCommon$1.isFunc(uiComponent)) {
	        return mount(uiComponent, this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      } else {
	        return new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      }
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        //eslint-disable-next-line no-unused-vars
	        const uiComponent = this.UIConstructor;
	        //eslint-disable-next-line no-unused-vars
	        const ui = this.createUI();
	        this.setUI(controller);
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "goBackAfterDelay",
	    value: function goBackAfterDelay(controller) {
	      controller.goBack(this.NAVIGATION_DELAY);
	    }
	  }, {
	    key: "goBack",
	    value: function goBack(controller) {
	      controller.goBack(0);
	    }
	  }]);
	}();

	const ACTION$2 = "create";
	const DEFAULT_BREADCRUMB_TAIL$1 = "Создание";
	let CRUDGenericActionCreate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionCreate() {
	    _classCallCheck(this, CRUDGenericActionCreate);
	    return _callSuper(this, CRUDGenericActionCreate, arguments);
	  }
	  _inherits(CRUDGenericActionCreate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionCreate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$1;
	    }
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return undefined;
	    }
	  }, {
	    key: "ACTION",
	    get: function () {
	      return ACTION$2;
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     *
	     * @param {import('../../controller.crud')} controller
	     * @param {any}                         [params]
	     * @returns {import('not-node/src/types').notAppResponse}
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "loadData",
	    value: function loadData(controller, params = {}) {
	      let defData = controller.createDefault();
	      if (defData.getData) {
	        defData = defData.getData();
	      }
	      return {
	        status: "ok",
	        result: defData
	      };
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response);
	    }
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const actionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: actionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(response)
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	let CRUDActionCreate = /*#__PURE__*/function (_CRUDGenericActionCre) {
	  function CRUDActionCreate() {
	    _classCallCheck(this, CRUDActionCreate);
	    return _callSuper(this, CRUDActionCreate, arguments);
	  }
	  _inherits(CRUDActionCreate, _CRUDGenericActionCre);
	  return _createClass(CRUDActionCreate);
	}(CRUDGenericActionCreate);

	/**
	 * Generic CRUD Details action class
	 * @class
	 */
	let CRUDGenericActionRead = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionRead() {
	    _classCallCheck(this, CRUDGenericActionRead);
	    return _callSuper(this, CRUDGenericActionRead, arguments);
	  }
	  _inherits(CRUDGenericActionRead, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionRead, null, [{
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      options.options.ui = {
	        submit: {
	          enabled: false
	        }
	      };
	      return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action details
	 */
	let CRUDActionDetails = /*#__PURE__*/function (_CRUDGenericActionRea) {
	  function CRUDActionDetails() {
	    _classCallCheck(this, CRUDActionDetails);
	    return _callSuper(this, CRUDActionDetails, arguments);
	  }
	  _inherits(CRUDActionDetails, _CRUDGenericActionRea);
	  return _createClass(CRUDActionDetails);
	}(CRUDGenericActionRead);

	const DEFAULT_BREADCRUMB_TAIL = "Редактирование";
	/**
	 * Generic CRUD Update action class
	 * @class
	 */
	let CRUDGenericActionUpdate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionUpdate() {
	    _classCallCheck(this, CRUDGenericActionUpdate);
	    return _callSuper(this, CRUDGenericActionUpdate, arguments);
	  }
	  _inherits(CRUDGenericActionUpdate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionUpdate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get:
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    function () {
	      return DEFAULT_BREADCRUMB_TAIL;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL,
	        set: `${DEFAULT_BREADCRUMB_TAIL}: "{:title}"`
	      };
	    }

	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "update";
	    }

	    /**
	     * @static {string} MODEL_ACTION_GET    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "getRaw";
	    }

	    /**
	     * @static {string} MODEL_ACTION_PUT    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "update";
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: this.MODEL_ACTION_PUT,
	          //will be used to get form fields information from manifest
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          ui: controller.getOptions(`${this.ACTION}.ui`, {}),
	          fields: controller.getOptions(`${this.ACTION}.fields`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(notCommon$1.stripProxy(response.result))
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, [params]);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action update
	 */
	let CRUDActionUpdate = /*#__PURE__*/function (_CRUDGenericActionUpd) {
	  function CRUDActionUpdate() {
	    _classCallCheck(this, CRUDActionUpdate);
	    return _callSuper(this, CRUDActionUpdate, arguments);
	  }
	  _inherits(CRUDActionUpdate, _CRUDGenericActionUpd);
	  return _createClass(CRUDActionUpdate);
	}(CRUDGenericActionUpdate);

	const ACTION$1 = "delete";
	const MODEL_ACTION = "delete";
	let CRUDActionDelete = /*#__PURE__*/function () {
	  function CRUDActionDelete() {
	    _classCallCheck(this, CRUDActionDelete);
	  }
	  return _createClass(CRUDActionDelete, null, [{
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        if (controller.ui[ACTION$1]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION$1] = new notActionUI({
	          name: "CRUDDelete",
	          target: controller.getContainerInnerElement(),
	          options: {
	            loaderActive: true,
	            loaderStyle: "container",
	            loaderTitle: "not-node:crud_delete_action_waiting",
	            container: {
	              id: `crud-delete-action-${params[0]}`
	            }
	          }
	        });
	        controller.setBreadcrumbs([{
	          title: "Удаление",
	          url: controller.getModelActionURL(params[0], ACTION$1)
	        }]);
	        if (confirm("Удалить запись?")) {
	          const deleteActionName = controller.getOptions(`${ACTION$1}.actionName`, MODEL_ACTION);
	          const success = await controller.onActionSubmit(deleteActionName, {
	            _id: params[0]
	          });
	          if (success) {
	            controller.goList();
	          }
	          return;
	        }
	        controller.goList();
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const ACTION = "list";
	let CRUDActionList = /*#__PURE__*/function () {
	  function CRUDActionList() {
	    _classCallCheck(this, CRUDActionList);
	  }
	  return _createClass(CRUDActionList, null, [{
	    key: "tweakActionsList",
	    value: function tweakActionsList(controller, ACTIONS_LIST) {
	      if (controller.getOptions(`${ACTION}.createAction`, true)) {
	        ACTIONS_LIST.push({
	          title: "Создать",
	          action: function () {
	            return controller.goCreate();
	          }
	        });
	      }
	      return ACTIONS_LIST;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../controller.crud').default} controller
	     * @param {string} value
	     * @param {number} [delay=0]
	     * @param {Array<string>} [actions=["details", "update", "delete"]]
	     * @param {Array<object>} [prepend=[]]
	     * @param {Array<object>} [append=[]]
	     * @param {boolean} [onlyIcons=true]
	     * @return {Array<object>}
	     * @memberof CRUDActionList
	     */
	  }, {
	    key: "createActionsButtons",
	    value: function createActionsButtons(controller, value, delay = 0, actions = ["details", "update", "delete"], prepend = [], append = [], onlyIcons = true) {
	      const ACTIONS = {
	        details: {
	          action: function () {
	            return controller.goDetails(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "circle-info"
	          } : {
	            title: "Подробнее"
	          }),
	          size: "small"
	        },
	        update: {
	          action: function () {
	            return controller.goUpdate(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "edit"
	          } : {
	            title: "Изменить"
	          }),
	          color: "warning",
	          size: "small"
	        },
	        delete: {
	          action: function () {
	            return controller.goDelete(value, delay);
	          },
	          color: "danger",
	          ...(onlyIcons ? {
	            icon: "trash"
	          } : {
	            title: "Удалить"
	          }),
	          size: "small",
	          style: "outlined"
	        }
	      };
	      const actionsButtons = [...prepend];
	      if (Array.isArray(actions)) {
	        actions.forEach(function (actionName) {
	          return actionsButtons.push(ACTIONS[actionName]);
	        });
	      }
	      actionsButtons.push(...append);
	      return actionsButtons;
	    }
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        await controller.preloadVariants(ACTION);
	        controller.setBreadcrumbs([{
	          title: "Список",
	          url: controller.getModelURL()
	        }]);
	        if (controller.ui[ACTION]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION] = new notTable(this.tweakUIOptions(CRUDActionList.prepareOptions(controller)));
	        controller.emit(`after:render:${ACTION}`, params, controller.ui[ACTION]);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${ACTION}`, params, e);
	        controller.report(e);
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "prepareOptions",
	    value: function prepareOptions(controller) {
	      const DEFAULT_OPTIONS_TABLE = {
	        interface: controller.getOptions(`${ACTION}.interface`, {
	          combined: true,
	          factory: controller.getInterface()
	        }),
	        fields: undefined,
	        showSelect: undefined,
	        getItemId: undefined,
	        idField: undefined,
	        preload: {},
	        filterUI: controller.getOptions(`${ACTION}.filterUI`),
	        pager: {
	          size: 50,
	          page: 0
	        },
	        sorter: {
	          id: -1
	        },
	        filter: undefined,
	        ui: undefined
	      };
	      //forming actions buttons list
	      let ACTIONS_LIST = [...controller.getOptions(`${ACTION}.actions`, [])];
	      ACTIONS_LIST = this.tweakActionsList(controller, ACTIONS_LIST);
	      //
	      const TABLE_OPTIONS = {
	        options: {
	          targetEl: controller.getContainerInnerElement(),
	          endless: false,
	          actions: ACTIONS_LIST
	        }
	      };
	      Object.keys(DEFAULT_OPTIONS_TABLE).forEach(function (key) {
	        let optVal = controller.getOptions(`${ACTION}.${key}`, DEFAULT_OPTIONS_TABLE[key]);
	        if (typeof optVal !== "undefined") {
	          TABLE_OPTIONS.options[key] = optVal;
	        }
	      });
	      return TABLE_OPTIONS;
	    }
	  }]);
	}();

	var CRUDActions = {
	  create: CRUDActionCreate,
	  details: CRUDActionDetails,
	  update: CRUDActionUpdate,
	  delete: CRUDActionDelete,
	  list: CRUDActionList
	};

	const BREADCRUMBS = [];
	const TITLE_FIELDS_PRIORITY = ["title", "label", "id", "name"];
	const LOADING_SCREEN_UI_NAME = "loading_screen";
	var _actions = /*#__PURE__*/new WeakMap();
	var _router = /*#__PURE__*/new WeakMap();
	var _preloader = /*#__PURE__*/new WeakMap();
	let notCRUD = /*#__PURE__*/function (_notController) {
	  function notCRUD(app, name, {
	    actions,
	    router,
	    preloader
	  } = {
	    actions: undefined,
	    router: undefined,
	    preloader: undefined
	  }) {
	    var _this;
	    _classCallCheck(this, notCRUD);
	    _this = _callSuper(this, notCRUD, [app, `CRUD.${name}`]);
	    _classPrivateFieldInitSpec(_this, _actions, {
	      ...CRUDActions
	    });
	    _classPrivateFieldInitSpec(_this, _router, notCRUDRouter);
	    _classPrivateFieldInitSpec(_this, _preloader, CRUDVariantsPreloader);
	    _defineProperty(_this, "TITLE_FIELDS_PRIORITY", TITLE_FIELDS_PRIORITY);
	    _defineProperty(_this, "TOP_CLASS", ["box"]);
	    _defineProperty(_this, "MAIN_CLASS", ["box"]);
	    _defineProperty(_this, "BOTTOM_CLASS", ["box"]);
	    _defineProperty(_this, "WS_CHECK_INTERVAL", 200);
	    if (actions) {
	      // @ts-ignore
	      _classPrivateFieldSet2(_actions, _this, {
	        ..._classPrivateFieldGet2(_actions, _this),
	        ...actions
	      });
	    }
	    if (router) {
	      _classPrivateFieldSet2(_router, _this, router);
	    }
	    if (preloader) {
	      _classPrivateFieldSet2(_preloader, _this, preloader);
	    }
	    _this.ui = {};
	    _this.els = {};
	    _this.setOptions("names", {
	      module: "",
	      plural: "plural",
	      single: "single"
	    });
	    _this.setOptions("containerSelector", _this.app?.getOptions("crud.containerSelector"));
	    _this.buildFrame();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notCRUD, _notController);
	  return _createClass(notCRUD, [{
	    key: "setValidators",
	    value: function setValidators(validators) {
	      //not-module-name -> [not,module,name]
	      const ModuleNameParts = this.getModuleName().split("-");
	      //[not,module,name] -> ModuleName
	      const ModuleName = (ModuleNameParts[0] === "not" ? ModuleNameParts.splice(1) : ModuleNameParts).map(notCommon$1.capitalizeFirstLetter).join("");
	      const serviceName = `ns${ModuleName}Common`;
	      const CommonModuleService = this.app?.getService(serviceName);
	      this.setWorking("validators", CommonModuleService.augmentValidators(validators));
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators() {
	      return this.getWorking("validators");
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      var _this2 = this;
	      let newHead = [];
	      if (this.getModuleName() && this.getOptions("names.module")) {
	        newHead.push({
	          title: this.getOptions("names.module"),
	          url: false
	        });
	      }
	      newHead.push({
	        title: this.getOptions("names.plural"),
	        url: this.getModelURL()
	      });
	      BREADCRUMBS.splice(0, BREADCRUMBS.length, ...newHead);
	      notBreadcrumbs.setHead(BREADCRUMBS).render({
	        root: "",
	        target: this.els.top,
	        navigate: function (url) {
	          return _this2.app?.getWorking("router").navigate(url);
	        }
	      });
	      this.route(this.getOptions("params"));
	    }
	  }, {
	    key: "startWhenWSClientReady",
	    value: function startWhenWSClientReady() {
	      var _this3 = this;
	      if (this.app?.getWSClient()) {
	        if (this.app?.getWSClient().isConnected()) {
	          this.start();
	        } else {
	          this.app.getWSClient().once("connected", this.startWhenWSClientReady.bind(this));
	        }
	      } else {
	        setTimeout(function () {
	          return _this3.startWhenWSClientReady();
	        }, this.WS_CHECK_INTERVAL);
	      }
	    }
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(tail) {
	      notBreadcrumbs.setTail(tail).update();
	    }
	  }, {
	    key: "backToList",
	    value: function backToList() {
	      this.navigate(this.linkBackToList());
	    }
	  }, {
	    key: "linkBackToList",
	    value: function linkBackToList() {
	      return this.getModelURL();
	    }
	  }, {
	    key: "afterAction",
	    value: function afterAction(action = "list") {
	      let navBack = this.app?.getOptions("crud.navigateBackAfter", []);
	      if (navBack && Array.isArray(navBack) && navBack.indexOf(action) > -1) {
	        window.history.back();
	      } else {
	        this.backToList();
	      }
	    }
	  }, {
	    key: "buildFrame",
	    value: function buildFrame() {
	      var _this4 = this;
	      let el = document.querySelector(this.app?.getOptions("crud.containerSelector", "body"));
	      while (el.firstChild) {
	        el.removeChild(el.firstChild);
	      }
	      this.els.top = document.createElement("div");
	      this.els.top.id = "crud-top";
	      this.getFrameClasses().TOP_CLASS.forEach(function (name) {
	        return _this4.els.top.classList.add(name);
	      });
	      el.appendChild(this.els.top);
	      this.els.main = document.createElement("div");
	      this.els.main.id = "crud-main";
	      this.getFrameClasses().MAIN_CLASS.forEach(function (name) {
	        return _this4.els.main.classList.add(name);
	      });
	      el.appendChild(this.els.main);
	      this.els.bottom = document.createElement("div");
	      this.els.bottom.id = "crud-bottom";
	      this.getFrameClasses().BOTTOM_CLASS.forEach(function (name) {
	        return _this4.els.bottom.classList.add(name);
	      });
	      el.appendChild(this.els.bottom);
	    }
	  }, {
	    key: "getFrameClasses",
	    value: function getFrameClasses() {
	      return {
	        TOP_CLASS: this.TOP_CLASS,
	        MAIN_CLASS: this.MAIN_CLASS,
	        BOTTOM_CLASS: this.BOTTOM_CLASS
	      };
	    }
	  }, {
	    key: "getContainerTopElement",
	    value: function getContainerTopElement() {
	      return this.els.top;
	    }
	  }, {
	    key: "getContainerInnerElement",
	    value: function getContainerInnerElement() {
	      return this.els.main;
	    }
	  }, {
	    key: "getContainerBottomElement",
	    value: function getContainerBottomElement() {
	      return this.els.bottom;
	    }
	  }, {
	    key: "preloadVariants",
	    value: async function preloadVariants(type = "list") {
	      await _classPrivateFieldGet2(_preloader, this).preload(this, type);
	    }
	  }, {
	    key: "getTitleFromLib",
	    value: function getTitleFromLib(propName, id) {
	      const actionName = this.getCurrentAction();
	      this.debug && this.debug("notCRUD.getTitleFromLib is obsolete, use notCRUD.getPreloadedVariantTitle(actionName, propName, id)");
	      return this.getPreloadedVariantTitle(actionName, propName, id);
	    }
	  }, {
	    key: "getPreloadedVariants",
	    value: function getPreloadedVariants(actionName, propName) {
	      return this.getOptions(`variants.${actionName}.${propName}`, []);
	    }
	  }, {
	    key: "getPreloadedVariantTitle",
	    value: function getPreloadedVariantTitle(actionName, propName, id) {
	      const variants = this.getPreloadedVariants(actionName, propName);
	      const item = variants.find(function (item) {
	        return item.id === id;
	      });
	      if (item) {
	        return item.title;
	      } else {
	        return id;
	      }
	    }
	  }, {
	    key: "getItemTitle",
	    value: function getItemTitle(item) {
	      const fieldName = this.TITLE_FIELDS_PRIORITY.find(function (key) {
	        return notCommon$1.objHas(item, key);
	      });
	      if (fieldName) {
	        return item[fieldName];
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "createDefault",
	    value: function createDefault() {
	      return this.getModel({}).toDefault();
	    }
	  }, {
	    key: "route",
	    value: function route(params = []) {
	      try {
	        return _classPrivateFieldGet2(_router, this).route(this, params);
	      } catch (e) {
	        this.report(e);
	        this.showErrorMessage(e);
	      }
	    }
	  }, {
	    key: "actionHandlerExists",
	    value: function actionHandlerExists(actionName) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return true;
	      }
	      if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "runAction",
	    value: function runAction(actionName, params) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return _classPrivateFieldGet2(_actions, this)[actionName].run(this, params);
	      } else if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return this["run" + notCommon$1.capitalizeFirstLetter(actionName)](params);
	      } else {
	        throw new Error(`No such action: ${actionName} in contoller ${this.getWorking("name")}`);
	      }
	    }

	    /**
	     *  Changes location to create page, after delay
	     *  @param {number|string} [delay=0] number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goCreate",
	    value: function goCreate(delay = 0) {
	      this.goAfterDelay(this.getModelActionURL("", "create"), delay);
	    }

	    /**
	     *  Changes location to document details page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDetails",
	    value: function goDetails(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, ""), delay);
	    }

	    /**
	     * Changes location to document update page, after delay
	     * @param {string}          id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goUpdate",
	    value: function goUpdate(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "update"), delay);
	    }

	    /**
	     *  Changes location to document delete page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDelete",
	    value: function goDelete(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "delete"), delay);
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goList",
	    value: function goList(delay = 0) {
	      this.goAfterDelay(this.getModelURL(), delay);
	    }

	    /**
	     *
	     * @param {string} url
	     * @param {number|string} delay
	     */
	  }, {
	    key: "goAfterDelay",
	    value: function goAfterDelay(url, delay = 0) {
	      var _this5 = this;
	      this.navigateWithDelay(url, delay, function () {
	        return _this5.$destroyUI();
	      });
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goBack",
	    value: function goBack(delay = 0) {
	      this.goList(delay);
	    }
	  }, {
	    key: "onActionSubmit",
	    value: async function onActionSubmit(action, item) {
	      let state = true;
	      const actionUI = this.ui[action];
	      if (actionUI) {
	        try {
	          actionUI.setLoading();
	          let result = await this.getModel(item)[`$${action}`]();
	          state = actionUI.processResult(result);
	        } catch (e) {
	          state = actionUI.processResult(e);
	        } finally {
	          actionUI.resetLoading();
	          // eslint-disable-next-line no-unsafe-finally
	          return state;
	        }
	      } else {
	        throw new Error("Action UI doesnt exist");
	      }
	    }
	  }, {
	    key: "$destroyUI",
	    value: function $destroyUI() {
	      for (let name in this.ui) {
	        this.destroyUIByName(name);
	      }
	    }
	  }, {
	    key: "destroyUIByName",
	    value: function destroyUIByName(name) {
	      // @ts-ignore
	      if (Object.hasOwn(this.ui, name)) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        this.ui[name].destroy && this.ui[name].destroy();
	        delete this.ui[name];
	      }
	    }
	  }, {
	    key: "showErrorMessage",
	    value: function showErrorMessage(res) {
	      this.error && this.error(res);
	      this.app && this.app.emit("error", {
	        title: "Произошла ошибка",
	        message: res.message ? res.message : UICommon$1.ERROR_DEFAULT
	      });
	      CRUDMessage.error(this, "Произошла ошибка", res.message ? res.message : UICommon$1.ERROR_DEFAULT);
	    }
	  }, {
	    key: "showSuccessMessage",
	    value: function showSuccessMessage(title, message) {
	      this.app && this.app.emit("success", {
	        title,
	        message
	      });
	      CRUDMessage.success(this, title, message);
	    }
	  }, {
	    key: "setUI",
	    value: function setUI(name, val, singleUI = true) {
	      if (singleUI) {
	        this.$destroyUI();
	      }
	      this.ui[name] = val;
	    }
	  }, {
	    key: "getUI",
	    value: function getUI(name) {
	      return this.ui[name];
	    }
	  }, {
	    key: "getActionUI",
	    value: function getActionUI() {
	      return this.ui[this.getCurrentAction()];
	    }
	  }, {
	    key: "renderLoadingScreen",
	    value: function renderLoadingScreen() {
	      this.setUI(LOADING_SCREEN_UI_NAME, this.createLoaderUI());
	    }
	  }, {
	    key: "removeLoadingScreen",
	    value: function removeLoadingScreen() {
	      this.destroyUIByName(LOADING_SCREEN_UI_NAME);
	    }
	  }, {
	    key: "createLoaderUI",
	    value: function createLoaderUI() {
	      return mount(Ui_loader, {
	        target: this.getContainerInnerElement(),
	        props: {
	          loading: true,
	          title: ""
	        }
	      });
	    }
	  }], [{
	    key: "LABELS",
	    get: function () {
	      return Object.freeze({
	        plural: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_plural`,
	        single: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_single`
	      });
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu(itemCustomProps = {}) {
	      return [{
	        section: this.MODULE_NAME,
	        title: this.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(this.MODULE_NAME)}/${notCommon$1.lowerFirstLetter(this.MODEL_NAME)}`,
	        ...itemCustomProps
	      }];
	    }
	  }]);
	}(notController);
	_defineProperty(notCRUD, "ERROR_DEFAULT", UICommon$1.ERROR_DEFAULT);

	const ROUTE_LIST = "list";
	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDPlainRouter = /*#__PURE__*/function () {
	  function notCRUDPlainRouter() {
	    _classCallCheck(this, notCRUDPlainRouter);
	  }
	  return _createClass(notCRUDPlainRouter, null, [{
	    key: "extractActionName",
	    value:
	    /**
	     * Returns first item from params or throws Error
	     * @param {string[]} params array of strings parsed from URI by route rules
	     * @returns {string}
	     */
	    function extractActionName(params) {
	      if (params.length > 0) {
	        return params[0];
	      }
	      return this.DEFAULT_ROUTE;
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = this.extractActionName(params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();
	_defineProperty(notCRUDPlainRouter, "DEFAULT_ROUTE", ROUTE_LIST);

	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDRouterSwitch = /*#__PURE__*/function () {
	  function notCRUDRouterSwitch() {
	    _classCallCheck(this, notCRUDRouterSwitch);
	  }
	  return _createClass(notCRUDRouterSwitch, null, [{
	    key: "routesVariants",
	    get:
	    /**
	     * Variants of this action
	     */
	    function () {
	      return {
	        /**
	        routeName: Action
	         */
	      };
	    }

	    /**
	     * Returns true if variant name is valid
	     * @param {string} name    name of route variant
	     * @returns {boolean}
	     */
	  }, {
	    key: "isRouteVariantValid",
	    value: function isRouteVariantValid(name) {
	      return name !== "" && notCommon$1.objHas(this.routesVariants, name);
	    }

	    /**
	     * This function returns which of routes variant should be executed
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]}    params  params passed to router
	     * @returns {Promise<string>}    name of route variant
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "determineRoute",
	    value: async function determineRoute(controller, params = []) {
	      return "";
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: async function route(controller, params) {
	      try {
	        const actionName = await this.determineRoute(controller, params);
	        if (this.isRouteVariantValid(actionName)) {
	          controller.setCurrentAction(actionName);
	          const routerAction = this.routesVariants[actionName];
	          if (notCommon$1.isAsync(routerAction.run)) {
	            await routerAction.run(controller, params);
	          } else {
	            routerAction.run(controller, params);
	          }
	        } else {
	          throw new Error(`No such action: ${actionName} in contoller ${controller.getWorking("name")}`);
	        }
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const emptyResult = function () {
	  return {
	    list: [],
	    count: 0,
	    page: 0,
	    pages: 0,
	    skip: 0
	  };
	};
	let notServiceModelSearch = /*#__PURE__*/function () {
	  function notServiceModelSearch(app, modelName) {
	    _classCallCheck(this, notServiceModelSearch);
	    this.modelName = modelName;
	    this.app = app;
	  }
	  return _createClass(notServiceModelSearch, [{
	    key: "destroy",
	    value: function destroy() {
	      delete this.app;
	    }
	  }, {
	    key: "getSearchRouteName",
	    value: function getSearchRouteName() {
	      return "listAndCount";
	    }
	  }, {
	    key: "getDataLoadRouteName",
	    value: function getDataLoadRouteName() {
	      return "get";
	    }
	  }, {
	    key: "transformSearchResult",
	    value: function transformSearchResult(result) {
	      var _this = this;
	      result.list = result.list.map(function (item) {
	        return {
	          _id: item._id,
	          id: item[`${_this.modelName}ID`],
	          title: item.name || item.title || item.label || item.username
	        };
	      });
	      return result;
	    }
	  }, {
	    key: "transformSelectedResult",
	    value: function transformSelectedResult(result) {
	      return {
	        _id: result._id,
	        [`${this.modelName}ID`]: result.id,
	        title: result.title
	      };
	    }
	  }, {
	    key: "searchByTerm",
	    value: async function searchByTerm(term) {
	      try {
	        if (term.value.length > 2) {
	          const model = this.app.getModel(this.modelName);
	          model.setSearch(term.value);
	          const response = await model[`$${this.getSearchRouteName()}`]();
	          if (response.status === "ok") {
	            return this.transformSearchResult(response.result);
	          } else {
	            return emptyResult();
	          }
	        } else {
	          return emptyResult();
	        }
	      } catch {
	        return emptyResult();
	      }
	    }
	  }, {
	    key: "openSelector",
	    value: function openSelector() {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        try {
	          const el = mount(Ui_generic_selector, {
	            target: document.body,
	            props: {}
	          });
	          el.$on("termChange", async function ({
	            detail
	          }) {
	            const results = await _this2.searchByTerm(detail);
	            el.$set({
	              results
	            });
	          });
	          el.$on("next", function () {
	            console.log("next selector results");
	          });
	          el.$on("prev", function () {
	            console.log("prev selector results");
	          });
	          el.$on("reject", function () {
	            unmount(el);
	            reject();
	          });
	          el.$on("resolve", function ({
	            detail
	          }) {
	            unmount(el);
	            resolve(_this2.transformSelectedResult(detail));
	          });
	        } catch (e) {
	          _this2.app.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "loadData",
	    value: async function loadData(_id) {
	      try {
	        if (_id && _id.length > 10) {
	          const model = this.app.getModel(this.modelName, {
	            _id
	          });
	          const response = await model[`$${this.getDataLoadRouteName()}`]();
	          if (response.status === "ok") {
	            return response.result;
	          } else {
	            return null;
	          }
	        } else {
	          return null;
	        }
	      } catch (e) {
	        this.app.error(e);
	        return null;
	      }
	    }
	  }]);
	}();

	//import 'babel-polyfill/dist/polyfill';

	const ncCRUD = notCRUD; //legacy alias

	var Frame = /*#__PURE__*/Object.freeze({
		__proto__: null,
		COMPONENTS: COMPONENTS$1,
		FIELDS: FIELDS$1,
		UIForm: Form,
		VARIANTS: VARIANTS$1,
		createCRUDActionUIView: create_crud_action_ui_view,
		ncCRUD: ncCRUD,
		notAPI: index,
		notApp: notApp,
		notBase: notBase,
		notBreadcrumbs: notBreadcrumbs,
		notCRUD: notCRUD,
		notCRUDRouter: notCRUDRouter,
		notCRUDRouterPlain: notCRUDPlainRouter,
		notCRUDRouterSwitch: notCRUDRouterSwitch,
		notCommon: notCommon$1,
		notController: notController,
		notForm: notForm,
		notFormHelpers: FormHelpers,
		notFormRules: notFormRules,
		notFormSet: notFormSet,
		notFormUtils: notFormUtils$1,
		notInterface: notInterface,
		notPath: notPath,
		notRecord: notRecord,
		notRouter: notRouter$1,
		notServiceModelSearch: notServiceModelSearch,
		notSideMenu: notSideMenu,
		notStores: stores,
		notTable: notTable,
		notTopMenu: notTopMenu
	});

	const Locale = {
	  LOCALE,
	  say,
	  notLocale: notLocale$1
	};
	const UICommon = UICommon$1;
	const {
	  notCommon,
	  COMPONENTS,
	  FIELDS,
	  VARIANTS,
	  notFormUtils
	} = Frame;
	Object.keys(Elements).forEach(function (componentsSetName) {
	  Object.keys(Elements[componentsSetName]).forEach(function (componentName) {
	    notFormUtils$1.addComponent(componentName, Elements[componentsSetName][componentName]);
	  });
	});

	exports.COMPONENTS = COMPONENTS;
	exports.Elements = Elements;
	exports.FIELDS = FIELDS;
	exports.Frame = Frame;
	exports.LOCALE = LOCALE;
	exports.Locale = Locale;
	exports.UICommon = UICommon;
	exports.VARIANTS = VARIANTS;
	exports.notCommon = notCommon;
	exports.notFormUtils = notFormUtils;
	exports.notLocale = notLocale$1;
	exports.say = say;
	exports.svelte = indexClient;

	return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90QnVsbWEuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9lc20tZW52L3RydWUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvY2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L293bmVyc2hpcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3NvdXJjZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2h5ZHJhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9wcm94eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL29wZXJhdGlvbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VmZmVjdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3Rhc2suanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9taXNjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vcmVjb25jaWxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vdGVtcGxhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvaWYuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9lYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvaHRtbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3Nsb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc3ZlbHRlLWNvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9hdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9hdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9jbGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC90aW1pbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvbG9vcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvdHJhbnNpdGlvbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL2lucHV0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9wcm9wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3Mvc2VsZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy90aGlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvZXZlbnQtbW9kaWZpZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbGlmZWN5Y2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbWlzYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3N0b3JlL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc3RvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9wcm9wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2luZGV4LWNsaWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2NvbW1vbi5qcyIsIi4uL3NyYy9lbGVtZW50cy9ibG9jay91aS5ibG9jay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuYmxvY2suaW5uZXIudmVydGljYWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Jsb2NrL3VpLmJveC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuY29udGVudC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuY2xpY2thYmxlLmRpdi5zdmVsdGUiLCIuLi9zcmMvbG9jYWxlL3N0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dvbGZ5ODctZXZlbnRlbWl0dGVyL0V2ZW50RW1pdHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtcGF0aC9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXBhdGgvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tbW9uLmpzIiwiLi4vc3JjL2xvY2FsZS9ub3RMb2NhbGUuanMiLCIuLi9zcmMvbG9jYWxlL2luZGV4LmpzIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuYm9vbGVhbi5sYWJlbGVkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW5zLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmNlbnNvcmVkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5sb2FkZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5jbG9zZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnJvdy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5zd2l0Y2guc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN3aXRjaGVycy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuZmllbGQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmNvbnRyb2wuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuc2VsZWN0LmZyb20ubW9kZWwub24uZGVtYW5kLmlubGluZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zZWxlY3QuZnJvbS5tb2RlbC53aXRoLnNlYXJjaC5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5wcm9ncmVzcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zaG93Lm9uZS5mcm9tLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnZhbHVlLnN2ZWx0ZSIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2ZsYWdzL2xlZ2FjeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2Vhc2luZy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2FuaW1hdGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlL3NyYy9TaW1wbGVBdXRvY29tcGxldGUuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuYXV0b2NvbXBsZXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jb2xvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubGFiZWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmNoZWNrYm94LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jaGVja2JveC5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5kYXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5kYXRldGltZS5pbi50ei5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuZW1haWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmhpZGRlbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkudGV4dGFyZWEuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmpzb24uYXJlYS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvbGliLmpzIiwiLi4vc3JjL2ZyYW1lL0xJQi5qcyIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3VpLmxpc3QuZW1wdHkucGxhY2Vob2xkZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpbmsvdWkubGluay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGluay91aS5saW5rcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC91aS5saXN0Lml0ZW0uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5ibG9jay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC91aS5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5saXN0Lm9mLm1vZGVscy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmNvbHVtbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmNvbHVtbnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5jb250YWluZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5mb290ZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5zZWN0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkubGV2ZWwuaXRlbS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubnVtYmVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5uYW1lZC5udW1iZXJzLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnBhc3N3b3JkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbWFnZS91aS5pbWFnZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucmFkaW8uYnV0dG9ucy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucmFuZ2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5tdWx0aXBsZS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29uc3QuanMiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc2VsZWN0LmZyb20ubW9kZWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnN3aXRjaC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc3dpdGNoLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRhZy5zZWxlY3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRlbGVwaG9uZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS50YWcudmFsdWUubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5lcnJvcnMubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS51c2VyLmNhcmQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mb250LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC5lcnJvcnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5idXR0b24ud2l0aC50YWcuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mbG9hdGluZy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9mb3JtL3VpLmZvcm0uaW5wdXQudmFsaWRhdGVkLmljb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvZm9ybS91aS5mb3JtLmNvbnRyb2wuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ltYWdlL3VpLmltYWdlcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC9lbmRsZXNzL3VpLmVuZGxlc3MubGlzdC5uYXZpZ2F0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0LnNpbXBsZS5pdGVtLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC91aS5saXN0LnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC9zZWxlY3QvZHRvL2xpc3QuZ3JvdXBzLnVpLnRyZWUuZHRvLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8ubXVsdGlwbGUuYmVoYXZpb3VyLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8uc2luZ2xlLmJlaGF2aW91ci5qcyIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC9kdG8vbGlzdC5ncm91cHMudmFsdWUuZHRvLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L3VpLmxpc3Quc2VsZWN0LndpdGguZ3JvdXBzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC91aS5saXN0LnNlbGVjdC5idXR0b25zLndpdGguZ3JvdXBzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9tb2RhbC91aS5vdmVybGF5LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9tb2RhbC91aS5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbW9kYWwvdWkuZ2VuZXJpYy5zZWxlY3Rvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLm1lc3NhZ2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5lcnJvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLnN1Y2Nlc3Muc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5jb29raWUubm90aWZpY2F0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9iYXNlLmpzIiwiLi4vc3JjL2ZyYW1lL3JvdXRlci5qcyIsIi4uL3NyYy9mcmFtZS9hcGkvcXVldWUuanMiLCIuLi9zcmMvZnJhbWUvYXBpL29wdGlvbnMuanMiLCIuLi9zcmMvZnJhbWUvYXBpL2Nvbm5lY3Rpb24uanMiLCIuLi9zcmMvZnJhbWUvc3RvcmVzLmpzIiwiLi4vc3JjL2ZyYW1lL29wdGlvbnMuanMiLCIuLi9zcmMvZnJhbWUvaW50ZXJmYWNlLmpzIiwiLi4vc3JjL2ZyYW1lL3JlY29yZC5qcyIsIi4uL3NyYy9mcmFtZS9hcHAuanMiLCIuLi9zcmMvZnJhbWUvY29udHJvbGxlci5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL3N0b3Jlcy5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL2NvbnRyb2xzL3VpLnN3aXRjaC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9jb250cm9scy91aS50YWdzLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL25vdFRhYmxlQ2VsbC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZVJvdy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZS5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2FjdGlvbi91aS5hY3Rpb24uY29udGFpbmVyLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2FjdGlvbi9hY3Rpb24udWkuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL3V0aWxzLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9mb3JtLmhlbHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL3Jlc3VsdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtZXJyb3Ivc3JjL2Vycm9yLm5vZGUuY2pzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC1lcnJvci9zcmMvdmFsaWRhdGlvbi5lcnJvci5ub2RlLmNqcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvY29tbW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9zZXNzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9ydW5uZXIudXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL3J1bm5lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvYnVpbGRlci51dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvYnVpbGRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2ZpZWxkLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0ucnVsZXMuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uc2V0LnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5zZXQuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy91aS5icmVhZGNydW1icy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy9icmVhZGNydW1icy5zdmVsdGUuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vbWVudS5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5pdGVtLndpdGhvdXQuY2hpbGRyZW4uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLnRyaWdnZXIuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLml0ZW0ubGFiZWwuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLml0ZW1zLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5zZWN0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vc2lkZS91aS5zaWRlLm1lbnUuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3N0b3JlLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuYnJhbmQuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuaXRlbS5jb250ZW50LnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLml0ZW0uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuc2VjdGlvbi5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS5idXJnZXIuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkudG9wLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvY29uc3QuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9jcmVhdGUuY3J1ZC5hY3Rpb24udWkudmlldy5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3ZhcmlhbnRzLnByZWxvYWRlci5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3JvdXRlci5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL21lc3NhZ2UuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvYWN0aW9uLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9nZW5lcmljL2NyZWF0ZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvY3JlYXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9nZW5lcmljL3JlYWQuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2RldGFpbHMuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvdXBkYXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy91cGRhdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2RlbGV0ZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvbGlzdC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9jb250cm9sbGVyLmNydWQuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9yb3V0ZXIucGxhaW4uanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9yb3V0ZXIuc3dpdGNoLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvc2VhcmNoLnNlcnZpY2UuanMiLCIuLi9zcmMvZnJhbWUvaW5kZXguanMiLCIuLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgdHJ1ZTtcbiIsIi8vIFN0b3JlIHRoZSByZWZlcmVuY2VzIHRvIGdsb2JhbHMgaW4gY2FzZSBzb21lb25lIHRyaWVzIHRvIG1vbmtleSBwYXRjaCB0aGVzZSwgY2F1c2luZyB0aGUgYmVsb3dcbi8vIHRvIGRlLW9wdCAodGhpcyBvY2N1cnMgb2Z0ZW4gd2hlbiB1c2luZyBwb3B1bGFyIGV4dGVuc2lvbnMpLlxuZXhwb3J0IHZhciBpc19hcnJheSA9IEFycmF5LmlzQXJyYXk7XG5leHBvcnQgdmFyIGluZGV4X29mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG5leHBvcnQgdmFyIGFycmF5X2Zyb20gPSBBcnJheS5mcm9tO1xuZXhwb3J0IHZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IHZhciBkZWZpbmVfcHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5leHBvcnQgdmFyIGdldF9kZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmV4cG9ydCB2YXIgZ2V0X2Rlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5leHBvcnQgdmFyIG9iamVjdF9wcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZXhwb3J0IHZhciBhcnJheV9wcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5leHBvcnQgdmFyIGdldF9wcm90b3R5cGVfb2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHRoaW5nXG4gKiBAcmV0dXJucyB7dGhpbmcgaXMgRnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuXHRyZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlPy50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiogQHBhcmFtIHtGdW5jdGlvbn0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0cmV0dXJuIGZuKCk7XG59XG5cbi8qKiBAcGFyYW0ge0FycmF5PCgpID0+IHZvaWQ+fSBhcnIgKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5fYWxsKGFycikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdGFycltpXSgpO1xuXHR9XG59XG5cbi8qKlxuICogVE9ETyByZXBsYWNlIHdpdGggUHJvbWlzZS53aXRoUmVzb2x2ZXJzIG9uY2Ugc3VwcG9ydGVkIHdpZGVseSBlbm91Z2hcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZlcnJlZCgpIHtcblx0LyoqIEB0eXBlIHsodmFsdWU6IFQpID0+IHZvaWR9ICovXG5cdHZhciByZXNvbHZlO1xuXG5cdC8qKiBAdHlwZSB7KHJlYXNvbjogYW55KSA9PiB2b2lkfSAqL1xuXHR2YXIgcmVqZWN0O1xuXG5cdC8qKiBAdHlwZSB7UHJvbWlzZTxUPn0gKi9cblx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRyZXNvbHZlID0gcmVzO1xuXHRcdHJlamVjdCA9IHJlajtcblx0fSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4geyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtWIHwgKCgpID0+IFYpfSBmYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBbbGF6eV1cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFsbGJhY2sodmFsdWUsIGZhbGxiYWNrLCBsYXp5ID0gZmFsc2UpIHtcblx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcblx0XHQ/IGxhenlcblx0XHRcdD8gLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoZmFsbGJhY2spKClcblx0XHRcdDogLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spXG5cdFx0OiB2YWx1ZTtcbn1cbiIsImV4cG9ydCBjb25zdCBERVJJVkVEID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IEVGRkVDVCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBSRU5ERVJfRUZGRUNUID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VGRkVDVCA9IDEgPDwgNDtcbmV4cG9ydCBjb25zdCBCUkFOQ0hfRUZGRUNUID0gMSA8PCA1O1xuZXhwb3J0IGNvbnN0IFJPT1RfRUZGRUNUID0gMSA8PCA2O1xuZXhwb3J0IGNvbnN0IEJPVU5EQVJZX0VGRkVDVCA9IDEgPDwgNztcbmV4cG9ydCBjb25zdCBVTk9XTkVEID0gMSA8PCA4O1xuZXhwb3J0IGNvbnN0IERJU0NPTk5FQ1RFRCA9IDEgPDwgOTtcbmV4cG9ydCBjb25zdCBDTEVBTiA9IDEgPDwgMTA7XG5leHBvcnQgY29uc3QgRElSVFkgPSAxIDw8IDExO1xuZXhwb3J0IGNvbnN0IE1BWUJFX0RJUlRZID0gMSA8PCAxMjtcbmV4cG9ydCBjb25zdCBJTkVSVCA9IDEgPDwgMTM7XG5leHBvcnQgY29uc3QgREVTVFJPWUVEID0gMSA8PCAxNDtcbmV4cG9ydCBjb25zdCBFRkZFQ1RfUkFOID0gMSA8PCAxNTtcbi8qKiAnVHJhbnNwYXJlbnQnIGVmZmVjdHMgZG8gbm90IGNyZWF0ZSBhIHRyYW5zaXRpb24gYm91bmRhcnkgKi9cbmV4cG9ydCBjb25zdCBFRkZFQ1RfVFJBTlNQQVJFTlQgPSAxIDw8IDE2O1xuLyoqIFN2ZWx0ZSA0IGxlZ2FjeSBtb2RlIHByb3BzIG5lZWQgdG8gYmUgaGFuZGxlZCB3aXRoIGRlcml2ZWRzIGFuZCBiZSByZWNvZ25pemVkIGVsc2V3aGVyZSwgaGVuY2UgdGhlIGRlZGljYXRlZCBmbGFnICovXG5leHBvcnQgY29uc3QgTEVHQUNZX0RFUklWRURfUFJPUCA9IDEgPDwgMTc7XG5leHBvcnQgY29uc3QgSU5TUEVDVF9FRkZFQ1QgPSAxIDw8IDE4O1xuZXhwb3J0IGNvbnN0IEhFQURfRUZGRUNUID0gMSA8PCAxOTtcbmV4cG9ydCBjb25zdCBFRkZFQ1RfSEFTX0RFUklWRUQgPSAxIDw8IDIwO1xuXG5leHBvcnQgY29uc3QgU1RBVEVfU1lNQk9MID0gU3ltYm9sKCckc3RhdGUnKTtcbmV4cG9ydCBjb25zdCBTVEFURV9TWU1CT0xfTUVUQURBVEEgPSBTeW1ib2woJyRzdGF0ZSBtZXRhZGF0YScpO1xuZXhwb3J0IGNvbnN0IExFR0FDWV9QUk9QUyA9IFN5bWJvbCgnbGVnYWN5IHByb3BzJyk7XG5leHBvcnQgY29uc3QgTE9BRElOR19BVFRSX1NZTUJPTCA9IFN5bWJvbCgnJyk7XG4iLCIvKiogQGltcG9ydCB7IEVxdWFscyB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHModmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSB0aGlzLnY7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBhXG4gKiBAcGFyYW0ge3Vua25vd259IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhXG5cdFx0PyBiID09IGJcblx0XHQ6IGEgIT09IGIgfHwgKGEgIT09IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPT0gYjtcbn1cblxuLyoqIEB0eXBlIHtFcXVhbHN9ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9lcXVhbHModmFsdWUpIHtcblx0cmV0dXJuICFzYWZlX25vdF9lcXVhbCh2YWx1ZSwgdGhpcy52KTtcbn1cbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbi8qKlxuICogVXNpbmcgYGJpbmQ6dmFsdWVgIHRvZ2V0aGVyIHdpdGggYSBjaGVja2JveCBpbnB1dCBpcyBub3QgYWxsb3dlZC4gVXNlIGBiaW5kOmNoZWNrZWRgIGluc3RlYWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVcXG5Vc2luZyBcXGBiaW5kOnZhbHVlXFxgIHRvZ2V0aGVyIHdpdGggYSBjaGVja2JveCBpbnB1dCBpcyBub3QgYWxsb3dlZC4gVXNlIFxcYGJpbmQ6Y2hlY2tlZFxcYCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIENvbXBvbmVudCAlY29tcG9uZW50JSBoYXMgYW4gZXhwb3J0IG5hbWVkIGAla2V5JWAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIGBiaW5kOiVrZXklYCwgd2hpY2ggaXMgZGlzYWxsb3dlZC4gSW5zdGVhZCwgdXNlIGBiaW5kOnRoaXNgIChlLmcuIGA8JW5hbWUlIGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPmApIGFuZCB0aGVuIGFjY2VzcyB0aGUgcHJvcGVydHkgb24gdGhlIGJvdW5kIGNvbXBvbmVudCBpbnN0YW5jZSAoZS5nLiBgY29tcG9uZW50LiVrZXklYClcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ludmFsaWRfZXhwb3J0KGNvbXBvbmVudCwga2V5LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9pbnZhbGlkX2V4cG9ydFxcbkNvbXBvbmVudCAke2NvbXBvbmVudH0gaGFzIGFuIGV4cG9ydCBuYW1lZCBcXGAke2tleX1cXGAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIFxcYGJpbmQ6JHtrZXl9XFxgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgXFxgYmluZDp0aGlzXFxgIChlLmcuIFxcYDwke25hbWV9IGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPlxcYCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIFxcYGNvbXBvbmVudC4ke2tleX1cXGApXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXHR9XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgaXMgYXR0ZW1wdGluZyB0byBiaW5kIHRvIGEgbm9uLWJpbmRhYmxlIHByb3BlcnR5IGAla2V5JWAgYmVsb25naW5nIHRvICVjb21wb25lbnQlIChpLmUuIGA8JW5hbWUlIGJpbmQ6JWtleSU9ey4uLn0+YCkuIFRvIG1hcmsgYSBwcm9wZXJ0eSBhcyBiaW5kYWJsZTogYGxldCB7ICVrZXklID0gJGJpbmRhYmxlKCkgfSA9ICRwcm9wcygpYFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfbm90X2JpbmRhYmxlKGtleSwgY29tcG9uZW50LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9ub3RfYmluZGFibGVcXG5BIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgXFxgJHtrZXl9XFxgIGJlbG9uZ2luZyB0byAke2NvbXBvbmVudH0gKGkuZS4gXFxgPCR7bmFtZX0gYmluZDoke2tleX09ey4uLn0+XFxgKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBcXGBsZXQgeyAke2tleX0gPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX25vdF9iaW5kYWJsZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9ub3RfYmluZGFibGVgKTtcblx0fVxufVxuXG4vKipcbiAqICVwYXJlbnQlIGNhbGxlZCBgJW1ldGhvZCVgIG9uIGFuIGluc3RhbmNlIG9mICVjb21wb25lbnQlLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfY2hhbmdlZChwYXJlbnQsIG1ldGhvZCwgY29tcG9uZW50KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY29tcG9uZW50X2FwaV9jaGFuZ2VkXFxuJHtwYXJlbnR9IGNhbGxlZCBcXGAke21ldGhvZH1cXGAgb24gYW4gaW5zdGFuY2Ugb2YgJHtjb21wb25lbnR9LCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2NoYW5nZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIGluc3RhbnRpYXRlICVjb21wb25lbnQlIHdpdGggYG5ldyAlbmFtZSVgLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDUuIElmIHRoaXMgY29tcG9uZW50IGlzIG5vdCB1bmRlciB5b3VyIGNvbnRyb2wsIHNldCB0aGUgYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpYCBjb21waWxlciBvcHRpb24gdG8gYDRgIHRvIGtlZXAgaXQgd29ya2luZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfYXBpX2ludmFsaWRfbmV3KGNvbXBvbmVudCwgbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXdcXG5BdHRlbXB0ZWQgdG8gaW5zdGFudGlhdGUgJHtjb21wb25lbnR9IHdpdGggXFxgbmV3ICR7bmFtZX1cXGAsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNS4gSWYgdGhpcyBjb21wb25lbnQgaXMgbm90IHVuZGVyIHlvdXIgY29udHJvbCwgc2V0IHRoZSBcXGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaVxcYCBjb21waWxlciBvcHRpb24gdG8gXFxgNFxcYCB0byBrZWVwIGl0IHdvcmtpbmcuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXHR9XG59XG5cbi8qKlxuICogQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZlxcbkEgZGVyaXZlZCB2YWx1ZSBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZiByZWN1cnNpdmVseVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZmApO1xuXHR9XG59XG5cbi8qKlxuICogS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBgJXZhbHVlJWAgYXQgaW5kZXhlcyAlYSUgYW5kICViJVxuICogQHBhcmFtIHtzdHJpbmd9IGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBiXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFt2YWx1ZV1cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2hfa2V5X2R1cGxpY2F0ZShhLCBiLCB2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVhY2hfa2V5X2R1cGxpY2F0ZVxcbiR7dmFsdWUgPyBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBcXGAke3ZhbHVlfVxcYCBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gIDogYEtleWVkIGVhY2ggYmxvY2sgaGFzIGR1cGxpY2F0ZSBrZXkgYXQgaW5kZXhlcyAke2F9IGFuZCAke2J9YH1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lYWNoX2tleV9kdXBsaWNhdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3RlYXJkb3duKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdGVhcmRvd25cXG5cXGAke3J1bmV9XFxgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgY2xlYW51cCBmdW5jdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl90ZWFyZG93bmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3RlYXJkb3duYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBFZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgYCRkZXJpdmVkYCB2YWx1ZSB0aGF0IHdhcyBub3QgaXRzZWxmIGNyZWF0ZWQgaW5zaWRlIGFuIGVmZmVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkXFxuRWZmZWN0IGNhbm5vdCBiZSBjcmVhdGVkIGluc2lkZSBhIFxcYCRkZXJpdmVkXFxgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IChlLmcuIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24pXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X29ycGhhbihydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X29ycGhhblxcblxcYCR7cnVuZX1cXGAgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IChlLmcuIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24pXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXHR9XG59XG5cbi8qKlxuICogTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgcmVhY3RpdmUgYmxvY2sgb3IgZWZmZWN0IHJlcGVhdGVkbHkgc2V0cyBhIG5ldyB2YWx1ZS4gU3ZlbHRlIGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZFxcbk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIHJlYWN0aXZlIGJsb2NrIG9yIGVmZmVjdCByZXBlYXRlZGx5IHNldHMgYSBuZXcgdmFsdWUuIFN2ZWx0ZSBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXHR9XG59XG5cbi8qKlxuICogRmFpbGVkIHRvIGh5ZHJhdGUgdGhlIGFwcGxpY2F0aW9uXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fZmFpbGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGh5ZHJhdGlvbl9mYWlsZWRcXG5GYWlsZWQgdG8gaHlkcmF0ZSB0aGUgYXBwbGljYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fZmFpbGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDb3VsZCBub3QgYHtAcmVuZGVyfWAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgYG51bGxgIG9yIGB1bmRlZmluZWRgLiBDb25zaWRlciB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBge0ByZW5kZXIgc25pcHBldD8uKCl9YFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9zbmlwcGV0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWRfc25pcHBldFxcbkNvdWxkIG5vdCBcXGB7QHJlbmRlcn1cXGAgc25pcHBldCBkdWUgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgXFxgbnVsbFxcYCBvciBcXGB1bmRlZmluZWRcXGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIFxcYHtAcmVuZGVyIHNuaXBwZXQ/LigpfVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJW5hbWUlKC4uLilgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfbGVnYWN5X29ubHkobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9sZWdhY3lfb25seVxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW5ub3QgYmUgdXNlZCBpbiBydW5lcyBtb2RlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBkbyBgYmluZDola2V5JT17dW5kZWZpbmVkfWAgd2hlbiBgJWtleSVgIGhhcyBhIGZhbGxiYWNrIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pbnZhbGlkX3ZhbHVlKGtleSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHByb3BzX2ludmFsaWRfdmFsdWVcXG5DYW5ub3QgZG8gXFxgYmluZDoke2tleX09e3VuZGVmaW5lZH1cXGAgd2hlbiBcXGAke2tleX1cXGAgaGFzIGEgZmFsbGJhY2sgdmFsdWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19pbnZhbGlkX3ZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXN0IGVsZW1lbnQgcHJvcGVydGllcyBvZiBgJHByb3BzKClgIHN1Y2ggYXMgYCVwcm9wZXJ0eSVgIGFyZSByZWFkb25seVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19yZXN0X3JlYWRvbmx5KHByb3BlcnR5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfcmVzdF9yZWFkb25seVxcblJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIFxcYCRwcm9wcygpXFxgIHN1Y2ggYXMgXFxgJHtwcm9wZXJ0eX1cXGAgYXJlIHJlYWRvbmx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGAlcnVuZSVgIHJ1bmUgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIGAuc3ZlbHRlYCBhbmQgYC5zdmVsdGUuanMvdHNgIGZpbGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuZV9vdXRzaWRlX3N2ZWx0ZShydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcnVuZV9vdXRzaWRlX3N2ZWx0ZVxcblRoZSBcXGAke3J1bmV9XFxgIHJ1bmUgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIFxcYC5zdmVsdGVcXGAgYW5kIFxcYC5zdmVsdGUuanMvdHNcXGAgZmlsZXNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9ydW5lX291dHNpZGVfc3ZlbHRlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9ydW5lX291dHNpZGVfc3ZlbHRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBQcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIGAkc3RhdGVgIG9iamVjdHMgbXVzdCBjb250YWluIGB2YWx1ZWAgYW5kIGFsd2F5cyBiZSBgZW51bWVyYWJsZWAsIGBjb25maWd1cmFibGVgIGFuZCBgd3JpdGFibGVgLlxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRcXG5Qcm9wZXJ0eSBkZXNjcmlwdG9ycyBkZWZpbmVkIG9uIFxcYCRzdGF0ZVxcYCBvYmplY3RzIG11c3QgY29udGFpbiBcXGB2YWx1ZVxcYCBhbmQgYWx3YXlzIGJlIFxcYGVudW1lcmFibGVcXGAsIFxcYGNvbmZpZ3VyYWJsZVxcYCBhbmQgXFxgd3JpdGFibGVcXGAuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBgJHN0YXRlYCBvYmplY3RcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3RvdHlwZV9maXhlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV9wcm90b3R5cGVfZml4ZWRcXG5DYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBcXGAkc3RhdGVcXGAgb2JqZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJvdG90eXBlX2ZpeGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFJlYWRpbmcgc3RhdGUgdGhhdCB3YXMgY3JlYXRlZCBpbnNpZGUgdGhlIHNhbWUgZGVyaXZlZCBpcyBmb3JiaWRkZW4uIENvbnNpZGVyIHVzaW5nIGB1bnRyYWNrYCB0byByZWFkIGxvY2FsbHkgY3JlYXRlZCBzdGF0ZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWRcXG5SZWFkaW5nIHN0YXRlIHRoYXQgd2FzIGNyZWF0ZWQgaW5zaWRlIHRoZSBzYW1lIGRlcml2ZWQgaXMgZm9yYmlkZGVuLiBDb25zaWRlciB1c2luZyBcXGB1bnRyYWNrXFxgIHRvIHJlYWQgbG9jYWxseSBjcmVhdGVkIHN0YXRlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9sb2NhbF9yZWFkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVcGRhdGluZyBzdGF0ZSBpbnNpZGUgYSBkZXJpdmVkIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgYCRzdGF0ZWBcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV91bnNhZmVfbXV0YXRpb25cXG5VcGRhdGluZyBzdGF0ZSBpbnNpZGUgYSBkZXJpdmVkIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgXFxgJHN0YXRlXFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX211dGF0aW9uYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbXV0YXRpb25gKTtcblx0fVxufSIsImV4cG9ydCBsZXQgbGVnYWN5X21vZGVfZmxhZyA9IGZhbHNlO1xuZXhwb3J0IGxldCB0cmFjaW5nX21vZGVfZmxhZyA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX2xlZ2FjeV9tb2RlX2ZsYWcoKSB7XG5cdGxlZ2FjeV9tb2RlX2ZsYWcgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlX3RyYWNpbmdfbW9kZV9mbGFnKCkge1xuXHR0cmFjaW5nX21vZGVfZmxhZyA9IHRydWU7XG59XG4iLCJleHBvcnQgY29uc3QgRUFDSF9JVEVNX1JFQUNUSVZFID0gMTtcbmV4cG9ydCBjb25zdCBFQUNIX0lOREVYX1JFQUNUSVZFID0gMSA8PCAxO1xuLyoqIFNlZSBFYWNoQmxvY2sgaW50ZXJmYWNlIG1ldGFkYXRhLmlzX2NvbnRyb2xsZWQgZm9yIGFuIGV4cGxhbmF0aW9uIHdoYXQgdGhpcyBpcyAqL1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVNfQ09OVFJPTExFRCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBFQUNIX0lTX0FOSU1BVEVEID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVRFTV9JTU1VVEFCTEUgPSAxIDw8IDQ7XG5cbmV4cG9ydCBjb25zdCBQUk9QU19JU19JTU1VVEFCTEUgPSAxO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX1JVTkVTID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX1VQREFURUQgPSAxIDw8IDI7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfQklOREFCTEUgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfTEFaWV9JTklUSUFMID0gMSA8PCA0O1xuXG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9JTiA9IDE7XG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9PVVQgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgVFJBTlNJVElPTl9HTE9CQUwgPSAxIDw8IDI7XG5cbmV4cG9ydCBjb25zdCBURU1QTEFURV9GUkFHTUVOVCA9IDE7XG5leHBvcnQgY29uc3QgVEVNUExBVEVfVVNFX0lNUE9SVF9OT0RFID0gMSA8PCAxO1xuXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUID0gJ1snO1xuLyoqIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhbiBgezplbHNlfS4uLmAgYmxvY2sgd2FzIHJlbmRlcmVkICovXG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX1NUQVJUX0VMU0UgPSAnWyEnO1xuZXhwb3J0IGNvbnN0IEhZRFJBVElPTl9FTkQgPSAnXSc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VSUk9SID0ge307XG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX0lTX05BTUVTUEFDRUQgPSAxO1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRfUFJFU0VSVkVfQVRUUklCVVRFX0NBU0UgPSAxIDw8IDE7XG5cbmV4cG9ydCBjb25zdCBVTklOSVRJQUxJWkVEID0gU3ltYm9sKCk7XG5cbi8vIERldi10aW1lIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgRklMRU5BTUUgPSBTeW1ib2woJ2ZpbGVuYW1lJyk7XG5leHBvcnQgY29uc3QgSE1SID0gU3ltYm9sKCdobXInKTtcblxuZXhwb3J0IGNvbnN0IE5BTUVTUEFDRV9TVkcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuZXhwb3J0IGNvbnN0IE5BTUVTUEFDRV9NQVRITUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG5cbi8vIHdlIHVzZSBhIGxpc3Qgb2YgaWdub3JhYmxlIHJ1bnRpbWUgd2FybmluZ3MgYmVjYXVzZSBub3QgZXZlcnkgcnVudGltZSB3YXJuaW5nXG4vLyBjYW4gYmUgaWdub3JlZCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSB2YWxpZGF0aW9uIGZvciBzdmVsdGUtaWdub3JlIGluIHBsYWNlXG5leHBvcnQgY29uc3QgSUdOT1JBQkxFX1JVTlRJTUVfV0FSTklOR1MgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUnLFxuXHQnYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmUnLFxuXHQnaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkJyxcblx0J2h5ZHJhdGlvbl9odG1sX2NoYW5nZWQnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfYmluZGluZycsXG5cdCdvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbidcbl0pO1xuXG4vKipcbiAqIFdoaXRlc3BhY2UgaW5zaWRlIG9uZSBvZiB0aGVzZSBlbGVtZW50cyB3aWxsIG5vdCByZXN1bHQgaW5cbiAqIGEgd2hpdGVzcGFjZSBub2RlIGJlaW5nIGNyZWF0ZWQgaW4gYW55IGNpcmN1bXN0YW5jZXMuIChUaGlzXG4gKiBsaXN0IGlzIGFsbW9zdCBjZXJ0YWlubHkgdmVyeSBpbmNvbXBsZXRlKVxuICogVE9ETyB0aGlzIGlzIGN1cnJlbnRseSB1bnVzZWRcbiAqL1xuZXhwb3J0IGNvbnN0IEVMRU1FTlRTX1dJVEhPVVRfVEVYVCA9IFsnYXVkaW8nLCAnZGF0YWxpc3QnLCAnZGwnLCAnb3B0Z3JvdXAnLCAnc2VsZWN0JywgJ3ZpZGVvJ107XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG52YXIgYm9sZCA9ICdmb250LXdlaWdodDogYm9sZCc7XG52YXIgbm9ybWFsID0gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG4vKipcbiAqIGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiV0YWclXCI+YCBpcyBhIHZvaWQgZWxlbWVudCDigJQgaXQgY2Fubm90IGhhdmUgY29udGVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudCh0YWcpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBkeW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50XFxuJWNcXGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPlxcYCBpcyBhIHZvaWQgZWxlbWVudCDigJQgaXQgY2Fubm90IGhhdmUgY29udGVudFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2R5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBgJHN0YXRlLnNuYXBzaG90YCDigJQgdGhlIHJldHVybiB2YWx1ZSBjb250YWlucyB0aGUgb3JpZ2luYWxzOlxuICogXG4gKiAlcHJvcGVydGllcyVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW3Byb3BlcnRpZXNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZShwcm9wZXJ0aWVzKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGVcXG4lYyR7cHJvcGVydGllc1xuXHRcdFx0PyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBcXGAkc3RhdGUuc25hcHNob3RcXGAg4oCUIHRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgdGhlIG9yaWdpbmFsczpcblxuJHtwcm9wZXJ0aWVzfWBcblx0XHRcdDogJ1ZhbHVlIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBgJHN0YXRlLnNuYXBzaG90YCDigJQgdGhlIG9yaWdpbmFsIHZhbHVlIHdhcyByZXR1cm5lZCd9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGVgKTtcblx0fVxufSIsIi8qKiBAaW1wb3J0IHsgU25hcHNob3QgfSBmcm9tICcuL3R5cGVzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0X3Byb3RvdHlwZV9vZiwgaXNfYXJyYXksIG9iamVjdF9wcm90b3R5cGUgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLyoqXG4gKiBJbiBkZXYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcHJvcGVydGllcyBjb3VsZCBub3QgYmUgY2xvbmVkLiBJbiBwcm9kXG4gKiB3ZSBkb24ndCBib3RoZXIsIGJ1dCB3ZSBrZWVwIGEgZHVtbXkgYXJyYXkgYXJvdW5kIHNvIHRoYXQgdGhlXG4gKiBzaWduYXR1cmUgc3RheXMgdGhlIHNhbWVcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuY29uc3QgZW1wdHkgPSBbXTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICogQHJldHVybnMge1NuYXBzaG90PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcHNob3QodmFsdWUsIHNraXBfd2FybmluZyA9IGZhbHNlKSB7XG5cdGlmIChERVYgJiYgIXNraXBfd2FybmluZykge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgcGF0aHMgPSBbXTtcblxuXHRcdGNvbnN0IGNvcHkgPSBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgcGF0aHMpO1xuXHRcdGlmIChwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0gPT09ICcnKSB7XG5cdFx0XHQvLyB2YWx1ZSBjb3VsZCBub3QgYmUgY2xvbmVkXG5cdFx0XHR3LnN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKCk7XG5cdFx0fSBlbHNlIGlmIChwYXRocy5sZW5ndGggPiAwKSB7XG5cdFx0XHQvLyBzb21lIHByb3BlcnRpZXMgY291bGQgbm90IGJlIGNsb25lZFxuXHRcdFx0Y29uc3Qgc2xpY2UgPSBwYXRocy5sZW5ndGggPiAxMCA/IHBhdGhzLnNsaWNlKDAsIDcpIDogcGF0aHMuc2xpY2UoMCwgMTApO1xuXHRcdFx0Y29uc3QgZXhjZXNzID0gcGF0aHMubGVuZ3RoIC0gc2xpY2UubGVuZ3RoO1xuXG5cdFx0XHRsZXQgdW5jbG9uZWQgPSBzbGljZS5tYXAoKHBhdGgpID0+IGAtIDx2YWx1ZT4ke3BhdGh9YCkuam9pbignXFxuJyk7XG5cdFx0XHRpZiAoZXhjZXNzID4gMCkgdW5jbG9uZWQgKz0gYFxcbi0gLi4uYW5kICR7ZXhjZXNzfSBtb3JlYDtcblxuXHRcdFx0dy5zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZSh1bmNsb25lZCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvcHk7XG5cdH1cblxuXHRyZXR1cm4gY2xvbmUodmFsdWUsIG5ldyBNYXAoKSwgJycsIGVtcHR5KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtNYXA8VCwgU25hcHNob3Q8VD4+fSBjbG9uZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoc1xuICogQHBhcmFtIHtudWxsIHwgVH0gb3JpZ2luYWwgVGhlIG9yaWdpbmFsIHZhbHVlLCBpZiBgdmFsdWVgIHdhcyBwcm9kdWNlZCBmcm9tIGEgYHRvSlNPTmAgY2FsbFxuICogQHJldHVybnMge1NuYXBzaG90PFQ+fVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSwgY2xvbmVkLCBwYXRoLCBwYXRocywgb3JpZ2luYWwgPSBudWxsKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0dmFyIHVud3JhcHBlZCA9IGNsb25lZC5nZXQodmFsdWUpO1xuXHRcdGlmICh1bndyYXBwZWQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHVud3JhcHBlZDtcblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgcmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChuZXcgTWFwKHZhbHVlKSk7XG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSByZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKG5ldyBTZXQodmFsdWUpKTtcblxuXHRcdGlmIChpc19hcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhciBjb3B5ID0gLyoqIEB0eXBlIHtTbmFwc2hvdDxhbnk+fSAqLyAoQXJyYXkodmFsdWUubGVuZ3RoKSk7XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdmFsdWVbaV07XG5cdFx0XHRcdGlmIChpIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IGNsb25lKGVsZW1lbnQsIGNsb25lZCwgREVWID8gYCR7cGF0aH1bJHtpfV1gIDogcGF0aCwgcGF0aHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmIChnZXRfcHJvdG90eXBlX29mKHZhbHVlKSA9PT0gb2JqZWN0X3Byb3RvdHlwZSkge1xuXHRcdFx0LyoqIEB0eXBlIHtTbmFwc2hvdDxhbnk+fSAqL1xuXHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0Y2xvbmVkLnNldCh2YWx1ZSwgY29weSk7XG5cblx0XHRcdGlmIChvcmlnaW5hbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjbG9uZWQuc2V0KG9yaWdpbmFsLCBjb3B5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0Y29weVtrZXldID0gY2xvbmUodmFsdWVba2V5XSwgY2xvbmVkLCBERVYgPyBgJHtwYXRofS4ke2tleX1gIDogcGF0aCwgcGF0aHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29weTtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSkpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgKC8qKiBAdHlwZSB7VCAmIHsgdG9KU09OPzogYW55IH0gfSAqLyAodmFsdWUpLnRvSlNPTikgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBjbG9uZShcblx0XHRcdFx0LyoqIEB0eXBlIHtUICYgeyB0b0pTT04oKTogYW55IH0gfSAqLyAodmFsdWUpLnRvSlNPTigpLFxuXHRcdFx0XHRjbG9uZWQsXG5cdFx0XHRcdERFViA/IGAke3BhdGh9LnRvSlNPTigpYCA6IHBhdGgsXG5cdFx0XHRcdHBhdGhzLFxuXHRcdFx0XHQvLyBBc3NvY2lhdGUgdGhlIGluc3RhbmNlIHdpdGggdGhlIHRvSlNPTiBjbG9uZVxuXHRcdFx0XHR2YWx1ZVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRpZiAodmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuXHRcdC8vIGNhbid0IGJlIGNsb25lZFxuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAodmFsdWUpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSkpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0cGF0aHMucHVzaChwYXRoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHZhbHVlKTtcblx0fVxufVxuIiwiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxudmFyIGJvbGQgPSAnZm9udC13ZWlnaHQ6IGJvbGQnO1xudmFyIG5vcm1hbCA9ICdmb250LXdlaWdodDogbm9ybWFsJztcblxuLyoqXG4gKiBBc3NpZ25tZW50IHRvIGAlcHJvcGVydHklYCBwcm9wZXJ0eSAoJWxvY2F0aW9uJSkgd2lsbCBldmFsdWF0ZSB0byB0aGUgcmlnaHQtaGFuZCBzaWRlLCBub3QgdGhlIHZhbHVlIG9mIGAlcHJvcGVydHklYCBmb2xsb3dpbmcgdGhlIGFzc2lnbm1lbnQuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25tZW50X3ZhbHVlX3N0YWxlKHByb3BlcnR5LCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGFzc2lnbm1lbnRfdmFsdWVfc3RhbGVcXG4lY0Fzc2lnbm1lbnQgdG8gXFxgJHtwcm9wZXJ0eX1cXGAgcHJvcGVydHkgKCR7bG9jYXRpb259KSB3aWxsIGV2YWx1YXRlIHRvIHRoZSByaWdodC1oYW5kIHNpZGUsIG5vdCB0aGUgdmFsdWUgb2YgXFxgJHtwcm9wZXJ0eX1cXGAgZm9sbG93aW5nIHRoZSBhc3NpZ25tZW50LiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvdXIuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXNzaWdubWVudF92YWx1ZV9zdGFsZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9hc3NpZ25tZW50X3ZhbHVlX3N0YWxlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJWJpbmRpbmclYCAoJWxvY2F0aW9uJSkgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmUoYmluZGluZywgbG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZVxcbiVjJHtsb2NhdGlvbiA/IGBcXGAke2JpbmRpbmd9XFxgICgke2xvY2F0aW9ufSkgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eWAgOiBgXFxgJHtiaW5kaW5nfVxcYCBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5YH1cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWApO1xuXHR9XG59XG5cbi8qKlxuICogWW91ciBgY29uc29sZS4lbWV0aG9kJWAgY29udGFpbmVkIGAkc3RhdGVgIHByb3hpZXMuIENvbnNpZGVyIHVzaW5nIGAkaW5zcGVjdCguLi4pYCBvciBgJHN0YXRlLnNuYXBzaG90KC4uLilgIGluc3RlYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnNvbGVfbG9nX3N0YXRlKG1ldGhvZCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGNvbnNvbGVfbG9nX3N0YXRlXFxuJWNZb3VyIFxcYGNvbnNvbGUuJHttZXRob2R9XFxgIGNvbnRhaW5lZCBcXGAkc3RhdGVcXGAgcHJveGllcy4gQ29uc2lkZXIgdXNpbmcgXFxgJGluc3BlY3QoLi4uKVxcYCBvciBcXGAkc3RhdGUuc25hcHNob3QoLi4uKVxcYCBpbnN0ZWFkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29uc29sZV9sb2dfc3RhdGVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29uc29sZV9sb2dfc3RhdGVgKTtcblx0fVxufVxuXG4vKipcbiAqICVoYW5kbGVyJSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBtZWFuIHRvICVzdWdnZXN0aW9uJT9cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3VnZ2VzdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGhhbmRsZXIsIHN1Z2dlc3Rpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBldmVudF9oYW5kbGVyX2ludmFsaWRcXG4lYyR7aGFuZGxlcn0gc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgbWVhbiB0byAke3N1Z2dlc3Rpb259P1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2V2ZW50X2hhbmRsZXJfaW52YWxpZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9ldmVudF9oYW5kbGVyX2ludmFsaWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgJWF0dHJpYnV0ZSVgIGF0dHJpYnV0ZSBvbiBgJWh0bWwlYCBjaGFuZ2VkIGl0cyB2YWx1ZSBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUsIGAldmFsdWUlYCwgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQoYXR0cmlidXRlLCBodG1sLCB2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZFxcbiVjVGhlIFxcYCR7YXR0cmlidXRlfVxcYCBhdHRyaWJ1dGUgb24gXFxgJHtodG1sfVxcYCBjaGFuZ2VkIGl0cyB2YWx1ZSBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUsIFxcYCR7dmFsdWV9XFxgLCB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgdmFsdWUgb2YgYW4gYHtAaHRtbCAuLi59YCBibG9jayAlbG9jYXRpb24lIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25faHRtbF9jaGFuZ2VkKGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX2h0bWxfY2hhbmdlZFxcbiVjJHtsb2NhdGlvbiA/IGBUaGUgdmFsdWUgb2YgYW4gXFxge0BodG1sIC4uLn1cXGAgYmxvY2sgJHtsb2NhdGlvbn0gY2hhbmdlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlYCA6ICdUaGUgdmFsdWUgb2YgYW4gYHtAaHRtbCAuLi59YCBibG9jayBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWUnfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9odG1sX2NoYW5nZWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2h0bWxfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSBlcnJvciBvY2N1cnJlZCBuZWFyICVsb2NhdGlvbiVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX21pc21hdGNoKGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX21pc21hdGNoXFxuJWMke2xvY2F0aW9uID8gYEh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLiBUaGUgZXJyb3Igb2NjdXJyZWQgbmVhciAke2xvY2F0aW9ufWAgOiAnSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXInfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fbWlzbWF0Y2hgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgcmVuZGVyYCBmdW5jdGlvbiBwYXNzZWQgdG8gYGNyZWF0ZVJhd1NuaXBwZXRgIHNob3VsZCByZXR1cm4gSFRNTCBmb3IgYSBzaW5nbGUgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJcXG4lY1RoZSBcXGByZW5kZXJcXGAgZnVuY3Rpb24gcGFzc2VkIHRvIFxcYGNyZWF0ZVJhd1NuaXBwZXRcXGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJgKTtcblx0fVxufVxuXG4vKipcbiAqIERldGVjdGVkIGEgbWlncmF0ZWQgYCQ6YCByZWFjdGl2ZSBibG9jayBpbiBgJWZpbGVuYW1lJWAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBgJGVmZmVjdGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2soZmlsZW5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBsZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrXFxuJWNEZXRlY3RlZCBhIG1pZ3JhdGVkIFxcYCQ6XFxgIHJlYWN0aXZlIGJsb2NrIGluIFxcYCR7ZmlsZW5hbWV9XFxgIHRoYXQgYm90aCBhY2Nlc3NlcyBhbmQgdXBkYXRlcyB0aGUgc2FtZSByZWFjdGl2ZSB2YWx1ZS4gVGhpcyBtYXkgY2F1c2UgcmVjdXJzaXZlIHVwZGF0ZXMgd2hlbiBjb252ZXJ0ZWQgdG8gYW4gXFxgJGVmZmVjdFxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9sZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgKTtcblx0fVxufVxuXG4vKipcbiAqIFRyaWVkIHRvIHVubW91bnQgYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IG1vdW50ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBsaWZlY3ljbGVfZG91YmxlX3VubW91bnRcXG4lY1RyaWVkIHRvIHVubW91bnQgYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IG1vdW50ZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlcGFyZW50JSBwYXNzZWQgYSB2YWx1ZSB0byAlY2hpbGQlIHdpdGggYGJpbmQ6YCwgYnV0IHRoZSB2YWx1ZSBpcyBvd25lZCBieSAlb3duZXIlLiBDb25zaWRlciBjcmVhdGluZyBhIGJpbmRpbmcgYmV0d2VlbiAlb3duZXIlIGFuZCAlcGFyZW50JVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gb3duZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcocGFyZW50LCBjaGlsZCwgb3duZXIpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nXFxuJWMke3BhcmVudH0gcGFzc2VkIGEgdmFsdWUgdG8gJHtjaGlsZH0gd2l0aCBcXGBiaW5kOlxcYCwgYnV0IHRoZSB2YWx1ZSBpcyBvd25lZCBieSAke293bmVyfS4gQ29uc2lkZXIgY3JlYXRpbmcgYSBiaW5kaW5nIGJldHdlZW4gJHtvd25lcn0gYW5kICR7cGFyZW50fVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogJWNvbXBvbmVudCUgbXV0YXRlZCBhIHZhbHVlIG93bmVkIGJ5ICVvd25lciUuIFRoaXMgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQuIENvbnNpZGVyIHBhc3NpbmcgdmFsdWVzIHRvIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBgYmluZDpgLCBvciB1c2UgYSBjYWxsYmFjayBpbnN0ZWFkXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtjb21wb25lbnRdXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtvd25lcl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKGNvbXBvbmVudCwgb3duZXIpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvblxcbiVjJHtjb21wb25lbnQgPyBgJHtjb21wb25lbnR9IG11dGF0ZWQgYSB2YWx1ZSBvd25lZCBieSAke293bmVyfS4gVGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgcGFzc2luZyB2YWx1ZXMgdG8gY2hpbGQgY29tcG9uZW50cyB3aXRoIFxcYGJpbmQ6XFxgLCBvciB1c2UgYSBjYWxsYmFjayBpbnN0ZWFkYCA6ICdNdXRhdGluZyBhIHZhbHVlIG91dHNpZGUgdGhlIGNvbXBvbmVudCB0aGF0IGNyZWF0ZWQgaXQgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQuIENvbnNpZGVyIHBhc3NpbmcgdmFsdWVzIHRvIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBgYmluZDpgLCBvciB1c2UgYSBjYWxsYmFjayBpbnN0ZWFkJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbmAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbmApO1xuXHR9XG59XG5cbi8qKlxuICogUmVhY3RpdmUgYCRzdGF0ZSguLi4pYCBwcm94aWVzIGFuZCB0aGUgdmFsdWVzIHRoZXkgcHJveHkgaGF2ZSBkaWZmZXJlbnQgaWRlbnRpdGllcy4gQmVjYXVzZSBvZiB0aGlzLCBjb21wYXJpc29ucyB3aXRoIGAlb3BlcmF0b3IlYCB3aWxsIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKG9wZXJhdG9yKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hcXG4lY1JlYWN0aXZlIFxcYCRzdGF0ZSguLi4pXFxgIHByb3hpZXMgYW5kIHRoZSB2YWx1ZXMgdGhleSBwcm94eSBoYXZlIGRpZmZlcmVudCBpZGVudGl0aWVzLiBCZWNhdXNlIG9mIHRoaXMsIGNvbXBhcmlzb25zIHdpdGggXFxgJHtvcGVyYXRvcn1cXGAgd2lsbCBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0c1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHNsaWRlYCB0cmFuc2l0aW9uIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciBlbGVtZW50cyB3aXRoIGBkaXNwbGF5OiAldmFsdWUlYFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXkodmFsdWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSB0cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXlcXG4lY1RoZSBcXGBzbGlkZVxcYCB0cmFuc2l0aW9uIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciBlbGVtZW50cyB3aXRoIFxcYGRpc3BsYXk6ICR7dmFsdWV9XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3RyYW5zaXRpb25fc2xpZGVfZGlzcGxheWApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBQcm94eU1ldGFkYXRhIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAdHlwZWRlZiB7eyBmaWxlOiBzdHJpbmcsIGxpbmU6IG51bWJlciwgY29sdW1uOiBudW1iZXIgfX0gTG9jYXRpb24gKi9cblxuaW1wb3J0IHsgU1RBVEVfU1lNQk9MX01FVEFEQVRBIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIHVzZXJfcHJlX2VmZmVjdCB9IGZyb20gJy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGdldF9wcm90b3R5cGVfb2YgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBGSUxFTkFNRSwgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQXJyYXk8eyBzdGFydDogTG9jYXRpb24sIGVuZDogTG9jYXRpb24sIGNvbXBvbmVudDogRnVuY3Rpb24gfT4+fSAqL1xuY29uc3QgYm91bmRhcmllcyA9IHt9O1xuXG5jb25zdCBjaHJvbWVfcGF0dGVybiA9IC9hdCAoPzouKyBcXCgpPyguKyk6KFxcZCspOihcXGQrKVxcKT8kLztcbmNvbnN0IGZpcmVmb3hfcGF0dGVybiA9IC9AKC4rKTooXFxkKyk6KFxcZCspJC87XG5cbmZ1bmN0aW9uIGdldF9zdGFjaygpIHtcblx0Y29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcblx0aWYgKCFzdGFjaykgcmV0dXJuIG51bGw7XG5cblx0Y29uc3QgZW50cmllcyA9IFtdO1xuXG5cdGZvciAoY29uc3QgbGluZSBvZiBzdGFjay5zcGxpdCgnXFxuJykpIHtcblx0XHRsZXQgbWF0Y2ggPSBjaHJvbWVfcGF0dGVybi5leGVjKGxpbmUpID8/IGZpcmVmb3hfcGF0dGVybi5leGVjKGxpbmUpO1xuXG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRlbnRyaWVzLnB1c2goe1xuXHRcdFx0XHRmaWxlOiBtYXRjaFsxXSxcblx0XHRcdFx0bGluZTogK21hdGNoWzJdLFxuXHRcdFx0XHRjb2x1bW46ICttYXRjaFszXVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVudHJpZXM7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGljaCBgLnN2ZWx0ZWAgY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlIGZvciBhIGdpdmVuIHN0YXRlIGNoYW5nZVxuICogQHJldHVybnMge0Z1bmN0aW9uIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9jb21wb25lbnQoKSB7XG5cdC8vIGZpcnN0IDQgbGluZXMgYXJlIHN2ZWx0ZSBpbnRlcm5hbHM7IGFkanVzdCB0aGlzIG51bWJlciBpZiB3ZSBjaGFuZ2UgdGhlIGludGVybmFsIGNhbGwgc3RhY2tcblx0Y29uc3Qgc3RhY2sgPSBnZXRfc3RhY2soKT8uc2xpY2UoNCk7XG5cdGlmICghc3RhY2spIHJldHVybiBudWxsO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBlbnRyeSA9IHN0YWNrW2ldO1xuXHRcdGNvbnN0IG1vZHVsZXMgPSBib3VuZGFyaWVzW2VudHJ5LmZpbGVdO1xuXHRcdGlmICghbW9kdWxlcykge1xuXHRcdFx0Ly8gSWYgdGhlIGZpcnN0IGVudHJ5IGlzIG5vdCBhIGNvbXBvbmVudCwgdGhhdCBtZWFucyB0aGUgbW9kaWZpY2F0aW9uIHZlcnkgbGlrZWx5IGhhcHBlbmVkXG5cdFx0XHQvLyB3aXRoaW4gYSAuc3ZlbHRlLmpzIGZpbGUsIHBvc3NpYmx5IHRyaWdnZXJlZCBieSBhIGNvbXBvbmVudC4gU2luY2UgdGhlc2UgZmlsZXMgYXJlIG5vdCBwYXJ0XG5cdFx0XHQvLyBvZiB0aGUgYm9uZGFyaWVzL2NvbXBvbmVudCBjb250ZXh0IGhldXJpc3RpYywgd2UgbmVlZCB0byBiYWlsIGluIHRoaXMgY2FzZSwgZWxzZSB3ZSB3b3VsZFxuXHRcdFx0Ly8gaGF2ZSBmYWxzZSBwb3NpdGl2ZXMgd2hlbiB0aGUgLnN2ZWx0ZS50cyBmaWxlIHByb3ZpZGVzIGEgc3RhdGUgY3JlYXRvciBmdW5jdGlvbiwgZW5jYXBzdWxhdGluZ1xuXHRcdFx0Ly8gdGhlIHN0YXRlIGFuZCBpdHMgbXV0YXRpb25zLCBhbmQgaXMgYmVpbmcgY2FsbGVkIGZyb20gYSBjb21wb25lbnQgb3RoZXIgdGhhbiB0aGUgb25lIHdob1xuXHRcdFx0Ly8gY2FsbGVkIHRoZSBzdGF0ZSBjcmVhdG9yIGZ1bmN0aW9uLlxuXHRcdFx0aWYgKGkgPT09IDApIHJldHVybiBudWxsO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuXHRcdFx0aWYgKG1vZHVsZS5lbmQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmIChtb2R1bGUuc3RhcnQubGluZSA8IGVudHJ5LmxpbmUgJiYgbW9kdWxlLmVuZC5saW5lID4gZW50cnkubGluZSkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmNvbXBvbmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IEFERF9PV05FUiA9IFN5bWJvbCgnQUREX09XTkVSJyk7XG5cbi8qKlxuICogVG9nZXRoZXIgd2l0aCBgbWFya19tb2R1bGVfZW5kYCwgdGhpcyBmdW5jdGlvbiBlc3RhYmxpc2hlcyB0aGUgYm91bmRhcmllcyBvZiBhIGAuc3ZlbHRlYCBmaWxlLFxuICogc3VjaCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gYGdldF9jb21wb25lbnRgIGNhbiB0ZWxsIHVzIHdoaWNoIGNvbXBvbmVudCBpcyByZXNwb25zaWJsZVxuICogZm9yIGEgZ2l2ZW4gc3RhdGUgY2hhbmdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrX21vZHVsZV9zdGFydCgpIHtcblx0Y29uc3Qgc3RhcnQgPSBnZXRfc3RhY2soKT8uWzJdO1xuXG5cdGlmIChzdGFydCkge1xuXHRcdChib3VuZGFyaWVzW3N0YXJ0LmZpbGVdID8/PSBbXSkucHVzaCh7XG5cdFx0XHRzdGFydCxcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGVuZDogbnVsbCxcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Igd2UgYWRkIHRoZSBjb21wb25lbnQgYXQgdGhlIGVuZCwgc2luY2UgSE1SIHdpbGwgb3ZlcndyaXRlIHRoZSBmdW5jdGlvblxuXHRcdFx0Y29tcG9uZW50OiBudWxsXG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtfbW9kdWxlX2VuZChjb21wb25lbnQpIHtcblx0Y29uc3QgZW5kID0gZ2V0X3N0YWNrKCk/LlsyXTtcblxuXHRpZiAoZW5kKSB7XG5cdFx0Y29uc3QgYm91bmRhcmllc19maWxlID0gYm91bmRhcmllc1tlbmQuZmlsZV07XG5cdFx0Y29uc3QgYm91bmRhcnkgPSBib3VuZGFyaWVzX2ZpbGVbYm91bmRhcmllc19maWxlLmxlbmd0aCAtIDFdO1xuXG5cdFx0Ym91bmRhcnkuZW5kID0gZW5kO1xuXHRcdGJvdW5kYXJ5LmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEBwYXJhbSB7YW55IHwgbnVsbH0gb3duZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9vd25lcihvYmplY3QsIG93bmVyLCBnbG9iYWwgPSBmYWxzZSwgc2tpcF93YXJuaW5nID0gZmFsc2UpIHtcblx0aWYgKG9iamVjdCAmJiAhZ2xvYmFsKSB7XG5cdFx0Y29uc3QgY29tcG9uZW50ID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdGNvbnN0IG1ldGFkYXRhID0gb2JqZWN0W1NUQVRFX1NZTUJPTF9NRVRBREFUQV07XG5cdFx0aWYgKG1ldGFkYXRhICYmICFoYXNfb3duZXIobWV0YWRhdGEsIGNvbXBvbmVudCkpIHtcblx0XHRcdGxldCBvcmlnaW5hbCA9IGdldF9vd25lcihtZXRhZGF0YSk7XG5cblx0XHRcdGlmIChvd25lciAmJiBvd25lcltGSUxFTkFNRV0gIT09IGNvbXBvbmVudFtGSUxFTkFNRV0gJiYgIXNraXBfd2FybmluZykge1xuXHRcdFx0XHR3Lm93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcoY29tcG9uZW50W0ZJTEVOQU1FXSwgb3duZXJbRklMRU5BTUVdLCBvcmlnaW5hbFtGSUxFTkFNRV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0LCBvd25lciwgbmV3IFNldCgpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldF9vYmplY3RcbiAqIEBwYXJhbSB7YW55fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9vd25lcl9lZmZlY3QoZ2V0X29iamVjdCwgQ29tcG9uZW50LCBza2lwX3dhcm5pbmcgPSBmYWxzZSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdGFkZF9vd25lcihnZXRfb2JqZWN0KCksIENvbXBvbmVudCwgZmFsc2UsIHNraXBfd2FybmluZyk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBfdGhpc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3duZXJcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gYW55Pn0gZ2V0dGVyc1xuICogQHBhcmFtIHtib29sZWFufSBza2lwX3dhcm5pbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9vd25lcl90b19jbGFzcyhfdGhpcywgb3duZXIsIGdldHRlcnMsIHNraXBfd2FybmluZykge1xuXHRfdGhpc1tBRERfT1dORVJdLmN1cnJlbnQgfHw9IGdldHRlcnMubWFwKCgpID0+IFVOSU5JVElBTElaRUQpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZ2V0dGVycy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBnZXR0ZXJzW2ldKCk7XG5cdFx0Ly8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgd2Ugb25seSByZS1hZGQgdGhlIG93bmVyIGlmIHRoZSBzdGF0ZSBoYXMgY2hhbmdlZFxuXHRcdGlmIChjdXJyZW50ICE9PSBfdGhpc1tBRERfT1dORVJdW2ldKSB7XG5cdFx0XHRfdGhpc1tBRERfT1dORVJdLmN1cnJlbnRbaV0gPSBjdXJyZW50O1xuXHRcdFx0YWRkX293bmVyKGN1cnJlbnQsIG93bmVyLCBmYWxzZSwgc2tpcF93YXJuaW5nKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGEgfCBudWxsfSBmcm9tXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGF9IHRvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aWRlbl9vd25lcnNoaXAoZnJvbSwgdG8pIHtcblx0aWYgKHRvLm93bmVycyA9PT0gbnVsbCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHdoaWxlIChmcm9tKSB7XG5cdFx0aWYgKGZyb20ub3duZXJzID09PSBudWxsKSB7XG5cdFx0XHR0by5vd25lcnMgPSBudWxsO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBvd25lciBvZiBmcm9tLm93bmVycykge1xuXHRcdFx0dG8ub3duZXJzLmFkZChvd25lcik7XG5cdFx0fVxuXG5cdFx0ZnJvbSA9IGZyb20ucGFyZW50O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbiB8IG51bGx9IG93bmVyIElmIGBudWxsYCwgdGhlbiB0aGUgb2JqZWN0IGlzIGdsb2JhbGx5IG93bmVkIGFuZCB3aWxsIG5vdCBiZSBjaGVja2VkXG4gKiBAcGFyYW0ge1NldDxhbnk+fSBzZWVuXG4gKi9cbmZ1bmN0aW9uIGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0LCBvd25lciwgc2Vlbikge1xuXHRjb25zdCBtZXRhZGF0YSA9IC8qKiBAdHlwZSB7UHJveHlNZXRhZGF0YX0gKi8gKG9iamVjdD8uW1NUQVRFX1NZTUJPTF9NRVRBREFUQV0pO1xuXG5cdGlmIChtZXRhZGF0YSkge1xuXHRcdC8vIHRoaXMgaXMgYSBzdGF0ZSBwcm94eSwgYWRkIG93bmVyIGRpcmVjdGx5LCBpZiBub3QgZ2xvYmFsbHkgc2hhcmVkXG5cdFx0aWYgKCdvd25lcnMnIGluIG1ldGFkYXRhICYmIG1ldGFkYXRhLm93bmVycyAhPSBudWxsKSB7XG5cdFx0XHRpZiAob3duZXIpIHtcblx0XHRcdFx0bWV0YWRhdGEub3duZXJzLmFkZChvd25lcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZXRhZGF0YS5vd25lcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoc2Vlbi5oYXMob2JqZWN0KSkgcmV0dXJuO1xuXHRcdHNlZW4uYWRkKG9iamVjdCk7XG5cdFx0aWYgKEFERF9PV05FUiBpbiBvYmplY3QgJiYgb2JqZWN0W0FERF9PV05FUl0pIHtcblx0XHRcdC8vIHRoaXMgaXMgYSBjbGFzcyB3aXRoIHN0YXRlIGZpZWxkcy4gd2UgcHV0IHRoaXMgaW4gYSByZW5kZXIgZWZmZWN0XG5cdFx0XHQvLyBzbyB0aGF0IGlmIHN0YXRlIGlzIHJlcGxhY2VkIChlLmcuIGBpbnN0YW5jZS5uYW1lID0geyBmaXJzdCwgbGFzdCB9YClcblx0XHRcdC8vIHRoZSBuZXcgc3RhdGUgaXMgYWxzbyBjby1vd25lZCBieSB0aGUgY2FsbGVyIG9mIGBnZXRDb250ZXh0YFxuXHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdG9iamVjdFtBRERfT1dORVJdKG93bmVyKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKG9iamVjdCk7XG5cblx0XHRcdGlmIChwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuXHRcdFx0XHQvLyByZWN1cnNlIHVudGlsIHdlIGZpbmQgYSBzdGF0ZSBwcm94eVxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSk/LmdldCkge1xuXHRcdFx0XHRcdFx0Ly8gU2ltaWxhciB0byB0aGUgY2xhc3MgY2FzZTsgdGhlIGdldHRlciBjb3VsZCB1cGRhdGUgd2l0aCBhIG5ldyBzdGF0ZVxuXHRcdFx0XHRcdFx0bGV0IGN1cnJlbnQgPSBVTklOSVRJQUxJWkVEO1xuXHRcdFx0XHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5leHQgPSBvYmplY3Rba2V5XTtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQgIT09IG5leHQpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0XHRhZGRfb3duZXJfdG9fb2JqZWN0KG5leHQsIG93bmVyLCBzZWVuKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0W2tleV0sIG93bmVyLCBzZWVuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocHJvdG8gPT09IEFycmF5LnByb3RvdHlwZSkge1xuXHRcdFx0XHQvLyByZWN1cnNlIHVudGlsIHdlIGZpbmQgYSBzdGF0ZSBwcm94eVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdGFkZF9vd25lcl90b19vYmplY3Qob2JqZWN0W2ldLCBvd25lciwgc2Vlbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3h5TWV0YWRhdGF9IG1ldGFkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNfb3duZXIobWV0YWRhdGEsIGNvbXBvbmVudCkge1xuXHRpZiAobWV0YWRhdGEub3duZXJzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gKFxuXHRcdG1ldGFkYXRhLm93bmVycy5oYXMoY29tcG9uZW50KSB8fFxuXHRcdC8vIFRoaXMgaGVscHMgYXZvaWQgZmFsc2UgcG9zaXRpdmVzIHdoZW4gdXNpbmcgSE1SLCB3aGVyZSB0aGUgY29tcG9uZW50IGZ1bmN0aW9uIGlzIHJlcGxhY2VkXG5cdFx0KEZJTEVOQU1FIGluIGNvbXBvbmVudCAmJlxuXHRcdFx0Wy4uLm1ldGFkYXRhLm93bmVyc10uc29tZShcblx0XHRcdFx0KG93bmVyKSA9PiAvKiogQHR5cGUge2FueX0gKi8gKG93bmVyKVtGSUxFTkFNRV0gPT09IGNvbXBvbmVudFtGSUxFTkFNRV1cblx0XHRcdCkpIHx8XG5cdFx0KG1ldGFkYXRhLnBhcmVudCAhPT0gbnVsbCAmJiBoYXNfb3duZXIobWV0YWRhdGEucGFyZW50LCBjb21wb25lbnQpKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gbWV0YWRhdGFcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldF9vd25lcihtZXRhZGF0YSkge1xuXHRyZXR1cm4gKFxuXHRcdG1ldGFkYXRhPy5vd25lcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSA/P1xuXHRcdGdldF9vd25lcigvKiogQHR5cGUge1Byb3h5TWV0YWRhdGF9ICovIChtZXRhZGF0YS5wYXJlbnQpKVxuXHQpO1xufVxuXG5sZXQgc2tpcCA9IGZhbHNlO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2tpcF9vd25lcnNoaXBfdmFsaWRhdGlvbihmbikge1xuXHRza2lwID0gdHJ1ZTtcblx0Zm4oKTtcblx0c2tpcCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gbWV0YWRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX293bmVyc2hpcChtZXRhZGF0YSkge1xuXHRpZiAoc2tpcCkgcmV0dXJuO1xuXG5cdGNvbnN0IGNvbXBvbmVudCA9IGdldF9jb21wb25lbnQoKTtcblxuXHRpZiAoY29tcG9uZW50ICYmICFoYXNfb3duZXIobWV0YWRhdGEsIGNvbXBvbmVudCkpIHtcblx0XHRsZXQgb3JpZ2luYWwgPSBnZXRfb3duZXIobWV0YWRhdGEpO1xuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGlmIChvcmlnaW5hbFtGSUxFTkFNRV0gIT09IGNvbXBvbmVudFtGSUxFTkFNRV0pIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdHcub3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24oY29tcG9uZW50W0ZJTEVOQU1FXSwgb3JpZ2luYWxbRklMRU5BTUVdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbigpO1xuXHRcdH1cblx0fVxufVxuIiwiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuLyoqXG4gKiBDYW5ub3QgdXNlIGB7QHJlbmRlciBjaGlsZHJlbiguLi4pfWAgaWYgdGhlIHBhcmVudCBjb21wb25lbnQgdXNlcyBgbGV0OmAgZGlyZWN0aXZlcy4gQ29uc2lkZXIgdXNpbmcgYSBuYW1lZCBzbmlwcGV0IGluc3RlYWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRfZGVmYXVsdF9zbmlwcGV0KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGludmFsaWRfZGVmYXVsdF9zbmlwcGV0XFxuQ2Fubm90IHVzZSBcXGB7QHJlbmRlciBjaGlsZHJlbiguLi4pfVxcYCBpZiB0aGUgcGFyZW50IGNvbXBvbmVudCB1c2VzIFxcYGxldDpcXGAgZGlyZWN0aXZlcy4gQ29uc2lkZXIgdXNpbmcgYSBuYW1lZCBzbmlwcGV0IGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX2RlZmF1bHRfc25pcHBldGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRcXG5cXGAke25hbWV9KC4uLilcXGAgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSVgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBgc3Vic2NyaWJlYCBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9pbnZhbGlkX3NoYXBlKG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdG9yZV9pbnZhbGlkX3NoYXBlXFxuXFxgJHtuYW1lfVxcYCBpcyBub3QgYSBzdG9yZSB3aXRoIGEgXFxgc3Vic2NyaWJlXFxgIG1ldGhvZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0b3JlX2ludmFsaWRfc2hhcGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0b3JlX2ludmFsaWRfc2hhcGVgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgdGhpc2AgcHJvcCBvbiBgPHN2ZWx0ZTplbGVtZW50PmAgbXVzdCBiZSBhIHN0cmluZywgaWYgZGVmaW5lZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZVxcblRoZSBcXGB0aGlzXFxgIHByb3Agb24gXFxgPHN2ZWx0ZTplbGVtZW50PlxcYCBtdXN0IGJlIGEgc3RyaW5nLCBpZiBkZWZpbmVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblx0fVxufSIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCB9IGZyb20gJyNjbGllbnQnICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgYWRkX293bmVyIH0gZnJvbSAnLi9kZXYvb3duZXJzaGlwLmpzJztcbmltcG9ydCB7IGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCB9IGZyb20gJy4uL3NoYXJlZC9lcnJvcnMuanMnO1xuaW1wb3J0IHsgc291cmNlIH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbixcblx0dW50cmFja1xufSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY29tcG9uZW50X2NvbnRleHQgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29udGV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jb21wb25lbnRfY29udGV4dChjb250ZXh0KSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGN1cnJlbnQgY29tcG9uZW50IGNvbnRleHQ6XG4gKiBgYGBodG1sXG4gKiA8IS0tIEFwcC5zdmVsdGUgLS0+XG4gKiA8Rm9vPlxuICogICA8QmFyIC8+IDwhLS0gY29udGV4dCA9PSBGb28uc3ZlbHRlLCBmdW5jdGlvbiA9PSBBcHAuc3ZlbHRlIC0tPlxuICogPC9Gb28+XG4gKiBgYGBcbiAqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfVxuICovXG5leHBvcnQgbGV0IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRbJ2Z1bmN0aW9uJ119IGZuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihmbikge1xuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBmbjtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRDb250ZXh0Jyk7XG5cdGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7VH0gKi8gKGNvbnRleHRfbWFwLmdldChrZXkpKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcGFyYW0ge1R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnc2V0Q29udGV4dCcpO1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBXaGVuIHN0YXRlIGlzIHB1dCBpbnRvIGNvbnRleHQsIHdlIHRyZWF0IGFzIGlmIGl0J3MgZ2xvYmFsIGZyb20gbm93IG9uLlxuXHRcdC8vIFdlIGRvIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIChpdCdzIGZvciBleGFtcGxlIHZlcnkgZXhwZW5zaXZlIHRvIGNhbGxcblx0XHQvLyBnZXRDb250ZXh0IG9uIGEgYmlnIG9iamVjdCBtYW55IHRpbWVzIHdoZW4gcGFydCBvZiBhIGxpc3QgY29tcG9uZW50KVxuXHRcdC8vIGFuZCBkYW5nZXIgb2YgZmFsc2UgcG9zaXRpdmVzLlxuXHRcdHVudHJhY2soKCkgPT4gYWRkX293bmVyKGNvbnRleHQsIG51bGwsIHRydWUpKTtcblx0fVxuXG5cdGNvbnRleHRfbWFwLnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnaGFzQ29udGV4dCcpO1xuXHRyZXR1cm4gY29udGV4dF9tYXAuaGFzKGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRBbGxDb250ZXh0cycpO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge2FueX0gcnVuZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaChwcm9wcywgcnVuZXMgPSBmYWxzZSwgZm4pIHtcblx0Y29tcG9uZW50X2NvbnRleHQgPSB7XG5cdFx0cDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0YzogbnVsbCxcblx0XHRlOiBudWxsLFxuXHRcdG06IGZhbHNlLFxuXHRcdHM6IHByb3BzLFxuXHRcdHg6IG51bGwsXG5cdFx0bDogbnVsbFxuXHR9O1xuXG5cdGlmIChsZWdhY3lfbW9kZV9mbGFnICYmICFydW5lcykge1xuXHRcdGNvbXBvbmVudF9jb250ZXh0LmwgPSB7XG5cdFx0XHRzOiBudWxsLFxuXHRcdFx0dTogbnVsbCxcblx0XHRcdHIxOiBbXSxcblx0XHRcdHIyOiBzb3VyY2UoZmFsc2UpXG5cdFx0fTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHQvLyBjb21wb25lbnQgZnVuY3Rpb25cblx0XHRjb21wb25lbnRfY29udGV4dC5mdW5jdGlvbiA9IGZuO1xuXHRcdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IGZuO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBUXG4gKiBAcGFyYW0ge1R9IFtjb21wb25lbnRdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvcChjb21wb25lbnQpIHtcblx0Y29uc3QgY29udGV4dF9zdGFja19pdGVtID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdGlmIChjb250ZXh0X3N0YWNrX2l0ZW0gIT09IG51bGwpIHtcblx0XHRpZiAoY29tcG9uZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnRleHRfc3RhY2tfaXRlbS54ID0gY29tcG9uZW50O1xuXHRcdH1cblx0XHRjb25zdCBjb21wb25lbnRfZWZmZWN0cyA9IGNvbnRleHRfc3RhY2tfaXRlbS5lO1xuXHRcdGlmIChjb21wb25lbnRfZWZmZWN0cyAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdFx0XHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0XHRjb250ZXh0X3N0YWNrX2l0ZW0uZSA9IG51bGw7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudF9lZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNvbXBvbmVudF9lZmZlY3QgPSBjb21wb25lbnRfZWZmZWN0c1tpXTtcblx0XHRcdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChjb21wb25lbnRfZWZmZWN0LmVmZmVjdCk7XG5cdFx0XHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihjb21wb25lbnRfZWZmZWN0LnJlYWN0aW9uKTtcblx0XHRcdFx0XHRlZmZlY3QoY29tcG9uZW50X2VmZmVjdC5mbik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb21wb25lbnRfY29udGV4dCA9IGNvbnRleHRfc3RhY2tfaXRlbS5wO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IGNvbnRleHRfc3RhY2tfaXRlbS5wPy5mdW5jdGlvbiA/PyBudWxsO1xuXHRcdH1cblx0XHRjb250ZXh0X3N0YWNrX2l0ZW0ubSA9IHRydWU7XG5cdH1cblx0Ly8gTWljcm8tb3B0aW1pemF0aW9uOiBEb24ndCBzZXQgLmEgYWJvdmUgdG8gdGhlIGVtcHR5IG9iamVjdFxuXHQvLyBzbyBpdCBjYW4gYmUgZ2FyYmFnZS1jb2xsZWN0ZWQgd2hlbiB0aGUgcmV0dXJuIGhlcmUgaXMgdW51c2VkXG5cdHJldHVybiBjb21wb25lbnQgfHwgLyoqIEB0eXBlIHtUfSAqLyAoe30pO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZXMoKSB7XG5cdHJldHVybiAhbGVnYWN5X21vZGVfZmxhZyB8fCAoY29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiYgY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtNYXA8dW5rbm93biwgdW5rbm93bj59XG4gKi9cbmZ1bmN0aW9uIGdldF9vcl9pbml0X2NvbnRleHRfbWFwKG5hbWUpIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIChjb21wb25lbnRfY29udGV4dC5jID8/PSBuZXcgTWFwKGdldF9wYXJlbnRfY29udGV4dChjb21wb25lbnRfY29udGV4dCkgfHwgdW5kZWZpbmVkKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0fSBjb21wb25lbnRfY29udGV4dFxuICogQHJldHVybnMge01hcDx1bmtub3duLCB1bmtub3duPiB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldF9wYXJlbnRfY29udGV4dChjb21wb25lbnRfY29udGV4dCkge1xuXHRsZXQgcGFyZW50ID0gY29tcG9uZW50X2NvbnRleHQucDtcblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IGNvbnRleHRfbWFwID0gcGFyZW50LmM7XG5cdFx0aWYgKGNvbnRleHRfbWFwICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dF9tYXA7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wO1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTb3VyY2UsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRhY3RpdmVfZWZmZWN0LFxuXHR1bnRyYWNrZWRfd3JpdGVzLFxuXHRnZXQsXG5cdHNjaGVkdWxlX2VmZmVjdCxcblx0c2V0X3VudHJhY2tlZF93cml0ZXMsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0ZGVyaXZlZF9zb3VyY2VzLFxuXHRzZXRfZGVyaXZlZF9zb3VyY2VzLFxuXHRjaGVja19kaXJ0aW5lc3MsXG5cdHNldF9pc19mbHVzaGluZ19lZmZlY3QsXG5cdGlzX2ZsdXNoaW5nX2VmZmVjdCxcblx0dW50cmFja2luZ1xufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVxdWFscywgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCB7XG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRESVJUWSxcblx0QlJBTkNIX0VGRkVDVCxcblx0SU5TUEVDVF9FRkZFQ1QsXG5cdFVOT1dORUQsXG5cdE1BWUJFX0RJUlRZLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNUXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnLCB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGdldF9zdGFjayB9IGZyb20gJy4uL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBpc19ydW5lcyB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuXG5leHBvcnQgbGV0IGluc3BlY3RfZWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1NldDxhbnk+fSB2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5zcGVjdF9lZmZlY3RzKHYpIHtcblx0aW5zcGVjdF9lZmZlY3RzID0gdjtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge0Vycm9yIHwgbnVsbH0gW3N0YWNrXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZSh2LCBzdGFjaykge1xuXHQvKiogQHR5cGUge1ZhbHVlfSAqL1xuXHR2YXIgc2lnbmFsID0ge1xuXHRcdGY6IDAsIC8vIFRPRE8gaWRlYWxseSB3ZSBjb3VsZCBza2lwIHRoaXMgYWx0b2dldGhlciwgYnV0IGl0IGNhdXNlcyB0eXBlIGVycm9yc1xuXHRcdHYsXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdGVxdWFscyxcblx0XHRydjogMCxcblx0XHR3djogMFxuXHR9O1xuXG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzaWduYWwuY3JlYXRlZCA9IHN0YWNrID8/IGdldF9zdGFjaygnQ3JlYXRlZEF0Jyk7XG5cdFx0c2lnbmFsLmRlYnVnID0gbnVsbDtcblx0fVxuXG5cdHJldHVybiBzaWduYWw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGUodikge1xuXHRyZXR1cm4gcHVzaF9kZXJpdmVkX3NvdXJjZShzb3VyY2UodikpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IGluaXRpYWxfdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGFibGVfc291cmNlKGluaXRpYWxfdmFsdWUsIGltbXV0YWJsZSA9IGZhbHNlKSB7XG5cdGNvbnN0IHMgPSBzb3VyY2UoaW5pdGlhbF92YWx1ZSk7XG5cdGlmICghaW1tdXRhYmxlKSB7XG5cdFx0cy5lcXVhbHMgPSBzYWZlX2VxdWFscztcblx0fVxuXG5cdC8vIGJpbmQgdGhlIHNpZ25hbCB0byB0aGUgY29tcG9uZW50IGNvbnRleHQsIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHQvLyB0cmFjayB1cGRhdGVzIHRvIHRyaWdnZXIgYmVmb3JlVXBkYXRlL2FmdGVyVXBkYXRlIGNhbGxiYWNrc1xuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiBjb21wb25lbnRfY29udGV4dCAhPT0gbnVsbCAmJiBjb21wb25lbnRfY29udGV4dC5sICE9PSBudWxsKSB7XG5cdFx0KGNvbXBvbmVudF9jb250ZXh0LmwucyA/Pz0gW10pLnB1c2gocyk7XG5cdH1cblxuXHRyZXR1cm4gcztcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW11dGFibGVdXG4gKiBAcmV0dXJucyB7U291cmNlPFY+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXV0YWJsZV9zdGF0ZSh2LCBpbW11dGFibGUgPSBmYWxzZSkge1xuXHRyZXR1cm4gcHVzaF9kZXJpdmVkX3NvdXJjZShtdXRhYmxlX3NvdXJjZSh2LCBpbW11dGFibGUpKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIHB1c2hfZGVyaXZlZF9zb3VyY2Uoc291cmNlKSB7XG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmcgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRpZiAoZGVyaXZlZF9zb3VyY2VzID09PSBudWxsKSB7XG5cdFx0XHRzZXRfZGVyaXZlZF9zb3VyY2VzKFtzb3VyY2VdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVyaXZlZF9zb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc291cmNlO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGF0ZShzb3VyY2UsIHZhbHVlKSB7XG5cdHNldChcblx0XHRzb3VyY2UsXG5cdFx0dW50cmFjaygoKSA9PiBnZXQoc291cmNlKSlcblx0KTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1NvdXJjZTxWPn0gc291cmNlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChzb3VyY2UsIHZhbHVlKSB7XG5cdGlmIChcblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiZcblx0XHQhdW50cmFja2luZyAmJlxuXHRcdGlzX3J1bmVzKCkgJiZcblx0XHQoYWN0aXZlX3JlYWN0aW9uLmYgJiAoREVSSVZFRCB8IEJMT0NLX0VGRkVDVCkpICE9PSAwICYmXG5cdFx0Ly8gSWYgdGhlIHNvdXJjZSB3YXMgY3JlYXRlZCBsb2NhbGx5IHdpdGhpbiB0aGUgY3VycmVudCBkZXJpdmVkLCB0aGVuXG5cdFx0Ly8gd2UgYWxsb3cgdGhlIG11dGF0aW9uLlxuXHRcdChkZXJpdmVkX3NvdXJjZXMgPT09IG51bGwgfHwgIWRlcml2ZWRfc291cmNlcy5pbmNsdWRlcyhzb3VyY2UpKVxuXHQpIHtcblx0XHRlLnN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpO1xuXHR9XG5cblx0cmV0dXJuIGludGVybmFsX3NldChzb3VyY2UsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5hbF9zZXQoc291cmNlLCB2YWx1ZSkge1xuXHRpZiAoIXNvdXJjZS5lcXVhbHModmFsdWUpKSB7XG5cdFx0dmFyIG9sZF92YWx1ZSA9IHNvdXJjZS52O1xuXHRcdHNvdXJjZS52ID0gdmFsdWU7XG5cdFx0c291cmNlLnd2ID0gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKTtcblxuXHRcdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRcdHNvdXJjZS51cGRhdGVkID0gZ2V0X3N0YWNrKCdVcGRhdGVkQXQnKTtcblx0XHRcdGlmIChhY3RpdmVfZWZmZWN0ICE9IG51bGwpIHtcblx0XHRcdFx0c291cmNlLnRyYWNlX25lZWRfaW5jcmVhc2UgPSB0cnVlO1xuXHRcdFx0XHRzb3VyY2UudHJhY2VfdiA/Pz0gb2xkX3ZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1hcmtfcmVhY3Rpb25zKHNvdXJjZSwgRElSVFkpO1xuXG5cdFx0Ly8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjdXJyZW50IHJlYWN0aW9uIG1pZ2h0IG5vdCBoYXZlIHVwLXRvLWRhdGUgZGVwZW5kZW5jaWVzXG5cdFx0Ly8gd2hpbHN0IGl0J3MgYWN0aXZlbHkgcnVubmluZy4gU28gaW4gdGhlIGNhc2Ugb2YgZW5zdXJpbmcgaXQgcmVnaXN0ZXJzIHRoZSByZWFjdGlvblxuXHRcdC8vIHByb3Blcmx5IGZvciBpdHNlbGYsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBjdXJyZW50IGVmZmVjdCBhY3R1YWxseSBnZXRzXG5cdFx0Ly8gc2NoZWR1bGVkLiBpLmU6IGAkZWZmZWN0KCgpID0+IHgrKylgXG5cdFx0aWYgKFxuXHRcdFx0aXNfcnVuZXMoKSAmJlxuXHRcdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIENMRUFOKSAhPT0gMCAmJlxuXHRcdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0aWYgKHVudHJhY2tlZF93cml0ZXMgPT09IG51bGwpIHtcblx0XHRcdFx0c2V0X3VudHJhY2tlZF93cml0ZXMoW3NvdXJjZV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dW50cmFja2VkX3dyaXRlcy5wdXNoKHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKERFViAmJiBpbnNwZWN0X2VmZmVjdHMuc2l6ZSA+IDApIHtcblx0XHRcdGNvbnN0IGluc3BlY3RzID0gQXJyYXkuZnJvbShpbnNwZWN0X2VmZmVjdHMpO1xuXHRcdFx0dmFyIHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0ID0gaXNfZmx1c2hpbmdfZWZmZWN0O1xuXHRcdFx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCh0cnVlKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAoY29uc3QgZWZmZWN0IG9mIGluc3BlY3RzKSB7XG5cdFx0XHRcdFx0Ly8gTWFyayBjbGVhbiBpbnNwZWN0LWVmZmVjdHMgYXMgbWF5YmUgZGlydHkgYW5kIHRoZW4gY2hlY2sgdGhlaXIgZGlydGluZXNzXG5cdFx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBqdXN0IHVwZGF0aW5nIHRoZSBlZmZlY3RzIC0gdGhpcyB3YXkgd2UgYXZvaWQgb3ZlcmZpcmluZy5cblx0XHRcdFx0XHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIE1BWUJFX0RJUlRZKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhlZmZlY3QpKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0KTtcblx0XHRcdH1cblx0XHRcdGluc3BlY3RfZWZmZWN0cy5jbGVhcigpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge251bWJlciB8IGJpZ2ludH0gVFxuICogQHBhcmFtIHtTb3VyY2U8VD59IHNvdXJjZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoc291cmNlLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc291cmNlKTtcblx0dmFyIHJlc3VsdCA9IGQgPT09IDEgPyB2YWx1ZSsrIDogdmFsdWUtLTtcblxuXHRzZXQoc291cmNlLCB2YWx1ZSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyIHwgYmlnaW50fSBUXG4gKiBAcGFyYW0ge1NvdXJjZTxUPn0gc291cmNlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmUoc291cmNlLCBkID0gMSkge1xuXHR2YXIgdmFsdWUgPSBnZXQoc291cmNlKTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiBzZXQoc291cmNlLCBkID09PSAxID8gKyt2YWx1ZSA6IC0tdmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyBzaG91bGQgYmUgRElSVFkgb3IgTUFZQkVfRElSVFlcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBtYXJrX3JlYWN0aW9ucyhzaWduYWwsIHN0YXR1cykge1xuXHR2YXIgcmVhY3Rpb25zID0gc2lnbmFsLnJlYWN0aW9ucztcblx0aWYgKHJlYWN0aW9ucyA9PT0gbnVsbCkgcmV0dXJuO1xuXG5cdHZhciBydW5lcyA9IGlzX3J1bmVzKCk7XG5cdHZhciBsZW5ndGggPSByZWFjdGlvbnMubGVuZ3RoO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cdFx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRcdC8vIFNraXAgYW55IGVmZmVjdHMgdGhhdCBhcmUgYWxyZWFkeSBkaXJ0eVxuXHRcdGlmICgoZmxhZ3MgJiBESVJUWSkgIT09IDApIGNvbnRpbnVlO1xuXG5cdFx0Ly8gSW4gbGVnYWN5IG1vZGUsIHNraXAgdGhlIGN1cnJlbnQgZWZmZWN0IHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRpZiAoIXJ1bmVzICYmIHJlYWN0aW9uID09PSBhY3RpdmVfZWZmZWN0KSBjb250aW51ZTtcblxuXHRcdC8vIEluc3BlY3QgZWZmZWN0cyBuZWVkIHRvIHJ1biBpbW1lZGlhdGVseSwgc28gdGhhdCB0aGUgc3RhY2sgdHJhY2UgbWFrZXMgc2Vuc2Vcblx0XHRpZiAoREVWICYmIChmbGFncyAmIElOU1BFQ1RfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0aW5zcGVjdF9lZmZlY3RzLmFkZChyZWFjdGlvbik7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgc3RhdHVzKTtcblxuXHRcdC8vIElmIHRoZSBzaWduYWwgYSkgd2FzIHByZXZpb3VzbHkgY2xlYW4gb3IgYikgaXMgYW4gdW5vd25lZCBkZXJpdmVkLCB0aGVuIG1hcmsgaXRcblx0XHRpZiAoKGZsYWdzICYgKENMRUFOIHwgVU5PV05FRCkpICE9PSAwKSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdFx0bWFya19yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pLCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzY2hlZHVsZV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuXG5pbXBvcnQge1xuXHRIWURSQVRJT05fRU5ELFxuXHRIWURSQVRJT05fRVJST1IsXG5cdEhZRFJBVElPTl9TVEFSVCxcblx0SFlEUkFUSU9OX1NUQVJUX0VMU0Vcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogVXNlIHRoaXMgdmFyaWFibGUgdG8gZ3VhcmQgZXZlcnl0aGluZyByZWxhdGVkIHRvIGh5ZHJhdGlvbiBjb2RlIHNvIGl0IGNhbiBiZSB0cmVlc2hha2VuIG91dFxuICogaWYgdGhlIHVzZXIgZG9lc24ndCB1c2UgdGhlIGBoeWRyYXRlYCBtZXRob2QgYW5kIHRoZXNlIGNvZGUgcGF0aHMgYXJlIHRoZXJlZm9yZSBub3QgbmVlZGVkLlxuICovXG5leHBvcnQgbGV0IGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9oeWRyYXRpbmcodmFsdWUpIHtcblx0aHlkcmF0aW5nID0gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIG5vZGUgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgaHlkcmF0ZWQuIFRoaXMgc3RhcnRzIG91dCBhcyB0aGUgZmlyc3Qgbm9kZSBpbnNpZGUgdGhlIG9wZW5pbmdcbiAqIDwhLS1bLS0+IGNvbW1lbnQsIGFuZCB1cGRhdGVzIGVhY2ggdGltZSBhIGNvbXBvbmVudCBjYWxscyBgJC5jaGlsZCguLi4pYCBvciBgJC5zaWJsaW5nKC4uLilgLlxuICogV2hlbiBlbnRlcmluZyBhIGJsb2NrIChlLmcuIGB7I2lmIC4uLn1gKSwgYGh5ZHJhdGVfbm9kZWAgaXMgdGhlIGJsb2NrIG9wZW5pbmcgY29tbWVudDsgYnkgdGhlXG4gKiB0aW1lIHdlIGxlYXZlIHRoZSBibG9jayBpdCBpcyB0aGUgY2xvc2luZyBjb21tZW50LCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGJsb2NrJ3MgYW5jaG9yLlxuICogQHR5cGUge1RlbXBsYXRlTm9kZX1cbiAqL1xuZXhwb3J0IGxldCBoeWRyYXRlX25vZGU7XG5cbi8qKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9oeWRyYXRlX25vZGUobm9kZSkge1xuXHRpZiAobm9kZSA9PT0gbnVsbCkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0cmV0dXJuIChoeWRyYXRlX25vZGUgPSBub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGVfbmV4dCgpIHtcblx0cmV0dXJuIHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKGh5ZHJhdGVfbm9kZSkpKTtcbn1cblxuLyoqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXQobm9kZSkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdC8vIElmIHRoZSBub2RlIGhhcyByZW1haW5pbmcgc2libGluZ3MsIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZ1xuXHRpZiAoZ2V0X25leHRfc2libGluZyhoeWRyYXRlX25vZGUpICE9PSBudWxsKSB7XG5cdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdH1cblxuXHRoeWRyYXRlX25vZGUgPSBub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGVfdGVtcGxhdGUodGVtcGxhdGUpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVGVtcGxhdGVOb2RlIGRvZXNuJ3QgaW5jbHVkZSBEb2N1bWVudEZyYWdtZW50LCBidXQgaXQncyBhY3R1YWxseSBmaW5lXG5cdFx0aHlkcmF0ZV9ub2RlID0gdGVtcGxhdGUuY29udGVudDtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV4dChjb3VudCA9IDEpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdHZhciBpID0gY291bnQ7XG5cdFx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHR9XG5cblx0XHRoeWRyYXRlX25vZGUgPSBub2RlO1xuXHR9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgbm9kZXMgc3RhcnRpbmcgYXQgYGh5ZHJhdGVfbm9kZWAgdXAgdW50aWwgdGhlIG5leHQgaHlkcmF0aW9uIGVuZCBjb21tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfbm9kZXMoKSB7XG5cdHZhciBkZXB0aCA9IDA7XG5cdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDgpIHtcblx0XHRcdHZhciBkYXRhID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSkuZGF0YTtcblxuXHRcdFx0aWYgKGRhdGEgPT09IEhZRFJBVElPTl9FTkQpIHtcblx0XHRcdFx0aWYgKGRlcHRoID09PSAwKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0ZGVwdGggLT0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKSB7XG5cdFx0XHRcdGRlcHRoICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgUHJveHlNZXRhZGF0YSwgU291cmNlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0LCBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmltcG9ydCB7XG5cdGFycmF5X3Byb3RvdHlwZSxcblx0Z2V0X2Rlc2NyaXB0b3IsXG5cdGdldF9wcm90b3R5cGVfb2YsXG5cdGlzX2FycmF5LFxuXHRvYmplY3RfcHJvdG90eXBlXG59IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBjaGVja19vd25lcnNoaXAsIHdpZGVuX293bmVyc2hpcCB9IGZyb20gJy4vZGV2L293bmVyc2hpcC5qcyc7XG5pbXBvcnQgeyBzb3VyY2UsIHNldCB9IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IFNUQVRFX1NZTUJPTCwgU1RBVEVfU1lNQk9MX01FVEFEQVRBIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGdldF9zdGFjayB9IGZyb20gJy4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YSB8IG51bGx9IFtwYXJlbnRdXG4gKiBAcGFyYW0ge1NvdXJjZTxUPn0gW3ByZXZdIGRldiBtb2RlIG9ubHlcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJveHkodmFsdWUsIHBhcmVudCA9IG51bGwsIHByZXYpIHtcblx0LyoqIEB0eXBlIHtFcnJvciB8IG51bGx9ICovXG5cdHZhciBzdGFjayA9IG51bGw7XG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzdGFjayA9IGdldF9zdGFjaygnQ3JlYXRlZEF0Jyk7XG5cdH1cblx0Ly8gaWYgbm9uLXByb3h5YWJsZSwgb3IgaXMgYWxyZWFkeSBhIHByb3h5LCByZXR1cm4gYHZhbHVlYFxuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRjb25zdCBwcm90b3R5cGUgPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblxuXHRpZiAocHJvdG90eXBlICE9PSBvYmplY3RfcHJvdG90eXBlICYmIHByb3RvdHlwZSAhPT0gYXJyYXlfcHJvdG90eXBlKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtNYXA8YW55LCBTb3VyY2U8YW55Pj59ICovXG5cdHZhciBzb3VyY2VzID0gbmV3IE1hcCgpO1xuXHR2YXIgaXNfcHJveGllZF9hcnJheSA9IGlzX2FycmF5KHZhbHVlKTtcblx0dmFyIHZlcnNpb24gPSBzb3VyY2UoMCk7XG5cblx0aWYgKGlzX3Byb3hpZWRfYXJyYXkpIHtcblx0XHQvLyBXZSBuZWVkIHRvIGNyZWF0ZSB0aGUgbGVuZ3RoIHNvdXJjZSBlYWdlcmx5IHRvIGVuc3VyZSB0aGF0XG5cdFx0Ly8gbXV0YXRpb25zIHRvIHRoZSBhcnJheSBhcmUgcHJvcGVybHkgc3luY2VkIHdpdGggb3VyIHByb3h5XG5cdFx0c291cmNlcy5zZXQoJ2xlbmd0aCcsIHNvdXJjZSgvKiogQHR5cGUge2FueVtdfSAqLyAodmFsdWUpLmxlbmd0aCwgc3RhY2spKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7UHJveHlNZXRhZGF0YX0gKi9cblx0dmFyIG1ldGFkYXRhO1xuXG5cdGlmIChERVYpIHtcblx0XHRtZXRhZGF0YSA9IHtcblx0XHRcdHBhcmVudCxcblx0XHRcdG93bmVyczogbnVsbFxuXHRcdH07XG5cblx0XHRpZiAocHJldikge1xuXHRcdFx0Ly8gUmV1c2Ugb3duZXJzIGZyb20gcHJldmlvdXMgc3RhdGU7IG5lY2Vzc2FyeSBiZWNhdXNlIHJlYXNzaWdubWVudCBpcyBub3QgZ3VhcmFudGVlZCB0byBoYXZlIGNvcnJlY3QgY29tcG9uZW50IGNvbnRleHQuXG5cdFx0XHQvLyBJZiBubyBwcmV2aW91cyBwcm94eSBleGlzdHMgd2UgcGxheSBpdCBzYWZlIGFuZCBhc3N1bWUgb3duZXJsZXNzIHN0YXRlXG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRjb25zdCBwcmV2X293bmVycyA9IHByZXYudj8uW1NUQVRFX1NZTUJPTF9NRVRBREFUQV0/Lm93bmVycztcblx0XHRcdG1ldGFkYXRhLm93bmVycyA9IHByZXZfb3duZXJzID8gbmV3IFNldChwcmV2X293bmVycykgOiBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXRhZGF0YS5vd25lcnMgPVxuXHRcdFx0XHRwYXJlbnQgPT09IG51bGxcblx0XHRcdFx0XHQ/IGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsXG5cdFx0XHRcdFx0XHQ/IG5ldyBTZXQoW2NvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uXSlcblx0XHRcdFx0XHRcdDogbnVsbFxuXHRcdFx0XHRcdDogbmV3IFNldCgpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgUHJveHkoLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSksIHtcblx0XHRkZWZpbmVQcm9wZXJ0eShfLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLndyaXRhYmxlID09PSBmYWxzZVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHdlIGRpc2FsbG93IG5vbi1iYXNpYyBkZXNjcmlwdG9ycywgYmVjYXVzZSB1bmxlc3MgdGhleSBhcmUgYXBwbGllZCB0byB0aGVcblx0XHRcdFx0Ly8gdGFyZ2V0IG9iamVjdCDigJQgd2hpY2ggd2UgYXZvaWQsIHNvIHRoYXQgc3RhdGUgY2FuIGJlIGZvcmtlZCDigJQgd2Ugd2lsbCBydW5cblx0XHRcdFx0Ly8gYWZvdWwgb2YgdGhlIHZhcmlvdXMgaW52YXJpYW50c1xuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9Qcm94eS9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjaW52YXJpYW50c1xuXHRcdFx0XHRlLnN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cyA9IHNvdXJjZShkZXNjcmlwdG9yLnZhbHVlLCBzdGFjayk7XG5cdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0KHMsIHByb3h5KGRlc2NyaXB0b3IudmFsdWUsIG1ldGFkYXRhKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdoZW4gd29ya2luZyB3aXRoIGFycmF5cywgd2UgbmVlZCB0byBhbHNvIGVuc3VyZSB3ZSB1cGRhdGUgdGhlIGxlbmd0aCB3aGVuIHJlbW92aW5nXG5cdFx0XHRcdC8vIGFuIGluZGV4ZWQgcHJvcGVydHlcblx0XHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGxzID0gLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHNvdXJjZXMuZ2V0KCdsZW5ndGgnKSk7XG5cdFx0XHRcdFx0dmFyIG4gPSBOdW1iZXIocHJvcCk7XG5cblx0XHRcdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSAmJiBuIDwgbHMudikge1xuXHRcdFx0XHRcdFx0c2V0KGxzLCBuKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0KHMsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHR1cGRhdGVfdmVyc2lvbih2ZXJzaW9uKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHRpZiAoREVWICYmIHByb3AgPT09IFNUQVRFX1NZTUJPTF9NRVRBREFUQSkge1xuXHRcdFx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcm9wID09PSBTVEFURV9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGV4aXN0cyA9IHByb3AgaW4gdGFyZ2V0O1xuXG5cdFx0XHQvLyBjcmVhdGUgYSBzb3VyY2UsIGJ1dCBvbmx5IGlmIGl0J3MgYW4gb3duIHByb3BlcnR5IGFuZCBub3QgYSBwcm90b3R5cGUgcHJvcGVydHlcblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQgJiYgKCFleGlzdHMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKSB7XG5cdFx0XHRcdHMgPSBzb3VyY2UocHJveHkoZXhpc3RzID8gdGFyZ2V0W3Byb3BdIDogVU5JTklUSUFMSVpFRCwgbWV0YWRhdGEpLCBzdGFjayk7XG5cdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciB2ID0gZ2V0KHMpO1xuXG5cdFx0XHRcdC8vIEluIGNhc2Ugb2Ygc29tZXRoaW5nIGxpa2UgYGZvbyA9IGJhci5tYXAoLi4uKWAsIGZvbyB3b3VsZCBoYXZlIG93bmVyc2hpcFxuXHRcdFx0XHQvLyBvZiB0aGUgYXJyYXkgaXRzZWxmLCB3aGlsZSB0aGUgaW5kaXZpZHVhbCBpdGVtcyB3b3VsZCBoYXZlIG93bmVyc2hpcFxuXHRcdFx0XHQvLyBvZiB0aGUgY29tcG9uZW50IHRoYXQgY3JlYXRlZCBiYXIuIFRoYXQgbWVhbnMgaWYgd2UgbGF0ZXIgZG8gYGZvb1swXS5iYXogPSA0MmAsXG5cdFx0XHRcdC8vIHdlIGNvdWxkIGdldCBhIGZhbHNlLXBvc2l0aXZlIG93bmVyc2hpcCB2aW9sYXRpb24sIHNpbmNlIHRoZSB0d28gcHJveGllc1xuXHRcdFx0XHQvLyBhcmUgbm90IGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHZpYSB0aGUgcGFyZW50IG1ldGFkYXRhIHJlbGF0aW9uc2hpcC5cblx0XHRcdFx0Ly8gRm9yIHRoaXMgcmVhc29uLCB3ZSBuZWVkIHRvIHdpZGVuIHRoZSBvd25lcnNoaXAgb2YgdGhlIGNoaWxkcmVuXG5cdFx0XHRcdC8vIHVwb24gYWNjZXNzIHdoZW4gd2UgZGV0ZWN0IHRoZXkgYXJlIG5vdCBjb25uZWN0ZWQuXG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge1Byb3h5TWV0YWRhdGEgfCB1bmRlZmluZWR9ICovXG5cdFx0XHRcdFx0dmFyIHByb3BfbWV0YWRhdGEgPSB2Py5bU1RBVEVfU1lNQk9MX01FVEFEQVRBXTtcblx0XHRcdFx0XHRpZiAocHJvcF9tZXRhZGF0YSAmJiBwcm9wX21ldGFkYXRhPy5wYXJlbnQgIT09IG1ldGFkYXRhKSB7XG5cdFx0XHRcdFx0XHR3aWRlbl9vd25lcnNoaXAobWV0YWRhdGEsIHByb3BfbWV0YWRhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2ID09PSBVTklOSVRJQUxJWkVEID8gdW5kZWZpbmVkIDogdjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXHRcdH0sXG5cblx0XHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChkZXNjcmlwdG9yICYmICd2YWx1ZScgaW4gZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHRpZiAocykgZGVzY3JpcHRvci52YWx1ZSA9IGdldChzKTtcblx0XHRcdH0gZWxzZSBpZiAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlPy52O1xuXG5cdFx0XHRcdGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0fSxcblxuXHRcdGhhcyh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGlmIChERVYgJiYgcHJvcCA9PT0gU1RBVEVfU1lNQk9MX01FVEFEQVRBKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJvcCA9PT0gU1RBVEVfU1lNQk9MKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGhhcyA9IChzICE9PSB1bmRlZmluZWQgJiYgcy52ICE9PSBVTklOSVRJQUxJWkVEKSB8fCBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHMgIT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAoIWhhcyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHMgPSBzb3VyY2UoaGFzID8gcHJveHkodGFyZ2V0W3Byb3BdLCBtZXRhZGF0YSkgOiBVTklOSVRJQUxJWkVELCBzdGFjayk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXQocyk7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFzO1xuXHRcdH0sXG5cblx0XHRzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIHZhcmlhYmxlLmxlbmd0aCA9IHZhbHVlIC0+IGNsZWFyIGFsbCBzaWduYWxzIHdpdGggaW5kZXggPj0gdmFsdWVcblx0XHRcdGlmIChpc19wcm94aWVkX2FycmF5ICYmIHByb3AgPT09ICdsZW5ndGgnKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB2YWx1ZTsgaSA8IC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovIChzKS52OyBpICs9IDEpIHtcblx0XHRcdFx0XHR2YXIgb3RoZXJfcyA9IHNvdXJjZXMuZ2V0KGkgKyAnJyk7XG5cdFx0XHRcdFx0aWYgKG90aGVyX3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2V0KG90aGVyX3MsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaSBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBpdGVtIGV4aXN0cyBpbiB0aGUgb3JpZ2luYWwsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdW5pbml0aWFsaXplZCBzb3VyY2UsXG5cdFx0XHRcdFx0XHQvLyBlbHNlIGEgbGF0ZXIgcmVhZCBvZiB0aGUgcHJvcGVydHkgd291bGQgcmVzdWx0IGluIGEgc291cmNlIGJlaW5nIGNyZWF0ZWQgd2l0aFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBpdGVtIGF0IHRoYXQgaW5kZXguXG5cdFx0XHRcdFx0XHRvdGhlcl9zID0gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKTtcblx0XHRcdFx0XHRcdHNvdXJjZXMuc2V0KGkgKyAnJywgb3RoZXJfcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgeWV0IGNyZWF0ZWQgYSBzb3VyY2UgZm9yIHRoaXMgcHJvcGVydHksIHdlIG5lZWQgdG8gZW5zdXJlXG5cdFx0XHQvLyB3ZSBkbyBzbyBvdGhlcndpc2UgaWYgd2UgcmVhZCBpdCBsYXRlciwgdGhlbiB0aGUgd3JpdGUgd29uJ3QgYmUgdHJhY2tlZCBhbmRcblx0XHRcdC8vIHRoZSBoZXVyaXN0aWNzIG9mIGVmZmVjdHMgd2lsbCBiZSBkaWZmZXJlbnQgdnMgaWYgd2UgaGFkIHJlYWQgdGhlIHByb3hpZWRcblx0XHRcdC8vIG9iamVjdCBwcm9wZXJ0eSBiZWZvcmUgd3JpdGluZyB0byB0aGF0IHByb3BlcnR5LlxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoIWhhcyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkge1xuXHRcdFx0XHRcdHMgPSBzb3VyY2UodW5kZWZpbmVkLCBzdGFjayk7XG5cdFx0XHRcdFx0c2V0KHMsIHByb3h5KHZhbHVlLCBtZXRhZGF0YSkpO1xuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYXMgPSBzLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cdFx0XHRcdHNldChzLCBwcm94eSh2YWx1ZSwgbWV0YWRhdGEpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHQvKiogQHR5cGUge1Byb3h5TWV0YWRhdGEgfCB1bmRlZmluZWR9ICovXG5cdFx0XHRcdHZhciBwcm9wX21ldGFkYXRhID0gdmFsdWU/LltTVEFURV9TWU1CT0xfTUVUQURBVEFdO1xuXHRcdFx0XHRpZiAocHJvcF9tZXRhZGF0YSAmJiBwcm9wX21ldGFkYXRhPy5wYXJlbnQgIT09IG1ldGFkYXRhKSB7XG5cdFx0XHRcdFx0d2lkZW5fb3duZXJzaGlwKG1ldGFkYXRhLCBwcm9wX21ldGFkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGVja19vd25lcnNoaXAobWV0YWRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3IHZhbHVlIGJlZm9yZSB1cGRhdGluZyBhbnkgc2lnbmFscyBzbyB0aGF0IGFueSBsaXN0ZW5lcnMgZ2V0IHRoZSBuZXcgdmFsdWVcblx0XHRcdGlmIChkZXNjcmlwdG9yPy5zZXQpIHtcblx0XHRcdFx0ZGVzY3JpcHRvci5zZXQuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWhhcykge1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG11dGF0ZWQgYW4gYXJyYXkgZGlyZWN0bHksIHdlIG1pZ2h0IG5lZWQgdG9cblx0XHRcdFx0Ly8gc2lnbmFsIHRoYXQgbGVuZ3RoIGhhcyBhbHNvIGNoYW5nZWQuIERvIGl0IGJlZm9yZSB1cGRhdGluZyBtZXRhZGF0YVxuXHRcdFx0XHQvLyB0byBlbnN1cmUgdGhhdCBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXkgYXMgYSByZXN1bHQgb2YgYSBtZXRhZGF0YSB1cGRhdGVcblx0XHRcdFx0Ly8gd2lsbCBub3QgY2F1c2UgdGhlIGxlbmd0aCB0byBiZSBvdXQgb2Ygc3luYy5cblx0XHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dmFyIGxzID0gLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHNvdXJjZXMuZ2V0KCdsZW5ndGgnKSk7XG5cdFx0XHRcdFx0dmFyIG4gPSBOdW1iZXIocHJvcCk7XG5cblx0XHRcdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcihuKSAmJiBuID49IGxzLnYpIHtcblx0XHRcdFx0XHRcdHNldChscywgbiArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVwZGF0ZV92ZXJzaW9uKHZlcnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0dmFyIG93bl9rZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZmlsdGVyKChrZXkpID0+IHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KGtleSk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBba2V5LCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdFx0aWYgKHNvdXJjZS52ICE9PSBVTklOSVRJQUxJWkVEICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHRvd25fa2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG93bl9rZXlzO1xuXHRcdH0sXG5cblx0XHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRcdGUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NvdXJjZTxudW1iZXI+fSBzaWduYWxcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlX3ZlcnNpb24oc2lnbmFsLCBkID0gMSkge1xuXHRzZXQoc2lnbmFsLCBzaWduYWwudiArIGQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3Byb3hpZWRfdmFsdWUodmFsdWUpIHtcblx0aWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU1RBVEVfU1lNQk9MIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlW1NUQVRFX1NZTUJPTF07XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdHJldHVybiBPYmplY3QuaXMoZ2V0X3Byb3hpZWRfdmFsdWUoYSksIGdldF9wcm94aWVkX3ZhbHVlKGIpKTtcbn1cbiIsImltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0X3Byb3hpZWRfdmFsdWUgfSBmcm9tICcuLi9wcm94eS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpIHtcblx0Y29uc3QgYXJyYXlfcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXHQvLyBUaGUgUkVQTCBlbmRzIHVwIGhlcmUgb3ZlciBhbmQgb3ZlciwgYW5kIHRoaXMgcHJldmVudHMgaXQgZnJvbSBhZGRpbmcgbW9yZSBhbmQgbW9yZSBwYXRjaGVzXG5cdC8vIG9mIHRoZSBzYW1lIGtpbmQgdG8gdGhlIHByb3RvdHlwZSwgd2hpY2ggd291bGQgc2xvdyBkb3duIGV2ZXJ5dGhpbmcgb3ZlciB0aW1lLlxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGNsZWFudXAgPSBBcnJheS5fX3N2ZWx0ZV9jbGVhbnVwO1xuXHRpZiAoY2xlYW51cCkge1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXG5cdGNvbnN0IHsgaW5kZXhPZiwgbGFzdEluZGV4T2YsIGluY2x1ZGVzIH0gPSBhcnJheV9wcm90b3R5cGU7XG5cblx0YXJyYXlfcHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdGNvbnN0IGluZGV4ID0gaW5kZXhPZi5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXgpO1xuXG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IGZyb21faW5kZXggPz8gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkuaW5kZXhPZiguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0YXJyYXlfcHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHQvLyB3ZSBuZWVkIHRvIHNwZWNpZnkgdGhpcy5sZW5ndGggLSAxIGJlY2F1c2UgaXQncyBwcm9iYWJseSB1c2luZyBzb21ldGhpbmcgbGlrZVxuXHRcdC8vIGBhcmd1bWVudHNgIGluc2lkZSBzbyBwYXNzaW5nIHVuZGVmaW5lZCBpcyBkaWZmZXJlbnQgZnJvbSBub3QgcGFzc2luZyBhbnl0aGluZ1xuXHRcdGNvbnN0IGluZGV4ID0gbGFzdEluZGV4T2YuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4ID8/IHRoaXMubGVuZ3RoIC0gMSk7XG5cblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8PSAoZnJvbV9pbmRleCA/PyB0aGlzLmxlbmd0aCAtIDEpOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkubGFzdEluZGV4T2YoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGFycmF5X3Byb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Y29uc3QgaGFzID0gaW5jbHVkZXMuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4KTtcblxuXHRcdGlmICghaGFzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0aWYgKGdldF9wcm94aWVkX3ZhbHVlKHRoaXNbaV0pID09PSBpdGVtKSB7XG5cdFx0XHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCgnYXJyYXkuaW5jbHVkZXMoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhcztcblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdEFycmF5Ll9fc3ZlbHRlX2NsZWFudXAgPSAoKSA9PiB7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmluZGV4T2YgPSBpbmRleE9mO1xuXHRcdGFycmF5X3Byb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuXHRcdGFycmF5X3Byb3RvdHlwZS5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtib29sZWFufSBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpY3RfZXF1YWxzKGEsIGIsIGVxdWFsID0gdHJ1ZSkge1xuXHQvLyB0cnktY2F0Y2ggbmVlZGVkIGJlY2F1c2UgdGhpcyB0cmllcyB0byByZWFkIHByb3BlcnRpZXMgb2YgYGFgIGFuZCBgYmAsXG5cdC8vIHdoaWNoIGNvdWxkIGJlIGRpc2FsbG93ZWQgZm9yIGV4YW1wbGUgaW4gYSBzZWN1cmUgY29udGV4dFxuXHR0cnkge1xuXHRcdGlmICgoYSA9PT0gYikgIT09IChnZXRfcHJveGllZF92YWx1ZShhKSA9PT0gZ2V0X3Byb3hpZWRfdmFsdWUoYikpKSB7XG5cdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKGVxdWFsID8gJz09PScgOiAnIT09Jyk7XG5cdFx0fVxuXHR9IGNhdGNoIHt9XG5cblx0cmV0dXJuIChhID09PSBiKSA9PT0gZXF1YWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVxdWFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiLCBlcXVhbCA9IHRydWUpIHtcblx0aWYgKChhID09IGIpICE9PSAoZ2V0X3Byb3hpZWRfdmFsdWUoYSkgPT0gZ2V0X3Byb3hpZWRfdmFsdWUoYikpKSB7XG5cdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChlcXVhbCA/ICc9PScgOiAnIT0nKTtcblx0fVxuXG5cdHJldHVybiAoYSA9PSBiKSA9PT0gZXF1YWw7XG59XG4iLCIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSB9IGZyb20gJy4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaW5pdF9hcnJheV9wcm90b3R5cGVfd2FybmluZ3MgfSBmcm9tICcuLi9kZXYvZXF1YWxpdHkuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vLyBleHBvcnQgdGhlc2UgZm9yIHJlZmVyZW5jZSBpbiB0aGUgY29tcGlsZWQgY29kZSwgbWFraW5nIGdsb2JhbCBuYW1lIGRlZHVwbGljYXRpb24gdW5uZWNlc3Nhcnlcbi8qKiBAdHlwZSB7V2luZG93fSAqL1xuZXhwb3J0IHZhciAkd2luZG93O1xuXG4vKiogQHR5cGUge0RvY3VtZW50fSAqL1xuZXhwb3J0IHZhciAkZG9jdW1lbnQ7XG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmV4cG9ydCB2YXIgaXNfZmlyZWZveDtcblxuLyoqIEB0eXBlIHsoKSA9PiBOb2RlIHwgbnVsbH0gKi9cbnZhciBmaXJzdF9jaGlsZF9nZXR0ZXI7XG4vKiogQHR5cGUgeygpID0+IE5vZGUgfCBudWxsfSAqL1xudmFyIG5leHRfc2libGluZ19nZXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGVzZSBsYXppbHkgdG8gYXZvaWQgaXNzdWVzIHdoZW4gdXNpbmcgdGhlIHJ1bnRpbWUgaW4gYSBzZXJ2ZXIgY29udGV4dFxuICogd2hlcmUgdGhlc2UgZ2xvYmFscyBhcmUgbm90IGF2YWlsYWJsZSB3aGlsZSBhdm9pZGluZyBhIHNlcGFyYXRlIHNlcnZlciBlbnRyeSBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9vcGVyYXRpb25zKCkge1xuXHRpZiAoJHdpbmRvdyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0JHdpbmRvdyA9IHdpbmRvdztcblx0JGRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cdGlzX2ZpcmVmb3ggPSAvRmlyZWZveC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXHR2YXIgZWxlbWVudF9wcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcblx0dmFyIG5vZGVfcHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGU7XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRmaXJzdF9jaGlsZF9nZXR0ZXIgPSBnZXRfZGVzY3JpcHRvcihub2RlX3Byb3RvdHlwZSwgJ2ZpcnN0Q2hpbGQnKS5nZXQ7XG5cdC8vIEB0cy1pZ25vcmVcblx0bmV4dF9zaWJsaW5nX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKS5nZXQ7XG5cblx0Ly8gdGhlIGZvbGxvd2luZyBhc3NpZ25tZW50cyBpbXByb3ZlIHBlcmYgb2YgbG9va3VwcyBvbiBET00gbm9kZXNcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsaWNrID0gdW5kZWZpbmVkO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnRfcHJvdG90eXBlLl9fY2xhc3NOYW1lID0gJyc7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudF9wcm90b3R5cGUuX19hdHRyaWJ1dGVzID0gbnVsbDtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX3N0eWxlcyA9IG51bGw7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudF9wcm90b3R5cGUuX19lID0gdW5kZWZpbmVkO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0VGV4dC5wcm90b3R5cGUuX190ID0gdW5kZWZpbmVkO1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdmVsdGVfbWV0YSA9IG51bGw7XG5cblx0XHRpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV90ZXh0KHZhbHVlID0gJycpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZmlyc3RfY2hpbGQobm9kZSkge1xuXHRyZXR1cm4gZmlyc3RfY2hpbGRfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuLypAX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X25leHRfc2libGluZyhub2RlKSB7XG5cdHJldHVybiBuZXh0X3NpYmxpbmdfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGQobm9kZSwgaXNfdGV4dCkge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBnZXRfZmlyc3RfY2hpbGQobm9kZSk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChoeWRyYXRlX25vZGUpKTtcblxuXHQvLyBDaGlsZCBjYW4gYmUgbnVsbCBpZiB3ZSBoYXZlIGFuIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSBjaGlsZCwgbGlrZSBgPHA+e3RleHR9PC9wPmAsIHdoZXJlIGB0ZXh0YCBpcyBlbXB0eVxuXHRpZiAoY2hpbGQgPT09IG51bGwpIHtcblx0XHRjaGlsZCA9IGh5ZHJhdGVfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fSBlbHNlIGlmIChpc190ZXh0ICYmIGNoaWxkLm5vZGVUeXBlICE9PSAzKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdGNoaWxkPy5iZWZvcmUodGV4dCk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHNldF9oeWRyYXRlX25vZGUoY2hpbGQpO1xuXHRyZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgVGVtcGxhdGVOb2RlW119IGZyYWdtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3RleHRcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0X2NoaWxkKGZyYWdtZW50LCBpc190ZXh0KSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0Ly8gd2hlbiBub3QgaHlkcmF0aW5nLCBgZnJhZ21lbnRgIGlzIGEgYERvY3VtZW50RnJhZ21lbnRgICh0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYG9wZW5fZnJhZ2ApXG5cdFx0dmFyIGZpcnN0ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGZyYWdtZW50KSkpO1xuXG5cdFx0Ly8gVE9ETyBwcmV2ZW50IHVzZXIgY29tbWVudHMgd2l0aCB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gcHJlc2VydmVDb21tZW50cyBpcyB0cnVlXG5cdFx0aWYgKGZpcnN0IGluc3RhbmNlb2YgQ29tbWVudCAmJiBmaXJzdC5kYXRhID09PSAnJykgcmV0dXJuIGdldF9uZXh0X3NpYmxpbmcoZmlyc3QpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9XG5cblx0Ly8gaWYgYW4ge2V4cHJlc3Npb259IGlzIGVtcHR5IGR1cmluZyBTU1IsIHRoZXJlIG1pZ2h0IGJlIG5vXG5cdC8vIHRleHQgbm9kZSB0byBoeWRyYXRlIOKAlCB3ZSBtdXN0IHRoZXJlZm9yZSBjcmVhdGUgb25lXG5cdGlmIChpc190ZXh0ICYmIGh5ZHJhdGVfbm9kZT8ubm9kZVR5cGUgIT09IDMpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cblx0XHRoeWRyYXRlX25vZGU/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3RleHRcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpYmxpbmcobm9kZSwgY291bnQgPSAxLCBpc190ZXh0ID0gZmFsc2UpIHtcblx0bGV0IG5leHRfc2libGluZyA9IGh5ZHJhdGluZyA/IGh5ZHJhdGVfbm9kZSA6IG5vZGU7XG5cdHZhciBsYXN0X3NpYmxpbmc7XG5cblx0d2hpbGUgKGNvdW50LS0pIHtcblx0XHRsYXN0X3NpYmxpbmcgPSBuZXh0X3NpYmxpbmc7XG5cdFx0bmV4dF9zaWJsaW5nID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5leHRfc2libGluZykpO1xuXHR9XG5cblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHRyZXR1cm4gbmV4dF9zaWJsaW5nO1xuXHR9XG5cblx0dmFyIHR5cGUgPSBuZXh0X3NpYmxpbmc/Lm5vZGVUeXBlO1xuXG5cdC8vIGlmIGEgc2libGluZyB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUg4oCUIHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgdHlwZSAhPT0gMykge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblx0XHQvLyBJZiB0aGUgbmV4dCBzaWJsaW5nIGlzIGBudWxsYCBhbmQgd2UncmUgaGFuZGxpbmcgdGV4dCB0aGVuIGl0J3MgYmVjYXVzZVxuXHRcdC8vIHRoZSBTU1IgY29udGVudCB3YXMgZW1wdHkgZm9yIHRoZSB0ZXh0LCBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIGEgbmV3IHRleHRcblx0XHQvLyBub2RlIGFuZCBpbnNlcnQgaXQgYWZ0ZXIgdGhlIGxhc3Qgc2libGluZ1xuXHRcdGlmIChuZXh0X3NpYmxpbmcgPT09IG51bGwpIHtcblx0XHRcdGxhc3Rfc2libGluZz8uYWZ0ZXIodGV4dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5leHRfc2libGluZy5iZWZvcmUodGV4dCk7XG5cdFx0fVxuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRzZXRfaHlkcmF0ZV9ub2RlKG5leHRfc2libGluZyk7XG5cdHJldHVybiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHRfc2libGluZyk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJfdGV4dF9jb250ZW50KG5vZGUpIHtcblx0bm9kZS50ZXh0Q29udGVudCA9ICcnO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBDTEVBTiwgREVSSVZFRCwgRElSVFksIEVGRkVDVF9IQVNfREVSSVZFRCwgTUFZQkVfRElSVFksIFVOT1dORUQgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRhY3RpdmVfZWZmZWN0LFxuXHRzZXRfc2lnbmFsX3N0YXR1cyxcblx0c2tpcF9yZWFjdGlvbixcblx0dXBkYXRlX3JlYWN0aW9uLFxuXHRpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3Rcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlcXVhbHMsIHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBkZXN0cm95X2VmZmVjdCB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBpbnNwZWN0X2VmZmVjdHMsIHNldF9pbnNwZWN0X2VmZmVjdHMgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrIH0gZnJvbSAnLi4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGZuXG4gKiBAcmV0dXJucyB7RGVyaXZlZDxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChmbikge1xuXHR2YXIgZmxhZ3MgPSBERVJJVkVEIHwgRElSVFk7XG5cdHZhciBwYXJlbnRfZGVyaXZlZCA9XG5cdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmIChhY3RpdmVfcmVhY3Rpb24uZiAmIERFUklWRUQpICE9PSAwXG5cdFx0XHQ/IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGFjdGl2ZV9yZWFjdGlvbilcblx0XHRcdDogbnVsbDtcblxuXHRpZiAoYWN0aXZlX2VmZmVjdCA9PT0gbnVsbCB8fCAocGFyZW50X2Rlcml2ZWQgIT09IG51bGwgJiYgKHBhcmVudF9kZXJpdmVkLmYgJiBVTk9XTkVEKSAhPT0gMCkpIHtcblx0XHRmbGFncyB8PSBVTk9XTkVEO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFNpbmNlIGRlcml2ZWRzIGFyZSBldmFsdWF0ZWQgbGF6aWx5LCBhbnkgZWZmZWN0cyBjcmVhdGVkIGluc2lkZSB0aGVtIGFyZVxuXHRcdC8vIGNyZWF0ZWQgdG9vIGxhdGUgdG8gZW5zdXJlIHRoYXQgdGhlIHBhcmVudCBlZmZlY3QgaXMgYWRkZWQgdG8gdGhlIHRyZWVcblx0XHRhY3RpdmVfZWZmZWN0LmYgfD0gRUZGRUNUX0hBU19ERVJJVkVEO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtEZXJpdmVkPFY+fSAqL1xuXHRjb25zdCBzaWduYWwgPSB7XG5cdFx0Y3R4OiBjb21wb25lbnRfY29udGV4dCxcblx0XHRkZXBzOiBudWxsLFxuXHRcdGVmZmVjdHM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdGY6IGZsYWdzLFxuXHRcdGZuLFxuXHRcdHJlYWN0aW9uczogbnVsbCxcblx0XHRydjogMCxcblx0XHR2OiAvKiogQHR5cGUge1Z9ICovIChudWxsKSxcblx0XHR3djogMCxcblx0XHRwYXJlbnQ6IHBhcmVudF9kZXJpdmVkID8/IGFjdGl2ZV9lZmZlY3Rcblx0fTtcblxuXHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0c2lnbmFsLmNyZWF0ZWQgPSBnZXRfc3RhY2soJ0NyZWF0ZWRBdCcpO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfc2FmZV9lcXVhbChmbikge1xuXHRjb25zdCBzaWduYWwgPSBkZXJpdmVkKGZuKTtcblx0c2lnbmFsLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKSB7XG5cdHZhciBlZmZlY3RzID0gZGVyaXZlZC5lZmZlY3RzO1xuXG5cdGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0ZGVyaXZlZC5lZmZlY3RzID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChlZmZlY3RzW2ldKSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSB1cGRhdGluZyBkZXJpdmVkcywgdXNlZCB0byBkZXRlY3QgaW5maW5pdGUgcmVjdXJzaW9uXG4gKiBpbiBkZXYgbW9kZSBhbmQgcHJvdmlkZSBhIG5pY2VyIGVycm9yIHRoYW4gJ3RvbyBtdWNoIHJlY3Vyc2lvbidcbiAqIEB0eXBlIHtEZXJpdmVkW119XG4gKi9cbmxldCBzdGFjayA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge0VmZmVjdCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldF9kZXJpdmVkX3BhcmVudF9lZmZlY3QoZGVyaXZlZCkge1xuXHR2YXIgcGFyZW50ID0gZGVyaXZlZC5wYXJlbnQ7XG5cdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRpZiAoKHBhcmVudC5mICYgREVSSVZFRCkgPT09IDApIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge0VmZmVjdH0gKi8gKHBhcmVudCk7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCkge1xuXHR2YXIgdmFsdWU7XG5cdHZhciBwcmV2X2FjdGl2ZV9lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdHNldF9hY3RpdmVfZWZmZWN0KGdldF9kZXJpdmVkX3BhcmVudF9lZmZlY3QoZGVyaXZlZCkpO1xuXG5cdGlmIChERVYpIHtcblx0XHRsZXQgcHJldl9pbnNwZWN0X2VmZmVjdHMgPSBpbnNwZWN0X2VmZmVjdHM7XG5cdFx0c2V0X2luc3BlY3RfZWZmZWN0cyhuZXcgU2V0KCkpO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoc3RhY2suaW5jbHVkZXMoZGVyaXZlZCkpIHtcblx0XHRcdFx0ZS5kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGFjay5wdXNoKGRlcml2ZWQpO1xuXG5cdFx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdFx0c2V0X2luc3BlY3RfZWZmZWN0cyhwcmV2X2luc3BlY3RfZWZmZWN0cyk7XG5cdFx0XHRzdGFjay5wb3AoKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZSA9IGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKTtcblx0dmFyIHN0YXR1cyA9XG5cdFx0KHNraXBfcmVhY3Rpb24gfHwgKGRlcml2ZWQuZiAmIFVOT1dORUQpICE9PSAwKSAmJiBkZXJpdmVkLmRlcHMgIT09IG51bGwgPyBNQVlCRV9ESVJUWSA6IENMRUFOO1xuXG5cdHNldF9zaWduYWxfc3RhdHVzKGRlcml2ZWQsIHN0YXR1cyk7XG5cblx0aWYgKCFkZXJpdmVkLmVxdWFscyh2YWx1ZSkpIHtcblx0XHRkZXJpdmVkLnYgPSB2YWx1ZTtcblx0XHRkZXJpdmVkLnd2ID0gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBDb21wb25lbnRDb250ZXh0TGVnYWN5LCBEZXJpdmVkLCBFZmZlY3QsIFRlbXBsYXRlTm9kZSwgVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHtcblx0Y2hlY2tfZGlydGluZXNzLFxuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHVwZGF0ZV9lZmZlY3QsXG5cdGdldCxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdGlzX2ZsdXNoaW5nX2VmZmVjdCxcblx0cmVtb3ZlX3JlYWN0aW9ucyxcblx0c2NoZWR1bGVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHNldF9pc19mbHVzaGluZ19lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRza2lwX3JlYWN0aW9uLFxuXHR1bnRyYWNraW5nXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0RElSVFksXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFJFTkRFUl9FRkZFQ1QsXG5cdEVGRkVDVCxcblx0REVTVFJPWUVELFxuXHRJTkVSVCxcblx0RUZGRUNUX1JBTixcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0RUZGRUNUX1RSQU5TUEFSRU5ULFxuXHRERVJJVkVELFxuXHRVTk9XTkVELFxuXHRDTEVBTixcblx0SU5TUEVDVF9FRkZFQ1QsXG5cdEhFQURfRUZGRUNULFxuXHRNQVlCRV9ESVJUWSxcblx0RUZGRUNUX0hBU19ERVJJVkVELFxuXHRCT1VOREFSWV9FRkZFQ1Rcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vZG9tL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCB9IGZyb20gJy4vZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7JyRlZmZlY3QnIHwgJyRlZmZlY3QucHJlJyB8ICckaW5zcGVjdCd9IHJ1bmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VmZmVjdChydW5lKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsICYmIGFjdGl2ZV9yZWFjdGlvbiA9PT0gbnVsbCkge1xuXHRcdGUuZWZmZWN0X29ycGhhbihydW5lKTtcblx0fVxuXG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgVU5PV05FRCkgIT09IDAgJiYgYWN0aXZlX2VmZmVjdCA9PT0gbnVsbCkge1xuXHRcdGUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpO1xuXHR9XG5cblx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0ZS5lZmZlY3RfaW5fdGVhcmRvd24ocnVuZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdH0gcGFyZW50X2VmZmVjdFxuICovXG5mdW5jdGlvbiBwdXNoX2VmZmVjdChlZmZlY3QsIHBhcmVudF9lZmZlY3QpIHtcblx0dmFyIHBhcmVudF9sYXN0ID0gcGFyZW50X2VmZmVjdC5sYXN0O1xuXHRpZiAocGFyZW50X2xhc3QgPT09IG51bGwpIHtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBwYXJlbnRfZWZmZWN0LmZpcnN0ID0gZWZmZWN0O1xuXHR9IGVsc2Uge1xuXHRcdHBhcmVudF9sYXN0Lm5leHQgPSBlZmZlY3Q7XG5cdFx0ZWZmZWN0LnByZXYgPSBwYXJlbnRfbGFzdDtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBlZmZlY3Q7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHBhcmFtIHtudWxsIHwgKCgpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCkpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHB1c2hcbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9lZmZlY3QodHlwZSwgZm4sIHN5bmMsIHB1c2ggPSB0cnVlKSB7XG5cdHZhciBpc19yb290ID0gKHR5cGUgJiBST09UX0VGRkVDVCkgIT09IDA7XG5cdHZhciBwYXJlbnRfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHRpZiAoREVWKSB7XG5cdFx0Ly8gRW5zdXJlIHRoZSBwYXJlbnQgaXMgbmV2ZXIgYW4gaW5zcGVjdCBlZmZlY3Rcblx0XHR3aGlsZSAocGFyZW50X2VmZmVjdCAhPT0gbnVsbCAmJiAocGFyZW50X2VmZmVjdC5mICYgSU5TUEVDVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRwYXJlbnRfZWZmZWN0ID0gcGFyZW50X2VmZmVjdC5wYXJlbnQ7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3R9ICovXG5cdHZhciBlZmZlY3QgPSB7XG5cdFx0Y3R4OiBjb21wb25lbnRfY29udGV4dCxcblx0XHRkZXBzOiBudWxsLFxuXHRcdG5vZGVzX3N0YXJ0OiBudWxsLFxuXHRcdG5vZGVzX2VuZDogbnVsbCxcblx0XHRmOiB0eXBlIHwgRElSVFksXG5cdFx0Zmlyc3Q6IG51bGwsXG5cdFx0Zm4sXG5cdFx0bGFzdDogbnVsbCxcblx0XHRuZXh0OiBudWxsLFxuXHRcdHBhcmVudDogaXNfcm9vdCA/IG51bGwgOiBwYXJlbnRfZWZmZWN0LFxuXHRcdHByZXY6IG51bGwsXG5cdFx0dGVhcmRvd246IG51bGwsXG5cdFx0dHJhbnNpdGlvbnM6IG51bGwsXG5cdFx0d3Y6IDBcblx0fTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0fVxuXG5cdGlmIChzeW5jKSB7XG5cdFx0dmFyIHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0ID0gaXNfZmx1c2hpbmdfZWZmZWN0O1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNldF9pc19mbHVzaGluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QuZiB8PSBFRkZFQ1RfUkFOO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0KTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoZm4gIT09IG51bGwpIHtcblx0XHRzY2hlZHVsZV9lZmZlY3QoZWZmZWN0KTtcblx0fVxuXG5cdC8vIGlmIGFuIGVmZmVjdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBubyBET00gYW5kIG5vIHRlYXJkb3duIGZ1bmN0aW9uLFxuXHQvLyBkb24ndCBib3RoZXIgYWRkaW5nIGl0IHRvIHRoZSBlZmZlY3QgdHJlZVxuXHR2YXIgaW5lcnQgPVxuXHRcdHN5bmMgJiZcblx0XHRlZmZlY3QuZGVwcyA9PT0gbnVsbCAmJlxuXHRcdGVmZmVjdC5maXJzdCA9PT0gbnVsbCAmJlxuXHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCAmJlxuXHRcdGVmZmVjdC50ZWFyZG93biA9PT0gbnVsbCAmJlxuXHRcdChlZmZlY3QuZiAmIChFRkZFQ1RfSEFTX0RFUklWRUQgfCBCT1VOREFSWV9FRkZFQ1QpKSA9PT0gMDtcblxuXHRpZiAoIWluZXJ0ICYmICFpc19yb290ICYmIHB1c2gpIHtcblx0XHRpZiAocGFyZW50X2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdFx0cHVzaF9lZmZlY3QoZWZmZWN0LCBwYXJlbnRfZWZmZWN0KTtcblx0XHR9XG5cblx0XHQvLyBpZiB3ZSdyZSBpbiBhIGRlcml2ZWQsIGFkZCB0aGUgZWZmZWN0IHRoZXJlIHRvb1xuXHRcdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdChkZXJpdmVkLmVmZmVjdHMgPz89IFtdKS5wdXNoKGVmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC50cmFja2luZygpYFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfdHJhY2tpbmcoKSB7XG5cdHJldHVybiBhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmc7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVhcmRvd24oZm4pIHtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNULCBudWxsLCBmYWxzZSk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXHRlZmZlY3QudGVhcmRvd24gPSBmbjtcblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdCguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlcl9lZmZlY3QoZm4pIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckZWZmZWN0Jyk7XG5cblx0Ly8gTm9uLW5lc3RlZCBgJGVmZmVjdCguLi4pYCBpbiBhIGNvbXBvbmVudCBzaG91bGQgYmUgZGVmZXJyZWRcblx0Ly8gdW50aWwgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkXG5cdHZhciBkZWZlciA9XG5cdFx0YWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJlxuXHRcdChhY3RpdmVfZWZmZWN0LmYgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMCAmJlxuXHRcdGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsICYmXG5cdFx0IWNvbXBvbmVudF9jb250ZXh0Lm07XG5cblx0aWYgKERFVikge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJyRlZmZlY3QnXG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoZGVmZXIpIHtcblx0XHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblx0XHQoY29udGV4dC5lID8/PSBbXSkucHVzaCh7XG5cdFx0XHRmbixcblx0XHRcdGVmZmVjdDogYWN0aXZlX2VmZmVjdCxcblx0XHRcdHJlYWN0aW9uOiBhY3RpdmVfcmVhY3Rpb25cblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR2YXIgc2lnbmFsID0gZWZmZWN0KGZuKTtcblx0XHRyZXR1cm4gc2lnbmFsO1xuXHR9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3QucHJlKC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlcl9wcmVfZWZmZWN0KGZuKSB7XG5cdHZhbGlkYXRlX2VmZmVjdCgnJGVmZmVjdC5wcmUnKTtcblx0aWYgKERFVikge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJyRlZmZlY3QucHJlJ1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiByZW5kZXJfZWZmZWN0KGZuKTtcbn1cblxuLyoqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0X2VmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChJTlNQRUNUX0VGRkVDVCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnJvb3QoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3Jvb3QoZm4pIHtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChST09UX0VGRkVDVCwgZm4sIHRydWUpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0fTtcbn1cblxuLyoqXG4gKiBBbiBlZmZlY3Qgcm9vdCB3aG9zZSBjaGlsZHJlbiBjYW4gdHJhbnNpdGlvbiBvdXRcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsob3B0aW9ucz86IHsgb3V0cm8/OiBib29sZWFuIH0pID0+IFByb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb25lbnRfcm9vdChmbikge1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJPT1RfRUZGRUNULCBmbiwgdHJ1ZSk7XG5cblx0cmV0dXJuIChvcHRpb25zID0ge30pID0+IHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbCkgPT4ge1xuXHRcdFx0aWYgKG9wdGlvbnMub3V0cm8pIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0ZnVsZmlsKHVuZGVmaW5lZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0ZnVsZmlsKHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChFRkZFQ1QsIGZuLCBmYWxzZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCQ6IC4uYFxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGRlcHNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9wcmVfZWZmZWN0KGRlcHMsIGZuKSB7XG5cdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdC8qKiBAdHlwZSB7eyBlZmZlY3Q6IG51bGwgfCBFZmZlY3QsIHJhbjogYm9vbGVhbiB9fSAqL1xuXHR2YXIgdG9rZW4gPSB7IGVmZmVjdDogbnVsbCwgcmFuOiBmYWxzZSB9O1xuXHRjb250ZXh0LmwucjEucHVzaCh0b2tlbik7XG5cblx0dG9rZW4uZWZmZWN0ID0gcmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0ZGVwcygpO1xuXG5cdFx0Ly8gSWYgdGhpcyBsZWdhY3kgcHJlIGVmZmVjdCBoYXMgYWxyZWFkeSBydW4gYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHJlc2V0LCB0aGVuXG5cdFx0Ly8gYmFpbCBvdXQgdG8gZW11bGF0ZSB0aGUgc2FtZSBiZWhhdmlvci5cblx0XHRpZiAodG9rZW4ucmFuKSByZXR1cm47XG5cblx0XHR0b2tlbi5yYW4gPSB0cnVlO1xuXHRcdHNldChjb250ZXh0LmwucjIsIHRydWUpO1xuXHRcdHVudHJhY2soZm4pO1xuXHR9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9wcmVfZWZmZWN0X3Jlc2V0KCkge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpZiAoIWdldChjb250ZXh0LmwucjIpKSByZXR1cm47XG5cblx0XHQvLyBSdW4gZGlydHkgYCQ6YCBzdGF0ZW1lbnRzXG5cdFx0Zm9yICh2YXIgdG9rZW4gb2YgY29udGV4dC5sLnIxKSB7XG5cdFx0XHR2YXIgZWZmZWN0ID0gdG9rZW4uZWZmZWN0O1xuXG5cdFx0XHQvLyBJZiB0aGUgZWZmZWN0IGlzIENMRUFOLCB0aGVuIG1ha2UgaXQgTUFZQkVfRElSVFkuIFRoaXMgZW5zdXJlcyB3ZSB0cmF2ZXJzZSB0aHJvdWdoXG5cdFx0XHQvLyB0aGUgZWZmZWN0cyBkZXBlbmRlbmNpZXMgYW5kIGNvcnJlY3RseSBlbnN1cmUgZWFjaCBkZXBlbmRlbmN5IGlzIHVwLXRvLWRhdGUuXG5cdFx0XHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pICE9PSAwKSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2hlY2tfZGlydGluZXNzKGVmZmVjdCkpIHtcblx0XHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHR0b2tlbi5yYW4gPSBmYWxzZTtcblx0XHR9XG5cblx0XHRjb250ZXh0LmwucjIudiA9IGZhbHNlOyAvLyBzZXQgZGlyZWN0bHkgdG8gYXZvaWQgcmVydW5uaW5nIHRoaXMgZWZmZWN0XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QsIGZuLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyguLi5leHByZXNzaW9uczogYW55KSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtBcnJheTwoKSA9PiBhbnk+fSB0aHVua3NcbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZV9lZmZlY3QoZm4sIHRodW5rcyA9IFtdLCBkID0gZGVyaXZlZCkge1xuXHRjb25zdCBkZXJpdmVkcyA9IHRodW5rcy5tYXAoZCk7XG5cdGNvbnN0IGVmZmVjdCA9ICgpID0+IGZuKC4uLmRlcml2ZWRzLm1hcChnZXQpKTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGVmZmVjdCwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJ3tleHByZXNzaW9ufSdcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBibG9jayhlZmZlY3QpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibG9jayhmbiwgZmxhZ3MgPSAwKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QgfCBCTE9DS19FRkZFQ1QgfCBmbGFncywgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBbcHVzaF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaChmbiwgcHVzaCA9IHRydWUpIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IEJSQU5DSF9FRkZFQ1QsIGZuLCB0cnVlLCBwdXNoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpIHtcblx0dmFyIHRlYXJkb3duID0gZWZmZWN0LnRlYXJkb3duO1xuXHRpZiAodGVhcmRvd24gIT09IG51bGwpIHtcblx0XHRjb25zdCBwcmV2aW91c2x5X2Rlc3Ryb3lpbmdfZWZmZWN0ID0gaXNfZGVzdHJveWluZ19lZmZlY3Q7XG5cdFx0Y29uc3QgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHRydWUpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0dHJ5IHtcblx0XHRcdHRlYXJkb3duLmNhbGwobnVsbCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdChwcmV2aW91c2x5X2Rlc3Ryb3lpbmdfZWZmZWN0KTtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVtb3ZlX2RvbVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihzaWduYWwsIHJlbW92ZV9kb20gPSBmYWxzZSkge1xuXHR2YXIgZWZmZWN0ID0gc2lnbmFsLmZpcnN0O1xuXHRzaWduYWwuZmlyc3QgPSBzaWduYWwubGFzdCA9IG51bGw7XG5cblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0LCByZW1vdmVfZG9tKTtcblx0XHRlZmZlY3QgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IHNpZ25hbC5maXJzdDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblx0XHRpZiAoKGVmZmVjdC5mICYgQlJBTkNIX0VGRkVDVCkgPT09IDApIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0fVxuXHRcdGVmZmVjdCA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfZG9tXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdChlZmZlY3QsIHJlbW92ZV9kb20gPSB0cnVlKSB7XG5cdHZhciByZW1vdmVkID0gZmFsc2U7XG5cblx0aWYgKChyZW1vdmVfZG9tIHx8IChlZmZlY3QuZiAmIEhFQURfRUZGRUNUKSAhPT0gMCkgJiYgZWZmZWN0Lm5vZGVzX3N0YXJ0ICE9PSBudWxsKSB7XG5cdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHRcdHZhciBub2RlID0gZWZmZWN0Lm5vZGVzX3N0YXJ0O1xuXHRcdHZhciBlbmQgPSBlZmZlY3Qubm9kZXNfZW5kO1xuXG5cdFx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0XHRcdHZhciBuZXh0ID0gbm9kZSA9PT0gZW5kID8gbnVsbCA6IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cblx0XHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0XHRub2RlID0gbmV4dDtcblx0XHR9XG5cblx0XHRyZW1vdmVkID0gdHJ1ZTtcblx0fVxuXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCwgcmVtb3ZlX2RvbSAmJiAhcmVtb3ZlZCk7XG5cdHJlbW92ZV9yZWFjdGlvbnMoZWZmZWN0LCAwKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBERVNUUk9ZRUQpO1xuXG5cdHZhciB0cmFuc2l0aW9ucyA9IGVmZmVjdC50cmFuc2l0aW9ucztcblxuXHRpZiAodHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgdHJhbnNpdGlvbnMpIHtcblx0XHRcdHRyYW5zaXRpb24uc3RvcCgpO1xuXHRcdH1cblx0fVxuXG5cdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCk7XG5cblx0dmFyIHBhcmVudCA9IGVmZmVjdC5wYXJlbnQ7XG5cblx0Ly8gSWYgdGhlIHBhcmVudCBkb2Vzbid0IGhhdmUgYW55IGNoaWxkcmVuLCB0aGVuIHNraXAgdGhpcyB3b3JrIGFsdG9nZXRoZXJcblx0aWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZmlyc3QgIT09IG51bGwpIHtcblx0XHR1bmxpbmtfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cdH1cblxuXHQvLyBgZmlyc3RgIGFuZCBgY2hpbGRgIGFyZSBudWxsZWQgb3V0IGluIGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuXG5cdC8vIHdlIGRvbid0IG51bGwgb3V0IGBwYXJlbnRgIHNvIHRoYXQgZXJyb3IgcHJvcGFnYXRpb24gY2FuIHdvcmsgY29ycmVjdGx5XG5cdGVmZmVjdC5uZXh0ID1cblx0XHRlZmZlY3QucHJldiA9XG5cdFx0ZWZmZWN0LnRlYXJkb3duID1cblx0XHRlZmZlY3QuY3R4ID1cblx0XHRlZmZlY3QuZGVwcyA9XG5cdFx0ZWZmZWN0LmZuID1cblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPVxuXHRcdGVmZmVjdC5ub2Rlc19lbmQgPVxuXHRcdFx0bnVsbDtcbn1cblxuLyoqXG4gKiBEZXRhY2ggYW4gZWZmZWN0IGZyb20gdGhlIGVmZmVjdCB0cmVlLCBmcmVlaW5nIHVwIG1lbW9yeSBhbmRcbiAqIHJlZHVjaW5nIHRoZSBhbW91bnQgb2Ygd29yayB0aGF0IGhhcHBlbnMgb24gc3Vic2VxdWVudCB0cmF2ZXJzYWxzXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpbmtfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblx0dmFyIHByZXYgPSBlZmZlY3QucHJldjtcblx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblxuXHRpZiAocHJldiAhPT0gbnVsbCkgcHJldi5uZXh0ID0gbmV4dDtcblx0aWYgKG5leHQgIT09IG51bGwpIG5leHQucHJldiA9IHByZXY7XG5cblx0aWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmIChwYXJlbnQuZmlyc3QgPT09IGVmZmVjdCkgcGFyZW50LmZpcnN0ID0gbmV4dDtcblx0XHRpZiAocGFyZW50Lmxhc3QgPT09IGVmZmVjdCkgcGFyZW50Lmxhc3QgPSBwcmV2O1xuXHR9XG59XG5cbi8qKlxuICogV2hlbiBhIGJsb2NrIGVmZmVjdCBpcyByZW1vdmVkLCB3ZSBkb24ndCBpbW1lZGlhdGVseSBkZXN0cm95IGl0IG9yIHlhbmsgaXRcbiAqIG91dCBvZiB0aGUgRE9NLCBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgdHJhbnNpdGlvbnMuIEluc3RlYWQsIHdlICdwYXVzZScgaXQuXG4gKiBJdCBzdGF5cyBhcm91bmQgKGluIG1lbW9yeSwgYW5kIGluIHRoZSBET00pIHVudGlsIG91dHJvIHRyYW5zaXRpb25zIGhhdmVcbiAqIGNvbXBsZXRlZCwgYW5kIGlmIHRoZSBzdGF0ZSBjaGFuZ2UgaXMgcmV2ZXJzZWQgdGhlbiB3ZSBfcmVzdW1lXyBpdC5cbiAqIEEgcGF1c2VkIGVmZmVjdCBkb2VzIG5vdCB1cGRhdGUsIGFuZCB0aGUgRE9NIHN1YnRyZWUgYmVjb21lcyBpbmVydC5cbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF1c2VfZWZmZWN0KGVmZmVjdCwgY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblxuXHRwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCB0cnVlKTtcblxuXHRydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCAoKSA9PiB7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gdHJhbnNpdGlvbnNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIGZuKSB7XG5cdHZhciByZW1haW5pbmcgPSB0cmFuc2l0aW9ucy5sZW5ndGg7XG5cdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0dmFyIGNoZWNrID0gKCkgPT4gLS1yZW1haW5pbmcgfHwgZm4oKTtcblx0XHRmb3IgKHZhciB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLm91dChjaGVjayk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge1RyYW5zaXRpb25NYW5hZ2VyW119IHRyYW5zaXRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCBsb2NhbCkge1xuXHRpZiAoKGVmZmVjdC5mICYgSU5FUlQpICE9PSAwKSByZXR1cm47XG5cdGVmZmVjdC5mIF49IElORVJUO1xuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9IChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fCAoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHBhdXNlX2NoaWxkcmVuIHJlY3Vyc2l2ZWx5IHdpdGggYSBsaW5rZWQgbGlzdCBpbiBwbGFjZVxuXHRcdC8vIGl0J3Mgc2xpZ2h0bHkgbW9yZSBpbnZvbHZlZCB0aG91Z2ggYXMgd2UgaGF2ZSB0byBhY2NvdW50IGZvciBgdHJhbnNwYXJlbnRgIGNoYW5naW5nXG5cdFx0Ly8gdGhyb3VnaCB0aGUgdHJlZS5cblx0XHRwYXVzZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNpdGlvbnMsIHRyYW5zcGFyZW50ID8gbG9jYWwgOiBmYWxzZSk7XG5cdFx0Y2hpbGQgPSBzaWJsaW5nO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBwYXVzZV9lZmZlY3RgLiBXZSBjYWxsIHRoaXMgaWYgKGZvciBleGFtcGxlKVxuICogYHhgIGJlY29tZXMgZmFsc3kgdGhlbiB0cnV0aHk6IGB7I2lmIHh9Li4uey9pZn1gXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN1bWVfZWZmZWN0KGVmZmVjdCkge1xuXHRyZXN1bWVfY2hpbGRyZW4oZWZmZWN0LCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZV9jaGlsZHJlbihlZmZlY3QsIGxvY2FsKSB7XG5cdGlmICgoZWZmZWN0LmYgJiBJTkVSVCkgPT09IDApIHJldHVybjtcblx0ZWZmZWN0LmYgXj0gSU5FUlQ7XG5cblx0Ly8gRW5zdXJlIHRoZSBlZmZlY3QgaXMgbWFya2VkIGFzIGNsZWFuIGFnYWluIHNvIHRoYXQgYW55IGRpcnR5IGNoaWxkXG5cdC8vIGVmZmVjdHMgY2FuIHNjaGVkdWxlIHRoZW1zZWx2ZXMgZm9yIGV4ZWN1dGlvblxuXHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pID09PSAwKSB7XG5cdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdH1cblxuXHQvLyBJZiBhIGRlcGVuZGVuY3kgb2YgdGhpcyBlZmZlY3QgY2hhbmdlZCB3aGlsZSBpdCB3YXMgcGF1c2VkLFxuXHQvLyBzY2hlZHVsZSB0aGUgZWZmZWN0IHRvIHVwZGF0ZVxuXHRpZiAoY2hlY2tfZGlydGluZXNzKGVmZmVjdCkpIHtcblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIERJUlRZKTtcblx0XHRzY2hlZHVsZV9lZmZlY3QoZWZmZWN0KTtcblx0fVxuXG5cdHZhciBjaGlsZCA9IGVmZmVjdC5maXJzdDtcblxuXHR3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0XHR2YXIgc2libGluZyA9IGNoaWxkLm5leHQ7XG5cdFx0dmFyIHRyYW5zcGFyZW50ID0gKGNoaWxkLmYgJiBFRkZFQ1RfVFJBTlNQQVJFTlQpICE9PSAwIHx8IChjaGlsZC5mICYgQlJBTkNIX0VGRkVDVCkgIT09IDA7XG5cdFx0Ly8gVE9ETyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgcmVzdW1lX2NoaWxkcmVuIHJlY3Vyc2l2ZWx5IHdpdGggYSBsaW5rZWQgbGlzdCBpbiBwbGFjZVxuXHRcdC8vIGl0J3Mgc2xpZ2h0bHkgbW9yZSBpbnZvbHZlZCB0aG91Z2ggYXMgd2UgaGF2ZSB0byBhY2NvdW50IGZvciBgdHJhbnNwYXJlbnRgIGNoYW5naW5nXG5cdFx0Ly8gdGhyb3VnaCB0aGUgdHJlZS5cblx0XHRyZXN1bWVfY2hpbGRyZW4oY2hpbGQsIHRyYW5zcGFyZW50ID8gbG9jYWwgOiBmYWxzZSk7XG5cdFx0Y2hpbGQgPSBzaWJsaW5nO1xuXHR9XG5cblx0aWYgKGVmZmVjdC50cmFuc2l0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiBlZmZlY3QudHJhbnNpdGlvbnMpIHtcblx0XHRcdGlmICh0cmFuc2l0aW9uLmlzX2dsb2JhbCB8fCBsb2NhbCkge1xuXHRcdFx0XHR0cmFuc2l0aW9uLmluKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCJpbXBvcnQgeyBydW5fYWxsIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLy8gRmFsbGJhY2sgZm9yIHdoZW4gcmVxdWVzdElkbGVDYWxsYmFjayBpcyBub3QgYXZhaWxhYmxlXG5leHBvcnQgY29uc3QgcmVxdWVzdF9pZGxlX2NhbGxiYWNrID1cblx0dHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09ICd1bmRlZmluZWQnXG5cdFx0PyAoLyoqIEB0eXBlIHsoKSA9PiB2b2lkfSAqLyBjYikgPT4gc2V0VGltZW91dChjYiwgMSlcblx0XHQ6IHJlcXVlc3RJZGxlQ2FsbGJhY2s7XG5cbmxldCBpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xubGV0IGlzX2lkbGVfdGFza19xdWV1ZWQgPSBmYWxzZTtcblxuLyoqIEB0eXBlIHtBcnJheTwoKSA9PiB2b2lkPn0gKi9cbmxldCBjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcyA9IFtdO1xuLyoqIEB0eXBlIHtBcnJheTwoKSA9PiB2b2lkPn0gKi9cbmxldCBjdXJyZW50X3F1ZXVlZF9pZGxlX3Rhc2tzID0gW107XG5cbmZ1bmN0aW9uIHByb2Nlc3NfbWljcm9fdGFza3MoKSB7XG5cdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cdGNvbnN0IHRhc2tzID0gY3VycmVudF9xdWV1ZWRfbWljcm9fdGFza3Muc2xpY2UoKTtcblx0Y3VycmVudF9xdWV1ZWRfbWljcm9fdGFza3MgPSBbXTtcblx0cnVuX2FsbCh0YXNrcyk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfaWRsZV90YXNrcygpIHtcblx0aXNfaWRsZV90YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXHRjb25zdCB0YXNrcyA9IGN1cnJlbnRfcXVldWVkX2lkbGVfdGFza3Muc2xpY2UoKTtcblx0Y3VycmVudF9xdWV1ZWRfaWRsZV90YXNrcyA9IFtdO1xuXHRydW5fYWxsKHRhc2tzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWV1ZV9taWNyb190YXNrKGZuKSB7XG5cdGlmICghaXNfbWljcm9fdGFza19xdWV1ZWQpIHtcblx0XHRpc19taWNyb190YXNrX3F1ZXVlZCA9IHRydWU7XG5cdFx0cXVldWVNaWNyb3Rhc2socHJvY2Vzc19taWNyb190YXNrcyk7XG5cdH1cblx0Y3VycmVudF9xdWV1ZWRfbWljcm9fdGFza3MucHVzaChmbik7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVldWVfaWRsZV90YXNrKGZuKSB7XG5cdGlmICghaXNfaWRsZV90YXNrX3F1ZXVlZCkge1xuXHRcdGlzX2lkbGVfdGFza19xdWV1ZWQgPSB0cnVlO1xuXHRcdHJlcXVlc3RfaWRsZV9jYWxsYmFjayhwcm9jZXNzX2lkbGVfdGFza3MpO1xuXHR9XG5cdGN1cnJlbnRfcXVldWVkX2lkbGVfdGFza3MucHVzaChmbik7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBydW4gYW55IHF1ZXVlZCB0YXNrcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX3Rhc2tzKCkge1xuXHRpZiAoaXNfbWljcm9fdGFza19xdWV1ZWQpIHtcblx0XHRwcm9jZXNzX21pY3JvX3Rhc2tzKCk7XG5cdH1cblx0aWYgKGlzX2lkbGVfdGFza19xdWV1ZWQpIHtcblx0XHRwcm9jZXNzX2lkbGVfdGFza3MoKTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBEZXJpdmVkLCBFZmZlY3QsIFJlYWN0aW9uLCBTaWduYWwsIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHksIGdldF9kZXNjcmlwdG9ycywgZ2V0X3Byb3RvdHlwZV9vZiwgaW5kZXhfb2YgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0ZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4sXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuLFxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93bixcblx0dW5saW5rX2VmZmVjdFxufSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRFRkZFQ1QsXG5cdFJFTkRFUl9FRkZFQ1QsXG5cdERJUlRZLFxuXHRNQVlCRV9ESVJUWSxcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdFVOT1dORUQsXG5cdERFU1RST1lFRCxcblx0SU5FUlQsXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFNUQVRFX1NZTUJPTCxcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0TEVHQUNZX0RFUklWRURfUFJPUCxcblx0RElTQ09OTkVDVEVELFxuXHRCT1VOREFSWV9FRkZFQ1Rcbn0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZmx1c2hfdGFza3MgfSBmcm9tICcuL2RvbS90YXNrLmpzJztcbmltcG9ydCB7IGludGVybmFsX3NldCB9IGZyb20gJy4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzLCB1cGRhdGVfZGVyaXZlZCB9IGZyb20gJy4vcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgdHJhY2luZ19leHByZXNzaW9ucywgZ2V0X3N0YWNrIH0gZnJvbSAnLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQge1xuXHRjb21wb25lbnRfY29udGV4dCxcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRpc19ydW5lcyxcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0LFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uXG59IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBpc19maXJlZm94IH0gZnJvbSAnLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5cbmNvbnN0IEZMVVNIX01JQ1JPVEFTSyA9IDA7XG5jb25zdCBGTFVTSF9TWU5DID0gMTtcbi8vIFVzZWQgZm9yIERFViB0aW1lIGVycm9yIGhhbmRsaW5nXG4vKiogQHBhcmFtIHtXZWFrU2V0PEVycm9yPn0gdmFsdWUgKi9cbmNvbnN0IGhhbmRsZWRfZXJyb3JzID0gbmV3IFdlYWtTZXQoKTtcbmV4cG9ydCBsZXQgaXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcblxuLy8gVXNlZCBmb3IgY29udHJvbGxpbmcgdGhlIGZsdXNoIG9mIGVmZmVjdHMuXG5sZXQgc2NoZWR1bGVyX21vZGUgPSBGTFVTSF9NSUNST1RBU0s7XG4vLyBVc2VkIGZvciBoYW5kbGluZyBzY2hlZHVsaW5nXG5sZXQgaXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcblxuLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xubGV0IGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cbmV4cG9ydCBsZXQgaXNfZmx1c2hpbmdfZWZmZWN0ID0gZmFsc2U7XG5leHBvcnQgbGV0IGlzX2Rlc3Ryb3lpbmdfZWZmZWN0ID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc19mbHVzaGluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodmFsdWUpIHtcblx0aXNfZGVzdHJveWluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuLy8gSGFuZGxlIGVmZmVjdCBxdWV1ZXNcblxuLyoqIEB0eXBlIHtFZmZlY3RbXX0gKi9cbmxldCBxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cbmxldCBmbHVzaF9jb3VudCA9IDA7XG4vKiogQHR5cGUge0VmZmVjdFtdfSBTdGFjayBvZiBlZmZlY3RzLCBkZXYgb25seSAqL1xubGV0IGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcbi8vIEhhbmRsZSBzaWduYWwgcmVhY3Rpdml0eSB0cmVlIGRlcGVuZGVuY2llcyBhbmQgcmVhY3Rpb25zXG5cbi8qKiBAdHlwZSB7bnVsbCB8IFJlYWN0aW9ufSAqL1xuZXhwb3J0IGxldCBhY3RpdmVfcmVhY3Rpb24gPSBudWxsO1xuXG5leHBvcnQgbGV0IHVudHJhY2tpbmcgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IFJlYWN0aW9ufSByZWFjdGlvbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hY3RpdmVfcmVhY3Rpb24ocmVhY3Rpb24pIHtcblx0YWN0aXZlX3JlYWN0aW9uID0gcmVhY3Rpb247XG59XG5cbi8qKiBAdHlwZSB7bnVsbCB8IEVmZmVjdH0gKi9cbmV4cG9ydCBsZXQgYWN0aXZlX2VmZmVjdCA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBFZmZlY3R9IGVmZmVjdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hY3RpdmVfZWZmZWN0KGVmZmVjdCkge1xuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xufVxuXG4vKipcbiAqIFdoZW4gc291cmNlcyBhcmUgY3JlYXRlZCB3aXRoaW4gYSBkZXJpdmVkLCB3ZSByZWNvcmQgdGhlbSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgYWxsb3dcbiAqIGxvY2FsIG11dGF0aW9ucyB0byB0aGVzZSBzb3VyY2VzIHdpdGhvdXQgdGhlIHNpZGUtZWZmZWN0IGVycm9yIGJlaW5nIGludm9rZWQgdW5uZWNlc3NhcmlseS5cbiAqIEB0eXBlIHtudWxsIHwgU291cmNlW119XG4gKi9cbmV4cG9ydCBsZXQgZGVyaXZlZF9zb3VyY2VzID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge1NvdXJjZVtdIHwgbnVsbH0gc291cmNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rlcml2ZWRfc291cmNlcyhzb3VyY2VzKSB7XG5cdGRlcml2ZWRfc291cmNlcyA9IHNvdXJjZXM7XG59XG5cbi8qKlxuICogVGhlIGRlcGVuZGVuY2llcyBvZiB0aGUgcmVhY3Rpb24gdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQuIEluIG1hbnkgY2FzZXMsXG4gKiB0aGUgZGVwZW5kZW5jaWVzIGFyZSB1bmNoYW5nZWQgYmV0d2VlbiBydW5zLCBhbmQgc28gdGhpcyB3aWxsIGJlIGBudWxsYCB1bmxlc3NcbiAqIGFuZCB1bnRpbCBhIG5ldyBkZXBlbmRlbmN5IGlzIGFjY2Vzc2VkIOKAlCB3ZSB0cmFjayB0aGlzIHZpYSBgc2tpcHBlZF9kZXBzYFxuICogQHR5cGUge251bGwgfCBWYWx1ZVtdfVxuICovXG5leHBvcnQgbGV0IG5ld19kZXBzID0gbnVsbDtcblxubGV0IHNraXBwZWRfZGVwcyA9IDA7XG5cbi8qKlxuICogVHJhY2tzIHdyaXRlcyB0aGF0IHRoZSBlZmZlY3QgaXQncyBleGVjdXRlZCBpbiBkb2Vzbid0IGxpc3RlbiB0byB5ZXQsXG4gKiBzbyB0aGF0IHRoZSBkZXBlbmRlbmN5IGNhbiBiZSBhZGRlZCB0byB0aGUgZWZmZWN0IGxhdGVyIG9uIGlmIGl0IHRoZW4gcmVhZHMgaXRcbiAqIEB0eXBlIHtudWxsIHwgU291cmNlW119XG4gKi9cbmV4cG9ydCBsZXQgdW50cmFja2VkX3dyaXRlcyA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBTb3VyY2VbXX0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdW50cmFja2VkX3dyaXRlcyh2YWx1ZSkge1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHR5cGUge251bWJlcn0gVXNlZCBieSBzb3VyY2VzIGFuZCBkZXJpdmVkcyBmb3IgaGFuZGxpbmcgdXBkYXRlcy5cbiAqIFZlcnNpb24gc3RhcnRzIGZyb20gMSBzbyB0aGF0IHVub3duZWQgZGVyaXZlZHMgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGEgY3JlYXRlZCBlZmZlY3QgYW5kIGEgcnVuIG9uZSBmb3IgdHJhY2luZ1xuICoqL1xubGV0IHdyaXRlX3ZlcnNpb24gPSAxO1xuXG4vKiogQHR5cGUge251bWJlcn0gVXNlZCB0byB2ZXJzaW9uIGVhY2ggcmVhZCBvZiBhIHNvdXJjZSBvZiBkZXJpdmVkIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGRlcGVkZW5jaWVzIGluc2lkZSBhIHJlYWN0aW9uICovXG5sZXQgcmVhZF92ZXJzaW9uID0gMDtcblxuLy8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIGdldCgpIGNoYWluIHRoYXQgaGFzIG5vIGFjdGl2ZSBjb250YWluZXIsXG4vLyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcywgd2Ugc2tpcCBhZGRpbmcgdGhlIHJlYWN0aW9uLlxuZXhwb3J0IGxldCBza2lwX3JlYWN0aW9uID0gZmFsc2U7XG4vLyBIYW5kbGUgY29sbGVjdGluZyBhbGwgc2lnbmFscyB3aGljaCBhcmUgcmVhZCBkdXJpbmcgYSBzcGVjaWZpYyB0aW1lIGZyYW1lXG4vKiogQHR5cGUge1NldDxWYWx1ZT4gfCBudWxsfSAqL1xuZXhwb3J0IGxldCBjYXB0dXJlZF9zaWduYWxzID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7U2V0PFZhbHVlPiB8IG51bGx9IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2NhcHR1cmVkX3NpZ25hbHModmFsdWUpIHtcblx0Y2FwdHVyZWRfc2lnbmFscyA9IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKSB7XG5cdHJldHVybiArK3dyaXRlX3ZlcnNpb247XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZGVyaXZlZCBvciBlZmZlY3QgaXMgZGlydHkuXG4gKiBJZiBpdCBpcyBNQVlCRV9ESVJUWSwgd2lsbCBzZXQgdGhlIHN0YXR1cyB0byBDTEVBTlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfZGlydGluZXNzKHJlYWN0aW9uKSB7XG5cdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0aWYgKChmbGFncyAmIERJUlRZKSAhPT0gMCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKChmbGFncyAmIE1BWUJFX0RJUlRZKSAhPT0gMCkge1xuXHRcdHZhciBkZXBlbmRlbmNpZXMgPSByZWFjdGlvbi5kZXBzO1xuXHRcdHZhciBpc191bm93bmVkID0gKGZsYWdzICYgVU5PV05FRCkgIT09IDA7XG5cblx0XHRpZiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdHZhciBkZXBlbmRlbmN5O1xuXHRcdFx0dmFyIGlzX2Rpc2Nvbm5lY3RlZCA9IChmbGFncyAmIERJU0NPTk5FQ1RFRCkgIT09IDA7XG5cdFx0XHR2YXIgaXNfdW5vd25lZF9jb25uZWN0ZWQgPSBpc191bm93bmVkICYmIGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgIXNraXBfcmVhY3Rpb247XG5cdFx0XHR2YXIgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIGRpc2Nvbm5lY3RlZCBvciBhbiB1bm93bmVkIHNpZ25hbCB0aGF0IGlzIG5vdyBjb25uZWN0ZWQgKGR1ZSB0byBhbiBhY3RpdmUgZWZmZWN0KVxuXHRcdFx0Ly8gdGhlbiB3ZSBuZWVkIHRvIHJlLWNvbm5lY3QgdGhlIHJlYWN0aW9uIHRvIHRoZSBkZXBlbmRlbmN5XG5cdFx0XHRpZiAoaXNfZGlzY29ubmVjdGVkIHx8IGlzX3Vub3duZWRfY29ubmVjdGVkKSB7XG5cdFx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pO1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gZGVyaXZlZC5wYXJlbnQ7XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcblxuXHRcdFx0XHRcdC8vIFdlIGFsd2F5cyByZS1hZGQgYWxsIHJlYWN0aW9ucyAoZXZlbiBkdXBsaWNhdGVzKSBpZiB0aGUgZGVyaXZlZCB3YXNcblx0XHRcdFx0XHQvLyBwcmV2aW91c2x5IGRpc2Nvbm5lY3RlZCwgaG93ZXZlciB3ZSBkb24ndCBpZiBpdCB3YXMgdW5vd25lZCBhcyB3ZVxuXHRcdFx0XHRcdC8vIGRlLWR1cGxpY2F0ZSBkZXBlbmRlbmNpZXMgaW4gdGhhdCBjYXNlXG5cdFx0XHRcdFx0aWYgKGlzX2Rpc2Nvbm5lY3RlZCB8fCAhZGVwZW5kZW5jeT8ucmVhY3Rpb25zPy5pbmNsdWRlcyhkZXJpdmVkKSkge1xuXHRcdFx0XHRcdFx0KGRlcGVuZGVuY3kucmVhY3Rpb25zID8/PSBbXSkucHVzaChkZXJpdmVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNfZGlzY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0ZGVyaXZlZC5mIF49IERJU0NPTk5FQ1RFRDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB0aGUgdW5vd25lZCBkZXJpdmVkIGlzIG5vdyBmdWxseSBjb25uZWN0ZWQgdG8gdGhlIGdyYXBoIGFnYWluIChpdCdzIHVub3duZWQgYW5kIHJlY29ubmVjdGVkLCBoYXMgYSBwYXJlbnRcblx0XHRcdFx0Ly8gYW5kIHRoZSBwYXJlbnQgaXMgbm90IHVub3duZWQpLCB0aGVuIHdlIGNhbiBtYXJrIGl0IGFzIGNvbm5lY3RlZCBhZ2FpbiwgcmVtb3ZpbmcgdGhlIG5lZWQgZm9yIHRoZSB1bm93bmVkXG5cdFx0XHRcdC8vIGZsYWdcblx0XHRcdFx0aWYgKGlzX3Vub3duZWRfY29ubmVjdGVkICYmIHBhcmVudCAhPT0gbnVsbCAmJiAocGFyZW50LmYgJiBVTk9XTkVEKSA9PT0gMCkge1xuXHRcdFx0XHRcdGRlcml2ZWQuZiBePSBVTk9XTkVEO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuXG5cdFx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwZW5kZW5jeSkpKSB7XG5cdFx0XHRcdFx0dXBkYXRlX2Rlcml2ZWQoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRlcGVuZGVuY3kud3YgPiByZWFjdGlvbi53dikge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVW5vd25lZCBzaWduYWxzIHNob3VsZCBuZXZlciBiZSBtYXJrZWQgYXMgY2xlYW4gdW5sZXNzIHRoZXlcblx0XHQvLyBhcmUgdXNlZCB3aXRoaW4gYW4gYWN0aXZlX2VmZmVjdCB3aXRob3V0IHNraXBfcmVhY3Rpb25cblx0XHRpZiAoIWlzX3Vub3duZWQgfHwgKGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgIXNraXBfcmVhY3Rpb24pKSB7XG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgQ0xFQU4pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIHByb3BhZ2F0ZV9lcnJvcihlcnJvciwgZWZmZWN0KSB7XG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGN1cnJlbnQgPSBlZmZlY3Q7XG5cblx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRpZiAoKGN1cnJlbnQuZiAmIEJPVU5EQVJZX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0Y3VycmVudC5mbihlcnJvcik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHQvLyBSZW1vdmUgYm91bmRhcnkgZmxhZyBmcm9tIGVmZmVjdFxuXHRcdFx0XHRjdXJyZW50LmYgXj0gQk9VTkRBUllfRUZGRUNUO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcblx0fVxuXG5cdGlzX3Rocm93aW5nX2Vycm9yID0gZmFsc2U7XG5cdHRocm93IGVycm9yO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZnVuY3Rpb24gc2hvdWxkX3JldGhyb3dfZXJyb3IoZWZmZWN0KSB7XG5cdHJldHVybiAoXG5cdFx0KGVmZmVjdC5mICYgREVTVFJPWUVEKSA9PT0gMCAmJlxuXHRcdChlZmZlY3QucGFyZW50ID09PSBudWxsIHx8IChlZmZlY3QucGFyZW50LmYgJiBCT1VOREFSWV9FRkZFQ1QpID09PSAwKVxuXHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRfaXNfdGhyb3dpbmdfZXJyb3IoKSB7XG5cdGlzX3Rocm93aW5nX2Vycm9yID0gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBlcnJvclxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtFZmZlY3QgfCBudWxsfSBwcmV2aW91c19lZmZlY3RcbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dCB8IG51bGx9IGNvbXBvbmVudF9jb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVfZXJyb3IoZXJyb3IsIGVmZmVjdCwgcHJldmlvdXNfZWZmZWN0LCBjb21wb25lbnRfY29udGV4dCkge1xuXHRpZiAoaXNfdGhyb3dpbmdfZXJyb3IpIHtcblx0XHRpZiAocHJldmlvdXNfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0XHRpc190aHJvd2luZ19lcnJvciA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChzaG91bGRfcmV0aHJvd19lcnJvcihlZmZlY3QpKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAocHJldmlvdXNfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0aXNfdGhyb3dpbmdfZXJyb3IgPSB0cnVlO1xuXHR9XG5cblx0aWYgKFxuXHRcdCFERVYgfHxcblx0XHRjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCB8fFxuXHRcdCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHxcblx0XHRoYW5kbGVkX2Vycm9ycy5oYXMoZXJyb3IpXG5cdCkge1xuXHRcdHByb3BhZ2F0ZV9lcnJvcihlcnJvciwgZWZmZWN0KTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRoYW5kbGVkX2Vycm9ycy5hZGQoZXJyb3IpO1xuXG5cdGNvbnN0IGNvbXBvbmVudF9zdGFjayA9IFtdO1xuXG5cdGNvbnN0IGVmZmVjdF9uYW1lID0gZWZmZWN0LmZuPy5uYW1lO1xuXG5cdGlmIChlZmZlY3RfbmFtZSkge1xuXHRcdGNvbXBvbmVudF9zdGFjay5wdXNoKGVmZmVjdF9uYW1lKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dCB8IG51bGx9ICovXG5cdGxldCBjdXJyZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblxuXHR3aGlsZSAoY3VycmVudF9jb250ZXh0ICE9PSBudWxsKSB7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdFx0XHR2YXIgZmlsZW5hbWUgPSBjdXJyZW50X2NvbnRleHQuZnVuY3Rpb24/LltGSUxFTkFNRV07XG5cblx0XHRcdGlmIChmaWxlbmFtZSkge1xuXHRcdFx0XHRjb25zdCBmaWxlID0gZmlsZW5hbWUuc3BsaXQoJy8nKS5wb3AoKTtcblx0XHRcdFx0Y29tcG9uZW50X3N0YWNrLnB1c2goZmlsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3VycmVudF9jb250ZXh0ID0gY3VycmVudF9jb250ZXh0LnA7XG5cdH1cblxuXHRjb25zdCBpbmRlbnQgPSBpc19maXJlZm94ID8gJyAgJyA6ICdcXHQnO1xuXHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdtZXNzYWdlJywge1xuXHRcdHZhbHVlOiBlcnJvci5tZXNzYWdlICsgYFxcbiR7Y29tcG9uZW50X3N0YWNrLm1hcCgobmFtZSkgPT4gYFxcbiR7aW5kZW50fWluICR7bmFtZX1gKS5qb2luKCcnKX1cXG5gXG5cdH0pO1xuXHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdjb21wb25lbnRfc3RhY2snLCB7XG5cdFx0dmFsdWU6IGNvbXBvbmVudF9zdGFja1xuXHR9KTtcblxuXHRjb25zdCBzdGFjayA9IGVycm9yLnN0YWNrO1xuXG5cdC8vIEZpbHRlciBvdXQgaW50ZXJuYWwgZmlsZXMgZnJvbSBjYWxsc3RhY2tcblx0aWYgKHN0YWNrKSB7XG5cdFx0Y29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG5cdFx0Y29uc3QgbmV3X2xpbmVzID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0aWYgKGxpbmUuaW5jbHVkZXMoJ3N2ZWx0ZS9zcmMvaW50ZXJuYWwnKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdG5ld19saW5lcy5wdXNoKGxpbmUpO1xuXHRcdH1cblx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcblx0XHRcdHZhbHVlOiBuZXdfbGluZXMuam9pbignXFxuJylcblx0XHR9KTtcblx0fVxuXG5cdHByb3BhZ2F0ZV9lcnJvcihlcnJvciwgZWZmZWN0KTtcblxuXHRpZiAoc2hvdWxkX3JldGhyb3dfZXJyb3IoZWZmZWN0KSkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyb290XVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oc2lnbmFsLCBlZmZlY3QsIHJvb3QgPSB0cnVlKSB7XG5cdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zID09PSBudWxsKSByZXR1cm47XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZWFjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cdFx0aWYgKChyZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDApIHtcblx0XHRcdHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbigvKiogQHR5cGUge0Rlcml2ZWR9ICovIChyZWFjdGlvbiksIGVmZmVjdCwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZiAoZWZmZWN0ID09PSByZWFjdGlvbikge1xuXHRcdFx0aWYgKHJvb3QpIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIERJUlRZKTtcblx0XHRcdH0gZWxzZSBpZiAoKHJlYWN0aW9uLmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIE1BWUJFX0RJUlRZKTtcblx0XHRcdH1cblx0XHRcdHNjaGVkdWxlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9yZWFjdGlvbihyZWFjdGlvbikge1xuXHR2YXIgcHJldmlvdXNfZGVwcyA9IG5ld19kZXBzO1xuXHR2YXIgcHJldmlvdXNfc2tpcHBlZF9kZXBzID0gc2tpcHBlZF9kZXBzO1xuXHR2YXIgcHJldmlvdXNfdW50cmFja2VkX3dyaXRlcyA9IHVudHJhY2tlZF93cml0ZXM7XG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX3NraXBfcmVhY3Rpb24gPSBza2lwX3JlYWN0aW9uO1xuXHR2YXIgcHJldl9kZXJpdmVkX3NvdXJjZXMgPSBkZXJpdmVkX3NvdXJjZXM7XG5cdHZhciBwcmV2aW91c19jb21wb25lbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXHR2YXIgcHJldmlvdXNfdW50cmFja2luZyA9IHVudHJhY2tpbmc7XG5cdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0bmV3X2RlcHMgPSAvKiogQHR5cGUge251bGwgfCBWYWx1ZVtdfSAqLyAobnVsbCk7XG5cdHNraXBwZWRfZGVwcyA9IDA7XG5cdHVudHJhY2tlZF93cml0ZXMgPSBudWxsO1xuXHRhY3RpdmVfcmVhY3Rpb24gPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDAgPyByZWFjdGlvbiA6IG51bGw7XG5cdHNraXBfcmVhY3Rpb24gPVxuXHRcdChmbGFncyAmIFVOT1dORUQpICE9PSAwICYmXG5cdFx0KCFpc19mbHVzaGluZ19lZmZlY3QgfHwgcHJldmlvdXNfcmVhY3Rpb24gPT09IG51bGwgfHwgcHJldmlvdXNfdW50cmFja2luZyk7XG5cblx0ZGVyaXZlZF9zb3VyY2VzID0gbnVsbDtcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHJlYWN0aW9uLmN0eCk7XG5cdHVudHJhY2tpbmcgPSBmYWxzZTtcblx0cmVhZF92ZXJzaW9uKys7XG5cblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKDAsIHJlYWN0aW9uLmZuKSgpO1xuXHRcdHZhciBkZXBzID0gcmVhY3Rpb24uZGVwcztcblxuXHRcdGlmIChuZXdfZGVwcyAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdHJlbW92ZV9yZWFjdGlvbnMocmVhY3Rpb24sIHNraXBwZWRfZGVwcyk7XG5cblx0XHRcdGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA+IDApIHtcblx0XHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHMgKyBuZXdfZGVwcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBuZXdfZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRlcHNbc2tpcHBlZF9kZXBzICsgaV0gPSBuZXdfZGVwc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVhY3Rpb24uZGVwcyA9IGRlcHMgPSBuZXdfZGVwcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFza2lwX3JlYWN0aW9uKSB7XG5cdFx0XHRcdGZvciAoaSA9IHNraXBwZWRfZGVwczsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHQoZGVwc1tpXS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKHJlYWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZGVwcyAhPT0gbnVsbCAmJiBza2lwcGVkX2RlcHMgPCBkZXBzLmxlbmd0aCkge1xuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblx0XHRcdGRlcHMubGVuZ3RoID0gc2tpcHBlZF9kZXBzO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIGluc2lkZSBhbiBlZmZlY3QgYW5kIHdlIGhhdmUgdW50cmFja2VkIHdyaXRlcywgdGhlbiB3ZSBuZWVkIHRvXG5cdFx0Ly8gZW5zdXJlIHRoYXQgaWYgYW55IG9mIHRob3NlIHVudHJhY2tlZCB3cml0ZXMgcmVzdWx0IGluIHJlLWludmFsaWRhdGlvblxuXHRcdC8vIG9mIHRoZSBjdXJyZW50IGVmZmVjdCwgdGhlbiB0aGF0IGhhcHBlbnMgYWNjb3JkaW5nbHlcblx0XHRpZiAoXG5cdFx0XHRpc19ydW5lcygpICYmXG5cdFx0XHR1bnRyYWNrZWRfd3JpdGVzICE9PSBudWxsICYmXG5cdFx0XHQhdW50cmFja2luZyAmJlxuXHRcdFx0ZGVwcyAhPT0gbnVsbCAmJlxuXHRcdFx0KHJlYWN0aW9uLmYgJiAoREVSSVZFRCB8IE1BWUJFX0RJUlRZIHwgRElSVFkpKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IC8qKiBAdHlwZSB7U291cmNlW119ICovICh1bnRyYWNrZWRfd3JpdGVzKS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oXG5cdFx0XHRcdFx0dW50cmFja2VkX3dyaXRlc1tpXSxcblx0XHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlIGFyZSByZXR1cm5pbmcgdG8gYW4gcHJldmlvdXMgcmVhY3Rpb24gdGhlblxuXHRcdC8vIHdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSByZWFkIHZlcnNpb24gdG8gZW5zdXJlIHRoYXRcblx0XHQvLyBhbnkgZGVwZW5kZW5jaWVzIGluIHRoaXMgcmVhY3Rpb24gYXJlbid0IG1hcmtlZCB3aXRoXG5cdFx0Ly8gdGhlIHNhbWUgdmVyc2lvblxuXHRcdGlmIChwcmV2aW91c19yZWFjdGlvbiAhPT0gbnVsbCkge1xuXHRcdFx0cmVhZF92ZXJzaW9uKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBmaW5hbGx5IHtcblx0XHRuZXdfZGVwcyA9IHByZXZpb3VzX2RlcHM7XG5cdFx0c2tpcHBlZF9kZXBzID0gcHJldmlvdXNfc2tpcHBlZF9kZXBzO1xuXHRcdHVudHJhY2tlZF93cml0ZXMgPSBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzO1xuXHRcdGFjdGl2ZV9yZWFjdGlvbiA9IHByZXZpb3VzX3JlYWN0aW9uO1xuXHRcdHNraXBfcmVhY3Rpb24gPSBwcmV2aW91c19za2lwX3JlYWN0aW9uO1xuXHRcdGRlcml2ZWRfc291cmNlcyA9IHByZXZfZGVyaXZlZF9zb3VyY2VzO1xuXHRcdHNldF9jb21wb25lbnRfY29udGV4dChwcmV2aW91c19jb21wb25lbnRfY29udGV4dCk7XG5cdFx0dW50cmFja2luZyA9IHByZXZpb3VzX3VudHJhY2tpbmc7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBkZXBlbmRlbmN5XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9uKHNpZ25hbCwgZGVwZW5kZW5jeSkge1xuXHRsZXQgcmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHR2YXIgaW5kZXggPSBpbmRleF9vZi5jYWxsKHJlYWN0aW9ucywgc2lnbmFsKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR2YXIgbmV3X2xlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGggLSAxO1xuXHRcdFx0aWYgKG5ld19sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3dhcCB3aXRoIGxhc3QgZWxlbWVudCBhbmQgdGhlbiByZW1vdmUuXG5cdFx0XHRcdHJlYWN0aW9uc1tpbmRleF0gPSByZWFjdGlvbnNbbmV3X2xlbmd0aF07XG5cdFx0XHRcdHJlYWN0aW9ucy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gSWYgdGhlIGRlcml2ZWQgaGFzIG5vIHJlYWN0aW9ucywgdGhlbiB3ZSBjYW4gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSBncmFwaCxcblx0Ly8gYWxsb3dpbmcgaXQgdG8gZWl0aGVyIHJlY29ubmVjdCBpbiB0aGUgZnV0dXJlLCBvciBiZSBHQydkIGJ5IHRoZSBWTS5cblx0aWYgKFxuXHRcdHJlYWN0aW9ucyA9PT0gbnVsbCAmJlxuXHRcdChkZXBlbmRlbmN5LmYgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdC8vIERlc3Ryb3lpbmcgYSBjaGlsZCBlZmZlY3Qgd2hpbGUgdXBkYXRpbmcgYSBwYXJlbnQgZWZmZWN0IGNhbiBjYXVzZSBhIGRlcGVuZGVuY3kgdG8gYXBwZWFyXG5cdFx0Ly8gdG8gYmUgdW51c2VkLCB3aGVuIGluIGZhY3QgaXQgaXMgdXNlZCBieSB0aGUgY3VycmVudGx5LXVwZGF0aW5nIHBhcmVudC4gQ2hlY2tpbmcgYG5ld19kZXBzYFxuXHRcdC8vIGFsbG93cyB1cyB0byBza2lwIHRoZSBleHBlbnNpdmUgd29yayBvZiBkaXNjb25uZWN0aW5nIGFuZCBpbW1lZGlhdGVseSByZWNvbm5lY3RpbmcgaXRcblx0XHQobmV3X2RlcHMgPT09IG51bGwgfHwgIW5ld19kZXBzLmluY2x1ZGVzKGRlcGVuZGVuY3kpKVxuXHQpIHtcblx0XHRzZXRfc2lnbmFsX3N0YXR1cyhkZXBlbmRlbmN5LCBNQVlCRV9ESVJUWSk7XG5cdFx0Ly8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIGRlcml2ZWQgdGhhdCBpcyBvd25lZCBieSBhbiBlZmZlY3QsIHRoZW4gbWFyayBpdCBhcyBiZWluZ1xuXHRcdC8vIGRpc2Nvbm5lY3RlZC5cblx0XHRpZiAoKGRlcGVuZGVuY3kuZiAmIChVTk9XTkVEIHwgRElTQ09OTkVDVEVEKSkgPT09IDApIHtcblx0XHRcdGRlcGVuZGVuY3kuZiBePSBESVNDT05ORUNURUQ7XG5cdFx0fVxuXHRcdC8vIERpc2Nvbm5lY3QgYW55IHJlYWN0aW9ucyBvd25lZCBieSB0aGlzIHJlYWN0aW9uXG5cdFx0ZGVzdHJveV9kZXJpdmVkX2VmZmVjdHMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqKi8gKGRlcGVuZGVuY3kpKTtcblx0XHRyZW1vdmVfcmVhY3Rpb25zKC8qKiBAdHlwZSB7RGVyaXZlZH0gKiovIChkZXBlbmRlbmN5KSwgMCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0aW9ufSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydF9pbmRleFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfcmVhY3Rpb25zKHNpZ25hbCwgc3RhcnRfaW5kZXgpIHtcblx0dmFyIGRlcGVuZGVuY2llcyA9IHNpZ25hbC5kZXBzO1xuXHRpZiAoZGVwZW5kZW5jaWVzID09PSBudWxsKSByZXR1cm47XG5cblx0Zm9yICh2YXIgaSA9IHN0YXJ0X2luZGV4OyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cmVtb3ZlX3JlYWN0aW9uKHNpZ25hbCwgZGVwZW5kZW5jaWVzW2ldKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2VmZmVjdChlZmZlY3QpIHtcblx0dmFyIGZsYWdzID0gZWZmZWN0LmY7XG5cblx0aWYgKChmbGFncyAmIERFU1RST1lFRCkgIT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIENMRUFOKTtcblxuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cblx0YWN0aXZlX2VmZmVjdCA9IGVmZmVjdDtcblxuXHRpZiAoREVWKSB7XG5cdFx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9mbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0XHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uKGVmZmVjdC5jb21wb25lbnRfZnVuY3Rpb24pO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAoKGZsYWdzICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0ZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4oZWZmZWN0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4oZWZmZWN0KTtcblx0XHR9XG5cblx0XHRleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpO1xuXHRcdHZhciB0ZWFyZG93biA9IHVwZGF0ZV9yZWFjdGlvbihlZmZlY3QpO1xuXHRcdGVmZmVjdC50ZWFyZG93biA9IHR5cGVvZiB0ZWFyZG93biA9PT0gJ2Z1bmN0aW9uJyA/IHRlYXJkb3duIDogbnVsbDtcblx0XHRlZmZlY3Qud3YgPSB3cml0ZV92ZXJzaW9uO1xuXG5cdFx0dmFyIGRlcHMgPSBlZmZlY3QuZGVwcztcblxuXHRcdC8vIEluIERFViwgd2UgbmVlZCB0byBoYW5kbGUgYSBjYXNlIHdoZXJlICRpbnNwZWN0LnRyYWNlKCkgbWlnaHRcblx0XHQvLyBpbmNvcnJlY3RseSBzdGF0ZSBhIHNvdXJjZSBkZXBlbmRlbmN5IGhhcyBub3QgY2hhbmdlZCB3aGVuIGl0IGhhcy5cblx0XHQvLyBUaGF0J3MgYmVhY3VzZSB0aGF0IHNvdXJjZSB3YXMgY2hhbmdlZCBieSB0aGUgc2FtZSBlZmZlY3QsIGNhdXNpbmdcblx0XHQvLyB0aGUgdmVyc2lvbnMgdG8gbWF0Y2guIFdlIGNhbiBhdm9pZCB0aGlzIGJ5IGluY3JlbWVudGluZyB0aGUgdmVyc2lvblxuXHRcdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcgJiYgKGVmZmVjdC5mICYgRElSVFkpICE9PSAwICYmIGRlcHMgIT09IG51bGwpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgZGVwID0gZGVwc1tpXTtcblx0XHRcdFx0aWYgKGRlcC50cmFjZV9uZWVkX2luY3JlYXNlKSB7XG5cdFx0XHRcdFx0ZGVwLnd2ID0gaW5jcmVtZW50X3dyaXRlX3ZlcnNpb24oKTtcblx0XHRcdFx0XHRkZXAudHJhY2VfbmVlZF9pbmNyZWFzZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRkZXAudHJhY2VfdiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9lZmZlY3Rfc3RhY2sucHVzaChlZmZlY3QpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGVmZmVjdCwgcHJldmlvdXNfZWZmZWN0LCBwcmV2aW91c19jb21wb25lbnRfY29udGV4dCB8fCBlZmZlY3QuY3R4KTtcblx0fSBmaW5hbGx5IHtcblx0XHRhY3RpdmVfZWZmZWN0ID0gcHJldmlvdXNfZWZmZWN0O1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihwcmV2aW91c19jb21wb25lbnRfZm4pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsb2dfZWZmZWN0X3N0YWNrKCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmVycm9yKFxuXHRcdCdMYXN0IHRlbiBlZmZlY3RzIHdlcmU6ICcsXG5cdFx0ZGV2X2VmZmVjdF9zdGFjay5zbGljZSgtMTApLm1hcCgoZCkgPT4gZC5mbilcblx0KTtcblx0ZGV2X2VmZmVjdF9zdGFjayA9IFtdO1xufVxuXG5mdW5jdGlvbiBpbmZpbml0ZV9sb29wX2d1YXJkKCkge1xuXHRpZiAoZmx1c2hfY291bnQgPiAxMDAwKSB7XG5cdFx0Zmx1c2hfY291bnQgPSAwO1xuXHRcdHRyeSB7XG5cdFx0XHRlLmVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHQvLyBzdGFjayBpcyBnYXJiYWdlLCBpZ25vcmUuIEluc3RlYWQgYWRkIGEgY29uc29sZS5lcnJvciBtZXNzYWdlLlxuXHRcdFx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcblx0XHRcdFx0XHR2YWx1ZTogJydcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUcnkgYW5kIGhhbmRsZSB0aGUgZXJyb3Igc28gaXQgY2FuIGJlIGNhdWdodCBhdCBhIGJvdW5kYXJ5LCB0aGF0J3Ncblx0XHRcdC8vIGlmIHRoZXJlJ3MgYW4gZWZmZWN0IGF2YWlsYWJsZSBmcm9tIHdoZW4gaXQgd2FzIGxhc3Qgc2NoZWR1bGVkXG5cdFx0XHRpZiAobGFzdF9zY2hlZHVsZWRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QsIG51bGwsIG51bGwpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdC8vIE9ubHkgbG9nIHRoZSBlZmZlY3Qgc3RhY2sgaWYgdGhlIGVycm9yIGlzIHJlLXRocm93blxuXHRcdFx0XHRcdFx0bG9nX2VmZmVjdF9zdGFjaygpO1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBsYXN0X3NjaGVkdWxlZF9lZmZlY3QsIG51bGwsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0bG9nX2VmZmVjdF9zdGFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmbHVzaF9jb3VudCsrO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RWZmZWN0Pn0gcm9vdF9lZmZlY3RzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcXVldWVkX3Jvb3RfZWZmZWN0cyhyb290X2VmZmVjdHMpIHtcblx0dmFyIGxlbmd0aCA9IHJvb3RfZWZmZWN0cy5sZW5ndGg7XG5cdGlmIChsZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aW5maW5pdGVfbG9vcF9ndWFyZCgpO1xuXG5cdHZhciBwcmV2aW91c2x5X2ZsdXNoaW5nX2VmZmVjdCA9IGlzX2ZsdXNoaW5nX2VmZmVjdDtcblx0aXNfZmx1c2hpbmdfZWZmZWN0ID0gdHJ1ZTtcblxuXHR0cnkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlZmZlY3QgPSByb290X2VmZmVjdHNbaV07XG5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgPT09IDApIHtcblx0XHRcdFx0ZWZmZWN0LmYgXj0gQ0xFQU47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb2xsZWN0ZWRfZWZmZWN0cyA9IHByb2Nlc3NfZWZmZWN0cyhlZmZlY3QpO1xuXHRcdFx0Zmx1c2hfcXVldWVkX2VmZmVjdHMoY29sbGVjdGVkX2VmZmVjdHMpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpc19mbHVzaGluZ19lZmZlY3QgPSBwcmV2aW91c2x5X2ZsdXNoaW5nX2VmZmVjdDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RWZmZWN0Pn0gZWZmZWN0c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3F1ZXVlZF9lZmZlY3RzKGVmZmVjdHMpIHtcblx0dmFyIGxlbmd0aCA9IGVmZmVjdHMubGVuZ3RoO1xuXHRpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhciBlZmZlY3QgPSBlZmZlY3RzW2ldO1xuXG5cdFx0aWYgKChlZmZlY3QuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpID09PSAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoY2hlY2tfZGlydGluZXNzKGVmZmVjdCkpIHtcblx0XHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cblx0XHRcdFx0XHQvLyBFZmZlY3RzIHdpdGggbm8gZGVwZW5kZW5jaWVzIG9yIHRlYXJkb3duIGRvIG5vdCBnZXQgYWRkZWQgdG8gdGhlIGVmZmVjdCB0cmVlLlxuXHRcdFx0XHRcdC8vIERlZmVycmVkIGVmZmVjdHMgKGUuZy4gYCRlZmZlY3QoLi4uKWApIF9hcmVfIGFkZGVkIHRvIHRoZSB0cmVlIGJlY2F1c2Ugd2Vcblx0XHRcdFx0XHQvLyBkb24ndCBrbm93IGlmIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVudGlsIHRoZXkgYXJlIGV4ZWN1dGVkLiBEb2luZyB0aGUgY2hlY2tcblx0XHRcdFx0XHQvLyBoZXJlIChyYXRoZXIgdGhhbiBpbiBgdXBkYXRlX2VmZmVjdGApIGFsbG93cyB1cyB0byBza2lwIHRoZSB3b3JrIGZvclxuXHRcdFx0XHRcdC8vIGltbWVkaWF0ZSBlZmZlY3RzLlxuXHRcdFx0XHRcdGlmIChlZmZlY3QuZGVwcyA9PT0gbnVsbCAmJiBlZmZlY3QuZmlyc3QgPT09IG51bGwgJiYgZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRpZiAoZWZmZWN0LnRlYXJkb3duID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSB0aGlzIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRcdFx0XHR1bmxpbmtfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3QgaW4gdGhlIGdyYXBoLCBidXQgZnJlZSB1cCBzb21lIG1lbW9yeVxuXHRcdFx0XHRcdFx0XHRlZmZlY3QuZm4gPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aGFuZGxlX2Vycm9yKGVycm9yLCBlZmZlY3QsIG51bGwsIGVmZmVjdC5jdHgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2RlZmVycmVkKCkge1xuXHRpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXHRpZiAoZmx1c2hfY291bnQgPiAxMDAxKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGNvbnN0IHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMgPSBxdWV1ZWRfcm9vdF9lZmZlY3RzO1xuXHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cdGZsdXNoX3F1ZXVlZF9yb290X2VmZmVjdHMocHJldmlvdXNfcXVldWVkX3Jvb3RfZWZmZWN0cyk7XG5cblx0aWYgKCFpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdGZsdXNoX2NvdW50ID0gMDtcblx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX2VmZmVjdChzaWduYWwpIHtcblx0aWYgKHNjaGVkdWxlcl9tb2RlID09PSBGTFVTSF9NSUNST1RBU0spIHtcblx0XHRpZiAoIWlzX21pY3JvX3Rhc2tfcXVldWVkKSB7XG5cdFx0XHRpc19taWNyb190YXNrX3F1ZXVlZCA9IHRydWU7XG5cdFx0XHRxdWV1ZU1pY3JvdGFzayhwcm9jZXNzX2RlZmVycmVkKTtcblx0XHR9XG5cdH1cblxuXHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBzaWduYWw7XG5cblx0dmFyIGVmZmVjdCA9IHNpZ25hbDtcblxuXHR3aGlsZSAoZWZmZWN0LnBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGVmZmVjdCA9IGVmZmVjdC5wYXJlbnQ7XG5cdFx0dmFyIGZsYWdzID0gZWZmZWN0LmY7XG5cblx0XHRpZiAoKGZsYWdzICYgKFJPT1RfRUZGRUNUIHwgQlJBTkNIX0VGRkVDVCkpICE9PSAwKSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgQ0xFQU4pID09PSAwKSByZXR1cm47XG5cdFx0XHRlZmZlY3QuZiBePSBDTEVBTjtcblx0XHR9XG5cdH1cblxuXHRxdWV1ZWRfcm9vdF9lZmZlY3RzLnB1c2goZWZmZWN0KTtcbn1cblxuLyoqXG4gKlxuICogVGhpcyBmdW5jdGlvbiBib3RoIHJ1bnMgcmVuZGVyIGVmZmVjdHMgYW5kIGNvbGxlY3RzIHVzZXIgZWZmZWN0cyBpbiB0b3BvbG9naWNhbCBvcmRlclxuICogZnJvbSB0aGUgc3RhcnRpbmcgZWZmZWN0IHBhc3NlZCBpbi4gRWZmZWN0cyB3aWxsIGJlIGNvbGxlY3RlZCB3aGVuIHRoZXkgbWF0Y2ggdGhlIGZpbHRlcmVkXG4gKiBiaXR3aXNlIGZsYWcgcGFzc2VkIGluIG9ubHkuIFRoZSBjb2xsZWN0ZWQgZWZmZWN0cyBhcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGFsbCB0aGUgdXNlclxuICogZWZmZWN0cyB0byBiZSBmbHVzaGVkLlxuICpcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEByZXR1cm5zIHtFZmZlY3RbXX1cbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc19lZmZlY3RzKGVmZmVjdCkge1xuXHQvKiogQHR5cGUge0VmZmVjdFtdfSAqL1xuXHR2YXIgZWZmZWN0cyA9IFtdO1xuXG5cdHZhciBjdXJyZW50X2VmZmVjdCA9IGVmZmVjdC5maXJzdDtcblxuXHRtYWluX2xvb3A6IHdoaWxlIChjdXJyZW50X2VmZmVjdCAhPT0gbnVsbCkge1xuXHRcdHZhciBmbGFncyA9IGN1cnJlbnRfZWZmZWN0LmY7XG5cdFx0dmFyIGlzX2JyYW5jaCA9IChmbGFncyAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdHZhciBpc19za2lwcGFibGVfYnJhbmNoID0gaXNfYnJhbmNoICYmIChmbGFncyAmIENMRUFOKSAhPT0gMDtcblx0XHR2YXIgc2libGluZyA9IGN1cnJlbnRfZWZmZWN0Lm5leHQ7XG5cblx0XHRpZiAoIWlzX3NraXBwYWJsZV9icmFuY2ggJiYgKGZsYWdzICYgSU5FUlQpID09PSAwKSB7XG5cdFx0XHRpZiAoKGZsYWdzICYgRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0XHRlZmZlY3RzLnB1c2goY3VycmVudF9lZmZlY3QpO1xuXHRcdFx0fSBlbHNlIGlmIChpc19icmFuY2gpIHtcblx0XHRcdFx0Y3VycmVudF9lZmZlY3QuZiBePSBDTEVBTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEVuc3VyZSB3ZSBzZXQgdGhlIGVmZmVjdCB0byBiZSB0aGUgYWN0aXZlIHJlYWN0aW9uXG5cdFx0XHRcdC8vIHRvIGVuc3VyZSB0aGF0IHVub3duZWQgZGVyaXZlZHMgYXJlIGNvcnJlY3RseSB0cmFja2VkXG5cdFx0XHRcdC8vIGJlY2F1c2Ugd2UncmUgZmx1c2hpbmcgdGhlIGN1cnJlbnQgZWZmZWN0XG5cdFx0XHRcdHZhciBwcmV2aW91c19hY3RpdmVfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YWN0aXZlX3JlYWN0aW9uID0gY3VycmVudF9lZmZlY3Q7XG5cdFx0XHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhjdXJyZW50X2VmZmVjdCkpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoY3VycmVudF9lZmZlY3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGN1cnJlbnRfZWZmZWN0LCBudWxsLCBjdXJyZW50X2VmZmVjdC5jdHgpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGFjdGl2ZV9yZWFjdGlvbiA9IHByZXZpb3VzX2FjdGl2ZV9yZWFjdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY2hpbGQgPSBjdXJyZW50X2VmZmVjdC5maXJzdDtcblxuXHRcdFx0aWYgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0XHRcdGN1cnJlbnRfZWZmZWN0ID0gY2hpbGQ7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzaWJsaW5nID09PSBudWxsKSB7XG5cdFx0XHRsZXQgcGFyZW50ID0gY3VycmVudF9lZmZlY3QucGFyZW50O1xuXG5cdFx0XHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChlZmZlY3QgPT09IHBhcmVudCkge1xuXHRcdFx0XHRcdGJyZWFrIG1haW5fbG9vcDtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcGFyZW50X3NpYmxpbmcgPSBwYXJlbnQubmV4dDtcblx0XHRcdFx0aWYgKHBhcmVudF9zaWJsaW5nICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VycmVudF9lZmZlY3QgPSBwYXJlbnRfc2libGluZztcblx0XHRcdFx0XHRjb250aW51ZSBtYWluX2xvb3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdXJyZW50X2VmZmVjdCA9IHNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gZWZmZWN0cztcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCB2ZXJzaW9uIG9mIGBmbHVzaFN5bmNgIHdpdGggdGhlIG9wdGlvbiB0byBub3QgZmx1c2ggcHJldmlvdXMgZWZmZWN0cy5cbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9uLCBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBbZm5dXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfc3luYyhmbikge1xuXHR2YXIgcHJldmlvdXNfc2NoZWR1bGVyX21vZGUgPSBzY2hlZHVsZXJfbW9kZTtcblx0dmFyIHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMgPSBxdWV1ZWRfcm9vdF9lZmZlY3RzO1xuXG5cdHRyeSB7XG5cdFx0aW5maW5pdGVfbG9vcF9ndWFyZCgpO1xuXG5cdFx0LyoqIEB0eXBlIHtFZmZlY3RbXX0gKi9cblx0XHRjb25zdCByb290X2VmZmVjdHMgPSBbXTtcblxuXHRcdHNjaGVkdWxlcl9tb2RlID0gRkxVU0hfU1lOQztcblx0XHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gcm9vdF9lZmZlY3RzO1xuXHRcdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cblx0XHRmbHVzaF9xdWV1ZWRfcm9vdF9lZmZlY3RzKHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHMpO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGZuPy4oKTtcblxuXHRcdGZsdXNoX3Rhc2tzKCk7XG5cdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCB8fCByb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Zmx1c2hfc3luYygpO1xuXHRcdH1cblxuXHRcdGZsdXNoX2NvdW50ID0gMDtcblx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdGRldl9lZmZlY3Rfc3RhY2sgPSBbXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9IGZpbmFsbHkge1xuXHRcdHNjaGVkdWxlcl9tb2RlID0gcHJldmlvdXNfc2NoZWR1bGVyX21vZGU7XG5cdFx0cXVldWVkX3Jvb3RfZWZmZWN0cyA9IHByZXZpb3VzX3F1ZXVlZF9yb290X2VmZmVjdHM7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGljaygpIHtcblx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdC8vIEJ5IGNhbGxpbmcgZmx1c2hfc3luYyB3ZSBndWFyYW50ZWUgdGhhdCBhbnkgcGVuZGluZyBzdGF0ZSBjaGFuZ2VzIGFyZSBhcHBsaWVkIGFmdGVyIG9uZSB0aWNrLlxuXHQvLyBUT0RPIGxvb2sgaW50byB3aGV0aGVyIHdlIGNhbiBtYWtlIGZsdXNoaW5nIHN1YnNlcXVlbnQgdXBkYXRlcyBzeW5jaHJvbm91c2x5IGluIHRoZSBmdXR1cmUuXG5cdGZsdXNoX3N5bmMoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPn0gc2lnbmFsXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzaWduYWwpIHtcblx0dmFyIGZsYWdzID0gc2lnbmFsLmY7XG5cdHZhciBpc19kZXJpdmVkID0gKGZsYWdzICYgREVSSVZFRCkgIT09IDA7XG5cblx0aWYgKGNhcHR1cmVkX3NpZ25hbHMgIT09IG51bGwpIHtcblx0XHRjYXB0dXJlZF9zaWduYWxzLmFkZChzaWduYWwpO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGRlcGVuZGVuY3kgb24gdGhlIGN1cnJlbnQgcmVhY3Rpb24gc2lnbmFsLlxuXHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmICF1bnRyYWNraW5nKSB7XG5cdFx0aWYgKGRlcml2ZWRfc291cmNlcyAhPT0gbnVsbCAmJiBkZXJpdmVkX3NvdXJjZXMuaW5jbHVkZXMoc2lnbmFsKSkge1xuXHRcdFx0ZS5zdGF0ZV91bnNhZmVfbG9jYWxfcmVhZCgpO1xuXHRcdH1cblx0XHR2YXIgZGVwcyA9IGFjdGl2ZV9yZWFjdGlvbi5kZXBzO1xuXHRcdGlmIChzaWduYWwucnYgPCByZWFkX3ZlcnNpb24pIHtcblx0XHRcdHNpZ25hbC5ydiA9IHJlYWRfdmVyc2lvbjtcblx0XHRcdC8vIElmIHRoZSBzaWduYWwgaXMgYWNjZXNzaW5nIHRoZSBzYW1lIGRlcGVuZGVuY2llcyBpbiB0aGUgc2FtZVxuXHRcdFx0Ly8gb3JkZXIgYXMgaXQgZGlkIGxhc3QgdGltZSwgaW5jcmVtZW50IGBza2lwcGVkX2RlcHNgXG5cdFx0XHQvLyByYXRoZXIgdGhhbiB1cGRhdGluZyBgbmV3X2RlcHNgLCB3aGljaCBjcmVhdGVzIEdDIGNvc3Rcblx0XHRcdGlmIChuZXdfZGVwcyA9PT0gbnVsbCAmJiBkZXBzICE9PSBudWxsICYmIGRlcHNbc2tpcHBlZF9kZXBzXSA9PT0gc2lnbmFsKSB7XG5cdFx0XHRcdHNraXBwZWRfZGVwcysrO1xuXHRcdFx0fSBlbHNlIGlmIChuZXdfZGVwcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRuZXdfZGVwcyA9IFtzaWduYWxdO1xuXHRcdFx0fSBlbHNlIGlmICghc2tpcF9yZWFjdGlvbiB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoc2lnbmFsKSkge1xuXHRcdFx0XHQvLyBOb3JtYWxseSB3ZSBjYW4gcHVzaCBkdXBsaWNhdGVkIGRlcGVuZGVuY2llcyB0byBgbmV3X2RlcHNgLCBidXQgaWYgd2UncmUgaW5zaWRlXG5cdFx0XHRcdC8vIGFuIHVub3duZWQgZGVyaXZlZCBiZWNhdXNlIHNraXBfcmVhY3Rpb24gaXMgdHJ1ZSwgdGhlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0XG5cdFx0XHRcdC8vIHdlIGRvbid0IGhhdmUgZHVwbGljYXRlc1xuXHRcdFx0XHRuZXdfZGVwcy5wdXNoKHNpZ25hbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKFxuXHRcdGlzX2Rlcml2ZWQgJiZcblx0XHQvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmRlcHMgPT09IG51bGwgJiZcblx0XHQvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpLmVmZmVjdHMgPT09IG51bGxcblx0KSB7XG5cdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXHRcdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblxuXHRcdGlmIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgVU5PV05FRCkgPT09IDApIHtcblx0XHRcdC8vIElmIHRoZSBkZXJpdmVkIGlzIG93bmVkIGJ5IGFub3RoZXIgZGVyaXZlZCB0aGVuIG1hcmsgaXQgYXMgdW5vd25lZFxuXHRcdFx0Ly8gYXMgdGhlIGRlcml2ZWQgdmFsdWUgbWlnaHQgaGF2ZSBiZWVuIHJlZmVyZW5jZWQgaW4gYSBkaWZmZXJlbnQgY29udGV4dFxuXHRcdFx0Ly8gc2luY2UgYW5kIHRodXMgaXRzIHBhcmVudCBtaWdodCBub3QgYmUgaXRzIHRydWUgb3duZXIgYW55bW9yZVxuXHRcdFx0ZGVyaXZlZC5mIF49IFVOT1dORUQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzX2Rlcml2ZWQpIHtcblx0XHRkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKTtcblxuXHRcdGlmIChjaGVja19kaXJ0aW5lc3MoZGVyaXZlZCkpIHtcblx0XHRcdHVwZGF0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChcblx0XHRERVYgJiZcblx0XHR0cmFjaW5nX21vZGVfZmxhZyAmJlxuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMgIT09IG51bGwgJiZcblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiZcblx0XHR0cmFjaW5nX2V4cHJlc3Npb25zLnJlYWN0aW9uID09PSBhY3RpdmVfcmVhY3Rpb25cblx0KSB7XG5cdFx0Ly8gVXNlZCB3aGVuIG1hcHBpbmcgc3RhdGUgYmV0d2VlbiBzcGVjaWFsIGJsb2NrcyBsaWtlIGBlYWNoYFxuXHRcdGlmIChzaWduYWwuZGVidWcpIHtcblx0XHRcdHNpZ25hbC5kZWJ1ZygpO1xuXHRcdH0gZWxzZSBpZiAoc2lnbmFsLmNyZWF0ZWQpIHtcblx0XHRcdHZhciBlbnRyeSA9IHRyYWNpbmdfZXhwcmVzc2lvbnMuZW50cmllcy5nZXQoc2lnbmFsKTtcblxuXHRcdFx0aWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZW50cnkgPSB7IHJlYWQ6IFtdIH07XG5cdFx0XHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMuZW50cmllcy5zZXQoc2lnbmFsLCBlbnRyeSk7XG5cdFx0XHR9XG5cblx0XHRcdGVudHJ5LnJlYWQucHVzaChnZXRfc3RhY2soJ1RyYWNlZEF0JykpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzaWduYWwudjtcbn1cblxuLyoqXG4gKiBMaWtlIGBnZXRgLCBidXQgY2hlY2tzIGZvciBgdW5kZWZpbmVkYC4gVXNlZCBmb3IgYHZhcmAgZGVjbGFyYXRpb25zIGJlY2F1c2UgdGhleSBjYW4gYmUgYWNjZXNzZWQgYmVmb3JlIGJlaW5nIGRlY2xhcmVkXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPiB8IHVuZGVmaW5lZH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7ViB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVfZ2V0KHNpZ25hbCkge1xuXHRyZXR1cm4gc2lnbmFsICYmIGdldChzaWduYWwpO1xufVxuXG4vKipcbiAqIENhcHR1cmUgYW4gYXJyYXkgb2YgYWxsIHRoZSBzaWduYWxzIHRoYXQgYXJlIHJlYWQgd2hlbiBgZm5gIGlzIGNhbGxlZFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVfc2lnbmFscyhmbikge1xuXHR2YXIgcHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscyA9IGNhcHR1cmVkX3NpZ25hbHM7XG5cdGNhcHR1cmVkX3NpZ25hbHMgPSBuZXcgU2V0KCk7XG5cblx0dmFyIGNhcHR1cmVkID0gY2FwdHVyZWRfc2lnbmFscztcblx0dmFyIHNpZ25hbDtcblxuXHR0cnkge1xuXHRcdHVudHJhY2soZm4pO1xuXHRcdGlmIChwcmV2aW91c19jYXB0dXJlZF9zaWduYWxzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKHNpZ25hbCBvZiBjYXB0dXJlZF9zaWduYWxzKSB7XG5cdFx0XHRcdHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMuYWRkKHNpZ25hbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGNhcHR1cmVkX3NpZ25hbHMgPSBwcmV2aW91c19jYXB0dXJlZF9zaWduYWxzO1xuXHR9XG5cblx0cmV0dXJuIGNhcHR1cmVkO1xufVxuXG4vKipcbiAqIEludm9rZXMgYSBmdW5jdGlvbiBhbmQgY2FwdHVyZXMgYWxsIHNpZ25hbHMgdGhhdCBhcmUgcmVhZCBkdXJpbmcgdGhlIGludm9jYXRpb24sXG4gKiB0aGVuIGludmFsaWRhdGVzIHRoZW0uXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVfaW5uZXJfc2lnbmFscyhmbikge1xuXHR2YXIgY2FwdHVyZWQgPSBjYXB0dXJlX3NpZ25hbHMoKCkgPT4gdW50cmFjayhmbikpO1xuXG5cdGZvciAodmFyIHNpZ25hbCBvZiBjYXB0dXJlZCkge1xuXHRcdC8vIEdvIG9uZSBsZXZlbCB1cCBiZWNhdXNlIGRlcml2ZWQgc2lnbmFscyBjcmVhdGVkIGFzIHBhcnQgb2YgcHJvcHMgaW4gbGVnYWN5IG1vZGVcblx0XHRpZiAoKHNpZ25hbC5mICYgTEVHQUNZX0RFUklWRURfUFJPUCkgIT09IDApIHtcblx0XHRcdGZvciAoY29uc3QgZGVwIG9mIC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCkuZGVwcyB8fCBbXSkge1xuXHRcdFx0XHRpZiAoKGRlcC5mICYgREVSSVZFRCkgPT09IDApIHtcblx0XHRcdFx0XHQvLyBVc2UgaW50ZXJuYWxfc2V0IGluc3RlYWQgb2Ygc2V0IGhlcmUgYW5kIGJlbG93IHRvIGF2b2lkIG11dGF0aW9uIHZhbGlkYXRpb25cblx0XHRcdFx0XHRpbnRlcm5hbF9zZXQoZGVwLCBkZXAudik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aW50ZXJuYWxfc2V0KHNpZ25hbCwgc2lnbmFsLnYpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFdoZW4gdXNlZCBpbnNpZGUgYSBbYCRkZXJpdmVkYF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRkZXJpdmVkKSBvciBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCksXG4gKiBhbnkgc3RhdGUgcmVhZCBpbnNpZGUgYGZuYCB3aWxsIG5vdCBiZSB0cmVhdGVkIGFzIGEgZGVwZW5kZW5jeS5cbiAqXG4gKiBgYGB0c1xuICogJGVmZmVjdCgoKSA9PiB7XG4gKiAgIC8vIHRoaXMgd2lsbCBydW4gd2hlbiBgZGF0YWAgY2hhbmdlcywgYnV0IG5vdCB3aGVuIGB0aW1lYCBjaGFuZ2VzXG4gKiAgIHNhdmUoZGF0YSwge1xuICogICAgIHRpbWVzdGFtcDogdW50cmFjaygoKSA9PiB0aW1lKVxuICogICB9KTtcbiAqIH0pO1xuICogYGBgXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnRyYWNrKGZuKSB7XG5cdHZhciBwcmV2aW91c191bnRyYWNraW5nID0gdW50cmFja2luZztcblx0dHJ5IHtcblx0XHR1bnRyYWNraW5nID0gdHJ1ZTtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHR1bnRyYWNraW5nID0gcHJldmlvdXNfdW50cmFja2luZztcblx0fVxufVxuXG5jb25zdCBTVEFUVVNfTUFTSyA9IH4oRElSVFkgfCBNQVlCRV9ESVJUWSB8IENMRUFOKTtcblxuLyoqXG4gKiBAcGFyYW0ge1NpZ25hbH0gc2lnbmFsXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zaWduYWxfc3RhdHVzKHNpZ25hbCwgc3RhdHVzKSB7XG5cdHNpZ25hbC5mID0gKHNpZ25hbC5mICYgU1RBVFVTX01BU0spIHwgc3RhdHVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IG9ialxuICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9mcm9tX29iamVjdChvYmosIGtleXMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKi9cblx0dmFyIHJlc3VsdCA9IHt9O1xuXG5cdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkge1xuXHRcdFx0cmVzdWx0W2tleV0gPSBvYmpba2V5XTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBvc3NpYmx5IHRyYXZlcnNlIGFuIG9iamVjdCBhbmQgcmVhZCBhbGwgaXRzIHByb3BlcnRpZXMgc28gdGhhdCB0aGV5J3JlIGFsbCByZWFjdGl2ZSBpbiBjYXNlIHRoaXMgaXMgYCRzdGF0ZWAuXG4gKiBEb2VzIG9ubHkgY2hlY2sgZmlyc3QgbGV2ZWwgb2YgYW4gb2JqZWN0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zIChoZXVyaXN0aWMgc2hvdWxkIGJlIGdvb2QgZm9yIDk5JSBvZiBhbGwgY2FzZXMpLlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBfcmVhZF9zdGF0ZSh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCAhdmFsdWUgfHwgdmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRkZWVwX3JlYWQodmFsdWUpO1xuXHR9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdGZvciAobGV0IGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0Y29uc3QgcHJvcCA9IHZhbHVlW2tleV07XG5cdFx0XHRpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnICYmIHByb3AgJiYgU1RBVEVfU1lNQk9MIGluIHByb3ApIHtcblx0XHRcdFx0ZGVlcF9yZWFkKHByb3ApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIERlZXBseSB0cmF2ZXJzZSBhbiBvYmplY3QgYW5kIHJlYWQgYWxsIGl0cyBwcm9wZXJ0aWVzXG4gKiBzbyB0aGF0IHRoZXkncmUgYWxsIHJlYWN0aXZlIGluIGNhc2UgdGhpcyBpcyBgJHN0YXRlYFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1NldDxhbnk+fSB2aXNpdGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBfcmVhZCh2YWx1ZSwgdmlzaXRlZCA9IG5ldyBTZXQoKSkge1xuXHRpZiAoXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHZhbHVlICE9PSBudWxsICYmXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZSBET00gZWxlbWVudHNcblx0XHQhKHZhbHVlIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpICYmXG5cdFx0IXZpc2l0ZWQuaGFzKHZhbHVlKVxuXHQpIHtcblx0XHR2aXNpdGVkLmFkZCh2YWx1ZSk7XG5cdFx0Ly8gV2hlbiB3b3JraW5nIHdpdGggYSBwb3NzaWJsZSBTdmVsdGVEYXRlLCB0aGlzXG5cdFx0Ly8gd2lsbCBlbnN1cmUgd2UgY2FwdHVyZSBjaGFuZ2VzIHRvIGl0LlxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHZhbHVlLmdldFRpbWUoKTtcblx0XHR9XG5cdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkZWVwX3JlYWQodmFsdWVba2V5XSwgdmlzaXRlZCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbnN0IHByb3RvID0gZ2V0X3Byb3RvdHlwZV9vZih2YWx1ZSk7XG5cdFx0aWYgKFxuXHRcdFx0cHJvdG8gIT09IE9iamVjdC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBBcnJheS5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBNYXAucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gU2V0LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IERhdGUucHJvdG90eXBlXG5cdFx0KSB7XG5cdFx0XHRjb25zdCBkZXNjcmlwdG9ycyA9IGdldF9kZXNjcmlwdG9ycyhwcm90byk7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gZGVzY3JpcHRvcnMpIHtcblx0XHRcdFx0Y29uc3QgZ2V0ID0gZGVzY3JpcHRvcnNba2V5XS5nZXQ7XG5cdFx0XHRcdGlmIChnZXQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Z2V0LmNhbGwodmFsdWUpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCJjb25zdCByZWdleF9yZXR1cm5fY2hhcmFjdGVycyA9IC9cXHIvZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChzdHIpIHtcblx0c3RyID0gc3RyLnJlcGxhY2UocmVnZXhfcmV0dXJuX2NoYXJhY3RlcnMsICcnKTtcblx0bGV0IGhhc2ggPSA1MzgxO1xuXHRsZXQgaSA9IHN0ci5sZW5ndGg7XG5cblx0d2hpbGUgKGktLSkgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuXG5jb25zdCBWT0lEX0VMRU1FTlRfTkFNRVMgPSBbXG5cdCdhcmVhJyxcblx0J2Jhc2UnLFxuXHQnYnInLFxuXHQnY29sJyxcblx0J2NvbW1hbmQnLFxuXHQnZW1iZWQnLFxuXHQnaHInLFxuXHQnaW1nJyxcblx0J2lucHV0Jyxcblx0J2tleWdlbicsXG5cdCdsaW5rJyxcblx0J21ldGEnLFxuXHQncGFyYW0nLFxuXHQnc291cmNlJyxcblx0J3RyYWNrJyxcblx0J3dicidcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIG9mIGEgdm9pZCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG5cdHJldHVybiBWT0lEX0VMRU1FTlRfTkFNRVMuaW5jbHVkZXMobmFtZSkgfHwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnIWRvY3R5cGUnO1xufVxuXG5jb25zdCBSRVNFUlZFRF9XT1JEUyA9IFtcblx0J2FyZ3VtZW50cycsXG5cdCdhd2FpdCcsXG5cdCdicmVhaycsXG5cdCdjYXNlJyxcblx0J2NhdGNoJyxcblx0J2NsYXNzJyxcblx0J2NvbnN0Jyxcblx0J2NvbnRpbnVlJyxcblx0J2RlYnVnZ2VyJyxcblx0J2RlZmF1bHQnLFxuXHQnZGVsZXRlJyxcblx0J2RvJyxcblx0J2Vsc2UnLFxuXHQnZW51bScsXG5cdCdldmFsJyxcblx0J2V4cG9ydCcsXG5cdCdleHRlbmRzJyxcblx0J2ZhbHNlJyxcblx0J2ZpbmFsbHknLFxuXHQnZm9yJyxcblx0J2Z1bmN0aW9uJyxcblx0J2lmJyxcblx0J2ltcGxlbWVudHMnLFxuXHQnaW1wb3J0Jyxcblx0J2luJyxcblx0J2luc3RhbmNlb2YnLFxuXHQnaW50ZXJmYWNlJyxcblx0J2xldCcsXG5cdCduZXcnLFxuXHQnbnVsbCcsXG5cdCdwYWNrYWdlJyxcblx0J3ByaXZhdGUnLFxuXHQncHJvdGVjdGVkJyxcblx0J3B1YmxpYycsXG5cdCdyZXR1cm4nLFxuXHQnc3RhdGljJyxcblx0J3N1cGVyJyxcblx0J3N3aXRjaCcsXG5cdCd0aGlzJyxcblx0J3Rocm93Jyxcblx0J3RydWUnLFxuXHQndHJ5Jyxcblx0J3R5cGVvZicsXG5cdCd2YXInLFxuXHQndm9pZCcsXG5cdCd3aGlsZScsXG5cdCd3aXRoJyxcblx0J3lpZWxkJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgd29yZGAgaXMgYSByZXNlcnZlZCBKYXZhU2NyaXB0IGtleXdvcmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yZXNlcnZlZCh3b3JkKSB7XG5cdHJldHVybiBSRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyh3b3JkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY2FwdHVyZV9ldmVudChuYW1lKSB7XG5cdHJldHVybiBuYW1lLmVuZHNXaXRoKCdjYXB0dXJlJykgJiYgbmFtZSAhPT0gJ2dvdHBvaW50ZXJjYXB0dXJlJyAmJiBuYW1lICE9PSAnbG9zdHBvaW50ZXJjYXB0dXJlJztcbn1cblxuLyoqIExpc3Qgb2YgRWxlbWVudCBldmVudHMgdGhhdCB3aWxsIGJlIGRlbGVnYXRlZCAqL1xuY29uc3QgREVMRUdBVEVEX0VWRU5UUyA9IFtcblx0J2JlZm9yZWlucHV0Jyxcblx0J2NsaWNrJyxcblx0J2NoYW5nZScsXG5cdCdkYmxjbGljaycsXG5cdCdjb250ZXh0bWVudScsXG5cdCdmb2N1c2luJyxcblx0J2ZvY3Vzb3V0Jyxcblx0J2lucHV0Jyxcblx0J2tleWRvd24nLFxuXHQna2V5dXAnLFxuXHQnbW91c2Vkb3duJyxcblx0J21vdXNlbW92ZScsXG5cdCdtb3VzZW91dCcsXG5cdCdtb3VzZW92ZXInLFxuXHQnbW91c2V1cCcsXG5cdCdwb2ludGVyZG93bicsXG5cdCdwb2ludGVybW92ZScsXG5cdCdwb2ludGVyb3V0Jyxcblx0J3BvaW50ZXJvdmVyJyxcblx0J3BvaW50ZXJ1cCcsXG5cdCd0b3VjaGVuZCcsXG5cdCd0b3VjaG1vdmUnLFxuXHQndG91Y2hzdGFydCdcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYGV2ZW50X25hbWVgIGlzIGEgZGVsZWdhdGVkIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZGVsZWdhdGVkKGV2ZW50X25hbWUpIHtcblx0cmV0dXJuIERFTEVHQVRFRF9FVkVOVFMuaW5jbHVkZXMoZXZlbnRfbmFtZSk7XG59XG5cbi8qKlxuICogQXR0cmlidXRlcyB0aGF0IGFyZSBib29sZWFuLCBpLmUuIHRoZXkgYXJlIHByZXNlbnQgb3Igbm90IHByZXNlbnQuXG4gKi9cbmNvbnN0IERPTV9CT09MRUFOX0FUVFJJQlVURVMgPSBbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5kZXRlcm1pbmF0ZScsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWFtbGVzcycsXG5cdCdzZWxlY3RlZCcsXG5cdCd3ZWJraXRkaXJlY3RvcnknLFxuXHQnZGVmZXInLFxuXHQnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLFxuXHQnZGlzYWJsZXJlbW90ZXBsYXliYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBib29sZWFuIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Jvb2xlYW5fYXR0cmlidXRlKG5hbWUpIHtcblx0cmV0dXJuIERPTV9CT09MRUFOX0FUVFJJQlVURVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbi8qKlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IHNob3VsZCBiZSBhbGlhc2VkIHRvIHRoZWlyIHByb3BlcnR5IG5hbWVzXG4gKiBiZWNhdXNlIHRoZXkgYmVoYXZlIGRpZmZlcmVudGx5IGJldHdlZW4gc2V0dGluZyB0aGVtIGFzIGFuIGF0dHJpYnV0ZSBhbmRcbiAqIHNldHRpbmcgdGhlbSBhcyBhIHByb3BlcnR5LlxuICovXG5jb25zdCBBVFRSSUJVVEVfQUxJQVNFUyA9IHtcblx0Ly8gbm8gYGNsYXNzOiAnY2xhc3NOYW1lJ2AgYmVjYXVzZSB3ZSBoYW5kbGUgdGhhdCBzZXBhcmF0ZWx5XG5cdGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuXHRpc21hcDogJ2lzTWFwJyxcblx0bm9tb2R1bGU6ICdub01vZHVsZScsXG5cdHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuXHRyZWFkb25seTogJ3JlYWRPbmx5Jyxcblx0ZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcblx0ZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG5cdHNyY29iamVjdDogJ3NyY09iamVjdCcsXG5cdG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcblx0YWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsc2NyZWVuJyxcblx0ZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG5cdGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaydcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZV9hdHRyaWJ1dGUobmFtZSkge1xuXHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRyZXR1cm4gQVRUUklCVVRFX0FMSUFTRVNbbmFtZV0gPz8gbmFtZTtcbn1cblxuY29uc3QgRE9NX1BST1BFUlRJRVMgPSBbXG5cdC4uLkRPTV9CT09MRUFOX0FUVFJJQlVURVMsXG5cdCdmb3JtTm9WYWxpZGF0ZScsXG5cdCdpc01hcCcsXG5cdCdub01vZHVsZScsXG5cdCdwbGF5c0lubGluZScsXG5cdCdyZWFkT25seScsXG5cdCd2YWx1ZScsXG5cdCd2b2x1bWUnLFxuXHQnZGVmYXVsdFZhbHVlJyxcblx0J2RlZmF1bHRDaGVja2VkJyxcblx0J3NyY09iamVjdCcsXG5cdCdub1ZhbGlkYXRlJyxcblx0J2FsbG93RnVsbHNjcmVlbicsXG5cdCdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG5cdCdkaXNhYmxlUmVtb3RlUGxheWJhY2snXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kb21fcHJvcGVydHkobmFtZSkge1xuXHRyZXR1cm4gRE9NX1BST1BFUlRJRVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE5PTl9TVEFUSUNfUFJPUEVSVElFUyA9IFsnYXV0b2ZvY3VzJywgJ211dGVkJywgJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCddO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgY2Fubm90IGJlIHNldCB0aHJvdWdoIHRoZSB0ZW1wbGF0ZVxuICogc3RyaW5nLCBpLmUuIG5lZWRzIHNvbWUga2luZCBvZiBKYXZhU2NyaXB0IGhhbmRsaW5nIHRvIHdvcmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90X2JlX3NldF9zdGF0aWNhbGx5KG5hbWUpIHtcblx0cmV0dXJuIE5PTl9TVEFUSUNfUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBTdWJzZXQgb2YgZGVsZWdhdGVkIGV2ZW50cyB3aGljaCBzaG91bGQgYmUgcGFzc2l2ZSBieSBkZWZhdWx0LlxuICogVGhlc2UgdHdvIGFyZSBhbHJlYWR5IHBhc3NpdmUgdmlhIGJyb3dzZXIgZGVmYXVsdHMgb24gd2luZG93LCBkb2N1bWVudCBhbmQgYm9keS5cbiAqIEJ1dCBzaW5jZVxuICogLSB3ZSdyZSBkZWxlZ2F0aW5nIHRoZW1cbiAqIC0gdGhleSBoYXBwZW4gb2Z0ZW5cbiAqIC0gdGhleSBhcHBseSB0byBtb2JpbGUgd2hpY2ggaXMgZ2VuZXJhbGx5IGxlc3MgcGVyZm9ybWFudFxuICogd2UncmUgbWFya2luZyB0aGVtIGFzIHBhc3NpdmUgYnkgZGVmYXVsdCBmb3Igb3RoZXIgZWxlbWVudHMsIHRvby5cbiAqL1xuY29uc3QgUEFTU0lWRV9FVkVOVFMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIGEgcGFzc2l2ZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Bhc3NpdmVfZXZlbnQobmFtZSkge1xuXHRyZXR1cm4gUEFTU0lWRV9FVkVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IENPTlRFTlRfRURJVEFCTEVfQklORElOR1MgPSBbJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCcsICdpbm5lclRleHQnXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY29udGVudF9lZGl0YWJsZV9iaW5kaW5nKG5hbWUpIHtcblx0cmV0dXJuIENPTlRFTlRfRURJVEFCTEVfQklORElOR1MuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IExPQURfRVJST1JfRUxFTUVOVFMgPSBbXG5cdCdib2R5Jyxcblx0J2VtYmVkJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnbGluaycsXG5cdCdvYmplY3QnLFxuXHQnc2NyaXB0Jyxcblx0J3N0eWxlJyxcblx0J3RyYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBlbWl0cyBgbG9hZGAgYW5kIGBlcnJvcmAgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfbG9hZF9lcnJvcl9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIExPQURfRVJST1JfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFNWR19FTEVNRU5UUyA9IFtcblx0J2FsdEdseXBoJyxcblx0J2FsdEdseXBoRGVmJyxcblx0J2FsdEdseXBoSXRlbScsXG5cdCdhbmltYXRlJyxcblx0J2FuaW1hdGVDb2xvcicsXG5cdCdhbmltYXRlTW90aW9uJyxcblx0J2FuaW1hdGVUcmFuc2Zvcm0nLFxuXHQnY2lyY2xlJyxcblx0J2NsaXBQYXRoJyxcblx0J2NvbG9yLXByb2ZpbGUnLFxuXHQnY3Vyc29yJyxcblx0J2RlZnMnLFxuXHQnZGVzYycsXG5cdCdkaXNjYXJkJyxcblx0J2VsbGlwc2UnLFxuXHQnZmVCbGVuZCcsXG5cdCdmZUNvbG9yTWF0cml4Jyxcblx0J2ZlQ29tcG9uZW50VHJhbnNmZXInLFxuXHQnZmVDb21wb3NpdGUnLFxuXHQnZmVDb252b2x2ZU1hdHJpeCcsXG5cdCdmZURpZmZ1c2VMaWdodGluZycsXG5cdCdmZURpc3BsYWNlbWVudE1hcCcsXG5cdCdmZURpc3RhbnRMaWdodCcsXG5cdCdmZURyb3BTaGFkb3cnLFxuXHQnZmVGbG9vZCcsXG5cdCdmZUZ1bmNBJyxcblx0J2ZlRnVuY0InLFxuXHQnZmVGdW5jRycsXG5cdCdmZUZ1bmNSJyxcblx0J2ZlR2F1c3NpYW5CbHVyJyxcblx0J2ZlSW1hZ2UnLFxuXHQnZmVNZXJnZScsXG5cdCdmZU1lcmdlTm9kZScsXG5cdCdmZU1vcnBob2xvZ3knLFxuXHQnZmVPZmZzZXQnLFxuXHQnZmVQb2ludExpZ2h0Jyxcblx0J2ZlU3BlY3VsYXJMaWdodGluZycsXG5cdCdmZVNwb3RMaWdodCcsXG5cdCdmZVRpbGUnLFxuXHQnZmVUdXJidWxlbmNlJyxcblx0J2ZpbHRlcicsXG5cdCdmb250Jyxcblx0J2ZvbnQtZmFjZScsXG5cdCdmb250LWZhY2UtZm9ybWF0Jyxcblx0J2ZvbnQtZmFjZS1uYW1lJyxcblx0J2ZvbnQtZmFjZS1zcmMnLFxuXHQnZm9udC1mYWNlLXVyaScsXG5cdCdmb3JlaWduT2JqZWN0Jyxcblx0J2cnLFxuXHQnZ2x5cGgnLFxuXHQnZ2x5cGhSZWYnLFxuXHQnaGF0Y2gnLFxuXHQnaGF0Y2hwYXRoJyxcblx0J2hrZXJuJyxcblx0J2ltYWdlJyxcblx0J2xpbmUnLFxuXHQnbGluZWFyR3JhZGllbnQnLFxuXHQnbWFya2VyJyxcblx0J21hc2snLFxuXHQnbWVzaCcsXG5cdCdtZXNoZ3JhZGllbnQnLFxuXHQnbWVzaHBhdGNoJyxcblx0J21lc2hyb3cnLFxuXHQnbWV0YWRhdGEnLFxuXHQnbWlzc2luZy1nbHlwaCcsXG5cdCdtcGF0aCcsXG5cdCdwYXRoJyxcblx0J3BhdHRlcm4nLFxuXHQncG9seWdvbicsXG5cdCdwb2x5bGluZScsXG5cdCdyYWRpYWxHcmFkaWVudCcsXG5cdCdyZWN0Jyxcblx0J3NldCcsXG5cdCdzb2xpZGNvbG9yJyxcblx0J3N0b3AnLFxuXHQnc3ZnJyxcblx0J3N3aXRjaCcsXG5cdCdzeW1ib2wnLFxuXHQndGV4dCcsXG5cdCd0ZXh0UGF0aCcsXG5cdCd0cmVmJyxcblx0J3RzcGFuJyxcblx0J3Vua25vd24nLFxuXHQndXNlJyxcblx0J3ZpZXcnLFxuXHQndmtlcm4nXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19zdmcobmFtZSkge1xuXHRyZXR1cm4gU1ZHX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBNQVRITUxfRUxFTUVOVFMgPSBbXG5cdCdhbm5vdGF0aW9uJyxcblx0J2Fubm90YXRpb24teG1sJyxcblx0J21hY3Rpb24nLFxuXHQnbWF0aCcsXG5cdCdtZXJyb3InLFxuXHQnbWZyYWMnLFxuXHQnbWknLFxuXHQnbW11bHRpc2NyaXB0cycsXG5cdCdtbicsXG5cdCdtbycsXG5cdCdtb3ZlcicsXG5cdCdtcGFkZGVkJyxcblx0J21waGFudG9tJyxcblx0J21wcmVzY3JpcHRzJyxcblx0J21yb290Jyxcblx0J21yb3cnLFxuXHQnbXMnLFxuXHQnbXNwYWNlJyxcblx0J21zcXJ0Jyxcblx0J21zdHlsZScsXG5cdCdtc3ViJyxcblx0J21zdWJzdXAnLFxuXHQnbXN1cCcsXG5cdCdtdGFibGUnLFxuXHQnbXRkJyxcblx0J210ZXh0Jyxcblx0J210cicsXG5cdCdtdW5kZXInLFxuXHQnbXVuZGVyb3ZlcicsXG5cdCdzZW1hbnRpY3MnXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19tYXRobWwobmFtZSkge1xuXHRyZXR1cm4gTUFUSE1MX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBSVU5FUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCckc3RhdGUnLFxuXHQnJHN0YXRlLnJhdycsXG5cdCckc3RhdGUuc25hcHNob3QnLFxuXHQnJHByb3BzJyxcblx0JyRwcm9wcy5pZCcsXG5cdCckYmluZGFibGUnLFxuXHQnJGRlcml2ZWQnLFxuXHQnJGRlcml2ZWQuYnknLFxuXHQnJGVmZmVjdCcsXG5cdCckZWZmZWN0LnByZScsXG5cdCckZWZmZWN0LnRyYWNraW5nJyxcblx0JyRlZmZlY3Qucm9vdCcsXG5cdCckaW5zcGVjdCcsXG5cdCckaW5zcGVjdCgpLndpdGgnLFxuXHQnJGluc3BlY3QudHJhY2UnLFxuXHQnJGhvc3QnXG5dKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgUlVORVNbbnVtYmVyXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3J1bmUobmFtZSkge1xuXHRyZXR1cm4gUlVORVMuaW5jbHVkZXMoLyoqIEB0eXBlIHtSVU5FU1tudW1iZXJdfSAqLyAobmFtZSkpO1xufVxuXG4vKiogTGlzdCBvZiBlbGVtZW50cyB0aGF0IHJlcXVpcmUgcmF3IGNvbnRlbnRzIGFuZCBzaG91bGQgbm90IGhhdmUgU1NSIGNvbW1lbnRzIHB1dCBpbiB0aGVtICovXG5jb25zdCBSQVdfVEVYVF9FTEVNRU5UUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ3RleHRhcmVhJywgJ3NjcmlwdCcsICdzdHlsZScsICd0aXRsZSddKTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcmF3X3RleHRfZWxlbWVudChuYW1lKSB7XG5cdHJldHVybiBSQVdfVEVYVF9FTEVNRU5UUy5pbmNsdWRlcygvKiogQHR5cGUge1JBV19URVhUX0VMRU1FTlRTW251bWJlcl19ICovIChuYW1lKSk7XG59XG5cbi8qKlxuICogUHJldmVudCBkZXZ0b29scyB0cnlpbmcgdG8gbWFrZSBgbG9jYXRpb25gIGEgY2xpY2thYmxlIGxpbmsgYnkgaW5zZXJ0aW5nIGEgemVyby13aWR0aCBzcGFjZVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZV9sb2NhdGlvbihsb2NhdGlvbikge1xuXHRyZXR1cm4gbG9jYXRpb24/LnJlcGxhY2UoL1xcLy9nLCAnL1xcdTIwMGInKTtcbn1cbiIsImltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjbGVhcl90ZXh0X2NvbnRlbnQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvZm9jdXMoZG9tLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUpIHtcblx0XHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0XHRkb20uYXV0b2ZvY3VzID0gdHJ1ZTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGJvZHkpIHtcblx0XHRcdFx0ZG9tLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY2hpbGQgb2YgYSB0ZXh0YXJlYSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV90ZXh0YXJlYV9jaGlsZChkb20pIHtcblx0aWYgKGh5ZHJhdGluZyAmJiBnZXRfZmlyc3RfY2hpbGQoZG9tKSAhPT0gbnVsbCkge1xuXHRcdGNsZWFyX3RleHRfY29udGVudChkb20pO1xuXHR9XG59XG5cbmxldCBsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKSB7XG5cdGlmICghbGlzdGVuaW5nX3RvX2Zvcm1fcmVzZXQpIHtcblx0XHRsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IHRydWU7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdyZXNldCcsXG5cdFx0XHQoZXZ0KSA9PiB7XG5cdFx0XHRcdC8vIE5lZWRzIHRvIGhhcHBlbiBvbmUgdGljayBsYXRlciBvciBlbHNlIHRoZSBkb20gcHJvcGVydGllcyBvZiB0aGUgZm9ybVxuXHRcdFx0XHQvLyBlbGVtZW50cyBoYXZlIG5vdCB1cGRhdGVkIHRvIHRoZWlyIHJlc2V0IHZhbHVlcyB5ZXRcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBlIG9mIC8qKkB0eXBlIHtIVE1MRm9ybUVsZW1lbnR9ICovIChldnQudGFyZ2V0KS5lbGVtZW50cykge1xuXHRcdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRcdGUuX19vbl9yPy4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8vIEluIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGd1YXJhbnRlZSB3ZSBnZXQgbm90aWNlZCBvZiBpdCAobm8gcG9zc2libGl0eSBvZiBzdG9wUHJvcGFnYXRpb24pXG5cdFx0XHR7IGNhcHR1cmU6IHRydWUgfVxuXHRcdCk7XG5cdH1cbn1cbiIsImltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBhZGRfZm9ybV9yZXNldF9saXN0ZW5lciB9IGZyb20gJy4uL21pc2MuanMnO1xuXG4vKipcbiAqIEZpcmVzIHRoZSBoYW5kbGVyIG9uY2UgaW1tZWRpYXRlbHkgKHVubGVzcyBjb3JyZXNwb25kaW5nIGFyZyBpcyBzZXQgdG8gYGZhbHNlYCksXG4gKiB0aGVuIGxpc3RlbnMgdG8gdGhlIGdpdmVuIGV2ZW50cyB1bnRpbCB0aGUgcmVuZGVyIGVmZmVjdCBjb250ZXh0IGlzIGRlc3Ryb3llZFxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHBhcmFtIHsoZXZlbnQ/OiBFdmVudCkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHthbnl9IGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRzLCBoYW5kbGVyLCBjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHkgPSB0cnVlKSB7XG5cdGlmIChjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHkpIHtcblx0XHRoYW5kbGVyKCk7XG5cdH1cblxuXHRmb3IgKHZhciBuYW1lIG9mIGV2ZW50cykge1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHR9XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoZm4pIHtcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGZuKCk7XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gZXZlbnQsIGFuZCB0aGVuIGluc3RhbnRpYXRlIGEgZ2xvYmFsIGZvcm0gcmVzZXQgbGlzdGVuZXIgaWYgbm90IGFscmVhZHkgZG9uZSxcbiAqIHRvIG5vdGlmeSBhbGwgYmluZGluZ3Mgd2hlbiB0aGUgZm9ybSBpcyByZXNldFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0geyhpc19yZXNldD86IHRydWUpID0+IHZvaWR9IGhhbmRsZXJcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gW29uX3Jlc2V0XVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb25fcmVzZXQgPSBoYW5kbGVyKSB7XG5cdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKCkgPT4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KGhhbmRsZXIpKTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBwcmV2ID0gZWxlbWVudC5fX29uX3I7XG5cdGlmIChwcmV2KSB7XG5cdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBjaGVja2JveCB0aGF0IGNhbiBoYXZlIG11bHRpcGxlIGJpbmRzIChncm91cCAmIGNoZWNrZWQpXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnQuX19vbl9yID0gKCkgPT4ge1xuXHRcdFx0cHJldigpO1xuXHRcdFx0b25fcmVzZXQodHJ1ZSk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiBvbl9yZXNldCh0cnVlKTtcblx0fVxuXG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG4iLCIvKiogQGltcG9ydCB7IExvY2F0aW9uIH0gZnJvbSAnbG9jYXRlLWNoYXJhY3RlcicgKi9cbmltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuLyoqIEB0eXBlIHtTZXQ8c3RyaW5nPn0gKi9cbmV4cG9ydCBjb25zdCBhbGxfcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBAdHlwZSB7U2V0PChldmVudHM6IEFycmF5PHN0cmluZz4pID0+IHZvaWQ+fSAqL1xuZXhwb3J0IGNvbnN0IHJvb3RfZXZlbnRfaGFuZGxlcyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBTU1IgYWRkcyBvbmxvYWQgYW5kIG9uZXJyb3IgYXR0cmlidXRlcyB0byBjYXRjaCB0aG9zZSBldmVudHMgYmVmb3JlIHRoZSBoeWRyYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgdGhvc2UgY2FzZXMsIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZXMgYW5kIHJlcGxheXMgdGhlIGV2ZW50cy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGF5X2V2ZW50cyhkb20pIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHRpZiAoZG9tLm9ubG9hZCkge1xuXHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ29ubG9hZCcpO1xuXHR9XG5cdGlmIChkb20ub25lcnJvcikge1xuXHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ29uZXJyb3InKTtcblx0fVxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGV2ZW50ID0gZG9tLl9fZTtcblx0aWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZG9tLl9fZSA9IHVuZGVmaW5lZDtcblx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoZG9tLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHRcdGRvbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBkb21cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gW2hhbmRsZXJdXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuXHQvKipcblx0ICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuXHQgKi9cblx0ZnVuY3Rpb24gdGFyZ2V0X2hhbmRsZXIoLyoqIEB0eXBlIHtFdmVudH0gKi8gZXZlbnQpIHtcblx0XHRpZiAoIW9wdGlvbnMuY2FwdHVyZSkge1xuXHRcdFx0Ly8gT25seSBjYWxsIGluIHRoZSBidWJibGUgcGhhc2UsIGVsc2UgZGVsZWdhdGVkIGV2ZW50cyB3b3VsZCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBjYXB0dXJpbmcgZXZlbnRzXG5cdFx0XHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24uY2FsbChkb20sIGV2ZW50KTtcblx0XHR9XG5cdFx0aWYgKCFldmVudC5jYW5jZWxCdWJibGUpIHtcblx0XHRcdHJldHVybiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlcj8uY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaHJvbWUgaGFzIGEgYnVnIHdoZXJlIHBvaW50ZXIgZXZlbnRzIGRvbid0IHdvcmsgd2hlbiBhdHRhY2hlZCB0byBhIERPTSBlbGVtZW50IHRoYXQgaGFzIGJlZW4gY2xvbmVkXG5cdC8vIHdpdGggY2xvbmVOb2RlKCkgYW5kIHRoZSBET00gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFRvIGVuc3VyZSB0aGUgZXZlbnQgd29ya3MsIHdlXG5cdC8vIGRlZmVyIHRoZSBhdHRhY2htZW50IHRpbGwgYWZ0ZXIgaXQncyBiZWVuIGFwcGVuZGVkIHRvIHRoZSBkb2N1bWVudC4gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgZml4ZXNcblx0Ly8gdGhpcyBidWcuIFRoZSBzYW1lIGFwcGxpZXMgdG8gd2hlZWwgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG5cdGlmIChcblx0XHRldmVudF9uYW1lLnN0YXJ0c1dpdGgoJ3BvaW50ZXInKSB8fFxuXHRcdGV2ZW50X25hbWUuc3RhcnRzV2l0aCgndG91Y2gnKSB8fFxuXHRcdGV2ZW50X25hbWUgPT09ICd3aGVlbCdcblx0KSB7XG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldF9oYW5kbGVyO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgaGFuZGxlci4gVXNpbmcgdGhpc1xuICogcmF0aGVyIHRoYW4gYGFkZEV2ZW50TGlzdGVuZXJgIHdpbGwgcHJlc2VydmUgdGhlIGNvcnJlY3Qgb3JkZXIgcmVsYXRpdmUgdG8gaGFuZGxlcnMgYWRkZWQgZGVjbGFyYXRpdmVseVxuICogKHdpdGggYXR0cmlidXRlcyBsaWtlIGBvbmNsaWNrYCksIHdoaWNoIHVzZSBldmVudCBkZWxlZ2F0aW9uIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICogQHBhcmFtIHtBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcblx0dmFyIHRhcmdldF9oYW5kbGVyID0gY3JlYXRlX2V2ZW50KHR5cGUsIGVsZW1lbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gW2hhbmRsZXJdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjYXB0dXJlXVxuICogQHBhcmFtIHtib29sZWFufSBbcGFzc2l2ZV1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBjYXB0dXJlLCBwYXNzaXZlKSB7XG5cdHZhciBvcHRpb25zID0geyBjYXB0dXJlLCBwYXNzaXZlIH07XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIG9wdGlvbnMpO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0aWYgKGRvbSA9PT0gZG9jdW1lbnQuYm9keSB8fCBkb20gPT09IHdpbmRvdyB8fCBkb20gPT09IGRvY3VtZW50KSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZWdhdGUoZXZlbnRzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudHNbaV0pO1xuXHR9XG5cblx0Zm9yICh2YXIgZm4gb2Ygcm9vdF9ldmVudF9oYW5kbGVzKSB7XG5cdFx0Zm4oZXZlbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbihldmVudCkge1xuXHR2YXIgaGFuZGxlcl9lbGVtZW50ID0gdGhpcztcblx0dmFyIG93bmVyX2RvY3VtZW50ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoaGFuZGxlcl9lbGVtZW50KS5vd25lckRvY3VtZW50O1xuXHR2YXIgZXZlbnRfbmFtZSA9IGV2ZW50LnR5cGU7XG5cdHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoPy4oKSB8fCBbXTtcblx0dmFyIGN1cnJlbnRfdGFyZ2V0ID0gLyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi8gKHBhdGhbMF0gfHwgZXZlbnQudGFyZ2V0KTtcblxuXHQvLyBjb21wb3NlZFBhdGggY29udGFpbnMgbGlzdCBvZiBub2RlcyB0aGUgZXZlbnQgaGFzIHByb3BhZ2F0ZWQgdGhyb3VnaC5cblx0Ly8gV2UgY2hlY2sgX19yb290IHRvIHNraXAgYWxsIG5vZGVzIGJlbG93IGl0IGluIGNhc2UgdGhpcyBpcyBhXG5cdC8vIHBhcmVudCBvZiB0aGUgX19yb290IG5vZGUsIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZXJlJ3MgbmVzdGVkXG5cdC8vIG1vdW50ZWQgYXBwcy4gSW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudHMgbXVsdGlwbGUgdGltZXMuXG5cdHZhciBwYXRoX2lkeCA9IDA7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyBhZGRlZCBiZWxvd1xuXHR2YXIgaGFuZGxlZF9hdCA9IGV2ZW50Ll9fcm9vdDtcblxuXHRpZiAoaGFuZGxlZF9hdCkge1xuXHRcdHZhciBhdF9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlZF9hdCk7XG5cdFx0aWYgKFxuXHRcdFx0YXRfaWR4ICE9PSAtMSAmJlxuXHRcdFx0KGhhbmRsZXJfZWxlbWVudCA9PT0gZG9jdW1lbnQgfHwgaGFuZGxlcl9lbGVtZW50ID09PSAvKiogQHR5cGUge2FueX0gKi8gKHdpbmRvdykpXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBvciBhIHdpbmRvdyBsaXN0ZW5lciwgYnV0IHRoZSBldmVudCB3YXMgYWxyZWFkeSBoYW5kbGVkXG5cdFx0XHQvLyAtPiBpZ25vcmUsIGJ1dCBzZXQgaGFuZGxlX2F0IHRvIGRvY3VtZW50L3dpbmRvdyBzbyB0aGF0IHdlJ3JlIHJlc2V0dGluZyB0aGUgZXZlbnRcblx0XHRcdC8vIGNoYWluIGluIGNhc2Ugc29tZW9uZSBtYW51YWxseSBkaXNwYXRjaGVzIHRoZSBzYW1lIGV2ZW50IG9iamVjdCBhZ2Fpbi5cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHNraXBwaW5nIGlmIHRoZSBpbmRleCBpcyBoaWdoZXIsIGJlY2F1c2Vcblx0XHQvLyBzb21lb25lIGNvdWxkIGNyZWF0ZSBhbiBldmVudCBwcm9ncmFtbWF0aWNhbGx5IGFuZCBlbWl0IGl0IG11bHRpcGxlIHRpbWVzLFxuXHRcdC8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgdGhlIHdob2xlIHByb3BhZ2F0aW9uIGNoYWluIHByb3Blcmx5IGVhY2ggdGltZS5cblx0XHQvLyAodGhpcyB3aWxsIG9ubHkgYmUgYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtdWx0aXBsZSB0aW1lcyBhbmRcblx0XHQvLyB0aGUgZmFsbGJhY2sgZG9jdW1lbnQgbGlzdGVuZXIgaXNuJ3QgcmVhY2hlZCBpbiBiZXR3ZWVuLCBidXQgdGhhdCdzIHN1cGVyIHJhcmUpXG5cdFx0dmFyIGhhbmRsZXJfaWR4ID0gcGF0aC5pbmRleE9mKGhhbmRsZXJfZWxlbWVudCk7XG5cdFx0aWYgKGhhbmRsZXJfaWR4ID09PSAtMSkge1xuXHRcdFx0Ly8gaGFuZGxlX2lkeCBjYW4gdGhlb3JldGljYWxseSBiZSAtMSAoaGFwcGVuZWQgaW4gc29tZSBKU0RPTSB0ZXN0aW5nIHNjZW5hcmlvcyB3aXRoIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgb2JqZWN0KVxuXHRcdFx0Ly8gc28gZ3VhcmQgYWdhaW5zdCB0aGF0LCB0b28sIGFuZCBhc3N1bWUgdGhhdCBldmVyeXRoaW5nIHdhcyBoYW5kbGVkIGF0IHRoaXMgcG9pbnQuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGF0X2lkeCA8PSBoYW5kbGVyX2lkeCkge1xuXHRcdFx0cGF0aF9pZHggPSBhdF9pZHg7XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChwYXRoW3BhdGhfaWR4XSB8fCBldmVudC50YXJnZXQpO1xuXHQvLyB0aGVyZSBjYW4gb25seSBiZSBvbmUgZGVsZWdhdGVkIGV2ZW50IHBlciBlbGVtZW50LCBhbmQgd2UgZWl0aGVyIGFscmVhZHkgaGFuZGxlZCB0aGUgY3VycmVudCB0YXJnZXQsXG5cdC8vIG9yIHRoaXMgaXMgdGhlIHZlcnkgZmlyc3QgdGFyZ2V0IGluIHRoZSBjaGFpbiB3aGljaCBoYXMgYSBub24tZGVsZWdhdGVkIGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGl0J3Mgc2FmZVxuXHQvLyB0byBoYW5kbGUgYSBwb3NzaWJsZSBkZWxlZ2F0ZWQgZXZlbnQgb24gaXQgbGF0ZXIgKHRocm91Z2ggdGhlIHJvb3QgZGVsZWdhdGlvbiBsaXN0ZW5lciBmb3IgZXhhbXBsZSkuXG5cdGlmIChjdXJyZW50X3RhcmdldCA9PT0gaGFuZGxlcl9lbGVtZW50KSByZXR1cm47XG5cblx0Ly8gUHJveHkgY3VycmVudFRhcmdldCB0byBjb3JyZWN0IHRhcmdldFxuXHRkZWZpbmVfcHJvcGVydHkoZXZlbnQsICdjdXJyZW50VGFyZ2V0Jywge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gY3VycmVudF90YXJnZXQgfHwgb3duZXJfZG9jdW1lbnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBUaGlzIHN0YXJ0ZWQgYmVjYXVzZSBvZiBDaHJvbWl1bSBpc3N1ZSBodHRwczovL2Nocm9tZXN0YXR1cy5jb20vZmVhdHVyZS81MTI4Njk2ODIzNTQ1ODU2LFxuXHQvLyB3aGVyZSByZW1vdmFsIG9yIG1vdmluZyBvZiBvZiB0aGUgRE9NIGNhbiBjYXVzZSBzeW5jIGBibHVyYCBldmVudHMgdG8gZmlyZSwgd2hpY2ggY2FuIGNhdXNlIGxvZ2ljXG5cdC8vIHRvIHJ1biBpbnNpZGUgdGhlIGN1cnJlbnQgYGFjdGl2ZV9yZWFjdGlvbmAsIHdoaWNoIGlzbid0IHdoYXQgd2Ugd2FudCBhdCBhbGwuIEhvd2V2ZXIsIG9uIHJlZmxlY3Rpb24sXG5cdC8vIGl0J3MgcHJvYmFibHkgYmVzdCB0aGF0IGFsbCBldmVudCBoYW5kbGVkIGJ5IFN2ZWx0ZSBoYXZlIHRoaXMgYmVoYXZpb3VyLCBhcyB3ZSBkb24ndCByZWFsbHkgd2FudFxuXHQvLyBhbiBldmVudCBoYW5kbGVyIHRvIHJ1biBpbiB0aGUgY29udGV4dCBvZiBhbm90aGVyIHJlYWN0aW9uIG9yIGVmZmVjdC5cblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cblx0dHJ5IHtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bn1cblx0XHQgKi9cblx0XHR2YXIgdGhyb3dfZXJyb3I7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3Vua25vd25bXX1cblx0XHQgKi9cblx0XHR2YXIgb3RoZXJfZXJyb3JzID0gW107XG5cblx0XHR3aGlsZSAoY3VycmVudF90YXJnZXQgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdFx0XHR2YXIgcGFyZW50X2VsZW1lbnQgPVxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5hc3NpZ25lZFNsb3QgfHxcblx0XHRcdFx0Y3VycmVudF90YXJnZXQucGFyZW50Tm9kZSB8fFxuXHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5ob3N0IHx8XG5cdFx0XHRcdG51bGw7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0dmFyIGRlbGVnYXRlZCA9IGN1cnJlbnRfdGFyZ2V0WydfXycgKyBldmVudF9uYW1lXTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZGVsZWdhdGVkICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHQoISgvKiogQHR5cGUge2FueX0gKi8gKGN1cnJlbnRfdGFyZ2V0KS5kaXNhYmxlZCkgfHxcblx0XHRcdFx0XHRcdC8vIERPTSBjb3VsZCd2ZSBiZWVuIHVwZGF0ZWQgYWxyZWFkeSBieSB0aGUgdGltZSB0aGlzIGlzIHJlYWNoZWQsIHNvIHdlIGNoZWNrIHRoaXMgYXMgd2VsbFxuXHRcdFx0XHRcdFx0Ly8gLT4gdGhlIHRhcmdldCBjb3VsZCBub3QgaGF2ZSBiZWVuIGRpc2FibGVkIGJlY2F1c2UgaXQgZW1pdHMgdGhlIGV2ZW50IGluIHRoZSBmaXJzdCBwbGFjZVxuXHRcdFx0XHRcdFx0ZXZlbnQudGFyZ2V0ID09PSBjdXJyZW50X3RhcmdldClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aWYgKGlzX2FycmF5KGRlbGVnYXRlZCkpIHtcblx0XHRcdFx0XHRcdHZhciBbZm4sIC4uLmRhdGFdID0gZGVsZWdhdGVkO1xuXHRcdFx0XHRcdFx0Zm4uYXBwbHkoY3VycmVudF90YXJnZXQsIFtldmVudCwgLi4uZGF0YV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkZWxlZ2F0ZWQuY2FsbChjdXJyZW50X3RhcmdldCwgZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKHRocm93X2Vycm9yKSB7XG5cdFx0XHRcdFx0b3RoZXJfZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93X2Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChldmVudC5jYW5jZWxCdWJibGUgfHwgcGFyZW50X2VsZW1lbnQgPT09IGhhbmRsZXJfZWxlbWVudCB8fCBwYXJlbnRfZWxlbWVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGN1cnJlbnRfdGFyZ2V0ID0gcGFyZW50X2VsZW1lbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRocm93X2Vycm9yKSB7XG5cdFx0XHRmb3IgKGxldCBlcnJvciBvZiBvdGhlcl9lcnJvcnMpIHtcblx0XHRcdFx0Ly8gVGhyb3cgdGhlIHJlc3Qgb2YgdGhlIGVycm9ycywgb25lLWJ5LW9uZSBvbiBhIG1pY3JvdGFza1xuXHRcdFx0XHRxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgdGhyb3dfZXJyb3I7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgaXMgdXNlZCBhYm92ZVxuXHRcdGV2ZW50Ll9fcm9vdCA9IGhhbmRsZXJfZWxlbWVudDtcblx0XHQvLyBAdHMtaWdub3JlIHJlbW92ZSBwcm94eSBvbiBjdXJyZW50VGFyZ2V0XG5cdFx0ZGVsZXRlIGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0fVxufVxuXG4vKipcbiAqIEluIGRldiwgd2FybiBpZiBhbiBldmVudCBoYW5kbGVyIGlzIG5vdCBhIGZ1bmN0aW9uLCBhcyBpdCBtZWFucyB0aGVcbiAqIHVzZXIgcHJvYmFibHkgY2FsbGVkIHRoZSBoYW5kbGVyIG9yIGZvcmdvdCB0byBhZGQgYSBgKCkgPT5gXG4gKiBAcGFyYW0geygpID0+IChldmVudDogRXZlbnQsIC4uLmFyZ3M6IGFueSkgPT4gdm9pZH0gdGh1bmtcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7W0V2ZW50LCAuLi5hbnldfSBhcmdzXG4gKiBAcGFyYW0ge2FueX0gY29tcG9uZW50XG4gKiBAcGFyYW0ge1tudW1iZXIsIG51bWJlcl19IFtsb2NdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfcGFyZW5zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkoXG5cdHRodW5rLFxuXHRlbGVtZW50LFxuXHRhcmdzLFxuXHRjb21wb25lbnQsXG5cdGxvYyxcblx0aGFzX3NpZGVfZWZmZWN0cyA9IGZhbHNlLFxuXHRyZW1vdmVfcGFyZW5zID0gZmFsc2Vcbikge1xuXHRsZXQgaGFuZGxlcjtcblx0bGV0IGVycm9yO1xuXG5cdHRyeSB7XG5cdFx0aGFuZGxlciA9IHRodW5rKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRlcnJvciA9IGU7XG5cdH1cblxuXHRpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRoYW5kbGVyLmFwcGx5KGVsZW1lbnQsIGFyZ3MpO1xuXHR9IGVsc2UgaWYgKGhhc19zaWRlX2VmZmVjdHMgfHwgaGFuZGxlciAhPSBudWxsIHx8IGVycm9yKSB7XG5cdFx0Y29uc3QgZmlsZW5hbWUgPSBjb21wb25lbnQ/LltGSUxFTkFNRV07XG5cdFx0Y29uc3QgbG9jYXRpb24gPSBsb2MgPyBgIGF0ICR7ZmlsZW5hbWV9OiR7bG9jWzBdfToke2xvY1sxXX1gIDogYCBpbiAke2ZpbGVuYW1lfWA7XG5cblx0XHRjb25zdCBldmVudF9uYW1lID0gYXJnc1swXS50eXBlO1xuXHRcdGNvbnN0IGRlc2NyaXB0aW9uID0gYFxcYCR7ZXZlbnRfbmFtZX1cXGAgaGFuZGxlciR7bG9jYXRpb259YDtcblx0XHRjb25zdCBzdWdnZXN0aW9uID0gcmVtb3ZlX3BhcmVucyA/ICdyZW1vdmUgdGhlIHRyYWlsaW5nIGAoKWAnIDogJ2FkZCBhIGxlYWRpbmcgYCgpID0+YCc7XG5cblx0XHR3LmV2ZW50X2hhbmRsZXJfaW52YWxpZChkZXNjcmlwdGlvbiwgc3VnZ2VzdGlvbik7XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBwYXJhbSB7c3RyaW5nfSBodG1sICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKSB7XG5cdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblx0ZWxlbS5pbm5lckhUTUwgPSBodG1sO1xuXHRyZXR1cm4gZWxlbS5jb250ZW50O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX3RleHQsIGdldF9maXJzdF9jaGlsZCwgaXNfZmlyZWZveCB9IGZyb20gJy4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi9yZWNvbmNpbGVyLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IFRFTVBMQVRFX0ZSQUdNRU5ULCBURU1QTEFURV9VU0VfSU1QT1JUX05PREUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBzdGFydFxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSBlbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbl9ub2RlcyhzdGFydCwgZW5kKSB7XG5cdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXHRpZiAoZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsKSB7XG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID0gc3RhcnQ7XG5cdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9IGVuZDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZShjb250ZW50LCBmbGFncykge1xuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB1c2VfaW1wb3J0X25vZGUgPSAoZmxhZ3MgJiBURU1QTEFURV9VU0VfSU1QT1JUX05PREUpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7Tm9kZX0gKi9cblx0dmFyIG5vZGU7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBmaXJzdCBpdGVtIGlzIGEgdGV4dC9lbGVtZW50IG5vZGUuIElmIG5vdCwgd2UgbmVlZCB0b1xuXHQgKiBjcmVhdGUgYW4gYWRkaXRpb25hbCBjb21tZW50IG5vZGUgdG8gYWN0IGFzIGBlZmZlY3Qubm9kZXMuc3RhcnRgXG5cdCAqL1xuXHR2YXIgaGFzX3N0YXJ0ID0gIWNvbnRlbnQuc3RhcnRzV2l0aCgnPCE+Jyk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bm9kZSA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaGFzX3N0YXJ0ID8gY29udGVudCA6ICc8IT4nICsgY29udGVudCk7XG5cdFx0XHRpZiAoIWlzX2ZyYWdtZW50KSBub2RlID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKTtcblx0XHR9XG5cblx0XHR2YXIgY2xvbmUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKFxuXHRcdFx0dXNlX2ltcG9ydF9ub2RlIHx8IGlzX2ZpcmVmb3ggPyBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpIDogbm9kZS5jbG9uZU5vZGUodHJ1ZSlcblx0XHQpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlX3dpdGhfc2NyaXB0KGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBmbiA9IHRlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKTtcblx0cmV0dXJuICgpID0+IHJ1bl9zY3JpcHRzKC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovIChmbigpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsnc3ZnJyB8ICdtYXRoJ30gbnNcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBuc190ZW1wbGF0ZShjb250ZW50LCBmbGFncywgbnMgPSAnc3ZnJykge1xuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB3cmFwcGVkID0gYDwke25zfT4ke2hhc19zdGFydCA/IGNvbnRlbnQgOiAnPCE+JyArIGNvbnRlbnR9PC8ke25zfT5gO1xuXG5cdC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovXG5cdHZhciBub2RlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmICghbm9kZSkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqLyAoY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCh3cmFwcGVkKSk7XG5cdFx0XHR2YXIgcm9vdCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChyb290KSkge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHN2Z190ZW1wbGF0ZV93aXRoX3NjcmlwdChjb250ZW50LCBmbGFncykge1xuXHR2YXIgZm4gPSBuc190ZW1wbGF0ZShjb250ZW50LCBmbGFncyk7XG5cdHJldHVybiAoKSA9PiBydW5fc2NyaXB0cygvKiogQHR5cGUge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSAqLyAoZm4oKSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRobWxfdGVtcGxhdGUoY29udGVudCwgZmxhZ3MpIHtcblx0cmV0dXJuIG5zX3RlbXBsYXRlKGNvbnRlbnQsIGZsYWdzLCAnbWF0aCcpO1xufVxuXG4vKipcbiAqIENyZWF0aW5nIGEgZG9jdW1lbnQgZnJhZ21lbnQgZnJvbSBIVE1MIHRoYXQgY29udGFpbnMgc2NyaXB0IHRhZ3Mgd2lsbCBub3QgZXhlY3V0ZVxuICogdGhlIHNjcmlwdHMuIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgc2NyaXB0IHRhZ3Mgd2l0aCBuZXcgb25lcyBzbyB0aGF0IHRoZXkgYXJlIGV4ZWN1dGVkLlxuICogQHBhcmFtIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBOb2RlW119XG4gKi9cbmZ1bmN0aW9uIHJ1bl9zY3JpcHRzKG5vZGUpIHtcblx0Ly8gc2NyaXB0cyB3ZXJlIFNTUidkLCBpbiB3aGljaCBjYXNlIHRoZXkgd2lsbCBydW5cblx0aWYgKGh5ZHJhdGluZykgcmV0dXJuIG5vZGU7XG5cblx0Y29uc3QgaXNfZnJhZ21lbnQgPSBub2RlLm5vZGVUeXBlID09PSAxMTtcblx0Y29uc3Qgc2NyaXB0cyA9XG5cdFx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpLnRhZ05hbWUgPT09ICdTQ1JJUFQnXG5cdFx0XHQ/IFsvKiogQHR5cGUge0hUTUxTY3JpcHRFbGVtZW50fSAqLyAobm9kZSldXG5cdFx0XHQ6IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0Jyk7XG5cdGNvbnN0IGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0Zm9yIChjb25zdCBzY3JpcHQgb2Ygc2NyaXB0cykge1xuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0Zm9yICh2YXIgYXR0cmlidXRlIG9mIHNjcmlwdC5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRjbG9uZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG5cdFx0fVxuXG5cdFx0Y2xvbmUudGV4dENvbnRlbnQgPSBzY3JpcHQudGV4dENvbnRlbnQ7XG5cblx0XHQvLyBUaGUgc2NyaXB0IGhhcyBjaGFuZ2VkIC0gaWYgaXQncyBhdCB0aGUgZWRnZXMsIHRoZSBlZmZlY3Qgbm93IHBvaW50cyBhdCBkZWFkIG5vZGVzXG5cdFx0aWYgKGlzX2ZyYWdtZW50ID8gbm9kZS5maXJzdENoaWxkID09PSBzY3JpcHQgOiBub2RlID09PSBzY3JpcHQpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IGNsb25lO1xuXHRcdH1cblx0XHRpZiAoaXNfZnJhZ21lbnQgPyBub2RlLmxhc3RDaGlsZCA9PT0gc2NyaXB0IDogbm9kZSA9PT0gc2NyaXB0KSB7XG5cdFx0XHRlZmZlY3Qubm9kZXNfZW5kID0gY2xvbmU7XG5cdFx0fVxuXG5cdFx0c2NyaXB0LnJlcGxhY2VXaXRoKGNsb25lKTtcblx0fVxuXHRyZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQodmFsdWUgPSAnJykge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHZhciB0ID0gY3JlYXRlX3RleHQodmFsdWUgKyAnJyk7XG5cdFx0YXNzaWduX25vZGVzKHQsIHQpO1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0aWYgKG5vZGUubm9kZVR5cGUgIT09IDMpIHtcblx0XHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgd2UgbmVlZCB0byBpbnNlcnQgYW4gZW1wdHkgdGV4dCBub2RlXG5cdFx0bm9kZS5iZWZvcmUoKG5vZGUgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShub2RlKTtcblx0fVxuXG5cdGFzc2lnbl9ub2Rlcyhub2RlLCBub2RlKTtcblx0cmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KCkge1xuXHQvLyB3ZSdyZSBub3QgZGVsZWdhdGluZyB0byBgdGVtcGxhdGVgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdH1cblxuXHR2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0dmFyIHN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG5cdHZhciBhbmNob3IgPSBjcmVhdGVfdGV4dCgpO1xuXHRmcmFnLmFwcGVuZChzdGFydCwgYW5jaG9yKTtcblxuXHRhc3NpZ25fbm9kZXMoc3RhcnQsIGFuY2hvcik7XG5cblx0cmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQXNzaWduIHRoZSBjcmVhdGVkIChvciBpbiBoeWRyYXRpb24gbW9kZSwgdHJhdmVyc2VkKSBkb20gZWxlbWVudHMgdG8gdGhlIGN1cnJlbnQgYmxvY2tcbiAqIGFuZCBpbnNlcnQgdGhlIGVsZW1lbnRzIGludG8gdGhlIGRvbSAoaW4gY2xpZW50IG1vZGUpLlxuICogQHBhcmFtIHtUZXh0IHwgQ29tbWVudCB8IEVsZW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoYW5jaG9yLCBkb20pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gaHlkcmF0ZV9ub2RlO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChhbmNob3IgPT09IG51bGwpIHtcblx0XHQvLyBlZGdlIGNhc2Ug4oCUIHZvaWQgYDxzdmVsdGU6ZWxlbWVudD5gIHdpdGggY29udGVudFxuXHRcdHJldHVybjtcblx0fVxuXG5cdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZG9tKSk7XG59XG5cbmxldCB1aWQgPSAxO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRfcHJvcHNfaWQoKSB7XG5cdHVpZCA9IDE7XG59XG5cbi8qKlxuICogQ3JlYXRlIChvciBoeWRyYXRlKSBhbiB1bmlxdWUgVUlEIGZvciB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNfaWQoKSB7XG5cdGlmIChcblx0XHRoeWRyYXRpbmcgJiZcblx0XHRoeWRyYXRlX25vZGUgJiZcblx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IDggJiZcblx0XHRoeWRyYXRlX25vZGUudGV4dENvbnRlbnQ/LnN0YXJ0c1dpdGgoJyNzJylcblx0KSB7XG5cdFx0Y29uc3QgaWQgPSBoeWRyYXRlX25vZGUudGV4dENvbnRlbnQuc3Vic3RyaW5nKDEpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybiBpZDtcblx0fVxuXG5cdHJldHVybiAnYycgKyB1aWQrKztcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudFR5cGUsIFN2ZWx0ZUNvbXBvbmVudCwgTW91bnRPcHRpb25zIH0gZnJvbSAnLi4vLi4vaW5kZXguanMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7XG5cdGNsZWFyX3RleHRfY29udGVudCxcblx0Y3JlYXRlX3RleHQsXG5cdGdldF9maXJzdF9jaGlsZCxcblx0Z2V0X25leHRfc2libGluZyxcblx0aW5pdF9vcGVyYXRpb25zXG59IGZyb20gJy4vZG9tL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX0VORCwgSFlEUkFUSU9OX0VSUk9SLCBIWURSQVRJT05fU1RBUlQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBwdXNoLCBwb3AsIGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9yb290LCBicmFuY2ggfSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGFsbF9yZWdpc3RlcmVkX2V2ZW50cyxcblx0aGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uLFxuXHRyb290X2V2ZW50X2hhbmRsZXNcbn0gZnJvbSAnLi9kb20vZWxlbWVudHMvZXZlbnRzLmpzJztcbmltcG9ydCB7IHJlc2V0X2hlYWRfYW5jaG9yIH0gZnJvbSAnLi9kb20vYmxvY2tzL3N2ZWx0ZS1oZWFkLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4vZG9tL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGlzX3Bhc3NpdmVfZXZlbnQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogVGhpcyBpcyBub3JtYWxseSB0cnVlIOKAlCBibG9jayBlZmZlY3RzIHNob3VsZCBydW4gdGhlaXIgaW50cm8gdHJhbnNpdGlvbnMg4oCUXG4gKiBidXQgaXMgZmFsc2UgZHVyaW5nIGh5ZHJhdGlvbiAodW5sZXNzIGBvcHRpb25zLmludHJvYCBpcyBgdHJ1ZWApIGFuZFxuICogd2hlbiBjcmVhdGluZyB0aGUgY2hpbGRyZW4gb2YgYSBgPHN2ZWx0ZTplbGVtZW50PmAgdGhhdCBqdXN0IGNoYW5nZWQgdGFnXG4gKi9cbmV4cG9ydCBsZXQgc2hvdWxkX2ludHJvID0gdHJ1ZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc2hvdWxkX2ludHJvKHZhbHVlKSB7XG5cdHNob3VsZF9pbnRybyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF90ZXh0KHRleHQsIHZhbHVlKSB7XG5cdC8vIEZvciBvYmplY3RzLCB3ZSBhcHBseSBzdHJpbmcgY29lcmNpb24gKHdoaWNoIG1pZ2h0IG1ha2UgdGhpbmdzIGxpa2UgJHN0YXRlIGFycmF5IHJlZmVyZW5jZXMgaW4gdGhlIHRlbXBsYXRlIHJlYWN0aXZlKSBiZWZvcmUgZGlmZmluZ1xuXHR2YXIgc3RyID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHZhbHVlICsgJycgOiB2YWx1ZTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRpZiAoc3RyICE9PSAodGV4dC5fX3QgPz89IHRleHQubm9kZVZhbHVlKSkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHR0ZXh0Ll9fdCA9IHN0cjtcblx0XHR0ZXh0Lm5vZGVWYWx1ZSA9IHN0ciArICcnO1xuXHR9XG59XG5cbi8qKlxuICogTW91bnRzIGEgY29tcG9uZW50IHRvIHRoZSBnaXZlbiB0YXJnZXQgYW5kIHJldHVybnMgdGhlIGV4cG9ydHMgYW5kIHBvdGVudGlhbGx5IHRoZSBwcm9wcyAoaWYgY29tcGlsZWQgd2l0aCBgYWNjZXNzb3JzOiB0cnVlYCkgb2YgdGhlIGNvbXBvbmVudC5cbiAqIFRyYW5zaXRpb25zIHdpbGwgcGxheSBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIHVubGVzcyB0aGUgYGludHJvYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHtNb3VudE9wdGlvbnM8UHJvcHM+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRyZXR1cm4gX21vdW50KGNvbXBvbmVudCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogSHlkcmF0ZXMgYSBjb21wb25lbnQgb24gdGhlIGdpdmVuIHRhcmdldCBhbmQgcmV0dXJucyB0aGUgZXhwb3J0cyBhbmQgcG90ZW50aWFsbHkgdGhlIHByb3BzIChpZiBjb21waWxlZCB3aXRoIGBhY2Nlc3NvcnM6IHRydWVgKSBvZiB0aGUgY29tcG9uZW50XG4gKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBQcm9wc1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PFByb3BzPj4gfCBDb21wb25lbnQ8UHJvcHMsIEV4cG9ydHMsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7fSBleHRlbmRzIFByb3BzID8ge1xuICogXHRcdHRhcmdldDogRG9jdW1lbnQgfCBFbGVtZW50IHwgU2hhZG93Um9vdDtcbiAqIFx0XHRwcm9wcz86IFByb3BzO1xuICogXHRcdGV2ZW50cz86IFJlY29yZDxzdHJpbmcsIChlOiBhbnkpID0+IGFueT47XG4gKiAgXHRjb250ZXh0PzogTWFwPGFueSwgYW55PjtcbiAqIFx0XHRpbnRybz86IGJvb2xlYW47XG4gKiBcdFx0cmVjb3Zlcj86IGJvb2xlYW47XG4gKiBcdH0gOiB7XG4gKiBcdFx0dGFyZ2V0OiBEb2N1bWVudCB8IEVsZW1lbnQgfCBTaGFkb3dSb290O1xuICogXHRcdHByb3BzOiBQcm9wcztcbiAqIFx0XHRldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCAoZTogYW55KSA9PiBhbnk+O1xuICogIFx0Y29udGV4dD86IE1hcDxhbnksIGFueT47XG4gKiBcdFx0aW50cm8/OiBib29sZWFuO1xuICogXHRcdHJlY292ZXI/OiBib29sZWFuO1xuICogXHR9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdGluaXRfb3BlcmF0aW9ucygpO1xuXHRvcHRpb25zLmludHJvID0gb3B0aW9ucy5pbnRybyA/PyBmYWxzZTtcblx0Y29uc3QgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cdGNvbnN0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGNvbnN0IHByZXZpb3VzX2h5ZHJhdGVfbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR0cnkge1xuXHRcdHZhciBhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZCh0YXJnZXQpKTtcblx0XHR3aGlsZSAoXG5cdFx0XHRhbmNob3IgJiZcblx0XHRcdChhbmNob3Iubm9kZVR5cGUgIT09IDggfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhICE9PSBIWURSQVRJT05fU1RBUlQpXG5cdFx0KSB7XG5cdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoYW5jaG9yKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFhbmNob3IpIHtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKSk7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cblx0XHRjb25zdCBpbnN0YW5jZSA9IF9tb3VudChjb21wb25lbnQsIHsgLi4ub3B0aW9ucywgYW5jaG9yIH0pO1xuXG5cdFx0aWYgKFxuXHRcdFx0aHlkcmF0ZV9ub2RlID09PSBudWxsIHx8XG5cdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgIT09IDggfHxcblx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSAhPT0gSFlEUkFUSU9OX0VORFxuXHRcdCkge1xuXHRcdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblxuXHRcdHJldHVybiAvKiogIEB0eXBlIHtFeHBvcnRzfSAqLyAoaW5zdGFuY2UpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChlcnJvciA9PT0gSFlEUkFUSU9OX0VSUk9SKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5yZWNvdmVyID09PSBmYWxzZSkge1xuXHRcdFx0XHRlLmh5ZHJhdGlvbl9mYWlsZWQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYW4gZXJyb3Igb2NjdXJlZCBhYm92ZSwgdGhlIG9wZXJhdGlvbnMgbWlnaHQgbm90IHlldCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQuXG5cdFx0XHRpbml0X29wZXJhdGlvbnMoKTtcblx0XHRcdGNsZWFyX3RleHRfY29udGVudCh0YXJnZXQpO1xuXG5cdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdHJldHVybiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9oeWRyYXRpbmcod2FzX2h5ZHJhdGluZyk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShwcmV2aW91c19oeWRyYXRlX25vZGUpO1xuXHRcdHJlc2V0X2hlYWRfYW5jaG9yKCk7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZG9jdW1lbnRfbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxhbnk+PiB8IENvbXBvbmVudDxhbnk+fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZnVuY3Rpb24gX21vdW50KENvbXBvbmVudCwgeyB0YXJnZXQsIGFuY2hvciwgcHJvcHMgPSB7fSwgZXZlbnRzLCBjb250ZXh0LCBpbnRybyA9IHRydWUgfSkge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblxuXHR2YXIgcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cblx0LyoqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzICovXG5cdHZhciBldmVudF9oYW5kbGUgPSAoZXZlbnRzKSA9PiB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBldmVudF9uYW1lID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRpZiAocmVnaXN0ZXJlZF9ldmVudHMuaGFzKGV2ZW50X25hbWUpKSBjb250aW51ZTtcblx0XHRcdHJlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudF9uYW1lKTtcblxuXHRcdFx0dmFyIHBhc3NpdmUgPSBpc19wYXNzaXZlX2V2ZW50KGV2ZW50X25hbWUpO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJvdGggdGhlIGNvbnRhaW5lciBhbmQgdGhlIGRvY3VtZW50LlxuXHRcdFx0Ly8gVGhlIGNvbnRhaW5lciBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyBmcm9tIHdpdGhpbiBpbiBjYXNlXG5cdFx0XHQvLyB0aGUgb3V0ZXIgY29udGVudCBzdG9wcyBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblxuXHRcdFx0dmFyIG4gPSBkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpO1xuXG5cdFx0XHRpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFRoZSBkb2N1bWVudCBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZSBmcm9tIGVsZW1lbnRzIHRoYXQgd2VyZVxuXHRcdFx0XHQvLyBtYW51YWxseSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBjb250YWluZXIgKGUuZy4gdmlhIG1hbnVhbCBwb3J0YWxzKS5cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbiArIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRldmVudF9oYW5kbGUoYXJyYXlfZnJvbShhbGxfcmVnaXN0ZXJlZF9ldmVudHMpKTtcblx0cm9vdF9ldmVudF9oYW5kbGVzLmFkZChldmVudF9oYW5kbGUpO1xuXG5cdC8qKiBAdHlwZSB7RXhwb3J0c30gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3aWxsIGJlIGRlZmluZWQgYmVjYXVzZSB0aGUgcmVuZGVyIGVmZmVjdCBydW5zIHN5bmNocm9ub3VzbHlcblx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgdW5tb3VudCA9IGNvbXBvbmVudF9yb290KCgpID0+IHtcblx0XHR2YXIgYW5jaG9yX25vZGUgPSBhbmNob3IgPz8gdGFyZ2V0LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXG5cdFx0YnJhbmNoKCgpID0+IHtcblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHB1c2goe30pO1xuXHRcdFx0XHR2YXIgY3R4ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdFx0XHRjdHguYyA9IGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0Ly8gV2UgY2FuJ3Qgc3ByZWFkIHRoZSBvYmplY3Qgb3IgZWxzZSB3ZSdkIGxvc2UgdGhlIHN0YXRlIHByb3h5IHN0dWZmLCBpZiBpdCBpcyBvbmVcblx0XHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChwcm9wcykuJCRldmVudHMgPSBldmVudHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0YXNzaWduX25vZGVzKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoYW5jaG9yX25vZGUpLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0c2hvdWxkX2ludHJvID0gaW50cm87XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBwdWJsaWMgdHlwaW5ncyBhcmUgbm90IHdoYXQgdGhlIGFjdHVhbCBmdW5jdGlvbiBsb29rcyBsaWtlXG5cdFx0XHRjb21wb25lbnQgPSBDb21wb25lbnQoYW5jaG9yX25vZGUsIHByb3BzKSB8fCB7fTtcblx0XHRcdHNob3VsZF9pbnRybyA9IHRydWU7XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHBvcCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAodmFyIGV2ZW50X25hbWUgb2YgcmVnaXN0ZXJlZF9ldmVudHMpIHtcblx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblxuXHRcdFx0XHR2YXIgbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZG9jdW1lbnRfbGlzdGVuZXJzLmdldChldmVudF9uYW1lKSk7XG5cblx0XHRcdFx0aWYgKC0tbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblx0XHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuZGVsZXRlKGV2ZW50X25hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cm9vdF9ldmVudF9oYW5kbGVzLmRlbGV0ZShldmVudF9oYW5kbGUpO1xuXG5cdFx0XHRpZiAoYW5jaG9yX25vZGUgIT09IGFuY2hvcikge1xuXHRcdFx0XHRhbmNob3Jfbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChhbmNob3Jfbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0bW91bnRlZF9jb21wb25lbnRzLnNldChjb21wb25lbnQsIHVubW91bnQpO1xuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG1vdW50ZWQgb3IgaHlkcmF0ZWQuXG4gKiBVc2VzIGEgYFdlYWtNYXBgIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAqL1xubGV0IG1vdW50ZWRfY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VudGVkIHVzaW5nIGBtb3VudGAgb3IgYGh5ZHJhdGVgLlxuICpcbiAqIFNpbmNlIDUuMTMuMCwgaWYgYG9wdGlvbnMub3V0cm9gIGlzIGB0cnVlYCwgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgd2lsbCBwbGF5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBhZnRlciB0cmFuc2l0aW9ucyBoYXZlIGNvbXBsZXRlZCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgdHJ1ZSwgb3IgaW1tZWRpYXRlbHkgb3RoZXJ3aXNlIChwcmlvciB0byA1LjEzLjAsIHJldHVybnMgYHZvaWRgKS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbW91bnQsIHVubW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICogaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zdmVsdGUnO1xuICpcbiAqIGNvbnN0IGFwcCA9IG1vdW50KEFwcCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSk7XG4gKlxuICogLy8gbGF0ZXIuLi5cbiAqIHVubW91bnQoYXBwLCB7IG91dHJvOiB0cnVlIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7IG91dHJvPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0Y29uc3QgZm4gPSBtb3VudGVkX2NvbXBvbmVudHMuZ2V0KGNvbXBvbmVudCk7XG5cblx0aWYgKGZuKSB7XG5cdFx0bW91bnRlZF9jb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuXHRcdHJldHVybiBmbihvcHRpb25zKTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHR3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpO1xuXHR9XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0cmVtb3ZlX25vZGVzLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBwYXVzZV9lZmZlY3QsIHJlc3VtZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgSFlEUkFUSU9OX1NUQVJUX0VMU0UsIFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geyhicmFuY2g6IChmbjogKGFuY2hvcjogTm9kZSkgPT4gdm9pZCwgZmxhZz86IGJvb2xlYW4pID0+IHZvaWQpID0+IHZvaWR9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbHNlaWZdIFRydWUgaWYgdGhpcyBpcyBhbiBgezplbHNlIGlmIC4uLn1gIGJsb2NrIHJhdGhlciB0aGFuIGFuIGB7I2lmIC4uLn1gLCBhcyB0aGF0IGFmZmVjdHMgd2hpY2ggdHJhbnNpdGlvbnMgYXJlIGNvbnNpZGVyZWQgJ2xvY2FsJ1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZl9ibG9jayhub2RlLCBmbiwgZWxzZWlmID0gZmFsc2UpIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgY29uc2VxdWVudF9lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGFsdGVybmF0ZV9lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7VU5JTklUSUFMSVpFRCB8IGJvb2xlYW4gfCBudWxsfSAqL1xuXHR2YXIgY29uZGl0aW9uID0gVU5JTklUSUFMSVpFRDtcblxuXHR2YXIgZmxhZ3MgPSBlbHNlaWYgPyBFRkZFQ1RfVFJBTlNQQVJFTlQgOiAwO1xuXG5cdHZhciBoYXNfYnJhbmNoID0gZmFsc2U7XG5cblx0Y29uc3Qgc2V0X2JyYW5jaCA9ICgvKiogQHR5cGUgeyhhbmNob3I6IE5vZGUpID0+IHZvaWR9ICovIGZuLCBmbGFnID0gdHJ1ZSkgPT4ge1xuXHRcdGhhc19icmFuY2ggPSB0cnVlO1xuXHRcdHVwZGF0ZV9icmFuY2goZmxhZywgZm4pO1xuXHR9O1xuXG5cdGNvbnN0IHVwZGF0ZV9icmFuY2ggPSAoXG5cdFx0LyoqIEB0eXBlIHtib29sZWFuIHwgbnVsbH0gKi8gbmV3X2NvbmRpdGlvbixcblx0XHQvKiogQHR5cGUge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9ICovIGZuXG5cdCkgPT4ge1xuXHRcdGlmIChjb25kaXRpb24gPT09IChjb25kaXRpb24gPSBuZXdfY29uZGl0aW9uKSkgcmV0dXJuO1xuXG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhIGh5ZHJhdGlvbiBtaXNtYXRjaC4gTmVlZHMgdG8gYmUgYSBgbGV0YCBvciBlbHNlIGl0IGlzbid0IHRyZWVzaGFrZW4gb3V0ICovXG5cdFx0bGV0IG1pc21hdGNoID0gZmFsc2U7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRjb25zdCBpc19lbHNlID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRTtcblxuXHRcdFx0aWYgKCEhY29uZGl0aW9uID09PSBpc19lbHNlKSB7XG5cdFx0XHRcdC8vIEh5ZHJhdGlvbiBtaXNtYXRjaDogcmVtb3ZlIGV2ZXJ5dGhpbmcgaW5zaWRlIHRoZSBhbmNob3IgYW5kIHN0YXJ0IGZyZXNoLlxuXHRcdFx0XHQvLyBUaGlzIGNvdWxkIGhhcHBlbiB3aXRoIGB7I2lmIGJyb3dzZXJ9Li4uey9pZn1gLCBmb3IgZXhhbXBsZVxuXHRcdFx0XHRhbmNob3IgPSByZW1vdmVfbm9kZXMoKTtcblxuXHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNvbmRpdGlvbikge1xuXHRcdFx0aWYgKGNvbnNlcXVlbnRfZWZmZWN0KSB7XG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoY29uc2VxdWVudF9lZmZlY3QpO1xuXHRcdFx0fSBlbHNlIGlmIChmbikge1xuXHRcdFx0XHRjb25zZXF1ZW50X2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBmbihhbmNob3IpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFsdGVybmF0ZV9lZmZlY3QpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGFsdGVybmF0ZV9lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRhbHRlcm5hdGVfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhbHRlcm5hdGVfZWZmZWN0KSB7XG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoYWx0ZXJuYXRlX2VmZmVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGZuKSB7XG5cdFx0XHRcdGFsdGVybmF0ZV9lZmZlY3QgPSBicmFuY2goKCkgPT4gZm4oYW5jaG9yKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb25zZXF1ZW50X2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoY29uc2VxdWVudF9lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRjb25zZXF1ZW50X2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRoYXNfYnJhbmNoID0gZmFsc2U7XG5cdFx0Zm4oc2V0X2JyYW5jaCk7XG5cdFx0aWYgKCFoYXNfYnJhbmNoKSB7XG5cdFx0XHR1cGRhdGVfYnJhbmNoKG51bGwsIG51bGwpO1xuXHRcdH1cblx0fSwgZmxhZ3MpO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWFjaEl0ZW0sIEVhY2hTdGF0ZSwgRWZmZWN0LCBNYXliZVNvdXJjZSwgU291cmNlLCBUZW1wbGF0ZU5vZGUsIFRyYW5zaXRpb25NYW5hZ2VyLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRFQUNIX0lOREVYX1JFQUNUSVZFLFxuXHRFQUNIX0lTX0FOSU1BVEVELFxuXHRFQUNIX0lTX0NPTlRST0xMRUQsXG5cdEVBQ0hfSVRFTV9JTU1VVEFCTEUsXG5cdEVBQ0hfSVRFTV9SRUFDVElWRSxcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX1NUQVJUX0VMU0Vcbn0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHJlbW92ZV9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nXG59IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnMsXG5cdHBhdXNlX2NoaWxkcmVuLFxuXHRwYXVzZV9lZmZlY3QsXG5cdHJlc3VtZV9lZmZlY3Rcbn0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgbXV0YWJsZV9zb3VyY2UsIGludGVybmFsX3NldCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBhcnJheV9mcm9tLCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBJTkVSVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24sIGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZXJpdmVkX3NhZmVfZXF1YWwgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcblxuLyoqXG4gKiBUaGUgcm93IG9mIGEga2V5ZWQgZWFjaCBibG9jayB0aGF0IGlzIGN1cnJlbnRseSB1cGRhdGluZy4gV2UgdHJhY2sgdGhpc1xuICogc28gdGhhdCBgYW5pbWF0ZTpgIGRpcmVjdGl2ZXMgaGF2ZSBzb21ldGhpbmcgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG9cbiAqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9XG4gKi9cbmV4cG9ydCBsZXQgY3VycmVudF9lYWNoX2l0ZW0gPSBudWxsO1xuXG4vKiogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IGl0ZW0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VycmVudF9lYWNoX2l0ZW0oaXRlbSkge1xuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IF9cbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChfLCBpKSB7XG5cdHJldHVybiBpO1xufVxuXG4vKipcbiAqIFBhdXNlIG11bHRpcGxlIGVmZmVjdHMgc2ltdWx0YW5lb3VzbHksIGFuZCBjb29yZGluYXRlIHRoZWlyXG4gKiBzdWJzZXF1ZW50IGRlc3RydWN0aW9uLiBVc2VkIGluIGVhY2ggYmxvY2tzXG4gKiBAcGFyYW0ge0VhY2hTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7RWFjaEl0ZW1bXX0gaXRlbXNcbiAqIEBwYXJhbSB7bnVsbCB8IE5vZGV9IGNvbnRyb2xsZWRfYW5jaG9yXG4gKiBAcGFyYW0ge01hcDxhbnksIEVhY2hJdGVtPn0gaXRlbXNfbWFwXG4gKi9cbmZ1bmN0aW9uIHBhdXNlX2VmZmVjdHMoc3RhdGUsIGl0ZW1zLCBjb250cm9sbGVkX2FuY2hvciwgaXRlbXNfbWFwKSB7XG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gKi9cblx0dmFyIHRyYW5zaXRpb25zID0gW107XG5cdHZhciBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHBhdXNlX2NoaWxkcmVuKGl0ZW1zW2ldLmUsIHRyYW5zaXRpb25zLCB0cnVlKTtcblx0fVxuXG5cdHZhciBpc19jb250cm9sbGVkID0gbGVuZ3RoID4gMCAmJiB0cmFuc2l0aW9ucy5sZW5ndGggPT09IDAgJiYgY29udHJvbGxlZF9hbmNob3IgIT09IG51bGw7XG5cdC8vIElmIHdlIGhhdmUgYSBjb250cm9sbGVkIGFuY2hvciwgaXQgbWVhbnMgdGhhdCB0aGUgZWFjaCBibG9jayBpcyBpbnNpZGUgYSBzaW5nbGVcblx0Ly8gRE9NIGVsZW1lbnQsIHNvIHdlIGNhbiBhcHBseSBhIGZhc3QtcGF0aCBmb3IgY2xlYXJpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50LlxuXHRpZiAoaXNfY29udHJvbGxlZCkge1xuXHRcdHZhciBwYXJlbnRfbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKFxuXHRcdFx0LyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoY29udHJvbGxlZF9hbmNob3IpLnBhcmVudE5vZGVcblx0XHQpO1xuXHRcdGNsZWFyX3RleHRfY29udGVudChwYXJlbnRfbm9kZSk7XG5cdFx0cGFyZW50X25vZGUuYXBwZW5kKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGNvbnRyb2xsZWRfYW5jaG9yKSk7XG5cdFx0aXRlbXNfbWFwLmNsZWFyKCk7XG5cdFx0bGluayhzdGF0ZSwgaXRlbXNbMF0ucHJldiwgaXRlbXNbbGVuZ3RoIC0gMV0ubmV4dCk7XG5cdH1cblxuXHRydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCAoKSA9PiB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdGlmICghaXNfY29udHJvbGxlZCkge1xuXHRcdFx0XHRpdGVtc19tYXAuZGVsZXRlKGl0ZW0uayk7XG5cdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0ucHJldiwgaXRlbS5uZXh0KTtcblx0XHRcdH1cblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGl0ZW0uZSwgIWlzX2NvbnRyb2xsZWQpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7RWxlbWVudCB8IENvbW1lbnR9IG5vZGUgVGhlIG5leHQgc2libGluZyBub2RlLCBvciB0aGUgcGFyZW50IG5vZGUgaWYgdGhpcyBpcyBhICdjb250cm9sbGVkJyBibG9ja1xuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEBwYXJhbSB7KHZhbHVlOiBWLCBpbmRleDogbnVtYmVyKSA9PiBhbnl9IGdldF9rZXlcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogTWF5YmVTb3VyY2U8Vj4sIGluZGV4OiBNYXliZVNvdXJjZTxudW1iZXI+KSA9PiB2b2lkfSByZW5kZXJfZm5cbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gZmFsbGJhY2tfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaChub2RlLCBmbGFncywgZ2V0X2NvbGxlY3Rpb24sIGdldF9rZXksIHJlbmRlcl9mbiwgZmFsbGJhY2tfZm4gPSBudWxsKSB7XG5cdHZhciBhbmNob3IgPSBub2RlO1xuXG5cdC8qKiBAdHlwZSB7RWFjaFN0YXRlfSAqL1xuXHR2YXIgc3RhdGUgPSB7IGZsYWdzLCBpdGVtczogbmV3IE1hcCgpLCBmaXJzdDogbnVsbCB9O1xuXG5cdHZhciBpc19jb250cm9sbGVkID0gKGZsYWdzICYgRUFDSF9JU19DT05UUk9MTEVEKSAhPT0gMDtcblxuXHRpZiAoaXNfY29udHJvbGxlZCkge1xuXHRcdHZhciBwYXJlbnRfbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUpO1xuXG5cdFx0YW5jaG9yID0gaHlkcmF0aW5nXG5cdFx0XHQ/IHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50IHwgVGV4dH0gKi8gKGdldF9maXJzdF9jaGlsZChwYXJlbnRfbm9kZSkpKVxuXHRcdFx0OiBwYXJlbnRfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fVxuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGZhbGxiYWNrID0gbnVsbDtcblxuXHR2YXIgd2FzX2VtcHR5ID0gZmFsc2U7XG5cblx0Ly8gVE9ETzogaWRlYWxseSB3ZSBjb3VsZCB1c2UgZGVyaXZlZCBmb3IgcnVuZXMgbW9kZSBidXQgYmVjYXVzZSBvZiB0aGUgYWJpbGl0eVxuXHQvLyB0byB1c2UgYSBzdG9yZSB3aGljaCBjYW4gYmUgbXV0YXRlZCwgd2UgY2FuJ3QgZG8gdGhhdCBoZXJlIGFzIG11dGF0aW5nIGEgc3RvcmVcblx0Ly8gd2lsbCBzdGlsbCByZXN1bHQgaW4gdGhlIGNvbGxlY3Rpb24gYXJyYXkgYmVpbmcgdGhlIHNhbWUgZnJvbSB0aGUgc3RvcmVcblx0dmFyIGVhY2hfYXJyYXkgPSBkZXJpdmVkX3NhZmVfZXF1YWwoKCkgPT4ge1xuXHRcdHZhciBjb2xsZWN0aW9uID0gZ2V0X2NvbGxlY3Rpb24oKTtcblxuXHRcdHJldHVybiBpc19hcnJheShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiBjb2xsZWN0aW9uID09IG51bGwgPyBbXSA6IGFycmF5X2Zyb20oY29sbGVjdGlvbik7XG5cdH0pO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHR2YXIgYXJyYXkgPSBnZXQoZWFjaF9hcnJheSk7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdGlmICh3YXNfZW1wdHkgJiYgbGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBpZ25vcmUgdXBkYXRlcyBpZiB0aGUgYXJyYXkgaXMgZW1wdHksXG5cdFx0XHQvLyBhbmQgaXQgYWxyZWFkeSB3YXMgZW1wdHkgb24gcHJldmlvdXMgcnVuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHdhc19lbXB0eSA9IGxlbmd0aCA9PT0gMDtcblxuXHRcdC8qKiBgdHJ1ZWAgaWYgdGhlcmUgd2FzIGEgaHlkcmF0aW9uIG1pc21hdGNoLiBOZWVkcyB0byBiZSBhIGBsZXRgIG9yIGVsc2UgaXQgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgKi9cblx0XHRsZXQgbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdHZhciBpc19lbHNlID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhID09PSBIWURSQVRJT05fU1RBUlRfRUxTRTtcblxuXHRcdFx0aWYgKGlzX2Vsc2UgIT09IChsZW5ndGggPT09IDApKSB7XG5cdFx0XHRcdC8vIGh5ZHJhdGlvbiBtaXNtYXRjaCDigJQgcmVtb3ZlIHRoZSBzZXJ2ZXItcmVuZGVyZWQgRE9NIGFuZCBzdGFydCBvdmVyXG5cdFx0XHRcdGFuY2hvciA9IHJlbW92ZV9ub2RlcygpO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGlzIGlzIHNlcGFyYXRlIHRvIHRoZSBwcmV2aW91cyBibG9jayBiZWNhdXNlIGBoeWRyYXRpbmdgIG1pZ2h0IGNoYW5nZVxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdC8qKiBAdHlwZSB7RWFjaEl0ZW0gfCBudWxsfSAqL1xuXHRcdFx0dmFyIHByZXYgPSBudWxsO1xuXG5cdFx0XHQvKiogQHR5cGUge0VhY2hJdGVtfSAqL1xuXHRcdFx0dmFyIGl0ZW07XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gOCAmJlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSA9PT0gSFlEUkFUSU9OX0VORFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBUaGUgc2VydmVyIHJlbmRlcmVkIGZld2VyIGl0ZW1zIHRoYW4gZXhwZWN0ZWQsXG5cdFx0XHRcdFx0Ly8gc28gYnJlYWsgb3V0IGFuZCBjb250aW51ZSBhcHBlbmRpbmcgbm9uLWh5ZHJhdGVkIGl0ZW1zXG5cdFx0XHRcdFx0YW5jaG9yID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdFx0dmFyIGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0XHRpdGVtID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdHByZXYsXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRyZW5kZXJfZm4sXG5cdFx0XHRcdFx0ZmxhZ3MsXG5cdFx0XHRcdFx0Z2V0X2NvbGxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdFx0c3RhdGUuaXRlbXMuc2V0KGtleSwgaXRlbSk7XG5cblx0XHRcdFx0cHJldiA9IGl0ZW07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBleGNlc3Mgbm9kZXNcblx0XHRcdGlmIChsZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUocmVtb3ZlX25vZGVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0XHRyZWNvbmNpbGUoYXJyYXksIHN0YXRlLCBhbmNob3IsIHJlbmRlcl9mbiwgZmxhZ3MsIGdldF9rZXksIGdldF9jb2xsZWN0aW9uKTtcblx0XHR9XG5cblx0XHRpZiAoZmFsbGJhY2tfZm4gIT09IG51bGwpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDApIHtcblx0XHRcdFx0aWYgKGZhbGxiYWNrKSB7XG5cdFx0XHRcdFx0cmVzdW1lX2VmZmVjdChmYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmFsbGJhY2sgPSBicmFuY2goKCkgPT4gZmFsbGJhY2tfZm4oYW5jaG9yKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZmFsbGJhY2sgIT09IG51bGwpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGZhbGxiYWNrLCAoKSA9PiB7XG5cdFx0XHRcdFx0ZmFsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobWlzbWF0Y2gpIHtcblx0XHRcdC8vIGNvbnRpbnVlIGluIGh5ZHJhdGlvbiBtb2RlXG5cdFx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gd2UgbW91bnQgdGhlIGVhY2ggYmxvY2sgZm9yIHRoZSBmaXJzdCB0aW1lLCB0aGUgY29sbGVjdGlvbiB3b24ndCBiZVxuXHRcdC8vIGNvbm5lY3RlZCB0byB0aGlzIGVmZmVjdCBhcyB0aGUgZWZmZWN0IGhhc24ndCBmaW5pc2hlZCBydW5uaW5nIHlldCBhbmQgaXRzIGRlcHNcblx0XHQvLyB3b24ndCBiZSBhc3NpZ25lZC4gSG93ZXZlciwgaXQncyBwb3NzaWJsZSB0aGF0IHdoZW4gcmVjb25jaWxpbmcgdGhlIGVhY2ggYmxvY2tcblx0XHQvLyB0aGF0IGEgbXV0YXRpb24gb2NjdXJyZWQgYW5kIGl0J3MgbWFkZSB0aGUgY29sbGVjdGlvbiBNQVlCRV9ESVJUWSwgc28gcmVhZGluZyB0aGVcblx0XHQvLyBjb2xsZWN0aW9uIGFnYWluIGNhbiBwcm92aWRlIGNvbnNpc3RlbmN5IHRvIHRoZSByZWFjdGl2ZSBncmFwaCBhZ2FpbiBhcyB0aGUgZGVyaXZlZHNcblx0XHQvLyB3aWxsIG5vdyBiZSBgQ0xFQU5gLlxuXHRcdGdldChlYWNoX2FycmF5KTtcblx0fSk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEFkZCwgcmVtb3ZlLCBvciByZW9yZGVyIGl0ZW1zIG91dHB1dCBieSBhbiBlYWNoIGJsb2NrIGFzIGl0cyBpbnB1dCBjaGFuZ2VzXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtBcnJheTxWPn0gYXJyYXlcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudCB8IFRleHR9IGFuY2hvclxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFNvdXJjZTxudW1iZXI+LCBjb2xsZWN0aW9uOiAoKSA9PiBWW10pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geyh2YWx1ZTogViwgaW5kZXg6IG51bWJlcikgPT4gYW55fSBnZXRfa2V5XG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiByZWNvbmNpbGUoYXJyYXksIHN0YXRlLCBhbmNob3IsIHJlbmRlcl9mbiwgZmxhZ3MsIGdldF9rZXksIGdldF9jb2xsZWN0aW9uKSB7XG5cdHZhciBpc19hbmltYXRlZCA9IChmbGFncyAmIEVBQ0hfSVNfQU5JTUFURUQpICE9PSAwO1xuXHR2YXIgc2hvdWxkX3VwZGF0ZSA9IChmbGFncyAmIChFQUNIX0lURU1fUkVBQ1RJVkUgfCBFQUNIX0lOREVYX1JFQUNUSVZFKSkgIT09IDA7XG5cblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGl0ZW1zID0gc3RhdGUuaXRlbXM7XG5cdHZhciBmaXJzdCA9IHN0YXRlLmZpcnN0O1xuXHR2YXIgY3VycmVudCA9IGZpcnN0O1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHNlZW47XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdHZhciBwcmV2ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge3VuZGVmaW5lZCB8IFNldDxFYWNoSXRlbT59ICovXG5cdHZhciB0b19hbmltYXRlO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtW119ICovXG5cdHZhciBzdGFzaGVkID0gW107XG5cblx0LyoqIEB0eXBlIHtWfSAqL1xuXHR2YXIgdmFsdWU7XG5cblx0LyoqIEB0eXBlIHthbnl9ICovXG5cdHZhciBrZXk7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGl0ZW07XG5cblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdHZhciBpO1xuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0aXRlbSA9IGl0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGl0ZW0uYT8ubWVhc3VyZSgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5hZGQoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRrZXkgPSBnZXRfa2V5KHZhbHVlLCBpKTtcblx0XHRpdGVtID0gaXRlbXMuZ2V0KGtleSk7XG5cblx0XHRpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgY2hpbGRfYW5jaG9yID0gY3VycmVudCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY3VycmVudC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblxuXHRcdFx0cHJldiA9IGNyZWF0ZV9pdGVtKFxuXHRcdFx0XHRjaGlsZF9hbmNob3IsXG5cdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRwcmV2LFxuXHRcdFx0XHRwcmV2ID09PSBudWxsID8gc3RhdGUuZmlyc3QgOiBwcmV2Lm5leHQsXG5cdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRrZXksXG5cdFx0XHRcdGksXG5cdFx0XHRcdHJlbmRlcl9mbixcblx0XHRcdFx0ZmxhZ3MsXG5cdFx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0XHQpO1xuXG5cdFx0XHRpdGVtcy5zZXQoa2V5LCBwcmV2KTtcblxuXHRcdFx0bWF0Y2hlZCA9IFtdO1xuXHRcdFx0c3Rhc2hlZCA9IFtdO1xuXG5cdFx0XHRjdXJyZW50ID0gcHJldi5uZXh0O1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3VsZF91cGRhdGUpIHtcblx0XHRcdHVwZGF0ZV9pdGVtKGl0ZW0sIHZhbHVlLCBpLCBmbGFncyk7XG5cdFx0fVxuXG5cdFx0aWYgKChpdGVtLmUuZiAmIElORVJUKSAhPT0gMCkge1xuXHRcdFx0cmVzdW1lX2VmZmVjdChpdGVtLmUpO1xuXHRcdFx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0XHRcdGl0ZW0uYT8udW5maXgoKTtcblx0XHRcdFx0KHRvX2FuaW1hdGUgPz89IG5ldyBTZXQoKSkuZGVsZXRlKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpdGVtICE9PSBjdXJyZW50KSB7XG5cdFx0XHRpZiAoc2VlbiAhPT0gdW5kZWZpbmVkICYmIHNlZW4uaGFzKGl0ZW0pKSB7XG5cdFx0XHRcdGlmIChtYXRjaGVkLmxlbmd0aCA8IHN0YXNoZWQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBsYXRlciBpdGVtcyB0byB0aGUgZnJvbnRcblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBzdGFzaGVkWzBdO1xuXHRcdFx0XHRcdHZhciBqO1xuXG5cdFx0XHRcdFx0cHJldiA9IHN0YXJ0LnByZXY7XG5cblx0XHRcdFx0XHR2YXIgYSA9IG1hdGNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGIgPSBtYXRjaGVkW21hdGNoZWQubGVuZ3RoIC0gMV07XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbWF0Y2hlZC5sZW5ndGg7IGogKz0gMSkge1xuXHRcdFx0XHRcdFx0bW92ZShtYXRjaGVkW2pdLCBzdGFydCwgYW5jaG9yKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgc3Rhc2hlZC5sZW5ndGg7IGogKz0gMSkge1xuXHRcdFx0XHRcdFx0c2Vlbi5kZWxldGUoc3Rhc2hlZFtqXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYS5wcmV2LCBiLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIHByZXYsIGEpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGIsIHN0YXJ0KTtcblxuXHRcdFx0XHRcdGN1cnJlbnQgPSBzdGFydDtcblx0XHRcdFx0XHRwcmV2ID0gYjtcblx0XHRcdFx0XHRpIC09IDE7XG5cblx0XHRcdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRcdFx0c3Rhc2hlZCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIG1vcmUgZWZmaWNpZW50IHRvIG1vdmUgZWFybGllciBpdGVtcyB0byB0aGUgYmFja1xuXHRcdFx0XHRcdHNlZW4uZGVsZXRlKGl0ZW0pO1xuXHRcdFx0XHRcdG1vdmUoaXRlbSwgY3VycmVudCwgYW5jaG9yKTtcblxuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0ucHJldiwgaXRlbS5uZXh0KTtcblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBpdGVtLCBwcmV2ID09PSBudWxsID8gc3RhdGUuZmlyc3QgOiBwcmV2Lm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIHByZXYsIGl0ZW0pO1xuXG5cdFx0XHRcdFx0cHJldiA9IGl0ZW07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bWF0Y2hlZCA9IFtdO1xuXHRcdFx0c3Rhc2hlZCA9IFtdO1xuXG5cdFx0XHR3aGlsZSAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmsgIT09IGtleSkge1xuXHRcdFx0XHQvLyBJZiB0aGUgZWFjaCBibG9jayBpc24ndCBpbmVydCBhbmQgYW4gaXRlbSBoYXMgYW4gZWZmZWN0IHRoYXQgaXMgYWxyZWFkeSBpbmVydCxcblx0XHRcdFx0Ly8gc2tpcCBvdmVyIGFkZGluZyBpdCB0byBvdXIgc2VlbiBTZXQgYXMgdGhlIGl0ZW0gaXMgYWxyZWFkeSBiZWluZyBoYW5kbGVkXG5cdFx0XHRcdGlmICgoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0XHQoc2VlbiA/Pz0gbmV3IFNldCgpKS5hZGQoY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Rhc2hlZC5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aXRlbSA9IGN1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZC5wdXNoKGl0ZW0pO1xuXHRcdHByZXYgPSBpdGVtO1xuXHRcdGN1cnJlbnQgPSBpdGVtLm5leHQ7XG5cdH1cblxuXHRpZiAoY3VycmVudCAhPT0gbnVsbCB8fCBzZWVuICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgdG9fZGVzdHJveSA9IHNlZW4gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJyYXlfZnJvbShzZWVuKTtcblxuXHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdFx0XHQvLyBJZiB0aGUgZWFjaCBibG9jayBpc24ndCBpbmVydCwgdGhlbiBpbmVydCBlZmZlY3RzIGFyZSBjdXJyZW50bHkgb3V0cm9pbmcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSB0cmFuc2l0aW9uIGlzIGZpbmlzaGVkXG5cdFx0XHRpZiAoKGN1cnJlbnQuZS5mICYgSU5FUlQpID09PSAwKSB7XG5cdFx0XHRcdHRvX2Rlc3Ryb3kucHVzaChjdXJyZW50KTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc3Ryb3lfbGVuZ3RoID0gdG9fZGVzdHJveS5sZW5ndGg7XG5cblx0XHRpZiAoZGVzdHJveV9sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgY29udHJvbGxlZF9hbmNob3IgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwICYmIGxlbmd0aCA9PT0gMCA/IGFuY2hvciA6IG51bGw7XG5cblx0XHRcdGlmIChpc19hbmltYXRlZCkge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8ubWVhc3VyZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRlc3Ryb3lfbGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHR0b19kZXN0cm95W2ldLmE/LmZpeCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHBhdXNlX2VmZmVjdHMoc3RhdGUsIHRvX2Rlc3Ryb3ksIGNvbnRyb2xsZWRfYW5jaG9yLCBpdGVtcyk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAodG9fYW5pbWF0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdFx0XHRmb3IgKGl0ZW0gb2YgdG9fYW5pbWF0ZSkge1xuXHRcdFx0XHRpdGVtLmE/LmFwcGx5KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmZpcnN0ID0gc3RhdGUuZmlyc3QgJiYgc3RhdGUuZmlyc3QuZTtcblx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5sYXN0ID0gcHJldiAmJiBwcmV2LmU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoSXRlbX0gaXRlbVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlX2l0ZW0oaXRlbSwgdmFsdWUsIGluZGV4LCB0eXBlKSB7XG5cdGlmICgodHlwZSAmIEVBQ0hfSVRFTV9SRUFDVElWRSkgIT09IDApIHtcblx0XHRpbnRlcm5hbF9zZXQoaXRlbS52LCB2YWx1ZSk7XG5cdH1cblxuXHRpZiAoKHR5cGUgJiBFQUNIX0lOREVYX1JFQUNUSVZFKSAhPT0gMCkge1xuXHRcdGludGVybmFsX3NldCgvKiogQHR5cGUge1ZhbHVlPG51bWJlcj59ICovIChpdGVtLmkpLCBpbmRleCk7XG5cdH0gZWxzZSB7XG5cdFx0aXRlbS5pID0gaW5kZXg7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtOb2RlfSBhbmNob3JcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IHByZXZcbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge3Vua25vd259IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyhhbmNob3I6IE5vZGUsIGl0ZW06IFYgfCBTb3VyY2U8Vj4sIGluZGV4OiBudW1iZXIgfCBWYWx1ZTxudW1iZXI+LCBjb2xsZWN0aW9uOiAoKSA9PiBWW10pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtFYWNoSXRlbX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2l0ZW0oXG5cdGFuY2hvcixcblx0c3RhdGUsXG5cdHByZXYsXG5cdG5leHQsXG5cdHZhbHVlLFxuXHRrZXksXG5cdGluZGV4LFxuXHRyZW5kZXJfZm4sXG5cdGZsYWdzLFxuXHRnZXRfY29sbGVjdGlvblxuKSB7XG5cdHZhciBwcmV2aW91c19lYWNoX2l0ZW0gPSBjdXJyZW50X2VhY2hfaXRlbTtcblx0dmFyIHJlYWN0aXZlID0gKGZsYWdzICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMDtcblx0dmFyIG11dGFibGUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fSU1NVVRBQkxFKSA9PT0gMDtcblxuXHR2YXIgdiA9IHJlYWN0aXZlID8gKG11dGFibGUgPyBtdXRhYmxlX3NvdXJjZSh2YWx1ZSkgOiBzb3VyY2UodmFsdWUpKSA6IHZhbHVlO1xuXHR2YXIgaSA9IChmbGFncyAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpID09PSAwID8gaW5kZXggOiBzb3VyY2UoaW5kZXgpO1xuXG5cdGlmIChERVYgJiYgcmVhY3RpdmUpIHtcblx0XHQvLyBGb3IgdHJhY2luZyBwdXJwb3Nlcywgd2UgbmVlZCB0byBsaW5rIHRoZSBzb3VyY2Ugc2lnbmFsIHdlIGNyZWF0ZSB3aXRoIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gKyBpbmRleCBzbyB0aGF0IHRyYWNpbmcgd29ya3MgYXMgaW50ZW5kZWRcblx0XHQvKiogQHR5cGUge1ZhbHVlfSAqLyAodikuZGVidWcgPSAoKSA9PiB7XG5cdFx0XHR2YXIgY29sbGVjdGlvbl9pbmRleCA9IHR5cGVvZiBpID09PSAnbnVtYmVyJyA/IGluZGV4IDogaS52O1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdGdldF9jb2xsZWN0aW9uKClbY29sbGVjdGlvbl9pbmRleF07XG5cdFx0fTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdHZhciBpdGVtID0ge1xuXHRcdGksXG5cdFx0dixcblx0XHRrOiBrZXksXG5cdFx0YTogbnVsbCxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZTogbnVsbCxcblx0XHRwcmV2LFxuXHRcdG5leHRcblx0fTtcblxuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG5cblx0dHJ5IHtcblx0XHRpdGVtLmUgPSBicmFuY2goKCkgPT4gcmVuZGVyX2ZuKGFuY2hvciwgdiwgaSwgZ2V0X2NvbGxlY3Rpb24pLCBoeWRyYXRpbmcpO1xuXG5cdFx0aXRlbS5lLnByZXYgPSBwcmV2ICYmIHByZXYuZTtcblx0XHRpdGVtLmUubmV4dCA9IG5leHQgJiYgbmV4dC5lO1xuXG5cdFx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHRcdHN0YXRlLmZpcnN0ID0gaXRlbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJldi5uZXh0ID0gaXRlbTtcblx0XHRcdHByZXYuZS5uZXh0ID0gaXRlbS5lO1xuXHRcdH1cblxuXHRcdGlmIChuZXh0ICE9PSBudWxsKSB7XG5cdFx0XHRuZXh0LnByZXYgPSBpdGVtO1xuXHRcdFx0bmV4dC5lLnByZXYgPSBpdGVtLmU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0gZmluYWxseSB7XG5cdFx0Y3VycmVudF9lYWNoX2l0ZW0gPSBwcmV2aW91c19lYWNoX2l0ZW07XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VhY2hJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gbmV4dFxuICogQHBhcmFtIHtUZXh0IHwgRWxlbWVudCB8IENvbW1lbnR9IGFuY2hvclxuICovXG5mdW5jdGlvbiBtb3ZlKGl0ZW0sIG5leHQsIGFuY2hvcikge1xuXHR2YXIgZW5kID0gaXRlbS5uZXh0ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChpdGVtLm5leHQuZS5ub2Rlc19zdGFydCkgOiBhbmNob3I7XG5cblx0dmFyIGRlc3QgPSBuZXh0ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChuZXh0LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXHR2YXIgbm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaXRlbS5lLm5vZGVzX3N0YXJ0KTtcblxuXHR3aGlsZSAobm9kZSAhPT0gZW5kKSB7XG5cdFx0dmFyIG5leHRfbm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0ZGVzdC5iZWZvcmUobm9kZSk7XG5cdFx0bm9kZSA9IG5leHRfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IHByZXZcbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKi9cbmZ1bmN0aW9uIGxpbmsoc3RhdGUsIHByZXYsIG5leHQpIHtcblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHRzdGF0ZS5maXJzdCA9IG5leHQ7XG5cdH0gZWxzZSB7XG5cdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHRwcmV2LmUubmV4dCA9IG5leHQgJiYgbmV4dC5lO1xuXHR9XG5cblx0aWYgKG5leHQgIT09IG51bGwpIHtcblx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdG5leHQuZS5wcmV2ID0gcHJldiAmJiBwcmV2LmU7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRklMRU5BTUUsIEhZRFJBVElPTl9FUlJPUiB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBkZXN0cm95X2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuLi9yZWNvbmNpbGVyLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgaGFzaCwgc2FuaXRpemVfbG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHNlcnZlcl9oYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tfaGFzaChlbGVtZW50LCBzZXJ2ZXJfaGFzaCwgdmFsdWUpIHtcblx0aWYgKCFzZXJ2ZXJfaGFzaCB8fCBzZXJ2ZXJfaGFzaCA9PT0gaGFzaChTdHJpbmcodmFsdWUgPz8gJycpKSkgcmV0dXJuO1xuXG5cdGxldCBsb2NhdGlvbjtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGxvYyA9IGVsZW1lbnQuX19zdmVsdGVfbWV0YT8ubG9jO1xuXHRpZiAobG9jKSB7XG5cdFx0bG9jYXRpb24gPSBgbmVhciAke2xvYy5maWxlfToke2xvYy5saW5lfToke2xvYy5jb2x1bW59YDtcblx0fSBlbHNlIGlmIChkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24/LltGSUxFTkFNRV0pIHtcblx0XHRsb2NhdGlvbiA9IGBpbiAke2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbltGSUxFTkFNRV19YDtcblx0fVxuXG5cdHcuaHlkcmF0aW9uX2h0bWxfY2hhbmdlZChzYW5pdGl6ZV9sb2NhdGlvbihsb2NhdGlvbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHQgfCBDb21tZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN2Z1xuICogQHBhcmFtIHtib29sZWFufSBtYXRobWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbChub2RlLCBnZXRfdmFsdWUsIHN2ZywgbWF0aG1sLCBza2lwX3dhcm5pbmcpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0dmFyIHZhbHVlID0gJyc7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCB1bmRlZmluZWR9ICovXG5cdHZhciBlZmZlY3Q7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGlmICh2YWx1ZSA9PT0gKHZhbHVlID0gZ2V0X3ZhbHVlKCkgPz8gJycpKSB7XG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChlZmZlY3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdGVmZmVjdCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgPT09ICcnKSByZXR1cm47XG5cblx0XHRlZmZlY3QgPSBicmFuY2goKCkgPT4ge1xuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHQvLyBXZSdyZSBkZWxpYmVyYXRlbHkgbm90IHRyeWluZyB0byByZXBhaXIgbWlzbWF0Y2hlcyBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50LFxuXHRcdFx0XHQvLyBhcyBpdCdzIGNvc3RseSBhbmQgZXJyb3ItcHJvbmUgKGFuZCBpdCdzIGFuIGVkZ2UgY2FzZSB0byBoYXZlIGEgbWlzbWF0Y2ggYW55d2F5KVxuXHRcdFx0XHR2YXIgaGFzaCA9IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YTtcblx0XHRcdFx0dmFyIG5leHQgPSBoeWRyYXRlX25leHQoKTtcblx0XHRcdFx0dmFyIGxhc3QgPSBuZXh0O1xuXG5cdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRuZXh0ICE9PSBudWxsICYmXG5cdFx0XHRcdFx0KG5leHQubm9kZVR5cGUgIT09IDggfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobmV4dCkuZGF0YSAhPT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGxhc3QgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobmV4dCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG5leHQgPT09IG51bGwpIHtcblx0XHRcdFx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdFx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChERVYgJiYgIXNraXBfd2FybmluZykge1xuXHRcdFx0XHRcdGNoZWNrX2hhc2goLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV4dC5wYXJlbnROb2RlKSwgaGFzaCwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbGFzdCk7XG5cdFx0XHRcdGFuY2hvciA9IHNldF9oeWRyYXRlX25vZGUobmV4dCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGh0bWwgPSB2YWx1ZSArICcnO1xuXHRcdFx0aWYgKHN2ZykgaHRtbCA9IGA8c3ZnPiR7aHRtbH08L3N2Zz5gO1xuXHRcdFx0ZWxzZSBpZiAobWF0aG1sKSBodG1sID0gYDxtYXRoPiR7aHRtbH08L21hdGg+YDtcblxuXHRcdFx0Ly8gRG9uJ3QgdXNlIGNyZWF0ZV9mcmFnbWVudF93aXRoX3NjcmlwdF9mcm9tX2h0bWwgaGVyZSBiZWNhdXNlIHRoYXQgd291bGQgbWVhbiBzY3JpcHQgdGFncyBhcmUgZXhlY3V0ZWQuXG5cdFx0XHQvLyBAaHRtbCBpcyBiYXNpY2FsbHkgYC5pbm5lckhUTUwgPSAuLi5gIGFuZCB0aGF0IGRvZXNuJ3QgZXhlY3V0ZSBzY3JpcHRzIGVpdGhlciBkdWUgdG8gc2VjdXJpdHkgcmVhc29ucy5cblx0XHRcdC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudCB8IEVsZW1lbnR9ICovXG5cdFx0XHR2YXIgbm9kZSA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaHRtbCk7XG5cblx0XHRcdGlmIChzdmcgfHwgbWF0aG1sKSB7XG5cdFx0XHRcdG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25fbm9kZXMoXG5cdFx0XHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKSxcblx0XHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChub2RlLmxhc3RDaGlsZClcblx0XHRcdCk7XG5cblx0XHRcdGlmIChzdmcgfHwgbWF0aG1sKSB7XG5cdFx0XHRcdHdoaWxlIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpIHtcblx0XHRcdFx0XHRhbmNob3IuYmVmb3JlKC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbmNob3IuYmVmb3JlKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cbiIsImltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0NvbW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gc2xvdF9wcm9wc1xuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IENvbW1lbnQpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xvdChhbmNob3IsICQkcHJvcHMsIG5hbWUsIHNsb3RfcHJvcHMsIGZhbGxiYWNrX2ZuKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBzbG90X2ZuID0gJCRwcm9wcy4kJHNsb3RzPy5bbmFtZV07XG5cdC8vIEludGVyb3A6IENhbiB1c2Ugc25pcHBldHMgdG8gZmlsbCBzbG90c1xuXHR2YXIgaXNfaW50ZXJvcCA9IGZhbHNlO1xuXHRpZiAoc2xvdF9mbiA9PT0gdHJ1ZSkge1xuXHRcdHNsb3RfZm4gPSAkJHByb3BzW25hbWUgPT09ICdkZWZhdWx0JyA/ICdjaGlsZHJlbicgOiBuYW1lXTtcblx0XHRpc19pbnRlcm9wID0gdHJ1ZTtcblx0fVxuXG5cdGlmIChzbG90X2ZuID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZmFsbGJhY2tfZm4gIT09IG51bGwpIHtcblx0XHRcdGZhbGxiYWNrX2ZuKGFuY2hvcik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHNsb3RfZm4oYW5jaG9yLCBpc19pbnRlcm9wID8gKCkgPT4gc2xvdF9wcm9wcyA6IHNsb3RfcHJvcHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfc2xvdHMocHJvcHMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gKi9cblx0Y29uc3Qgc2FuaXRpemVkID0ge307XG5cdGlmIChwcm9wcy5jaGlsZHJlbikgc2FuaXRpemVkLmRlZmF1bHQgPSB0cnVlO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy4kJHNsb3RzKSB7XG5cdFx0c2FuaXRpemVkW2tleV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiBzYW5pdGl6ZWQ7XG59XG4iLCIvKiogQGltcG9ydCB7IFNuaXBwZXQgfSBmcm9tICdzdmVsdGUnICovXG4vKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgR2V0dGVycyB9IGZyb20gJyNzaGFyZWQnICovXG5pbXBvcnQgeyBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYnJhbmNoLCBibG9jaywgZGVzdHJveV9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvblxufSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4uL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uLy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGdldF9maXJzdF9jaGlsZCwgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gU25pcHBldEZuXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBTbmlwcGV0Rm4gfCBudWxsIHwgdW5kZWZpbmVkfSBnZXRfc25pcHBldFxuICogQHBhcmFtIHsoKCkgPT4gYW55KVtdfSBhcmdzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuaXBwZXQobm9kZSwgZ2V0X3NuaXBwZXQsIC4uLmFyZ3MpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtTbmlwcGV0Rm4gfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xuXHQvLyBAdHMtaWdub3JlXG5cdHZhciBzbmlwcGV0ID0gbm9vcDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBzbmlwcGV0X2VmZmVjdDtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0aWYgKHNuaXBwZXQgPT09IChzbmlwcGV0ID0gZ2V0X3NuaXBwZXQoKSkpIHJldHVybjtcblxuXHRcdGlmIChzbmlwcGV0X2VmZmVjdCkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3Qoc25pcHBldF9lZmZlY3QpO1xuXHRcdFx0c25pcHBldF9lZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChERVYgJiYgc25pcHBldCA9PSBudWxsKSB7XG5cdFx0XHRlLmludmFsaWRfc25pcHBldCgpO1xuXHRcdH1cblxuXHRcdHNuaXBwZXRfZWZmZWN0ID0gYnJhbmNoKCgpID0+IC8qKiBAdHlwZSB7U25pcHBldEZufSAqLyAoc25pcHBldCkoYW5jaG9yLCAuLi5hcmdzKSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEluIGRldmVsb3BtZW50LCB3cmFwIHRoZSBzbmlwcGV0IGZ1bmN0aW9uIHNvIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb24sIGFuZCBzbyB0aGF0IHRoZVxuICogY29ycmVjdCBjb21wb25lbnQgY29udGV4dCBpcyBzZXQgZm9yIG93bmVyc2hpcCBjaGVja3NcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7KG5vZGU6IFRlbXBsYXRlTm9kZSwgLi4uYXJnczogYW55W10pID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwX3NuaXBwZXQoY29tcG9uZW50LCBmbikge1xuXHRyZXR1cm4gKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyBub2RlLCAvKiogQHR5cGUge2FueVtdfSAqLyAuLi5hcmdzKSA9PiB7XG5cdFx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9mdW5jdGlvbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0XHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uKGNvbXBvbmVudCk7XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGZuKG5vZGUsIC4uLmFyZ3MpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uKHByZXZpb3VzX2NvbXBvbmVudF9mdW5jdGlvbik7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNuaXBwZXQgcHJvZ3JhbW1hdGljYWxseVxuICogQHRlbXBsYXRlIHt1bmtub3duW119IFBhcmFtc1xuICogQHBhcmFtIHsoLi4ucGFyYW1zOiBHZXR0ZXJzPFBhcmFtcz4pID0+IHtcbiAqICAgcmVuZGVyOiAoKSA9PiBzdHJpbmdcbiAqICAgc2V0dXA/OiAoZWxlbWVudDogRWxlbWVudCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKVxuICogfX0gZm5cbiAqIEByZXR1cm5zIHtTbmlwcGV0PFBhcmFtcz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXdTbmlwcGV0KGZuKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHR5cGVzIGFyZSBhIGxpZVxuXHRyZXR1cm4gKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyBhbmNob3IsIC8qKiBAdHlwZSB7R2V0dGVyczxQYXJhbXM+fSAqLyAuLi5wYXJhbXMpID0+IHtcblx0XHR2YXIgc25pcHBldCA9IGZuKC4uLnBhcmFtcyk7XG5cblx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovXG5cdFx0dmFyIGVsZW1lbnQ7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaHRtbCA9IHNuaXBwZXQucmVuZGVyKCkudHJpbSgpO1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKTtcblx0XHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoZnJhZ21lbnQpKTtcblxuXHRcdFx0aWYgKERFViAmJiAoZ2V0X25leHRfc2libGluZyhlbGVtZW50KSAhPT0gbnVsbCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSkge1xuXHRcdFx0XHR3LmludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzdWx0ID0gc25pcHBldC5zZXR1cD8uKGVsZW1lbnQpO1xuXHRcdGFzc2lnbl9ub2RlcyhlbGVtZW50LCBlbGVtZW50KTtcblxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0ZWFyZG93bihyZXN1bHQpO1xuXHRcdH1cblx0fTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlLCBEb20sIEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYmxvY2ssIGJyYW5jaCwgcGF1c2VfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBQXG4gKiBAdGVtcGxhdGUgeyhwcm9wczogUCkgPT4gdm9pZH0gQ1xuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gQ30gZ2V0X2NvbXBvbmVudFxuICogQHBhcmFtIHsoYW5jaG9yOiBUZW1wbGF0ZU5vZGUsIGNvbXBvbmVudDogQykgPT4gRG9tIHwgdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudChub2RlLCBnZXRfY29tcG9uZW50LCByZW5kZXJfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtDfSAqL1xuXHR2YXIgY29tcG9uZW50O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGVmZmVjdDtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gKGNvbXBvbmVudCA9IGdldF9jb21wb25lbnQoKSkpIHJldHVybjtcblxuXHRcdGlmIChlZmZlY3QpIHtcblx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0ZWZmZWN0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoY29tcG9uZW50KSB7XG5cdFx0XHRlZmZlY3QgPSBicmFuY2goKCkgPT4gcmVuZGVyX2ZuKGFuY2hvciwgY29tcG9uZW50KSk7XG5cdFx0fVxuXHR9LCBFRkZFQ1RfVFJBTlNQQVJFTlQpO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRklMRU5BTUUsIE5BTUVTUEFDRV9TVkcgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX3RleHQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHBhdXNlX2VmZmVjdCxcblx0cmVzdW1lX2VmZmVjdFxufSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgc2V0X3Nob3VsZF9pbnRybyB9IGZyb20gJy4uLy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSwgc2V0X2N1cnJlbnRfZWFjaF9pdGVtIH0gZnJvbSAnLi9lYWNoLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBpc19yYXdfdGV4dF9lbGVtZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29tbWVudCB8IEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSBnZXRfdGFnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3N2Z1xuICogQHBhcmFtIHt1bmRlZmluZWQgfCAoKGVsZW1lbnQ6IEVsZW1lbnQsIGFuY2hvcjogTm9kZSB8IG51bGwpID0+IHZvaWQpfSByZW5kZXJfZm4sXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpfSBnZXRfbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8IFtudW1iZXIsIG51bWJlcl19IGxvY2F0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobm9kZSwgZ2V0X3RhZywgaXNfc3ZnLCByZW5kZXJfZm4sIGdldF9uYW1lc3BhY2UsIGxvY2F0aW9uKSB7XG5cdGxldCB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBmaWxlbmFtZSA9IERFViAmJiBsb2NhdGlvbiAmJiBjb21wb25lbnRfY29udGV4dD8uZnVuY3Rpb25bRklMRU5BTUVdO1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cblx0dmFyIHRhZztcblxuXHQvKiogQHR5cGUge3N0cmluZyB8IG51bGx9ICovXG5cdHZhciBjdXJyZW50X3RhZztcblxuXHQvKiogQHR5cGUge251bGwgfCBFbGVtZW50fSAqL1xuXHR2YXIgZWxlbWVudCA9IG51bGw7XG5cblx0aWYgKGh5ZHJhdGluZyAmJiBoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IDEpIHtcblx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGh5ZHJhdGluZyA/IGh5ZHJhdGVfbm9kZSA6IG5vZGUpO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGVmZmVjdDtcblxuXHQvKipcblx0ICogVGhlIGtleWVkIGB7I2VhY2ggLi4ufWAgaXRlbSBibG9jaywgaWYgYW55LCB0aGF0IHRoaXMgZWxlbWVudCBpcyBpbnNpZGUuXG5cdCAqIFdlIHRyYWNrIHRoaXMgc28gd2UgY2FuIHNldCBpdCB3aGVuIGNoYW5naW5nIHRoZSBlbGVtZW50LCBhbGxvd2luZyBhbnlcblx0ICogYGFuaW1hdGU6YCBkaXJlY3RpdmUgdG8gYmluZCBpdHNlbGYgdG8gdGhlIGNvcnJlY3QgYmxvY2tcblx0ICovXG5cdHZhciBlYWNoX2l0ZW1fYmxvY2sgPSBjdXJyZW50X2VhY2hfaXRlbTtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0Y29uc3QgbmV4dF90YWcgPSBnZXRfdGFnKCkgfHwgbnVsbDtcblx0XHR2YXIgbnMgPSBnZXRfbmFtZXNwYWNlID8gZ2V0X25hbWVzcGFjZSgpIDogaXNfc3ZnIHx8IG5leHRfdGFnID09PSAnc3ZnJyA/IE5BTUVTUEFDRV9TVkcgOiBudWxsO1xuXG5cdFx0Ly8gQXNzdW1wdGlvbjogTm9vbmUgY2hhbmdlcyB0aGUgbmFtZXNwYWNlIGJ1dCBub3QgdGhlIHRhZyAod2hhdCB3b3VsZCB0aGF0IGV2ZW4gbWVhbj8pXG5cdFx0aWYgKG5leHRfdGFnID09PSB0YWcpIHJldHVybjtcblxuXHRcdC8vIFNlZSBleHBsYW5hdGlvbiBvZiBgZWFjaF9pdGVtX2Jsb2NrYCBhYm92ZVxuXHRcdHZhciBwcmV2aW91c19lYWNoX2l0ZW0gPSBjdXJyZW50X2VhY2hfaXRlbTtcblx0XHRzZXRfY3VycmVudF9lYWNoX2l0ZW0oZWFjaF9pdGVtX2Jsb2NrKTtcblxuXHRcdGlmIChlZmZlY3QpIHtcblx0XHRcdGlmIChuZXh0X3RhZyA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBzdGFydCBvdXRyb1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0ZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0XHRjdXJyZW50X3RhZyA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChuZXh0X3RhZyA9PT0gY3VycmVudF90YWcpIHtcblx0XHRcdFx0Ly8gc2FtZSB0YWcgYXMgaXMgY3VycmVudGx5IHJlbmRlcmVkIOKAlCBhYm9ydCBvdXRyb1xuXHRcdFx0XHRyZXN1bWVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0YWcgaXMgY2hhbmdpbmcg4oCUIGRlc3Ryb3kgaW1tZWRpYXRlbHksIHJlbmRlciBjb250ZW50cyB3aXRob3V0IGludHJvIHRyYW5zaXRpb25zXG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdHNldF9zaG91bGRfaW50cm8oZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChuZXh0X3RhZyAmJiBuZXh0X3RhZyAhPT0gY3VycmVudF90YWcpIHtcblx0XHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRcdGVsZW1lbnQgPSBoeWRyYXRpbmdcblx0XHRcdFx0XHQ/IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGVsZW1lbnQpXG5cdFx0XHRcdFx0OiBuc1xuXHRcdFx0XHRcdFx0PyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIG5leHRfdGFnKVxuXHRcdFx0XHRcdFx0OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5leHRfdGFnKTtcblxuXHRcdFx0XHRpZiAoREVWICYmIGxvY2F0aW9uKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRcdFx0XHRcdGxvYzoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiBmaWxlbmFtZSxcblx0XHRcdFx0XHRcdFx0bGluZTogbG9jYXRpb25bMF0sXG5cdFx0XHRcdFx0XHRcdGNvbHVtbjogbG9jYXRpb25bMV1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJfZm4pIHtcblx0XHRcdFx0XHRpZiAoaHlkcmF0aW5nICYmIGlzX3Jhd190ZXh0X2VsZW1lbnQobmV4dF90YWcpKSB7XG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IGh5ZHJhdGlvbiBnbGl0Y2hlc1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJykpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIGh5ZHJhdGluZywgdXNlIHRoZSBleGlzdGluZyBzc3IgY29tbWVudCBhcyB0aGUgYW5jaG9yIHNvIHRoYXQgdGhlXG5cdFx0XHRcdFx0Ly8gaW5uZXIgb3BlbiBhbmQgY2xvc2UgbWV0aG9kcyBjYW4gcGljayB1cCB0aGUgZXhpc3Rpbmcgbm9kZXMgY29ycmVjdGx5XG5cdFx0XHRcdFx0dmFyIGNoaWxkX2FuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHRcdFx0XHRoeWRyYXRpbmcgPyBnZXRfZmlyc3RfY2hpbGQoZWxlbWVudCkgOiBlbGVtZW50LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZF9hbmNob3IgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGNoaWxkX2FuY2hvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYGNoaWxkX2FuY2hvcmAgaXMgdW5kZWZpbmVkIGlmIHRoaXMgaXMgYSB2b2lkIGVsZW1lbnQsIGJ1dCB3ZSBzdGlsbFxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gY2FsbCBgcmVuZGVyX2ZuYCBpbiBvcmRlciB0byBydW4gYWN0aW9ucyBldGMuIElmIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gY29udGFpbnMgY2hpbGRyZW4sIGl0J3MgYSB1c2VyIGVycm9yICh3aGljaCBpcyB3YXJuZWQgb24gZWxzZXdoZXJlKVxuXHRcdFx0XHRcdC8vIGFuZCB0aGUgRE9NIHdpbGwgYmUgc2lsZW50bHkgZGlzY2FyZGVkXG5cdFx0XHRcdFx0cmVuZGVyX2ZuKGVsZW1lbnQsIGNoaWxkX2FuY2hvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3ZSBkbyB0aGlzIGFmdGVyIGNhbGxpbmcgYHJlbmRlcl9mbmAgc28gdGhhdCBjaGlsZCBlZmZlY3RzIGRvbid0IG92ZXJyaWRlIGBub2Rlcy5lbmRgXG5cdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gZWxlbWVudDtcblxuXHRcdFx0XHRhbmNob3IuYmVmb3JlKGVsZW1lbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dGFnID0gbmV4dF90YWc7XG5cdFx0aWYgKHRhZykgY3VycmVudF90YWcgPSB0YWc7XG5cdFx0c2V0X3Nob3VsZF9pbnRybyh0cnVlKTtcblxuXHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShwcmV2aW91c19lYWNoX2l0ZW0pO1xuXHR9LCBFRkZFQ1RfVFJBTlNQQVJFTlQpO1xuXG5cdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdH1cbn1cbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IHsgZXNjYXBlX2h0bWwgfSBmcm9tICcuLi8uLi9lc2NhcGluZy5qcyc7XG5pbXBvcnQgeyBjbHN4IGFzIF9jbHN4IH0gZnJvbSAnY2xzeCc7XG5cbi8qKlxuICogYDxkaXYgdHJhbnNsYXRlPXtmYWxzZX0+YCBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYDxkaXYgdHJhbnNsYXRlPVwibm9cIj5gIGFuZCBfbm90X1xuICogYDxkaXYgdHJhbnNsYXRlPVwiZmFsc2VcIj5gLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIGA8ZGl2IHRyYW5zbGF0ZT1cInllc1wiPmAuIFRoZXJlXG4gKiBtYXkgYmUgb3RoZXIgb2RkIGNhc2VzIHRoYXQgbmVlZCB0byBiZSBhZGRlZCB0byB0aGlzIGxpc3QgaW4gZnV0dXJlXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgTWFwPGFueSwgc3RyaW5nPj59XG4gKi9cbmNvbnN0IHJlcGxhY2VtZW50cyA9IHtcblx0dHJhbnNsYXRlOiBuZXcgTWFwKFtcblx0XHRbdHJ1ZSwgJ3llcyddLFxuXHRcdFtmYWxzZSwgJ25vJ11cblx0XSlcbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc19ib29sZWFuXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUsIGlzX2Jvb2xlYW4gPSBmYWxzZSkge1xuXHRpZiAodmFsdWUgPT0gbnVsbCB8fCAoIXZhbHVlICYmIGlzX2Jvb2xlYW4pIHx8ICh2YWx1ZSA9PT0gJycgJiYgbmFtZSA9PT0gJ2NsYXNzJykpIHJldHVybiAnJztcblx0Y29uc3Qgbm9ybWFsaXplZCA9IChuYW1lIGluIHJlcGxhY2VtZW50cyAmJiByZXBsYWNlbWVudHNbbmFtZV0uZ2V0KHZhbHVlKSkgfHwgdmFsdWU7XG5cdGNvbnN0IGFzc2lnbm1lbnQgPSBpc19ib29sZWFuID8gJycgOiBgPVwiJHtlc2NhcGVfaHRtbChub3JtYWxpemVkLCB0cnVlKX1cImA7XG5cdHJldHVybiBgICR7bmFtZX0ke2Fzc2lnbm1lbnR9YDtcbn1cblxuLyoqXG4gKiBTbWFsbCB3cmFwcGVyIGFyb3VuZCBjbHN4IHRvIHByZXNlcnZlIFN2ZWx0ZSdzICh3ZWlyZCkgaGFuZGxpbmcgb2YgZmFsc3kgdmFsdWVzLlxuICogVE9ETyBTdmVsdGUgNiByZXZpc2l0IHRoaXMsIGFuZCBsaWtlbHkgdHVybiBhbGwgZmFsc3kgdmFsdWVzIGludG8gdGhlIGVtcHR5IHN0cmluZyAod2hhdCBjbHN4IGFsc28gZG9lcylcbiAqIEBwYXJhbSAge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsc3godmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gX2Nsc3godmFsdWUpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB2YWx1ZSA/PyAnJztcblx0fVxufVxuIiwiaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBoeWRyYXRpbmcsIHNldF9oeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3JzLCBnZXRfcHJvdG90eXBlX29mIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9ldmVudCwgZGVsZWdhdGUgfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgeyBhZGRfZm9ybV9yZXNldF9saXN0ZW5lciwgYXV0b2ZvY3VzIH0gZnJvbSAnLi9taXNjLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgTE9BRElOR19BVFRSX1NZTUJPTCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9pZGxlX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IGlzX2NhcHR1cmVfZXZlbnQsIGlzX2RlbGVnYXRlZCwgbm9ybWFsaXplX2F0dHJpYnV0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBjbHN4IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2F0dHJpYnV0ZXMuanMnO1xuXG4vKipcbiAqIFRoZSB2YWx1ZS9jaGVja2VkIGF0dHJpYnV0ZSBpbiB0aGUgdGVtcGxhdGUgYWN0dWFsbHkgY29ycmVzcG9uZHMgdG8gdGhlIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSwgc28gd2UgbmVlZFxuICogdG8gcmVtb3ZlIGl0IHVwb24gaHlkcmF0aW9uIHRvIGF2b2lkIGEgYnVnIHdoZW4gc29tZW9uZSByZXNldHMgdGhlIGZvcm0gdmFsdWUuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9pbnB1dF9kZWZhdWx0cyhpbnB1dCkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdHZhciBhbHJlYWR5X3JlbW92ZWQgPSBmYWxzZTtcblxuXHQvLyBXZSB0cnkgYW5kIHJlbW92ZSB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGxhdGVyLCByYXRoZXIgdGhhbiBzeW5jIGR1cmluZyBoeWRyYXRpb24uXG5cdC8vIERvaW5nIGl0IHN5bmMgZHVyaW5nIGh5ZHJhdGlvbiBoYXMgYSBuZWdhdGl2ZSBpbXBhY3Qgb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWZlcnJpbmcgdGhlXG5cdC8vIHdvcmsgaW4gYW4gaWRsZSB0YXNrIGFsbGV2aWF0ZXMgdGhpcyBncmVhdGx5LiBJZiBhIGZvcm0gcmVzZXQgZXZlbnQgY29tZXMgaW4gYmVmb3JlXG5cdC8vIHRoZSBpZGxlIGNhbGxiYWNrLCB0aGVuIHdlIGVuc3VyZSB0aGUgaW5wdXQgZGVmYXVsdHMgYXJlIGNsZWFyZWQganVzdCBiZWZvcmUuXG5cdHZhciByZW1vdmVfZGVmYXVsdHMgPSAoKSA9PiB7XG5cdFx0aWYgKGFscmVhZHlfcmVtb3ZlZCkgcmV0dXJuO1xuXHRcdGFscmVhZHlfcmVtb3ZlZCA9IHRydWU7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGF0dHJpYnV0ZXMgYnV0IHByZXNlcnZlIHRoZSB2YWx1ZXNcblx0XHRpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcblx0XHRcdHNldF9hdHRyaWJ1dGUoaW5wdXQsICd2YWx1ZScsIG51bGwpO1xuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcblx0XHRcdHZhciBjaGVja2VkID0gaW5wdXQuY2hlY2tlZDtcblx0XHRcdHNldF9hdHRyaWJ1dGUoaW5wdXQsICdjaGVja2VkJywgbnVsbCk7XG5cdFx0XHRpbnB1dC5jaGVja2VkID0gY2hlY2tlZDtcblx0XHR9XG5cdH07XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRpbnB1dC5fX29uX3IgPSByZW1vdmVfZGVmYXVsdHM7XG5cdHF1ZXVlX2lkbGVfdGFzayhyZW1vdmVfZGVmYXVsdHMpO1xuXHRhZGRfZm9ybV9yZXNldF9saXN0ZW5lcigpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgYXR0cmlidXRlcyA9IChlbGVtZW50Ll9fYXR0cmlidXRlcyA/Pz0ge30pO1xuXG5cdGlmIChcblx0XHRhdHRyaWJ1dGVzLnZhbHVlID09PVxuXHRcdFx0KGF0dHJpYnV0ZXMudmFsdWUgPVxuXHRcdFx0XHQvLyB0cmVhdCBudWxsIGFuZCB1bmRlZmluZWQgdGhlIHNhbWUgZm9yIHRoZSBpbml0aWFsIHZhbHVlXG5cdFx0XHRcdHZhbHVlID8/IHVuZGVmaW5lZCkgfHxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0Ly8gYHByb2dyZXNzYCBlbGVtZW50cyBhbHdheXMgbmVlZCB0aGVpciB2YWx1ZSBzZXQgd2hlbiBpdCdzIGAwYFxuXHRcdChlbGVtZW50LnZhbHVlID09PSB2YWx1ZSAmJiAodmFsdWUgIT09IDAgfHwgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ1BST0dSRVNTJykpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC52YWx1ZSA9IHZhbHVlID8/ICcnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2hlY2tlZChlbGVtZW50LCBjaGVja2VkKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0dmFyIGF0dHJpYnV0ZXMgPSAoZWxlbWVudC5fX2F0dHJpYnV0ZXMgPz89IHt9KTtcblxuXHRpZiAoXG5cdFx0YXR0cmlidXRlcy5jaGVja2VkID09PVxuXHRcdChhdHRyaWJ1dGVzLmNoZWNrZWQgPVxuXHRcdFx0Ly8gdHJlYXQgbnVsbCBhbmQgdW5kZWZpbmVkIHRoZSBzYW1lIGZvciB0aGUgaW5pdGlhbCB2YWx1ZVxuXHRcdFx0Y2hlY2tlZCA/PyB1bmRlZmluZWQpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC5jaGVja2VkID0gY2hlY2tlZDtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSBvbiBhbiBgb3B0aW9uYCBlbGVtZW50LlxuICogTm90IHNldCB0aHJvdWdoIHRoZSBwcm9wZXJ0eSBiZWNhdXNlIHRoYXQgZG9lc24ndCByZWZsZWN0IHRvIHRoZSBET00sXG4gKiB3aGljaCBtZWFucyBpdCB3b3VsZG4ndCBiZSB0YWtlbiBpbnRvIGFjY291bnQgd2hlbiBhIGZvcm0gaXMgcmVzZXQuXG4gKiBAcGFyYW0ge0hUTUxPcHRpb25FbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc2VsZWN0ZWQoZWxlbWVudCwgc2VsZWN0ZWQpIHtcblx0aWYgKHNlbGVjdGVkKSB7XG5cdFx0Ly8gVGhlIHNlbGVjdGVkIG9wdGlvbiBjb3VsZCd2ZSBjaGFuZ2VkIHZpYSB1c2VyIHNlbGVjdGlvbiwgYW5kXG5cdFx0Ly8gc2V0dGluZyB0aGUgdmFsdWUgd2l0aG91dCB0aGlzIGNoZWNrIHdvdWxkIHNldCBpdCBiYWNrLlxuXHRcdGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICcnKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IGNoZWNrZWQgcHJvcGVydHkgd2l0aG91dCBpbmZsdWVuY2luZyB0aGUgY3VycmVudCBjaGVja2VkIHByb3BlcnR5LlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X2NoZWNrZWQoZWxlbWVudCwgY2hlY2tlZCkge1xuXHRjb25zdCBleGlzdGluZ192YWx1ZSA9IGVsZW1lbnQuY2hlY2tlZDtcblx0ZWxlbWVudC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XG5cdGVsZW1lbnQuY2hlY2tlZCA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGRlZmF1bHQgdmFsdWUgcHJvcGVydHkgd2l0aG91dCBpbmZsdWVuY2luZyB0aGUgY3VycmVudCB2YWx1ZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RlZmF1bHRfdmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LnZhbHVlO1xuXHRlbGVtZW50LmRlZmF1bHRWYWx1ZSA9IHZhbHVlO1xuXHRlbGVtZW50LnZhbHVlID0gZXhpc3RpbmdfdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUsIHNraXBfd2FybmluZykge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cblx0XHRpZiAoXG5cdFx0XHRhdHRyaWJ1dGUgPT09ICdzcmMnIHx8XG5cdFx0XHRhdHRyaWJ1dGUgPT09ICdzcmNzZXQnIHx8XG5cdFx0XHQoYXR0cmlidXRlID09PSAnaHJlZicgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0xJTksnKVxuXHRcdCkge1xuXHRcdFx0aWYgKCFza2lwX3dhcm5pbmcpIHtcblx0XHRcdFx0Y2hlY2tfc3JjX2luX2Rldl9oeWRyYXRpb24oZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSA/PyAnJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIHJlc2V0IHRoZXNlIGF0dHJpYnV0ZXMsIHRoZXkgd291bGQgcmVzdWx0IGluIGFub3RoZXIgbmV0d29yayByZXF1ZXN0LCB3aGljaCB3ZSB3YW50IHRvIGF2b2lkLlxuXHRcdFx0Ly8gV2UgYXNzdW1lIHRoZXkgYXJlIHRoZSBzYW1lIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIgYXMgY2hlY2tpbmcgaWYgdGhleSBhcmUgZXF1YWwgaXMgZXhwZW5zaXZlXG5cdFx0XHQvLyAod2UgY2FuJ3QganVzdCBjb21wYXJlIHRoZSBzdHJpbmdzIGFzIHRoZXkgY2FuIGJlIGRpZmZlcmVudCBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyIGJ1dCByZXN1bHQgaW4gdGhlXG5cdFx0XHQvLyBzYW1lIHVybCwgc28gd2Ugd291bGQgbmVlZCB0byBjcmVhdGUgaGlkZGVuIGFuY2hvciBlbGVtZW50cyB0byBjb21wYXJlIHRoZW0pXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9PT0gKGF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlKSkgcmV0dXJuO1xuXG5cdGlmIChhdHRyaWJ1dGUgPT09ICdzdHlsZScgJiYgJ19fc3R5bGVzJyBpbiBlbGVtZW50KSB7XG5cdFx0Ly8gcmVzZXQgc3R5bGVzIHRvIGZvcmNlIHN0eWxlOiBkaXJlY3RpdmUgdG8gdXBkYXRlXG5cdFx0ZWxlbWVudC5fX3N0eWxlcyA9IHt9O1xuXHR9XG5cblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ2xvYWRpbmcnKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnRbTE9BRElOR19BVFRSX1NZTUJPTF0gPSB2YWx1ZTtcblx0fVxuXG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIGdldF9zZXR0ZXJzKGVsZW1lbnQpLmluY2x1ZGVzKGF0dHJpYnV0ZSkpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZWxlbWVudFthdHRyaWJ1dGVdID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfeGxpbmtfYXR0cmlidXRlKGRvbSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRkb20uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHQvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNldHRpbmcgY3VzdG9tIGVsZW1lbnQgcHJvcHMsIHdoaWNoIGNhblxuXHQvLyBpbnZva2UgbGlmZWN5Y2xlIG1ldGhvZHMgb24gb3RoZXIgY3VzdG9tIGVsZW1lbnRzLCBkb2VzIG5vdCBhbHNvXG5cdC8vIGFzc29jaWF0ZSB0aG9zZSBsaWZlY3ljbGUgbWV0aG9kcyB3aXRoIHRoZSBjdXJyZW50IGFjdGl2ZSByZWFjdGlvblxuXHQvLyBvciBlZmZlY3Rcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0Ly8gSWYgd2UncmUgaHlkcmF0aW5nIGJ1dCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgZnJvbSBTdmVsdGUsIGFuZCBpdCBhbHJlYWR5IHNjYWZmb2xkZWQsXG5cdC8vIHRoZW4gaXQgbWlnaHQgcnVuIGJsb2NrIGxvZ2ljIGluIGh5ZHJhdGlvbiBtb2RlLCB3aGljaCB3ZSBoYXZlIHRvIHByZXZlbnQuXG5cdGxldCB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdH1cblxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0dHJ5IHtcblx0XHRpZiAoXG5cdFx0XHQvLyBEb24ndCBjb21wdXRlIHNldHRlcnMgZm9yIGN1c3RvbSBlbGVtZW50cyB3aGlsZSB0aGV5IGFyZW4ndCByZWdpc3RlcmVkIHlldCxcblx0XHRcdC8vIGJlY2F1c2UgZHVyaW5nIHRoZWlyIHVwZ3JhZGUvaW5zdGFudGlhdGlvbiB0aGV5IG1pZ2h0IGFkZCBtb3JlIHNldHRlcnMuXG5cdFx0XHQvLyBJbnN0ZWFkLCBmYWxsIGJhY2sgdG8gYSBzaW1wbGUgXCJhbiBvYmplY3QsIHRoZW4gc2V0IGFzIHByb3BlcnR5XCIgaGV1cmlzdGljLlxuXHRcdFx0c2V0dGVyc19jYWNoZS5oYXMobm9kZS5ub2RlTmFtZSkgfHxcblx0XHRcdC8vIGN1c3RvbUVsZW1lbnRzIG1heSBub3QgYmUgYXZhaWxhYmxlIGluIGJyb3dzZXIgZXh0ZW5zaW9uIGNvbnRleHRzXG5cdFx0XHQhY3VzdG9tRWxlbWVudHMgfHxcblx0XHRcdGN1c3RvbUVsZW1lbnRzLmdldChub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0PyBnZXRfc2V0dGVycyhub2RlKS5pbmNsdWRlcyhwcm9wKVxuXHRcdFx0XHQ6IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdG5vZGVbcHJvcF0gPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gV2UgZGlkIGdldHRlcnMgZXRjIGNoZWNrcyBhbHJlYWR5LCBzdHJpbmdpZnkgYmVmb3JlIHBhc3NpbmcgdG8gc2V0X2F0dHJpYnV0ZVxuXHRcdFx0Ly8gdG8gZW5zdXJlIGl0IGRvZXNuJ3QgaW52b2tlIHRoZSBzYW1lIGxvZ2ljIGFnYWluLCBhbmQgcG90ZW50aWFsbHkgcG9wdWxhdGluZ1xuXHRcdFx0Ly8gdGhlIHNldHRlcnMgY2FjaGUgdG9vIGVhcmx5LlxuXHRcdFx0c2V0X2F0dHJpYnV0ZShub2RlLCBwcm9wLCB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpKTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBTcHJlYWRzIGF0dHJpYnV0ZXMgb250byBhIERPTSBlbGVtZW50LCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBjdXJyZW50bHkgc2V0IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gZWxlbWVudFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkfSBwcmV2XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IG5leHQgTmV3IGF0dHJpYnV0ZXMgLSB0aGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhpcyBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3NzX2hhc2hdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX2N1c3RvbV9lbGVtZW50XVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhcblx0ZWxlbWVudCxcblx0cHJldixcblx0bmV4dCxcblx0Y3NzX2hhc2gsXG5cdHByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlID0gZmFsc2UsXG5cdGlzX2N1c3RvbV9lbGVtZW50ID0gZmFsc2UsXG5cdHNraXBfd2FybmluZyA9IGZhbHNlXG4pIHtcblx0Ly8gSWYgd2UncmUgaHlkcmF0aW5nIGJ1dCB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgZnJvbSBTdmVsdGUsIGFuZCBpdCBhbHJlYWR5IHNjYWZmb2xkZWQsXG5cdC8vIHRoZW4gaXQgbWlnaHQgcnVuIGJsb2NrIGxvZ2ljIGluIGh5ZHJhdGlvbiBtb2RlLCB3aGljaCB3ZSBoYXZlIHRvIHByZXZlbnQuXG5cdGxldCBpc19oeWRyYXRpbmdfY3VzdG9tX2VsZW1lbnQgPSBoeWRyYXRpbmcgJiYgaXNfY3VzdG9tX2VsZW1lbnQ7XG5cdGlmIChpc19oeWRyYXRpbmdfY3VzdG9tX2VsZW1lbnQpIHtcblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0fVxuXG5cdHZhciBjdXJyZW50ID0gcHJldiB8fCB7fTtcblx0dmFyIGlzX29wdGlvbl9lbGVtZW50ID0gZWxlbWVudC50YWdOYW1lID09PSAnT1BUSU9OJztcblxuXHRmb3IgKHZhciBrZXkgaW4gcHJldikge1xuXHRcdGlmICghKGtleSBpbiBuZXh0KSkge1xuXHRcdFx0bmV4dFtrZXldID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRpZiAobmV4dC5jbGFzcykge1xuXHRcdG5leHQuY2xhc3MgPSBjbHN4KG5leHQuY2xhc3MpO1xuXHR9XG5cblx0aWYgKGNzc19oYXNoICE9PSB1bmRlZmluZWQpIHtcblx0XHRuZXh0LmNsYXNzID0gbmV4dC5jbGFzcyA/IG5leHQuY2xhc3MgKyAnICcgKyBjc3NfaGFzaCA6IGNzc19oYXNoO1xuXHR9XG5cblx0dmFyIHNldHRlcnMgPSBnZXRfc2V0dGVycyhlbGVtZW50KTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gKiovIChlbGVtZW50Ll9fYXR0cmlidXRlcyA/Pz0ge30pO1xuXG5cdC8vIHNpbmNlIGtleSBpcyBjYXB0dXJlZCB3ZSB1c2UgY29uc3Rcblx0Zm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuXHRcdC8vIGxldCBpbnN0ZWFkIG9mIHZhciBiZWNhdXNlIHJlZmVyZW5jZWQgaW4gYSBjbG9zdXJlXG5cdFx0bGV0IHZhbHVlID0gbmV4dFtrZXldO1xuXG5cdFx0Ly8gVXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gZG8gdGhpcyBmb3IgdGhlIGluaXRpYWwgdmFsdWUsIHRvbywgZXZlbiBpZiBpdCdzIHVuZGVmaW5lZCxcblx0XHQvLyBhbmQgdGhpcyB3b3VsZG4ndCBiZSByZWFjaGVkIGluIGNhc2Ugb2YgdW5kZWZpbmVkIGJlY2F1c2Ugb2YgdGhlIGVxdWFsaXR5IGNoZWNrIGJlbG93XG5cdFx0aWYgKGlzX29wdGlvbl9lbGVtZW50ICYmIGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHQvLyBUaGUgPG9wdGlvbj4gZWxlbWVudCBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHJlbW92aW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgbWVhbnNcblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHRleHQgY29udGVudCBvZiB0aGUgb3B0aW9uIGVsZW1lbnQsIGFuZCBzZXR0aW5nIHRoZSB2YWx1ZVxuXHRcdFx0Ly8gdG8gbnVsbCBvciB1bmRlZmluZWQgbWVhbnMgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgc3RyaW5nIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIuXG5cdFx0XHQvLyBUbyBhbGlnbiB3aXRoIGhvdyB3ZSBoYW5kbGUgdGhpcyBjYXNlIGluIG5vbi1zcHJlYWQtc2NlbmFyaW9zLCB0aGlzIGxvZ2ljIGlzIG5lZWRlZC5cblx0XHRcdC8vIFRoZXJlJ3MgYSBzdXBlci1lZGdlLWNhc2UgYnVnIGhlcmUgdGhhdCBpcyBsZWZ0IGluIGluIGZhdm9yIG9mIHNtYWxsZXIgY29kZSBzaXplOlxuXHRcdFx0Ly8gQmVjYXVzZSBvZiB0aGUgXCJzZXQgbWlzc2luZyBwcm9wcyB0byBudWxsXCIgbG9naWMgYWJvdmUsIHdlIGNhbid0IGRpZmZlcmVudGlhdGVcblx0XHRcdC8vIGJldHdlZW4gYSBtaXNzaW5nIHZhbHVlIGFuZCBhbiBleHBsaWNpdGx5IHNldCB2YWx1ZSBvZiBudWxsIG9yIHVuZGVmaW5lZC4gVGhhdCBtZWFuc1xuXHRcdFx0Ly8gdGhhdCBvbmNlIHNldCwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvZiBhbiA8b3B0aW9uPiBlbGVtZW50IGNhbid0IGJlIHJlbW92ZWQuIFRoaXMgaXNcblx0XHRcdC8vIGEgdmVyeSByYXJlIGVkZ2UgY2FzZSwgYW5kIHJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgYWx0b2dldGhlciBpc24ndCBwb3NzaWJsZSBlaXRoZXJcblx0XHRcdC8vIGZvciB0aGUgPG9wdGlvbiB2YWx1ZT17dW5kZWZpbmVkfT4gY2FzZSwgc28gd2UncmUgbm90IGxvc2luZyBhbnkgZnVuY3Rpb25hbGl0eSBoZXJlLlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQuX192YWx1ZSA9ICcnO1xuXHRcdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YXIgcHJldl92YWx1ZSA9IGN1cnJlbnRba2V5XTtcblx0XHRpZiAodmFsdWUgPT09IHByZXZfdmFsdWUpIGNvbnRpbnVlO1xuXG5cdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cblx0XHR2YXIgcHJlZml4ID0ga2V5WzBdICsga2V5WzFdOyAvLyB0aGlzIGlzIGZhc3RlciB0aGFuIGtleS5zbGljZSgwLCAyKVxuXHRcdGlmIChwcmVmaXggPT09ICckJCcpIGNvbnRpbnVlO1xuXG5cdFx0aWYgKHByZWZpeCA9PT0gJ29uJykge1xuXHRcdFx0LyoqIEB0eXBlIHt7IGNhcHR1cmU/OiB0cnVlIH19ICovXG5cdFx0XHRjb25zdCBvcHRzID0ge307XG5cdFx0XHRjb25zdCBldmVudF9oYW5kbGVfa2V5ID0gJyQkJyArIGtleTtcblx0XHRcdGxldCBldmVudF9uYW1lID0ga2V5LnNsaWNlKDIpO1xuXHRcdFx0dmFyIGRlbGVnYXRlZCA9IGlzX2RlbGVnYXRlZChldmVudF9uYW1lKTtcblxuXHRcdFx0aWYgKGlzX2NhcHR1cmVfZXZlbnQoZXZlbnRfbmFtZSkpIHtcblx0XHRcdFx0ZXZlbnRfbmFtZSA9IGV2ZW50X25hbWUuc2xpY2UoMCwgLTcpO1xuXHRcdFx0XHRvcHRzLmNhcHR1cmUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRlbGVnYXRlZCAmJiBwcmV2X3ZhbHVlKSB7XG5cdFx0XHRcdC8vIExpc3RlbmluZyB0byBzYW1lIGV2ZW50IGJ1dCBkaWZmZXJlbnQgaGFuZGxlciAtPiBvdXIgaGFuZGxlIGZ1bmN0aW9uIGJlbG93IHRha2VzIGNhcmUgb2YgdGhpc1xuXHRcdFx0XHQvLyBJZiB3ZSB3ZXJlIHRvIHJlbW92ZSBhbmQgYWRkIGxpc3RlbmVycyBpbiB0aGlzIGNhc2UsIGl0IGNvdWxkIGhhcHBlbiB0aGF0IHRoZSBldmVudCBpcyBcInN3YWxsb3dlZFwiXG5cdFx0XHRcdC8vICh0aGUgYnJvd3NlciBzZWVtcyB0byBub3Qga25vdyB5ZXQgdGhhdCBhIG5ldyBvbmUgZXhpc3RzIG5vdykgYW5kIGRvZXNuJ3QgcmVhY2ggdGhlIGhhbmRsZXJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMTE5MDNcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldLCBvcHRzKTtcblx0XHRcdFx0Y3VycmVudFtldmVudF9oYW5kbGVfa2V5XSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICghZGVsZWdhdGVkKSB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0ICogQHRoaXMge2FueX1cblx0XHRcdFx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldnRcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRmdW5jdGlvbiBoYW5kbGUoZXZ0KSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50W2tleV0uY2FsbCh0aGlzLCBldnQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBjcmVhdGVfZXZlbnQoZXZlbnRfbmFtZSwgZWxlbWVudCwgaGFuZGxlLCBvcHRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0ZWxlbWVudFtgX18ke2V2ZW50X25hbWV9YF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWxlZ2F0ZShbZXZlbnRfbmFtZV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnICYmIHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHZhbHVlICsgJyc7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdhdXRvZm9jdXMnKSB7XG5cdFx0XHRhdXRvZm9jdXMoLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGVsZW1lbnQpLCBCb29sZWFuKHZhbHVlKSk7XG5cdFx0fSBlbHNlIGlmICghaXNfY3VzdG9tX2VsZW1lbnQgJiYgKGtleSA9PT0gJ19fdmFsdWUnIHx8IChrZXkgPT09ICd2YWx1ZScgJiYgdmFsdWUgIT0gbnVsbCkpKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFdlJ3JlIG5vdCBydW5uaW5nIHRoaXMgZm9yIGN1c3RvbSBlbGVtZW50cyBiZWNhdXNlIF9fdmFsdWUgaXMgYWN0dWFsbHlcblx0XHRcdC8vIGhvdyBMaXQgc3RvcmVzIHRoZSBjdXJyZW50IHZhbHVlIG9uIHRoZSBlbGVtZW50LCBhbmQgbWVzc2luZyB3aXRoIHRoYXQgd291bGQgYnJlYWsgdGhpbmdzLlxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQuX192YWx1ZSA9IHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2VsZWN0ZWQnICYmIGlzX29wdGlvbl9lbGVtZW50KSB7XG5cdFx0XHRzZXRfc2VsZWN0ZWQoLyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudH0gKi8gKGVsZW1lbnQpLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuYW1lID0ga2V5O1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZSkge1xuXHRcdFx0XHRuYW1lID0gbm9ybWFsaXplX2F0dHJpYnV0ZShuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGlzX2RlZmF1bHQgPSBuYW1lID09PSAnZGVmYXVsdFZhbHVlJyB8fCBuYW1lID09PSAnZGVmYXVsdENoZWNrZWQnO1xuXG5cdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaXNfY3VzdG9tX2VsZW1lbnQgJiYgIWlzX2RlZmF1bHQpIHtcblx0XHRcdFx0YXR0cmlidXRlc1trZXldID0gbnVsbDtcblxuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnY2hlY2tlZCcpIHtcblx0XHRcdFx0XHQvLyByZW1vdmluZyB2YWx1ZS9jaGVja2VkIGFsc28gcmVtb3ZlcyBkZWZhdWx0VmFsdWUvZGVmYXVsdENoZWNrZWQg4oCUIHByZXNlcnZlXG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqLyAoZWxlbWVudCk7XG5cdFx0XHRcdFx0Y29uc3QgdXNlX2RlZmF1bHQgPSBwcmV2ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0aWYgKG5hbWUgPT09ICd2YWx1ZScpIHtcblx0XHRcdFx0XHRcdGxldCBwcmV2aW91cyA9IGlucHV0LmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0XHRcdGlucHV0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHRcdFx0XHRcdGlucHV0LmRlZmF1bHRWYWx1ZSA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0aW5wdXQudmFsdWUgPSBpbnB1dC5fX3ZhbHVlID0gdXNlX2RlZmF1bHQgPyBwcmV2aW91cyA6IG51bGw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxldCBwcmV2aW91cyA9IGlucHV0LmRlZmF1bHRDaGVja2VkO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdENoZWNrZWQgPSBwcmV2aW91cztcblx0XHRcdFx0XHRcdGlucHV0LmNoZWNrZWQgPSB1c2VfZGVmYXVsdCA/IHByZXZpb3VzIDogZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGlzX2RlZmF1bHQgfHxcblx0XHRcdFx0KHNldHRlcnMuaW5jbHVkZXMobmFtZSkgJiYgKGlzX2N1c3RvbV9lbGVtZW50IHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0ZWxlbWVudFtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChrZXkgPT09ICdzdHlsZScgJiYgJ19fc3R5bGVzJyBpbiBlbGVtZW50KSB7XG5cdFx0XHQvLyByZXNldCBzdHlsZXMgdG8gZm9yY2Ugc3R5bGU6IGRpcmVjdGl2ZSB0byB1cGRhdGVcblx0XHRcdGVsZW1lbnQuX19zdHlsZXMgPSB7fTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50KSB7XG5cdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0fVxuXG5cdHJldHVybiBjdXJyZW50O1xufVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIHN0cmluZ1tdPn0gKi9cbnZhciBzZXR0ZXJzX2NhY2hlID0gbmV3IE1hcCgpO1xuXG4vKiogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICovXG5mdW5jdGlvbiBnZXRfc2V0dGVycyhlbGVtZW50KSB7XG5cdHZhciBzZXR0ZXJzID0gc2V0dGVyc19jYWNoZS5nZXQoZWxlbWVudC5ub2RlTmFtZSk7XG5cdGlmIChzZXR0ZXJzKSByZXR1cm4gc2V0dGVycztcblx0c2V0dGVyc19jYWNoZS5zZXQoZWxlbWVudC5ub2RlTmFtZSwgKHNldHRlcnMgPSBbXSkpO1xuXG5cdHZhciBkZXNjcmlwdG9ycztcblx0dmFyIHByb3RvID0gZWxlbWVudDsgLy8gSW4gdGhlIGNhc2Ugb2YgY3VzdG9tIGVsZW1lbnRzIHRoZXJlIG1pZ2h0IGJlIHNldHRlcnMgb24gdGhlIGluc3RhbmNlXG5cdHZhciBlbGVtZW50X3Byb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG5cblx0Ly8gU3RvcCBhdCBFbGVtZW50LCBmcm9tIHRoZXJlIG9uIHRoZXJlJ3Mgb25seSB1bm5lY2Vzc2FyeSBzZXR0ZXJzIHdlJ3JlIG5vdCBpbnRlcmVzdGVkIGluXG5cdC8vIERvIG5vdCB1c2UgY29udHJ1Y3Rvci5uYW1lIGhlcmUgYXMgdGhhdCdzIHVucmVsaWFibGUgaW4gc29tZSBicm93c2VyIGVudmlyb25tZW50c1xuXHR3aGlsZSAoZWxlbWVudF9wcm90byAhPT0gcHJvdG8pIHtcblx0XHRkZXNjcmlwdG9ycyA9IGdldF9kZXNjcmlwdG9ycyhwcm90byk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZGVzY3JpcHRvcnMpIHtcblx0XHRcdGlmIChkZXNjcmlwdG9yc1trZXldLnNldCkge1xuXHRcdFx0XHRzZXR0ZXJzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwcm90byA9IGdldF9wcm90b3R5cGVfb2YocHJvdG8pO1xuXHR9XG5cblx0cmV0dXJuIHNldHRlcnM7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBjaGVja19zcmNfaW5fZGV2X2h5ZHJhdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGlmICghREVWKSByZXR1cm47XG5cdGlmIChhdHRyaWJ1dGUgPT09ICdzcmNzZXQnICYmIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudCwgdmFsdWUpKSByZXR1cm47XG5cdGlmIChzcmNfdXJsX2VxdWFsKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgPz8gJycsIHZhbHVlKSkgcmV0dXJuO1xuXG5cdHcuaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkKFxuXHRcdGF0dHJpYnV0ZSxcblx0XHRlbGVtZW50Lm91dGVySFRNTC5yZXBsYWNlKGVsZW1lbnQuaW5uZXJIVE1MLCBlbGVtZW50LmlubmVySFRNTCAmJiAnLi4uJyksXG5cdFx0U3RyaW5nKHZhbHVlKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50X3NyY1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuXHRpZiAoZWxlbWVudF9zcmMgPT09IHVybCkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBuZXcgVVJMKGVsZW1lbnRfc3JjLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmID09PSBuZXcgVVJMKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZjtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXQgKi9cbmZ1bmN0aW9uIHNwbGl0X3NyY3NldChzcmNzZXQpIHtcblx0cmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcCgoc3JjKSA9PiBzcmMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTb3VyY2VFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNyY3NldFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudCwgc3Jjc2V0KSB7XG5cdHZhciBlbGVtZW50X3VybHMgPSBzcGxpdF9zcmNzZXQoZWxlbWVudC5zcmNzZXQpO1xuXHR2YXIgdXJscyA9IHNwbGl0X3NyY3NldChzcmNzZXQpO1xuXG5cdHJldHVybiAoXG5cdFx0dXJscy5sZW5ndGggPT09IGVsZW1lbnRfdXJscy5sZW5ndGggJiZcblx0XHR1cmxzLmV2ZXJ5KFxuXHRcdFx0KFt1cmwsIHdpZHRoXSwgaSkgPT5cblx0XHRcdFx0d2lkdGggPT09IGVsZW1lbnRfdXJsc1tpXVsxXSAmJlxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgYm90aCB3YXlzIGJlY2F1c2UgVml0ZSB3aWxsIGNyZWF0ZSBhbiBhIGZ1bGwgVVJMIHdpdGhcblx0XHRcdFx0Ly8gYG5ldyBVUkwoYXNzZXQsIGltcG9ydC5tZXRhLnVybCkuaHJlZmAgZm9yIHRoZSBjbGllbnQgd2hlbiBgYmFzZTogJy4vJ2AsIGFuZCB0aGVcblx0XHRcdFx0Ly8gcmVsYXRpdmUgVVJMcyBpbnNpZGUgc3Jjc2V0IGFyZSBub3QgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhYnNvbHV0ZSBVUkxzIGJ5XG5cdFx0XHRcdC8vIGJyb3dzZXJzIChpbiBjb250cmFzdCB0byBpbWcuc3JjKS4gVGhpcyBtZWFucyBib3RoIFNTUiBhbmQgRE9NIGNvZGUgY291bGRcblx0XHRcdFx0Ly8gY29udGFpbiByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxzLlxuXHRcdFx0XHQoc3JjX3VybF9lcXVhbChlbGVtZW50X3VybHNbaV1bMF0sIHVybCkgfHwgc3JjX3VybF9lcXVhbCh1cmwsIGVsZW1lbnRfdXJsc1tpXVswXSkpXG5cdFx0KVxuXHQpO1xufVxuIiwiaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zdmdfY2xhc3MoZG9tLCB2YWx1ZSwgaGFzaCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdHZhciBwcmV2X2NsYXNzX25hbWUgPSBkb20uX19jbGFzc05hbWU7XG5cdHZhciBuZXh0X2NsYXNzX25hbWUgPSB0b19jbGFzcyh2YWx1ZSwgaGFzaCk7XG5cblx0aWYgKGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSBuZXh0X2NsYXNzX25hbWUpIHtcblx0XHQvLyBJbiBjYXNlIG9mIGh5ZHJhdGlvbiBkb24ndCByZXNldCB0aGUgY2xhc3MgYXMgaXQncyBhbHJlYWR5IGNvcnJlY3QuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fSBlbHNlIGlmIChcblx0XHRwcmV2X2NsYXNzX25hbWUgIT09IG5leHRfY2xhc3NfbmFtZSB8fFxuXHRcdChoeWRyYXRpbmcgJiYgZG9tLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAhPT0gbmV4dF9jbGFzc19uYW1lKVxuXHQpIHtcblx0XHRpZiAobmV4dF9jbGFzc19uYW1lID09PSAnJykge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBuZXh0X2NsYXNzX25hbWUpO1xuXHRcdH1cblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0XHRkb20uX19jbGFzc05hbWUgPSBuZXh0X2NsYXNzX25hbWU7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hdGhNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9tYXRobWxfY2xhc3MoZG9tLCB2YWx1ZSwgaGFzaCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdHZhciBwcmV2X2NsYXNzX25hbWUgPSBkb20uX19jbGFzc05hbWU7XG5cdHZhciBuZXh0X2NsYXNzX25hbWUgPSB0b19jbGFzcyh2YWx1ZSwgaGFzaCk7XG5cblx0aWYgKGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSBuZXh0X2NsYXNzX25hbWUpIHtcblx0XHQvLyBJbiBjYXNlIG9mIGh5ZHJhdGlvbiBkb24ndCByZXNldCB0aGUgY2xhc3MgYXMgaXQncyBhbHJlYWR5IGNvcnJlY3QuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fSBlbHNlIGlmIChcblx0XHRwcmV2X2NsYXNzX25hbWUgIT09IG5leHRfY2xhc3NfbmFtZSB8fFxuXHRcdChoeWRyYXRpbmcgJiYgZG9tLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAhPT0gbmV4dF9jbGFzc19uYW1lKVxuXHQpIHtcblx0XHRpZiAobmV4dF9jbGFzc19uYW1lID09PSAnJykge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBuZXh0X2NsYXNzX25hbWUpO1xuXHRcdH1cblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0XHRkb20uX19jbGFzc05hbWUgPSBuZXh0X2NsYXNzX25hbWU7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtoYXNoXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2xhc3MoZG9tLCB2YWx1ZSwgaGFzaCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdHZhciBwcmV2X2NsYXNzX25hbWUgPSBkb20uX19jbGFzc05hbWU7XG5cdHZhciBuZXh0X2NsYXNzX25hbWUgPSB0b19jbGFzcyh2YWx1ZSwgaGFzaCk7XG5cblx0aWYgKGh5ZHJhdGluZyAmJiBkb20uY2xhc3NOYW1lID09PSBuZXh0X2NsYXNzX25hbWUpIHtcblx0XHQvLyBJbiBjYXNlIG9mIGh5ZHJhdGlvbiBkb24ndCByZXNldCB0aGUgY2xhc3MgYXMgaXQncyBhbHJlYWR5IGNvcnJlY3QuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fSBlbHNlIGlmIChcblx0XHRwcmV2X2NsYXNzX25hbWUgIT09IG5leHRfY2xhc3NfbmFtZSB8fFxuXHRcdChoeWRyYXRpbmcgJiYgZG9tLmNsYXNzTmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lKVxuXHQpIHtcblx0XHQvLyBSZW1vdmluZyB0aGUgYXR0cmlidXRlIHdoZW4gdGhlIHZhbHVlIGlzIG9ubHkgYW4gZW1wdHkgc3RyaW5nIGNhdXNlc1xuXHRcdC8vIHBlZm9ybWFuY2UgaXNzdWVzIHZzIHNpbXBseSBtYWtpbmcgdGhlIGNsYXNzTmFtZSBhbiBlbXB0eSBzdHJpbmcuIFNvXG5cdFx0Ly8gd2Ugc2hvdWxkIG9ubHkgcmVtb3ZlIHRoZSBjbGFzcyBpZiB0aGUgdGhlIHZhbHVlIGlzIG51bGxpc2guXG5cdFx0aWYgKHZhbHVlID09IG51bGwgJiYgIWhhc2gpIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5jbGFzc05hbWUgPSBuZXh0X2NsYXNzX25hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgVn1cbiAqL1xuZnVuY3Rpb24gdG9fY2xhc3ModmFsdWUsIGhhc2gpIHtcblx0cmV0dXJuICh2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSkgKyAoaGFzaCA/ICcgJyArIGhhc2ggOiAnJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc19uYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhkb20sIGNsYXNzX25hbWUsIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSkge1xuXHRcdGlmIChkb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzX25hbWUpKSByZXR1cm47XG5cdFx0ZG9tLmNsYXNzTGlzdC5hZGQoY2xhc3NfbmFtZSk7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKCFkb20uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzX25hbWUpKSByZXR1cm47XG5cdFx0ZG9tLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NfbmFtZSk7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgUmFmIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBCUk9XU0VSIH0gZnJvbSAnZXNtLWVudic7XG5cbmNvbnN0IG5vdyA9IEJST1dTRVIgPyAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA6ICgpID0+IERhdGUubm93KCk7XG5cbi8qKiBAdHlwZSB7UmFmfSAqL1xuZXhwb3J0IGNvbnN0IHJhZiA9IHtcblx0Ly8gZG9uJ3QgYWNjZXNzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBlYWdlcmx5IG91dHNpZGUgbWV0aG9kXG5cdC8vIHRoaXMgYWxsb3dzIGJhc2ljIHRlc3Rpbmcgb2YgdXNlciBjb2RlIHdpdGhvdXQgSlNET01cblx0Ly8gYnVuZGVyIHdpbGwgZXZhbCBhbmQgcmVtb3ZlIHRlcm5hcnkgd2hlbiB0aGUgdXNlcidzIGFwcCBpcyBidWlsdFxuXHR0aWNrOiAvKiogQHBhcmFtIHthbnl9IF8gKi8gKF8pID0+IChCUk9XU0VSID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogbm9vcCkoXyksXG5cdG5vdzogKCkgPT4gbm93KCksXG5cdHRhc2tzOiBuZXcgU2V0KClcbn07XG4iLCIvKiogQGltcG9ydCB7IFRhc2tDYWxsYmFjaywgVGFzaywgVGFza0VudHJ5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJhZiB9IGZyb20gJy4vdGltaW5nLmpzJztcblxuLy8gVE9ETyBtb3ZlIHRoaXMgaW50byB0aW1pbmcuanMgd2hlcmUgaXQgcHJvYmFibHkgYmVsb25nc1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBydW5fdGFza3MoKSB7XG5cdC8vIHVzZSBgcmFmLm5vdygpYCBpbnN0ZWFkIG9mIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjayBhcmd1bWVudCwgYmVjYXVzZVxuXHQvLyBvdGhlcndpc2UgdGhpbmdzIGNhbiBnZXQgd29ua3kgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzE0NTQxXG5cdGNvbnN0IG5vdyA9IHJhZi5ub3coKTtcblxuXHRyYWYudGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdGlmICghdGFzay5jKG5vdykpIHtcblx0XHRcdHJhZi50YXNrcy5kZWxldGUodGFzayk7XG5cdFx0XHR0YXNrLmYoKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSAhPT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICogQHBhcmFtIHtUYXNrQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7VGFza31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUYXNrRW50cnl9ICovXG5cdGxldCB0YXNrO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSA9PT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHByb21pc2U6IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG5cdFx0XHRyYWYudGFza3MuYWRkKCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KSk7XG5cdFx0fSksXG5cdFx0YWJvcnQoKSB7XG5cdFx0XHRyYWYudGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdH1cblx0fTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQW5pbWF0ZUZuLCBBbmltYXRpb24sIEFuaW1hdGlvbkNvbmZpZywgRWFjaEl0ZW0sIEVmZmVjdCwgVHJhbnNpdGlvbkZuLCBUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBub29wLCBpc19mdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBlZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvbixcblx0dW50cmFja1xufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGxvb3AgfSBmcm9tICcuLi8uLi9sb29wLmpzJztcbmltcG9ydCB7IHNob3VsZF9pbnRybyB9IGZyb20gJy4uLy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSB9IGZyb20gJy4uL2Jsb2Nrcy9lYWNoLmpzJztcbmltcG9ydCB7IFRSQU5TSVRJT05fR0xPQkFMLCBUUkFOU0lUSU9OX0lOLCBUUkFOU0lUSU9OX09VVCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBCTE9DS19FRkZFQ1QsIEVGRkVDVF9SQU4sIEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQgfSBmcm9tICcuL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geydpbnRyb3N0YXJ0JyB8ICdpbnRyb2VuZCcgfCAnb3V0cm9zdGFydCcgfCAnb3V0cm9lbmQnfSB0eXBlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgdHlwZSkge1xuXHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSkpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByb3BlcnR5IHRvIHRoZSBjYW1lbC1jYXNlIGZvcm1hdCBleHBlY3RlZCBieSBFbGVtZW50LmFuaW1hdGUoKSwgS2V5ZnJhbWVFZmZlY3QoKSwgYW5kIEtleWZyYW1lRWZmZWN0LnNldEtleWZyYW1lcygpLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHN0eWxlKSB7XG5cdC8vIGluIGNvbXBsaWFuY2Ugd2l0aCBzcGVjXG5cdGlmIChzdHlsZSA9PT0gJ2Zsb2F0JykgcmV0dXJuICdjc3NGbG9hdCc7XG5cdGlmIChzdHlsZSA9PT0gJ29mZnNldCcpIHJldHVybiAnY3NzT2Zmc2V0JztcblxuXHQvLyBkbyBub3QgcmVuYW1lIGN1c3RvbSBAcHJvcGVydGllc1xuXHRpZiAoc3R5bGUuc3RhcnRzV2l0aCgnLS0nKSkgcmV0dXJuIHN0eWxlO1xuXG5cdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy0nKTtcblx0aWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzWzBdO1xuXHRyZXR1cm4gKFxuXHRcdHBhcnRzWzBdICtcblx0XHRwYXJ0c1xuXHRcdFx0LnNsaWNlKDEpXG5cdFx0XHQubWFwKC8qKiBAcGFyYW0ge2FueX0gd29yZCAqLyAod29yZCkgPT4gd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSlcblx0XHRcdC5qb2luKCcnKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NcbiAqIEByZXR1cm5zIHtLZXlmcmFtZX1cbiAqL1xuZnVuY3Rpb24gY3NzX3RvX2tleWZyYW1lKGNzcykge1xuXHQvKiogQHR5cGUge0tleWZyYW1lfSAqL1xuXHRjb25zdCBrZXlmcmFtZSA9IHt9O1xuXHRjb25zdCBwYXJ0cyA9IGNzcy5zcGxpdCgnOycpO1xuXHRmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcblx0XHRjb25zdCBbcHJvcGVydHksIHZhbHVlXSA9IHBhcnQuc3BsaXQoJzonKTtcblx0XHRpZiAoIXByb3BlcnR5IHx8IHZhbHVlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuXG5cdFx0Y29uc3QgZm9ybWF0dGVkX3Byb3BlcnR5ID0gY3NzX3Byb3BlcnR5X3RvX2NhbWVsY2FzZShwcm9wZXJ0eS50cmltKCkpO1xuXHRcdGtleWZyYW1lW2Zvcm1hdHRlZF9wcm9wZXJ0eV0gPSB2YWx1ZS50cmltKCk7XG5cdH1cblx0cmV0dXJuIGtleWZyYW1lO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHQgKi9cbmNvbnN0IGxpbmVhciA9ICh0KSA9PiB0O1xuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUga2V5ZWQgYHsjZWFjaCAuLi59YCBibG9ja3MgKGFzIGAkLmFuaW1hdGlvbiguLi4pYCkuIFRoaXMgY3JlYXRlcyBhbiBhbmltYXRpb24gbWFuYWdlclxuICogYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBibG9jaywgc28gdGhhdCBtb3ZlcyBjYW4gYmUgYW5pbWF0ZWQgZm9sbG93aW5nIHJlY29uY2lsaWF0aW9uLlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBBbmltYXRlRm48UCB8IHVuZGVmaW5lZD59IGdldF9mblxuICogQHBhcmFtIHsoKCkgPT4gUCkgfCBudWxsfSBnZXRfcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRpb24oZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpdGVtID0gLyoqIEB0eXBlIHtFYWNoSXRlbX0gKi8gKGN1cnJlbnRfZWFjaF9pdGVtKTtcblxuXHQvKiogQHR5cGUge0RPTVJlY3R9ICovXG5cdHZhciBmcm9tO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIHRvO1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgYW5pbWF0aW9uO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IHsgcG9zaXRpb246IHN0cmluZywgd2lkdGg6IHN0cmluZywgaGVpZ2h0OiBzdHJpbmcsIHRyYW5zZm9ybTogc3RyaW5nIH19ICovXG5cdHZhciBvcmlnaW5hbF9zdHlsZXMgPSBudWxsO1xuXG5cdGl0ZW0uYSA/Pz0ge1xuXHRcdGVsZW1lbnQsXG5cdFx0bWVhc3VyZSgpIHtcblx0XHRcdGZyb20gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fSxcblx0XHRhcHBseSgpIHtcblx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblxuXHRcdFx0dG8gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8XG5cdFx0XHRcdGZyb20ucmlnaHQgIT09IHRvLnJpZ2h0IHx8XG5cdFx0XHRcdGZyb20udG9wICE9PSB0by50b3AgfHxcblx0XHRcdFx0ZnJvbS5ib3R0b20gIT09IHRvLmJvdHRvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IG9wdGlvbnMgPSBnZXRfZm4oKSh0aGlzLmVsZW1lbnQsIHsgZnJvbSwgdG8gfSwgZ2V0X3BhcmFtcz8uKCkpO1xuXG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGUodGhpcy5lbGVtZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIDEsICgpID0+IHtcblx0XHRcdFx0XHRhbmltYXRpb24/LmFib3J0KCk7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGZpeCgpIHtcblx0XHRcdC8vIElmIGFuIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHJ1bm5pbmcsIHRyYW5zZm9ybWluZyB0aGUgZWxlbWVudCBpcyBsaWtlbHkgdG8gZmFpbCxcblx0XHRcdC8vIGJlY2F1c2UgdGhlIHN0eWxlcyBhcHBsaWVkIGJ5IHRoZSBhbmltYXRpb24gdGFrZSBwcmVjZWRlbmNlLiBJbiB0aGUgY2FzZSBvZiBjcm9zc2ZhZGUsXG5cdFx0XHQvLyB0aGF0IG1lYW5zIHRoZSBgdHJhbnNsYXRlKC4uLilgIG9mIHRoZSBjcm9zc2ZhZGUgdHJhbnNpdGlvbiBvdmVycnVsZXMgdGhlIGB0cmFuc2xhdGUoLi4uKWBcblx0XHRcdC8vIHdlIHdvdWxkIGFwcGx5IGJlbG93LCBsZWFkaW5nIHRvIHRoZSBlbGVtZW50IGp1bXBpbmcgc29tZXdoZXJlIHRvIHRoZSB0b3AgbGVmdC5cblx0XHRcdGlmIChlbGVtZW50LmdldEFuaW1hdGlvbnMoKS5sZW5ndGgpIHJldHVybjtcblxuXHRcdFx0Ly8gSXQncyBpbXBvcnRhbnQgdG8gZGVzdHJ1Y3R1cmUgdGhlc2UgdG8gZ2V0IGZpeGVkIHZhbHVlcyAtIHRoZSBvYmplY3QgaXRzZWxmIGhhcyBnZXR0ZXJzLFxuXHRcdFx0Ly8gYW5kIGNoYW5naW5nIHRoZSBzdHlsZSB0byAnYWJzb2x1dGUnIGNhbiBmb3IgZXhhbXBsZSBpbmZsdWVuY2UgdGhlIHdpZHRoLlxuXHRcdFx0dmFyIHsgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cblx0XHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdG9yaWdpbmFsX3N0eWxlcyA9IHtcblx0XHRcdFx0XHRwb3NpdGlvbjogc3R5bGUucG9zaXRpb24sXG5cdFx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHRcdHRyYW5zZm9ybTogc3R5bGUudHJhbnNmb3JtXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdHZhciB0byA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0aWYgKGZyb20ubGVmdCAhPT0gdG8ubGVmdCB8fCBmcm9tLnRvcCAhPT0gdG8udG9wKSB7XG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtmcm9tLmxlZnQgLSB0by5sZWZ0fXB4LCAke2Zyb20udG9wIC0gdG8udG9wfXB4KWA7XG5cdFx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID8gYCR7c3R5bGUudHJhbnNmb3JtfSAke3RyYW5zZm9ybX1gIDogdHJhbnNmb3JtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR1bmZpeCgpIHtcblx0XHRcdGlmIChvcmlnaW5hbF9zdHlsZXMpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovIChlbGVtZW50KS5zdHlsZTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsX3N0eWxlcy5wb3NpdGlvbjtcblx0XHRcdFx0c3R5bGUud2lkdGggPSBvcmlnaW5hbF9zdHlsZXMud2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IG9yaWdpbmFsX3N0eWxlcy5oZWlnaHQ7XG5cdFx0XHRcdHN0eWxlLnRyYW5zZm9ybSA9IG9yaWdpbmFsX3N0eWxlcy50cmFuc2Zvcm07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIGluIHRoZSBjYXNlIG9mIGEgYDxzdmVsdGU6ZWxlbWVudD5gLCBpdCdzIHBvc3NpYmxlIGZvciBgJC5hbmltYXRpb24oLi4uKWAgdG8gYmUgY2FsbGVkXG5cdC8vIHdoZW4gYW4gYW5pbWF0aW9uIG1hbmFnZXIgYWxyZWFkeSBleGlzdHMsIGlmIHRoZSB0YWcgY2hhbmdlcy4gaW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvXG5cdC8vIHN3YXAgb3V0IHRoZSBlbGVtZW50IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG1hbmFnZXIsIGluIGNhc2UgaXQgaGFwcGVuZWQgYXQgdGhlIHNhbWVcblx0Ly8gbW9tZW50IGFzIGEgcmVjb25jaWxpYXRpb25cblx0aXRlbS5hLmVsZW1lbnQgPSBlbGVtZW50O1xufVxuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUgYmxvY2sgZWZmZWN0cyBhcyBgJC50cmFuc2l0aW9uKC4uLilgLiBUaGlzIGNyZWF0ZXMgYSB0cmFuc2l0aW9uIG1hbmFnZXIgYW5kXG4gKiBhdHRhY2hlcyBpdCB0byB0aGUgY3VycmVudCBlZmZlY3Qg4oCUIGxhdGVyLCBpbnNpZGUgYHBhdXNlX2VmZmVjdGAgYW5kIGByZXN1bWVfZWZmZWN0YCwgd2VcbiAqIHVzZSB0aGlzIHRvIGNyZWF0ZSBgaW50cm9gIGFuZCBgb3V0cm9gIHRyYW5zaXRpb25zLlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBUcmFuc2l0aW9uRm48UCB8IHVuZGVmaW5lZD59IGdldF9mblxuICogQHBhcmFtIHsoKCkgPT4gUCkgfCBudWxsfSBnZXRfcGFyYW1zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb24oZmxhZ3MsIGVsZW1lbnQsIGdldF9mbiwgZ2V0X3BhcmFtcykge1xuXHR2YXIgaXNfaW50cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0lOKSAhPT0gMDtcblx0dmFyIGlzX291dHJvID0gKGZsYWdzICYgVFJBTlNJVElPTl9PVVQpICE9PSAwO1xuXHR2YXIgaXNfYm90aCA9IGlzX2ludHJvICYmIGlzX291dHJvO1xuXHR2YXIgaXNfZ2xvYmFsID0gKGZsYWdzICYgVFJBTlNJVElPTl9HTE9CQUwpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7J2luJyB8ICdvdXQnIHwgJ2JvdGgnfSAqL1xuXHR2YXIgZGlyZWN0aW9uID0gaXNfYm90aCA/ICdib3RoJyA6IGlzX2ludHJvID8gJ2luJyA6ICdvdXQnO1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uQ29uZmlnIHwgKChvcHRzOiB7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIH0pID0+IEFuaW1hdGlvbkNvbmZpZykgfCB1bmRlZmluZWR9ICovXG5cdHZhciBjdXJyZW50X29wdGlvbnM7XG5cblx0dmFyIGluZXJ0ID0gZWxlbWVudC5pbmVydDtcblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgb3ZlcmZsb3cgc3R5bGUsIHN0YXNoZWQgc28gd2UgY2FuIHJldmVydCBjaGFuZ2VzIGR1cmluZyB0aGUgdHJhbnNpdGlvblxuXHQgKiB0aGF0IGFyZSBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgPDE4IGJ1Z1xuXHQgKiBUT0RPIDYuMCByZW1vdmUgdGhpcywgaWYgb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIGhhdmUgZGllZCBvdXQgZW5vdWdoXG5cdCAqL1xuXHR2YXIgb3ZlcmZsb3cgPSBlbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaW50cm87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBvdXRybztcblxuXHRmdW5jdGlvbiBnZXRfb3B0aW9ucygpIHtcblx0XHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0XHR0cnkge1xuXHRcdFx0Ly8gSWYgYSB0cmFuc2l0aW9uIGlzIHN0aWxsIG9uZ29pbmcsIHdlIHVzZSB0aGUgZXhpc3Rpbmcgb3B0aW9ucyByYXRoZXIgdGhhbiBnZW5lcmF0aW5nXG5cdFx0XHQvLyBuZXcgb25lcy4gVGhpcyBlbnN1cmVzIHRoYXQgcmV2ZXJzaWJsZSB0cmFuc2l0aW9ucyByZXZlcnNlIHNtb290aGx5LCByYXRoZXIgdGhhblxuXHRcdFx0Ly8ganVtcGluZyB0byBhIG5ldyBzcG90IGJlY2F1c2UgKGZvciBleGFtcGxlKSBhIGRpZmZlcmVudCBgZHVyYXRpb25gIHdhcyB1c2VkXG5cdFx0XHRyZXR1cm4gKGN1cnJlbnRfb3B0aW9ucyA/Pz0gZ2V0X2ZuKCkoZWxlbWVudCwgZ2V0X3BhcmFtcz8uKCkgPz8gLyoqIEB0eXBlIHtQfSAqLyAoe30pLCB7XG5cdFx0XHRcdGRpcmVjdGlvblxuXHRcdFx0fSkpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcn0gKi9cblx0dmFyIHRyYW5zaXRpb24gPSB7XG5cdFx0aXNfZ2xvYmFsLFxuXHRcdGluKCkge1xuXHRcdFx0ZWxlbWVudC5pbmVydCA9IGluZXJ0O1xuXG5cdFx0XHRpZiAoIWlzX2ludHJvKSB7XG5cdFx0XHRcdG91dHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRvdXRybz8ucmVzZXQ/LigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNfb3V0cm8pIHtcblx0XHRcdFx0Ly8gaWYgd2UgaW50cm8gdGhlbiBvdXRybyB0aGVuIGludHJvIGFnYWluLCB3ZSB3YW50IHRvIGFib3J0IHRoZSBmaXJzdCBpbnRybyxcblx0XHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiaWRpcmVjdGlvbmFsIHRyYW5zaXRpb25cblx0XHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdpbnRyb3N0YXJ0Jyk7XG5cblx0XHRcdGludHJvID0gYW5pbWF0ZShlbGVtZW50LCBnZXRfb3B0aW9ucygpLCBvdXRybywgMSwgKCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnaW50cm9lbmQnKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgd2UgY2FuY2VsIHRoZSBhbmltYXRpb24gdG8gcHJldmVudCBsZWFraW5nXG5cdFx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0XHRpbnRybyA9IGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG91dChmbikge1xuXHRcdFx0aWYgKCFpc19vdXRybykge1xuXHRcdFx0XHRmbj8uKCk7XG5cdFx0XHRcdGN1cnJlbnRfb3B0aW9ucyA9IHVuZGVmaW5lZDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtZW50LmluZXJ0ID0gdHJ1ZTtcblxuXHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ291dHJvc3RhcnQnKTtcblxuXHRcdFx0b3V0cm8gPSBhbmltYXRlKGVsZW1lbnQsIGdldF9vcHRpb25zKCksIGludHJvLCAwLCAoKSA9PiB7XG5cdFx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdvdXRyb2VuZCcpO1xuXHRcdFx0XHRmbj8uKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdHN0b3A6ICgpID0+IHtcblx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0b3V0cm8/LmFib3J0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBlID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHQoZS50cmFuc2l0aW9ucyA/Pz0gW10pLnB1c2godHJhbnNpdGlvbik7XG5cblx0Ly8gaWYgdGhpcyBpcyBhIGxvY2FsIHRyYW5zaXRpb24sIHdlIG9ubHkgd2FudCB0byBydW4gaXQgaWYgdGhlIHBhcmVudCAoYnJhbmNoKSBlZmZlY3Qnc1xuXHQvLyBwYXJlbnQgKGJsb2NrKSBlZmZlY3QgaXMgd2hlcmUgdGhlIHN0YXRlIGNoYW5nZSBoYXBwZW5lZC4gd2UgY2FuIGRldGVybWluZSB0aGF0IGJ5XG5cdC8vIGxvb2tpbmcgYXQgd2hldGhlciB0aGUgYmxvY2sgZWZmZWN0IGlzIGN1cnJlbnRseSBpbml0aWFsaXppbmdcblx0aWYgKGlzX2ludHJvICYmIHNob3VsZF9pbnRybykge1xuXHRcdHZhciBydW4gPSBpc19nbG9iYWw7XG5cblx0XHRpZiAoIXJ1bikge1xuXHRcdFx0dmFyIGJsb2NrID0gLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqLyAoZS5wYXJlbnQpO1xuXG5cdFx0XHQvLyBza2lwIG92ZXIgdHJhbnNwYXJlbnQgYmxvY2tzIChlLmcuIHNuaXBwZXRzLCBlbHNlLWlmIGJsb2Nrcylcblx0XHRcdHdoaWxlIChibG9jayAmJiAoYmxvY2suZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDApIHtcblx0XHRcdFx0d2hpbGUgKChibG9jayA9IGJsb2NrLnBhcmVudCkpIHtcblx0XHRcdFx0XHRpZiAoKGJsb2NrLmYgJiBCTE9DS19FRkZFQ1QpICE9PSAwKSBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRydW4gPSAhYmxvY2sgfHwgKGJsb2NrLmYgJiBFRkZFQ1RfUkFOKSAhPT0gMDtcblx0XHR9XG5cblx0XHRpZiAocnVuKSB7XG5cdFx0XHRlZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHR1bnRyYWNrKCgpID0+IHRyYW5zaXRpb24uaW4oKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhbiBlbGVtZW50LCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKX0gb3B0aW9uc1xuICogQHBhcmFtIHtBbmltYXRpb24gfCB1bmRlZmluZWR9IGNvdW50ZXJwYXJ0IFRoZSBjb3JyZXNwb25kaW5nIGludHJvL291dHJvIHRvIHRoaXMgb3V0cm8vaW50cm9cbiAqIEBwYXJhbSB7bnVtYmVyfSB0MiBUaGUgdGFyZ2V0IGB0YCB2YWx1ZSDigJQgYDFgIGZvciBpbnRybywgYDBgIGZvciBvdXRyb1xuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IG9uX2ZpbmlzaCBDYWxsZWQgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRpbmcgdGhlIGFuaW1hdGlvblxuICogQHJldHVybnMge0FuaW1hdGlvbn1cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBvcHRpb25zLCBjb3VudGVycGFydCwgdDIsIG9uX2ZpbmlzaCkge1xuXHR2YXIgaXNfaW50cm8gPSB0MiA9PT0gMTtcblxuXHRpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucykpIHtcblx0XHQvLyBJbiB0aGUgY2FzZSBvZiBhIGRlZmVycmVkIHRyYW5zaXRpb24gKHN1Y2ggYXMgYGNyb3NzZmFkZWApLCBgb3B0aW9uYCB3aWxsIGJlXG5cdFx0Ly8gYSBmdW5jdGlvbiByYXRoZXIgdGhhbiBhbiBgQW5pbWF0aW9uQ29uZmlnYC4gV2UgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb25cblx0XHQvLyBvbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZC4uLlxuXHRcdC8qKiBAdHlwZSB7QW5pbWF0aW9ufSAqL1xuXHRcdHZhciBhO1xuXHRcdHZhciBhYm9ydGVkID0gZmFsc2U7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmIChhYm9ydGVkKSByZXR1cm47XG5cdFx0XHR2YXIgbyA9IG9wdGlvbnMoeyBkaXJlY3Rpb246IGlzX2ludHJvID8gJ2luJyA6ICdvdXQnIH0pO1xuXHRcdFx0YSA9IGFuaW1hdGUoZWxlbWVudCwgbywgY291bnRlcnBhcnQsIHQyLCBvbl9maW5pc2gpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gLi4uYnV0IHdlIHdhbnQgdG8gZG8gc28gd2l0aG91dCB1c2luZyBgYXN5bmNgL2Bhd2FpdGAgZXZlcnl3aGVyZSwgc29cblx0XHQvLyB3ZSByZXR1cm4gYSBmYWNhZGUgdGhhdCBhbGxvd3MgZXZlcnl0aGluZyB0byByZW1haW4gc3luY2hyb25vdXNcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWJvcnQ6ICgpID0+IHtcblx0XHRcdFx0YWJvcnRlZCA9IHRydWU7XG5cdFx0XHRcdGE/LmFib3J0KCk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVhY3RpdmF0ZTogKCkgPT4gYS5kZWFjdGl2YXRlKCksXG5cdFx0XHRyZXNldDogKCkgPT4gYS5yZXNldCgpLFxuXHRcdFx0dDogKCkgPT4gYS50KClcblx0XHR9O1xuXHR9XG5cblx0Y291bnRlcnBhcnQ/LmRlYWN0aXZhdGUoKTtcblxuXHRpZiAoIW9wdGlvbnM/LmR1cmF0aW9uKSB7XG5cdFx0b25fZmluaXNoKCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWJvcnQ6IG5vb3AsXG5cdFx0XHRkZWFjdGl2YXRlOiBub29wLFxuXHRcdFx0cmVzZXQ6IG5vb3AsXG5cdFx0XHR0OiAoKSA9PiB0MlxuXHRcdH07XG5cdH1cblxuXHRjb25zdCB7IGRlbGF5ID0gMCwgY3NzLCB0aWNrLCBlYXNpbmcgPSBsaW5lYXIgfSA9IG9wdGlvbnM7XG5cblx0dmFyIGtleWZyYW1lcyA9IFtdO1xuXG5cdGlmIChpc19pbnRybyAmJiBjb3VudGVycGFydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRpY2spIHtcblx0XHRcdHRpY2soMCwgMSk7IC8vIFRPRE8gcHV0IGluIG5lc3RlZCBlZmZlY3QsIHRvIGF2b2lkIGludGVybGVhdmVkIHJlYWRzL3dyaXRlcz9cblx0XHR9XG5cblx0XHRpZiAoY3NzKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gY3NzX3RvX2tleWZyYW1lKGNzcygwLCAxKSk7XG5cdFx0XHRrZXlmcmFtZXMucHVzaChzdHlsZXMsIHN0eWxlcyk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGdldF90ID0gKCkgPT4gMSAtIHQyO1xuXG5cdC8vIGNyZWF0ZSBhIGR1bW15IGFuaW1hdGlvbiB0aGF0IGxhc3RzIGFzIGxvbmcgYXMgdGhlIGRlbGF5IChidXQgd2l0aCB3aGF0ZXZlciBkZXZ0b29sc1xuXHQvLyBtdWx0aXBsaWVyIGlzIGluIGVmZmVjdCkuIGluIHRoZSBjb21tb24gY2FzZSB0aGF0IGl0IGlzIGAwYCwgd2Uga2VlcCBpdCBhbnl3YXkgc28gdGhhdFxuXHQvLyB0aGUgQ1NTIGtleWZyYW1lcyBhcmVuJ3QgY3JlYXRlZCB1bnRpbCB0aGUgRE9NIGlzIHVwZGF0ZWRcblx0dmFyIGFuaW1hdGlvbiA9IGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZXMsIHsgZHVyYXRpb246IGRlbGF5IH0pO1xuXG5cdGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcblx0XHQvLyBmb3IgYmlkaXJlY3Rpb25hbCB0cmFuc2l0aW9ucywgd2Ugc3RhcnQgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbixcblx0XHQvLyByYXRoZXIgdGhhbiBkb2luZyBhIGZ1bGwgaW50cm8vb3V0cm9cblx0XHR2YXIgdDEgPSBjb3VudGVycGFydD8udCgpID8/IDEgLSB0Mjtcblx0XHRjb3VudGVycGFydD8uYWJvcnQoKTtcblxuXHRcdHZhciBkZWx0YSA9IHQyIC0gdDE7XG5cdFx0dmFyIGR1cmF0aW9uID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvcHRpb25zLmR1cmF0aW9uKSAqIE1hdGguYWJzKGRlbHRhKTtcblx0XHR2YXIga2V5ZnJhbWVzID0gW107XG5cblx0XHRpZiAoZHVyYXRpb24gPiAwKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBDU1MgaW5jbHVkZXMgYG92ZXJmbG93OiBoaWRkZW5gLCBpbiB3aGljaCBjYXNlIHdlIG5lZWQgdG9cblx0XHRcdCAqIGFkZCBpdCBhcyBhbiBpbmxpbmUgc3R5bGUgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgPDE4IGJ1Z1xuXHRcdFx0ICogVE9ETyA2LjAgcmVtb3ZlIHRoaXMsIGlmIHBvc3NpYmxlXG5cdFx0XHQgKi9cblx0XHRcdHZhciBuZWVkc19vdmVyZmxvd19oaWRkZW4gPSBmYWxzZTtcblxuXHRcdFx0aWYgKGNzcykge1xuXHRcdFx0XHR2YXIgbiA9IE1hdGguY2VpbChkdXJhdGlvbiAvICgxMDAwIC8gNjApKTsgLy8gYG5gIG11c3QgYmUgYW4gaW50ZWdlciwgb3Igd2UgcmlzayBtaXNzaW5nIHRoZSBgdDJgIHZhbHVlXG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gbjsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSB0MSArIGRlbHRhICogZWFzaW5nKGkgLyBuKTtcblx0XHRcdFx0XHR2YXIgc3R5bGVzID0gY3NzX3RvX2tleWZyYW1lKGNzcyh0LCAxIC0gdCkpO1xuXHRcdFx0XHRcdGtleWZyYW1lcy5wdXNoKHN0eWxlcyk7XG5cblx0XHRcdFx0XHRuZWVkc19vdmVyZmxvd19oaWRkZW4gfHw9IHN0eWxlcy5vdmVyZmxvdyA9PT0gJ2hpZGRlbic7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lZWRzX292ZXJmbG93X2hpZGRlbikge1xuXHRcdFx0XHQvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblx0XHRcdH1cblxuXHRcdFx0Z2V0X3QgPSAoKSA9PiB7XG5cdFx0XHRcdHZhciB0aW1lID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChcblx0XHRcdFx0XHQvKiogQHR5cGUge2dsb2JhbFRoaXMuQW5pbWF0aW9ufSAqLyAoYW5pbWF0aW9uKS5jdXJyZW50VGltZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHJldHVybiB0MSArIGRlbHRhICogZWFzaW5nKHRpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAodGljaykge1xuXHRcdFx0XHRsb29wKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ3J1bm5pbmcnKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR2YXIgdCA9IGdldF90KCk7XG5cdFx0XHRcdFx0dGljayh0LCAxIC0gdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbiwgZmlsbDogJ2ZvcndhcmRzJyB9KTtcblxuXHRcdGFuaW1hdGlvbi5vbmZpbmlzaCA9ICgpID0+IHtcblx0XHRcdGdldF90ID0gKCkgPT4gdDI7XG5cdFx0XHR0aWNrPy4odDIsIDEgLSB0Mik7XG5cdFx0XHRvbl9maW5pc2goKTtcblx0XHR9O1xuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0YWJvcnQ6ICgpID0+IHtcblx0XHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdFx0YW5pbWF0aW9uLmNhbmNlbCgpO1xuXHRcdFx0XHQvLyBUaGlzIHByZXZlbnRzIG1lbW9yeSBsZWFrcyBpbiBDaHJvbWl1bVxuXHRcdFx0XHRhbmltYXRpb24uZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0Ly8gVGhpcyBwcmV2ZW50cyBvbmZpbmlzaCB0byBiZSBsYXVuY2hlZCBhZnRlciBjYW5jZWwoKSxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGhhcHBlbiBpbiBzb21lIHJhcmUgY2FzZXNcblx0XHRcdFx0Ly8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzEzNjgxXG5cdFx0XHRcdGFuaW1hdGlvbi5vbmZpbmlzaCA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRkZWFjdGl2YXRlOiAoKSA9PiB7XG5cdFx0XHRvbl9maW5pc2ggPSBub29wO1xuXHRcdH0sXG5cdFx0cmVzZXQ6ICgpID0+IHtcblx0XHRcdGlmICh0MiA9PT0gMCkge1xuXHRcdFx0XHR0aWNrPy4oMSwgMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0OiAoKSA9PiBnZXRfdCgpXG5cdH07XG59XG4iLCJpbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uLy4uLy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi8uLi90YXNrLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uLy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19ydW5lcyB9IGZyb20gJy4uLy4uLy4uL2NvbnRleHQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfdmFsdWUoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBydW5lcyA9IGlzX3J1bmVzKCk7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2lucHV0JywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0aWYgKERFViAmJiBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0dmFyIHZhbHVlID0gaXNfcmVzZXQgPyBpbnB1dC5kZWZhdWx0VmFsdWUgOiBpbnB1dC52YWx1ZTtcblx0XHR2YWx1ZSA9IGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpID8gdG9fbnVtYmVyKHZhbHVlKSA6IHZhbHVlO1xuXHRcdHNldCh2YWx1ZSk7XG5cblx0XHQvLyBJbiBydW5lcyBtb2RlLCByZXNwZWN0IGFueSB2YWxpZGF0aW9uIGluIGFjY2Vzc29ycyAoZG9lc24ndCBhcHBseSBpbiBsZWdhY3kgbW9kZSxcblx0XHQvLyBiZWNhdXNlIHdlIHVzZSBtdXRhYmxlIHN0YXRlIHdoaWNoIGVuc3VyZXMgdGhlIHJlbmRlciBlZmZlY3QgYWx3YXlzIHJ1bnMpXG5cdFx0aWYgKHJ1bmVzICYmIHZhbHVlICE9PSAodmFsdWUgPSBnZXQoKSkpIHtcblx0XHRcdHZhciBzdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuXHRcdFx0dmFyIGVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcblxuXHRcdFx0Ly8gdGhlIHZhbHVlIGlzIGNvZXJjZWQgb24gYXNzaWdubWVudFxuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZSA/PyAnJztcblxuXHRcdFx0Ly8gUmVzdG9yZSBzZWxlY3Rpb25cblx0XHRcdGlmIChlbmQgIT09IG51bGwpIHtcblx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlZCB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdFZhbHVlICE9PSBpbnB1dC52YWx1ZSkgfHxcblx0XHQvLyBJZiBkZWZhdWx0VmFsdWUgaXMgc2V0LCB0aGVuIHZhbHVlID09IGRlZmF1bHRWYWx1ZVxuXHRcdC8vIFRPRE8gU3ZlbHRlIDY6IHJlbW92ZSBpbnB1dC52YWx1ZSBjaGVjayBhbmQgc2V0IHRvIGVtcHR5IHN0cmluZz9cblx0XHQodW50cmFjayhnZXQpID09IG51bGwgJiYgaW5wdXQudmFsdWUpXG5cdCkge1xuXHRcdHNldChpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSA/IHRvX251bWJlcihpbnB1dC52YWx1ZSkgOiBpbnB1dC52YWx1ZSk7XG5cdH1cblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpZiAoREVWICYmIGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKTtcblx0XHR9XG5cblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblxuXHRcdGlmIChpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSAmJiB2YWx1ZSA9PT0gdG9fbnVtYmVyKGlucHV0LnZhbHVlKSkge1xuXHRcdFx0Ly8gaGFuZGxlcyAwIHZzIDAwIGNhc2UgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy85OTU5KVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC50eXBlID09PSAnZGF0ZScgJiYgIXZhbHVlICYmICFpbnB1dC52YWx1ZSkge1xuXHRcdFx0Ly8gSGFuZGxlcyB0aGUgY2FzZSB3aGVyZSBhIHRlbXBvcmFyaWx5IGludmFsaWQgZGF0ZSBpcyBzZXQgKHdoaWxlIHR5cGluZywgZm9yIGV4YW1wbGUgd2l0aCBhIGxlYWRpbmcgMCBmb3IgdGhlIGRheSlcblx0XHRcdC8vIGFuZCBwcmV2ZW50cyB0aGlzIHN0YXRlIGZyb20gY2xlYXJpbmcgdGhlIG90aGVyIHBhcnRzIG9mIHRoZSBkYXRlIGlucHV0IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvNzg5Nylcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBzZXQgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpZiBpdCdzIHRoZSBzYW1lIHRvIGFsbG93XG5cdFx0Ly8gbWlubGVuZ3RoIHRvIHdvcmsgcHJvcGVybHlcblx0XHRpZiAodmFsdWUgIT09IGlucHV0LnZhbHVlKSB7XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSB2YWx1ZSBpcyBjb2VyY2VkIG9uIGFzc2lnbm1lbnRcblx0XHRcdGlucHV0LnZhbHVlID0gdmFsdWUgPz8gJyc7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqIEB0eXBlIHtTZXQ8SFRNTElucHV0RWxlbWVudFtdPn0gKi9cbmNvbnN0IHBlbmRpbmcgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGlucHV0c1xuICogQHBhcmFtIHtudWxsIHwgW251bWJlcl19IGdyb3VwX2luZGV4XG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2dyb3VwKGlucHV0cywgZ3JvdXBfaW5kZXgsIGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgaXNfY2hlY2tib3ggPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94Jztcblx0dmFyIGJpbmRpbmdfZ3JvdXAgPSBpbnB1dHM7XG5cblx0Ly8gbmVlZHMgdG8gYmUgbGV0IG9yIHJlbGF0ZWQgY29kZSBpc24ndCB0cmVlc2hha2VuIG91dCBpZiBpdCdzIGFsd2F5cyBmYWxzZVxuXHRsZXQgaHlkcmF0aW9uX21pc21hdGNoID0gZmFsc2U7XG5cblx0aWYgKGdyb3VwX2luZGV4ICE9PSBudWxsKSB7XG5cdFx0Zm9yICh2YXIgaW5kZXggb2YgZ3JvdXBfaW5kZXgpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGJpbmRpbmdfZ3JvdXAgPSBiaW5kaW5nX2dyb3VwW2luZGV4XSA/Pz0gW107XG5cdFx0fVxuXHR9XG5cblx0YmluZGluZ19ncm91cC5wdXNoKGlucHV0KTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KFxuXHRcdGlucHV0LFxuXHRcdCdjaGFuZ2UnLFxuXHRcdCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0Ll9fdmFsdWU7XG5cblx0XHRcdGlmIChpc19jaGVja2JveCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGJpbmRpbmdfZ3JvdXAsIHZhbHVlLCBpbnB1dC5jaGVja2VkKTtcblx0XHRcdH1cblxuXHRcdFx0c2V0KHZhbHVlKTtcblx0XHR9LFxuXHRcdC8vIFRPRE8gYmV0dGVyIGRlZmF1bHQgdmFsdWUgaGFuZGxpbmdcblx0XHQoKSA9PiBzZXQoaXNfY2hlY2tib3ggPyBbXSA6IG51bGwpXG5cdCk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsIHRoZW4gdXNlIHRoZSB1cGRhdGUgdmFsdWVcblx0XHQvLyBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdGlmIChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdENoZWNrZWQgIT09IGlucHV0LmNoZWNrZWQpIHtcblx0XHRcdGh5ZHJhdGlvbl9taXNtYXRjaCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IFtdO1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0aW5wdXQuY2hlY2tlZCA9IHZhbHVlLmluY2x1ZGVzKGlucHV0Ll9fdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRpbnB1dC5jaGVja2VkID0gaXMoaW5wdXQuX192YWx1ZSwgdmFsdWUpO1xuXHRcdH1cblx0fSk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdHZhciBpbmRleCA9IGJpbmRpbmdfZ3JvdXAuaW5kZXhPZihpbnB1dCk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRiaW5kaW5nX2dyb3VwLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoIXBlbmRpbmcuaGFzKGJpbmRpbmdfZ3JvdXApKSB7XG5cdFx0cGVuZGluZy5hZGQoYmluZGluZ19ncm91cCk7XG5cblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdC8vIG5lY2Vzc2FyeSB0byBtYWludGFpbiBiaW5kaW5nIGdyb3VwIG9yZGVyIGluIGFsbCBpbnNlcnRpb24gc2NlbmFyaW9zXG5cdFx0XHRiaW5kaW5nX2dyb3VwLnNvcnQoKGEsIGIpID0+IChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpID09PSA0ID8gLTEgOiAxKSk7XG5cdFx0XHRwZW5kaW5nLmRlbGV0ZShiaW5kaW5nX2dyb3VwKTtcblx0XHR9KTtcblx0fVxuXG5cdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpb25fbWlzbWF0Y2gpIHtcblx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoYmluZGluZ19ncm91cCwgdmFsdWUsIGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGh5ZHJhdGlvbl9pbnB1dCA9IGJpbmRpbmdfZ3JvdXAuZmluZCgoaW5wdXQpID0+IGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdHZhbHVlID0gaHlkcmF0aW9uX2lucHV0Py5fX3ZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXQodmFsdWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9jaGVja2VkKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gaXNfcmVzZXQgPyBpbnB1dC5kZWZhdWx0Q2hlY2tlZCA6IGlucHV0LmNoZWNrZWQ7XG5cdFx0c2V0KHZhbHVlKTtcblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0KGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0Q2hlY2tlZCAhPT0gaW5wdXQuY2hlY2tlZCkgfHxcblx0XHQvLyBJZiBkZWZhdWx0Q2hlY2tlZCBpcyBzZXQsIHRoZW4gY2hlY2tlZCA9PSBkZWZhdWx0Q2hlY2tlZFxuXHRcdHVudHJhY2soZ2V0KSA9PSBudWxsXG5cdCkge1xuXHRcdHNldChpbnB1dC5jaGVja2VkKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXHRcdGlucHV0LmNoZWNrZWQgPSBCb29sZWFuKHZhbHVlKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7QXJyYXk8SFRNTElucHV0RWxlbWVudD59IGdyb3VwXG4gKiBAcGFyYW0ge1Z9IF9fdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZFxuICogQHJldHVybnMge1ZbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0dmFyIHZhbHVlID0gbmV3IFNldCgpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXG5cdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpIHtcblx0dmFyIHR5cGUgPSBpbnB1dC50eXBlO1xuXHRyZXR1cm4gdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3JhbmdlJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gRmlsZUxpc3QgfCBudWxsfSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiBGaWxlTGlzdCB8IG51bGwpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9maWxlcyhpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2NoYW5nZScsICgpID0+IHtcblx0XHRzZXQoaW5wdXQuZmlsZXMpO1xuXHR9KTtcblxuXHRpZiAoXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLFxuXHRcdC8vIHRoZW4gdXNlIHRoZSB1cGRhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0aHlkcmF0aW5nICYmXG5cdFx0aW5wdXQuZmlsZXNcblx0KSB7XG5cdFx0c2V0KGlucHV0LmZpbGVzKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlucHV0LmZpbGVzID0gZ2V0KCk7XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIE1ha2VzIGFuIGBleHBvcnRgZWQgKG5vbi1wcm9wKSB2YXJpYWJsZSBhdmFpbGFibGUgb24gdGhlIGAkJHByb3BzYCBvYmplY3RcbiAqIHNvIHRoYXQgY29uc3VtZXJzIGNhbiBkbyBgYmluZDp4YCBvbiB0aGUgY29tcG9uZW50LlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3Byb3AocHJvcHMsIHByb3AsIHZhbHVlKSB7XG5cdHZhciBkZXNjID0gZ2V0X2Rlc2NyaXB0b3IocHJvcHMsIHByb3ApO1xuXG5cdGlmIChkZXNjICYmIGRlc2Muc2V0KSB7XG5cdFx0cHJvcHNbcHJvcF0gPSB2YWx1ZTtcblx0XHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0XHRwcm9wc1twcm9wXSA9IG51bGw7XG5cdFx0fSk7XG5cdH1cbn1cbiIsImltcG9ydCB7IGVmZmVjdCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50IH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uLy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi8uLi8uLi9wcm94eS5qcyc7XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoaXMgaXMgYSBtdWx0aXBsZSBzZWxlY3QpXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFttb3VudGluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcblx0aWYgKHNlbGVjdC5tdWx0aXBsZSkge1xuXHRcdHJldHVybiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKTtcblx0fVxuXG5cdGZvciAodmFyIG9wdGlvbiBvZiBzZWxlY3Qub3B0aW9ucykge1xuXHRcdHZhciBvcHRpb25fdmFsdWUgPSBnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbik7XG5cdFx0aWYgKGlzKG9wdGlvbl92YWx1ZSwgdmFsdWUpKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcblx0fVxufVxuXG4vKipcbiAqIFNlbGVjdHMgdGhlIGNvcnJlY3Qgb3B0aW9uKHMpIGlmIGB2YWx1ZWAgaXMgZ2l2ZW4sXG4gKiBhbmQgdGhlbiBzZXRzIHVwIGEgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gc3luYyB0aGVcbiAqIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBkb20gd2hlbiBpdCBjaGFuZ2VzLiBTdWNoXG4gKiBjaGFuZ2VzIGNvdWxkIGZvciBleGFtcGxlIG9jY3VyIHdoZW4gb3B0aW9ucyBhcmVcbiAqIGluc2lkZSBhbiBgI2VhY2hgIGJsb2NrLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICogQHBhcmFtIHsoKSA9PiBWfSBbZ2V0X3ZhbHVlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9zZWxlY3Qoc2VsZWN0LCBnZXRfdmFsdWUpIHtcblx0bGV0IG1vdW50aW5nID0gdHJ1ZTtcblx0ZWZmZWN0KCgpID0+IHtcblx0XHRpZiAoZ2V0X3ZhbHVlKSB7XG5cdFx0XHRzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdW50cmFjayhnZXRfdmFsdWUpLCBtb3VudGluZyk7XG5cdFx0fVxuXHRcdG1vdW50aW5nID0gZmFsc2U7XG5cblx0XHR2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR2YXIgdmFsdWUgPSBzZWxlY3QuX192YWx1ZTtcblx0XHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSk7XG5cdFx0XHQvLyBEZWxpYmVyYXRlbHkgZG9uJ3QgdXBkYXRlIHRoZSBwb3RlbnRpYWwgYmluZGluZyB2YWx1ZSxcblx0XHRcdC8vIHRoZSBtb2RlbCBzaG91bGQgYmUgcHJlc2VydmVkIHVubGVzcyBleHBsaWNpdGx5IGNoYW5nZWRcblx0XHR9KTtcblxuXHRcdG9ic2VydmVyLm9ic2VydmUoc2VsZWN0LCB7XG5cdFx0XHQvLyBMaXN0ZW4gdG8gb3B0aW9uIGVsZW1lbnQgY2hhbmdlc1xuXHRcdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdFx0c3VidHJlZTogdHJ1ZSwgLy8gYmVjYXVzZSBvZiA8b3B0Z3JvdXA+XG5cdFx0XHQvLyBMaXN0ZW4gdG8gb3B0aW9uIGVsZW1lbnQgdmFsdWUgYXR0cmlidXRlIGNoYW5nZXNcblx0XHRcdC8vIChkb2Vzbid0IGdldCBub3RpZmllZCBvZiBzZWxlY3QgdmFsdWUgY2hhbmdlcyxcblx0XHRcdC8vIGJlY2F1c2UgdGhhdCBwcm9wZXJ0eSBpcyBub3QgcmVmbGVjdGVkIGFzIGFuIGF0dHJpYnV0ZSlcblx0XHRcdGF0dHJpYnV0ZXM6IHRydWUsXG5cdFx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFsndmFsdWUnXVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfc2VsZWN0X3ZhbHVlKHNlbGVjdCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIG1vdW50aW5nID0gdHJ1ZTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KHNlbGVjdCwgJ2NoYW5nZScsIChpc19yZXNldCkgPT4ge1xuXHRcdHZhciBxdWVyeSA9IGlzX3Jlc2V0ID8gJ1tzZWxlY3RlZF0nIDogJzpjaGVja2VkJztcblx0XHQvKiogQHR5cGUge3Vua25vd259ICovXG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aWYgKHNlbGVjdC5tdWx0aXBsZSkge1xuXHRcdFx0dmFsdWUgPSBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGdldF9vcHRpb25fdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiogQHR5cGUge0hUTUxPcHRpb25FbGVtZW50IHwgbnVsbH0gKi9cblx0XHRcdHZhciBzZWxlY3RlZF9vcHRpb24gPVxuXHRcdFx0XHRzZWxlY3QucXVlcnlTZWxlY3RvcihxdWVyeSkgPz9cblx0XHRcdFx0Ly8gd2lsbCBmYWxsIGJhY2sgdG8gZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbiBpZiBubyBvcHRpb24gaXMgc2VsZWN0ZWRcblx0XHRcdFx0c2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJ29wdGlvbjpub3QoW2Rpc2FibGVkXSknKTtcblx0XHRcdHZhbHVlID0gc2VsZWN0ZWRfb3B0aW9uICYmIGdldF9vcHRpb25fdmFsdWUoc2VsZWN0ZWRfb3B0aW9uKTtcblx0XHR9XG5cblx0XHRzZXQodmFsdWUpO1xuXHR9KTtcblxuXHQvLyBOZWVkcyB0byBiZSBhbiBlZmZlY3QsIG5vdCBhIHJlbmRlcl9lZmZlY3QsIHNvIHRoYXQgaW4gY2FzZSBvZiBlYWNoIGxvb3BzIHRoZSBsb2dpYyBydW5zIGFmdGVyIHRoZSBlYWNoIGJsb2NrIGhhcyB1cGRhdGVkXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZyk7XG5cblx0XHQvLyBNb3VudGluZyBhbmQgdmFsdWUgdW5kZWZpbmVkIC0+IHRha2Ugc2VsZWN0aW9uIGZyb20gZG9tXG5cdFx0aWYgKG1vdW50aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpO1xuXHRcdFx0aWYgKHNlbGVjdGVkX29wdGlvbiAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUoc2VsZWN0ZWRfb3B0aW9uKTtcblx0XHRcdFx0c2V0KHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c2VsZWN0Ll9fdmFsdWUgPSB2YWx1ZTtcblx0XHRtb3VudGluZyA9IGZhbHNlO1xuXHR9KTtcblxuXHQvLyBkb24ndCBwYXNzIGdldF92YWx1ZSwgd2UgYWxyZWFkeSBpbml0aWFsaXplIGl0IGluIHRoZSBlZmZlY3QgYWJvdmVcblx0aW5pdF9zZWxlY3Qoc2VsZWN0KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpIHtcblx0Zm9yICh2YXIgb3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKGdldF9vcHRpb25fdmFsdWUob3B0aW9uKSk7XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7SFRNTE9wdGlvbkVsZW1lbnR9IG9wdGlvbiAqL1xuZnVuY3Rpb24gZ2V0X29wdGlvbl92YWx1ZShvcHRpb24pIHtcblx0Ly8gX192YWx1ZSBvbmx5IGV4aXN0cyBpZiB0aGUgPG9wdGlvbj4gaGFzIGEgdmFsdWUgYXR0cmlidXRlXG5cdGlmICgnX192YWx1ZScgaW4gb3B0aW9uKSB7XG5cdFx0cmV0dXJuIG9wdGlvbi5fX3ZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBvcHRpb24udmFsdWU7XG5cdH1cbn1cbiIsImltcG9ydCB7IFNUQVRFX1NZTUJPTCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBlZmZlY3QsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uLy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uLy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBib3VuZF92YWx1ZVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50X29yX2NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzX2JvdW5kX3RoaXMoYm91bmRfdmFsdWUsIGVsZW1lbnRfb3JfY29tcG9uZW50KSB7XG5cdHJldHVybiAoXG5cdFx0Ym91bmRfdmFsdWUgPT09IGVsZW1lbnRfb3JfY29tcG9uZW50IHx8IGJvdW5kX3ZhbHVlPy5bU1RBVEVfU1lNQk9MXSA9PT0gZWxlbWVudF9vcl9jb21wb25lbnRcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZWxlbWVudF9vcl9jb21wb25lbnRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duLCAuLi5wYXJ0czogdW5rbm93bltdKSA9PiB2b2lkfSB1cGRhdGVcbiAqIEBwYXJhbSB7KC4uLnBhcnRzOiB1bmtub3duW10pID0+IHVua25vd259IGdldF92YWx1ZVxuICogQHBhcmFtIHsoKSA9PiB1bmtub3duW119IFtnZXRfcGFydHNdIFNldCBpZiB0aGUgdGhpcyBiaW5kaW5nIGlzIHVzZWQgaW5zaWRlIGFuIGVhY2ggYmxvY2ssXG4gKiBcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybnMgYWxsIHRoZSBwYXJ0cyBvZiB0aGUgZWFjaCBibG9jayBjb250ZXh0IHRoYXQgYXJlIHVzZWQgaW4gdGhlIGV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF90aGlzKGVsZW1lbnRfb3JfY29tcG9uZW50ID0ge30sIHVwZGF0ZSwgZ2V0X3ZhbHVlLCBnZXRfcGFydHMpIHtcblx0ZWZmZWN0KCgpID0+IHtcblx0XHQvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblx0XHR2YXIgb2xkX3BhcnRzO1xuXG5cdFx0LyoqIEB0eXBlIHt1bmtub3duW119ICovXG5cdFx0dmFyIHBhcnRzO1xuXG5cdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvbGRfcGFydHMgPSBwYXJ0cztcblx0XHRcdC8vIFdlIG9ubHkgdHJhY2sgY2hhbmdlcyB0byB0aGUgcGFydHMsIG5vdCB0aGUgdmFsdWUgaXRzZWxmIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcnVucy5cblx0XHRcdHBhcnRzID0gZ2V0X3BhcnRzPy4oKSB8fCBbXTtcblxuXHRcdFx0dW50cmFjaygoKSA9PiB7XG5cdFx0XHRcdGlmIChlbGVtZW50X29yX2NvbXBvbmVudCAhPT0gZ2V0X3ZhbHVlKC4uLnBhcnRzKSkge1xuXHRcdFx0XHRcdHVwZGF0ZShlbGVtZW50X29yX2NvbXBvbmVudCwgLi4ucGFydHMpO1xuXHRcdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gZWZmZWN0IHJlcnVuIChjYXVzZTogZWFjaCBibG9jayBjb250ZXh0IGNoYW5nZXMpLCB0aGVuIG51bGxmaXkgdGhlIGJpbmRpbmcgYXRcblx0XHRcdFx0XHQvLyB0aGUgcHJldmlvdXMgcG9zaXRpb24gaWYgaXQgaXNuJ3QgYWxyZWFkeSB0YWtlbiBvdmVyIGJ5IGEgZGlmZmVyZW50IGVmZmVjdC5cblx0XHRcdFx0XHRpZiAob2xkX3BhcnRzICYmIGlzX2JvdW5kX3RoaXMoZ2V0X3ZhbHVlKC4uLm9sZF9wYXJ0cyksIGVsZW1lbnRfb3JfY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdFx0dXBkYXRlKG51bGwsIC4uLm9sZF9wYXJ0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHQvLyBXZSBjYW5ub3QgdXNlIGVmZmVjdHMgaW4gdGhlIHRlYXJkb3duIHBoYXNlLCB3ZSB3ZSB1c2UgYSBtaWNyb3Rhc2sgaW5zdGVhZC5cblx0XHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRpZiAocGFydHMgJiYgaXNfYm91bmRfdGhpcyhnZXRfdmFsdWUoLi4ucGFydHMpLCBlbGVtZW50X29yX2NvbXBvbmVudCkpIHtcblx0XHRcdFx0XHR1cGRhdGUobnVsbCwgLi4ucGFydHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudF9vcl9jb21wb25lbnQ7XG59XG4iLCIvKiogQGltcG9ydCB7IEFjdGlvblJldHVybiB9IGZyb20gJ3N2ZWx0ZS9hY3Rpb24nICovXG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJfcHJlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBvbiB9IGZyb20gJy4uL2VsZW1lbnRzL2V2ZW50cy5qcyc7XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGB0cnVzdGVkYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RlZChmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Zm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHNlbGZgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxmKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0Zm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHN0b3BQcm9wYWdhdGlvbmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBvbmNlYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25jZShmbikge1xuXHR2YXIgcmFuID0gZmFsc2U7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHJhbikgcmV0dXJuO1xuXHRcdHJhbiA9IHRydWU7XG5cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHR2YXIgZXZlbnQgPSAvKiogQHR5cGUge0V2ZW50fSAqLyAoYXJnc1swXSk7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBwcmV2ZW50RGVmYXVsdGAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgcGFzc2l2ZWAgZXZlbnQgbW9kaWZpZXIsIGltcGxlbWVudGVkIGFzIGFuIGFjdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7W2V2ZW50OiBzdHJpbmcsIGhhbmRsZXI6ICgpID0+IEV2ZW50TGlzdGVuZXJdfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXNzaXZlKG5vZGUsIFtldmVudCwgaGFuZGxlcl0pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRyZXR1cm4gb24obm9kZSwgZXZlbnQsIGhhbmRsZXIoKSA/PyBub29wLCB7XG5cdFx0XHRwYXNzaXZlOiB0cnVlXG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgbm9ucGFzc2l2ZWAgZXZlbnQgbW9kaWZpZXIsIGltcGxlbWVudGVkIGFzIGFuIGFjdGlvblxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7W2V2ZW50OiBzdHJpbmcsIGhhbmRsZXI6ICgpID0+IEV2ZW50TGlzdGVuZXJdfSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25wYXNzaXZlKG5vZGUsIFtldmVudCwgaGFuZGxlcl0pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRyZXR1cm4gb24obm9kZSwgZXZlbnQsIGhhbmRsZXIoKSA/PyBub29wLCB7XG5cdFx0XHRwYXNzaXZlOiBmYWxzZVxuXHRcdH0pO1xuXHR9KTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBydW4sIHJ1bl9hbGwgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGRlcml2ZWQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IHVzZXJfcHJlX2VmZmVjdCwgdXNlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGVlcF9yZWFkX3N0YXRlLCBnZXQsIHVudHJhY2sgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBMZWdhY3ktbW9kZSBvbmx5OiBDYWxsIGBvbk1vdW50YCBjYWxsYmFja3MgYW5kIHNldCB1cCBgYmVmb3JlVXBkYXRlYC9gYWZ0ZXJVcGRhdGVgIGVmZmVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoaW1tdXRhYmxlID0gZmFsc2UpIHtcblx0Y29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHRjb25zdCBjYWxsYmFja3MgPSBjb250ZXh0LmwudTtcblx0aWYgKCFjYWxsYmFja3MpIHJldHVybjtcblxuXHRsZXQgcHJvcHMgPSAoKSA9PiBkZWVwX3JlYWRfc3RhdGUoY29udGV4dC5zKTtcblxuXHRpZiAoaW1tdXRhYmxlKSB7XG5cdFx0bGV0IHZlcnNpb24gPSAwO1xuXHRcdGxldCBwcmV2ID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pO1xuXG5cdFx0Ly8gSW4gbGVnYWN5IGltbXV0YWJsZSBtb2RlLCBiZWZvcmUvYWZ0ZXJVcGRhdGUgb25seSBmaXJlIGlmIHRoZSBvYmplY3QgaWRlbnRpdHkgb2YgYSBwcm9wIGNoYW5nZXNcblx0XHRjb25zdCBkID0gZGVyaXZlZCgoKSA9PiB7XG5cdFx0XHRsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgcHJvcHMgPSBjb250ZXh0LnM7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHNba2V5XSAhPT0gcHJldltrZXldKSB7XG5cdFx0XHRcdFx0cHJldltrZXldID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNoYW5nZWQpIHZlcnNpb24rKztcblx0XHRcdHJldHVybiB2ZXJzaW9uO1xuXHRcdH0pO1xuXG5cdFx0cHJvcHMgPSAoKSA9PiBnZXQoZCk7XG5cdH1cblxuXHQvLyBiZWZvcmVVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5iLmxlbmd0aCkge1xuXHRcdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcyk7XG5cdFx0XHRydW5fYWxsKGNhbGxiYWNrcy5iKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIG9uTW91bnQgKG11c3QgcnVuIGJlZm9yZSBhZnRlclVwZGF0ZSlcblx0dXNlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGNvbnN0IGZucyA9IHVudHJhY2soKCkgPT4gY2FsbGJhY2tzLm0ubWFwKHJ1bikpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuXHRcdFx0XHRpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Zm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdC8vIGFmdGVyVXBkYXRlXG5cdGlmIChjYWxsYmFja3MuYS5sZW5ndGgpIHtcblx0XHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcyk7XG5cdFx0XHRydW5fYWxsKGNhbGxiYWNrcy5hKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEludm9rZSB0aGUgZ2V0dGVyIG9mIGFsbCBzaWduYWxzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBvbmVudFxuICogc28gdGhleSBjYW4gYmUgcmVnaXN0ZXJlZCB0byB0aGUgZWZmZWN0IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluLlxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSBjb250ZXh0XG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZV9hbGwoY29udGV4dCwgcHJvcHMpIHtcblx0aWYgKGNvbnRleHQubC5zKSB7XG5cdFx0Zm9yIChjb25zdCBzaWduYWwgb2YgY29udGV4dC5sLnMpIGdldChzaWduYWwpO1xuXHR9XG5cblx0cHJvcHMoKTtcbn1cbiIsImltcG9ydCB7IHNldCwgc291cmNlIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIFVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgaW1wb3J0cyBtYXkgYmUgcmVhY3RpdmUgaW4gbGVnYWN5IG1vZGUuIEluIHRoYXQgY2FzZSxcbiAqIHRoZXkgc2hvdWxkIGJlIHVzaW5nIGByZWFjdGl2ZV9pbXBvcnRgIGFzIHBhcnQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWN0aXZlX2ltcG9ydChmbikge1xuXHR2YXIgcyA9IHNvdXJjZSgwKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRzZXQocywgZ2V0KHMpICsgMSk7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzWzBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXQocyk7XG5cdFx0XHRyZXR1cm4gZm4oKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHRoaXMge2FueX1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59ICQkcHJvcHNcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1YmJsZV9ldmVudCgkJHByb3BzLCBldmVudCkge1xuXHR2YXIgZXZlbnRzID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbltdIHwgRnVuY3Rpb24+fSAqLyAoJCRwcm9wcy4kJGV2ZW50cyk/Lltcblx0XHRldmVudC50eXBlXG5cdF07XG5cblx0dmFyIGNhbGxiYWNrcyA9IGlzX2FycmF5KGV2ZW50cykgPyBldmVudHMuc2xpY2UoKSA6IGV2ZW50cyA9PSBudWxsID8gW10gOiBbZXZlbnRzXTtcblxuXHRmb3IgKHZhciBmbiBvZiBjYWxsYmFja3MpIHtcblx0XHQvLyBQcmVzZXJ2ZSBcInRoaXNcIiBjb250ZXh0XG5cdFx0Zm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNpbXVsYXRlIGAkb25gIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIHdoZW4gYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpID09PSA0YFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRfY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9sZWdhY3lfZXZlbnRfbGlzdGVuZXIoJCRwcm9wcywgZXZlbnRfbmFtZSwgZXZlbnRfY2FsbGJhY2spIHtcblx0JCRwcm9wcy4kJGV2ZW50cyB8fD0ge307XG5cdCQkcHJvcHMuJCRldmVudHNbZXZlbnRfbmFtZV0gfHw9IFtdO1xuXHQkJHByb3BzLiQkZXZlbnRzW2V2ZW50X25hbWVdLnB1c2goZXZlbnRfY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFVzZWQgdG8gc2ltdWxhdGUgYCRzZXRgIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIHdoZW4gYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpID09PSA0YC5cbiAqIE5lZWRzIGNvbXBvbmVudCBhY2Nlc3NvcnMgc28gdGhhdCBpdCBjYW4gY2FsbCB0aGUgc2V0dGVyIG9mIHRoZSBwcm9wLiBUaGVyZWZvcmUgZG9lc24ndFxuICogd29yayBmb3IgdXBkYXRpbmcgcHJvcHMgaW4gYCQkcHJvcHNgIG9yIGAkJHJlc3RQcm9wc2AuXG4gKiBAdGhpcyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRuZXdfcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9sZWdhY3lfcHJvcHMoJCRuZXdfcHJvcHMpIHtcblx0Zm9yICh2YXIga2V5IGluICQkbmV3X3Byb3BzKSB7XG5cdFx0aWYgKGtleSBpbiB0aGlzKSB7XG5cdFx0XHR0aGlzW2tleV0gPSAkJG5ld19wcm9wc1trZXldO1xuXHRcdH1cblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJy4vcHVibGljJyAqL1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL2luZGV4LWNsaWVudC5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vaW50ZXJuYWwvc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPiB8IG51bGwgfCB1bmRlZmluZWR9IHN0b3JlXG4gKiBAcGFyYW0geyh2YWx1ZTogVCkgPT4gdm9pZH0gcnVuXG4gKiBAcGFyYW0geyh2YWx1ZTogVCkgPT4gdm9pZH0gW2ludmFsaWRhdGVdXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgcnVuLCBpbnZhbGlkYXRlKSB7XG5cdGlmIChzdG9yZSA9PSBudWxsKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHJ1bih1bmRlZmluZWQpO1xuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGlmIChpbnZhbGlkYXRlKSBpbnZhbGlkYXRlKHVuZGVmaW5lZCk7XG5cblx0XHRyZXR1cm4gbm9vcDtcblx0fVxuXG5cdC8vIFN2ZWx0ZSBzdG9yZSB0YWtlcyBhIHByaXZhdGUgc2Vjb25kIGFyZ3VtZW50XG5cdC8vIFN0YXJ0U3RvcE5vdGlmaWVyIGNvdWxkIG11dGF0ZSBzdGF0ZSwgYW5kIHdlIHdhbnQgdG8gc2lsZW5jZSB0aGUgY29ycmVzcG9uZGluZyB2YWxpZGF0aW9uIGVycm9yXG5cdGNvbnN0IHVuc3ViID0gdW50cmFjaygoKSA9PlxuXHRcdHN0b3JlLnN1YnNjcmliZShcblx0XHRcdHJ1bixcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGludmFsaWRhdGVcblx0XHQpXG5cdCk7XG5cblx0Ly8gQWxzbyBzdXBwb3J0IFJ4SlNcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGZpeCB0aGlzIGluIHRoZSB0eXBlcz9cblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSwgU3RhcnRTdG9wTm90aWZpZXIsIFN1YnNjcmliZXIsIFVuc3Vic2NyaWJlciwgVXBkYXRlciwgV3JpdGFibGUgfSBmcm9tICcuLi9wdWJsaWMuanMnICovXG4vKiogQGltcG9ydCB7IFN0b3JlcywgU3RvcmVzVmFsdWVzLCBTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGUgfSBmcm9tICcuLi9wcml2YXRlLmpzJyAqL1xuaW1wb3J0IHsgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBzYWZlX25vdF9lcXVhbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPGFueT4gfCBhbnk+fVxuICovXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtXcml0YWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcblx0LyoqIEB0eXBlIHtVbnN1YnNjcmliZXIgfCBudWxsfSAqL1xuXHRsZXQgc3RvcCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtTZXQ8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuXHRcdGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRpZiAoc3RvcCkge1xuXHRcdFx0XHQvLyBzdG9yZSBpcyByZWFkeVxuXHRcdFx0XHRjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuXHRcdFx0XHRcdHN1YnNjcmliZXJbMV0oKTtcblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLnB1c2goc3Vic2NyaWJlciwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5fcXVldWUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGRhdGVyPFQ+fSBmblxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuXHRcdHNldChmbigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N1YnNjcmliZXI8VD59IHJ1blxuXHQgKiBAcGFyYW0geygpID0+IHZvaWR9IFtpbnZhbGlkYXRlXVxuXHQgKiBAcmV0dXJucyB7VW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge1N1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPn0gKi9cblx0XHRjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG5cdFx0c3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG5cdFx0XHRzdG9wID0gc3RhcnQoc2V0LCB1cGRhdGUpIHx8IG5vb3A7XG5cdFx0fVxuXHRcdHJ1bigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cdFx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG5cdFx0XHRcdHN0b3AoKTtcblx0XHRcdFx0c3RvcCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBAdGVtcGxhdGUge1N0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IFVwZGF0ZXI8VD4pID0+IHZvaWQpID0+IFVuc3Vic2NyaWJlciB8IHZvaWR9IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFN0b3Jlc1ZhbHVlczxTPikgPT4gVH0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbi8qKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcblx0Y29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcblx0LyoqIEB0eXBlIHtBcnJheTxSZWFkYWJsZTxhbnk+Pn0gKi9cblx0Y29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlID8gW3N0b3Jlc10gOiBzdG9yZXM7XG5cdGlmICghc3RvcmVzX2FycmF5LmV2ZXJ5KEJvb2xlYW4pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkKCkgZXhwZWN0cyBzdG9yZXMgYXMgaW5wdXQsIGdvdCBhIGZhbHN5IHZhbHVlJyk7XG5cdH1cblx0Y29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG5cdHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0LCB1cGRhdGUpID0+IHtcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7VFtdfSAqL1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdGxldCBwZW5kaW5nID0gMDtcblx0XHRsZXQgY2xlYW51cCA9IG5vb3A7XG5cdFx0Y29uc3Qgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmIChwZW5kaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0LCB1cGRhdGUpO1xuXHRcdFx0aWYgKGF1dG8pIHtcblx0XHRcdFx0c2V0KHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbnVwID0gdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJyA/IHJlc3VsdCA6IG5vb3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+XG5cdFx0XHRzdWJzY3JpYmVfdG9fc3RvcmUoXG5cdFx0XHRcdHN0b3JlLFxuXHRcdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRwZW5kaW5nICY9IH4oMSA8PCBpKTtcblx0XHRcdFx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0c3luYygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHBlbmRpbmcgfD0gMSA8PCBpO1xuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRzeW5jKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcblx0XHRcdC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcblx0XHRcdC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdG9yZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUgZGVyaXZlZCBmcm9tIHRoZSBvbGQgb25lIHRoYXQgaXMgcmVhZGFibGUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UmVhZGFibGU8VD59IHN0b3JlICAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGkgc3VzcGVjdCB0aGUgYmluZCBpcyB1bm5lY2Vzc2FyeVxuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLmJpbmQoc3RvcmUpXG5cdH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZyb20gYSBzdG9yZSBieSBzdWJzY3JpYmluZyBhbmQgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmluZy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHZhbHVlO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBTdG9yZVJlZmVyZW5jZXNDb250YWluZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBTdG9yZSB9IGZyb20gJyNzaGFyZWQnICovXG5pbXBvcnQgeyBzdWJzY3JpYmVfdG9fc3RvcmUgfSBmcm9tICcuLi8uLi8uLi9zdG9yZS91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXQgYXMgZ2V0X3N0b3JlIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmUvc2hhcmVkL2luZGV4LmpzJztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgbm9vcCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG11dGFibGVfc291cmNlLCBzZXQgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wIGN1cnJlbnRseSBiZWluZyByZWFkIGlzIGEgc3RvcmUgYmluZGluZywgYXMgaW5cbiAqIGA8Q2hpbGQgYmluZDp4PXskeX0gLz5gLiBJZiBpdCBpcywgd2UgdHJlYXQgdGhlIHByb3AgYXMgbXV0YWJsZSBldmVuIGluXG4gKiBydW5lcyBtb2RlLCBhbmQgc2tpcCBgYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgIHZhbGlkYXRpb25cbiAqL1xubGV0IGlzX3N0b3JlX2JpbmRpbmcgPSBmYWxzZTtcblxubGV0IElTX1VOTU9VTlRFRCA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdG9yZS4gSWYgdGhlIHN0b3JlIGlzbid0IHN1YnNjcmliZWQgdG8geWV0LCBpdCB3aWxsIGNyZWF0ZSBhIHByb3h5XG4gKiBzaWduYWwgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGUgc3RvcmUgaXMuIFRoZSBzdG9yZSByZWZlcmVuY2VzIGNvbnRhaW5lciBpcyBuZWVkZWQgdG9cbiAqIHRyYWNrIHJlYXNzaWdubWVudHMgdG8gc3RvcmVzIGFuZCB0byB0cmFjayB0aGUgY29ycmVjdCBjb21wb25lbnQgY29udGV4dC5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2dldChzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdGNvbnN0IGVudHJ5ID0gKHN0b3Jlc1tzdG9yZV9uYW1lXSA/Pz0ge1xuXHRcdHN0b3JlOiBudWxsLFxuXHRcdHNvdXJjZTogbXV0YWJsZV9zb3VyY2UodW5kZWZpbmVkKSxcblx0XHR1bnN1YnNjcmliZTogbm9vcFxuXHR9KTtcblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IHRoYXQgc2V0dXAgdGhpcyBpcyBhbHJlYWR5IHVubW91bnRlZCB3ZSBkb24ndCB3YW50IHRvIHJlZ2lzdGVyIGEgc3Vic2NyaXB0aW9uXG5cdGlmIChlbnRyeS5zdG9yZSAhPT0gc3RvcmUgJiYgIShJU19VTk1PVU5URUQgaW4gc3RvcmVzKSkge1xuXHRcdGVudHJ5LnVuc3Vic2NyaWJlKCk7XG5cdFx0ZW50cnkuc3RvcmUgPSBzdG9yZSA/PyBudWxsO1xuXG5cdFx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRcdGVudHJ5LnNvdXJjZS52ID0gdW5kZWZpbmVkOyAvLyBzZWUgc3luY2hyb25vdXMgY2FsbGJhY2sgY29tbWVudCBiZWxvd1xuXHRcdFx0ZW50cnkudW5zdWJzY3JpYmUgPSBub29wO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaXNfc3luY2hyb25vdXNfY2FsbGJhY2sgPSB0cnVlO1xuXG5cdFx0XHRlbnRyeS51bnN1YnNjcmliZSA9IHN1YnNjcmliZV90b19zdG9yZShzdG9yZSwgKHYpID0+IHtcblx0XHRcdFx0aWYgKGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGZpcnN0IHVwZGF0ZXMgdG8gdGhlIHN0b3JlIHZhbHVlIChwb3NzaWJseSBtdWx0aXBsZSBvZiB0aGVtKSBhcmUgc3luY2hyb25vdXNseVxuXHRcdFx0XHRcdC8vIGluc2lkZSBhIGRlcml2ZWQsIHdlIHdpbGwgaGl0IHRoZSBgc3RhdGVfdW5zYWZlX211dGF0aW9uYCBlcnJvciBpZiB3ZSBgc2V0YCB0aGUgdmFsdWVcblx0XHRcdFx0XHRlbnRyeS5zb3VyY2UudiA9IHY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0KGVudHJ5LnNvdXJjZSwgdik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpc19zeW5jaHJvbm91c19jYWxsYmFjayA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgdGhhdCBzZXR1cCB0aGlzIHN0b3JlcyBpcyBhbHJlYWR5IHVubW91bnRlZCB0aGUgc291cmNlIHdpbGwgYmUgb3V0IG9mIHN5bmNcblx0Ly8gc28gd2UganVzdCB1c2UgdGhlIGBnZXRgIGZvciB0aGUgc3RvcmVzLCBsZXNzIHBlcmZvcm1hbnQgYnV0IGl0IGF2b2lkcyB0byBjcmVhdGUgYSBtZW1vcnkgbGVha1xuXHQvLyBhbmQgaXQgd2lsbCBrZWVwIHRoZSB2YWx1ZSBjb25zaXN0ZW50XG5cdGlmIChzdG9yZSAmJiBJU19VTk1PVU5URUQgaW4gc3RvcmVzKSB7XG5cdFx0cmV0dXJuIGdldF9zdG9yZShzdG9yZSk7XG5cdH1cblxuXHRyZXR1cm4gZ2V0KGVudHJ5LnNvdXJjZSk7XG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGlmIGl0J3Mgbm90IHRoZSBzYW1lIGFzIHRoZSBvbmUgaW4gdGhlIHN0b3JlIHJlZmVyZW5jZXMgY29udGFpbmVyLlxuICogV2UgbmVlZCB0aGlzIGluIGFkZGl0aW9uIHRvIGBzdG9yZV9nZXRgIGJlY2F1c2Ugc29tZW9uZSBjb3VsZCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgYnV0XG4gKiB0aGVuIG5ldmVyIHN1YnNjcmliZSB0byB0aGUgbmV3IG9uZSAoaWYgYW55KSwgY2F1c2luZyB0aGUgc3Vic2NyaXB0aW9uIHRvIHN0YXkgb3BlbiB3cm9uZ2Z1bGx5LlxuICogQHBhcmFtIHtTdG9yZTxhbnk+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV91bnN1YihzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdC8qKiBAdHlwZSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyWycnXSB8IHVuZGVmaW5lZH0gKi9cblx0bGV0IGVudHJ5ID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXG5cdGlmIChlbnRyeSAmJiBlbnRyeS5zdG9yZSAhPT0gc3RvcmUpIHtcblx0XHQvLyBEb24ndCByZXNldCBzdG9yZSB5ZXQsIHNvIHRoYXQgc3RvcmVfZ2V0IGFib3ZlIGNhbiByZXN1YnNjcmliZSB0byBuZXcgc3RvcmUgaWYgbmVjZXNzYXJ5XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdH1cblxuXHRyZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbmV3IHZhbHVlIG9mIGEgc3RvcmUgYW5kIHJldHVybnMgdGhhdCB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+fSBzdG9yZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9zZXQoc3RvcmUsIHZhbHVlKSB7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVfbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZV9zdG9yZShzdG9yZXMsIHN0b3JlX25hbWUpIHtcblx0dmFyIGVudHJ5ID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXHRpZiAoZW50cnkuc3RvcmUgIT09IG51bGwpIHtcblx0XHRzdG9yZV9zZXQoZW50cnkuc3RvcmUsIGVudHJ5LnNvdXJjZS52KTtcblx0fVxufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlcyBmcm9tIGFsbCBhdXRvLXN1YnNjcmliZWQgc3RvcmVzIG9uIGRlc3Ryb3lcbiAqIEByZXR1cm5zIHtbU3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyLCAoKT0+dm9pZF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cF9zdG9yZXMoKSB7XG5cdC8qKiBAdHlwZSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSAqL1xuXHRjb25zdCBzdG9yZXMgPSB7fTtcblxuXHRmdW5jdGlvbiBjbGVhbnVwKCkge1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdGZvciAodmFyIHN0b3JlX25hbWUgaW4gc3RvcmVzKSB7XG5cdFx0XHRcdGNvbnN0IHJlZiA9IHN0b3Jlc1tzdG9yZV9uYW1lXTtcblx0XHRcdFx0cmVmLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVfcHJvcGVydHkoc3RvcmVzLCBJU19VTk1PVU5URUQsIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHRcdHZhbHVlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBbc3RvcmVzLCBjbGVhbnVwXTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGEgc3RvcmUgd2l0aCBhIG5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlICB0aGUgc3RvcmUgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gZXhwcmVzc2lvbiAgdGhlIGV4cHJlc3Npb24gdGhhdCBtdXRhdGVzIHRoZSBzdG9yZVxuICogQHBhcmFtIHtWfSBuZXdfdmFsdWUgIHRoZSBuZXcgc3RvcmUgdmFsdWVcbiAqIEB0ZW1wbGF0ZSBWXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZV9tdXRhdGUoc3RvcmUsIGV4cHJlc3Npb24sIG5ld192YWx1ZSkge1xuXHRzdG9yZS5zZXQobmV3X3ZhbHVlKTtcblx0cmV0dXJuIGV4cHJlc3Npb247XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdG9yZTxudW1iZXI+fSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0b3JlX3ZhbHVlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3N0b3JlKHN0b3JlLCBzdG9yZV92YWx1ZSwgZCA9IDEpIHtcblx0c3RvcmUuc2V0KHN0b3JlX3ZhbHVlICsgZCk7XG5cdHJldHVybiBzdG9yZV92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcmVfdmFsdWVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3N0b3JlKHN0b3JlLCBzdG9yZV92YWx1ZSwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBzdG9yZV92YWx1ZSArIGQ7XG5cdHN0b3JlLnNldCh2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgaW5zaWRlIHByb3AgZ2V0dGVycyB0byBjb21tdW5pY2F0ZSB0aGF0IHRoZSBwcm9wIGlzIGEgc3RvcmUgYmluZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya19zdG9yZV9iaW5kaW5nKCkge1xuXHRpc19zdG9yZV9iaW5kaW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdHVwbGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBgZm4oKWAgcmVhZHMgYSBwcm9wIHRoYXQgaXMgYSBzdG9yZSBiaW5kaW5nLlxuICogVXNlZCB0byBwcmV2ZW50IGBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAgdmFsaWRhdGlvbiBmYWxzZSBwb3NpdGl2ZXMgYW5kXG4gKiBlbnN1cmUgdGhhdCB0aGVzZSBwcm9wcyBhcmUgdHJlYXRlZCBhcyBtdXRhYmxlIGV2ZW4gaW4gcnVuZXMgbW9kZVxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqIEByZXR1cm5zIHtbVCwgYm9vbGVhbl19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlX3N0b3JlX2JpbmRpbmcoZm4pIHtcblx0dmFyIHByZXZpb3VzX2lzX3N0b3JlX2JpbmRpbmcgPSBpc19zdG9yZV9iaW5kaW5nO1xuXG5cdHRyeSB7XG5cdFx0aXNfc3RvcmVfYmluZGluZyA9IGZhbHNlO1xuXHRcdHJldHVybiBbZm4oKSwgaXNfc3RvcmVfYmluZGluZ107XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfc3RvcmVfYmluZGluZyA9IHByZXZpb3VzX2lzX3N0b3JlX2JpbmRpbmc7XG5cdH1cbn1cbiIsIi8qKiBAaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi90eXBlcy5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0UFJPUFNfSVNfQklOREFCTEUsXG5cdFBST1BTX0lTX0lNTVVUQUJMRSxcblx0UFJPUFNfSVNfTEFaWV9JTklUSUFMLFxuXHRQUk9QU19JU19SVU5FUyxcblx0UFJPUFNfSVNfVVBEQVRFRFxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IG11dGFibGVfc291cmNlLCBzZXQsIHNvdXJjZSwgdXBkYXRlIH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGRlcml2ZWQsIGRlcml2ZWRfc2FmZV9lcXVhbCB9IGZyb20gJy4vZGVyaXZlZHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0Z2V0LFxuXHRjYXB0dXJlZF9zaWduYWxzLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0dW50cmFjayxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7XG5cdEJSQU5DSF9FRkZFQ1QsXG5cdExFR0FDWV9ERVJJVkVEX1BST1AsXG5cdExFR0FDWV9QUk9QUyxcblx0Uk9PVF9FRkZFQ1QsXG5cdFNUQVRFX1NZTUJPTFxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcHJveHkgfSBmcm9tICcuLi9wcm94eS5qcyc7XG5pbXBvcnQgeyBjYXB0dXJlX3N0b3JlX2JpbmRpbmcgfSBmcm9tICcuL3N0b3JlLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsoKHZhbHVlPzogbnVtYmVyKSA9PiBudW1iZXIpfSBmblxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcm9wKGZuLCBkID0gMSkge1xuXHRjb25zdCB2YWx1ZSA9IGZuKCk7XG5cdGZuKHZhbHVlICsgZCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygodmFsdWU/OiBudW1iZXIpID0+IG51bWJlcil9IGZuXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3ByZV9wcm9wKGZuLCBkID0gMSkge1xuXHRjb25zdCB2YWx1ZSA9IGZuKCkgKyBkO1xuXHRmbih2YWx1ZSk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgcHJveHkgaGFuZGxlciBmb3IgcmVzdCBwcm9wcyAoaS5lLiBgY29uc3QgeyB4LCAuLi5yZXN0IH0gPSAkcHJvcHMoKWApLlxuICogSXMgcGFzc2VkIHRoZSBmdWxsIGAkJHByb3BzYCBvYmplY3QgYW5kIGV4Y2x1ZGVzIHRoZSBuYW1lZCBwcm9wcy5cbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4sIGV4Y2x1ZGU6IEFycmF5PHN0cmluZyB8IHN5bWJvbD4sIG5hbWU/OiBzdHJpbmcgfT59fVxuICovXG5jb25zdCByZXN0X3Byb3BzX2hhbmRsZXIgPSB7XG5cdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cdFx0cmV0dXJuIHRhcmdldC5wcm9wc1trZXldO1xuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUucHJvcHNfcmVzdF9yZWFkb25seShgJHt0YXJnZXQubmFtZX0uJHtTdHJpbmcoa2V5KX1gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cdFx0aWYgKGtleSBpbiB0YXJnZXQucHJvcHMpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHRhcmdldC5wcm9wc1trZXldXG5cdFx0XHR9O1xuXHRcdH1cblx0fSxcblx0aGFzKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5wcm9wcztcblx0fSxcblx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRyZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldC5wcm9wcykuZmlsdGVyKChrZXkpID0+ICF0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKTtcblx0fVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gZXhjbHVkZVxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN0X3Byb3BzKHByb3BzLCBleGNsdWRlLCBuYW1lKSB7XG5cdHJldHVybiBuZXcgUHJveHkoXG5cdFx0REVWID8geyBwcm9wcywgZXhjbHVkZSwgbmFtZSwgb3RoZXI6IHt9LCB0b19wcm94eTogW10gfSA6IHsgcHJvcHMsIGV4Y2x1ZGUgfSxcblx0XHRyZXN0X3Byb3BzX2hhbmRsZXJcblx0KTtcbn1cblxuLyoqXG4gKiBUaGUgcHJveHkgaGFuZGxlciBmb3IgbGVnYWN5ICQkcmVzdFByb3BzIGFuZCAkJHByb3BzXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+LCBleGNsdWRlOiBBcnJheTxzdHJpbmcgfCBzeW1ib2w+LCBzcGVjaWFsOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCAodj86IHVua25vd24pID0+IHVua25vd24+LCB2ZXJzaW9uOiBTb3VyY2U8bnVtYmVyPiB9Pn19XG4gKi9cbmNvbnN0IGxlZ2FjeV9yZXN0X3Byb3BzX2hhbmRsZXIgPSB7XG5cdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cdFx0Z2V0KHRhcmdldC52ZXJzaW9uKTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5zcGVjaWFsID8gdGFyZ2V0LnNwZWNpYWxba2V5XSgpIDogdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcblx0XHRpZiAoIShrZXkgaW4gdGFyZ2V0LnNwZWNpYWwpKSB7XG5cdFx0XHQvLyBIYW5kbGUgcHJvcHMgdGhhdCBjYW4gdGVtcG9yYXJpbHkgZ2V0IG91dCBvZiBzeW5jIHdpdGggdGhlIHBhcmVudFxuXHRcdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCAodj86IHVua25vd24pID0+IHVua25vd24+fSAqL1xuXHRcdFx0dGFyZ2V0LnNwZWNpYWxba2V5XSA9IHByb3AoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRnZXQgW2tleV0oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiogQHR5cGUge3N0cmluZ30gKi8gKGtleSksXG5cdFx0XHRcdFBST1BTX0lTX1VQREFURURcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0LnNwZWNpYWxba2V5XSh2YWx1ZSk7XG5cdFx0dXBkYXRlKHRhcmdldC52ZXJzaW9uKTsgLy8gJCRwcm9wcyBpcyBjb2Fyc2UtZ3JhaW5lZDogd2hlbiAkJHByb3BzLnggaXMgdXBkYXRlZCwgdXNhZ2VzIG9mICQkcHJvcHMueSBldGMgYXJlIGFsc28gcmVydW5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuXHRcdC8vIFN2ZWx0ZSA0IGFsbG93ZWQgZm9yIGRlbGV0aW9ucyBvbiAkJHJlc3RQcm9wc1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gdHJ1ZTtcblx0XHR0YXJnZXQuZXhjbHVkZS5wdXNoKGtleSk7XG5cdFx0dXBkYXRlKHRhcmdldC52ZXJzaW9uKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0aGFzKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5wcm9wcztcblx0fSxcblx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRyZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldC5wcm9wcykuZmlsdGVyKChrZXkpID0+ICF0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKTtcblx0fVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmdbXX0gZXhjbHVkZVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHVua25vd24+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3Jlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUpIHtcblx0cmV0dXJuIG5ldyBQcm94eSh7IHByb3BzLCBleGNsdWRlLCBzcGVjaWFsOiB7fSwgdmVyc2lvbjogc291cmNlKDApIH0sIGxlZ2FjeV9yZXN0X3Byb3BzX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciBzcHJlYWQgcHJvcHMuIEhhbmRsZXMgdGhlIGluY29taW5nIGFycmF5IG9mIHByb3BzXG4gKiB0aGF0IGxvb2tzIGxpa2UgYCgpID0+IHsgZHluYW1pYzogcHJvcHMgfSwgeyBzdGF0aWM6IHByb3AgfSwgLi5gIGFuZCB3cmFwc1xuICogdGhlbSBzbyB0aGF0IHRoZSB3aG9sZSB0aGluZyBpcyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCBhcyB0aGUgYCQkcHJvcHNgIGFyZ3VtZW50LlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPn0gVFxuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBBcnJheTxUIHwgKCgpID0+IFQpPiB9Pn19XG4gKi9cbmNvbnN0IHNwcmVhZF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwgJiYga2V5IGluIHApIHJldHVybiBwW2tleV07XG5cdFx0fVxuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0Y29uc3QgZGVzYyA9IGdldF9kZXNjcmlwdG9yKHAsIGtleSk7XG5cdFx0XHRpZiAoZGVzYyAmJiBkZXNjLnNldCkge1xuXHRcdFx0XHRkZXNjLnNldCh2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmICh0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCAmJiBrZXkgaW4gcCkge1xuXHRcdFx0XHRjb25zdCBkZXNjcmlwdG9yID0gZ2V0X2Rlc2NyaXB0b3IocCwga2V5KTtcblx0XHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gUHJldmVudCBhIFwiTm9uLWNvbmZpZ3VyYWJpbGl0eSBSZXBvcnQgRXJyb3JcIjogVGhlIHRhcmdldCBpcyBhbiBhcnJheSwgaXQgZG9lc1xuXHRcdFx0XHRcdC8vIG5vdCBhY3R1YWxseSBjb250YWluIHRoaXMgcHJvcGVydHkuIElmIGl0IGlzIG5vdyBkZXNjcmliZWQgYXMgbm9uLWNvbmZpZ3VyYWJsZSxcblx0XHRcdFx0XHQvLyB0aGUgcHJveHkgdGhyb3dzIGEgdmFsaWRhdGlvbiBlcnJvci4gU2V0dGluZyBpdCB0byB0cnVlIGF2b2lkcyB0aGF0LlxuXHRcdFx0XHRcdGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdC8vIFRvIHByZXZlbnQgYSBmYWxzZSBwb3NpdGl2ZSBgaXNfZW50cnlfcHJvcHNgIGluIHRoZSBgcHJvcGAgZnVuY3Rpb25cblx0XHRpZiAoa2V5ID09PSBTVEFURV9TWU1CT0wgfHwga2V5ID09PSBMRUdBQ1lfUFJPUFMpIHJldHVybiBmYWxzZTtcblxuXHRcdGZvciAobGV0IHAgb2YgdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAocCAhPSBudWxsICYmIGtleSBpbiBwKSByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0LyoqIEB0eXBlIHtBcnJheTxzdHJpbmcgfCBzeW1ib2w+fSAqL1xuXHRcdGNvbnN0IGtleXMgPSBbXTtcblxuXHRcdGZvciAobGV0IHAgb2YgdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwKSB7XG5cdFx0XHRcdGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSBrZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ga2V5cztcblx0fVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgKCgpID0+IFJlY29yZDxzdHJpbmcsIHVua25vd24+KT59IHByb3BzXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkX3Byb3BzKC4uLnByb3BzKSB7XG5cdHJldHVybiBuZXcgUHJveHkoeyBwcm9wcyB9LCBzcHJlYWRfcHJvcHNfaGFuZGxlcik7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3Igc3luY2hyb25pemluZyBhIHBvc3NpYmx5IGJvdW5kIHByb3Agd2l0aCB0aGUgaW5uZXIgY29tcG9uZW50IHN0YXRlLlxuICogSXQgaXMgdXNlZCB3aGVuZXZlciB0aGUgY29tcGlsZXIgc2VlcyB0aGF0IHRoZSBjb21wb25lbnQgd3JpdGVzIHRvIHRoZSBwcm9wLCBvciB3aGVuIGl0IGhhcyBhIGRlZmF1bHQgcHJvcF92YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0ge1YgfCAoKCkgPT4gVil9IFtmYWxsYmFja11cbiAqIEByZXR1cm5zIHsoKCkgPT4gViB8ICgoYXJnOiBWKSA9PiBWKSB8ICgoYXJnOiBWLCBtdXRhdGlvbjogYm9vbGVhbikgPT4gVikpfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcChwcm9wcywga2V5LCBmbGFncywgZmFsbGJhY2spIHtcblx0dmFyIGltbXV0YWJsZSA9IChmbGFncyAmIFBST1BTX0lTX0lNTVVUQUJMRSkgIT09IDA7XG5cdHZhciBydW5lcyA9ICFsZWdhY3lfbW9kZV9mbGFnIHx8IChmbGFncyAmIFBST1BTX0lTX1JVTkVTKSAhPT0gMDtcblx0dmFyIGJpbmRhYmxlID0gKGZsYWdzICYgUFJPUFNfSVNfQklOREFCTEUpICE9PSAwO1xuXHR2YXIgbGF6eSA9IChmbGFncyAmIFBST1BTX0lTX0xBWllfSU5JVElBTCkgIT09IDA7XG5cdHZhciBpc19zdG9yZV9zdWIgPSBmYWxzZTtcblx0dmFyIHByb3BfdmFsdWU7XG5cblx0aWYgKGJpbmRhYmxlKSB7XG5cdFx0W3Byb3BfdmFsdWUsIGlzX3N0b3JlX3N1Yl0gPSBjYXB0dXJlX3N0b3JlX2JpbmRpbmcoKCkgPT4gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSkpO1xuXHR9IGVsc2Uge1xuXHRcdHByb3BfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblx0fVxuXG5cdC8vIENhbiBiZSB0aGUgY2FzZSB3aGVuIHNvbWVvbmUgZG9lcyBgbW91bnQoQ29tcG9uZW50LCBwcm9wcylgIHdpdGggYGxldCBwcm9wcyA9ICRzdGF0ZSh7Li4ufSlgXG5cdC8vIG9yIGBjcmVhdGVDbGFzc0NvbXBvbmVudChDb21wb25lbnQsIHByb3BzKWBcblx0dmFyIGlzX2VudHJ5X3Byb3BzID0gU1RBVEVfU1lNQk9MIGluIHByb3BzIHx8IExFR0FDWV9QUk9QUyBpbiBwcm9wcztcblxuXHR2YXIgc2V0dGVyID1cblx0XHQoYmluZGFibGUgJiZcblx0XHRcdChnZXRfZGVzY3JpcHRvcihwcm9wcywga2V5KT8uc2V0ID8/XG5cdFx0XHRcdChpc19lbnRyeV9wcm9wcyAmJiBrZXkgaW4gcHJvcHMgJiYgKCh2KSA9PiAocHJvcHNba2V5XSA9IHYpKSkpKSB8fFxuXHRcdHVuZGVmaW5lZDtcblxuXHR2YXIgZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjayk7XG5cdHZhciBmYWxsYmFja19kaXJ0eSA9IHRydWU7XG5cdHZhciBmYWxsYmFja191c2VkID0gZmFsc2U7XG5cblx0dmFyIGdldF9mYWxsYmFjayA9ICgpID0+IHtcblx0XHRmYWxsYmFja191c2VkID0gdHJ1ZTtcblx0XHRpZiAoZmFsbGJhY2tfZGlydHkpIHtcblx0XHRcdGZhbGxiYWNrX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRpZiAobGF6eSkge1xuXHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IHVudHJhY2soLyoqIEB0eXBlIHsoKSA9PiBWfSAqLyAoZmFsbGJhY2spKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxsYmFja192YWx1ZTtcblx0fTtcblxuXHRpZiAocHJvcF92YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoc2V0dGVyICYmIHJ1bmVzKSB7XG5cdFx0XHRlLnByb3BzX2ludmFsaWRfdmFsdWUoa2V5KTtcblx0XHR9XG5cblx0XHRwcm9wX3ZhbHVlID0gZ2V0X2ZhbGxiYWNrKCk7XG5cdFx0aWYgKHNldHRlcikgc2V0dGVyKHByb3BfdmFsdWUpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHsoKSA9PiBWfSAqL1xuXHR2YXIgZ2V0dGVyO1xuXHRpZiAocnVuZXMpIHtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0X2ZhbGxiYWNrKCk7XG5cdFx0XHRmYWxsYmFja19kaXJ0eSA9IHRydWU7XG5cdFx0XHRmYWxsYmFja191c2VkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdmVsdGUgNCBkaWQgbm90IHRyaWdnZXIgdXBkYXRlcyB3aGVuIGEgcHJpbWl0aXZlIHZhbHVlIHdhcyB1cGRhdGVkIHRvIHRoZSBzYW1lIHZhbHVlLlxuXHRcdC8vIFJlcGxpY2F0ZSB0aGF0IGJlaGF2aW9yIHRocm91Z2ggdXNpbmcgYSBkZXJpdmVkXG5cdFx0dmFyIGRlcml2ZWRfZ2V0dGVyID0gKGltbXV0YWJsZSA/IGRlcml2ZWQgOiBkZXJpdmVkX3NhZmVfZXF1YWwpKFxuXHRcdFx0KCkgPT4gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSlcblx0XHQpO1xuXHRcdGRlcml2ZWRfZ2V0dGVyLmYgfD0gTEVHQUNZX0RFUklWRURfUFJPUDtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXQoZGVyaXZlZF9nZXR0ZXIpO1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIGZhbGxiYWNrX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAodW5kZWZpbmVkKTtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsbGJhY2tfdmFsdWUgOiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gZWFzeSBtb2RlIOKAlCBwcm9wIGlzIG5ldmVyIHdyaXR0ZW4gdG9cblx0aWYgKChmbGFncyAmIFBST1BTX0lTX1VQREFURUQpID09PSAwKSB7XG5cdFx0cmV0dXJuIGdldHRlcjtcblx0fVxuXG5cdC8vIGludGVybWVkaWF0ZSBtb2RlIOKAlCBwcm9wIGlzIHdyaXR0ZW4gdG8sIGJ1dCB0aGUgcGFyZW50IGNvbXBvbmVudCBoYWRcblx0Ly8gYGJpbmQ6Zm9vYCB3aGljaCBtZWFucyB3ZSBjYW4ganVzdCBjYWxsIGAkJHByb3BzLmZvbyA9IHZhbHVlYCBkaXJlY3RseVxuXHRpZiAoc2V0dGVyKSB7XG5cdFx0dmFyIGxlZ2FjeV9wYXJlbnQgPSBwcm9wcy4kJGxlZ2FjeTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKC8qKiBAdHlwZSB7YW55fSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gbm90aWZ5IGlmIHRoZSB2YWx1ZSB3YXMgbXV0YXRlZCBhbmQgdGhlIHBhcmVudCBpcyBpbiBydW5lcyBtb2RlLlxuXHRcdFx0XHQvLyBJbiB0aGF0IGNhc2UgdGhlIHN0YXRlIHByb3h5IChpZiBpdCBleGlzdHMpIHNob3VsZCB0YWtlIGNhcmUgb2YgdGhlIG5vdGlmaWNhdGlvbi5cblx0XHRcdFx0Ly8gSWYgdGhlIHBhcmVudCBpcyBub3QgaW4gcnVuZXMgbW9kZSwgd2UgbmVlZCB0byBub3RpZnkgb24gbXV0YXRpb24sIHRvbywgdGhhdCB0aGUgcHJvcFxuXHRcdFx0XHQvLyBoYXMgY2hhbmdlZCBiZWNhdXNlIHRoZSBwYXJlbnQgd2lsbCBub3QgYmUgYWJsZSB0byBkZXRlY3QgdGhlIGNoYW5nZSBvdGhlcndpc2UuXG5cdFx0XHRcdGlmICghcnVuZXMgfHwgIW11dGF0aW9uIHx8IGxlZ2FjeV9wYXJlbnQgfHwgaXNfc3RvcmVfc3ViKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtGdW5jdGlvbn0gKi8gKHNldHRlcikobXV0YXRpb24gPyBnZXR0ZXIoKSA6IHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZ2V0dGVyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIGhhcmQgbW9kZS4gdGhpcyBpcyB3aGVyZSBpdCBnZXRzIHVnbHkg4oCUIHRoZSB2YWx1ZSBpbiB0aGUgY2hpbGQgc2hvdWxkXG5cdC8vIHN5bmNocm9uaXplIHdpdGggdGhlIHBhcmVudCwgYnV0IGl0IHNob3VsZCBhbHNvIGJlIHBvc3NpYmxlIHRvIHRlbXBvcmFyaWx5XG5cdC8vIHNldCB0aGUgdmFsdWUgdG8gc29tZXRoaW5nIGVsc2UgbG9jYWxseS5cblx0dmFyIGZyb21fY2hpbGQgPSBmYWxzZTtcblx0dmFyIHdhc19mcm9tX2NoaWxkID0gZmFsc2U7XG5cblx0Ly8gVGhlIGRlcml2ZWQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZS4gVGhlIHVuZGVybHlpbmcgbXV0YWJsZVxuXHQvLyBzb3VyY2UgaXMgd3JpdHRlbiB0byBmcm9tIHZhcmlvdXMgcGxhY2VzIHRvIHBlcnNpc3QgdGhpcyB2YWx1ZS5cblx0dmFyIGlubmVyX2N1cnJlbnRfdmFsdWUgPSBtdXRhYmxlX3NvdXJjZShwcm9wX3ZhbHVlKTtcblx0dmFyIGN1cnJlbnRfdmFsdWUgPSBkZXJpdmVkKCgpID0+IHtcblx0XHR2YXIgcGFyZW50X3ZhbHVlID0gZ2V0dGVyKCk7XG5cdFx0dmFyIGNoaWxkX3ZhbHVlID0gZ2V0KGlubmVyX2N1cnJlbnRfdmFsdWUpO1xuXG5cdFx0aWYgKGZyb21fY2hpbGQpIHtcblx0XHRcdGZyb21fY2hpbGQgPSBmYWxzZTtcblx0XHRcdHdhc19mcm9tX2NoaWxkID0gdHJ1ZTtcblx0XHRcdHJldHVybiBjaGlsZF92YWx1ZTtcblx0XHR9XG5cblx0XHR3YXNfZnJvbV9jaGlsZCA9IGZhbHNlO1xuXHRcdHJldHVybiAoaW5uZXJfY3VycmVudF92YWx1ZS52ID0gcGFyZW50X3ZhbHVlKTtcblx0fSk7XG5cblx0aWYgKCFpbW11dGFibGUpIGN1cnJlbnRfdmFsdWUuZXF1YWxzID0gc2FmZV9lcXVhbHM7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgvKiogQHR5cGUge2FueX0gKi8gdmFsdWUsIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gbXV0YXRpb24pIHtcblx0XHQvLyBsZWdhY3kgbm9uc2Vuc2Ug4oCUIG5lZWQgdG8gZW5zdXJlIHRoZSBzb3VyY2UgaXMgaW52YWxpZGF0ZWQgd2hlbiBuZWNlc3Nhcnlcblx0XHQvLyBhbHNvIG5lZWRlZCBmb3Igd2hlbiBoYW5kbGluZyBpbnNwZWN0IGxvZ2ljIHNvIHdlIGNhbiBpbnNwZWN0IHRoZSBjb3JyZWN0IHNvdXJjZSBzaWduYWxcblx0XHRpZiAoY2FwdHVyZWRfc2lnbmFscyAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gc2V0IHRoaXMgc28gdGhhdCB3ZSBkb24ndCByZXNldCB0byB0aGUgcGFyZW50IHZhbHVlIGlmIGBkYFxuXHRcdFx0Ly8gaXMgaW52YWxpZGF0ZWQgYmVjYXVzZSBvZiBgaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzYCAocmF0aGVyXG5cdFx0XHQvLyB0aGFuIGJlY2F1c2UgdGhlIHBhcmVudCBvciBjaGlsZCB2YWx1ZSBjaGFuZ2VkKVxuXHRcdFx0ZnJvbV9jaGlsZCA9IHdhc19mcm9tX2NoaWxkO1xuXHRcdFx0Ly8gaW52b2tlIGdldHRlcnMgc28gdGhhdCBzaWduYWxzIGFyZSBwaWNrZWQgdXAgYnkgYGludmFsaWRhdGVfaW5uZXJfc2lnbmFsc2Bcblx0XHRcdGdldHRlcigpO1xuXHRcdFx0Z2V0KGlubmVyX2N1cnJlbnRfdmFsdWUpO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc3QgbmV3X3ZhbHVlID0gbXV0YXRpb24gPyBnZXQoY3VycmVudF92YWx1ZSkgOiBydW5lcyAmJiBiaW5kYWJsZSA/IHByb3h5KHZhbHVlKSA6IHZhbHVlO1xuXG5cdFx0XHRpZiAoIWN1cnJlbnRfdmFsdWUuZXF1YWxzKG5ld192YWx1ZSkpIHtcblx0XHRcdFx0ZnJvbV9jaGlsZCA9IHRydWU7XG5cdFx0XHRcdHNldChpbm5lcl9jdXJyZW50X3ZhbHVlLCBuZXdfdmFsdWUpO1xuXHRcdFx0XHQvLyBUbyBlbnN1cmUgdGhlIGZhbGxiYWNrIHZhbHVlIGlzIGNvbnNpc3RlbnQgd2hlbiB1c2VkIHdpdGggcHJveGllcywgd2Vcblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBsb2NhbCBmYWxsYmFja192YWx1ZSwgYnV0IG9ubHkgaWYgdGhlIGZhbGxiYWNrIGlzIGFjdGl2ZWx5IHVzZWRcblx0XHRcdFx0aWYgKGZhbGxiYWNrX3VzZWQgJiYgZmFsbGJhY2tfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVudHJhY2soKCkgPT4gZ2V0KGN1cnJlbnRfdmFsdWUpKTsgLy8gZm9yY2UgYSBzeW5jaHJvbmlzYXRpb24gaW1tZWRpYXRlbHlcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0KGN1cnJlbnRfdmFsdWUpO1xuXHR9O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBDb21wb25lbnRDb250ZXh0TGVnYWN5IH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9pbmRleC5qcycgKi9cbi8qKiBAaW1wb3J0IHsgTm90RnVuY3Rpb24gfSBmcm9tICcuL2ludGVybmFsL3R5cGVzLmpzJyAqL1xuaW1wb3J0IHsgZmx1c2hfc3luYywgdW50cmFjayB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyB1c2VyX2VmZmVjdCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzJztcbmltcG9ydCB7IGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCB9IGZyb20gJy4vaW50ZXJuYWwvc2hhcmVkL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi9pbnRlcm5hbC9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2NvbnRleHQuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbmlmIChERVYpIHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG5cdCAqL1xuXHRmdW5jdGlvbiB0aHJvd19ydW5lX2Vycm9yKHJ1bmUpIHtcblx0XHRpZiAoIShydW5lIGluIGdsb2JhbFRoaXMpKSB7XG5cdFx0XHQvLyBUT0RPIGlmIHBlb3BsZSBzdGFydCBhZGp1c3RpbmcgdGhlIFwidGhpcyBjYW4gY29udGFpbiBydW5lc1wiIGNvbmZpZyB0aHJvdWdoIHYtcC1zIG1vcmUsIGFkanVzdCB0aGlzIG1lc3NhZ2Vcblx0XHRcdC8qKiBAdHlwZSB7YW55fSAqL1xuXHRcdFx0bGV0IHZhbHVlOyAvLyBsZXQncyBob3BlIG5vb25lIG1vZGlmaWVzIHRoaXMgZ2xvYmFsLCBidXQgYmVsdHMgYW5kIGJyYWNlc1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHJ1bmUsIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2V0dGVyLXJldHVyblxuXHRcdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGUucnVuZV9vdXRzaWRlX3N2ZWx0ZShydW5lKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiAodikgPT4ge1xuXHRcdFx0XHRcdHZhbHVlID0gdjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3dfcnVuZV9lcnJvcignJHN0YXRlJyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRlZmZlY3QnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGRlcml2ZWQnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGluc3BlY3QnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJHByb3BzJyk7XG5cdHRocm93X3J1bmVfZXJyb3IoJyRiaW5kYWJsZScpO1xufVxuXG4vKipcbiAqIFRoZSBgb25Nb3VudGAgZnVuY3Rpb24gc2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGFzIHNvb24gYXMgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIHRvIHRoZSBET00uXG4gKiBJdCBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgdGhlIGNvbXBvbmVudCdzIGluaXRpYWxpc2F0aW9uIChidXQgZG9lc24ndCBuZWVkIHRvIGxpdmUgKmluc2lkZSogdGhlIGNvbXBvbmVudDtcbiAqIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBhbiBleHRlcm5hbCBtb2R1bGUpLlxuICpcbiAqIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIGBvbk1vdW50YCBkb2VzIG5vdCBydW4gaW5zaWRlIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRzXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvc3ZlbHRlLXNlcnZlciNyZW5kZXIpLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IE5vdEZ1bmN0aW9uPFQ+IHwgUHJvbWlzZTxOb3RGdW5jdGlvbjxUPj4gfCAoKCkgPT4gYW55KX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Nb3VudChmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uTW91bnQnKTtcblx0fVxuXG5cdGlmIChsZWdhY3lfbW9kZV9mbGFnICYmIGNvbXBvbmVudF9jb250ZXh0LmwgIT09IG51bGwpIHtcblx0XHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLm0ucHVzaChmbik7XG5cdH0gZWxzZSB7XG5cdFx0dXNlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0Y29uc3QgY2xlYW51cCA9IHVudHJhY2soZm4pO1xuXHRcdFx0aWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSByZXR1cm4gLyoqIEB0eXBlIHsoKSA9PiB2b2lkfSAqLyAoY2xlYW51cCk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICpcbiAqIE91dCBvZiBgb25Nb3VudGAsIGBiZWZvcmVVcGRhdGVgLCBgYWZ0ZXJVcGRhdGVgIGFuZCBgb25EZXN0cm95YCwgdGhpcyBpcyB0aGVcbiAqIG9ubHkgb25lIHRoYXQgcnVucyBpbnNpZGUgYSBzZXJ2ZXItc2lkZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uRGVzdHJveScpO1xuXHR9XG5cblx0b25Nb3VudCgoKSA9PiAoKSA9PiB1bnRyYWNrKGZuKSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge2FueX1wYXJhbXNfMFxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL2xlZ2FjeS1vbiNDb21wb25lbnQtZXZlbnRzKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBuZXZlcjsgLy8gZG9lcyBub3QgdGFrZSBhIGRldGFpbCBhcmd1bWVudFxuICogIGNoYW5nZTogc3RyaW5nOyAvLyB0YWtlcyBhIGRldGFpbCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZywgd2hpY2ggaXMgcmVxdWlyZWRcbiAqICBvcHRpb25hbDogbnVtYmVyIHwgbnVsbDsgLy8gdGFrZXMgYW4gb3B0aW9uYWwgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgbnVtYmVyXG4gKiB9PigpO1xuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGNhbGxiYWNrIHByb3BzIGFuZC9vciB0aGUgYCRob3N0KClgIHJ1bmUgaW5zdGVhZCDigJQgc2VlIFttaWdyYXRpb24gZ3VpZGVdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS92NS1taWdyYXRpb24tZ3VpZGUjRXZlbnQtY2hhbmdlcy1Db21wb25lbnQtZXZlbnRzKVxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbRXZlbnRNYXAgPSBhbnldXG4gKiBAcmV0dXJucyB7RXZlbnREaXNwYXRjaGVyPEV2ZW50TWFwPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpIHtcblx0Y29uc3QgYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdGlmIChhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2NyZWF0ZUV2ZW50RGlzcGF0Y2hlcicpO1xuXHR9XG5cblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpID0+IHtcblx0XHRjb25zdCBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uIHwgRnVuY3Rpb25bXT59ICovIChcblx0XHRcdGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC5zLiQkZXZlbnRzXG5cdFx0KT8uWy8qKiBAdHlwZSB7YW55fSAqLyAodHlwZSldO1xuXG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogW2V2ZW50c107XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGNyZWF0ZV9jdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCBvcHRpb25zKTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLy8gVE9ETyBtYXJrIGJlZm9yZVVwZGF0ZSBhbmQgYWZ0ZXJVcGRhdGUgYXMgZGVwcmVjYXRlZCBpbiBTdmVsdGUgNlxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0LnByZWAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0LnByZWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0IyRlZmZlY3QucHJlKSBpbnN0ZWFkXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2JlZm9yZVVwZGF0ZScpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9sZWdhY3lfb25seSgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmIucHVzaChmbik7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YC5cbiAqXG4gKiBJbiBydW5lcyBtb2RlIHVzZSBgJGVmZmVjdGAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0YF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QpIGluc3RlYWRcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0bGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdhZnRlclVwZGF0ZScpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9sZWdhY3lfb25seSgnYWZ0ZXJVcGRhdGUnKTtcblx0fVxuXG5cdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkuYS5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBMZWdhY3ktbW9kZTogSW5pdCBjYWxsYmFja3Mgb2JqZWN0IGZvciBvbk1vdW50L2JlZm9yZVVwZGF0ZS9hZnRlclVwZGF0ZVxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb250ZXh0KSB7XG5cdHZhciBsID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29udGV4dCkubDtcblx0cmV0dXJuIChsLnUgPz89IHsgYTogW10sIGI6IFtdLCBtOiBbXSB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGZsdXNoZXMgYW55IHBlbmRpbmcgc3RhdGUgY2hhbmdlcyBhbmQgdGhvc2UgdGhhdCByZXN1bHQgZnJvbSBpdC5cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2ZuXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcblx0Zmx1c2hfc3luYyhmbik7XG59XG5cbmV4cG9ydCB7IGdldENvbnRleHQsIGdldEFsbENvbnRleHRzLCBoYXNDb250ZXh0LCBzZXRDb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5leHBvcnQgeyBoeWRyYXRlLCBtb3VudCwgdW5tb3VudCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyc7XG5leHBvcnQgeyB0aWNrLCB1bnRyYWNrIH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5leHBvcnQgeyBjcmVhdGVSYXdTbmlwcGV0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzJztcbiIsIi8vIGdlbmVyYXRlZCBkdXJpbmcgcmVsZWFzZSwgZG8gbm90IG1vZGlmeVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IHZlcnNpb24sIGFzIHNldCBpbiBwYWNrYWdlLmpzb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICc1LjIwLjInO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19WRVJTSU9OID0gJzUnO1xuIiwiaW1wb3J0IHsgUFVCTElDX1ZFUlNJT04gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHw9IHsgdjogbmV3IFNldCgpIH0pLnYuYWRkKFBVQkxJQ19WRVJTSU9OKTtcbiIsImNvbnN0IGlucHV0VmFsdWVzRXh0cmFjdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNoZWNrYm94OiAoaW5wRWwsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZGVmYXVsdFZhbHVlID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oZGVmYXVsdFZhbHVlLCBcImNoZWNrZWRcIikgJiZcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oZGVmYXVsdFZhbHVlLCBcInVuY2hlY2tlZFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBFbC5jaGVja2VkXG4gICAgICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWUuY2hlY2tlZFxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlLnVuY2hlY2tlZDtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24oaW5wRWwsIFwidmFsdWVcIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpbnBFbC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBFbC5jaGVja2VkID8gaW5wRWwudmFsdWUgOiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbnBFbC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgY29tbW9uIHRvIFVJIGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllc1xuICpcbiAqIEBjbGFzcyBVSUNvbW1vblxuICovXG5jbGFzcyBVSUNvbW1vbiB7XG4gICAgc3RhdGljIENMRUFSX01BQ1JPID0gXCJfX0NMRUFSX19cIjtcbiAgICBzdGF0aWMgRVJST1JfREVGQVVMVCA9IFwi0KfRgtC+INC/0L7RiNC70L4g0L3QtSDRgtCw0LouXCI7XG4gICAgc3RhdGljIERFRkFVTFRfUkVESVJFQ1RfVElNRU9VVCA9IDMwMDA7XG4gICAgc3RhdGljIENMQVNTX09LID0gXCJpcy1zdWNjZXNzXCI7XG4gICAgc3RhdGljIENMQVNTX0VSUiA9IFwiaXMtZGFuZ2VyXCI7XG4gICAgc3RhdGljIFNDUk9MTF9ESVNBQkxFUl9DTEFTUyA9IFwicmVtb3ZlLXNjcm9sbFwiO1xuICAgIHN0YXRpYyBGSUxMRVIgPSBcIl9cIjtcblxuICAgIHN0YXRpYyBTQ1JPTExfT1BUSU9OUyA9IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBiZWhhdmlvcjogXCJzbW9vdGhcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldCBpbnB1dFZhbHVlc0V4dHJhY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlc0V4dHJhY3RvcnM7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4dHJhY3RWYWx1ZUZyb21JbnB1dChpbnBFbCwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghaW5wRWwpIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKFVJQ29tbW9uLmlucHV0VmFsdWVzRXh0cmFjdG9ycywgaW5wRWwudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBVSUNvbW1vbi5pbnB1dFZhbHVlc0V4dHJhY3RvcnNbaW5wRWwudHlwZV0oXG4gICAgICAgICAgICAgICAgaW5wRWwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnBFbC52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgIGZpZWxkICAgIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50SW5wdXRDaGFuZ2VDYWxsYmFja30gICAgb25jaGFuZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gICAgICAgICBbZGVmYXVsdFZhbHVlPXVuZGVmaW5lZF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbYWRkaXRpb25hbCA9IHt9XVxuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50Q2FsbGJhY2t9XG4gICAgICogQG1lbWJlcm9mIFVJQ29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIG9uSW5wdXQoZmllbGQsIG9uY2hhbmdlLCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQsIGFkZGl0aW9uYWwgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIG9uY2hhbmdlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdHlwZW9mIGV2ZW50Py5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQ/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IFVJQ29tbW9uLmV4dHJhY3RWYWx1ZUZyb21JbnB1dChcbiAgICAgICAgICAgICAgICBldmVudD8uY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gb25jaGFuZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAgICogQG1lbWJlcm9mIFVJQ29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIGlzRW50ZXJFdmVudChlKSB7XG4gICAgICAgIHJldHVybiBlLmtleSA9PT0gXCJFbnRlclwiICYmICFlLmFsdEtleSAmJiAhZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5O1xuICAgIH1cblxuICAgIHN0YXRpYyBvbmx5T25FbnRlcihjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChVSUNvbW1vbi5pc0VudGVyRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBNT0JJTEVfV0lEVEhfQlJFQUtfUE9JTlQgPSA3NjA7XG5cbiAgICBzdGF0aWMgaXNNb2JpbGUoKSB7XG4gICAgICAgIGNvbnN0IHRlc3RNb2JpbGUgPSB3aW5kb3cubWF0Y2hNZWRpYSB8fCB3aW5kb3cubXNNYXRjaE1lZGlhO1xuICAgICAgICBpZiAodGVzdE1vYmlsZSkge1xuICAgICAgICAgICAgbGV0IHRlc3RRdWVyeSA9IFwiKHBvaW50ZXI6Y29hcnNlKVwiO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhfd2lkdGggPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLk1PQklMRV9XSURUSF9CUkVBS19QT0lOVFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGVzdFF1ZXJ5ID0gYG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAke21heF93aWR0aH1weClgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlc3RNb2JpbGUodGVzdFF1ZXJ5KS5tYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlQm9keVNjcm9sbCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHRoaXMuU0NST0xMX0RJU0FCTEVSX0NMQVNTKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzdG9yZUJvZHlTY3JvbGwoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLlNDUk9MTF9ESVNBQkxFUl9DTEFTUyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJlZm9ybWF0cyBpbnB1dCBmcm9tIGFueSBzdHJpbmcgdG8gc3RyaWN0IHBob25lIGZvcm1hdFxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gICAgdmFsICAgIGZyZWUgc3R5bGUgcGhvbmUgbnVtYmVyXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICBbZmlsbGVyPVVJQ29tbW9uLkZJTExFUl0gICAgZnJlZSBzdHlsZSBwaG9uZSBudW1iZXJcbiAgICAgKiAgQHJldHVybnMge3N0cmluZ30gICAgICAgICAgcGhvbmUgbnVtYmVyXG4gICAgICoqL1xuICAgIHN0YXRpYyBmb3JtYXRQaG9uZSh2YWwsIGZpbGxlciA9IHRoaXMuRklMTEVSKSB7XG4gICAgICAgIC8vc3RhcnRpbmcgZnJvbSAxMSBkaWdpdHMgaW4gcGhvbmUgbnVtYmVyXG4gICAgICAgIGNvbnN0IHNsb3RzID0gWzEsIDIsIDIsIDIsIDMsIDMsIDMsIDQsIDQsIDUsIDVdO1xuICAgICAgICBsZXQgZGlnaXRzID0gdmFsLnJlcGxhY2UoL1xcRC9nLCBcIlwiKTtcbiAgICAgICAgLy9pZiB0aGVyZSBhcmUgbW9yZSwgbW92ZSB0aGVtIHRvIGNvdW50cnkgY29kZSBzbG90XG4gICAgICAgIGlmIChkaWdpdHMubGVuZ3RoID4gMTEpIHtcbiAgICAgICAgICAgIGxldCBkID0gZGlnaXRzLmxlbmd0aCAtIDExO1xuICAgICAgICAgICAgd2hpbGUgKGQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZC0tO1xuICAgICAgICAgICAgICAgIHNsb3RzLnVuc2hpZnQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YWNrID0gW1wiXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFwiXCJdO1xuICAgICAgICBBcnJheS5mcm9tKGRpZ2l0cykuZm9yRWFjaCgoZGlnaXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2xvdCA9IHNsb3RzW2luZGV4XTtcbiAgICAgICAgICAgIHN0YWNrW3Nsb3QgLSAxXSA9IHN0YWNrW3Nsb3QgLSAxXSArIGRpZ2l0O1xuICAgICAgICB9KTtcbiAgICAgICAgLy9jcmVhdGluZyBtYXAgb2YgcGFydHMgbGVuZ3Roc1xuICAgICAgICBjb25zdCBsZW5zID0gc2xvdHMucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWNjW2N1cnJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgYWNjW2N1cnJdID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjW2N1cnJdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vZmlsbCBlbXB0eSBwb3NpdGlvbnMgd2l0aCBmaWxsZXIgKF8pXG4gICAgICAgIGZvciAobGV0IHQgaW4gc3RhY2spIHtcbiAgICAgICAgICAgIGxldCBkaWYgPSBsZW5zW3BhcnNlSW50KHQpICsgMV0gLSBzdGFja1t0XS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoZGlmID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YWNrW3RdID0gc3RhY2tbdF0gKyBmaWxsZXI7XG4gICAgICAgICAgICAgICAgZGlmLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGArJHtzdGFja1swXX0gKCR7c3RhY2tbMV19KSAke3N0YWNrWzJdfS0ke3N0YWNrWzNdfS0ke3N0YWNrWzRdfWA7XG4gICAgfVxuXG4gICAgc3RhdGljIE1PTkVZX1NJR04gPSBcIiYjODM4MTtcIjtcblxuICAgIHN0YXRpYyBzZXRNb25leVNpZ24odmFsKSB7XG4gICAgICAgIHRoaXMuTU9ORVlfU0lHTiA9IHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmljZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgVUlDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0UHJpY2UocHJpY2UpIHtcbiAgICAgICAgbGV0IG1ham9yID0gTWF0aC5mbG9vcihwcmljZSAvIDEwMCksXG4gICAgICAgICAgICBtaW5vciA9IHByaWNlICUgMTAwO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5NT05FWV9TSUdOfSR7bWFqb3IudG9TdHJpbmcoKX0uJHttaW5vci50b1N0cmluZygpfWA7XG4gICAgfVxuXG4gICAgc3RhdGljIGZvcm1hdExvY2FsZURhdGV0aW1lKGR0LCBvcHRzID0geyBkYXRlOiB0cnVlLCB0aW1lOiB0cnVlIH0pIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IGR0LnRvTG9jYWxlRGF0ZVN0cmluZyh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlKTtcbiAgICAgICAgY29uc3QgdGltZSA9IGR0LnRvTG9jYWxlVGltZVN0cmluZyh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlKTtcbiAgICAgICAgaWYgKG9wdHMuZGF0ZSAmJiBvcHRzLnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtkYXRlfSAke3RpbWV9YDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLmRhdGUgJiYgIW9wdHMudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB0cnlGb3JtYXRMb2NhbGVEYXRlVGltZSh2YWx1ZSwgb3B0cyA9IHsgZGF0ZTogdHJ1ZSwgdGltZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgZHQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gVUlDb21tb24uZm9ybWF0TG9jYWxlRGF0ZXRpbWUoZHQsIG9wdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gVUlDb21tb24uZm9ybWF0TG9jYWxlRGF0ZXRpbWUodmFsdWUsIG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZm9ybWF0VGltZXN0YW1wKHRpbWVzdGFtcCwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgb2Zmc2V0TG9jYWwgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIGxldCBkZWx0YU9mZnNldCA9IChvZmZzZXRMb2NhbCAtIG9mZnNldCkgKiA2MCAqIDEwMDA7XG4gICAgICAgIGxldCBsb2NhbERhdGVUaW1lID0gbmV3IERhdGUocGFyc2VJbnQodGltZXN0YW1wKSAtIGRlbHRhT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZVRpbWUudG9Mb2NhbGVTdHJpbmcod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIFRJTUUgPSB7XG4gICAgICAgIFNFQ09ORFM6IFtcItGB0LXQutGD0L3QtNGDXCIsIFwi0YHQtdC60YPQvdC00YtcIiwgXCLRgdC10LrRg9C90LRcIl0sXG4gICAgICAgIE1JTlVURVM6IFtcItC80LjQvdGD0YLRg1wiLCBcItC80LjQvdGD0YLRi1wiLCBcItC80LjQvdGD0YJcIl0sXG4gICAgICAgIEhPVVJTOiBbXCLRh9Cw0YFcIiwgXCLRh9Cw0YHQsFwiLCBcItGH0LDRgdC+0LJcIl0sXG4gICAgfTtcblxuICAgIHN0YXRpYyBkZWNsT2ZOdW0obiwgdGV4dF9mb3Jtcykge1xuICAgICAgICBuID0gTWF0aC5hYnMobikgJSAxMDA7XG4gICAgICAgIGxldCBuMSA9IG4gJSAxMDtcbiAgICAgICAgaWYgKG4gPiAxMCAmJiBuIDwgMjApIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0X2Zvcm1zWzJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA+IDEgJiYgbjEgPCA1KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dF9mb3Jtc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjEgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRfZm9ybXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRfZm9ybXNbMl07XG4gICAgfVxuXG4gICAgc3RhdGljIGh1bWFuaXplZFRpbWVEaWZmKGRhdGUgLyogdW5peCB0aW1lICovKSB7XG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBsZXQgc2VjID0gTWF0aC5yb3VuZCgoY3VycmVudFRpbWUgLSBkYXRlKSAvIDEwMDApO1xuICAgICAgICBsZXQgdW5pdDtcbiAgICAgICAgaWYgKHNlYyA8IDYwKSB7XG4gICAgICAgICAgICB1bml0ID0gdGhpcy5kZWNsT2ZOdW0oc2VjLCB0aGlzLlRJTUUuU0VDT05EUyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7c2VjfSAke3VuaXR9INC90LDQt9Cw0LRgO1xuICAgICAgICB9IGVsc2UgaWYgKHNlYyA8IDM2MDApIHtcbiAgICAgICAgICAgIGxldCBtaW4gPSBNYXRoLmZsb29yKHNlYyAvIDYwKTtcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmRlY2xPZk51bShtaW4sIHRoaXMuVElNRS5NSU5VVEVTKTtcbiAgICAgICAgICAgIHJldHVybiBgJHttaW59ICR7dW5pdH0g0L3QsNC30LDQtGA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKHNlYyAvICg2MCAqIDYwKSk7XG4gICAgICAgICAgICB1bml0ID0gdGhpcy5kZWNsT2ZOdW0oaG91cnMsIHRoaXMuVElNRS5IT1VSUyk7XG4gICAgICAgICAgICByZXR1cm4gYCR7aG91cnN9ICR7dW5pdH0g0L3QsNC30LDQtGA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgc3R5bGVzT2JqZWN0VG9TdHJpbmcoc3R5bGVzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcylcbiAgICAgICAgICAgICAgICAubWFwKChwcm9wKSA9PiBgJHtwcm9wfTogJHtzdHlsZXMucHJvcH07YClcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHN0cmluZ09yTnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLmluZGV4T2YodHlwZW9mIHZhbCkgPiAtMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3RyaW5nc09mTnVtYmVycyhsaXN0KSB7XG4gICAgICAgIHJldHVybiBsaXN0LmV2ZXJ5KHRoaXMuc3RyaW5nT3JOdW1iZXIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVUlDb21tb247XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLCBjaGlsZHJlbiwgLi4ub3RoZXJzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiYmxvY2sge2NsYXNzZXN9XCIgey4uLm90aGVyc30+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgaW1wb3J0IFVJQmxvY2sgZnJvbSBcIi4vdWkuYmxvY2suc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdGFiSW5kZXg9MF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGljayA9ICgpID0+IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IDAsXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBERUZBVUxUX0NMQVNTRVNfSU5ORVIgPSBcImJsb2NrLWlubmVyLXZlcnRpY2FsXCI7XG5cbiAgICBsZXQgY2xhc3Nlc0lubmVyID0gJHN0YXRlKERFRkFVTFRfQ0xBU1NFU19JTk5FUik7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2xhc3Nlc0lubmVyID0gYGJsb2NrLWlubmVyLXZlcnRpY2FsICR7Y2xhc3Nlc31gO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPFVJQmxvY2tcbiAgICB7aWR9XG4gICAgY2xhc3M9e2NsYXNzZXNJbm5lcn1cbiAgICB7b25jbGlja31cbiAgICBvbmtleXVwPXtvbktleVVwfVxuICAgIHtyb2xlfVxuICAgIHt0YWJJbmRleH1cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L1VJQmxvY2s+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2sgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSAwLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPGRpdiB7aWR9IGNsYXNzPVwiYm94IHtjbGFzc2VzfSBcIiB7b25jbGlja30gb25rZXl1cD17b25LZXlVcH0ge3JvbGV9IHt0YWJJbmRleH0+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2sgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmtleXVwXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSAwLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3Qgb25LZXlVcCA9XG4gICAgICAgIG9ua2V5dXAgPz8gKG9uY2xpY2sgPyBVSUNvbW1vbi5vbmx5T25FbnRlcihvbmNsaWNrKSA6IHVuZGVmaW5lZCk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIHtpZH1cbiAgICBjbGFzcz1cImNvbnRlbnQge2NsYXNzZXN9XCJcbiAgICB7b25jbGlja31cbiAgICBvbmtleXVwPXtvbktleVVwfVxuICAgIHtyb2xlfVxuICAgIHt0YWJJbmRleH1cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWUsXG4gICAgICAgIGNsaWNrID0gdHJ1ZSxcbiAgICAgICAgZW50ZXIgPSB0cnVlLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IG1vdXNlRXZlbnQgPSAoZSkgPT4ge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG5cbiAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gKGUpID0+IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoZSAmJiBlLmtleSA9PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgfTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9e2NsYXNzZXN9XG4gICAgcm9sZT1cImJ1dHRvblwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICBvbmtleXVwPXtlbnRlciA/IGtleWJvYXJkRXZlbnQgOiB1bmRlZmluZWR9XG4gICAgb25jbGljaz17Y2xpY2sgPyBtb3VzZUV2ZW50IDogdW5kZWZpbmVkfVxuICAgIHsuLi5vdGhlcnN9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4oKX1cbjwvZGl2PlxuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbmZ1bmN0aW9uIGluaXREaWN0KHRhcmdldCA9IHt9KSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24odGFyZ2V0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb3h5KHRhcmdldCwgaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsZSgpIHtcbiAgICBjb25zdCB7IHN1YnNjcmliZSwgc2V0LCB1cGRhdGUgfSA9IHdyaXRhYmxlKGluaXREaWN0KCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBzZXQ6ICh2YWwpID0+IHtcbiAgICAgICAgICAgIHNldChpbml0RGljdCh2YWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHNldChpbml0RGljdCgpKSxcbiAgICB9O1xufVxuXG5jb25zdCBMT0NBTEUgPSBjcmVhdGVMb2NhbGUoKTtcblxuZXhwb3J0IGRlZmF1bHQgTE9DQUxFO1xuIiwiLyohXG4gKiBFdmVudEVtaXR0ZXIgdjUuMi45IC0gZ2l0LmlvL2VlXG4gKiBVbmxpY2Vuc2UgLSBodHRwOi8vdW5saWNlbnNlLm9yZy9cbiAqIE9saXZlciBDYWxkd2VsbCAtIGh0dHBzOi8vb2xpLm1lLnVrL1xuICogQHByZXNlcnZlXG4gKi9cblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGZvciBtYW5hZ2luZyBldmVudHMuXG4gICAgICogQ2FuIGJlIGV4dGVuZGVkIHRvIHByb3ZpZGUgZXZlbnQgZnVuY3Rpb25hbGl0eSBpbiBvdGhlciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQGNsYXNzIEV2ZW50RW1pdHRlciBNYW5hZ2VzIGV2ZW50IHJlZ2lzdGVyaW5nIGFuZCBlbWl0dGluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG4gICAgLy8gU2hvcnRjdXRzIHRvIGltcHJvdmUgc3BlZWQgYW5kIHNpemVcbiAgICB2YXIgcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuICAgIHZhciBvcmlnaW5hbEdsb2JhbFZhbHVlID0gZXhwb3J0cy5FdmVudEVtaXR0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgaW4gaXRzIHN0b3JhZ2UgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IGxpc3RlbmVycyBBcnJheSBvZiBsaXN0ZW5lcnMgdG8gc2VhcmNoIHRocm91Z2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGxvb2sgZm9yLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciwgLTEgaWYgbm90IGZvdW5kXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGEgbWV0aG9kIHdoaWxlIGtlZXBpbmcgdGhlIGNvbnRleHQgY29ycmVjdCwgdG8gYWxsb3cgZm9yIG92ZXJ3cml0aW5nIG9mIHRhcmdldCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGFsaWFzZWQgbWV0aG9kXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWxpYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYWxpYXNDbG9zdXJlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lciBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBXaWxsIGluaXRpYWxpc2UgdGhlIGV2ZW50IG9iamVjdCBhbmQgbGlzdGVuZXIgYXJyYXlzIGlmIHJlcXVpcmVkLlxuICAgICAqIFdpbGwgcmV0dXJuIGFuIG9iamVjdCBpZiB5b3UgdXNlIGEgcmVnZXggc2VhcmNoLiBUaGUgb2JqZWN0IGNvbnRhaW5zIGtleXMgZm9yIGVhY2ggbWF0Y2hlZCBldmVudC4gU28gL2JhW3J6XS8gbWlnaHQgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGJhciBhbmQgYmF6LiBCdXQgb25seSBpZiB5b3UgaGF2ZSBlaXRoZXIgZGVmaW5lZCB0aGVtIHdpdGggZGVmaW5lRXZlbnQgb3IgYWRkZWQgc29tZSBsaXN0ZW5lcnMgdG8gdGhlbS5cbiAgICAgKiBFYWNoIHByb3BlcnR5IGluIHRoZSBvYmplY3QgcmVzcG9uc2UgaXMgYW4gYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfE9iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByb3RvLmdldExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldExpc3RlbmVycyhldnQpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2dldEV2ZW50cygpO1xuICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgY29uY2F0ZW5hdGVkIGFycmF5IG9mIGFsbCBtYXRjaGluZyBldmVudHMgaWZcbiAgICAgICAgLy8gdGhlIHNlbGVjdG9yIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAgICBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Vba2V5XSA9IGV2ZW50c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZXZlbnRzW2V2dF0gfHwgKGV2ZW50c1tldnRdID0gW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGxpc3Qgb2YgbGlzdGVuZXIgb2JqZWN0cyBhbmQgZmxhdHRlbnMgaXQgaW50byBhIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbGlzdGVuZXJzIFJhdyBsaXN0ZW5lciBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW119IEp1c3QgdGhlIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBwcm90by5mbGF0dGVuTGlzdGVuZXJzID0gZnVuY3Rpb24gZmxhdHRlbkxpc3RlbmVycyhsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGZsYXRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgZmxhdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyc1tpXS5saXN0ZW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmxhdExpc3RlbmVycztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgcmVxdWVzdGVkIGxpc3RlbmVycyB2aWEgZ2V0TGlzdGVuZXJzIGJ1dCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHJlc3VsdHMgaW5zaWRlIGFuIG9iamVjdC4gVGhpcyBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSBidXQgb3RoZXJzIG1heSBmaW5kIGl0IHVzZWZ1bC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBpbiBhbiBvYmplY3QuXG4gICAgICovXG4gICAgcHJvdG8uZ2V0TGlzdGVuZXJzQXNPYmplY3QgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnNBc09iamVjdChldnQpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XG4gICAgICAgIHZhciByZXNwb25zZTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICByZXNwb25zZVtldnRdID0gbGlzdGVuZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlIHx8IGxpc3RlbmVycztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNWYWxpZExpc3RlbmVyIChsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nIHx8IGxpc3RlbmVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyICYmIHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkTGlzdGVuZXIobGlzdGVuZXIubGlzdGVuZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFRoZSBsaXN0ZW5lciB3aWxsIG5vdCBiZSBhZGRlZCBpZiBpdCBpcyBhIGR1cGxpY2F0ZS5cbiAgICAgKiBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGl0IGlzIGNhbGxlZC5cbiAgICAgKiBJZiB5b3UgcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSB0aGVuIHRoZSBsaXN0ZW5lciB3aWxsIGJlIGFkZGVkIHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNhbGxpbmcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghaXNWYWxpZExpc3RlbmVyKGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuICAgICAgICB2YXIgbGlzdGVuZXJJc1dyYXBwZWQgPSB0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnO1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldLnB1c2gobGlzdGVuZXJJc1dyYXBwZWQgPyBsaXN0ZW5lciA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGFkZExpc3RlbmVyXG4gICAgICovXG4gICAgcHJvdG8ub24gPSBhbGlhcygnYWRkTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIFNlbWktYWxpYXMgb2YgYWRkTGlzdGVuZXIuIEl0IHdpbGwgYWRkIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlXG4gICAgICogYXV0b21hdGljYWxseSByZW1vdmVkIGFmdGVyIGl0cyBmaXJzdCBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmFkZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZE9uY2VMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKGV2dCwge1xuICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYWRkT25jZUxpc3RlbmVyLlxuICAgICAqL1xuICAgIHByb3RvLm9uY2UgPSBhbGlhcygnYWRkT25jZUxpc3RlbmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGFuIGV2ZW50IG5hbWUuIFRoaXMgaXMgcmVxdWlyZWQgaWYgeW91IHdhbnQgdG8gdXNlIGEgcmVnZXggdG8gYWRkIGEgbGlzdGVuZXIgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIElmIHlvdSBkb24ndCBkbyB0aGlzIHRoZW4gaG93IGRvIHlvdSBleHBlY3QgaXQgdG8ga25vdyB3aGF0IGV2ZW50IHRvIGFkZCB0bz8gU2hvdWxkIGl0IGp1c3QgYWRkIHRvIGV2ZXJ5IHBvc3NpYmxlIG1hdGNoIGZvciBhIHJlZ2V4PyBOby4gVGhhdCBpcyBzY2FyeSBhbmQgYmFkLlxuICAgICAqIFlvdSBuZWVkIHRvIHRlbGwgaXQgd2hhdCBldmVudCBuYW1lcyBzaG91bGQgYmUgbWF0Y2hlZCBieSBhIHJlZ2V4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBjcmVhdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uZGVmaW5lRXZlbnQgPSBmdW5jdGlvbiBkZWZpbmVFdmVudChldnQpIHtcbiAgICAgICAgdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZXMgZGVmaW5lRXZlbnQgdG8gZGVmaW5lIG11bHRpcGxlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IGV2dHMgQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGVmaW5lLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmRlZmluZUV2ZW50cyA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50cyhldnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVFdmVudChldnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBXaGVuIHBhc3NlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSwgaXQgd2lsbCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1trZXldLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIHJlbW92ZUxpc3RlbmVyXG4gICAgICovXG4gICAgcHJvdG8ub2ZmID0gYWxpYXMoJ3JlbW92ZUxpc3RlbmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cbiAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHlvdSBjYW4gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBhZGQgdGhlIGFycmF5IG9mIGxpc3RlbmVycyB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICogWWVhaCwgdGhpcyBmdW5jdGlvbiBkb2VzIHF1aXRlIGEgYml0LiBUaGF0J3MgcHJvYmFibHkgYSBiYWQgdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5hZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyhmYWxzZSwgZXZ0LCBsaXN0ZW5lcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cbiAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHlvdSBjYW4gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byByZW1vdmUgdGhlIGxpc3RlbmVycyBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnModHJ1ZSwgZXZ0LCBsaXN0ZW5lcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFZGl0cyBsaXN0ZW5lcnMgaW4gYnVsay4gVGhlIGFkZExpc3RlbmVycyBhbmQgcmVtb3ZlTGlzdGVuZXJzIG1ldGhvZHMgYm90aCB1c2UgdGhpcyB0byBkbyB0aGVpciBqb2IuIFlvdSBzaG91bGQgcmVhbGx5IHVzZSB0aG9zZSBpbnN0ZWFkLCB0aGlzIGlzIGEgbGl0dGxlIGxvd2VyIGxldmVsLlxuICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCB3aWxsIGRldGVybWluZSBpZiB0aGUgbGlzdGVuZXJzIGFyZSByZW1vdmVkICh0cnVlKSBvciBhZGRlZCAoZmFsc2UpLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkL3JlbW92ZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWFuaXB1bGF0ZSB0aGUgbGlzdGVuZXJzIG9mIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIFRydWUgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVycywgZmFsc2UgaWYgeW91IHdhbnQgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkL3JlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5tYW5pcHVsYXRlTGlzdGVuZXJzID0gZnVuY3Rpb24gbWFuaXB1bGF0ZUxpc3RlbmVycyhyZW1vdmUsIGV2dCwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhciBzaW5nbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVyIDogdGhpcy5hZGRMaXN0ZW5lcjtcbiAgICAgICAgdmFyIG11bHRpcGxlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lcnMgOiB0aGlzLmFkZExpc3RlbmVycztcblxuICAgICAgICAvLyBJZiBldnQgaXMgYW4gb2JqZWN0IHRoZW4gcGFzcyBlYWNoIG9mIGl0cyBwcm9wZXJ0aWVzIHRvIHRoaXMgbWV0aG9kXG4gICAgICAgIGlmICh0eXBlb2YgZXZ0ID09PSAnb2JqZWN0JyAmJiAhKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBldnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpICYmICh2YWx1ZSA9IGV2dFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgc2luZ2xlIGxpc3RlbmVyIHN0cmFpZ2h0IHRocm91Z2ggdG8gdGhlIHNpbmd1bGFyIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUuY2FsbCh0aGlzLCBpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFzcyBiYWNrIHRvIHRoZSBtdWx0aXBsZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUuY2FsbCh0aGlzLCBpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTbyBldnQgbXVzdCBiZSBhIHN0cmluZ1xuICAgICAgICAgICAgLy8gQW5kIGxpc3RlbmVycyBtdXN0IGJlIGFuIGFycmF5IG9mIGxpc3RlbmVyc1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIGl0IGFuZCBwYXNzIGVhY2ggb25lIHRvIHRoZSBtdWx0aXBsZSBtZXRob2RcbiAgICAgICAgICAgIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHNpbmdsZS5jYWxsKHRoaXMsIGV2dCwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYW4gZXZlbnQgdGhlbiBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKiBUaGF0IG1lYW5zIGV2ZXJ5IGV2ZW50IHdpbGwgYmUgZW1wdGllZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ2V4IHRvIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IFtldnRdIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci4gV2lsbCByZW1vdmUgZnJvbSBldmVyeSBldmVudCBpZiBub3QgcGFzc2VkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZXZ0KSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGV2dDtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2dldEV2ZW50cygpO1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIC8vIFJlbW92ZSBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2YgZXZ0XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbZXZ0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSByZWdleC5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBhbGwgZXZlbnRzXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIHJlbW92ZUV2ZW50LlxuICAgICAqXG4gICAgICogQWRkZWQgdG8gbWlycm9yIHRoZSBub2RlIEFQSS5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBhbGlhcygncmVtb3ZlRXZlbnQnKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IG9mIHlvdXIgY2hvaWNlLlxuICAgICAqIFdoZW4gZW1pdHRlZCwgZXZlcnkgbGlzdGVuZXIgYXR0YWNoZWQgdG8gdGhhdCBldmVudCB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgICAqIElmIHlvdSBwYXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBhcnJheSB0aGVuIHRob3NlIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBldmVyeSBsaXN0ZW5lciB1cG9uIGV4ZWN1dGlvbi5cbiAgICAgKiBCZWNhdXNlIGl0IHVzZXMgYGFwcGx5YCwgeW91ciBhcnJheSBvZiBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgYXMgaWYgeW91IHdyb3RlIHRoZW0gb3V0IHNlcGFyYXRlbHkuXG4gICAgICogU28gdGhleSB3aWxsIG5vdCBhcnJpdmUgd2l0aGluIHRoZSBhcnJheSBvbiB0aGUgb3RoZXIgc2lkZSwgdGhleSB3aWxsIGJlIHNlcGFyYXRlLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdCBhbmQgZXhlY3V0ZSBsaXN0ZW5lcnMgZm9yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSBPcHRpb25hbCBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uZW1pdEV2ZW50ID0gZnVuY3Rpb24gZW1pdEV2ZW50KGV2dCwgYXJncykge1xuICAgICAgICB2YXIgbGlzdGVuZXJzTWFwID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuICAgICAgICB2YXIgbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXI7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzTWFwKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXBba2V5XS5zbGljZSgwKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHNoYWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGVpdGhlciB3aXRoIGEgYmFzaWMgY2FsbCBvciBhbiBhcHBseSBpZiB0aGVyZSBpcyBhbiBhcmdzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5vbmNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIubGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBsaXN0ZW5lci5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IHRoaXMuX2dldE9uY2VSZXR1cm5WYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIubGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGVtaXRFdmVudFxuICAgICAqL1xuICAgIHByb3RvLnRyaWdnZXIgPSBhbGlhcygnZW1pdEV2ZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0bHkgZGlmZmVyZW50IGZyb20gZW1pdEV2ZW50IGluIHRoYXQgaXQgd2lsbCBwYXNzIGl0cyBhcmd1bWVudHMgb24gdG8gdGhlIGxpc3RlbmVycywgYXMgb3Bwb3NlZCB0byB0YWtpbmcgYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3Mgb24uXG4gICAgICogQXMgd2l0aCBlbWl0RXZlbnQsIHlvdSBjYW4gcGFzcyBhIHJlZ2V4IGluIHBsYWNlIG9mIHRoZSBldmVudCBuYW1lIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdCBhbmQgZXhlY3V0ZSBsaXN0ZW5lcnMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gT3B0aW9uYWwgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdEV2ZW50KGV2dCwgYXJncyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmIGFcbiAgICAgKiBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhlIG9uZSBzZXQgaGVyZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIGFmdGVyIGV4ZWN1dGlvbi4gVGhpcyB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIHRvIGNoZWNrIGZvciB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uc2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gc2V0T25jZVJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWZcbiAgICAgKiB0aGUgbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoaXMgb25lIHRoZW4gaXQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKiBhdXRvbWF0aWNhbGx5LiBJdCB3aWxsIHJldHVybiB0cnVlIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfEJvb2xlYW59IFRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGZvciBvciB0aGUgZGVmYXVsdCwgdHJ1ZS5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5fZ2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gX2dldE9uY2VSZXR1cm5WYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoJ19vbmNlUmV0dXJuVmFsdWUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uY2VSZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGV2ZW50cyBvYmplY3QgYW5kIGNyZWF0ZXMgb25lIGlmIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXZlbnRzIHN0b3JhZ2Ugb2JqZWN0LlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLl9nZXRFdmVudHMgPSBmdW5jdGlvbiBfZ2V0RXZlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGdsb2JhbCB7QGxpbmsgRXZlbnRFbWl0dGVyfSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IE5vbiBjb25mbGljdGluZyBFdmVudEVtaXR0ZXIgY2xhc3MuXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IG9yaWdpbmFsR2xvYmFsVmFsdWU7XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfTtcblxuICAgIC8vIEV4cG9zZSB0aGUgY2xhc3MgZWl0aGVyIHZpYSBBTUQsIENvbW1vbkpTIG9yIHRoZSBnbG9iYWwgb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKXtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcbiAgICB9XG59KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyB8fCB7fSkpO1xuIiwiLypcblx0OnByb3BlcnR5LnN1YjEuZnVuYygpLmZ1bmNQcm9wXG5cdCA9IHJldHVybiBmdW5jUHJvcCBvZiBmdW5jdGlvbiByZXN1bHQgb2Ygc3ViMSBwcm9wZXJ0eSBvZiBwcm9wZXJ0eSBvZiBvYmplY3Rcblx0Ons6OmhlbHBlclZhbH0uc3ViXG5cdCA9IHJldHVybiBzdWIgcHJvcGVydHkgb2Ygb2JqZWN0IHByb3BlcnR5IHdpdGggbmFtZSByZXRyaWV2ZWQgZnJvbSBoZWxwZXJWYWwgcHJvcGVydHkgb2YgaGVscGVycyBvYmplY3Rcblx0Ons6OmhlbHBlckZ1bmMoKX0uc3ViXG5cdD0gcmV0dXJuIHN1YiBwcm9wZXJ0eSBvZiBvYmplY3QgcHJvcGVydHkgd2l0aCBuYW1lIHJldHJpZXZlZCBmcm9tIGhlbHBlclZhbCBmdW5jdGlvbiByZXN1bHQgb2YgaGVscGVycyBvYmplY3QuXG5cdGlmIGhlbHBlcnNGdW54IHJldHVybiAnY2FyJyB0aGVuIHNvdXJjZSBwYXRoIGJlY29tZXMgOmNhci5zdWJcblxuKi9cblxuY29uc3QgU1VCX1BBVEhfU1RBUlQgPSBcIntcIixcbiAgICBTVUJfUEFUSF9FTkQgPSBcIn1cIixcbiAgICBQQVRIX1NQTElUID0gXCIuXCIsXG4gICAgUEFUSF9TVEFSVF9PQkpFQ1QgPSBcIjpcIixcbiAgICBQQVRIX1NUQVJUX0hFTFBFUlMgPSBcIjo6XCIsXG4gICAgRlVOQ1RJT05fTUFSS0VSID0gXCIoKVwiLFxuICAgIE1BWF9ERUVQID0gMTA7XG5cbi8qKlxuICogU2V0IG9mIHRvb2xzIHRvIHVzZSBub3RQYXRoIHByb3BlcnR5IGFjY2VzcyBub3RhdGlvblxuICogOiBpcyBmb3IgaXRlbVxuICogOjogaXMgZm9yIGhlbHBlcnNcbiAqIHt9IHN1YnBhdGhcbiAqIC4gcGF0aCBzcGxpdHRlclxuICogKCkgZnVuY3Rpb24gYW5kIHNob3VsZCBiZSBleGVjdXRlZCB3aXRoIHBhcmFtcyAoaXRlbSwgaGVscGVyIHwgdW5kZWZpbmVkKVxuICogc3ViLXBhdGhzIHdpbGwgYmUgcGFyc2VkIGFuZCByZXBsYWNlZCBieSByZXN1bHRzIGluIHNvdXJjZSBwYXRoXG4gKi9cbmNsYXNzIG5vdFBhdGgge1xuICAgIHN0YXRpYyBnZXQgU1VCX1BBVEhfU1RBUlQoKSB7XG4gICAgICAgIHJldHVybiBTVUJfUEFUSF9TVEFSVDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBTVUJfUEFUSF9FTkQoKSB7XG4gICAgICAgIHJldHVybiBTVUJfUEFUSF9FTkQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgUEFUSF9TUExJVCgpIHtcbiAgICAgICAgcmV0dXJuIFBBVEhfU1BMSVQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgUEFUSF9TVEFSVF9PQkpFQ1QoKSB7XG4gICAgICAgIHJldHVybiBQQVRIX1NUQVJUX09CSkVDVDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBQQVRIX1NUQVJUX0hFTFBFUlMoKSB7XG4gICAgICAgIHJldHVybiBQQVRIX1NUQVJUX0hFTFBFUlM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRlVOQ1RJT05fTUFSS0VSKCkge1xuICAgICAgICByZXR1cm4gRlVOQ1RJT05fTUFSS0VSO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE1BWF9ERUVQKCkge1xuICAgICAgICByZXR1cm4gTUFYX0RFRVA7XG4gICAgfVxuXG4gICAgLypcblx0XHRpbnB1dCAnOns6OmhlbHBlclZhbH0uc3ViJ1xuXHRcdHJldHVybiA6OmhlbHBlclZhbFxuXHQqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBzdWJwYXRoIGluIHBhdGhcbiAgICAgKiBpZiBzdWJwYXRoIG5vdCBjbG9zZWQgd2lsbCByZXR1cm4gaXQgYW55d2F5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCBpbiBzdHJpbmcgbm90YXRpb25cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH0gc3VicGF0aCBvciBudWxsIGlmIG5vIHN1YiBwYXRoIHdlcmUgZm91bmRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluZE5leHRTdWJQYXRoKHBhdGgpIHtcbiAgICAgICAgbGV0IHN1YlBhdGggPSBcIlwiLFxuICAgICAgICAgICAgZmluZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldID09PSBTVUJfUEFUSF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIGZpbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN1YlBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gU1VCX1BBVEhfRU5EICYmIGZpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YlBhdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViUGF0aCArPSBwYXRoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZCA/IHN1YlBhdGggOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2Ugc3ViLXBhdGggaW4gcGFyZW50IHBhdGggYnkgcGFyc2VkIHZlcnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViIHN1YiBwYXRoIHRvIHJlcGxhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyc2VkIHBhcnNlZCBzdWIgcGF0aFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcGFyc2VkIHBhdGhcbiAgICAgKi9cblxuICAgIHN0YXRpYyByZXBsYWNlU3ViUGF0aChwYXRoLCBzdWIsIHBhcnNlZCkge1xuICAgICAgICBsZXQgc3ViZiA9IFNVQl9QQVRIX1NUQVJUICsgc3ViICsgU1VCX1BBVEhfRU5ELFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChwYXRoLmluZGV4T2Yoc3ViZikgPiAtMSAmJiBpIDwgTUFYX0RFRVApIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2Uoc3ViZiwgcGFyc2VkKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgcGF0aCB3aGlsZSB0aGVyZSBhbnkgc3ViLXBhdGhzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcmF3IHVucGFyc2VkIHBhdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGhlbHBlcnMgaGVscGVyc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcGFyc2VkIHBhdGhcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VTdWJzKHBhdGgsIGl0ZW0sIGhlbHBlcnMpIHtcbiAgICAgICAgbGV0IHN1YlBhdGggPSB0aGlzLmZpbmROZXh0U3ViUGF0aChwYXRoKSxcbiAgICAgICAgICAgIHN1YlBhdGhQYXJzZWQsXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKHN1YlBhdGgpIHtcbiAgICAgICAgICAgIHN1YlBhdGhQYXJzZWQgPSB0aGlzLmdldFZhbHVlQnlQYXRoKFxuICAgICAgICAgICAgICAgIHN1YlBhdGguaW5kZXhPZihQQVRIX1NUQVJUX0hFTFBFUlMpID4gLTEgPyBoZWxwZXJzIDogaXRlbSxcbiAgICAgICAgICAgICAgICBzdWJQYXRoLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgaGVscGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLnJlcGxhY2VTdWJQYXRoKHBhdGgsIHN1YlBhdGgsIHN1YlBhdGhQYXJzZWQpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPiBNQVhfREVFUCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3ViUGF0aCA9IHRoaXMuZmluZE5leHRTdWJQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbaGVscGVyc10gaGVscGVycyBvYmplY3RcbiAgICAgKi9cblxuICAgIHN0YXRpYyBnZXQocGF0aCwgaXRlbSwgaGVscGVycyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKHBhdGgpIHtcbiAgICAgICAgICAgIGNhc2UgUEFUSF9TVEFSVF9PQkpFQ1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICBjYXNlIFBBVEhfU1RBUlRfSEVMUEVSUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycztcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gdGhpcy5wYXJzZVN1YnMocGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQnlQYXRoKFxuICAgICAgICAgICAgcGF0aC5pbmRleE9mKFBBVEhfU1RBUlRfSEVMUEVSUykgPiAtMSA/IGhlbHBlcnMgOiBpdGVtLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBoZWxwZXJzXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBwYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIGl0ZW0gaXRlbSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIGhlbHBlcnMgICAgICAgICBoZWxwZXJzIG9iamVjdCBpZiA0IGFyZ3VtZW50cyBvciBhdHRyVmFsdWUgaWYgb25seSAzIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHthbnl9ICAgICBbYXR0clZhbHVlXSAgICAgdmFsdWUgd2Ugd2FudCB0byBhc3NpZ25cbiAgICAgKi9cblxuICAgIHN0YXRpYyBzZXQocGF0aCwgaXRlbSwgaGVscGVycywgYXR0clZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBhdHRyVmFsdWUgPSBoZWxwZXJzO1xuICAgICAgICAgICAgaGVscGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ViUGF0aCA9IHRoaXMuZmluZE5leHRTdWJQYXRoKHBhdGgpLFxuICAgICAgICAgICAgc3ViUGF0aFBhcnNlZCxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoc3ViUGF0aCkge1xuICAgICAgICAgICAgc3ViUGF0aFBhcnNlZCA9IHRoaXMuZ2V0VmFsdWVCeVBhdGgoXG4gICAgICAgICAgICAgICAgc3ViUGF0aC5pbmRleE9mKFBBVEhfU1RBUlRfSEVMUEVSUykgPiAtMSA/IGhlbHBlcnMgOiBpdGVtLFxuICAgICAgICAgICAgICAgIHN1YlBhdGgsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBoZWxwZXJzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGF0aCA9IHRoaXMucmVwbGFjZVN1YlBhdGgocGF0aCwgc3ViUGF0aCwgc3ViUGF0aFBhcnNlZCk7XG4gICAgICAgICAgICBpZiAoaSA+IE1BWF9ERUVQKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJQYXRoID0gdGhpcy5maW5kTmV4dFN1YlBhdGgocGF0aCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRWYWx1ZUJ5UGF0aChpdGVtLCBwYXRoLCBhdHRyVmFsdWUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpdGVtLmlzUmVjb3JkICYmXG4gICAgICAgICAgICB0aGlzLm5vcm1pbGl6ZVBhdGgocGF0aCkubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgaXRlbS5fX2lzQWN0aXZlXG4gICAgICAgICkge1xuICAgICAgICAgICAgaXRlbS50cmlnZ2VyKFwiY2hhbmdlXCIsIGl0ZW0sIHBhdGgsIGF0dHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGFyZ2V0IHByb3BlcnR5IHRvIG51bGxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gaXRlbSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVscGVycyBoZWxwZXJzIG9iamVjdFxuICAgICAqL1xuXG4gICAgc3RhdGljIHVuc2V0KHBhdGgsIGl0ZW0sIGhlbHBlcnMpIHtcbiAgICAgICAgdGhpcy5zZXQocGF0aCwgaXRlbSwgaGVscGVycywgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHN0ZXAga2V5LCB0cmFuc2Zvcm1zIGl0IHRvIGVuZC1mb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ZXAgbm90IHBhcnNlZCBzdGVwIGtleVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGhlbHBlciBoZWxwZXJzIG9iamVjdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ9IHBhcnNlZCBzdGVwIGtleVxuICAgICAqL1xuXG4gICAgc3RhdGljIHBhcnNlUGF0aFN0ZXAoc3RlcCwgaXRlbSwgaGVscGVyKSB7XG4gICAgICAgIGxldCByU3RlcCA9IG51bGw7XG4gICAgICAgIGlmIChzdGVwLmluZGV4T2YoUEFUSF9TVEFSVF9IRUxQRVJTKSA9PT0gMCAmJiBoZWxwZXIpIHtcbiAgICAgICAgICAgIHJTdGVwID0gc3RlcC5yZXBsYWNlKFBBVEhfU1RBUlRfSEVMUEVSUywgXCJcIik7XG4gICAgICAgICAgICBpZiAoclN0ZXAuaW5kZXhPZihGVU5DVElPTl9NQVJLRVIpID09PSByU3RlcC5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgclN0ZXAgPSByU3RlcC5yZXBsYWNlKEZVTkNUSU9OX01BUktFUiwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWxwZXIsIHJTdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyW3JTdGVwXShpdGVtLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcltyU3RlcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5pbmRleE9mKFBBVEhfU1RBUlRfT0JKRUNUKSA9PT0gMCAmJiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgclN0ZXAgPSBzdGVwLnJlcGxhY2UoUEFUSF9TVEFSVF9PQkpFQ1QsIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChyU3RlcC5pbmRleE9mKEZVTkNUSU9OX01BUktFUikgPT09IHJTdGVwLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgclN0ZXAgPSByU3RlcC5yZXBsYWNlKEZVTkNUSU9OX01BUktFUiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlbSwgclN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVtyU3RlcF0oaXRlbSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtW3JTdGVwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfVxuXG4gICAgLy86OmZpZWxkTmFtZS5yZXN1bHRcbiAgICAvL3t9XG4gICAgLy97ZmllbGROYW1lOiAndGFyZ2V0UmVjb3JkRmllbGQnfVxuICAgIC8vLy9bJ3RhcmdldFJlY29yZEZpZWxkJywgJ3Jlc3VsdCddXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBwYXRoIHdpdGggc3ViIHBhdGhzIHRvIHBhdGggd2l0aG91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBwYXRoIHBhdGggdG8gdGFyZ2V0IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gaXRlbSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVscGVyIGhlbHBlciBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gcGFyc2VkIHBhdGhcbiAgICAgKiovXG4gICAgc3RhdGljIHBhcnNlUGF0aChwYXRoLCBpdGVtLCBoZWxwZXIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChQQVRIX1NQTElUKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGhbaV0gPSB0aGlzLnBhcnNlUGF0aFN0ZXAocGF0aFtpXSwgaXRlbSwgaGVscGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHBhdGggZnJvbSBzdHJpbmcgbm90YXRpb24gdG8gYXJyYXkgb2Yga2V5c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBwYXRoICBpbnB1dCBwYXRoLCBpZiBhcnJheSBkb2VzIG5vdGhpbmdcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gcGF0aCBpbiBhcnJheSBub3RhdGlvblxuICAgICAqL1xuXG4gICAgc3RhdGljIG5vcm1pbGl6ZVBhdGgocGF0aCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAocGF0aC5pbmRleE9mKFBBVEhfU1RBUlRfT0JKRUNUKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShQQVRIX1NUQVJUX09CSkVDVCwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zcGxpdChQQVRIX1NQTElUKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG5cdFx0c21hbGwgPSBbXCJ0b2RvXCJdLFxuXHRcdGJpZyA9IFtcInRvZG9cIiwgXCJsZW5ndGhcIl1cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHQqL1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllcyBpZiBmaXJzdCBwYXRoIGluY2x1ZGVzIHNlY29uZCwgY29tcGFyZWQgZnJvbSBzdGFydCxcbiAgICAgKiBubyBmbG9hdGluZyBzdGFydCBwb3NpdGlvbiBpbnNpZGUgWydqb2luJywgJ21lJ10sIFsnbWUnXVxuICAgICAqIHdpbGwgcmVzdWx0IGluIGZhbHNlXG4gICAgICogQHBhcmFtIHthcnJheX0gYmlnIHdoZXJlIHdlIHdpbGwgc2VhcmNoXG4gICAgICogQHBhcmFtIHthcnJheX0gc21hbGwgd2hhdCB3ZSB3aWxsIHNlYXJjaFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIHdlIHN1Y2NlZWRcbiAgICAgKi9cblxuICAgIHN0YXRpYyBpZkZ1bGxTdWJQYXRoKGJpZywgc21hbGwpIHtcbiAgICAgICAgaWYgKGJpZy5sZW5ndGggPCBzbWFsbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHNtYWxsLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBpZiAoc21hbGxbdF0gIT09IGJpZ1t0XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXR0ZXIgdGhyb3VnaCB0aGlyZCBvYmplY3RcbiAgICAgKiBQYXRoIGlzIHBhcnNlZCwgbm8gZXZlbnQgdHJpZ2dlcmluZyBmb3Igbm90UmVjb3JkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBvYmplY3QgdG8gYmUgdXNlZCBhcyBnZXR0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gYXR0clBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIHN1cHBvcnRpbmcgZGF0YVxuICAgICAqIEBwYXJhbSB7aGVscGVyc30gb2JqZWN0ICBzdXBwb3J0aW5nIGhlbHBlcnNcbiAgICAgKi9cblxuICAgIHN0YXRpYyBnZXRWYWx1ZUJ5UGF0aChvYmplY3QsIGF0dHJQYXRoLCBpdGVtLCBoZWxwZXJzKSB7XG4gICAgICAgIGF0dHJQYXRoID0gdGhpcy5ub3JtaWxpemVQYXRoKGF0dHJQYXRoKTtcbiAgICAgICAgbGV0IGF0dHJOYW1lID0gYXR0clBhdGguc2hpZnQoKSxcbiAgICAgICAgICAgIGlzRnVuY3Rpb24gPSBhdHRyTmFtZS5pbmRleE9mKEZVTkNUSU9OX01BUktFUikgPiAtMTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUucmVwbGFjZShGVU5DVElPTl9NQVJLRVIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdFthdHRyTmFtZV0gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIG9iamVjdFthdHRyTmFtZV0gIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgbmV3T2JqID0gaXNGdW5jdGlvblxuICAgICAgICAgICAgICAgID8gb2JqZWN0W2F0dHJOYW1lXSh7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJzLFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICA6IG9iamVjdFthdHRyTmFtZV07XG4gICAgICAgICAgICBpZiAoYXR0clBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQnlQYXRoKG5ld09iaiwgYXR0clBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHRlciB0aHJvdWdoIHRoaXJkIG9iamVjdFxuICAgICAqIFBhdGggaXMgcGFyc2VkLCBubyBldmVudCB0cmlnZ2VyaW5nIGZvciBub3RSZWNvcmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IG9iamVjdCB0byBiZSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBhdHRyUGF0aCBwYXRoIHRvIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHthbnl9IGF0dHJWYWx1ZSAgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG5cbiAgICBzdGF0aWMgc2V0VmFsdWVCeVBhdGgob2JqZWN0LCBhdHRyUGF0aCwgYXR0clZhbHVlKSB7XG4gICAgICAgIGF0dHJQYXRoID0gdGhpcy5ub3JtaWxpemVQYXRoKGF0dHJQYXRoKTtcbiAgICAgICAgbGV0IGF0dHJOYW1lID0gYXR0clBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKGF0dHJQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2F0dHJOYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUJ5UGF0aChvYmplY3RbYXR0ck5hbWVdLCBhdHRyUGF0aCwgYXR0clZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdFthdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBKb2lucyBwYXNzZWQgaW4gc3RyaW5ncyB3aXRoIFBBVEhfU1BMSVRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJndW1lbnRzIHBhdGggdG8gYmUgZ2x1ZWRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IGNvbXBvc2l0ZSBwYXRoXG4gICAgICovXG5cbiAgICBzdGF0aWMgam9pbigpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYXJncy5qb2luKFBBVEhfU1BMSVQpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub3RQYXRoO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9pbmRleC5qcycpO1xuIiwiLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbi8qXG5odHRwczovL2dpdGh1Yi5jb20vVGVoU2hyaWtlL2lzLW1lcmdlYWJsZS1vYmplY3RcblxuSW5jbHVkZWQgZm9yIGNvbnZpbmllbmNlIG9ubHkuIEFsbCByaWdodHMgYmVsb25ncyB0byB0aGVpciBhdXRob3JzIGFuZCBldGMuXG5zdGFydCBvZiBteSBjb2RlIG1hcmtlZC5cblxuKi9cblxubGV0IGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJiAhaXNTcGVjaWFsKHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIHN0cmluZ1ZhbHVlID09PSBcIltvYmplY3QgUmVnRXhwXVwiIHx8XG4gICAgICAgIHN0cmluZ1ZhbHVlID09PSBcIltvYmplY3QgRGF0ZV1cIiB8fFxuICAgICAgICBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbiAgICApO1xufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxuLypcbmh0dHBzOi8vZ2l0aHViLmNvbS9LeWxlQU1hdGhld3MvZGVlcG1lcmdlXG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTIgTmljaG9sYXMgRmlzaGVyXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9O1xufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgY29uc3QgY2xvbmUgPSAhb3B0aW9uc0FyZ3VtZW50IHx8IG9wdGlvbnNBcmd1bWVudC5jbG9uZSAhPT0gZmFsc2U7XG5cbiAgICByZXR1cm4gY2xvbmUgJiYgaXNNZXJnZWFibGVPYmplY3QodmFsdWUpXG4gICAgICAgID8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnNBcmd1bWVudClcbiAgICAgICAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB7fTtcbiAgICBpZiAoaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKFxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNBcmd1bWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pIHx8ICF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKFxuICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNBcmd1bWVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBkZWVwbWVyZ2UoXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0sXG4gICAgICAgICAgICAgICAgc291cmNlW2tleV0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc0FyZ3VtZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIGNvbnN0IHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcbiAgICBjb25zdCBvcHRpb25zID0gb3B0aW9uc0FyZ3VtZW50IHx8IHtcbiAgICAgICAgYXJyYXlNZXJnZTogZGVmYXVsdEFycmF5TWVyZ2UsXG4gICAgfTtcbiAgICBjb25zdCBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuICAgIGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuICAgICAgICByZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuICAgICAgICBjb25zdCBhcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuICAgICAgICByZXR1cm4gYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgICAgIHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICB9LCB7fSk7XG59O1xuXG4vKipcbiAqICBDb2xsZWN0aW9uIG9mIGNvbW1vbiBmdW5jdGlvbnNcbiAqICBAY2xhc3NcbiAqL1xuY2xhc3Mgbm90Q29tbW9uIHtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7T2JqZWN0fSBbTUFOQUdFUj1udWxsXSAgYXBwbGljYXRpb24gbWFuYWdlciwgaW4gc29tZSBjYXNlcyB1c2VkIHRvIGNvbnRyb2wgaW5pdGlhbGl6YXRpb24gcm91dGluZVxuICAgICAqL1xuICAgIHN0YXRpYyBNQU5BR0VSID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7c3RyaW5nfSBbTE9HPVwiY29uc29sZVwiXSAgbG9nZ2VyLCB3aW5kb3dbTE9HXVxuICAgICAqL1xuICAgIHN0YXRpYyBMT0cgPSBcImNvbnNvbGVcIjtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7ZnVuY3Rpb259IGRlZXBNZXJnZSAgZnVuY3Rpb24gdG8gcGVyZm9ybSBkZWVwIG1lcmdlcyBvZiBvYmplY3RzXG4gICAgICovXG4gICAgc3RhdGljIGRlZXBNZXJnZSA9IGRlZXBtZXJnZTtcblxuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtmdW5jdGlvbn0gaXNFcnJvciAgZnVuY3Rpb24gdG8gcGVyZm9ybSBvYmplY3QgdGVzdCwgaWYgaXQncyBhbiBlcnJvciBvYmplY3Qgb3Igbm90XG4gICAgICogQHBhcmFtICAge29iamVjdH0gICAgZSAgIG9iamVjdCB0byB0ZXN0XG4gICAgICovXG4gICAgc3RhdGljIGlzRXJyb3IoZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZSBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAoT2JqZWN0Lmhhc093bihlLCBcInN0YXR1c1wiKSAmJiBlLnN0YXR1cyA9PT0gXCJlcnJvclwiKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBUWl9PRkZTRVQgPSAobmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpIC8gNjApICogLTE7XG4gICAgc3RhdGljIERFVl9FTlYgPSBcInByb2R1Y3Rpb25cIjtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc3RhdGljIEVOVl9UWVBFID0gd2luZG93Lk5PVF9FTlZfVFlQRSA/PyBub3RDb21tb24uREVWX0VOVjtcbiAgICBzdGF0aWMgTk9PUCA9ICgpID0+IHt9O1xuXG4gICAgc3RhdGljIG11dGUoKSB7XG4gICAgICAgIG5vdENvbW1vbi5FTlZfVFlQRSA9IFwicHJvZHVjdGlvblwiO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYWQobikge1xuICAgICAgICByZXR1cm4gbiA8IDEwID8gXCIwXCIgKyBuIDogbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdG9kYXkgRGF0ZSBvYmplY3Qgd2l0aG91dCBob3VycywgbWludXRlcywgc2Vjb25kc1xuICAgICAqICBAcmV0dXJuIHtudW1iZXJ9ICBjdXJyZW50IGRhdGUgd2l0aCAwMDowMDowMCBpbiBtcyBvZiB1bml4IHRpbWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VG9kYXlEYXRlKCkge1xuICAgICAgICBsZXQgdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksIHQuZ2V0TW9udGgoKSwgdC5nZXREYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgZmllbGQgb2YgbmFtZVxuICAgICAqICAgQHBhcmFtICAge29iamVjdH0gICAgb2JqICAgIHNvbWUgb2JqZWN0XG4gICAgICogIEBwYXJhbSAge3N0cmluZ30gICAgbmFtZSAgZmllbGQgbmFtZVxuICAgICAqICBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICBpZiBvYmplY3QgY29udGFpbnMgZmllbGQgd2l0aCBuYW1lXG4gICAgICoqL1xuICAgIHN0YXRpYyBvYmpIYXMob2JqLCBuYW1lKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdC5oYXNPd24ob2JqLCBuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb2JqZWN0IHRvIHNlY3VyZSBpdCBmcm9tIGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICBvYmogICAgIG9yaWdpbmFsIG9iamVjdFxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgY29weSBvZiBvYmplY3RcbiAgICAgKiovXG4gICAgc3RhdGljIGNvcHlPYmoob2JqKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvYmplY3QgdG8gc2VjdXJlIGl0IGZyb20gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iaiAgICAgb3JpZ2luYWwgb2JqZWN0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBjb3B5IG9mIG9iamVjdFxuICAgICAqKi9cbiAgICBzdGF0aWMgcGFydENvcHlPYmoob2JqLCBsaXN0KSB7XG4gICAgICAgIGxldCBwYXJ0T2JqID0gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgICAgIGlmIChsaXN0LmluY2x1ZGVzKGN1cnIpKSB7XG4gICAgICAgICAgICAgICAgcHJldltjdXJyXSA9IG9ialtjdXJyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBhcnRPYmopKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29tcGFyZVR3b0FycmF5cyhhLCBiKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiZcbiAgICAgICAgICAgIGEuZXZlcnkoKGVsZW1lbnQsIGluZGV4KSA9PiBlbGVtZW50ID09PSBiW2luZGV4XSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGFyZ3VtZW50IHR5cGUgdG8gYmUgJ2Z1bmN0aW9uJ1xuICAgICAqIEBwYXJhbSB7YW55fSAgZnVuYyAgICBwb3NzaWJsZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICBpZiB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgICAgKiovXG4gICAgc3RhdGljIGlzRnVuYyhmdW5jKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhcmd1bWVudCBpcyBBc3luYyBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNvbnN0cnVjdGVkIGFzIEFzeW5jRnVuY3Rpb25cbiAgICAgKiovXG4gICAgc3RhdGljIGlzQXN5bmMoZnVuYykge1xuICAgICAgICByZXR1cm4gZnVuYy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jRnVuY3Rpb25cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgRXhlY3V0ZXMgbWV0aG9kIG9mIG9iamVjdCBpbiBhcHByb3ByaWF0ZSB3YXkgaW5zaWRlIFByb21pc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICBvYmogICAgIG9yaWdpbmFsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWUgICAgbWV0aG9kIG5hbWUgdG8gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBwYXJhbXMgIGFycmF5IG9mIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgIHJlc3VsdHMgb2YgbWV0aG9kIGV4ZWN1dGlvblxuICAgICAqKi9cbiAgICBzdGF0aWMgYXN5bmMgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uKG9iaiwgbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHByb2MgPSBub3RQYXRoLmdldChcIjpcIiArIG5hbWUsIG9iaik7XG4gICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhwcm9jKSkge1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNBc3luYyhwcm9jKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvYyguLi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEV4ZWN1dGVzIG1ldGhvZCBvZiBvYmplY3QgaW4gYXByb3ByaWF0ZSB3YXkgaW5zaWRlIFByb21pc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBmcm9tICAgICBvcmlnaW5hbCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICB0byAgICBtZXRob2QgbmFtZSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gICAgIGxpc3QgIGFycmF5IG9mIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgcmVzdWx0cyBvZiBtZXRob2QgZXhlY3V0aW9uXG4gICAgICoqL1xuICAgIHN0YXRpYyBtYXBCaW5kKGZyb20sIHRvLCBsaXN0KSB7XG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tW2l0ZW1dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0b1tpdGVtXSA9IGZyb21baXRlbV0uYmluZChmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzQ2xhc3MoZm4pIHtcbiAgICAgICAgcmV0dXJuIC9eXFxzKmNsYXNzLy50ZXN0KGZuLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZXRlY3RUeXBlKHRlc3RpZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlc3RpZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRlc3RpZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNDbGFzcyh0ZXN0aWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY2xhc3NcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8v0J/RgNC+0LLQtdGA0LrQsCDRj9Cy0LvRj9C10YLRgdGPINC70Lgg0L/QtdGA0LXQvNC10L3QvdCw0Y8g0LzQsNGB0YHQuNCy0L7QvFxuICAgIHN0YXRpYyBpc0FycmF5KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5O1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2NhbElzb0RhdGUoZGF0ZSkge1xuICAgICAgICBkYXRlID0gZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgbG9jYWxJc29TdHJpbmcgPVxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQoZGF0ZS5nZXRNb250aCgpICsgMSkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldERhdGUoKSkgK1xuICAgICAgICAgICAgXCJUXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldEhvdXJzKCkpICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQoZGF0ZS5nZXRNaW51dGVzKCkpICtcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQoZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICByZXR1cm4gbG9jYWxJc29TdHJpbmc7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFRvZGF5KCkge1xuICAgICAgICBsZXQgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgZGF0ZSA9XG4gICAgICAgICAgICB0b2RheS5nZXRGdWxsWWVhcigpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQodG9kYXkuZ2V0TW9udGgoKSArIDEpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIG5vdENvbW1vbi5wYWQodG9kYXkuZ2V0RGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGJhY2tsb2cgPSBbXTtcblxuICAgIHN0YXRpYyBiYWNrbG9nQWRkKG1zZywgdHlwZSA9IFwibG9nXCIpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5nZXQoXCJiYWNrbG9nXCIpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uYmFja2xvZy5wdXNoKHsgbXNnLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGR1bXBCYWNrbG9nKCkge1xuICAgICAgICB3aGlsZSAobm90Q29tbW9uLmJhY2tsb2cubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcm93ID0gbm90Q29tbW9uLmJhY2tsb2cuc2hpZnQoKTtcbiAgICAgICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXVtyb3cudHlwZV0oLi4ucm93Lm1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbG9nTXNnKCkge1xuICAgICAgICBsZXQgbm93ID0gbm90Q29tbW9uLmxvY2FsSXNvRGF0ZSgpO1xuXG4gICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5sb2coYFske25vd31dOiBgLCAuLi5hcmd1bWVudHMpO1xuICAgICAgICBub3RDb21tb24uYmFja2xvZ0FkZChbYFske25vd31dOiBgLCAuLi5hcmd1bWVudHNdLCBcImxvZ1wiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9nKCkge1xuICAgICAgICBub3RDb21tb24ubG9nTXNnKC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUxvZ2dlcihwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvZzogbm90Q29tbW9uLmdlbkxvZ01zZyhwcmVmaXgpLFxuICAgICAgICAgICAgZXJyb3I6IG5vdENvbW1vbi5nZW5Mb2dFcnJvcihwcmVmaXgpLFxuICAgICAgICAgICAgZGVidWc6IG5vdENvbW1vbi5nZW5Mb2dEZWJ1ZyhwcmVmaXgpLFxuICAgICAgICAgICAgcmVwb3J0OiBub3RDb21tb24ucmVwb3J0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8v0JPQtdC90LXRgNCw0YbQuNGPINC80LXRgtC+0LTQsCDQstGL0LLQvtC00LAg0YHQvtC+0LHRidC10L3QuNC5INCyINC60L7QvdGB0L7Qu9GMINGBINGD0LrQsNC30LDQvdC40LXQvCDQv9GA0LXRhNC40LrRgdCwLlxuICAgIHN0YXRpYyBnZW5Mb2dNc2cocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL25vdCBhcnJvdyBiYyBvZiBhcmd1bWVudHMgc3BlY2lhbCB2YXIgaXMgbm90IGF2YWlsYWJsZSBpbiBhcnJvdyBmdW5jdGlvbnNcbiAgICAgICAgICAgIGxldCBub3cgPSBub3RDb21tb24ubG9jYWxJc29EYXRlKCk7XG5cbiAgICAgICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5sb2coYFske25vd31dOiAke3ByZWZpeH06OmAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBub3RDb21tb24uYmFja2xvZ0FkZChcbiAgICAgICAgICAgICAgICBbYFske25vd31dOiAke3ByZWZpeH06OmAsIC4uLmFyZ3VtZW50c10sXG4gICAgICAgICAgICAgICAgXCJsb2dcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDQntC/0YDQtdC00LXQu9GP0LXRgiDRj9Cy0LvRj9C10YLRgdGPINC70Lgg0L7QutGA0YPQttC10L3QuNC1INC+0LrRgNGD0LbQtdC90LjQtdC8INGA0LDQt9GA0LDQsdC+0YLQutC4XG4gICAgICogQHJldHVybnMgIHtib29sZWFufSB0cnVlINC10YHQu9C4INGN0YLQviDQt9Cw0L/Rg9GJ0LXQvdC+INCyINC+0LrRgNGD0LbQtdC90LjQuCDRgNCw0LfRgNCw0LHQvtGC0LrQuFxuICAgICAqKi9cbiAgICBzdGF0aWMgaXNEZXYoKSB7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uRU5WX1RZUEUgPT09IG5vdENvbW1vbi5ERVZfRU5WO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWJ1ZygpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0RldigpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLmxvZ01zZyguLi5hcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5OT09QO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdlbkxvZ0RlYnVnKHByZWZpeCkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRGV2KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24uZ2VuTG9nTXNnKHByZWZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLk5PT1A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZXJyb3IoKSB7XG4gICAgICAgIG5vdENvbW1vbi5sb2dFcnJvciguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8v0KTRg9C90LrRhtC40Y8g0LLRi9Cy0L7QtNCwINGB0L7QvtCx0YnQtdC90LjRjyDQvtCxINC+0YjQuNCx0LrQtVxuICAgIHN0YXRpYyBsb2dFcnJvcigpIHtcbiAgICAgICAgbGV0IG5vdyA9IG5vdENvbW1vbi5sb2NhbElzb0RhdGUoKTtcblxuICAgICAgICB3aW5kb3dbbm90Q29tbW9uLkxPR10uZXJyb3IoYFske25vd31dOiBgLCAuLi5hcmd1bWVudHMpO1xuICAgICAgICBub3RDb21tb24uYmFja2xvZ0FkZChbYFske25vd31dOiBgLCAuLi5hcmd1bWVudHNdLCBcImVycm9yXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZW5Mb2dFcnJvcihwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGNoYW5nZSB0byBhcnJvdyBmdW5jdGlvbiwgYmMgb2YgYXJndW1lbnRzXG4gICAgICAgICAgICBsZXQgbm93ID0gbm90Q29tbW9uLmxvY2FsSXNvRGF0ZSgpO1xuXG4gICAgICAgICAgICB3aW5kb3dbbm90Q29tbW9uLkxPR10uZXJyb3IoYFske25vd31dOiAke3ByZWZpeH06OmAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBub3RDb21tb24uYmFja2xvZ0FkZChcbiAgICAgICAgICAgICAgICBbYFske25vd31dOiAke3ByZWZpeH06OmAsIC4uLmFyZ3VtZW50c10sXG4gICAgICAgICAgICAgICAgXCJlcnJvclwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyByZXBvcnQoZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmdldEFwcCgpKSB7XG4gICAgICAgICAgICBsZXQgcmVwb3J0ZXIgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0U2VydmljZShcIm5zRXJyb3JSZXBvcnRlclwiKTtcbiAgICAgICAgICAgIGlmIChyZXBvcnRlcikge1xuICAgICAgICAgICAgICAgIHJlcG9ydGVyLnJlcG9ydChlKS5jYXRjaChub3RDb21tb24uZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFub3RDb21tb24uZ2V0KFwicHJvZHVjdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHRyYWNlKCkge1xuICAgICAgICBpZiAoIW5vdENvbW1vbi5nZXQoXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICBub3RDb21tb24udHJhY2UoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB0cmltQmFja3NsYXNoKHN0cikge1xuICAgICAgICBpZiAoc3RyLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQnVpbGRzIFVSTCB3aXRoIHN0cnVjdHVyZSBsaWtlIHByZWZpeC9tb2R1bGUvbW9kZWwvaWQvYWN0aW9uXG4gICAgICogSWYgc29tZSBwYXJ0IGFic2VudCBvciBzZXQgdG8gZmFsc2UgaXQgd2lsbCBiZSBleGNsdWRlZCBmcm9tIHJlc3VsdFxuICAgICAqICBAcGFyYW0ge29iamVjdH0gdXJsUGFydHNcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFt1cmxQYXJ0cy5wcmVmaXg9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMubW9kdWxlPScnXVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLm1vZGVsPScnXVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLmlkPScnXVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLmFjdGlvbj0nJ11cbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfSAgdXJsIHBhdGhcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRVUkwoXG4gICAgICAgIHsgcHJlZml4LCBtb2R1bGUsIG1vZGVsLCBpZCwgYWN0aW9uIH0gPSB7XG4gICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICBtb2R1bGU6IFwiXCIsXG4gICAgICAgICAgICBtb2RlbDogXCJcIixcbiAgICAgICAgICAgIGlkOiBcIlwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlwiLFxuICAgICAgICB9XG4gICAgKSB7XG4gICAgICAgIGxldCB1cmwgPSBbXCIvXCJdO1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2gocHJlZml4KSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChtb2R1bGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2gobW9kZWwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2goaWQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgdXJsLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5vdENvbW1vbi50cmltQmFja3NsYXNoKGFjdGlvbikpKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB1cmwuZmlsdGVyKChlbCkgPT4gZWwgIT09IFwiXCIpO1xuICAgICAgICByZXR1cm4gdXJsLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLy9nLCBcIi9cIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGNhcGl0YWxpemVGaXJzdExldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG93ZXJGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3RyTGVuZ3RoQ2FwKHN0ciwgTUFYX1RJVExFX0xFTkdUSCA9IDUwLCBQT1NUX0ZJWCA9IFwiLi4uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgc3RyLmxlbmd0aCA+IE1BWF9USVRMRV9MRU5HVEgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIE1BWF9USVRMRV9MRU5HVEgpICsgUE9TVF9GSVg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVzY2FwZUh0bWwodW5zYWZlKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiJiMwMzk7XCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdGFydEFwcChzdGFydGVyKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHN0YXJ0ZXIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBcHAoKSB7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uZ2V0KFwiYXBwXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHRlbmRBcHBDb25maWcoY29uZiwgY29uZjIpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5kZWVwTWVyZ2UoY29uZiwgY29uZjIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhYnNvcmJNb2R1bGUoKSB7XG4gICAgICAgIGxldCBkZWZhdWx0Q29uZiwgLy9hcHAgb3B0aW9uc1xuICAgICAgICAgICAgbW9kLCAvL21vZHVsZSBvcHRpb25zXG4gICAgICAgICAgICB0YXJnZXRzID0ge307IC8vdmFyaW91cyBjb2xsZWN0aW9uc1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB0YXJnZXRzID0geyAuLi5hcmd1bWVudHNbMF0gfTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbMF0sIFwiZGVmYXVsdENvbmZcIikpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZiA9IGFyZ3VtZW50c1swXS5kZWZhdWx0Q29uZjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0cy5kZWZhdWx0Q29uZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbMF0sIFwibW9kXCIpKSB7XG4gICAgICAgICAgICAgICAgbW9kID0gYXJndW1lbnRzWzBdLm1vZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0cy5tb2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3RDb21tb24ubG9nKFxuICAgICAgICAgICAgICAgIFwiV0FSTklORzogYWJzb3JiTW9kdWxlIGZvcm1hdCBvYnNvbGV0ZWQsIHVzZSBvYmplY3Qge2RlZmF1bHRDb25mLCBtb2QsIHNlcnZpY2VzLCB1aXMsIHdzYywgZXRjfVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGVmYXVsdENvbmYgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBtb2QgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnNlcnZpY2VzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0cy51aXMgPSBhcmd1bWVudHNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLndjcyA9IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG1vZCkge1xuICAgICAgICAgICAgLy9hZGQgbWFuaWZlc3QgdG8gb3RoZXJcbiAgICAgICAgICAgIGlmIChwcm9wID09PSBcIm1hbmlmZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZiA9IG5vdENvbW1vbi5leHRlbmRBcHBDb25maWcoXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mLFxuICAgICAgICAgICAgICAgICAgICBtb2QubWFuaWZlc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub3RDb21tb24uZ2V0KGBhYnNvcmIuJHtwcm9wfWApID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldHMsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGBXQVJOSU5HOiBubyBhY2NhbXVsYXRvciBvYmplY3QgcHJvdmlkZWQgZm9yICcke3Byb3B9JyBjb2xsZWN0aW9uYFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3RDb21tb24uZ2V0KGBhYnNvcmIuJHtwcm9wfWApKHRhcmdldHNbcHJvcF0sIG1vZFtwcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AuaW5kZXhPZihcIm5jXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihkZWZhdWx0Q29uZiwgXCJjb250cm9sbGVyc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZi5jb250cm9sbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29uZi5jb250cm9sbGVyc1twcm9wXSA9IG1vZFtwcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9pbiBjYXNlIG9mIHNvbWUgb3RoZXIgc3R1ZmYgcHJlc2VudGVkLCBpc29sYXRpbmcgaXQgaW4gc3BlY2lhbCB2YXJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHdpbmRvdywgXCJub3RFbnZcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubm90RW52ID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB3aW5kb3cubm90RW52W3Byb3BdID0gbW9kW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q29uZjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGVmaW5lSWZOb3RFeGlzdHMob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlZ2lzdHJ5ID0ge307XG5cbiAgICBzdGF0aWMgcmVnaXN0ZXIoa2V5LCB2YWwpIHtcbiAgICAgICAgbm90Q29tbW9uLnJlZ2lzdHJ5W2tleV0gPSB2YWw7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldChrZXkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bihub3RDb21tb24ucmVnaXN0cnksIGtleSlcbiAgICAgICAgICAgID8gbm90Q29tbW9uLnJlZ2lzdHJ5W2tleV1cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBpdGVtIGluc2lkZSBhcnJheSBmcm9tIG9sZF9pbmRleCB0byBuZXdfaW5kZXhcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRfaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3X2luZGV4XG4gICAgICogQG1lbWJlcm9mIG5vdENvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBtb3ZlSXRlbShhcnJheSwgb2xkX2luZGV4LCBuZXdfaW5kZXgpIHtcbiAgICAgICAgY29uc3QgaW5SYW5nZSA9IChudW0pID0+IG51bSA8IGFycmF5Lmxlbmd0aCAmJiBudW0gPiAtMTtcbiAgICAgICAgaWYgKGluUmFuZ2UobmV3X2luZGV4KSAmJiBpblJhbmdlKG9sZF9pbmRleCkpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShuZXdfaW5kZXgsIDAsIGFycmF5LnNwbGljZShvbGRfaW5kZXgsIDEpWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzdHJpcFByb3h5KG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmogIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChvYmouaXNQcm94eSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gQXJyYXkuZnJvbShvYmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24ob2JqLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3RdID0gbm90Q29tbW9uLnN0cmlwUHJveHkob2JqW3RdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0YXRpYyBwaXBlKGRhdGEgLyogZmVlZCBkYXRhICovLCBmdW5jcyAvKiBmdW5jdGlvbnMgYXJyYXkgKi8pIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgZm9yIChsZXQgZnVuYyBvZiBmdW5jcykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyhyZXN1bHQgfHwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJvZiBub3RDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QVBJKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRNYW5hZ2VyKCk/LmdldEFQSSh0eXBlKSA/PyBudWxsO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRNYW5hZ2VyKHYpIHtcbiAgICAgICAgbm90Q29tbW9uLk1BTkFHRVIgPSB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJvZiBub3RDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5NQU5BR0VSO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsKS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgd2FpdChzZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzLCBzZWMgKiAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlZ2lzdGVyV2lkZ2V0RXZlbnRzKGV2ZW50cykge1xuICAgICAgICBpZiAobm90Q29tbW9uLmdldEFwcCgpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5vbihldmVudE5hbWUsIGV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIG5hdmlnYXRlKHVybCkge1xuICAgICAgICBub3RDb21tb24uZ2V0QXBwKCkgJiZcbiAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXb3JraW5nKFwicm91dGVyXCIpLm5hdmlnYXRlKHVybCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdCh2YXJpYW50c1NldCwgdmFsdWUsIGRlZikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB2YXJpYW50c1NldCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhcmlhbnRzU2V0ID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXModmFyaWFudHNTZXQsIHZhbHVlKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhcmlhbnRzU2V0W3ZhbHVlXSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdmFyaWFudHNTZXRbdmFsdWVdICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzU2V0W3ZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFic29yYlNlcnZpY2VzKHRhcmdldCwgc3JjKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBzZXJ2IGluIHNyYykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odGFyZ2V0LCBzZXJ2KSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5sb2dFcnJvcihgc2VydmljZXMgcHJvcGVydHkgZHVwbGljYXRpb24gJHtzZXJ2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3NlcnZdID0gc3JjW3NlcnZdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRXU0NsaWVudCh3Y3MsIHdzY05hbWUsIHdzY09wdGlvbnMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFPYmplY3QuaGFzT3duKHdjcywgd3NjTmFtZSkpIHtcbiAgICAgICAgd2NzW3dzY05hbWVdID0ge1xuICAgICAgICAgICAgY29ubmVjdGlvbjoge30sXG4gICAgICAgICAgICByb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICByb3V0ZXM6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3Nlbmdlcjoge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSB3Y3Nbd3NjTmFtZV07XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChPYmplY3QuaGFzT3duKHdzY09wdGlvbnMsIFwicm91dGVyXCIpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucy5yb3V0ZXIsIFwicm91dGVzXCIpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByb3V0ZVR5cGUgaW4gd3NjT3B0aW9ucy5yb3V0ZXIucm91dGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bih0YXJnZXQucm91dGVyLnJvdXRlcywgcm91dGVUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucm91dGVyLnJvdXRlc1tyb3V0ZVR5cGVdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LnJvdXRlci5yb3V0ZXNbcm91dGVUeXBlXSwge1xuICAgICAgICAgICAgICAgICAgICAuLi53c2NPcHRpb25zLnJvdXRlci5yb3V0ZXNbcm91dGVUeXBlXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucywgXCJtZXNzZW5nZXJcIikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQubWVzc2VuZ2VyLCB7IC4uLndzY09wdGlvbnMubWVzc2VuZ2VyIH0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucywgXCJjb25uZWN0aW9uXCIpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LmNvbm5lY3Rpb24sIHsgLi4ud3NjT3B0aW9ucy5jb25uZWN0aW9uIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCB0IG9mIFtcIm5hbWVcIiwgXCJnZXRUb2tlblwiLCBcImxvZ2dlclwiLCBcImlkZW50aXR5XCIsIFwiY3JlZGVudGlhbHNcIl0pIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLCB0KSkge1xuICAgICAgICAgICAgdGFyZ2V0W3RdID0gd3NjT3B0aW9uc1t0XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWJzb3JiV1NDKHRhcmdldCwgc3JjKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCB3c0NsaWVudE5hbWUgaW4gc3JjKSB7XG4gICAgICAgICAgICBleHRlbmRXU0NsaWVudCh0YXJnZXQsIHdzQ2xpZW50TmFtZSwgc3JjW3dzQ2xpZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhYnNvcmJVSXModGFyZ2V0LCBzcmMpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IHVpIGluIHNyYykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odGFyZ2V0LCB1aSkpIHtcbiAgICAgICAgICAgICAgICBub3RDb21tb24ubG9nRXJyb3IoYHVpcyBwcm9wZXJ0eSBkdXBsaWNhdGlvbiAke3VpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3VpXSA9IHNyY1t1aV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFic29yYkZpZWxkcyh0YXJnZXQsIHNyYykge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgdWkgaW4gc3JjKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0YXJnZXQsIHVpKSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5sb2dFcnJvcihgZmllbGRzIHByb3BlcnR5IGR1cGxpY2F0aW9uICR7dWl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbdWldID0gc3JjW3VpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLndzY1wiLCBhYnNvcmJXU0MpO1xubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLnNlcnZpY2VzXCIsIGFic29yYlNlcnZpY2VzKTtcbm5vdENvbW1vbi5yZWdpc3RlcihcImFic29yYi51aXNcIiwgYWJzb3JiVUlzKTtcbm5vdENvbW1vbi5yZWdpc3RlcihcImFic29yYi51aXNcIiwgYWJzb3JiRmllbGRzKTtcblxuZXhwb3J0IGRlZmF1bHQgbm90Q29tbW9uO1xuIiwiLyoqXG4gKiBQdXJwb3NlIG9mIHRoaXMgTG9jYWxlIG9iamVjdCBpcyB0aGF0IGl0IHdpbGwgaG9sZCBsaWJyYXJ5IG9mIGxvY2FsaXphdGlvblxuICogdGVtcGxhdGVzIGFuZCBwcm92aWRlIGJhc2ljIGxvY2FsaXphdGlvbiBzZXJ2aWNlIHRvIG90aGVyIG1vZHVsZXNcbiAqKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwid29sZnk4Ny1ldmVudGVtaXR0ZXJcIjtcblxuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vZnJhbWUvY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcblxuaW1wb3J0IExPQ0FMRSBmcm9tIFwiLi9zdG9yZVwiO1xuXG4vKipcbiAqIHN0cmluZ3MgbG9jYWxpemF0aW9uIGFuZCBmb3JtYXRpbmcgbW9kZWxcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBub3RMb2NhbGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTsgLy9kaWN0aW9uYXJ5IG9mIHBocmFzZXNcbiAgICAgICAgdGhpcy5oZWxwZXJzID0ge307IC8vYWRkaXRpb25hbCBoZWxwZXIgZnVuY3Rpb25zIGFuZCBjb25zdGFudHNcbiAgICAgICAgbGV0IGRpY3QgPSB0aGlzLnJlc3RvcmVGcm9tU3RvcmFnZSgpO1xuICAgICAgICBpZiAoZGljdCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoZGljdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgZm9ybWF0IHNob3VsZCBjb21wbHkgbm90UGF0aCBzdGFuZGFydC5cbiAgICAgKiB7cGF0aF90b19hY2Nlc3N9IC0gaXNcbiAgICAgKiA6IC0gaXMgdXNlZCB0byBhY2Nlc3MgdG8gcGFyYW1zXG4gICAgICogOjogLSBpcyB1c2VkIHRvIGFjY2VzcyB0byBoZWxwZXJzXG4gICAgICogV2VsY29tZSwgezp3aGVyZX0hIC0gd2lsbCByZXBsYWNlIHs6d2hlcmV9IHdpdGggY29udGVudCBvZiBwYXJhbXMud2hlcmVcbiAgICAgKiBXZWxjb21lLCB7Ojp3aGVyZX0hIC0gd2lsbCByZXBsYWNlIHs6d2hlcmV9IHdpdGggY29udGVudCBvZiB0aGlzLmhlbHBlcnMud2hlcmVcbiAgICAgKiAoKSAtIGFmdGVyIHBhdGggaXMgdG8gaW52b2tlIGZ1bmN0aW9uIG9mIHRhcmdldCBvYmplY3RcbiAgICAgKiBXZWxjb21lLCB7Ojp3aGVyZSgpfSEgLSB3aWxsIHRyeSB0byBleGVjIHRoaXMuaGVscGVycy53aGVyZShwYXJhbXMsIHVuZGVmaW5lZClcbiAgICAgKiBAcGFyYW0gICAge3N0cmluZ30gIHN0ciAgICAgICAgIGxvY2FsaXplZCBzdHJpbmcgdGVtcGxhdGUgd2l0aCBtYXJrIHRvIGluY2x1ZGUgZGF0YVxuICAgICAqIEBwYXJhbSAgICB7b2JqZWN0fSAgcGFyYW1zICAgICAgcGFyYW1zIHRvIHVzZSBpbiBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyAge3N0cmluZ30gICAgICAgICAgICAgIGxvY2FsaXplZCB2ZXJzaW9uIG9mIHN0cmluZyB3aXRoXG4gICAgICovXG4gICAgZm9ybWF0KHN0ciwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBub3RQYXRoLnBhcnNlU3VicyhzdHIsIHBhcmFtcywgdGhpcy5oZWxwZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbG9jYWxpemVkIHZlcnNpb24gb2Ygc3RyaW5nIHdpdGggaW5qZWN0ZWQgZGF0YSBmcm9tIHByb3ZpZGVkIG9iamVjdFxuICAgICAqIG1heSBhbHNvIHVzZSBMb2NhbGUuaGVscGVycyBhcyBzb3VyY2Ugb2YgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgIHBocmFzZSAgICBuYW1lIG9mIHN0cmluZyB0byBsb2NhbGl6ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIHBhcmFtcyAgICBvYmplY3Qgd2l0aCBkYXRhIHRvIGluamVjdCBpbiBwaHJhc2UgdGVtcGxhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgbG9jYWxpemVkIHN0cmluZyB3aXRoIGluamVjdGVkIGRhdGFcbiAgICAgKi9cbiAgICBzYXkocGhyYXNlLCBwYXJhbXMgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5kaWN0LCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcGwgPSB0aGlzLmRpY3RbcGhyYXNlXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZm9ybWF0KHRtcGwsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdG1wbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvY2FsZSBwaHJhc2U6ICR7cGhyYXNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uZGVidWcoZSk7XG4gICAgICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGluZyBuZXcgZGljdGlvbmFyeS4gdHJpZ2dlcnMgZXZlbnQgJ2NoYW5nZSdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgIGRpY3QgICAgICB2b2NhYnVsYXJ5IG9mIHBocmFzZXMgYW5kIHRlbXBsYXRlc1xuICAgICAqKi9cbiAgICBzZXQoZGljdCkge1xuICAgICAgICBMT0NBTEUuc2V0KGRpY3QpO1xuICAgICAgICB0aGlzLnNhdmVUb1N0b3JhZ2UoZGljdCk7XG4gICAgICAgIHRoaXMuZGljdCA9IE9iamVjdC5hc3NpZ24oe30sIHsgLi4uZGljdCB9KTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIH1cblxuICAgIHNhdmVUb1N0b3JhZ2UoZGljdCkge1xuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAgICAgICBcImRpY3Rpb25hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGljdClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5kZWJ1ZyhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlc3RvcmVGcm9tU3RvcmFnZSgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ciA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImRpY3Rpb25hcnlcIik7XG4gICAgICAgICAgICAgICAgaWYgKHN0cikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGljdCA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBub3RDb21tb24uZGVidWcoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdyaXRhYmxlIHN0b3JlIG9mIHBocmFzZXNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICB3cml0YWJsZSBzdG9yZVxuICAgICAqL1xuICAgIHZvY2FidWxhcnkoKSB7XG4gICAgICAgIHJldHVybiBMT0NBTEU7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgbm90TG9jYWxlKCk7XG4iLCJpbXBvcnQgTE9DQUxFIGZyb20gXCIuL3N0b3JlLmpzXCI7XG5pbXBvcnQgbm90TG9jYWxlIGZyb20gXCIuL25vdExvY2FsZS5qc1wiO1xuY29uc3Qgc2F5ID0gbm90TG9jYWxlLnNheS5iaW5kKG5vdExvY2FsZSk7XG5cbmV4cG9ydCB7IExPQ0FMRSwgc2F5LCBub3RMb2NhbGUgfTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZCA9IFwidGFnSWRcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgd2Ugd2FudCB0byBhZGRyZXNzIHRoaXMgdGFnLCBhcyB0YWcte2lkfTp7ZXZlbnROYW1lfSwgZXguIHRhZy10YWdJZDp1cGRhdGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdGl0bGUgPSBcInRhZ1wiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjb2xvciA9IFwiaW5mb1wiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbWEgY29sb3JcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc2l6ZSA9IFwibm9ybWFsXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bG1hIHNpemVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcGFkZGluZyA9IFwibm9ybWFsXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgb2YgbGVmdC9yaWdodCBwYWRkaW5ncyAoc21hbGwgPSAwLjVlbSwgbm9ybWFsID0gMWVtLCBiaWcgPSAxLjVlbSwgbGFyZ2UgPSAyZW0pLCBjbGFzcyBuYW1lcyBpcyBpcy1wYWRkZWQte3BhZGRpbmd9XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2JvbGQgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGUgc3R5bGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtyaWdodCA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyBwb3NpdGlvbmluZyBvbiB0aGUgcmlnaHQsIHRvIHNlZSBhdCB3b3JrIGxvb2sgZXhhbXBsZXMgb2YgRWxlbWVudHMuSWNvbnMuVUlJY29uQnV0dG9uV2l0aFRhZ1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtsZWZ0ID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyBwb3NpdGlvbmluZyBvbiB0aGUgbGVmdCwgdG8gc2VlIGF0IHdvcmsgbG9vayBleGFtcGxlcyBvZiBFbGVtZW50cy5JY29ucy5VSUljb25CdXR0b25XaXRoVGFnXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3RvcCA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSB0b3AsIHRvIHNlZSBhdCB3b3JrIGxvb2sgZXhhbXBsZXMgb2YgRWxlbWVudHMuSWNvbnMuVUlJY29uQnV0dG9uV2l0aFRhZ1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtib3R0b20gPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyBwb3NpdGlvbmluZyBvbiB0aGUgYm90dG9tLCB0byBzZWUgYXQgd29yayBsb29rIGV4YW1wbGVzIG9mIEVsZW1lbnRzLkljb25zLlVJSWNvbkJ1dHRvbldpdGhUYWdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgID0gXCJcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWwgY3NzIGNsYXNzZXMgbGlzdFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtldmVudHMgPSB7fV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgb2YgZXZlbnRzIHtuYW1lOmNhbGxiYWNrfVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtyZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50c10gICAgIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uVXBkYXRlID0gKGRhdGEpID0+IHRpdGxlID0gZGF0YS50aXRsZTtdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2FjdGlvbl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljay9vbmtleWRvd24gY2FsbGJhY2tcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbdmFycyA9IHt9XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3MgdmFycyBsaXN0XG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJ0YWdJZFwiLFxuICAgICAgICB0aXRsZSA9IFwidGFnXCIsXG4gICAgICAgIGNvbG9yID0gXCJpbmZvXCIsXG4gICAgICAgIHNpemUgPSBcIm5vcm1hbFwiLFxuICAgICAgICBwYWRkaW5nID0gXCJub3JtYWxcIixcbiAgICAgICAgYm9sZCA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgICAgICBsZWZ0ID0gZmFsc2UsXG4gICAgICAgIHRvcCA9IGZhbHNlLFxuICAgICAgICBib3R0b20gPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBldmVudHMgPSB7fSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMuYmluZChub3RDb21tb24pLFxuICAgICAgICBvblVwZGF0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkYXRhLCBcInRpdGxlXCIpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBkYXRhLnRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIHZhcnMgPSB7fSxcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gXCIwXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHNpZGVkID0gJGRlcml2ZWQocmlnaHQgfHwgbGVmdCB8fCB0b3AgfHwgYm90dG9tKTtcblxuICAgIGxldCBoQ2VudGVyZWQgPSAkZGVyaXZlZCghcmlnaHQgJiYgIWxlZnQgJiYgc2lkZWQpO1xuICAgIGxldCB2Q2VudGVyZWQgPSAkZGVyaXZlZCghYm90dG9tICYmICF0b3AgJiYgc2lkZWQpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgdGFnLSR7aWR9OnVwZGF0ZWA7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlID0gJHN0YXRlKFwiXCIpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0eWxlID0gT2JqZWN0LmtleXMoJHN0YXRlLnNuYXBzaG90KHZhcnMpKVxuICAgICAgICAgICAgLm1hcCgodmFyTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt2YXJOYW1lfTogJHt2YXJzW3Zhck5hbWVdfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGV9XG4gICAgPHNwYW5cbiAgICAgICAge3JvbGV9XG4gICAgICAgIHt0YWJJbmRleH1cbiAgICAgICAgb25rZXlkb3duPXthY3Rpb24gPyBhY3Rpb24gOiB1bmRlZmluZWR9XG4gICAgICAgIG9uY2xpY2s9e2FjdGlvbiA/IGFjdGlvbiA6IHVuZGVmaW5lZH1cbiAgICAgICAgaWQ9XCJ0YWcte2lkfVwiXG4gICAgICAgIGNsYXNzPVwiXG4gIHRhZ1xuICB7cGFkZGluZyAhPT0gJ25vcm1hbCcgPyBgaXMtcGFkZGVkLSR7cGFkZGluZ31gIDogJyd9XG4gIGlzLXtzaXplfVxuICBpcy17Y29sb3J9ICBcbiAge2NsYXNzZXN9XCJcbiAgICAgICAgY2xhc3M6aXMtY2xpY2thYmxlPXthY3Rpb259XG4gICAgICAgIGNsYXNzOmhhcy10ZXh0LXdlaWdodC1ib2xkPXtib2xkfVxuICAgICAgICBjbGFzczppcy12ZXJ0aWNhbC1jZW50ZXJlZD17dkNlbnRlcmVkfVxuICAgICAgICBjbGFzczppcy1ob3Jpem9udGFsLWNlbnRlcmVkPXtoQ2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXNpZGVkPXtzaWRlZH1cbiAgICAgICAgY2xhc3M6aXMtc2lkZWQtcmlnaHQ9e3JpZ2h0fVxuICAgICAgICBjbGFzczppcy1zaWRlZC1sZWZ0PXtsZWZ0fVxuICAgICAgICBjbGFzczppcy1zaWRlZC10b3A9e3RvcH1cbiAgICAgICAgY2xhc3M6aXMtc2lkZWQtYm90dG9tPXtib3R0b219XG4gICAgICAgIHtzdHlsZX0+eyRMT0NBTEVbdGl0bGVdfTwvc3BhblxuICAgID5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSVRhZyBmcm9tIFwiLi91aS50YWcuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbTENfVFJVRSA9IFwibm90LW5vZGU6Ym9vbGVhbnNfdHJ1ZVwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbTENfRkFMU0UgPSBcIm5vdC1ub2RlOmJvb2xlYW5zX2ZhbHNlXCJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWQgPSBmYWxzZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgTENfVFJVRSA9IFwibm90LW5vZGU6Ym9vbGVhbnNfdHJ1ZVwiLFxuICAgICAgICBMQ19GQUxTRSA9IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgRkFMU0VfVkFMVUUgPSB7XG4gICAgICAgIHRpdGxlOiBMQ19GQUxTRSxcbiAgICAgICAgY29sb3I6IGludmVydGVkID8gXCJzdWNjZXNzXCIgOiBcImRhbmdlclwiLFxuICAgIH07XG5cbiAgICBjb25zdCBUUlVFX1ZBTFVFID0ge1xuICAgICAgICB0aXRsZTogTENfVFJVRSxcbiAgICAgICAgY29sb3I6IGludmVydGVkID8gXCJkYW5nZXJcIiA6IFwic3VjY2Vzc1wiLFxuICAgIH07XG5cbiAgICAvL2lmIGludmVydGVkID09PSB0cnVlLCBpbnZlcnRzIHZhbHVlXG4gICAgbGV0IHRhZ1ZhbHVlID0gJGRlcml2ZWQodmFsdWUgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUUpO1xuPC9zY3JpcHQ+XG5cbjxVSVRhZyB7Li4udGFnVmFsdWV9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlCb29sZWFuIGZyb20gXCIuL3VpLmJvb2xlYW4uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyB2YWx1ZSwgbGFiZWwsIGludmVydGVkID0gZmFsc2UgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxzcGFuIGNsYXNzPVwibGFiZWxcIj57JExPQ0FMRVtsYWJlbF19OiA8VUlCb29sZWFuIHt2YWx1ZX0ge2ludmVydGVkfSAvPjwvc3Bhbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCb29sZWFuIGZyb20gXCIuL3VpLmJvb2xlYW4uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIHZhbHVlc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtpbnZlcnRlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICAgW2NvbXBvbmVudENvbnN0cnVjdG9yID0gVUlCb29sZWFuXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpdGVtUmVuZGVyZXJdICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBzdXBwbGllZCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBjb21wb25lbnRDb25zdHJ1Y3RvclxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgY29tcG9uZW50Q29uc3RydWN0b3I6IEl0ZW1Db25zdHJ1Y3RvciA9IFVJQm9vbGVhbixcbiAgICAgICAgaXRlbVJlbmRlcmVyLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBfdmFsdWVzID0gJHN0YXRlKFtdKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIF92YWx1ZXMgPSBbeyB2YWx1ZTogdmFsdWVzIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5ldmVyeSgoaXRtKSA9PiB0eXBlb2YgaXRtID09PSBcImJvb2xlYW5cIikpIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzID0gdmFsdWVzLm1hcCgoaXRtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdG0gfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlcyA9IFsuLi52YWx1ZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBfdmFsdWVzLmxlbmd0aH1cbiAgICB7I2VhY2ggX3ZhbHVlcyBhcyBpdGVtLCBpbmRleH1cbiAgICAgICAgeyNpZiBpdGVtUmVuZGVyZXJ9XG4gICAgICAgICAgICB7QHJlbmRlciBpdGVtUmVuZGVyZXIoaXRlbSwgaW5kZXgpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8SXRlbUNvbnN0cnVjdG9yIHsuLi5pdGVtfSBpbnZlcnRlZD17aW52ZXJ0ZWQgfHwgaXRlbS5pbnZlcnRlZH0gLz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgXCJidWxtYS10b29sdGlwL2Rpc3QvY3NzL2J1bG1hLXRvb2x0aXAubWluLmNzc1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbaGlkZGVuID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbc2hvd2FibGUgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtjb3BpYWJsZSA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NvcHlJY29uID0gJ2NvcHknXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaG93SWNvbiA9ICdleWUnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtoaWRlSWNvbiA9ICdleWUtc2xhc2gnXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFttYXhMZW5ndGggPSAyMF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc2hhZG93Q2xhc3MgPSBcImhhcy1iYWNrZ3JvdW5kLXByaW1hcnktOTBcIl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbdG9vbHRpcCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3Rvb2x0aXBUVEwgPSAyMDAwXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0b29sdGlwVGV4dCA9IFwi0KHQutC+0L/QuNGA0L7QstCw0L3QviDQsiDQsdGD0YTQtdGAXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Rvb2x0aXBDbGFzcyA9IFwiaGFzLXRvb2x0aXAtaW5mb1wiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt2YWx1ZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uZXJyb3JdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGhpZGRlbiA9ICRiaW5kYWJsZSh0cnVlKSxcbiAgICAgICAgc2hvd2FibGUgPSB0cnVlLFxuICAgICAgICBjb3BpYWJsZSA9IHRydWUsXG4gICAgICAgIGNvcHlJY29uID0gXCJjb3B5XCIsXG4gICAgICAgIHNob3dJY29uID0gXCJleWVcIixcbiAgICAgICAgaGlkZUljb24gPSBcImV5ZS1zbGFzaFwiLFxuICAgICAgICBtYXhMZW5ndGggPSAyMCxcbiAgICAgICAgc2hhZG93Q2xhc3MgPSBcImhhcy1iYWNrZ3JvdW5kLXByaW1hcnktOTBcIixcbiAgICAgICAgdG9vbHRpcCA9IHRydWUsXG4gICAgICAgIHRvb2x0aXBUVEwgPSAyMDAwLFxuICAgICAgICB0b29sdGlwVGV4dCA9IFwi0KHQutC+0L/QuNGA0L7QstCw0L3QviDQsiDQsdGD0YTQtdGAXCIsXG4gICAgICAgIHRvb2x0aXBDbGFzcyA9IFwiaGFzLXRvb2x0aXAtaW5mb1wiLFxuICAgICAgICB2YWx1ZSA9IFwiXCIsXG4gICAgICAgIG9uZXJyb3IsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlVmlldygpIHtcbiAgICAgICAgaGlkZGVuID0gIWhpZGRlbjtcbiAgICB9XG5cbiAgICBsZXQgY29udGVudENvcGllZCA9ICRzdGF0ZShmYWxzZSksXG4gICAgICAgIHRvb2x0aXBBY3RpdmUgPSAkZGVyaXZlZCh0b29sdGlwICYmIGNvbnRlbnRDb3BpZWQpLFxuICAgICAgICB0b29sdGlwVGFyZ2V0ID0gJHN0YXRlKCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb3B5Q29udGVudCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgY29udGVudENvcGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFRhcmdldC5kYXRhc2V0LnRvb2x0aXAgPSB0b29sdGlwVGV4dDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvcGllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdG9vbHRpcFwiKTtcbiAgICAgICAgICAgICAgICB9LCB0b29sdGlwVFRMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBvbmVycm9yICYmIG9uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c3BhblxuICAgIGNsYXNzPXsoaGlkZGVuID8gXCJpcy1jZW5zb3JlZCBcIiArIHNoYWRvd0NsYXNzIDogXCJcIikgK1xuICAgICAgICBcIiBpcy12ZXJ0aWNhbC1taWRkbGUgXCJ9XG4gICAgc3R5bGU9e2BkaXNwbGF5OmlubGluZS1ibG9jazsgd2lkdGg6ICR7bWF4TGVuZ3RofXJlbTsgaGVpZ2h0OiB2YXIoLS1idWxtYS1zaXplLW1lZGl1bSk7IG92ZXJmbG93LXg6aGlkZGVuO2B9XG4gICAgPntoaWRkZW4gPyBcIlwiIDogdmFsdWV9PC9zcGFuXG4+XG57I2lmIGNvcGlhYmxlfVxuICAgIDxzcGFuXG4gICAgICAgIGJpbmQ6dGhpcz17dG9vbHRpcFRhcmdldH1cbiAgICAgICAgb25jbGljaz17Y29weUNvbnRlbnR9XG4gICAgICAgIG9ua2V5ZG93bj17Y29weUNvbnRlbnR9XG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICBjbGFzcz17XCJpY29uIGlzLXNtYWxsIGlzLXJpZ2h0IGlzLWNsaWNrYWJsZSBcIiArXG4gICAgICAgICAgICAodG9vbHRpcEFjdGl2ZSA/IGAgJHt0b29sdGlwQ2xhc3N9IGAgOiBcIlwiKSArXG4gICAgICAgICAgICBcIiBpcy12ZXJ0aWNhbC1taWRkbGVcIn0+PGkgY2xhc3M9XCJmYXMgZmEte2NvcHlJY29ufVwiPjwvaT48L3NwYW5cbiAgICA+XG57L2lmfVxueyNpZiBzaG93YWJsZX1cbiAgICA8c3BhblxuICAgICAgICBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtcmlnaHQgaXMtY2xpY2thYmxlIGlzLXZlcnRpY2FsLW1pZGRsZVwiXG4gICAgICAgIG9uY2xpY2s9e3RvZ2dsZVZpZXd9XG4gICAgICAgIG9ua2V5ZG93bj17dG9nZ2xlVmlld31cbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiPjxpIGNsYXNzPVwiZmFzIGZhLXtoaWRkZW4gPyBzaG93SWNvbiA6IGhpZGVJY29ufVwiPjwvaT48L3NwYW5cbiAgICA+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWQgPSBcInRhZ0lkXCJdIC0gaWYgd2Ugd2FudCB0byBhZGRyZXNzIHRoaXMgaW5kaWNhdG9yXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3N0YXRlID0gXCJsaWdodFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaXplID0gXCJub3JtYWxcIl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbbGFiZWxzID0ge2JsYWNrLCBkYXJrLCBsaWdodCwgd2hpdGUsIHByaW1hcnksIGxpbmssIGluZm8sIHN1Y2Nlc3MsIHdhcm5pbmcsIGRhbmdlcn1dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gXCJtYXgtMVwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtwYWRkaW5nID0gXCJub3JtYWxcIl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbYm9sZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtyaWdodCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtsZWZ0ID0gbGVmdF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbdG9wID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2JvdHRvbSA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtldmVudHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHNdIC0gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbb25VcGRhdGUgPSAoZGF0YSkgPT4gY3VycmVudFN0YXRlID0gZGF0YS5zdGF0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInRhZ0lkXCIsXG4gICAgICAgIHN0YXRlOiBjdXJyZW50U3RhdGUgPSAkYmluZGFibGUoXCJsaWdodFwiKSxcbiAgICAgICAgc2l6ZSA9IFwibm9ybWFsXCIsXG4gICAgICAgIGxhYmVscyA9IHtcbiAgICAgICAgICAgIGJsYWNrOiBcImJsYWNrXCIsXG4gICAgICAgICAgICBkYXJrOiBcImRhcmtcIixcbiAgICAgICAgICAgIGxpZ2h0OiBcImxpZ2h0XCIsXG4gICAgICAgICAgICB3aGl0ZTogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgcHJpbWFyeTogXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICBsaW5rOiBcImxpbmtcIixcbiAgICAgICAgICAgIGluZm86IFwiaW5mb1wiLFxuICAgICAgICAgICAgc3VjY2VzczogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICB3YXJuaW5nOiBcIndhcm5pbmdcIixcbiAgICAgICAgICAgIGRhbmdlcjogXCJkYW5nZXJcIixcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIm14LTFcIixcbiAgICAgICAgcGFkZGluZyA9IFwibm9ybWFsXCIsXG4gICAgICAgIGJvbGQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgbGVmdCA9IGZhbHNlLFxuICAgICAgICB0b3AgPSBmYWxzZSxcbiAgICAgICAgYm90dG9tID0gZmFsc2UsXG4gICAgICAgIGV2ZW50cyA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIHJlZ2lzdGVyID0gbm90Q29tbW9uLnJlZ2lzdGVyV2lkZ2V0RXZlbnRzLmJpbmQobm90Q29tbW9uKSxcbiAgICAgICAgb25VcGRhdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZGF0YSwgXCJzdGF0ZVwiKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGRhdGEuc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgaW5kaWNhdG9yLSR7aWR9OnVwZGF0ZWA7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuXG4gICAgbGV0IHNpZGVkID0gJGRlcml2ZWQocmlnaHQgfHwgbGVmdCB8fCB0b3AgfHwgYm90dG9tKTtcbjwvc2NyaXB0PlxuXG48c3BhblxuICAgIGNsYXNzPVwidGFnIGlzLXtzaXplfSB7cGFkZGluZyAhPT0gJ25vcm1hbCdcbiAgICAgICAgPyBgaXMtcGFkZGVkLSR7cGFkZGluZ31gXG4gICAgICAgIDogJyd9IGlzLXtjdXJyZW50U3RhdGV9IHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6aGFzLXRleHQtd2VpZ2h0LWJvbGQ9e2JvbGR9XG4gICAgY2xhc3M6aXMtc2lkZWQ9e3NpZGVkfVxuICAgIGNsYXNzOmlzLXNpZGVkLXJpZ2h0PXtyaWdodH1cbiAgICBjbGFzczppcy1zaWRlZC1sZWZ0PXtsZWZ0fVxuICAgIGNsYXNzOmlzLXNpZGVkLXRvcD17dG9wfVxuICAgIGNsYXNzOmlzLXNpZGVkLWJvdHRvbT17Ym90dG9tfT57bGFiZWxzW2N1cnJlbnRTdGF0ZV19PC9zcGFuXG4+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXBhZ2Vsb2FkZXJcIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG5cbiAgICBpbXBvcnQgeyBvbkRlc3Ryb3ksIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvL2hpZGRlbiAtIG5vIGxvYWRlclxuICAgIC8vY29udGFpbmVyIC0gcGFyZW50IGNvbnRhaW5lciBvZiBmb3JtXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtsb2FkaW5nID0gZmFsc2VdICAgICAgIHN0YXRlIGlmIGZvcm0gbG9hZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaXplID0gJ2NvbnRhaW5lciddICAgIChwYWdlLCBjb250YWluZXIsIGhpZGRlbilcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdGl0bGUgPSAnV2FpdGluZy4uLiddICBMQyBzdHJpbmdcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdHRsXSAgICAgICAgICAgICAgICAgICB0aW1lIHRvIGxpdmUsIHdpbGwgYmUgY2xvc2VkIGFmdGVyIHR0bCBtc1xuICAgICAqIEBwcm9wZXJ0eSB7c25pcHBldH0gIFtjaGlsZHJlbl0gICAgICAgICAgICAgIHNuaXBwZXRzIG1heSBiZSBwcm92aWRlZFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHNpemUgPSBcImNvbnRhaW5lclwiLFxuICAgICAgICB0aXRsZSA9IFwiV2FpdGluZy4uLlwiLFxuICAgICAgICB0dGwsXG4gICAgICAgIG9ucmVqZWN0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgdHRsVGltZXI7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHR0bCkge1xuICAgICAgICAgICAgdHRsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb25yZWplY3QoKTtcbiAgICAgICAgICAgIH0sIHR0bCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgICAgIGlmICh0dGxUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHR0bFRpbWVyKTtcbiAgICAgICAgfVxuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjaWYgc2l6ZSAhPT0gXCJoaWRkZW5cIn1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPXtzaXplID09PSBcInBhZ2VcIiA/IFwicGFnZWxvYWRlclwiIDogXCJjb250YWluZXJsb2FkZXJcIn1cbiAgICAgICAgY2xhc3M6aXMtYWN0aXZlPXtsb2FkaW5nfVxuICAgID5cbiAgICAgICAgeyNpZiBjaGlsZHJlbn1cbiAgICAgICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPnskTE9DQUxFW3RpdGxlXX08L3NwYW4+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgbGV0IHsgdmFsdWUsIHRpdGxlLCBzZWxlY3RlZCB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPG9wdGlvbiB7dmFsdWV9IHtzZWxlY3RlZH0+eyRMT0NBTEVbdGl0bGVdfTwvb3B0aW9uPiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJU2VsZWN0T3B0aW9uIGZyb20gXCIuL3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFt2YXJpYW50c11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbZW1wdHlWYWx1ZUVuYWJsZWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bWJlcn0gIFtlbXB0eVZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW1wdHlWYWx1ZVRpdGxlID0gXCJuby1zZWxlY3Rpb25cIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZW1wdHlWYWx1ZVRpdGxlID0gXCJuby1zZWxlY3Rpb25cIixcbiAgICAgICAgZW1wdHlWYWx1ZUVuYWJsZWQgPSB0cnVlLFxuICAgICAgICBlbXB0eVZhbHVlID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWxlY3RcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHNlbGVjdGVkVmFyaWFudHMgPSAkc3RhdGUoW10pO1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyU2VsZWN0ZWRWYXJpYW50cyh2YXJpYW50KSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IHZhcmlhbnQuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja09uQ2xlYXJNYWNybyhuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IFVJQ29tbW9uLkNMRUFSX01BQ1JPKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxyZWFkeVByb2Nlc3NlZChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uY29tcGFyZVR3b0FycmF5cyh2YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoZXYpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogZXYuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFscmVhZHlQcm9jZXNzZWQoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGVja09uQ2xlYXJNYWNybyhkYXRhLnZhbHVlKTtcbiAgICAgICAgb25jaGFuZ2UoZGF0YSk7XG4gICAgfVxuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNlbGVjdGVkVmFyaWFudHMgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRzKVxuICAgICAgICAgICAgPyB2YXJpYW50cy5maWx0ZXIoZmlsdGVyU2VsZWN0ZWRWYXJpYW50cylcbiAgICAgICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHJlYWRvbmx5KSByZXR1cm47XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlbXB0eVZhbHVlRW5hYmxlZCAmJiB2YXJpYW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhcmlhbnRzWzBdLmlkO1xuICAgICAgICAgICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhcmlhbnRzWzBdLmlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICB7I2lmIHZhbHVlfVxuICAgICAgICB7I2VhY2ggc2VsZWN0ZWRWYXJpYW50cyBhcyBzZWxlY3RlZFZhcmlhbnR9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1yLTJcIj57JExPQ0FMRVtzZWxlY3RlZFZhcmlhbnQudGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9lYWNofVxuICAgIHs6ZWxzZSBpZiBlbXB0eVZhbHVlRW5hYmxlZH1cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJtci0yXCI+eyRMT0NBTEVbZW1wdHlWYWx1ZVRpdGxlXX08L3NwYW4+XG4gICAgey9pZn1cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwic2VsZWN0IHtsb2FkaW5nID8gYGlzLWxvYWRpbmdgIDogJyd9IHtzaXplXG4gICAgICAgICAgICA/IGBpcy0ke3NpemV9YFxuICAgICAgICAgICAgOiAnJ30ge2NvbG9yID8gYGlzLSR7Y29sb3J9YCA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgID5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXNlbGVjdC17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBvbmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgb25ibHVyPXtvbklucHV0fVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICB7c2l6ZX1cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgZW1wdHlWYWx1ZUVuYWJsZWR9XG4gICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uIHZhbHVlPXtlbXB0eVZhbHVlfSB0aXRsZT17ZW1wdHlWYWx1ZVRpdGxlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50ICh2YXJpYW50LmlkKX1cbiAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhcmlhbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXt2YWx1ZSA9PSB2YXJpYW50LmlkfVxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17dmFyaWFudC50aXRsZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhaXNlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdXRsaW5lZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3VuZGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3R5bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2FjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGxpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmFpc2VkID0gZmFsc2UsXG4gICAgICAgIG91dGxpbmVkID0gZmFsc2UsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgICAgIHJvdW5kZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgc3RhdGUgPSBcIlwiLFxuICAgICAgICB0eXBlID0gXCJcIixcbiAgICAgICAgY29sb3IgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgc3R5bGUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGljb24gPSBmYWxzZSxcbiAgICAgICAgaWNvblNpZGUgPSBcInJpZ2h0XCIsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBvbmNsaWNrICYmIG9uY2xpY2soeyBldmVudCwgdmFsdWUgfSk7XG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uKGV2ZW50LCB2YWx1ZSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b25cbiAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgIHtkaXNhYmxlZH1cbiAgICB0eXBlPXt0eXBlID8gdHlwZSA6IFwiXCJ9XG4gICAge3N0eWxlfVxuICAgIGNsYXNzPVwiXG4gIGJ1dHRvblxuICB7Y2xhc3Nlc31cbiAge3N0YXRlID8gYGlzLSR7c3RhdGV9YCA6ICcnfVxuICB7aW52ZXJ0ZWQgPyBgaXMtaW52ZXJ0ZWRgIDogJyd9XG4gIHtvdXRsaW5lZCA/IGBpcy1vdXRsaW5lZGAgOiAnJ31cbiAge3JhaXNlZCA/IGBpcy1yYWlzZWRgIDogJyd9XG4gIHtyb3VuZGVkID8gYGlzLXJvdW5kZWRgIDogJyd9XG4gIHtsaWdodCA/IGBpcy1saWdodGAgOiAnJ31cbiAge2xvYWRpbmcgPyBgaXMtbG9hZGluZ2AgOiAnJ31cbiAge2NvbG9yID8gYGlzLSR7Y29sb3J9YCA6ICcnfVxuICB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVxuICBcIlxuPlxuICAgIHsjaWYgY2hpbGRyZW59e0ByZW5kZXIgY2hpbGRyZW4oKX17OmVsc2UgaWYgaWNvbn1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJsZWZ0XCJ9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIlxuICAgICAgICAgICAgICAgID48aSBjbGFzcz1cImZhcyBmYS17aWNvbn0ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj48L2k+PC9zcGFuXG4gICAgICAgICAgICA+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgdGl0bGV9XG4gICAgICAgICAgICA8c3Bhbj57JExPQ0FMRVt0aXRsZV19PC9zcGFuPlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIGljb25TaWRlID09PSBcInJpZ2h0XCJ9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIlxuICAgICAgICAgICAgICAgID48aSBjbGFzcz1cImZhcyBmYS17aWNvbn0ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj48L2k+PC9zcGFuXG4gICAgICAgICAgICA+XG4gICAgICAgIHsvaWZ9XG4gICAgezplbHNlfVxuICAgICAgICB7JExPQ0FMRVt0aXRsZV19XG4gICAgey9pZn1cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXJpYUxhYmVsID0gXCJkZWxldGUgYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGlnaHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWlzZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0bGluZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcm91bmRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3R5bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgYXJpYUxhYmVsID0gXCJkZWxldGUgYnV0dG9uXCIsXG4gICAgICAgIGxpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmFpc2VkID0gZmFsc2UsXG4gICAgICAgIG91dGxpbmVkID0gZmFsc2UsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgICAgIHJvdW5kZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgc3RhdGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBzdHlsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBvbmNsaWNrICYmIG9uY2xpY2soeyBldmVudCwgdmFsdWUgfSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b25cbiAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWx9XG4gICAgb25jbGljaz17b25DbGlja31cbiAgICB7ZGlzYWJsZWR9XG4gICAge3N0eWxlfVxuICAgIGNsYXNzPVwiXG4gIGRlbGV0ZVxuICB7Y2xhc3Nlc30gIFxuICB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVxuICBcIlxuPjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSBcIi4vdWkuYnV0dG9uLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge0FycmF5PG9iamVjdD59IFt2YWx1ZXMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjZW50ZXJlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JpZ2h0ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5Db21wb25lbnR9IFtidXR0b25Db21wb25lbnQgPSBVSUJ1dHRvbl1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vZXZlbnRzLnR5cGVzJykuVUlFdmVudElucHV0Q2hhbmdlQ2FsbGJhY2t9IFthY3Rpb24gPSAoKT0+dHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vZXZlbnRzLnR5cGVzJykuVUlFdmVudENhbGxiYWNrfSBbb25jbGljayA9ICgpPT50cnVlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgY2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBidXR0b25Db21wb25lbnQ6IFN2ZWx0ZUNvbXBvbmVudCA9IFVJQnV0dG9uLFxuICAgICAgICBhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBfdmFsdWVzID0gJHN0YXRlKFtdKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBfdmFsdWVzID0gdmFsdWVzLm1hcCgoaXRtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oaXRtLmlkKSkge1xuICAgICAgICAgICAgICAgIGl0bS5pZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRtO1xuICAgICAgICB9KTtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJidXR0b25zIGhhcy1hZGRvbnMge2NsYXNzZXN9XCJcbiAgICBjbGFzczppcy1yaWdodD17cmlnaHR9XG4gICAgY2xhc3M6aXMtY2VudGVyZWQ9e2NlbnRlcmVkfVxuPlxuICAgIHsjZWFjaCBfdmFsdWVzIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50IHthY3Rpb259IHtvbmNsaWNrfSB7Li4uaXRlbX0gYmluZDp2YWx1ZT17aXRlbS52YWx1ZX0gLz5cbiAgICB7L2VhY2h9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGVmdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2NlbnRlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3JpZ2h0XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBjbGFzczogY2xhc3NlcyA9IFwiXCIsIGxlZnQgPSBbXSwgY2VudGVyID0gW10sIHJpZ2h0ID0gW10gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJjb2x1bW5zIHtjbGFzc2VzfVwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e2xlZnR9PjwvVUlCdXR0b25zPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e2NlbnRlcn0gY2VudGVyZWQ9e3RydWV9PjwvVUlCdXR0b25zPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5cIj5cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e3JpZ2h0fSByaWdodD17dHJ1ZX0+PC9VSUJ1dHRvbnM+XG4gICAgPC9kaXY+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b24gZnJvbSBcIi4vdWkuYnV0dG9uLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmFpc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dGxpbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdW5kZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3VpT2ZmXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt1aU9uXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFthY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgbGlnaHQgPSBmYWxzZSxcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlLFxuICAgICAgICByYWlzZWQgPSBmYWxzZSxcbiAgICAgICAgb3V0bGluZWQgPSBmYWxzZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcm91bmRlZCA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICBzdGF0ZTogYWN0aXZlU3RhdGUgPSBcIlwiLFxuICAgICAgICB0eXBlID0gXCJcIixcbiAgICAgICAgY29sb3IgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBpY29uID0gZmFsc2UsXG4gICAgICAgIGljb25TaWRlID0gXCJyaWdodFwiLFxuICAgICAgICB1aU9mZiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB1aU9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXNlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4ge30sXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4ge30sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBzZWxlY3RlZCA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGNoaWxkUHJvcHMgPSAkc3RhdGUoe1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgbGlnaHQsXG4gICAgICAgIGxvYWRpbmcsXG4gICAgICAgIHJhaXNlZCxcbiAgICAgICAgb3V0bGluZWQsXG4gICAgICAgIGludmVydGVkLFxuICAgICAgICByb3VuZGVkLFxuICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzLFxuICAgICAgICBpY29uLFxuICAgICAgICBpY29uU2lkZSxcbiAgICAgICAgdmFsdWUsXG4gICAgfSk7XG5cbiAgICBsZXQgdWlFbGVtZW50ID0gJHN0YXRlKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgc2VsZWN0ZWQgPSBhY3Rpb24oZXZlbnQsIHZhbHVlLCBzZWxlY3RlZCk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgIG9uY2xpY2soeyB2YWx1ZSwgc2VsZWN0ZWQgfSk7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1cGRhdGVVSSgpIHtcbiAgICAgICAgaWYgKHVpRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHNDaGFuZ2VzID0gc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICA/IHVpT24odmFsdWUsIHNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIDogdWlPZmYodmFsdWUsIHNlbGVjdGVkKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BzQ2hhbmdlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRQcm9wc1trZXldID0gcHJvcHNDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkUHJvcHMgPSBjaGlsZFByb3BzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWQgIT09IFwidW5kZWZpbmVkXCIpIHVwZGF0ZVVJKCk7XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPFVJQnV0dG9uXG4gICAgYmluZDp0aGlzPXt1aUVsZW1lbnR9XG4gICAgey4uLmNoaWxkUHJvcHN9XG4gICAgc3RhdGU9e2FjdGl2ZVN0YXRlfVxuICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9uU3dpdGNoIGZyb20gXCIuL3VpLmJ1dHRvbi5zd2l0Y2guc3ZlbHRlXCI7XG5cbiAgICBjb25zdCB1aXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUl0ZW1VSShpdGVtKSB7XG4gICAgICAgIHVpc1tpdGVtLmlkXS51cGRhdGVVSSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmF1bHRBY3Rpb24gPSAoZXYsIHZhbHVlLCBzZWxlY3RlZCkgPT4ge1xuICAgICAgICBjb25zdCBjb3VudE9mU2VsZWN0ZWQgPSBjb3VudFNlbGVjdGVkKCk7XG4gICAgICAgIGlmIChjb3VudE9mU2VsZWN0ZWQgPT09IG1pbiAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudE9mU2VsZWN0ZWQgPT09IG1heCAmJiBzZWxlY3RlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4T2ZDdXJyZW50ID0gX3ZhbHVlcy5maW5kSW5kZXgoKGl0bSkgPT4gaXRtLnZhbHVlID09PSB2YWx1ZSk7XG4gICAgICAgIGxldCBuZXdTZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICBpZiAoaW5kZXhPZkN1cnJlbnQgPiAtMSkge1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWQgPSAhbmV3U2VsZWN0ZWQ7XG4gICAgICAgICAgICBjb25zdCBjbnQgPSBjb3VudFNlbGVjdGVkKCkgKyAobmV3U2VsZWN0ZWQgPyAxIDogLTEpO1xuICAgICAgICAgICAgaWYgKG1pbikge1xuICAgICAgICAgICAgICAgIGlmIChjbnQgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0VXBUb01pbihjbnQsIGluZGV4T2ZDdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA8IGNudCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNlbGVjdERvd25Ub01pbihjbnQsIGluZGV4T2ZDdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRUb0hpc3RvcnkoaW5kZXhPZkN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1NlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTZWxlY3RlZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5PG9iamVjdD59IFt2YWx1ZXNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2VudGVyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuQ29tcG9uZW50fSAgICAgIFtidXR0b25Db21wb25lbnQgPSBVSUJ1dHRvblN3aXRjaF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uUHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbYWN0aW9uID0gKGV2ZW50LCB2YWx1ZSwgc2VsZWN0ZWQpID0+IGJvb2xlYW5dICBmaXJlcyBvbiBidXR0b24gc3dpdGNoIGNsaWNrLCByZXR1cm5zIG5ldyBzdGF0ZSBvZiBzZWxlY3RlZFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNoYW5nZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21pbiA9IDBdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXggPSAxMDBdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBjZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGJ1dHRvbkNvbXBvbmVudCA9IFVJQnV0dG9uU3dpdGNoLFxuICAgICAgICBidXR0b25Qcm9wcyA9IHt9LFxuICAgICAgICBhY3Rpb24gPSBkZWZhdWx0QWN0aW9uLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBtaW4gPSAwLFxuICAgICAgICBtYXggPSAxMDAsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3Qgc2VsZWN0SGlzdG9yeSA9IFtdO1xuICAgIGxldCBfdmFsdWVzID0gJHN0YXRlKHZhbHVlcyk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgdmFsdWVzID0gJHN0YXRlLnNuYXBzaG90KF92YWx1ZXMpO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHZhbHVlcy5maWx0ZXIoKGl0bSkgPT4gaXRtLnNlbGVjdGVkKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJZHMgPSBzZWxlY3RlZC5tYXAoKGl0bSkgPT4gaXRtLmlkKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb3VudCA9IHNlbGVjdGVkSWRzLmxlbmd0aDtcbiAgICAgICAgb25jaGFuZ2UgJiZcbiAgICAgICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJZHMsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRDb3VudCxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZWxlY3RBbGwoKSB7XG4gICAgICAgIF92YWx1ZXMuZm9yRWFjaCgoaXRtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgX3ZhbHVlc1tpbmRleF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXBkYXRlSXRlbVVJKGl0bSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBkZXNlbGVjdEFsbCgpIHtcbiAgICAgICAgX3ZhbHVlcy5mb3JFYWNoKChpdG0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBfdmFsdWVzW2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdXBkYXRlSXRlbVVJKGl0bSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZENvdW50ID0gY291bnRTZWxlY3RlZCgpO1xuICAgICAgICBpZiAobWluICYmIHNlbGVjdGVkQ291bnQgPCBtaW4pIHtcbiAgICAgICAgICAgIHNlbGVjdFVwVG9NaW4oc2VsZWN0ZWRDb3VudCwgLTEpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gYWRkVG9IaXN0b3J5KGlkKSB7XG4gICAgICAgIGlmIChzZWxlY3RIaXN0b3J5LmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgICAgc2VsZWN0SGlzdG9yeS5zcGxpY2Uoc2VsZWN0SGlzdG9yeS5pbmRleE9mKGlkKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0SGlzdG9yeS5wdXNoKGlkKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gY291bnRTZWxlY3RlZCgpIHtcbiAgICAgICAgY29uc3QgY291bnRPZlNlbGVjdGVkID0gX3ZhbHVlcy5maWx0ZXIoKGJ0bikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGJ0bi5zZWxlY3RlZDtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY291bnRPZlNlbGVjdGVkO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB0b2dnbGVGaXJzdFN1aXRlZCh0b1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gX3ZhbHVlcy5maW5kSW5kZXgoKGl0bSkgPT4gIXRvVmFsdWUgPT0gaXRtLnNlbGVjdGVkKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIF92YWx1ZXNbaW5kZXhdLnNlbGVjdGVkID0gdG9WYWx1ZTtcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW1VSShfdmFsdWVzW2luZGV4XSk7XG4gICAgICAgICAgICBhZGRUb0hpc3RvcnkoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFVwVG9NaW4oY250LCBpbmRleE9mQ3VycmVudCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBtaW4gLSBjbnQ7XG4gICAgICAgIGlmICghZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IGluIF92YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSBpbmRleE9mQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdmFsdWVzW3RdLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1t0XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbVVJKF92YWx1ZXNbdF0pO1xuICAgICAgICAgICAgICAgIGFkZFRvSGlzdG9yeSh0KTtcbiAgICAgICAgICAgICAgICBkZWx0YS0tO1xuICAgICAgICAgICAgICAgIGlmICghZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGRlc2VsZWN0RG93blRvTWluKGNudCwgaW5kZXhPZkN1cnJlbnQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY250IC0gbWF4O1xuICAgICAgICBpZiAoIWRlbHRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCBpbiBfdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gaW5kZXhPZkN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdmFsdWVzW3RdLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1t0XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1VSShfdmFsdWVzW3RdKTtcbiAgICAgICAgICAgICAgICBkZWx0YS0tO1xuICAgICAgICAgICAgICAgIGlmICghZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVVJKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh1aXMpLmZvckVhY2goKGl0ZW1JZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHVpc1tpdGVtSWRdKSB7XG4gICAgICAgICAgICAgICAgdWlzW2l0ZW1JZF0udXBkYXRlVUkgJiYgdWlzW2l0ZW1JZF0udXBkYXRlVUkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cImJ1dHRvbnMgaGFzLWFkZG9ucyB7Y2VudGVyZWQgPyAnaXMtY2VudGVyZWQnIDogJyd9IHtyaWdodFxuICAgICAgICA/ICdpcy1yaWdodCdcbiAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbj5cbiAgICB7I2VhY2ggX3ZhbHVlcyBhcyBpdGVtLCBpbmRleCAoaXRlbS5pZCl9XG4gICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gYnV0dG9uQ29tcG9uZW50fVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50XG4gICAgICAgICAgICBiaW5kOnRoaXM9e3Vpc1tpdGVtLmlkXX1cbiAgICAgICAgICAgIHthY3Rpb259XG4gICAgICAgICAgICB7Li4uaXRlbX1cbiAgICAgICAgICAgIHsuLi5idXR0b25Qcm9wc31cbiAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAgYmluZDpzZWxlY3RlZD17X3ZhbHVlc1tpbmRleF0uc2VsZWN0ZWR9XG4gICAgICAgICAgICBvbmNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgIC8+XG4gICAgey9lYWNofVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGxldCB7XG4gICAgICAgIGdyb3VwZWQgPSBmYWxzZSxcbiAgICAgICAgYWRkb25zID0gZmFsc2UsXG4gICAgICAgIG11bHRpbGluZSA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwiZmllbGQge2NsYXNzZXN9XCJcbiAgICBjbGFzczpoYXMtYWRkb25zPXthZGRvbnN9XG4gICAgY2xhc3M6aXMtZ3JvdXBlZD17Z3JvdXBlZH1cbiAgICBjbGFzczppcy1tdWx0aWxpbmU9e211bHRpbGluZX1cbiAgICB7Li4ub3RoZXJzfVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzPScnXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hhc0ljb25zTGVmdD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtoYXNJY29uc1JpZ2h0PWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaGFzSWNvbnNMZWZ0ID0gZmFsc2UsXG4gICAgICAgIGhhc0ljb25zUmlnaHQgPSBmYWxzZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48cFxuICAgIGNsYXNzPVwiY29udHJvbCB7Y2xhc3Nlc31cIlxuICAgIGNsYXNzOmhhcy1pY29ucy1sZWZ0PXtoYXNJY29uc0xlZnR9XG4gICAgY2xhc3M6aGFzLWljb25zLXJpZ2h0PXtoYXNJY29uc1JpZ2h0fVxuICAgIHsuLi5vdGhlcnN9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9wPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbiAgICBpbXBvcnQgVUlTZWxlY3QgZnJvbSBcIi4uL2lucHV0L3VpLnNlbGVjdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbnMsIFVJQnV0dG9uIH0gZnJvbSBcIi4uL2J1dHRvblwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlGaWVsZCBmcm9tIFwiLi4vaW5wdXQvdWkuZmllbGQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udHJvbCBmcm9tIFwiLi4vaW5wdXQvdWkuY29udHJvbC5zdmVsdGVcIjtcblxuICAgIGNvbnN0IERFRkFVTFRfQVBJX01PREVMX0dFVFRFUiA9IChcbiAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICBhY3Rpb25GaWx0ZXIsXG4gICAgICAgIGFjdGlvblNvcnRlcixcbiAgICAgICAgYWN0aW9uUGFnZXIsXG4gICAgICAgIGFjdGlvblNlYXJjaFxuICAgICkgPT4ge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uXG4gICAgICAgICAgICAuZ2V0QXBwKClcbiAgICAgICAgICAgIC5nZXRNb2RlbChtb2RlbE5hbWUpXG4gICAgICAgICAgICAuc2V0RmlsdGVyKGFjdGlvbkZpbHRlcilcbiAgICAgICAgICAgIC5zZXRTb3J0ZXIoYWN0aW9uU29ydGVyKVxuICAgICAgICAgICAgLnNldFBhZ2VyKGFjdGlvblBhZ2VyKVxuICAgICAgICAgICAgLnNldFNlYXJjaChhY3Rpb25TZWFyY2gpO1xuICAgIH07XG5cbiAgICBjb25zdCBERUZBVUxUX0FQSV9SRVFVRVNUID0gKGFwaU1vZGVsLCBhY3Rpb25OYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBhcGlNb2RlbFtgJGAgKyBhY3Rpb25OYW1lXSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgb2Ygc2VsZWN0ZWQgdmFyaWFudFxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIFt2YXJpYW50cyA9IFtdXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCBvZiB2YXJpYW50c1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtsb2FkZWQgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSBpZiB3ZSBhbHJlYWR5IGxvYWRlZCB2YXJpYW50cyBmcm9tIHNlcnZlciB2aWEgQVBJXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3BsYWNlaG9sZGVyID0gXCJlbXB0eSBzZWxlY3QgaXRlbVwiXSAgICAgICAgIHBsYWNlaG9sZGVyIHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2ZpZWxkbmFtZSA9IFwic2VsZWN0RnJvbU1vZGVsXCJdICAgICAgICAgICAgIHRoaXMgaW5wdXQgZmllbGRuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW21vZGVsTmFtZSA9IFwiXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFQSSBtb2RlbE5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbYWN0aW9uTmFtZSA9IFwiXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBJIGFjdGlvbk5hbWVcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYWN0aW9uRmlsdGVyID0ge31dICAgICAgICAgICAgICAgICAgICAgICAgIEFQSSBmaWx0ZXJpbmcgcnVsZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYWN0aW9uU29ydGVyID0ge31dICAgICAgICAgICAgICAgICAgICAgICAgIEFQSSBzb3J0aW5nIHJ1bGVzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2FjdGlvblBhZ2VyID0ge31dICAgICAgICAgICAgICAgICAgICAgICAgICBBUEkgcGFnZXIgc3RhdGVcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYWN0aW9uU2VhcmNoID0gdW5kZWZpbmVkXSAgICAgICAgICAgICAgICAgIEFQSSBzZWFyY2ggc3RyaW5nXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW29wdGlvbklkID0gXCI6X2lkXCJdICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQgb2JqZWN0IGlkIGZpZWxkIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbb3B0aW9uVGl0bGUgPSBcIjp0aXRsZVwiXSAgICAgICAgICAgICAgICAgICAgdmFyaWFudCBvYmplY3QgdGl0bGUgZmllbGQgbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtyZXF1aXJlZCA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgaXMgcmVxdWlyZWRcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbcmVhZG9ubHkgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkIGlzIHJlYW9ubHlcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbc2l6ZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdyBtYW55IHZhcmlhbnRzIHdvdWxkIGJlIHZpc2libGUgYXQgb25jZSwgZGVmYXVsdDogMVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFt2YWxpZCA9IHRydWVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgaXMgdmFsaWRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25yZWplY3QgPSAoKSA9PiBmYWxzZV0gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrIG9uIHJlamVjdCBvZiBzZWxlY3Rpb24gcHJvY2Vzc1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbnJlc29sdmUgPSAoKSA9PiB0cnVlXSAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgb24gcmVzb2x2ZSBvZiBzZWxlY3Rpb24gcHJvY2Vzc1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmVycm9yID0gKCkgPT4gdHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgb24gZXJyb3JcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIGxvYWRlZCA9IGZhbHNlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiZW1wdHkgc2VsZWN0IGl0ZW1cIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWxlY3RGcm9tTW9kZWxcIixcbiAgICAgICAgbW9kZWxOYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbkZpbHRlciA9IHt9LFxuICAgICAgICBhY3Rpb25Tb3J0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uUGFnZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU2VhcmNoID0gdW5kZWZpbmVkLFxuICAgICAgICBhcGlNb2RlbEdldHRlciA9IERFRkFVTFRfQVBJX01PREVMX0dFVFRFUixcbiAgICAgICAgYXBpUmVxdWVzdCA9IERFRkFVTFRfQVBJX1JFUVVFU1QsXG4gICAgICAgIG9wdGlvbklkID0gXCI6X2lkXCIsXG4gICAgICAgIG9wdGlvblRpdGxlID0gXCI6dGl0bGVcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBvbnJlamVjdCA9ICgpID0+IGZhbHNlLFxuICAgICAgICBvbnJlc29sdmUgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmVycm9yID0gKCkgPT4gdHJ1ZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBhcmd1bWVudHNTZXRQcm92aWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsTmFtZSAmJiBhY3Rpb25OYW1lICYmIGFjdGlvbkZpbHRlcjtcbiAgICB9XG5cbiAgICBsZXQgZGlzYWJsZWQgPSAkZGVyaXZlZCghbG9hZGVkKTtcbiAgICBsZXQgY29tcG9uZW50U3RhdGUgPSAkc3RhdGUoXCJoaWRkZW5cIik7XG4gICAgbGV0IHJlc3VsdHNMaXN0ID0gW107XG5cbiAgICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1NldFByb3ZpZGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpUmVxdWVzdChcbiAgICAgICAgICAgICAgICBhcGlNb2RlbEdldHRlcihcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25GaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblNvcnRlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uUGFnZXIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblNlYXJjaFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvbmVycm9yKHJlc3BvbnNlLmVycm9ycyB8fCBbcmVzcG9uc2UubWVzc2FnZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzTGlzdCA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB2YXJpYW50cyA9IHJlc3VsdHNMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vdFBhdGguZ2V0KG9wdGlvbklkLCBpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBub3RQYXRoLmdldChvcHRpb25UaXRsZSwgaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc29sdmVkVmFsdWU7XG5cbiAgICBmdW5jdGlvbiBvbk1vZGVsQ2hhbmdlZCh7IHZhbHVlOiBzZWxlY3RlZFZhbHVlIH0pIHtcbiAgICAgICAgaWYgKHJlc3VsdHNMaXN0Lmxlbmd0aCA+IHZhcmlhbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IHJlc3VsdHNMaXN0LmZpbmQoXG4gICAgICAgICAgICAgICAgKGl0ZW0pID0+IG5vdFBhdGguZ2V0KG9wdGlvbklkLCBpdGVtKSA9PSBzZWxlY3RlZFZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT0gc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBBQ1RJT05TID0ge1xuICAgICAgICBhZGQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGljb246IFwicGx1c1wiLFxuICAgICAgICAgICAgYWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YXRlID0gXCJzaG93XCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICBpY29uOiBcImNoZWNrXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJwcmltYXJ5XCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RhdGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIG9ucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QocmVzb2x2ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6IHtcbiAgICAgICAgICAgIGljb246IFwieG1hcmtcIixcbiAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgYWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YXRlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBvbnJlamVjdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbnsjaWYgY29tcG9uZW50U3RhdGUgPT09IFwiaGlkZGVuXCJ9XG4gICAgPFVJQnV0dG9uIHsuLi5BQ1RJT05TLmFkZH0+PC9VSUJ1dHRvbj5cbns6ZWxzZSBpZiBjb21wb25lbnRTdGF0ZSA9PSBcInNob3dcIn1cbiAgICA8VUlGaWVsZCBhZGRvbnM9e3RydWV9PlxuICAgICAgICA8VUlDb250cm9sPlxuICAgICAgICAgICAgPFVJU2VsZWN0XG4gICAgICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAgICAgIHt2YXJpYW50c31cbiAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAge2ZpZWxkbmFtZX1cbiAgICAgICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICB7c2l6ZX1cbiAgICAgICAgICAgICAgICB7Y29sb3J9XG4gICAgICAgICAgICAgICAge3ZhbGlkfVxuICAgICAgICAgICAgICAgIG9uY2hhbmdlPXtvbk1vZGVsQ2hhbmdlZH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvVUlDb250cm9sPlxuICAgICAgICA8VUlDb250cm9sPlxuICAgICAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e1tBQ1RJT05TLnJlc29sdmUsIEFDVElPTlMucmVqZWN0XX0+PC9VSUJ1dHRvbnM+XG4gICAgICAgIDwvVUlDb250cm9sPlxuICAgIDwvVUlGaWVsZD5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udHJvbCBmcm9tIFwiLi4vaW5wdXQvdWkuY29udHJvbC5zdmVsdGVcIjtcblxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBjb25zdCBERUZBVUxUX1NFUlZJQ0VfR0VUVEVSID0gKHNlcnZpY2VOYW1lKSA9PiB7XG4gICAgICAgIGlmICghc2VydmljZU5hbWUpIHRocm93IG5ldyBFcnJvcihcInNlcnZpY2VOYW1lIGlzIG5vdCBzZXRcIik7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uZ2V0QXBwKCkuZ2V0U2VydmljZShzZXJ2aWNlTmFtZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSAgIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2ljb24gPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbZmllbGRuYW1lID0gJyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JlYWRvbmx5ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NlcnZpY2VOYW1lID0gJyddIC0gU2V0IHRoaXMsIGFzIG5zW01vZGVsTmFtZV0sIHNob3VsZCBiZSByZWdpc3RlcmVkIGluIG5vdEFwcFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzZXJ2aWNlT3BlblNlbGVjdG9yTWV0aG9kID0gXCJvcGVuU2VsZWN0b3JcIl0gLSBTZXQgdGhpc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzZXJ2aWNlTG9hZERhdGFNZXRob2QgPSBcImxvYWREYXRhXCJdIC0gU2V0IHRoaXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbbW9kZWxEYXRhID0gbnVsbF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbbG9hZGluZyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXIgPSAoZGF0YSkgPT4gZGF0YS5faWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3NlcnZpY2VHZXR0ZXIgPSAoc2VydmljZU5hbWUpPT5ub3RDb21tb24uZ2V0QXBwKCkuZ2V0U2VydmljZShzZXJ2aWNlTmFtZSldXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2xvYWRpbmdMYWJlbCA9IFwibm90LW5vZGU6bG9hZGluZ19sYWJlbFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpc0VtcHR5TGFiZWwgPSBcIm5vdC1ub2RlOmZpZWxkX3ZhbHVlX2lzX2VtcHR5X3BsYWNlaG9sZGVyXCJdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlID0gKCkgPT4gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbb3BlblNlbGVjdG9yQnV0dG9uUHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbcmVzZXRCdXR0b25Qcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtlbXB0eUJ1dHRvblByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW3ZhbHVlQnV0dG9uUHJvcHMgPSB7fV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoKSxcbiAgICAgICAgaWNvbiA9IFwic2VhcmNoXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiXCIsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHNlcnZpY2VOYW1lID0gXCJcIixcbiAgICAgICAgc2VydmljZU9wZW5TZWxlY3Rvck1ldGhvZCA9IFwib3BlblNlbGVjdG9yXCIsXG4gICAgICAgIHNlcnZpY2VMb2FkRGF0YU1ldGhvZCA9IFwibG9hZERhdGFcIixcbiAgICAgICAgbW9kZWxEYXRhID0gJGJpbmRhYmxlKG51bGwpLFxuICAgICAgICBsb2FkaW5nID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgc2VsZWN0ZWRNb2RlbFRpdGxlRm9ybWF0dGVyID0gKGRhdGEpID0+IGAke2RhdGEuX2lkfWAsXG4gICAgICAgIHNlcnZpY2VHZXR0ZXIgPSBERUZBVUxUX1NFUlZJQ0VfR0VUVEVSLFxuICAgICAgICBsb2FkaW5nTGFiZWwgPSBcIm5vdC1ub2RlOmxvYWRpbmdfbGFiZWxcIixcbiAgICAgICAgaXNFbXB0eUxhYmVsID0gXCJub3Qtbm9kZTpmaWVsZF92YWx1ZV9pc19lbXB0eV9wbGFjZWhvbGRlclwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9wZW5TZWxlY3RvckJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIHJlc2V0QnV0dG9uUHJvcHMgPSB7fSxcbiAgICAgICAgZW1wdHlCdXR0b25Qcm9wcyA9IHt9LFxuICAgICAgICB2YWx1ZUJ1dHRvblByb3BzID0ge30sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb3Blbk1vZGVsU2VhcmNoQW5kU2VsZWN0KCkge1xuICAgICAgICBpZiAoIXNlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2QgaXMgbm90IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlID0gc2VydmljZUdldHRlcihzZXJ2aWNlTmFtZSk7XG4gICAgICAgIHNlcnZpY2Vbc2VydmljZU9wZW5TZWxlY3Rvck1ldGhvZF0oKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0Ll9pZDtcbiAgICAgICAgICAgICAgICBtb2RlbERhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG1vZGVsRGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRTZWxlY3RlZE1vZGVsKCkge1xuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbW9kZWxEYXRhID0gbnVsbDtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBsb2FkTW9kZWxEYXRhKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFtb2RlbERhdGEgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb2RlbERhdGEgPSBhd2FpdCBnZXRTZXJ2aWNlKClbc2VydmljZUxvYWREYXRhTWV0aG9kXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgbG9hZE1vZGVsRGF0YSgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgQVZBSUxBQkxFX0JVVFRPTlMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgYWN0aW9uOiBvcGVuTW9kZWxTZWFyY2hBbmRTZWxlY3QsXG4gICAgICAgICAgICBpY29uLFxuICAgICAgICAgICAgY29sb3I6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgLi4ub3BlblNlbGVjdG9yQnV0dG9uUHJvcHMsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgYWN0aW9uOiByZXNldFNlbGVjdGVkTW9kZWwsXG4gICAgICAgICAgICBpY29uOiBcInRpbWVzXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJkYW5nZXJcIixcbiAgICAgICAgICAgIC4uLnJlc2V0QnV0dG9uUHJvcHMsXG4gICAgICAgIH0sXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGdldE1vZGVsQnV0dG9uKCkge1xuICAgICAgICBpZiAobG9hZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBsb2FkaW5nTGFiZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGVsRGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiByZWFkb25seSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBvcGVuTW9kZWxTZWFyY2hBbmRTZWxlY3QsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXIobW9kZWxEYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsdWVCdXR0b25Qcm9wcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGlzRW1wdHlMYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgLi4uZW1wdHlCdXR0b25Qcm9wcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IFZJU0lCTEVfQlVUVE9OUyA9ICRzdGF0ZShbXSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBWSVNJQkxFX0JVVFRPTlMgPSBbXG4gICAgICAgICAgICAgICAgZ2V0TW9kZWxCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAuLi4ocmVhZG9ubHkgPyBbXSA6IEFWQUlMQUJMRV9CVVRUT05TKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBWSVNJQkxFX0JVVFRPTlMgPSBbXG4gICAgICAgICAgICAgICAgZ2V0TW9kZWxCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAuLi4ocmVhZG9ubHkgPyBbXSA6IFtBVkFJTEFCTEVfQlVUVE9OU1swXV0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxVSUNvbnRyb2w+XG4gICAgPFVJQnV0dG9ucyB2YWx1ZXM9e1ZJU0lCTEVfQlVUVE9OU30gY2xhc3M9e1wiaXMtbm8tZmxleC13cmFwXCJ9PjwvVUlCdXR0b25zPlxuPC9VSUNvbnRyb2w+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbbWF4ID0gMTAwXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjb2xvciA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NpemUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzcyA9IFwiXCJdXG4gICAgICoqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbWF4ID0gMTAwLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxwcm9ncmVzc1xuICAgIGNsYXNzPVwiXG4gIHByb2dyZXNzXG4gIHtjbGFzc2VzfVxuICB7Y29sb3IgPyBgaXMtJHtjb2xvcn1gIDogJyd9XG4gIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCJcbiAgICB7dmFsdWV9XG4gICAge21heH0+e3ZhbHVlfSU8L3Byb2dyZXNzXG4+XG4iLCI8c2NyaXB0PlxuICAgIGNvbnN0IGRlZmF1bHRGaWx0ZXIgPSAodmFsdWUpID0+IHZhbHVlW2lkRmllbGROYW1lXSA9PT0gaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bWJlcn0gICAgaWQgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIG9mIGFjdGl2ZSBpdGVtXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgICAgICAgICBbdmFsdWVzID0gW11dICAgICAgICAgICAgICAgbGlzdCBvZiBpdGVtc1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICAgICAgVUlDb21wb25lbnQgICAgICAgICAgICAgICAgIGNvbXBvbmVudCB0byBzaG93IGFjdGl2ZSBpdGVtXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICAgICBjb21wb25lbnQgICAgICAgICAgICAgICAgICAgc25pcHBldCB0byBzaG93IGFjdGl2ZSBpdGVtXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICAgICBVSVBsYWNlaG9sZGVyICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIgaWYgYWN0aXZlIGlzIHVuc2V0XG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICAgICBwbGFjZWhvbGRlciAgICAgICAgICAgICAgICAgc25pcHBldCB0byBzaG93IHBsYWNlaG9sZGVyXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgICAgICBbcGxhY2Vob2xkZXJQcm9wcyA9IHt9XSAgICAgcGxhY2Vob2xkZXIgcHJvcHNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgICAgIFthY3RpdmUgPSB7fV0gICAgICAgICAgICAgICBjdXJyZW50IGFjdGl2ZSBlbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgICAgICAgICBbaWRGaWVsZE5hbWUgPSBcIl9pZFwiXSAgICAgICBuYW1lIG9mIGl0ZW0gcHJvcGVydHkgdXNlZCBhcyBpZGVudGlmaWNhdG9yXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICAgICBbZmlsdGVyID0gKHZhbHVlKSA9PiB2YWx1ZVtpZEZpZWxkTmFtZV0gPT09IGlkXSBmaWx0ZXJpbmcgZnVuY3Rpb24gdG8gc2VsZWN0IGFjdGl2ZSBpdGVtLiBkZWZhdWx0IGlzIHRvIHNlYXJjaCBmb3IgaXRlbSB3aXRoIHNlbGVjdGVkIGlkXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkLFxuICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgYWN0aXZlID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgaWRGaWVsZE5hbWUgPSBcIl9pZFwiLFxuICAgICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgICBVSUNvbXBvbmVudCxcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBVSVBsYWNlaG9sZGVyLFxuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgcGxhY2Vob2xkZXJQcm9wcyxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgYWN0aXZlID1cbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiB2YWx1ZXMubGVuZ3RoICYmIHR5cGVvZiBpZCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gdmFsdWVzLmZpbmQoZmlsdGVyIHx8IGRlZmF1bHRGaWx0ZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBhY3RpdmV9XG4gICAgeyNpZiBjb21wb25lbnR9XG4gICAgICAgIHtAcmVuZGVyIGNvbXBvbmVudChhY3RpdmUpfVxuICAgIHs6ZWxzZSBpZiBVSUNvbXBvbmVudH1cbiAgICAgICAgPFVJQ29tcG9uZW50IHsuLi5hY3RpdmV9IC8+XG4gICAgey9pZn1cbns6ZWxzZSBpZiBVSVBsYWNlaG9sZGVyfVxuICAgIHsjaWYgcGxhY2Vob2xkZXJ9XG4gICAgICAgIHtAcmVuZGVyIHBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyUHJvcHMpfVxuICAgIHs6ZWxzZSBpZiBVSVBsYWNlaG9sZGVyfVxuICAgICAgICA8VUlQbGFjZWhvbGRlciB7Li4ucGxhY2Vob2xkZXJQcm9wc30gLz5cbiAgICB7L2lmfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuL3VpLnRhZy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkID0gXCJ0YWdnZWRWYWx1ZUlkXCJdIC0gaWYgd2Ugd2FudCB0byBhZGRyZXNzIHRoaXMgdGFnXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIFthY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW2FjdGlvbnNHcm91cENvbnRydWN0b3IgPSBVSUJ1dHRvbnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW2FjdGlvbnNHcm91cFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JlYWRvbmx5ID0gZmFsc2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJ0YWdnZWRWYWx1ZUlkXCIsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGFjdGlvbnNHcm91cENvbnRydWN0b3I6IEFjdGlvbnNHcm91cENvbnRydWN0b3IgPSBVSUJ1dHRvbnMsXG4gICAgICAgIGFjdGlvbnNHcm91cFByb3BzID0ge30sXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJ0YWdzIGhhcy1hZGRvbnMge2NsYXNzZXN9XCIge2lkfT5cbiAgICB7I2lmIHRpdGxlfTxVSVRhZyB7Li4udGl0bGV9IC8+ey9pZn1cbiAgICB7I2lmIHZhbHVlfTxVSVRhZyB7Li4udmFsdWV9IC8+ey9pZn1cbjwvZGl2PlxueyNpZiAhcmVhZG9ubHkgJiYgYWN0aW9ucyAmJiBhY3Rpb25zLmxlbmd0aH1cbiAgICA8QWN0aW9uc0dyb3VwQ29udHJ1Y3RvciB2YWx1ZXM9e2FjdGlvbnN9IHsuLi5hY3Rpb25zR3JvdXBQcm9wc30gLz5cbnsvaWZ9XG4iLCJpbXBvcnQgeyBlbmFibGVfbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4vaW5kZXguanMnO1xuXG5lbmFibGVfbGVnYWN5X21vZGVfZmxhZygpO1xuIiwiLypcbkFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2xcbkRpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9lYXNlcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4qL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyKHQpIHtcblx0cmV0dXJuIHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gMC41ICogKHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykpO1xuXHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrSW4odCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrT3V0KHQpIHtcblx0Y29uc3QgcyA9IDEuNzAxNTg7XG5cdHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcblx0Y29uc3QgYSA9IDQuMCAvIDExLjA7XG5cdGNvbnN0IGIgPSA4LjAgLyAxMS4wO1xuXHRjb25zdCBjID0gOS4wIC8gMTAuMDtcblx0Y29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcblx0Y29uc3QgY2IgPSAzNTQ0Mi4wIC8gMTgwNS4wO1xuXHRjb25zdCBjYyA9IDE2MDYxLjAgLyAxODA1LjA7XG5cdGNvbnN0IHQyID0gdCAqIHQ7XG5cdHJldHVybiB0IDwgYVxuXHRcdD8gNy41NjI1ICogdDJcblx0XHQ6IHQgPCBiXG5cdFx0XHQ/IDkuMDc1ICogdDIgLSA5LjkgKiB0ICsgMy40XG5cdFx0XHQ6IHQgPCBjXG5cdFx0XHRcdD8gY2EgKiB0MiAtIGNiICogdCArIGNjXG5cdFx0XHRcdDogMTAuOCAqIHQgKiB0IC0gMjAuNTIgKiB0ICsgMTAuNzI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gMC41ICogKDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0ICogMi4wKSkgOiAwLjUgKiBib3VuY2VPdXQodCAqIDIuMCAtIDEuMCkgKyAwLjU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VJbih0KSB7XG5cdHJldHVybiAxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW5PdXQodCkge1xuXHRpZiAoKHQgKj0gMikgPCAxKSByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY0luKHQpIHtcblx0cmV0dXJuIDEuMCAtIE1hdGguc3FydCgxLjAgLSB0ICogdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjT3V0KHQpIHtcblx0cmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyA0LjAgKiB0ICogdCAqIHQgOiAwLjUgKiBNYXRoLnBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3ViaWNJbih0KSB7XG5cdHJldHVybiB0ICogdCAqIHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY091dCh0KSB7XG5cdGNvbnN0IGYgPSB0IC0gMS4wO1xuXHRyZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjVcblx0XHQ/IDAuNSAqIE1hdGguc2luKCgoKzEzLjAgKiBNYXRoLlBJKSAvIDIpICogMi4wICogdCkgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAoMi4wICogdCAtIDEuMCkpXG5cdFx0OiAwLjUgKlxuXHRcdFx0XHRNYXRoLnNpbigoKC0xMy4wICogTWF0aC5QSSkgLyAyKSAqICgyLjAgKiB0IC0gMS4wICsgMS4wKSkgKlxuXHRcdFx0XHRNYXRoLnBvdygyLjAsIC0xMC4wICogKDIuMCAqIHQgLSAxLjApKSArXG5cdFx0XHRcdDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoMTMuMCAqIHQgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zaW4oKC0xMy4wICogKHQgKyAxLjApICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KSArIDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9Jbk91dCh0KSB7XG5cdHJldHVybiB0ID09PSAwLjAgfHwgdCA9PT0gMS4wXG5cdFx0PyB0XG5cdFx0OiB0IDwgMC41XG5cdFx0XHQ/ICswLjUgKiBNYXRoLnBvdygyLjAsIDIwLjAgKiB0IC0gMTAuMClcblx0XHRcdDogLTAuNSAqIE1hdGgucG93KDIuMCwgMTAuMCAtIHQgKiAyMC4wKSArIDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9Jbih0KSB7XG5cdHJldHVybiB0ID09PSAwLjAgPyB0IDogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cG9PdXQodCkge1xuXHRyZXR1cm4gdCA9PT0gMS4wID8gdCA6IDEuMCAtIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG5cdHQgLz0gMC41O1xuXHRpZiAodCA8IDEpIHJldHVybiAwLjUgKiB0ICogdDtcblx0dC0tO1xuXHRyZXR1cm4gLTAuNSAqICh0ICogKHQgLSAyKSAtIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEluKHQpIHtcblx0cmV0dXJuIHQgKiB0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZE91dCh0KSB7XG5cdHJldHVybiAtdCAqICh0IC0gMi4wKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0SW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/ICs4LjAgKiBNYXRoLnBvdyh0LCA0LjApIDogLTguMCAqIE1hdGgucG93KHQgLSAxLjAsIDQuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFydEluKHQpIHtcblx0cmV0dXJuIE1hdGgucG93KHQsIDQuMCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFydE91dCh0KSB7XG5cdHJldHVybiBNYXRoLnBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRJbk91dCh0KSB7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0ICogdDtcblx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50SW4odCkge1xuXHRyZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludE91dCh0KSB7XG5cdHJldHVybiAtLXQgKiB0ICogdCAqIHQgKiB0ICsgMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmVJbk91dCh0KSB7XG5cdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluKHQpIHtcblx0Y29uc3QgdiA9IE1hdGguY29zKHQgKiBNYXRoLlBJICogMC41KTtcblx0aWYgKE1hdGguYWJzKHYpIDwgMWUtMTQpIHJldHVybiAxO1xuXHRlbHNlIHJldHVybiAxIC0gdjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmVPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zaW4oKHQgKiBNYXRoLlBJKSAvIDIpO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBGbGlwUGFyYW1zLCBBbmltYXRpb25Db25maWcgfSBmcm9tICcuL3B1YmxpYy5qcycgKi9cbmltcG9ydCB7IGN1YmljT3V0IH0gZnJvbSAnLi4vZWFzaW5nL2luZGV4LmpzJztcblxuLyoqXG4gKiBUaGUgZmxpcCBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgYW5kIGFuaW1hdGVzIGJldHdlZW4gdGhlbSwgdHJhbnNsYXRpbmcgdGhlIHggYW5kIHkgdmFsdWVzLlxuICogYGZsaXBgIHN0YW5kcyBmb3IgW0ZpcnN0LCBMYXN0LCBJbnZlcnQsIFBsYXldKGh0dHBzOi8vYWVyb3R3aXN0LmNvbS9ibG9nL2ZsaXAteW91ci1hbmltYXRpb25zLykuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3sgZnJvbTogRE9NUmVjdDsgdG86IERPTVJlY3QgfX0gZnJvbVRvXG4gKiBAcGFyYW0ge0ZsaXBQYXJhbXN9IHBhcmFtc1xuICogQHJldHVybnMge0FuaW1hdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsaXAobm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMgPSB7fSkge1xuXHR2YXIgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gKGQpID0+IE1hdGguc3FydChkKSAqIDEyMCwgZWFzaW5nID0gY3ViaWNPdXQgfSA9IHBhcmFtcztcblxuXHR2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG5cdC8vIGZpbmQgdGhlIHRyYW5zZm9ybSBvcmlnaW4sIGV4cHJlc3NlZCBhcyBhIHBhaXIgb2YgdmFsdWVzIGJldHdlZW4gMCBhbmQgMVxuXHR2YXIgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0dmFyIFtveCwgb3ldID0gc3R5bGUudHJhbnNmb3JtT3JpZ2luLnNwbGl0KCcgJykubWFwKHBhcnNlRmxvYXQpO1xuXHRveCAvPSBub2RlLmNsaWVudFdpZHRoO1xuXHRveSAvPSBub2RlLmNsaWVudEhlaWdodDtcblxuXHQvLyBjYWxjdWxhdGUgZWZmZWN0IG9mIHBhcmVudCB0cmFuc2Zvcm1zIGFuZCB6b29tXG5cdHZhciB6b29tID0gZ2V0X3pvb20obm9kZSk7IC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtdmlld3BvcnQvI2VmZmVjdGl2ZS16b29tXG5cdHZhciBzeCA9IG5vZGUuY2xpZW50V2lkdGggLyB0by53aWR0aCAvIHpvb207XG5cdHZhciBzeSA9IG5vZGUuY2xpZW50SGVpZ2h0IC8gdG8uaGVpZ2h0IC8gem9vbTtcblxuXHQvLyBmaW5kIHRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgdHJhbnNmb3JtIG9yaWdpblxuXHR2YXIgZnggPSBmcm9tLmxlZnQgKyBmcm9tLndpZHRoICogb3g7XG5cdHZhciBmeSA9IGZyb20udG9wICsgZnJvbS5oZWlnaHQgKiBveTtcblxuXHQvLyBmaW5kIHRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSBvcmlnaW5cblx0dmFyIHR4ID0gdG8ubGVmdCArIHRvLndpZHRoICogb3g7XG5cdHZhciB0eSA9IHRvLnRvcCArIHRvLmhlaWdodCAqIG95O1xuXG5cdC8vIGZpbmQgdGhlIHRyYW5zbGF0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgdHJhbnNmb3JtXG5cdHZhciBkeCA9IChmeCAtIHR4KSAqIHN4O1xuXHR2YXIgZHkgPSAoZnkgLSB0eSkgKiBzeTtcblxuXHQvLyBmaW5kIHRoZSByZWxhdGl2ZSBzY2FsZSBhdCB0aGUgc3RhcnQgb2YgdGhlIHRyYW5zZm9ybVxuXHR2YXIgZHN4ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuXHR2YXIgZHN5ID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG5cblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbjogdHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nID8gZHVyYXRpb24oTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSkgOiBkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCwgdSkgPT4ge1xuXHRcdFx0dmFyIHggPSB1ICogZHg7XG5cdFx0XHR2YXIgeSA9IHUgKiBkeTtcblx0XHRcdHZhciBzeCA9IHQgKyB1ICogZHN4O1xuXHRcdFx0dmFyIHN5ID0gdCArIHUgKiBkc3k7XG5cblx0XHRcdHJldHVybiBgdHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KSBzY2FsZSgke3N4fSwgJHtzeX0pO2A7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRfem9vbShlbGVtZW50KSB7XG5cdGlmICgnY3VycmVudENTU1pvb20nIGluIGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbGVtZW50LmN1cnJlbnRDU1Nab29tKTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWxlbWVudCB8IG51bGx9ICovXG5cdHZhciBjdXJyZW50ID0gZWxlbWVudDtcblx0dmFyIHpvb20gPSAxO1xuXG5cdHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG5cdFx0em9vbSAqPSArZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50KS56b29tO1xuXHRcdGN1cnJlbnQgPSAvKiogQHR5cGUge0VsZW1lbnQgfCBudWxsfSAqLyAoY3VycmVudC5wYXJlbnRFbGVtZW50KTtcblx0fVxuXG5cdHJldHVybiB6b29tO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBCbHVyUGFyYW1zLCBDcm9zc2ZhZGVQYXJhbXMsIERyYXdQYXJhbXMsIEZhZGVQYXJhbXMsIEZseVBhcmFtcywgU2NhbGVQYXJhbXMsIFNsaWRlUGFyYW1zLCBUcmFuc2l0aW9uQ29uZmlnIH0gZnJvbSAnLi9wdWJsaWMnICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMnO1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHggKi9cbmNvbnN0IGxpbmVhciA9ICh4KSA9PiB4O1xuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHQgKi9cbmZ1bmN0aW9uIGN1YmljX291dCh0KSB7XG5cdGNvbnN0IGYgPSB0IC0gMS4wO1xuXHRyZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjdWJpY19pbl9vdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5mdW5jdGlvbiBzcGxpdF9jc3NfdW5pdCh2YWx1ZSkge1xuXHRjb25zdCBzcGxpdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL15cXHMqKC0/W1xcZC5dKykoW15cXHNdKilcXHMqJC8pO1xuXHRyZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogWy8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodmFsdWUpLCAncHgnXTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyBhIGBibHVyYCBmaWx0ZXIgYWxvbmdzaWRlIGFuIGVsZW1lbnQncyBvcGFjaXR5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtCbHVyUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHVyKFxuXHRub2RlLFxuXHR7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljX2luX291dCwgYW1vdW50ID0gNSwgb3BhY2l0eSA9IDAgfSA9IHt9XG4pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCBmID0gc3R5bGUuZmlsdGVyID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLmZpbHRlcjtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdGNvbnN0IFt2YWx1ZSwgdW5pdF0gPSBzcGxpdF9jc3NfdW5pdChhbW91bnQpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfdCwgdSkgPT4gYG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9OyBmaWx0ZXI6ICR7Zn0gYmx1cigke3UgKiB2YWx1ZX0ke3VuaXR9KTtgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudCBmcm9tIDAgdG8gdGhlIGN1cnJlbnQgb3BhY2l0eSBmb3IgYGluYCB0cmFuc2l0aW9ucyBhbmQgZnJvbSB0aGUgY3VycmVudCBvcGFjaXR5IHRvIDAgZm9yIGBvdXRgIHRyYW5zaXRpb25zLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtGYWRlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0gPSB7fSkge1xuXHRjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCkgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSB4IGFuZCB5IHBvc2l0aW9ucyBhbmQgdGhlIG9wYWNpdHkgb2YgYW4gZWxlbWVudC4gYGluYCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIHByb3ZpZGVkIHZhbHVlcywgcGFzc2VkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcy4gYG91dGAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBlbGVtZW50J3MgZGVmYXVsdCB2YWx1ZXMgdG8gdGhlIHByb3ZpZGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7Rmx5UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHkoXG5cdG5vZGUsXG5cdHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfb3V0LCB4ID0gMCwgeSA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdGNvbnN0IFt4X3ZhbHVlLCB4X3VuaXRdID0gc3BsaXRfY3NzX3VuaXQoeCk7XG5cdGNvbnN0IFt5X3ZhbHVlLCB5X3VuaXRdID0gc3BsaXRfY3NzX3VuaXQoeSk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKHQsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgkeygxIC0gdCkgKiB4X3ZhbHVlfSR7eF91bml0fSwgJHsoMSAtIHQpICogeV92YWx1ZX0ke3lfdW5pdH0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX1gXG5cdH07XG59XG5cbnZhciBzbGlkZV93YXJuaW5nID0gZmFsc2U7XG5cbi8qKlxuICogU2xpZGVzIGFuIGVsZW1lbnQgaW4gYW5kIG91dC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U2xpZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfb3V0LCBheGlzID0gJ3knIH0gPSB7fSkge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cblx0aWYgKERFViAmJiAhc2xpZGVfd2FybmluZyAmJiAvKGNvbnRlbnRzfGlubGluZXx0YWJsZSkvLnRlc3Qoc3R5bGUuZGlzcGxheSkpIHtcblx0XHRzbGlkZV93YXJuaW5nID0gdHJ1ZTtcblx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IChzbGlkZV93YXJuaW5nID0gZmFsc2UpKTtcblx0XHR3LnRyYW5zaXRpb25fc2xpZGVfZGlzcGxheShzdHlsZS5kaXNwbGF5KTtcblx0fVxuXG5cdGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eSA9IGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblx0Y29uc3QgcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbcHJpbWFyeV9wcm9wZXJ0eV0pO1xuXHRjb25zdCBzZWNvbmRhcnlfcHJvcGVydGllcyA9IGF4aXMgPT09ICd5JyA/IFsndG9wJywgJ2JvdHRvbSddIDogWydsZWZ0JywgJ3JpZ2h0J107XG5cdGNvbnN0IGNhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzID0gc2Vjb25kYXJ5X3Byb3BlcnRpZXMubWFwKFxuXHRcdChlKSA9PiAvKiogQHR5cGUgeydMZWZ0JyB8ICdSaWdodCcgfCAnVG9wJyB8ICdCb3R0b20nfSAqLyAoYCR7ZVswXS50b1VwcGVyQ2FzZSgpfSR7ZS5zbGljZSgxKX1gKVxuXHQpO1xuXHRjb25zdCBwYWRkaW5nX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuXHRjb25zdCBwYWRkaW5nX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYHBhZGRpbmcke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfWBdKTtcblx0Y29uc3QgbWFyZ2luX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgbWFyZ2luJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG5cdGNvbnN0IG1hcmdpbl9lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BtYXJnaW4ke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfWBdKTtcblx0Y29uc3QgYm9yZGVyX3dpZHRoX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChcblx0XHRzdHlsZVtgYm9yZGVyJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1XaWR0aGBdXG5cdCk7XG5cdGNvbnN0IGJvcmRlcl93aWR0aF9lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KFxuXHRcdHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfVdpZHRoYF1cblx0KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCkgPT5cblx0XHRcdCdvdmVyZmxvdzogaGlkZGVuOycgK1xuXHRcdFx0YG9wYWNpdHk6ICR7TWF0aC5taW4odCAqIDIwLCAxKSAqIG9wYWNpdHl9O2AgK1xuXHRcdFx0YCR7cHJpbWFyeV9wcm9wZXJ0eX06ICR7dCAqIHByaW1hcnlfcHJvcGVydHlfdmFsdWV9cHg7YCArXG5cdFx0XHRgcGFkZGluZy0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfTogJHt0ICogcGFkZGluZ19zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBwYWRkaW5nLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19OiAke3QgKiBwYWRkaW5nX2VuZF92YWx1ZX1weDtgICtcblx0XHRcdGBtYXJnaW4tJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX06ICR7dCAqIG1hcmdpbl9zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBtYXJnaW4tJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX06ICR7dCAqIG1hcmdpbl9lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgYm9yZGVyLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19LXdpZHRoOiAke3QgKiBib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWV9cHg7YCArXG5cdFx0XHRgYm9yZGVyLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19LXdpZHRoOiAke3QgKiBib3JkZXJfd2lkdGhfZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1pbi0ke3ByaW1hcnlfcHJvcGVydHl9OiAwYFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBvcGFjaXR5IGFuZCBzY2FsZSBvZiBhbiBlbGVtZW50LiBgaW5gIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWVzLCBwYXNzZWQgYXMgcGFyYW1ldGVycywgdG8gYW4gZWxlbWVudCdzIGN1cnJlbnQgKGRlZmF1bHQpIHZhbHVlcy4gYG91dGAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIGFuIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcyB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtTY2FsZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoXG5cdG5vZGUsXG5cdHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfb3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fVxuKSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0Y29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcblx0Y29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG5cdGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfdCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHsxIC0gc2QgKiB1fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fVxuXHRcdGBcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgc3Ryb2tlIG9mIGFuIFNWRyBlbGVtZW50LCBsaWtlIGEgc25ha2UgaW4gYSB0dWJlLiBgaW5gIHRyYW5zaXRpb25zIGJlZ2luIHdpdGggdGhlIHBhdGggaW52aXNpYmxlIGFuZCBkcmF3IHRoZSBwYXRoIHRvIHRoZSBzY3JlZW4gb3ZlciB0aW1lLiBgb3V0YCB0cmFuc2l0aW9ucyBzdGFydCBpbiBhIHZpc2libGUgc3RhdGUgYW5kIGdyYWR1YWxseSBlcmFzZSB0aGUgcGF0aC4gYGRyYXdgIG9ubHkgd29ya3Mgd2l0aCBlbGVtZW50cyB0aGF0IGhhdmUgYSBgZ2V0VG90YWxMZW5ndGhgIG1ldGhvZCwgbGlrZSBgPHBhdGg+YCBhbmQgYDxwb2x5bGluZT5gLlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudCAmIHsgZ2V0VG90YWxMZW5ndGgoKTogbnVtYmVyIH19IG5vZGVcbiAqIEBwYXJhbSB7RHJhd1BhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY19pbl9vdXQgfSA9IHt9KSB7XG5cdGxldCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKHN0eWxlLnN0cm9rZUxpbmVjYXAgIT09ICdidXR0Jykge1xuXHRcdGxlbiArPSBwYXJzZUludChzdHlsZS5zdHJva2VXaWR0aCk7XG5cdH1cblx0aWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZHVyYXRpb24gPSA4MDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGR1cmF0aW9uID0gbGVuIC8gc3BlZWQ7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGR1cmF0aW9uID0gZHVyYXRpb24obGVuKTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6IChfLCB1KSA9PiBgXG5cdFx0XHRzdHJva2UtZGFzaGFycmF5OiAke2xlbn07XG5cdFx0XHRzdHJva2UtZGFzaG9mZnNldDogJHt1ICogbGVufTtcblx0XHRgXG5cdH07XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge1R9IHRhclxuICogQHBhcmFtIHtTfSBzcmNcbiAqIEByZXR1cm5zIHtUICYgU31cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Zm9yIChjb25zdCBrIGluIHNyYykgdGFyW2tdID0gc3JjW2tdO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUICYgU30gKi8gKHRhcik7XG59XG5cbi8qKlxuICogVGhlIGBjcm9zc2ZhZGVgIGZ1bmN0aW9uIGNyZWF0ZXMgYSBwYWlyIG9mIFt0cmFuc2l0aW9uc10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3RyYW5zaXRpb24pIGNhbGxlZCBgc2VuZGAgYW5kIGByZWNlaXZlYC4gV2hlbiBhbiBlbGVtZW50IGlzICdzZW50JywgaXQgbG9va3MgZm9yIGEgY29ycmVzcG9uZGluZyBlbGVtZW50IGJlaW5nICdyZWNlaXZlZCcsIGFuZCBnZW5lcmF0ZXMgYSB0cmFuc2l0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgZWxlbWVudCB0byBpdHMgY291bnRlcnBhcnQncyBwb3NpdGlvbiBhbmQgZmFkZXMgaXQgb3V0LiBXaGVuIGFuIGVsZW1lbnQgaXMgJ3JlY2VpdmVkJywgdGhlIHJldmVyc2UgaGFwcGVucy4gSWYgdGhlcmUgaXMgbm8gY291bnRlcnBhcnQsIHRoZSBgZmFsbGJhY2tgIHRyYW5zaXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge0Nyb3NzZmFkZVBhcmFtcyAmIHtcbiAqIFx0ZmFsbGJhY2s/OiAobm9kZTogRWxlbWVudCwgcGFyYW1zOiBDcm9zc2ZhZGVQYXJhbXMsIGludHJvOiBib29sZWFuKSA9PiBUcmFuc2l0aW9uQ29uZmlnO1xuICogfX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7Wyhub2RlOiBhbnksIHBhcmFtczogQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gVHJhbnNpdGlvbkNvbmZpZywgKG5vZGU6IGFueSwgcGFyYW1zOiBDcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBUcmFuc2l0aW9uQ29uZmlnXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzZmFkZSh7IGZhbGxiYWNrLCAuLi5kZWZhdWx0cyB9KSB7XG5cdC8qKiBAdHlwZSB7TWFwPGFueSwgRWxlbWVudD59ICovXG5cdGNvbnN0IHRvX3JlY2VpdmUgPSBuZXcgTWFwKCk7XG5cdC8qKiBAdHlwZSB7TWFwPGFueSwgRWxlbWVudD59ICovXG5cdGNvbnN0IHRvX3NlbmQgPSBuZXcgTWFwKCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbV9ub2RlXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuXHQgKiBAcGFyYW0ge0Nyb3NzZmFkZVBhcmFtc30gcGFyYW1zXG5cdCAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuXHQgKi9cblx0ZnVuY3Rpb24gY3Jvc3NmYWRlKGZyb21fbm9kZSwgbm9kZSwgcGFyYW1zKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0ZGVsYXkgPSAwLFxuXHRcdFx0ZHVyYXRpb24gPSAvKiogQHBhcmFtIHtudW1iZXJ9IGQgKi8gKGQpID0+IE1hdGguc3FydChkKSAqIDMwLFxuXHRcdFx0ZWFzaW5nID0gY3ViaWNfb3V0XG5cdFx0fSA9IGFzc2lnbihhc3NpZ24oe30sIGRlZmF1bHRzKSwgcGFyYW1zKTtcblx0XHRjb25zdCBmcm9tID0gZnJvbV9ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRjb25zdCBkeCA9IGZyb20ubGVmdCAtIHRvLmxlZnQ7XG5cdFx0Y29uc3QgZHkgPSBmcm9tLnRvcCAtIHRvLnRvcDtcblx0XHRjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcblx0XHRjb25zdCBkaCA9IGZyb20uaGVpZ2h0IC8gdG8uaGVpZ2h0O1xuXHRcdGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRcdGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGVsYXksXG5cdFx0XHRkdXJhdGlvbjogdHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcblx0XHRcdGVhc2luZyxcblx0XHRcdGNzczogKHQsIHUpID0+IGBcblx0XHRcdCAgIG9wYWNpdHk6ICR7dCAqIG9wYWNpdHl9O1xuXHRcdFx0ICAgdHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7XG5cdFx0XHQgICB0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7XG5cdFx0XHRcdFx0XHR0ICsgKDEgLSB0KSAqIGRoXG5cdFx0XHRcdFx0fSk7XG5cdFx0ICAgYFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNYXA8YW55LCBFbGVtZW50Pn0gaXRlbXNcblx0ICogQHBhcmFtIHtNYXA8YW55LCBFbGVtZW50Pn0gY291bnRlcnBhcnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50cm9cblx0ICogQHJldHVybnMgeyhub2RlOiBhbnksIHBhcmFtczogQ3Jvc3NmYWRlUGFyYW1zICYgeyBrZXk6IGFueTsgfSkgPT4gKCkgPT4gVHJhbnNpdGlvbkNvbmZpZ31cblx0ICovXG5cdGZ1bmN0aW9uIHRyYW5zaXRpb24oaXRlbXMsIGNvdW50ZXJwYXJ0cywgaW50cm8pIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gaW1wcm92ZSB0eXBpbmdzIChhcmUgdGhlIHB1YmxpYyB0eXBlcyB3cm9uZz8pXG5cdFx0cmV0dXJuIChub2RlLCBwYXJhbXMpID0+IHtcblx0XHRcdGl0ZW1zLnNldChwYXJhbXMua2V5LCBub2RlKTtcblx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdGlmIChjb3VudGVycGFydHMuaGFzKHBhcmFtcy5rZXkpKSB7XG5cdFx0XHRcdFx0Y29uc3Qgb3RoZXJfbm9kZSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG5cdFx0XHRcdFx0Y291bnRlcnBhcnRzLmRlbGV0ZShwYXJhbXMua2V5KTtcblx0XHRcdFx0XHRyZXR1cm4gY3Jvc3NmYWRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG90aGVyX25vZGUpLCBub2RlLCBwYXJhbXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBub2RlIGlzIGRpc2FwcGVhcmluZyBhbHRvZ2V0aGVyXG5cdFx0XHRcdC8vIChpLmUuIHdhc24ndCBjbGFpbWVkIGJ5IHRoZSBvdGhlciBsaXN0KVxuXHRcdFx0XHQvLyB0aGVuIHdlIG5lZWQgdG8gc3VwcGx5IGFuIG91dHJvXG5cdFx0XHRcdGl0ZW1zLmRlbGV0ZShwYXJhbXMua2V5KTtcblx0XHRcdFx0cmV0dXJuIGZhbGxiYWNrICYmIGZhbGxiYWNrKG5vZGUsIHBhcmFtcywgaW50cm8pO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBbdHJhbnNpdGlvbih0b19zZW5kLCB0b19yZWNlaXZlLCBmYWxzZSksIHRyYW5zaXRpb24odG9fcmVjZWl2ZSwgdG9fc2VuZCwgdHJ1ZSldO1xufVxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZmxpcCB9IGZyb20gXCJzdmVsdGUvYW5pbWF0ZVwiXG4gIGltcG9ydCB7IGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIlxuICBpbXBvcnQge2FmdGVyVXBkYXRlfSBmcm9tICdzdmVsdGUnXG5cbiAgLy8gdGhlIGxpc3Qgb2YgaXRlbXMgIHRoZSB1c2VyIGNhbiBzZWxlY3QgZnJvbVxuICBleHBvcnQgbGV0IGl0ZW1zID0gW11cblxuICAvKipcbiAgICogZnVuY3Rpb24gdG8gdXNlIHRvIGdldCBhbGwgaXRlbXMgKGFsdGVybmF0aXZlIHRvIHByb3ZpZGluZyBpdGVtcylcbiAgICogQHR5cGUge2Jvb2xlYW58ZnVuY3Rpb259XG4gICAqL1xuICBleHBvcnQgbGV0IHNlYXJjaEZ1bmN0aW9uID0gZmFsc2VcblxuICAvLyBmaWVsZCBvZiBlYWNoIGl0ZW0gdGhhdCdzIHVzZWQgZm9yIHRoZSBsYWJlbHMgaW4gdGhlIGxpc3RcbiAgZXhwb3J0IGxldCBsYWJlbEZpZWxkTmFtZSA9IHVuZGVmaW5lZFxuICBleHBvcnQgbGV0IGtleXdvcmRzRmllbGROYW1lID0gbGFiZWxGaWVsZE5hbWVcbiAgZXhwb3J0IGxldCB2YWx1ZUZpZWxkTmFtZSA9IHVuZGVmaW5lZFxuXG4gIGV4cG9ydCBsZXQgbGFiZWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgICByZXR1cm4gbGFiZWxGaWVsZE5hbWUgPyBpdGVtW2xhYmVsRmllbGROYW1lXSA6IGl0ZW1cbiAgfVxuXG4gIGV4cG9ydCBsZXQga2V5d29yZHNGdW5jdGlvbiA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgICByZXR1cm4ga2V5d29yZHNGaWVsZE5hbWUgPyBpdGVtW2tleXdvcmRzRmllbGROYW1lXSA6IGxhYmVsRnVuY3Rpb24oaXRlbSlcbiAgfVxuXG4gIGV4cG9ydCBsZXQgdmFsdWVGdW5jdGlvbiA9IGZ1bmN0aW9uIChpdGVtLCBmb3JjZVNpbmdsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXRlbVxuICAgIH1cbiAgICBpZiAoIW11bHRpcGxlIHx8IGZvcmNlU2luZ2xlKSB7XG4gICAgICByZXR1cm4gdmFsdWVGaWVsZE5hbWUgPyBpdGVtW3ZhbHVlRmllbGROYW1lXSA6IGl0ZW1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGl0ZW0ubWFwKChpKSA9PiAodmFsdWVGaWVsZE5hbWUgPyBpW3ZhbHVlRmllbGROYW1lXSA6IGkpKVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBsZXQga2V5d29yZHNDbGVhbkZ1bmN0aW9uID0gZnVuY3Rpb24gKGtleXdvcmRzKSB7XG4gICAgcmV0dXJuIGtleXdvcmRzXG4gIH1cblxuICBleHBvcnQgbGV0IHRleHRDbGVhbkZ1bmN0aW9uID0gZnVuY3Rpb24gKHVzZXJFbnRlcmVkVGV4dCkge1xuICAgIHJldHVybiB1c2VyRW50ZXJlZFRleHRcbiAgfVxuXG4gIC8vIGV2ZW50c1xuICBleHBvcnQgbGV0IGJlZm9yZUNoYW5nZSA9IGZ1bmN0aW9uIChvbGRTZWxlY3RlZEl0ZW0sIG5ld1NlbGVjdGVkSXRlbSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgZXhwb3J0IGxldCBvbkNoYW5nZSA9IGZ1bmN0aW9uIChuZXdTZWxlY3RlZEl0ZW0pIHt9XG4gIGV4cG9ydCBsZXQgb25Gb2N1cyA9IGZ1bmN0aW9uICgpIHt9XG4gIGV4cG9ydCBsZXQgb25CbHVyID0gZnVuY3Rpb24gKCkge31cbiAgZXhwb3J0IGxldCBvbkNyZWF0ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uQ3JlYXRlOiBcIiArIHRleHQpXG4gICAgfVxuICB9XG5cbiAgLy8gQmVoYXZpb3VyIHByb3BlcnRpZXNcbiAgZXhwb3J0IGxldCBzZWxlY3RGaXJzdElmRW1wdHkgPSBmYWxzZVxuICBleHBvcnQgbGV0IG1pbkNoYXJhY3RlcnNUb1NlYXJjaCA9IDFcbiAgZXhwb3J0IGxldCBtYXhJdGVtc1RvU2hvd0luTGlzdCA9IDBcbiAgZXhwb3J0IGxldCBtdWx0aXBsZSA9IGZhbHNlXG4gIGV4cG9ydCBsZXQgY3JlYXRlID0gZmFsc2VcblxuICAvLyBpZ25vcmVzIHRoZSBhY2NlbnRzIHdoZW4gbWF0Y2hpbmcgaXRlbXNcbiAgZXhwb3J0IGxldCBpZ25vcmVBY2NlbnRzID0gdHJ1ZVxuXG4gIC8vIGFsbCB0aGUgaW5wdXQga2V5d29yZHMgc2hvdWxkIGJlIG1hdGNoZWQgaW4gdGhlIGl0ZW0ga2V5d29yZHNcbiAgZXhwb3J0IGxldCBtYXRjaEFsbEtleXdvcmRzID0gdHJ1ZVxuXG4gIC8vIHNvcnRzIHRoZSBpdGVtcyBieSB0aGUgbnVtYmVyIG9mIG1hdGNoaW5rIGtleXdvcmRzXG4gIGV4cG9ydCBsZXQgc29ydEJ5TWF0Y2hlZEtleXdvcmRzID0gZmFsc2VcblxuICAvLyBhbGxvdyB1c2VycyB0byB1c2UgYSBjdXN0b20gaXRlbSBmaWx0ZXIgZnVuY3Rpb25cbiAgZXhwb3J0IGxldCBpdGVtRmlsdGVyRnVuY3Rpb24gPSB1bmRlZmluZWRcblxuICAvLyBhbGxvdyB1c2VycyB0byB1c2UgYSBjdXN0b20gaXRlbSBzb3J0IGZ1bmN0aW9uXG4gIGV4cG9ydCBsZXQgaXRlbVNvcnRGdW5jdGlvbiA9IHVuZGVmaW5lZFxuXG4gIC8vIGRvIG5vdCBhbGxvdyByZS1zZWxlY3Rpb24gYWZ0ZXIgaW5pdGlhbCBzZWxlY3Rpb25cbiAgZXhwb3J0IGxldCBsb2NrID0gZmFsc2VcblxuICAvLyBkZWxheSB0byB3YWl0IGFmdGVyIGEga2V5cHJlc3MgdG8gc2VhcmNoIGZvciBuZXcgaXRlbXNcbiAgZXhwb3J0IGxldCBkZWxheSA9IDBcblxuICAvLyB0cnVlIHRvIHBlcmZvcm0gbG9jYWwgZmlsdGVyaW5nIG9mIGl0ZW1zLCBldmVuIGlmIHNlYXJjaEZ1bmN0aW9uIGlzIHByb3ZpZGVkXG4gIGV4cG9ydCBsZXQgbG9jYWxGaWx0ZXJpbmcgPSB0cnVlXG5cbiAgLy8gdHJ1ZSB0byBwZXJmb3JtIGxvY2FsIHNvcnR5aW5nIG9mIGl0ZW1zXG4gIGV4cG9ydCBsZXQgbG9jYWxTb3J0aW5nID0gdHJ1ZVxuXG4gIC8vIHRydWUgdG8gY2xlYW4gdGhlIHVzZXIgZW50ZXJlZCB0ZXh0IChyZW1vdmVzIHNwYWNlcylcbiAgZXhwb3J0IGxldCBjbGVhblVzZXJUZXh0ID0gdHJ1ZVxuXG4gIC8vIHRydWUgdG8gbG93ZXJjYXNlIHRoZSBrZXl3b3JkcyBkZXJpdmVkIGZyb20gZWFjaCBpdGVtIChsb3dlcmNhc2UpXG4gIGV4cG9ydCBsZXQgbG93ZXJjYXNlS2V5d29yZHMgPSB0cnVlXG5cbiAgLy8gdHJ1ZSB0byBjbG9zZSB0aGUgZHJvcGRvd24gd2hlbiB0aGUgY29tcG9uZW50IGxvc2VzIGZvY3VzXG4gIGV4cG9ydCBsZXQgY2xvc2VPbkJsdXIgPSBmYWxzZVxuXG4gIC8vIHRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIHJlb3JkZXJpbmcgYnkgZHJhZyBhbmQgZHJvcCwgbmVlZHMgbXVsdGlwbGUgdG8gdHJ1ZVxuICBleHBvcnQgbGV0IG9yZGVyYWJsZVNlbGVjdGlvbiA9IGZhbHNlXG5cbiAgLy8gVUkgcHJvcGVydGllc1xuXG4gIC8vIG9wdGlvbiB0byBoaWRlIHRoZSBkcm9wZG93biBhcnJvd1xuICBleHBvcnQgbGV0IGhpZGVBcnJvdyA9IGZhbHNlXG5cbiAgLy8gb3B0aW9uIHRvIHNob3cgY2xlYXIgc2VsZWN0aW9uIGJ1dHRvblxuICBleHBvcnQgbGV0IHNob3dDbGVhciA9IGZhbHNlXG5cbiAgLy8gdGV4dCB0byB1c2UgZm9yIGNsZWFyXG4gIGV4cG9ydCBsZXQgY2xlYXJUZXh0ID0gXCImIzEwMDA2O1wiXG5cbiAgLy8gb3B0aW9uIHRvIHNob3cgbG9hZGluZyBpbmRpY2F0b3Igd2hlbiB0aGUgYXN5bmMgZnVuY3Rpb24gaXMgZXhlY3V0ZWRcbiAgZXhwb3J0IGxldCBzaG93TG9hZGluZ0luZGljYXRvciA9IGZhbHNlXG5cbiAgLy8gdGV4dCBkaXNwbGF5ZWQgd2hlbiBubyBpdGVtcyBtYXRjaCB0aGUgaW5wdXQgdGV4dFxuICBleHBvcnQgbGV0IG5vUmVzdWx0c1RleHQgPSBcIk5vIHJlc3VsdHMgZm91bmRcIlxuXG4gIC8vIHRleHQgZGlzcGxheWVkIHdoZW4gYXN5bmMgZGF0YSBpcyBiZWluZyBsb2FkZWRcbiAgZXhwb3J0IGxldCBsb2FkaW5nVGV4dCA9IFwiTG9hZGluZyByZXN1bHRzLi4uXCJcblxuICAvLyB0ZXh0IGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIHRleHQgbWF0Y2hlcyBhIGxvdCBvZiBpdGVtcyBhbmQgd2UgY2FuIG5vdCBkaXNwbGF5IHRoZW0gYWxsIGluIHRoZSBkcm9wZG93blxuICBleHBvcnQgbGV0IG1vcmVJdGVtc1RleHQgPSBcIml0ZW1zIG5vdCBzaG93blwiXG5cbiAgLy8gdGV4dCBkaXNwbGF5ZWQgd2hlbiBhc3luYyBkYXRhIGlzIGJlaW5nIGxvYWRlZFxuICBleHBvcnQgbGV0IGNyZWF0ZVRleHQgPSBcIk5vdCBmb3VuZCwgYWRkIGFueXdheT9cIlxuXG4gIC8vIHRoZSB0ZXh0IGRpc3BsYXllZCB3aGVuIG5vIG9wdGlvbiBpcyBzZWxlY3RlZFxuICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gdW5kZWZpbmVkXG5cbiAgLy8gYXBwbHkgYSBjbGFzc05hbWUgdG8gdGhlIGNvbnRyb2xcbiAgZXhwb3J0IGxldCBjbGFzc05hbWUgPSB1bmRlZmluZWRcblxuICAvLyBIVE1MIGlucHV0IFVJIHByb3BlcnRpZXNcbiAgLy8gYXBwbHkgYSBjbGFzc05hbWUgdG8gdGhlIGlucHV0IGNvbnRyb2xcbiAgZXhwb3J0IGxldCBpbnB1dENsYXNzTmFtZSA9IHVuZGVmaW5lZFxuICAvLyBhcHBseSBhIGlkIHRvIHRoZSBpbnB1dCBjb250cm9sXG4gIGV4cG9ydCBsZXQgaW5wdXRJZCA9IHVuZGVmaW5lZFxuICAvLyBnZW5lcmF0ZSBhbiBIVE1MIGlucHV0IHdpdGggdGhpcyBuYW1lXG4gIGV4cG9ydCBsZXQgbmFtZSA9IHVuZGVmaW5lZFxuICAvLyBnZW5lcmF0ZSBhIDxzZWxlY3Q+IHRhZyB0aGF0IGhvbGRzIHRoZSB2YWx1ZVxuICBleHBvcnQgbGV0IHNlbGVjdE5hbWUgPSB1bmRlZmluZWRcbiAgLy8gYXBwbHkgYSBpZCB0byB0aGUgPHNlbGVjdD5cbiAgZXhwb3J0IGxldCBzZWxlY3RJZCA9IHVuZGVmaW5lZFxuICAvLyBhZGQgdGhlIHRpdGxlIHRvIHRoZSBIVE1MIGlucHV0XG4gIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgLy8gZW5hYmxlIHRoZSBodG1sNSBhdXRvY29tcGxldGlvbiB0byB0aGUgSFRNTCBpbnB1dFxuICBleHBvcnQgbGV0IGh0bWw1YXV0b2NvbXBsZXRlID0gdW5kZWZpbmVkXG4gIC8vIGVuYWJsZSB0aGUgaHRtbDUgYXV0b2NvbXBsZXRpb24gdmFsdWVcbiAgZXhwb3J0IGxldCBhdXRvY29tcGxldGVPZmZWYWx1ZSA9IFwib2ZmXCJcbiAgLy8gbWFrZSB0aGUgaW5wdXQgcmVhZG9ubHlcbiAgZXhwb3J0IGxldCByZWFkb25seSA9IHVuZGVmaW5lZFxuICAvLyBhcHBseSBhIGNsYXNzTmFtZSB0byB0aGUgZHJvcGRvd24gZGl2XG4gIGV4cG9ydCBsZXQgZHJvcGRvd25DbGFzc05hbWUgPSB1bmRlZmluZWRcbiAgLy8gYWRkcyB0aGUgZGlzYWJsZWQgdGFnIHRvIHRoZSBIVE1MIGlucHV0XG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAvLyByZW1vdmUgdGhlIGF1dG9jb21wbGV0ZS1pbnB1dCBjbGFzcyBvZiB0aGUgaW5wdXRcbiAgZXhwb3J0IGxldCBub0lucHV0U3R5bGVzID0gZmFsc2VcbiAgLy8gYWRkcyB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIHRvIHRoZSBIVE1MIGlucHV0XG4gIGV4cG9ydCBsZXQgcmVxdWlyZWQgPSBudWxsXG5cbiAgZXhwb3J0IGxldCBkZWJ1ZyA9IGZhbHNlXG5cbiAgLy8gYWRkIHRhYmluZGV4IHN1cHBvcnQgZm9yIHRoZSBpbnB1dFxuICAvLyBzZXQgc3RhbmRhcmQgdG8gMDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9HbG9iYWxfYXR0cmlidXRlcy90YWJpbmRleFxuICBleHBvcnQgbGV0IHRhYmluZGV4ID0gMFxuXG4gIC8vIC0tLSBQdWJsaWMgU3RhdGUgLS0tLVxuXG4gIC8vIHNlbGVjdGVkIGl0ZW0gc3RhdGVcbiAgZXhwb3J0IGxldCBzZWxlY3RlZEl0ZW0gPSBtdWx0aXBsZSA/IFtdIDogdW5kZWZpbmVkXG4gIGV4cG9ydCBsZXQgdmFsdWUgPSB1bmRlZmluZWRcbiAgZXhwb3J0IGxldCBoaWdobGlnaHRlZEl0ZW0gPSB1bmRlZmluZWRcblxuICAvLyAtLS0gSW50ZXJuYWwgU3RhdGUgLS0tLVxuICBjb25zdCB1bmlxdWVJZCA9IFwic2F1dG9jb21wbGV0ZS1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApXG5cbiAgLy8gSFRNTCBlbGVtZW50c1xuICBsZXQgaW5wdXRcbiAgbGV0IGxpc3RcbiAgbGV0IGlucHV0Q29udGFpbmVyXG5cbiAgLy8gVUkgc3RhdGVcbiAgbGV0IG9wZW5lZCA9IGZhbHNlXG4gIGxldCBsb2FkaW5nID0gZmFsc2VcbiAgbGV0IGhpZ2hsaWdodEluZGV4ID0gLTFcbiAgZXhwb3J0IGxldCB0ZXh0ID0gdW5kZWZpbmVkXG4gIGxldCBmaWx0ZXJlZFRleHRMZW5ndGggPSAwXG5cbiAgLy8gdmlldyBtb2RlbFxuICBsZXQgZmlsdGVyZWRMaXN0SXRlbXNcbiAgbGV0IGxpc3RJdGVtcyA9IFtdXG5cbiAgLy8gcmVxdWVzdHMvcmVzcG9uc2VzIGNvdW50ZXJzXG4gIGxldCBsYXN0UmVxdWVzdElkID0gMFxuICBsZXQgbGFzdFJlc3BvbnNlSWQgPSAwXG5cbiAgLy8gb3RoZXIgc3RhdGVcbiAgbGV0IGlucHV0RGVsYXlUaW1lb3V0XG5cbiAgbGV0IHNldFBvc2l0aW9uT25OZXh0VXBkYXRlID0gZmFsc2U7XG5cbiAgLy8gLS0tIExpZmVjeWNsZSBldmVudHMgLS0tXG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmKHNldFBvc2l0aW9uT25OZXh0VXBkYXRlKSB7XG4gICAgICBzZXRTY3JvbGxBd2FyZUxpc3RQb3NpdGlvbigpXG4gICAgfVxuICAgIHNldFBvc2l0aW9uT25OZXh0VXBkYXRlID0gZmFsc2VcbiAgfSlcblxuICAvLyAtLS0gRnVuY3Rpb25zIC0tLVxuXG4gIGZ1bmN0aW9uIHNhZmVGdW5jdGlvbih0aGVGdW5jdGlvbiwgYXJndW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIHRoZUZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb3QgYSBmdW5jdGlvbjogXCIgKyB0aGVGdW5jdGlvbiArIFwiLCBhcmd1bWVudDogXCIgKyBhcmd1bWVudClcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgbGV0IHJlc3VsdFxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGVGdW5jdGlvbihhcmd1bWVudClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIkVycm9yIGV4ZWN1dGluZyBBdXRvY29tcGxldGUgZnVuY3Rpb24gb24gdmFsdWU6IFwiICsgYXJndW1lbnQgKyBcIiBmdW5jdGlvbjogXCIgKyB0aGVGdW5jdGlvblxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlU3RyaW5nRnVuY3Rpb24odGhlRnVuY3Rpb24sIGFyZ3VtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IHNhZmVGdW5jdGlvbih0aGVGdW5jdGlvbiwgYXJndW1lbnQpXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gXCJcIlxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvU3RyaW5nKClcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZUxhYmVsRnVuY3Rpb24oaXRlbSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwibGFiZWxGdW5jdGlvbjogXCIgKyBsYWJlbEZ1bmN0aW9uKTtcbiAgICAvLyBjb25zb2xlLmxvZyhcInNhZmVMYWJlbEZ1bmN0aW9uLCBpdGVtOiBcIiArIGl0ZW0pO1xuICAgIHJldHVybiBzYWZlU3RyaW5nRnVuY3Rpb24obGFiZWxGdW5jdGlvbiwgaXRlbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVLZXl3b3Jkc0Z1bmN0aW9uKGl0ZW0pIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcInNhZmVLZXl3b3Jkc0Z1bmN0aW9uXCIpO1xuICAgIGNvbnN0IGtleXdvcmRzID0gc2FmZVN0cmluZ0Z1bmN0aW9uKGtleXdvcmRzRnVuY3Rpb24sIGl0ZW0pXG4gICAgbGV0IHJlc3VsdCA9IHNhZmVTdHJpbmdGdW5jdGlvbihrZXl3b3Jkc0NsZWFuRnVuY3Rpb24sIGtleXdvcmRzKVxuICAgIHJlc3VsdCA9IGxvd2VyY2FzZUtleXdvcmRzID8gcmVzdWx0LnRvTG93ZXJDYXNlKCkudHJpbSgpIDogcmVzdWx0XG4gICAgaWYgKGlnbm9yZUFjY2VudHMpIHtcbiAgICAgIHJlc3VsdCA9IHJlbW92ZUFjY2VudHMocmVzdWx0KVxuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJFeHRyYWN0ZWQga2V5d29yZHM6ICdcIiArIHJlc3VsdCArIFwiJyBmcm9tIGl0ZW06IFwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVMaXN0SXRlbXMoKSB7XG4gICAgbGV0IHRpbWVySWRcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIHRpbWVySWQgPSBgQXV0b2NvbXBsZXRlIHByZXBhcmUgbGlzdCAke2lucHV0SWQgPyBgKGlkOiAke2lucHV0SWR9KWAgOiBcIlwifWBcbiAgICAgIGNvbnNvbGUudGltZSh0aW1lcklkKVxuICAgICAgY29uc29sZS5sb2coXCJQcmVwYXJlIGl0ZW1zIHRvIHNlYXJjaFwiKVxuICAgICAgY29uc29sZS5sb2coXCJpdGVtczogXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtcykpXG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiQXV0b2NvbXBsZXRlIGl0ZW1zIC8gc2VhcmNoIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGFycmF5IGJ1dFwiLCBpdGVtcylcbiAgICAgIGl0ZW1zID0gW11cbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCA6IDBcbiAgICBsaXN0SXRlbXMgPSBuZXcgQXJyYXkobGVuZ3RoKVxuXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSBnZXRMaXN0SXRlbShpdGVtKVxuICAgICAgICBpZiAobGlzdEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5kZWZpbmVkIGl0ZW0gZm9yOiBcIiwgaXRlbSlcbiAgICAgICAgfVxuICAgICAgICBsaXN0SXRlbXNbaV0gPSBsaXN0SXRlbVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhsaXN0SXRlbXMubGVuZ3RoICsgXCIgaXRlbXMgdG8gc2VhcmNoXCIpXG4gICAgICBjb25zb2xlLnRpbWVFbmQodGltZXJJZClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaXN0SXRlbShpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGtleXdvcmRzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpdGVtXG4gICAgICBrZXl3b3JkczogbG9jYWxGaWx0ZXJpbmcgPyBzYWZlS2V5d29yZHNGdW5jdGlvbihpdGVtKSA6IFtdLFxuICAgICAgLy8gaXRlbSBsYWJlbFxuICAgICAgbGFiZWw6IHNhZmVMYWJlbEZ1bmN0aW9uKGl0ZW0pLFxuICAgICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaWFsIGl0ZW1cbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgfVxuICB9XG5cbiAgLy8gLS0gUmVhY3Rpdml0eSAtLVxuICAkOiBpdGVtcywgc2VhcmNoRnVuY3Rpb24gfHwgcHJlcGFyZUxpc3RJdGVtcygpXG5cbiAgZnVuY3Rpb24gb25TZWxlY3RlZEl0ZW1DaGFuZ2VkKCkge1xuICAgIHZhbHVlID0gdmFsdWVGdW5jdGlvbihzZWxlY3RlZEl0ZW0pXG4gICAgaWYgKHNlbGVjdGVkSXRlbSAmJiAhbXVsdGlwbGUpIHtcbiAgICAgIHRleHQgPSBzYWZlTGFiZWxGdW5jdGlvbihzZWxlY3RlZEl0ZW0pXG4gICAgfVxuXG4gICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICBvbkNoYW5nZShzZWxlY3RlZEl0ZW0pXG4gIH1cblxuICAkOiBzZWxlY3RlZEl0ZW0sIG9uU2VsZWN0ZWRJdGVtQ2hhbmdlZCgpXG5cbiAgJDogaGlnaGxpZ2h0ZWRJdGVtID1cbiAgICBmaWx0ZXJlZExpc3RJdGVtcyAmJlxuICAgIGhpZ2hsaWdodEluZGV4ICYmXG4gICAgaGlnaGxpZ2h0SW5kZXggPj0gMCAmJlxuICAgIGhpZ2hsaWdodEluZGV4IDwgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoXG4gICAgICA/IGZpbHRlcmVkTGlzdEl0ZW1zW2hpZ2hsaWdodEluZGV4XS5pdGVtXG4gICAgICA6IG51bGxcblxuICAkOiBzaG93TGlzdCA9IG9wZW5lZCAmJiAoKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHx8IGZpbHRlcmVkVGV4dExlbmd0aCA+IDApXG5cbiAgJDogaGFzU2VsZWN0aW9uID1cbiAgICAobXVsdGlwbGUgJiYgc2VsZWN0ZWRJdGVtICYmIHNlbGVjdGVkSXRlbS5sZW5ndGggPiAwKSB8fCAoIW11bHRpcGxlICYmIHNlbGVjdGVkSXRlbSlcblxuICAkOiBjbGVhcmFibGUgPSBzaG93Q2xlYXIgfHwgKChsb2NrIHx8IG11bHRpcGxlKSAmJiBoYXNTZWxlY3Rpb24pXG5cbiAgJDogbG9ja2VkID0gbG9jayAmJiBoYXNTZWxlY3Rpb25cblxuICBmdW5jdGlvbiBwcmVwYXJlVXNlckVudGVyZWRUZXh0KHVzZXJFbnRlcmVkVGV4dCkge1xuICAgIGlmICh1c2VyRW50ZXJlZFRleHQgPT09IHVuZGVmaW5lZCB8fCB1c2VyRW50ZXJlZFRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuXG4gICAgaWYgKCFjbGVhblVzZXJUZXh0KSB7XG4gICAgICByZXR1cm4gdXNlckVudGVyZWRUZXh0XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dEZpbHRlcmVkID0gdXNlckVudGVyZWRUZXh0LnJlcGxhY2UoL1smL1xcXFwjLCsoKSR+JS4nXCI6Kj88Pnt9XS9nLCBcIiBcIikudHJpbSgpXG5cbiAgICBjb25zdCBjbGVhblVzZXJFbnRlcmVkVGV4dCA9IHNhZmVTdHJpbmdGdW5jdGlvbih0ZXh0Q2xlYW5GdW5jdGlvbiwgdGV4dEZpbHRlcmVkKVxuICAgIGNvbnN0IHRleHRUcmltbWVkID0gbG93ZXJjYXNlS2V5d29yZHNcbiAgICAgID8gY2xlYW5Vc2VyRW50ZXJlZFRleHQudG9Mb3dlckNhc2UoKS50cmltKClcbiAgICAgIDogY2xlYW5Vc2VyRW50ZXJlZFRleHQudHJpbSgpXG5cbiAgICByZXR1cm4gdGV4dFRyaW1tZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIG51bWJlck9mTWF0Y2hlcyhsaXN0SXRlbSwgc2VhcmNoV29yZHMpIHtcbiAgICBpZiAoIWxpc3RJdGVtKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1LZXl3b3JkcyA9IGxpc3RJdGVtLmtleXdvcmRzXG5cbiAgICBsZXQgbWF0Y2hlcyA9IDBcbiAgICBzZWFyY2hXb3Jkcy5mb3JFYWNoKChzZWFyY2hXb3JkKSA9PiB7XG4gICAgICBpZiAoaXRlbUtleXdvcmRzLmluY2x1ZGVzKHNlYXJjaFdvcmQpKSB7XG4gICAgICAgIG1hdGNoZXMrK1xuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VhcmNoKCkge1xuICAgIGxldCB0aW1lcklkXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICB0aW1lcklkID0gYEF1dG9jb21wbGV0ZSBzZWFyY2ggJHtpbnB1dElkID8gYChpZDogJHtpbnB1dElkfSlgIDogXCJcIn1gXG4gICAgICBjb25zb2xlLnRpbWUodGltZXJJZClcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VhcmNoaW5nIHVzZXIgZW50ZXJlZCB0ZXh0OiAnXCIgKyB0ZXh0ICsgXCInXCIpXG4gICAgfVxuXG4gICAgbGV0IHRleHRGaWx0ZXJlZCA9IHByZXBhcmVVc2VyRW50ZXJlZFRleHQodGV4dClcbiAgICBpZiAobWluQ2hhcmFjdGVyc1RvU2VhcmNoID4gMSAmJiB0ZXh0RmlsdGVyZWQubGVuZ3RoIDwgbWluQ2hhcmFjdGVyc1RvU2VhcmNoKSB7XG4gICAgICB0ZXh0RmlsdGVyZWQgPSBcIlwiXG4gICAgfVxuICAgIGZpbHRlcmVkVGV4dExlbmd0aCA9IHRleHRGaWx0ZXJlZC5sZW5ndGhcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJDaGFuZ2VkIHVzZXIgZW50ZXJlZCB0ZXh0ICdcIiArIHRleHQgKyBcIicgaW50byAnXCIgKyB0ZXh0RmlsdGVyZWQgKyBcIidcIilcbiAgICB9XG5cbiAgICAvLyBpZiBubyBzZWFyY2ggdGV4dCBsb2FkIGFsbCBpdGVtc1xuICAgIGlmICh0ZXh0RmlsdGVyZWQgPT09IFwiXCIpIHtcbiAgICAgIGlmIChzZWFyY2hGdW5jdGlvbikge1xuICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcmVydW4gdGhlIHNlYXJjaFxuICAgICAgICBpdGVtcyA9IFtdXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBlbnRlcmVkIHRleHQgaXMgZW1wdHkgY2xlYXIgbGlzdCBvZiBpdGVtc1wiKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZXIgZW50ZXJlZCB0ZXh0IGlzIGVtcHR5IHNldCB0aGUgbGlzdCBvZiBpdGVtcyB0byBhbGwgaXRlbXNcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNsb3NlSWZNaW5DaGFyc1RvU2VhcmNoUmVhY2hlZCgpKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUudGltZUVuZCh0aW1lcklkKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2VhcmNoRnVuY3Rpb24pIHtcbiAgICAgIC8vIGludGVybmFsIHNlYXJjaFxuICAgICAgcHJvY2Vzc0xpc3RJdGVtcyh0ZXh0RmlsdGVyZWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4dGVybmFsIHNlYXJjaCB3aGljaCBwcm92aWRlcyBpdGVtc1xuICAgICAgbGFzdFJlcXVlc3RJZCA9IGxhc3RSZXF1ZXN0SWQgKyAxXG4gICAgICBjb25zdCBjdXJyZW50UmVxdWVzdElkID0gbGFzdFJlcXVlc3RJZFxuICAgICAgbG9hZGluZyA9IHRydWVcblxuICAgICAgLy8gc2VhcmNoRnVuY3Rpb24gaXMgYSBnZW5lcmF0b3JcbiAgICAgIGlmIChzZWFyY2hGdW5jdGlvbi5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIikge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHNlYXJjaEZ1bmN0aW9uKHRleHRGaWx0ZXJlZCwgbWF4SXRlbXNUb1Nob3dJbkxpc3QpKSB7XG4gICAgICAgICAgLy8gYSBjaHVuayBvZiBhbiBvbGQgcmVzcG9uc2U6IHRocm93IGl0IGF3YXlcbiAgICAgICAgICBpZiAoY3VycmVudFJlcXVlc3RJZCA8IGxhc3RSZXNwb25zZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhIGNodW5rIGZvciBhIG5ldyByZXNwb25zZTogcmVzZXQgdGhlIGl0ZW0gbGlzdFxuICAgICAgICAgIGlmIChjdXJyZW50UmVxdWVzdElkID4gbGFzdFJlc3BvbnNlSWQpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXN0UmVzcG9uc2VJZCA9IGN1cnJlbnRSZXF1ZXN0SWRcbiAgICAgICAgICBpdGVtcyA9IFsuLi5pdGVtcywgLi4uY2h1bmtdXG4gICAgICAgICAgcHJvY2Vzc0xpc3RJdGVtcyh0ZXh0RmlsdGVyZWQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGVyZSB3YXMgbm90aGluZyBpbiB0aGUgY2h1bmtcbiAgICAgICAgaWYgKGxhc3RSZXNwb25zZUlkIDwgY3VycmVudFJlcXVlc3RJZCkge1xuICAgICAgICAgIGxhc3RSZXNwb25zZUlkID0gY3VycmVudFJlcXVlc3RJZFxuICAgICAgICAgIGl0ZW1zID0gW11cbiAgICAgICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZWFyY2hGdW5jdGlvbiBpcyBhIHJlZ3VsYXIgZnVuY3Rpb25cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc2VhcmNoRnVuY3Rpb24odGV4dEZpbHRlcmVkLCBtYXhJdGVtc1RvU2hvd0luTGlzdClcblxuICAgICAgICAvLyBJZiBhIHJlc3BvbnNlIHRvIGEgbmV3ZXIgcmVxdWVzdCBoYXMgYmVlbiByZWNlaXZlZFxuICAgICAgICAvLyB3aGlsZSByZXNwb25zZXMgdG8gdGhpcyByZXF1ZXN0IHdlcmUgYmVpbmcgbG9hZGVkLFxuICAgICAgICAvLyB0aGVuIHdlIGNhbiBqdXN0IHRocm93IGF3YXkgdGhpcyBvdXRkYXRlZCByZXN1bHRzLlxuICAgICAgICBpZiAoY3VycmVudFJlcXVlc3RJZCA8IGxhc3RSZXNwb25zZUlkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UmVzcG9uc2VJZCA9IGN1cnJlbnRSZXF1ZXN0SWRcbiAgICAgICAgaXRlbXMgPSByZXN1bHRcbiAgICAgICAgcHJvY2Vzc0xpc3RJdGVtcyh0ZXh0RmlsdGVyZWQpXG4gICAgICB9XG5cbiAgICAgIGxvYWRpbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS50aW1lRW5kKHRpbWVySWQpXG4gICAgICBjb25zb2xlLmxvZyhcIlNlYXJjaCBmb3VuZCBcIiArIGZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aCArIFwiIGl0ZW1zXCIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEl0ZW1GaWx0ZXJGdW5jdGlvbihsaXN0SXRlbSwgc2VhcmNoV29yZHMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gbnVtYmVyT2ZNYXRjaGVzKGxpc3RJdGVtLCBzZWFyY2hXb3JkcylcbiAgICBpZiAobWF0Y2hBbGxLZXl3b3Jkcykge1xuICAgICAgcmV0dXJuIG1hdGNoZXMgPj0gc2VhcmNoV29yZHMubGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaGVzID4gMFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRJdGVtU29ydEZ1bmN0aW9uKG9iajEsIG9iajIsIHNlYXJjaFdvcmRzKSB7XG4gICAgcmV0dXJuIG51bWJlck9mTWF0Y2hlcyhvYmoyLCBzZWFyY2hXb3JkcykgLSBudW1iZXJPZk1hdGNoZXMob2JqMSwgc2VhcmNoV29yZHMpXG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZCkge1xuICAgIC8vIGNsZWFucywgZmlsdGVycywgb3JkZXJzLCBhbmQgaGlnaGxpZ2h0cyB0aGUgbGlzdCBpdGVtc1xuICAgIHByZXBhcmVMaXN0SXRlbXMoKVxuXG4gICAgY29uc3QgdGV4dEZpbHRlcmVkV2l0aG91dEFjY2VudHMgPSBpZ25vcmVBY2NlbnRzID8gcmVtb3ZlQWNjZW50cyh0ZXh0RmlsdGVyZWQpIDogdGV4dEZpbHRlcmVkXG4gICAgY29uc3Qgc2VhcmNoV29yZHMgPSB0ZXh0RmlsdGVyZWRXaXRob3V0QWNjZW50cy5zcGxpdCgvXFxzKy9nKS5maWx0ZXIoKHdvcmQpID0+IHdvcmQgIT09IFwiXCIpXG5cbiAgICAvLyBsb2NhbCBzZWFyY2hcbiAgICBsZXQgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zXG4gICAgaWYgKGxvY2FsRmlsdGVyaW5nKSB7XG4gICAgICBpZiAoaXRlbUZpbHRlckZ1bmN0aW9uKSB7XG4gICAgICAgIHRlbXBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtcy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbUZpbHRlckZ1bmN0aW9uKGl0ZW0uaXRlbSwgc2VhcmNoV29yZHMpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtcy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgICAgZGVmYXVsdEl0ZW1GaWx0ZXJGdW5jdGlvbihpdGVtLCBzZWFyY2hXb3JkcylcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAobG9jYWxTb3J0aW5nKSB7XG4gICAgICAgIGlmIChpdGVtU29ydEZ1bmN0aW9uKSB7XG4gICAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gdGVtcGZpbHRlcmVkTGlzdEl0ZW1zLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT5cbiAgICAgICAgICAgIGl0ZW1Tb3J0RnVuY3Rpb24oaXRlbTEuaXRlbSwgaXRlbTIuaXRlbSwgc2VhcmNoV29yZHMpXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzb3J0QnlNYXRjaGVkS2V5d29yZHMpIHtcbiAgICAgICAgICAgIHRlbXBmaWx0ZXJlZExpc3RJdGVtcyA9IHRlbXBmaWx0ZXJlZExpc3RJdGVtcy5zb3J0KChpdGVtMSwgaXRlbTIpID0+XG4gICAgICAgICAgICAgIGRlZmF1bHRJdGVtU29ydEZ1bmN0aW9uKGl0ZW0xLCBpdGVtMiwgc2VhcmNoV29yZHMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgIH1cblxuICAgIGNvbnN0IGhsZmlsdGVyID0gaGlnaGxpZ2h0RmlsdGVyKHNlYXJjaFdvcmRzLCBcImxhYmVsXCIpXG4gICAgZmlsdGVyZWRMaXN0SXRlbXMgPSB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMubWFwKGhsZmlsdGVyKVxuICAgIGNsb3NlSWZNaW5DaGFyc1RvU2VhcmNoUmVhY2hlZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vICQ6IHRleHQsIHNlYXJjaCgpO1xuXG4gIGZ1bmN0aW9uIGFmdGVyQ3JlYXRlKGNyZWF0ZWRJdGVtKSB7XG4gICAgbGV0IGxpc3RJdGVtXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImNyZWF0ZWRJdGVtXCIsIGNyZWF0ZWRJdGVtKVxuICAgIH1cbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNyZWF0ZWRJdGVtKSB7XG4gICAgICBwcmVwYXJlTGlzdEl0ZW1zKClcbiAgICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgICBsZXQgaW5kZXggPSBmaW5kSXRlbUluZGV4KGNyZWF0ZWRJdGVtLCBmaWx0ZXJlZExpc3RJdGVtcylcblxuICAgICAgLy8gaWYgdGhlIGl0ZW1zIGFycmF5IHdhcyBub3QgdXBkYXRlZCwgYWRkIHRoZSBjcmVhdGVkIGl0ZW0gbWFudWFsbHlcbiAgICAgIGlmIChpbmRleCA8PSAwKSB7XG4gICAgICAgIGl0ZW1zID0gW2NyZWF0ZWRJdGVtXVxuICAgICAgICBwcmVwYXJlTGlzdEl0ZW1zKClcbiAgICAgICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICAgICAgaW5kZXggPSAwXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGhpZ2hsaWdodEluZGV4ID0gaW5kZXhcbiAgICAgICAgbGlzdEl0ZW0gPSBmaWx0ZXJlZExpc3RJdGVtc1toaWdobGlnaHRJbmRleF1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3RJdGVtXG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RMaXN0SXRlbShsaXN0SXRlbSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJzZWxlY3RMaXN0SXRlbVwiLCBsaXN0SXRlbSlcbiAgICB9XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBsaXN0SXRlbSAmJiBjcmVhdGUpIHtcbiAgICAgIC8vIGFsbG93IHVuZGVmaW5lZCBpdGVtcyBpZiBjcmVhdGUgaXMgZW5hYmxlZFxuICAgICAgY29uc3QgY3JlYXRlZEl0ZW0gPSBvbkNyZWF0ZSh0ZXh0KVxuICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjcmVhdGVkSXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGNyZWF0ZWRJdGVtLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNyZWF0ZWRJdGVtLnRoZW4oKG5ld0l0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbmV3SXRlbSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXdMaXN0SXRlbSA9IGFmdGVyQ3JlYXRlKG5ld0l0ZW0pXG4gICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbmV3TGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RMaXN0SXRlbShuZXdMaXN0SXRlbSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0SXRlbSA9IGFmdGVyQ3JlYXRlKGNyZWF0ZWRJdGVtKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBsaXN0SXRlbSkge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBsaXN0SXRlbSBpcyB1bmRlZmluZWQuIENhbiBub3Qgc2VsZWN0LmApXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IG5ld1NlbGVjdGVkSXRlbSA9IGxpc3RJdGVtLml0ZW1cbiAgICBpZiAoYmVmb3JlQ2hhbmdlKHNlbGVjdGVkSXRlbSwgbmV3U2VsZWN0ZWRJdGVtKSkge1xuICAgICAgLy8gc2ltcGxlIHNlbGVjdGlvblxuICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZEl0ZW0gPSB1bmRlZmluZWQgLy8gdHJpZ2dlcnMgY2hhbmdlIGV2ZW4gaWYgdGhlIHRoZSBzYW1lIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAgc2VsZWN0ZWRJdGVtID0gbmV3U2VsZWN0ZWRJdGVtXG4gICAgICB9XG4gICAgICAvLyBmaXJzdCBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgb25lc1xuICAgICAgZWxzZSBpZiAoIXNlbGVjdGVkSXRlbSkge1xuICAgICAgICBzZWxlY3RlZEl0ZW0gPSBbbmV3U2VsZWN0ZWRJdGVtXVxuICAgICAgfVxuICAgICAgLy8gc2VsZWN0aW5nIHNvbWV0aGluZyBhbHJlYWR5IHNlbGVjdGVkID0+IHVuc2VsZWN0IGl0XG4gICAgICBlbHNlIGlmIChzZWxlY3RlZEl0ZW0uaW5jbHVkZXMobmV3U2VsZWN0ZWRJdGVtKSkge1xuICAgICAgICBzZWxlY3RlZEl0ZW0gPSBzZWxlY3RlZEl0ZW0uZmlsdGVyKChpKSA9PiBpICE9PSBuZXdTZWxlY3RlZEl0ZW0pXG4gICAgICB9XG4gICAgICAvLyBhZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBzZWxlY3Rpb25cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxlY3RlZEl0ZW0gPSBbLi4uc2VsZWN0ZWRJdGVtLCBuZXdTZWxlY3RlZEl0ZW1dXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RJdGVtKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJzZWxlY3RJdGVtXCIsIGhpZ2hsaWdodEluZGV4KVxuICAgIH1cbiAgICBjb25zdCBsaXN0SXRlbSA9IGZpbHRlcmVkTGlzdEl0ZW1zW2hpZ2hsaWdodEluZGV4XVxuICAgIGlmIChzZWxlY3RMaXN0SXRlbShsaXN0SXRlbSkpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInNlbGVjdExpc3RJdGVtIHRydWUsIGNsb3NpbmdcIilcbiAgICAgIH1cbiAgICAgIGNsb3NlKClcbiAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICB0ZXh0ID0gXCJcIlxuICAgICAgICBpbnB1dC5mb2N1cygpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcInNlbGVjdExpc3RJdGVtIGZhbHNlLCBub3QgY2xvc2luZ1wiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJ1cFwiKVxuICAgIH1cblxuICAgIG9wZW4oKVxuICAgIGlmIChoaWdobGlnaHRJbmRleCA+IDApIHtcbiAgICAgIGhpZ2hsaWdodEluZGV4LS1cbiAgICB9XG5cbiAgICBoaWdobGlnaHQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZG93bigpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZG93blwiKVxuICAgIH1cblxuICAgIG9wZW4oKVxuICAgIGlmIChoaWdobGlnaHRJbmRleCA8IGZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgIGhpZ2hsaWdodEluZGV4KytcbiAgICB9XG5cbiAgICBoaWdobGlnaHQoKVxuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0KCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJoaWdobGlnaHRcIilcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeSA9IFwiLnNlbGVjdGVkXCJcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VhY2hpbmcgRE9NIGVsZW1lbnQ6IFwiICsgcXVlcnkgKyBcIiBpbiBcIiArIGxpc3QpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgICAqL1xuICAgIGNvbnN0IGVsID0gbGlzdCAmJiBsaXN0LnF1ZXJ5U2VsZWN0b3IocXVlcnkpXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAodHlwZW9mIGVsLnNjcm9sbEludG9WaWV3SWZOZWVkZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNjcm9sbGluZyBzZWxlY3RlZCBpdGVtIGludG8gdmlld1wiKVxuICAgICAgICB9XG4gICAgICAgIGVsLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoKVxuICAgICAgfSBlbHNlIGlmIChlbC5zY3JvbGxJbnRvVmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2Nyb2xsaW5nIHNlbGVjdGVkIGl0ZW0gaW50byB2aWV3XCIpXG4gICAgICAgIH1cbiAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJDb3VsZCBub3Qgc2Nyb2xsIHNlbGVjdGVkIGl0ZW0gaW50byB2aWV3LCBzY3JvbGxJbnRvVmlld0lmTmVlZGVkIG5vdCBzdXBwb3J0ZWRcIlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU2VsZWN0ZWQgaXRlbSBub3QgZm91bmQgdG8gc2Nyb2xsIGludG8gdmlld1wiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkxpc3RJdGVtQ2xpY2tcIilcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0TGlzdEl0ZW0obGlzdEl0ZW0pKSB7XG4gICAgICBjbG9zZSgpXG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgdGV4dCA9IFwiXCJcbiAgICAgICAgaW5wdXQuZm9jdXMoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRG9jdW1lbnRDbGljayhlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uRG9jdW1lbnRDbGlja1wiKVxuICAgIH1cbiAgICBpZiAoZS5jb21wb3NlZFBhdGgoKS5zb21lKChwYXRoKSA9PiBwYXRoLmNsYXNzTGlzdCAmJiBwYXRoLmNsYXNzTGlzdC5jb250YWlucyh1bmlxdWVJZCkpKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkRvY3VtZW50Q2xpY2sgaW5zaWRlXCIpXG4gICAgICB9XG4gICAgICAvLyByZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlbigpO1xuICAgICAgaGlnaGxpZ2h0KClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwib25Eb2N1bWVudENsaWNrIG91dHNpZGVcIilcbiAgICAgIH1cbiAgICAgIGNsb3NlKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbktleURvd25cIilcbiAgICB9XG5cbiAgICBsZXQga2V5ID0gZS5rZXlcbiAgICBpZiAoa2V5ID09PSBcIlRhYlwiICYmIGUuc2hpZnRLZXkpIGtleSA9IFwiU2hpZnRUYWJcIlxuICAgIGNvbnN0IGZubWFwID0ge1xuICAgICAgVGFiOiBvcGVuZWQgPyBjbG9zZSA6IG51bGwsXG4gICAgICBTaGlmdFRhYjogb3BlbmVkID8gY2xvc2UgOiBudWxsLFxuICAgICAgQXJyb3dEb3duOiBkb3duLmJpbmQodGhpcyksXG4gICAgICBBcnJvd1VwOiB1cC5iaW5kKHRoaXMpLFxuICAgICAgRXNjYXBlOiBvbkVzYy5iaW5kKHRoaXMpLFxuICAgICAgQmFja3NwYWNlOiBtdWx0aXBsZSAmJiBoYXNTZWxlY3Rpb24gJiYgIXRleHQgPyBvbkJhY2tzcGFjZS5iaW5kKHRoaXMpIDogbnVsbCxcbiAgICB9XG4gICAgY29uc3QgZm4gPSBmbm1hcFtrZXldXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmbihlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5UHJlc3MoZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbktleVByZXNzXCIpXG4gICAgfVxuXG4gICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIG9uRW50ZXIoZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVudGVyKGUpIHtcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIHNlbGVjdEl0ZW0oKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSW5wdXQoZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbklucHV0XCIpXG4gICAgfVxuXG4gICAgdGV4dCA9IGUudGFyZ2V0LnZhbHVlXG4gICAgaWYgKGlucHV0RGVsYXlUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW5wdXREZWxheVRpbWVvdXQpXG4gICAgfVxuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBpbnB1dERlbGF5VGltZW91dCA9IHNldFRpbWVvdXQocHJvY2Vzc0lucHV0LCBkZWxheSlcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzc0lucHV0KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bnNlbGVjdEl0ZW0odGFnKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInVuc2VsZWN0SXRlbVwiLCB0YWcpXG4gICAgfVxuICAgIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbS5maWx0ZXIoKGkpID0+IGkgIT09IHRhZylcbiAgICBpbnB1dC5mb2N1cygpXG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSW5wdXQoKSB7XG4gICAgaWYgKHNlYXJjaCgpKSB7XG4gICAgICBoaWdobGlnaHRJbmRleCA9IDBcbiAgICAgIG9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSW5wdXRDbGljaygpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25JbnB1dENsaWNrXCIpXG4gICAgfVxuICAgIHJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXNjKGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25Fc2NcIilcbiAgICB9XG5cbiAgICAvL2lmICh0ZXh0KSByZXR1cm4gY2xlYXIoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgaWYgKG9wZW5lZCkge1xuICAgICAgaW5wdXQuZm9jdXMoKVxuICAgICAgY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQmFja3NwYWNlKGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25CYWNrc3BhY2VcIilcbiAgICB9XG5cbiAgICB1bnNlbGVjdEl0ZW0oc2VsZWN0ZWRJdGVtW3NlbGVjdGVkSXRlbS5sZW5ndGggLSAxXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9jdXNJbnRlcm5hbCgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25Gb2N1c1wiKVxuICAgIH1cblxuICAgIG9uRm9jdXMoKVxuXG4gICAgcmVzZXRMaXN0VG9BbGxJdGVtc0FuZE9wZW4oKVxuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVySW50ZXJuYWwoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uQmx1clwiKVxuICAgIH1cblxuICAgIGlmIChjbG9zZU9uQmx1cikge1xuICAgICAgY2xvc2UoKVxuICAgIH1cblxuICAgIG9uQmx1cigpXG4gIH1cblxuICBmdW5jdGlvbiByZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlbigpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwicmVzZXRMaXN0VG9BbGxJdGVtc0FuZE9wZW5cIilcbiAgICB9XG5cbiAgICBpZiAoc2VhcmNoRnVuY3Rpb24gJiYgIWxpc3RJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHNlYXJjaCgpXG4gICAgfSBlbHNlIGlmICghdGV4dCkge1xuICAgICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICB9XG5cbiAgICBvcGVuKClcblxuICAgIC8vIGZpbmQgc2VsZWN0ZWQgaXRlbVxuICAgIGlmIChzZWxlY3RlZEl0ZW0pIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNlYXJjaGluZyBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbTogXCIgKyBKU09OLnN0cmluZ2lmeShzZWxlY3RlZEl0ZW0pKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IGZpbmRJdGVtSW5kZXgoc2VsZWN0ZWRJdGVtLCBmaWx0ZXJlZExpc3RJdGVtcylcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGhpZ2hsaWdodEluZGV4ID0gaW5kZXhcbiAgICAgICAgaGlnaGxpZ2h0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSXRlbUluZGV4KGl0ZW0sIGl0ZW1zKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZpbmRpbmcgaW5kZXggZm9yIGl0ZW1cIiwgaXRlbSlcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9IGl0ZW1zW2ldXG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGxpc3RJdGVtKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBsaXN0SXRlbSAke2l9IGlzIHVuZGVmaW5lZC4gU2tpcHBpbmcuYClcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSXRlbSBcIiArIGkgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShsaXN0SXRlbSkpXG4gICAgICB9XG4gICAgICBpZiAoaXRlbSA9PT0gbGlzdEl0ZW0uaXRlbSkge1xuICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgaW5kZXggZm9yIGl0ZW06IFwiICsgaW5kZXgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJOb3QgZm91bmQgaW5kZXggZm9yIGl0ZW06IFwiICsgaXRlbSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4XG4gIH1cblxuICBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvcGVuXCIpXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhlIHNlYXJjaCB0ZXh0IGhhcyBtb3JlIHRoYW4gdGhlIG1pbiBjaGFycyByZXF1aXJlZFxuICAgIGlmIChsb2NrZWQgfHwgbm90RW5vdWdoU2VhcmNoVGV4dCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRQb3NpdGlvbk9uTmV4dFVwZGF0ZSA9IHRydWVcblxuICAgIG9wZW5lZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJjbG9zZVwiKVxuICAgIH1cbiAgICBvcGVuZWQgPSBmYWxzZVxuICAgIGxvYWRpbmcgPSBmYWxzZVxuXG4gICAgaWYgKCF0ZXh0ICYmIHNlbGVjdEZpcnN0SWZFbXB0eSkge1xuICAgICAgaGlnaGxpZ2h0SW5kZXggPSAwXG4gICAgICBzZWxlY3RJdGVtKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3RFbm91Z2hTZWFyY2hUZXh0KCkge1xuICAgIHJldHVybiAoXG4gICAgICBtaW5DaGFyYWN0ZXJzVG9TZWFyY2ggPiAwICYmXG4gICAgICBmaWx0ZXJlZFRleHRMZW5ndGggPCBtaW5DaGFyYWN0ZXJzVG9TZWFyY2ggJiZcbiAgICAgIC8vIFdoZW4gbm8gc2VhcmNoRnVuY3Rpb24gaXMgZGVmaW5lZCwgdGhlIG1lbnUgc2hvdWxkIGFsd2F5cyBvcGVuIHdoZW4gdGhlIGlucHV0IGlzIGZvY3VzZWRcbiAgICAgIChzZWFyY2hGdW5jdGlvbiB8fCBmaWx0ZXJlZFRleHRMZW5ndGggPiAwKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlSWZNaW5DaGFyc1RvU2VhcmNoUmVhY2hlZCgpIHtcbiAgICBpZiAobm90RW5vdWdoU2VhcmNoVGV4dCgpKSB7XG4gICAgICBjbG9zZSgpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJjbGVhclwiKVxuICAgIH1cblxuICAgIHRleHQgPSBcIlwiXG4gICAgc2VsZWN0ZWRJdGVtID0gbXVsdGlwbGUgPyBbXSA6IHVuZGVmaW5lZFxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpbnB1dC5mb2N1cygpXG4gICAgfSlcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBoaWdobGlnaHRGaWx0ZXIoa2V5d29yZHMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIChpdGVtKSA9PiB7XG4gICAgICBsZXQgbGFiZWwgPSBpdGVtW2ZpZWxkXVxuXG4gICAgICBjb25zdCBuZXdJdGVtID0gT2JqZWN0LmFzc2lnbih7IGhpZ2hsaWdodGVkOiB1bmRlZmluZWQgfSwgaXRlbSlcbiAgICAgIG5ld0l0ZW0uaGlnaGxpZ2h0ZWQgPSBsYWJlbFxuXG4gICAgICBjb25zdCBsYWJlbExvd2VyY2FzZSA9IGxhYmVsLnRvTG93ZXJDYXNlKClcbiAgICAgIGNvbnN0IGxhYmVsTG93ZXJjYXNlTm9BYyA9IGlnbm9yZUFjY2VudHMgPyByZW1vdmVBY2NlbnRzKGxhYmVsTG93ZXJjYXNlKSA6IGxhYmVsTG93ZXJjYXNlXG5cbiAgICAgIGlmIChrZXl3b3JkcyAmJiBrZXl3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gW11cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGtleXdvcmQgPSBrZXl3b3Jkc1tpXVxuICAgICAgICAgIGlmIChpZ25vcmVBY2NlbnRzKSB7XG4gICAgICAgICAgICBrZXl3b3JkID0gcmVtb3ZlQWNjZW50cyhrZXl3b3JkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBrZXl3b3JkTGVuID0ga2V5d29yZC5sZW5ndGhcblxuICAgICAgICAgIGxldCBwb3MxID0gMFxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBvczEgPSBsYWJlbExvd2VyY2FzZU5vQWMuaW5kZXhPZihrZXl3b3JkLCBwb3MxKVxuICAgICAgICAgICAgaWYgKHBvczEgPj0gMCkge1xuICAgICAgICAgICAgICBsZXQgcG9zMiA9IHBvczEgKyBrZXl3b3JkTGVuXG4gICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFtwb3MxLCBwb3MyXSlcbiAgICAgICAgICAgICAgcG9zMSA9IHBvczJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChwb3MxICE9PSAtMSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGtleXdvcmRQYXR0ZXJucyA9IG5ldyBTZXQoKVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gcG9zaXRpb25zW2ldXG4gICAgICAgICAgICBjb25zdCBwb3MxID0gcGFpclswXVxuICAgICAgICAgICAgY29uc3QgcG9zMiA9IHBhaXJbMV1cblxuICAgICAgICAgICAgY29uc3Qga2V5d29yZFBhdHRlcm4gPSBsYWJlbExvd2VyY2FzZS5zdWJzdHJpbmcocG9zMSwgcG9zMilcbiAgICAgICAgICAgIGtleXdvcmRQYXR0ZXJucy5hZGQoa2V5d29yZFBhdHRlcm4pXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGtleXdvcmRQYXR0ZXJuIG9mIGtleXdvcmRQYXR0ZXJucykge1xuICAgICAgICAgICAgLy8gRklYTUUgcHN0OiB3b3JrYXJvbmQgZm9yIHdyb25nIHJlcGxhY2VtZW50IDxiPiB0YWdzXG4gICAgICAgICAgICBpZiAoa2V5d29yZFBhdHRlcm4gPT09IFwiYlwiKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKFwiKFwiICsga2V5d29yZFBhdHRlcm4gKyBcIilcIiwgXCJpZ1wiKVxuXG4gICAgICAgICAgICBjb25zdCBuZXdIaWdobGlnaHRlZCA9IG5ld0l0ZW0uaGlnaGxpZ2h0ZWQucmVwbGFjZShyZWcsIFwiPGI+JDE8L2I+XCIpXG4gICAgICAgICAgICBuZXdJdGVtLmhpZ2hsaWdodGVkID0gbmV3SGlnaGxpZ2h0ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0l0ZW1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBY2NlbnRzKHN0cikge1xuICAgIHJldHVybiBzdHIubm9ybWFsaXplKFwiTkZEXCIpLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csIFwiXCIpXG4gIH1cblxuICBmdW5jdGlvbiBpc0NvbmZpcm1lZChsaXN0SXRlbSkge1xuICAgIGlmICghc2VsZWN0ZWRJdGVtKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWRJdGVtLmluY2x1ZGVzKGxpc3RJdGVtKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdEl0ZW0gPT09IHNlbGVjdGVkSXRlbVxuICAgIH1cbiAgfVxuXG4gIGxldCBkcmFnZ2luZ092ZXIgPSBmYWxzZVxuXG4gIGZ1bmN0aW9uIGRyYWdzdGFydChldmVudCwgaW5kZXgpIHtcbiAgICBpZiAob3JkZXJhYmxlU2VsZWN0aW9uKSB7XG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInNvdXJjZVwiLCBpbmRleClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnb3ZlcihldmVudCwgaW5kZXgpIHtcbiAgICBpZiAob3JkZXJhYmxlU2VsZWN0aW9uKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBkcmFnZ2luZ092ZXIgPSBpbmRleFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdsZWF2ZShldmVudCwgaW5kZXgpIHtcbiAgICBpZiAob3JkZXJhYmxlU2VsZWN0aW9uKSB7XG4gICAgICBkcmFnZ2luZ092ZXIgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyb3AoZXZlbnQsIGluZGV4KSB7XG4gICAgaWYgKG9yZGVyYWJsZVNlbGVjdGlvbikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgZHJhZ2dpbmdPdmVyID0gZmFsc2VcbiAgICAgIGxldCBmcm9tID0gcGFyc2VJbnQoZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJzb3VyY2VcIikpXG4gICAgICBsZXQgdG8gPSBpbmRleFxuICAgICAgaWYgKGZyb20gIT0gdG8pIHtcbiAgICAgICAgbW92ZVNlbGVjdGVkSXRlbShmcm9tLCB0bylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlU2VsZWN0ZWRJdGVtKGZyb20sIHRvKSB7XG4gICAgbGV0IG5ld1NlbGVjdGlvbiA9IFsuLi5zZWxlY3RlZEl0ZW1dXG4gICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgbmV3U2VsZWN0aW9uLnNwbGljZSh0byArIDEsIDAsIG5ld1NlbGVjdGlvbltmcm9tXSlcbiAgICAgIG5ld1NlbGVjdGlvbi5zcGxpY2UoZnJvbSwgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2VsZWN0aW9uLnNwbGljZSh0bywgMCwgbmV3U2VsZWN0aW9uW2Zyb21dKVxuICAgICAgbmV3U2VsZWN0aW9uLnNwbGljZShmcm9tICsgMSwgMSlcbiAgICB9XG4gICAgc2VsZWN0ZWRJdGVtID0gbmV3U2VsZWN0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBzZXRTY3JvbGxBd2FyZUxpc3RQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IGhlaWdodDogdmlld1BvcnRIZWlnaHQgfSA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydFxuICAgIGNvbnN0IHsgYm90dG9tOiBpbnB1dEJ1dHRvbSwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9ID0gaW5wdXRDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCB7IGhlaWdodDogbGlzdEhlaWdodCB9ID0gbGlzdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgaWYgKGlucHV0QnV0dG9tICsgbGlzdEhlaWdodCA+IHZpZXdQb3J0SGVpZ2h0KSB7XG4gICAgICBsaXN0LnN0eWxlLnRvcCA9IGAtJHtpbnB1dEhlaWdodCArIGxpc3RIZWlnaHR9cHhgXG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3R5bGUudG9wID0gXCIwcHhcIlxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG48ZGl2XG4gIGNsYXNzPVwie2NsYXNzTmFtZSA/IGNsYXNzTmFtZSA6ICcnfSBhdXRvY29tcGxldGUgc2VsZWN0IGlzLWZ1bGx3aWR0aCB7dW5pcXVlSWR9XCJcbiAgY2xhc3M6aGlkZS1hcnJvdz17aGlkZUFycm93IHx8ICFpdGVtcy5sZW5ndGh9XG4gIGNsYXNzOmlzLW11bHRpcGxlPXttdWx0aXBsZX1cbiAgY2xhc3M6c2hvdy1jbGVhcj17Y2xlYXJhYmxlfVxuICBjbGFzczppcy1sb2FkaW5nPXtzaG93TG9hZGluZ0luZGljYXRvciAmJiBsb2FkaW5nfVxuPlxuICA8c2VsZWN0IG5hbWU9e3NlbGVjdE5hbWV9IGlkPXtzZWxlY3RJZH0ge211bHRpcGxlfT5cbiAgICB7I2lmICFtdWx0aXBsZSAmJiBoYXNTZWxlY3Rpb259XG4gICAgICA8b3B0aW9uIHZhbHVlPXt2YWx1ZUZ1bmN0aW9uKHNlbGVjdGVkSXRlbSwgdHJ1ZSl9IHNlbGVjdGVkPlxuICAgICAgICB7c2FmZUxhYmVsRnVuY3Rpb24oc2VsZWN0ZWRJdGVtKX1cbiAgICAgIDwvb3B0aW9uPlxuICAgIHs6ZWxzZSBpZiBtdWx0aXBsZSAmJiBoYXNTZWxlY3Rpb259XG4gICAgICB7I2VhY2ggc2VsZWN0ZWRJdGVtIGFzIGl9XG4gICAgICAgIDxvcHRpb24gdmFsdWU9e3ZhbHVlRnVuY3Rpb24oaSwgdHJ1ZSl9IHNlbGVjdGVkPlxuICAgICAgICAgIHtzYWZlTGFiZWxGdW5jdGlvbihpKX1cbiAgICAgICAgPC9vcHRpb24+XG4gICAgICB7L2VhY2h9XG4gICAgey9pZn1cbiAgPC9zZWxlY3Q+XG4gIDxkaXYgY2xhc3M9XCJpbnB1dC1jb250YWluZXJcIiBiaW5kOnRoaXM9e2lucHV0Q29udGFpbmVyfT5cbiAgICB7I2lmIG11bHRpcGxlICYmIGhhc1NlbGVjdGlvbn1cbiAgICAgIHsjZWFjaCBzZWxlY3RlZEl0ZW0gYXMgdGFnSXRlbSwgaSAodmFsdWVGdW5jdGlvbih0YWdJdGVtLCB0cnVlKSl9XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBkcmFnZ2FibGU9e3RydWV9XG4gICAgICAgICAgYW5pbWF0ZTpmbGlwPXt7IGR1cmF0aW9uOiAyMDAgfX1cbiAgICAgICAgICB0cmFuc2l0aW9uOmZhZGU9e3sgZHVyYXRpb246IDIwMCB9fVxuICAgICAgICAgIG9uOmRyYWdzdGFydD17KGV2ZW50KSA9PiBkcmFnc3RhcnQoZXZlbnQsIGkpfVxuICAgICAgICAgIG9uOmRyYWdvdmVyPXsoZXZlbnQpID0+IGRyYWdvdmVyKGV2ZW50LCBpKX1cbiAgICAgICAgICBvbjpkcmFnbGVhdmU9eyhldmVudCkgPT4gZHJhZ2xlYXZlKGV2ZW50LCBpKX1cbiAgICAgICAgICBvbjpkcm9wPXsoZXZlbnQpID0+IGRyb3AoZXZlbnQsIGkpfVxuICAgICAgICAgIGNsYXNzOmlzLWFjdGl2ZT17ZHJhZ2dpbmdPdmVyID09PSBpfVxuICAgICAgICA+XG4gICAgICAgICAgPHNsb3QgbmFtZT1cInRhZ1wiIGxhYmVsPXtzYWZlTGFiZWxGdW5jdGlvbih0YWdJdGVtKX0gaXRlbT17dGFnSXRlbX0ge3Vuc2VsZWN0SXRlbX0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFncyBoYXMtYWRkb25zXCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGFnXCI+e3NhZmVMYWJlbEZ1bmN0aW9uKHRhZ0l0ZW0pfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICBjbGFzcz1cInRhZyBpcy1kZWxldGVcIlxuICAgICAgICAgICAgICAgIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0PXt1bnNlbGVjdEl0ZW0odGFnSXRlbSl9XG4gICAgICAgICAgICAgICAgb246a2V5cHJlc3N8cHJldmVudERlZmF1bHQ9eyhlKSA9PiB7ZS5rZXkgPT0gXCJFbnRlclwiICYmIHVuc2VsZWN0SXRlbSh0YWdJdGVtKX19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgIDwvZGl2PlxuICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG4gICAgPGlucHV0XG4gICAgICB0eXBlPVwidGV4dFwiXG4gICAgICBjbGFzcz1cIntpbnB1dENsYXNzTmFtZSA/IGlucHV0Q2xhc3NOYW1lIDogJyd9IHtub0lucHV0U3R5bGVzXG4gICAgICAgID8gJydcbiAgICAgICAgOiAnaW5wdXQgYXV0b2NvbXBsZXRlLWlucHV0J31cIlxuICAgICAgaWQ9e2lucHV0SWQgPyBpbnB1dElkIDogXCJcIn1cbiAgICAgIGF1dG9jb21wbGV0ZT17aHRtbDVhdXRvY29tcGxldGUgPyBcIm9uXCIgOiBhdXRvY29tcGxldGVPZmZWYWx1ZX1cbiAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgIHtuYW1lfVxuICAgICAge2Rpc2FibGVkfVxuICAgICAge3JlcXVpcmVkfVxuICAgICAge3RpdGxlfVxuICAgICAgcmVhZG9ubHk9e3JlYWRvbmx5IHx8IGxvY2tlZH1cbiAgICAgIHt0YWJpbmRleH1cbiAgICAgIGJpbmQ6dGhpcz17aW5wdXR9XG4gICAgICBiaW5kOnZhbHVlPXt0ZXh0fVxuICAgICAgb246aW5wdXQ9e29uSW5wdXR9XG4gICAgICBvbjpmb2N1cz17b25Gb2N1c0ludGVybmFsfVxuICAgICAgb246Ymx1cj17b25CbHVySW50ZXJuYWx9XG4gICAgICBvbjprZXlkb3duPXtvbktleURvd259XG4gICAgICBvbjpjbGljaz17b25JbnB1dENsaWNrfVxuICAgICAgb246a2V5cHJlc3M9e29uS2V5UHJlc3N9XG4gICAgICBvbjpkcmFnb3Zlcj17KGV2ZW50KSA9PiBkcmFnb3ZlcihldmVudCwgc2VsZWN0ZWRJdGVtLmxlbmd0aCAtIDEpfVxuICAgICAgb246ZHJvcD17KGV2ZW50KSA9PiBkcm9wKGV2ZW50LCBzZWxlY3RlZEl0ZW0ubGVuZ3RoIC0gMSl9XG4gICAgICB7Li4uJCRyZXN0UHJvcHN9XG4gICAgLz5cbiAgICB7I2lmIGNsZWFyYWJsZX1cbiAgICAgIDxzcGFuXG4gICAgICAgIG9uOmNsaWNrPXtjbGVhcn1cbiAgICAgICAgb246a2V5cHJlc3M9eyhlKSA9PiB7ZS5rZXkgPT0gXCJFbnRlclwiICYmIGNsZWFyKCl9fVxuICAgICAgICBjbGFzcz1cImF1dG9jb21wbGV0ZS1jbGVhci1idXR0b25cIlxuICAgICAgICA+e0BodG1sIGNsZWFyVGV4dH08L3NwYW4+XG4gICAgey9pZn1cbiAgPC9kaXY+XG4gIDxkaXZcbiAgICBjbGFzcz1cIntkcm9wZG93bkNsYXNzTmFtZSA/IGRyb3Bkb3duQ2xhc3NOYW1lIDogJyd9IGF1dG9jb21wbGV0ZS1saXN0IHtzaG93TGlzdCA/ICcnIDogJ2hpZGRlbid9XG4gICAgaXMtZnVsbHdpZHRoXCJcbiAgICBiaW5kOnRoaXM9e2xpc3R9XG4gID5cbiAgICB7I2lmIGZpbHRlcmVkTGlzdEl0ZW1zICYmIGZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aCA+IDB9XG4gICAgICA8c2xvdCBuYW1lPVwiZHJvcGRvd24taGVhZGVyXCIgbmJJdGVtcz17ZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RofSB7bWF4SXRlbXNUb1Nob3dJbkxpc3R9IC8+XG5cbiAgICAgIHsjZWFjaCBmaWx0ZXJlZExpc3RJdGVtcyBhcyBsaXN0SXRlbSwgaX1cbiAgICAgICAgeyNpZiBsaXN0SXRlbSAmJiAobWF4SXRlbXNUb1Nob3dJbkxpc3QgPD0gMCB8fCBpIDwgbWF4SXRlbXNUb1Nob3dJbkxpc3QpfVxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiYXV0b2NvbXBsZXRlLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICBjbGFzczpzZWxlY3RlZD17aSA9PT0gaGlnaGxpZ2h0SW5kZXh9XG4gICAgICAgICAgICBjbGFzczpjb25maXJtZWQ9e2lzQ29uZmlybWVkKGxpc3RJdGVtLml0ZW0pfVxuICAgICAgICAgICAgb246Y2xpY2s9eygpID0+IG9uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSl9XG4gICAgICAgICAgICBvbjprZXlwcmVzcz17KGUpID0+IHtlLmtleSA9PSBcIkVudGVyXCIgJiYgb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKX19XG4gICAgICAgICAgICBvbjpwb2ludGVyZW50ZXI9eygpID0+IHtcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0SW5kZXggPSBpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzbG90XG4gICAgICAgICAgICAgIG5hbWU9XCJpdGVtXCJcbiAgICAgICAgICAgICAgaXRlbT17bGlzdEl0ZW0uaXRlbX1cbiAgICAgICAgICAgICAgbGFiZWw9e2xpc3RJdGVtLmhpZ2hsaWdodGVkID8gbGlzdEl0ZW0uaGlnaGxpZ2h0ZWQgOiBsaXN0SXRlbS5sYWJlbH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgeyNpZiBsaXN0SXRlbS5oaWdobGlnaHRlZH1cbiAgICAgICAgICAgICAgICB7QGh0bWwgbGlzdEl0ZW0uaGlnaGxpZ2h0ZWR9XG4gICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICB7QGh0bWwgbGlzdEl0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgICB7L2VhY2h9XG5cbiAgICAgIDxzbG90IG5hbWU9XCJkcm9wZG93bi1mb290ZXJcIiBuYkl0ZW1zPXtmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGh9IHttYXhJdGVtc1RvU2hvd0luTGlzdH0+XG4gICAgICAgIHsjaWYgbWF4SXRlbXNUb1Nob3dJbkxpc3QgPiAwICYmIGZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aCA+IG1heEl0ZW1zVG9TaG93SW5MaXN0fVxuICAgICAgICAgIHsjaWYgbW9yZUl0ZW1zVGV4dH1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtLW5vLXJlc3VsdHNcIj5cbiAgICAgICAgICAgICAgLi4ue2ZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aCAtIG1heEl0ZW1zVG9TaG93SW5MaXN0fVxuICAgICAgICAgICAgICB7bW9yZUl0ZW1zVGV4dH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvaWZ9XG4gICAgICA8L3Nsb3Q+XG4gICAgezplbHNlIGlmIGxvYWRpbmcgJiYgbG9hZGluZ1RleHR9XG4gICAgICA8ZGl2IGNsYXNzPVwiYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1sb2FkaW5nXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJsb2FkaW5nXCIge2xvYWRpbmdUZXh0fT57bG9hZGluZ1RleHR9PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgezplbHNlIGlmIGNyZWF0ZX1cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtLWNyZWF0ZVwiXG4gICAgICAgIG9uOmNsaWNrPXtzZWxlY3RJdGVtfVxuICAgICAgICBvbjprZXlwcmVzcz17KGUpID0+IHtlLmtleSA9PSBcIkVudGVyXCIgJiYgc2VsZWN0SXRlbSgpfX1cbiAgICAgID5cbiAgICAgICAgPHNsb3QgbmFtZT1cImNyZWF0ZVwiIHtjcmVhdGVUZXh0fT57Y3JlYXRlVGV4dH08L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICB7OmVsc2UgaWYgbm9SZXN1bHRzVGV4dH1cbiAgICAgIDxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtLW5vLXJlc3VsdHNcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cIm5vLXJlc3VsdHNcIiB7bm9SZXN1bHRzVGV4dH0+e25vUmVzdWx0c1RleHR9PC9zbG90PlxuICAgICAgPC9kaXY+XG4gICAgey9pZn1cbiAgPC9kaXY+XG48L2Rpdj5cblxuPHN2ZWx0ZTp3aW5kb3cgb246Y2xpY2s9e29uRG9jdW1lbnRDbGlja30gb246c2Nyb2xsPXsoKSA9PiBzZXRQb3NpdGlvbk9uTmV4dFVwZGF0ZSA9IHRydWV9IC8+XG5cbjxzdHlsZT5cbiAgLmF1dG9jb21wbGV0ZSB7XG4gICAgbWluLXdpZHRoOiAyMDBweDtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgIGhlaWdodDogMi4yNWVtO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZTpub3QoLmhpZGUtYXJyb3cpOm5vdCguaXMtbG9hZGluZyk6OmFmdGVyIHtcbiAgICBib3JkZXI6IDNweCBzb2xpZDtcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgYm9yZGVyLXJpZ2h0OiAwO1xuICAgIGJvcmRlci10b3A6IDA7XG4gICAgY29udGVudDogXCIgXCI7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgaGVpZ2h0OiAwLjYyNWVtO1xuICAgIG1hcmdpbi10b3A6IC0wLjQzNzVlbTtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA1MCU7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xuICAgIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyO1xuICAgIHdpZHRoOiAwLjYyNWVtO1xuICAgIGJvcmRlci1jb2xvcjogIzMyNzNkYztcbiAgICByaWdodDogMS4xMjVlbTtcbiAgICB6LWluZGV4OiA0O1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5zaG93LWNsZWFyOm5vdCguaGlkZS1hcnJvdyk6OmFmdGVyIHtcbiAgICByaWdodDogMi4zZW07XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlICoge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgZm9udDogaW5oZXJpdDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgcGFkZGluZzogNXB4IDExcHg7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlOm5vdCguaGlkZS1hcnJvdykgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgcGFkZGluZy1yaWdodDogMmVtO1xuICB9XG4gIC5hdXRvY29tcGxldGUuc2hvdy1jbGVhcjpub3QoLmhpZGUtYXJyb3cpIC5hdXRvY29tcGxldGUtaW5wdXQge1xuICAgIHBhZGRpbmctcmlnaHQ6IDMuMmVtO1xuICB9XG4gIC5hdXRvY29tcGxldGUuaGlkZS1hcnJvdy5zaG93LWNsZWFyIC5hdXRvY29tcGxldGUtaW5wdXQge1xuICAgIHBhZGRpbmctcmlnaHQ6IDJlbTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUtbGlzdCB7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICB6LWluZGV4OiA5OTtcbiAgICBwYWRkaW5nOiAxMHB4IDA7XG4gICAgdG9wOiAwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWQgIzk5OTtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDE1ICogKDFyZW0gKyAxMHB4KSArIDE1cHgpO1xuICAgIHVzZXItc2VsZWN0OiBub25lO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdDplbXB0eSB7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbSB7XG4gICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgY29sb3I6ICMzMzM7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0uY29uZmlybWVkIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzg5ZmVkO1xuICAgIGNvbG9yOiAjZmZmO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtLnNlbGVjdGVkIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMmU2OWUyO1xuICAgIGNvbG9yOiAjZmZmO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtLW5vLXJlc3VsdHMge1xuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgIGNvbG9yOiAjOTk5O1xuICAgIGxpbmUtaGVpZ2h0OiAxO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtLWNyZWF0ZSB7XG4gICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbG9hZGluZyB7XG4gICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLWxpc3QuaGlkZGVuIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLnNob3ctY2xlYXIgLmF1dG9jb21wbGV0ZS1jbGVhci1idXR0b24ge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHJpZ2h0OiAwLjFlbTtcbiAgICBwYWRkaW5nOiAwLjNlbSAwLjZlbTtcbiAgICB0b3A6IDUwJTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcbiAgICB6LWluZGV4OiA0O1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZTpub3QoLnNob3ctY2xlYXIpIC5hdXRvY29tcGxldGUtY2xlYXItYnV0dG9uIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZSBzZWxlY3Qge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLmlzLW11bHRpcGxlIC5pbnB1dC1jb250YWluZXIge1xuICAgIGhlaWdodDogYXV0bztcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAycHggcmdiYSgxMCwgMTAsIDEwLCAwLjEpO1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYjViNWI1O1xuICAgIHBhZGRpbmctbGVmdDogMC40ZW07XG4gICAgcGFkZGluZy1yaWdodDogMC40ZW07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuaXMtbXVsdGlwbGUgLnRhZyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW4tdG9wOiAwLjVlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAwLjNlbTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuaXMtbXVsdGlwbGUgLnRhZy5pcy1kZWxldGUge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuaXMtbXVsdGlwbGUgLnRhZ3Mge1xuICAgIG1hcmdpbi1yaWdodDogMC4zZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMDtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuaXMtbXVsdGlwbGUgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBmbGV4OiAxIDEgNTBweDtcbiAgICBtaW4td2lkdGg6IDNlbTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJ0ZXh0ZmllbGRcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICBzaXplID0gXCJub3JtYWxcIixcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXRleHRmaWVsZC17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgQXV0b0NvbXBsZXRlIGZyb20gXCJzaW1wbGUtc3ZlbHRlLWF1dG9jb21wbGV0ZVwiO1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSVRleHRmaWVsZElucHV0IGZyb20gXCIuL3VpLnRleHRmaWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqXG4gICAgICogTW9yZSBwcm9wZXJ0aWVzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9wc3Rhbm9ldi9zaW1wbGUtc3ZlbHRlLWF1dG9jb21wbGV0ZSNwcm9wZXJ0aWVzXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWUgPSAnYXV0b2NvbXBsZXRlJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICAvL2dlbmVyaWMgaW5wdXQgcHJvcHNcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImF1dG9jb21wbGV0ZVwiLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbCkge1xuICAgICAgICBpZiAob25jaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbCksXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgZGlzYWJsZWR9XG4gICAgPFVJVGV4dGZpZWxkSW5wdXRcbiAgICAgICAgdmFsdWU9e3ZhbHVlID8gdmFsdWUudGl0bGUgOiBcIlwifVxuICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbns6ZWxzZSBpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWUgPyAodmFsdWU/LnRpdGxlID8/IFwiXCIpIDogXCJcIn08L3A+XG57OmVsc2V9XG4gICAgPEF1dG9Db21wbGV0ZVxuICAgICAgICBiaW5kOnNlbGVjdGVkSXRlbT17dmFsdWV9XG4gICAgICAgIHtvbkNoYW5nZX1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICB7dmFsaWR9XG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgeyBVSUNvbW1vbiB9IGZyb20gXCIuLi8uLlwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImNvbG9yXCIsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG48aW5wdXRcbiAgICBpZD1cImZvcm0tZmllbGQtY29sb3Ite2ZpZWxkbmFtZX1cIlxuICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgIHR5cGU9XCJjb2xvclwiXG4gICAgbmFtZT17ZmllbGRuYW1lfVxuICAgIGJpbmQ6dmFsdWVcbiAgICB7aW52YWxpZH1cbiAgICB7cmVxdWlyZWR9XG4gICAge3JlYWRvbmx5fVxuICAgIHtkaXNhYmxlZH1cbiAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgey4uLm90aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGZvclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWw9J2xhYmVsJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZvcjogZm9ySWQsXG4gICAgICAgIGxhYmVsID0gXCJsYWJlbFwiLFxuICAgICAgICBjbGFzczogbGFiZWxDbGFzcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48bGFiZWwgY2xhc3M9XCJsYWJlbCB7bGFiZWxDbGFzc31cIiBmb3I9e2ZvcklkfT5cbiAgICB7I2lmIGNoaWxkcmVufVxuICAgICAgICB7QHJlbmRlciBjaGlsZHJlbigpfVxuICAgIHs6ZWxzZX17bGFiZWwgPyAkTE9DQUxFW2xhYmVsXSA6IFwiXCJ9ey9pZn1cbjwvbGFiZWw+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEBjb21wb25lbnRcbiAgICAgKiBjaGVja2JveCB3aXRoIHRydWUgb3IgZmFsc2UgdmFsdWVzXG4gICAgICoqL1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4vdWkubGFiZWwuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQm9vbGVhbiBmcm9tIFwiLi4vdmFyaW91cy91aS5ib29sZWFuLnN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIGxhYmVsID0gXCJjaGVja2JveFwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImNoZWNrYm94XCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGxhYmVsQ2xhc3MgPSBcImNoZWNrYm94XCIsXG4gICAgICAgIHJlYWN0T24gPSBbXCJvbmNoYW5nZVwiLCBcIm9uaW5wdXRcIl0sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBpZCA9IGBmb3JtLWZpZWxkLWNoZWNrYm94LSR7ZmllbGRuYW1lfWA7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChcbiAgICAgICAgICAgIGZpZWxkbmFtZSxcbiAgICAgICAgICAgIG90aGVycy5vbmNoYW5nZSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogb3RoZXJzPy5pZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmVhY3RPbi5mb3JFYWNoKChldmVudE5hbWUpID0+IChvcHRpb25hbFByb3BzW2V2ZW50TmFtZV0gPSBvbmlucHV0KSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSUxhYmVsIGNsYXNzPXtsYWJlbENsYXNzfSB7ZGlzYWJsZWR9IGZvcj17aWR9PlxuICAgIHsjaWYgcmVhZG9ubHl9XG4gICAgICAgIDxVSUJvb2xlYW4gTENfVFJVRT17bGFiZWx9IExDX0ZBTFNFPXtsYWJlbH0ge3ZhbHVlfSAvPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICBjbGFzcz17Y2xhc3Nlc31cbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e3ZhbHVlfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICAvPlxuICAgICAgICB7JExPQ0FMRVtsYWJlbF19XG4gICAgey9pZn1cbjwvVUlMYWJlbD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ2hlY2tib3hJbnB1dCBmcm9tIFwiLi91aS5jaGVja2JveC5zdmVsdGVcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoW10pLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImNoZWNrYm94LWxpc3RcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25jaGFuZ2UoZGF0YSwgZXYsIGFkZGl0aW9uYWwpIHtcbiAgICAgICAgaWYgKCFhZGRpdGlvbmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5pbmNsdWRlcyhhZGRpdGlvbmFsLmlkKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goYWRkaXRpb25hbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoYWRkaXRpb25hbC5pZCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zcGxpY2UodmFsdWUuaW5kZXhPZihhZGRpdGlvbmFsLmlkKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJzPy5vbmNoYW5nZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV2LFxuICAgICAgICAgICAgYWRkaXRpb25hbFxuICAgICAgICApO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2VhY2ggdmFyaWFudHMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgPFVJQ2hlY2tib3hJbnB1dFxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICB7Li4uaXRlbX1cbiAgICAgICAgZmllbGRuYW1lPXtgJHtmaWVsZG5hbWV9LSR7aXRlbS5pZH1gfVxuICAgICAgICB2YWx1ZT17dmFsdWUuaW5jbHVkZXMoaXRlbS5pZCl9XG4gICAgICAgIHtvbmNoYW5nZX1cbiAgICAvPlxuey9lYWNofVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShuZXcgRGF0ZSgpKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImRhdGV0aW1lXCIsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICBwYXR0ZXJuID0gXCJkezR9LWR7Mn0tZHsyfVwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0lTT1N0cmluZygpLnNwbGl0KFwiVFwiKVswXTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKFwiVFwiKSA+IDApIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoXCJUXCIpWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPlxuICAgICAgICA8dGltZSBkYXRldGltZT17dmFsdWV9PntVSUNvbW1vbi50cnlGb3JtYXRMb2NhbGVEYXRlVGltZSh2YWx1ZSl9PC90aW1lPlxuICAgIDwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLWRhdGUte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwiZGF0ZVwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICB7cGF0dGVybn1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZU1zRnJvbURhdGUoaXNvRGF0ZSwgbWFya0FzWlVMVSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBpc29EYXRlLnNwbGl0KFwiLlwiKVswXSArIChtYXJrQXNaVUxVID8gXCJcIiA6IFwiWlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTZWNGcm9tRGF0ZShpc29EYXRlLCBtYXJrQXNaVUxVID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzb0RhdGUuc2xpY2UoMCwgaXNvRGF0ZS5sYXN0SW5kZXhPZihcIjpcIikpICsgKG1hcmtBc1pVTFUgPyBcIlwiIDogXCJaXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hpZnREYXRldGltZShpc29EYXRlLCBzaGlmdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZVV0YyA9IG5ldyBEYXRlKG1hcmtBc1pVTFUoaXNvRGF0ZSkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHNoaWZ0ICogLTYwMDAwO1xuICAgICAgICAgICAgaWYgKGRhdGVJc1ZhbGlkKGRhdGVVdGMgKyBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGVVdGMgKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0lzb0RhdGUgPSBuZXdEYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNlY0Zyb21EYXRlKFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVNc0Zyb21EYXRlKG5ld0lzb0RhdGUsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXJrQXNaVUxVKGRhdGVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVTdHJpbmcgJiYgZGF0ZVN0cmluZy5hdCgtMSkgIT09IFwiWlwiXG4gICAgICAgICAgICA/IGRhdGVTdHJpbmcgKyBcIlpcIlxuICAgICAgICAgICAgOiBkYXRlU3RyaW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuUmVhZGFibGUoaXNvRGF0ZSkge1xuICAgICAgICByZXR1cm4gVUlDb21tb24udHJ5Rm9ybWF0TG9jYWxlRGF0ZVRpbWUoaXNvRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcImRhdGV0aW1lSW5UWlwiLFxuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcbiAgICAgICAgICAgIHJlbW92ZVNlY0Zyb21EYXRlKHJlbW92ZU1zRnJvbURhdGUobmV3IERhdGUoKS50b0lTT1N0cmluZygpKSlcbiAgICAgICAgKSxcbiAgICAgICAgdGltZXpvbmVPZmZzZXQgPSAwLFxuICAgICAgICBodW1hbiA9IHRydWUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgc2hpZnRlZFZhbHVlID0gJHN0YXRlKCksXG4gICAgICAgIHByZXZTaGlmdGVkVmFsdWU7XG5cbiAgICBjb25zdCBzZXRTaGlmdGVkID0gKHZhbCkgPT4ge1xuICAgICAgICBpZiAoZGF0ZUlzVmFsaWQodmFsKSkge1xuICAgICAgICAgICAgcHJldlNoaWZ0ZWRWYWx1ZSA9IHNoaWZ0ZWRWYWx1ZTtcbiAgICAgICAgICAgIHNoaWZ0ZWRWYWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXNldFNoaWZ0ZWRWYWx1ZSA9ICgpID0+IHtcbiAgICAgICAgc2hpZnRlZFZhbHVlID0gcHJldlNoaWZ0ZWRWYWx1ZTtcbiAgICB9O1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHNldFNoaWZ0ZWQoc2hpZnREYXRldGltZSh2YWx1ZSwgdGltZXpvbmVPZmZzZXQpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGRhdGVJc1ZhbGlkID0gKGRhdGUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNoYW5nZWQgPSAoKSA9PlxuICAgICAgICB2YWx1ZSAhPT0gc2hpZnREYXRldGltZShzaGlmdGVkVmFsdWUsIC10aW1lem9uZU9mZnNldCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBkaXNwYXRjaENoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgc2V0U2hpZnRlZChzaGlmdGVkVmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IG1hcmtBc1pVTFUoc2hpZnREYXRldGltZShzaGlmdGVkVmFsdWUsIC10aW1lem9uZU9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWU6ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShldikge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldi5jdXJyZW50VGFyZ2V0LnZhbHVlICYmXG4gICAgICAgICAgICBzaGlmdGVkVmFsdWUgJiZcbiAgICAgICAgICAgIGRhdGVJc1ZhbGlkKHNoaWZ0ZWRWYWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCgpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRTaGlmdGVkVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgc2hpZnRlZFZhbHVlfVxuICAgIHsjaWYgcmVhZG9ubHl9XG4gICAgICAgIDxwPntodW1hblJlYWRhYmxlKHNoaWZ0ZWRWYWx1ZSl9PC9wPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgICBpZD1cImZvcm0tZmllbGQtZGF0ZXRpbWUtaW4tdGltZXpvbmUte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICAgICAgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIGJpbmQ6dmFsdWU9e3NoaWZ0ZWRWYWx1ZX1cbiAgICAgICAgICAgIHtpbnZhbGlkfVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBvbmNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAgICAgICBvbmJsdXI9e29uQ2hhbmdlfVxuICAgICAgICAgICAgb25pbnB1dD17b25DaGFuZ2V9XG4gICAgICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiZW1haWxcIixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLWVtYWlsLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cImVtYWlsXCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImhpZGRlblwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48aW5wdXRcbiAgICBpZD1cImZvcm0tZmllbGQtaGlkZGVuLXtmaWVsZG5hbWV9XCJcbiAgICB0eXBlPVwiaGlkZGVuXCJcbiAgICBiaW5kOnZhbHVlXG4gICAge3JlcXVpcmVkfVxuICAgIHtyZWFkb25seX1cbiAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAge290aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRleHRhcmVhXCIsXG4gICAgICAgIHJvd3MgPSAxMCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uYmx1clwiXSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgcmVhY3RPbi5mb3JFYWNoKChldmVudE5hbWUpID0+IChvcHRpb25hbFByb3BzW2V2ZW50TmFtZV0gPSBvbmlucHV0KSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8dGV4dGFyZWFcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXRleHRhcmVhLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJ0ZXh0YXJlYSB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIHtpbnZhbGlkfVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHtyb3dzfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgID48L3RleHRhcmVhPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUZXh0YXJlYSBmcm9tIFwiLi91aS50ZXh0YXJlYS5zdmVsdGVcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImpzb25hcmVhXCIsXG4gICAgICAgIHZhbGlkID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB7fSxcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uYmx1clwiXSxcbiAgICAgICAgY29sb3JWYWxpZCA9IFwic3VjY2Vzc1wiLFxuICAgICAgICBjb2xvckludmFsaWQgPSBcImRhbmdlclwiLFxuICAgICAgICB2YWxpZGF0aW9uRGVsYXkgPSAxMDAwLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgX3ZhbHVlID0gJHN0YXRlKFwie31cIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF92YWx1ZSA9IEpTT04uc3RyaW5naWZ5KCRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksIG51bGwsIDQpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIF92YWx1ZSA9IFwie31cIjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGRlbGF5ZWRWYWxpZGF0aW9uO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UodmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsKTtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgb25lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsYXllZE9uQ2hhbmdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogdmFsIH0gPSBkYXRhO1xuICAgICAgICBpZiAoZGVsYXllZFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWxheWVkVmFsaWRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsYXllZFZhbGlkYXRpb24gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKHZhbCk7XG4gICAgICAgIH0sIHZhbGlkYXRpb25EZWxheSk7XG4gICAgfVxuXG4gICAgbGV0IGNvbG9yID0gJGRlcml2ZWQodmFsaWQgPyBjb2xvclZhbGlkIDogY29sb3JJbnZhbGlkKTtcbjwvc2NyaXB0PlxuXG48VUlUZXh0YXJlYVxuICAgIGJpbmQ6dmFsdWU9e192YWx1ZX1cbiAgICB7ZmllbGRuYW1lfVxuICAgIG9uY2hhbmdlPXtkZWxheWVkT25DaGFuZ2V9XG4gICAge3JlYWN0T259XG4gICAge3ZhbGlkfVxuICAgIHtjb2xvcn1cbiAgICB7Li4ub3RoZXJzfVxuLz5cbiIsImNsYXNzIExpYiB7XG4gICAgI2xpYiA9IHt9O1xuXG4gICAgY29uc3RydWN0b3Ioc2VlZExpYikge1xuICAgICAgICBpZiAoc2VlZExpYiBpbnN0YW5jZW9mIExpYikge1xuICAgICAgICAgICAgdGhpcy5pbXBvcnQoc2VlZExpYi5nZXRDb250ZW50KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW1zIHtzdHJpbmd9ICBtb2RlIHdoYXQgdG8gZG8gaWYgZWxlbWVudCBleGlzdHMgW3JlcGxhY2V8YWRkfHNraXBdXG4gICAgICovXG4gICAgYWRkKG5hbWUsIGNvbXAsIG1vZGUgPSBcInJlcGxhY2VcIikge1xuICAgICAgICBpZiAodGhpcy5jb250YWlucyhuYW1lKSkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbGliW25hbWVdID0gY29tcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCJhZGRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xpYltuYW1lXSA9IE9iamVjdC5hc3NpZ24odGhpcy4jbGliW25hbWVdLCBjb21wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2xpYltuYW1lXSA9IGNvbXA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbGliW25hbWVdO1xuICAgIH1cblxuICAgIGNvbnRhaW5zKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5oYXNPd24odGhpcy4jbGliLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpbXBvcnQoYnVsaywgbW9kZSA9IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGZvciAobGV0IGYgaW4gYnVsaykge1xuICAgICAgICAgICAgdGhpcy5hZGQoZiwgYnVsa1tmXSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy4jbGliKS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuI2xpYixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpYjtcbiIsIi8qXG4gKiDQkdC40LHQu9C40L7RgtC10LrQsCBVSSDQutC+0L3RgdGC0YDRg9C60YLQvtGA0L7QslxuICovXG5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCBMaWIgZnJvbSBcIi4vbGliLmpzXCI7XG5cbmNvbnN0IENPTVBPTkVOVFMgPSBuZXcgTGliKCk7XG5jb25zdCBGSUVMRFMgPSBuZXcgTGliKCk7XG5jb25zdCBWQVJJQU5UUyA9IG5ldyBMaWIoKTtcblxuZXhwb3J0IHsgQ09NUE9ORU5UUywgRklFTERTLCBWQVJJQU5UUyB9O1xuIiwiPHNjcmlwdD5cbiAgICAvKiBlc2xpbnQgc3ZlbHRlL25vLWF0LWh0bWwtdGFnczogMCAqL1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZCA9IGB0aXRsZS0ke01hdGgucmFuZG9tKCl9YF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdGl0bGUgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc3VidGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3NpemUgPSAxXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtzdWJzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtzcGFjZWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbYWxpZ24gPSAnbGVmdCddXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gYHRpdGxlLSR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIHN1YnRpdGxlLFxuICAgICAgICBzaXplID0gMSxcbiAgICAgICAgc3Vic2l6ZSxcbiAgICAgICAgc3BhY2VkID0gZmFsc2UsXG4gICAgICAgIGFsaWduID0gXCJsZWZ0XCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZXhwb3J0IGNvbnN0IHNjcm9sbFRvVG9wID0gKG9wdGlvbnMgPSBVSUNvbW1vbi5TQ1JPTExfT1BUSU9OUykgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKS5zY3JvbGxJbnRvVmlldyhvcHRpb25zKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9O1xuXG4gICAgbGV0IHNpemUyID0gJGRlcml2ZWQoXG4gICAgICAgIHN1YnNpemUgPyBzdWJzaXplIDogcGFyc2VJbnQoc2l6ZSkgPCA2ID8gcGFyc2VJbnQoc2l6ZSkgKyAxIDogc2l6ZVxuICAgICk7XG5cbiAgICBsZXQgc3BhY2VkU3R5bGUgPSAkZGVyaXZlZChzcGFjZWQgPyBcImhhcy10ZXh0LWp1c3RpZmllZFwiIDogXCJcIik7XG5cbiAgICBsZXQgcmVzdWx0VGl0bGUgPSAkZGVyaXZlZChcbiAgICAgICAgYDxoJHtzaXplfSBpZD1cIiR7aWR9XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiAke2FsaWdufTtcIiBjbGFzcz1cInRpdGxlICR7c3BhY2VkU3R5bGV9IGlzLSR7c2l6ZX1cIj4keyRMT0NBTEVbdGl0bGVdfTwvaCR7c2l6ZX0+YFxuICAgICk7XG4gICAgbGV0IHJlc3VsdFN1YnRpdGxlID0gJGRlcml2ZWQoXG4gICAgICAgIGA8aCR7c2l6ZTJ9IGlkPVwiJHtpZH1cIiBzdHlsZT1cInRleHQtYWxpZ246ICR7YWxpZ259O1wiIGNsYXNzPVwic3VidGl0bGUgaXMtJHtzaXplMn1cIj4keyRMT0NBTEVbc3VidGl0bGVdfTwvaCR7c2l6ZTJ9PmBcbiAgICApO1xuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGV9XG4gICAge0BodG1sIHJlc3VsdFRpdGxlfVxuey9pZn1cblxueyNpZiBzdWJ0aXRsZX1cbiAgICB7QGh0bWwgcmVzdWx0U3VidGl0bGV9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSAgICBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0aXRsZSA9IFwibm90LW5vZGU6ZW1wdHlfbGlzdF9wbGFjZWhvbGRlclwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtzaXplID0gNF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbYWxpZ24gPSAnY2VudGVyJ11cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIFByb3BzXG4gICAgICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIm5vdC1ub2RlOmVtcHR5X2xpc3RfcGxhY2Vob2xkZXJcIixcbiAgICAgICAgc2l6ZSA9IDQsXG4gICAgICAgIGFsaWduID0gXCJjZW50ZXJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxVSVRpdGxlIHt0aXRsZX0ge3NpemV9IHthbGlnbn0gey4uLm90aGVyc30gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSAtIGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gZG93bmxvYWRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RhcmdldF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gcmVsXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGlnaHRdIC0gdmlzdWFsXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWlzZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0bGluZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcm91bmRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidXR0b25dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpY29uXSAtIGljb25zXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2lkZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIHVybCA9IFwiXCIsXG4gICAgICAgIGRvd25sb2FkLFxuICAgICAgICB0YXJnZXQgPSBcIl9ibGFua1wiLFxuICAgICAgICByZWwsXG4gICAgICAgIGxpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmFpc2VkID0gZmFsc2UsXG4gICAgICAgIG91dGxpbmVkID0gZmFsc2UsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgICAgIHJvdW5kZWQgPSBmYWxzZSxcbiAgICAgICAgYnV0dG9uID0gdHJ1ZSxcbiAgICAgICAgc3RhdGU6IGFjdGl2ZVN0YXRlID0gXCJcIixcbiAgICAgICAgdHlwZSA9IFwiXCIsXG4gICAgICAgIGNvbG9yID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaWNvbixcbiAgICAgICAgaWNvblNpZGUgPSBcInJpZ2h0XCIsXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjc25pcHBldCBzaWRlSWNvbigpfVxuICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiXG4gICAgICAgID48aSBjbGFzcz1cImZhcyBmYS17aWNvbn0ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIj48L2k+PC9zcGFuXG4gICAgPlxuey9zbmlwcGV0fVxuXG48YVxuICAgIG9uY2xpY2s9e2FjdGlvbiB8fCBvbmNsaWNrfVxuICAgIGhyZWY9e3VybH1cbiAgICB7dGFyZ2V0fVxuICAgIHtkb3dubG9hZH1cbiAgICB7cmVsfVxuICAgIGNsYXNzPVwie2NsYXNzZXN9IHthY3RpdmVTdGF0ZSA/IGBpcy0ke2FjdGl2ZVN0YXRlfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICA6ICcnfSB7dHlwZSA/IGBpcy0ke3R5cGV9YCA6ICcnfSB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiXG4gICAgY2xhc3M6YnV0dG9uXG4gICAgY2xhc3M6aXMtbGlnaHQ9e2xpZ2h0fVxuICAgIGNsYXNzOmlzLWludmVydGVkPXtpbnZlcnRlZH1cbiAgICBjbGFzczppcy1vdXRsaW5lZD17b3V0bGluZWR9XG4gICAgY2xhc3M6aXMtcmFpc2VkPXtyYWlzZWR9XG4gICAgY2xhc3M6aXMtcm91bmRlZD17cm91bmRlZH1cbiAgICBjbGFzczppcy1sb2FkaW5nPXtsb2FkaW5nfVxuPlxuICAgIHsjaWYgaWNvbn1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJsZWZ0XCJ9e0ByZW5kZXIgc2lkZUljb24oKX17L2lmfVxuICAgICAgICB7I2lmIHRpdGxlfTxzcGFuPnskTE9DQUxFW3RpdGxlXX08L3NwYW4+ey9pZn1cbiAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuICAgICAgICB7I2lmIGljb25TaWRlID09PSBcInJpZ2h0XCJ9e0ByZW5kZXIgc2lkZUljb24oKX17L2lmfVxuICAgIHs6ZWxzZX17JExPQ0FMRVt0aXRsZV19e0ByZW5kZXIgY2hpbGRyZW4/LigpfXsvaWZ9XG48L2E+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxpbmsgZnJvbSBcIi4vdWkubGluay5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICBbdmFsdWVzPVtdXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlcz0nJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjZW50ZXJlZD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqb2luZWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbaXRlbXNQcm9wcyA9IHt9XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgICAgICBqb2luZWQgPSB0cnVlLFxuICAgICAgICBpdGVtc1Byb3BzID0ge30sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjc25pcHBldCBsaXN0TGlua3MoKX1cbiAgICB7I2VhY2ggdmFsdWVzIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICA8VUlMaW5rIHsuLi5pdGVtfSB7Li4uaXRlbXNQcm9wc30gLz5cbiAgICB7L2VhY2h9XG57L3NuaXBwZXR9XG5cbnsjaWYgam9pbmVkfVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJmaWVsZCBoYXMtYWRkb25zIHtjbGFzc2VzfVwiXG4gICAgICAgIGNsYXNzOmlzLWNlbnRlcmVkPXtjZW50ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtcmlnaHQ9e3JpZ2h0fVxuICAgID5cbiAgICAgICAgPHAgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICB7QHJlbmRlciBsaXN0TGlua3MoKX1cbiAgICAgICAgPC9wPlxuICAgIDwvZGl2PlxuezplbHNlfVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJidXR0b25zIHtjbGFzc2VzfVwiXG4gICAgICAgIGNsYXNzOmlzLWNlbnRlcmVkPXtjZW50ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtcmlnaHQ9e3JpZ2h0fVxuICAgID5cbiAgICAgICAge0ByZW5kZXIgbGlzdExpbmtzKCl9XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlua3MgZnJvbSBcIi4uL2xpbmsvdWkubGlua3Muc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ2xpY2thYmxlRGl2IGZyb20gXCIuLi9ibG9jay91aS5jbGlja2FibGUuZGl2LnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBpbmRleFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG9iamVjdH0gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R9IGRlc2NyaXB0aW9uXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2FjdGlvbnMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBbbGlua3MgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBbbGlzdEFjdGlvbnMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBbbGlzdExpbmtzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tbW9uQ2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R9IFtpbWFnZSA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB2YWx1ZSAtIHZhbHVlIG9mIGl0ZW0sIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSBbaW5kZXggPSAtMV0gLSBpbmRleCBpbiBhcnJheSAwLWxlbmd0aFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZpcnN0ID0gZmFsc2VdIC0gaWYgZmlyc3RcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsYXN0ID0gZmFsc2VdIC0gaWYgbGFzdFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdIC0gY3VzdG9taXphdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdGl0bGVDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25Db21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2ltYWdlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbaW1hZ2VDb21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tEZXNjcmlwdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja0ltYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrQ29udGVudF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGxpbmtzID0gW10sXG4gICAgICAgIGxpc3RBY3Rpb25zID0gW10sXG4gICAgICAgIGxpc3RMaW5rcyA9IFtdLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNvbW1vbkNsYXNzID0gXCJcIixcbiAgICAgICAgaW1hZ2UgPSBcIlwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgZmlyc3QgPSBmYWxzZSxcbiAgICAgICAgbGFzdCA9IGZhbHNlLFxuICAgICAgICBsaXN0SXRlbUNvbnRlbnRDb21wb25lbnQ6IFVJTGlzdEl0ZW1Db250ZW50Q29tcG9uZW50LFxuICAgICAgICBsaXN0SXRlbUNvbnRlbnRDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICB0aXRsZVJlbmRlcmVyLFxuICAgICAgICB0aXRsZUNvbXBvbmVudDogVUlUaXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDYgfSxcbiAgICAgICAgZGVzY3JpcHRpb25SZW5kZXJlcixcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnQ6IFVJRGVzY3JpcHRpb25Db21wb25lbnQsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgaW1hZ2VSZW5kZXJlcixcbiAgICAgICAgaW1hZ2VDb21wb25lbnQ6IFVJSW1hZ2VDb21wb25lbnQsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25jbGlja0ltYWdlLFxuICAgICAgICBvbmNsaWNrQ29udGVudCxcbiAgICAgICAgb25jbGlja1RpdGxlLFxuICAgICAgICBvbmNsaWNrRGVzY3JpcHRpb24sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgb25jbGljayAmJiBvbmNsaWNrKHZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgYWxsQWN0aW9ucyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IGFsbExpbmtzID0gJHN0YXRlKFtdKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrVGVtcGxhdGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBhbGxBY3Rpb25zID0gWy4uLmFjdGlvbnMsIC4uLmxpc3RBY3Rpb25zXS5tYXAoKGJ0biwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uYnRuLFxuICAgICAgICAgICAgICAgIGlkOiBpbmRleCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGJ0bi5hY3Rpb24gPyAoKSA9PiBidG4uYWN0aW9uKHZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFsbExpbmtzID0gWy4uLmxpbmtzLCAuLi5saXN0TGlua3NdLm1hcCgobGluaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxpbmsuaWQgPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHBhcmFtc1NldCA9IHsgdGl0bGUsIGRlc2NyaXB0aW9uLCBpbWFnZSwgdmFsdWUsIGluZGV4IH07XG5cbiAgICBjb25zdCBjbGlja2FibGVJdGVtRWxlbWVudEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHJvbGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYmluZGV4OiBcIjBcIixcbiAgICAgICAgb25jbGljazogb25DbGljayxcbiAgICAgICAgb25rZXl1cDogKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlICYmIGUua2V5ID09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgYWRkaXRpb25hbEVsZW1lbnRBdHRyaWJ1dGVzID0gb25jbGlja1xuICAgICAgICA/IGNsaWNrYWJsZUl0ZW1FbGVtZW50QXR0cmlidXRlc1xuICAgICAgICA6IHt9O1xuXG4gICAgbGV0IGltYWdlUHJvcHMgPSAkc3RhdGUoe30pO1xuICAgIGxldCB0aXRsZVByb3BzID0gJHN0YXRlKHt9KTtcbiAgICBsZXQgZGVzY3JpcHRpb25Qcm9wcyA9ICRzdGF0ZSh7fSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaW1hZ2VQcm9wcyA9IHsgLi4uaW1hZ2UgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGltYWdlUHJvcHMgPSB7IGltYWdlIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRpdGxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aXRsZVByb3BzID0geyAuLi50aXRsZSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGl0bGVQcm9wcyA9IHsgdGl0bGUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uUHJvcHMgPSB7IC4uLmRlc2NyaXB0aW9uIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvblByb3BzID0geyBkZXNjcmlwdGlvbiB9O1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNzbmlwcGV0IGl0ZW1Db250ZW50KCl9XG4gICAgeyNpZiB0aXRsZVJlbmRlcmVyfVxuICAgICAgICB7QHJlbmRlciB0aXRsZVJlbmRlcmVyKHBhcmFtc1NldCl9XG4gICAgezplbHNlIGlmIHRpdGxlfVxuICAgICAgICA8VUlDbGlja2FibGVEaXZcbiAgICAgICAgICAgIGNsYXNzPVwibGlzdC1pdGVtLXRpdGxlXCJcbiAgICAgICAgICAgIGNhbGxiYWNrPXtjYWxsYmFja1RlbXBsYXRlKG9uY2xpY2tUaXRsZSl9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgVUlUaXRsZUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICA8VUlUaXRsZUNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICB7Li4udGl0bGVQcm9wc31cbiAgICAgICAgICAgICAgICAgICAgey4uLnRpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHtvbmNoYW5nZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgezplbHNlfXt0aXRsZX17L2lmfVxuICAgICAgICA8L1VJQ2xpY2thYmxlRGl2PlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIGRlc2NyaXB0aW9uUmVuZGVyZXJ9XG4gICAgICAgIHtAcmVuZGVyIGRlc2NyaXB0aW9uUmVuZGVyZXIocGFyYW1zU2V0KX1cbiAgICB7OmVsc2UgaWYgZGVzY3JpcHRpb259XG4gICAgICAgIDxVSUNsaWNrYWJsZURpdlxuICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0tZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgY2FsbGJhY2s9e2NhbGxiYWNrVGVtcGxhdGUob25jbGlja0Rlc2NyaXB0aW9uKX1cbiAgICAgICAgPlxuICAgICAgICAgICAgeyNpZiBVSURlc2NyaXB0aW9uQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgIDxVSURlc2NyaXB0aW9uQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIHsuLi5kZXNjcmlwdGlvblByb3BzfVxuICAgICAgICAgICAgICAgICAgICB7Li4uZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgICAgICAgICAge29uY2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICB7b25jbGlja31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgezplbHNlfXtkZXNjcmlwdGlvbn17L2lmfVxuICAgICAgICA8L1VJQ2xpY2thYmxlRGl2PlxuICAgIHsvaWZ9XG57L3NuaXBwZXR9XG5cbjxkaXZcbiAgICB7Li4uYWRkaXRpb25hbEVsZW1lbnRBdHRyaWJ1dGVzfVxuICAgIGNsYXNzOmlzLWNsaWNrYWJsZT17b25jbGlja31cbiAgICBjbGFzczpsaXN0LWl0ZW0tbGFzdD17bGFzdH1cbiAgICBjbGFzczpsaXN0LWl0ZW0tZmlyc3Q9e2ZpcnN0fVxuICAgIGNsYXNzOmxpc3QtaXRlbS1vZGQ9e2luZGV4ICUgMiA9PT0gMX1cbiAgICBjbGFzczpsaXN0LWl0ZW0tZXZlbj17aW5kZXggJSAyID09PSAwfVxuICAgIGNsYXNzPVwibGlzdC1pdGVtIHtjbGFzc2VzfSB7Y29tbW9uQ2xhc3N9IHtgbGlzdC1pdGVtLWF0LSR7aW5kZXh9YH1cIlxuPlxuICAgIHsjaWYgaW1hZ2V9XG4gICAgICAgIHsjaWYgaW1hZ2VSZW5kZXJlcn1cbiAgICAgICAgICAgIHtAcmVuZGVyIGltYWdlUmVuZGVyZXIocGFyYW1zU2V0KX1cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPFVJQ2xpY2thYmxlRGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0taW1hZ2VcIlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrPXtjYWxsYmFja1RlbXBsYXRlKG9uY2xpY2tJbWFnZSl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgeyNpZiBVSUltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICA8VUlJbWFnZUNvbXBvbmVudCB7Li4uaW1hZ2VQcm9wc30gLz5cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxmaWd1cmUgY2xhc3M9XCJpbWFnZSBpcy02NHg2NFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaXMtcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXtpbWFnZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9e3RpdGxlID8gdGl0bGU/LnRpdGxlIHx8IHRpdGxlIDogaW1hZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L2ZpZ3VyZT5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9VSUNsaWNrYWJsZURpdj5cbiAgICAgICAgey9pZn1cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBVSUxpc3RJdGVtQ29udGVudENvbXBvbmVudH1cbiAgICAgICAgPFVJTGlzdEl0ZW1Db250ZW50Q29tcG9uZW50IHsuLi5saXN0SXRlbUNvbnRlbnRDb21wb25lbnRQcm9wc30+XG4gICAgICAgICAgICB7QHJlbmRlciBpdGVtQ29udGVudCgpfVxuICAgICAgICA8L1VJTGlzdEl0ZW1Db250ZW50Q29tcG9uZW50PlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPFVJQ2xpY2thYmxlRGl2XG4gICAgICAgICAgICBjbGFzcz1cImxpc3QtaXRlbS1jb250ZW50XCJcbiAgICAgICAgICAgIGNhbGxiYWNrPXtjYWxsYmFja1RlbXBsYXRlKG9uY2xpY2tDb250ZW50KX1cbiAgICAgICAgPlxuICAgICAgICAgICAge0ByZW5kZXIgaXRlbUNvbnRlbnQoKX08L1VJQ2xpY2thYmxlRGl2XG4gICAgICAgID5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiAoYWxsQWN0aW9ucyAmJiBhbGxBY3Rpb25zLmxlbmd0aCkgfHwgKGFsbExpbmtzICYmIGFsbExpbmtzLmxlbmd0aCl9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW0tY29udHJvbHNcIj5cbiAgICAgICAgICAgIHsjaWYgYWxsQWN0aW9ucyAmJiBhbGxBY3Rpb25zLmxlbmd0aH1cbiAgICAgICAgICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17YWxsQWN0aW9uc30gcmlnaHQ9e3RydWV9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNpZiBhbGxMaW5rcyAmJiBhbGxMaW5rcy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgPFVJTGlua3MgdmFsdWVzPXthbGxMaW5rc30gcmlnaHQ9e3RydWV9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxpc3RJdGVtIGZyb20gXCIuL3VpLmxpc3QuaXRlbS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkRmllbGROYW1lID0gXCJpZFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIFtpdGVtcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIFthY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgW2xpbmtzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2l0ZW1DbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2xpc3RJdGVtQ29udGVudENvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbbGlzdEl0ZW1SZW5kZXJlcl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbbGlzdEl0ZW1Db21wb25lbnQgPSBVSUxpc3RJdGVtXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtsaXN0SXRlbUNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3RpdGxlUmVuZGVyZXJdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNiB9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtkZXNjcmlwdGlvblJlbmRlcmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtkZXNjcmlwdGlvbkNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbWFnZVJlbmRlcmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGltYWdlQ29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2ltYWdlQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja0NvbnRlbnRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tEZXNjcmlwdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja0ltYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrVGl0bGVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkRmllbGROYW1lID0gXCJpZFwiLFxuICAgICAgICBpdGVtcyA9IFtdLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGxpbmtzID0gW10sXG4gICAgICAgIGl0ZW1DbGFzcyA9IFwiXCIsXG4gICAgICAgIGxpc3RJdGVtQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdEl0ZW1SZW5kZXJlcixcbiAgICAgICAgbGlzdEl0ZW1Db21wb25lbnQ6IFVJTGlzdEl0ZW1Db21wb25lbnQgPSBVSUxpc3RJdGVtLFxuICAgICAgICBsaXN0SXRlbUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIHRpdGxlUmVuZGVyZXIsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50ID0gVUlUaXRsZSxcbiAgICAgICAgdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNiB9LFxuICAgICAgICBkZXNjcmlwdGlvblJlbmRlcmVyLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBpbWFnZVJlbmRlcmVyLFxuICAgICAgICBpbWFnZUNvbXBvbmVudCxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBvbmNsaWNrQ29udGVudCxcbiAgICAgICAgb25jbGlja0Rlc2NyaXB0aW9uLFxuICAgICAgICBvbmNsaWNrSW1hZ2UsXG4gICAgICAgIG9uY2xpY2tUaXRsZSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtc31cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaW5kZXggKGl0ZW1baWRGaWVsZE5hbWVdKX1cbiAgICAgICAgeyNpZiBsaXN0SXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAge0ByZW5kZXIgbGlzdEl0ZW1SZW5kZXJlcihpdGVtLCBpbmRleCl9XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxVSUxpc3RJdGVtQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgey4uLmxpc3RJdGVtQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAge2xpc3RJdGVtQ29udGVudENvbXBvbmVudH1cbiAgICAgICAgICAgICAgICB7bGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAge3RpdGxlUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAge3RpdGxlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHtkZXNjcmlwdGlvblJlbmRlcmVyfVxuICAgICAgICAgICAgICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgICAgICB7aW1hZ2VSZW5kZXJlcn1cbiAgICAgICAgICAgICAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAgICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLml0ZW1zW2luZGV4XX1cbiAgICAgICAgICAgICAgICBsaXN0QWN0aW9ucz17YWN0aW9uc31cbiAgICAgICAgICAgICAgICBsaXN0TGlua3M9e2xpbmtzfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtpdGVtc1tpbmRleF0udmFsdWV9XG4gICAgICAgICAgICAgICAgY29tbW9uQ2xhc3M9e2l0ZW1DbGFzc31cbiAgICAgICAgICAgICAgICB7aW5kZXh9XG4gICAgICAgICAgICAgICAgZmlyc3Q9e2luZGV4ID09PSAwfVxuICAgICAgICAgICAgICAgIGxhc3Q9e2luZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxfVxuICAgICAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAgICAgIHtvbmNsaWNrQ29udGVudH1cbiAgICAgICAgICAgICAgICB7b25jbGlja0Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAgICAgIHtvbmNsaWNrSW1hZ2V9XG4gICAgICAgICAgICAgICAge29uY2xpY2tUaXRsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGlzdEVtcHR5UGxhY2Vob2xkZXIgZnJvbSBcIi4vdWkubGlzdC5lbXB0eS5wbGFjZWhvbGRlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlMaXN0SXRlbSBmcm9tIFwiLi91aS5saXN0Lml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlzdEJsb2NrIGZyb20gXCIuL3VpLmxpc3QuYmxvY2suc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG5cbiAgICAvL2N1c3RvbWl6YXRpb25cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2l0ZW1zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2FjdGlvbnMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSBbbGlua3MgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthY3Rpb25zVmlzaWJsZSA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2l0ZW1zSG92ZXJhYmxlID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3dFbGxpcHNpcyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hpZGRlbkltYWdlcyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaXRlbUNsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZW1MZW5ndGhcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkRmllbGROYW1lID0gJ2lkJ11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnQgPSBVSUxpc3RFbXB0eVBsYWNlaG9sZGVyXSAtIGVtcHR5XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2xpc3RJdGVtQ29tcG9uZW50ID0gVUlMaXN0SXRlbV0gLSBpdGVtXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtsaXN0SXRlbUNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV0gLSBpdGVtIHBhcnRzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFt0aXRsZUNvbXBvbmVudFByb3BzID0ge3NpemU6IDZ9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtkZXNjcmlwdGlvbkNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW1hZ2VDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtpbWFnZUNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2hhbmdlXSAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tDb250ZW50XSAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tEZXNjcmlwdGlvbl0gICAgICAgIGNhbGxiYWNrXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tJbWFnZV0gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tUaXRsZV0gICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgICBsaW5rcyA9IFtdLFxuICAgICAgICBhY3Rpb25zVmlzaWJsZSA9IGZhbHNlLFxuICAgICAgICBpdGVtc0hvdmVyYWJsZSA9IGZhbHNlLFxuICAgICAgICBvdmVyZmxvd0VsbGlwc2lzID0gZmFsc2UsXG4gICAgICAgIGhpZGRlbkltYWdlcyA9IGZhbHNlLFxuICAgICAgICBpdGVtQ2xhc3MgPSBcIlwiLFxuICAgICAgICBpdGVtTGVuZ3RoLFxuICAgICAgICBpZEZpZWxkTmFtZSA9IFwiaWRcIixcbiAgICAgICAgZW1wdHlMaXN0UmVuZGVyZXIsXG4gICAgICAgIGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50OlxuICAgICAgICAgICAgVUlFbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudCA9IFVJTGlzdEVtcHR5UGxhY2Vob2xkZXIsXG4gICAgICAgIGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50LFxuICAgICAgICBsaXN0SXRlbUNvbnRlbnRDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0SXRlbVJlbmRlcmVyLFxuICAgICAgICBsaXN0SXRlbUNvbXBvbmVudCA9IFVJTGlzdEl0ZW0sXG4gICAgICAgIGxpc3RJdGVtQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgdGl0bGVSZW5kZXJlcixcbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA2IH0sXG4gICAgICAgIGRlc2NyaXB0aW9uUmVuZGVyZXIsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGltYWdlUmVuZGVyZXIsXG4gICAgICAgIGltYWdlQ29tcG9uZW50LFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIG9uY2hhbmdlLFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBvbmNsaWNrQ29udGVudCxcbiAgICAgICAgb25jbGlja0Rlc2NyaXB0aW9uLFxuICAgICAgICBvbmNsaWNrSW1hZ2UsXG4gICAgICAgIG9uY2xpY2tUaXRsZSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBpdGVtcy5sZW5ndGh9XG4gICAgPGRpdlxuICAgICAgICBzdHlsZT17aXRlbUxlbmd0aCA/IGAtLWxlbmd0aDogJHtpdGVtTGVuZ3RofTtgIDogXCJcIn1cbiAgICAgICAgY2xhc3M9XCJsaXN0IHtjbGFzc2VzfVwiXG4gICAgICAgIGNsYXNzOmhhcy12aXNpYmxlLXBvaW50ZXItY29udHJvbHM9e2FjdGlvbnNWaXNpYmxlfVxuICAgICAgICBjbGFzczpoYXMtaG92ZXJhYmxlLWxpc3QtaXRlbXM9e2l0ZW1zSG92ZXJhYmxlfVxuICAgICAgICBjbGFzczpoYXMtb3ZlcmZsb3ctZWxsaXBzaXM9e292ZXJmbG93RWxsaXBzaXN9XG4gICAgICAgIGNsYXNzOmhhcy1oaWRkZW4taW1hZ2VzPXtoaWRkZW5JbWFnZXN9XG4gICAgPlxuICAgICAgICA8VUlMaXN0QmxvY2tcbiAgICAgICAgICAgIHtpdGVtc31cbiAgICAgICAgICAgIHtpdGVtQ2xhc3N9XG4gICAgICAgICAgICB7bGlzdEl0ZW1Db250ZW50Q29tcG9uZW50fVxuICAgICAgICAgICAge2xpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2xpc3RJdGVtUmVuZGVyZXJ9XG4gICAgICAgICAgICB7bGlzdEl0ZW1Db21wb25lbnR9XG4gICAgICAgICAgICB7bGlzdEl0ZW1Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtpZEZpZWxkTmFtZX1cbiAgICAgICAgICAgIHt0aXRsZVJlbmRlcmVyfVxuICAgICAgICAgICAge3RpdGxlQ29tcG9uZW50fVxuICAgICAgICAgICAge3RpdGxlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25SZW5kZXJlcn1cbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICAgICAgICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2ltYWdlUmVuZGVyZXJ9XG4gICAgICAgICAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAgICAgICAgICB7aW1hZ2VDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHthY3Rpb25zfVxuICAgICAgICAgICAge2xpbmtzfVxuICAgICAgICAgICAge29uY2hhbmdlfVxuICAgICAgICAgICAge29uY2xpY2t9XG4gICAgICAgICAgICB7b25jbGlja0NvbnRlbnR9XG4gICAgICAgICAgICB7b25jbGlja0Rlc2NyaXB0aW9ufVxuICAgICAgICAgICAge29uY2xpY2tJbWFnZX1cbiAgICAgICAgICAgIHtvbmNsaWNrVGl0bGV9XG4gICAgICAgIC8+XG4gICAgPC9kaXY+XG57OmVsc2UgaWYgZW1wdHlMaXN0UmVuZGVyZXJ9XG4gICAge0ByZW5kZXIgZW1wdHlMaXN0UmVuZGVyZXIoZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wcyl9XG57OmVsc2V9XG4gICAgPFVJRW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnQgey4uLmVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHN9IC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uL2ZyYW1lL0xJQi5qc1wiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vbi5qc1wiO1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL2xpc3QvdWkubGlzdC5zdmVsdGVcIjtcblxuICAgIC8vZmllbGQgcHJvcHNcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW5wdXRTdGFydGVkXSAtIHN2ZWx0ZS1pZ25vcmUgdW51c2VkLWV4cG9ydC1sZXRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlwbGVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkXSAtIHZhbGlkYXRpb25cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZGF0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZXJyb3JzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zvcm1FcnJvcnNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9ybUxldmVsRXJyb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RlbE5hbWVdIC0gbW9kZWwgYmluZGluZ3NcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FjdGlvbk5hbWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25GaWx0ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25Tb3J0ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25QYWdlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvblNlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbklkXSAtIHByZXNlbnRhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9uVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RvclVJXSAtIHNlbGVjdG9yIFVJIHRvIGFkZCBuZXcgaXRlbSB0byBsaXN0XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzZWxlY3RvclVJUHJvcHNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpdGVtVUldIC0gbGlzdCBpdGVtIFVJIHRvIHByZXNlbnQgaW4gcmVhZG9ubHkgb3IgZWRpdGFibGUgdmFyaWFudHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1VSVByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdHJhbnNmb3JtVmFsdWVJdGVtVG9MaXN0SXRlbV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSBbXSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInNlbGVjdEZyb21Nb2RlbFwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgIHNpemUgPSA4LFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIG1vZGVsTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbk5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25GaWx0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU29ydGVyID0ge30sXG4gICAgICAgIGFjdGlvblBhZ2VyID0ge30sXG4gICAgICAgIGFjdGlvblNlYXJjaCA9IHVuZGVmaW5lZCxcbiAgICAgICAgb3B0aW9uSWQgPSBcIjpfaWRcIixcbiAgICAgICAgb3B0aW9uVGl0bGUgPSBcIjp0aXRsZVwiLFxuICAgICAgICBzZWxlY3RvclVJID0gXCJVSVNlbGVjdEZyb21Nb2RlbE9uRGVtYW5kSW5saW5lXCIsXG4gICAgICAgIHNlbGVjdG9yVUlQcm9wcyA9IHt9LFxuICAgICAgICBpdGVtVUkgPSBcIlVJTGlzdEl0ZW1cIixcbiAgICAgICAgaXRlbVVJUHJvcHMgPSB7fSxcbiAgICAgICAgdHJhbnNmb3JtVmFsdWVJdGVtVG9MaXN0SXRlbSA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogaXRlbS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaXRlbXMgPSAkc3RhdGUoW10pO1xuICAgIGNvbnN0IHRyYW5zZm9ybVZhbHVlVG9JdGVtcyA9ICh2YWwpID0+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5tYXAodHJhbnNmb3JtVmFsdWVJdGVtVG9MaXN0SXRlbSkgOiBbXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYWRkSXRlbShpdGVtKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSgkc3RhdGUuc25hcHNob3QodmFsdWUpKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZS5wdXNoKGl0ZW0pO1xuXG4gICAgICAgIGl0ZW1zID0gdHJhbnNmb3JtVmFsdWVUb0l0ZW1zKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRJdGVtSW5kZXhJblZhbHVlID0gKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5maW5kSW5kZXgoKHZhbHVlSXRlbSkgPT4gdmFsdWVJdGVtLmlkID09PSBsaXN0SXRlbS5pZCk7XG4gICAgfTtcblxuICAgIGNvbnN0IEFDVElPTlMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbihsaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IGdldEl0ZW1JbmRleEluVmFsdWUobGlzdEl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxDb3B5ID0gWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm1vdmVJdGVtKHZhbENvcHksIGl0ZW1JbmRleCwgaXRlbUluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsQ29weTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSB0cmFuc2Zvcm1WYWx1ZVRvSXRlbXModmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgIGljb246IFwiYXJyb3ctdXBcIixcbiAgICAgICAgICAgIGNvbG9yOiBcIm5vcm1hbFwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246IChsaXN0SXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IGdldEl0ZW1JbmRleEluVmFsdWUobGlzdEl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxDb3B5ID0gWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm1vdmVJdGVtKHZhbENvcHksIGl0ZW1JbmRleCwgaXRlbUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsQ29weTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSB0cmFuc2Zvcm1WYWx1ZVRvSXRlbXModmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgIGljb246IFwiYXJyb3ctZG93blwiLFxuICAgICAgICAgICAgY29sb3I6IFwibm9ybWFsXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogKGxpc3RJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gZ2V0SXRlbUluZGV4SW5WYWx1ZShsaXN0SXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNwbGljZShpdGVtSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdHJhbnNmb3JtVmFsdWVUb0l0ZW1zKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICBpY29uOiBcInRyYXNoXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJkYW5nZXJcIixcbiAgICAgICAgfSxcbiAgICBdO1xuPC9zY3JpcHQ+XG5cbjxVSUxpc3RcbiAgICBsaXN0SXRlbUNvbXBvbmVudD17Q09NUE9ORU5UUy5nZXQoaXRlbVVJKX1cbiAgICB7Li4uaXRlbVVJUHJvcHN9XG4gICAge2l0ZW1zfVxuICAgIGFjdGlvbnM9e0FDVElPTlN9XG4vPlxueyNpZiAhcmVhZG9ubHl9XG4gICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBDT01QT05FTlRTLmdldChzZWxlY3RvclVJKX1cbiAgICA8U3ZlbHRlQ29tcG9uZW50XG4gICAgICAgIHsuLi5zZWxlY3RvclVJUHJvcHN9XG4gICAgICAgIHttb2RlbE5hbWV9XG4gICAgICAgIHthY3Rpb25OYW1lfVxuICAgICAgICB7YWN0aW9uRmlsdGVyfVxuICAgICAgICB7YWN0aW9uU29ydGVyfVxuICAgICAgICB7YWN0aW9uUGFnZXJ9XG4gICAgICAgIHthY3Rpb25TZWFyY2h9XG4gICAgICAgIHtvcHRpb25JZH1cbiAgICAgICAge29wdGlvblRpdGxlfVxuICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgIHtmaWVsZG5hbWV9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgbXVsdGlwbGU9e2ZhbHNlfVxuICAgICAgICB7dmFsaWR9XG4gICAgICAgIG9ucmVzb2x2ZT17KGUpID0+IGFkZEl0ZW0oZS52YWx1ZSl9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtuYXJyb3c9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHNpemVcbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHNpemUsXG4gICAgICAgIG5hcnJvdyA9IGZhbHNlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cImNvbHVtbiB7Y2xhc3Nlc30ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIlxuICAgIGNsYXNzOmlzLW5hcnJvdz17bmFycm93fVxuICAgIHsuLi5vdGhlcnN9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBjbGFzczogY2xhc3NlcyA9IFwiXCIsIGNoaWxkcmVuLCAuLi5vdGhlcnMgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJjb2x1bW5zIHtjbGFzc2VzfVwiIHsuLi5vdGhlcnN9PlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWQgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZSA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3RhYkluZGV4PTBdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbd2lkZXNjcmVlbj1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmdWxsaGQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbWF4RGVza3RvcD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXhXaWRlc2NyZWVuPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZsdWlkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25rZXl1cF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gXCIwXCIsXG4gICAgICAgIHdpZGVzY3JlZW4gPSBmYWxzZSxcbiAgICAgICAgZnVsbGhkID0gZmFsc2UsXG4gICAgICAgIG1heERlc2t0b3AgPSBmYWxzZSxcbiAgICAgICAgbWF4V2lkZXNjcmVlbiA9IGZhbHNlLFxuICAgICAgICBmbHVpZCA9IGZhbHNlLFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIHtpZH1cbiAgICB7dGl0bGV9XG4gICAgY2xhc3M9XCJjb250YWluZXIge2NsYXNzZXN9XCJcbiAgICBjbGFzczppcy13aWRlc2NyZWVuPXt3aWRlc2NyZWVufVxuICAgIGNsYXNzOmlzLWZ1bGxoZD17ZnVsbGhkfVxuICAgIGNsYXNzOmlzLW1heC1kZXNrdG9wPXttYXhEZXNrdG9wfVxuICAgIGNsYXNzOmlzLW1heC13aWRlc2NyZWVuPXttYXhXaWRlc2NyZWVufVxuICAgIGNsYXNzOmlzLWZsdWlkPXtmbHVpZH1cbiAgICB7b25jbGlja31cbiAgICB7b25rZXl1cH1cbiAgICB7cm9sZX1cbiAgICB7dGFiSW5kZXh9XG4+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IGlkID0gXCJcIiwgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLCBjaGlsZHJlbiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGZvb3RlciB7aWR9IGNsYXNzPVwiZm9vdGVyIHtjbGFzc2VzfSBcIj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Zvb3Rlcj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3RhYkluZGV4ID0gMF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gXCIwXCIsXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIG9ua2V5dXAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiB7aWR9IGNsYXNzPVwic2VjdGlvbiB7Y2xhc3Nlc31cIiB7b25jbGlja30ge29ua2V5dXB9IHtyb2xlfSB7dGFiSW5kZXh9PlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvc2VjdGlvbj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RhZ11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyB0YWcgPSBcImRpdlwiLCBjaGlsZHJlbiB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTplbGVtZW50IHRoaXM9e3RhZ30+XG4gICAgeyNpZiBjaGlsZHJlbn17QHJlbmRlciBjaGlsZHJlbj8uKCl9ezplbHNlfTwhLS0gb3B0aW9uYWwgZmFsbGJhY2sgLS0+ey9pZn1cbjwvc3ZlbHRlOmVsZW1lbnQ+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgwKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIjAuMFwiLFxuICAgICAgICBtaW4gPSAwLFxuICAgICAgICBtYXggPSAxMDAsXG4gICAgICAgIHN0ZXAgPSAxLFxuICAgICAgICBmaWVsZG5hbWUgPSBcIm51bWJlclwiLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtbnVtYmVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAge21pbn1cbiAgICAgICAge21heH1cbiAgICAgICAge3N0ZXB9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IHsgVUlDb2x1bW5zLCBVSUNvbHVtbiB9IGZyb20gXCIuLi9sYXlvdXRcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcbiAgICBpbXBvcnQgVUlOdW1iZXIgZnJvbSBcIi4vdWkubnVtYmVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRleHRmaWVsZCBmcm9tIFwiLi4vaW5wdXQvdWkudGV4dGZpZWxkLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFVJVGl0bGUgfSBmcm9tIFwiLi4vdmFyaW91c1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcIm51bWJlcnNfbGlzdFwiLFxuICAgICAgICB2YWx1ZSA9IHt9LFxuICAgICAgICBkZWZhdWx0SXRlbVRpdGxlID0gXCJcIixcbiAgICAgICAgZGVmYXVsdEl0ZW1WYWx1ZSA9IDAsXG4gICAgICAgIGxhYmVsID0gXCJuYW1lZCBudW1iZXJzIGxpc3RcIixcbiAgICAgICAgbGFiZWxTaXplID0gNSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIm5ldyBpdGVtXCIsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgY3JlYXRlTmV3VmFsID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGRlZmF1bHRJdGVtVGl0bGUsXG4gICAgICAgICAgICBudW1iZXI6IGRlZmF1bHRJdGVtVmFsdWUsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGxldCBuZXdWYWwgPSAkc3RhdGUoY3JlYXRlTmV3VmFsKCkpO1xuXG4gICAgY29uc3QgdHJhbnNmb3JtT2JqZWN0VG9MaXN0ID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogbmFtZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogbmFtZSxcbiAgICAgICAgICAgICAgICBudW1iZXI6IHZhbHVlW25hbWVdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGxldCBsaXN0ID0gJHN0YXRlKHRyYW5zZm9ybU9iamVjdFRvTGlzdCgpKTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh2YWx1ZSwgaWQpKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbaWRdO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxpc3QgPSB0cmFuc2Zvcm1PYmplY3RUb0xpc3QoKTtcbiAgICAgICAgICAgIG9uY2hhbmdlKHsgdmFsdWUsIGZpZWxkOiBmaWVsZG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbmV3VmFsLmlkLnRyaW0oKTtcbiAgICAgICAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQobmV3VmFsLm51bWJlcik7XG4gICAgICAgIGlmIChpZCAmJiBpZCAhPT0gXCJcIiAmJiAhaXNOYU4obnVtYmVyKSAmJiAhbm90Q29tbW9uLm9iakhhcyh2YWx1ZSwgaWQpKSB7XG4gICAgICAgICAgICB2YWx1ZVtpZF0gPSBudW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdCA9IHRyYW5zZm9ybU9iamVjdFRvTGlzdCgpO1xuICAgICAgICBvbmNoYW5nZSh7IHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLCBmaWVsZDogZmllbGRuYW1lIH0pO1xuICAgICAgICBuZXdWYWwgPSBjcmVhdGVOZXdWYWwoKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPFVJVGl0bGUgdGl0bGU9e2xhYmVsfSBzaXplPXtsYWJlbFNpemV9IC8+XG57I2VhY2ggbGlzdCBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICA8VUlDb2x1bW5zIGNsYXNzPXtjbGFzc2VzfSB7ZGlzYWJsZWR9PlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTZcIj5cbiAgICAgICAgICAgIHtpdGVtLnRpdGxlfVxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTRcIj5cbiAgICAgICAgICAgIHtpdGVtLm51bWJlcn1cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICAgICAgeyNpZiAhcmVhZG9ubHl9XG4gICAgICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTJcIj5cbiAgICAgICAgICAgICAgICA8VUlCdXR0b24gaWNvbj17XCJtaW51c1wifSBhY3Rpb249eygpID0+IHJlbW92ZShpdGVtLmlkKX0gLz5cbiAgICAgICAgICAgIDwvVUlDb2x1bW4+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9VSUNvbHVtbnM+XG57L2VhY2h9XG57I2lmICFyZWFkb25seX1cbiAgICA8VUlDb2x1bW5zIGNsYXNzPXtjbGFzc2VzfT5cbiAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy02XCI+XG4gICAgICAgICAgICA8VUlUZXh0ZmllbGRcbiAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtuZXdWYWwuaWR9XG4gICAgICAgICAgICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAgICAgICAgICAgIHJlcXVpcmVkPXtmYWxzZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtNFwiPlxuICAgICAgICAgICAgPFVJTnVtYmVyIGJpbmQ6dmFsdWU9e25ld1ZhbC5udW1iZXJ9IC8+XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtMlwiPlxuICAgICAgICAgICAgPFVJQnV0dG9uIGljb249e1wicGx1c1wifSBhY3Rpb249eygpID0+IGFkZCgpfSAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgIDwvVUlDb2x1bW5zPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwicGFzc3dvcmRcIixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxpbnB1dFxuICAgIGlkPVwiZm9ybS1maWVsZC1wYXNzd29yZC17ZmllbGRuYW1lfVwiXG4gICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgdHlwZT1cInBhc3N3b3JkXCJcbiAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgYmluZDp2YWx1ZVxuICAgIHtpbnZhbGlkfVxuICAgIHtyZXF1aXJlZH1cbiAgICB7cmVhZG9ubHl9XG4gICAge2Rpc2FibGVkfVxuICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICB7Li4ub3RoZXJzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VybEZ1bGxdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHVybFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbWFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthbHRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb3JzPSdhbm9ueW1vdXMnXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZSA9IDY0XVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGVpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY29udGFpbmVkPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvdmVyZWQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcG9pbnRhYmxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25rZXl1cF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdXJsRnVsbCxcbiAgICAgICAgdXJsLFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGFsdCxcbiAgICAgICAgY29ycyA9IFwiYW5vbnltb3VzXCIsXG4gICAgICAgIHNpemUgPSA2NCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgY29udGFpbmVkID0gZmFsc2UsXG4gICAgICAgIGNvdmVyZWQgPSBmYWxzZSxcbiAgICAgICAgcG9pbnRhYmxlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2xpY2sgPSB1bmRlZmluZWQsXG4gICAgICAgIG9ua2V5dXAgPSB1bmRlZmluZWQsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjc25pcHBldCBpbWFnZUZpZ3VyZSgpfVxuICAgIDwhLS0gc3ZlbHRlLWlnbm9yZSBhMTF5X25vX25vbmludGVyYWN0aXZlX2VsZW1lbnRfaW50ZXJhY3Rpb25zIC0tPlxuICAgIDxmaWd1cmVcbiAgICAgICAgY2xhc3M9XCJpbWFnZSB7Y2xhc3Nlc30geyF3aWR0aCAmJiAhaGVpZ2h0XG4gICAgICAgICAgICA/IGlzTmFOKHNpemUpXG4gICAgICAgICAgICAgICAgPyBgaXMtJHtzaXplfWBcbiAgICAgICAgICAgICAgICA6IGBpcy0ke3NpemV9eCR7c2l6ZX1gXG4gICAgICAgICAgICA6ICcnfVwiXG4gICAgICAgIGNsYXNzOmlzLWNvbnRhaW5lZD17Y29udGFpbmVkfVxuICAgICAgICBjbGFzczppcy1jb3ZlcmVkPXtjb3ZlcmVkfVxuICAgICAgICBjbGFzczppcy1jbGlja2FibGU9eyhvbmNsaWNrICYmIHBvaW50YWJsZSAhPT0gZmFsc2UpIHx8IHBvaW50YWJsZX1cbiAgICAgICAgc3R5bGU9eyh3aWR0aCA/IGB3aWR0aDogJHt3aWR0aH07YCA6IFwiXCIpICtcbiAgICAgICAgICAgIChoZWlnaHQgPyBgaGVpZ2h0OiAke2hlaWdodH07YCA6IFwiXCIpfVxuICAgID5cbiAgICAgICAgPGltZ1xuICAgICAgICAgICAge29uY2xpY2t9XG4gICAgICAgICAgICB7b25rZXl1cH1cbiAgICAgICAgICAgIGNsYXNzPVwiXCJcbiAgICAgICAgICAgIGFsdD17YWx0IHx8IHRpdGxlfVxuICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgICAgc3JjPXt1cmwgfHwgaW1hZ2V9XG4gICAgICAgICAgICBjcm9zc09yaWdpbj17Y29yc31cbiAgICAgICAgLz5cbiAgICA8L2ZpZ3VyZT5cbnsvc25pcHBldH1cblxueyNpZiB1cmxGdWxsfVxuICAgIDxhIGhyZWY9e3VybEZ1bGx9IHRpdGxlPXt0aXRsZSB8fCBhbHR9IHtvbmNsaWNrfT5cbiAgICAgICAge0ByZW5kZXIgaW1hZ2VGaWd1cmUoKX1cbiAgICA8L2E+XG57OmVsc2V9XG4gICAge0ByZW5kZXIgaW1hZ2VGaWd1cmUoKX1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vbGlzdC91aS5saXN0LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUltYWdlIGZyb20gXCIuLi9pbWFnZS91aS5pbWFnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcblxuICAgIC8vXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdmFyaWFudHNdIC0gW1xuYXJyYXkgb2YgZ3JvdXBzXG57XG5pZDpudW1iZXIsXG50aXRsZTpzdHJpbmd8b2JqZWN0LFxuaW1hZ2U6c3RyaW5nfG9iamVjdCxcbnZhcmlhbnRzID0gW1xuYXJyYXkgb2YgdmFsdWVzIHZhcmlhbnRzIGluIGdyb3VwXG57XG5pZDpudW1iZXIsXG50aXRsZTpzdHJpbmd8b2JqZWN0LFxuZGVzY3JpcHRpb246c3RyaW5nfG9iamVjdCxcbmltYWdlOnN0cmluZ3xvYmplY3QsXG52YWx1ZTpvYmplY3Rcbn1dXG59XG5dXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlIC0gbXVsdGlwbGUgJiYgbXVsdGlwbGUgaW4gZ3JvdXBcbntcbmFycmF5IG9mIGFycmF5cyBvZiBzZWxlY3RlZCB2YWx1ZXMgaW4gZ3JvdXBcbmlmIG5vIHNlbGVjdGlvbiBncm91cCBzaG91bGQgYmUgZW1wdHkgYXJyYXlcbltncm91cElkXTogWy4uLnZhcmlhbnRzSWRdXG59XG5tdWx0aXBsZSAmJiBvbmUgaW4gZ3JvdXBcbntcbltncm91cElkXTogdmFyaWFudElkXG59XG5vbmx5IG9uZSAobm90IG11bHRpcGxlICYmIG9uZSBpbiBncm91cClcbntcbmdyb3VwOiBncm91cElkXG52YWx1ZTogdmFyaWFudElkXG59XG4gICAgICogQHByb3BlcnR5IHthbnl9IHRpdGxlXG4gICAgICogQHByb3BlcnR5IHthbnl9IGltYWdlXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtidXR0b25Qcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdGl0bGVDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaW1hZ2VDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3RDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtnZXRVSUl0ZW1dXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtnZXREZWZhdWx0SXRlbVN1YmxpbWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt1aU9uXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdWlPZmZdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZpZWxkbmFtZSA9IFwicmFkaW8tYnV0dG9uc1wiLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGltYWdlLFxuICAgICAgICBidXR0b25Qcm9wcyA9IHt9LFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDUgfSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlLFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICByZXR1cm5WYXJpYW50ID0gZmFsc2UsXG4gICAgICAgIGdldFVJSXRlbSA9ICh2YWx1ZUlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudHNCdXR0b25zLmZpbmQoKGJ0blZhbCkgPT4gYnRuVmFsLnZhbHVlID09PSB2YWx1ZUlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgVUlJdGVtSGFzVmFsdWUgPSAoaXRlbSwgdmFsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS52YWx1ZSA9PSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERlZmF1bHRJdGVtU3VibGltZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50c1swXS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdWlPbiA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLmNvbG9yID0gXCJzdWNjZXNzXCI7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSxcbiAgICAgICAgdWlPZmYgPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5jb2xvciA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpbml0VmFyaWFudHNCdXR0b24oKTtcbiAgICAgICAgc2VsZWN0RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgbGV0IHZhcmlhbnRzQnV0dG9ucyA9IFtdLFxuICAgICAgICBsaXN0SXRlbXMgPSAkc3RhdGUoW10pO1xuXG4gICAgZnVuY3Rpb24gaW5pdFZhcmlhbnRzQnV0dG9uKCkge1xuICAgICAgICB2YXJpYW50c0J1dHRvbnMgPSB2YXJpYW50cy5tYXAoKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmJ1dHRvblByb3BzLCAuLi52YXJpYW50IH07XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0SXRlbXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHsgdmFsdWVzOiB2YXJpYW50c0J1dHRvbnMgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q3VycmVudFZhcmlhbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5maW5kKCh2YSkgPT4gdmEudmFsdWUgPT09IHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICBmdW5jdGlvbiB0b2dnbGUoc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBsZXQgdWkgPSB7XG4gICAgICAgICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2ZmOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHVpLm9mZiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdWkub24gPSBzZWxlY3RlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgdXBkYXRlVUkodWkpO1xuICAgICAgICAvL1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHJldHVyblZhcmlhbnQgPyBnZXRDdXJyZW50VmFyaWFudCgpIDogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVVSShjaGFuZ2VzKSB7XG4gICAgICAgIGZvciAobGV0IHQgaW4gdmFyaWFudHNCdXR0b25zKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNoYW5nZXMub2ZmICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgVUlJdGVtSGFzVmFsdWUodmFyaWFudHNCdXR0b25zW3RdLCBjaGFuZ2VzLm9mZilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhcmlhbnRzQnV0dG9uc1t0XSA9IHVpT2ZmKHZhcmlhbnRzQnV0dG9uc1t0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNoYW5nZXMub24gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICBVSUl0ZW1IYXNWYWx1ZSh2YXJpYW50c0J1dHRvbnNbdF0sIGNoYW5nZXMub24pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXJpYW50c0J1dHRvbnNbdF0gPSB1aU9uKHZhcmlhbnRzQnV0dG9uc1t0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1zWzBdLmRlc2NyaXB0aW9uLnZhbHVlcyA9IHZhcmlhbnRzQnV0dG9ucztcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiBzZWxlY3REZWZhdWx0KCkge1xuICAgICAgICBpZiAodmFyaWFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZlZhbHVlID0gZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKGRlZlZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVUkoeyBvbjogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBTdmVsdGVDb21wb25lbnQgPSAkZGVyaXZlZChsaXN0Q29tcG9uZW50KTtcbjwvc2NyaXB0PlxuXG48U3ZlbHRlQ29tcG9uZW50XG4gICAgey4uLmxpc3RDb21wb25lbnRQcm9wc31cbiAgICBpdGVtcz17bGlzdEl0ZW1zfVxuICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcz17e1xuICAgICAgICAuLi5kZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzLFxuICAgICAgICBhY3Rpb24oZXZlbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICB0b2dnbGUodmFsdWUpO1xuICAgICAgICB9LFxuICAgIH19XG4gICAge2ltYWdlQ29tcG9uZW50fVxuICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKDEwKSxcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbWF4ID0gMTAwLFxuICAgICAgICBzdGVwID0gMSxcbiAgICAgICAgdGlja21hcmtzID0gZmFsc2UsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJyYW5nZVwiLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcblxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXJhbmdlLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCBiaWctbnVtYmVyIHNsaWRlciBoYXMtb3V0cHV0IHtzaXplXG4gICAgICAgICAgICA/IGBpcy0ke3NpemV9YFxuICAgICAgICAgICAgOiAnJ30ge2NvbG9yID8gYGlzLSR7Y29sb3J9YCA6ICcnfSAge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICB7bWlufVxuICAgICAgICB7bWF4fVxuICAgICAgICB7c3RlcH1cbiAgICAgICAgbGlzdD1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX0tdGlja21hcmtzXCJcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuICAgIDxvdXRwdXQgZm9yPVwiZm9ybS1maWVsZC1yYW5nZS17ZmllbGRuYW1lfVwiPnt2YWx1ZX08L291dHB1dD5cbiAgICB7I2lmIEFycmF5LmlzQXJyYXkodGlja21hcmtzKSAmJiB0aWNrbWFya3MubGVuZ3RofVxuICAgICAgICA8ZGF0YWxpc3QgaWQ9XCJmb3JtLWZpZWxkLXJhbmdlLXtmaWVsZG5hbWV9LXRpY2ttYXJrc1wiPlxuICAgICAgICAgICAgeyNlYWNoIHRpY2ttYXJrcyBhcyB0aWNrbWFya31cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXt0aWNrbWFyay52YWx1ZX0gbGFiZWw9e3RpY2ttYXJrLmxhYmVsfT48L29wdGlvbj5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kYXRhbGlzdD5cbiAgICB7L2lmfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSVNlbGVjdE9wdGlvbiBmcm9tIFwiLi91aS5zZWxlY3Qub3B0aW9uLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt2YWx1ZSA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFt2YXJpYW50cyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXIgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtlbXB0eVZhbHVlRW5hYmxlZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSAgW2VtcHR5VmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtlbXB0eVZhbHVlVGl0bGUgPSBcIm5vLXNlbGVjdGlvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lPVwic2VsZWN0LW11bHRpcGxlXCJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWQgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3dzID0gOF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2UgPSAoe3ZhbHVlOmFycmF5IG9mIHN0cmluZ3xudW1iZXIsIGZpZWxkOnN0cmluZywgdmFyaWFudHM6YXJyYXkgb2Ygb2JqZWN0fSk9PnRydWVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gW10sXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZW1wdHlWYWx1ZVRpdGxlID0gXCJuby1zZWxlY3Rpb25cIixcbiAgICAgICAgZW1wdHlWYWx1ZUVuYWJsZWQgPSB0cnVlLFxuICAgICAgICBlbXB0eVZhbHVlLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInNlbGVjdC1tdWx0aXBsZVwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHJvd3MgPSA4LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGxhc3RWYWx1ZSA9ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSk7XG5cbiAgICBmdW5jdGlvbiBpc0NsZWFyVmFsdWVNYWNybyhwbGFpblZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwbGFpblZhbHVlLmluY2x1ZGVzKFVJQ29tbW9uLkNMRUFSX01BQ1JPKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RlZE9wdGlvbnNWYWx1ZXMoZXYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZXYuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKGVsKSA9PlxuICAgICAgICAgICAgdHlwZW9mIGVsLl9fdmFsdWUgIT09IFwidW5kZWZpbmVkXCIgPyBlbC5fX3ZhbHVlIDogZWwudmFsdWVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbXB0eVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVtcHR5VmFsdWUgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gVUlDb21tb24uQ0xFQVJfTUFDUk9cbiAgICAgICAgICAgIDogZW1wdHlWYWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZFRvVmFyaWFudChpZCkge1xuICAgICAgICByZXR1cm4gdmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5pZCA9PSBpZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVJZHNUb1ZhcmlhbnRzKCkge1xuICAgICAgICBjb25zdCBldiA9IGdldEVtcHR5VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmZpbHRlcigoaWQpID0+IGlkICE9PSBldikubWFwKGlkVG9WYXJpYW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbklucHV0KGV2KSB7XG4gICAgICAgIGxldCBzZWxlY3RlZElkcyA9IGdldFNlbGVjdGVkT3B0aW9uc1ZhbHVlcyhldi5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGlzQ2xlYXJWYWx1ZU1hY3JvKHNlbGVjdGVkSWRzKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHNlbGVjdGVkSWRzO1xuICAgICAgICB2YWx1ZSA9IHNlbGVjdGVkSWRzO1xuICAgICAgICBpZiAobm90Q29tbW9uLmNvbXBhcmVUd29BcnJheXMobmV3VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhcmlhbnRzOiB2YWx1ZUlkc1RvVmFyaWFudHMoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IHNlbGVjdGVkVmFyaWFudHMgPSAkZGVyaXZlZChcbiAgICAgICAgdmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZUlkc1RvVmFyaWFudHModmFsdWUpIDogW11cbiAgICApO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGxldCBVSV9DTEFTU0VTID0gJGRlcml2ZWQoXG4gICAgICAgIFtzaXplLCBjb2xvcl1cbiAgICAgICAgICAgIC5maWx0ZXIoKHZhbCkgPT4gdmFsKVxuICAgICAgICAgICAgLm1hcCgodmFsKSA9PiBgaXMtJHt2YWx9YClcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKVxuICAgICk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICB7I2lmIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aH1cbiAgICAgICAgeyNlYWNoIHNlbGVjdGVkVmFyaWFudHMgYXMgc2VsZWN0ZWRWYXJpYW50fVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtci0yXCI+eyRMT0NBTEVbc2VsZWN0ZWRWYXJpYW50LnRpdGxlXX08L3NwYW4+XG4gICAgICAgIHsvZWFjaH1cbiAgICB7OmVsc2UgaWYgZW1wdHlWYWx1ZUVuYWJsZWR9XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibXItMlwiPnskTE9DQUxFW2VtcHR5VmFsdWVUaXRsZV19PC9zcGFuPlxuICAgIHsvaWZ9XG57OmVsc2V9XG4gICAgPGRpdiBjbGFzcz1cInNlbGVjdCBpcy1tdWx0aXBsZSB7VUlfQ0xBU1NFU30ge2NsYXNzZXN9IFwiPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICBtdWx0aXBsZT1cInRydWVcIlxuICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXNlbGVjdC17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBvbmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgb25jaGFuZ2U9e29uSW5wdXR9XG4gICAgICAgICAgICBvbmJsdXI9e29uSW5wdXR9XG4gICAgICAgICAgICB7dmFsdWV9XG4gICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHNpemU9e3Jvd3N9XG4gICAgICAgICAgICB7Li4ub3RoZXJzfVxuICAgICAgICA+XG4gICAgICAgICAgICB7I2lmIGVtcHR5VmFsdWVFbmFibGVkfVxuICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dHlwZW9mIGVtcHR5VmFsdWUgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gVUlDb21tb24uQ0xFQVJfTUFDUk9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZW1wdHlWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2VtcHR5VmFsdWVUaXRsZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50ICh2YXJpYW50LmlkKX1cbiAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb24gdmFsdWU9e3ZhcmlhbnQuaWR9IHRpdGxlPXt2YXJpYW50LnRpdGxlfSAvPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCJjb25zdCBERUZBVUxUX1NUQVRVU19TVUNDRVNTID0gXCJva1wiO1xuY29uc3QgREVGQVVMVF9TVEFUVVNfRVJST1IgPSBcImVycm9yXCI7XG5cbmNvbnN0IE5BVklHQVRJT05fREVMQVlfU0hPUlQgPSA1MDA7XG5jb25zdCBOQVZJR0FUSU9OX0RFTEFZX05PUk1BTCA9IDE1MDA7XG5jb25zdCBOQVZJR0FUSU9OX0RFTEFZX0xPTkcgPSA1MDAwO1xuXG5jb25zdCBOQVZJR0FUSU9OX0RFTEFZUyA9IHtcbiAgICBTSE9SVDogTkFWSUdBVElPTl9ERUxBWV9TSE9SVCxcbiAgICBOT1JNQUw6IE5BVklHQVRJT05fREVMQVlfTk9STUFMLFxuICAgIExPTkc6IE5BVklHQVRJT05fREVMQVlfTE9ORyxcbn07XG5cbmNvbnN0IE5BVklHQVRJT05fREVMQVlfREVGQVVMVCA9IE5BVklHQVRJT05fREVMQVlfTk9STUFMO1xuXG5leHBvcnQge1xuICAgIERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MsXG4gICAgREVGQVVMVF9TVEFUVVNfRVJST1IsXG4gICAgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxULFxuICAgIE5BVklHQVRJT05fREVMQVlTLFxufTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbiAgICBpbXBvcnQgVUlTZWxlY3QgZnJvbSBcIi4vdWkuc2VsZWN0LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuICAgIGltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vZnJhbWUvY29uc3RcIjtcblxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBjb25zdCBERUZBVUxUX0FQSV9NT0RFTF9HRVRURVIgPSAoXG4gICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgYWN0aW9uRmlsdGVyLFxuICAgICAgICBhY3Rpb25Tb3J0ZXIsXG4gICAgICAgIGFjdGlvblBhZ2VyLFxuICAgICAgICBhY3Rpb25TZWFyY2hcbiAgICApID0+IHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vblxuICAgICAgICAgICAgLmdldEFwcCgpXG4gICAgICAgICAgICAuZ2V0TW9kZWwobW9kZWxOYW1lKVxuICAgICAgICAgICAgLnNldEZpbHRlcihhY3Rpb25GaWx0ZXIpXG4gICAgICAgICAgICAuc2V0U29ydGVyKGFjdGlvblNvcnRlcilcbiAgICAgICAgICAgIC5zZXRQYWdlcihhY3Rpb25QYWdlcilcbiAgICAgICAgICAgIC5zZXRTZWFyY2goYWN0aW9uU2VhcmNoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgREVGQVVMVF9BUElfUkVRVUVTVCA9IChhcGlNb2RlbCwgYWN0aW9uTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gYXBpTW9kZWxbYCRgICsgYWN0aW9uTmFtZV0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW1wdHlWYWx1ZVRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW1wdHlWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbXB0eVZhbHVlRW5hYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW21vZGVsTmFtZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FjdGlvbk5hbWVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25GaWx0ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25Tb3J0ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25QYWdlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvblNlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbklkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9uVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmV0dXJuVmFyaWFudF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2UgPSAoe3ZhbHVlOmFycmF5IG9mIHN0cmluZ3xudW1iZXIsIGZpZWxkOnN0cmluZywgdmFyaWFudHM6YXJyYXkgb2Ygb2JqZWN0fSk9PnRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uZXJyb3IgPSAobWVzc2FnZTpzdHJpbmcpOnZvaWRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RlbE5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25OYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uRmlsdGVyID0ge30sXG4gICAgICAgIGFjdGlvblNvcnRlciA9IHt9LFxuICAgICAgICBhY3Rpb25QYWdlciA9IHt9LFxuICAgICAgICBhY3Rpb25TZWFyY2ggPSB1bmRlZmluZWQsXG4gICAgICAgIG9wdGlvbklkID0gXCI6X2lkXCIsXG4gICAgICAgIG9wdGlvblRpdGxlID0gXCI6dGl0bGVcIixcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgYXBpTW9kZWxHZXR0ZXIgPSBERUZBVUxUX0FQSV9NT0RFTF9HRVRURVIsXG4gICAgICAgIGFwaVJlcXVlc3QgPSBERUZBVUxUX0FQSV9SRVFVRVNULFxuICAgICAgICByZXR1cm5WYXJpYW50ID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmVycm9yID0gKCkgPT4ge30sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFyZ3VtZW50c1NldFByb3ZpZGVkKCkge1xuICAgICAgICByZXR1cm4gbW9kZWxOYW1lICYmIGFjdGlvbk5hbWUgJiYgYWN0aW9uRmlsdGVyO1xuICAgIH1cblxuICAgIGxldCBsb2FkZWQgPSAkc3RhdGUoZmFsc2UpO1xuICAgIGxldCB2YXJpYW50cyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IHJlc3VsdHNMaXN0ID0gW107XG4gICAgbGV0IHVpRGlzYWJsZWQgPSAkZGVyaXZlZChkaXNhYmxlZCB8fCAhbG9hZGVkKTtcblxuICAgIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYXJndW1lbnRzU2V0UHJvdmlkZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGFwaU1vZGVsR2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uU29ydGVyLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25QYWdlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uU2VhcmNoXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9uZXJyb3IocmVzcG9uc2UuZXJyb3JzIHx8IFtyZXNwb25zZS5tZXNzYWdlXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNMaXN0ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhcmlhbnRzID0gcmVzdWx0c0xpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm90UGF0aC5nZXQob3B0aW9uSWQsIGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5vdFBhdGguZ2V0KG9wdGlvblRpdGxlLCBpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIGlmIChyZXR1cm5WYXJpYW50KSB7XG4gICAgICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFyaWFudHMuZmluZCgoaXRtKSA9PiBpdG0uaWQgPT09IGRhdGEudmFsdWUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvbmNoYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlTZWxlY3RcbiAgICB7dmFsdWV9XG4gICAge3ZhcmlhbnRzfVxuICAgIGNsYXNzPXtjbGFzc2VzfVxuICAgIGRpc2FibGVkPXt1aURpc2FibGVkfVxuICAgIG9uY2hhbmdlPXtvbkNoYW5nZX1cbiAgICBsb2FkaW5nPXshbG9hZGVkfVxuICAgIHsuLi5vdGhlcnN9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgXCJidWxtYS1zd2l0Y2hcIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcbiAgICBpbXBvcnQgVUlCb29sZWFuIGZyb20gXCIuLi92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbGFiZWwgPSBcIlwiLFxuICAgICAgICBoaWRlTGFiZWwgPSBmYWxzZSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInN3aXRjaFwiLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFjdE9uID0gW1wib25ibHVyXCIsIFwib25pbnB1dFwiXSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgcmVhY3RPbi5mb3JFYWNoKChldmVudE5hbWUpID0+IChvcHRpb25hbFByb3BzW2V2ZW50TmFtZV0gPSBvbmlucHV0KSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPFVJQm9vbGVhbiBMQ19UUlVFPXtsYWJlbH0gTENfRkFMU0U9e2xhYmVsfSB7dmFsdWV9IC8+XG57OmVsc2V9XG4gICAgeyNpZiAhbGFiZWwgJiYgIWhpZGVMYWJlbH1cbiAgICAgICAgPFVJQm9vbGVhbiB2YWx1ZT17ZmFsc2V9IC8+XG4gICAgey9pZn1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwic3dpdGNoIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6Y2hlY2tlZD17dmFsdWV9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbiAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiIGZvcj1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9XCI+XG4gICAgICAgIHsjaWYgIWhpZGVMYWJlbH1cbiAgICAgICAgICAgIHsjaWYgbGFiZWx9XG4gICAgICAgICAgICAgICAgeyRMT0NBTEVbbGFiZWxdfVxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxVSUJvb2xlYW4gdmFsdWU9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9pZn1cbiAgICA8L2xhYmVsPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4vdWkubGFiZWwuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIGltcG9ydCBcImJ1bG1hLXN3aXRjaFwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic3dpdGNoXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uYmx1clwiLCBcIm9uaW5wdXRcIl0sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIiBpcy1yb3VuZGVkIFwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFkZElkKHZhcklkKSB7XG4gICAgICAgIGlmICghdmFsdWUuaW5jbHVkZXModmFySWQpKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhcklkKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1JZCh2YXJJZCkge1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXModmFySWQpKSB7XG4gICAgICAgICAgICB2YWx1ZS5zcGxpY2UodmFsdWUuaW5kZXhPZih2YXJJZCksIDEpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGV2ZW50RGF0YSwgZXYpIHtcbiAgICAgICAgY29uc3QgdmFySWQgPSBldi50YXJnZXQuaWQuc3BsaXQoXCItdmFyaWFudC1cIikuYXQoLTEpO1xuICAgICAgICBldi50YXJnZXQuY2hlY2tlZCA/IGFkZElkKHZhcklkKSA6IHJlbUlkKHZhcklkKTtcbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWU6ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIG9uY2hhbmdlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG9uQ2hhbmdlKTtcbiAgICAgICAgcmVhY3RPbi5mb3JFYWNoKChldmVudE5hbWUpID0+IChvcHRpb25hbFByb3BzW2V2ZW50TmFtZV0gPSBvbmlucHV0KSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgeyNpZiB2YWx1ZX1cbiAgICAgICAge3ZhcmlhbnRzXG4gICAgICAgICAgICAuZmlsdGVyKCh2YXJpYW50KSA9PiB2YWx1ZS5pbmNsdWRlcyh2YXJpYW50LmlkKSlcbiAgICAgICAgICAgIC5tYXAoKHZhcmlhbnQpID0+IHZhcmlhbnQudGl0bGUpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfVxuICAgIHsvaWZ9XG57OmVsc2V9XG4gICAgeyNlYWNoIHZhcmlhbnRzIGFzIHZhcmlhbnQgKHZhcmlhbnQuaWQpfVxuICAgICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoLWxpc3QtaXRlbVwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInN3aXRjaCB7Y2xhc3Nlc30ge3ZhcmlhbnQudHlwZVxuICAgICAgICAgICAgICAgICAgICA/IGBpcy0ke3ZhcmlhbnQudHlwZX1gXG4gICAgICAgICAgICAgICAgICAgIDogJyd9XCJcbiAgICAgICAgICAgICAgICBpZD1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZS5pbmNsdWRlcyh2YXJpYW50LmlkKX1cbiAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfS12YXJpYW50LXt2YXJpYW50LmlkfVwiXG4gICAgICAgICAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfS12YXJpYW50LXt2YXJpYW50LmlkfVwiXG4gICAgICAgICAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgICAgIGNsYXNzPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgIGZvcj1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICBsYWJlbD17dmFyaWFudC50aXRsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgeyBVSUNvbHVtbiwgVUlDb2x1bW5zIH0gZnJvbSBcIi4uL2xheW91dFwiO1xuICAgIGltcG9ydCBVSVNlbGVjdE9wdGlvbiBmcm9tIFwiLi91aS5zZWxlY3Qub3B0aW9uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGNsZWFyVmFsdWVGcm9tRGVhZFZhcmlhbnRzKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbTENfQUREID0gXCJub3Qtbm9kZTphZGRfbGFiZWxcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW0xDX1NFTEVDVF9GUk9NX0xJU1QgPSBcIm5vdC1ub2RlOnNlbGVjdF9mcm9tX2xpc3RfbGFiZWxcIl1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PHN0cmluZ3xudW1iZXI+fSBbdmFsdWVdIC0gbGlzdCBvZiBpdGVtIGlkc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8b2JqZWN0Pn0gW3ZhcmlhbnRzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lID0gJ3RhZyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHkgPSBmYWxzZV0gLSBleHBvcnQgbGV0IHJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2JlZm9yZUFkZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZ2V0SXRlbUlkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtnZXRJdGVtVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2dldEl0ZW1UeXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtidWlsZEl0ZW1dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIExDX0FERCA9IFwibm90LW5vZGU6YWRkX2xhYmVsXCIsXG4gICAgICAgIExDX1NFTEVDVF9GUk9NX0xJU1QgPSBcIm5vdC1ub2RlOnNlbGVjdF9mcm9tX2xpc3RfbGFiZWxcIixcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoW10pLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRhZ1wiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGJlZm9yZUFkZCA9ICgvKnZhcmlhbnQsIHZhcmlhbnRzKi8pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtSWQgPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnQuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEl0ZW1UaXRsZSA9ICh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudC50aXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgZ2V0SXRlbVR5cGUgPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnQ/LnR5cGUgPz8gXCJpbmZvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1aWxkSXRlbSA9ICh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBnZXRJdGVtSWQodmFyaWFudCksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGdldEl0ZW1UaXRsZSh2YXJpYW50KSxcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRJdGVtVHlwZSh2YXJpYW50KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gdmFyaWFudElkVG9WYXJpYW50KGlkKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiBnZXRJdGVtSWQodmFyaWFudCkgPT0gaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZUV2ZW50KCkge1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgaWQgPSBlLmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pZDtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHZhbHVlLmluZGV4T2YoaWQpLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGlkID0gZS5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcInNlbGVjdFwiKS52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRJZFRvVmFyaWFudChpZCk7XG4gICAgICAgIGlmICghdmFyaWFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmVmb3JlQWRkKHZhcmlhbnQsIHZhcmlhbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAmJiB2YWx1ZS5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goaWQpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyVmFsdWVGcm9tRGVhZFZhcmlhbnRzKCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcih2YXJpYW50SWRUb1ZhcmlhbnQpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLypcbml0ZW0gPSB7XG4gIGlkLCAgICAgICAgLy91bmlxdWVcbiAgdGl0bGUsICAgICAvL3NvbWUgdGV4dFxuICB0eXBlICAgICAgIC8vZm9yIGNvbG9yaW5nIGl0ZW1zLCB1c3VhbCBodG1sIHRlbXBsYXRlIG5hbWVzIGRhbmdlciwgc3VjY2VzcywgZXRjXG59XG4qL1xuICAgIGxldCBpdGVtcyA9ICRkZXJpdmVkKFxuICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgLm1hcCh2YXJpYW50SWRUb1ZhcmlhbnQpXG4gICAgICAgICAgICAuZmlsdGVyKCh2YXJpYW50KSA9PiB2YXJpYW50KVxuICAgICAgICAgICAgLm1hcChidWlsZEl0ZW0pXG4gICAgKTtcbjwvc2NyaXB0PlxuXG48VUlDb2x1bW5zIGNsYXNzPXtjbGFzc2VzfT5cbiAgICA8VUlDb2x1bW4+XG4gICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXgtMSB0YWcgaXMte2l0ZW0udHlwZX1cIlxuICAgICAgICAgICAgICAgID57JExPQ0FMRVtpdGVtLnRpdGxlXX1cbiAgICAgICAgICAgICAgICB7I2lmICFyZWFkb25seX1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cImRlbGV0ZSBidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1pZD17aXRlbS5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZGVsZXRlIGlzLXNtYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3JlbW92ZX1cbiAgICAgICAgICAgICAgICAgICAgPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L1VJQ29sdW1uPlxuXG4gICAgeyNpZiAhcmVhZG9ubHl9XG4gICAgICAgIDxVSUNvbHVtbj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3QgaXMtc21hbGxcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXstMX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e0xDX1NFTEVDVF9GUk9NX0xJU1R9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhcmlhbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3ZhcmlhbnQudGl0bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxVSUJ1dHRvblxuICAgICAgICAgICAgICAgIGNvbG9yPXtcInByaW1hcnlcIn1cbiAgICAgICAgICAgICAgICBzaXplPXtcInNtYWxsXCJ9XG4gICAgICAgICAgICAgICAgYWN0aW9uPXthZGR9XG4gICAgICAgICAgICAgICAgdGl0bGU9e0xDX0FERH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgey9pZn1cbjwvVUlDb2x1bW5zPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCIrNyA5ODcgNjU0LTMyLTEwXCIsXG4gICAgICAgIHBhdHRlcm4gPSBcIlxcXFwrWzAtOV17MSwzfVxcXFxzK1swLTldezN9XFxcXHMrWzAtOV17M30tWzAtOV17Mn0tWzAtOV17Mn1cIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJ0ZWxlcGhvbmVcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZX08L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC10ZWxlcGhvbmUte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwidGVsXCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIHtwYXR0ZXJufVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVUlDb250cm9sIH0gZnJvbSBcIi4uL2lucHV0XCI7XG4gICAgaW1wb3J0IFVJRmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLmZpZWxkLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRhZ1ZhbHVlIGZyb20gXCIuL3VpLnRhZy52YWx1ZS5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtvYmplY3R9ICAgIFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgdmFsdWVzID0gW11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbZ3JvdXBlZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW211bHRpbGluZSA9IHRydWVdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSAgIFByb3BzXG4gICAgICovXG4gICAgbGV0IHsgdmFsdWVzID0gW10sIGdyb3VwZWQgPSB0cnVlLCBtdWx0aWxpbmUgPSB0cnVlIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIHZhbHVlcy5sZW5ndGh9XG4gICAgPFVJRmllbGQge2dyb3VwZWR9IHttdWx0aWxpbmV9PlxuICAgICAgICB7I2VhY2ggdmFsdWVzIGFzIHRhZ1ZhbHVlUHJvcHN9XG4gICAgICAgICAgICA8VUlDb250cm9sPlxuICAgICAgICAgICAgICAgIDxVSVRhZ1ZhbHVlIHsuLi50YWdWYWx1ZVByb3BzfSAvPlxuICAgICAgICAgICAgPC9VSUNvbnRyb2w+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L1VJRmllbGQ+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5PHN0cmluZz59ICBbZXJyb3JzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvdyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkID0gJ2Vycm9ycy1saXN0J11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZXJyb3JzID0gW10sXG4gICAgICAgIHNob3cgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBpZCA9IFwiZXJyb3JzLWxpc3RcIixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBBcnJheS5pc0FycmF5KGVycm9ycykgJiYgZXJyb3JzLmxlbmd0aH1cbiAgICA8cCBjbGFzcz1cImhlbHAge2NsYXNzZXN9XCIge2lkfT5cbiAgICAgICAgeyNpZiBzaG93fVxuICAgICAgICAgICAgeyNlYWNoIGVycm9ycyBhcyBlcnJvciwgaW5kZXh9XG4gICAgICAgICAgICAgICAgPHNwYW4+eyRMT0NBTEVbZXJyb3JdfTwvc3Bhbj57aW5kZXggPCBlcnJvcnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICA/IFwiLCBcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHs6ZWxzZX0mbmJzcDt7L2lmfVxuICAgIDwvcD5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG4gICAgaW1wb3J0IHsgVUlDb250ZW50IH0gZnJvbSBcIi4uL2Jsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbaWQgPSBcInVzZXJDYXJkXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgICAgIFtpbWFnZSA9IFwiaHR0cHM6Ly9idWxtYS5pby9pbWFnZXMvcGxhY2Vob2xkZXJzLzMyeDMyLnBuZ1wiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbdXNlcm5hbWUgPSBcIkpvaG4gRG9lXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgICAgIFtyb2xlID0gXCJhZG1pblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbZXZlbnRzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtyZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50c10gLSByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbb25VcGRhdGUgPSAoZGF0YSk9PiB7dXNlcm5hbWU9ZGF0YS51c2VybmFtZTsgcm9sZSA9IGRhdGEucm9sZTt9XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwidXNlckNhcmRcIixcbiAgICAgICAgaW1hZ2UgPSBcImh0dHBzOi8vYnVsbWEuaW8vaW1hZ2VzL3BsYWNlaG9sZGVycy8zMngzMi5wbmdcIixcbiAgICAgICAgdXNlcm5hbWUgPSBcIkpvaG4gRG9lXCIsXG4gICAgICAgIHJvbGUgPSBcImFkbWluXCIsXG4gICAgICAgIGV2ZW50cyA9IHt9LFxuICAgICAgICByZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50cy5iaW5kKG5vdENvbW1vbiksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwidXNlcm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZSA9IGRhdGEudXNlcm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwicm9sZVwiKSkge1xuICAgICAgICAgICAgICAgIHJvbGUgPSBkYXRhLnJvbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBJZCgpIHtcbiAgICAgICAgcmV0dXJuIGB1c2VyY2FyZC0ke2lkfWA7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gYCR7Z2V0Q29tcElkKCl9OnVwZGF0ZWA7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxhcnRpY2xlIGlkPXtnZXRDb21wSWQoKX0gY2xhc3M9XCJtZWRpYVwiPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJtZWRpYS1sZWZ0XCI+XG4gICAgICAgIDxwIGNsYXNzPVwiaW1hZ2UgaXMtMzJ4MzJcIj5cbiAgICAgICAgICAgIDxpbWcgc3JjPXtpbWFnZX0gYWx0PXt1c2VybmFtZX0gLz5cbiAgICAgICAgPC9wPlxuICAgIDwvZmlndXJlPlxuICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50XCI+XG4gICAgICAgIDxVSUNvbnRlbnQ+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPnt1c2VybmFtZX08L3N0cm9uZz5cbiAgICAgICAgICAgICAgICA8c21hbGw+QDwvc21hbGw+XG4gICAgICAgICAgICAgICAgPHN0cm9uZz57cm9sZX08L3N0cm9uZz5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9VSUNvbnRlbnQ+XG4gICAgPC9kaXY+XG48L2FydGljbGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmb250ID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2lkZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcG9pbnRhYmxlID0gZmFsc2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgZm9udCA9IFwiXCIsXG4gICAgICAgIHNpZGUgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgcG9pbnRhYmxlID0gZmFsc2UsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGV9XG4gICAgPHNwYW4gY2xhc3M9XCJpY29uLXRleHQge3BvaW50YWJsZSA/ICdpcy1jbGlja2FibGUnIDogJyd9XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiPlxuICAgICAgICAgICAgPGlcbiAgICAgICAgICAgICAgICBjbGFzcz1cImlzLXRpdGxlLWljb24gZmFzXG4gICAgICBmYS17Zm9udH1cbiAgICAgIHtzaXplID09ICdtZWRpdW0nID8gJ2ZhLWxnJyA6ICcnfVxuICAgICAge3NpemUgPT0gJ2xhcmdlJyA/ICdmYS0yeCcgOiAnJ31cbiAgICAgIFwiXG4gICAgICAgICAgICA+PC9pPlxuICAgICAgICAgICAgPHNwYW4+eyRMT0NBTEVbdGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbns6ZWxzZX1cbiAgICA8c3BhblxuICAgICAgICBjbGFzcz1cIlxuICAgICAgICB7cG9pbnRhYmxlID8gJ2lzLWNsaWNrYWJsZScgOiAnJ31cbiAgICAgICAge3NpZGUgPyBgaXMtJHtzaWRlfWAgOiAnJ31cbiAgICAgICAgaWNvbiB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7c2l6ZSA9PSAnbWVkaXVtJyA/ICdmYS1sZycgOiAnJ31cbntzaXplID09ICdsYXJnZScgPyAnZmEtMngnIDogJyd9XCJcbiAgICA+XG4gICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLXtmb250fVwiPjwvaT5cbiAgICA8L3NwYW4+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlUZXh0ZmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUNvbHVtbiwgVUlDb2x1bW5zIH0gZnJvbSBcIi4uL2xheW91dFwiO1xuICAgIGltcG9ydCBVSUljb25Gb250IGZyb20gXCIuLi9pY29uL3VpLmljb24uZm9udC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUZpZWxkIGZyb20gXCIuLi9pbnB1dC91aS5maWVsZC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3BsYWNlaG9sZGVyID0gJ25vdC1ub2RlOmZpZWxkX3NlYXJjaF9wbGFjZWhvbGRlciddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Rlcm0gPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbZmllbGRuYW1lID0gJ3NlYXJjaFRlcm1JbnB1dCddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2ljb24gPSAnc2VhcmNoJ11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJub3Qtbm9kZTpmaWVsZF9zZWFyY2hfcGxhY2Vob2xkZXJcIixcbiAgICAgICAgdGVybSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWFyY2hUZXJtSW5wdXRcIixcbiAgICAgICAgaWNvbiA9IFwic2VhcmNoXCIsXG4gICAgICAgIGljb25TaWRlID0gXCJsZWZ0XCIsXG4gICAgICAgIHNpemUgPSBcIm5vcm1hbFwiLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaGFzSWNvbnNMZWZ0ID0gJGRlcml2ZWQoaWNvbiAmJiBpY29uU2lkZSA9PT0gXCJsZWZ0XCIpO1xuICAgIGxldCBoYXNJY29uc1JpZ2h0ID0gJGRlcml2ZWQoaWNvbiAmJiBpY29uU2lkZSA9PT0gXCJyaWdodFwiKTtcbjwvc2NyaXB0PlxuXG48VUlDb2x1bW5zIHJvbGU9XCJub25lXCI+XG4gICAgPFVJQ29sdW1uIHJvbGU9XCJub25lXCI+XG4gICAgICAgIDxVSUZpZWxkPlxuICAgICAgICAgICAgPFVJQ29udHJvbCB7aGFzSWNvbnNMZWZ0fSB7aGFzSWNvbnNSaWdodH0+XG4gICAgICAgICAgICAgICAgPFVJVGV4dGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e3Rlcm19XG4gICAgICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAge2ZpZWxkbmFtZX1cbiAgICAgICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICB7c2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgcm9sZT17XCJzZWFyY2hib3hcIn1cbiAgICAgICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHsjaWYgaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgPFVJSWNvbkZvbnQgZm9udD17aWNvbn0gc2lkZT17aWNvblNpZGV9IC8+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvVUlDb250cm9sPlxuICAgICAgICA8L1VJRmllbGQ+XG4gICAgPC9VSUNvbHVtbj5cbjwvVUlDb2x1bW5zPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgRXJyb3JzTGlzdCBmcm9tIFwiLi4vdmFyaW91cy91aS5lcnJvcnMubGlzdC5zdmVsdGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJnZW5lcmljLWZpZWxkXCIsXG4gICAgICAgIGlucHV0U3RhcnRlZCxcbiAgICAgICAgdmFsaWRhdGVkLFxuICAgICAgICB2YWxpZCxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmb3JtRXJyb3JzLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGFsbEVycm9ycyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IHNob3dFcnJvcnMgPSAkc3RhdGUodHJ1ZSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgYWxsRXJyb3JzID0gW1xuICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZXJyb3JzKSA/IGVycm9ycyA6IFtdKSxcbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGZvcm1FcnJvcnMpID8gZm9ybUVycm9ycyA6IFtdKSxcbiAgICAgICAgXTtcbiAgICAgICAgc2hvd0Vycm9ycyA9IGlucHV0U3RhcnRlZCAmJiB2YWxpZGF0ZWQgJiYgIXZhbGlkO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxFcnJvcnNMaXN0IHNob3c9e3Nob3dFcnJvcnN9IGVycm9ycz17YWxsRXJyb3JzfSBjbGFzcz17Y2xhc3Nlc30ge2lkfSAvPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9uIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRhZyBmcm9tIFwiLi4vdmFyaW91cy91aS50YWcuc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyBidXR0b24gPSB7fSwgdGFnID0ge30sIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgdmFycyA9ICRzdGF0ZSh7fSk7XG5cbiAgICBsZXQgdGFnUG9zaXRpb24gPSB7XG4gICAgICAgIGxlZnQ6ICEhbGVmdCxcbiAgICAgICAgcmlnaHQ6ICEhcmlnaHQsXG4gICAgICAgIHRvcDogISF0b3AsXG4gICAgICAgIGJvdHRvbTogISFib3R0b20sXG4gICAgfTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgdmFyc1tgLS1zaWRpbmctbGVmdC1zaXplYF0gPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgdmFyc1tcIi0tc2lkaW5nLXJpZ2h0LXNpemVcIl0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICB2YXJzW1wiLS1zaWRpbmctdG9wLXNpemVcIl0gPSB0b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSkge1xuICAgICAgICAgICAgdmFyc1tcIi0tc2lkaW5nLWJvdHRvbS1zaXplXCJdID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIHZhcnMgPSB2YXJzO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxzcGFuIGNsYXNzPVwiaXMtdGFnLWNvbnRhaW5lclwiPlxuICAgIDxVSUJ1dHRvbiB7Li4uYnV0dG9ufSAvPlxuICAgIDxVSVRhZyB7Li4udGFnfSB7dmFyc30gey4uLnRhZ1Bvc2l0aW9ufSAvPlxuPC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0cmlnZ2VyXSAtIGV4cG9ydCBsZXQgZGlyZWN0aW9uID0gJ2xlZnQnOyAgLy9sZWZ0L3JpZ2h0L3RvcC9ib3R0b20vYXJvdW5kXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRyaWdnZXIgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCJDbGljayBtZSFcIixcbiAgICAgICAgICAgIGljb246IFwicGx1c1wiLFxuICAgICAgICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgc2l6ZTogXCJtZWRpdW1cIixcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRvcCA9IFwiMmVtXCIsXG4gICAgICAgIGxlZnQgPSBcIjJlbVwiLFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHBvc2l0aW9uU3R5bGUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgcG9zaXRpb25TdHlsZSA9IFwiXCI7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYHRvcDogJHt0b3B9O2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYGxlZnQ6ICR7bGVmdH07YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYHJpZ2h0OiAke3JpZ2h0fTtgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3R0b20pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYGJvdHRvbTogJHtib3R0b219O2A7XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiaXMtYWJzb2x1dGUge2NsYXNzZXN9XCIgc3R5bGU9e3Bvc2l0aW9uU3R5bGV9PlxuICAgIDxVSUJ1dHRvbiB7Li4udHJpZ2dlcn0gLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKiBlc2xpbnQgc3ZlbHRlL25vLWF0LWh0bWwtdGFnczogMCAqL1xuXG4gICAgaW1wb3J0IFVJSWNvbkZvbnQgZnJvbSBcIi4vdWkuaWNvbi5mb250LnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlID0gXCJcIl0gLSBmb250IGljb24gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemUgPSBcIlwiXSAgLSBmb250IGljb24gc2l6ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udCA9IFwiXCJdIC0gZm9udCBpY29uIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N2ZyA9IFwiXCJdIC0gc3ZnIGljb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NyYyA9IFwiXCJdIC0gaW1hZ2UgaWNvblxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfHN0cmluZ30gd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IGhlaWdodFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBmb250ID0gXCJcIixcbiAgICAgICAgc3ZnID0gXCJcIixcbiAgICAgICAgc3JjID0gXCJcIixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBmb250fVxuICAgIDxVSUljb25Gb250IHtmb250fSB7c2l6ZX0ge3RpdGxlfT48L1VJSWNvbkZvbnQ+XG57OmVsc2UgaWYgc3ZnfVxuICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPntAaHRtbCBzdmd9PC9zcGFuPlxuezplbHNlIGlmIHNyY31cbiAgICA8ZmlndXJlIGNsYXNzPVwiaW1hZ2Uge3dpZHRoICYmIGhlaWdodCA/IGBpcy0ke3dpZHRofXgke2hlaWdodH1gIDogJyd9IFwiPlxuICAgICAgICA8aW1nIHtzcmN9IHt0aXRsZX0gYWx0PXt0aXRsZX0ge3dpZHRofSB7aGVpZ2h0fSAvPlxuICAgIDwvZmlndXJlPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVUlJY29uRm9udCB9IGZyb20gXCIuLi9pY29uXCI7XG5cbiAgICBsZXQgeyB2YWxpZGF0ZWQsIHZhbGlkLCBzaWRlID0gXCJyaWdodFwiLCBzaXplID0gXCJzbWFsbFwiIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIHZhbGlkYXRlZCA9PT0gdHJ1ZX1cbiAgICA8VUlJY29uRm9udCBmb250PXt2YWxpZCA/IFwiY2hlY2tcIiA6IFwiZXhjbGFtYXRpb24tdHJpYW5nbGVcIn0ge3NpZGV9IHtzaXplfSAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJRm9ybUlucHV0VmFsaWRhdGVkSWNvbiBmcm9tIFwiLi91aS5mb3JtLmlucHV0LnZhbGlkYXRlZC5pY29uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFVJSWNvbkZvbnQgfSBmcm9tIFwiLi4vaWNvblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgVUlJbnB1dFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWVsZHR5cGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGRuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVQcmVmaXggPSBcImZvcm0tZmllbGQtXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGUgPSAnbGVmdCddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2l6ZT0gJ3NtYWxsJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkID0gZmFsc2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICByZWFkb25seSxcbiAgICAgICAgVUlJbnB1dCxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZpZWxkdHlwZSxcbiAgICAgICAgZmllbGRuYW1lLFxuICAgICAgICBmaWVsZG5hbWVQcmVmaXggPSBcImZvcm0tZmllbGQtXCIsXG4gICAgICAgIGljb24sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVkID0gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlJbnB1dCB7ZmllbGR0eXBlfSB7ZmllbGRuYW1lfSB7dmFsaWR9IHtyZWFkb25seX0gYmluZDp2YWx1ZSB7Li4ub3RoZXJzfSAvPlxuPCEtLSBlZGl0IFVJIHJlbmRlcmVyIC0tPlxueyNpZiBpY29ufVxuICAgIDxVSUljb25Gb250IGZvbnQ9e2ljb259IHNpZGU9e2ljb25TaWRlfSBzaXplPXtpY29uU2l6ZX0gLz5cbnsvaWZ9XG57I2lmICFyZWFkb25seX1cbiAgICA8IS0tIHZhbGlkYXRlZCBhbmQgdmFsaWQgc2hvdWxkIGJlIGNyZWF0ZWQgYnkgJHN0YXRlKCkgLS0+XG4gICAgPFVJRm9ybUlucHV0VmFsaWRhdGVkSWNvbiB7dmFsaWRhdGVkfSB7dmFsaWR9PjwvVUlGb3JtSW5wdXRWYWxpZGF0ZWRJY29uPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4uL2lucHV0L3VpLmxhYmVsLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBJbnB1dEVycm9ycyBmcm9tIFwiLi91aS5mb3JtLmlucHV0LmVycm9ycy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlGb3JtSW5wdXQgZnJvbSBcIi4vdWkuZm9ybS5pbnB1dC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnB1dFN0YXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWVsZG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGR0eXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50SW5wdXRDaGFuZ2VDYWxsYmFja30gW29uY2hhbmdlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkYXRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlcnJvcnNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9ybUVycm9yc11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIFVJSW5wdXQsXG4gICAgICAgIGlucHV0U3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGFiZWxWZXJ0aWNhbCA9IHRydWUsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGR0eXBlLFxuICAgICAgICBmaWVsZG5hbWUsXG4gICAgICAgIGZpZWxkbmFtZVByZWZpeCA9IFwiZm9ybS1maWVsZC1cIixcbiAgICAgICAgaWNvbiA9IFwiXCIsXG4gICAgICAgIGljb25TaWRlID0gXCJsZWZ0XCIsXG4gICAgICAgIGljb25TaXplID0gXCJzbWFsbFwiLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmb3JtRXJyb3JzID0gW10sXG4gICAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaWNvbkNsYXNzZXMgPSAkZGVyaXZlZChcbiAgICAgICAgKGljb24gPyBcIiBoYXMtaWNvbnMtbGVmdCBcIiA6IFwiXCIpICsgXCIgaGFzLWljb25zLXJpZ2h0IFwiXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgY29udHJvbCgpfVxuICAgIDxVSUNvbnRyb2wgY2xhc3M9e2ljb25DbGFzc2VzfT5cbiAgICAgICAgPFVJRm9ybUlucHV0XG4gICAgICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgICAgICB7VUlJbnB1dH1cbiAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIHtmaWVsZHR5cGV9XG4gICAgICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICAgICAge2ZpZWxkbmFtZVByZWZpeH1cbiAgICAgICAgICAgIHtpY29ufVxuICAgICAgICAgICAge2ljb25TaWRlfVxuICAgICAgICAgICAge2ljb25TaXplfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge2lucHV0U3RhcnRlZH1cbiAgICAgICAgICAgIHt2YWxpZGF0ZWR9XG4gICAgICAgICAgICB7dmFsaWR9XG4gICAgICAgICAgICB7b25jaGFuZ2V9XG4gICAgICAgICAgICB7b25lcnJvcn1cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgPC9VSUNvbnRyb2w+XG57L3NuaXBwZXR9XG5cbnsjaWYgbGFiZWx9XG4gICAgeyNpZiBsYWJlbFZlcnRpY2FsfVxuICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgY2xhc3M9e2ZpZWxkdHlwZX1cbiAgICAgICAgICAgIGZvcj1cIntmaWVsZG5hbWVQcmVmaXh9e2ZpZWxkdHlwZX0te2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAvPlxuICAgICAgICB7QHJlbmRlciBjb250cm9sKCl9XG4gICAgezplbHNlfVxuICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgY2xhc3M9e2ZpZWxkdHlwZX1cbiAgICAgICAgICAgIGZvcj1cIntmaWVsZG5hbWVQcmVmaXh9e2ZpZWxkdHlwZX0te2ZpZWxkbmFtZX1cIlxuICAgICAgICA+XG4gICAgICAgICAgICB7bGFiZWx9OiB7QHJlbmRlciBjb250cm9sKCl9XG4gICAgICAgIDwvVUlMYWJlbD5cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIHtAcmVuZGVyIGNvbnRyb2woKX1cbnsvaWZ9XG5cbjxJbnB1dEVycm9yc1xuICAgIHtpbnB1dFN0YXJ0ZWR9XG4gICAge3ZhbGlkYXRlZH1cbiAgICB7dmFsaWR9XG4gICAge2Vycm9yc31cbiAgICB7Zm9ybUVycm9yc31cbiAgICBpZD1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi91aS5pbWFnZS5zdmVsdGVcIjtcblxuICAgIGxldCB7IHZhbHVlcyA9IFtdLCAuLi5vdmVycmlkZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNlYWNoIHZhbHVlcyBhcyBpdGVtIChpdGVtLnVybCl9XG4gICAgPFVJSW1hZ2Ugey4uLml0ZW19IHsuLi5vdmVycmlkZX0gLz5cbnsvZWFjaH1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVUlCdXR0b25zUm93IH0gZnJvbSBcIi4uLy4uL2J1dHRvblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbcGFnZV0gICAgICAgICAgICAgICAgLSBjdXJyZW50IHBhZ2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbcGFnZXNdICAgICAgICAgICAgICAgLSB0b3RhbCBjb3VudCBvZiBwYWdlc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtidXR0b25zUm93Q29tcG9uZW50ID0gVUlCdXR0b25zUm93XSAtIGJ1dHRvbnMgcm93IHVpIHN2ZWx0ZSBjb21wb25lbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uc1Jvd0NvbXBvbmVudFByb3BzXSAgIC0gYnV0dG9ucyByb3cgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uUHJldlByb3BzXSAgIC0gcHJldiBidXR0b24gdWkgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uUHJvZ3Jlc3NQcm9wc10gICAtIGNlbnRlci9wcm9ncmVzcyBidXR0b24gdWkgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uTmV4dFByb3BzXSAgIC0gbmV4dCBidXR0b24gdWkgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25uZXh0XSAgICAgICAgICAgIC0gY2FsbGJhY2sgb24gbmV4dFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbnByZXZdICAgICAgICAgICAgLSBjYWxsYmFjayBvbiBwcmV2XG4gICAgICogQHByb3BlcnR5ICAgIHtzdHJpbmd9ICAgIFtwcm9ncmVzc1RpdGxlU3RhcnQgPSAnJ10gIC0gcHJlZml4IG9mIHByb2dyZXNzIGJ1dHRvbiB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbcHJvZ3Jlc3NUaXRsZURlbGltaXRlciA9ICcgLyAnXSAgLSB0ZXh0IHRoYXQgYnJlYWtzIG51bWJlcnMgb2YgY3VycmVudCBwYWdlIGFuZCB0b3RhbCBjb3VudCBvZiBwYWdlc1xuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbcHJvZ3Jlc3NUaXRsZUVuZCA9ICcnXSAgLSBzdWZmaXggb2YgcHJvZ3Jlc3MgYnV0dG9uIHRpdGxlXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHBhZ2UgPSAwLFxuICAgICAgICBwYWdlcyA9IDAsXG4gICAgICAgIGJ1dHRvbnNSb3dDb21wb25lbnQ6IFVJQnV0dG9uc1Jvd0NvbXBvbmVudCA9IFVJQnV0dG9uc1JvdyxcbiAgICAgICAgYnV0dG9uc1Jvd0NvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGJ1dHRvblByZXZQcm9wcyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIm5vdC1ub2RlOmxpc3RfbmF2aWdhdGlvbl9wcmV2X2J1dHRvbl9sYWJlbFwiLFxuICAgICAgICB9LFxuICAgICAgICBidXR0b25Qcm9ncmVzc1Byb3BzID0ge30sXG4gICAgICAgIGJ1dHRvbk5leHRQcm9wcyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIm5vdC1ub2RlOmxpc3RfbmF2aWdhdGlvbl9uZXh0X2J1dHRvbl9sYWJlbFwiLFxuICAgICAgICB9LFxuICAgICAgICAvL3RoaXMgaXMgcGxhY2Vob2xkZXJzIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIG9ubHksIGBwYWdlYCBzaG91bGQgYmUgbW9kaWZpZWQgb3V0c2lkZSBpbiBvbnByZXYvb25uZXh0IGNhbGxiYWNrc1xuICAgICAgICBvbnByZXYgPSAoKSA9PiB7XG4gICAgICAgICAgICBwYWdlID4gMCAmJiBwYWdlLS07XG4gICAgICAgIH0sXG4gICAgICAgIG9ubmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIHBhZ2UgPCBwYWdlcyAtIDEgJiYgcGFnZSsrO1xuICAgICAgICB9LFxuICAgICAgICBwcm9ncmVzc1RpdGxlU3RhcnQgPSBcIlwiLFxuICAgICAgICBwcm9ncmVzc1RpdGxlRGVsaW1pdGVyID0gXCIgLyBcIixcbiAgICAgICAgcHJvZ3Jlc3NUaXRsZUVuZCA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGN1cnJlbnRQYWdlID0gJGRlcml2ZWQocGFnZSArIDEpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgcGFnZXMgPiAwfVxuICAgIDxVSUJ1dHRvbnNSb3dDb21wb25lbnRcbiAgICAgICAgey4uLmJ1dHRvbnNSb3dDb21wb25lbnRQcm9wc31cbiAgICAgICAgbGVmdD17Y3VycmVudFBhZ2UgPiAxXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5idXR0b25QcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBvbnByZXYsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtdfVxuICAgICAgICBjZW50ZXI9e3BhZ2VzID4gMVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uYnV0dG9uUHJvZ3Jlc3NQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYCR7cHJvZ3Jlc3NUaXRsZVN0YXJ0fSR7Y3VycmVudFBhZ2V9JHtwcm9ncmVzc1RpdGxlRGVsaW1pdGVyfSR7cGFnZXN9JHtwcm9ncmVzc1RpdGxlRW5kfWAsXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtdfVxuICAgICAgICByaWdodD17Y3VycmVudFBhZ2UgPCBwYWdlc1xuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uYnV0dG9uTmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogb25uZXh0LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXX1cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQm94IGZyb20gXCIuLi8uLi9ibG9jay91aS5ib3guc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyB0aXRsZSwgaWQsIF9pZCwgb25jbGljayB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25jbGljayh7XG4gICAgICAgICAgICBfaWQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlCb3ggb25jbGljaz17Y2xpY2t9IG9ua2V5dXA9e2NsaWNrfSBjbGFzcz1cImxpc3QtaXRlbS1zZWxlY3RhYmxlXCI+XG4gICAgPHNwYW4+e3RpdGxlfTwvc3Bhbj5cbjwvVUlCb3g+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUVuZGxlc3NMaXN0U2ltcGxlSXRlbSBmcm9tIFwiLi91aS5lbmRsZXNzLmxpc3Quc2ltcGxlLml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJRW5kbGVzc0xpc3RFbXB0eVBsYWNlaG9sZGVyIGZyb20gXCIuLi91aS5saXN0LmVtcHR5LnBsYWNlaG9sZGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUVuZGxlc3NMaXN0TmF2aWdhdGlvbiBmcm9tIFwiLi91aS5lbmRsZXNzLmxpc3QubmF2aWdhdGlvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJsb2NrIH0gZnJvbSBcIi4uLy4uL2Jsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZGF0YV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1Db21wb25lbnQgPSBVSUVuZGxlc3NMaXN0U2ltcGxlSXRlbV0gLSBsaXN0IGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1Db21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2VtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdEVtcHR5UGxhY2Vob2xkZXJdIC0gaWYgbGlzdCBpcyBlbXB0eVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3ROYXZpZ2F0aW9uQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdE5hdmlnYXRpb25dIC0gcHJldiBhbmQgbmV4dCBibG9ja1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdE5hdmlnYXRpb25Db21wb25lbnRQcm9wc11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBkYXRhID0gJGJpbmRhYmxlKHtcbiAgICAgICAgICAgIGxpc3Q6IFtdLFxuICAgICAgICAgICAgc2tpcDogMCxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgcGFnZTogMCxcbiAgICAgICAgICAgIHBhZ2VzOiAwLFxuICAgICAgICB9KSxcbiAgICAgICAgaXRlbUNvbXBvbmVudDogVUlJdGVtQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdFNpbXBsZUl0ZW0sXG4gICAgICAgIGl0ZW1Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudDpcbiAgICAgICAgICAgIFVJRW1wdHlMaXN0UGxhY2Vob2xkZXIgPSBVSUVuZGxlc3NMaXN0RW1wdHlQbGFjZWhvbGRlcixcbiAgICAgICAgZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbkNvbXBvbmVudDpcbiAgICAgICAgICAgIFVJTmF2aWdhdGlvbkNvbXBvbmVudCA9IFVJRW5kbGVzc0xpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIG9uc2VsZWN0LFxuICAgICAgICBvbnByZXYsXG4gICAgICAgIG9ubmV4dCxcbiAgICAgICAgaXRlbVJlbmRlcmVyLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlCbG9jayBjbGFzcz17Y2xhc3Nlc30+XG4gICAgeyNpZiBkYXRhPy5saXN0Py5sZW5ndGh9XG4gICAgICAgIHsjZWFjaCBkYXRhLmxpc3QgYXMgaXRlbSwgaW5kZXggKGl0ZW0uaWQpfVxuICAgICAgICAgICAgeyNpZiBpdGVtUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAge0ByZW5kZXIgaXRlbVJlbmRlcmVyKGl0ZW0sIGluZGV4KX1cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8VUlJdGVtQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uc2VsZWN0fVxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuICAgIHs6ZWxzZX1cbiAgICAgICAgPFVJRW1wdHlMaXN0UGxhY2Vob2xkZXIgey4uLmVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHN9IC8+XG4gICAgey9pZn1cbjwvVUlCbG9jaz5cbjxVSU5hdmlnYXRpb25Db21wb25lbnRcbiAgICB7Li4ubGlzdE5hdmlnYXRpb25Db21wb25lbnRQcm9wc31cbiAgICBiaW5kOnBhZ2U9e2RhdGEucGFnZX1cbiAgICBiaW5kOnBhZ2VzPXtkYXRhLnBhZ2VzfVxuICAgIGJpbmQ6c2tpcD17ZGF0YS5za2lwfVxuICAgIGJpbmQ6Y291bnQ9e2RhdGEuY291bnR9XG4gICAge29ucHJldn1cbiAgICB7b25uZXh0fVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8vXG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbZmllbGRuYW1lID0gXCJsaXN0LXNlbGVjdFwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICBbbXVsdGlwbGUgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHdhbnQgbm90IG9uZSB2YXJpYW50IHNlbGVjdGVkXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgICAgIFthdExlYXN0T25lID0gdHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gZW1wdHkgcmVzdWx0XG4gICAgICogQHByb3BlcnR5IHthcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5WYXJpYW50cz59IFt2YXJpYW50cyA9IFtdXSAgICAgICAgICAgdmFyaWFudHMgdG8gc2VsZWN0IGZyb21cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PG9iamVjdD59IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLi4uc2VsZWN0ZWRJdGVtc1ZhbHVlc11cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PHN0cmluZ3xudW1iZXI+fSBbc2VsZWN0ZWRWYXJpYW50c0lkcyA9IFtdXSAgICAgICAgICAgICAgICAgICAgICBbLi4uc2VsZWN0ZWRJdGVtc0lkc11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW3RpdGxlQ29tcG9uZW50UHJvcHM9IHsgc2l6ZTogNSB9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbaW1hZ2VDb21wb25lbnRQcm9wcz0geyBjb3ZlcmVkOiB0cnVlIH1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtsaXN0Q29tcG9uZW50ID0gVUlMaXN0XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbbGlzdENvbXBvbmVudFByb3BzID0ge2FjdGlvbnNWaXNpYmxlOiB0cnVlfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3N1YmxpbWVWYWx1ZSA9ICh2YWx1ZSkgPT4gdmFsdWUuaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFt1cGRhdGVWYXJpYW50ID0gKHZhbHVlSWQsIHByb3BzLCB0b2dnbGVUaXRsZSkgPT4gdm9pZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldEl0ZW1JbmRleCA9IChpdGVtcywgdmFsdWVJZCkgPT4gbnVtYmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbZ2V0SXRlbSA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IG9iamVjdF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldEl0ZW1WYWx1ZSA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IG9iamVjdF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldERlZmF1bHRJdGVtU3VibGltZSA9IChpdGVtcykgPT4gc3RyaW5nXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdXBkYXRlVmFyaWFudCA9IChpdGVtcywgdmFsdWVJZCwgcHJvcHMsIHRvZ2dsZVRpdGxlKSA9PiB2b2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdWlPbiA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHZvaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFt1aU9mZiA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHZvaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtleHRlbmRWYXJpYW50VG9JdGVtTGlzdCA9IChpdGVtKSA9PiBvYmplY3RdXG4gICAgICovXG4gICAgbGV0IGl0ZW1zID0gJHN0YXRlKFtdKTtcbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZpZWxkbmFtZSA9IFwibGlzdC1zZWxlY3RcIixcbiAgICAgICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAgICAgYXRMZWFzdE9uZSA9IHRydWUsXG4gICAgICAgIHZhcmlhbnRzID0gW10sIC8vdmFyaWFudHMgdG8gc2VsZWN0IGZyb21cbiAgICAgICAgdmFsdWUgPSBbXSwgLy9zZWxlY3RlZCBvYmplY3RzXG4gICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSBbXSwgLy9vbmx5IGlkcyBvZiBzZWxlY3RlZCB2YXJpYW50c1xuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBsaXN0Q29tcG9uZW50OiBVSUxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHsgYWN0aW9uc1Zpc2libGU6IHRydWUgfSxcbiAgICAgICAgc3VibGltZVZhbHVlID0gKHZhbHVlKSA9PiB2YWx1ZS5pZCwgLy9vYmplY3QgLT4gaWRcbiAgICAgICAgZ2V0SXRlbUluZGV4ID0gKGl0ZW1zLCB2YWx1ZUlkKSA9PlxuICAgICAgICAgICAgaXRlbXMuZmluZEluZGV4KCh2YWwpID0+IHZhbC52YWx1ZS5pZCA9PT0gdmFsdWVJZCksXG4gICAgICAgIGdldEl0ZW0gPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEl0ZW1JbmRleChpdGVtcywgdmFsdWVJZCk7XG4gICAgICAgICAgICAvL3JldHVybnMgdmFyaWFudHMgYnkgaXRzIGlkXG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMVxuICAgICAgICAgICAgICAgID8gaXRlbXMuZmluZCgoYnRuVmFsKSA9PiBidG5WYWwudmFsdWUuaWQgPT09IHZhbHVlSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEl0ZW1WYWx1ZSA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHtcbiAgICAgICAgICAgIC8vIHJldHVybnMgdmFyaWFudCdzIHZhbHVlIGJ5IGlkIG9mIHZhcmlhbnRcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtKGl0ZW1zLCB7IHZhbHVlSWQgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0udmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERlZmF1bHRJdGVtU3VibGltZSA9IChpdGVtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IGl0ZW1zWzBdLmlkIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVWYXJpYW50ID0gKGl0ZW1zLCB2YWx1ZUlkLCBpdGVtUHJvcHMsIGJ1dHRvblByb3BzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEl0ZW1JbmRleChpdGVtcywgdmFsdWVJZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoaXRlbVByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF1ba2V5XSA9IGl0ZW1Qcm9wc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtc1tpbmRleF0uYWN0aW9ucykgJiZcbiAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF0uYWN0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGJ1dHRvblByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaW5kZXhdLmFjdGlvbnNbMF1ba2V5XSA9IGJ1dHRvblByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVpT24gPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVWYXJpYW50KFxuICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJoYXMtYmFja2dyb3VuZC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiBcIm5vdC1ub2RlOmJvb2xlYW5zX3RydWVcIiwgY29sb3I6IFwic3VjY2Vzc1wiIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVpT2ZmID0gKGl0ZW1zLCB7IHZhbHVlSWQgfSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlVmFyaWFudChcbiAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiBcIm5vdC1ub2RlOmJvb2xlYW5zX2ZhbHNlXCIsIGNvbG9yOiBcImRhbmdlclwiIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZFZhcmlhbnRUb0l0ZW1MaXN0ID0gKGl0bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0geyAuLi5pdG0gfTtcbiAgICAgICAgICAgIHJlcy5hY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIixcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHRvZ2dsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2hhbmdlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaXRlbXMgPSB2YXJpYW50cy5tYXAoZXh0ZW5kVmFyaWFudFRvSXRlbUxpc3QpO1xuICAgICAgICBpZiAodmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChhdExlYXN0T25lICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW1WYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdWkgPSB1cGRhdGVTZWxlY3RlZChpdGVtVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVVSSh1aSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIC8vXG4gICAgZnVuY3Rpb24gY291bnRPZlNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBzZWxlY3RlZFZhcmlhbnRzSWRzLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgY29uc3Qgbm90TGFzdE9uZSA9ICgpID0+ICEoYXRMZWFzdE9uZSAmJiBjb3VudE9mU2VsZWN0ZWQoKSA9PT0gMSk7XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZChkZXRhaWwpIHtcbiAgICAgICAgY29uc3QgdmFsdWVJZCA9IHN1YmxpbWVWYWx1ZShkZXRhaWwpO1xuICAgICAgICBsZXQgdWkgPSB7XG4gICAgICAgICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2ZmOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZWxlY3RlZFZhcmlhbnRzSWRzKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFyaWFudHNJZHMuaW5jbHVkZXModmFsdWVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm90TGFzdE9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcy5pbmRleE9mKHZhbHVlSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB1aS5vZmYgPSB7IHZhbHVlSWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMucHVzaCh2YWx1ZUlkKTtcbiAgICAgICAgICAgICAgICB1aS5vbiA9IHsgdmFsdWVJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkVmFyaWFudHNJZHMuaW5jbHVkZXModmFsdWVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50T2ZTZWxlY3RlZCgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWkub2ZmID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHNlbGVjdGVkVmFyaWFudHNJZHMucG9wKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVpLm9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcyA9IFt2YWx1ZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhcmlhbnRzSWRzLmluY2x1ZGVzKHZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLm9mZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcy5pbmRleE9mKHZhbHVlSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLm9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcy5wdXNoKHZhbHVlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1aTtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB0b2dnbGUoZGV0YWlsKSB7XG4gICAgICAgIGxldCB1aSA9IHVwZGF0ZVNlbGVjdGVkKGRldGFpbCk7XG4gICAgICAgIHVwZGF0ZVVJKHVpKTtcbiAgICAgICAgLy9cbiAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgLy9cbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLFxuICAgICAgICAgICAgaWRzOiAkc3RhdGUuc25hcHNob3Qoc2VsZWN0ZWRWYXJpYW50c0lkcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVVJKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMub2ZmKSB7XG4gICAgICAgICAgICB1aU9mZihpdGVtcywgY2hhbmdlcy5vZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLm9uKSB7XG4gICAgICAgICAgICB1aU9uKGl0ZW1zLCBjaGFuZ2VzLm9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKCkge1xuICAgICAgICBsZXQgbmV3VmFsID0gW107XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RlZFZhcmlhbnRzSWRzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNlbGVjdGVkVmFyaWFudHNJZHMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbmV3VmFsID0gc2VsZWN0ZWRWYXJpYW50c0lkc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbCkgPT4gdHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZUlkKSA9PlxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtVmFsdWUoaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IG5ld1ZhbDtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiBzZWxlY3REZWZhdWx0KCkge1xuICAgICAgICBpZiAoYXRMZWFzdE9uZSAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZWYWx1ZUlkID0gZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lKGl0ZW1zKTtcbiAgICAgICAgICAgIGlmIChkZWZWYWx1ZUlkKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKHsgaWQ6IGRlZlZhbHVlSWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPFVJTGlzdENvbXBvbmVudFxuICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgIHtpbWFnZUNvbXBvbmVudH1cbiAgICB7aW1hZ2VDb21wb25lbnRQcm9wc31cbiAgICB7Li4ub3RoZXJzfVxuICAgIHsuLi5saXN0Q29tcG9uZW50UHJvcHN9XG4gICAge2l0ZW1zfVxuLz5cbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBzdGF0aWMgbWV0aG9kcyB0byB3b3JrIHdpdGggU2VsZWN0b3JHcm91cHMgb2JqZWN0c1xuICpcbiAqIEBjbGFzcyBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gKi9cbmNsYXNzIExpc3RHcm91cHNVSVRyZWVEVE8ge1xuICAgIHN0YXRpYyBVSV9QUk9QU19ERUxUQV9PTiA9IHtcbiAgICAgICAgY2xhc3M6IFwiaGFzLWJhY2tncm91bmQtc3VjY2Vzc1wiLFxuICAgIH07XG5cbiAgICBzdGF0aWMgVUlfUFJPUFNfREVMVEFfT0ZGID0ge1xuICAgICAgICBjbGFzczogXCJcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIFVJX1BST1BTX0RFTFRBX09OX0FDVElPTiA9IHtcbiAgICAgICAgdGl0bGU6IFwibm90LW5vZGU6Ym9vbGVhbnNfdHJ1ZVwiLFxuICAgICAgICBjb2xvcjogXCJzdWNjZXNzXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBVSV9QUk9QU19ERUxUQV9PRkZfQUNUSU9OID0ge1xuICAgICAgICB0aXRsZTogXCJub3Qtbm9kZTpib29sZWFuc19mYWxzZVwiLFxuICAgICAgICBjb2xvcjogXCJkYW5nZXJcIixcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aXRsZSBmaWVsZCBmcm9tIG9iamVjdCBhcyBzdHJpbmdcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICB2YWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHZhbC50aXRsZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0R3JvdXBUaXRsZSh7IHRpdGxlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgaW1hZ2UgZmllbGQgZnJvbSBvYmplY3QgYXMgc3RyaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgdmFsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICB2YWwuaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cblxuICAgIHN0YXRpYyBjb252ZXJ0R3JvdXBJbWFnZSh7IGltYWdlIH0pIHtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB2YXJpYW50IG9iamVjdCB0byBzZWxlY3RvciBpdGVtIG9iamVjdFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlZhcmlhbnR9IHZhcmlhbnRcbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JJdGVtfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnRWYXJpYW50KHZhcmlhbnQsIGdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB2YXJpYW50LmlkLFxuICAgICAgICAgICAgdGl0bGU6IHZhcmlhbnQudGl0bGUsXG4gICAgICAgICAgICB2YWx1ZTogeyB2YWx1ZUlkOiB2YXJpYW50LmlkLCBncm91cElkIH0sIC8vd2hhdCB3ZSB3aWxsIHN1YmxpbWVcbiAgICAgICAgfTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50c0dyb3VwfSBncm91cFxuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3VwfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnRWYXJpYW50c0dyb3VwKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogZ3JvdXAuaWQsXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5jb252ZXJ0R3JvdXBUaXRsZShncm91cCksXG4gICAgICAgICAgICBpbWFnZTogdGhpcy5jb252ZXJ0R3JvdXBJbWFnZShncm91cCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlczogZ3JvdXAudmFyaWFudHMubWFwKChpdG0pID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydFZhcmlhbnQoaXRtLCBncm91cC5pZClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50c0dyb3Vwc30gdmFyaWFudHNcbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzKHZhcmlhbnRzKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5tYXAoKGl0bSkgPT4gdGhpcy5jb252ZXJ0VmFyaWFudHNHcm91cChpdG0pKTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHtncm91cDogbnVtYmVyLCBpZDogbnVtYmVyfSBhcyBTZWxlY3RlZFZhcmlhbnQgdHlwZSB7Z3JvdXBJZDogc3RyaW5nfG51bWJlciwgdmFsdWVJZDogc3RyaW5nfG51bWJlcn1cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtICAge29iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJuICB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdGVkVmFyaWFudH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBzdWJsaW1lVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwSWQ6IHZhbHVlLmdyb3VwIHx8IHZhbHVlLmdyb3VwSWQsXG4gICAgICAgICAgICB2YWx1ZUlkOiB2YWx1ZS5pZCB8fCB2YWx1ZS52YWx1ZUlkLFxuICAgICAgICB9O1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGdyb3VwIGluIGFycmF5IGJ5IGdyb3VwSWQgb3IgdW5kZWZpbmVkIGlmIGl0cyBub3QgZm91bmRcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cElkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yR3JvdXBJbmRleChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBncm91cElkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZWN0b3JHcm91cHNJdGVtcy5maW5kSW5kZXgoXG4gICAgICAgICAgICAoZ3JvdXApID0+IGdyb3VwLmlkID09PSBncm91cElkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXB9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3JHcm91cChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3JHcm91cHNJdGVtc1tpbmRleF07XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXB9IGdyb3VwXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBzZWxlY3Rvckdyb3VwSGFzVmFyaWFudHMoZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGdyb3VwICYmXG4gICAgICAgICAgICBncm91cC5kZXNjcmlwdGlvbiAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShncm91cC5kZXNjcmlwdGlvbi52YWx1ZXMpXG4gICAgICAgICk7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3VwfSBncm91cFxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3R5cGVzLmpzXCIpLlNlbGVjdG9ySXRlbXN9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3JHcm91cFZhcmlhbnRzKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBncm91cC5kZXNjcmlwdGlvbi52YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wYXJhdGlvbiBmdW5jdGlvbiwgKHZhbDogU2VsZWN0b3JJdGVtKT0+Ym9vbGVhbixcbiAgICAgKiB3aGljaCBjaGVja3MgaWYgdmFsIGhhcyBzcGVjaWZpZWQgdmFyaWFudElkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSB2YXJpYW50SWRcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlU2VsZWN0b3JHcm91cFZhbHVlSWRXaXRoKHZhcmlhbnRJZCkge1xuICAgICAgICByZXR1cm4gKHZhbCkgPT4gdmFsPy52YWx1ZT8udmFsdWVJZCA9PT0gdmFyaWFudElkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGl0ZW0gaW4gZ3JvdXAgYnkgZ3JvdXBJbmRleCBhbmQgaXRlbSB2YWx1ZUlkIG9yIHVuZGVmaW5lZCBpZiBpdHMgbm90IGZvdW5kXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXhcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50SWR9IHZhbHVlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3Rvckl0ZW1JbmRleChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBncm91cEluZGV4LCB2YWx1ZUlkKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGdyb3VwSW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3JHcm91cEhhc1ZhcmlhbnRzKGdyb3VwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSB0aGlzLmdldFNlbGVjdG9yR3JvdXBWYXJpYW50cyhncm91cCkuZmluZEluZGV4KFxuICAgICAgICAgICAgdGhpcy5jb21wYXJlU2VsZWN0b3JHcm91cFZhbHVlSWRXaXRoKHZhbHVlSWQpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpdGVtSW5kZXggPiAtMSA/IGl0ZW1JbmRleCA6IHVuZGVmaW5lZDtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7Z3JvdXBJbmRleDogbnVtYmVyLCBpdGVtSW5kZXg6IG51bWJlcn0gb3IgdW5kZWZpbmVkIGZyb20gVmFyaWFudHNHcm91cHMgYnkgZ3JvdXBJZCwgdmFsdWVJZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSBncm91cElkXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSB2YWx1ZUlkXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLkl0ZW1JbmRleGVzIHwgdW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9ySXRlbUluZGV4ZXMoc2VsZWN0b3JHcm91cHNJdGVtcywgZ3JvdXBJZCwgdmFsdWVJZCkge1xuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwSW5kZXgoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgZ3JvdXBJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZ3JvdXBJbmRleCA9PT0gLTEgfHwgdHlwZW9mIGdyb3VwSW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gdGhpcy5nZXRTZWxlY3Rvckl0ZW1JbmRleChcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgdmFsdWVJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaXRlbUluZGV4ID09PSAtMSB8fCB0eXBlb2YgaXRlbUluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgaXRlbUluZGV4LFxuICAgICAgICB9O1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSAgIHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSWRzfSAgICAgICBpdGVtSWRzXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9ySXRlbX1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3Rvckl0ZW0oc2VsZWN0b3JHcm91cHNJdGVtcywgaXRlbUlkcykge1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSW5kZXhlcyB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0b3JJdGVtSW5kZXhlcyhcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBpdGVtSWRzLmdyb3VwSWQsXG4gICAgICAgICAgICBpdGVtSWRzLnZhbHVlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwKFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICAgICAgaW5kZXhlcy5ncm91cEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yR3JvdXBIYXNWYXJpYW50cyhncm91cCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ3JvdXBWYXJpYW50cyA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cFZhcmlhbnRzKGdyb3VwKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cFZhcmlhbnRzW2luZGV4ZXMuaXRlbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdGVkVmFyaWFudCB8IHVuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgVUlMaXN0U2VsZWN0V2l0aEdyb3Vwc0JlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0U2VsZWN0b3JJdGVtU3VibGltZShzZWxlY3Rvckdyb3Vwc0l0ZW1zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMgJiZcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yR3JvdXBIYXNWYXJpYW50cyhzZWxlY3Rvckdyb3Vwc0l0ZW1zWzBdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBzZWxlY3Rvckdyb3Vwc0l0ZW1zWzBdLmlkO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVJZCA9XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtc1swXS5kZXNjcmlwdGlvbi52YWx1ZXNbMF0/LnZhbHVlPy52YWx1ZUlkO1xuICAgICAgICAgICAgaWYgKFVJQ29tbW9uLnN0cmluZ3NPZk51bWJlcnMoW2dyb3VwSWQsIHZhbHVlSWRdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHNlbGVjdG9yIGl0ZW1zXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9IHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSWRzfSBpdGVtSWRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW1Qcm9wc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY3Rpb25zVUlQcm9wc1xuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgVUlMaXN0U2VsZWN0V2l0aEdyb3Vwc0JlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVTZWxlY3Rvckl0ZW0oXG4gICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgIGl0ZW1JZHMsXG4gICAgICAgIGl0ZW1Qcm9wcyxcbiAgICAgICAgYWN0aW9uc1VJUHJvcHNcbiAgICApIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0b3JJdGVtSW5kZXhlcyhcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBpdGVtSWRzLmdyb3VwSWQsXG4gICAgICAgICAgICBpdGVtSWRzLnZhbHVlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoaXRlbVByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXNbaW5kZXhlcy5ncm91cEluZGV4XS5kZXNjcmlwdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgaW5kZXhlcy5pdGVtSW5kZXhcbiAgICAgICAgICAgIF1ba2V5XSA9IGl0ZW1Qcm9wc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShcbiAgICAgICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zW2luZGV4ZXMuZ3JvdXBJbmRleF0uZGVzY3JpcHRpb24udmFsdWVzW1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLml0ZW1JbmRleFxuICAgICAgICAgICAgICAgIF0uYWN0aW9uc1xuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtc1tpbmRleGVzLmdyb3VwSW5kZXhdLmRlc2NyaXB0aW9uLnZhbHVlc1tcbiAgICAgICAgICAgICAgICBpbmRleGVzLml0ZW1JbmRleFxuICAgICAgICAgICAgXS5hY3Rpb25zLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVpUHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXNbaW5kZXhlcy5ncm91cEluZGV4XS5kZXNjcmlwdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuaXRlbUluZGV4XG4gICAgICAgICAgICAgICAgXVswXVtrZXldID0gYWN0aW9uc1VJUHJvcHNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9IHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSWRzfSAgIGl0ZW1JZHNcbiAgICAgKiBAbWVtYmVyb2YgVUlMaXN0U2VsZWN0V2l0aEdyb3Vwc0JlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyB1aU9uKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGl0ZW1JZHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rvckl0ZW0oXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgaXRlbUlkcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLlVJX1BST1BTX0RFTFRBX09OLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgLi4udGhpcy5VSV9QUk9QU19ERUxUQV9PTl9BQ1RJT04gfVxuICAgICAgICApO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuSXRlbUlkc30gICBpdGVtSWRzXG4gICAgICogQG1lbWJlcm9mIFVJTGlzdFNlbGVjdFdpdGhHcm91cHNCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgdWlPZmYoc2VsZWN0b3JHcm91cHNJdGVtcywgaXRlbUlkcykge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdG9ySXRlbShcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBpdGVtSWRzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuVUlfUFJPUFNfREVMVEFfT0ZGLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgLi4udGhpcy5VSV9QUk9QU19ERUxUQV9PRkZfQUNUSU9OIH1cbiAgICAgICAgKTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgc3RhdGljIHN5bmNVSVdpdGhWYWx1ZShzZWxlY3Rvckdyb3VwcywgaXRlbUluVmFsdWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBzZWxlY3Rvckdyb3Vwcykge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldFNlbGVjdG9yR3JvdXBWYXJpYW50cyhncm91cCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSWRzID0ge1xuICAgICAgICAgICAgICAgICAgICBncm91cElkOiBncm91cC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVJZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpdGVtSW5WYWx1ZShpdGVtSWRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpT24oc2VsZWN0b3JHcm91cHMsIGl0ZW1JZHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWlPZmYoc2VsZWN0b3JHcm91cHMsIGl0ZW1JZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3JHcm91cHM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBzVUlUcmVlRFRPO1xuIiwiaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb24uanNcIjtcblxuY2xhc3MgTGlzdEdyb3Vwc1ZhbHVlRFRPTXVsdGlwbGVCZWhhdmlvdXIge1xuICAgIHN0YXRpYyBjb3VudEl0ZW1zSW5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlKS5yZWR1Y2UoKGEsIGIpID0+IChhICs9IGIubGVuZ3RoKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh2YWx1ZSkuZXZlcnkodGhpcy5ncm91cEl0ZW1zSXNWYWxpZClcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDoge307XG4gICAgfVxuXG4gICAgc3RhdGljIGdyb3VwSXRlbXNJc1ZhbGlkKGdyb3VwSXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGdyb3VwSXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwSXRlbXMuZXZlcnkoKGl0bSkgPT4gVUlDb21tb24uc3RyaW5nT3JOdW1iZXIoaXRtKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGl0ZW1JblZhbHVlKHZhbHVlLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKHZhbHVlLCBpdGVtLmdyb3VwSWQpICYmXG4gICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLmluY2x1ZGVzKGl0ZW0udmFsdWVJZClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xlYXJGcm9tRW1wdHlHcm91cHModmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBJc0VtcHR5KHZhbHVlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBncm91cElzRW1wdHkoZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwICYmIEFycmF5LmlzQXJyYXkoZ3JvdXApKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGdyb3VwSXNGdWxsKHZhbHVlR3JvdXAsIHZhcmlhbnRzR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlR3JvdXAubGVuZ3RoID09PSB2YXJpYW50c0dyb3VwPy52YXJpYW50cz8ubGVuZ3RoO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmF0TGVhc3RPbmUgJiYgdGhpcy5jb3VudEl0ZW1zSW5WYWx1ZSh2YWx1ZSkgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLnNwbGljZShcbiAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0uaW5kZXhPZihpdGVtLnZhbHVlSWQpLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsZWFyRnJvbUVtcHR5R3JvdXBzKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5MaXN0R3JvdXBzT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJdGVtVG9WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5vbmx5T25lUGVyR3JvdXApIHtcbiAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0gPSBbaXRlbS52YWx1ZUlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmFsdWVbaXRlbS5ncm91cElkXSB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZVtpdGVtLmdyb3VwSWRdKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0gPSBbaXRlbS52YWx1ZUlkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZVtpdGVtLmdyb3VwSWRdLmluY2x1ZGVzKGl0ZW0udmFsdWVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbaXRlbS5ncm91cElkXS5wdXNoKGl0ZW0udmFsdWVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdEFsbCh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyaWFudHMuZm9yRWFjaCgodmFyaWFudHNHcm91cCkgPT4ge1xuICAgICAgICAgICAgdmFyaWFudHNHcm91cC52YXJpYW50cy5mb3JFYWNoKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtVG9WYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHZhcmlhbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiB2YXJpYW50c0dyb3VwLmlkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0Tm9uZSh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goKGdyb3VwSWQpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtncm91cElkXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdEFsbEluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghVUlDb21tb24uc3RyaW5nT3JOdW1iZXIoZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YXJpYW50c0dyb3VwID0gdmFyaWFudHMuZmluZCgoaXRtKSA9PiBpdG0uaWQgPT0gZ3JvdXBJZCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF2YXJpYW50c0dyb3VwIHx8XG4gICAgICAgICAgICAhdmFyaWFudHNHcm91cC52YXJpYW50cyB8fFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFyaWFudHNHcm91cC52YXJpYW50cylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFudHNHcm91cC52YXJpYW50cy5mb3JFYWNoKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZEl0ZW1Ub1ZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZUlkOiB2YXJpYW50LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3ROb25lSW5Hcm91cCh2YXJpYW50cywgdmFsdWUsIGdyb3VwSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHZhbHVlW2dyb3VwSWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbZ3JvdXBJZF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyaWFudHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwSXNFbXB0eShncm91cC5pZCkpIHJldHVybjtcbiAgICAgICAgICAgIGdyb3VwLnZhcmlhbnRzLmZvckVhY2goKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUluVmFsdWUodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZDogdmFyaWFudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2dyb3VwLmlkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtncm91cC5pZF0ucHVzaCh2YXJpYW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtncm91cC5pZF0gPSBbdmFyaWFudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91cjtcbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbmNsYXNzIExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91ciB7XG4gICAgc3RhdGljIGNvdW50SXRlbXNJblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICAgICAgVUlDb21tb24uc3RyaW5nc09mTnVtYmVycyhbdmFsdWUudmFsdWVJZCwgdmFsdWUuZ3JvdXBJZF0pXG4gICAgICAgICAgICA/IDFcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICAgICAgVUlDb21tb24uc3RyaW5nc09mTnVtYmVycyhbdmFsdWUudmFsdWVJZCwgdmFsdWUuZ3JvdXBJZF0pXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IHsgdmFsdWVJZDogdW5kZWZpbmVkLCBncm91cElkOiB1bmRlZmluZWQgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24odmFsdWUsIFwiZ3JvdXBJZFwiKSAmJlxuICAgICAgICAgICAgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ2YWx1ZUlkXCIpICYmXG4gICAgICAgICAgICBVSUNvbW1vbi5zdHJpbmdzT2ZOdW1iZXJzKFt2YWx1ZS52YWx1ZUlkLCB2YWx1ZS5ncm91cElkXSkgJiZcbiAgICAgICAgICAgIHZhbHVlLmdyb3VwSWQgPT0gaXRlbS5ncm91cElkICYmXG4gICAgICAgICAgICB2YWx1ZS52YWx1ZUlkID09IGl0ZW0udmFsdWVJZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLkxpc3RHcm91cHNPcHRpb25zfSBvcHRpb25zXG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5hdExlYXN0T25lKSB7XG4gICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLnNwbGljZShcbiAgICAgICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLmluZGV4T2YoaXRlbS52YWx1ZUlkKSxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGFkZEl0ZW1Ub1ZhbHVlKHZhbHVlLCBpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbml0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZS52YWx1ZUlkID0gaXRlbS52YWx1ZUlkO1xuICAgICAgICB2YWx1ZS5ncm91cElkID0gaXRlbS5ncm91cElkO1xuICAgIH1cblxuICAgIHN0YXRpYyB2YWx1ZUFzVmFyaWFudHModmFsdWUsIHZhcmlhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50SXRlbXNJblZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzXG4gICAgICAgICAgICAgICAgLmZpbmQoKGdyb3VwKSA9PiBncm91cC5pZCA9PT0gdmFsdWUuZ3JvdXBJZClcbiAgICAgICAgICAgICAgICAudmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5pZCA9PT0gdmFsdWUudmFsdWVJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91cjtcbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbmltcG9ydCBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91ciBmcm9tIFwiLi9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8ubXVsdGlwbGUuYmVoYXZpb3VyLmpzXCI7XG5pbXBvcnQgTGlzdEdyb3Vwc1ZhbHVlRFRPU2luZ2xlQmVoYXZpb3VyIGZyb20gXCIuL2xpc3QuZ3JvdXBzLnZhbHVlLmR0by5zaW5nbGUuYmVoYXZpb3VyLmpzXCI7XG5cbmNsYXNzIExpc3RHcm91cHNWYWx1ZURUTyB7XG4gICAgc3RhdGljIGJlaGF2aW91cihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm11bHRpcGxlXG4gICAgICAgICAgICA/IExpc3RHcm91cHNWYWx1ZURUT011bHRpcGxlQmVoYXZpb3VyXG4gICAgICAgICAgICA6IExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91cjtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdFZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5pbml0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpdGVtSW5WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0ZWRWYWx1ZXN9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0xpc3RHcm91cHNPcHRpb25zfSBvcHRpb25zXG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNWYWx1ZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyB0b2dnbGUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtVG9WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlSXRlbUZyb21WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5yZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWRkSXRlbVRvVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuYWRkSXRlbVRvVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3RBbGwodmFyaWFudHMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3VyKG9wdGlvbnMpLnNlbGVjdEFsbCh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3ROb25lKHZhcmlhbnRzLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5zZWxlY3ROb25lKHZhcmlhbnRzLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdEFsbEluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3VyKG9wdGlvbnMpLnNlbGVjdEFsbEluR3JvdXAoXG4gICAgICAgICAgICB2YXJpYW50cyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0Tm9uZUluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3VyKG9wdGlvbnMpLnNlbGVjdE5vbmVJbkdyb3VwKFxuICAgICAgICAgICAgdmFyaWFudHMsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIHZhbHVlQXNWYXJpYW50cyh2YWx1ZSwgdmFyaWFudHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3VyKG9wdGlvbnMpLnZhbHVlQXNWYXJpYW50cyh2YWx1ZSwgdmFyaWFudHMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlzdEdyb3Vwc1ZhbHVlRFRPO1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLy9cbiAgICBpbXBvcnQgVUlMaXN0IGZyb20gXCIuLi91aS5saXN0LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi8uLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUltYWdlIGZyb20gXCIuLi8uLi9pbWFnZS91aS5pbWFnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi8uLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBMaXN0R3JvdXBzVUlUcmVlRFRPIGZyb20gXCIuL2R0by9saXN0Lmdyb3Vwcy51aS50cmVlLmR0by5qc1wiO1xuICAgIGltcG9ydCBMaXN0R3JvdXBzVmFsdWVEVE8gZnJvbSBcIi4vZHRvL2xpc3QuZ3JvdXBzLnZhbHVlLmR0by5qc1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICAgICAgW2ZpZWxkbmFtZSA9IFwibGlzdC1zZWxlY3RcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW29uY2hhbmdlXSAgY2FsbGJhY2sgb24gdmFsdWUgY2hhbmdlIGV2ZW50XG4gICAgICogQHByb3BlcnR5IHthcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5WYXJpYW50c0dyb3Vwcz59ICAgW3ZhcmlhbnRzID0gW11dICAgICAgICAgICB2YXJpYW50cyB0byBzZWxlY3QgZnJvbVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8aW1wb3J0KCcuL3R5cGVzLmpzJykuU2VsZWN0ZWRWYWx1ZXN9ICBbdmFyaWFudHNTZWxlY3RlZF0gLSBtdWx0aXBsZSAmJiBtdWx0aXBsZSBpbiBncm91cFxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8aW1wb3J0KCcuL3R5cGVzLmpzJykuU2VsZWN0ZWRWYXJpYW50c30gIHZhbHVlIC0ge1tncm91cElkXTogWy4uLnZhbHVlc09mU2VsZWN0ZWRJdGVtc119XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFtiZWhhdmlvdXJVSSA9IExpc3RHcm91cHNVSVRyZWVEVE9dXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFtiZWhhdmlvdXJWYWx1ZSA9IExpc3RHcm91cHNWYWx1ZURUT11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgW211bHRpcGxlID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB3YW50IG5vdCBvbmUgdmFyaWFudCBzZWxlY3RlZFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICBbb25seU9uZVBlckdyb3VwID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgW2F0TGVhc3RPbmUgPSB0cnVlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBubyBlbXB0eSByZXN1bHRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW3RpdGxlQ29tcG9uZW50UHJvcHM9IHsgc2l6ZTogNSB9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbaW1hZ2VDb21wb25lbnRQcm9wcz0geyBjb3ZlcmVkOiB0cnVlIH1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtkZXNjcmlwdGlvbkNvbXBvbmVudCA9IFVJQnV0dG9uc11cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2xpc3RDb21wb25lbnQgPSBVSUxpc3RdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFtsaXN0Q29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKi9cblxuICAgIGxldCBzZWxlY3Rvckdyb3VwcyA9ICRzdGF0ZShbXSk7XG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwibGlzdC1zZWxlY3QtdGFnc1wiLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0ge30sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBiZWhhdmlvdXJVSSA9IExpc3RHcm91cHNVSVRyZWVEVE8sXG4gICAgICAgIGJlaGF2aW91clZhbHVlID0gTGlzdEdyb3Vwc1ZhbHVlRFRPLFxuICAgICAgICBtdWx0aXBsZSA9IGZhbHNlLFxuICAgICAgICBvbmx5T25lUGVyR3JvdXAgPSB0cnVlLFxuICAgICAgICBhdExlYXN0T25lID0gdHJ1ZSxcblxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDUgfSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlLFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RDb21wb25lbnQ6IFVJTGlzdENvbXBvbmVudCA9IFVJTGlzdCxcbiAgICAgICAgbGlzdENvbXBvbmVudFByb3BzID0ge30sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlVUkoKSB7XG4gICAgICAgIHNlbGVjdG9yR3JvdXBzID0gYmVoYXZpb3VyVUkuc3luY1VJV2l0aFZhbHVlKFxuICAgICAgICAgICAgc2VsZWN0b3JHcm91cHMsXG4gICAgICAgICAgICAoaXRlbUlkcykgPT5cbiAgICAgICAgICAgICAgICBiZWhhdmlvdXJWYWx1ZS5pdGVtSW5WYWx1ZSh2YWx1ZSwgaXRlbUlkcywge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHNlbGVjdG9yR3JvdXBzID0gYmVoYXZpb3VyVUkuYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzKHZhcmlhbnRzKTtcbiAgICAgICAgdmFsdWUgPSBiZWhhdmlvdXJWYWx1ZS5pbml0VmFsdWUodmFsdWUsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgfSk7XG5cbiAgICBleHBvcnQgY29uc3QgdmFsdWVBc1ZhcmlhbnRzID0gKCkgPT5cbiAgICAgICAgYmVoYXZpb3VyVmFsdWUudmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cyk7XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0gdmFsdWVBc1ZhcmlhbnRzKCk7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGNvbnN0IHRvZ2dsZUl0ZW0gPSAoaXRlbVZhbHVlKSA9PiB7XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnRvZ2dsZSh2YWx1ZSwgaXRlbVZhbHVlLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVwZGF0ZVVJKCk7XG5cbiAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgIH07XG48L3NjcmlwdD5cblxuPFVJTGlzdENvbXBvbmVudFxuICAgIHsuLi5saXN0Q29tcG9uZW50UHJvcHN9XG4gICAge3RpdGxlQ29tcG9uZW50fVxuICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzPXt7XG4gICAgICAgIGFjdGlvbihldmVudCwgaXRlbVZhbHVlKSB7XG4gICAgICAgICAgICB0b2dnbGVJdGVtKGl0ZW1WYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMsXG4gICAgfX1cbiAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgaXRlbXM9e3NlbGVjdG9yR3JvdXBzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8vXG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9uc1N3aXRjaGVycyBmcm9tIFwiLi4vLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3dpdGNoZXJzLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IExpc3RHcm91cHNVSVRyZWVEVE8gZnJvbSBcIi4vZHRvL2xpc3QuZ3JvdXBzLnVpLnRyZWUuZHRvLmpzXCI7XG4gICAgaW1wb3J0IExpc3RHcm91cHNWYWx1ZURUTyBmcm9tIFwiLi9kdG8vbGlzdC5ncm91cHMudmFsdWUuZHRvLmpzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNoYW5nZV0gIGNhbGxiYWNrIG9uIHZhbHVlIGNoYW5nZSBldmVudFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lPVwibGlzdC1zZWxlY3QtdGFnc1wiXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi90eXBlcycpLlZhcmlhbnRzR3JvdXBzfSBbdmFyaWFudHMgPSBbXV0gLVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi90eXBlcycpLlNlbGVjdGVkVmFsdWVzfSBbdmFyaWFudHNTZWxlY3RlZCA9IHt9XSAtIG11bHRpcGxlICYmIG11bHRpcGxlIGluIGdyb3VwXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uL3R5cGVzJykuU2VsZWN0ZWRWYXJpYW50c30gW3ZhbHVlID0gW11dXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtiZWhhdmlvdXJVSSA9IExpc3RHcm91cHNVSVRyZWVEVE9dXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtiZWhhdmlvdXJWYWx1ZSA9IExpc3RHcm91cHNWYWx1ZURUT11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttdWx0aXBsZSA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb25seU9uZVBlckdyb3VwID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdExlYXN0T25lID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNX1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2ltYWdlQ29tcG9uZW50ID0gVUlJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW2ltYWdlQ29tcG9uZW50UHJvcHMgPSB7IGNvdmVyZWQ6IHRydWUgfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25Db21wb25lbnQgPSBVSUJ1dHRvbnNTd2l0Y2hlcnNdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2xpc3RDb21wb25lbnQgPSBVSUxpc3RdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtsaXN0Q29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFthY3Rpb25zTGlzdD1bXCJzZWxlY3RBbGxcIiwgXCJzZWxlY3ROb25lXCJdXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwibGlzdC1zZWxlY3QtdGFnc1wiLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0ge30sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAvL2JlaGF2aW91ciBtYW5hZ2Vyc1xuICAgICAgICBiZWhhdmlvdXJVSSA9IExpc3RHcm91cHNVSVRyZWVEVE8sXG4gICAgICAgIGJlaGF2aW91clZhbHVlID0gTGlzdEdyb3Vwc1ZhbHVlRFRPLFxuICAgICAgICAvL2JlaGF2aW91ciBvcHRpb25zXG4gICAgICAgIG11bHRpcGxlID0gdHJ1ZSxcbiAgICAgICAgb25seU9uZVBlckdyb3VwID0gdHJ1ZSxcbiAgICAgICAgYXRMZWFzdE9uZSA9IHRydWUsXG4gICAgICAgIC8vY29tb3BuZW50cywgcmVuZGVyZXJzIGFuZCBwcm9wcyBmb3IgdGhlbVxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDUgfSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlLFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zU3dpdGNoZXJzLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RDb21wb25lbnQ6IFVJTGlzdENvbXBvbmVudCA9IFVJTGlzdCxcbiAgICAgICAgbGlzdENvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGFjdGlvbnNMaXN0ID0gW1wic2VsZWN0QWxsXCIsIFwic2VsZWN0Tm9uZVwiXSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICAvL1xuXG4gICAgY29uc3QgQVZBSUxBQkxFX0FDVElPTlMgPSB7XG4gICAgICAgIHNlbGVjdEFsbDoge1xuICAgICAgICAgICAgdGl0bGU6IFwi0JLRi9Cx0YDQsNGC0Ywg0LLRgdC1XCIsXG4gICAgICAgICAgICBjb2xvcjogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3ROb25lOiB7XG4gICAgICAgICAgICB0aXRsZTogXCLQodC90Y/RgtGMINCy0YvQtNC10LvQtdC90LjQtSDRgdC+INCy0YHQtdGFXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJcIixcbiAgICAgICAgICAgIGFjdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3ROb25lKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBsZXQgQUNUSU9OUyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IHNlbGVjdG9yR3JvdXBzID0gJHN0YXRlKFtdKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVVJKCkge1xuICAgICAgICBzZWxlY3Rvckdyb3VwcyA9IGJlaGF2aW91clVJLnN5bmNVSVdpdGhWYWx1ZShcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzLFxuICAgICAgICAgICAgKGl0ZW1JZHMpID0+XG4gICAgICAgICAgICAgICAgYmVoYXZpb3VyVmFsdWUuaXRlbUluVmFsdWUodmFsdWUsIGl0ZW1JZHMsIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGV4cG9ydCBjb25zdCB2YWx1ZUFzVmFyaWFudHMgPSAoKSA9PlxuICAgICAgICBiZWhhdmlvdXJWYWx1ZS52YWx1ZUFzVmFyaWFudHModmFsdWUsIHZhcmlhbnRzKTtcblxuICAgIGZ1bmN0aW9uIHRyaWdnZXJDaGFuZ2UoKSB7XG4gICAgICAgIHZhcmlhbnRzU2VsZWN0ZWQgPSB2YWx1ZUFzVmFyaWFudHMoKTtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgYWN0aW9uc0xpc3QuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0Lmhhc093bihBVkFJTEFCTEVfQUNUSU9OUywgbmFtZSlcbiAgICAgICAgICAgICAgICA/IEFDVElPTlMucHVzaChBVkFJTEFCTEVfQUNUSU9OU1tuYW1lXSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgQUNUSU9OUyA9IEFDVElPTlM7XG4gICAgICAgIHNlbGVjdG9yR3JvdXBzID0gYmVoYXZpb3VyVUkuYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzKHZhcmlhbnRzKTtcbiAgICAgICAgdmFsdWUgPSBiZWhhdmlvdXJWYWx1ZS5pbml0VmFsdWUodmFsdWUsIHsgbXVsdGlwbGUgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgfSk7XG5cbiAgICBleHBvcnQgY29uc3Qgc2VsZWN0QWxsID0gKCkgPT4ge1xuICAgICAgICBiZWhhdmlvdXJWYWx1ZS5zZWxlY3RBbGwodmFyaWFudHMsIHZhbHVlLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCBzZWxlY3ROb25lID0gKCkgPT4ge1xuICAgICAgICBiZWhhdmlvdXJWYWx1ZS5zZWxlY3ROb25lKHZhcmlhbnRzLCB2YWx1ZSwge1xuICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3Qgc2VsZWN0QWxsSW5Hcm91cCA9IChncm91cElkKSA9PiB7XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnNlbGVjdEFsbEluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCBzZWxlY3ROb25lSW5Hcm91cCA9IChncm91cElkKSA9PiB7XG4gICAgICAgIGJlaGF2aW91ci5zZWxlY3ROb25lSW5Hcm91cCh2YXJpYW50cywgdmFsdWUsIGdyb3VwSWQsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHRvZ2dsZUl0ZW0gPSAoaXRlbVZhbHVlKSA9PiB7XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnRvZ2dsZSh2YWx1ZSwgaXRlbVZhbHVlLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxVSUJ1dHRvbnMgdmFsdWVzPXtBQ1RJT05TfSBjZW50ZXJlZD17dHJ1ZX0gLz5cblxuPFVJTGlzdENvbXBvbmVudFxuICAgIHsuLi5saXN0Q29tcG9uZW50UHJvcHN9XG4gICAge3RpdGxlQ29tcG9uZW50fVxuICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzPXt7XG4gICAgICAgIGFjdGlvbihldmVudCwgaXRlbVZhbHVlKSB7XG4gICAgICAgICAgICB0b2dnbGVJdGVtKGl0ZW1WYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMsXG4gICAgfX1cbiAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgaXRlbXM9e3NlbGVjdG9yR3JvdXBzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgZmFkZSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiO1xuICAgIGltcG9ydCB7IG9uTW91bnQsIG9uRGVzdHJveSB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCB7IFVJQnV0dG9uQ2xvc2UgfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG5cbiAgICBsZXQgb3ZlcmZsb3dTYXZlID0gJHN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgZGVmYXVsdENsb3NlQnV0dG9uUHJvcHMgPSB7XG4gICAgICAgIGNsYXNzOiBcImlzLWFic29sdXRlIGlzLXNpZGVkLXJpZ2h0IGlzLXNpZGVkLXRvcFwiLFxuICAgICAgICBzdHlsZTogXCItLXNpZGluZy1yaWdodC1zaXplOiAycmVtOyAtLXNpZGluZy10b3Atc2l6ZTogMnJlbVwiLFxuICAgICAgICBzaXplOiBcIm5vcm1hbFwiLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtjbG9zZUJ1dHRvbiA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtjbG9zZUJ1dHRvblByb3BzID0gZGVmYXVsdENsb3NlQnV0dG9uUHJvcHNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3Nob3cgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtjbG9zZU9uQ2xpY2sgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtsYXllciA9IDFdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbekluZGV4U3RlcCA9IDEwMDBdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGUgPSAnYnV0dG9uJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdGFiSW5kZXggPSAnYnV0dG9uJ11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjbG9zZUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICBjbG9zZUJ1dHRvblByb3BzID0gZGVmYXVsdENsb3NlQnV0dG9uUHJvcHMsXG4gICAgICAgIHNob3cgPSB0cnVlLFxuICAgICAgICBjbG9zZU9uQ2xpY2sgPSB0cnVlLFxuICAgICAgICBsYXllciA9IDEsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIG9ucmVqZWN0ID0gKCkgPT4gZmFsc2UsXG4gICAgICAgIHpJbmRleFN0ZXAgPSAxMDAwLFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSBcIjBcIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvdmVybGF5Q2xpY2soZSkge1xuICAgICAgICBpZiAoY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgICAgICBjbG9zZU92ZXJsYXkoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUJ1dHRvbkNsaWNrKCkge1xuICAgICAgICByZWplY3RPdmVybGF5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VPdmVybGF5KGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChlICYmIGUub3JpZ2luYWxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLm9yaWdpbmFsVGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdCAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXMtb3ZlcmxheVwiKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3RPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdE92ZXJsYXkoZGF0YSA9IHt9KSB7XG4gICAgICAgIHNob3cgPSBmYWxzZTtcbiAgICAgICAgb25yZWplY3QoZGF0YSk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIG92ZXJmbG93U2F2ZSA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvd1NhdmU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvd1NhdmU7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBzaG93fVxuICAgIDxkaXZcbiAgICAgICAgdHJhbnNpdGlvbjpmYWRlXG4gICAgICAgIGNsYXNzPVwiaXMtb3ZlcmxheSBub3Qtb3ZlcmxheSB7Y2xhc3Nlc31cIlxuICAgICAgICBvbmNsaWNrPXtvdmVybGF5Q2xpY2t9XG4gICAgICAgIG9ua2V5dXA9e292ZXJsYXlDbGlja31cbiAgICAgICAge3JvbGV9XG4gICAgICAgIHt0YWJJbmRleH1cbiAgICAgICAgc3R5bGU9XCJ6LWluZGV4OiB7ekluZGV4U3RlcCAqIGxheWVyfTtcIlxuICAgID5cbiAgICAgICAgeyNpZiBjbG9zZUJ1dHRvbn1cbiAgICAgICAgICAgIDxVSUJ1dHRvbkNsb3NlIHsuLi5jbG9zZUJ1dHRvblByb3BzfSBvbmNsaWNrPXtjbG9zZUJ1dHRvbkNsaWNrfSAvPlxuICAgICAgICB7L2lmfVxuICAgICAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlPdmVybGF5IGZyb20gXCIuL3VpLm92ZXJsYXkuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlCb3ggZnJvbSBcIi4uL2Jsb2NrL3VpLmJveC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250ZW50IGZyb20gXCIuLi9ibG9jay91aS5jb250ZW50LnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9uc1JvdyBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbnMucm93LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFVJTG9hZGVyIH0gZnJvbSBcIi4uL3ZhcmlvdXNcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtidXR0b25zUG9zaXRpb24gPSBcImJvdHRvbVwiXSAgICAgICAgICAgdG9wLCB0b3BPZkNvbnRlbnQsIGJvdHRvbVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Z1bGxzY3JlZW4gPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbG9zZUJ1dHRvbiA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FwcGx5QnV0dG9uID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aXRsZVNpemUgPSAyXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3cgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZT0gXCJNb2RhbCB3aW5kb3dcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N1YnRpdGxlID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW292ZXJsYXlDbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtidXR0b25zQ2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbV0FJVElOR19URVhUID0gXCLQntCx0YDQsNCx0L7RgtC60LBcIl1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBidXR0b25zUG9zaXRpb24gPSBcImJvdHRvbVwiLFxuICAgICAgICBmdWxsc2NyZWVuID0gZmFsc2UsXG4gICAgICAgIGNsb3NlQnV0dG9uID0gZmFsc2UsXG4gICAgICAgIGFwcGx5QnV0dG9uID0gZmFsc2UsXG4gICAgICAgIHRpdGxlU2l6ZSA9IDIsXG4gICAgICAgIHNob3cgPSBmYWxzZSxcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlLFxuICAgICAgICB0aXRsZSA9IFwiTW9kYWwgd2luZG93XCIsXG4gICAgICAgIHN1YnRpdGxlID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvdmVybGF5Q2xhc3M6IG92ZXJsYXlDbGFzcyA9IFwiXCIsXG4gICAgICAgIGJ1dHRvbnNDbGFzczogYnV0dG9uc0NsYXNzID0gXCJcIixcbiAgICAgICAgV0FJVElOR19URVhUID0gXCLQntCx0YDQsNCx0L7RgtC60LBcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjc25pcHBldCBidXR0b25zKG1vcmVDbGFzc2VzcyA9IFwiXCIpfVxuICAgIDxVSUJ1dHRvbnNSb3dcbiAgICAgICAgY2xhc3M9e2J1dHRvbnNDbGFzcyB8fCBtb3JlQ2xhc3Nlc3N9XG4gICAgICAgIGxlZnQ9e2Nsb3NlQnV0dG9uID8gW2Nsb3NlQnV0dG9uXSA6IFtdfVxuICAgICAgICByaWdodD17YXBwbHlCdXR0b24gPyBbYXBwbHlCdXR0b25dIDogW119XG4gICAgLz5cbnsvc25pcHBldH1cblxuPFVJT3ZlcmxheSB7c2hvd30gY2xvc2VPbkNsaWNrPXtmYWxzZX0gY2xvc2VCdXR0b249e2ZhbHNlfSBjbGFzcz17b3ZlcmxheUNsYXNzfT5cbiAgICA8VUlCb3ggY2xhc3M9e2Ake2NsYXNzZXN9ICR7ZnVsbHNjcmVlbiA/IFwiaXMtZnVsbHNjcmVlblwiIDogXCJcIn1gfT5cbiAgICAgICAgeyNpZiBidXR0b25zUG9zaXRpb24gPT09IFwidG9wXCJ9XG4gICAgICAgICAgICB7QHJlbmRlciBidXR0b25zKFwiXCIpfVxuICAgICAgICB7L2lmfVxuICAgICAgICA8VUlUaXRsZSBzaXplPXt0aXRsZVNpemV9IHt0aXRsZX0ge3N1YnRpdGxlfSAvPlxuICAgICAgICA8VUlDb250ZW50PlxuICAgICAgICAgICAgPFVJTG9hZGVyIHNpemU9XCJwYWdlXCIge2xvYWRpbmd9IHRpdGxlPXtXQUlUSU5HX1RFWFR9IC8+XG5cbiAgICAgICAgICAgIHsjaWYgYnV0dG9uc1Bvc2l0aW9uID09PSBcInRvcE9mQ29udGVudFwifVxuICAgICAgICAgICAgICAgIHtAcmVuZGVyIGJ1dHRvbnMoXCJcIil9XG4gICAgICAgICAgICB7L2lmfVxuXG4gICAgICAgICAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG5cbiAgICAgICAgICAgIHsjaWYgYnV0dG9uc1Bvc2l0aW9uID09PSBcImJvdHRvbVwifVxuICAgICAgICAgICAgICAgIHtAcmVuZGVyIGJ1dHRvbnMoYGlzLW1vYmlsZSAke2Z1bGxzY3JlZW4gPyBcImlzLWZvb3RlclwiIDogXCJcIn1gKX1cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvVUlDb250ZW50PlxuICAgIDwvVUlCb3g+XG48L1VJT3ZlcmxheT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU92ZXJsYXkgZnJvbSBcIi4vdWkub3ZlcmxheS5zdmVsdGVcIjtcblxuICAgIGltcG9ydCB7IFVJRW5kbGVzc0xpc3QgfSBmcm9tIFwiLi4vbGlzdC9lbmRsZXNzXCI7XG4gICAgaW1wb3J0IFVJU2ltcGxlU2VhcmNoSW5wdXQgZnJvbSBcIi4uL3ZhcmlvdXMvdWkuc2ltcGxlLnNlYXJjaC5pbnB1dC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJveCwgVUlCbG9jayB9IGZyb20gXCIuLi9ibG9ja1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgICAgIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5ICAgIHtib29sZWFufSAgIFtzaG93XVxuICAgICAqIEBwcm9wZXJ0eSAgICB7Ym9vbGVhbn0gICBbc2hvd1NlYXJjaCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5ICAgIHtzdHJpbmd9ICAgIFt0ZXJtXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7KGZ1bGxzY3JlZW58d2lkZXxub3JtYWx8bmFycm93KX0gW3NpemVdICAgMTAwdncsIDc1dncsIDUwdncsIDI1dndcbiAgICAgKiBAcHJvcGVydHkgICAge2FueX0gICAgICAgW2lucHV0Q29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSAgICB7b2JqZWN0fSAgICBbaW5wdXRDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkgICAge2FueX0gICAgICAgW291dHB1dENvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkgICAge29iamVjdH0gICAgW291dHB1dENvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7b2JqZWN0fSAgICBbYnV0dG9uc1Byb3BzID0geyBjZW50ZXJlZDogdHJ1ZSwgY2xhc3M6IFwibXQtNVwiLH1dXG4gICAgICogQHByb3BlcnR5ICAgIHtvYmplY3R9ICAgIFtyZXN1bHRzXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7ZnVuY3Rpb259ICBbb25wcmV2XVxuICAgICAqIEBwcm9wZXJ0eSAgICB7ZnVuY3Rpb259ICBbb25uZXh0XVxuICAgICAqIEBwcm9wZXJ0eSAgICB7ZnVuY3Rpb259ICBbb25jaGFuZ2VdXG4gICAgICogQHByb3BlcnR5ICAgIHtmdW5jdGlvbn0gIFtvbnJlamVjdF1cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29ucmVzb2x2ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgc2hvdyA9IHRydWUsXG4gICAgICAgIHNob3dTZWFyY2ggPSB0cnVlLFxuICAgICAgICB0ZXJtID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBzaXplID0gXCJuYXJyb3dcIixcbiAgICAgICAgaW5wdXRDb21wb25lbnQ6IFVJSW5wdXRDb21wb25lbnQgPSBVSVNpbXBsZVNlYXJjaElucHV0LFxuICAgICAgICBpbnB1dENvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIG91dHB1dENvbXBvbmVudDogVUlPdXRwdXRDb21wb25lbnQgPSBVSUVuZGxlc3NMaXN0LFxuICAgICAgICBvdXRwdXRDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBidXR0b25zUHJvcHMgPSB7XG4gICAgICAgICAgICBjZW50ZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzOiBcIm10LTVcIixcbiAgICAgICAgfSxcbiAgICAgICAgcmVqZWN0QnV0dG9uUHJvcHMgPSB7fSxcbiAgICAgICAgcmVzdWx0cyA9ICRiaW5kYWJsZSh7IGxpc3Q6IFtdLCBwYWdlOiAwLCBwYWdlczogMCwgc2tpcDogMCwgY291bnQ6IDAgfSksXG4gICAgICAgIG9uY2hhbmdlLFxuICAgICAgICBvbnByZXYsXG4gICAgICAgIG9ubmV4dCxcbiAgICAgICAgb25yZXNvbHZlLFxuICAgICAgICBvbnJlamVjdCxcbiAgICAgICAgaXRlbVJlbmRlcmVyLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGJ1dHRvbnMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAkTE9DQUxFW1wibm90LW5vZGU6YnV0dG9uX2NhbmNlbF9sYWJlbFwiXSxcbiAgICAgICAgICAgIGFjdGlvbjogb25yZWplY3QsXG4gICAgICAgICAgICAuLi5yZWplY3RCdXR0b25Qcm9wcyxcbiAgICAgICAgfSxcbiAgICBdO1xuPC9zY3JpcHQ+XG5cbjxVSU92ZXJsYXkge29ucmVqZWN0fSB7c2hvd30gY2xvc2VPbkNsaWNrPXt0cnVlfSBjbG9zZUJ1dHRvbj17ZmFsc2V9PlxuICAgIDxVSUJveCBjbGFzcz1cIm1vZGFsLXNlbGVjdG9yIHtzaXplfVwiPlxuICAgICAgICB7I2lmIHNob3dTZWFyY2h9XG4gICAgICAgICAgICA8VUlJbnB1dENvbXBvbmVudCB7b25jaGFuZ2V9IGJpbmQ6dGVybSB7Li4uaW5wdXRDb21wb25lbnRQcm9wc30gLz5cbiAgICAgICAgey9pZn1cblxuICAgICAgICA8VUlPdXRwdXRDb21wb25lbnRcbiAgICAgICAgICAgIGJpbmQ6ZGF0YT17cmVzdWx0c31cbiAgICAgICAgICAgIHtvbnByZXZ9XG4gICAgICAgICAgICB7b25uZXh0fVxuICAgICAgICAgICAgb25zZWxlY3Q9e29ucmVzb2x2ZX1cbiAgICAgICAgICAgIGNsYXNzPVwiaGFzLWhlaWdodC11cC10by02MCBvdmVyZmxvdy1zY3JvbGxcIlxuICAgICAgICAgICAgey4uLm91dHB1dENvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2l0ZW1SZW5kZXJlcn1cbiAgICAgICAgLz5cblxuICAgICAgICA8VUlCdXR0b25zIHsuLi5idXR0b25zUHJvcHN9IHZhbHVlcz17YnV0dG9uc30gLz5cbiAgICA8L1VJQm94PlxuPC9VSU92ZXJsYXk+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICB0aXRsZVNuaXAsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VTbmlwLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNvbG9yLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48YXJ0aWNsZSBjbGFzcz1cIm1lc3NhZ2Uge2NsYXNzZXN9IHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ31cIj5cbiAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1oZWFkZXJcIj5cbiAgICAgICAgeyNpZiB0aXRsZVNuaXB9XG4gICAgICAgICAgICB7QHJlbmRlciB0aXRsZVNuaXAodGl0bGUpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8cD57JExPQ0FMRVt0aXRsZV19PC9wPlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLWJvZHlcIj5cbiAgICAgICAgeyNpZiBtZXNzYWdlU25pcH1cbiAgICAgICAgICAgIHtAcmVuZGVyIG1lc3NhZ2VTbmlwKG1lc3NhZ2UpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8cD57JExPQ0FMRVttZXNzYWdlXX08L3A+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG48L2FydGljbGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU1lc3NhZ2UgZnJvbSBcIi4vdWkubWVzc2FnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBVSUNvbW1vbi5DTEFTU19FUlIsIC4uLnByb3BzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlNZXNzYWdlIHsuLi5wcm9wc30gY2xhc3M9e2NsYXNzZXN9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSU1lc3NhZ2UgZnJvbSBcIi4vdWkubWVzc2FnZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBVSUNvbW1vbi5DTEFTU19PSywgLi4ucHJvcHMgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxVSU1lc3NhZ2Ugey4uLnByb3BzfSBjbGFzcz17Y2xhc3Nlc30gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttZXNzYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWdyZWVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHNob3cgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBtZXNzYWdlID0gXCLQlNC70Y8g0YPQu9GD0YfRiNC10L3QuNGPINGA0LDQsdC+0YLRiyDRgdCw0LnRgtCwINC4INC10LPQviDQstC30LDQuNC80L7QtNC10LnRgdGC0LLQuNGPINGBINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C80Lgg0LzRiyDQuNGB0L/QvtC70YzQt9GD0LXQvCDRhNCw0LnQu9GLIGNvb2tpZS4g0J/RgNC+0LTQvtC70LbQsNGPINGA0LDQsdC+0YLRgyDRgSDRgdCw0LnRgtC+0LwsINCS0Ysg0YDQsNC30YDQtdGI0LDQtdGC0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LUgY29va2llLdGE0LDQudC70L7Qsi4g0JLRiyDQstGB0LXQs9C00LAg0LzQvtC20LXRgtC1INC+0YLQutC70Y7Rh9C40YLRjCDRhNCw0LnQu9GLIGNvb2tpZSDQsiDQvdCw0YHRgtGA0L7QudC60LDRhSDQktCw0YjQtdCz0L4g0LHRgNCw0YPQt9C10YDQsC5cIixcbiAgICAgICAgYWdyZWUgPSBcItCl0L7RgNC+0YjQvlwiLFxuICAgICAgICBjb29sZG93biA9IDMxNTM2MDAwMDAwLFxuICAgICAgICBsc0tleSA9IFwiY29va2llX2RhdGVcIixcbiAgICAgICAgaWQgPSBcImNvb2tpZV9ub3RpZmljYXRpb25cIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgbGV0IGNvb2tpZURhdGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsc0tleSk7XG4gICAgICAgIGlmICghY29va2llRGF0ZSB8fCArY29va2llRGF0ZSArIGNvb2xkb3duIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgc2hvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFjY2VwdCgpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obHNLZXksIERhdGUubm93KCkpO1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgc2hvd31cbiAgICA8ZGl2IHtpZH0+XG4gICAgICAgIDxwPnskTE9DQUxFW21lc3NhZ2VdfTwvcD5cbiAgICAgICAgPFVJQnV0dG9uIG9uY2xpY2s9e2FjY2VwdH0gY29sb3I9XCJzdWNjZXNzXCIgY2xhc3M9XCJjb29raWVfYWNjZXB0XCJcbiAgICAgICAgICAgID57JExPQ0FMRVthZ3JlZV19PC9VSUJ1dHRvblxuICAgICAgICA+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiLy9ibG9jayBlbGVtZW50c1xuaW1wb3J0ICogYXMgQmxvY2tzIGZyb20gXCIuL2Jsb2NrXCI7XG5leHBvcnQgeyBCbG9ja3MgfTtcblxuLy9nZW5lcmFsIGVsZW1lbnRzXG5pbXBvcnQgKiBhcyBWYXJpb3VzIGZyb20gXCIuL3ZhcmlvdXNcIjtcbmV4cG9ydCB7IFZhcmlvdXMgfTtcblxuLy9cbmltcG9ydCAqIGFzIEJ1dHRvbnMgZnJvbSBcIi4vYnV0dG9uXCI7XG5leHBvcnQgeyBCdXR0b25zIH07XG5cbi8vZm9ybSBlbGVtZW50c1xuaW1wb3J0ICogYXMgRm9ybXMgZnJvbSBcIi4vZm9ybVwiO1xuZXhwb3J0IHsgRm9ybXMgfTtcblxuLy9pY29ucyB2YXJpYW50c1xuaW1wb3J0ICogYXMgSWNvbnMgZnJvbSBcIi4vaWNvblwiO1xuZXhwb3J0IHsgSWNvbnMgfTtcblxuLy9pbWFnZXMgdWlcbmltcG9ydCAqIGFzIEltYWdlcyBmcm9tIFwiLi9pbWFnZVwiO1xuZXhwb3J0IHsgSW1hZ2VzIH07XG5cbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi9pbnB1dFwiO1xuZXhwb3J0IHsgSW5wdXRzIH07XG5cbmltcG9ydCAqIGFzIExheW91dHMgZnJvbSBcIi4vbGF5b3V0XCI7XG5leHBvcnQgeyBMYXlvdXRzIH07XG5cbmltcG9ydCAqIGFzIExpbmtzIGZyb20gXCIuL2xpbmtcIjtcbmV4cG9ydCB7IExpbmtzIH07XG5cbmltcG9ydCAqIGFzIExpc3RzIGZyb20gXCIuL2xpc3RcIjtcbmV4cG9ydCB7IExpc3RzIH07XG5cbmltcG9ydCAqIGFzIE1vZGFscyBmcm9tIFwiLi9tb2RhbFwiO1xuZXhwb3J0IHsgTW9kYWxzIH07XG5cbmltcG9ydCAqIGFzIE5vdGlmaWNhdGlvbnMgZnJvbSBcIi4vbm90aWZpY2F0aW9uXCI7XG5leHBvcnQgeyBOb3RpZmljYXRpb25zIH07XG5cbmltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi9jb21tb25cIjtcbmV4cG9ydCB7IFVJQ29tbW9uIH07XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJ3b2xmeTg3LWV2ZW50ZW1pdHRlclwiO1xuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5cbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbmNvbnN0IE1FVEFfTUVUSE9EX0lOSVQgPSBTeW1ib2woXCJpbml0XCIpLFxuICAgIE1FVEFfREFUQSA9IFN5bWJvbChcImRhdGFcIiksXG4gICAgTUVUQV9XT1JLSU5HID0gU3ltYm9sKFwid29ya2luZ1wiKSxcbiAgICBNRVRBX09QVElPTlMgPSBTeW1ib2woXCJvcHRpb25zXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBub3RCYXNlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzW01FVEFfREFUQV0gPSB7fTtcbiAgICAgICAgdGhpc1tNRVRBX1dPUktJTkddID0ge307XG4gICAgICAgIHRoaXNbTUVUQV9PUFRJT05TXSA9IHt9O1xuICAgICAgICB0aGlzW01FVEFfTUVUSE9EX0lOSVRdKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgW01FVEFfTUVUSE9EX0lOSVRdKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGlucHV0LCBcImRhdGFcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaW5wdXQsIFwid29ya2luZ1wiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKGlucHV0LndvcmtpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpbnB1dCwgXCJvcHRpb25zXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoaW5wdXQub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZyA9IG5vdENvbW1vbi5nZW5Mb2dNc2codGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKSk7XG4gICAgICAgIHRoaXMuaW5mbyA9IHRoaXMubG9nO1xuICAgICAgICB0aGlzLmRlYnVnID0gbm90Q29tbW9uLmdlbkxvZ0RlYnVnKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgICAgICB0aGlzLmVycm9yID0gbm90Q29tbW9uLmdlbkxvZ0Vycm9yKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgIH1cblxuICAgIHNldENvbW1vbih3aGF0LCBhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8qIHNldCBjb2xsZWN0aW9uICovXG4gICAgICAgICAgICAgICAgd2hhdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAvKiBzZXQgY29sbGVjdGlvbiBlbGVtZW50ICovXG4gICAgICAgICAgICAgICAgbm90UGF0aC5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gLyogcGF0aCAqLyxcbiAgICAgICAgICAgICAgICAgICAgd2hhdCAvKiBjb2xsZWN0aW9uICovLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgLyogaGVscGVycyAqLyxcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sxXSAvKiB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldENvbW1vbih3aGF0LCBhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8qIGlmIHdlIHdhbnQgZ2V0IGRhdGEgYnkgcGF0aCAqL1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KGFyZ3NbMF0sIHdoYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaWYgd2Ugd2FudCBnZXQgZGF0YSBieSBwYXRoIHdpdGggZGVmYXVsdCB2YWx1ZSAqL1xuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IG5vdFBhdGguZ2V0KGFyZ3NbMF0sIHdoYXQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBubyBkYXRhLCByZXR1cm4gZGVmYXVsdCB2YWx1ZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBkYXRhLCByZXR1cm4gaXQgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiByZXR1cm4gZnVsbCBjb2xsZWN0aW9uICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIENPUkUgT0JKRUNUXG4gICAgICBEQVRBIC0gaW5mb3JtYXRpb25cbiAgICAgIE9QVElPTlMgLSBob3cgdG8gd29ya1xuICAgICAgV09SS0lORyAtIHRlbXBvcmFyaWx5IGdlbmVyYXRlZCBpbiBwcm9jY2Vzc1xuICAqL1xuXG4gICAgc2V0RGF0YSgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbTUVUQV9EQVRBXSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29tbW9uKHRoaXMuZ2V0RGF0YSgpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9EQVRBXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzZXRPcHRpb25zKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpc1tNRVRBX09QVElPTlNdID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21tb24odGhpcy5nZXRPcHRpb25zKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9PUFRJT05TXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzZXRXb3JraW5nKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpc1tNRVRBX1dPUktJTkddID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21tb24odGhpcy5nZXRXb3JraW5nKCksIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tbW9uKHRoaXNbTUVUQV9XT1JLSU5HXSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXBvcnQoZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLnJlcG9ydCkge1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEFwcCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgfVxufVxuIiwiaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuXG5pbXBvcnQgeyBOQVZJR0FUSU9OX0RFTEFZUywgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUIH0gZnJvbSBcIi4vY29uc3QuanNcIjtcblxuY29uc3QgT1BUX01PREVfSElTVE9SWSA9IFN5bWJvbChcImhpc3RvcnlcIiksXG4gICAgT1BUX01PREVfSEFTSCA9IFN5bWJvbChcImhhc2hcIiksXG4gICAgT1BUX0RFRkFVTFRfQ0hFQ0tfSU5URVJWQUwgPSA1MDtcblxuY2xhc3Mgbm90Um91dGVyIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgaG9zdCA9IFwiXCI7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICByb3V0ZXM6IFtdLFxuICAgICAgICAgICAgICAgIG1vZGU6IE9QVF9NT0RFX0hJU1RPUlksXG4gICAgICAgICAgICAgICAgcm9vdDogXCIvXCIsIC8vYWx3YXlzIGluIHNsYXNoZXMgL3VzZXIvLCAvLCAvaW5wdXQvLiBhbmQgbm8gL3VzZXIgb3IgaW5wdXQvbGV2ZWxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVsYXlzOiBOQVZJR0FUSU9OX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBkZWxheV9kZWZhdWx0OiBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9iamVjdCB3aXRoIG5hbWVkIGRlbGF5c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbGF5c1xuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgc2V0RGVsYXlzKGRlbGF5cykge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJkZWxheXNcIiwgZGVsYXlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgbmF2aWdhdGlvbiBkZWxheSwgcHJvdmlkZWQgYXMgbmFtZSBvZiBvbmUgb2YgYGRlbGF5c2Agb3IgaW4gbnVtYmVyIGZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGRlbGF5XG4gICAgICogQHJldHVybnMge25vdFJvdXRlcn1cbiAgICAgKi9cbiAgICBzZXREZWZhdWx0TmF2aWdhdGlvbkRlbGF5KGRlbGF5KSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImRlbGF5X2RlZmF1bHRcIiwgdGhpcy5kZWxheUFzTXMoZGVsYXkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgb2YgbXMsIGlmIG5vdCBzZXQgcmV0dXJucyBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoYGRlbGF5X2RlZmF1bHRgLCBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFbnN1cmVzIHRoYXQgZGVsYXkgaXMgaW4gbXMsIGlmIGl0cyBwcm92aWRlZCBhcyBuYW1lIG9mIGFsaWFzLCBzZWFyY2hlcyBmb3IgaXQgYW5kIHJldHVybnMsIGlmIG5vdCBmb3VuZCAtIHJldHVybnMgd29ya2luZyBkZWZhdWx0X2RlbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZWxheSAgICBuYW1lIG9mIGRlbGF5IGFsaWFzIG9yIG51bWJlciBvZiBtc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9ICAgICAgICAgICAgICAgZGVsYXkgaW4gbXNcbiAgICAgKi9cbiAgICBkZWxheUFzTXMoZGVsYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJzdHJpbmdcIiAmJiBkZWxheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgYGRlbGF5cy4ke2RlbGF5fWAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICB1cmwgICAgIHdlIGdvIHRvIHVybFxuICAgICAqICBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9ICAgICAgIGRlbGF5ICAgbmFtZSBvZiBkZWxheSBhbGlhcyBvciBudW1iZXIgb2YgbXNcbiAgICAgKiAgQHJldHVybnMge05vZGVKUy5UaW1lb3V0fSAgICAgICAgICAgIHRpbWVvdXQgaWRlbnRpZmljYXRvclxuICAgICAqL1xuICAgIG5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksIGRvQmVmb3JlKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHR5cGVvZiBkb0JlZm9yZSA9PT0gXCJmdW5jdGlvblwiICYmIGRvQmVmb3JlKCk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRlKHVybCk7XG4gICAgICAgIH0sIHRoaXMuZGVsYXlBc01zKGRlbGF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlIGJyb3dzZXIgSGlzdG9yeSBBUElcbiAgICAgKi9cbiAgICBoaXN0b3J5KCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlXCIsIE9QVF9NT0RFX0hJU1RPUlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBoYXNoIHBhcnQgYXMgY29udGFpbmVyIGZvciBsb2NhdGlvbiBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGhhc2goKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVcIiwgT1BUX01PREVfSEFTSCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm9vdCBzaG91bGQgc3RhcnQgYW5kIGVuZCB3aXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RcbiAgICAgKiBAcmV0dXJucyB7bm90Um91dGVyfVxuICAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcInJvb3RcIixcbiAgICAgICAgICAgIHJvb3QgJiYgcm9vdCAhPT0gXCIvXCIgPyBcIi9cIiArIHRoaXMuY2xlYXJTbGFzaGVzKHJvb3QpICsgXCIvXCIgOiBcIi9cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbGVhciBmaXJzdCBhbmQgbGFzdCBzbGFzaGVzIGZyb20gc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsZWFyU2xhc2hlcyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnRvU3RyaW5nKCkucmVwbGFjZSgvXFwvJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG5cbiAgICBhZGQocmUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSByZTtcbiAgICAgICAgICAgIHJlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVsZSA9IHtcbiAgICAgICAgICAgIHJlOiByZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKS5wdXNoKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhZGRMaXN0KGxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgdCBpbiBsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0LCBsaXN0W3RdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmUocGFyYW0pIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBpID0gMCwgcjtcbiAgICAgICAgICAgIGkgPCB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikubGVuZ3RoLFxuICAgICAgICAgICAgKHIgPSB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIilbaV0pO1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHIuaGFuZGxlciA9PT0gcGFyYW0gfHwgci5yZSA9PT0gcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoe1xuICAgICAgICAgICAgcm91dGVzOiBbXSxcbiAgICAgICAgICAgIG1vZGU6IE9QVF9NT0RFX0hJU1RPUlksXG4gICAgICAgICAgICByb290OiBcIi9cIixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJpbml0aWFsaXplZFwiKTtcbiAgICB9XG5cbiAgICBzZXRJbml0aWFsaXplZCh2YWwgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFdvcmtpbmcoXCJpbml0aWFsaXplZFwiLCB2YWwpO1xuICAgIH1cblxuICAgIGdldEZyYWdtZW50KCkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSA9PT0gT1BUX01PREVfSElTVE9SWSkge1xuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuY2xlYXJTbGFzaGVzKFxuICAgICAgICAgICAgICAgIGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2UoL1xcPyguKikkLywgXCJcIik7XG4gICAgICAgICAgICBmcmFnbWVudCA9XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSAhPSBcIi9cIlxuICAgICAgICAgICAgICAgICAgICA/IGZyYWdtZW50LnJlcGxhY2UodGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBmcmFnbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghd2luZG93KSByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXJTbGFzaGVzKGZyYWdtZW50KTtcbiAgICB9XG5cbiAgICBjaGVja0xvY2F0aW9uKCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0V29ya2luZyhcImN1cnJlbnRcIiksXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IGZyYWdtZW50IHx8ICFpbml0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJjdXJyZW50XCIsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2soZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsaXplZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhyZWZDbGljaygpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyguLi5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGdldFJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpO1xuICAgIH1cblxuICAgIGxpc3Rlbihsb29wSW50ZXJ2YWwgPSBPUFRfREVGQVVMVF9DSEVDS19JTlRFUlZBTCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJjdXJyZW50XCIsIFwibm90SW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5nZXRXb3JraW5nKFwiaW50ZXJ2YWxcIikpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcImludGVydmFsXCIsXG4gICAgICAgICAgICBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrTG9jYXRpb24uYmluZCh0aGlzKSwgbG9vcEludGVydmFsKVxuICAgICAgICApO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMuaHJlZkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjaGVjayhmKSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IGYgfHwgdGhpcy5nZXRGcmFnbWVudCgpLFxuICAgICAgICAgICAgZmFpbEJhY2sgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhdGggPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpICsgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLnJlLFxuICAgICAgICAgICAgICAgIGZ1bGxSRSA9IHRoaXMuY2xlYXJTbGFzaGVzKGRlY29kZVVSSShwYXRoKSksXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmcmFnbWVudC5tYXRjaChmdWxsUkUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsUkUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZmFpbEJhY2sgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldLmhhbmRsZXIuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvc3QgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJvdXRlXCIsIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFpbEJhY2spIHtcbiAgICAgICAgICAgIGZhaWxCYWNrLnJvdXRlLmhhbmRsZXIuYXBwbHkodGhpcy5ob3N0IHx8IHt9LCBmYWlsQmFjay5tYXRjaCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJvdXRlXCIsIGZhaWxCYWNrLnJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmcmVzaGVzIHBhZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCB0aW1lIHRvIHdhaXQgaW4gbXNcbiAgICAgKi9cbiAgICByZWZyZXNoKHRpbWVvdXQgPSAwKSB7XG4gICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlZnJlc2goKSwgdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrKHRoaXMuZ2V0V29ya2luZyhcImN1cnJlbnRcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBsb2NhdGlvbnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbmF2aWdhdGUocGF0aCkge1xuICAgICAgICBwYXRoID0gcGF0aCA/IHBhdGggOiBcIlwiO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIikpIHtcbiAgICAgICAgICAgIGNhc2UgT1BUX01PREVfSElTVE9SWToge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JvdXRlID0gdGhpcy5nZXRGdWxsUm91dGUocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JvdXRlID09PSB0aGlzLmxhc3RSb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RSb3V0ZSA9IG5ld1JvdXRlO1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBcIlwiLCB0aGlzLmxhc3RSb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBPUFRfTU9ERV9IQVNIOiB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIyguKikkLywgXCJcIikgKyBcIiNcIiArIHBhdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHJldHVybnMgYXBwIHJvb3QgKyBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEZ1bGxSb3V0ZShwYXRoID0gXCJcIikge1xuICAgICAgICBwYXRoID0gdGhpcy5jbGVhclNsYXNoZXMocGF0aCk7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmdldFdvcmtpbmcoXCJyb290XCIpO1xuICAgICAgICBpZiAocm9vdCAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmluZGV4T2Yocm9vdC5zdWJzdHJpbmcoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiICsgcGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSArIHRoaXMuY2xlYXJTbGFzaGVzKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGxpbmtzIHdpdGggbi1ocmVmIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheTxIVE1MQW5jaG9yRWxlbWVudD59XG4gICAgICovXG4gICAgZ2V0QWxsTGlua3MoKSB7XG4gICAgICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiYVwiKTtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhbGxFbGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDAsIGF0dHMgPSBhbGxFbGVtZW50c1tqXS5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaSA8IG47XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0c1tpXS5ub2RlTmFtZS5pbmRleE9mKFwibi1ocmVmXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhbGxFbGVtZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXJvdXRlIGFsbCBsaW5rcyhhbmNob3IgdGFncykgd2l0aCBuLWhyZWYgYXR0cmlidXRlLlxuICAgICAqIERpc2FibGUgbmF2aWdhdGlvbiB0byBocmVmLlxuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgcmVSb3V0ZUV4aXN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldEFsbExpbmtzKCk7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbGlzdC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgdGhpcy5pbml0UmVyb3V0aW5nKGxpc3RbdF0sIGxpc3RbdF0uZ2V0QXR0cmlidXRlKFwibi1ocmVmXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBgZWxgIGlzIG5vdCBpbml0aWFsaXplZCwgYWRkcyBvbmNsaWNrIGxpc3RlbmVyIHRvIG5hdmlnYXRlIHRvIGBsaW5rYCBsb2NhdGlvbi5cbiAgICAgKiBEaXNhYmxlcyBkZWZhdWx0IG5hdmlnYXRpb24gdG8gaHJlZi5cbiAgICAgKiBAcGFyYW0ge0hUTUxBbmNob3JFbGVtZW50fSAgIGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICBsaW5rXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBpbml0UmVyb3V0aW5nKGVsLCBsaW5rKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFlbC5ub3RSb3V0ZXJJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbGV0IGZ1bGxMaW5rID0gdGhpcy5nZXRGdWxsUm91dGUobGluayk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGZ1bGxMaW5rKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlKGxpbmspO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZWwubm90Um91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IG5vdFJvdXRlcigpO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vYmFzZS5qc1wiO1xuXG5jb25zdCBMT0dfUFJFRklYID0gXCJBUElRdWVlXCI7XG5cbmNsYXNzIG5vdEFQSVF1ZXVlIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgc3RhdGljIFFVRVVFX0NIRUNLX0lOVEVSVkFMID0gMTAwO1xuXG4gICAgc3RhdGljIE1BWF9CVVNZX1RJTUUgPSAzMDA7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSA/IG9wdGlvbnMubmFtZSA6IExPR19QUkVGSVgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgIHRoaXMuY2hlY2tRdWV1ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdGhpcy5RVUVVRV9DSEVDS19JTlRFUlZBTFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNoZWNrUXVldWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5KCkgJiYgIXRoaXMuaXNCdXN5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnVzeSgpXG4gICAgICAgICAgICAgICAgLnJ1bk5leHQoKVxuICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0RnJlZS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RnJlZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQnVzeSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuYWZ0ZXJFbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZnRlckVtcHR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkVG9RdWV1ZSh0YXNrKSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICB9XG5cbiAgICBydW5OZXh0KCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMucXVldWUubWFwKChhY3Rpb24pID0+IGFjdGlvbi50aXRsZSkuam9pbihcIiwgXCIpO1xuICAgICAgICB0aGlzLmRlYnVnICYmIHRoaXMuZGVidWcoYHRhc2tzIFske2xpc3R9XWApO1xuICAgICAgICBsZXQgdGFzayA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFub3RDb21tb24uaXNGdW5jKHRhc2suYWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwi0JIg0LfQsNC00LDQvdC40Lgg0L3QtdGCINC40YHQv9C+0LvQvdC40LzQvtC5INGH0LDRgdGC0LgsIGFjdGlvbiDQvdC1INGE0YPQvdC60YbQuNGPXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhc2sudGl0bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub3RDb21tb24uaXNGdW5jKHRhc2sucmVzb2x2ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcItCSINC30LDQtNCw0L3QuNC4INC90LXRgiDQstC+0LfQstGA0LDRgtC90L7QuSDRh9Cw0YHRgtC4LCByZXNvbHZlINC90LUg0YTRg9C90LrRhtC40Y9cIixcbiAgICAgICAgICAgICAgICAgICAgdGFzay50aXRsZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdGFzay5hY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFzay5hY3Rpb24oKS50aGVuKHRhc2sucmVzb2x2ZSk7XG4gICAgfVxuXG4gICAgaXNCdXN5KCkge1xuICAgICAgICBsZXQgYnVzeSA9ICEhdGhpcy5idXN5LFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIGlmIChidXN5ICYmIHRoaXMuYnVzeVNpbmNlID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aGlzLmJ1c3lTaW5jZSA+IG5vdEFQSVF1ZXVlLk1BWF9CVVNZX1RJTUUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZyZWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0QnVzeSgpIHtcbiAgICAgICAgdGhpcy5idXN5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXN5U2luY2UgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0RnJlZSgpIHtcbiAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gLTE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDQmNGB0L/QvtC70L3QuNGC0LXQu9GMINC30LDQv9GA0L7RgdC+0LJcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgYWN0aW9uICAgICAg0LTQvtC70LbQvdCwINCy0L7Qt9Cy0YDQsNGJ0LDRgtGMIFByb21pc2VcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgW2FmdGVyRW1wdHkgPSB1bmRlZmluZWRdICDQsdGD0LTQtdGCINCy0YvQv9C+0LvQvdC10L3QsCDQutC+0LPQtNCwINC+0YfRg9GA0YPQtNGMINC+0L/Rg9GB0YLQtdC10YIg0Lgg0LHRg9C00LXRgiDRgdCy0L7QsdC+0LTQvdCwLiDQv9C+0LvQtdC30L3QsCDQv9GA0Lgg0L/QsNGH0LrQtSDQvtC00L3QvtGC0LjQv9C90YvRhSDQt9Cw0LTQsNC90LjQuVxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBbdGl0bGUgPSAnJ10gICAgb3B0aW9uYWwgdGl0bGUgb2YgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zICAgIHtQcm9taXNlfSAgICDRgNC10LfRg9C70YzRgtCw0YIg0YTRg9C90LrRhtC40LhcbiAgICAgKiovXG4gICAgcnVuKGFjdGlvbiwgYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZCwgdGl0bGUgPSBcIlwiKSB7XG4gICAgICAgIGlmIChhZnRlckVtcHR5ICYmIHR5cGVvZiB0aGlzLmFmdGVyRW1wdHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IGFmdGVyRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb1F1ZXVlKHsgYWN0aW9uLCByZXNvbHZlLCB0aXRsZSB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3Rpb25Jc1F1ZXVlZCh0aXRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5zb21lKChxdWV1ZWQpID0+IHF1ZXVlZC50aXRsZSA9PSB0aXRsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgICAgIHtmdW5jdGlvbn0gICBhY3Rpb24gICAgICDQtNC+0LvQttC90LAg0LLQvtC30LLRgNCw0YnQsNGC0YwgUHJvbWlzZVxuICAgICAqIEBwYXJhbSAgICAgIHtmdW5jdGlvbn0gICBbYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZF0gINCx0YPQtNC10YIg0LLRi9C/0L7Qu9C90LXQvdCwINC60L7Qs9C00LAg0L7Rh9GD0YDRg9C00Ywg0L7Qv9GD0YHRgtC10LXRgiDQuCDQsdGD0LTQtdGCINGB0LLQvtCx0L7QtNC90LAuINC/0L7Qu9C10LfQvdCwINC/0YDQuCDQv9Cw0YfQutC1INC+0LTQvdC+0YLQuNC/0L3Ri9GFINC30LDQtNCw0L3QuNC5XG4gICAgICogQHBhcmFtICAgICAgIHtzdHJpbmd9ICAgIFt0aXRsZSA9ICcnXSAgICBvcHRpb25hbCB0aXRsZSBvZiByZXF1ZXN0XG4gICAgICogQHJldHVybiAgICB7UHJvbWlzZX1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QVBJUXVldWVcbiAgICAgKi9cbiAgICBydW5JZk5vdFF1ZXVlZChhY3Rpb24sIGFmdGVyRW1wdHkgPSB1bmRlZmluZWQsIHRpdGxlID0gXCJcIikge1xuICAgICAgICBpZiAodGhpcy5hY3Rpb25Jc1F1ZXVlZCh0aXRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bihhY3Rpb24sIGFmdGVyRW1wdHksIHRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QVBJUXVldWU7XG4iLCJsZXQgbm90QVBJT3B0aW9ucyA9IHtcbiAgICBycHM6IDUwLFxuICAgIHByb3RvY29sOiAnaHR0cCcsXG4gICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgcG9ydDogOTAwMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbm90QVBJT3B0aW9ucztcbiIsImltcG9ydCBub3RCYXNlIGZyb20gJy4uL2Jhc2UuanMnO1xuY29uc3QgTE9HX1BSRUZJWCA9ICdBUElDb25uZWN0aW9uJztcblxuY2xhc3Mgbm90QVBJQ29ubmVjdGlvbiBleHRlbmRzIG5vdEJhc2V7XG4gICAgc3RhdGljIGludDtcbiAgICBzdGF0aWMgb25saW5lO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZT9vcHRpb25zLm5hbWU6TE9HX1BSRUZJWFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBydW4oKSB7XG4gICAgICAgIHRoaXMuaW50ID0gd2luZG93LnNldEludGVydmFsKHRoaXMuY2hlY2suYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgfVxuXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuaW50KTtcbiAgICB9XG5cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgfVxuXG4gICAgaXNPbmxpbmUoKXtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lO1xuICAgIH1cblxuICAgIGNoZWNrKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXMuaXNPbmxpbmUoKTtcbiAgICAgICAgaWYgKHRoaXMub25saW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vbmxpbmUgIT09IHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25saW5lID0gdDtcbiAgICB9XG5cbiAgICBjaGFuZ2VTdGF0ZShvbmxpbmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAob25saW5lKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ29ubGluZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEFQSUNvbm5lY3Rpb247XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbmNvbnN0IEFMTCA9IHt9O1xuXG5mdW5jdGlvbiBleGlzdChrZXkpIHtcbiAgICByZXR1cm4gbm90Q29tbW9uLm9iakhhcyhBTEwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoZXhpc3Qoa2V5KSkge1xuICAgICAgICByZXR1cm4gQUxMW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKFxuICAgIGtleSxcbiAgICBwcm9wcyA9IHtcbiAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgZmlsdGVyZWQ6IFtdLFxuICAgICAgICBzZWxlY3RlZDoge30sXG4gICAgfVxuKSB7XG4gICAgaWYgKCFleGlzdChrZXkpKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgQUxMW2tleV0gPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgQUxMW2tleV1bbmFtZV0gPSB3cml0YWJsZShwcm9wc1tuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0b3JlJ3MgcHJvcHMgd2Fzbid0IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQUxMW2tleV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBvYmplY3QgdGhhdCBpcyBmYWtlIFN0b3JlXG4gKiBTb21lIHRpbWUgdGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBpbml0aWFsaXplIGxvY2FsIHZhcixcbiAqIGJlZm9yZSB5b3UgY291bGQgZ2V0IGFjdHVhbCBTdG9yZXMgZnJvbSBjZW50cmFsIHN0b3JhZ2UgYnkgaXRzIElEXG4gKlx0QHBhcmFtcyB7bWl4ZWR9IHZhbCBcdGRhdGEgb2YgdHlwZSB0aGF0IGlzIGFjdHVhbCBzdG9yYWdlIHdpbGwgY29udGFpblxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBmYWtlKHZhbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShmKSB7XG4gICAgICAgICAgICBmKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHt9LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZSwgZ2V0LCBmYWtlIH07XG4iLCJjb25zdFxuICAgIC8vaW50ZXJmYWNlXG4gICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSA9IFsnX2lkJywgJ2lkJywgJ0lEJ10sXG4gICAgREVGQVVMVF9GSUxURVIgPSB7fSxcbiAgICBERUZBVUxUX1NFQVJDSCA9ICcnLFxuICAgIERFRkFVTFRfUkVUVVJOID0ge30sXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUiA9IDEsXG4gICAgREVGQVVMVF9QQUdFX1NJWkUgPSAxMCxcbiAgICAvL3JlY29yZFxuICAgIE1FVEFfSU5URVJGQUNFID0gU3ltYm9sKCdpbnRlcmZhY2UnKSxcbiAgICBNRVRBX01BUF9UT19JTlRFUkZBQ0UgPSBbXG4gICAgICAgICdnZXRBY3Rpb25zQ291bnQnLFxuICAgICAgICAnZ2V0QWN0aW9ucycsXG4gICAgICAgICdzZXRGaW5kQnknLFxuICAgICAgICAncmVzZXRGaWx0ZXInLFxuICAgICAgICAnc2V0RmlsdGVyJyxcbiAgICAgICAgJ2dldEZpbHRlcicsXG4gICAgICAgICdzZXRTb3J0ZXInLFxuICAgICAgICAnZ2V0U29ydGVyJyxcbiAgICAgICAgJ3Jlc2V0U29ydGVyJyxcbiAgICAgICAgJ3NldFBhZ2VOdW1iZXInLFxuICAgICAgICAnc2V0UGFnZVNpemUnLFxuICAgICAgICAnc2V0UGFnZXInLFxuICAgICAgICAnc2V0UmV0dXJuJyxcbiAgICAgICAgJ3NldFNlYXJjaCcsXG4gICAgICAgICdnZXRTZWFyY2gnLFxuICAgICAgICAncmVzZXRTZWFyY2gnLFxuICAgICAgICAncmVzZXRQYWdlcicsXG4gICAgICAgICdnZXRQYWdlcicsXG4gICAgICAgICdhZGRGb3JtRmllbGRUeXBlJyxcbiAgICAgICAgJ2FkZEZvcm1GaWVsZCcsXG4gICAgICAgICdnZXRGaWVsZFR5cGVzJyxcbiAgICAgICAgJ2dldEFjdGlvbkZvcm1GaWVsZHMnXG4gICAgXSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVggPSAnJCc7XG5cbmV4cG9ydCB7XG4gICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSxcbiAgICBERUZBVUxUX0ZJTFRFUixcbiAgICBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgIERFRkFVTFRfUEFHRV9TSVpFLFxuICAgIERFRkFVTFRfU0VBUkNILFxuICAgIERFRkFVTFRfUkVUVVJOLFxuICAgIE1FVEFfSU5URVJGQUNFLFxuICAgIE1FVEFfTUFQX1RPX0lOVEVSRkFDRSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVhcbn07XG4iLCJpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5cbmNvbnN0IE9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFkgPSBbXCJfaWRcIiwgXCJpZFwiLCBcIklEXCJdLFxuICAgIERFRkFVTFRfRklMVEVSID0ge30sXG4gICAgREVGQVVMVF9TRUFSQ0ggPSBcIlwiLFxuICAgIERFRkFVTFRfUkVUVVJOID0ge30sXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUiA9IDAsXG4gICAgREVGQVVMVF9QQUdFX1NJWkUgPSAxMCxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVggPSBcIiRcIixcbiAgICBERUZBVUxUX1dTX1JPVVRFX0FDVElPTl9TUExJVFRFUiA9IFwiLy9cIjtcblxuY2xhc3Mgbm90SW50ZXJmYWNlIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgY29uc3RydWN0b3IobWFuaWZlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6XG4gICAgICAgICAgICAgICAgICAgIFwibmV0d29yayBpbnRlcmZhY2UgZm9yOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChtYW5pZmVzdC5tb2RlbCA/IG1hbmlmZXN0Lm1vZGVsIDogXCJ1bmtub3duXCIpLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogREVGQVVMVF9GSUxURVIsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBERUZBVUxUX1NFQVJDSCxcbiAgICAgICAgICAgICAgICByZXR1cm46IERFRkFVTFRfUkVUVVJOLFxuICAgICAgICAgICAgICAgIHBhZ2VyOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpemU6IERFRkFVTFRfUEFHRV9TSVpFLFxuICAgICAgICAgICAgICAgICAgICBwYWdlOiBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgICAgdGhpcy5pbml0QWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpbml0QWN0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QWN0aW9uc0NvdW50KCkgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMuZ2V0QWN0aW9ucygpO1xuICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uTmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdEFjdGlvbihhY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyh0aGlzLCBERUZBVUxUX0FDVElPTl9QUkVGSVggKyBhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgdGhpc1tERUZBVUxUX0FDVElPTl9QUkVGSVggKyBhY3Rpb25OYW1lXSA9IChcbiAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgZmlsZVVwbG9hZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICApID0+XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlVXBsb2FkLFxuICAgICAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0SFRUUChcbiAgICAgICAgcmVjb3JkLFxuICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGhlYWRlcnMgPSB7fSxcbiAgICAgICAgZmlsZVVwbG9hZCA9IGZhbHNlLFxuICAgICAgICBmaWxlc1xuICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0ZURhdGEgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIHJlY29yZC5nZXREYXRhICYmIHR5cGVvZiByZWNvcmQuZ2V0RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVjb3JkLmdldERhdGEoKVxuICAgICAgICAgICAgICAgICAgICA6IHJlY29yZCxcbiAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IHRoaXMuZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gdGhpcy5jb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtc0VuY29kZWQgPSB0aGlzLmVuY29kZVJlcXVlc3QocmVxdWVzdFBhcmFtcyksXG4gICAgICAgICAgICAgICAgLy9pZCA9IHRoaXMuZ2V0SUQoY29tcG9zaXRlRGF0YSwgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgYXBpU2VydmVyVVJMID0gdGhpcy5nZXRTZXJ2ZXJVUkwoKSxcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmdldFVSTChjb21wb3NpdGVEYXRhLCBhY3Rpb25EYXRhLCBhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgICBpZiAoZmlsZVVwbG9hZCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZ2V0VVJMKHBhcmFtcywgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQoXCJmaWxlXCIsIGZpbGVzKTtcbiAgICAgICAgICAgICAgICBvcHRzLmJvZHkgPSBmZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBbXCJPUFRJT05TXCIsIFwiR0VUXCJdLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLm1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICkgPT09IC0xXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGFjdGlvbkRhdGEubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmdldERhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlY29yZC5nZXREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWNvcmQuZ2V0RGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVjb3JkXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdHMubWV0aG9kID0gYWN0aW9uRGF0YS5tZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYXBpU2VydmVyVVJMICsgdXJsICsgcmVxdWVzdFBhcmFtc0VuY29kZWQsIG9wdHMpLnRoZW4oXG4gICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvcihlKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0V1MocmVjb3JkLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgYWN0aW9uRGF0YSA9IHRoaXMuZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gdGhpcy5jb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBXUyA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXU0NsaWVudCgpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZU5hbWUgPSB0aGlzLmdldFdTUmVxdWVzdE5hbWUoYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcywgcmVjb3JkLmdldERhdGEoKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcInR5cGVcIikgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgYWN0aW9uRGF0YS50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgYWN0aW9uRGF0YS50eXBlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEudHlwZSAhPT0gXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBXUy5tZXNzYWdlKGFjdGlvbkRhdGEudHlwZSwgbWVzc2FnZU5hbWUsIHBheWxvYWQpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UucGF5bG9hZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBXUy5yZXF1ZXN0KG1lc3NhZ2VOYW1lLCBwYXlsb2FkKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLnBheWxvYWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uZXJyb3IoZSk7XG4gICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdCgpIHtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSB0aGlzLmdldEFjdGlvbkRhdGEoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdFRyYW5zcG9ydChhY3Rpb25EYXRhKSkge1xuICAgICAgICAgICAgY2FzZSBcIndzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFdTKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RIVFRQKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZmxpbmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3c0lzVXAoYWN0aW9uRGF0YSkge1xuICAgICAgICBpZiAoYWN0aW9uRGF0YS53cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwid3NDbGllbnRcIikgJiZcbiAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLndzQ2xpZW50XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0V1NDbGllbnQoYWN0aW9uRGF0YS53c0NsaWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsaWVudCA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRXU0NsaWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3RUcmFuc3BvcnQoYWN0aW9uRGF0YSkge1xuICAgICAgICBpZiAodGhpcy53c0lzVXAoYWN0aW9uRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIndzXCI7IC8vZm9yIHdzL3dzc1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwibWV0aG9kXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwXCI7IC8vZm9yIGh0dHAvaHR0cHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vZm9yIG9mZmxpbmVcbiAgICB9XG5cbiAgICBnZXRNb2RlbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzICYmIHRoaXMubWFuaWZlc3QgPyB0aGlzLm1hbmlmZXN0Lm1vZGVsIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25EYXRhKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9ucygpICYmIHRoaXMuZ2V0QWN0aW9ucygpW2FjdGlvbk5hbWVdXG4gICAgICAgICAgICA/IHRoaXMuZ2V0QWN0aW9ucygpW2FjdGlvbk5hbWVdXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3Rpb25zKCkgPyBPYmplY3Qua2V5cyh0aGlzLmdldEFjdGlvbnMoKSkubGVuZ3RoIDogMDtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdCAmJiB0aGlzLm1hbmlmZXN0LmFjdGlvbnNcbiAgICAgICAgICAgID8gdGhpcy5tYW5pZmVzdC5hY3Rpb25zXG4gICAgICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIHBhcnNlUGFyYW1zKHN0YXJ0LCBlbmQsIGxpbmUsIHJlY29yZCkge1xuICAgICAgICBsZXQgZmllbGROYW1lID0gXCJcIjtcbiAgICAgICAgbGV0IGxlbiA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxpbmUuaW5kZXhPZihzdGFydCkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGluZCA9IGxpbmUuaW5kZXhPZihzdGFydCk7XG4gICAgICAgICAgICBsZXQgc3RhcnRTbGljZSA9IGluZCArIGxlbjtcbiAgICAgICAgICAgIGxldCBlbmRTbGljZSA9IGxpbmUuaW5kZXhPZihlbmQpO1xuICAgICAgICAgICAgaWYgKGluZCA+IGVuZFNsaWNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWVsZE5hbWUgPSBsaW5lLnNsaWNlKHN0YXJ0U2xpY2UsIGVuZFNsaWNlKTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT0gXCJcIikgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmxvZyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICAgICAgICBzdGFydCArIGZpZWxkTmFtZSArIGVuZCxcbiAgICAgICAgICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGROYW1lLCByZWNvcmQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBmaWVsZE5hbWUgKyBlbmQsXG4gICAgICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGROYW1lLCByZWNvcmQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIHBhcnNlTGluZShsaW5lLCByZWNvcmQsIGFjdGlvbk5hbWUpIHtcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZShcIjptb2RlbE5hbWVcIiwgdGhpcy5tYW5pZmVzdC5tb2RlbCk7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCI6YWN0aW9uTmFtZVwiLCBhY3Rpb25OYW1lKTtcbiAgICAgICAgbGluZSA9IHRoaXMucGFyc2VQYXJhbXMoXCI6cmVjb3JkW1wiLCBcIl1cIiwgbGluZSwgcmVjb3JkKTtcbiAgICAgICAgbGluZSA9IHRoaXMucGFyc2VQYXJhbXMoXCI6XCIsIFwiP1wiLCBsaW5lLCByZWNvcmQpO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICBnZXRVUkwocmVjb3JkLCBhY3Rpb25EYXRhLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIHZhciBsaW5lID1cbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKHRoaXMubWFuaWZlc3QudXJsLCByZWNvcmQsIGFjdGlvbk5hbWUpICtcbiAgICAgICAgICAgIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwicG9zdEZpeFwiKVxuICAgICAgICAgICAgICAgID8gdGhpcy5wYXJzZUxpbmUoYWN0aW9uRGF0YS5wb3N0Rml4LCByZWNvcmQsIGFjdGlvbk5hbWUpXG4gICAgICAgICAgICAgICAgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgZ2V0U2VydmVyVVJMKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpXG4gICAgICAgICAgICA/IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRPcHRpb25zKFwiYXBpLnNlcnZlci51cmxcIiwgXCJcIilcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICB9XG5cbiAgICBnZXRXU1JlcXVlc3ROYW1lKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5tYW5pZmVzdC5tb2RlbDtcbiAgICAgICAgcmV0dXJuIGAke21vZGVsTmFtZX0ke0RFRkFVTFRfV1NfUk9VVEVfQUNUSU9OX1NQTElUVEVSfSR7YWN0aW9uTmFtZX1gO1xuICAgIH1cblxuICAgIGVuY29kZVJlcXVlc3QoZGF0YSkge1xuICAgICAgICBsZXQgcCA9IFwiP1wiO1xuICAgICAgICBmb3IgKGxldCB0IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVt0XSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhW3RdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcCArPVxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodCkgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbdF0uY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoZGF0YVt0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRhdGFbdF1cbiAgICAgICAgICAgICAgICAgICAgKSArXG4gICAgICAgICAgICAgICAgICAgIFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZm9yIHRlc3QgcHVycG9zZSBvbmx5LCBzcGVjaWFsIHRlc3Qgc2VydmVyIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdFwiKSkge1xuICAgICAgICAgICAgcCArPSBcIiZ0ZXN0PTFcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJ0ZXN0LnNlc3Npb25cIikpIHtcbiAgICAgICAgICAgICAgICBwICs9IFwiJnNlc3Npb249XCIgKyB0aGlzLmdldE9wdGlvbnMoXCJ0ZXN0LnNlc3Npb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdC5zZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgcCArPSBcIiZyb2xlPVwiICsgdGhpcy5nZXRPcHRpb25zKFwidGVzdC5yb2xlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGNvbGxlY3RSZXF1ZXN0RGF0YShhY3Rpb25EYXRhKSB7XG4gICAgICAgIGxldCByZXF1ZXN0RGF0YSA9IHt9O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwiZGF0YVwiKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhY3Rpb25EYXRhLmRhdGEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25EYXRhLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVByb3ZpZGVyTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgIFwiZ2V0XCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbkRhdGEuZGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzW2RhdGFQcm92aWRlck5hbWVdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW2RhdGFQcm92aWRlck5hbWVdID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzW2RhdGFQcm92aWRlck5hbWVdKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNvcnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInJldHVyblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5pbmRleE9mKGFjdGlvbkRhdGEuZGF0YVtpXSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1thY3Rpb25EYXRhLmRhdGFbaV1dID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEgPSBPYmplY3QuYXNzaWduKHJlcXVlc3REYXRhLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdERhdGE7XG4gICAgfVxuXG4gICAgZ2V0SUQocmVjb3JkLCBhY3Rpb25EYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHRJZCxcbiAgICAgICAgICAgIGxpc3QgPSBPUFRfREVGQVVMVF9JTkRFWF9GSUVMRF9OQU1FX1BSSU9SSVRZLFxuICAgICAgICAgICAgcHJlZml4ZXMgPSBbXCJcIiwgdGhpcy5tYW5pZmVzdC5tb2RlbF07XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGFjdGlvbkRhdGEsIFwiaW5kZXhcIikgJiYgYWN0aW9uRGF0YS5pbmRleCkge1xuICAgICAgICAgICAgbGlzdCA9IFthY3Rpb25EYXRhLmluZGV4XS5jb25jYXQoXG4gICAgICAgICAgICAgICAgT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcmUgb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgbGlzdCkge1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHJlY29yZCwgcHJlICsgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SWQgPSByZWNvcmRbcHJlICsgdF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0SWQ7XG4gICAgfVxuXG4gICAgc2V0RmluZEJ5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRGaWx0ZXIob2JqKTtcbiAgICB9XG5cbiAgICBzZXRGaWx0ZXIoZmlsdGVyRGF0YSA9IERFRkFVTFRfRklMVEVSKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImZpbHRlclwiLCBmaWx0ZXJEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldEZpbHRlcigpO1xuICAgIH1cblxuICAgIGdldEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImZpbHRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRTZWFyY2goc2VhcmNoRGF0YSA9IERFRkFVTFRfU0VBUkNIKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInNlYXJjaFwiLCBzZWFyY2hEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRTZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFNlYXJjaCgpO1xuICAgIH1cblxuICAgIGdldFNlYXJjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNlYXJjaFwiKTtcbiAgICB9XG5cbiAgICBzZXRTb3J0ZXIoc29ydGVyRGF0YSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzb3J0ZXJcIiwgc29ydGVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0U29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3J0ZXIoe30pO1xuICAgIH1cblxuICAgIGdldFNvcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNvcnRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRSZXR1cm4ocmV0dXJuRGF0YSA9IERFRkFVTFRfUkVUVVJOKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJldHVyblwiLCByZXR1cm5EYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRSZXR1cm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFJldHVybih7fSk7XG4gICAgfVxuXG4gICAgZ2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicmV0dXJuXCIpO1xuICAgIH1cblxuICAgIHNldFBhZ2VOdW1iZXIocGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlci5wYWdlXCIsIHBhZ2VOdW1iZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRQYWdlU2l6ZShwYWdlU2l6ZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlci5zaXplXCIsIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy9wYWdlU2l6ZSA9IERFRkFVTFRfUEFHRV9TSVpFLCBwYWdlTnVtYmVyID0gREVGQVVMVF9QQUdFX05VTUJFUlxuICAgIHNldFBhZ2VyKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYXJndW1lbnRzLmxlbmd0aCA8IDIgfHxcbiAgICAgICAgICAgICAgICBpc05hTihhcmd1bWVudHNbMF0pIHx8XG4gICAgICAgICAgICAgICAgaXNOYU4oYXJndW1lbnRzWzFdKSkgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFyZ3VtZW50c1swXSwgXCJwYWdlXCIpICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGFyZ3VtZW50c1swXSwgXCJzaXplXCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcGFnZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlclwiLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogcGFnZXIuc2l6ZSB8fCBERUZBVUxUX1BBR0VfU0laRSxcbiAgICAgICAgICAgICAgICBwYWdlOiBwYWdlci5wYWdlIHx8IERFRkFVTFRfUEFHRV9OVU1CRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICFpc05hTihhcmd1bWVudHNbMF0pICYmXG4gICAgICAgICAgICAhaXNOYU4oYXJndW1lbnRzWzFdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcInBhZ2VyXCIsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBhcmd1bWVudHNbMF0gfHwgREVGQVVMVF9QQUdFX1NJWkUsXG4gICAgICAgICAgICAgICAgcGFnZTogYXJndW1lbnRzWzFdIHx8IERFRkFVTFRfUEFHRV9OVU1CRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlcigpO1xuICAgIH1cblxuICAgIGdldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicGFnZXJcIik7XG4gICAgfVxuXG4gICAgZ2V0UmVjb3JkKCkge1xuICAgICAgICB0aGlzLmdldERhdGEoKTtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0QXNQbGFpbk9iamVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hbmlmZXN0IHx8ICF0aGlzLm1hbmlmZXN0LmZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLm1hbmlmZXN0LmZpZWxkcykpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRoaXMubWFuaWZlc3QuZmllbGRzW2ZpZWxkTmFtZV0sIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMubWFuaWZlc3QuZmllbGRzW2ZpZWxkTmFtZV0uZGVmYXVsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gWy4uLmRlZmF1bHRWYWx1ZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0geyAuLi5kZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEludGVyZmFjZTtcbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbmltcG9ydCB7XG4gICAgTUVUQV9JTlRFUkZBQ0UsXG4gICAgTUVUQV9NQVBfVE9fSU5URVJGQUNFLFxuICAgIERFRkFVTFRfQUNUSU9OX1BSRUZJWCxcbn0gZnJvbSBcIi4vb3B0aW9uc1wiO1xuXG5pbXBvcnQgbm90SW50ZXJmYWNlIGZyb20gXCIuL2ludGVyZmFjZVwiO1xuXG5jbGFzcyBub3RSZWNvcmQgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihtYW5pZmVzdCwgaXRlbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgaXRlbSA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09IFwib2JqZWN0XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmlzUHJveHkpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5lcnJvcihcInRoaXMgaXMgUHJveHkgaXRlbVwiKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIChpdGVtLmlzUmVjb3JkIHx8IGl0ZW0uaXNQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKG1hbmlmZXN0LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE9wdGlvbnMoe30pO1xuICAgICAgICB0aGlzW01FVEFfSU5URVJGQUNFXSA9IG5ldyBub3RJbnRlcmZhY2UobWFuaWZlc3QsIHt9KTtcbiAgICAgICAgdGhpcy5zZXREYXRhKGl0ZW0pO1xuICAgICAgICB0aGlzLmludGVyZmFjZVVwKCk7XG4gICAgICAgIHRoaXMubWFwVG9JbnRlcmZhY2UoKTtcbiAgICAgICAgdGhpcy5tYXBUb01ldGhvZHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdG9EZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKHRoaXNbTUVUQV9JTlRFUkZBQ0VdLmdldERlZmF1bHRBc1BsYWluT2JqZWN0KCkpO1xuICAgIH1cblxuICAgIG1hcFRvSW50ZXJmYWNlKCkge1xuICAgICAgICBsZXQgcmVjID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgdCBvZiBNRVRBX01BUF9UT19JTlRFUkZBQ0UpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzW01FVEFfSU5URVJGQUNFXVt0XSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzW01FVEFfSU5URVJGQUNFXVt0XSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gcmVjW01FVEFfSU5URVJGQUNFXVt0XSguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzID09IHJlY1tNRVRBX0lOVEVSRkFDRV0gPyByZWMgOiByZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcFRvTWV0aG9kcygpIHtcbiAgICAgICAgbGV0IG1hbmlmZXN0ID0gdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3QsXG4gICAgICAgICAgICBhcHAgPSBub3RDb21tb24uZ2V0QXBwKCksXG4gICAgICAgICAgICBtZXRob2RzID0ge307XG4gICAgICAgIGlmIChtYW5pZmVzdC5tZXRob2RzKSB7XG4gICAgICAgICAgICBtZXRob2RzID0gbWFuaWZlc3QubWV0aG9kcztcbiAgICAgICAgfSBlbHNlIGlmIChhcHApIHtcbiAgICAgICAgICAgIG1ldGhvZHMgPSBhcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJtb2RlbHNcIiwgdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3QubW9kZWxdLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihtZXRob2RzLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RdID0gbWV0aG9kc1t0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVDb2xsZWN0aW9uKG1hbmlmZXN0LCBpdGVtcykge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2gobmV3IG5vdFJlY29yZChtYW5pZmVzdCwgaXRlbXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnRlcmZhY2VVcCgpIHtcbiAgICAgICAgaWYgKHRoaXNbTUVUQV9JTlRFUkZBQ0VdLmdldEFjdGlvbnNDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzW01FVEFfSU5URVJGQUNFXS5nZXRBY3Rpb25zKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvblVwKGksIGFjdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVXAoaW5kZXgpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRoaXMsIFtERUZBVUxUX0FDVElPTl9QUkVGSVggKyBpbmRleF0pKSB7XG4gICAgICAgICAgICB0aGlzW0RFRkFVTFRfQUNUSU9OX1BSRUZJWCArIGluZGV4XSA9ICguLi5wYXJhbXMpID0+XG4gICAgICAgICAgICAgICAgdGhpc1tNRVRBX0lOVEVSRkFDRV0ucmVxdWVzdCh0aGlzLCBpbmRleCwgLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKlxuICAtPiAncGF0aC50by5rZXknLCB2YWx1ZU9mS2V5XG4gIDwtIG9rLCB3aXRoIG9uZSBvbkNoYW5nZSBldmVudCB0cmlnZ2VyZWRcbiAgKi9cblxuICAgIHNldEF0dHIoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXREYXRhKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qXG4gIC0+XG4gIHtcbiAgICAna2V5UGF0aCc6IHZhbHVlLFxuICAgICdrZXkuc3ViUGF0aCc6IHZhbHVlMixcbiAgICAna2V5UGF0aC4wLnRpdGxlJzogdmFsdWUzXG4gIH1cbiAgPC0gb2ssIHdpdGggYnVuY2ggb2Ygb25DaGFuZ2UgZXZlbnRzIHRyaWdnZXJlZFxuICAqL1xuICAgIHNldEF0dHJzKG9iamVjdFBhcnQpIHtcbiAgICAgICAgLy9ub3RDb21tb24ubG9nKCdzZXRBdHRycycsIG9iamVjdFBhcnQsIE9iamVjdC5rZXlzKG9iamVjdFBhcnQpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2JqZWN0UGFydCAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdFBhcnQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iamVjdFBhcnQpLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXRoIGluIG9iamVjdFBhcnQpIHtcbiAgICAgICAgICAgICAgICAvL25vdENvbW1vbi5sb2coJ3NldEF0dHJzIG9uZSB0byBnbycsIHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cihwYXRoLCBvYmplY3RQYXJ0W3BhdGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gIC0+ICdwYXRoVG9LZXknXG4gIDwtIHZhbHVlMVxuICAqL1xuICAgIGdldEF0dHIod2hhdCwgcGxhaW4gPSBmYWxzZSkge1xuICAgICAgICBsZXQgcHJ4ID0gdGhpcy5nZXREYXRhKHdoYXQsIHt9KTtcbiAgICAgICAgaWYgKHBsYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLnN0cmlwUHJveHkocHJ4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcng7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAtPiBbJ3BhdGhUb0tleScsICdwYXRoLnRvLmtleScsICdzaW1wbGVLZXknLC4uLl1cbiAgPC0gW3ZhbHVlMSwgdmFsdWUyLCB2YWx1ZTMsLi4uXVxuICAqL1xuICAgIGdldEF0dHJzKHdoYXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAod2hhdCAmJiB3aGF0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBhdGggb2Ygd2hhdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2V0QXR0cihwYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRNYW5pZmVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXNbTUVUQV9JTlRFUkZBQ0VdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tNRVRBX0lOVEVSRkFDRV0ubWFuaWZlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJdGVtKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZXREYXRhKGl0ZW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFJlY29yZDtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90UmVjb3JkIGZyb20gXCIuL3JlY29yZC5qc1wiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IG5vdFJvdXRlciBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW09QVF9DT05UUk9MTEVSX1BSRUZJWCA9IFwibmNcIl0gY29udHJvbGxlciBuYW1lcyBwcmVmaXggbmMgYWthIE5vdENvbnRyb2xsZXJcbiAqL1xuY29uc3QgT1BUX0NPTlRST0xMRVJfUFJFRklYID0gXCJuY1wiO1xuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW09QVF9SRUNPUkRfUFJFRklYID0gXCJuclwiXSByZWNvcmQgbmFtZXMgcHJlZml4IG5yIGFrYSBOb3RSZWNvcmRcbiAqL1xuY29uc3QgT1BUX1JFQ09SRF9QUkVGSVggPSBcIm5yXCI7XG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSBbREVGQVVMVF9XU19DTElFTlRfTkFNRSA9IFwibWFpblwiXSBkZWZhdWx0IG5hbWUgb2YgV1MgY2xpZW50XG4gKi9cbmNvbnN0IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBcIm1haW5cIjtcblxuLyoqXG4gKiBDbGFzcyBvZiBhcHBsaWNhdGlvblxuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdEFwcCBleHRlbmRzIG5vdEJhc2Uge1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtmdW5jdGlvbn0gREVGQVVMVF9XU19DTElFTlRfTkFNRSAgZnVuY3Rpb24gdG8gcGVyZm9ybSBkZWVwIG1lcmdlcyBvZiBvYmplY3RzXG4gICAgICovXG4gICAgc3RhdGljIERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBERUZBVUxUX1dTX0NMSUVOVF9OQU1FO1xuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubmFtZSAgICAgICAgIG5hbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jb250cm9sbGVycyAgY29udHJvbGxlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG9wdGlvbnMubWFuaWZlc3RVUkwgVVJMIG9mIG5ldHdvcmsgbWFuaWZlc3Qgd2l0aCBhbGwgYXZhaWxhYmxlIG1vZGVscy9hY3Rpb25zL2ZpZWxkcyByZXF1ZXN0cyBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGludGVyZmFjZXM6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJzOiBub3RDb21tb24ub2JqSGFzKG9wdGlvbnMsIFwiY29udHJvbGxlcnNcIilcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmNvbnRyb2xsZXJzXG4gICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICAgICAgaW5pdENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgdWlzOiB7fSxcbiAgICAgICAgICAgICAgICB3c2M6IHt9LFxuICAgICAgICAgICAgICAgIHdzczoge30sXG4gICAgICAgICAgICAgICAgc2VydmljZXM6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzPy5sb2cgJiYgdGhpcy5sb2coXCJzdGFydCBhcHBcIik7XG4gICAgICAgIG5vdENvbW1vbi5yZWdpc3RlcihcImFwcFwiLCB0aGlzKTtcbiAgICAgICAgdGhpcy5pbml0TWFuaWZlc3QoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYXBwbGljYXRpb24gYWNjb3JkaW5nIHRvIG5ldHdvcmsgbWFuaWZlc3QsIHdoaWNoIGlzIHJldHJpZXZlZCBmcm9tIHNlcnZlclxuICAgICAqL1xuICAgIGluaXRNYW5pZmVzdCgpIHtcbiAgICAgICAgbm90Q29tbW9uXG4gICAgICAgICAgICAuZ2V0SlNPTih0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFVSTFwiKSlcbiAgICAgICAgICAgIC50aGVuKChtYW5pZmVzdCkgPT4gdGhpcy5zZXRJbnRlcmZhY2VNYW5pZmVzdChtYW5pZmVzdCkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IG5vdENvbW1vbi5yZXBvcnQoZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uZSBwYWdlIHJvdXRpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgKi9cbiAgICBpbml0Um91dGVyKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJyb3V0ZXJcIiwgbm90Um91dGVyKTtcbiAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVyXCIpLnNldFJvb3QodGhpcy5nZXRPcHRpb25zKFwicm91dGVyLnJvb3RcIikpO1xuICAgICAgICBub3RSb3V0ZXIucmVSb3V0ZUV4aXN0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFsbCB0aGUgcm91dGVzIGhhbmRsZXJzIGFuZCBwdXNoZXMgdGhlbSBpbnRvIHJvdXRlclxuICAgICAqL1xuICAgIGV4ZWNSb3V0ZXIoKSB7XG4gICAgICAgIHZhciByb3V0aWVJbnB1dCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuZ2V0T3B0aW9ucyhcInJvdXRlci5tYW5pZmVzdFwiKS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHJvdXRlQmxvY2sgPSB0aGlzLmdldE9wdGlvbnMoXCJyb3V0ZXIubWFuaWZlc3RcIilbdF0sXG4gICAgICAgICAgICAgICAgcGF0aHMgPSByb3V0ZUJsb2NrLnBhdGhzLFxuICAgICAgICAgICAgICAgIHNjaGVtZXMgPSByb3V0ZUJsb2NrLnNjaGVtZXMsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlciA9IHJvdXRlQmxvY2suY29udHJvbGxlcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGF0aFNjaGVtZSA9XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtZXMgJiYgQXJyYXkuaXNBcnJheShzY2hlbWVzKSAmJiBzY2hlbWVzLmxlbmd0aCA+IGlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2NoZW1lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICByb3V0aWVJbnB1dFtwYXRoc1tpXV0gPSB0aGlzLmJpbmRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgICAgICBwYXRoU2NoZW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXJcIikuYWRkTGlzdChyb3V0aWVJbnB1dCkubGlzdGVuKCk7IC8vLm5hdmlnYXRlKHRoaXMuZ2V0T3B0aW9ucygncm91dGVyLmluZGV4JykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaW50ZXJmYWNlIG1hbmlmZXN0IG9wdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgbWFuaWZlc3QgICAgaW50ZXJmYWNlIG1hbmlmZXN0XG4gICAgICovXG4gICAgc2V0SW50ZXJmYWNlTWFuaWZlc3QobWFuaWZlc3QpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShtYW5pZmVzdCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIsIG1hbmlmZXN0KTtcbiAgICAgICAgdGhpcy5pbml0Um91dGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBjb25zdHJ1Y3RvciBvZiBpbnRlcmZhY2UgbW9kZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIG1vZGVsTmFtZSAgIG1vZGVsIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICBpbnRlcmZhY2UgbW9kZWwgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2VNYW5pZmVzdChtb2RlbE5hbWUpIHtcbiAgICAgICAgaWYgKG1vZGVsTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIpW21vZGVsTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlTWFuaWZlc3RcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGluZyBBcHBsaWNhdGlvbiwgcmVsb2FkcyBpbnRlcmZhY2VzLCBpbml0IGNvbnRyb2xsZXIgbGF1bmNoZWQsIHN0YXJ0IGFnYWluXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICAvL9C90YPQttC90L4g0LjQvdC40YbQuNCw0LvQuNC30LjRgNC+0LLQsNGC0YxcbiAgICAgICAgLy/QvNC+0LTQtdC70Lgg0L/QvtC70YPRh9C10L3QvdGL0LzQuCDQuNC90YLQtdGA0YTQtdC50YHQsNC80LhcbiAgICAgICAgdGhpcy51cGRhdGVJbnRlcmZhY2VzKCk7XG4gICAgICAgIC8v0LjQvdC40YbQuNC70LjRhtC40YDQvtCy0LDRgtGMINC4INC30LDQv9GD0YHRgtC40YLRjCDQutC+0L3RgtGA0L7Qu9C70LXRgCDQuNC90LjRhtC40LDQu9C40LfQsNGG0LjQuFxuICAgICAgICB0aGlzLmluaXRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRBcHAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXphdGlvbiBvZiBzZXJ2aWNlcywgc3RhcnR1cCBvZiByb3V0aW5nXG4gICAgICovXG4gICAgc3RhcnRBcHAoKSB7XG4gICAgICAgIHRoaXMuaW5pdFNlcnZpY2VzKCk7XG4gICAgICAgIC8v0YHQvtC30LTQsNGC0Ywg0LrQvtC90YLRgNC+0LvQu9C10YDRi1xuICAgICAgICAvL9GA0L7Rg9GC0LXRgCDQuCDQv9GA0LjQstGP0LfQsNGC0Ywg0Log0L3QtdC80YMg0LrQvtC90YLRgNC+0LvQu9C10YDRi1xuICAgICAgICB0aGlzLmV4ZWNSb3V0ZXIoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJTdGFydGVkXCIsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXJOYW1lIGNvbnRyb2xsZXIgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb250cm9sbGVyUGF0aFNjaGVtZVxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gZnVuY3Rpb24gY3JlYXRlcyBuZXcgY29udHJvbGxlciBpbnN0YW5jZSBhbmQgcGFzcyBpbiBub3RBcHAgaW5zdGFuY2UsIGFyZ3VtZW50cyBmcm9tIHJvdXRlciBwYXJzZXIgYW5kIHBhdGhTY2hlbWVcbiAgICAgKi9cbiAgICBiaW5kQ29udHJvbGxlcihjb250cm9sbGVyTmFtZSwgY29udHJvbGxlclBhdGhTY2hlbWUpIHtcbiAgICAgICAgbGV0IGFwcCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXcgY29udHJvbGxlck5hbWUoYXBwLCBhcmd1bWVudHMsIGNvbnRyb2xsZXJQYXRoU2NoZW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyAnaW5pdGlhbGl6YXRpb24nIGNvbnRyb2xsZXIgd2hpY2ggaXMgcnVucyBvbmNlLFxuICAgICAqIHRvIHBlcmZvcm0gY3VzdG9tIGluaXRpYWxpemF0aW9ucyByb3V0aW5lcyBieSBhcHBsaWNhdGlvbiBjb2RlXG4gICAgICovXG4gICAgaW5pdENvbnRyb2xsZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXRPcHRpb25zKFwiaW5pdENvbnRyb2xsZXJcIikgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBpbml0Q29udHJvbGxlciA9IHRoaXMuZ2V0T3B0aW9ucyhcImluaXRDb250cm9sbGVyXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiaW5pdENvbnRyb2xsZXJcIiwgbmV3IGluaXRDb250cm9sbGVyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd29ya2luZyBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gd29ya2luZyBjb250cm9sbGVyXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJjdXJyZW50Q29udHJvbGxlclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95ZXMgd29ya2luZyBjb250cm9sbGVyIHRoZW4gc2V0cyBwcm92aWRlZCBhcyB3b3JraW5nXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGN0cmwgY29udHJvbGxlciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IG5vdEFwcCBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDb250cm9sbGVyKGN0cmwpIHtcbiAgICAgICAgbGV0IG9sZEN0cmwgPSB0aGlzLmdldEN1cnJlbnRDb250cm9sbGVyKCk7XG4gICAgICAgIGlmIChvbGRDdHJsICYmIG9sZEN0cmwuZGVzdHJveSkge1xuICAgICAgICAgICAgb2xkQ3RybC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiY3VycmVudENvbnRyb2xsZXJcIiwgY3RybCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYXJyb3cgZnVuY3Rpb246IChtb2RlbEluaXREYXRhID0ge30pID0+IG5vdFJlY29yZFxuICAgICAqIEZhY3RvcnkgdGhhdCBjcmVhdGVzIG5vdFJlY29yZCBpbnN0YW5jZXMgd2l0aCBiaW5kZWRcbiAgICAgKiByZWNvcmRNYW5pZmVzdCBhbmQgcHJvdmlkZWQgZGF0YSB0byBpbml0aWFsaXplIHJlY29yZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRNYW5pZmVzdFxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgICAqIEBtZW1iZXJvZiBub3RBcHBcbiAgICAgKi9cbiAgICBjcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkocmVjb3JkTWFuaWZlc3QpIHtcbiAgICAgICAgcmV0dXJuIChyZWNvcmREYXRhKSA9PiBuZXcgbm90UmVjb3JkKHJlY29yZE1hbmlmZXN0LCByZWNvcmREYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgaW50ZXJmYWNlcywgcmVjcmVhdGVzIGFsbCBhY2NvcmRpbmcgdG8gT3B0aW9ucy5pbnRlcmFmYWNlTWFuaWZlc3RcbiAgICAgKi9cbiAgICB1cGRhdGVJbnRlcmZhY2VzKCkge1xuICAgICAgICB0aGlzLmNsZWFySW50ZXJmYWNlcygpO1xuICAgICAgICBsZXQgbWFuaWZlc3RzID0gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlTWFuaWZlc3RcIik7XG4gICAgICAgIGlmIChtYW5pZmVzdHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gbWFuaWZlc3RzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY29yZE1hbmlmZXN0ID0gbWFuaWZlc3RzW25hbWVdLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRNZXRob2RzID0gdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgW1wibW9kZWxzXCIsIG5hbWVdLmpvaW4oXCIuXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAge31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZWNvcmRNYW5pZmVzdC5tZXRob2RzID0gcmVjb3JkTWV0aG9kcztcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lSW50ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnRlcmZhY2VNb2RlbEZhY3RvcnkocmVjb3JkTWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJmYWNlKG5hbWUsIG5hbWVJbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgaW50ZXJmYWNlIG5hbWUgKG1vZGVsTmFtZSkgdG8gc3RhbmRhcnRpemllZCBwcmVmaXhNb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBpbnRlcmZhY2UgbW9kZWwgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIG5vdCByZWNvcmQgbmFtZVxuICAgICAqL1xuICAgIGdldFJlY29yZE5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gT1BUX1JFQ09SRF9QUkVGSVggKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGNvbnRyb2xsZXIgbmFtZSAoY29udHJvbGxlck5hbWUpIHRvIHN0YW5kYXJ0aXppZWQgcHJlZml4Q29udHJvbGxlck5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb250cm9sbGVyIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICBub3QgY29udHJvbGxlciBuYW1lXG4gICAgICovXG4gICAgZ2V0Q29udHJvbGxlck5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gT1BUX0NPTlRST0xMRVJfUFJFRklYICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG5hbWVkIGludGVyZmFjZSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1vZGVsRmFjdG9yeVxuICAgICAqIEByZXR1cm4ge25vdEFwcH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QXBwXG4gICAgICovXG4gICAgc2V0SW50ZXJmYWNlKG5hbWUsIG1vZGVsRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGBpbnRlcmZhY2VzLiR7bmFtZX1gLCBtb2RlbEZhY3RvcnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIG5ldHdvcmsgaW50ZXJmYWNlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGFsbCBuZXR3b3JrIGluc3RlcmZhY2VzXG4gICAgICovXG4gICAgZ2V0SW50ZXJmYWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZXNcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbnRlcmZhY2VzIGxpc3QgY2xlYXJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjbGVhckludGVyZmFjZXMoKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImludGVyZmFjZXNcIiwge30pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFdlYlNvY2tldHMgY2xpZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPURFRkFVTFRfV1NfQ0xJRU5UX05BTUVdIG5hbWUgb2YgY2xpZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHdzYyAgbm90V1NDbGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2V0V1NDbGllbnQobmFtZSA9IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUsIHdzYykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGB3c2MuJHtuYW1lfWAsIHdzYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3ZWIgc29ja2V0cyBjbGllbnQgaW5zdGFuY2UgYnkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1ERUZBVUxUX1dTX0NMSUVOVF9OQU1FXVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGluc3RhbmNlIG9mIG5vdFdTQ2xpZW50XG4gICAgICovXG4gICAgZ2V0V1NDbGllbnQobmFtZSA9IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhgd3NjLiR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIG5ldHdvcmsgaW50ZXJmYWNlIGNsYXNzIGluaXRpYWxpemF0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIG5ldHdvcmsgaW50ZXJmYWNlXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBpbnRlcmZhY2UgY2xhc3MgaW5pdGlhbGl6YXRvclxuICAgICAqL1xuICAgIGdldEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZXMoKVtuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldHdvcmsgaW50ZXJmYWNlIChtb2RlbCkgaW5pdGlhbGl6ZWQgd2l0aCBwcm92aWRlZCBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgaW50ZXJmYWNlKG1vZGVsTmFtZSlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2RhdGE9e31dICAgIG1vZGVsIGRhdGFcbiAgICAgKiBAcmV0dXJucyBuZXR3b3JrIGludGVyZmFjZSBpbml0aWFsaXplcyB3aXRoIHByb3ZpZGVkIGRhdGFcbiAgICAgKi9cbiAgICBnZXRNb2RlbChuYW1lLCBkYXRhID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJmYWNlKG5hbWUpKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VydmljZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gdmFsIHNlcnZpY2VcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlKG5hbWUsIHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKGBzZXJ2aWNlcy4ke25hbWV9YCwgdmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gICAgICogQHJldHVybnMge29iamVjdHxmdW5jdGlvbn0gc2VydmljZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2UobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKGBzZXJ2aWNlcy4ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHByb3ZpZGVkIHNlcnZpY2VzXG4gICAgICovXG4gICAgaW5pdFNlcnZpY2VzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwic2VydmljZXNcIikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlcnZOYW1lIGluIHRoaXMuZ2V0T3B0aW9ucyhcInNlcnZpY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcnYgPSB0aGlzLmdldE9wdGlvbnMoYHNlcnZpY2VzLiR7c2Vydk5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZUeXBlID0gbm90Q29tbW9uLmRldGVjdFR5cGUoc2Vydik7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VydlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZXJ2aWNlKHNlcnZOYW1lLCBuZXcgc2Vydih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VydmljZShzZXJ2TmFtZSwgc2Vydik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXM/LmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBTZXJ2aWNlICgke3NlcnZOYW1lfSkgaW5pdCBlcnJvcmAsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kdWxlIGRlZGljYXRlZCBvcHRpb25zIHJlYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lICAgbW9kdWxlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByZWFkZXIgb2JqZWN0IHtnZXQocGF0aFRvVmFsdWUsIGRlZmF1bHRWYWx1ZSl9XG4gICAgICovXG4gICAgZ2V0Q29uZmlnUmVhZGVyRm9yTW9kdWxlKG1vZHVsZU5hbWUgPSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IG1vZENvbmZQYXRoID0gW1wibW9kdWxlc1wiLCBtb2R1bGVOYW1lXS5qb2luKFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogKHN1YlBhdGgsIGZhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlBhdGggJiYgdHlwZW9mIHN1YlBhdGggPT0gXCJzdHJpbmdcIiAmJiBzdWJQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgW21vZENvbmZQYXRoLCBzdWJQYXRoXS5qb2luKFwiLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhtb2RDb25mUGF0aCwgZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtb2R1bGUgZGVkaWNhdGVkIG9wdGlvbnMgcmVhZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2R1bGVOYW1lPScnXSAgIG1vZHVsZSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVhZGVyIG9iamVjdCB7Z2V0KHBhdGhUb1ZhbHVlLCBkZWZhdWx0VmFsdWUpfVxuICAgICAqL1xuICAgIG1vZHVsZUNvbmZpZyhtb2R1bGVOYW1lID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWdSZWFkZXJGb3JNb2R1bGUobW9kdWxlTmFtZSk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgbm90QXBwO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCB7IE5BVklHQVRJT05fREVMQVlfREVGQVVMVCB9IGZyb20gXCIuL2NvbnN0LmpzXCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUgPSBcImRlZmF1bHRcIl0gICAgICBkZWZhdWx0IGFjdGlvbiBuYW1lXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FID0gXCJkZWZhdWx0XCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCJtYWluLmNvbnRlbnRcIl0gIHNlbGVjdG9yIG9mIGNvbnRhaW5lciBIVE1MXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFxuICovXG5jb25zdCBPUFRfREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIm1haW4uY29udGVudFwiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX1BMVVJBTF9OQU1FID0gXCJNb2RlbHNcIl0gIGRlZmF1bHQgcGx1cmFsIG5hbWUgb2YgZW50aXRpZXNcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfUExVUkFMX05BTUUgPSBcIk1vZGVsc1wiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX1NJTkdMRV9OQU1FID0gXCJNb2RlbFwiXSAgZGVmYXVsdCBzaW5nbGUgbmFtZSBvZiBlbnRpdGllc1xuICovXG5jb25zdCBPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSA9IFwiTW9kZWxcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gIFtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRT1cIm1haW5cIl0gIGRlZmF1bHQgbW9kdWxlIG5hbWVcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfTU9EVUxFX05BTUUgPSBcIm1haW5cIjtcblxuLyoqXG4gKiBAY29uc3Qge2Jvb2xlYW59ICBbT1BUX0RFRkFVTFRfQVVUT19OQU1FID0gdHJ1ZV0gIGlmIHNob291bGQgYmUgdXNlZCBhdXRvIG5hbWUgZ2VuZXJhdG9yXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX0FVVE9fTkFNRSA9IHRydWU7XG5cbi8qKlxuICogIEJhc2ljIGNsYXNzIGZvciB1c2VyIGNvbnRyb2xsZXJcbiAqICBAZXh0ZW5kcyBub3RCYXNlXG4gKi9cbmNsYXNzIG5vdENvbnRyb2xsZXIgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7bnVtYmVyfSBQQVJBTVNfTEVOR1RIICBudW1iZXIgb2YgcGFyYW1zIGluIFVSTCBwYXRoXG4gICAgICovXG4gICAgc3RhdGljIFBBUkFNU19MRU5HVEggPSAyO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtzdHJpbmd9IE1PRFVMRV9OQU1FICBuYW1lIG9mIG1vZHVsZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9EVUxFX05BTUUoKSB7XG4gICAgICAgIHJldHVybiBPUFRfREVGQVVMVF9NT0RVTEVfTkFNRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfTkFNRSAgbmFtZSBvZiBtb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfTkFNRSgpIHtcbiAgICAgICAgcmV0dXJuIFwiTW9kZWxOYW1lXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBMQUJFTFMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbHVyYWw6IGAke09QVF9ERUZBVUxUX01PRFVMRV9OQU1FfTptb2RlbF9sYWJlbF9wbHVyYWxgLFxuICAgICAgICAgICAgc2luZ2xlOiBgJHtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRX06bW9kZWxfbGFiZWxfc2luZ2xlYCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlICAgIHtvYmplY3R8bnVsbH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIGVscztcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlICAgIHtvYmplY3R8bnVsbH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIG1ha2U7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSAgICB7bnVsbHxpbXBvcnQoJy4vYXBwLmpzJykuZGVmYXVsdH1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIGFwcDtcbiAgICAvKipcbiAgICAgKiAgQGNsYXNzXG4gICAgICogIEBwYXJhbSB7aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9IGFwcFxuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgIG5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5hcHAuc2V0Q3VycmVudENvbnRyb2xsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgcmVhZHk6IGZhbHNlLFxuICAgICAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICAgICAgbGliczoge30sXG4gICAgICAgICAgICBoZWxwZXJzOiB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHt9KTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IE9QVF9ERUZBVUxUX01PRFVMRV9OQU1FLFxuICAgICAgICAgICAgY29udGFpbmVyU2VsZWN0b3I6IE9QVF9ERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUixcbiAgICAgICAgICAgIHByZWZpeDogYXBwLmdldE9wdGlvbnMoXCJwYXRocy5tb2R1bGVcIiksXG4gICAgICAgICAgICBuYW1lczoge1xuICAgICAgICAgICAgICAgIHBsdXJhbDogT1BUX0RFRkFVTFRfUExVUkFMX05BTUUsXG4gICAgICAgICAgICAgICAgc2luZ2xlOiBPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFVSTFByZWZpeChhcHAuZ2V0T3B0aW9ucyhcInJvdXRlci5yb290XCIpKTtcbiAgICAgICAgLypcbiAgICAgINGB0YDQsNC30YMg0LTQtdC70LDQtdC8INC00L7RgdGC0YPQv9C90YvQvNC4INC80L7QtNC10LvQuCBub3RSZWNvcmQg0LjQtyBuY2BDb250cm9sbGVyTmFtZWAg0LHRg9C00YPRgiDQtNC+0YHRgtGD0L/QvdGLINC60LDQuiB0aGlzLm5yYE1vZGVsTmFtZWBcbiAgICAqL1xuICAgICAgICBsZXQgaW50ZXJmYWNlcyA9IGFwcC5nZXRJbnRlcmZhY2VzKCk7XG4gICAgICAgIHRoaXMubWFrZSA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0IGluIGludGVyZmFjZXMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGludGVyZmFjZXMsIHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlW3RdID0gaW50ZXJmYWNlc1t0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uKFwiZGVzdHJveVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCB1aU5hbWUgaW4gdGhpcy51aSkge1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXS5kZXN0cm95ICYmIHRoaXMudWlbdWlOYW1lXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51aVt1aU5hbWVdLiRkZXN0cm95ICYmIHRoaXMudWlbdWlOYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVscyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1ha2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgY3VycmVudCBub3RBcHBcbiAgICAgKiAgQHJldHVybiB7aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZ2V0QXBwKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIGRlZmF1bHQgY29udHJvbGxlciBtb2RlbFxuICAgICAqICBAcGFyYW0ge2ltcG9ydCgnLi9yZWNvcmQuanMnKX0gIG1vZGVsICBub3RSZWNvcmQgaW50ZXJmYWNlIG9iamVjdFxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVsXCIsIG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIElmIHplcm8gb3Igb25lIGFyZ3VtZW50IHByb3ZpZGVkIHRoaXMgbW9kZWxOYW1lIGluc3RhbmNlIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiAgSWYgdHdvIHByb3ZpZGVkIGFuZCBmaXJzdCBpcyBhIHN0cmluZyB0aGFuIGluc3RhbmNlIG9mIG5hbWUgd2lsbCBiZSByZXR1cm5lZCBpbml0aWFsaXplZCB3aXRoIHNlY29uZCBvYmplY3QgcGFyYW0gb3IgZW1wdHkgb2JqZWN0XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gICAgICBbbmFtZV0gICAgbW9kZWxOYW1lIG9mIGluc3RhbmNlIHRvIHJldHVybiBvciBpbml0aWFsIGRhdGEgZm9yIGluc3RhbmNlXG4gICAgICogIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICBbZGF0YV0gICAgbW9kZWwgZGF0YVxuICAgICAqICBAcmV0dXJuIHtpbXBvcnQoJy4vcmVjb3JkLmpzJykuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBnZXRNb2RlbChuYW1lLCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgaW50ID0gdGhpcy5nZXRJbnRlcmZhY2UobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50ICYmIGludChkYXRhIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGludCA9IHRoaXMuZ2V0SW50ZXJmYWNlKCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ICYmIGludChuYW1lIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbGxlciBpbnRlcmZhY2UgaWYgbmFtZSBpcyBub3Qgc3BlY2lmaWVkIG9yIGludGVyZmFjZSBvZiBzcGVjaWZpZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1cIlwiXVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2UobmFtZSA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwPy5nZXRJbnRlcmZhY2UobmFtZSB8fCB0aGlzLmdldE1vZGVsTmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBjdXJyZW50IG1vZGVsIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vZGVsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm1vZGVsTmFtZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFNldHMgZGVmYXVsdCBjb250cm9sbGVyIG1vZGVsIG5hbWVcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICBtb2RlbE5hbWUgIG5vdFJlY29yZCBpbnRlcmZhY2Ugb2JqZWN0XG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9XG4gICAgICovXG4gICAgc2V0TW9kZWxOYW1lKG1vZGVsTmFtZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlbE5hbWVcIiwgbm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIobW9kZWxOYW1lKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGN1cnJlbnQgbW9kZWwgcHJpbWFyeSBJRCBmaWVsZCBuYW1lXG4gICAgICogIEByZXR1cm4ge2ltcG9ydCgnLi9yZWNvcmQuanMnKX1cbiAgICAgKi9cbiAgICBnZXRNb2RlbElERmllbGROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibW9kZWxJREZpZWxkTmFtZVwiLCBcIl9pZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBjdXJyZW50IG1vZGVsIHByaW1hcnkgSUQgZmllbGQgbmFtZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsSURGaWVsZE5hbWUodmFsID0gXCJfaWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKFwibW9kZWxJREZpZWxkTmFtZVwiLCB2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBNYXJrcyB0aGlzIGNvbnRyb2xsZXIgYXMgcmVhZHlcbiAgICAgKiAgZW1pdHMgXCJyZWFkeVwiL1wiYnVzeVwiIGV2ZW50c1xuICAgICAqICBAcGFyYW0ge0Jvb2xlYW59ICB2YWwgIHRydWUvZmFsc2VcbiAgICAgKi9cbiAgICBzZXRSZWFkeSh2YWwgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJlYWR5XCIsIHZhbCk7XG4gICAgICAgIHZhbCA/IHRoaXMuZW1pdChcInJlYWR5XCIpIDogdGhpcy5lbWl0KFwiYnVzeVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBtb2R1bGUgVVJMIHByZWZpeFxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmFsIFVSTCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldFVSTFByZWZpeCh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidXJsUHJlZml4XCIsIHZhbCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXV0b05hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIHVybCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiAge3N0cmluZ30gcHJlZml4XG4gICAgICovXG4gICAgZ2V0VVJMUHJlZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwidXJsUHJlZml4XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIG1vZHVsZSBuYW1lXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgbmFtZSBvZiB0aGUgbW9kdWxlXG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRNb2R1bGVOYW1lKHZhbCkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJtb2R1bGVOYW1lXCIsIG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHZhbCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1dG9OYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBtb2R1bGUgbmFtZVxuICAgICAqICBAcmV0dXJuICB7c3RyaW5nfSBtb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIGdldE1vZHVsZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJtb2R1bGVOYW1lXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kdWxlIHBhdGggcHJlZml4XG4gICAgICogIEByZXR1cm4ge3N0cmluZ30gIHBhdGggdG8gbW9kdWxlIGRpclxuICAgICAqL1xuICAgIGdldE1vZHVsZVByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRPcHRpb25zKFwicGF0aHMubW9kdWxlc1wiKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICBdLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kZWwgVVJMIHdpdGggVVJMIHByZWZpeFxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9ICB1cmwgcGF0aFxuICAgICAqL1xuICAgIGdldE1vZGVsVVJMKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdGhpcyBtb2RlbCBhY3Rpb24gVVJMIHdpdGggVVJMIHByZWZpeFxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBpZCAgICAgICBzb21lIGlkZW50aWZpY2F0b3Igb2YgbW9kZWxcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgYWN0aW9uICAgYWN0aW9uIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfSAgdXJsIHBhdGhcbiAgICAgKi9cbiAgICBnZXRNb2RlbEFjdGlvblVSTChpZCwgYWN0aW9uID0gXCJcIikge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgIG1vZHVsZTogdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHVybCBmcm9tIHZhbHVlIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIHZhbFxuICAgICAqKi9cbiAgICBidWlsZFVSTCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5idWlsZFVSTCh2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBVcGRhdGVzIHdvcmtpbmcgbmFtZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfSB0aGlzXG4gICAgICovXG4gICAgdXBkYXRlQXV0b05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvTmFtZVwiLCBPUFRfREVGQVVMVF9BVVRPX05BTUUpKSB7XG4gICAgICAgICAgICAvL3RoaXMuc2V0V29ya2luZygnbmFtZScsIHRoaXMuZ2V0TW9kZWxVUkwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgb2JqZWN0IG5hbWVcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBuYW1lIG9mIHRoZSBvYmplY3RcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHNldE5hbWUodmFsKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm5hbWVcIiwgdmFsKTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwiYXV0b05hbWVcIiwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgR2V0cyBvYmplY3QgbmFtZVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFByZWxvYWQgcmVjb3JkcyBmcm9tIHNlcnZlciwgdXNpbmcgbGlzdEFsbCBtZXRob2QsXG4gICAgICogIHJldHVybnMgUHJvbWlzZVxuICAgICAqICBAcGFyYW0ge29iamVjdH0gIGxpc3QgIG1hcCBvZiBwcmVsb2FkZWQgcmVjb3Jkc1xuICAgICAqICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHByZWxvYWRMaWIobGlzdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcImxvYWRpbmdcIiwgW10pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgaW4gbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLnB1c2gobGlzdFt0XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVtsaXN0W3RdXSh7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC4kbGlzdEFsbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5nZXRPcHRpb25zKFwibGlic1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJsaWJzXCIsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwibGlic1wiKVt0XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmluZGV4T2YobGlzdFt0XSkgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ya2luZyhcImxvYWRpbmdcIikuaW5kZXhPZihsaXN0W3RdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0V29ya2luZyhcImxvYWRpbmdcIikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbWl0cyBhZnRlclJlbmRlciBldmVudFxuICAgICAqL1xuICAgIG9uQWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImFmdGVyUmVuZGVyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBUcmFuc2Zvcm0gcm91dGUgbmFtZSBpbiBhY3Rpb24gbmFtZVxuICAgICAqICBAcGFyYW0ge1N0cmluZ30gICBuYW1lIHRyYW5mb3JtIGFjdGlvbiBuYW1lXG4gICAgICogIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBY3Rpb25OYW1lKG5hbWUgPSBPUFRfREVGQVVMVF9BQ1RJT05fTkFNRSkge1xuICAgICAgICByZXR1cm4gXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEdldCBkZWZhdWx0IGNvbnRyb2xsZXIgYWN0aW9uIG5hbWVcbiAgICAgKiAgQHJldHVybiB7U3RyaW5nfSBkZWZhdWx0IGFjdGlvbiBmcm9tIG9wdGlvbnNcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0QWN0aW9uTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9uTmFtZShcbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImRlZmF1bHRBY3Rpb25cIiwgT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJvdXRlIHBhcmFtcyBpbnRvIHNwZWNpZmljIHJ1bltSb3V0ZV9uYW1lXSBmdW5jdGlvblxuICAgICAqICBAcGFyYW0ge2FycmF5fSAgIHBhcmFtcyAgIGNvbnRyb2xsZXIgaW5wdXQgcGFyYW1zXG4gICAgICogIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICByb3V0ZShwYXJhbXMpIHtcbiAgICAgICAgbGV0IFtyb3V0ZXJOYW1lLCAuLi5zdWJQYXJhbXNdID0gcGFyYW1zLFxuICAgICAgICAgICAgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0QWN0aW9uTmFtZShcbiAgICAgICAgICAgICAgICByb3V0ZXJOYW1lID8gcm91dGVyTmFtZSA6IE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FXG4gICAgICAgICAgICApO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbYWN0aW9uTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgdGhpc1thY3Rpb25OYW1lXShzdWJQYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbdGhpcy5nZXREZWZhdWx0QWN0aW9uTmFtZSgpXSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50QWN0aW9uKHRoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKSk7XG4gICAgICAgICAgICB0aGlzW3RoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKV0oc3ViUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudEFjdGlvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKFwiTm8gYWN0aW9uIGluIHJvdXRlclwiLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3b3JraW5nIGFjdGlvblxuICAgICAqIEBwYXJhbXMge3N0cmluZ30gYWN0aW9uTmFtZSBjdXJyZW50IGFjdGlvbiBuYW1lXG4gICAgICovXG4gICAgc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImFjdGlvblwiLCBhY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdvcmtpbmcgYWN0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3VycmVudCBhY3Rpb24gbmFtZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRBY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJhY3Rpb25cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBhcHBsaWNhdGlvbiBvcHRpb25zXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRBcHBPcHRpb25zKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBtb2R1bGUgb3B0aW9uc1xuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgW21vZHVsZU5hbWVdICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBvcHRpb25zIHJlcXVlc3RlZFxuICAgICAqICBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cbiAgICBnZXRNb2R1bGVPcHRpb25zKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcCgpLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgW1wibW9kdWxlc1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIHNlcnZpY2VzXG4gICAgICogIEBwYXJhbSAge3N0cmluZ30gICBtb2R1bGVOYW1lICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBzZXJ2aWNlcyByZXF1ZXN0ZWRcbiAgICAgKiAgQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgZ2V0U2VydmljZXMobW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJzZXJ2aWNlc1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIGNvbXBvbmVudHNcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgIG1vZHVsZU5hbWUgICAgbmFtZSBvZiB0aGUgbW9kdWxlIHdoaWNoIGNvbXBvbmVudHMgcmVxdWVzdGVkXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuICAgIGdldENvbXBvbmVudHMobW9kdWxlTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICBbXCJjb21wb25lbnRzXCIsIG1vZHVsZU5hbWUgfHwgdGhpcy5nZXRNb2R1bGVOYW1lKCldLmpvaW4oXCIuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmcmVzaGVzIGN1cnJlbnQgVVJMLCByZS1ydW4gYWxsIGFjdGlvblxuICAgICAqICBAcGFyYW0ge251bWJlcn0gdGltZW91dCB0aW1lIHRvIHdhaXQgaW4gbXNcbiAgICAgKi9cbiAgICByZWZyZXNoKHRpbWVvdXQgPSAwKSB7XG4gICAgICAgIHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpLnJlZnJlc2godGltZW91dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwYXRoIHBhdHRlcm4gZm9yIHJvdXRlclxuICAgICAqIEBwYXJhbXMge251bWJlcn0gWzBdIHBhcmFtc0NvdW50ICAgbnVtYmVyIG9mIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIHBhdHRlcm4gZm9yIGNvbnRyb2xsZXIgc3VwcG9ydGVkIHVybFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb250cm9sbGVyUm91dGUocGFyYW1zQ291bnQgPSAwKSB7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGlmICh0aGlzLk1PRFVMRV9OQU1FICYmIHRoaXMuTU9EVUxFX05BTUUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHRoaXMuTU9EVUxFX05BTUUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5NT0RFTF9OQU1FICYmIHRoaXMuTU9ERUxfTkFNRS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIodGhpcy5NT0RFTF9OQU1FKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IFtwYXRoLmpvaW4oXCIvXCIpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCIvKFteL10rKVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGF0aCBwYXR0ZXJucyBmb3Igcm91dGVyXG4gICAgICogQHBhcmFtcyB7bnVtYmVyfSBbMF0gcGFyYW1zRGVlcCAgIGhvdyBtYW55IHBhdGhzIHdpdGggcGFyYW1zIGluIHRoZSBlbmRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gIHBhdHRlcm5zIGZvciBjb250cm9sbGVyIHN1cHBvcnRlZCB1cmwgaW4gb3JkZXIgb2Ygc2ltcGxpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29udHJvbGxlclJvdXRlcyhwYXJhbXNEZWVwID0gMCkge1xuICAgICAgICBsZXQgcm91dGVzID0gW3RoaXMuZ2V0Q29udHJvbGxlclJvdXRlKDApXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXNEZWVwOyBpKyspIHtcbiAgICAgICAgICAgIHJvdXRlcy51bnNoaWZ0KHRoaXMuZ2V0Q29udHJvbGxlclJvdXRlKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJvdXRlciBydWxlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJvdXRlciBydWxlIHtwYXRoczpTdHJpbmdbXSwgY29udHJvbGxlcjpub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoczogdGhpcy5nZXRDb250cm9sbGVyUm91dGVzKHRoaXMuUEFSQU1TX0xFTkdUSCksXG4gICAgICAgICAgICBjb250cm9sbGVyOiB0aGlzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQXBwbGljYXRpb24gcm91dGVyXG4gICAgICogQHJldHVybnMge2ltcG9ydCgnLi9yb3V0ZXIuanMnKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIGdldFJvdXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwPy5nZXRXb3JraW5nKFwicm91dGVyXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgbG9jYXRpb24gdG8gYHVybGAgYWZ0ZXIgYGRlbGF5YCBtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICAgZGVsYXkgICBudW1iZXIgaW4gbXMgb3IgbmFtZSBvZiBkZWxheVxuICAgICAqL1xuICAgIG5hdmlnYXRlV2l0aERlbGF5KFxuICAgICAgICB1cmwsXG4gICAgICAgIGRlbGF5ID0gTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxULFxuICAgICAgICBkb0JlZm9yZSA9ICgpID0+IHt9XG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvdXRlcigpLm5hdmlnYXRlV2l0aERlbGF5KHVybCwgZGVsYXksIGRvQmVmb3JlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGxvY2F0aW9uIHRvIGB1cmxgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIG5hdmlnYXRlKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZSh1cmwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBOYXZpZ2F0aW5nIHRvIHRoaXMgY29udHJvbGxlciBtYWluIG1vZGVsIGBhY3Rpb25gIHdpdGggcHJvdmlkZWQgYGlkYCxcbiAgICAgKiAgZW1wdHkgYGlkYCB3aWxsIGJlIGRyb3BwZWQgZnJvbSByZXN1bHRpbmcgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZUFjdGlvbihpZCwgYWN0aW9uID0gXCJcIiwgZGVsYXkgPSAwLCBkb0JlZm9yZSA9ICgpID0+IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlTW9kdWxlQWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5nZXRNb2R1bGVOYW1lKCksXG4gICAgICAgICAgICB0aGlzLmdldE1vZGVsTmFtZSgpLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE5hdmlnYXRpbmcgdG8gdGhpcyBjb250cm9sbGVyIG1vZHVsZSBtb2RlbCBvZiBgbW9kZWxOYW1lYCBgYWN0aW9uYCB3aXRoIHByb3ZpZGVkIGBpZGAsXG4gICAgICogIGVtcHR5IGBpZGAgd2lsbCBiZSBkcm9wcGVkIGZyb20gcmVzdWx0aW5nIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYWN0aW9uPVwiXCJdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSAgICAgICAgICAgIGRlbGF5IGluIG1zIGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gIFtkb0JlZm9yZV0gICAgICB3aWxsIGV4ZWN1dGVkIG9ubHkgaWYgZGVsYXllZCBhZnRlciBkZWxheSBidXQgYmVmb3JlIG5hdmlnYXRlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29udHJvbGxlclxuICAgICAqL1xuICAgIG5hdmlnYXRlTW9kZWxBY3Rpb24oXG4gICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGlvbiA9IFwiXCIsXG4gICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgZG9CZWZvcmUgPSAoKSA9PiB7fVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE5hdmlnYXRpbmcgdG8gYG1vZHVsZU5hbWVgIGBtb2RlbE5hbWVgIGBhY3Rpb25gIHdpdGggcHJvdmlkZWQgYGlkYCxcbiAgICAgKiAgZW1wdHkgYGlkYCB3aWxsIGJlIGRyb3BwZWQgZnJvbSByZXN1bHRpbmcgdXJsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgbW9kZWxOYW1lLFxuICAgICAgICBpZCxcbiAgICAgICAgYWN0aW9uID0gXCJcIixcbiAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICBkb0JlZm9yZSA9ICgpID0+IHt9XG4gICAgKSB7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVyKCkubmF2aWdhdGVXaXRoRGVsYXkoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiB0aGlzLmdldFVSTFByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICAgICAgZG9CZWZvcmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZShcbiAgICAgICAgICAgICAgICBub3RDb21tb24uYnVpbGRVUkwoe1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHRoaXMuZ2V0VVJMUHJlZml4KCksXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWVudSBpdGVtIGZyb20gY2hpbGQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge25vdENvbnRyb2xsZXJ9IGNoaWxkQ29uc3RydWN0b3JcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5OYXZpZ2F0aW9uSXRlbT59XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29tbW9uTWVudShjaGlsZENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHNlY3Rpb246IGNoaWxkQ29uc3RydWN0b3IuTU9EVUxFX05BTUUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaGlsZENvbnN0cnVjdG9yLkxBQkVMUy5wbHVyYWwsXG4gICAgICAgICAgICAgICAgdXJsOiBgLyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb25zdHJ1Y3Rvci5NT0RVTEVfTkFNRVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgKX0vJHtub3RDb21tb24ubG93ZXJGaXJzdExldHRlcihjaGlsZENvbnN0cnVjdG9yLk1PREVMX05BTUUpfWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNZW51KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q29udHJvbGxlcjtcbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBBTEwgPSB7fTtcblxuZnVuY3Rpb24gZXhpc3Qoa2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd24oQUxMLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGV4aXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIEFMTFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShcbiAgICBrZXksXG4gICAgcHJvcHMgPSB7XG4gICAgICAgIHJhdzogW10sXG4gICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgIH1cbikge1xuICAgIGlmICghZXhpc3Qoa2V5KSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIEFMTFtrZXldID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFMTFtrZXldW25hbWVdID0gd3JpdGFibGUocHJvcHNbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdG9yZSdzIHByb3BzIHdhc24ndCBzcGVjaWZpZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFMTFtrZXldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgb2JqZWN0IHRoYXQgaXMgZmFrZSBTdG9yZVxuICogU29tZSB0aW1lIHRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBsb2NhbCB2YXIsXG4gKiBiZWZvcmUgeW91IGNvdWxkIGdldCBhY3R1YWwgU3RvcmVzIGZyb20gY2VudHJhbCBzdG9yYWdlIGJ5IGl0cyBJRFxuICpcdEBwYXJhbXMge21peGVkfSB2YWwgXHRkYXRhIG9mIHR5cGUgdGhhdCBpcyBhY3R1YWwgc3RvcmFnZSB3aWxsIGNvbnRhaW5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmFrZSh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZikge1xuICAgICAgICAgICAgZih2YWwpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7fSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGUsIGdldCwgZmFrZSB9O1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0ICdidWxtYS1zd2l0Y2gnO1xuXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWx1ZV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHlsaW5nXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgaWQgPSAnJyxcbiAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgIGZpZWxkbmFtZSA9ICdzd2l0Y2gnLFxuICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICBzdHlsaW5nID0gXCIgaXMtcm91bmRlZCBpcy1zdWNjZXNzIFwiXG4gIH0gPSAkcHJvcHMoKTtcblxuZnVuY3Rpb24gb25JbnB1dChldil7XG4gICAgbGV0IGRhdGEgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICB2YWx1ZTogZXYudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcgPyBldi50YXJnZXQuY2hlY2tlZDpldi50YXJnZXQudmFsdWVcbiAgICB9O1xuICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCBkYXRhKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuPC9zY3JpcHQ+XG5cbjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICBjbGFzcz1cInN3aXRjaCB7c3R5bGluZ31cIlxuICBpZD1cImVkaXQtdGFibGUtcm93LWNlbGwtaW5saW5lLXN3aXRjaC17ZmllbGRuYW1lfS17aWR9XCJcbiAgYmluZDpjaGVja2VkPXt2YWx1ZX1cbiAgbmFtZT1cIntmaWVsZG5hbWV9XCJcbiAge3JlYWRvbmx5fSB7ZGlzYWJsZWR9XG4gIG9uaW5wdXQ9e29uSW5wdXR9XG4gIC8+XG48bGFiZWwgY2xhc3M9XCJsYWJlbFwiIGZvcj1cImVkaXQtdGFibGUtcm93LWNlbGwtaW5saW5lLXN3aXRjaC17ZmllbGRuYW1lfS17aWR9XCI+PC9sYWJlbD5cbiIsIjxzY3JpcHQ+XG4gICAgLypcbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJztcbiAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG4qL1xuICAgIFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge2FueX0gW3ZhbHVlc10gLSBpdGVtID0ge1xuaWQsICAgICAgICAvL3VuaXF1ZVxudGl0bGUsICAgICAvL3NvbWUgdGV4dFxudmFsdWUsICAgICAgLy9mb3IgZG91YmxlIHRhZ3NcbmNvbG9yICAgICAgIC8vY29sb3Jpbmdcbn1cbiAgICovXG5cbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgbGV0IHsgdmFsdWVzID0gW10gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjZWFjaCB2YWx1ZXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgeyNpZiBPYmplY3QuaGFzT3duKGl0ZW0sIFwidmFsdWVcIil9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJteC0xIHRhZ3MgaGFzLWFkZG9uc1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWdcIj57aXRlbS50aXRsZX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRhZyBpcy17aXRlbS5jb2xvcn0ge2l0ZW0uY3VzdG9tQ2xhc3Nlc31cIj5cbiAgICAgICAgICAgICAgICB7I2lmIGl0ZW0udXJsfVxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPXtpdGVtLnVybH0gY2xhc3M9e2l0ZW0udXJsQ3VzdG9tQ2xhc3Nlc31cbiAgICAgICAgICAgICAgICAgICAgICAgID57aXRlbS52YWx1ZX08L2FcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAge2l0ZW0udmFsdWV9XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgezplbHNlfVxuICAgICAgICA8c3BhbiBjbGFzcz1cIm14LTEgdGFnIGlzLXtpdGVtLmNvbG9yfSB7aXRlbS5jdXN0b21DbGFzc2VzfVwiPlxuICAgICAgICAgICAgeyNpZiBpdGVtLnVybH1cbiAgICAgICAgICAgICAgICA8YSBocmVmPXtpdGVtLnVybH0gY2xhc3M9e2l0ZW0udXJsQ3VzdG9tQ2xhc3Nlc30+e2l0ZW0udGl0bGV9PC9hXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHtpdGVtLnRpdGxlfVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9zcGFuPlxuICAgIHsvaWZ9XG57L2VhY2h9XG5cbjxzdHlsZT5cbiAgICAudGFnczpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogbm9uZTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgbGV0IHRpdGxlID0gJHN0YXRlKFwiXCIpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGQudHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGQsIFwidGl0bGVQYXRoXCIpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBub3RQYXRoLmdldChmaWVsZC50aXRsZVBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBPYmplY3QuaGFzT3duKGZpZWxkLCBcInRpdGxlQ29tcG9zZXJcIikgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZmllbGQudGl0bGVDb21wb3NlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGZpZWxkLnRpdGxlQ29tcG9zZXIoaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gbm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlua3MgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xpbmsvdWkubGlua3Muc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2VzIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9pbWFnZS91aS5pbWFnZXMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQm9vbGVhbnMgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuYm9vbGVhbnMuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVGFibGVTd2l0Y2ggZnJvbSBcIi4vY29udHJvbHMvdWkuc3dpdGNoLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBUYWJsZVRhZ3MgZnJvbSBcIi4vY29udHJvbHMvdWkudGFncy5zdmVsdGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIGdldEl0ZW1JZCA9IChpdGVtKSA9PiBpdGVtLl9pZCxcbiAgICAgICAgZmllbGQgPSB7fSxcbiAgICAgICAgaXRlbSA9IHt9LFxuICAgICAgICBoZWxwZXJzID0ge31cbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHRkXG4gICAgY2xhc3M9eyhmaWVsZC5oaWRlT25Nb2JpbGUgPyBcIiBpcy1oaWRkZW4tdG91Y2ggXCIgOiBcIlwiKSArXG4gICAgICAgIChmaWVsZC5jbGFzc2VzID8gYCAke2ZpZWxkLmNsYXNzZXN9IGAgOiBcIlwiKX1cbiAgICB7dGl0bGV9XG4+XG4gICAgeyNpZiBmaWVsZC50eXBlID09PSBcImxpbmtcIn1cbiAgICAgICAgPFVJTGlua3MgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJidXR0b25cIn1cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcImltYWdlXCJ9XG4gICAgICAgIDxVSUltYWdlcyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcImJvb2xlYW5cIn1cbiAgICAgICAgPFVJQm9vbGVhbnMgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJ0YWdcIn1cbiAgICAgICAgPFRhYmxlVGFncyB2YWx1ZXM9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfSAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC50eXBlID09PSBcInN3aXRjaFwifVxuICAgICAgICA8VGFibGVTd2l0Y2hcbiAgICAgICAgICAgIGlkPXtnZXRJdGVtSWQoaXRlbSl9XG4gICAgICAgICAgICBmaWVsZG5hbWU9e2ZpZWxkLnBhdGh9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgdmFsdWU9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfVxuICAgICAgICAgICAgcmVhZG9ubHk9e2ZpZWxkLnJlYWRvbmx5fVxuICAgICAgICAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZC5jb21wb25lbnR9XG4gICAgICAgIDxmaWVsZC5jb21wb25lbnRcbiAgICAgICAgICAgIGlkPXtnZXRJdGVtSWQoaXRlbSl9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e2ZpZWxkLm9uQ2hhbmdlfVxuICAgICAgICAgICAgZmllbGRuYW1lPXtmaWVsZC5wYXRofVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZpZWxkLmRpc2FibGVkfVxuICAgICAgICAgICAgcmVhZG9ubHk9e2ZpZWxkLnJlYWRvbmx5fVxuICAgICAgICAgICAgdmFsdWU9e25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpfVxuICAgICAgICAgICAgey4uLmZpZWxkLm9wdGlvbnN9XG4gICAgICAgIC8+XG4gICAgezplbHNlIGlmIGZpZWxkICYmIHR5cGVvZiBmaWVsZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNOYU4oZmllbGQubWF4TGVuZ3RoKSAmJiBmaWVsZC5tYXhMZW5ndGh9XG4gICAgICAgIHtub3RDb21tb24uc3RyTGVuZ3RoQ2FwKFxuICAgICAgICAgICAgbm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyksXG4gICAgICAgICAgICBmaWVsZC5tYXhMZW5ndGhcbiAgICAgICAgKX1cbiAgICB7OmVsc2V9XG4gICAgICAgIHskTE9DQUxFW25vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpXX1cbiAgICB7L2lmfVxuPC90ZD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBVSVRhYmxlQ2VsbCBmcm9tICcuL25vdFRhYmxlQ2VsbC5zdmVsdGUnO1xuICBpbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSAnLi9zdG9yZXMuanMnO1xuICBcbiAgaW1wb3J0IHtvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXJ9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGxldCBpdGVtSWQgPSAkc3RhdGUoKSwgc2VsZWN0ZWRMaXN0O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgICAgaXRlbUlkID0gZ2V0SXRlbUlkKGl0ZW0pO1xuICAgICAgc2VsZWN0ZWRMaXN0ID0gU3RvcmVzLmdldChpZCkuc2VsZWN0ZWQ7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBpZFxuICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbaGVscGVyc11cbiAgICogQHByb3BlcnR5IHthbnl9IFtmaWVsZHNdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dTZWxlY3RdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbUlkXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgaWQsXG4gICAgICBpdGVtID0ge30sXG4gICAgICBoZWxwZXJzID0ge30sXG4gICAgICBmaWVsZHMgPSBbXSxcbiAgICAgIHNob3dTZWxlY3QgPSBmYWxzZSxcbiAgICAgIGdldEl0ZW1JZCA9ICgpPT57fVxuICB9ID0gJHByb3BzKCk7XG5cbiAgZnVuY3Rpb24gb25Sb3dTZWxlY3QoZSl7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNwYXRjaCgncm93U2VsZWN0Q2hhbmdlJywge1xuICAgICAgICAgIGlkOiAgICAgICBpdGVtSWQsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICRzZWxlY3RlZExpc3RbaXRlbUlkXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG48L3NjcmlwdD5cblxuPHRyPlxuICB7I2lmIHNob3dTZWxlY3QgJiYgJHNlbGVjdGVkTGlzdCB9XG4gIDx0ZD5cbiAgICA8aW5wdXQgaWQ9XCJ0YWJsZS1yb3ctc2VsZWN0LXtnZXRJdGVtSWQoaXRlbSl9XCIgdHlwZT1cImNoZWNrYm94XCIgZGF0YS1pZD1cIntnZXRJdGVtSWQoaXRlbSl9XCIgYmluZDpjaGVja2VkPXskc2VsZWN0ZWRMaXN0W2l0ZW1JZF19IHBsYWNlaG9sZGVyPVwiXCIgbmFtZT1cInJvd19zZWxlY3RlZF97Z2V0SXRlbUlkKGl0ZW0pfVwiIG9uY2hhbmdlPXtvblJvd1NlbGVjdH0gLz5cbiAgPC90ZD5cbiAgey9pZn1cbiAgeyNlYWNoIGZpZWxkcyBhcyBmaWVsZCB9XG4gIDxVSVRhYmxlQ2VsbCB7ZmllbGR9IHtoZWxwZXJzfSB7aXRlbX0ge2dldEl0ZW1JZH0gLz5cbiAgey9lYWNofVxuPC90cj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0ICogYXMgU3RvcmVzIGZyb20gXCIuL3N0b3Jlcy5qc1wiO1xuXG4gICAgaW1wb3J0IFVJVGFibGVSb3cgZnJvbSBcIi4vbm90VGFibGVSb3cuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUxpbmtzIH0gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xpbmtcIjtcbiAgICBpbXBvcnQgeyBVSUJ1dHRvbnMgfSBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvYnV0dG9uXCI7XG4gICAgaW1wb3J0IFVJSWNvbiBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvaWNvbi91aS5pY29uLmZvbnQuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBvbk1vdW50LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBpZFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBmaWx0ZXJVSVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaGVscGVyc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZmllbGRzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VsZWN0ZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2FjdGlvbnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaW5rc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93U2VhcmNoXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dTZWxlY3RdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2VsZWN0QWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0SXRlbUlkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCxcbiAgICAgICAgZmlsdGVyVUksXG4gICAgICAgIGhlbHBlcnMgPSB7fSxcbiAgICAgICAgc3RhdGUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWx0ZXIgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBzb3J0ZXIgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBmaWVsZHMgPSBbXSxcbiAgICAgICAgc2VsZWN0ZWQgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBpdGVtcyA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgc2VhcmNoID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBzaG93U2VhcmNoID0gdHJ1ZSxcbiAgICAgICAgc2hvd1NlbGVjdCA9IHRydWUsXG4gICAgICAgIHNlbGVjdEFsbCA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIGdldEl0ZW1JZCA9IChpdGVtKSA9PiBpdGVtLl9pZCxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKHNob3dTZWxlY3QpIHtcbiAgICAgICAgICAgIFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgU3RvcmVzLmdldChpZCkucmVmaW5lZC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpdGVtcyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHNob3dTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtSWQgaW4gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcy5zb21lKChpdGVtKSA9PiBnZXRJdGVtSWQoaXRlbSkgPT09IGl0ZW1JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFtpdGVtSWRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHNlbGVjdGVkLCBpdGVtSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbaXRlbUlkXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBTdG9yZXMuZ2V0KGlkKS5zdGF0ZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uU2VhcmNoSW5wdXQoZXYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZXYuY3VycmVudFRhcmdldC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICBkaXNwYXRjaChcInNlYXJjaENoYW5nZVwiLCBkYXRhKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblNlYXJjaENoYW5nZSh7IGRldGFpbCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChcInNlYXJjaENoYW5nZVwiLCBkZXRhaWwpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRmlsdGVyQ2hhbmdlKHsgZGV0YWlsIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKFwiZmlsdGVyQ2hhbmdlXCIsIGRldGFpbCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29QcmV2KCkge1xuICAgICAgICBkaXNwYXRjaChcImdvVG9QcmV2UGFnZVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb05leHQoKSB7XG4gICAgICAgIGRpc3BhdGNoKFwiZ29Ub05leHRQYWdlXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvVG8oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCBlbCA9IGUudGFyZ2V0O1xuICAgICAgICBkaXNwYXRjaChcImdvVG9QYWdlXCIsIHBhcnNlSW50KGVsLmRhdGFzZXQucGFnZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TZWxlY3RBbGwoKSB7XG4gICAgICAgIFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkLnVwZGF0ZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtnZXRJdGVtSWQoaXRlbSldID0gc2VsZWN0QWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRmllbGRIZWFkQ2xpY2soZmllbGQpIHtcbiAgICAgICAgY29uc3QgcHJvcFBhdGggPSBmaWVsZC5wYXRoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oc29ydGVyLCBwcm9wUGF0aCkpIHtcbiAgICAgICAgICAgIHNvcnRlcltwcm9wUGF0aF0gPSBwYXJzZUludChzb3J0ZXJbcHJvcFBhdGhdKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydGVyID0ge1xuICAgICAgICAgICAgICAgIFtwcm9wUGF0aF06IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKFwic29ydGVyQ2hhbmdlXCIsIHNvcnRlcik7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgbGlua3MubGVuZ3RofVxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZCBpcy1ncm91cGVkXCI+XG4gICAgICAgIDxVSUxpbmtzIHZhbHVlcz17bGlua3N9IC8+XG4gICAgPC9kaXY+XG57L2lmfVxueyNpZiBhY3Rpb25zLmxlbmd0aH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZFwiPlxuICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17YWN0aW9uc30gLz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG57I2lmIHNob3dTZWFyY2h9XG4gICAgeyNpZiBmaWx0ZXJVSX1cbiAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBmaWx0ZXJVSX1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICAgICAgYmluZDpmaWx0ZXJcbiAgICAgICAgICAgIG9uOmNoYW5nZT17b25GaWx0ZXJDaGFuZ2V9XG4gICAgICAgICAgICBvbjpzZWFyY2hDaGFuZ2U9e29uU2VhcmNoQ2hhbmdlfVxuICAgICAgICAvPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cItCf0L7QuNGB0LpcIlxuICAgICAgICAgICAgICAgICAgICBiaW5kOnZhbHVlPXtzZWFyY2h9XG4gICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9e29uU2VhcmNoSW5wdXR9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuey9pZn1cbjx0YWJsZSBjbGFzcz1cInRhYmxlXCI+XG4gICAgPHRoZWFkPlxuICAgICAgICA8dHI+XG4gICAgICAgICAgICB7I2lmIHNob3dTZWxlY3R9XG4gICAgICAgICAgICAgICAgPHRoXG4gICAgICAgICAgICAgICAgICAgID48aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cInRhYmxlLXJvdy1zZWxlY3QtcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNoZWNrZWQ9e3NlbGVjdEFsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyb3dfc2VsZWN0ZWRfYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2hhbmdlPXtvblNlbGVjdEFsbH1cbiAgICAgICAgICAgICAgICAgICAgLz48L3RoXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCBmaWVsZHMgYXMgZmllbGR9XG4gICAgICAgICAgICAgICAge0Bjb25zdCBwcm9wUGF0aCA9IGZpZWxkLnBhdGguc3Vic3RyaW5nKDEpfVxuICAgICAgICAgICAgICAgIDx0aFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz17KGZpZWxkLmhpZGVPbk1vYmlsZSA/IFwiIGlzLWhpZGRlbi10b3VjaFwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZpZWxkLnNvcnRhYmxlID8gXCIgaXMtY2xpY2thYmxlXCIgOiBcIlwiKX1cbiAgICAgICAgICAgICAgICAgICAgb25jbGljaz17b25GaWVsZEhlYWRDbGljayhmaWVsZCl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGZpZWxkLnNvcnRhYmxlICYmIE9iamVjdC5oYXNPd24oc29ydGVyLCBwcm9wUGF0aCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VUlJY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udD17c29ydGVyW3Byb3BQYXRoXSA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInNvcnQtdXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwic29ydC1kb3duXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2ZpZWxkLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50YWJsZT17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHskTE9DQUxFW2ZpZWxkLnRpdGxlXX1cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5PlxuICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5faWQpfVxuICAgICAgICAgICAgPFVJVGFibGVSb3dcbiAgICAgICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICAgICAge2l0ZW19XG4gICAgICAgICAgICAgICAge2ZpZWxkc31cbiAgICAgICAgICAgICAgICB7aGVscGVyc31cbiAgICAgICAgICAgICAgICB7c2hvd1NlbGVjdH1cbiAgICAgICAgICAgICAgICB7Z2V0SXRlbUlkfVxuICAgICAgICAgICAgICAgIG9uOnJvd1NlbGVjdENoYW5nZVxuICAgICAgICAgICAgLz5cbiAgICAgICAgey9lYWNofVxuICAgIDwvdGJvZHk+XG48L3RhYmxlPlxueyNpZiBzdGF0ZT8ucGFnaW5hdGlvbj8ucGFnZXM/Lmxpc3QubGVuZ3RoID4gMX1cbiAgICA8bmF2IGNsYXNzPVwicGFnaW5hdGlvbiBpcy1jZW50ZXJlZFwiIGFyaWEtbGFiZWw9XCJwYWdpbmF0aW9uXCI+XG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XCJwYWdpbmF0aW9uLXByZXZpb3VzXCIgb25jbGljaz17Z29QcmV2fT7QndCw0LfQsNC0PC9hPlxuICAgICAgICA8YSBocmVmIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgb25jbGljaz17Z29OZXh0fT7QktC/0LXRgNC10LQ8L2E+XG4gICAgICAgIDx1bCBjbGFzcz1cInBhZ2luYXRpb24tbGlzdFwiPlxuICAgICAgICAgICAgeyNpZiBzdGF0ZS5wYWdpbmF0aW9uICYmIHN0YXRlLnBhZ2luYXRpb24ucGFnZXMgJiYgc3RhdGUucGFnaW5hdGlvbi5wYWdlcy5saXN0fVxuICAgICAgICAgICAgICAgIHsjZWFjaCBzdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QgYXMgcGFnZX1cbiAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBwYWdlLmFjdGl2ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1saW5rIGlzLWN1cnJlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwi0KHRgtGA0LDQvdC40YbQsCB7cGFnZS5pbmRleH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWN1cnJlbnQ9XCJwYWdlXCI+e3BhZ2UuaW5kZXggKyAxfTwvYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwicGFnaW5hdGlvbi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cItCh0YLRgNCw0L3QuNGG0LAge3BhZ2UuaW5kZXh9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1wYWdlPXtwYWdlLmluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtnb1RvfT57cGFnZS5pbmRleCArIDF9PC9hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3VsPlxuICAgIDwvbmF2Plxuey9pZn1cbiIsImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIndvbGZ5ODctZXZlbnRlbWl0dGVyXCI7XG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vbi5qc1wiO1xuXG5pbXBvcnQgKiBhcyBTdG9yZXMgZnJvbSBcIi4vc3RvcmVzLmpzXCI7XG5pbXBvcnQgVUlUYWJsZSBmcm9tIFwiLi9ub3RUYWJsZS5zdmVsdGVcIjtcblxuY29uc3QgQ09OU1RfSURfRFVCTElDQVRFX1BPU1RGSVggPSBcIl9fZHVibGljYXRlX19cIjtcblxuY29uc3QgT1BUX0RFRkFVTFRfUEFHRV9TSVpFID0gMjAsXG4gICAgT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVIgPSAwLFxuICAgIE9QVF9ERUZBVUxUX1BBR0VfUkFOR0UgPSA2LFxuICAgIE9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OID0gMSxcbiAgICBPUFRfREVGQVVMVF9TRUFSQ0ggPSBcIlwiLFxuICAgIE9QVF9ERUZBVUxUX1JFVFVSTiA9IHt9LFxuICAgIE9QVF9ERUZBVUxUX0NPTUJJTkVEID0gZmFsc2UsXG4gICAgT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OID0gXCJsaXN0QW5kQ291bnRcIixcbiAgICBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT04gPSBcImNvdW50XCIsXG4gICAgT1BUX0RFRkFVTFRfTElTVF9BQ1RJT04gPSBcImxpc3RcIixcbiAgICBPUFRfREVGQVVMVF9TT1JUX0ZJRUxEID0gXCJfaWRcIixcbiAgICBPUFRfRklFTERfTkFNRV9QUkVfUFJPQyA9IFwicHJlcHJvY2Vzc29yXCI7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1aTogVUlUYWJsZSxcbiAgICBsaW5rczogW10sXG4gICAgYWN0aW9uczogW10sXG4gICAgZW5kbGVzczogZmFsc2UsXG4gICAgaWRGaWVsZDogXCJfaWRcIixcbiAgICBnZXRJdGVtSWQ6IChpdGVtKSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLl9pZDtcbiAgICB9LFxufTtcblxuY2xhc3Mgbm90VGFibGUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0ID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IFwidGFibGUtXCIgKyBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX09QVElPTlMsXG4gICAgICAgICAgICAuLi4oaW5wdXQub3B0aW9ucyA/IGlucHV0Lm9wdGlvbnMgOiB7fSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgICAgIHJlZmluZWQ6IFtdLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgICAgICAgICB0bzogMCxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud29ya2luZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuc3RvcmVzID0gU3RvcmVzLmNyZWF0ZSh0aGlzLmlkLCB7XG4gICAgICAgICAgICByYXc6IFtdLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IFtdLFxuICAgICAgICAgICAgcmVmaW5lZDogW10sXG4gICAgICAgICAgICBzZWxlY3RlZDoge30sXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHdvcmtpbmc6IHRoaXMud29ya2luZyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdG9yZXMud29ya2luZy5zdWJzY3JpYmUodGhpcy5vbldvcmtpbmdVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0L/QvtC70YPRh9C10L3QvdGL0LUg0LjQtyDRgdC10YLQuFxuICAgICAgICB0aGlzLnN0b3Jlcy5yYXcuc3Vic2NyaWJlKHRoaXMub25SYXdVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0L/RgNC40LzQtdC90LXQvdGLINGE0LjQu9GM0YLRgNGLLCDRgdC+0YDRgtC40YDQvtCy0LrQuCDQuCDRgi7QtC5cbiAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQuc3Vic2NyaWJlKHRoaXMub25GaWx0ZXJlZFVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy/Rg9GA0LXQt9Cw0L3RiyDQtNC+INC80LjQvdC40LzQsNC70YzQvdC+0LPQviDQvdCw0LHQvtGA0LAsINGC0L7Rh9C90L4g0YHQvtC+0YLQstC10YHRgtCy0YPRjtGJ0LXQs9C+INGC0LDQsdC70LjRh9C90L7QvNGDINGE0L7RgNC80LDRgtGDXG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQuc3Vic2NyaWJlKHRoaXMub25SZWZpbmVkVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL9GB0LvQvtCy0LDRgNGMINGBINC40LTQtdC90YLQuNGE0LjQutCw0YLQvtGA0LDQvNC4INCy0YvQsdGA0LDQvdC90YvRhSDRgdGC0YDQvtC6XG4gICAgICAgIHRoaXMuc3RvcmVzLnNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLm9uU2VsZWN0ZWRVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vcGFnaW5hdGlvbiwgaXRlbXMgaW5mb3JtYXRpb25cbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUuc3Vic2NyaWJlKHRoaXMub25TdGF0ZVVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhpbnB1dCwgXCJkYXRhXCIpICYmIEFycmF5LmlzQXJyYXkoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLnJhdy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbCA9IGlucHV0LmRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDb21iaW5lZEFjdGlvbk5hbWUoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIixcbiAgICAgICAgICAgICAgICBPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT05cbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwiZmlsdGVyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpbHRlcih0aGlzLm9wdGlvbnMuZmlsdGVyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwicGFnZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGFnZXIodGhpcy5vcHRpb25zLnBhZ2VyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHRoaXMub3B0aW9ucywgXCJzb3J0ZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ydGVyKHRoaXMub3B0aW9ucy5zb3J0ZXIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNvcnRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwicmV0dXJuXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJldHVybih0aGlzLm9wdGlvbnMucmV0dXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5vcHRpb25zLCBcInNlYXJjaFwiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2godGhpcy5vcHRpb25zLnNlYXJjaCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvbldvcmtpbmdVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblJhd1VwZGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5kYXRhLnJhdyA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvbkZpbHRlcmVkVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRhdGEuZmlsdGVyZWQgPSB2YWw7XG4gICAgICAgIHRoaXMucmVmaW5lRmlsdGVyZWQoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblJlZmluZWRVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5yZWZpbmVkID0gdmFsO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblN0YXRlVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIG9uU2VhcmNoQ2hhbmdlKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2gobGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Tb3J0ZXJDaGFuZ2Uoc29ydGVyKSB7XG4gICAgICAgIGlmIChzb3J0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U29ydGVyKHNvcnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U29ydGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkZpbHRlckNoYW5nZSh7IGZpbHRlciwgYWN0aW9uTmFtZSB9KSB7XG4gICAgICAgIGlmIChhY3Rpb25OYW1lLmluZGV4T2YoT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb21iaW5lZEFjdGlvbk5hbWUoYWN0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU2VsZWN0ZWRVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZWxlY3RlZCA9IHZhbDtcbiAgICB9XG5cbiAgICBjbGVhclNlbGVjdGVkKCkge1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0ZWQgPSB7fTtcbiAgICB9XG5cbiAgICBnZXRTZWxlY3RlZChvYmplY3QgPSBmYWxzZSwgc3RvcmUgPSBcInJlZmluZWRcIikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMuZGF0YS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5zZWxlY3RlZFtpZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmR4ID0gdGhpcy5kYXRhW3N0b3JlXS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5faWQgPT09IGlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuZGF0YVtzdG9yZV1baW5keF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGdldEl0ZW1JZChpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJnZXRJdGVtSWRcIiwgREVGQVVMVF9PUFRJT05TLmdldEl0ZW1JZCkoaXRlbSk7XG4gICAgfVxuXG4gICAgc2VsZWN0QWxsKCkge1xuICAgICAgICB0aGlzLnN0b3Jlcy5zZWxlY3RlZC51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ge307XG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlsdGVyZWQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbHVlW3RoaXMuZ2V0SXRlbUlkKGl0ZW0pXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZWN0Tm9uZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc2VsZWN0ZWQudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0aGlzLmdldEl0ZW1JZChpdGVtKV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy51aS50YWJsZSkge1xuICAgICAgICAgICAgdGhpcy51aS50YWJsZSA9IG5ldyB0aGlzLm9wdGlvbnMudWkoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLnRhcmdldEVsLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclVJOiB0aGlzLmdldE9wdGlvbnMoXCJmaWx0ZXJVSVwiLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRIZWxwZXJzKCkpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogdGhpcy5nZXRBY3Rpb25zKCksXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzOiB0aGlzLmdldExpbmtzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlbGVjdDogdGhpcy5nZXRPcHRpb25zKFwic2hvd1NlbGVjdFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NlYXJjaDogdGhpcy5nZXRPcHRpb25zKFwic2hvd1NlYXJjaFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1NvcnQ6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dTb3J0XCIpLFxuICAgICAgICAgICAgICAgICAgICBpZEZpZWxkOiB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpLFxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtSWQ6IHRoaXMuZ2V0T3B0aW9ucyhcImdldEl0ZW1JZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmdldEZpbHRlcigpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcInNlYXJjaENoYW5nZVwiLCAoZSkgPT4gdGhpcy5vblNlYXJjaENoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcInNvcnRlckNoYW5nZVwiLCAoZSkgPT4gdGhpcy5vblNvcnRlckNoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImZpbHRlckNoYW5nZVwiLCAoZSkgPT4gdGhpcy5vbkZpbHRlckNoYW5nZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImdvVG9QYWdlXCIsIChlKSA9PiB0aGlzLmdvVG9QYWdlKGUuZGV0YWlsKSk7XG4gICAgICAgIHRoaXMudWkudGFibGUuJG9uKFwiZ29Ub05leHRQYWdlXCIsICgpID0+IHRoaXMuZ29Ub05leHQoKSk7XG4gICAgICAgIHRoaXMudWkudGFibGUuJG9uKFwiZ29Ub1ByZXZQYWdlXCIsICgpID0+IHRoaXMuZ29Ub1ByZXYoKSk7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImFjdGlvbnNcIiwgW10pO1xuICAgIH1cblxuICAgIGdldExpbmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibGlua3NcIiwgW10pO1xuICAgIH1cblxuICAgIGdldEhlbHBlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaGVscGVycyB8fCB7fTtcbiAgICB9XG5cbiAgICBzZXRXb3JraW5nKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMud29ya2luZy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgbm90UGF0aC5zZXQoa2V5LCB2YWwsIHRoaXMuZ2V0SGVscGVycygpLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0V29ya2luZyhrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLndvcmtpbmcsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFN0YXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIG5vdFBhdGguc2V0KGtleSwgdmFsLCB0aGlzLmdldEhlbHBlcnMoKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFN0YXRlKGtleSwgZGVmKSB7XG4gICAgICAgIGxldCByZXMgPSBub3RQYXRoLmdldChrZXksIHRoaXMuc3RhdGUsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldE9wdGlvbnMoa2V5LCB2YWx1ZSkge1xuICAgICAgICBub3RQYXRoLnNldChrZXksIHRoaXMub3B0aW9ucywgdGhpcy5nZXRIZWxwZXJzKCksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9ucyhrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2V0SGVscGVycygpKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEZpbHRlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImZpbHRlclwiLCBoYXNoKTtcbiAgICAgICAgaWYgKHdpdGhvdXRJbnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0RmlsdGVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwiZmlsdGVyXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZShcImZpbHRlclwiKTtcbiAgICB9XG5cbiAgICBzZXRQYWdlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInBhZ2VyXCIsIGhhc2gpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldERlZmF1bHRQYWdlTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gaXNOYU4odGhpcy5nZXRPcHRpb25zKFwicGFnZXIucGFnZVwiKSlcbiAgICAgICAgICAgID8gT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVJcbiAgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25zKFwicGFnZXIucGFnZVwiKTtcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0UGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiBpc05hTih0aGlzLmdldE9wdGlvbnMoXCJwYWdlci5zaXplXCIpKVxuICAgICAgICAgICAgPyBPUFRfREVGQVVMVF9QQUdFX1NJWkVcbiAgICAgICAgICAgIDogdGhpcy5nZXRPcHRpb25zKFwicGFnZXIuc2l6ZVwiKTtcbiAgICB9XG5cbiAgICByZXNldFBhZ2VyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXJcIiwge1xuICAgICAgICAgICAgc2l6ZTogdGhpcy5nZXREZWZhdWx0UGFnZVNpemUoKSxcbiAgICAgICAgICAgIHBhZ2U6IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0UGFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKFwicGFnZXJcIik7XG4gICAgfVxuXG4gICAgc2V0U29ydGVyKGhhc2gsIHdpdGhvdXRJbnZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzb3J0ZXJcIiwgaGFzaCk7XG4gICAgICAgIGlmICh3aXRob3V0SW52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludmFsaWRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFNvcnRlcih3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHQgPSB7fTtcbiAgICAgICAgdFtPUFRfREVGQVVMVF9TT1JUX0ZJRUxEXSA9IE9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTb3J0ZXIodCwgd2l0aG91dEludmFsaWRhdGlvbik7XG4gICAgfVxuXG4gICAgZ2V0U29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwic29ydGVyXCIpO1xuICAgIH1cblxuICAgIGdldFNvcnRlckRpcmVjdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0U29ydGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVyKClbbmFtZXNbMF1dO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBPUFRfREVGQVVMVF9TT1JUX0RJUkVDVElPTjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNlYXJjaCgpIHtcbiAgICAgICAgbGV0IHNlYXJjaCA9XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5nZXRXb3JraW5nKFwic2VhcmNoXCIpICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIikgIT09IG51bGw7XG4gICAgICAgIHJldHVybiBzZWFyY2ggPyB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIikgOiBcIlwiO1xuICAgIH1cblxuICAgIHNldFNlYXJjaChsaW5lID0gT1BUX0RFRkFVTFRfU0VBUkNILCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwic2VhcmNoXCIsIGxpbmUpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicmV0dXJuXCIpO1xuICAgIH1cblxuICAgIHNldFJldHVybihyZXQgPSBPUFRfREVGQVVMVF9SRVRVUk4pIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicmV0dXJuXCIsIHJldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyRmlsdGVyZWREYXRhKCkge1xuICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyUmF3RGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMucmF3LnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXJSZWZpbmVkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMucmVmaW5lZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGludmFsaWRhdGVEYXRhKCkge1xuICAgICAgICAvL2NsZWFyaW5nIGZpbHRlcmVkIGFuZCBzb3J0ZWRcbiAgICAgICAgdGhpcy5jbGVhckZpbHRlcmVkRGF0YSgpO1xuICAgICAgICAvL2luIGNhc2UgbGl2ZSBsb2FkaW5nIGZyb20gc2VydmVyXG4gICAgICAgIGlmICh0aGlzLmlzTGl2ZSgpKSB7XG4gICAgICAgICAgICAvL2NsZWFyaW5nIGxvYWRlZCBkYXRhXG4gICAgICAgICAgICB0aGlzLmNsZWFyUmF3RGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVzc2V0IHBhZ2VyIGFueXdheVxuICAgICAgICB0aGlzLnJlc2V0UGFnZXIoKTtcbiAgICB9XG5cbiAgICBpc0xpdmUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2VcIikgJiYgdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmZhY3RvcnlcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzZXRVcGRhdGluZygpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInVwZGF0aW5nXCIsIHRydWUpO1xuICAgIH1cblxuICAgIHNldFVwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJ1cGRhdGluZ1wiLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWZVcGRhdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoXCJ1cGRhdGluZ1wiKTtcbiAgICB9XG5cbiAgICBnZXREYXRhSW50ZXJmYWNlKCkge1xuICAgICAgICBsZXQgZmFjdG9yeSA9IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5mYWN0b3J5XCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnkoe30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRMb2FkRGF0YUFjdGlvbk5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UubGlzdEFjdGlvblwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UubGlzdEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9MSVNUX0FDVElPTjtcbiAgICB9XG5cbiAgICBzZXRDb21iaW5lZEFjdGlvbk5hbWUoYWN0aW9uTmFtZSA9IE9QVF9ERUZBVUxUX0NPVU5UX0FDVElPTikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIiwgYWN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgZ2V0Q29tYmluZWRBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwiaW50ZXJmYWNlLmNvbWJpbmVkQWN0aW9uXCIpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZS5jb21iaW5lZEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT047XG4gICAgfVxuXG4gICAgZ2V0Q291bnRBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvdW50QWN0aW9uXCIpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5jb3VudEFjdGlvblwiKVxuICAgICAgICAgICAgOiBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT047XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKSB7XG4gICAgICAgIC8vbG9hZCBmcm9tIHNlcnZlclxuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmdldERhdGFJbnRlcmZhY2UoKVxuICAgICAgICAgICAgICAgIC5zZXRGaWx0ZXIodGhpcy5nZXRGaWx0ZXIoKSlcbiAgICAgICAgICAgICAgICAuc2V0U29ydGVyKHRoaXMuZ2V0U29ydGVyKCkpXG4gICAgICAgICAgICAgICAgLnNldFJldHVybih0aGlzLmdldFJldHVybigpKVxuICAgICAgICAgICAgICAgIC5zZXRTZWFyY2godGhpcy5nZXRTZWFyY2goKSlcbiAgICAgICAgICAgICAgICAuc2V0UGFnZXIodGhpcy5nZXRQYWdlcigpKSxcbiAgICAgICAgICAgIGFjdGlvbk5hbWU7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UuY29tYmluZWRcIiwgT1BUX0RFRkFVTFRfQ09NQklORUQpKSB7XG4gICAgICAgICAgICBhY3Rpb25OYW1lID0gdGhpcy5nZXRDb21iaW5lZEFjdGlvbk5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbk5hbWUgPSB0aGlzLmdldExvYWREYXRhQWN0aW9uTmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeVtcIiRcIiArIGFjdGlvbk5hbWVdKCk7XG4gICAgfVxuXG4gICAgZ29Ub05leHQoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gaXNOYU4odGhpcy5nZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIikpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKVxuICAgICAgICAgICAgOiB0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSArIDE7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICBcInBhZ2VyLnBhZ2VcIixcbiAgICAgICAgICAgIE1hdGgubWluKG5leHQsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLnRvXCIpKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICB9XG5cbiAgICBnb1RvUHJldigpIHtcbiAgICAgICAgbGV0IHByZXYgPSBpc05hTih0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSlcbiAgICAgICAgICAgID8gdGhpcy5nZXREZWZhdWx0UGFnZU51bWJlcigpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0U3RhdGUoXCJwYWdlci5wYWdlXCIpIC0gMTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgIFwicGFnZXIucGFnZVwiLFxuICAgICAgICAgICAgTWF0aC5tYXgocHJldiwgdGhpcy5nZXRTdGF0ZShcInBhZ2luYXRpb24ucGFnZXMuZnJvbVwiKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub0ZpcnN0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCB0aGlzLmdldFN0YXRlKFwicGFnaW5hdGlvbi5wYWdlcy5mcm9tXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub0xhc3QoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJwYWdlci5wYWdlXCIsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLnRvXCIpKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub1BhZ2UocGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCBwYWdlTnVtYmVyKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgdGVzdERhdGFJdGVtKGl0ZW0pIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gdGhpcy5nZXRTZWFyY2goKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKHZhciBrIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciB0b0NvbXAgPSBpdGVtW2tdLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0b0NvbXAuaW5kZXhPZihzdHJWYWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRSb3dzQ291bnQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZ2V0RGF0YUludGVyZmFjZSgpLnNldEZpbHRlcih0aGlzLmdldEZpbHRlcigpKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5W1wiJFwiICsgdGhpcy5nZXRDb3VudEFjdGlvbk5hbWUoKV0oKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oZGF0YS5jb3VudCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZVBhZ2luYXRpb24oaXRlbXNDb3VudCkge1xuICAgICAgICB0aGlzLmxvZyhcInVwZGF0ZSBwYWdpbmF0aW9uXCIsIGl0ZW1zQ291bnQpO1xuICAgICAgICB0aGlzLnN0YXRlLnBhZ2luYXRpb24ucGFnZXMubGlzdC5zcGxpY2UoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIGxldCBpdGVtc0Zyb20gPVxuICAgICAgICAgICAgICAgICh0aGlzLmdldFBhZ2VyKCkucGFnZSAtIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSKSAqXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5zaXplICtcbiAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgcGFnZXNDb3VudCA9XG4gICAgICAgICAgICAgICAgaXRlbXNDb3VudCAlIHRoaXMuZ2V0UGFnZXIoKS5zaXplXG4gICAgICAgICAgICAgICAgICAgID8gTWF0aC5mbG9vcihpdGVtc0NvdW50IC8gdGhpcy5nZXRQYWdlcigpLnNpemUpICsgMVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgucm91bmQoaXRlbXNDb3VudCAvIHRoaXMuZ2V0UGFnZXIoKS5zaXplKSxcbiAgICAgICAgICAgIHBhZ2VzRnJvbSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5wYWdlIC0gT1BUX0RFRkFVTFRfUEFHRV9SQU5HRVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHBhZ2VzVG8gPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBwYWdlc0NvdW50IC0gKDEgLSBPUFRfREVGQVVMVF9QQUdFX05VTUJFUiksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRQYWdlcigpLnBhZ2UgKyBPUFRfREVGQVVMVF9QQUdFX1JBTkdFXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICAgICAgaXRlbXNUbyA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIGl0ZW1zRnJvbSArIHRoaXMuZ2V0UGFnZXIoKS5zaXplIC0gMSxcbiAgICAgICAgICAgICAgICBpdGVtc0NvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCB0ID0gcGFnZXNGcm9tOyB0IDw9IHBhZ2VzVG87IHQrKykge1xuICAgICAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogdCxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IHQgPT09IHRoaXMuZ2V0UGFnZXIoKS5wYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3Jlcy5zdGF0ZS51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ1cGRhdGUgcGFnaW5hdGlvblwiLCB2YWwpO1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24uaXRlbXMuY291bnQgPSBpdGVtc0NvdW50O1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24uaXRlbXMuZnJvbSA9IGl0ZW1zRnJvbTtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLml0ZW1zLnRvID0gaXRlbXNUbztcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmNvdW50ID0gcGFnZXNDb3VudDtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmZyb20gPSBwYWdlc0Zyb207XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy50byA9IHBhZ2VzVG87XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5jdXJyZW50ID0gdGhpcy5nZXRQYWdlcigpLnBhZ2U7XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5saXN0LnNwbGljZShcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLnBhZ2VzLmxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgICAgIC4uLmxpc3RcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVEYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWZVcGRhdGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldE9wdGlvbnMoXCJlbmRsZXNzXCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJSYXdEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFVwZGF0aW5nKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvbWJpbmVkXCIsIE9QVF9ERUZBVUxUX0NPTUJJTkVEKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ1bGwgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgXCJzdGF0dXNcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGRhdGEsIFwicmVzdWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0T3B0aW9ucyhcImVuZGxlc3NcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGaWx0ZXJlZERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnB1c2goLi4uZGF0YS5yZXN1bHQubGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhkYXRhLCBcImxpc3RcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS5saXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEubGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnB1c2goLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGFzdENvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbCA/IGRhdGEucmVzdWx0LmNvdW50IDogZGF0YS5jb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uKHRoaXMuZ2V0V29ya2luZyhcImxhc3RDb3VudFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aGlzLmVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0VXBkYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5nZXRSb3dzQ291bnQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHRoaXMuZXJyb3IuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odGhpcy5zZXRVcGRhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9sb2NhbCBtYWdpY1xuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGluZygpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIHByb2Nlc3NEYXRhKCkge1xuICAgICAgICBsZXQgdGhhdEZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyKCk7XG4gICAgICAgIC8vdGhpcy5nZXREYXRhKCdyb3dzJykuX19zZXRQYXNzaXZlO1xuICAgICAgICB0aGlzLmxvZyh0aGlzLmdldERhdGEoKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGF0RmlsdGVyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhhdEZpbHRlci5maWx0ZXJTZWFyY2ggIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHRoYXRGaWx0ZXIuZmlsdGVyU2VhcmNoICE9PSBudWxsICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyLmZpbHRlclNlYXJjaC5sZW5ndGggPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICB2YWwubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmRhdGEucmF3LmZpbHRlcih0aGlzLnRlc3REYXRhSXRlbS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgsIC4uLnRoaXMuZGF0YS5yYXcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLy8vc29ydGVyXG4gICAgICAgIGxldCB0aGF0U29ydGVyID0gdGhpcy5nZXRTb3J0ZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGF0U29ydGVyICE9PSBcInVuZGVmaW5lZFwiICYmIHRoYXRTb3J0ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdDEgPSBub3RQYXRoLmdldCh0aGF0U29ydGVyLnNvcnRCeUZpZWxkLCBpdGVtMSwge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBub3RQYXRoLmdldCh0aGF0U29ydGVyLnNvcnRCeUZpZWxkLCBpdGVtMiwge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4odDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHQxICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHQyICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEubG9jYWxlQ29tcGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEubG9jYWxlQ29tcGFyZSgpICogLXRoYXRTb3J0ZXIuc29ydERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0MSA8IHQyID8gMSA6IC0xKSAqIHRoYXRTb3J0ZXIuc29ydERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvZ2dlci5lcnJvciguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxvZ2dlci5sb2coLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrRmllbGRzTmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpO1xuICAgICAgICBjb25zdCBwYXRoSWQgPSBcIjpcIiArIGZpZWxkSWQ7XG4gICAgICAgIGxldCBmaWVsZHMgPSB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwgW10pO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXRoSWQgPT09IGZpZWxkLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5wYXRoID0gZmllbGQucGF0aCArIENPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWFkRmllbGRWYWx1ZShwYXRoLCBpdGVtLCBoZWxwZXJzKSB7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoQ09OU1RfSURfRFVCTElDQVRFX1BPU1RGSVgpID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSWQgPSB0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpO1xuICAgICAgICAgICAgY29uc3QgcGF0aElkID0gXCI6XCIgKyBmaWVsZElkO1xuICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KHBhdGhJZCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90UGF0aC5nZXQocGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWZpbmVGaWx0ZXJlZCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmNoZWNrRmllbGRzTmFtZXMoKTtcbiAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImlkRmllbGRcIikpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW3RoaXMuZ2V0T3B0aW9ucyhcImlkRmllbGRcIildID1cbiAgICAgICAgICAgICAgICAgICAgaXRlbVt0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiLCBbXSkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlcHJvY2Vzc2VkID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkRmllbGRWYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwiaGVscGVyc1wiKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKGZpZWxkLCBPUFRfRklFTERfTkFNRV9QUkVfUFJPQykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXByb2Nlc3NlZCA9IGZpZWxkW09QVF9GSUVMRF9OQU1FX1BSRV9QUk9DXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVycm9yIHdoaWxlIHByZXByb2Nlc3NpbmcgY2VsbCB2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub3RQYXRoLnNldChmaWVsZC5wYXRoLCByZWZpbmVkLCBwcmVwcm9jZXNzZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdFBhdGguc2V0KGZpZWxkLnBhdGgsIHJlZmluZWQsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5zcGxpY2UoMCwgdmFsLmxlbmd0aCwgLi4ucmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMudWkpIHtcbiAgICAgICAgICAgIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3kgJiYgdGhpcy51aVtuYW1lXS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudWlbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFRhYmxlO1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMb2FkZXIgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkubG9hZGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbnRhaW5lciBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvbGF5b3V0L3VpLmNvbnRhaW5lci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOb3RpZmljYXRpb25FcnJvciBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLmVycm9yLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5vdGlmaWNhdGlvblN1Y2Nlc3MgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5zdWNjZXNzLnN2ZWx0ZVwiO1xuXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuXG4gICAgbGV0IHN1Y2Nlc3MgPSAkc3RhdGUoZmFsc2UpO1xuXG4gICAgbGV0IGVycm9yID0gJHN0YXRlKGZhbHNlKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY29udGFpbmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGVyQWN0aXZlXSAtIHN0YXRlIGlmIGZvcm0gbG9hZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyU2l6ZV0gLSBwYWdlIC0gd2hvbGUgcGFnZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VjY2Vzc1RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3VjY2Vzc01lc3NhZ2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvclRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JNZXNzYWdlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjb250YWluZXIgPSB7fSxcbiAgICAgICAgbG9hZGVyVGl0bGUgPSAkYmluZGFibGUoXCLQntGC0L/RgNCw0LLQutCwINC00LDQvdC90YvRhSDQvdCwINGB0LXRgNCy0LXRgFwiKSxcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbG9hZGVyU2l6ZSA9ICRiaW5kYWJsZShcImNvbnRhaW5lclwiKSxcbiAgICAgICAgc3VjY2Vzc1RpdGxlID0gJGJpbmRhYmxlKFwiT0tcIiksXG4gICAgICAgIHN1Y2Nlc3NNZXNzYWdlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBlcnJvclRpdGxlID0gJGJpbmRhYmxlKFwiRXJyb3JcIiksXG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2hvd1N1Y2Nlc3ModGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChtZXNzYWdlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3VjY2Vzc01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NUaXRsZSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dFcnJvcih0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yVGl0bGUgPSB0aXRsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRMb2FkaW5nKCkge1xuICAgICAgICBsb2FkZXJBY3RpdmUgPSB0cnVlO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGhpZGVBbGwoKSB7XG4gICAgICAgIGxvYWRlckFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSUxvYWRlclxuICAgIGJpbmQ6bG9hZGluZz17bG9hZGVyQWN0aXZlfVxuICAgIGJpbmQ6dGl0bGU9e2xvYWRlclRpdGxlfVxuICAgIGJpbmQ6c2l6ZT17bG9hZGVyU2l6ZX1cbi8+XG48VUlDb250YWluZXIgey4uLmNvbnRhaW5lcn0+XG4gICAgeyNpZiBlcnJvcn1cbiAgICAgICAgPFVJTm90aWZpY2F0aW9uRXJyb3JcbiAgICAgICAgICAgIGJpbmQ6dGl0bGU9e2Vycm9yVGl0bGV9XG4gICAgICAgICAgICBiaW5kOm1lc3NhZ2U9e2Vycm9yTWVzc2FnZX1cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuICAgIHsjaWYgc3VjY2Vzc31cbiAgICAgICAgPFVJTm90aWZpY2F0aW9uU3VjY2Vzc1xuICAgICAgICAgICAgYmluZDp0aXRsZT17c3VjY2Vzc1RpdGxlfVxuICAgICAgICAgICAgYmluZDptZXNzYWdlPXtzdWNjZXNzTWVzc2FnZX1cbiAgICAgICAgLz5cbiAgICB7L2lmfVxuPC9VSUNvbnRhaW5lcj5cbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuLi8uLi9iYXNlXCI7XG5cbmltcG9ydCBVSUFjdGlvbkNvbnRhaW5lciBmcm9tIFwiLi91aS5hY3Rpb24uY29udGFpbmVyLnN2ZWx0ZVwiO1xuY29uc3QgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIi5jb250YWluZXJcIjtcbmltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vY29uc3RcIjtcblxuY2xhc3Mgbm90QWN0aW9uVUkgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvL1VJIHJlbmRlcmVyIGNvbXBvbmVudCBjbGFzcyBjb25zdHJ1Y3RvclxuICAgICN1aUNvbXBvbmVudCA9IG51bGw7XG4gICAgI3VpID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgICAgbmFtZSA9IFwiRGVmYXVsdFwiLFxuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIHdvcmtpbmcgPSB7fSxcbiAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICB1aSA9IFVJQWN0aW9uQ29udGFpbmVyLCAvL2RlZmF1bHQgVUlcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtuYW1lfUFjdGlvblVJYCxcbiAgICAgICAgICAgICAgICAuLi53b3JraW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdWlDb21wb25lbnQgPSB1aTtcbiAgICAgICAgdGhpcy5pbml0VUkoKTtcbiAgICB9XG5cbiAgICBpbml0VUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFRhcmdldEVsKCk7XG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0LmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQodGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy4jdWkgPSBuZXcgdGhpcy4jdWlDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wczogdGhpcy5nZXRPcHRpb25zKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMuI3VpLnNldExvYWRpbmcoKTtcbiAgICB9XG5cbiAgICByZXNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRlZFwiKTtcbiAgICAgICAgdGhpcy4jdWkucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI3VpKSB7XG4gICAgICAgICAgICB0aGlzLiN1aS4kZGVzdHJveSAmJiB0aGlzLiN1aS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jdWkuZGVzdHJveSAmJiB0aGlzLiN1aS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiN1aSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG51bGwpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YShudWxsKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gREVGQVVMVF9TVEFUVVNfU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtU3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1FcnJvcnMocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgRm9ybSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAqKi9cbiAgICBzZXRGb3JtU3VjY2VzcygpIHtcbiAgICAgICAgdGhpcy4jdWkuc2hvd1N1Y2Nlc3MoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtRXJyb3JzKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBmb3JtOiBbXSxcbiAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgc3RhdHVzLmZvcm0ucHVzaChyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiYgT2JqZWN0LmtleXMocmVzdWx0LmVycm9ycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdHVzLmZpZWxkcyA9IHsgLi4ucmVzdWx0LmVycm9ycyB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VpLnNob3dFcnJvcihzdGF0dXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIC8qKipcbiAgICAgKiBSZWRlZmluYWJsZSBnZXR0ZXJzXG4gICAgICoqL1xuICAgIGdldFRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuZ2V0T3B0aW9ucyhcInRhcmdldFwiLCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUik7XG4gICAgICAgIGlmICh0YXJnZXRFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0RWw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldEVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRFbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY3Rpb25VSSBwYXJlbnQgZWxlbWVudCBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QWN0aW9uVUk7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb25cIjtcblxuaW1wb3J0IHsgRklFTERTLCBDT01QT05FTlRTLCBWQVJJQU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcblxuY2xhc3Mgbm90Rm9ybVV0aWxzIHtcbiAgICBzdGF0aWMgdmFsaWRhdG9yID0gbnVsbDtcblxuICAgIHN0YXRpYyBhZGRDb21wb25lbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgQ09NUE9ORU5UUy5hZGQobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRWYXJpYW50cyhuYW1lLCB2YWx1ZSkge1xuICAgICAgICBWQVJJQU5UUy5hZGQobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhZGRGaWVsZChuYW1lLCBmaWVsZCkge1xuICAgICAgICBGSUVMRFMuYWRkKG5hbWUsIGZpZWxkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWN0aW9uRmllbGRzSW5pdChmaWVsZE5hbWUsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZmllbGROYW1lLmZvckVhY2goKHN1YkZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uRmllbGRzSW5pdChzdWJGaWVsZE5hbWUsIG9wdGlvbnMsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5vdENvbW1vbi5vYmpIYXMob3B0aW9ucywgXCJmaWVsZHNcIikpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub3RDb21tb24ub2JqSGFzKG9wdGlvbnMuZmllbGRzLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZHNbZmllbGROYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb3B5aW5nIGluaXRpYWwgZGF0YVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgZGF0YSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhW2ZpZWxkTmFtZV0gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gIT09IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzW2ZpZWxkTmFtZV0udmFsdWUgPSBkYXRhW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEZvcm1VdGlscztcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG5jb25zdCBERUZBVUxUX0ZJRUxEID0ge1xuICAgIGxhYmVsOiBcIlwiLFxuICAgIHBsYWNlaG9sZGVyOiBcIlwiLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgdmlzaWJsZTogdHJ1ZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB2YWxpZGF0ZWQ6IGZhbHNlLFxuICAgIHZhbGlkOiBmYWxzZSxcbiAgICBlcnJvcnM6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGZpZWxkIG1hbmlmZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAgICAgIG5hbWUvdHlwZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBtdXRhdGlvbiAgbXV0YXRpb24gdG8gbWFuaWZlc3QgZnJvbSBsaWJyYXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gVkFSSUFOVFMgIHN0b3JlIHdoaWNoIGNvbnRhaW5zIG5hbWVkIGxpc3RzIG9mIGZpZWxkIHZhbHVlIHZhcmlhbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gRklFTERTICAgIHN0b3JlIHdoaWNoIGNvbnRhaW5zIG5hbWVkIGxpc3RzIG9mIGZpZWxkIG1hbmlmZXN0c1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBmaWVsZCBtYW5pZmVzdFxuICoqL1xuZnVuY3Rpb24gZmllbGRJbml0KHR5cGUsIG11dGF0aW9uID0ge30sIFZBUklBTlRTLCBGSUVMRFMpIHtcbiAgICBsZXQgZmllbGQgPSB7IC4uLkRFRkFVTFRfRklFTEQgfTtcbiAgICAvL2dldHRpbmcgZmllbGQgY29yZSBtYW5pZmVzdFxuICAgIGlmIChGSUVMRFMuY29udGFpbnModHlwZSkpIHtcbiAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIC4uLkZJRUxEUy5nZXQodHlwZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYWRkaW5nIG11dGF0aW9uc1xuICAgIGlmIChtdXRhdGlvbikge1xuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgLi4ubXV0YXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vYWRkaW5nIHZhcmlhbnRzIGxpc3QgdG8gZmllbGQgZnJvbSBWQVJJQU5UUyBzdG9yZVxuICAgIGlmIChcbiAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmaWVsZCwgXCJ2YXJpYW50c1NvdXJjZVwiKSAmJlxuICAgICAgICBWQVJJQU5UUy5jb250YWlucyhmaWVsZC52YXJpYW50c1NvdXJjZSlcbiAgICApIHtcbiAgICAgICAgZmllbGQudmFyaWFudHMgPSBWQVJJQU5UUy5nZXQoZmllbGQudmFyaWFudHNTb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmllbGQudmFyaWFudHMgfHwgZmllbGQudmFyaWFudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC52YXJpYW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBvZiBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkIHR5cGUgaWYgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzID0gc3ViZm9ybVxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgVkFSSUFOVFMgICAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCB2YWx1ZSB2YXJpYW50c1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICAgICAgRklFTERTICAgICAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCBtYW5pZmVzdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zICAgZm9ybSB3aWRlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBpbml0Rm9ybUJ5RmllbGQoXG4gICAgZm9ybSA9IHt9LFxuICAgIGZpZWxkTmFtZSA9IFtdLFxuICAgIFZBUklBTlRTLFxuICAgIEZJRUxEUyxcbiAgICBmb3JtRmllbGRzT3B0aW9ucyxcbiAgICBkYXRhXG4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZE5hbWUpKSB7XG4gICAgICAgIGZpZWxkTmFtZS5mb3JFYWNoKChzdWJGb3JtRmllbGROYW1lKSA9PlxuICAgICAgICAgICAgaW5pdEZvcm1CeUZpZWxkKFxuICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgc3ViRm9ybUZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBWQVJJQU5UUyxcbiAgICAgICAgICAgICAgICBGSUVMRFMsXG4gICAgICAgICAgICAgICAgZm9ybUZpZWxkc09wdGlvbnMsXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBvcHRzID0ge307XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zICYmXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGZvcm1GaWVsZHNPcHRpb25zLCBcIm11dGF0aW9uc1wiKSAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmb3JtRmllbGRzT3B0aW9ucy5tdXRhdGlvbnMsIGZpZWxkTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRzID0gZm9ybUZpZWxkc09wdGlvbnMubXV0YXRpb25zW2ZpZWxkTmFtZV07IC8vb3B0aW9uIG11dGF0aW9uIGZvciBmaWVsZFxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICYmIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgb3B0cy52YWx1ZSA9IGRhdGFbZmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBmb3JtW2ZpZWxkTmFtZV0gPSBmaWVsZEluaXQoZmllbGROYW1lLCBvcHRzLCBWQVJJQU5UUywgRklFTERTKTtcbiAgICAgICAgLy9pZiBmb3JtIHJlYWRvbmx5LCBtYXJraW5nIGV2ZXJ5IGZpZWxkIGFzIHJlYWRvbmx5XG4gICAgICAgIGlmIChmb3JtRmllbGRzT3B0aW9ucyAmJiBmb3JtRmllbGRzT3B0aW9ucy5yZWFkb25seSkge1xuICAgICAgICAgICAgZm9ybVtmaWVsZE5hbWVdLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiAgTWFya2luZyBmaWVsZCBhcyBpbnZhbGlkIGJ5IG93biB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgZmllbGROYW1lICAgICBuYW1lIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIHthbnl9ICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgIHZhbHVlIG9mIGZpZWxkXG4gKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgIGVycm9ycyAgICAgICAgbGlzdCBvZiBlcnJvcnNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpIHtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzID0gWy4uLmVycm9yc107XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGZvcm07XG59XG5cbi8qKlxuICogIE1hcmtpbmcgZmllbGQgYXMgdmFsaWQgYnkgb3duIHZhbGlkYXRvclxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcGFyYW0ge2FueX0gICAgICAgICAgICAgIHZhbHVlICAgICAgICAgdmFsdWUgb2YgZmllbGRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSkge1xuICAgIGZvcm1bZmllbGROYW1lXS5lcnJvcnMgPSBmYWxzZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsaWRhdGVkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsaWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgZm9yIChsZXQgZm5hbWUgaW4gZm9ybSkge1xuICAgICAgICBpZiAoZm5hbWUgIT09IGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZm9ybVtmbmFtZV0uZXJyb3JzKSAmJlxuICAgICAgICAgICAgICAgIGZvcm1bZm5hbWVdLmVycm9ycy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZvcm1bZm5hbWVdLmVycm9ycyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1bZm5hbWVdLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgZmllbGQgaGFzIGVycm9yc1xuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAtIHZhbGlkLCBmYWxzZSAtaW52YWxpZFxuICoqL1xuZnVuY3Rpb24gaXNGaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzKTtcbn1cblxuLyoqXG4gKiBGb3JtIGxldmVsIHZhbGlkYXRvciBlcnJvciBpbiB0aGlzIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSAge0FycmF5PHN0cmluZz59ICAgZXJyb3JzICAgICAgICBsaXN0IG9mIGVycm9yc1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICoqL1xuZnVuY3Rpb24gc2V0Rm9ybUZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIGVycm9ycykge1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtRXJyb3JzID0gWy4uLmVycm9yc107XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmlucHV0U3RhcnRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmZvcm1MZXZlbEVycm9yID0gdHJ1ZTtcbiAgICByZXR1cm4gZm9ybTtcbn1cbi8qKlxuICogRm9ybSBsZXZlbCB2YWxpZGF0b3Igc3VjY2VzcyBpbiB0aGlzIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSkge1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtRXJyb3JzID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZm9ybUxldmVsRXJyb3IgPSBmYWxzZTtcbiAgICByZXR1cm4gZm9ybTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIGZpZWxkcyBhbmQgZm9ybSBlcnJvciBsYWJlbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzICAgICAgcmVzdWx0cyBvZiB2YWxpZGF0aW9uXG4gKiovXG5mdW5jdGlvbiB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyhcbiAgICB7XG4gICAgICAgIGZvcm0sXG4gICAgICAgIGZvcm1FcnJvcnMsXG4gICAgICAgIHZhbGlkYXRpb25TdGF0dXMsXG4gICAgfSAvKiBGb3JtVmFsaWRhdGlvblNlc3Npb24uZ2V0Q29tcGxldGVSZXN1bHQoKSAqL1xuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5mb3JtKSAmJiB2YWxpZGF0aW9uU3RhdHVzLmZvcm0ubGVuZ3RoKSB7XG4gICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoLCAuLi52YWxpZGF0aW9uU3RhdHVzLmZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRpb25TdGF0dXMuZmllbGRzKSB7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXSkgJiZcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUZpZWxkSW52YWxpZChcbiAgICAgICAgICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9ybUZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0RmllbGRzVmlzaWJpbGl0eShmb3JtLCBmaWVsZHNMaXN0LCB2YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHNMaXN0KSkge1xuICAgICAgICBPYmplY3Qua2V5cyhmb3JtKS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGZvcm1bZmllbGROYW1lXS52aXNpYmxlID0gZmllbGRzTGlzdC5pbmNsdWRlcyhmaWVsZE5hbWUpXG4gICAgICAgICAgICAgICAgPyB2YWxcbiAgICAgICAgICAgICAgICA6ICF2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXRGaWVsZFZhbHVlKGZvcm0sIGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobm90Q29tbW9uLm9iakhhcyhmb3JtLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaWVsZElzVmlzaWJsZUFuZEZpbGxlZChmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBub3RDb21tb24ub2JqSGFzKGZvcm0sIGZpZWxkTmFtZSkgJiZcbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdLmVuYWJsZWQgJiZcbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdLnZpc2libGUgJiZcbiAgICAgICAgdHlwZW9mIGZvcm1bZmllbGROYW1lXS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3REYXRhKGZpZWxkcywgZm9ybSkge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmaWVsZHMuZmxhdCgpLmZvckVhY2goKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICBpZiAoZmllbGRJc1Zpc2libGVBbmRGaWxsZWQoZm9ybSwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBmb3JtW2ZpZWxkTmFtZV0udmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZmllbGRJbml0LFxuICAgIGluaXRGb3JtQnlGaWVsZCxcbiAgICBzZXRGaWVsZEludmFsaWQsXG4gICAgc2V0RmllbGRWYWxpZCxcbiAgICBpc0ZpZWxkVmFsaWQsXG4gICAgc2V0Rm9ybUZpZWxkSW52YWxpZCxcbiAgICBzZXRGb3JtRmllbGRWYWxpZCxcbiAgICB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyxcbiAgICBmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCxcbiAgICBzZXRGaWVsZHNWaXNpYmlsaXR5LFxuICAgIHNldEZpZWxkVmFsdWUsXG4gICAgY29sbGVjdERhdGEsXG59O1xuIiwiY29uc3QgZW1wdHlGaWVsZHNSZXN1bHRzID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSkucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgYWNjW2N1cnJdID0gW107XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcblxuY29uc3QgRklFTERTID0gW1wiZmllbGRzXCIsIFwiZm9ybVwiXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICAjY2xlYW4gPSB0cnVlO1xuICAgICNyZXN1bHQ7XG5cbiAgICBjb25zdHJ1Y3RvcihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy4jcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy4jcmVzdWx0KS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghRklFTERTLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4jcmVzdWx0W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjbGVhbiA9IHRoaXMuI3Jlc3VsdC5mb3JtLmVycm9ycy5sZW5ndGggPT09IDA7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNnZXRGaWVsZHNMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZpZWxkRGlydHkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiNyZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0IGNsZWFuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2xlYW47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldERlZmF1bHRSZXN1bHQoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRzOiBlbXB0eUZpZWxkc1Jlc3VsdHMoZGF0YSksXG4gICAgICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBlbXB0eUZpZWxkc1Jlc3VsdHMoZGF0YSksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0UmVwb3J0KCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLiNnZXRDb21wbGV0ZVJlc3VsdCgpKSk7XG4gICAgfVxuXG4gICAgZ2V0RGV0YWlsZWRSZXBvcnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLiNyZXN1bHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0ZpZWxkRGlydHkoZmllbGROYW1lKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKSAmJlxuICAgICAgICAgICAgdGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICB0aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXS5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Q29tcGxldGVSZXN1bHRGb3JGaWVsZChmaWVsZE5hbWUpIHtcbiAgICAgICAgY29uc3QgZmllbGRSZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgZmllbGRSZXN1bHQucHVzaCguLi50aGlzLiNyZXN1bHQuZmllbGRzW2ZpZWxkTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgZmllbGRSZXN1bHQucHVzaCguLi50aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkUmVzdWx0O1xuICAgIH1cblxuICAgICNnZXRDb21wbGV0ZVJlc3VsdCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0Q29tcGxldGUgPSB7XG4gICAgICAgICAgICBjbGVhbjogdGhpcy4jY2xlYW4sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICAgICAgZm9ybTogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLiNnZXRGaWVsZHNMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmdldENvbXBsZXRlUmVzdWx0Rm9yRmllbGQoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q29tcGxldGUuZmllbGRzW2ZpZWxkTmFtZV0gPSBlcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Q29tcGxldGUuZm9ybSA9IFsuLi50aGlzLiNyZXN1bHQuZm9ybS5lcnJvcnNdO1xuICAgICAgICBpZiAocmVzdWx0Q29tcGxldGUuZm9ybS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRDb21wbGV0ZS5mb3JtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRDb21wbGV0ZTtcbiAgICB9XG5cbiAgICAjZ2V0RmllbGRzTGlzdCgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXModGhpcy4jcmVzdWx0LmZpZWxkcyk7XG4gICAgICAgIGNvbnN0IGZpZWxkc0luRm9ybSA9IE9iamVjdC5rZXlzKHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkcyk7XG4gICAgICAgIHJldHVybiBbLi4ubmV3IFNldChbLi4uZmllbGRzSW5Gb3JtLCAuLi5maWVsZHNdKV07XG4gICAgfVxufTtcbiIsIi8qKlxuKlx0VGVtcGxhdGUgb2YgZXJyb3IuanNcbipcdEZvciBidWlsZGluZyBmb3Igc3BlY2lmaWMgZW52aXJvbm1lbnQuXG4qXHROb2RlLmpzIG9yIEJyb3dzZXJcbipcdEBwYXJhbSB7c3RyaW5nfVx0ZW52XHRub2RlfGJyb3dzZXIgaW4gd2ljaCBlbnYgaXQgd2lsbCBiZSBydW5uaW5nXG4qXHRAcGFyYW0ge3N0cmluZ31cdHVybFx0VVJMIG9mIHJlcG9ydCBjb2xsZWN0b3JcbipcdEBwYXJhbSB7c3RyaW5nfVx0a2V5XHRrZXkgdG8gaW5kZXRpZmljYXRlIHJlcG9ydGVyXG4qL1xuLyoqXG4qIEVycm9yIHJlcG9ydGluZyB3aXRoIGZlYXR1cmVzLCBzYXZpbmcgYnJvd3NlciBpbmZvLCB1cmkgYW5kIHNvIG9uLlxuKiBAbW9kdWxlIG5vdC1lcnJvci9lcnJvclxuKi9cbmNsYXNzIG5vdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zID0ge30sIGVycm9yID0gbnVsbCl7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmFkb3B0KGVycm9yKTtcblx0XHR0aGlzLmZpbGwoKTtcblx0XHR0aGlzLmdldFRpbWUoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQqXHRBZG9wdGluZyBuYXRpdmUgZXJyb3Igb2JqZWN0XG5cdCpcdEBwYXJhbSB7RXJyb3J9XHRlcnJvciBcdEVycm9yIG9iamVjdFxuXHQqXHRAcmV0dXJuIHtub3RFcnJvcn1cdFx0Y2hhaW5hYmxlXG5cdCovXG5cdGFkb3B0KGVycm9yKXtcblx0XHRpZihlcnJvciBpbnN0YW5jZW9mIEVycm9yKXtcblx0XHRcdHRoaXMucGFyZW50ID0gZXJyb3I7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Z2V0U3RhY2soKXtcblx0XHRpZih0aGlzLnBhcmVudCl7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuc3RhY2s7XG5cdFx0fWVsc2V7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFjaztcblx0XHR9XG5cdH1cblxuXHRnZXREZXRhaWxzKCl7XG5cdFx0bGV0IHNyYyA9IHRoaXM7XG5cdFx0aWYodGhpcy5wYXJlbnQpe1xuXHRcdFx0c3JjID0gdGhpcy5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRjb2x1bW5OdW1iZXI6ICAgIFx0c3JjLmNvbHVtbk51bWJlcixcblx0XHRcdGZpbGVOYW1lOiAgICAgICAgXHRzcmMuZmlsZU5hbWUsXG5cdFx0XHRsaW5lTnVtYmVyOiAgICAgIFx0c3JjLmxpbmVOdW1iZXIsXG5cdFx0XHRuYW1lOiAgICAgICAgICAgIFx0c3JjLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiAgICAgICAgXHRzcmMubWVzc2FnZSxcblx0XHRcdHN0YWNrOiAgICAgICAgICBcdHNyYy5zdGFja1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0Klx0VXBkYXRpbmcgdGhpcy5lbnYuZGF0ZSBwcm9wZXJ0eVxuXHQqXHRAcmV0dXJuICB7b2JqZWN0fVx0e3RpbWVzdGFtcCwgb2Zmc2V0fVxuXHQqL1xuXHRnZXRUaW1lKCl7XG5cdFx0bGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdHRoaXMuZW52LmRhdGUgPSB7XG5cdFx0XHR0aW1lc3RhbXAgOiBkYXRlLmdldFRpbWUoKSxcblx0XHRcdG9mZnNldDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcy5lbnYuZGF0ZTtcblx0fVxuXG5cblx0LyoqXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KioqXHROb2RlLmpzIFNlY3Rpb25cblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKi9cblxuXHQvKipcblx0Klx0RmlsdGVyaW5nIG91dCBrZXkgYnkgYHdoaXRlYCBsaXN0XG5cdCpcdEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgaGFzaCB0byBiZSBjb3BpZWQgYWNjb3JkaW5nIGZpbHRlciBgd2hpdGVgIGxpc3Rcblx0Klx0QHBhcmFtIHthcnJheX0gZmlsdGVyIGFycmF5IG9mIHN0aW5nLCB3aGljaCByZXByZXNlbnRzIGtleXMgd2Ugd2FudCB0byBiZVxuXHQqXHRcdFx0XHRcdFx0Y29waWVkIGluIHJlc3VsdGluZyBvYmplY3QgZnJvbSBzb3VyY2Vcblx0Klx0QHJldHVybiB7b2JqZWN0fVx0XHR3aGl0ZSBsaXN0ZWQgaGFzaFxuXHQqL1xuXHRmaWx0ZXJFbnYob2JqZWN0LCBmaWx0ZXIpe1xuXHRcdGxldCByZXN1bHQgPSB7fTtcblx0XHRmb3IobGV0IHQgb2YgZmlsdGVyKXtcblx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHQpKXtcblx0XHRcdFx0cmVzdWx0W3RdID0gb2JqZWN0W3RdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCpcdENvbGxlY3RpbmcgaW5mb3JtYXRpb24gc3BlY2lmaWMgZm9yIE5vZGUuanMgVjhcblx0Klx0QHJldHVybiB7bm90RXJyb3J9XHRcdGNoYWluYWJsZVxuXHQqL1xuXHRmaWxsKCl7XG5cdFx0LyoqXG5cdFx0Klx0WW91IHdhbnQgc29tZSBmaWVsZHMgZnJvbSBlbnYgYnV0IG5vdCBhbGwsIGNhdXNlIHRoZXJlIGFyZSBwYXNzd29yZHNcblx0XHQqXHRmcm9tIGRiLCBhcGkga2V5cyBhbmQgZXRjXG5cdFx0Ki9cblx0XHR0aGlzLmVudiA9IHtcblx0XHRcdGJyb3dzZXI6IFx0ZmFsc2UsXG5cdFx0XHRub2RlOiBcdFx0dHJ1ZSxcblx0XHRcdHZlcnNpb25zOiBPYmplY3QuYXNzaWduKHt9LCBwcm9jZXNzLnZlcnNpb25zKSxcblx0XHRcdHZhcnM6IFx0XHR0aGlzLmZpbHRlckVudihwcm9jZXNzLmVudiwgdGhpcy5vcHRpb25zLndoaXRlbGlzdCB8fCBbJ05PREVfRU5WJ10pXG5cdFx0fTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdEVycm9yO1xuXG4iLCJcbmNvbnN0IG5vdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci5ub2RlLmNqcycpO1xuXG5cbi8vcmVwb3J0YWJsZVxuY2xhc3Mgbm90VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgbm90RXJyb3J7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpZWxkcyA9IHt9LCBlcnIgPSBudWxsLCBwYXJhbXMgPSB7fSl7XG4gICAgc3VwZXIobWVzc2FnZSwge2ZpZWxkcywgcGFyYW1zfSwgZXJyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAqIFNldHMgaGFzaCBvZiBmaWVsZHMgZXJyb3JzIG1lc3NhZ2VzIGZvciB1c2FnZSBpbiBmb3Jtc1xuICAqXHRAcmV0dXJuIHtPYmplY3R9XHRoYXNoIG9mIGZpZWxkLT5lcnJvcnMgW2tleTpzdHJpbmddOiBBcnJheTxzdHJpbmc+XG4gICoqL1xuICBzZXRGaWVsZHNFcnJvcnMobWVzc2FnZXMpe1xuICAgIHRoaXMub3B0aW9ucy5maWVsZHMgPSBtZXNzYWdlcztcbiAgfVxuXG4gIC8qKlxuICAqIFJldHVybnMgaGFzaCBvZiBlcnJvcnNcbiAgKlx0QHJldHVybiB7T2JqZWN0fVx0aGFzaCBvZiBmaWVsZC0+ZXJyb3JzIFtrZXk6c3RyaW5nXTogQXJyYXk8c3RyaW5nPlxuICAqKi9cbiAgZ2V0RmllbGRzRXJyb3JzKCl7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maWVsZHM7XG4gIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gbm90VmFsaWRhdGlvbkVycm9yO1xuXG4iLCIvKipcbiAqIFRlc3QgYXJndW1lbnQgdHlwZSB0byBiZSAnZnVuY3Rpb24nXG4gKiBAcGFyYW0ge2FueX0gIGZ1bmMgICAgcG9zc2libGUgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICBpZiB0aGlzIGlzIGEgZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGlzRnVuYyA9IChmdW5jKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhcmd1bWVudCBpcyBBc3luYyBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgaWYgdGhpcyBmdW5jdGlvbiBpcyBjb25zdHJ1Y3RlZCBhcyBBc3luY0Z1bmN0aW9uXG4gKiovXG5jb25zdCBpc0FzeW5jID0gKGZ1bmMpID0+IHtcbiAgICByZXR1cm4gZnVuYy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFzeW5jRnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHByb2MsIHBhcmFtcykgPT4ge1xuICAgIGlmIChpc0Z1bmMocHJvYykpIHtcbiAgICAgICAgaWYgKGlzQXN5bmMocHJvYykpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jKC4uLnBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvYyguLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsImNvbnN0IFZhbGlkYXRpb25SZXN1bHQgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5jb25zdCBub3RWYWlsZGF0aW9uRXJyb3IgPSByZXF1aXJlKFwibm90LWVycm9yL3NyYy92YWxpZGF0aW9uLmVycm9yLm5vZGUuY2pzXCIpO1xuY29uc3QgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG5jb25zdCBWYWxpZGF0aW9uU2Vzc2lvbiA9IGFzeW5jICh2YWxpZGF0b3JzLCBkYXRhKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gVmFsaWRhdGlvblJlc3VsdC5nZXREZWZhdWx0UmVzdWx0KGRhdGEpO1xuICAgIGF3YWl0IHZhbGlkYXRlRmllbGRzKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pO1xuICAgIGF3YWl0IHZhbGlkYXRlRm9ybSh7IHZhbGlkYXRvcnMsIGRhdGEsIHJlc3VsdCB9KTtcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRpb25SZXN1bHQocmVzdWx0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblNlc3Npb247XG5cbmNvbnN0IHZhbGlkYXRlRmllbGRzID0gYXN5bmMgKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pID0+IHtcbiAgICBmb3IgKGxldCB0IGluIGRhdGEpIHtcbiAgICAgICAgYXdhaXQgdmFsaWRhdGVGaWVsZCh0LCBkYXRhW3RdLCB2YWxpZGF0b3JzLCByZXN1bHQpO1xuICAgIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGROYW1lLCB2YWx1ZSwgdmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgY29uc3QgZmllbGRWYWxpZGF0b3JzID0gZ2V0RmllbGRWYWxpZGF0b3JzKGZpZWxkTmFtZSwgdmFsaWRhdG9ycyk7XG4gICAgcmV0dXJuIGF3YWl0IHJ1bkZpZWxkVmFsaWRhdG9ycyhmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFZhbGlkYXRvcnMsIHJlc3VsdCk7XG59O1xuXG5jb25zdCBnZXRGaWVsZFZhbGlkYXRvcnMgPSAobmFtZSwgdmFsaWRhdG9ycykgPT4ge1xuICAgIHJldHVybiB2YWxpZGF0b3JzICYmIHZhbGlkYXRvcnMuZmllbGRzICYmIHZhbGlkYXRvcnMuZmllbGRzW25hbWVdXG4gICAgICAgID8gdmFsaWRhdG9ycy5maWVsZHNbbmFtZV1cbiAgICAgICAgOiBbXTtcbn07XG5cbmNvbnN0IHJ1bkZpZWxkVmFsaWRhdG9ycyA9IGFzeW5jIChmaWVsZE5hbWUsIHZhbHVlLCB2YWxpZGF0b3JzLCByZXN1bHQpID0+IHtcbiAgICBmb3IgKGxldCB2YWxpZGF0b3JSdWxlIG9mIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gYXdhaXQgZXhlY3V0ZU9iamVjdEZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvclJ1bGVbXCJ2YWxpZGF0b3JcIl0sXG4gICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzZXRGaWVsZEVycm9yKGZpZWxkTmFtZSwgdmFsaWRhdG9yUnVsZS5tZXNzYWdlLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIG5vdFZhaWxkYXRpb25FcnJvciB8fCAhdmFsaWRhdG9yUnVsZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIHZhbGlkYXRvclJ1bGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHNldEZpZWxkRXJyb3IgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZUZvcm0gPSBhc3luYyAoeyB2YWxpZGF0b3JzLCBkYXRhLCByZXN1bHQgfSkgPT4ge1xuICAgIGNvbnN0IGZvcm1WYWxpZGF0b3JzID0gZ2V0Rm9ybVZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgYXdhaXQgcnVuRm9ybVZhbGlkYXRvcnMoZGF0YSwgZm9ybVZhbGlkYXRvcnMsIHJlc3VsdCk7XG59O1xuXG5jb25zdCBnZXRGb3JtVmFsaWRhdG9ycyA9ICh2YWxpZGF0b3JzKSA9PiB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnMgJiYgdmFsaWRhdG9ycy5mb3JtID8gdmFsaWRhdG9ycy5mb3JtIDogW107XG59O1xuXG5jb25zdCBydW5Gb3JtVmFsaWRhdG9ycyA9IGFzeW5jIChkYXRhLCBmb3JtVmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgdmFsaWRhdG9yIG9mIGZvcm1WYWxpZGF0b3JzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB2YWxpZGF0b3IoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmIHR5cGVvZiBlLmdldEZpZWxkc0Vycm9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IGUuZ2V0RmllbGRzRXJyb3JzKCk7XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShmb3JtRXJyb3JzLmZvcm0pICYmXG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1FcnJvcnMoZm9ybUVycm9ycy5mb3JtLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMuZmllbGRzICYmXG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1GaWVsZHNFcnJvcnMoZm9ybUVycm9ycy5maWVsZHMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRXJyb3JzID0gKGVycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgZXJyb3JzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFkZEZvcm1FcnJvcihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGFkZEZvcm1FcnJvciA9IChlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghcmVzdWx0LmZvcm0uZXJyb3JzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRzRXJyb3JzID0gKGZpZWxkc0Vycm9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgZmllbGROYW1lIGluIGZpZWxkc0Vycm9ycykge1xuICAgICAgICBhZGRGb3JtRmllbGRFcnJvcnMoZmllbGROYW1lLCBmaWVsZHNFcnJvcnNbZmllbGROYW1lXSwgcmVzdWx0KTtcbiAgICB9XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRFcnJvcnMgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2VzLCByZXN1bHQpID0+IHtcbiAgICBlcnJvck1lc3NhZ2VzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFkZEZvcm1GaWVsZEVycm9yKGZpZWxkTmFtZSwgZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBhZGRGb3JtRmllbGRFcnJvciA9IChmaWVsZE5hbWUsIGVycm9yTWVzc2FnZSwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICByZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdLmluY2x1ZGVzKGVycm9yTWVzc2FnZSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0ucHVzaChlcnJvck1lc3NhZ2UpO1xuICAgIH1cbn07XG4iLCJjb25zdCBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyA9IChkYXRhLCB2YWxpZGF0b3JzTGliKSA9PiB7XG4gICAgaWYgKHZhbGlkYXRvcnNMaWIgJiYgdmFsaWRhdG9yc0xpYi5maWVsZHMpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRvcnNMaWIuZmllbGRzW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSB2YWxpZGF0b3JzTGliLmZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcblxuY29uc3QgY29tcG9zZUZvcm1WYWxpZGF0b3JzID0gKG5hbWUsIHZhbGlkYXRvcnNMaWIpID0+IHtcbiAgICBpZiAoIXZhbGlkYXRvcnNMaWIpIHJldHVybiBbXTtcbiAgICBpZiAodmFsaWRhdG9yc0xpYi5mb3JtcyAmJiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnNMaWIuZm9ybXNbbmFtZV0pKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzTGliLmZvcm1zW25hbWVdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzTGliLmZvcm0pKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzTGliLmZvcm07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbXBvc2VGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGNvbXBvc2VGb3JtVmFsaWRhdG9ycyxcbn07XG4iLCJjb25zdCB7XG4gICAgY29tcG9zZUZpZWxkc1ZhbGlkYXRvcnMsXG4gICAgY29tcG9zZUZvcm1WYWxpZGF0b3JzLFxufSA9IHJlcXVpcmUoXCIuL3J1bm5lci51dGlscy5qc1wiKTtcblxuY29uc3QgVmFsaWRhdGlvblNlc3Npb24gPSByZXF1aXJlKFwiLi9zZXNzaW9uLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgdmFsaWRhdGlvbiBydW5uZXIgZnVuY3Rpb24gZnJvbSBwcm92aWRlZCB2YWxpZGF0aW9uIHJ1bGVzIGxpYlxuICogQHBhcmFtIHtvYmplY3R9ICAgICB2YWxpZGF0aW9uTGliIG9iamVjdCBjb250YWluaW5nIGZpZWxkcyB2YWxpZGF0aW9uIHJ1bGVzIGFuZCBmb3JtIHNwZWNpZmljIHJ1bGVzXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IChkYXRhOiBvYmplY3QsIGZvcm1OYW1lOiBzdHJpbmcpPT5Qcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+XG4gKiovXG5jb25zdCBWYWxpZGF0aW9uUnVubmVyID0gKHZhbGlkYXRvcnNMaWIpID0+IHtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0aW9uIHNlc3Npb24gcnVubmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgICAgICBvYmplY3QgdG8gdmFsaWRhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybU5hbWVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiovXG4gICAgcmV0dXJuIChkYXRhLCBmb3JtTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0ge1xuICAgICAgICAgICAgLy9maWVsZHMgc3BlY2lmaWMgdmFsaWRhdG9yc1xuICAgICAgICAgICAgZmllbGRzOiBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyhkYXRhLCB2YWxpZGF0b3JzTGliKSxcbiAgICAgICAgICAgIC8vZm9ybSBzcGVjaWZpYyB2YWxpZGF0b3JzXG4gICAgICAgICAgICBmb3JtOiBjb21wb3NlRm9ybVZhbGlkYXRvcnMoZm9ybU5hbWUsIHZhbGlkYXRvcnNMaWIpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblNlc3Npb24odmFsaWRhdG9ycywgZGF0YSk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblJ1bm5lcjtcbiIsImNvbnN0IGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzID0gKGZpZWxkVmFsaWRhdG9ycywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuIGZpZWxkVmFsaWRhdG9ycy5tYXAoKGZpZWxkUnVsZSkgPT5cbiAgICAgICAgYXVnbWVudEZpZWxkVmFsaWRhdG9yKGZpZWxkUnVsZSwgZ2V0VmFsaWRhdG9yRW52KVxuICAgICk7XG59O1xuXG5jb25zdCBhdWdtZW50RmllbGRWYWxpZGF0b3IgPSAocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgaWYgKHJ1bGUudmFsaWRhdG9yICYmIHR5cGVvZiBydWxlLnZhbGlkYXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVWYWxpZGF0b3IgPSBydWxlLnZhbGlkYXRvcjtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgLi4ucnVsZSxcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC52YWxpZGF0b3I7XG4gICAgICAgIHJlc3VsdC52YWxpZGF0b3IgPSAodmFsKSA9PiBydWxlVmFsaWRhdG9yKHZhbCwgZ2V0VmFsaWRhdG9yRW52KCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmNvbnN0IGF1Z21lbnRGb3JtVmFsaWRhdG9ycyA9IChydWxlcywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuIHJ1bGVzLm1hcCgocnVsZSkgPT4gYXVnbWVudEZvcm1WYWxpZGF0b3IocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSk7XG59O1xuXG5jb25zdCBhdWdtZW50Rm9ybVZhbGlkYXRvciA9IChydWxlLCBnZXRWYWxpZGF0b3JFbnYpID0+IHtcbiAgICByZXR1cm4gKHZhbCkgPT4gcnVsZSh2YWwsIGdldFZhbGlkYXRvckVudigpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGF1Z21lbnRGaWVsZFZhbGlkYXRvcixcbiAgICBhdWdtZW50Rm9ybVZhbGlkYXRvcnMsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3IsXG59O1xuIiwiY29uc3Qgb2JqSGFzID0gKG9iaiwgbmFtZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBuYW1lKTtcbn07XG5jb25zdCB7XG4gICAgYXVnbWVudEZpZWxkc1ZhbGlkYXRvcnMsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3JzLFxufSA9IHJlcXVpcmUoXCIuL2J1aWxkZXIudXRpbHNcIik7XG5cbi8qKlxuICogQHR5cGVkZWYgICB7b2JqZWN0fSAgICBub3RWYWxpZGF0aW9uU2NoZW1hXG4gKiBAcHJvcGVydHkgIHtvYmplY3R9ICAgIFtmaWVsZHNdXG4gKiBAcHJvcGVydHkgIHthcnJheX0gICAgIFtmb3JtXVxuICogQHByb3BlcnR5ICB7b2JqZWN0fSAgICBbZm9ybXNdXG4gKi9cblxuLyoqXG4gKiByZXR1cm5zIHZhbGlkIGVtcHR5IHZhbGlkYXRpb24gc2NoZW1lXG4gKlxuICogQHJldHVybiB7bm90VmFsaWRhdGlvblNjaGVtYX1cbiAqL1xuY29uc3QgZW1wdHlTY2hlbWUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgZm9ybXM6IHt9LFxuICAgIH07XG59O1xuLyoqXG4gKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWxpZGF0b3JzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRWYWxpZGF0b3JFbnZcbiAqIEByZXR1cm4ge25vdFZhbGlkYXRpb25TY2hlbWF9XG4gKi9cbmNvbnN0IHZhbGlkYXRpb25CdWlsZGVyID0gKHZhbGlkYXRvcnMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9ycyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB2YWxpZGF0b3JzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlbXB0eVNjaGVtZSgpO1xuICAgIH1cbiAgICBjb25zdCBhdWdtZW50ZWQgPSB7fTtcbiAgICBpZiAob2JqSGFzKHZhbGlkYXRvcnMsIFwiZmllbGRzXCIpKSB7XG4gICAgICAgIGF1Z21lbnRlZC5maWVsZHMgPSB0cmFuc2Zvcm1GaWVsZHNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgdmFsaWRhdG9ycy5maWVsZHMsXG4gICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9iakhhcyh2YWxpZGF0b3JzLCBcImZvcm1zXCIpKSB7XG4gICAgICAgIGF1Z21lbnRlZC5mb3JtcyA9IHRyYW5zZm9ybUZvcm1zVmFsaWRhdG9ycyhcbiAgICAgICAgICAgIHZhbGlkYXRvcnMuZm9ybXMsXG4gICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2JqSGFzKHZhbGlkYXRvcnMsIFwiZm9ybVwiKSkge1xuICAgICAgICAgICAgYXVnbWVudGVkLmZvcm0gPSBhdWdtZW50Rm9ybVZhbGlkYXRvcnMoXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5mb3JtLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0aW9uQnVpbGRlcjtcblxuY29uc3QgdHJhbnNmb3JtRmllbGRzVmFsaWRhdG9ycyA9IChmaWVsZHMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGNvbnN0IGF1Z21lbnRlZCA9IHt9O1xuICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICBhdWdtZW50ZWRbZmllbGROYW1lXSA9IGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcblxuY29uc3QgdHJhbnNmb3JtRm9ybXNWYWxpZGF0b3JzID0gKGZvcm1zVmFsaWRhdG9ycywgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgY29uc3QgYXVnbWVudGVkID0ge307XG4gICAgZm9yIChsZXQgZm9ybU5hbWUgaW4gZm9ybXNWYWxpZGF0b3JzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1zVmFsaWRhdG9yc1tmb3JtTmFtZV0pKSB7XG4gICAgICAgICAgICBhdWdtZW50ZWRbZm9ybU5hbWVdID0gYXVnbWVudEZvcm1WYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIGZvcm1zVmFsaWRhdG9yc1tmb3JtTmFtZV0sXG4gICAgICAgICAgICAgICAgZ2V0VmFsaWRhdG9yRW52XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdWdtZW50ZWQ7XG59O1xuIiwiY29uc3QgU2Vzc2lvbiA9IHJlcXVpcmUoXCIuL3Nlc3Npb25cIik7XG5jb25zdCBSdW5uZXIgPSByZXF1aXJlKFwiLi9ydW5uZXJcIik7XG5jb25zdCBCdWlsZGVyID0gcmVxdWlyZShcIi4vYnVpbGRlclwiKTtcbmNvbnN0IFJlc3VsdCA9IHJlcXVpcmUoXCIuL3Jlc3VsdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbmFtZTogXCJub3QtdmFsaWRhdGlvblwiLFxuICAgIFNlc3Npb24sXG4gICAgUnVubmVyLFxuICAgIEJ1aWxkZXIsXG4gICAgUmVzdWx0LFxufTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2lucHV0L3VpLmxhYmVsLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xhYmVsXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWFkb25seV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtob3Jpem9udGFsXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbY29udHJvbHNdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uLy4uLy4uL2VsZW1lbnRzL2V2ZW50cy50eXBlcycpLlVJRXZlbnRJbnB1dENoYW5nZUNhbGxiYWNrfSBvbmNoYW5nZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3Nlc10gLSBmaWVsZCBzdHlsZSBtb2RpZmljYXRpb25cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNdIC0gLy9hZGRvbnNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNDZW50ZXJlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthZGRvbnNSaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cGVkXSAtIC8vZ3JvdXAgZmxhZ1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRNdWx0aWxpbmVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXBlZFJpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRDZW50ZXJlZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgbGFiZWwgPSBcIlwiLFxuICAgICAgICBuYW1lID0gXCJnZW5lcmljIGZpZWxkXCIsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGhvcml6b250YWwgPSBmYWxzZSxcbiAgICAgICAgY29udHJvbHMgPSBbXSxcbiAgICAgICAgY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGFkZG9ucyA9IGZhbHNlLFxuICAgICAgICBhZGRvbnNDZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICBhZGRvbnNSaWdodCA9IGZhbHNlLFxuICAgICAgICBncm91cGVkID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRNdWx0aWxpbmUgPSBmYWxzZSxcbiAgICAgICAgZ3JvdXBlZFJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRDZW50ZXJlZCA9IGZhbHNlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIGZvcm1GaWVsZFByZWZpeCA9IFwiZm9ybS1maWVsZC1cIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgZmllbGRDbGFzc2VzID0gJHN0YXRlKFwiXCIpO1xuICAgIGxldCBoaWRkZW4gPSAkc3RhdGUoZmFsc2UpO1xuICAgIGxldCBmaWVsZElkID0gJHN0YXRlKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IFwiIFwiICsgY2xhc3NlcztcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9ucyA/IFwiIGhhcy1hZGRvbnMgXCIgOiBcIlwiO1xuICAgICAgICBmaWVsZENsYXNzZXMgKz0gYWRkb25zQ2VudGVyZWQgPyBcIiBoYXMtYWRkb25zLWNlbnRlcmVkIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9uc1JpZ2h0ID8gXCIgaGFzLWFkZG9ucy1yaWdodCBcIiA6IFwiXCI7XG5cbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWQgPyBcIiBpcy1ncm91cGVkIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWRNdWx0aWxpbmUgPyBcIiBpcy1ncm91cGVkLW11bHRpbGluZSBcIiA6IFwiXCI7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBncm91cGVkUmlnaHQgPyBcIiBpcy1ncm91cGVkLXJpZ2h0IFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGdyb3VwZWRDZW50ZXJlZCA/IFwiIGlzLWdyb3VwZWQtY2VudGVyZWQgXCIgOiBcIlwiO1xuXG4gICAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICAgICAgY29udHJvbHMuZm9yRWFjaCgoY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm90SGlkZGVuID0gY29udHJvbHMuZmlsdGVyKFxuICAgICAgICAgICAgKGNvbnRyb2wpID0+IGNvbnRyb2wuY29tcG9uZW50ICE9PSBcIlVJSGlkZGVuXCJcbiAgICAgICAgKTtcbiAgICAgICAgaGlkZGVuID0gbm90SGlkZGVuLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgbGV0IHRtcCA9IGNvbnRyb2xzLm1hcCgoaXRtKSA9PiBpdG0uY29tcG9uZW50KS5qb2luKFwiX1wiKTtcbiAgICAgICAgZmllbGRJZCA9IGAke2Zvcm1GaWVsZFByZWZpeH0ke3RtcH0tJHtuYW1lfWA7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBoaWRkZW59XG4gICAgeyNlYWNoIGNvbnRyb2xzIGFzIGNvbnRyb2x9XG4gICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoY29udHJvbC5jb21wb25lbnQpfVxuICAgICAgICA8U3ZlbHRlQ29tcG9uZW50IHsuLi5jb250cm9sfSB7b25jaGFuZ2V9IGZpZWxkbmFtZT17bmFtZX0gLz5cbiAgICB7L2VhY2h9XG57OmVsc2UgaWYgaG9yaXpvbnRhbH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtaG9yaXpvbnRhbCB7ZmllbGRDbGFzc2VzfSB7ZmllbGRJZH1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkLWxhYmVsIGlzLW5vcm1hbFwiPlxuICAgICAgICAgICAgPFVJTGFiZWwgZm9yPXtmaWVsZElkfSBsYWJlbD17bGFiZWwgfHwgY29udHJvbHNbMF0ubGFiZWx9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQtYm9keVwiIGlkPXtmaWVsZElkfT5cbiAgICAgICAgICAgIHsjZWFjaCBjb250cm9scyBhcyBjb250cm9sfVxuICAgICAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50XzEgPSBDT01QT05FTlRTLmdldChjb250cm9sLmNvbXBvbmVudCl9XG4gICAgICAgICAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudF8xIHsuLi5jb250cm9sfSB7b25jaGFuZ2V9IGZpZWxkbmFtZT17bmFtZX0gLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG57OmVsc2V9XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkIHtmaWVsZENsYXNzZXN9IHtmaWVsZElkfVwiPlxuICAgICAgICB7I2VhY2ggY29udHJvbHMgYXMgY29udHJvbH1cbiAgICAgICAgICAgIDxVSUxhYmVsXG4gICAgICAgICAgICAgICAgZm9yPVwiZm9ybS1maWVsZC17Y29udHJvbC5jb21wb25lbnR9LXtuYW1lfVwiXG4gICAgICAgICAgICAgICAgbGFiZWw9e2NvbnRyb2wubGFiZWx9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnRfMiA9IENPTVBPTkVOVFMuZ2V0KGNvbnRyb2wuY29tcG9uZW50KX1cbiAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnRfMiB7Li4uY29udHJvbH0ge29uY2hhbmdlfSBmaWVsZG5hbWU9e25hbWV9IC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXBhZ2Vsb2FkZXJcIjtcbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgbGV0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vbG9jYWxlXCI7XG5cbiAgICBpbXBvcnQgVUlGaWVsZCBmcm9tIFwiLi9maWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgRm9ybUhlbHBlcnMgZnJvbSBcIi4vZm9ybS5oZWxwZXJzLmpzXCI7XG5cbiAgICAvL3ZhbGlkYXRpb24gc3RhdHVzXG4gICAgbGV0IGZvcm1FcnJvcnMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBmb3JtSGFzRXJyb3JzID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgZmllbGRzSGFzRXJyb3JzID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgc3VjY2VzcyA9ICRzdGF0ZShmYWxzZSk7XG5cbiAgICAvL2lucHV0IGRhdGFcbiAgICAvL2Zvcm0gc3RydWN0dXJlIG9iamVjdFxuXG4gICAgLy9oaWRkZW4gLSBubyBsb2FkZXJcbiAgICAvL2NvbnRhaW5lciAtIHBhcmVudCBjb250YWluZXIgb2YgZm9ybVxuXG4gICAgLy9maWVsZHMgbGlzdCBzdHJ1Y3R1cmVcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtmb3JtXSAtIHtcbltmaWVsZE5hbWU6IHN0cmluZ10gPT4gZGVzY3JpcHRpb246IG9iamVjdFxufVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddIC0gc3RhdGUgaWYgZm9ybSBsb2FkaW5nXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsb2FkZXJdIC0gcGFnZSAtIHdob2xlIHBhZ2VcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ZpZWxkc10gLSBlYWNoIGl0ZW0gaXMgYSByb3dcbmlmIGl0ZW0gaXMgYXJyYXksIHRoZW4gdGhlcmUgZmV3IGZpZWxkcyBpbiBhIHJvd1xuW1xuW25hbWUsIGFnZV0sXG5bZW1haWwsIHRlbGVwaG9uZV1cbmJpbyxcbmFncmVlZFxuXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbU1VDQ0VTU19URVhUXSAtIGZvcm0gcmVzdWx0IGxhYmVsc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbV0FJVElOR19URVhUXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdIC0gZm9ybSBsYWJlbHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1dHRvbnNGaXJzdF0gLSBpZiB5b3Ugd2FudCBidXR0b24gb24gdG9wXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaG9yaXpvbnRhbF0gLSBpZiBmb3JtIGZpZWxkcyBzaG91bGQgaGF2ZSBob3Jpem9udGFsIGxheW91dFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc3VibWl0XSAtIGJ1dHRvbnMgbGFiZWxzIGFuZCBhdmFpbGFiaWxpdHlcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2NhbmNlbF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZm9ybSA9ICRiaW5kYWJsZSh7fSksXG4gICAgICAgIGxvYWRpbmcgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBsb2FkZXIgPSBcImNvbnRhaW5lclwiLFxuICAgICAgICBmaWVsZHMgPSBbXSxcbiAgICAgICAgU1VDQ0VTU19URVhUID0gXCLQntC/0LXRgNCw0YbQuNGPINC30LDQstC10YDRiNC10L3QsFwiLFxuICAgICAgICBXQUlUSU5HX1RFWFQgPSBcItCe0YLQv9GA0LDQstC60LAg0LTQsNC90L3Ri9GFINC90LAg0YHQtdGA0LLQtdGAXCIsXG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb24gPSBcIlwiLFxuICAgICAgICBidXR0b25zRmlyc3QgPSBmYWxzZSxcbiAgICAgICAgaG9yaXpvbnRhbCA9IGZhbHNlLFxuICAgICAgICBzdWJtaXQgPSB7XG4gICAgICAgICAgICBjYXB0aW9uOiBcItCe0YLQv9GA0LDQstC40YLRjFwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsID0ge1xuICAgICAgICAgICAgY2FwdGlvbjogXCLQndCw0LfQsNC0XCIsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBmb3JtSW52YWxpZCA9ICRkZXJpdmVkKGZvcm1IYXNFcnJvcnMgfHwgZmllbGRzSGFzRXJyb3JzKTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1IZWxwZXJzLmNvbGxlY3REYXRhKGZpZWxkcywgZm9ybSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEZpZWxkSW52YWxpZChmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIHZhbHVlLCBlcnJvcnMpO1xuICAgICAgICBmaWVsZHNIYXNFcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZFZhbGlkKGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRmllbGRWYWxpZChmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1IZWxwZXJzLmlzRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGb3JtRmllbGRJbnZhbGlkKGZpZWxkTmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIGZvcm0gPSBGb3JtSGVscGVycy5zZXRGb3JtRmllbGRJbnZhbGlkKGZvcm0sIGZpZWxkTmFtZSwgZXJyb3JzKTtcbiAgICAgICAgZGlzcGF0Y2goYGZpZWxkLmludmFsaWRgLCB7XG4gICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGb3JtRmllbGRWYWxpZChmaWVsZE5hbWUpIHtcbiAgICAgICAgZm9ybSA9IEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgIGRpc3BhdGNoKGBmaWVsZC52YWxpZGAsIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKFxuICAgICAgICB2YWxpZGF0aW9uU3RhdHVzIC8qIEZvcm1WYWxpZGF0aW9uU2Vzc2lvbi5nZXRDb21wbGV0ZVJlc3VsdCgpICovXG4gICAgKSB7XG4gICAgICAgIGZvcm1IYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgZmllbGRzSGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvblN0YXR1cy5mb3JtKSAmJlxuICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5mb3JtLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZvcm1FcnJvcnMuc3BsaWNlKDAsIGZvcm1FcnJvcnMubGVuZ3RoLCAuLi52YWxpZGF0aW9uU3RhdHVzLmZvcm0pO1xuICAgICAgICAgICAgZm9ybUhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtRXJyb3JzLnNwbGljZSgwLCBmb3JtRXJyb3JzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybUVycm9ycyA9IGZvcm1FcnJvcnM7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICAgICAgZm9yIChsZXQgZmllbGROYW1lIG9mIE9iamVjdC5rZXlzKGZvcm0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZEludmFsaWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHNIYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEZvcm1IZWxwZXJzLnNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dTdWNjZXNzKCkge1xuICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNWaXNpYmlsaXR5KGZpZWxkc0xpc3QsIHZhbCkge1xuICAgICAgICBpZiAoRm9ybUhlbHBlcnMuc2V0RmllbGRzVmlzaWJpbGl0eShmb3JtLCBmaWVsZHNMaXN0LCB2YWwpKSB7XG4gICAgICAgICAgICBmb3JtID0gZm9ybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRWaXNpYmxlRmllbGRzKGZpZWxkc0xpc3QpIHtcbiAgICAgICAgc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCB0cnVlKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0SW52aXNpYmxlRmllbGRzKGZpZWxkc0xpc3QpIHtcbiAgICAgICAgc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEZpZWxkVmFsdWUoZmllbGROYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoRm9ybUhlbHBlcnMuc2V0RmllbGRWYWx1ZShmb3JtLCBmaWVsZE5hbWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgb25GaWVsZENoYW5nZSh7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGaWVsZChmaWVsZE5hbWUsIHByb3BzKSB7XG4gICAgICAgIGZvcm1bZmllbGROYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLmZvcm1bZmllbGROYW1lXSxcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtID0gZm9ybTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkZpZWxkQ2hhbmdlKGV2KSB7XG4gICAgICAgIGxldCBkYXRhID0gZXYuZGV0YWlsO1xuICAgICAgICBmb3JtW2RhdGEuZmllbGRdLnZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICAgICAgZm9ybSA9IGZvcm07XG4gICAgICAgIGRpc3BhdGNoKFwiY2hhbmdlXCIsIGRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1Ym1pdEZvcm0oZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2goXCJzdWJtaXRcIiwgY29sbGVjdERhdGEoKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3RGb3JtKCkge1xuICAgICAgICBkaXNwYXRjaChcInJlamVjdFwiKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImZvcm0tY29udGFpbmVyXCI+XG4gICAgeyNpZiBsb2FkZXIgIT09IFwiaGlkZGVuXCJ9XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwie2xvYWRlciA9PT0gJ3BhZ2UnXG4gICAgICAgICAgICAgICAgPyAncGFnZWxvYWRlcidcbiAgICAgICAgICAgICAgICA6ICdjb250YWluZXJsb2FkZXInfSB7bG9hZGluZyA/ICdpcy1hY3RpdmUnIDogJyd9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPnskTE9DQUxFW1dBSVRJTkdfVEVYVF19PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBzdWNjZXNzfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibm90aWZpY2F0aW9uIGlzLXN1Y2Nlc3NcIj5cbiAgICAgICAgICAgIDxoMyBjbGFzcz1cImZvcm0tc3VjY2Vzcy1tZXNzYWdlXCI+eyRMT0NBTEVbU1VDQ0VTU19URVhUXX08L2gzPlxuICAgICAgICA8L2Rpdj5cbiAgICB7OmVsc2V9XG4gICAgICAgIHsjaWYgdGl0bGV9XG4gICAgICAgICAgICA8aDUgY2xhc3M9XCJ0aXRsZSBpcy01XCI+eyRMT0NBTEVbdGl0bGVdfTwvaDU+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgZGVzY3JpcHRpb259XG4gICAgICAgICAgICA8aDYgY2xhc3M9XCJzdWJ0aXRsZSBpcy02XCI+eyRMT0NBTEVbZGVzY3JpcHRpb25dfTwvaDY+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgYnV0dG9uc0ZpcnN0fVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaXMtZ3JvdXBlZCBpcy1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgIHsjaWYgY2FuY2VsLmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIGlzLW91dGxpbmVkIHtjYW5jZWwuY2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17cmVqZWN0Rm9ybX0+eyRMT0NBTEVbY2FuY2VsLmNhcHRpb25dfTwvYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsjaWYgc3VibWl0LmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3N1Ym1pdEZvcm19XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Zm9ybUludmFsaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1wcmltYXJ5IGlzLWhvdmVyZWQge3N1Ym1pdC5jbGFzc2VzfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+eyRMT0NBTEVbc3VibWl0LmNhcHRpb25dfTwvYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsjaWYgZm9ybUVycm9ycy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlZGl0LWZvcm0tZXJyb3Igbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICB7Zm9ybUVycm9ycy5qb2luKFwiLCBcIil9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2lmfVxuXG4gICAgICAgIHsjZWFjaCBmaWVsZHMgYXMgZmllbGR9XG4gICAgICAgICAgICB7I2lmIEFycmF5LmlzQXJyYXkoZmllbGQpfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBmaWVsZCBhcyBzdWJmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtzdWJmaWVsZF0gJiYgZm9ybVtzdWJmaWVsZF0uY29tcG9uZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtzdWJmaWVsZF0udmlzaWJsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJjb2x1bW4ge2Zvcm1bc3ViZmllbGRdLmZpZWxkU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2lzLScgKyBmb3JtW3N1YmZpZWxkXS5maWVsZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfSBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VUlGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzPXtbZm9ybVtzdWJmaWVsZF1dfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17b25GaWVsZENoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtzdWJmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aG9yaXpvbnRhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17Zm9ybVtzdWJmaWVsZF0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJmaWVsZCAne3N1YmZpZWxkfScgaXMgbm90IHJlZ2lzdGVyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHs6ZWxzZSBpZiBmb3JtW2ZpZWxkXSAmJiBmb3JtW2ZpZWxkXS5jb21wb25lbnR9XG4gICAgICAgICAgICAgICAgeyNpZiBmb3JtW2ZpZWxkXS52aXNpYmxlfVxuICAgICAgICAgICAgICAgICAgICA8VUlGaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbHM9e1tmb3JtW2ZpZWxkXV19XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uRmllbGRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtob3Jpem9udGFsfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2Zvcm1bZmllbGRdLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbiBpcy1kYW5nZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgRmllbGQgJ3tmaWVsZH0nIGlzIG5vdCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG5cbiAgICAgICAgeyNpZiAhYnV0dG9uc0ZpcnN0fVxuICAgICAgICAgICAgeyNpZiBmb3JtRXJyb3JzLmxlbmd0aCA+IDB9XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVkaXQtZm9ybS1lcnJvciBub3RpZmljYXRpb24gaXMtZGFuZ2VyXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBmb3JtRXJyb3JzIGFzIGZvcm1FcnJvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnskTE9DQUxFW2Zvcm1FcnJvcl19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnMgaXMtZ3JvdXBlZCBpcy1jZW50ZXJlZFwiPlxuICAgICAgICAgICAgICAgIHsjaWYgY2FuY2VsLmVuYWJsZWR9XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIHtjYW5jZWwuY2xhc3NlcyA/IGNhbmNlbC5jbGFzc2VzIDogJyd9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3JlamVjdEZvcm19PnskTE9DQUxFW2NhbmNlbC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7I2lmIHN1Ym1pdC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtzdWJtaXRGb3JtfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Zvcm1JbnZhbGlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBpcy1ob3ZlcmVkIHtzdWJtaXQuY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3VibWl0LmNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfVwiPnskTE9DQUxFW3N1Ym1pdC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIHsvaWZ9XG48L2Rpdj5cbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuXG5jb25zdCBERUZBVUxUX1JVTEVTID0ge1xuICAgIG5vdFJlYWRvbmx5KHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWRvbmx5OiAhdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWRvbmx5KHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWRvbmx5OiB2LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZW5hYmxlKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiAhdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRpc2FibGUodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHYsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIG5vdEZvcm1SdWxlcyB7XG4gICAgc3RhdGljICNSVUxFUyA9IHsgLi4uREVGQVVMVF9SVUxFUyB9O1xuXG4gICAgc3RhdGljIGFkZChuYW1lLCBmdW5jKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyh0aGlzLiNSVUxFUywgbmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuI1JVTEVTW25hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUobmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKHRoaXMuI1JVTEVTLCBuYW1lKSAmJlxuICAgICAgICAgICAgIU9iamVjdC5rZXlzKERFRkFVTFRfUlVMRVMpLmluY2x1ZGVzKG5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuI1JVTEVTW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGV4ZWMocnVsZSwgbWFzdGVyLCBzbGF2ZXMsIHZhbHVlLCBmb3JtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNSVUxFU1tydWxlXSh2YWx1ZSwgbWFzdGVyLCBzbGF2ZXMsIGZvcm0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFJ1bm5lciB9IGZyb20gXCJub3QtdmFsaWRhdGlvblwiO1xuXG5pbXBvcnQgeyBWQVJJQU5UUyB9IGZyb20gXCIuLi8uLi9MSUIuanNcIjtcbmltcG9ydCBMaWIgZnJvbSBcIi4uLy4uL2xpYi5qc1wiO1xuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vLi4vYmFzZVwiO1xuXG5pbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IEZvcm1IZWxwZXJzIGZyb20gXCIuL2Zvcm0uaGVscGVycy5qc1wiO1xuaW1wb3J0IFVJRm9ybUNvbXBvbmVudCBmcm9tIFwiLi9mb3JtLnN2ZWx0ZVwiO1xuaW1wb3J0IG5vdEZvcm1SdWxlcyBmcm9tIFwiLi9mb3JtLnJ1bGVzLmpzXCI7XG5cbmltcG9ydCB7IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgfSBmcm9tIFwiLi4vLi4vY29uc3RcIjtcblxuY29uc3QgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IgPSBcIi5mb3JtXCI7XG5jb25zdCBERUZBVUxUX0FDVElPTl9OQU1FID0gXCJkZWZhdWx0XCI7XG5cbmNsYXNzIG5vdEZvcm0gZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvL1VJIHJlbmRlcmVyIGNvbXBvbmVudCBjbGFzcyBjb25zdHJ1Y3RvclxuICAgICN1aUNvbXBvbmVudCA9IG51bGw7XG4gICAgLy9mb3JtIHZhbGlkYXRpb25cbiAgICAjdmFsaWRhdGlvblJ1bm5lciA9IG51bGw7XG4gICAgLy91aSBjb21wb25lbnRcbiAgICAjZm9ybSA9IG51bGw7XG4gICAgLy9tb2RlbC5hY3Rpb25cbiAgICAjYWN0aW9uID0gREVGQVVMVF9BQ1RJT05fTkFNRTtcbiAgICAvL2ZpZWxkcyBzY2hlbWFzXG4gICAgI2ZpZWxkcyA9IG5ldyBMaWIoKTsgLy9maWVsZHMgb2YgVUlcbiAgICAvL3ZhcmlhbnRzIHNldHMgZm9yIHNlbGVjdCBtZW51cyBhbmQgc28gb25cbiAgICAjdmFyaWFudHMgPSBudWxsOyAvL3ZhcmlhbnRzIGZvciBVSVxuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgICBuYW1lID0gXCJEZWZhdWx0XCIsXG4gICAgICAgIG9wdGlvbnMgPSB7fSxcbiAgICAgICAgd29ya2luZyA9IHt9LFxuICAgICAgICBkYXRhID0ge30sXG4gICAgICAgIHVpID0gVUlGb3JtQ29tcG9uZW50LCAvL2RlZmF1bHQgVUlcbiAgICB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtuYW1lfUZvcm1gLFxuICAgICAgICAgICAgICAgIC4uLndvcmtpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiN2YXJpYW50cyA9IG5ldyBMaWIoVkFSSUFOVFMuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdWlDb21wb25lbnQgPSB1aTtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXMob3B0aW9ucywgXCJhY3Rpb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuI2FjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdEZvcm0oKTtcbiAgICB9XG5cbiAgICBpbml0Rm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImF1dG9Jbml0XCIsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRMaWJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImF1dG9SZW5kZXJcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0TGlicygpIHtcbiAgICAgICAgdGhpcy5pbml0RmllbGRzKCk7XG4gICAgICAgIHRoaXMuaW5pdFZhcmlhbnRzKCk7XG4gICAgICAgIHRoaXMuaW5pdFZhbGlkYXRvcigpO1xuICAgIH1cblxuICAgIHJlSW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbml0TGlicygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVVJKCk7XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgaW5pdEZpZWxkcygpIHtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSB0aGlzLmdldEZvcm1NYW5pZmVzdCgpO1xuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhtYW5pZmVzdCwgXCJmaWVsZHNcIikgJiYgdGhpcy4jZmllbGRzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy4jZmllbGRzLmltcG9ydChtYW5pZmVzdC5maWVsZHMpOyAvL2FsbCBmaWVsZHMgYXZhaWxhYmxlIGluIG1vZGVsIG1hbmlmZXN0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0VmFyaWFudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJ2YXJpYW50c1wiKSkge1xuICAgICAgICAgICAgdGhpcy4jdmFyaWFudHMuaW1wb3J0KHRoaXMuZ2V0T3B0aW9ucyhcInZhcmlhbnRzXCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vY3JlYXRpbmcgdmFsaWRhdG9ycyBydW5uZXIgZm9yIHRoaXMgc3BlY2lmaWMgZm9ybVxuICAgIGluaXRWYWxpZGF0b3IoKSB7XG4gICAgICAgIHRoaXMuI3ZhbGlkYXRpb25SdW5uZXIgPSBSdW5uZXIodGhpcy5nZXRGb3JtVmFsaWRhdG9ycygpKTtcbiAgICB9XG5cbiAgICBpbml0VUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuI2dldEZvcm1Qcm9wcyh7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3Q6IHRoaXMuZ2V0Rm9ybU1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgZm9ybU9wdGlvbnM6IHRoaXMuZ2V0Rm9ybU9wdGlvbnMoKSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmdldEZvcm1EYXRhKCksXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9wczogdGhpcy5nZXRGb3JtSW5qZWN0ZWRQcm9wcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEZvcm1UYXJnZXRFbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUNoaWxkKHRhcmdldC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBuZXcgdGhpcy4jdWlDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jYmluZFVJRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlRm9ybSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlVUkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuI2dldEZvcm1Qcm9wcyh7XG4gICAgICAgICAgICAgICAgbWFuaWZlc3Q6IHRoaXMuZ2V0Rm9ybU1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgZm9ybU9wdGlvbnM6IHRoaXMuZ2V0Rm9ybU9wdGlvbnMoKSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmdldEZvcm1EYXRhKCksXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9wczogdGhpcy5nZXRGb3JtSW5qZWN0ZWRQcm9wcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLiRzZXQocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm0oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICNiaW5kVUlFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuI2Zvcm0uJG9uKFwiY2hhbmdlXCIsICgpID0+IHRoaXMudmFsaWRhdGVGb3JtKCkpO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcImNoYW5nZVwiLCAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiLCBldi5kZXRhaWwpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGBjaGFuZ2UuJHtldi5kZXRhaWwuZmllbGR9YCwgZXYuZGV0YWlsLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2Zvcm0uJG9uKFwic3VibWl0XCIsIChldikgPT4gdGhpcy5zdWJtaXQoZXYuZGV0YWlsKSk7XG4gICAgICAgIHRoaXMuI2Zvcm0uJG9uKFwicmVqZWN0XCIsICgpID0+IHRoaXMucmVqZWN0KCkpO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcImVycm9yXCIsICh7IGRldGFpbCB9KSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBkZXRhaWwpKTtcbiAgICAgICAgdGhpcy4jYmluZE1hc3RlclNsYXZlRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgI2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cygpIHtcbiAgICAgICAgY29uc3QgbWFzdGVycyA9IHRoaXMuZ2V0T3B0aW9ucyhcIm1hc3RlcnNcIiwgZmFsc2UpO1xuICAgICAgICBpZiAoIW1hc3RlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBtYXN0ZXIgaW4gbWFzdGVycykge1xuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBtYXN0ZXJzW21hc3Rlcl07XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlTmFtZSBpbiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVTbGF2ZXMgPSBydWxlc1tydWxlTmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy4jYWRkTWFzdGVyU2xhdmVFdmVudHMocnVsZU5hbWUsIG1hc3RlciwgcnVsZVNsYXZlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAjYWRkTWFzdGVyU2xhdmVFdmVudHMocnVsZSwgbWFzdGVyLCBzbGF2ZXMgPSBbXSkge1xuICAgICAgICB0aGlzLm9uKGBjaGFuZ2UuJHttYXN0ZXJ9YCwgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNleGVjU2xhdmVSdWxlKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoYGNoYW5nZS4ke21hc3Rlcn1gLCB0aGlzLmdldEZvcm1EYXRhKClbbWFzdGVyXSk7XG4gICAgfVxuXG4gICAgI2V4ZWNTbGF2ZVJ1bGUocnVsZSwgbWFzdGVyLCBzbGF2ZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IG5vdEZvcm1SdWxlcy5leGVjKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIHNsYXZlcy5mb3JFYWNoKChzbGF2ZUZpZWxkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkKHNsYXZlRmllbGQsIGNtZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHZhbGlkYXRlRm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInJlYWRvbmx5XCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy4jdmFsaWRhdGlvblJ1bm5lcihcbiAgICAgICAgICAgICAgICB0aGlzLiNmb3JtLmNvbGxlY3REYXRhKCksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGb3JtQWN0aW9uKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLnVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKHZhbGlkYXRpb25SZXN1bHQuZ2V0UmVwb3J0KCkpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LmNsZWFuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgdmFsaWRhdGlvblJlc3VsdC5nZXRSZXBvcnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHtcbiAgICAgICAgICAgICAgICBmb3JtOiBbVUlDb21tb24uRVJST1JfREVGQVVMVCwgZS5tZXNzYWdlXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLiNmb3JtICYmIHRoaXMuI2Zvcm0udXBkYXRlRm9ybVZhbGlkYXRpb25TdGF0dXMocmVwb3J0KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHJlcG9ydCk7XG4gICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3VibWl0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VibWl0XCIsIGRhdGEpO1xuICAgIH1cblxuICAgIHJlamVjdCgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVqZWN0XCIpO1xuICAgIH1cblxuICAgIC8vYmluZGluZyBldmVudCB0byBhY3R1YWwgVUlcbiAgICAkb24oKSB7XG4gICAgICAgIGlmICh0aGlzLiNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLiRvbiguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TG9hZGluZygpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG9hZGluZ1wiKTtcbiAgICAgICAgdGhpcy4jZm9ybS5zZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgcmVzZXRMb2FkaW5nKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJsb2FkZWRcIik7XG4gICAgICAgIHRoaXMuI2Zvcm0ucmVzZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICAgICAgaWYgKHRoaXMuI2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0uJGRlc3Ryb3kgJiYgdGhpcy4jZm9ybS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jZm9ybS5kZXN0cm95ICYmIHRoaXMuI2Zvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jZm9ybSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdmFsaWRhdGlvblJ1bm5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuI2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuI2ZpZWxkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuI3ZhcmlhbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG51bGwpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0RGF0YShudWxsKTtcbiAgICB9XG5cbiAgICAjZ2V0Rm9ybVByb3BzKHtcbiAgICAgICAgbWFuaWZlc3QsIC8vbW9kZWwgbWFuaWZlc3RcbiAgICAgICAgZm9ybU9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1aToge30sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICB9LCAvL3NvbWUgb3B0aW9uc1xuICAgICAgICBkYXRhID0gbnVsbCwgLy9pbml0aWFsIGRhdGEgZm9yIGZvcm1cbiAgICAgICAgaW5qZWN0ZWRQcm9wcyA9IHt9LFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy4jYWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1PcHRpb25zID09PSBcInVuZGVmaW5lZFwiIHx8IGZvcm1PcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1aToge30sXG4gICAgICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb3JtID0gRm9ybUhlbHBlcnMuaW5pdEZvcm1CeUZpZWxkKFxuICAgICAgICAgICAgLy9mb3JtIHNlZWQgb2JqZWN0XG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIC8qXG4gICAgICBGb3JtIHN0cnVjdHVyZVxuICAgICAgW1xuICAgICAgICAvL2VhY2ggaXRlbSBpcyBsaW5lIG9mIGZvcm1cbiAgICAgICAgLy9maWVsZCAtIGZpZWxkIHRha2VzIHdob2xlIGxpbmUgb2YgZm9ybVxuICAgICAgICAvL1tmaWVsZDEsIGZpZWxkMl0gLSBmZXcgZmllbGRzIGluIG9uZSBsaW5lXG4gICAgICAgIG5hbWVGaXJzdCwgbmFtZUxhc3RcbiAgICAgICAgW2FnZSwgY291bnRyeSwgbGFuZ3VhZ2VdLFxuICAgICAgICBbZW1haWwsIHRlbGVwaG9uZV1cbiAgICAgIF1cbiAgICAgICovXG4gICAgICAgICAgICBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0uZmllbGRzLCAvL2Zvcm0gZmllbGRzIHN0cnVjdHVyZVxuICAgICAgICAgICAgdGhpcy4jdmFyaWFudHMsIC8vdmFyaWFudHMgbGlicmFyeVxuICAgICAgICAgICAgdGhpcy4jZmllbGRzLCAvL2ZpZWxkcyBsaWJyYXJ5XG4gICAgICAgICAgICBmb3JtT3B0aW9ucy5maWVsZHMsIC8vZm9ybSB3aWRlIGZpZWxkcyBvcHRpb25zXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vaWYgbm8gYXV0byBpbml0IG9mIGZvcm0gc3RydWN0dXJlLCBzZXQgdG8gbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgbG9hZGluZzogIXRoaXMuZ2V0T3B0aW9ucyhcImF1dG9Jbml0XCIsIHRydWUpLFxuICAgICAgICAgICAgdGl0bGU6IG1hbmlmZXN0LmFjdGlvbnNbYWN0aW9uXS50aXRsZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBmaWVsZHM6IG1hbmlmZXN0LmFjdGlvbnNbYWN0aW9uXS5maWVsZHMsXG4gICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgLy9pbmplY3Rpbmcgb3B0aW9ucyB0byBVSSBmcm9tIHRvcCBsZXZlbCBpbnB1dFxuICAgICAgICAgICAgLi4uZm9ybU9wdGlvbnMudWksIC8vZm9ybSBVSSBvcHRpb25zXG4gICAgICAgICAgICAuLi5pbmplY3RlZFByb3BzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJuYW1lXCIpO1xuICAgIH1cblxuICAgIGdldEZvcm1BY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhY3Rpb247XG4gICAgfVxuXG4gICAgc2V0Rm9ybUFjdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCAmJiB2YWwgIT09IHRoaXMuI2FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy4jYWN0aW9uID0gdmFsO1xuICAgICAgICAgICAgdGhpcy4jZm9ybSAmJiB0aGlzLiNmb3JtLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluaXRGb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gREVGQVVMVF9TVEFUVVNfU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtU3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1FcnJvcnMocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgRm9ybSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgICAqKi9cbiAgICBzZXRGb3JtU3VjY2VzcygpIHtcbiAgICAgICAgdGhpcy4jZm9ybS5zaG93U3VjY2VzcygpO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdWNjZXNzXCIpO1xuICAgIH1cblxuICAgIHNldEZvcm1FcnJvcnMocmVzdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJyZWFkb25seVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBmb3JtOiBbXSxcbiAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xuICAgICAgICAgICAgc3RhdHVzLmZvcm0ucHVzaChyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiYgT2JqZWN0LmtleXMocmVzdWx0LmVycm9ycykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdHVzLmZpZWxkcyA9IHsgLi4ucmVzdWx0LmVycm9ycyB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Zvcm0udXBkYXRlRm9ybVZhbGlkYXRpb25TdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgc3RhdHVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhcmlhbnQgYnkgY29sbGVjdGlvbiBuYW1lIGFuZCBpdGVtIGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgbmFtZSAgbmFtZSBvZiB0aGUgdmFyaWFudHMgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gIGlkICAgIGl0ZW0gaWRlbnRpZmljYXRvclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgICAgICAgICAgIGl0ZW1cbiAgICAgKiovXG4gICAgZ2V0VmFyaWFudChuYW1lLCBpZCkge1xuICAgICAgICBsZXQgbGliID0gdGhpcy4jdmFyaWFudHMuZ2V0KG5hbWUpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbGliLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKioqXG4gICAgICogUmVkZWZpbmFibGUgZ2V0dGVyc1xuICAgICAqKi9cblxuICAgIGdldEZvcm1UYXJnZXRFbCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLmdldE9wdGlvbnMoXCJ0YXJnZXRcIiwgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IpO1xuICAgICAgICBpZiAodGFyZ2V0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEVsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXRFbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0RWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9ybSBwYXJlbnQgZWxlbWVudCBpcyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1WYWxpZGF0b3JzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidmFsaWRhdG9yc1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcInZhbGlkYXRvcnNcIiwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcInZhbGlkYXRvcnNcIik7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtTWFuaWZlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMuZ2V0TW9kZWxOYW1lKCk7XG4gICAgICAgIGlmIChtb2RlbE5hbWUgJiYgbm90Q29tbW9uLmdldEFwcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpLmdldEludGVyZmFjZU1hbmlmZXN0KG1vZGVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcIm1hbmlmZXN0XCIsIHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFwiLCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNtaXNzaW5nT3ZlcnJpZGVXYXJuaW5nKFwibWFuaWZlc3RcIik7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtRGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGF0YSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNtaXNzaW5nT3ZlcnJpZGVXYXJuaW5nKFwiZGF0YVwiKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1PcHRpb25zKCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJ1aVwiLCB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwgdW5kZWZpbmVkKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdWk6IHRoaXMuZ2V0T3B0aW9ucyhcInVpXCIsIHt9KSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXMuZ2V0T3B0aW9ucyhcImZpZWxkc1wiLCB7fSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcIm9wdGlvbnNcIik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVpOiB7fSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1JbmplY3RlZFByb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW5qZWN0ZWRcIiwge30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGVtcHR5IG1lc3NhZ2VcbiAgICAgKiovXG4gICAgI21pc3NpbmdPdmVycmlkZVdhcm5pbmcobWlzc2luZykge1xuICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgYCR7bWlzc2luZ30gZm9yICR7dGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKX0gZm9ybSBpcyBub3QgZGVmaW5lZGBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtIG9wZXJhdGlvbnNcbiAgICAgKiovXG4gICAgY29sbGVjdERhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJyZWFkb25seVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy4jZm9ybS5jb2xsZWN0RGF0YSgpO1xuICAgICAgICB0aGlzLnNldERhdGEoeyAuLi5kYXRhIH0pOyAvL3VwZGF0ZSBpbiBpbm5lciBzdG9yZVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB1cGRhdGVGaWVsZChmaWVsZE5hbWUsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuI2Zvcm0udXBkYXRlRmllbGQoZmllbGROYW1lLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgZ2V0TW9kZWwobmFtZSwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZShuYW1lKShkYXRhIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZSgpKG5hbWUgfHwge30pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SW50ZXJmYWNlKG5hbWUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldEFwcCgpLmdldEludGVyZmFjZShuYW1lIHx8IHRoaXMuZ2V0TW9kZWxOYW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGN1cnJlbnQgbW9kZWwgbmFtZVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TW9kZWxOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibW9kZWxcIik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RGb3JtO1xuIiwiPHNjcmlwdD5cblxuICBpbXBvcnQgVUlCdXR0b25zIGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZSc7XG5cbiAgaW1wb3J0IHtcbiAgICAgIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcixcbiAgICAgIG9uTW91bnRcbiAgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvd01vZGVzXVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW21vZGVdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZm9ybXNdXG4gICAqL1xuXG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGxldCB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQtZm9ybScsXG4gICAgICBzaG93TW9kZXMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAkYmluZGFibGUoJ2RlZmF1bHQnKSxcbiAgICAgIGZvcm1zID0gW11cbiAgfSA9ICRwcm9wcygpO1xuXG4gIGZ1bmN0aW9uIHNldE1vZGUodmFsKSB7XG4gICAgICBtb2RlID0gdmFsO1xuICAgICAgZGlzcGF0Y2goJ21vZGUnLCB2YWwpO1xuICAgICAgdXBkYXRlTW9kZXNCdXR0b25zKCk7XG4gIH1cblxuICBsZXQgRk9STVNfQlVUVE9OUyA9ICRzdGF0ZShbXSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlTW9kZXNCdXR0b25zKCkge1xuICAgICAgRk9STVNfQlVUVE9OUyA9IGZvcm1zLmZpbHRlcihmb3JtID0+IHtcbiAgICAgICAgICByZXR1cm4gKG1vZGUgIT09IGZvcm0ubW9kZSk7XG4gICAgICB9KS5tYXAoZm9ybSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGl0bGU6IGZvcm0udGl0bGUsXG4gICAgICAgICAgICAgIG91dGxpbmVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgIGFjdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNldE1vZGUoZm9ybS5tb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9KTtcbiAgfVxuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgICAgdXBkYXRlTW9kZXNCdXR0b25zKCk7XG4gIH0pO1xuXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImJsb2NrLWNvbnRhaW5lclwiIGlkPVwie25hbWV9LWZvcm0tc2V0XCI+XG4gIDxkaXYgY2xhc3M9XCJmb3JtLXBhcGVyXCIgIGlkPVwie25hbWV9LWZvcm0tc2V0LWNvbnRhaW5lclwiPjwvZGl2PlxuICB7I2lmIHNob3dNb2Rlc31cbiAgPFVJQnV0dG9ucyBjZW50ZXJlZD17dHJ1ZX0gYmluZDp2YWx1ZXM9e0ZPUk1TX0JVVFRPTlN9IGNsYXNzZXM9J210LTQnIC8+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuLi8uLi9iYXNlXCI7XG5cbmltcG9ydCBVSUZvcm1TZXRDb21wb25lbnQgZnJvbSBcIi4vZm9ybS5zZXQuc3ZlbHRlXCI7XG5pbXBvcnQgVUlGb3JtQ29tcG9uZW50IGZyb20gXCIuL2Zvcm0uc3ZlbHRlXCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCIuZm9ybS1zZXRcIjtcbmNvbnN0IERFRkFVTFRfRk9STV9TRVRfTkFNRSA9IFwiZm9ybS1zZXRcIjtcblxuY2xhc3Mgbm90Rm9ybVNldCBleHRlbmRzIG5vdEJhc2Uge1xuICAgICNmb3JtU2V0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAjZm9ybUNvbXBvbmVudCA9IG51bGw7XG5cbiAgICAjZm9ybSA9IG51bGw7XG4gICAgI2ZyYW1lID0gbnVsbDtcblxuICAgIC8qXG4gIG5ldyBub3RGb3JtU2V0KHtcbiAgICBvcHRpb25zOntcbiAgICAgIHRhcmdldDogZWwsXG4gICAgICBmb3JtczogW3tcbiAgICAgICAgbW9kZTogJ2Zvcm0xJyxcbiAgICAgICAgdGl0bGU6ICdGb3JtIDEnLFxuICAgICAgICBmb3JtOiBmb3JtQ29uc3RydWN0b3IxIC8vY3VzdG9tIGNvbnN0cnVjdG9yc1xuICAgICAgfSx7XG4gICAgICAgIG1vZGU6ICdmb3JtMicsXG4gICAgICAgIHRpdGxlOiAnRm9ybSAyJyxcbiAgICAgICAgcHJvcHM6IHt9ICAgICAgICAgICAgIC8vcGFyYW1zIHRvIGNyZWF0ZSBub3RGb3JtIGluc3RhbmNlXG4gICAgICB9LHtcbiAgICAgICAgbW9kZTogJ2Zvcm0zJyxcbiAgICAgICAgdGl0bGU6ICdGb3JtIDMnLFxuICAgICAgICBmb3JtOiBmb3JtQ29uc3RydWN0b3IzIC8vY3VzdG9tIGNvbnN0cnVjdG9yc1xuICAgICAgfV1cbiAgICB9XG4gIH0pO1xuICAqL1xuXG4gICAgY29uc3RydWN0b3Ioe1xuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIGZvcm1Db21wb25lbnQgPSBVSUZvcm1Db21wb25lbnQsXG4gICAgICAgIGZvcm1TZXRDb21wb25lbnQgPSBVSUZvcm1TZXRDb21wb25lbnQsXG4gICAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogREVGQVVMVF9GT1JNX1NFVF9OQU1FLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIHNob3dNb2RlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2Zvcm1Db21wb25lbnQgPSBmb3JtQ29tcG9uZW50O1xuICAgICAgICB0aGlzLiNmb3JtU2V0Q29tcG9uZW50ID0gZm9ybVNldENvbXBvbmVudDtcbiAgICAgICAgdGhpcy5zZXRGb3JtTW9kZSh0aGlzLmdldE9wdGlvbnMoXCJtb2RlXCIpKTtcbiAgICAgICAgdGhpcy5pbml0VUkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0YWxpemluZyBmb3JtIGZyYW1lIG1vZGUsIHdpdGggc3dpdGNoZXJzIGJldHdlZW4gbW9kZXNcbiAgICAgKiovXG4gICAgaW5pdFVJKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEZyYW1lVGFyZ2V0RWwoKTtcbiAgICAgICAgd2hpbGUgKHRhcmdldC5jaGlsZHJlbi5sZW5ndGgpIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gbmV3IHRoaXMuI2Zvcm1TZXRDb21wb25lbnQoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcHJvcHM6IHRoaXMuI2dldEZyYW1lUHJvcHMoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ZyYW1lLiRvbihcIm1vZGVcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1Nb2RlKGV2LmRldGFpbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9ybSgpO1xuICAgIH1cblxuICAgIHNldEZvcm1Nb2RlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNb2RlRXhpc3RzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlXCIsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwibW9kZVwiLCB0aGlzLmdldEZpcnN0TW9kZSgpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybU1vZGVJblVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVGb3JtTW9kZUluVUkoKSB7XG4gICAgICAgIGlmICh0aGlzLiNmcmFtZSAmJiB0aGlzLmdldFdvcmtpbmcoXCJtb2RlXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZS4kc2V0KHsgbW9kZTogdGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGb3JtKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lGb3JtKCk7XG4gICAgICAgIGlmICh0aGlzLmdldFdvcmtpbmcoXCJtb2RlXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlckZvcm0oKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5nZXRGb3JtVGFyZ2V0RWwoKTtcbiAgICAgICAgY29uc3QgZm9ybUNvbmZpZyA9IHRoaXMuZ2V0Rm9ybUNvbmZpZygpO1xuICAgICAgICBpZiAoISh0YXJnZXRFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGZvcm1Db25maWcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlcnJvciB3aGlsZSBmb3JtIHJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VNb2RlID0gKG1vZGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9ybU1vZGUobW9kZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZvcm1Db25maWcuZm9ybSkge1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldEVsLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0YXJnZXRFbC5yZW1vdmVDaGlsZCh0YXJnZXRFbC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBuZXcgZm9ybUNvbmZpZy5mb3JtKHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7IHRhcmdldDogdGFyZ2V0RWwsIGNoYW5nZU1vZGUgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1Db25maWcucHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBuZXcgdGhpcy4jZm9ybUNvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRFbCxcbiAgICAgICAgICAgICAgICAuLi5mb3JtQ29uZmlnLnByb3BzLFxuICAgICAgICAgICAgICAgIGNoYW5nZU1vZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEZvcm1Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiKS5maW5kKFxuICAgICAgICAgICAgKGZvcm0pID0+IGZvcm0ubW9kZSA9PT0gdGhpcy5nZXRGb3JtTW9kZSgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZGVzdHJveUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckVsID0gdGhpcy5nZXRGb3JtVGFyZ2V0RWwoKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lckVsKSB7XG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbmVyRWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVsLnJlbW92ZUNoaWxkKGNvbnRhaW5lckVsLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2Zvcm0gJiYgdGhpcy4jZm9ybS4kZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy4jZm9ybS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Zvcm0gPSBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3lGcmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2ZyYW1lICYmIHRoaXMuI2ZyYW1lLiRkZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICBpc01vZGVFeGlzdHMobW9kZSkge1xuICAgICAgICBjb25zdCBmb3JtcyA9IHRoaXMuZ2V0T3B0aW9ucyhcImZvcm1zXCIsIFtdKTtcbiAgICAgICAgcmV0dXJuIGZvcm1zLnNvbWUoKGl0ZW0pID0+IGl0ZW0ubW9kZSA9PT0gbW9kZSk7XG4gICAgfVxuXG4gICAgZ2V0Rmlyc3RNb2RlKCkge1xuICAgICAgICBjb25zdCBmb3JtcyA9IHRoaXMuZ2V0T3B0aW9ucyhcImZvcm1zXCIsIFtdKTtcbiAgICAgICAgaWYgKGZvcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmb3Jtc1swXS5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuI2Zvcm1TZXRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLiNmb3JtQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXN0cm95Rm9ybSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lGcmFtZSgpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgIH1cblxuICAgIGdldEZyYW1lVGFyZ2V0RWwoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0T3B0aW9ucyhcInRhcmdldFwiLCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUik7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybSBzZXQgdGFyZ2V0IGlzIG5vdCBIVE1MRWxlbWVudCBvciBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtVGFyZ2V0RWwoKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldE9wdGlvbnMoXCJuYW1lXCIsIERFRkFVTFRfRk9STV9TRVRfTkFNRSk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtuYW1lfS1mb3JtLXNldC1jb250YWluZXJgKTtcbiAgICB9XG5cbiAgICAjZ2V0RnJhbWVQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNob3dNb2RlczogdGhpcy5nZXRPcHRpb25zKFwic2hvd01vZGVzXCIsIHRydWUpLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5nZXRGb3JtTW9kZSgpLFxuICAgICAgICAgICAgZm9ybXM6IHRoaXMuZ2V0T3B0aW9ucyhcImZvcm1zXCIsIFtdKSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0T3B0aW9ucyhcIm5hbWVcIiwgREVGQVVMVF9GT1JNX1NFVF9OQU1FKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEZvcm1TZXQ7XG4iLCI8c2NyaXB0PlxuXG4gIGltcG9ydCB7TE9DQUxFfSBmcm9tICcuLi8uLi8uLi9sb2NhbGUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZ29dXG4gICAqL1xuXG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGxldCB7IHJvb3QgPSAnJywgaXRlbXMgPSBbXSwgZ28gPSBudWxsIH0gPSAkcHJvcHMoKTtcblxuICBmdW5jdGlvbiBvbkNsaWNrKGV2KXtcbiAgICAgIGlmKHR5cGVvZiBnbyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBnbyhldi5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaHJlZik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfWVsc2V7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxuYXYgY2xhc3M9XCJicmVhZGNydW1iXCIgYXJpYS1sYWJlbD1cImJyZWFkY3J1bWJzXCI+XG4gIDx1bD5cbiAgICB7I2VhY2ggaXRlbXMgYXMgbGluaywgaW5kZXh9XG4gICAgeyNpZiAoaXRlbXMubGVuZ3RoID09PSAoaW5kZXggKyAxKSkgfVxuICAgIDxsaSBjbGFzcz1cImlzLWFjdGl2ZVwiPjxhIGhyZWY9XCJ7cm9vdH17bGluay51cmx9XCIgZGF0YS1ocmVmPVwie2xpbmsudXJsfVwiIGFyaWEtY3VycmVudD1cInBhZ2VcIj57JExPQ0FMRVtsaW5rLnRpdGxlXX08L2E+PC9saT5cbiAgICB7OmVsc2UgfVxuICAgIHsjaWYgbGluay51cmwgPT09IGZhbHNlIH1cbiAgICA8bGkgY2xhc3M9XCJpcy1wbGFpbi1jcnVtYlwiPnskTE9DQUxFW2xpbmsudGl0bGVdfTwvbGk+XG4gICAgezplbHNlfVxuICAgIDxsaT48YSBocmVmPVwie3Jvb3R9e2xpbmsudXJsfVwiIGRhdGEtaHJlZj1cIntsaW5rLnVybH1cIiBvbmNsaWNrPXtvbkNsaWNrfT57JExPQ0FMRVtsaW5rLnRpdGxlXX08L2E+PC9saT5cbiAgICB7L2lmfVxuICAgIHsvaWZ9XG4gICAgey9lYWNofVxuICA8L3VsPlxuPC9uYXY+XG4iLCJpbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxubGV0IGxvY2FsX3VpX3Byb3BzID0gJHN0YXRlKHt9KTtcblxuY2xhc3Mgbm90QnJlYWRjcnVtYnMge1xuICAgIHN0YXRpYyBVSUNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICBzdGF0aWMgdWkgPSBudWxsO1xuICAgIHN0YXRpYyBoZWFkID0gW107XG4gICAgc3RhdGljIHRhaWwgPSBbXTtcblxuICAgIHN0YXRpYyBpbml0VUlQcm9wcyhyb290LCBuYXZpZ2F0ZSkge1xuICAgICAgICBsb2NhbF91aV9wcm9wcyA9IHtcbiAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmdldEJyZWFkY3J1bWJzKCksXG4gICAgICAgICAgICByb290OiByb290LFxuICAgICAgICAgICAgZ286IG5hdmlnYXRlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyByZW5kZXIoeyB0YXJnZXQsIHJvb3QgPSBcIlwiLCBuYXZpZ2F0ZSB9KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIGlmIChub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRVSVByb3BzKHJvb3QsIG5hdmlnYXRlKTtcbiAgICAgICAgICAgIHRoaXMudWkgPSBtb3VudChub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHByb3BzOiBsb2NhbF91aV9wcm9wcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRIZWFkKGhlYWQpIHtcbiAgICAgICAgdGhpcy5oZWFkLnNwbGljZSgwLCB0aGlzLmhlYWQubGVuZ3RoLCAuLi5oZWFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFRhaWwodGFpbCkge1xuICAgICAgICB0aGlzLnRhaWwuc3BsaWNlKDAsIHRoaXMudGFpbC5sZW5ndGgsIC4uLnRhaWwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QnJlYWRjcnVtYnMoKSB7XG4gICAgICAgIGxldCBjcnVtYnMgPSBbXTtcbiAgICAgICAgY3J1bWJzLnB1c2goLi4udGhpcy5oZWFkKTtcbiAgICAgICAgY3J1bWJzLnB1c2goLi4udGhpcy50YWlsKTtcbiAgICAgICAgcmV0dXJuIGNydW1icztcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy51aSkge1xuICAgICAgICAgICAgbG9jYWxfdWlfcHJvcHMuaXRlbXMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy51aSkge1xuICAgICAgICAgICAgdW1vdW50KHRoaXMudWkpO1xuICAgICAgICAgICAgdGhpcy51aSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RCcmVhZGNydW1icztcbiIsImltcG9ydCBVSUJyZWFkY3J1bWJzIGZyb20gXCIuL3VpLmJyZWFkY3J1bWJzLnN2ZWx0ZVwiO1xuaW1wb3J0IG5vdEJyZWFkY3J1bWJzIGZyb20gXCIuL2JyZWFkY3J1bWJzLnN2ZWx0ZS5qc1wiO1xuXG5ub3RCcmVhZGNydW1icy5VSUNvbnN0cnVjdG9yID0gVUlCcmVhZGNydW1icztcblxuZXhwb3J0IGRlZmF1bHQgbm90QnJlYWRjcnVtYnM7XG4iLCJpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uL0xJQi5qc1wiO1xuaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9jb21tb24uanNcIjtcblxuY2xhc3MgTWVudSB7XG4gICAgc3RhdGljIE1BWF9UT1VDSF9XSURUSCA9IDEwMjM7XG5cbiAgICBzdGF0aWMgREVGQVVMVCA9IHtcbiAgICAgICAgc2VjdGlvbjogXCJhbnlcIixcbiAgICAgICAgc2VjdGlvblRpdGxlOiBcItCc0LXQvdGOXCIsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICAvL2xpbmssIGJ1dHRvbiwgZHJvcGRvd24sIGNvbXBvbmVudFxuICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgICAgb3BlbjogZmFsc2UsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4uLy4uL2FwcC5qcycpLmRlZmF1bHQgfCBudWxsfVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgTWVudVxuICAgICAqL1xuICAgIHN0YXRpYyBhcHAgPSBudWxsO1xuICAgIHN0YXRpYyBkaXJlY3ROYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgc3RhdGljIG1lbnU7XG4gICAgc3RhdGljIG9wdGlvbnMgPSB7XG4gICAgICAgIGRpcmVjdE5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICBuYXZpZ2F0ZTogKHVybHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlyZWN0TmF2aWdhdGlvbigpICYmIHRoaXMuYXBwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLmFwcC5nZXRXb3JraW5nKFwicm91dGVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLm5hdmlnYXRlKHVybHMuc2hvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmFzc2lnbih1cmxzLmZ1bGwpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBzdGF0aWMgaGlkZSgpIHt9XG5cbiAgICBzdGF0aWMgaXRlbXMgPSBbXTtcbiAgICBzdGF0aWMgc2VjdGlvbnMgPSBbXTtcbiAgICBzdGF0aWMgbG9jYXRpb247XG4gICAgc3RhdGljIGludGVydmFsO1xuXG4gICAgc3RhdGljIHNldEFwcChhcHApIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwcCkge1xuICAgICAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0T3B0aW9uc1BhdGhUbyh3aGF0KSB7XG4gICAgICAgIHJldHVybiBgbWVudS4ke3RoaXMub3B0aW9ucy50eXBlfS4ke3doYXR9YDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNEaXJlY3ROYXZpZ2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBcbiAgICAgICAgICAgID8gdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJkaXJlY3ROYXZpZ2F0aW9uXCIpLFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kaXJlY3ROYXZpZ2F0aW9uXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5kaXJlY3ROYXZpZ2F0aW9uO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRPcHRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5hcHApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYnJhbmQ6IHRoaXMuYXBwLmdldE9wdGlvbnMoXCJicmFuZFwiLCB0aGlzLm9wdGlvbnMuYnJhbmQpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJpdGVtc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLml0ZW1zXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzZWN0aW9uczogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwic2VjdGlvbnNcIiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWN0aW9uc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGFyZ2V0U2VsZWN0b3I6IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcInRhcmdldFNlbGVjdG9yXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0U2VsZWN0b3JcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdG9yOiB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJ0b2dnbGVTZWxlY3RvclwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRvZ2dsZVNlbGVjdG9yXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBvcGVuOiB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJvcGVuXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3BlblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZGlyZWN0TmF2aWdhdGlvbjogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwiZGlyZWN0TmF2aWdhdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpcmVjdE5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJvb3Q6IHRoaXMuYXBwLmdldE9wdGlvbnMoXCJyb3V0ZXIucm9vdFwiLCB0aGlzLm9wdGlvbnMucm9vdCksXG4gICAgICAgICAgICAgICAgbmF2aWdhdGU6IHRoaXMub3B0aW9ucy5uYXZpZ2F0ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudDogdGhpcy5nZXRDb21wb25lbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldENvbXBvbmVudChuYW1lKSB7XG4gICAgICAgIGlmIChDT01QT05FTlRTLmNvbnRhaW5zKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ09NUE9ORU5UUy5nZXQobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdEZpZWxkKGxpc3QsIGZpZWxkcyA9IFtdKSB7XG4gICAgICAgIGxpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGl0ZW0sIGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtW2ZpZWxkXSA9IHRoaXMuREVGQVVMVFtmaWVsZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpdGVtLCBcIml0ZW1zXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0RmllbGQoaXRlbS5pdGVtcywgZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNvcnRMaXN0KGxpc3QpIHtcbiAgICAgICAgbGlzdC5zb3J0KChpdGVtMSwgaXRlbTIpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGl0ZW0xLCBcIml0ZW1zXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0TGlzdChpdGVtMS5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpdGVtMiwgXCJpdGVtc1wiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydExpc3QoaXRlbTIuaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0xLnByaW9yaXR5ID09PSBpdGVtMi5wcmlvcml0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtMS50aXRsZSA+IGl0ZW0yLnRpdGxlID8gMSA6IC0xO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTEucHJpb3JpdHkgPCBpdGVtMi5wcmlvcml0eSA/IDEgOiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbW92ZUR1YmxpY2F0ZXMoc2VjdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gc2VjdGlvbnNbaV0ucHJpb3JpdHk7XG4gICAgICAgICAgICBzZWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb24uaWQgPT09IHNlY3Rpb25zW2ldLmlkO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGl0ZW0sIGluZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcmlvcml0eSA8IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eSA9IGl0ZW0ucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnMuc3BsaWNlKHNlY3Rpb25zLmluZGV4T2YoaXRlbSksIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VjdGlvbnNbaV0ucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VjdGlvbnM7XG4gICAgfVxuXG4gICAgc3RhdGljIHByZXBhcmVEYXRhKCkge1xuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgaXRlbXMucHVzaCguLi50aGlzLmdldE9wdGlvbnMoKS5pdGVtcyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKC4uLnRoaXMuZ2V0T3B0aW9ucygpLnNlY3Rpb25zKTtcblxuICAgICAgICB0aGlzLmluaXRGaWVsZChzZWN0aW9ucywgW1wicHJpb3JpdHlcIl0pO1xuICAgICAgICB0aGlzLnJlbW92ZUR1YmxpY2F0ZXMoc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLmluaXRGaWVsZChpdGVtcywgW1wicHJpb3JpdHlcIiwgXCJzZWN0aW9uXCIsIFwidHlwZVwiXSk7XG4gICAgICAgIHRoaXMuc29ydExpc3Qoc2VjdGlvbnMpO1xuXG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHRoaXMuREVGQVVMVC5zZWN0aW9uLFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMuREVGQVVMVC5zZWN0aW9uVGl0bGUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvcnRMaXN0KGl0ZW1zKTtcblxuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aGlzLm1lbnUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMubWVudSA9IG51bGw7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZUluZGljYXRvcihzZWN0aW9uSWQsIGl0ZW1JZCwgc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWN0aW9uKHNlY3Rpb25JZCwgKHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNlY3Rpb24uaW5kaWNhdG9yLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUl0ZW0oaXRlbUlkLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaXRlbS5pbmRpY2F0b3Iuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVRhZyhzZWN0aW9uSWQsIGl0ZW1JZCwgdGFnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbihzZWN0aW9uSWQsIChzZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzZWN0aW9uLnRhZyA9IHRhZztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbShpdGVtSWQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnRhZyA9IHRhZztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZVNlY3Rpb25UYWcoc2VjdGlvbklkLCB0YWcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWN0aW9uKHNlY3Rpb25JZCwgKHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNlY3Rpb24udGFnID0geyAuLi5zZWN0aW9uLnRhZywgLi4udGFnIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVJdGVtVGFnKGl0ZW1JZCwgdGFnKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbShpdGVtSWQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLnRhZyA9IHsgLi4uaXRlbS50YWcsIC4uLnRhZyB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlU2VjdGlvbihzZWN0aW9uSWQsIHByb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdGlvbnMgJiYgc2VjdGlvbklkKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWN0aW9uIGluIHRoaXMuc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWN0aW9uc1tzZWN0aW9uXS5pZCAhPT0gc2VjdGlvbklkKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBwcm9jKHRoaXMuc2VjdGlvbnNbc2VjdGlvbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudS4kc2V0KHsgc2VjdGlvbnM6IHRoaXMuc2VjdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlU2VjdGlvbkl0ZW1zKHNlY3Rpb25JZCwgcHJvYykge1xuICAgICAgICBpZiAodGhpcy5zZWN0aW9ucyAmJiBzZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGxldCBvbGRMaXN0ID0gdGhpcy5pdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKGl0ZW0pID0+IGl0ZW0uc2VjdGlvbiA9PT0gc2VjdGlvbklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBvbGRMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGkpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaCguLi5wcm9jKG9sZExpc3QpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuJHNldCh7IGl0ZW1zOiB0aGlzLml0ZW1zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZUl0ZW0oaXRlbUlkLCBwcm9jKSB7XG4gICAgICAgIGlmIChpdGVtSWQgJiYgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IGl0ZW1JZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHByb2MoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lbnUuJHNldCh7IGl0ZW1zOiB0aGlzLml0ZW1zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVG91Y2goKSB7XG4gICAgICAgIHJldHVybiBVSUNvbW1vbi5pc01vYmlsZSh0cnVlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U2VjdGlvbkNvbXBvbmVudCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lbnU7XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi8uLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlJbmRpY2F0b3IgZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuaW5kaWNhdG9yLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyByb290ID0gXCJcIiwgaXRlbSA9IHt9LCBvbm5hdmlnYXRlID0gKCkgPT4ge30gfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvbm5hdmlnYXRlKHtcbiAgICAgICAgICAgIGZ1bGw6IGV2LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLFxuICAgICAgICAgICAgc2hvcnQ6IGV2LnRhcmdldC5kYXRhc2V0LmhyZWYsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgdHlwZW9mIGl0ZW0udXJsICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZW0udXJsICE9PSBmYWxzZX1cbiAgICA8bGkgY2xhc3M9e2l0ZW0uY2xhc3Nlc30+XG4gICAgICAgIDxhIGhyZWY9XCJ7cm9vdH17aXRlbS51cmx9XCIgZGF0YS1ocmVmPXtpdGVtLnVybH0gb25jbGljaz17b25DbGlja30+XG4gICAgICAgICAgICB7JExPQ0FMRVtpdGVtLnRpdGxlXX1cbiAgICAgICAgICAgIHsjaWYgaXRlbS50YWd9XG4gICAgICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS50YWd9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNpZiBpdGVtLmluZGljYXRvcn1cbiAgICAgICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLmluZGljYXRvcn0gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvYT5cbiAgICA8L2xpPlxuezplbHNlfVxuICAgIDxsaSBjbGFzcz1cImlzLW5vLWZvbGxvdy1zdWJ0aXRsZSB7aXRlbS5jbGFzc2VzfVwiPlxuICAgICAgICB7JExPQ0FMRVtpdGVtLnRpdGxlXX1cbiAgICAgICAgeyNpZiBpdGVtLnRhZ31cbiAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0udGFnfSAvPlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIGl0ZW0uaW5kaWNhdG9yfVxuICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9saT5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGNvbnN0IENMQVNTX0lDT04gPSB7XG4gICAgICAgIE9QRU5FRDogXCJmYS1hbmdsZS1kb3duXCIsXG4gICAgICAgIENMT1NFRDogXCJmYS1hbmdsZS11cFwiLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaWNvbl9vcGVuZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpY29uX2Nsb3NlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbG9zZWRdICAgIHJldHVybnMgaWYgd2Ugc2hvdWxkIGFwcGx5IHRvZ2dsZSBvciBpZiBmYWxzZSAtIHJlamVjdCBpdCBhbmQgdG9nZ2xlIGJhY2t3YXJkXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGljb25fb3BlbmVkID0gQ0xBU1NfSUNPTi5PUEVORUQsXG4gICAgICAgIGljb25fY2xvc2VkID0gQ0xBU1NfSUNPTi5DTE9TRUQsXG4gICAgICAgIGNsb3NlZCxcbiAgICAgICAgb250b2dnbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCkgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY2xvc2VkID0gIWNsb3NlZDtcbiAgICAgICAgaWYgKCFvbnRvZ2dsZShjbG9zZWQpKSB7XG4gICAgICAgICAgICBjbG9zZWQgPSAhY2xvc2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG48L3NjcmlwdD5cblxuPHNwYW5cbiAgICBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtdG9nZ2xlLXN1Ym1lbnUgaXMtcHVsbGVkLXJpZ2h0XCJcbiAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgIG9ua2V5dXA9e29uQ2xpY2t9XG4gICAgcm9sZT1cImJ1dHRvblwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICA8aSBjbGFzcz1cImZhcyB7Y2xvc2VkID8gaWNvbl9jbG9zZWQgOiBpY29uX29wZW5lZH1cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG48L3NwYW4+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi8uLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlJY29uIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy9pY29uL3VpLmljb24uZm9udC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbmRpY2F0b3IgZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuaW5kaWNhdG9yLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRhZyBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS50YWcuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi8uLi9MSUIuanNcIjtcbiAgICBsZXQgeyBpdGVtID0ge30sIGNoaWxkcmVuIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIGl0ZW0uaWNvbn1cbiAgICA8VUlJY29uIHsuLi5pdGVtLmljb259IC8+XG57OmVsc2UgaWYgaXRlbS50eXBlID09PSBcImNvbXBvbmVudFwiICYmIGl0ZW0uY29tcG9uZW50ICYmIENPTVBPTkVOVFMuY29udGFpbnMoaXRlbS5jb21wb25lbnQpfVxuICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoaXRlbS5jb21wb25lbnQpfVxuICAgIDxTdmVsdGVDb21wb25lbnQgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnByb3BzfSAvPlxuezplbHNlfVxuICAgIDxzcGFuIGNsYXNzPVwiaXMtbm8tbGlua1wiPnskTE9DQUxFW2l0ZW0udGl0bGVdfTwvc3Bhbj5cbnsvaWZ9XG57I2lmIGl0ZW0udGFnfVxuICAgIDxVSVRhZyBpZD17aXRlbS5pZH0gey4uLml0ZW0udGFnfSAvPlxuey9pZn1cbnsjaWYgaXRlbS5pbmRpY2F0b3J9XG4gICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG57L2lmfVxue0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVWlfaXRlbXMgZnJvbSBcIi4vdWkuaXRlbXMuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlTaWRlTWVudUl0ZW1XaXRob3V0Q2hpbGRyZW4gZnJvbSBcIi4vdWkuaXRlbS53aXRob3V0LmNoaWxkcmVuLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJU2lkZU1lbnVUcmlnZ2VyIGZyb20gXCIuL3VpLnRyaWdnZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJU2lkZU1lbnVJdGVtTGFiZWwgZnJvbSBcIi4vdWkuaXRlbS5sYWJlbC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2xvc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbm5hdmlnYXRlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyByb290ID0gXCJcIiwgaXRlbXMgPSBbXSwgY2xvc2VkLCBvbm5hdmlnYXRlID0gKCkgPT4ge30gfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgY3JlYXRlQ2xvc2VkSXRlbXNMaWIgPSAobHN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpYiA9IHt9O1xuICAgICAgICBsc3QuZm9yRWFjaCgoaXRtLCBpbmRleCkgPT4gKGxpYltpbmRleF0gPSBpdG0uY2xvc2VkKSk7XG4gICAgICAgIHJldHVybiBsaWI7XG4gICAgfTtcblxuICAgIGxldCBjbG9zZWRDaGlsZHJlbiA9ICRzdGF0ZShjcmVhdGVDbG9zZWRJdGVtc0xpYihpdGVtcykpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvbm5hdmlnYXRlKHtcbiAgICAgICAgICAgIGZ1bGw6IGV2LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLFxuICAgICAgICAgICAgc2hvcnQ6IGV2LnRhcmdldC5kYXRhc2V0LmhyZWYsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjx1bCBjbGFzcz1cIm1lbnUtbGlzdCB7Y2xvc2VkID8gJ2lzLWNsb3NlZCcgOiAnJ31cIj5cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaW5kZXh9XG4gICAgICAgIHsjaWYgaXRlbS5pdGVtcyAmJiBpdGVtLml0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImlzLW5vLWZvbGxvdy1zdWJ0aXRsZSB7aXRlbS5jbGFzc2VzfVwiPlxuICAgICAgICAgICAgICAgIHsjaWYgdHlwZW9mIGl0ZW0udXJsICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZW0udXJsICE9PSBmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9XCJ7cm9vdH17aXRlbS51cmx9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtaHJlZj17aXRlbS51cmx9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJoYXMtc3ViaXRlbXNcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VUlTaWRlTWVudUl0ZW1MYWJlbCB7aXRlbX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFVJU2lkZU1lbnVUcmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmQ6Y2xvc2VkPXtjbG9zZWRDaGlsZHJlbltpbmRleF19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvVUlTaWRlTWVudUl0ZW1MYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgPFVJU2lkZU1lbnVJdGVtTGFiZWwge2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFVJU2lkZU1lbnVUcmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZDpjbG9zZWQ9e2Nsb3NlZENoaWxkcmVuW2luZGV4XX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvVUlTaWRlTWVudUl0ZW1MYWJlbD5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIDxVaV9pdGVtc1xuICAgICAgICAgICAgICAgICAgICB7cm9vdH1cbiAgICAgICAgICAgICAgICAgICAgaXRlbXM9e2l0ZW0uaXRlbXN9XG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6Y2xvc2VkPXtjbG9zZWRDaGlsZHJlbltpbmRleF19XG4gICAgICAgICAgICAgICAgICAgIHtvbm5hdmlnYXRlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8VUlTaWRlTWVudUl0ZW1XaXRob3V0Q2hpbGRyZW4ge3Jvb3R9IHtpdGVtfSB7b25uYXZpZ2F0ZX0gLz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG48L3VsPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlTaWRlTWVudUl0ZW1zIGZyb20gXCIuL3VpLml0ZW1zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IENPTVBPTkVOVFMgfSBmcm9tIFwiLi4vLi4vLi4vTElCLmpzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIHNlY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ubmF2aWdhdGVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHNlY3Rpb24sIGl0ZW1zID0gW10sIHJvb3QgPSBcIlwiLCBvbm5hdmlnYXRlID0gKCkgPT4ge30gfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHNlY3Rpb25JdGVtcyA9ICRkZXJpdmVkKFxuICAgICAgICBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IHNlY3Rpb24uaWQgPT09IGl0ZW0uc2VjdGlvbilcbiAgICApO1xuPC9zY3JpcHQ+XG5cbnsjaWYgc2VjdGlvbn1cbiAgICB7I2lmIHNlY3Rpb25JdGVtcy5sZW5ndGggfHwgc2VjdGlvbi5jb21wb25lbnQgfHwgc2VjdGlvbi50YWcgfHwgc2VjdGlvbi5pbmRpY2F0b3J9XG4gICAgICAgIDxwIGNsYXNzPVwibWVudS1sYWJlbCB7c2VjdGlvbi5jbGFzc2VzfVwiPlxuICAgICAgICAgICAgeyNpZiBzZWN0aW9uLnR5cGUgPT09IFwiY29tcG9uZW50XCIgJiYgc2VjdGlvbi5jb21wb25lbnQgJiYgQ09NUE9ORU5UUy5jb250YWlucyhzZWN0aW9uLmNvbXBvbmVudCl9XG4gICAgICAgICAgICAgICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBDT01QT05FTlRTLmdldChzZWN0aW9uLmNvbXBvbmVudCl9XG4gICAgICAgICAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudCBpZD17c2VjdGlvbi5pZH0gey4uLnNlY3Rpb24ucHJvcHN9IC8+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgeyRMT0NBTEVbc2VjdGlvbi50aXRsZV19XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNpZiBzZWN0aW9uLnRhZ31cbiAgICAgICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e3NlY3Rpb24uaWR9IHsuLi5zZWN0aW9uLnRhZ30gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2lmIHNlY3Rpb24uaW5kaWNhdG9yfVxuICAgICAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17c2VjdGlvbi5pZH0gey4uLnNlY3Rpb24uaW5kaWNhdG9yfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9wPlxuICAgIHsvaWZ9XG57L2lmfVxueyNpZiBzZWN0aW9uSXRlbXMubGVuZ3RofVxuICAgIDxVSVNpZGVNZW51SXRlbXMge3Jvb3R9IGl0ZW1zPXtzZWN0aW9uSXRlbXN9IHtvbm5hdmlnYXRlfSAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJU2lkZU1lbnVTZWN0aW9uIGZyb20gXCIuL3VpLnNlY3Rpb24uc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlY3Rpb25zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbmF2aWdhdGUgPSAoKT0+dW5kZWZpbmVkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyByb290ID0gXCJcIiwgaXRlbXMgPSBbXSwgc2VjdGlvbnMgPSBbXSwgbmF2aWdhdGUgPSBudWxsIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZShldik7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxueyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb259XG4gICAgPFVJU2lkZU1lbnVTZWN0aW9uIHtzZWN0aW9ufSB7aXRlbXN9IHtyb290fSBvbm5hdmlnYXRlPXtvbkNsaWNrfSAvPlxuey9lYWNofVxuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbmNvbnN0IFNpZGVNZW51U3RhdGUgPSB3cml0YWJsZSh7XG4gICAgb3BlbjogdHJ1ZSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBTaWRlTWVudVN0YXRlO1xuIiwiaW1wb3J0IE1lbnUgZnJvbSBcIi4uL21lbnUuanNcIjtcbmltcG9ydCBVSVNpZGVNZW51IGZyb20gXCIuL3VpLnNpZGUubWVudS5zdmVsdGVcIjtcblxuaW1wb3J0IFNpZGVNZW51U3RhdGUgZnJvbSBcIi4vc3RvcmUuanNcIjtcbmltcG9ydCB7IG1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBUWVBFID0gXCJzaWRlXCI7XG5cbmNsYXNzIG5vdFNpZGVNZW51IGV4dGVuZHMgTWVudSB7XG4gICAgc3RhdGljIG5hdjtcbiAgICBzdGF0aWMgbWFpbjtcbiAgICBzdGF0aWMgYXNpZGU7XG5cbiAgICBzdGF0aWMgREVGQVVMVCA9IHtcbiAgICAgICAgc2VjdGlvbjogXCJhbnlcIixcbiAgICAgICAgc2VjdGlvblRpdGxlOiBcItCc0LXQvdGOXCIsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIG9wdGlvbnMgPSB7XG4gICAgICAgIGRpcmVjdE5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICB0eXBlOiBUWVBFLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHNlY3Rpb25zOiBbXSxcbiAgICAgICAgdGFyZ2V0U2VsZWN0b3I6IGAjJHtUWVBFfS1tZW51YCxcbiAgICAgICAgdG9nZ2xlU2VsZWN0b3I6IGAuJHtUWVBFfS1tZW51LXRvZ2dsZWAsXG4gICAgICAgIHJvb3Q6IFwiL1wiLFxuICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0ZTogKHVybHMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLmVtaXQoXCJ0b3AtbmF2YmFyLWJ1cmdlcjp1cGRhdGVcIiwgeyBjbG9zZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXJlY3ROYXZpZ2F0aW9uKCkgJiYgdGhpcy5hcHApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuYXBwLmdldFdvcmtpbmcoXCJyb3V0ZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMubmF2aWdhdGUodXJscy5zaG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uYXNzaWduKHVybHMuZnVsbCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHN0YXRpYyByZW5kZXIoYXBwKSB7XG4gICAgICAgIGlmIChhcHApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXBwKGFwcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlRGF0YSgpO1xuICAgICAgICBpZiAoIXRoaXMubWVudSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVVSSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgdGhpcy5tZW51LiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVUkoKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lbnUgPSBtb3VudChVSVNpZGVNZW51LCB7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLnNlY3Rpb25zLFxuICAgICAgICAgICAgICAgIHJvb3Q6IHRoaXMuZ2V0T3B0aW9ucygpLnJvb3QsXG4gICAgICAgICAgICAgICAgbmF2aWdhdGU6IHRoaXMuZ2V0T3B0aW9ucygpLm5hdmlnYXRlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5pdFNpemVSZXNwb25zZSgpO1xuXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLnVwZGF0ZU1lbnVBY3RpdmVJdGVtLmJpbmQodGhpcyksIDIwMCk7XG4gICAgICAgIHRoaXMuYmluZFRvZ2dsZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpdGVtSXNBY3RpdmUoaXRlbVVSTCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG9jYXRpb24gKyBcIi9cIikuaW5kZXhPZihpdGVtVVJMICsgXCIvXCIpID4gLTE7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZU1lbnUoKSB7XG4gICAgICAgIEFycmF5LmZyb20oXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yICsgXCIgYVwiKVxuICAgICAgICApLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZW1Jc0FjdGl2ZShpdGVtLmdldEF0dHJpYnV0ZShcImhyZWZcIikpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVNZW51QWN0aXZlSXRlbSgpIHtcbiAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgbGFzdExvY2F0aW9uID0gdGhpcy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKGxhc3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKHVybCAhPT0gbGFzdExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0U2l6ZVJlc3BvbnNlKCkge1xuICAgICAgICB0aGlzLm5hdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJuYXYubmF2YmFyXCIpO1xuICAgICAgICB0aGlzLmFzaWRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImFzaWRlXCIpO1xuICAgICAgICB0aGlzLm1haW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWFpblwiKTtcbiAgICAgICAgdGhpcy5yZXNpemVBc2lkZUFuZE1haW4odGhpcy5hc2lkZSwgdGhpcy5tYWluLCB0aGlzLm5hdik7XG4gICAgICAgIHRoaXMucmVzaXplTWFpbih0aGlzLm1haW4sIHRoaXMuYXNpZGUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZU1haW4uYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucygpLm9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzaXplTWFpbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hc2lkZS5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMuYXNpZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1haW4uc3R5bGUuaGVpZ2h0ID09PSBcIjBweFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYWluLnN0eWxlLm1hcmdpbkxlZnQgPSByZWN0LndpZHRoICsgcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2l6ZUFzaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5hc2lkZS5zdHlsZS5kaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLm5hdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuYXNpZGUuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gcmVjdC5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLmFzaWRlLnN0eWxlLm1hcmdpblRvcCA9IHJlY3QuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHJlc2l6ZUFzaWRlQW5kTWFpbigpIHtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLm5hdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5hc2lkZS5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSByZWN0LmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgLy90aGlzLmFzaWRlLnN0eWxlLnBhZGRpbmdUb3AgPSAocmVjdC5oZWlnaHQpICsgJ3B4JztcbiAgICAgICAgLy90aGlzLm1haW4uc3R5bGUubWFyZ2luVG9wID0gKHJlY3QuaGVpZ2h0KSArICdweCc7XG4gICAgfVxuXG4gICAgc3RhdGljIGJpbmRUb2dnbGUoKSB7XG4gICAgICAgIGxldCBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZ2V0T3B0aW9ucygpLnRvZ2dsZVNlbGVjdG9yKTtcbiAgICAgICAgQXJyYXkuZnJvbShlbHMpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB0b2dnbGUoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNpemVNYWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBoaWRlKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LmFkZChcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaXplTWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIFNpZGVNZW51U3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBzaG93KGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC5hZGQoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LnJlbW92ZShcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaXplTWFpbigpO1xuICAgICAgICB9XG4gICAgICAgIFNpZGVNZW51U3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzT3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzaWRlLmNsYXNzTGlzdC5jb250YWlucyhcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmFzaWRlLmNsYXNzTGlzdC5jb250YWlucyhcImlzLWNsb3NlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RTaWRlTWVudTtcbiIsIjxzY3JpcHQ+XG4gICAgLyogZXNsaW50IHN2ZWx0ZS9uby1hdC1odG1sLXRhZ3M6IDAgKi9cbiAgICBpbXBvcnQgVUlJY29uIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy9pY29uL3VpLmljb24uc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaWNvbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdXJsID0gXCIvXCIsXG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgaWNvbiA9IHtcbiAgICAgICAgICAgIHNyYzogXCJodHRwczovL3ZpYS5wbGFjZWhvbGRlci5jb20vNTZ4MjhcIixcbiAgICAgICAgICAgIHdpZHRoOiAyOCxcbiAgICAgICAgICAgIGhlaWdodDogNTYsXG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxhIGNsYXNzPVwibmF2YmFyLWl0ZW1cIiBocmVmPXt1cmx9PlxuICAgIDxVSUljb24gey4uLmljb259IC8+XG4gICAgeyNpZiB0aXRsZX1cbiAgICAgICAge0BodG1sIGA8c3BhbiBjbGFzcz1cIm5hdmJhci1pdGVtLWJyYW5kLXRpdGxlXCI+JHt0aXRsZX08L3NwYW4+YH1cbiAgICB7L2lmfVxuPC9hPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHtMT0NBTEV9IGZyb20gJy4uLy4uLy4uLy4uL2xvY2FsZSc7XG5cbiAgaW1wb3J0IFVJSWNvbiBmcm9tICcuLi8uLi8uLi8uLi9lbGVtZW50cy9pY29uL3VpLmljb24uc3ZlbHRlJztcbiAgaW1wb3J0IFVJVGFnIGZyb20gJy4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZSc7XG4gIGltcG9ydCBVSUluZGljYXRvciBmcm9tICcuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGUnO1xuICBpbXBvcnQge0NPTVBPTkVOVFN9IGZyb20gJy4uLy4uLy4uL0xJQi5qcyc7XG4gIGxldCB7IGl0ZW0gfSA9ICRwcm9wcygpO1xuICAvKlxuICBzdHJpbmcgdGl0bGVcbiAgb2JqZWN0IGljb247XG4gIG9iamVjdCB0YWc7XG4gIHN0cmluZyB0eXBlO1xuICBDbGFzcyBjb21wb25lbnQ7XG4gIG9iamVjdCBpbmRpY2F0b3I7XG4gIG9iamVjdCBvcHRpb25zO1xuICAqL1xuXG5cbjwvc2NyaXB0PlxuXG57I2lmIGl0ZW0uaWNvbn1cbjxVSUljb24gey4uLml0ZW0uaWNvbn0gLz5cbns6ZWxzZSBpZiAoaXRlbS50eXBlPT09J2NvbXBvbmVudCcgJiYgaXRlbS5jb21wb25lbnQgJiYgQ09NUE9ORU5UUy5jb250YWlucyhpdGVtLmNvbXBvbmVudCkpIH1cbntAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoaXRlbS5jb21wb25lbnQpfVxuPFN2ZWx0ZUNvbXBvbmVudFxuICBpZD17aXRlbS5pZH1cbiAgey4uLml0ZW0ucHJvcHN9XG4gICAvPlxuezplbHNlfVxueyRMT0NBTEVbaXRlbS50aXRsZV19XG57L2lmfVxuXG57I2lmIGl0ZW0udGFnIH1cbjxVSVRhZyB0b3A9e3RydWV9IHJpZ2h0PXt0cnVlfSBzaXplPSdzbWFsbCcgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ30+PC9VSVRhZz5cbnsvaWZ9XG5cbnsjaWYgaXRlbS5pbmRpY2F0b3IgfVxuPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS5pbmRpY2F0b3J9IC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBVSUl0ZW1Db250ZW50IGZyb20gXCIuL3VpLml0ZW0uY29udGVudC5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtoaWRkZW5dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc2VzXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyByb290ID0gXCJcIiwgaXRlbSA9IHt9LCBoaWRkZW4gPSBcIlwiLCBjbGFzc2VzID0gXCJcIiB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoKFwiY2xpY2tcIiwgeyBldmVudCwgZWxlbWVudDogaXRlbSB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBpdGVtLmJyZWFrfVxuICAgIDxociBjbGFzcz1cIm5hdmJhci1kaXZpZGVyIHtoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiAnJ30gXCIgLz5cbnsvaWZ9XG5cbnsjaWYgaXRlbS51cmx9XG4gICAgPGFcbiAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuXG4gICAgICAgICAgICA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YFxuICAgICAgICAgICAgOiAnJ30ge2l0ZW0uY2xhc3Nlc30ge2NsYXNzZXN9IFwiXG4gICAgICAgIGhyZWY9XCJ7cm9vdH17aXRlbS51cmx9XCJcbiAgICAgICAgZGF0YS1ocmVmPXtpdGVtLnVybH1cbiAgICA+XG4gICAgICAgIDxVSUl0ZW1Db250ZW50IHtpdGVtfSAvPlxuICAgIDwvYT5cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIG9ua2V5dXA9e29uQ2xpY2t9XG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW0ge2hpZGRlblxuICAgICAgICAgICAgPyBgaXMtaGlkZGVuLSR7aGlkZGVufWBcbiAgICAgICAgICAgIDogJyd9IHtpdGVtLmNsYXNzZXN9IHtjbGFzc2VzfVwiXG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgID5cbiAgICAgICAgPFVJSXRlbUNvbnRlbnQge2l0ZW19IC8+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBVSUl0ZW1Db250ZW50IGZyb20gXCIuL3VpLml0ZW0uY29udGVudC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJdGVtIGZyb20gXCIuL3VpLml0ZW0uc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2hpZGRlbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtob3ZlcmFibGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYXJyb3dsZXNzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JpZ2h0XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICByb290ID0gXCJcIixcbiAgICAgICAgc2VjdGlvbiA9IHt9LFxuICAgICAgICBpdGVtcyA9IFtdLFxuICAgICAgICBoaWRkZW4gPSBcIlwiLFxuICAgICAgICBob3ZlcmFibGUgPSB0cnVlLFxuICAgICAgICBhcnJvd2xlc3MgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoKFwiY2xpY2tcIiwgeyBldmVudCwgZWxlbWVudDogc2VjdGlvbiB9KTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBpdGVtcy5sZW5ndGh9XG4gICAgPGRpdlxuICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtIGhhcy1kcm9wZG93biB7aG92ZXJhYmxlXG4gICAgICAgICAgICA/ICdpcy1ob3ZlcmFibGUnXG4gICAgICAgICAgICA6ICcnfSB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiXG4gICAgPlxuICAgICAgICA8YVxuICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgICAgIGNsYXNzPVwibmF2YmFyLWxpbmsge2Fycm93bGVzcyA/ICdpcy1hcnJvd2xlc3MnIDogJyd9XCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPFVJSXRlbUNvbnRlbnQgaXRlbT17c2VjdGlvbn0gLz5cbiAgICAgICAgPC9hPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWRyb3Bkb3duIHtyaWdodCA/ICdpcy1yaWdodCcgOiAnJ31cIj5cbiAgICAgICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgICAgICAgICA8VUlJdGVtIHtyb290fSB7aXRlbX0gb246Y2xpY2sgLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG57OmVsc2UgaWYgc2VjdGlvbi51cmx9XG4gICAgPGFcbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiXG4gICAgICAgIGhyZWY9XCJ7cm9vdH17c2VjdGlvbi51cmx9XCJcbiAgICAgICAgZGF0YS1ocmVmPXtzZWN0aW9uLnVybH1cbiAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICA+XG4gICAgICAgIDxVSUl0ZW1Db250ZW50IGl0ZW09e3NlY3Rpb259IC8+XG4gICAgPC9hPlxuezplbHNlfVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gIDogJyd9IFwiXG4gICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgIG9ua2V5dXA9e29uQ2xpY2t9XG4gICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgID5cbiAgICAgICAgPFVJSXRlbUNvbnRlbnQgaXRlbT17c2VjdGlvbn0gLz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGNvbnN0IENPTVBPTkVOVF9OQU1FID0gXCJ0b3AtbmF2YmFyLWJ1cmdlclwiO1xuXG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBTaWRlTWVudVN0b3JlIGZyb20gXCIuLi9zaWRlL3N0b3JlXCI7XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5cblxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjbG9zZWQgPSAhY2xvc2VkO1xuICAgICAgICBkaXNwYXRjaChcInRvZ2dsZVwiLCB7XG4gICAgICAgICAgICBjbG9zZWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBDT01QT05FTlRfTkFNRSArIFwiOnVwZGF0ZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtldmVudHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtyZWdpc3Rlcl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbG9zZWRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtvblVwZGF0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZXZlbnRzID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMuYmluZChub3RDb21tb24pLFxuICAgICAgICBjbG9zZWQgPSAkYmluZGFibGUodHJ1ZSksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNsb3NlZCA9IGRhdGEuY2xvc2VkO1xuICAgICAgICB9XG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyhldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuXG4gICAgU2lkZU1lbnVTdG9yZS5zdWJzY3JpYmUoKHZhbCkgPT4ge1xuICAgICAgICBjbG9zZWQgPSAhdmFsLm9wZW47XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPGFcbiAgICBocmVmXG4gICAgb25jbGljaz17dG9nZ2xlfVxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIGNsYXNzPVwibmF2YmFyLWJ1cmdlciB7Y2xvc2VkID8gJycgOiAnaXMtYWN0aXZlJ31cIlxuICAgIGFyaWEtbGFiZWw9XCJtZW51XCJcbiAgICBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIlxuICAgIGRhdGEtdGFyZ2V0PVwibmF2YmFyXCJcbj5cbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbjwvYT5cbiIsIjwhLS0gQG1pZ3JhdGlvbi10YXNrIEVycm9yIHdoaWxlIG1pZ3JhdGluZyBTdmVsdGUgY29kZTogQ2FuJ3QgbWlncmF0ZSBjb2RlIHdpdGggYmVmb3JlVXBkYXRlLiBQbGVhc2UgbWlncmF0ZSBieSBoYW5kLiAtLT5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgU2lkZU1lbnUgZnJvbSBcIi4uL3NpZGVcIjtcblxuICAgIGltcG9ydCBVSUJyYW5kIGZyb20gXCIuL3VpLmJyYW5kLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhckl0ZW0gZnJvbSBcIi4vdWkuaXRlbS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJTZWN0aW9uIGZyb20gXCIuL3VpLnNlY3Rpb24uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFyQnVyZ2VyIGZyb20gXCIuL3VpLmJ1cmdlci5zdmVsdGVcIjtcbiAgICBcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzZWN0aW9uc10gLSBpbXBvcnQgeyBiZWZvcmVVcGRhdGUgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtuYXZpZ2F0ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFticmFuZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93QnVyZ2VyXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1cmdlckNvbnRyb2xzU2lkZW1lbnVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHNlY3Rpb25zID0gW10sXG4gICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgIHJvb3QgPSBcIlwiLFxuICAgICAgICBuYXZpZ2F0ZSA9IG51bGwsXG4gICAgICAgIGJyYW5kID0gZmFsc2UsXG4gICAgICAgIHNob3dCdXJnZXIgPSB0cnVlLFxuICAgICAgICBidXJnZXJDb250cm9sc1NpZGVtZW51ID0gdHJ1ZVxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBtZW51Q2xvc2VkID0gJHN0YXRlKHRydWUpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayh7IGRldGFpbCB9KSB7XG4gICAgICAgIGxldCB7IGV2ZW50LCBlbGVtZW50IH0gPSBkZXRhaWw7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGVsZW1lbnQsIFwiYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5hY3Rpb24oZXZlbnQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbmF2aWdhdGUoe1xuICAgICAgICAgICAgICAgIGZ1bGw6IGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxcbiAgICAgICAgICAgICAgICBzaG9ydDogZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0LmhyZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHNlY3Rpb25zSXRlbXNDb3VudCA9IHt9O1xuICAgIGxldCBzZWN0aW9uc0l0ZW1zID0ge307XG4gICAgLypcbiAgICBiZWZvcmVVcGRhdGUoKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgICAgICBzZWN0aW9uc0l0ZW1zW3NlY3Rpb24uaWRdID0gaXRlbXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICh0KSA9PiB0LnNlY3Rpb24gPT09IHNlY3Rpb24uaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWN0aW9uc0l0ZW1zQ291bnRbc2VjdGlvbi5pZF0gPSBpdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHQpID0+IHQuc2VjdGlvbiA9PT0gc2VjdGlvbi5pZFxuICAgICAgICAgICAgKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9KTtcbiovXG4gICAgZnVuY3Rpb24gdG9nZ2xlQnVyZ2VyKHsgZGV0YWlsIH0pIHtcbiAgICAgICAgaWYgKGJ1cmdlckNvbnRyb2xzU2lkZW1lbnUpIHtcbiAgICAgICAgICAgIFNpZGVNZW51LnRvZ2dsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2goXCJ0b2dnbGVCdXJnZXJcIiwgZGV0YWlsKTtcbiAgICAgICAgICAgIG1lbnVDbG9zZWQgPSBkZXRhaWwuY2xvc2VkO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJuYXZiYXItYnJhbmRcIj5cbiAgICB7I2lmIGJyYW5kfVxuICAgICAgICA8VUlCcmFuZCB7Li4uYnJhbmR9IC8+XG4gICAgey9pZn1cbiAgICB7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbiAoc2VjdGlvbi5pZCl9XG4gICAgICAgIHsjaWYgc2VjdGlvbi5zaG93T25Ub3VjaH1cbiAgICAgICAgICAgIDxVSU5hdmJhckl0ZW1cbiAgICAgICAgICAgICAgICBoaWRkZW49XCJkZXNrdG9wXCJcbiAgICAgICAgICAgICAgICBpdGVtPXtzZWN0aW9ufVxuICAgICAgICAgICAgICAgIHtyb290fVxuICAgICAgICAgICAgICAgIG9uOmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgey9pZn1cbiAgICB7L2VhY2h9XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICB7I2lmIGl0ZW0uc2hvd09uVG91Y2h9XG4gICAgICAgICAgICA8VUlOYXZiYXJJdGVtIGhpZGRlbj1cImRlc2t0b3BcIiB7aXRlbX0ge3Jvb3R9IG9uOmNsaWNrPXtvbkNsaWNrfSAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbiAgICB7I2lmIHNob3dCdXJnZXJ9XG4gICAgICAgIDxVSU5hdmJhckJ1cmdlciBvbjp0b2dnbGU9e3RvZ2dsZUJ1cmdlcn0gLz5cbiAgICB7L2lmfVxuPC9kaXY+XG48ZGl2IGlkPVwibmF2YmFyXCIgY2xhc3M9XCJuYXZiYXItbWVudSB7bWVudUNsb3NlZCA/ICcnIDogJ2lzLWFjdGl2ZSd9XCI+XG4gICAgPGRpdiBjbGFzcz1cIm5hdmJhci1zdGFydFwiPlxuICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbX1cbiAgICAgICAgICAgIHsjaWYgaXRlbS5wbGFjZSA9PT0gXCJzdGFydFwifVxuICAgICAgICAgICAgICAgIDxVSU5hdmJhckl0ZW0gaGlkZGVuPVwidG91Y2hcIiB7aXRlbX0gb246Y2xpY2s9e29uQ2xpY2t9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm5hdmJhci1lbmRcIj5cbiAgICAgICAgeyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb24gKHNlY3Rpb24uaWQpfVxuICAgICAgICAgICAgeyNpZiAoc2VjdGlvbnNJdGVtc0NvdW50W3NlY3Rpb24uaWRdIHx8IHNlY3Rpb24uaW5kaWNhdG9yIHx8IHNlY3Rpb24udGFnKSAmJiBzZWN0aW9uLnBsYWNlID09IFwiZW5kXCJ9XG4gICAgICAgICAgICAgICAgPFVJTmF2YmFyU2VjdGlvblxuICAgICAgICAgICAgICAgICAgICByaWdodD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuPXtzZWN0aW9uLmhpZGRlbn1cbiAgICAgICAgICAgICAgICAgICAge3Jvb3R9XG4gICAgICAgICAgICAgICAgICAgIHtzZWN0aW9ufVxuICAgICAgICAgICAgICAgICAgICBpdGVtcz17c2VjdGlvbnNJdGVtc1tzZWN0aW9uLmlkXX1cbiAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbjwvZGl2PlxuIiwiaW1wb3J0IE1lbnUgZnJvbSBcIi4uL21lbnUuanNcIjtcbmltcG9ydCBVSU5hdmJhclRvcCBmcm9tIFwiLi91aS50b3Auc3ZlbHRlXCI7XG5pbXBvcnQgeyBtb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgVFlQRSA9IFwidG9wXCI7XG5cbmNsYXNzIG5vdFRvcE1lbnUgZXh0ZW5kcyBNZW51IHtcbiAgICBzdGF0aWMgREVGQVVMVCA9IHtcbiAgICAgICAgc2VjdGlvbjogXCJhbnlcIixcbiAgICAgICAgc2VjdGlvblRpdGxlOiBcItCc0LXQvdGOXCIsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICAvL2xpbmssIGJ1dHRvbiwgZHJvcGRvd24sIGNvbXBvbmVudFxuICAgICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgICAgcGxhY2U6IFwibWFpblwiLFxuICAgIH07XG5cbiAgICBzdGF0aWMgb3B0aW9ucyA9IHtcbiAgICAgICAgYnJhbmQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiBUWVBFLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHNlY3Rpb25zOiBbXSxcbiAgICAgICAgdGFyZ2V0U2VsZWN0b3I6IGAjJHtUWVBFfS1tZW51YCxcbiAgICAgICAgcm9vdDogXCIvXCIsXG4gICAgICAgIGRpcmVjdE5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICBuYXZpZ2F0ZTogKHVybHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlyZWN0TmF2aWdhdGlvbigpICYmIHRoaXMuYXBwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLmFwcC5nZXRXb3JraW5nKFwicm91dGVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLm5hdmlnYXRlKHVybHMuc2hvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmxvY2F0aW9uLmFzc2lnbih1cmxzLmZ1bGwpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBzdGF0aWMgcmVuZGVyKGFwcCkge1xuICAgICAgICBpZiAoYXBwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFwcChhcHApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZURhdGEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lbnUgPSBtb3VudChVSU5hdmJhclRvcCwge1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBicmFuZDogdGhpcy5nZXRPcHRpb25zKCkuYnJhbmQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uczogdGhpcy5zZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogdGhpcy5nZXRPcHRpb25zKCkucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGU6IHRoaXMuZ2V0T3B0aW9ucygpLm5hdmlnYXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnVBY3RpdmVJdGVtLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgMjAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZU1lbnUodXJsKSB7XG4gICAgICAgIEFycmF5LmZyb20oXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yICsgXCIgYXNpZGUubWVudSBhXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgKS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXRlbS5ocmVmID09IHVybCB8fFxuICAgICAgICAgICAgICAgICh1cmwuaHJlZiAmJiB1cmwuaHJlZi5pbmRleE9mKGl0ZW0uaHJlZikgPT0gMClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlTWVudUFjdGl2ZUl0ZW0oKSB7XG4gICAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGxhc3RMb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgICAgIGlmIChsYXN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh1cmwgIT09IGxhc3RMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51KHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51KHVybCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdG9nZ2xlKCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZShcImlzLWFjdGl2ZVwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaGlkZSgpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmdldE9wdGlvbnMoKS50YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldEJ1cmdlclN0YXRlKG1lbnVDbG9zZWQpIHtcbiAgICAgICAgdGhpcy5tZW51LiRzZXQoe1xuICAgICAgICAgICAgbWVudUNsb3NlZCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RUb3BNZW51O1xuIiwiY29uc3QgREVGQVVMVF9UUkFTRk9STUVSID0gKHJlcykgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0Lmhhc093bihyZXMsIFwic3RhdHVzXCIpICYmIE9iamVjdC5oYXNPd24ocmVzLCBcInJlc3VsdFwiKVxuICAgICAgICA/IHJlcy5yZXN1bHRcbiAgICAgICAgOiByZXM7XG59O1xuXG5leHBvcnQgeyBERUZBVUxUX1RSQVNGT1JNRVIgfTtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuaW1wb3J0IHsgREVGQVVMVF9UUkFTRk9STUVSIH0gZnJvbSBcIi4vY29uc3RcIjtcbmV4cG9ydCBkZWZhdWx0ICh7IEFDVElPTiwgVElUTEUsIFVJQ29uc3RydWN0b3IsIGRhdGFQcm92aWRlciwgZ29CYWNrIH0pID0+IHtcbiAgICByZXR1cm4gY2xhc3Mge1xuICAgICAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNldEJyZWFkY3J1bWJzKFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGDQn9GA0L7RgdC80L7RgtGAIFwiJHtUSVRMRX1cImAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHMoQUNUSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci51aVtBQ1RJT05dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGRhdGFQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNBc3luYyhkYXRhUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGRhdGFQcm92aWRlcihwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVByb3ZpZGVyKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0geyAuLi5kYXRhUHJvdmlkZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRUcmFuc2Zvcm1lciA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgYCR7QUNUSU9OfS50cmFuc2Zvcm1lcmAsXG4gICAgICAgICAgICAgICAgICAgIERFRkFVTFRfVFJBU0ZPUk1FUlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dID0gbmV3IFVJQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7IHBhcmFtcywgLi4ucmVzdWx0VHJhbnNmb3JtZXIoZGF0YSkgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGFmdGVyOnJlbmRlcjoke0FDVElPTn1gKTtcbiAgICAgICAgICAgICAgICBpZiAoZ29CYWNrICYmIG5vdENvbW1vbi5pc0Z1bmMoZ29CYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnVpW0FDVElPTl0ub24oXCJyZWplY3RcIiwgKCkgPT4gZ29CYWNrKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG5jb25zdCBQUkVMT0FEQUJMRSA9IFtcImNyZWF0ZVwiLCBcInVwZGF0ZVwiLCBcImxpc3RcIiwgXCJkZWxldGVcIiwgXCJkZXRhaWxzXCJdO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUlVEVmFyaWFudHNQcmVsb2FkZXIge1xuICAgIHN0YXRpYyBhc3luYyBwcmVsb2FkKGNvbnRyb2xsZXIsIHR5cGUgPSBcImxpc3RcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFQUkVMT0FEQUJMRS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcmVsb2FkID0gY29udHJvbGxlci5nZXRPcHRpb25zKGAke3R5cGV9LnByZWxvYWRgLCB7fSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJlbG9hZCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkID0gY29udHJvbGxlci5nZXRPcHRpb25zKGBwcmVsb2FkYCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByZWxvYWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbGliUHJvcHMgPSBPYmplY3Qua2V5cyhwcmVsb2FkKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsaWJQcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb2RlbE5hbWUgPSBub3RDb21tb24ubG93ZXJGaXJzdExldHRlcihwcmVsb2FkW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IE1vZGVsID0gY29udHJvbGxlci5tYWtlW21vZGVsTmFtZV0oe30pO1xuICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKE1vZGVsLiRsaXN0QWxsKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbXMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGliUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBsaWJQcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXS5zdGF0dXMgPT09IFwib2tcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShyZXN1bHRzW2ldLnJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzTGlzdCA9IHJlc3VsdHNbaV0ucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFyaWFudHMgPSByZXN1bHRzTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdmFyaWFudHMuJHt0eXBlfS4ke3Byb3BOYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmxvZyhcInByZWxvYWQgZmluaXNoZWRcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiY29uc3QgREVGQVVMVF9BQ1RJT04gPSBcImxpc3RcIjtcblxuY2xhc3Mgbm90Q1JVRFJvdXRlciB7XG4gICAgc3RhdGljIGV4dHJhY3RBY3Rpb25OYW1lKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICBsZXQgYWN0aW9uTmFtZSA9IERFRkFVTFRfQUNUSU9OO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1swXSA9PT0gXCJjcmVhdGVcIikge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBcImNyZWF0ZVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250cm9sbGVyLmFjdGlvbkhhbmRsZXJFeGlzdHMocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBwYXJhbXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBcImRldGFpbHNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1sxXSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBcImRlbGV0ZVwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXNbMV0gPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gXCJ1cGRhdGVcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IHBhcmFtc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9uTmFtZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcm91dGUoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gbm90Q1JVRFJvdXRlci5leHRyYWN0QWN0aW9uTmFtZShcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnJ1bkFjdGlvbihhY3Rpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q1JVRFJvdXRlcjtcbiIsImltcG9ydCB7IFVJU3VjY2VzcywgVUlFcnJvciB9IGZyb20gXCIuLi8uLi9lbGVtZW50cy9ub3RpZmljYXRpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1JVRE1lc3NhZ2Uge1xuICAgIHN0YXRpYyBlcnJvcihjb250cm9sbGVyLCB0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICBjb250cm9sbGVyLnNldFVJKFxuICAgICAgICAgICAgXCJfX21lc3NhZ2VfX1wiLFxuICAgICAgICAgICAgbmV3IFVJRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBwcm9wczogeyB0aXRsZSwgbWVzc2FnZSB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3VjY2Vzcyhjb250cm9sbGVyLCB0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICBjb250cm9sbGVyLnNldFVJKFxuICAgICAgICAgICAgXCJfX21lc3NhZ2VfX1wiLFxuICAgICAgICAgICAgbmV3IFVJU3VjY2Vzcyh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7IHRpdGxlLCBtZXNzYWdlIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IG5vdExvY2FsZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9sb2NhbGVcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IHsgbm90Rm9ybSB9IGZyb20gXCIuLi8uLi8uLi9jb21wb25lbnRzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1RSQVNGT1JNRVIgfSBmcm9tIFwiLi4vLi4vY29uc3RcIjtcbmltcG9ydCB7IE5BVklHQVRJT05fREVMQVlfREVGQVVMVCB9IGZyb20gXCIuLi8uLi8uLi9jb25zdFwiO1xuaW1wb3J0IHsgbW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbmNvbnN0IERFRkFVTFRfQlJFQURDUlVNQl9UQUlMID0gXCLQn9GA0L7RgdC80L7RgtGAXCI7XG5cbi8qKlxuICogR2VuZXJpYyBDUlVEIGFjdGlvbiBjbGFzc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIENSVURHZW5lcmljQWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IE5BVklHQVRJT05fREVMQVkoKSB7XG4gICAgICAgIHJldHVybiBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYnJlYWRjcnVtYnMgdGFpbCB0ZW1wbGF0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgZGVhZnVsdEJyZWFkY3J1bWJzVGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfQlJFQURDUlVNQl9UQUlMO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpYmFyYXJ5IG9mIGJyZWFkY3J1bWJzIHRhaWxzIHN0cmluZ3MgdGVtcGxhdGVzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGJyZWFkY3J1bWJzVGFpbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVzZXQ6IERFRkFVTFRfQlJFQURDUlVNQl9UQUlMLFxuICAgICAgICAgICAgc2V0OiAn0J/RgNC+0YHQvNC+0YLRgCwgXCJ7OnRpdGxlfVwiJyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRlbXBsYXRlIG9mIGJyZWFkY3J1bWJzIHRhaWxcbiAgICAgKiBAcGFyYW0gICB7c3RyaW5nfSAgICBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gICAgdGVtcGxhdGUgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGdldEJyZWFkY3J1bWJzVGFpbChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5icmVhZGNydW1ic1RhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm90Q29tbW9uLnNlbGVjdChcbiAgICAgICAgICAgIHRoaXMuYnJlYWRjcnVtYnNUYWlscyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0aGlzLmRlYWZ1bHRCcmVhZGNydW1ic1RhaWxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBBQ1RJT04gdGhpcyBjb250cm9sbGVyIGFjdGlvbiBuYW1lLCB1c2VkIGluIFVSSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQUNUSU9OKCkge1xuICAgICAgICByZXR1cm4gXCJkZXRhaWxzXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX0dFVCgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2V0XCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT04gICAgbmV0d29yayBtb2RlbCBpbnRlcmZhY2UgYWN0aW9uIG5hbWUsIHVzZWQgaW4gQVBJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNT0RFTF9BQ1RJT05fUFVUKCkge1xuICAgICAgICByZXR1cm4gXCJnZXRcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtvYmplY3R9IFVJQ29uc3RydWN0b3IgICAgY29uc3RydWN0b3Igb2YgVUkgY29tcG9uZW50XG4gICAgICovXG4gICAgc3RhdGljIGdldCBVSUNvbnN0cnVjdG9yKCkge1xuICAgICAgICByZXR1cm4gbm90Rm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7ZnVuY3Rpb259ICAgVFJBTlNGT1JNRVIgICAgIHJlc3BvbnNlLnJlc3VsdCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiBpZiB3YW50IHRvIGNoYW5nZSBpdCdzIHN0cnVjdHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgVFJBTlNGT1JNRVIoKSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX1RSQVNGT1JNRVI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmFtZSBvZiBtb2RlbCBpZGVudGlmaWNhaXRvbiBmaWVsZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICBkZWZhdWx0IGlkIGZpZWxkIG5hbWUgaXMgJ19pZCdcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SWRGaWVsZChjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059LmlkRmllbGRgLCBcIl9pZFwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbG9hZERhdGFRdWVyeShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaWRGaWVsZCA9IHRoaXMuZ2V0SWRGaWVsZChjb250cm9sbGVyKTtcbiAgICAgICAgcmV0dXJuIHsgW2lkRmllbGRdOiBwYXJhbXNbMF0gfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gUHJvbWlzZSBvZiBBUEkgcmVwb25zZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGFycmF5IG9mIHN0cmluZ3MgcGFyc2VkIGZyb20gVVJJIGJ5IHJvdXRlciBhbmQgcGFzc2VkIHRvIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gICBBUEkgcmVzcG9uc2Uge3N0YXR1czpzdHJpbmcsIHJlc3VsdDphbnksIG1lc3NhZ2U6c3RyaW5nLCBlcnJvcnM6IHtbZmllbGRuYW1lXTpbLi4uZXJyb3JNZXNzYWdlc119fVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLmxvYWREYXRhUXVlcnkoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0TW9kZWxBY3Rpb25OYW1lKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgY29udHJvbGxlci5nZXRNb2RlbChxdWVyeSlbYCQke2FjdGlvbk5hbWV9YF0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1vZGVsIEFQSSBhY3Rpb24gbmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICBuZXR3b3JrIGludGVyZmFjZSBtb2RlbCBhY3Rpb24gbmFtZSwgZm9yIEFQSTsgZGVmYXVsdDogdGhpcy5NT0RFTF9BQ1RJT05fR0VUXG4gICAgICovXG4gICAgc3RhdGljIGdldE1vZGVsQWN0aW9uTmFtZShjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmdldE9wdGlvbnMoXG4gICAgICAgICAgICBgJHt0aGlzLkFDVElPTn0uYWN0aW9uTmFtZWAsXG4gICAgICAgICAgICB0aGlzLk1PREVMX0FDVElPTl9HRVRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGJyZWFkY3J1bWJzIHRhaWwsIHdpdGhvdXQgcmVzdWx0IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBwcmVzZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuZ2V0QnJlYWRjcnVtYnNUYWlsKFwicHJlc2V0XCIpLFxuICAgICAgICAgICAgICAgIHVybDogY29udHJvbGxlci5nZXRNb2RlbEFjdGlvblVSTChwYXJhbXNbMF0sIGZhbHNlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRUaXRsZShjb250b2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRvbGxlci5nZXRJdGVtVGl0bGUocmVzcG9uc2UucmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGJyZWFkY3J1bWJzIHRhaWwgd2l0aCByZXNwb25zZSBkZXRhaWxzLCBha2EgdGl0bGUgb2YgbG9hZGVkIGl0ZW1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlICAgICBBUEkgcmVzcG9uc2UgaW4gd3JhcHBlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZS5yZXN1bHQgIEFQSSByZXNwb25zZSByZXN1bHRcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGJyZWFkY3J1bWJzVGFpbFRlbXBsYXRlID0gdGhpcy5nZXRCcmVhZGNydW1ic1RhaWwoXCJzZXRcIik7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0QnJlYWRjcnVtYnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBicmVhZGNydW1ic1RhaWxUZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICA/IG5vdExvY2FsZS5mb3JtYXQoYnJlYWRjcnVtYnNUYWlsVGVtcGxhdGUsIHsgdGl0bGUgfSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aXRsZSxcbiAgICAgICAgICAgICAgICB1cmw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxBY3Rpb25VUkwocGFyYW1zWzBdLCBmYWxzZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgcmVzcG9uc2Ugb24gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZS5zdGF0dXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICB0cnVlIGlmIHJlc3BvbnNlIGlzIGJhZFxuICAgICAqL1xuICAgIHN0YXRpYyBpc1Jlc3BvbnNlQmFkKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2UgfHwgcmVzcG9uc2Uuc3RhdHVzICE9PSBcIm9rXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFZhbGlkYXRvcnMoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGNvbnRyb2xsZXIuZ2V0VmFsaWRhdG9ycyAmJiBjb250cm9sbGVyLmdldFZhbGlkYXRvcnMoKSkgfHxcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhcIlZhbGlkYXRvcnNcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9iamVjdCB3aXRoIGFsbCBvcHRpb25zIG5lZWRlZCB0byBpbml0aWFsaXplIFVJIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAgICAgQVBJIHJlcG9uc2Ugb2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH0gICAgdWkgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgcHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzQWN0aW9uTmFtZSA9IHRoaXMuZ2V0TW9kZWxBY3Rpb25OYW1lKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBtb2RlbDogY29udHJvbGxlci5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGRldGFpbHNBY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIG5hbWU6IGAke2NvbnRyb2xsZXIuZ2V0TmFtZSgpfS4ke3RoaXMuQUNUSU9OfUZvcm1gLFxuICAgICAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IHRoaXMuZ2V0VmFsaWRhdG9ycyhjb250cm9sbGVyKSxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogY29udHJvbGxlci5nZXRPcHRpb25zKGB2YXJpYW50cy4ke3RoaXMuQUNUSU9OfWAsIHt9KSxcbiAgICAgICAgICAgICAgICBtYXN0ZXJzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059Lm1hc3RlcnNgLCB7fSksXG4gICAgICAgICAgICAgICAgaW5qZWN0ZWQ6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0uaW5qZWN0ZWRgLCB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogdGhpcy5UUkFOU0ZPUk1FUihyZXNwb25zZS5yZXN1bHQpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgdGhpcyBhY3Rpb24gVUkgY29tcG9uZW50IGZyb20gY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9ICAgIGluc3RhbmNlIG9mIFVJIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRVSShjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmdldFVJKHRoaXMuQUNUSU9OKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFVJIG9mIHRoaXMgYWN0aW9uIGluIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdWkgICAgICAgICAgIGluc3RhbmNlIG9mIFVJIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRVSShjb250cm9sbGVyLCB1aSkge1xuICAgICAgICBjb250cm9sbGVyLnNldFVJKHRoaXMuQUNUSU9OLCB1aSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgdmlhIGAuJHNldGAgbWV0aG9kIGBsb2FkaW5nYCB0byBgdHJ1ZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vY29udHJvbGxlci5jcnVkJyl9IGNvbnRyb2xsZXJcbiAgICAgKiBAbWVtYmVyb2YgQ1JVREdlbmVyaWNBY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VUlMb2FkaW5nKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5nZXRVSShjb250cm9sbGVyKS4kc2V0KHsgbG9hZGluZzogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyB2aWEgYC4kc2V0YCBtZXRob2QgYGxvYWRpbmdgIHRvIGBmYWxzZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vY29udHJvbGxlci5jcnVkJyl9IGNvbnRyb2xsZXJcbiAgICAgKiBAbWVtYmVyb2YgQ1JVREdlbmVyaWNBY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VUlMb2FkZWQoY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmdldFVJKGNvbnRyb2xsZXIpLiRzZXQoeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyB2aWEgYC4kc2V0YCBtZXRob2QgYGVycm9yYCB0byBgbWVzc2FnZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vY29udHJvbGxlci5jcnVkJyl9IGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0gICB7RXJyb3J9IG1lc3NhZ2UgICAgIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAbWVtYmVyb2YgQ1JVREdlbmVyaWNBY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0VUlFcnJvcihjb250cm9sbGVyLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZ2V0VUkoY29udHJvbGxlcikuJHNldCh7IGVycm9yOiBtZXNzYWdlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGV2ZW50cyB0byBhY3Rpb24gVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlICAgICBBUEkgcmVzcG9uc2VcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdGF0aWMgYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5nb0JhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwicmVqZWN0XCIsICgpID0+IGNvbnRyb2xsZXIuZ29CYWNrKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZCBldmVudCBoYW5kbGVyIG5hbWVkIGV2ZW50IHRvIFVJLiBDaGVja3MgZGlmZmVyZW50IGJpbmRlciBub3RhdGlvbiAkb24vb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgICAgICAgIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAgIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIGV2ZW50XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFVJRXZlbnQoY29udHJvbGxlciwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHVpID0gdGhpcy5nZXRVSShjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKHVpLiRvbikge1xuICAgICAgICAgICAgcmV0dXJuIHVpLiRvbihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5vbikge1xuICAgICAgICAgICAgcmV0dXJuIHVpLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cnVlLCBpZiBVSSBvZiB0aGlzIGFjdGlvbiBhbHJlYWR5IGV4aXN0cyxcbiAgICAgKiBmYWxzZSwgaWYgVUkgb2YgdGhpcyBhY3Rpb24gd2Fzbid0IGV4aXN0ZWQgYW5kIG90aGVyIFVJcyB3ZXJlIGRlc3RvcnllZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgIHRydWUgaWYgVUkgb2YgdGhpcyBhY3Rpb24gZXhpc3RzLCBmYWxzZSBpZiBVSSBvZiBvdGhlciB3YXMgZGVzdHJveWVkXG4gICAgICovXG4gICAgc3RhdGljIGlzVUlSZW5kZXJlZChjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFVJKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuJGRlc3Ryb3lVSSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdHdlYWtVSU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVUkodWlDb21wb25lbnQsIGNvbnRyb2xsZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKHVpQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vdW50KFxuICAgICAgICAgICAgICAgIHVpQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHRoaXMudHdlYWtVSU9wdGlvbnModGhpcy5wcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHVpQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIHRoaXMudHdlYWtVSU9wdGlvbnModGhpcy5wcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtaW5nIGFjdGlvbiBwcmVwYXJhdGlvbiBhbmQgcmVuZGVycyBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBydW4oY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSBzdGFydGluZ1xuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBiZWZvcmU6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vaWYgVUkgZm9yIHRoaXMgYWN0aW9uIGV4aXN0cyBleGl0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VJUmVuZGVyZWQoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2luZGljYXRpbmcgdGhhdCB3ZSBhcmUgd29ya2luZ1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICAgICAgLy9wcmVsb2FkaW5nIGZvcm0gdmFyaWFudHNcbiAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKHRoaXMuQUNUSU9OKTtcbiAgICAgICAgICAgIC8vc2V0dGluZyBpbml0aWFsIHN0YXRlIG9mIGJyZWFkY3J1bWJzIHRhaWxcbiAgICAgICAgICAgIHRoaXMucHJlc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vbG9hZGluZyBkYXRhXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlIGlmIHJlc3BvbnNlIGlzICdiYWQnXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jlc3BvbnNlQmFkKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cGRhdGluZyBicmVhZGNydW1icyB0YWlsIHdpdGggbW9yZSBkZXRhaWxzIGZyb20gcmVzcG9uc2VcbiAgICAgICAgICAgIHRoaXMuc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2NyZWF0aW5nIGFjdGlvbiBVSSBjb21wb25lbnRcbiAgICAgICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICBjb25zdCB1aUNvbXBvbmVudCA9IHRoaXMuVUlDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICBjb25zdCB1aSA9IHRoaXMuY3JlYXRlVUkoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VUkoY29udHJvbGxlcik7XG4gICAgICAgICAgICAvL2JpbmQgZXZlbnRzIHRvIFVJXG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHJlYWR5XG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGFmdGVyOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvL2luZm9ybWluZyBhYm91dCBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgZXhjZXB0aW9uOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcywgZSk7XG4gICAgICAgICAgICAvL3JlcG9ydGluZyBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnb0JhY2tBZnRlckRlbGF5KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5nb0JhY2sodGhpcy5OQVZJR0FUSU9OX0RFTEFZKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ29CYWNrKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5nb0JhY2soMCk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUlVER2VuZXJpY0FjdGlvbjtcbiIsImltcG9ydCBDUlVER2VuZXJpY0FjdGlvbiBmcm9tIFwiLi9hY3Rpb25cIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vblwiO1xuY29uc3QgQUNUSU9OID0gXCJjcmVhdGVcIjtcbmNvbnN0IERFRkFVTFRfQlJFQURDUlVNQl9UQUlMID0gXCLQodC+0LfQtNCw0L3QuNC1XCI7XG5cbmNsYXNzIENSVURHZW5lcmljQWN0aW9uQ3JlYXRlIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb24ge1xuICAgIHN0YXRpYyBnZXQgZGVhZnVsdEJyZWFkY3J1bWJzVGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfQlJFQURDUlVNQl9UQUlMO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgYnJlYWRjcnVtYnNUYWlscygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IEFDVElPTigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT04gICAgbmV0d29yayBtb2RlbCBpbnRlcmZhY2UgYWN0aW9uIG5hbWUsIHVzZWQgaW4gQVBJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNT0RFTF9BQ1RJT05fR0VUKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OICAgIG5ldHdvcmsgbW9kZWwgaW50ZXJmYWNlIGFjdGlvbiBuYW1lLCB1c2VkIGluIEFQSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgTU9ERUxfQUNUSU9OX1BVVCgpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9jb250cm9sbGVyLmNydWQnKX0gY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7YW55fSAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYW1zXVxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoJ25vdC1ub2RlL3NyYy90eXBlcycpLm5vdEFwcFJlc3BvbnNlfVxuICAgICAqL1xuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGxvYWREYXRhKGNvbnRyb2xsZXIsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBkZWZEYXRhID0gY29udHJvbGxlci5jcmVhdGVEZWZhdWx0KCk7XG4gICAgICAgIGlmIChkZWZEYXRhLmdldERhdGEpIHtcbiAgICAgICAgICAgIGRlZkRhdGEgPSBkZWZEYXRhLmdldERhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGRlZkRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFRpdGxlKGNvbnRvbGxlciwgcGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gY29udG9sbGVyLmdldEl0ZW1UaXRsZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0TW9kZWxBY3Rpb25OYW1lKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBtb2RlbDogY29udHJvbGxlci5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogYCR7Y29udHJvbGxlci5nZXROYW1lKCl9LiR7dGhpcy5BQ1RJT059Rm9ybWAsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogdGhpcy5nZXRWYWxpZGF0b3JzKGNvbnRyb2xsZXIpLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYHZhcmlhbnRzLiR7dGhpcy5BQ1RJT059YCwge30pLFxuICAgICAgICAgICAgICAgIG1hc3RlcnM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0ubWFzdGVyc2AsIHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLlRSQU5TRk9STUVSKHJlc3BvbnNlKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBldmVudHMgdG8gYWN0aW9uIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcmVzcG9uc2VdICAgICBBUEkgcmVzcG9uc2VcbiAgICAgKi9cbiAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBiaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhjb250cm9sbGVyLmdvQmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnQoY29udHJvbGxlciwgXCJyZWplY3RcIiwgKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmdvQmFjayhjb250cm9sbGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInN1Ym1pdFwiLCBhc3luYyAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgY29udHJvbGxlci5vbkFjdGlvblN1Ym1pdCh0aGlzLkFDVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmxvYWREYXRhUXVlcnkoY29udHJvbGxlciwgcGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZXYuZGV0YWlsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29CYWNrQWZ0ZXJEZWxheShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREdlbmVyaWNBY3Rpb25DcmVhdGU7XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb25DcmVhdGUgZnJvbSBcIi4vZ2VuZXJpYy9jcmVhdGVcIjtcblxuY2xhc3MgQ1JVREFjdGlvbkNyZWF0ZSBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uQ3JlYXRlIHt9XG5cbmV4cG9ydCBkZWZhdWx0IENSVURBY3Rpb25DcmVhdGU7XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb24gZnJvbSBcIi4vYWN0aW9uXCI7XG5cbi8qKlxuICogR2VuZXJpYyBDUlVEIERldGFpbHMgYWN0aW9uIGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgQ1JVREdlbmVyaWNBY3Rpb25SZWFkIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb24ge1xuICAgIHN0YXRpYyB0d2Vha1VJT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMub3B0aW9ucy51aSA9IHtcbiAgICAgICAgICAgIHN1Ym1pdDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybWluZyBhY3Rpb24gcHJlcGFyYXRpb24gYW5kIHJlbmRlcnMgVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcnVuKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgc3RhcnRpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYmVmb3JlOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2lmIFVJIGZvciB0aGlzIGFjdGlvbiBleGlzdHMgZXhpdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVSVJlbmRlcmVkKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pbmRpY2F0aW5nIHRoYXQgd2UgYXJlIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgICAgIC8vcHJlbG9hZGluZyBmb3JtIHZhcmlhbnRzXG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnByZWxvYWRWYXJpYW50cyh0aGlzLkFDVElPTik7XG4gICAgICAgICAgICAvL3NldHRpbmcgaW5pdGlhbCBzdGF0ZSBvZiBicmVhZGNydW1icyB0YWlsXG4gICAgICAgICAgICB0aGlzLnByZXNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2xvYWRpbmcgZGF0YVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmxvYWREYXRhKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZSBpZiByZXNwb25zZSBpcyAnYmFkJ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNwb25zZUJhZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRpbmcgYnJlYWRjcnVtYnMgdGFpbCB3aXRoIG1vcmUgZGV0YWlscyBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLnNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9jcmVhdGluZyBhY3Rpb24gVUkgY29tcG9uZW50XG4gICAgICAgICAgICBjb25zdCB1aUNvbXBvbmVudCA9IHRoaXMuVUlDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHRoaXMuc2V0VUkoXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBuZXcgdWlDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlYWtVSU9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy9iaW5kIGV2ZW50cyB0byBVSVxuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSByZWFkeVxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBhZnRlcjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pbmZvcm1pbmcgYWJvdXQgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGV4Y2VwdGlvbjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIGUpO1xuICAgICAgICAgICAgLy9yZXBvcnRpbmcgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENSVURHZW5lcmljQWN0aW9uUmVhZDtcbiIsImltcG9ydCBDUlVER2VuZXJpY0FjdGlvblJlYWQgZnJvbSBcIi4vZ2VuZXJpYy9yZWFkXCI7XG5cbi8qKlxuICogQ1JVRCBhY3Rpb24gZGV0YWlsc1xuICovXG5jbGFzcyBDUlVEQWN0aW9uRGV0YWlscyBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uUmVhZCB7fVxuXG5leHBvcnQgZGVmYXVsdCBDUlVEQWN0aW9uRGV0YWlscztcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IENSVURHZW5lcmljQWN0aW9uIGZyb20gXCIuL2FjdGlvblwiO1xuXG5jb25zdCBERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCA9IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjQtVwiO1xuLyoqXG4gKiBHZW5lcmljIENSVUQgVXBkYXRlIGFjdGlvbiBjbGFzc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIENSVURHZW5lcmljQWN0aW9uVXBkYXRlIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYnJlYWRjcnVtYnMgdGFpbCB0ZW1wbGF0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgZGVhZnVsdEJyZWFkY3J1bWJzVGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfQlJFQURDUlVNQl9UQUlMO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpYmFyYXJ5IG9mIGJyZWFkY3J1bWJzIHRhaWxzIHN0cmluZ3MgdGVtcGxhdGVzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGJyZWFkY3J1bWJzVGFpbHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVzZXQ6IERFRkFVTFRfQlJFQURDUlVNQl9UQUlMLFxuICAgICAgICAgICAgc2V0OiBgJHtERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTH06IFwiezp0aXRsZX1cImAsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBBQ1RJT04gdGhpcyBjb250cm9sbGVyIGFjdGlvbiBuYW1lLCB1c2VkIGluIFVSSVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQUNUSU9OKCkge1xuICAgICAgICByZXR1cm4gXCJ1cGRhdGVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTl9HRVQgICAgbmV0d29yayBtb2RlbCBpbnRlcmZhY2UgYWN0aW9uIG5hbWUsIHVzZWQgaW4gQVBJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNT0RFTF9BQ1RJT05fR0VUKCkge1xuICAgICAgICByZXR1cm4gXCJnZXRSYXdcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTl9QVVQgICAgbmV0d29yayBtb2RlbCBpbnRlcmZhY2UgYWN0aW9uIG5hbWUsIHVzZWQgaW4gQVBJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNT0RFTF9BQ1RJT05fUFVUKCkge1xuICAgICAgICByZXR1cm4gXCJ1cGRhdGVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9iamVjdCB3aXRoIGFsbCBvcHRpb25zIG5lZWRlZCB0byBpbml0aWFsaXplIFVJIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSAgICAgQVBJIHJlcG9uc2Ugb2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH0gICAgdWkgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgcHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBtb2RlbDogY29udHJvbGxlci5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuTU9ERUxfQUNUSU9OX1BVVCwgLy93aWxsIGJlIHVzZWQgdG8gZ2V0IGZvcm0gZmllbGRzIGluZm9ybWF0aW9uIGZyb20gbWFuaWZlc3RcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtjb250cm9sbGVyLmdldE5hbWUoKX0uJHt0aGlzLkFDVElPTn1Gb3JtYCxcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB0aGlzLmdldFZhbGlkYXRvcnMoY29udHJvbGxlciksXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgdmFyaWFudHMuJHt0aGlzLkFDVElPTn1gLCB7fSksXG4gICAgICAgICAgICAgICAgdWk6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0udWlgLCB7fSksXG4gICAgICAgICAgICAgICAgZmllbGRzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059LmZpZWxkc2AsIHt9KSxcbiAgICAgICAgICAgICAgICBtYXN0ZXJzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dGhpcy5BQ1RJT059Lm1hc3RlcnNgLCB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogdGhpcy5UUkFOU0ZPUk1FUihub3RDb21tb24uc3RyaXBQcm94eShyZXNwb25zZS5yZXN1bHQpKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBldmVudHMgdG8gYWN0aW9uIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcmVzcG9uc2VdICAgICBBUEkgcmVzcG9uc2VcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdGF0aWMgYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5nb0JhY2spKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwicmVqZWN0XCIsICgpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5nb0JhY2soY29udHJvbGxlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoY29udHJvbGxlci5vbkFjdGlvblN1Ym1pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnQoY29udHJvbGxlciwgXCJzdWJtaXRcIiwgYXN5bmMgKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQodGhpcy5BQ1RJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5sb2FkRGF0YVF1ZXJ5KGNvbnRyb2xsZXIsIHBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLmV2LmRldGFpbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvQmFja0FmdGVyRGVsYXkoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0cnVlLCBpZiBVSSBvZiB0aGlzIGFjdGlvbiBhbHJlYWR5IGV4aXN0cyxcbiAgICAgKiBmYWxzZSwgaWYgVUkgb2YgdGhpcyBhY3Rpb24gd2Fzbid0IGV4aXN0ZWQgYW5kIG90aGVyIFVJcyB3ZXJlIGRlc3RvcnllZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgIHRydWUgaWYgVUkgb2YgdGhpcyBhY3Rpb24gZXhpc3RzLCBmYWxzZSBpZiBVSSBvZiBvdGhlciB3YXMgZGVzdHJveWVkXG4gICAgICovXG4gICAgc3RhdGljIGlzVUlSZW5kZXJlZChjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFVJKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuJGRlc3Ryb3lVSSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtaW5nIGFjdGlvbiBwcmVwYXJhdGlvbiBhbmQgcmVuZGVycyBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBydW4oY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSBzdGFydGluZ1xuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBiZWZvcmU6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgW3BhcmFtc10pO1xuICAgICAgICAgICAgLy9pZiBVSSBmb3IgdGhpcyBhY3Rpb24gZXhpc3RzIGV4aXRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVUlSZW5kZXJlZChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaW5kaWNhdGluZyB0aGF0IHdlIGFyZSB3b3JraW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgICAgICAvL3ByZWxvYWRpbmcgZm9ybSB2YXJpYW50c1xuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHModGhpcy5BQ1RJT04pO1xuICAgICAgICAgICAgLy9zZXR0aW5nIGluaXRpYWwgc3RhdGUgb2YgYnJlYWRjcnVtYnMgdGFpbFxuICAgICAgICAgICAgdGhpcy5wcmVzZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9sb2FkaW5nIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5sb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2UgaWYgcmVzcG9uc2UgaXMgJ2JhZCdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2VCYWQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0aW5nIGJyZWFkY3J1bWJzIHRhaWwgd2l0aCBtb3JlIGRldGFpbHMgZnJvbSByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5zZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vY3JlYXRpbmcgYWN0aW9uIFVJIGNvbXBvbmVudFxuICAgICAgICAgICAgY29uc3QgdWlDb21wb25lbnQgPSB0aGlzLlVJQ29uc3RydWN0b3I7XG4gICAgICAgICAgICB0aGlzLnNldFVJKFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgbmV3IHVpQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vYmluZCBldmVudHMgdG8gVUlcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgcmVhZHlcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYWZ0ZXI6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pbmZvcm1pbmcgYWJvdXQgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGV4Y2VwdGlvbjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMsIGUpO1xuICAgICAgICAgICAgLy9yZXBvcnRpbmcgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENSVURHZW5lcmljQWN0aW9uVXBkYXRlO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uVXBkYXRlIGZyb20gXCIuL2dlbmVyaWMvdXBkYXRlXCI7XG5cbi8qKlxuICogQ1JVRCBhY3Rpb24gdXBkYXRlXG4gKi9cbmNsYXNzIENSVURBY3Rpb25VcGRhdGUgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSB7fVxuXG5leHBvcnQgZGVmYXVsdCBDUlVEQWN0aW9uVXBkYXRlO1xuIiwiaW1wb3J0IG5vdEFjdGlvblVJIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2FjdGlvbi9hY3Rpb24udWkuanNcIjtcblxuY29uc3QgQUNUSU9OID0gXCJkZWxldGVcIjtcbmNvbnN0IE1PREVMX0FDVElPTiA9IFwiZGVsZXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENSVURBY3Rpb25EZWxldGUge1xuICAgIHN0YXRpYyBhc3luYyBydW4oY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci51aVtBQ1RJT05dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLiRkZXN0cm95VUkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dID0gbmV3IG5vdEFjdGlvblVJKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNSVUREZWxldGVcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBsb2FkZXJBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlclN0eWxlOiBcImNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgICAgICBsb2FkZXJUaXRsZTogXCJub3Qtbm9kZTpjcnVkX2RlbGV0ZV9hY3Rpb25fd2FpdGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBgY3J1ZC1kZWxldGUtYWN0aW9uLSR7cGFyYW1zWzBdfWAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250cm9sbGVyLnNldEJyZWFkY3J1bWJzKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcItCj0LTQsNC70LXQvdC40LVcIixcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjb250cm9sbGVyLmdldE1vZGVsQWN0aW9uVVJMKHBhcmFtc1swXSwgQUNUSU9OKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maXJtKFwi0KPQtNCw0LvQuNGC0Ywg0LfQsNC/0LjRgdGMP1wiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUFjdGlvbk5hbWUgPSBjb250cm9sbGVyLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIGAke0FDVElPTn0uYWN0aW9uTmFtZWAsXG4gICAgICAgICAgICAgICAgICAgIE1PREVMX0FDVElPTlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUFjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogcGFyYW1zWzBdLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmdvTGlzdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmdvTGlzdCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IG5vdFRhYmxlIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudHNcIjtcblxuY29uc3QgQUNUSU9OID0gXCJsaXN0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENSVURBY3Rpb25MaXN0IHtcbiAgICBzdGF0aWMgdHdlYWtBY3Rpb25zTGlzdChjb250cm9sbGVyLCBBQ1RJT05TX0xJU1QpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHtBQ1RJT059LmNyZWF0ZUFjdGlvbmAsIHRydWUpKSB7XG4gICAgICAgICAgICBBQ1RJT05TX0xJU1QucHVzaCh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwi0KHQvtC30LTQsNGC0YxcIixcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IGNvbnRyb2xsZXIuZ29DcmVhdGUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBQ1RJT05TX0xJU1Q7XG4gICAgfVxuXG4gICAgc3RhdGljIHR3ZWFrVUlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29udHJvbGxlci5jcnVkJykuZGVmYXVsdH0gY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF1cbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFthY3Rpb25zPVtcImRldGFpbHNcIiwgXCJ1cGRhdGVcIiwgXCJkZWxldGVcIl1dXG4gICAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBbcHJlcGVuZD1bXV1cbiAgICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IFthcHBlbmQ9W11dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb25seUljb25zPXRydWVdXG4gICAgICogQHJldHVybiB7QXJyYXk8b2JqZWN0Pn1cbiAgICAgKiBAbWVtYmVyb2YgQ1JVREFjdGlvbkxpc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQWN0aW9uc0J1dHRvbnMoXG4gICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWxheSA9IDAsXG4gICAgICAgIGFjdGlvbnMgPSBbXCJkZXRhaWxzXCIsIFwidXBkYXRlXCIsIFwiZGVsZXRlXCJdLFxuICAgICAgICBwcmVwZW5kID0gW10sXG4gICAgICAgIGFwcGVuZCA9IFtdLFxuICAgICAgICBvbmx5SWNvbnMgPSB0cnVlXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IEFDVElPTlMgPSB7XG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBjb250cm9sbGVyLmdvRGV0YWlscyh2YWx1ZSwgZGVsYXkpLFxuICAgICAgICAgICAgICAgIC4uLihvbmx5SWNvbnNcbiAgICAgICAgICAgICAgICAgICAgPyB7IGljb246IFwiY2lyY2xlLWluZm9cIiB9XG4gICAgICAgICAgICAgICAgICAgIDogeyB0aXRsZTogXCLQn9C+0LTRgNC+0LHQvdC10LVcIiB9KSxcbiAgICAgICAgICAgICAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBjb250cm9sbGVyLmdvVXBkYXRlKHZhbHVlLCBkZWxheSksXG4gICAgICAgICAgICAgICAgLi4uKG9ubHlJY29ucyA/IHsgaWNvbjogXCJlZGl0XCIgfSA6IHsgdGl0bGU6IFwi0JjQt9C80LXQvdC40YLRjFwiIH0pLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIndhcm5pbmdcIixcbiAgICAgICAgICAgICAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAoKSA9PiBjb250cm9sbGVyLmdvRGVsZXRlKHZhbHVlLCBkZWxheSksXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgLi4uKG9ubHlJY29ucyA/IHsgaWNvbjogXCJ0cmFzaFwiIH0gOiB7IHRpdGxlOiBcItCj0LTQsNC70LjRgtGMXCIgfSksXG4gICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIm91dGxpbmVkXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3Rpb25zQnV0dG9ucyA9IFsuLi5wcmVwZW5kXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWN0aW9ucykpIHtcbiAgICAgICAgICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uTmFtZSkgPT5cbiAgICAgICAgICAgICAgICBhY3Rpb25zQnV0dG9ucy5wdXNoKEFDVElPTlNbYWN0aW9uTmFtZV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnNCdXR0b25zLnB1c2goLi4uYXBwZW5kKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnNCdXR0b25zO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBydW4oY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL2luZGljYXRpbmcgdGhhdCB3ZSBhcmUgd29ya2luZ1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbigpO1xuXG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnByZWxvYWRWYXJpYW50cyhBQ1RJT04pO1xuXG4gICAgICAgICAgICBjb250cm9sbGVyLnNldEJyZWFkY3J1bWJzKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcItCh0L/QuNGB0L7QulwiLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxVUkwoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnVpW0FDVElPTl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuJGRlc3Ryb3lVSSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250cm9sbGVyLnVpW0FDVElPTl0gPSBuZXcgbm90VGFibGUoXG4gICAgICAgICAgICAgICAgdGhpcy50d2Vha1VJT3B0aW9ucyhDUlVEQWN0aW9uTGlzdC5wcmVwYXJlT3B0aW9ucyhjb250cm9sbGVyKSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChcbiAgICAgICAgICAgICAgICBgYWZ0ZXI6cmVuZGVyOiR7QUNUSU9OfWAsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pbmZvcm1pbmcgYWJvdXQgZXhjZXB0aW9uXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGV4Y2VwdGlvbjpyZW5kZXI6JHtBQ1RJT059YCwgcGFyYW1zLCBlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHByZXBhcmVPcHRpb25zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgREVGQVVMVF9PUFRJT05TX1RBQkxFID0ge1xuICAgICAgICAgICAgaW50ZXJmYWNlOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7QUNUSU9OfS5pbnRlcmZhY2VgLCB7XG4gICAgICAgICAgICAgICAgY29tYmluZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZmFjdG9yeTogY29udHJvbGxlci5nZXRJbnRlcmZhY2UoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZmllbGRzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaG93U2VsZWN0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBnZXRJdGVtSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlkRmllbGQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZWxvYWQ6IHt9LFxuICAgICAgICAgICAgZmlsdGVyVUk6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHtBQ1RJT059LmZpbHRlclVJYCksXG4gICAgICAgICAgICBwYWdlcjogeyBzaXplOiA1MCwgcGFnZTogMCB9LFxuICAgICAgICAgICAgc29ydGVyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdWk6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy9mb3JtaW5nIGFjdGlvbnMgYnV0dG9ucyBsaXN0XG4gICAgICAgIGxldCBBQ1RJT05TX0xJU1QgPSBbLi4uY29udHJvbGxlci5nZXRPcHRpb25zKGAke0FDVElPTn0uYWN0aW9uc2AsIFtdKV07XG4gICAgICAgIEFDVElPTlNfTElTVCA9IHRoaXMudHdlYWtBY3Rpb25zTGlzdChjb250cm9sbGVyLCBBQ1RJT05TX0xJU1QpO1xuICAgICAgICAvL1xuICAgICAgICBjb25zdCBUQUJMRV9PUFRJT05TID0ge1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRhcmdldEVsOiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIGVuZGxlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IEFDVElPTlNfTElTVCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5rZXlzKERFRkFVTFRfT1BUSU9OU19UQUJMRSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgb3B0VmFsID0gY29udHJvbGxlci5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgIGAke0FDVElPTn0uJHtrZXl9YCxcbiAgICAgICAgICAgICAgICBERUZBVUxUX09QVElPTlNfVEFCTEVba2V5XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0VmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgVEFCTEVfT1BUSU9OUy5vcHRpb25zW2tleV0gPSBvcHRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVEFCTEVfT1BUSU9OUztcbiAgICB9XG59XG4iLCJpbXBvcnQgQ1JVREFjdGlvbkNyZWF0ZSBmcm9tIFwiLi9jcmVhdGVcIjtcbmltcG9ydCBDUlVEQWN0aW9uRGV0YWlscyBmcm9tIFwiLi9kZXRhaWxzXCI7XG5pbXBvcnQgQ1JVREFjdGlvblVwZGF0ZSBmcm9tIFwiLi91cGRhdGVcIjtcbmltcG9ydCBDUlVEQWN0aW9uRGVsZXRlIGZyb20gXCIuL2RlbGV0ZVwiO1xuaW1wb3J0IENSVURBY3Rpb25MaXN0IGZyb20gXCIuL2xpc3RcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZTogQ1JVREFjdGlvbkNyZWF0ZSxcbiAgICBkZXRhaWxzOiBDUlVEQWN0aW9uRGV0YWlscyxcbiAgICB1cGRhdGU6IENSVURBY3Rpb25VcGRhdGUsXG4gICAgZGVsZXRlOiBDUlVEQWN0aW9uRGVsZXRlLFxuICAgIGxpc3Q6IENSVURBY3Rpb25MaXN0LFxufTtcbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vZWxlbWVudHMvY29tbW9uXCI7XG5cbmltcG9ydCBub3RCcmVhZGNydW1icyBmcm9tIFwiLi4vY29tcG9uZW50cy9icmVhZGNydW1ic1wiO1xuXG5pbXBvcnQgVUlMb2FkZXIgZnJvbSBcIi4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkubG9hZGVyLnN2ZWx0ZVwiO1xuXG5pbXBvcnQgbm90Q29udHJvbGxlciBmcm9tIFwiLi4vY29udHJvbGxlclwiO1xuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbmltcG9ydCBDUlVEVmFyaWFudHNQcmVsb2FkZXIgZnJvbSBcIi4vdmFyaWFudHMucHJlbG9hZGVyLmpzXCI7XG5pbXBvcnQgQ1JVRFJvdXRlciBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcbmltcG9ydCBDUlVETWVzc2FnZSBmcm9tIFwiLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgQ1JVREFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsgbW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbmNvbnN0IEJSRUFEQ1JVTUJTID0gW107XG5jb25zdCBUSVRMRV9GSUVMRFNfUFJJT1JJVFkgPSBbXCJ0aXRsZVwiLCBcImxhYmVsXCIsIFwiaWRcIiwgXCJuYW1lXCJdO1xuXG5jb25zdCBMT0FESU5HX1NDUkVFTl9VSV9OQU1FID0gXCJsb2FkaW5nX3NjcmVlblwiO1xuXG5jbGFzcyBub3RDUlVEIGV4dGVuZHMgbm90Q29udHJvbGxlciB7XG4gICAgI2FjdGlvbnMgPSB7IC4uLkNSVURBY3Rpb25zIH07XG4gICAgI3JvdXRlciA9IENSVURSb3V0ZXI7XG4gICAgI3ByZWxvYWRlciA9IENSVURWYXJpYW50c1ByZWxvYWRlcjtcblxuICAgIFRJVExFX0ZJRUxEU19QUklPUklUWSA9IFRJVExFX0ZJRUxEU19QUklPUklUWTtcblxuICAgIHN0YXRpYyBFUlJPUl9ERUZBVUxUID0gVUlDb21tb24uRVJST1JfREVGQVVMVDtcblxuICAgIFRPUF9DTEFTUyA9IFtcImJveFwiXTtcbiAgICBNQUlOX0NMQVNTID0gW1wiYm94XCJdO1xuICAgIEJPVFRPTV9DTEFTUyA9IFtcImJveFwiXTtcblxuICAgIFdTX0NIRUNLX0lOVEVSVkFMID0gMjAwO1xuXG4gICAgc3RhdGljIGdldCBMQUJFTFMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIHBsdXJhbDogYCR7dGhpcy5NT0RVTEVfTkFNRX06JHt0aGlzLk1PREVMX05BTUV9X2xhYmVsX3BsdXJhbGAsXG4gICAgICAgICAgICBzaW5nbGU6IGAke3RoaXMuTU9EVUxFX05BTUV9OiR7dGhpcy5NT0RFTF9OQU1FfV9sYWJlbF9zaW5nbGVgLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWVudShpdGVtQ3VzdG9tUHJvcHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlY3Rpb246IHRoaXMuTU9EVUxFX05BTUUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuTEFCRUxTLnBsdXJhbCxcbiAgICAgICAgICAgICAgICB1cmw6IGAvJHtub3RDb21tb24ubG93ZXJGaXJzdExldHRlcihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfTkFNRVxuICAgICAgICAgICAgICAgICl9LyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIodGhpcy5NT0RFTF9OQU1FKX1gLFxuICAgICAgICAgICAgICAgIC4uLml0ZW1DdXN0b21Qcm9wcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGFwcCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgeyBhY3Rpb25zLCByb3V0ZXIsIHByZWxvYWRlciB9ID0ge1xuICAgICAgICAgICAgYWN0aW9uczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcm91dGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwcmVsb2FkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgICkge1xuICAgICAgICBzdXBlcihhcHAsIGBDUlVELiR7bmFtZX1gKTtcbiAgICAgICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuI2FjdGlvbnMgPSB7IC4uLnRoaXMuI2FjdGlvbnMsIC4uLmFjdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNyb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWxvYWRlcikge1xuICAgICAgICAgICAgdGhpcy4jcHJlbG9hZGVyID0gcHJlbG9hZGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudWkgPSB7fTtcbiAgICAgICAgdGhpcy5lbHMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwibmFtZXNcIiwge1xuICAgICAgICAgICAgbW9kdWxlOiBcIlwiLFxuICAgICAgICAgICAgcGx1cmFsOiBcInBsdXJhbFwiLFxuICAgICAgICAgICAgc2luZ2xlOiBcInNpbmdsZVwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFxuICAgICAgICAgICAgXCJjb250YWluZXJTZWxlY3RvclwiLFxuICAgICAgICAgICAgdGhpcy5hcHA/LmdldE9wdGlvbnMoXCJjcnVkLmNvbnRhaW5lclNlbGVjdG9yXCIpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuYnVpbGRGcmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgLy9ub3QtbW9kdWxlLW5hbWUgLT4gW25vdCxtb2R1bGUsbmFtZV1cbiAgICAgICAgY29uc3QgTW9kdWxlTmFtZVBhcnRzID0gdGhpcy5nZXRNb2R1bGVOYW1lKCkuc3BsaXQoXCItXCIpO1xuICAgICAgICAvL1tub3QsbW9kdWxlLG5hbWVdIC0+IE1vZHVsZU5hbWVcbiAgICAgICAgY29uc3QgTW9kdWxlTmFtZSA9IChcbiAgICAgICAgICAgIE1vZHVsZU5hbWVQYXJ0c1swXSA9PT0gXCJub3RcIlxuICAgICAgICAgICAgICAgID8gTW9kdWxlTmFtZVBhcnRzLnNwbGljZSgxKVxuICAgICAgICAgICAgICAgIDogTW9kdWxlTmFtZVBhcnRzXG4gICAgICAgIClcbiAgICAgICAgICAgIC5tYXAobm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcilcbiAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IGBucyR7TW9kdWxlTmFtZX1Db21tb25gO1xuICAgICAgICBjb25zdCBDb21tb25Nb2R1bGVTZXJ2aWNlID0gdGhpcy5hcHA/LmdldFNlcnZpY2Uoc2VydmljZU5hbWUpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXG4gICAgICAgICAgICBcInZhbGlkYXRvcnNcIixcbiAgICAgICAgICAgIENvbW1vbk1vZHVsZVNlcnZpY2UuYXVnbWVudFZhbGlkYXRvcnModmFsaWRhdG9ycylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBnZXRWYWxpZGF0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwidmFsaWRhdG9yc1wiKTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgbGV0IG5ld0hlYWQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0TW9kdWxlTmFtZSgpICYmIHRoaXMuZ2V0T3B0aW9ucyhcIm5hbWVzLm1vZHVsZVwiKSkge1xuICAgICAgICAgICAgbmV3SGVhZC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5nZXRPcHRpb25zKFwibmFtZXMubW9kdWxlXCIpLFxuICAgICAgICAgICAgICAgIHVybDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdIZWFkLnB1c2goe1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMuZ2V0T3B0aW9ucyhcIm5hbWVzLnBsdXJhbFwiKSxcbiAgICAgICAgICAgIHVybDogdGhpcy5nZXRNb2RlbFVSTCgpLFxuICAgICAgICB9KTtcbiAgICAgICAgQlJFQURDUlVNQlMuc3BsaWNlKDAsIEJSRUFEQ1JVTUJTLmxlbmd0aCwgLi4ubmV3SGVhZCk7XG4gICAgICAgIG5vdEJyZWFkY3J1bWJzLnNldEhlYWQoQlJFQURDUlVNQlMpLnJlbmRlcih7XG4gICAgICAgICAgICByb290OiBcIlwiLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmVscy50b3AsXG4gICAgICAgICAgICBuYXZpZ2F0ZTogKHVybCkgPT4gdGhpcy5hcHA/LmdldFdvcmtpbmcoXCJyb3V0ZXJcIikubmF2aWdhdGUodXJsKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm91dGUodGhpcy5nZXRPcHRpb25zKFwicGFyYW1zXCIpKTtcbiAgICB9XG5cbiAgICBzdGFydFdoZW5XU0NsaWVudFJlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy5hcHA/LmdldFdTQ2xpZW50KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcD8uZ2V0V1NDbGllbnQoKS5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcFxuICAgICAgICAgICAgICAgICAgICAuZ2V0V1NDbGllbnQoKVxuICAgICAgICAgICAgICAgICAgICAub25jZShcImNvbm5lY3RlZFwiLCB0aGlzLnN0YXJ0V2hlbldTQ2xpZW50UmVhZHkuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICgpID0+IHRoaXMuc3RhcnRXaGVuV1NDbGllbnRSZWFkeSgpLFxuICAgICAgICAgICAgICAgIHRoaXMuV1NfQ0hFQ0tfSU5URVJWQUxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRCcmVhZGNydW1icyh0YWlsKSB7XG4gICAgICAgIG5vdEJyZWFkY3J1bWJzLnNldFRhaWwodGFpbCkudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgYmFja1RvTGlzdCgpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZSh0aGlzLmxpbmtCYWNrVG9MaXN0KCkpO1xuICAgIH1cblxuICAgIGxpbmtCYWNrVG9MaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2RlbFVSTCgpO1xuICAgIH1cblxuICAgIGFmdGVyQWN0aW9uKGFjdGlvbiA9IFwibGlzdFwiKSB7XG4gICAgICAgIGxldCBuYXZCYWNrID0gdGhpcy5hcHA/LmdldE9wdGlvbnMoXCJjcnVkLm5hdmlnYXRlQmFja0FmdGVyXCIsIFtdKTtcbiAgICAgICAgaWYgKG5hdkJhY2sgJiYgQXJyYXkuaXNBcnJheShuYXZCYWNrKSAmJiBuYXZCYWNrLmluZGV4T2YoYWN0aW9uKSA+IC0xKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tUb0xpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJ1aWxkRnJhbWUoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICB0aGlzLmFwcD8uZ2V0T3B0aW9ucyhcImNydWQuY29udGFpbmVyU2VsZWN0b3JcIiwgXCJib2R5XCIpXG4gICAgICAgICk7XG4gICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVscy50b3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVscy50b3AuaWQgPSBcImNydWQtdG9wXCI7XG4gICAgICAgIHRoaXMuZ2V0RnJhbWVDbGFzc2VzKCkuVE9QX0NMQVNTLmZvckVhY2goKG5hbWUpID0+XG4gICAgICAgICAgICB0aGlzLmVscy50b3AuY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICApO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmVscy50b3ApO1xuICAgICAgICB0aGlzLmVscy5tYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lbHMubWFpbi5pZCA9IFwiY3J1ZC1tYWluXCI7XG4gICAgICAgIHRoaXMuZ2V0RnJhbWVDbGFzc2VzKCkuTUFJTl9DTEFTUy5mb3JFYWNoKChuYW1lKSA9PlxuICAgICAgICAgICAgdGhpcy5lbHMubWFpbi5jbGFzc0xpc3QuYWRkKG5hbWUpXG4gICAgICAgICk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuZWxzLm1haW4pO1xuICAgICAgICB0aGlzLmVscy5ib3R0b20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVscy5ib3R0b20uaWQgPSBcImNydWQtYm90dG9tXCI7XG4gICAgICAgIHRoaXMuZ2V0RnJhbWVDbGFzc2VzKCkuQk9UVE9NX0NMQVNTLmZvckVhY2goKG5hbWUpID0+XG4gICAgICAgICAgICB0aGlzLmVscy5ib3R0b20uY2xhc3NMaXN0LmFkZChuYW1lKVxuICAgICAgICApO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmVscy5ib3R0b20pO1xuICAgIH1cblxuICAgIGdldEZyYW1lQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFRPUF9DTEFTUzogdGhpcy5UT1BfQ0xBU1MsXG4gICAgICAgICAgICBNQUlOX0NMQVNTOiB0aGlzLk1BSU5fQ0xBU1MsXG4gICAgICAgICAgICBCT1RUT01fQ0xBU1M6IHRoaXMuQk9UVE9NX0NMQVNTLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldENvbnRhaW5lclRvcEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVscy50b3A7XG4gICAgfVxuXG4gICAgZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHMubWFpbjtcbiAgICB9XG5cbiAgICBnZXRDb250YWluZXJCb3R0b21FbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbHMuYm90dG9tO1xuICAgIH1cblxuICAgIGFzeW5jIHByZWxvYWRWYXJpYW50cyh0eXBlID0gXCJsaXN0XCIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcHJlbG9hZGVyLnByZWxvYWQodGhpcywgdHlwZSk7XG4gICAgfVxuXG4gICAgZ2V0VGl0bGVGcm9tTGliKHByb3BOYW1lLCBpZCkge1xuICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gdGhpcy5nZXRDdXJyZW50QWN0aW9uKCk7XG4gICAgICAgIHRoaXMuZGVidWcgJiZcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgICAgICAgXCJub3RDUlVELmdldFRpdGxlRnJvbUxpYiBpcyBvYnNvbGV0ZSwgdXNlIG5vdENSVUQuZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlKGFjdGlvbk5hbWUsIHByb3BOYW1lLCBpZClcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlKGFjdGlvbk5hbWUsIHByb3BOYW1lLCBpZCk7XG4gICAgfVxuXG4gICAgZ2V0UHJlbG9hZGVkVmFyaWFudHMoYWN0aW9uTmFtZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhgdmFyaWFudHMuJHthY3Rpb25OYW1lfS4ke3Byb3BOYW1lfWAsIFtdKTtcbiAgICB9XG5cbiAgICBnZXRQcmVsb2FkZWRWYXJpYW50VGl0bGUoYWN0aW9uTmFtZSwgcHJvcE5hbWUsIGlkKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnRzID0gdGhpcy5nZXRQcmVsb2FkZWRWYXJpYW50cyhhY3Rpb25OYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB2YXJpYW50cy5maW5kKChpdGVtKSA9PiBpdGVtLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50aXRsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEl0ZW1UaXRsZShpdGVtKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IHRoaXMuVElUTEVfRklFTERTX1BSSU9SSVRZLmZpbmQoKGtleSkgPT5cbiAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoaXRlbSwga2V5KVxuICAgICAgICApO1xuICAgICAgICBpZiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVtmaWVsZE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2RlbCh7fSkudG9EZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcm91dGUocGFyYW1zID0gW10pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb3V0ZXIucm91dGUodGhpcywgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnQoZSk7XG4gICAgICAgICAgICB0aGlzLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25IYW5kbGVyRXhpc3RzKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuI2FjdGlvbnMpLmluY2x1ZGVzKGFjdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgdGhpc1tcInJ1blwiICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihhY3Rpb25OYW1lKV0gPT09XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcnVuQWN0aW9uKGFjdGlvbk5hbWUsIHBhcmFtcykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy4jYWN0aW9ucykuaW5jbHVkZXMoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNhY3Rpb25zW2FjdGlvbk5hbWVdLnJ1bih0aGlzLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIHRoaXNbXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoYWN0aW9uTmFtZSldID09PVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbXCJydW5cIiArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoYWN0aW9uTmFtZSldKFxuICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgTm8gc3VjaCBhY3Rpb246ICR7YWN0aW9uTmFtZX0gaW4gY29udG9sbGVyICR7dGhpcy5nZXRXb3JraW5nKFxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDaGFuZ2VzIGxvY2F0aW9uIHRvIGNyZWF0ZSBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtkZWxheT0wXSBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvQ3JlYXRlKGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLmdvQWZ0ZXJEZWxheSh0aGlzLmdldE1vZGVsQWN0aW9uVVJMKFwiXCIsIFwiY3JlYXRlXCIpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENoYW5nZXMgbG9jYXRpb24gdG8gZG9jdW1lbnQgZGV0YWlscyBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gICAgICAgICBpZCAgICAgICAgICB0YXJnZXQgZG9jdW1lbnQgaWRcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgW2RlbGF5PTBdICAgbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb0RldGFpbHMoaWQsIGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLmdvQWZ0ZXJEZWxheSh0aGlzLmdldE1vZGVsQWN0aW9uVVJMKGlkLCBcIlwiKSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgbG9jYXRpb24gdG8gZG9jdW1lbnQgdXBkYXRlIHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIGlkICAgICAgICAgIHRhcmdldCBkb2N1bWVudCBpZFxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvVXBkYXRlKGlkLCBkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5nb0FmdGVyRGVsYXkodGhpcy5nZXRNb2RlbEFjdGlvblVSTChpZCwgXCJ1cGRhdGVcIiksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudCBkZWxldGUgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgaWQgICAgICAgICAgdGFyZ2V0IGRvY3VtZW50IGlkXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gIFtkZWxheT0wXSAgIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29EZWxldGUoaWQsIGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLmdvQWZ0ZXJEZWxheSh0aGlzLmdldE1vZGVsQWN0aW9uVVJMKGlkLCBcImRlbGV0ZVwiKSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50cyBsaXN0IHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gIFtkZWxheT0wXSAgIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29MaXN0KGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLmdvQWZ0ZXJEZWxheSh0aGlzLmdldE1vZGVsVVJMKCksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGRlbGF5XG4gICAgICovXG4gICAgZ29BZnRlckRlbGF5KHVybCwgZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGVXaXRoRGVsYXkodXJsLCBkZWxheSwgKCkgPT4gdGhpcy4kZGVzdHJveVVJKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50cyBsaXN0IHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gIFtkZWxheT0wXSAgIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29CYWNrKGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLmdvTGlzdChkZWxheSk7XG4gICAgfVxuXG4gICAgYXN5bmMgb25BY3Rpb25TdWJtaXQoYWN0aW9uLCBpdGVtKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGFjdGlvblVJID0gdGhpcy51aVthY3Rpb25dO1xuICAgICAgICBpZiAoYWN0aW9uVUkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uVUkuc2V0TG9hZGluZygpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldE1vZGVsKGl0ZW0pW2AkJHthY3Rpb259YF0oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGFjdGlvblVJLnByb2Nlc3NSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGFjdGlvblVJLnByb2Nlc3NSZXN1bHQoZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGFjdGlvblVJLnJlc2V0TG9hZGluZygpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnNhZmUtZmluYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjdGlvbiBVSSBkb2VzbnQgZXhpc3RcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkZGVzdHJveVVJKCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMudWkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVVJQnlOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveVVJQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0aGlzLnVpLCBuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy51aVtuYW1lXS4kZGVzdHJveSAmJiB0aGlzLnVpW25hbWVdLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnVpW25hbWVdLmRlc3Ryb3kgJiYgdGhpcy51aVtuYW1lXS5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy51aVtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dFcnJvck1lc3NhZ2UocmVzKSB7XG4gICAgICAgIHRoaXMuZXJyb3IgJiYgdGhpcy5lcnJvcihyZXMpO1xuICAgICAgICB0aGlzLmFwcCAmJlxuICAgICAgICAgICAgdGhpcy5hcHAuZW1pdChcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCLQn9GA0L7QuNC30L7RiNC70LAg0L7RiNC40LHQutCwXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzLm1lc3NhZ2UgPyByZXMubWVzc2FnZSA6IFVJQ29tbW9uLkVSUk9SX0RFRkFVTFQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgQ1JVRE1lc3NhZ2UuZXJyb3IoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgXCLQn9GA0L7QuNC30L7RiNC70LAg0L7RiNC40LHQutCwXCIsXG4gICAgICAgICAgICByZXMubWVzc2FnZSA/IHJlcy5tZXNzYWdlIDogVUlDb21tb24uRVJST1JfREVGQVVMVFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHNob3dTdWNjZXNzTWVzc2FnZSh0aXRsZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmFwcCAmJiB0aGlzLmFwcC5lbWl0KFwic3VjY2Vzc1wiLCB7IHRpdGxlLCBtZXNzYWdlIH0pO1xuICAgICAgICBDUlVETWVzc2FnZS5zdWNjZXNzKHRoaXMsIHRpdGxlLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBzZXRVSShuYW1lLCB2YWwsIHNpbmdsZVVJID0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2luZ2xlVUkpIHtcbiAgICAgICAgICAgIHRoaXMuJGRlc3Ryb3lVSSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudWlbbmFtZV0gPSB2YWw7XG4gICAgfVxuXG4gICAgZ2V0VUkobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aVtuYW1lXTtcbiAgICB9XG5cbiAgICBnZXRBY3Rpb25VSSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWlbdGhpcy5nZXRDdXJyZW50QWN0aW9uKCldO1xuICAgIH1cblxuICAgIHJlbmRlckxvYWRpbmdTY3JlZW4oKSB7XG4gICAgICAgIHRoaXMuc2V0VUkoTE9BRElOR19TQ1JFRU5fVUlfTkFNRSwgdGhpcy5jcmVhdGVMb2FkZXJVSSgpKTtcbiAgICB9XG5cbiAgICByZW1vdmVMb2FkaW5nU2NyZWVuKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lVSUJ5TmFtZShMT0FESU5HX1NDUkVFTl9VSV9OQU1FKTtcbiAgICB9XG5cbiAgICBjcmVhdGVMb2FkZXJVSSgpIHtcbiAgICAgICAgcmV0dXJuIG1vdW50KFVJTG9hZGVyLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENSVUQ7XG4iLCJjb25zdCBST1VURV9MSVNUID0gXCJsaXN0XCI7XG4vKipcbiAqIFJ1bnMgY29udHJvbGxlciBhY3Rpb24gYnkgbmFtZSB0aGF0IGdldHMgZnJvbSBVUkkgcGFyYW1zXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3Mgbm90Q1JVRFBsYWluUm91dGVyIHtcbiAgICBzdGF0aWMgREVGQVVMVF9ST1VURSA9IFJPVVRFX0xJU1Q7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaXJzdCBpdGVtIGZyb20gcGFyYW1zIG9yIHRocm93cyBFcnJvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyBhcnJheSBvZiBzdHJpbmdzIHBhcnNlZCBmcm9tIFVSSSBieSByb3V0ZSBydWxlc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGV4dHJhY3RBY3Rpb25OYW1lKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuREVGQVVMVF9ST1VURTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGNvbnRyb2xsZXIgYWN0aW9uIG9yIHRocm93c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2Ygbm90Q29udHJvbGxlciBkZXNjZW5kYW50XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIHJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IHRoaXMuZXh0cmFjdEFjdGlvbk5hbWUocGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnJ1bkFjdGlvbihhY3Rpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q1JVRFBsYWluUm91dGVyO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbi8qKlxuICogUnVucyBjb250cm9sbGVyIGFjdGlvbiBieSBuYW1lIHRoYXQgZ2V0cyBmcm9tIFVSSSBwYXJhbXNcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBub3RDUlVEUm91dGVyU3dpdGNoIHtcbiAgICAvKipcbiAgICAgKiBWYXJpYW50cyBvZiB0aGlzIGFjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcm91dGVzVmFyaWFudHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIHJvdXRlTmFtZTogQWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdmFyaWFudCBuYW1lIGlzIHZhbGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgbmFtZSBvZiByb3V0ZSB2YXJpYW50XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3RhdGljIGlzUm91dGVWYXJpYW50VmFsaWQobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZSAhPT0gXCJcIiAmJiBub3RDb21tb24ub2JqSGFzKHRoaXMucm91dGVzVmFyaWFudHMsIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB3aGljaCBvZiByb3V0ZXMgdmFyaWFudCBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIG5vdENvbnRyb2xsZXIgZGVzY2VuZGFudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119ICAgIHBhcmFtcyAgcGFyYW1zIHBhc3NlZCB0byByb3V0ZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAgICBuYW1lIG9mIHJvdXRlIHZhcmlhbnRcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdGF0aWMgYXN5bmMgZGV0ZXJtaW5lUm91dGUoY29udHJvbGxlciwgcGFyYW1zID0gW10pIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBjb250cm9sbGVyIGFjdGlvbiBvciB0aHJvd3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIG5vdENvbnRyb2xsZXIgZGVzY2VuZGFudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyByb3V0ZShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSBhd2FpdCB0aGlzLmRldGVybWluZVJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JvdXRlVmFyaWFudFZhbGlkKGFjdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRDdXJyZW50QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlckFjdGlvbiA9IHRoaXMucm91dGVzVmFyaWFudHNbYWN0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0FzeW5jKHJvdXRlckFjdGlvbi5ydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJvdXRlckFjdGlvbi5ydW4oY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXJBY3Rpb24ucnVuKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBObyBzdWNoIGFjdGlvbjogJHthY3Rpb25OYW1lfSBpbiBjb250b2xsZXIgJHtjb250cm9sbGVyLmdldFdvcmtpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlcG9ydChlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q1JVRFJvdXRlclN3aXRjaDtcbiIsImltcG9ydCBVSUdlbmVyaWNTZWxlY3RvciBmcm9tIFwiLi4vLi4vZWxlbWVudHMvbW9kYWwvdWkuZ2VuZXJpYy5zZWxlY3Rvci5zdmVsdGVcIjtcbmltcG9ydCB7IG1vdW50LCB1bm1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBlbXB0eVJlc3VsdCA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsaXN0OiBbXSxcbiAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIHBhZ2U6IDAsXG4gICAgICAgIHBhZ2VzOiAwLFxuICAgICAgICBza2lwOiAwLFxuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBub3RTZXJ2aWNlTW9kZWxTZWFyY2gge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgbW9kZWxOYW1lKSB7XG4gICAgICAgIHRoaXMubW9kZWxOYW1lID0gbW9kZWxOYW1lO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hcHA7XG4gICAgfVxuXG4gICAgZ2V0U2VhcmNoUm91dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJsaXN0QW5kQ291bnRcIjtcbiAgICB9XG5cbiAgICBnZXREYXRhTG9hZFJvdXRlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2V0XCI7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtU2VhcmNoUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICByZXN1bHQubGlzdCA9IHJlc3VsdC5saXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgICAgIGlkOiBpdGVtW2Ake3RoaXMubW9kZWxOYW1lfUlEYF0sXG4gICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0ubmFtZSB8fCBpdGVtLnRpdGxlIHx8IGl0ZW0ubGFiZWwgfHwgaXRlbS51c2VybmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHRyYW5zZm9ybVNlbGVjdGVkUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX2lkOiByZXN1bHQuX2lkLFxuICAgICAgICAgICAgW2Ake3RoaXMubW9kZWxOYW1lfUlEYF06IHJlc3VsdC5pZCxcbiAgICAgICAgICAgIHRpdGxlOiByZXN1bHQudGl0bGUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgc2VhcmNoQnlUZXJtKHRlcm0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0ZXJtLnZhbHVlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuYXBwLmdldE1vZGVsKHRoaXMubW9kZWxOYW1lKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXRTZWFyY2godGVybS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbFtgJCR7dGhpcy5nZXRTZWFyY2hSb3V0ZU5hbWUoKX1gXSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFwib2tcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TZWFyY2hSZXN1bHQocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlblNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IG1vdW50KFVJR2VuZXJpY1NlbGVjdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsLiRvbihcInRlcm1DaGFuZ2VcIiwgYXN5bmMgKHsgZGV0YWlsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VhcmNoQnlUZXJtKGRldGFpbCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLiRzZXQoeyByZXN1bHRzIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWwuJG9uKFwibmV4dFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibmV4dCBzZWxlY3RvciByZXN1bHRzXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWwuJG9uKFwicHJldlwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJldiBzZWxlY3RvciByZXN1bHRzXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZWwuJG9uKFwicmVqZWN0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsLiRvbihcInJlc29sdmVcIiwgKHsgZGV0YWlsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChlbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy50cmFuc2Zvcm1TZWxlY3RlZFJlc3VsdChkZXRhaWwpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGxvYWREYXRhKF9pZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9pZCAmJiBfaWQubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuYXBwLmdldE1vZGVsKHRoaXMubW9kZWxOYW1lLCB7IF9pZCB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsW1xuICAgICAgICAgICAgICAgICAgICBgJCR7dGhpcy5nZXREYXRhTG9hZFJvdXRlTmFtZSgpfWBcbiAgICAgICAgICAgICAgICBdKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJva1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5hcHAuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vaW1wb3J0ICdiYWJlbC1wb2x5ZmlsbC9kaXN0L3BvbHlmaWxsJztcblxuLypcbiAgQ29tbW9uIGZ1bmN0aW9uc1xuKi9cbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qXG4gIGZyYW1ld29yayB3aWRlIHBhcnNlciBmb3IgZGF0YSBhY2Nlc3NcbiovXG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcblxuaW1wb3J0IG5vdFJvdXRlciBmcm9tIFwiLi9yb3V0ZXIuanNcIjtcblxuaW1wb3J0ICogYXMgbm90QVBJIGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0ICogYXMgbm90U3RvcmVzIGZyb20gXCIuL3N0b3Jlc1wiO1xuLypcbiAgYmFzaWMgZXZlbnQgaGFuZGxlcnMgYW5kIGNvcmUgZGF0YSBtb2RpZmllcnNcbiovXG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5cbmltcG9ydCB7IENPTVBPTkVOVFMsIEZJRUxEUywgVkFSSUFOVFMgfSBmcm9tIFwiLi9MSUIuanNcIjtcbi8qXG4gIGFwcGxpY2F0aW9uIG1haW4gaW5mcmFzdHJ1Y3R1cmUgc2V0dGVyXG4qL1xuaW1wb3J0IG5vdEFwcCBmcm9tIFwiLi9hcHAuanNcIjtcbi8qXG4gIHVzZXIgY29udHJvbGxlcnNcbiovXG5pbXBvcnQgbm90Q29udHJvbGxlciBmcm9tIFwiLi9jb250cm9sbGVyLmpzXCI7XG5pbXBvcnQgbm90UmVjb3JkIGZyb20gXCIuL3JlY29yZC5qc1wiOyAvLyAgd3JhcHBlciBmb3IgZGF0YSB3aXRoIHNlcnZlciBsaXZlIGludGVyYWN0aW9uc1xuaW1wb3J0IG5vdEludGVyZmFjZSBmcm9tIFwiLi9pbnRlcmZhY2UuanNcIjsgLy8gIHdyYXBwZXIgZm9yIGRhdGEgd2l0aCBzZXJ2ZXIgbGl2ZSBpbnRlcmFjdGlvbnNcblxuaW1wb3J0IHtcbiAgICBub3RUYWJsZSxcbiAgICBVSUZvcm0sXG4gICAgbm90Rm9ybSxcbiAgICBub3RGb3JtU2V0LFxuICAgIG5vdEZvcm1SdWxlcyxcbiAgICBub3RGb3JtVXRpbHMsXG4gICAgbm90Rm9ybUhlbHBlcnMsXG4gICAgbm90QnJlYWRjcnVtYnMsXG4gICAgbm90VG9wTWVudSxcbiAgICBub3RTaWRlTWVudSxcbn0gZnJvbSBcIi4vY29tcG9uZW50c1wiO1xuXG5pbXBvcnQgY3JlYXRlQ1JVREFjdGlvblVJVmlldyBmcm9tIFwiLi9jcnVkL2NyZWF0ZS5jcnVkLmFjdGlvbi51aS52aWV3LmpzXCI7XG5pbXBvcnQgbm90Q1JVRCBmcm9tIFwiLi9jcnVkL2NvbnRyb2xsZXIuY3J1ZC5qc1wiO1xuaW1wb3J0IG5vdENSVURSb3V0ZXIgZnJvbSBcIi4vY3J1ZC9yb3V0ZXIuanNcIjtcbmltcG9ydCBub3RDUlVEUm91dGVyUGxhaW4gZnJvbSBcIi4vY3J1ZC9yb3V0ZXIucGxhaW4uanNcIjtcbmltcG9ydCBub3RDUlVEUm91dGVyU3dpdGNoIGZyb20gXCIuL2NydWQvcm91dGVyLnN3aXRjaC5qc1wiO1xuaW1wb3J0IG5vdFNlcnZpY2VNb2RlbFNlYXJjaCBmcm9tIFwiLi9jcnVkL3NlYXJjaC5zZXJ2aWNlLmpzXCI7XG5cbmNvbnN0IG5jQ1JVRCA9IG5vdENSVUQ7IC8vbGVnYWN5IGFsaWFzXG5cbmV4cG9ydCB7XG4gICAgQ09NUE9ORU5UUyxcbiAgICBGSUVMRFMsXG4gICAgVUlGb3JtLFxuICAgIFZBUklBTlRTLFxuICAgIG5jQ1JVRCxcbiAgICBjcmVhdGVDUlVEQWN0aW9uVUlWaWV3LFxuICAgIG5vdEFQSSxcbiAgICBub3RBcHAsXG4gICAgbm90QmFzZSxcbiAgICBub3RCcmVhZGNydW1icyxcbiAgICBub3RDUlVELFxuICAgIG5vdENvbW1vbixcbiAgICBub3RDb250cm9sbGVyLFxuICAgIG5vdEZvcm0sXG4gICAgbm90Rm9ybVNldCxcbiAgICBub3RGb3JtVXRpbHMsXG4gICAgbm90Rm9ybUhlbHBlcnMsXG4gICAgbm90Rm9ybVJ1bGVzLFxuICAgIG5vdEludGVyZmFjZSxcbiAgICBub3RQYXRoLFxuICAgIG5vdFJlY29yZCxcbiAgICBub3RSb3V0ZXIsXG4gICAgbm90Q1JVRFJvdXRlcixcbiAgICBub3RDUlVEUm91dGVyUGxhaW4sXG4gICAgbm90Q1JVRFJvdXRlclN3aXRjaCxcbiAgICBub3RTZXJ2aWNlTW9kZWxTZWFyY2gsXG4gICAgbm90U2lkZU1lbnUsXG4gICAgbm90U3RvcmVzLFxuICAgIG5vdFRhYmxlLFxuICAgIG5vdFRvcE1lbnUsXG59O1xuIiwiaW1wb3J0IFwiLi9zY3NzL3N0eWxlLnNjc3NcIjtcblxuaW1wb3J0ICogYXMgc3ZlbHRlIGZyb20gXCJzdmVsdGVcIjtcblxuaW1wb3J0ICogYXMgRWxlbWVudHMgZnJvbSBcIi4vZWxlbWVudHNcIjtcblxuaW1wb3J0ICogYXMgRnJhbWUgZnJvbSBcIi4vZnJhbWVcIjtcblxuaW1wb3J0IHsgTE9DQUxFLCBzYXksIG5vdExvY2FsZSB9IGZyb20gXCIuL2xvY2FsZVwiO1xuXG5jb25zdCBMb2NhbGUgPSB7IExPQ0FMRSwgc2F5LCBub3RMb2NhbGUgfTtcbmNvbnN0IFVJQ29tbW9uID0gRWxlbWVudHMuVUlDb21tb247XG5cbmNvbnN0IHsgbm90Q29tbW9uLCBDT01QT05FTlRTLCBGSUVMRFMsIFZBUklBTlRTLCBub3RGb3JtVXRpbHMgfSA9IEZyYW1lO1xuXG5PYmplY3Qua2V5cyhFbGVtZW50cykuZm9yRWFjaCgoY29tcG9uZW50c1NldE5hbWUpID0+IHtcbiAgICBPYmplY3Qua2V5cyhFbGVtZW50c1tjb21wb25lbnRzU2V0TmFtZV0pLmZvckVhY2goKGNvbXBvbmVudE5hbWUpID0+IHtcbiAgICAgICAgRnJhbWUubm90Rm9ybVV0aWxzLmFkZENvbXBvbmVudChcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICBFbGVtZW50c1tjb21wb25lbnRzU2V0TmFtZV1bY29tcG9uZW50TmFtZV1cbiAgICAgICAgKTtcbiAgICB9KTtcbn0pO1xuXG5leHBvcnQge1xuICAgIHN2ZWx0ZSxcbiAgICAvL1VJXG4gICAgRWxlbWVudHMsXG4gICAgVUlDb21tb24sXG4gICAgLy9hcHBsaWNhdGlvbiBmcmFtZXdvcmtcbiAgICBGcmFtZSxcbiAgICAvL3Nob3J0cyBmb3IgY29tbW9uIGVsZW1lbnRzXG4gICAgbm90Q29tbW9uLFxuICAgIG5vdEZvcm1VdGlscyxcbiAgICBDT01QT05FTlRTLFxuICAgIEZJRUxEUyxcbiAgICBWQVJJQU5UUyxcbiAgICAvL2xvY2FsaXphdGlvblxuICAgIExvY2FsZSxcbiAgICBMT0NBTEUsXG4gICAgc2F5LFxuICAgIG5vdExvY2FsZSxcbn07XG4iXSwibmFtZXMiOlsiYm9sZCIsIm5vcm1hbCIsIncuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUiLCJ3Lm93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uIiwiZ2V0IiwiZS5zdGF0ZV91bnNhZmVfbXV0YXRpb24iLCJ3Lmh5ZHJhdGlvbl9taXNtYXRjaCIsImUuc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWQiLCJlLnN0YXRlX3Byb3RvdHlwZV9maXhlZCIsIncuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2giLCJlLmRlcml2ZWRfcmVmZXJlbmNlc19zZWxmIiwiZS5lZmZlY3Rfb3JwaGFuIiwiZS5lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkIiwiZS5lZmZlY3RfaW5fdGVhcmRvd24iLCJpc19taWNyb190YXNrX3F1ZXVlZCIsImUuZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZCIsImUuc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWQiLCJlLmh5ZHJhdGlvbl9mYWlsZWQiLCJ3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCIsImluZGV4Iiwidy5oeWRyYXRpb25faHRtbF9jaGFuZ2VkIiwiZS5pbnZhbGlkX3NuaXBwZXQiLCJ3LmludmFsaWRfcmF3X3NuaXBwZXRfcmVuZGVyIiwiY2xzeCIsIl9jbHN4Iiwidy5oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQiLCJsaW5lYXIiLCJlLmJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSIsImdldF9zdG9yZSIsImUucHJvcHNfcmVzdF9yZWFkb25seSIsImUucHJvcHNfaW52YWxpZF92YWx1ZSIsImUucnVuZV9vdXRzaWRlX3N2ZWx0ZSIsImUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5IiwiaW5wdXRWYWx1ZXNFeHRyYWN0b3JzIiwiT2JqZWN0IiwiZnJlZXplIiwiY2hlY2tib3giLCJpbnBFbCIsImRlZmF1bHRWYWx1ZSIsInVuZGVmaW5lZCIsImhhc093biIsImNoZWNrZWQiLCJ1bmNoZWNrZWQiLCJ2YWx1ZSIsIlVJQ29tbW9uIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NyZWF0ZUNsYXNzIiwia2V5IiwiZXh0cmFjdFZhbHVlRnJvbUlucHV0IiwidHlwZSIsIm9uSW5wdXQiLCJmaWVsZCIsIm9uY2hhbmdlIiwiYWRkaXRpb25hbCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJjdXJyZW50VGFyZ2V0IiwiaXNFbnRlckV2ZW50IiwiZSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIm9ubHlPbkVudGVyIiwiY2FsbGJhY2siLCJpc01vYmlsZSIsInRlc3RNb2JpbGUiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibXNNYXRjaE1lZGlhIiwidGVzdFF1ZXJ5IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwibWF4X3dpZHRoIiwiTU9CSUxFX1dJRFRIX0JSRUFLX1BPSU5UIiwibWF0Y2hlcyIsInJlbW92ZUJvZHlTY3JvbGwiLCJkb2N1bWVudCIsImJvZHkiLCJjbGFzc0xpc3QiLCJhZGQiLCJTQ1JPTExfRElTQUJMRVJfQ0xBU1MiLCJyZXN0b3JlQm9keVNjcm9sbCIsInJlbW92ZSIsImZvcm1hdFBob25lIiwidmFsIiwiZmlsbGVyIiwiRklMTEVSIiwic2xvdHMiLCJkaWdpdHMiLCJyZXBsYWNlIiwiZCIsInVuc2hpZnQiLCJzdGFjayIsIkFycmF5IiwiZnJvbSIsImZvckVhY2giLCJkaWdpdCIsInNsb3QiLCJsZW5zIiwicmVkdWNlIiwiYWNjIiwiY3VyciIsInQiLCJkaWYiLCJwYXJzZUludCIsInNldE1vbmV5U2lnbiIsIk1PTkVZX1NJR04iLCJmb3JtYXRQcmljZSIsInByaWNlIiwibWFqb3IiLCJNYXRoIiwiZmxvb3IiLCJtaW5vciIsInRvU3RyaW5nIiwiZm9ybWF0TG9jYWxlRGF0ZXRpbWUiLCJkdCIsIm9wdHMiLCJkYXRlIiwidGltZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwidHJ5Rm9ybWF0TG9jYWxlRGF0ZVRpbWUiLCJEYXRlIiwiZm9ybWF0VGltZXN0YW1wIiwidGltZXN0YW1wIiwib2Zmc2V0Iiwib2Zmc2V0TG9jYWwiLCJnZXRUaW1lem9uZU9mZnNldCIsImRlbHRhT2Zmc2V0IiwibG9jYWxEYXRlVGltZSIsInRvTG9jYWxlU3RyaW5nIiwiZGVjbE9mTnVtIiwibiIsInRleHRfZm9ybXMiLCJhYnMiLCJuMSIsImh1bWFuaXplZFRpbWVEaWZmIiwiY3VycmVudFRpbWUiLCJnZXRUaW1lIiwic2VjIiwicm91bmQiLCJ1bml0IiwiVElNRSIsIlNFQ09ORFMiLCJtaW4iLCJNSU5VVEVTIiwiaG91cnMiLCJIT1VSUyIsInN0eWxlc09iamVjdFRvU3RyaW5nIiwic3R5bGVzIiwia2V5cyIsIm1hcCIsInByb3AiLCJqb2luIiwic3RyaW5nT3JOdW1iZXIiLCJpbmRleE9mIiwic3RyaW5nc09mTnVtYmVycyIsImxpc3QiLCJldmVyeSIsIl9kZWZpbmVQcm9wZXJ0eSIsInRvcCIsImJlaGF2aW9yIiwiJC5yZXN0X3Byb3BzIiwiJC51c2VyX2VmZmVjdCIsIiQuc2V0IiwiaW5pdERpY3QiLCJ0YXJnZXQiLCJoYW5kbGVyIiwiUmVmbGVjdCIsIlByb3h5IiwiY3JlYXRlTG9jYWxlIiwic3Vic2NyaWJlIiwic2V0IiwidXBkYXRlIiwid3JpdGFibGUiLCJyZXNldCIsIkxPQ0FMRSIsInRoaXMiLCJzcmMiLCJub3RQYXRoIiwicmVxdWlyZSQkMCIsImlzTWVyZ2VhYmxlT2JqZWN0IiwiaXNOb25OdWxsT2JqZWN0IiwiaXNTcGVjaWFsIiwic3RyaW5nVmFsdWUiLCJwcm90b3R5cGUiLCJjYWxsIiwiaXNSZWFjdEVsZW1lbnQiLCJjYW5Vc2VTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCIkJHR5cGVvZiIsImVtcHR5VGFyZ2V0IiwiaXNBcnJheSIsImNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIiwib3B0aW9uc0FyZ3VtZW50IiwiY2xvbmUiLCJkZWVwbWVyZ2UiLCJkZWZhdWx0QXJyYXlNZXJnZSIsInNvdXJjZSIsImNvbmNhdCIsImVsZW1lbnQiLCJtZXJnZU9iamVjdCIsImRlc3RpbmF0aW9uIiwic291cmNlSXNBcnJheSIsInRhcmdldElzQXJyYXkiLCJvcHRpb25zIiwiYXJyYXlNZXJnZSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJhbGwiLCJkZWVwbWVyZ2VBbGwiLCJhcnJheSIsIkVycm9yIiwicHJldiIsIm5leHQiLCJub3RDb21tb24iLCJpc0Vycm9yIiwic3RhdHVzIiwibXV0ZSIsIkVOVl9UWVBFIiwicGFkIiwiZ2V0VG9kYXlEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJvYmpIYXMiLCJvYmoiLCJuYW1lIiwiY29weU9iaiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInBhcnRDb3B5T2JqIiwicGFydE9iaiIsImluY2x1ZGVzIiwiY29tcGFyZVR3b0FycmF5cyIsImEiLCJiIiwiaXNGdW5jIiwiZnVuYyIsImlzQXN5bmMiLCJjb25zdHJ1Y3RvciIsImV4ZWN1dGVPYmplY3RGdW5jdGlvbiIsInBhcmFtcyIsInByb2MiLCJtYXBCaW5kIiwidG8iLCJpdGVtIiwiYmluZCIsImlzQ2xhc3MiLCJmbiIsInRlc3QiLCJkZXRlY3RUeXBlIiwidGVzdGllIiwiZGF0YSIsImxvY2FsSXNvRGF0ZSIsImxvY2FsSXNvU3RyaW5nIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldFRvZGF5IiwidG9kYXkiLCJiYWNrbG9nQWRkIiwibXNnIiwiYmFja2xvZyIsInB1c2giLCJkdW1wQmFja2xvZyIsInJvdyIsInNoaWZ0IiwiTE9HIiwibG9nTXNnIiwibm93IiwibG9nIiwiY3JlYXRlTG9nZ2VyIiwicHJlZml4IiwiZ2VuTG9nTXNnIiwiZXJyb3IiLCJnZW5Mb2dFcnJvciIsImRlYnVnIiwiZ2VuTG9nRGVidWciLCJyZXBvcnQiLCJpc0RldiIsIkRFVl9FTlYiLCJOT09QIiwibG9nRXJyb3IiLCJnZXRBcHAiLCJyZXBvcnRlciIsImdldFNlcnZpY2UiLCJjYXRjaCIsInRyYWNlIiwidHJpbUJhY2tzbGFzaCIsInN0ciIsInN1YnN0cmluZyIsImJ1aWxkVVJMIiwibW9kdWxlIiwibW9kZWwiLCJpZCIsImFjdGlvbiIsInVybCIsImVuY29kZVVSSUNvbXBvbmVudCIsImZpbHRlciIsImVsIiwiY2FwaXRhbGl6ZUZpcnN0TGV0dGVyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImxvd2VyRmlyc3RMZXR0ZXIiLCJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInN0ckxlbmd0aENhcCIsIk1BWF9USVRMRV9MRU5HVEgiLCJQT1NUX0ZJWCIsInN1YnN0ciIsImVzY2FwZUh0bWwiLCJ1bnNhZmUiLCJzdGFydEFwcCIsInN0YXJ0ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZXh0ZW5kQXBwQ29uZmlnIiwiY29uZiIsImNvbmYyIiwiZGVlcE1lcmdlIiwiYWJzb3JiTW9kdWxlIiwiZGVmYXVsdENvbmYiLCJtb2QiLCJ0YXJnZXRzIiwiaGFzT3duUHJvcGVydHkiLCJzZXJ2aWNlcyIsInVpcyIsIndjcyIsIm1hbmlmZXN0IiwiY29udHJvbGxlcnMiLCJub3RFbnYiLCJkZWZpbmVJZk5vdEV4aXN0cyIsInJlZ2lzdGVyIiwicmVnaXN0cnkiLCJtb3ZlSXRlbSIsIm9sZF9pbmRleCIsIm5ld19pbmRleCIsImluUmFuZ2UiLCJudW0iLCJzcGxpY2UiLCJzdHJpcFByb3h5IiwiaXNQcm94eSIsImFzc2lnbiIsInBpcGUiLCJmdW5jcyIsInJlc3VsdCIsImdldEFQSSIsImdldE1hbmFnZXIiLCJzZXRNYW5hZ2VyIiwidiIsIk1BTkFHRVIiLCJnZXRKU09OIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwid2FpdCIsIlByb21pc2UiLCJyZXMiLCJzZXRUaW1lb3V0IiwicmVnaXN0ZXJXaWRnZXRFdmVudHMiLCJldmVudHMiLCJldmVudE5hbWUiLCJvbiIsIm5hdmlnYXRlIiwiZ2V0V29ya2luZyIsInNlbGVjdCIsInZhcmlhbnRzU2V0IiwiZGVmIiwiX25vdENvbW1vbiIsIk5PVF9FTlZfVFlQRSIsImFic29yYlNlcnZpY2VzIiwic2VydiIsImV4dGVuZFdTQ2xpZW50Iiwid3NjTmFtZSIsIndzY09wdGlvbnMiLCJjb25uZWN0aW9uIiwicm91dGVyIiwicm91dGVzIiwibWVzc2VuZ2VyIiwicm91dGVUeXBlIiwiYWJzb3JiV1NDIiwid3NDbGllbnROYW1lIiwiYWJzb3JiVUlzIiwidWkiLCJhYnNvcmJGaWVsZHMiLCJub3RMb2NhbGUiLCJfRXZlbnRFbWl0dGVyIiwiX3RoaXMiLCJfY2FsbFN1cGVyIiwiZGljdCIsImhlbHBlcnMiLCJyZXN0b3JlRnJvbVN0b3JhZ2UiLCJfaW5oZXJpdHMiLCJmb3JtYXQiLCJwYXJzZVN1YnMiLCJzYXkiLCJwaHJhc2UiLCJ0bXBsIiwic2F2ZVRvU3RvcmFnZSIsImVtaXQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0SXRlbSIsInZvY2FidWxhcnkiLCJFdmVudEVtaXR0ZXIiLCIkLnByb3AiLCIkLmRlcml2ZWQiLCIkLnByb3h5IiwiJC5zbmFwc2hvdCIsIiQuc2V0X3RleHQiLCJVSUJvb2xlYW4iLCIkLnN0YXRlIiwiJC5lYWNoIiwiJC5nZXQiLCIkLnNuaXBwZXQiLCIkLmJpbmRfdGhpcyIsIiQuc2V0X2NsYXNzIiwiJC50ZW1wbGF0ZV9lZmZlY3QiLCIkLmNsc3giLCJvbkNsaWNrIiwiVUlCdXR0b24iLCJVSUJ1dHRvblN3aXRjaCIsIiQuc3ByZWFkX3Byb3BzIiwiVUlCdXR0b25zIiwiJC5tdXRhYmxlX3N0YXRlIiwidGV4dCIsIiQubXV0YXRlIiwiJC5ldmVudCIsIiQud2luZG93IiwiJC5kZXJpdmVkX3NhZmVfZXF1YWwiLCIkLnByZXZlbnREZWZhdWx0IiwiJC50b2dnbGVfY2xhc3MiLCIkLmFuaW1hdGlvbiIsIiQudHJhbnNpdGlvbiIsIiQuaHRtbCIsIlVJQ2hlY2tib3hJbnB1dCIsIiQuYmluZF92YWx1ZSIsIkxpYiIsInNlZWRMaWIiLCJfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyIsIl9saWIiLCJpbXBvcnQiLCJnZXRDb250ZW50IiwiY29tcCIsIm1vZGUiLCJjb250YWlucyIsIl9jbGFzc1ByaXZhdGVGaWVsZEdldCIsImJ1bGsiLCJmIiwiaXNFbXB0eSIsIkNPTVBPTkVOVFMiLCJGSUVMRFMiLCJWQVJJQU5UUyIsIlVJTGluayIsIlVJVGl0bGUiLCIkLnNldF9hdHRyaWJ1dGUiLCJVSUxpc3RJdGVtIiwiVUlMaXN0RW1wdHlQbGFjZWhvbGRlciIsIlVJSW1hZ2UiLCJVSUxpc3QiLCJERUZBVUxUX1NUQVRVU19TVUNDRVNTIiwiTkFWSUdBVElPTl9ERUxBWV9TSE9SVCIsIk5BVklHQVRJT05fREVMQVlfTk9STUFMIiwiTkFWSUdBVElPTl9ERUxBWV9MT05HIiwiTkFWSUdBVElPTl9ERUxBWVMiLCJTSE9SVCIsIk5PUk1BTCIsIkxPTkciLCJOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQiLCJVSUJ1dHRvbnNSb3ciLCIkLnVwZGF0ZV9wcm9wIiwiVUlFbmRsZXNzTGlzdFNpbXBsZUl0ZW0iLCJVSUVuZGxlc3NMaXN0RW1wdHlQbGFjZWhvbGRlciIsIlVJRW5kbGVzc0xpc3ROYXZpZ2F0aW9uIiwiTGlzdEdyb3Vwc1VJVHJlZURUTyIsImNvbnZlcnRHcm91cFRpdGxlIiwidGl0bGUiLCJjb252ZXJ0R3JvdXBJbWFnZSIsImltYWdlIiwiY29udmVydFZhcmlhbnQiLCJ2YXJpYW50IiwiZ3JvdXBJZCIsInZhbHVlSWQiLCJjb252ZXJ0VmFyaWFudHNHcm91cCIsImdyb3VwIiwiZGVzY3JpcHRpb24iLCJ2YWx1ZXMiLCJ2YXJpYW50cyIsIml0bSIsImJ1aWxkU2VsZWN0b3JJdGVtc0Zyb21WYXJpYW50cyIsIl90aGlzMiIsInN1YmxpbWVWYWx1ZSIsImdldFNlbGVjdG9yR3JvdXBJbmRleCIsInNlbGVjdG9yR3JvdXBzSXRlbXMiLCJmaW5kSW5kZXgiLCJnZXRTZWxlY3Rvckdyb3VwIiwic2VsZWN0b3JHcm91cEhhc1ZhcmlhbnRzIiwiZ2V0U2VsZWN0b3JHcm91cFZhcmlhbnRzIiwiY29tcGFyZVNlbGVjdG9yR3JvdXBWYWx1ZUlkV2l0aCIsInZhcmlhbnRJZCIsImdldFNlbGVjdG9ySXRlbUluZGV4IiwiZ3JvdXBJbmRleCIsIml0ZW1JbmRleCIsImdldFNlbGVjdG9ySXRlbUluZGV4ZXMiLCJnZXRTZWxlY3Rvckl0ZW0iLCJpdGVtSWRzIiwiaW5kZXhlcyIsImdyb3VwVmFyaWFudHMiLCJnZXREZWZhdWx0U2VsZWN0b3JJdGVtU3VibGltZSIsInVwZGF0ZVNlbGVjdG9ySXRlbSIsIml0ZW1Qcm9wcyIsImFjdGlvbnNVSVByb3BzIiwiYWN0aW9ucyIsInVpUHJvcHMiLCJ1aU9uIiwiVUlfUFJPUFNfREVMVEFfT04iLCJVSV9QUk9QU19ERUxUQV9PTl9BQ1RJT04iLCJ1aU9mZiIsIlVJX1BST1BTX0RFTFRBX09GRiIsIlVJX1BST1BTX0RFTFRBX09GRl9BQ1RJT04iLCJzeW5jVUlXaXRoVmFsdWUiLCJzZWxlY3Rvckdyb3VwcyIsIml0ZW1JblZhbHVlIiwiaXRlbXMiLCJjbGFzcyIsImNvbG9yIiwiTGlzdEdyb3Vwc1ZhbHVlRFRPTXVsdGlwbGVCZWhhdmlvdXIiLCJjb3VudEl0ZW1zSW5WYWx1ZSIsImluaXRWYWx1ZSIsImdyb3VwSXRlbXNJc1ZhbGlkIiwiZ3JvdXBJdGVtcyIsImNsZWFyRnJvbUVtcHR5R3JvdXBzIiwiZ3JvdXBJc0VtcHR5IiwiZ3JvdXBJc0Z1bGwiLCJ2YWx1ZUdyb3VwIiwidmFyaWFudHNHcm91cCIsInJlbW92ZUl0ZW1Gcm9tVmFsdWUiLCJhdExlYXN0T25lIiwiYWRkSXRlbVRvVmFsdWUiLCJvbmx5T25lUGVyR3JvdXAiLCJzZWxlY3RBbGwiLCJzZWxlY3ROb25lIiwic2VsZWN0QWxsSW5Hcm91cCIsIl90aGlzMyIsImZpbmQiLCJzZWxlY3ROb25lSW5Hcm91cCIsInZhbHVlQXNWYXJpYW50cyIsIl90aGlzNCIsIkxpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91ciIsIkxpc3RHcm91cHNWYWx1ZURUTyIsImJlaGF2aW91ciIsIm11bHRpcGxlIiwidG9nZ2xlIiwiVUlCdXR0b25zU3dpdGNoZXJzIiwiVUlCdXR0b25DbG9zZSIsIlVJU2ltcGxlU2VhcmNoSW5wdXQiLCJVSUVuZGxlc3NMaXN0IiwiTUVUQV9NRVRIT0RfSU5JVCIsIk1FVEFfREFUQSIsIk1FVEFfV09SS0lORyIsIk1FVEFfT1BUSU9OUyIsIm5vdEJhc2UiLCJpbnB1dCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2V0RGF0YSIsInNldFdvcmtpbmciLCJ3b3JraW5nIiwic2V0T3B0aW9ucyIsImluZm8iLCJzZXRDb21tb24iLCJ3aGF0IiwiYXJncyIsImdldENvbW1vbiIsImdldERhdGEiLCJnZXRPcHRpb25zIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50IiwiT1BUX01PREVfSElTVE9SWSIsIk9QVF9NT0RFX0hBU0giLCJPUFRfREVGQVVMVF9DSEVDS19JTlRFUlZBTCIsIm5vdFJvdXRlciIsIl9ub3RCYXNlIiwicm9vdCIsImluaXRpYWxpemVkIiwiZGVsYXlzIiwiZGVsYXlfZGVmYXVsdCIsInNldERlbGF5cyIsInNldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkiLCJkZWxheSIsImRlbGF5QXNNcyIsImdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkiLCJuYXZpZ2F0ZVdpdGhEZWxheSIsImRvQmVmb3JlIiwiaGlzdG9yeSIsImhhc2giLCJzZXRSb290IiwiY2xlYXJTbGFzaGVzIiwicGF0aCIsInJlIiwicnVsZSIsImFkZExpc3QiLCJwYXJhbSIsImkiLCJyIiwiZmx1c2giLCJpc0luaXRpYWxpemVkIiwic2V0SW5pdGlhbGl6ZWQiLCJnZXRGcmFnbWVudCIsImZyYWdtZW50IiwibG9jYXRpb24iLCJkZWNvZGVVUkkiLCJwYXRobmFtZSIsInNlYXJjaCIsIm1hdGNoIiwiaHJlZiIsImNoZWNrTG9jYXRpb24iLCJjdXJyZW50IiwiaW5pdCIsImNoZWNrIiwiaHJlZkNsaWNrIiwiZ2V0Um9vdCIsImxpc3RlbiIsImxvb3BJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImZhaWxCYWNrIiwiZnVsbFJFIiwicm91dGUiLCJhcHBseSIsImhvc3QiLCJyZWZyZXNoIiwidGltZW91dCIsIm5ld1JvdXRlIiwiZ2V0RnVsbFJvdXRlIiwibGFzdFJvdXRlIiwicHVzaFN0YXRlIiwiZ2V0QWxsTGlua3MiLCJhbGxFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqIiwiYXR0cyIsImF0dHJpYnV0ZXMiLCJub2RlTmFtZSIsInJlUm91dGVFeGlzdGVkIiwiaW5pdFJlcm91dGluZyIsImdldEF0dHJpYnV0ZSIsImxpbmsiLCJub3RSb3V0ZXJJbml0aWFsaXplZCIsImZ1bGxMaW5rIiwic2V0QXR0cmlidXRlIiwiTE9HX1BSRUZJWCIsIm5vdEFQSVF1ZXVlIiwiYnVzeSIsInF1ZXVlIiwiYnVzeVNpbmNlIiwiYWZ0ZXJFbXB0eSIsInN0YXJ0Iiwic3RvcCIsImludGVydmFsIiwiY2hlY2tRdWV1ZSIsIlFVRVVFX0NIRUNLX0lOVEVSVkFMIiwiaXNCdXN5Iiwic2V0QnVzeSIsInJ1bk5leHQiLCJzZXRGcmVlIiwiYWRkVG9RdWV1ZSIsInRhc2siLCJyZXNvbHZlIiwiTUFYX0JVU1lfVElNRSIsInJ1biIsInJlamVjdCIsImFjdGlvbklzUXVldWVkIiwic29tZSIsInF1ZXVlZCIsInJ1bklmTm90UXVldWVkIiwibm90QVBJT3B0aW9ucyIsInJwcyIsInByb3RvY29sIiwicG9ydCIsIm5vdEFQSUNvbm5lY3Rpb24iLCJvbmxpbmUiLCJpbnQiLCJwYXVzZSIsInJlc3VtZSIsImlzT25saW5lIiwib25MaW5lIiwiY2hhbmdlU3RhdGUiLCJBTEwiLCJleGlzdCIsImNyZWF0ZSIsInByb3BzIiwicmF3IiwiZmlsdGVyZWQiLCJzZWxlY3RlZCIsImZha2UiLCJNRVRBX0lOVEVSRkFDRSIsIk1FVEFfTUFQX1RPX0lOVEVSRkFDRSIsIkRFRkFVTFRfQUNUSU9OX1BSRUZJWCIsIk9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFkiLCJERUZBVUxUX0ZJTFRFUiIsIkRFRkFVTFRfU0VBUkNIIiwiREVGQVVMVF9SRVRVUk4iLCJERUZBVUxUX1BBR0VfTlVNQkVSIiwiREVGQVVMVF9QQUdFX1NJWkUiLCJERUZBVUxUX1dTX1JPVVRFX0FDVElPTl9TUExJVFRFUiIsIm5vdEludGVyZmFjZSIsInJldHVybiIsInBhZ2VyIiwic2l6ZSIsInBhZ2UiLCJpbml0QWN0aW9ucyIsImdldEFjdGlvbnNDb3VudCIsImdldEFjdGlvbnMiLCJhY3Rpb25OYW1lIiwiaW5pdEFjdGlvbiIsImhlYWRlcnMiLCJmaWxlVXBsb2FkIiwiZmlsZXMiLCJyZXF1ZXN0IiwicmVxdWVzdEhUVFAiLCJyZWNvcmQiLCJjb21wb3NpdGVEYXRhIiwiYWN0aW9uRGF0YSIsImdldEFjdGlvbkRhdGEiLCJyZXF1ZXN0UGFyYW1zIiwiY29sbGVjdFJlcXVlc3REYXRhIiwicmVxdWVzdFBhcmFtc0VuY29kZWQiLCJlbmNvZGVSZXF1ZXN0IiwiYXBpU2VydmVyVVJMIiwiZ2V0U2VydmVyVVJMIiwiZ2V0VVJMIiwiZmQiLCJGb3JtRGF0YSIsImFwcGVuZCIsIm1ldGhvZCIsIkFjY2VwdCIsInJlcXVlc3RXUyIsIldTIiwiZ2V0V1NDbGllbnQiLCJtZXNzYWdlTmFtZSIsImdldFdTUmVxdWVzdE5hbWUiLCJwYXlsb2FkIiwibWVzc2FnZSIsInNlbGVjdFRyYW5zcG9ydCIsIndzSXNVcCIsIndzIiwiY2xpZW50Iiwid3NDbGllbnQiLCJnZXRNb2RlbE5hbWUiLCJwYXJzZVBhcmFtcyIsImVuZCIsImxpbmUiLCJmaWVsZE5hbWUiLCJsZW4iLCJpbmQiLCJzdGFydFNsaWNlIiwiZW5kU2xpY2UiLCJwYXJzZUxpbmUiLCJwb3N0Rml4IiwibW9kZWxOYW1lIiwicCIsInJlcXVlc3REYXRhIiwiZGF0YVByb3ZpZGVyTmFtZSIsImdldElEIiwicmVzdWx0SWQiLCJwcmVmaXhlcyIsInByZSIsInNldEZpbmRCeSIsInNldEZpbHRlciIsImZpbHRlckRhdGEiLCJyZXNldEZpbHRlciIsImdldEZpbHRlciIsInNldFNlYXJjaCIsInNlYXJjaERhdGEiLCJyZXNldFNlYXJjaCIsImdldFNlYXJjaCIsInNldFNvcnRlciIsInNvcnRlckRhdGEiLCJyZXNldFNvcnRlciIsImdldFNvcnRlciIsInNldFJldHVybiIsInJldHVybkRhdGEiLCJyZXNldFJldHVybiIsImdldFJldHVybiIsInNldFBhZ2VOdW1iZXIiLCJwYWdlTnVtYmVyIiwic2V0UGFnZVNpemUiLCJwYWdlU2l6ZSIsInNldFBhZ2VyIiwiaXNOYU4iLCJyZXNldFBhZ2VyIiwiZ2V0UGFnZXIiLCJnZXRSZWNvcmQiLCJnZXREZWZhdWx0QXNQbGFpbk9iamVjdCIsImZpZWxkcyIsImRlZmF1bHQiLCJub3RSZWNvcmQiLCJpc1JlY29yZCIsImlzUHJvcGVydHkiLCJjcmVhdGVDb2xsZWN0aW9uIiwiaW50ZXJmYWNlVXAiLCJtYXBUb0ludGVyZmFjZSIsIm1hcFRvTWV0aG9kcyIsInRvRGVmYXVsdCIsInJlYyIsImFwcCIsIm1ldGhvZHMiLCJjb2xsZWN0aW9uIiwiYWN0aW9uVXAiLCJzZXRBdHRyIiwic2V0QXR0cnMiLCJvYmplY3RQYXJ0IiwiZ2V0QXR0ciIsInBsYWluIiwicHJ4IiwiZ2V0QXR0cnMiLCJnZXRNYW5pZmVzdCIsIk9QVF9DT05UUk9MTEVSX1BSRUZJWCIsIk9QVF9SRUNPUkRfUFJFRklYIiwiREVGQVVMVF9XU19DTElFTlRfTkFNRSIsIm5vdEFwcCIsImludGVyZmFjZXMiLCJpbml0Q29udHJvbGxlciIsImN1cnJlbnRDb250cm9sbGVyIiwid3NjIiwid3NzIiwiaW5pdE1hbmlmZXN0Iiwic2V0SW50ZXJmYWNlTWFuaWZlc3QiLCJpbml0Um91dGVyIiwiZXhlY1JvdXRlciIsInJvdXRpZUlucHV0Iiwicm91dGVCbG9jayIsInBhdGhzIiwic2NoZW1lcyIsImNvbnRyb2xsZXIiLCJwYXRoU2NoZW1lIiwiYmluZENvbnRyb2xsZXIiLCJnZXRJbnRlcmZhY2VNYW5pZmVzdCIsInVwZGF0ZUludGVyZmFjZXMiLCJpbml0U2VydmljZXMiLCJjb250cm9sbGVyTmFtZSIsImNvbnRyb2xsZXJQYXRoU2NoZW1lIiwiZ2V0Q3VycmVudENvbnRyb2xsZXIiLCJzZXRDdXJyZW50Q29udHJvbGxlciIsImN0cmwiLCJvbGRDdHJsIiwiY3JlYXRlSW50ZXJmYWNlTW9kZWxGYWN0b3J5IiwicmVjb3JkTWFuaWZlc3QiLCJyZWNvcmREYXRhIiwiY2xlYXJJbnRlcmZhY2VzIiwibWFuaWZlc3RzIiwicmVjb3JkTWV0aG9kcyIsIm5hbWVJbnQiLCJzZXRJbnRlcmZhY2UiLCJnZXRSZWNvcmROYW1lIiwiZ2V0Q29udHJvbGxlck5hbWUiLCJtb2RlbEZhY3RvcnkiLCJnZXRJbnRlcmZhY2VzIiwic2V0V1NDbGllbnQiLCJnZXRJbnRlcmZhY2UiLCJnZXRNb2RlbCIsInNldFNlcnZpY2UiLCJzZXJ2TmFtZSIsInNlcnZUeXBlIiwiZ2V0Q29uZmlnUmVhZGVyRm9yTW9kdWxlIiwibW9kdWxlTmFtZSIsIm1vZENvbmZQYXRoIiwic3ViUGF0aCIsImZhbGxiYWNrIiwibW9kdWxlQ29uZmlnIiwiT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUiLCJPUFRfREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IiLCJPUFRfREVGQVVMVF9QTFVSQUxfTkFNRSIsIk9QVF9ERUZBVUxUX1NJTkdMRV9OQU1FIiwiT1BUX0RFRkFVTFRfTU9EVUxFX05BTUUiLCJPUFRfREVGQVVMVF9BVVRPX05BTUUiLCJub3RDb250cm9sbGVyIiwicmVhZHkiLCJ2aWV3cyIsImxpYnMiLCJlbHMiLCJjb250YWluZXJTZWxlY3RvciIsIm5hbWVzIiwicGx1cmFsIiwic2luZ2xlIiwic2V0VVJMUHJlZml4IiwibWFrZSIsInVpTmFtZSIsIiRkZXN0cm95Iiwic2V0TW9kZWwiLCJzZXRNb2RlbE5hbWUiLCJnZXRNb2RlbElERmllbGROYW1lIiwic2V0TW9kZWxJREZpZWxkTmFtZSIsInNldFJlYWR5IiwidXBkYXRlQXV0b05hbWUiLCJnZXRVUkxQcmVmaXgiLCJzZXRNb2R1bGVOYW1lIiwiZ2V0TW9kdWxlTmFtZSIsImdldE1vZHVsZVByZWZpeCIsImdldE1vZGVsVVJMIiwiZ2V0TW9kZWxBY3Rpb25VUkwiLCJzZXROYW1lIiwiZ2V0TmFtZSIsInByZWxvYWRMaWIiLCIkbGlzdEFsbCIsImVyciIsIm9uQWZ0ZXJSZW5kZXIiLCJnZXRBY3Rpb25OYW1lIiwiZ2V0RGVmYXVsdEFjdGlvbk5hbWUiLCJyb3V0ZXJOYW1lIiwic3ViUGFyYW1zIiwic2V0Q3VycmVudEFjdGlvbiIsImdldEN1cnJlbnRBY3Rpb24iLCJnZXRBcHBPcHRpb25zIiwiZ2V0TW9kdWxlT3B0aW9ucyIsImdldFNlcnZpY2VzIiwiZ2V0Q29tcG9uZW50cyIsImdldFJvdXRlciIsIm5hdmlnYXRlQWN0aW9uIiwibmF2aWdhdGVNb2R1bGVBY3Rpb24iLCJuYXZpZ2F0ZU1vZGVsQWN0aW9uIiwiZ2V0Q29udHJvbGxlclJvdXRlIiwicGFyYW1zQ291bnQiLCJNT0RVTEVfTkFNRSIsIk1PREVMX05BTUUiLCJnZXRDb250cm9sbGVyUm91dGVzIiwicGFyYW1zRGVlcCIsImdldFJvdXRlcyIsIlBBUkFNU19MRU5HVEgiLCJnZXRDb21tb25NZW51IiwiY2hpbGRDb25zdHJ1Y3RvciIsInNlY3Rpb24iLCJMQUJFTFMiLCJnZXRNZW51IiwiU3RvcmVzLmdldCIsIiQuYmluZF9jaGVja2VkIiwiJC5zdG9yZV9tdXRhdGUiLCIkLnVudHJhY2siLCJDT05TVF9JRF9EVUJMSUNBVEVfUE9TVEZJWCIsIk9QVF9ERUZBVUxUX1BBR0VfU0laRSIsIk9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSIiwiT1BUX0RFRkFVTFRfUEFHRV9SQU5HRSIsIk9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OIiwiT1BUX0RFRkFVTFRfU0VBUkNIIiwiT1BUX0RFRkFVTFRfUkVUVVJOIiwiT1BUX0RFRkFVTFRfQ09NQklORUQiLCJPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT04iLCJPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT04iLCJPUFRfREVGQVVMVF9MSVNUX0FDVElPTiIsIk9QVF9ERUZBVUxUX1NPUlRfRklFTEQiLCJPUFRfRklFTERfTkFNRV9QUkVfUFJPQyIsIkRFRkFVTFRfT1BUSU9OUyIsIlVJVGFibGUiLCJsaW5rcyIsImVuZGxlc3MiLCJpZEZpZWxkIiwiZ2V0SXRlbUlkIiwiX2lkIiwibm90VGFibGUiLCJyYW5kb20iLCJyZWZpbmVkIiwic3RhdGUiLCJwYWdpbmF0aW9uIiwiY291bnQiLCJwYWdlcyIsInN0b3JlcyIsIlN0b3JlcyIsIm9uV29ya2luZ1VwZGF0ZSIsIm9uUmF3VXBkYXRlIiwib25GaWx0ZXJlZFVwZGF0ZSIsIm9uUmVmaW5lZFVwZGF0ZSIsIm9uU2VsZWN0ZWRVcGRhdGUiLCJvblN0YXRlVXBkYXRlIiwic2V0Q29tYmluZWRBY3Rpb25OYW1lIiwic29ydGVyIiwicmVuZGVyIiwidXBkYXRlRGF0YSIsInJlZmluZUZpbHRlcmVkIiwiY2xlYXJTZWxlY3RlZCIsIm9uU2VhcmNoQ2hhbmdlIiwib25Tb3J0ZXJDaGFuZ2UiLCJvbkZpbHRlckNoYW5nZSIsImdldFNlbGVjdGVkIiwib2JqZWN0Iiwic3RvcmUiLCJpbmR4IiwidGFibGUiLCJ0YXJnZXRFbCIsImZpbHRlclVJIiwiZ2V0SGVscGVycyIsImdldExpbmtzIiwic2hvd1NlbGVjdCIsInNob3dTZWFyY2giLCJzaG93U29ydCIsIiRvbiIsImRldGFpbCIsImdvVG9QYWdlIiwiZ29Ub05leHQiLCJnb1RvUHJldiIsIl90aGlzNSIsInNldFN0YXRlIiwiX3RoaXM2IiwiZ2V0U3RhdGUiLCJ3aXRob3V0SW52YWxpZGF0aW9uIiwiaW52YWxpZGF0ZURhdGEiLCJnZXREZWZhdWx0UGFnZU51bWJlciIsImdldERlZmF1bHRQYWdlU2l6ZSIsImdldFNvcnRlckRpcmVjdGlvbiIsInJldCIsImNsZWFyRmlsdGVyZWREYXRhIiwiY2xlYXJSYXdEYXRhIiwiY2xlYXJSZWZpbmVkRGF0YSIsImlzTGl2ZSIsInNldFVwZGF0aW5nIiwic2V0VXBkYXRlZCIsImlmVXBkYXRpbmciLCJnZXREYXRhSW50ZXJmYWNlIiwiZmFjdG9yeSIsImdldExvYWREYXRhQWN0aW9uTmFtZSIsImdldENvbWJpbmVkQWN0aW9uTmFtZSIsImdldENvdW50QWN0aW9uTmFtZSIsImxvYWREYXRhIiwicXVlcnkiLCJtYXgiLCJnb1RvRmlyc3QiLCJnb1RvTGFzdCIsInRlc3REYXRhSXRlbSIsInN0clZhbHVlIiwiayIsInRvQ29tcCIsImdldFJvd3NDb3VudCIsIl90aGlzNyIsInVwZGF0ZVBhZ2luYXRpb24iLCJpdGVtc0NvdW50IiwiX3RoaXM4IiwiaXRlbXNGcm9tIiwicGFnZXNDb3VudCIsInBhZ2VzRnJvbSIsInBhZ2VzVG8iLCJpdGVtc1RvIiwiYWN0aXZlIiwiX3RoaXM5IiwiZnVsbCIsInByb2Nlc3NEYXRhIiwiX3RoaXMxMCIsInRoYXRGaWx0ZXIiLCJmaWx0ZXJTZWFyY2giLCJ0aGF0U29ydGVyIiwic29ydCIsIml0ZW0xIiwiaXRlbTIiLCJ0MSIsInNvcnRCeUZpZWxkIiwidDIiLCJsb2NhbGVDb21wYXJlIiwic29ydERpcmVjdGlvbiIsImxvZ2dlciIsImNoZWNrRmllbGRzTmFtZXMiLCJmaWVsZElkIiwicGF0aElkIiwicmVhZEZpZWxkVmFsdWUiLCJfdGhpczExIiwicHJlcHJvY2Vzc2VkIiwiREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IiLCJfdWlDb21wb25lbnQiLCJXZWFrTWFwIiwiX3VpIiwibm90QWN0aW9uVUkiLCJVSUFjdGlvbkNvbnRhaW5lciIsIl9jbGFzc1ByaXZhdGVGaWVsZFNldCIsImluaXRVSSIsImdldFRhcmdldEVsIiwiY2hpbGRyZW4iLCJyZW1vdmVDaGlsZCIsImZpcnN0Q2hpbGQiLCJzZXRMb2FkaW5nIiwicmVzZXRMb2FkaW5nIiwicHJvY2Vzc1Jlc3VsdCIsInNldEZvcm1TdWNjZXNzIiwic2V0Rm9ybUVycm9ycyIsInNob3dTdWNjZXNzIiwiZm9ybSIsImVycm9ycyIsInNob3dFcnJvciIsIkhUTUxFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIm5vdEZvcm1VdGlscyIsImFkZENvbXBvbmVudCIsImFkZFZhcmlhbnRzIiwiYWRkRmllbGQiLCJhY3Rpb25GaWVsZHNJbml0Iiwic3ViRmllbGROYW1lIiwiREVGQVVMVF9GSUVMRCIsImxhYmVsIiwicGxhY2Vob2xkZXIiLCJlbmFibGVkIiwidmlzaWJsZSIsInJlcXVpcmVkIiwidmFsaWRhdGVkIiwidmFsaWQiLCJmaWVsZEluaXQiLCJtdXRhdGlvbiIsInZhcmlhbnRzU291cmNlIiwiaW5pdEZvcm1CeUZpZWxkIiwiZm9ybUZpZWxkc09wdGlvbnMiLCJzdWJGb3JtRmllbGROYW1lIiwibXV0YXRpb25zIiwicmVhZG9ubHkiLCJzZXRGaWVsZEludmFsaWQiLCJzZXRGaWVsZFZhbGlkIiwiZm5hbWUiLCJpc0ZpZWxkVmFsaWQiLCJzZXRGb3JtRmllbGRJbnZhbGlkIiwiZm9ybUVycm9ycyIsImlucHV0U3RhcnRlZCIsImZvcm1MZXZlbEVycm9yIiwic2V0Rm9ybUZpZWxkVmFsaWQiLCJ1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyIsInZhbGlkYXRpb25TdGF0dXMiLCJzZXRGaWVsZHNWaXNpYmlsaXR5IiwiZmllbGRzTGlzdCIsInNldEZpZWxkVmFsdWUiLCJmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCIsImNvbGxlY3REYXRhIiwiZmxhdCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsIkRFRkFVTFRfUlVMRVMiLCJub3RSZWFkb25seSIsImVuYWJsZSIsImRpc2FibGVkIiwiZGlzYWJsZSIsIm5vdEZvcm1SdWxlcyIsIl9hc3NlcnRDbGFzc0JyYW5kIiwiX1JVTEVTIiwiXyIsImV4ZWMiLCJtYXN0ZXIiLCJzbGF2ZXMiLCJERUZBVUxUX0FDVElPTl9OQU1FIiwiX3ZhbGlkYXRpb25SdW5uZXIiLCJfZm9ybSIsIl9hY3Rpb24iLCJfZmllbGRzIiwiX3ZhcmlhbnRzIiwiX25vdEZvcm1fYnJhbmQiLCJXZWFrU2V0Iiwibm90Rm9ybSIsIlVJRm9ybUNvbXBvbmVudCIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsImluaXRGb3JtIiwiaW5pdExpYnMiLCJpbml0RmllbGRzIiwiaW5pdFZhcmlhbnRzIiwiaW5pdFZhbGlkYXRvciIsInJlSW5pdCIsInVwZGF0ZVVJIiwiZ2V0Rm9ybU1hbmlmZXN0IiwiUnVubmVyIiwiZ2V0Rm9ybVZhbGlkYXRvcnMiLCJfZ2V0Rm9ybVByb3BzIiwiZm9ybU9wdGlvbnMiLCJnZXRGb3JtT3B0aW9ucyIsImdldEZvcm1EYXRhIiwiaW5qZWN0ZWRQcm9wcyIsImdldEZvcm1JbmplY3RlZFByb3BzIiwiZ2V0Rm9ybVRhcmdldEVsIiwiX2JpbmRVSUV2ZW50cyIsInZhbGlkYXRlRm9ybSIsIiRzZXQiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiZ2V0Rm9ybUFjdGlvbiIsImdldFJlcG9ydCIsImNsZWFuIiwiRVJST1JfREVGQVVMVCIsInN1Ym1pdCIsInNldEZvcm1BY3Rpb24iLCJnZXRWYXJpYW50IiwibGliIiwiX21pc3NpbmdPdmVycmlkZVdhcm5pbmciLCJ1cGRhdGVGaWVsZCIsImV2IiwiX2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cyIsIm1hc3RlcnMiLCJydWxlcyIsInJ1bGVOYW1lIiwicnVsZVNsYXZlcyIsIl9hZGRNYXN0ZXJTbGF2ZUV2ZW50cyIsIl9leGVjU2xhdmVSdWxlIiwiY21kIiwic2xhdmVGaWVsZCIsIkZvcm1IZWxwZXJzIiwibG9hZGluZyIsIm1pc3NpbmciLCJERUZBVUxUX0ZPUk1fU0VUX05BTUUiLCJfZm9ybVNldENvbXBvbmVudCIsIl9mb3JtQ29tcG9uZW50IiwiX2ZyYW1lIiwiX25vdEZvcm1TZXRfYnJhbmQiLCJub3RGb3JtU2V0IiwiZm9ybUNvbXBvbmVudCIsImZvcm1TZXRDb21wb25lbnQiLCJVSUZvcm1TZXRDb21wb25lbnQiLCJzaG93TW9kZXMiLCJzZXRGb3JtTW9kZSIsImdldEZyYW1lVGFyZ2V0RWwiLCJfZ2V0RnJhbWVQcm9wcyIsInVwZGF0ZUZvcm0iLCJpc01vZGVFeGlzdHMiLCJnZXRGaXJzdE1vZGUiLCJ1cGRhdGVGb3JtTW9kZUluVUkiLCJnZXRGb3JtTW9kZSIsImRlc3Ryb3lGb3JtIiwicmVuZGVyRm9ybSIsImZvcm1Db25maWciLCJnZXRGb3JtQ29uZmlnIiwiY2hhbmdlTW9kZSIsImNvbnRhaW5lckVsIiwibGFzdENoaWxkIiwiZGVzdHJveUZyYW1lIiwiZm9ybXMiLCJsb2NhbF91aV9wcm9wcyIsIiQiLCJub3RCcmVhZGNydW1icyIsImluaXRVSVByb3BzIiwiZ2V0QnJlYWRjcnVtYnMiLCJnbyIsIlVJQ29uc3RydWN0b3IiLCJtb3VudCIsInNldEhlYWQiLCJoZWFkIiwic2V0VGFpbCIsInRhaWwiLCJjcnVtYnMiLCJ1bW91bnQiLCJVSUJyZWFkY3J1bWJzIiwiTWVudSIsImhpZGUiLCJzZXRBcHAiLCJnZXRPcHRpb25zUGF0aFRvIiwiaXNEaXJlY3ROYXZpZ2F0aW9uIiwiZGlyZWN0TmF2aWdhdGlvbiIsImJyYW5kIiwic2VjdGlvbnMiLCJ0YXJnZXRTZWxlY3RvciIsInRvZ2dsZVNlbGVjdG9yIiwib3BlbiIsImdldENvbXBvbmVudCIsImluaXRGaWVsZCIsIkRFRkFVTFQiLCJzb3J0TGlzdCIsInByaW9yaXR5IiwicmVtb3ZlRHVibGljYXRlcyIsInByZXBhcmVEYXRhIiwic2VjdGlvblRpdGxlIiwibWVudSIsInVwZGF0ZUluZGljYXRvciIsInNlY3Rpb25JZCIsIml0ZW1JZCIsInVwZGF0ZVNlY3Rpb24iLCJpbmRpY2F0b3IiLCJ1cGRhdGVJdGVtIiwidXBkYXRlVGFnIiwidGFnIiwidXBkYXRlU2VjdGlvblRhZyIsInVwZGF0ZUl0ZW1UYWciLCJ1cGRhdGVTZWN0aW9uSXRlbXMiLCJvbGRMaXN0IiwiaXNUb3VjaCIsImdldFNlY3Rpb25Db21wb25lbnQiLCJfTWVudSIsInVybHMiLCJzaG9ydCIsIlVJSWNvbiIsIlNpZGVNZW51U3RhdGUiLCJUWVBFIiwibm90U2lkZU1lbnUiLCJjcmVhdGVVSSIsIlVJU2lkZU1lbnUiLCJpbml0U2l6ZVJlc3BvbnNlIiwidXBkYXRlTWVudUFjdGl2ZUl0ZW0iLCJiaW5kVG9nZ2xlIiwiaXRlbUlzQWN0aXZlIiwiaXRlbVVSTCIsInVwZGF0ZU1lbnUiLCJsYXN0TG9jYXRpb24iLCJuYXYiLCJhc2lkZSIsIm1haW4iLCJyZXNpemVBc2lkZUFuZE1haW4iLCJyZXNpemVNYWluIiwic2hvdyIsInN0eWxlIiwiZGlzcGxheSIsIm1hcmdpbkxlZnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGVpZ2h0Iiwid2lkdGgiLCJsZWZ0IiwicmVzaXplQXNpZGUiLCJpbm5lckhlaWdodCIsIm1hcmdpblRvcCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJpc09wZW4iLCJfbm90U2lkZU1lbnUiLCJjbG9zZWQiLCJTaWRlTWVudVN0b3JlIiwiU2lkZU1lbnUiLCJub3RUb3BNZW51IiwiVUlOYXZiYXJUb3AiLCJzZXRCdXJnZXJTdGF0ZSIsIm1lbnVDbG9zZWQiLCJfbm90VG9wTWVudSIsInBsYWNlIiwiREVGQVVMVF9UUkFTRk9STUVSIiwiQUNUSU9OIiwiVElUTEUiLCJkYXRhUHJvdmlkZXIiLCJnb0JhY2siLCJfY2xhc3MiLCJzZXRCcmVhZGNydW1icyIsInByZWxvYWRWYXJpYW50cyIsIiRkZXN0cm95VUkiLCJyZXN1bHRUcmFuc2Zvcm1lciIsImdldENvbnRhaW5lcklubmVyRWxlbWVudCIsInNob3dFcnJvck1lc3NhZ2UiLCJQUkVMT0FEQUJMRSIsIkNSVURWYXJpYW50c1ByZWxvYWRlciIsInByZWxvYWQiLCJsaWJQcm9wcyIsInByb21zIiwiTW9kZWwiLCJyZXN1bHRzIiwicHJvcE5hbWUiLCJyZXN1bHRzTGlzdCIsIkRFRkFVTFRfQUNUSU9OIiwibm90Q1JVRFJvdXRlciIsImV4dHJhY3RBY3Rpb25OYW1lIiwiYWN0aW9uSGFuZGxlckV4aXN0cyIsInJ1bkFjdGlvbiIsIkNSVURNZXNzYWdlIiwic2V0VUkiLCJVSUVycm9yIiwic3VjY2VzcyIsIlVJU3VjY2VzcyIsIkRFRkFVTFRfQlJFQURDUlVNQl9UQUlMIiwiQ1JVREdlbmVyaWNBY3Rpb24iLCJwcmVzZXQiLCJnZXRCcmVhZGNydW1ic1RhaWwiLCJicmVhZGNydW1ic1RhaWxzIiwiZGVhZnVsdEJyZWFkY3J1bWJzVGFpbCIsImdldElkRmllbGQiLCJsb2FkRGF0YVF1ZXJ5IiwiZ2V0TW9kZWxBY3Rpb25OYW1lIiwiTU9ERUxfQUNUSU9OX0dFVCIsInByZXNldEJyZWFkY3J1bWJzIiwiZ2V0VGl0bGUiLCJjb250b2xsZXIiLCJnZXRJdGVtVGl0bGUiLCJicmVhZGNydW1ic1RhaWxUZW1wbGF0ZSIsImlzUmVzcG9uc2VCYWQiLCJnZXRWYWxpZGF0b3JzIiwicHJlcGFyZVVJT3B0aW9ucyIsImRldGFpbHNBY3Rpb25OYW1lIiwidmFsaWRhdG9ycyIsImluamVjdGVkIiwiVFJBTlNGT1JNRVIiLCJnZXRVSSIsInNldFVJTG9hZGluZyIsInNldFVJTG9hZGVkIiwic2V0VUlFcnJvciIsImJpbmRVSUV2ZW50cyIsImJpbmRVSUV2ZW50IiwiaXNVSVJlbmRlcmVkIiwidHdlYWtVSU9wdGlvbnMiLCJ1aUNvbXBvbmVudCIsInJlbmRlckxvYWRpbmdTY3JlZW4iLCJyZW1vdmVMb2FkaW5nU2NyZWVuIiwiZ29CYWNrQWZ0ZXJEZWxheSIsIk5BVklHQVRJT05fREVMQVkiLCJDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSIsIl9DUlVER2VuZXJpY0FjdGlvbiIsImRlZkRhdGEiLCJjcmVhdGVEZWZhdWx0Iiwib25BY3Rpb25TdWJtaXQiLCJDUlVEQWN0aW9uQ3JlYXRlIiwiX0NSVURHZW5lcmljQWN0aW9uQ3JlIiwiQ1JVREdlbmVyaWNBY3Rpb25SZWFkIiwiQ1JVREFjdGlvbkRldGFpbHMiLCJfQ1JVREdlbmVyaWNBY3Rpb25SZWEiLCJDUlVER2VuZXJpY0FjdGlvblVwZGF0ZSIsIk1PREVMX0FDVElPTl9QVVQiLCJDUlVEQWN0aW9uVXBkYXRlIiwiX0NSVURHZW5lcmljQWN0aW9uVXBkIiwiTU9ERUxfQUNUSU9OIiwiQ1JVREFjdGlvbkRlbGV0ZSIsImxvYWRlckFjdGl2ZSIsImxvYWRlclN0eWxlIiwibG9hZGVyVGl0bGUiLCJjb250YWluZXIiLCJjb25maXJtIiwiZGVsZXRlQWN0aW9uTmFtZSIsImdvTGlzdCIsIkNSVURBY3Rpb25MaXN0IiwidHdlYWtBY3Rpb25zTGlzdCIsIkFDVElPTlNfTElTVCIsImdvQ3JlYXRlIiwiY3JlYXRlQWN0aW9uc0J1dHRvbnMiLCJwcmVwZW5kIiwib25seUljb25zIiwiQUNUSU9OUyIsImRldGFpbHMiLCJnb0RldGFpbHMiLCJpY29uIiwiZ29VcGRhdGUiLCJkZWxldGUiLCJnb0RlbGV0ZSIsImFjdGlvbnNCdXR0b25zIiwicHJlcGFyZU9wdGlvbnMiLCJERUZBVUxUX09QVElPTlNfVEFCTEUiLCJpbnRlcmZhY2UiLCJjb21iaW5lZCIsIlRBQkxFX09QVElPTlMiLCJvcHRWYWwiLCJCUkVBRENSVU1CUyIsIlRJVExFX0ZJRUxEU19QUklPUklUWSIsIkxPQURJTkdfU0NSRUVOX1VJX05BTUUiLCJfYWN0aW9ucyIsIl9yb3V0ZXIiLCJfcHJlbG9hZGVyIiwibm90Q1JVRCIsIl9ub3RDb250cm9sbGVyIiwicHJlbG9hZGVyIiwiQ1JVREFjdGlvbnMiLCJDUlVEUm91dGVyIiwiYnVpbGRGcmFtZSIsInNldFZhbGlkYXRvcnMiLCJNb2R1bGVOYW1lUGFydHMiLCJzcGxpdCIsIk1vZHVsZU5hbWUiLCJzZXJ2aWNlTmFtZSIsIkNvbW1vbk1vZHVsZVNlcnZpY2UiLCJhdWdtZW50VmFsaWRhdG9ycyIsIm5ld0hlYWQiLCJzdGFydFdoZW5XU0NsaWVudFJlYWR5IiwiaXNDb25uZWN0ZWQiLCJvbmNlIiwiV1NfQ0hFQ0tfSU5URVJWQUwiLCJiYWNrVG9MaXN0IiwibGlua0JhY2tUb0xpc3QiLCJhZnRlckFjdGlvbiIsIm5hdkJhY2siLCJiYWNrIiwiY3JlYXRlRWxlbWVudCIsImdldEZyYW1lQ2xhc3NlcyIsIlRPUF9DTEFTUyIsImFwcGVuZENoaWxkIiwiTUFJTl9DTEFTUyIsImJvdHRvbSIsIkJPVFRPTV9DTEFTUyIsImdldENvbnRhaW5lclRvcEVsZW1lbnQiLCJnZXRDb250YWluZXJCb3R0b21FbGVtZW50IiwiZ2V0VGl0bGVGcm9tTGliIiwiZ2V0UHJlbG9hZGVkVmFyaWFudFRpdGxlIiwiZ2V0UHJlbG9hZGVkVmFyaWFudHMiLCJnb0FmdGVyRGVsYXkiLCJhY3Rpb25VSSIsImRlc3Ryb3lVSUJ5TmFtZSIsInNob3dTdWNjZXNzTWVzc2FnZSIsInNpbmdsZVVJIiwiZ2V0QWN0aW9uVUkiLCJjcmVhdGVMb2FkZXJVSSIsIlVJTG9hZGVyIiwiaXRlbUN1c3RvbVByb3BzIiwiUk9VVEVfTElTVCIsIm5vdENSVURQbGFpblJvdXRlciIsIkRFRkFVTFRfUk9VVEUiLCJub3RDUlVEUm91dGVyU3dpdGNoIiwiaXNSb3V0ZVZhcmlhbnRWYWxpZCIsInJvdXRlc1ZhcmlhbnRzIiwiZGV0ZXJtaW5lUm91dGUiLCJyb3V0ZXJBY3Rpb24iLCJlbXB0eVJlc3VsdCIsInNraXAiLCJub3RTZXJ2aWNlTW9kZWxTZWFyY2giLCJnZXRTZWFyY2hSb3V0ZU5hbWUiLCJnZXREYXRhTG9hZFJvdXRlTmFtZSIsInRyYW5zZm9ybVNlYXJjaFJlc3VsdCIsInVzZXJuYW1lIiwidHJhbnNmb3JtU2VsZWN0ZWRSZXN1bHQiLCJzZWFyY2hCeVRlcm0iLCJ0ZXJtIiwib3BlblNlbGVjdG9yIiwiVUlHZW5lcmljU2VsZWN0b3IiLCJjb25zb2xlIiwidW5tb3VudCIsIm5jQ1JVRCIsIkxvY2FsZSIsIkVsZW1lbnRzIiwiRnJhbWUiLCJjb21wb25lbnRzU2V0TmFtZSIsImNvbXBvbmVudE5hbWUiXSwibWFwcGluZ3MiOiI7OztBQUFBLFdBQWUsSUFBSTs7Q0NBbkI7Q0FDQTtDQUNPLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxPQUFPO0NBQzVCLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTztDQUN0QyxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsSUFBSTtDQUUzQixJQUFJLGVBQWUsR0FBRyxNQUFNLENBQUMsY0FBYztDQUMzQyxJQUFJLGNBQWMsR0FBRyxNQUFNLENB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QixDQUFDLEtBQUssRUFBRSxJQUFJLEdBQUc7Q0FDZixDQUFDOztDQ2ZEOztDQUdBOztDQUVBO0NBQ0E7Q0FDQTtDQUNBLFNBQVMsU0FBUyxHQUFHO0NBQ3JCO0NBQ0E7Q0FDQSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEVBQUU7O0NBRXRCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEtBQUs7Q0FDN0IsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRTtDQUNwQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztDQUN6QixHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUU7Q0FDWDtDQUNBLEVBQUUsQ0FBQzs7Q0FFSCxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO0NBQzNCLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7Q0FDckI7Q0FDQTs7Q0FFQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDTyxTQUFTLElBQUksQ0FBQyxRQUFRLEVBQUU7Q0FDL0I7Q0FDQSxDQUFDLElBQUksSUFBSTs7Q0FFVCxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO0NBQzNCLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7Q0FDckI7O0NBRUEsQ0FBQyxPQUFPO0NBQ1IsRUFBRSxPQUFPLEVBQUUsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEtBQUs7Q0FDcEMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxJQUFJLEdBQUcsRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRTtDQUN0RCxHQUFHLENBQUM7Q0FDSixFQUFFLEtBQUssR0FBRztDQUNWLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFB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QUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUMxQyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztDQUNqQztDQUNBOztDQUVBLENBQUMsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEdBQUcsRUFBRTs7Q0FFekI7Q0FDQTtDQUNBO0NBQ0EsQ0FBQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQzs7Q0FFaEUsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLE1BQU07Q0FDNUI7Q0FDQTtDQUNBLEVBQUUsSUFBSSxFQUFFLEdBQUcsV0FBVyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFO0NBQ3JDLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRTs7Q0FFdEIsRUFBRSxJQUFJLEtBQUssR0FBRyxFQUFFLEdBQUcsRUFBRTtDQUNyQixFQUFFLElBQUksUUFBUSx5QkFBeUIsQ0FBQyxPQUFPLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0NBQzNFLEVBQUUsSUFBSSxTQUFTLEdBQUcsRUFBRTs7Q0FFcEIsRUFBRSxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUU7Q0FDcEI7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBLEdBQUcsSUFBSSxxQkFBcUIsR0FBRyxLQUFLOztDQUVwQyxHQUFHLElBQUksR0FBRyxFQUFFO0NBQ1osSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQzs7Q0FFOUMsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7Q0FDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NB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TyxLQUFLO0tBQzFCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsSUFBSTtLQUMxQixDQUFBOzs7T0FHRCxTQUFTLEdBQUcsUUFBUSxFQUFBLENBQUMsTUFBTSxDQUFBLENBQzFCLE9BQU8sS0FBSyxPQUFPLENBQUMsU0FBUyxLQUFLLFVBQVUsQ0FBQTs7Q0FFakQsRUFBQUEsR0FBQSxDQUFBLE1BQU0sRUFBRyxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQTs7Q0FDM0IsRUFBQSxJQUFBLEdBQUcsR0FBRyxRQUFRLEVBQUMsQ0FBQSxHQUFHLENBQUUsQ0FBQSxHQUFHLEtBQUssR0FBRyxDQUFDLFNBQVMsQ0FBRSxDQUFBLElBQUksQ0FBQyxHQUFHLENBQUE7O0NBQ3ZELEVBQUFBLEdBQUEsQ0FBQSxPQUFPLEVBQU0sQ0FBQSxFQUFBLGVBQWUsRUFBRyxDQUFBLEVBQUEsR0FBRyxJQUFJLElBQUksRUFBQSxDQUFBLENBQUEsQ0FBQTtHQUM3QyxDQUFBOzs7Ozs7Ozs7O0NBSU0sR0FBQTRQLElBQUEsQ0FBQSxNQUFBLEVBQUEsRUFBQSxFQUFBLFFBQVEsc0JBQUksT0FBTyxLQUFBOztDQUNkLElBQUEsTUFBQSxlQUFlLGlCQUFHc0MsWUFBVSxDQUFDLEdBQUcsQ0FBQ3JDLEtBQUEsQ0FBQSxPQUFPLEVBQUMsU0FBUyxDQUFBLENBQUE7Ozs7cURBQ3JDLE9BQU8sQ0FBQSxFQUFBOzs7OztlQUF3QixJQUFJLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBS3RCLEtBQUEsTUFBQSxVQUFBLEdBQUFQLE9BQUEsQ0FBQSxNQUFBLEtBQUssRUFBSSxJQUFBLFFBQVEsRUFBQyxDQUFBLENBQUMsRUFBRSxLQUFLLENBQUE7Ozs7cUJBQTFDLE9BQU8sQ0FBQTs7Ozs7Ozs7Ozs7Q0FHZCxLQUFBTSxJQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsRUFBQSxRQUFRLHNCQUFJLE9BQU8sS0FBQTs7Q0FDZCxNQUFBLE1BQUEsaUJBQWlCLGlCQUFHc0MsWUFBVSxDQUFDLEdBQUcsQ0FBQ3JDLEtBQUEsQ0FBQSxPQUFPLEVBQUMs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QUFDbjRDLE9BQU8sQ0FBQyxVQUFDcTRDLGlCQUFpQixFQUFLO0NBQ2pEbDhDLEVBQUFBLE1BQU0sQ0FBQ3NILElBQUksQ0FBQzAwQyxRQUFRLENBQUNFLGlCQUFpQixDQUFDLENBQUMsQ0FBQ3I0QyxPQUFPLENBQUMsVUFBQ3M0QyxhQUFhLEVBQUs7Q0FDaEVGLElBQUFBLGNBQWtCLENBQUM5WixZQUFZLENBQzNCZ2EsYUFBYSxFQUNiSCxRQUFRLENBQUNFLGlCQUFpQixDQUFDLENBQUNDLGFBQWEsQ0FDN0MsQ0FBQztDQUNMLEdBQUMsQ0FBQztDQUNOLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw2NCw2NSw2Niw5Miw5Myw5NCw5NSw5NiwxOTEsMTkyLDE5MywxOTQsMTk1LDE5NiwxOTcsMTk4LDE5OSwyMDBdfQ==
