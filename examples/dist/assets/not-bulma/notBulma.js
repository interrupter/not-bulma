var notBulma = (function (exports) {
	'use strict';

	var DEV = true;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * @template V
	 * @param {V} value
	 * @param {V | (() => V)} fallback
	 * @param {boolean} [lazy]
	 * @returns {V}
	 */
	function fallback(value, fallback, lazy = false) {
		return value === undefined
			? lazy
				? /** @type {() => V} */ (fallback)()
				: /** @type {V} */ (fallback)
			: value;
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */
	const LEGACY_DERIVED_PROP = 1 << 17;
	const INSPECT_EFFECT = 1 << 18;
	const HEAD_EFFECT = 1 << 19;
	const EFFECT_HAS_DERIVED = 1 << 20;

	const STATE_SYMBOL = Symbol('$state');
	const STATE_SYMBOL_METADATA = Symbol('$state metadata');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');

	/** @import { Equals } from '#client' */
	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
	 * @returns {never}
	 */
	function bind_invalid_checkbox_value() {
		{
			const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		{
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Failed to hydrate the application
	 * @returns {never}
	 */
	function hydration_failed() {
		{
			const error = new Error(`hydration_failed\nFailed to hydrate the application\nhttps://svelte.dev/e/hydration_failed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`
	 * @returns {never}
	 */
	function invalid_snippet() {
		{
			const error = new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * `%name%(...)` cannot be used in runes mode
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_legacy_only(name) {
		{
			const error = new Error(`lifecycle_legacy_only\n\`${name}(...)\` cannot be used in runes mode\nhttps://svelte.dev/e/lifecycle_legacy_only`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Rest element properties of `$props()` such as `%property%` are readonly
	 * @param {string} property
	 * @returns {never}
	 */
	function props_rest_readonly(property) {
		{
			const error = new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		{
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state
	 * @returns {never}
	 */
	function state_unsafe_local_read() {
		{
			const error = new Error(`state_unsafe_local_read\nReading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state\nhttps://svelte.dev/e/state_unsafe_local_read`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/**
	 * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			const error = new Error(`state_unsafe_mutation\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const HYDRATION_START = '[';
	/** used to indicate that an `{:else}...` block was rendered */
	const HYDRATION_START_ELSE = '[!';
	const HYDRATION_END = ']';
	const HYDRATION_ERROR = {};

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold$1 = 'font-weight: bold';
	var normal$1 = 'font-weight: normal';

	/**
	 * The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:
	 * 
	 * %properties%
	 * @param {string | undefined | null} [properties]
	 */
	function state_snapshot_uncloneable(properties) {
		{
			console.warn(`%c[svelte] state_snapshot_uncloneable\n%c${properties
			? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}`
			: 'Value cannot be cloned with `$state.snapshot` — the original value was returned'}\nhttps://svelte.dev/e/state_snapshot_uncloneable`, bold$1, normal$1);
		}
	}

	/** @import { Snapshot } from './types' */

	/**
	 * In dev, we keep track of which properties could not be cloned. In prod
	 * we don't bother, but we keep a dummy array around so that the
	 * signature stays the same
	 * @type {string[]}
	 */
	const empty = [];

	/**
	 * @template T
	 * @param {T} value
	 * @param {boolean} [skip_warning]
	 * @returns {Snapshot<T>}
	 */
	function snapshot(value, skip_warning = false) {
		if (!skip_warning) {
			/** @type {string[]} */
			const paths = [];

			const copy = clone(value, new Map(), '', paths);
			if (paths.length === 1 && paths[0] === '') {
				// value could not be cloned
				state_snapshot_uncloneable();
			} else if (paths.length > 0) {
				// some properties could not be cloned
				const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
				const excess = paths.length - slice.length;

				let uncloned = slice.map((path) => `- <value>${path}`).join('\n');
				if (excess > 0) uncloned += `\n- ...and ${excess} more`;

				state_snapshot_uncloneable(uncloned);
			}

			return copy;
		}

		return clone(value, new Map(), '', empty);
	}

	/**
	 * @template T
	 * @param {T} value
	 * @param {Map<T, Snapshot<T>>} cloned
	 * @param {string} path
	 * @param {string[]} paths
	 * @param {null | T} original The original value, if `value` was produced from a `toJSON` call
	 * @returns {Snapshot<T>}
	 */
	function clone(value, cloned, path, paths, original = null) {
		if (typeof value === 'object' && value !== null) {
			var unwrapped = cloned.get(value);
			if (unwrapped !== undefined) return unwrapped;

			if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value));
			if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value));

			if (is_array(value)) {
				var copy = /** @type {Snapshot<any>} */ (Array(value.length));
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var i = 0; i < value.length; i += 1) {
					var element = value[i];
					if (i in value) {
						copy[i] = clone(element, cloned, `${path}[${i}]` , paths);
					}
				}

				return copy;
			}

			if (get_prototype_of(value) === object_prototype) {
				/** @type {Snapshot<any>} */
				copy = {};
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var key in value) {
					// @ts-expect-error
					copy[key] = clone(value[key], cloned, `${path}.${key}` , paths);
				}

				return copy;
			}

			if (value instanceof Date) {
				return /** @type {Snapshot<T>} */ (structuredClone(value));
			}

			if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function') {
				return clone(
					/** @type {T & { toJSON(): any } } */ (value).toJSON(),
					cloned,
					`${path}.toJSON()` ,
					paths,
					// Associate the instance with the toJSON clone
					value
				);
			}
		}

		if (value instanceof EventTarget) {
			// can't be cloned
			return /** @type {Snapshot<T>} */ (value);
		}

		try {
			return /** @type {Snapshot<T>} */ (structuredClone(value));
		} catch (e) {
			{
				paths.push(path);
			}

			return /** @type {Snapshot<T>} */ (value);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value
	 * @param {string} attribute
	 * @param {string} html
	 * @param {string} value
	 */
	function hydration_attribute_changed(attribute, html, value) {
		{
			console.warn(`%c[svelte] hydration_attribute_changed\n%cThe \`${attribute}\` attribute on \`${html}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value\nhttps://svelte.dev/e/hydration_attribute_changed`, bold, normal);
		}
	}

	/**
	 * The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value
	 * @param {string | undefined | null} [location]
	 */
	function hydration_html_changed(location) {
		{
			console.warn(`%c[svelte] hydration_html_changed\n%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : 'The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value'}\nhttps://svelte.dev/e/hydration_html_changed`, bold, normal);
		}
	}

	/**
	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
	 * @param {string | undefined | null} [location]
	 */
	function hydration_mismatch(location) {
		{
			console.warn(`%c[svelte] hydration_mismatch\n%c${'Hydration failed because the initial UI does not match what was rendered on the server'}\nhttps://svelte.dev/e/hydration_mismatch`, bold, normal);
		}
	}

	/**
	 * The `render` function passed to `createRawSnippet` should return HTML for a single element
	 */
	function invalid_raw_snippet_render() {
		{
			console.warn(`%c[svelte] invalid_raw_snippet_render\n%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element\nhttps://svelte.dev/e/invalid_raw_snippet_render`, bold, normal);
		}
	}

	/**
	 * Tried to unmount a component that was not mounted
	 */
	function lifecycle_double_unmount() {
		{
			console.warn(`%c[svelte] lifecycle_double_unmount\n%cTried to unmount a component that was not mounted\nhttps://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
		}
	}

	/**
	 * %component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead
	 * @param {string | undefined | null} [component]
	 * @param {string | undefined | null} [owner]
	 */
	function ownership_invalid_mutation(component, owner) {
		{
			console.warn(`%c[svelte] ownership_invalid_mutation\n%c${component ? `${component} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : 'Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead'}\nhttps://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
		}
	}

	/** @import { ProxyMetadata } from '#client' */
	/** @typedef {{ file: string, line: number, column: number }} Location */


	/** @type {Record<string, Array<{ start: Location, end: Location, component: Function }>>} */
	const boundaries = {};

	const chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
	const firefox_pattern = /@(.+):(\d+):(\d+)$/;

	function get_stack() {
		const stack = new Error().stack;
		if (!stack) return null;

		const entries = [];

		for (const line of stack.split('\n')) {
			let match = chrome_pattern.exec(line) ?? firefox_pattern.exec(line);

			if (match) {
				entries.push({
					file: match[1],
					line: +match[2],
					column: +match[3]
				});
			}
		}

		return entries;
	}

	/**
	 * Determines which `.svelte` component is responsible for a given state change
	 * @returns {Function | null}
	 */
	function get_component() {
		// first 4 lines are svelte internals; adjust this number if we change the internal call stack
		const stack = get_stack()?.slice(4);
		if (!stack) return null;

		for (let i = 0; i < stack.length; i++) {
			const entry = stack[i];
			const modules = boundaries[entry.file];
			if (!modules) {
				// If the first entry is not a component, that means the modification very likely happened
				// within a .svelte.js file, possibly triggered by a component. Since these files are not part
				// of the bondaries/component context heuristic, we need to bail in this case, else we would
				// have false positives when the .svelte.ts file provides a state creator function, encapsulating
				// the state and its mutations, and is being called from a component other than the one who
				// called the state creator function.
				if (i === 0) return null;
				continue;
			}

			for (const module of modules) {
				if (module.end == null) {
					return null;
				}
				if (module.start.line < entry.line && module.end.line > entry.line) {
					return module.component;
				}
			}
		}

		return null;
	}

	const ADD_OWNER = Symbol('ADD_OWNER');

	/**
	 * @param {any} object
	 * @param {any | null} owner
	 * @param {boolean} [global]
	 * @param {boolean} [skip_warning]
	 */
	function add_owner(object, owner, global = false, skip_warning = false) {
		if (object && !global) {
			const component = dev_current_component_function;
			const metadata = object[STATE_SYMBOL_METADATA];
			if (metadata && !has_owner(metadata, component)) {
				get_owner(metadata);
			}
		}

		add_owner_to_object(object, owner, new Set());
	}

	/**
	 * @param {ProxyMetadata | null} from
	 * @param {ProxyMetadata} to
	 */
	function widen_ownership(from, to) {
		if (to.owners === null) {
			return;
		}

		while (from) {
			if (from.owners === null) {
				to.owners = null;
				break;
			}

			for (const owner of from.owners) {
				to.owners.add(owner);
			}

			from = from.parent;
		}
	}

	/**
	 * @param {any} object
	 * @param {Function | null} owner If `null`, then the object is globally owned and will not be checked
	 * @param {Set<any>} seen
	 */
	function add_owner_to_object(object, owner, seen) {
		const metadata = /** @type {ProxyMetadata} */ (object?.[STATE_SYMBOL_METADATA]);

		if (metadata) {
			// this is a state proxy, add owner directly, if not globally shared
			if ('owners' in metadata && metadata.owners != null) {
				{
					metadata.owners = null;
				}
			}
		} else if (object && typeof object === 'object') {
			if (seen.has(object)) return;
			seen.add(object);
			if (ADD_OWNER in object && object[ADD_OWNER]) {
				// this is a class with state fields. we put this in a render effect
				// so that if state is replaced (e.g. `instance.name = { first, last }`)
				// the new state is also co-owned by the caller of `getContext`
				render_effect(() => {
					object[ADD_OWNER](owner);
				});
			} else {
				var proto = get_prototype_of(object);

				if (proto === Object.prototype) {
					// recurse until we find a state proxy
					for (const key in object) {
						if (Object.getOwnPropertyDescriptor(object, key)?.get) {
							// Similar to the class case; the getter could update with a new state
							let current = UNINITIALIZED;
							render_effect(() => {
								const next = object[key];
								if (current !== next) {
									current = next;
									add_owner_to_object(next, owner, seen);
								}
							});
						} else {
							add_owner_to_object(object[key], owner, seen);
						}
					}
				} else if (proto === Array.prototype) {
					// recurse until we find a state proxy
					for (let i = 0; i < object.length; i += 1) {
						add_owner_to_object(object[i], owner, seen);
					}
				}
			}
		}
	}

	/**
	 * @param {ProxyMetadata} metadata
	 * @param {Function} component
	 * @returns {boolean}
	 */
	function has_owner(metadata, component) {
		if (metadata.owners === null) {
			return true;
		}

		return (
			metadata.owners.has(component) ||
			// This helps avoid false positives when using HMR, where the component function is replaced
			(FILENAME in component &&
				[...metadata.owners].some(
					(owner) => /** @type {any} */ (owner)[FILENAME] === component[FILENAME]
				)) ||
			(metadata.parent !== null && has_owner(metadata.parent, component))
		);
	}

	/**
	 * @param {ProxyMetadata} metadata
	 * @returns {any}
	 */
	function get_owner(metadata) {
		return (
			metadata?.owners?.values().next().value ??
			get_owner(/** @type {ProxyMetadata} */ (metadata.parent))
		);
	}

	/**
	 * @param {ProxyMetadata} metadata
	 */
	function check_ownership(metadata) {

		const component = get_component();

		if (component && !has_owner(metadata, component)) {
			let original = get_owner(metadata);

			// @ts-expect-error
			if (original[FILENAME] !== component[FILENAME]) {
				// @ts-expect-error
				ownership_invalid_mutation(component[FILENAME], original[FILENAME]);
			} else {
				ownership_invalid_mutation();
			}
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);

			error.name = 'Svelte error';
			throw error;
		}
	}

	/** @import { ComponentContext } from '#client' */


	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		const context_map = get_or_init_context_map('getContext');
		const result = /** @type {T} */ (context_map.get(key));
		return result;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map('setContext');

		{
			// When state is put into context, we treat as if it's global from now on.
			// We do for performance reasons (it's for example very expensive to call
			// getContext on a big object many times when part of a list component)
			// and danger of false positives.
			untrack(() => add_owner(context, null, true));
		}

		context_map.set(key, context);
		return context;
	}

	/**
	 * Checks whether a given `key` has been set in the context of a parent component.
	 * Must be called during component initialisation.
	 *
	 * @param {any} key
	 * @returns {boolean}
	 */
	function hasContext(key) {
		const context_map = get_or_init_context_map('hasContext');
		return context_map.has(key);
	}

	/**
	 * Retrieves the whole context map that belongs to the closest parent component.
	 * Must be called during component initialisation. Useful, for example, if you
	 * programmatically create a component and want to pass the existing context to it.
	 *
	 * @template {Map<any, any>} [T=Map<any, any>]
	 * @returns {T}
	 */
	function getAllContexts() {
		const context_map = get_or_init_context_map('getAllContexts');
		return /** @type {T} */ (context_map);
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			m: false,
			s: props,
			x: null,
			l: null
		};

		if (legacy_mode_flag && !runes) {
			component_context.l = {
				s: null,
				u: null,
				r1: [],
				r2: source(false)
			};
		}

		{
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		const context_stack_item = component_context;
		if (context_stack_item !== null) {
			if (component !== undefined) {
				context_stack_item.x = component;
			}
			const component_effects = context_stack_item.e;
			if (component_effects !== null) {
				var previous_effect = active_effect;
				var previous_reaction = active_reaction;
				context_stack_item.e = null;
				try {
					for (var i = 0; i < component_effects.length; i++) {
						var component_effect = component_effects[i];
						set_active_effect(component_effect.effect);
						set_active_reaction(component_effect.reaction);
						effect(component_effect.fn);
					}
				} finally {
					set_active_effect(previous_effect);
					set_active_reaction(previous_reaction);
				}
			}
			component_context = context_stack_item.p;
			{
				dev_current_component_function = context_stack_item.p?.function ?? null;
			}
			context_stack_item.m = true;
		}
		// Micro-optimization: Don't set .a above to the empty object
		// so it can be garbage-collected when the return here is unused
		return component || /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component(name);
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */

	let inspect_effects = new Set();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 */
	function state(v) {
		return push_derived_source(source(v));
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	function mutable_state(v, immutable = false) {
		return push_derived_source(mutable_source(v, immutable));
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function push_derived_source(source) {
		if (active_reaction !== null && !untracking && (active_reaction.f & DERIVED) !== 0) {
			if (derived_sources === null) {
				set_derived_sources([source]);
			} else {
				derived_sources.push(source);
			}
		}

		return source;
	}

	/**
	 * @template V
	 * @param {Value<V>} source
	 * @param {V} value
	 */
	function mutate(source, value) {
		set(
			source,
			untrack(() => get$3(source))
		);
		return value;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function set(source, value) {
		if (
			active_reaction !== null &&
			!untracking &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&
			// If the source was created locally within the current derived, then
			// we allow the mutation.
			(derived_sources === null || !derived_sources.includes(source))
		) {
			state_unsafe_mutation();
		}

		return internal_set(source, value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			source.v;
			source.v = value;
			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (inspect_effects.size > 0) {
				const inspects = Array.from(inspect_effects);
				var previously_flushing_effect = is_flushing_effect;
				set_is_flushing_effect(true);
				try {
					for (const effect of inspects) {
						// Mark clean inspect-effects as maybe dirty and then check their dirtiness
						// instead of just updating the effects - this way we avoid overfiring.
						if ((effect.f & CLEAN) !== 0) {
							set_signal_status(effect, MAYBE_DIRTY);
						}
						if (check_dirtiness(effect)) {
							update_effect(effect);
						}
					}
				} finally {
					set_is_flushing_effect(previously_flushing_effect);
				}
				inspect_effects.clear();
			}
		}

		return value;
	}

	/**
	 * @template {number | bigint} T
	 * @param {Source<T>} source
	 * @param {1 | -1} [d]
	 * @returns {T}
	 */
	function update(source, d = 1) {
		var value = get$3(source);
		var result = d === 1 ? value++ : value--;

		set(source, value);

		// @ts-expect-error
		return result;
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// Skip any effects that are already dirty
			if ((flags & DIRTY) !== 0) continue;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if ((flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			set_signal_status(reaction, status);

			// If the signal a) was previously clean or b) is an unowned derived, then mark it
			if ((flags & (CLEAN | UNOWNED)) !== 0) {
				if ((flags & DERIVED) !== 0) {
					mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
				} else {
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {boolean} value */
	function set_hydrating(value) {
		hydrating = value;
	}

	/**
	 * The node that is currently being hydrated. This starts out as the first node inside the opening
	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
	 * time we leave the block it is the closing comment, which serves as the block's anchor.
	 * @type {TemplateNode}
	 */
	let hydrate_node;

	/** @param {TemplateNode} node */
	function set_hydrate_node(node) {
		if (node === null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return (hydrate_node = node);
	}

	function hydrate_next() {
		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
	}

	/** @param {TemplateNode} node */
	function reset(node) {
		if (!hydrating) return;

		// If the node has remaining siblings, something has gone wrong
		if (get_next_sibling(hydrate_node) !== null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		hydrate_node = node;
	}

	function next(count = 1) {
		if (hydrating) {
			var i = count;
			var node = hydrate_node;

			while (i--) {
				node = /** @type {TemplateNode} */ (get_next_sibling(node));
			}

			hydrate_node = node;
		}
	}

	/**
	 * Removes all nodes starting at `hydrate_node` up until the next hydration end comment
	 */
	function remove_nodes() {
		var depth = 0;
		var node = hydrate_node;

		while (true) {
			if (node.nodeType === 8) {
				var data = /** @type {Comment} */ (node).data;

				if (data === HYDRATION_END) {
					if (depth === 0) return node;
					depth -= 1;
				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
					depth += 1;
				}
			}

			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
			node.remove();
			node = next;
		}
	}

	/** @import { ProxyMetadata, Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @param {ProxyMetadata | null} [parent]
	 * @param {Source<T>} [prev] dev mode only
	 * @returns {T}
	 */
	function proxy(value, parent = null, prev) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = source(0);

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', source(/** @type {any[]} */ (value).length));
		}

		/** @type {ProxyMetadata} */
		var metadata;

		{
			metadata = {
				parent,
				owners: null
			};

			{
				metadata.owners =
					parent === null
						? component_context !== null
							? new Set([component_context.function])
							: null
						: new Set();
			}
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}

				var s = sources.get(prop);

				if (s === undefined) {
					s = source(descriptor.value);
					sources.set(prop, s);
				} else {
					set(s, proxy(descriptor.value, metadata));
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						sources.set(prop, source(UNINITIALIZED));
					}
				} else {
					// When working with arrays, we need to also ensure we update the length when removing
					// an indexed property
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n < ls.v) {
							set(ls, n);
						}
					}
					set(s, UNINITIALIZED);
					update_version(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL_METADATA) {
					return metadata;
				}

				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata));
					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get$3(s);

					// In case of something like `foo = bar.map(...)`, foo would have ownership
					// of the array itself, while the individual items would have ownership
					// of the component that created bar. That means if we later do `foo[0].baz = 42`,
					// we could get a false-positive ownership violation, since the two proxies
					// are not connected to each other via the parent metadata relationship.
					// For this reason, we need to widen the ownership of the children
					// upon access when we detect they are not connected.
					{
						/** @type {ProxyMetadata | undefined} */
						var prop_metadata = v?.[STATE_SYMBOL_METADATA];
						if (prop_metadata && prop_metadata?.parent !== metadata) {
							widen_ownership(metadata, prop_metadata);
						}
					}

					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get$3(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL_METADATA) {
					return true;
				}

				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = source(has ? proxy(target[prop], metadata) : UNINITIALIZED);
						sources.set(prop, s);
					}

					var value = get$3(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = source(UNINITIALIZED);
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = source(undefined);
						set(s, proxy(value, metadata));
						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;
					set(s, proxy(value, metadata));
				}

				{
					/** @type {ProxyMetadata | undefined} */
					var prop_metadata = value?.[STATE_SYMBOL_METADATA];
					if (prop_metadata && prop_metadata?.parent !== metadata) {
						widen_ownership(metadata, prop_metadata);
					}
					check_ownership(metadata);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					update_version(version);
				}

				return true;
			},

			ownKeys(target) {
				get$3(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {Source<number>} signal
	 * @param {1 | -1} [d]
	 */
	function update_version(signal, d = 1) {
		set(signal, signal.v + d);
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
			return value[STATE_SYMBOL];
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/** @import { TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		// the following assignments improve perf of lookups on DOM nodes
		// @ts-expect-error
		element_prototype.__click = undefined;
		// @ts-expect-error
		element_prototype.__className = '';
		// @ts-expect-error
		element_prototype.__attributes = null;
		// @ts-expect-error
		element_prototype.__styles = null;
		// @ts-expect-error
		element_prototype.__e = undefined;

		// @ts-expect-error
		Text.prototype.__t = undefined;

		{
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		if (!hydrating) {
			return get_first_child(node);
		}

		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
		if (child === null) {
			child = hydrate_node.appendChild(create_text());
		} else if (is_text && child.nodeType !== 3) {
			var text = create_text();
			child?.before(text);
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(child);
		return child;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode[]} fragment
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text) {
		if (!hydrating) {
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}

		// if an {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && hydrate_node?.nodeType !== 3) {
			var text = create_text();

			hydrate_node?.before(text);
			set_hydrate_node(text);
			return text;
		}

		return hydrate_node;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = hydrating ? hydrate_node : node;
		var last_sibling;

		while (count--) {
			last_sibling = next_sibling;
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		if (!hydrating) {
			return next_sibling;
		}

		var type = next_sibling?.nodeType;

		// if a sibling {expression} is empty during SSR, there might be no
		// text node to hydrate — we must therefore create one
		if (is_text && type !== 3) {
			var text = create_text();
			// If the next sibling is `null` and we're handling text then it's because
			// the SSR content was empty for the text, so we need to generate a new text
			// node and insert it after the last sibling
			if (next_sibling === null) {
				last_sibling?.after(text);
			} else {
				next_sibling.before(text);
			}
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(next_sibling);
		return /** @type {TemplateNode} */ (next_sibling);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/** @import { Derived, Effect } from '#client' */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_HAS_DERIVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (null),
			wv: 0,
			parent: parent_derived ?? active_effect
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);
		var status =
			(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

		set_signal_status(derived, status);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var is_root = (type & ROOT_EFFECT) !== 0;
		var parent_effect = active_effect;

		{
			// Ensure the parent is never an inspect effect
			while (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {
				parent_effect = parent_effect.parent;
			}
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent: is_root ? null : parent_effect,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0
		};

		{
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			var previously_flushing_effect = is_flushing_effect;

			try {
				set_is_flushing_effect(true);
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			} finally {
				set_is_flushing_effect(previously_flushing_effect);
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		// if an effect has no dependencies, no DOM and no teardown function,
		// don't bother adding it to the effect tree
		var inert =
			sync &&
			effect.deps === null &&
			effect.first === null &&
			effect.nodes_start === null &&
			effect.teardown === null &&
			(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;

		if (!inert && !is_root && push) {
			if (parent_effect !== null) {
				push_effect(effect, parent_effect);
			}

			// if we're in a derived, add the effect there too
			if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
				var derived = /** @type {Derived} */ (active_reaction);
				(derived.effects ??= []).push(effect);
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var defer =
			active_effect !== null &&
			(active_effect.f & BRANCH_EFFECT) !== 0 &&
			component_context !== null &&
			!component_context.m;

		{
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		if (defer) {
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push({
				fn,
				effect: active_effect,
				reaction: active_reaction
			});
		} else {
			var signal = effect(fn);
			return signal;
		}
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		{
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return render_effect(fn);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		const effect = create_effect(ROOT_EFFECT, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean }} */
		var token = { effect: null, ran: false };
		context.l.r1.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			set(context.l.r2, true);
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			if (!get$3(context.l.r2)) return;

			// Run dirty `$:` statements
			for (var token of context.l.r1) {
				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (check_dirtiness(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}

			context.l.r2.v = false; // set directly to avoid rerunning this effect
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn) {
		return create_effect(RENDER_EFFECT, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} thunks
	 * @returns {Effect}
	 */
	function template_effect(fn, thunks = [], d = derived) {
		const deriveds = thunks.map(d);
		const effect = () => fn(...deriveds.map(get$3));

		{
			define_property(effect, 'name', {
				value: '{expression}'
			});
		}

		return block(effect);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			var next = effect.next;
			destroy_effect(effect, remove_dom);
			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {
			/** @type {TemplateNode | null} */
			var node = effect.nodes_start;
			var end = effect.nodes_end;

			while (node !== null) {
				/** @type {TemplateNode | null} */
				var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

				node.remove();
				node = next;
			}

			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		{
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
				null;
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// Ensure the effect is marked as clean again so that any dirty child
		// effects can schedule themselves for execution
		if ((effect.f & CLEAN) === 0) {
			effect.f ^= CLEAN;
		}

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update
		if (check_dirtiness(effect)) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	// Fallback for when requestIdleCallback is not available
	const request_idle_callback =
		typeof requestIdleCallback === 'undefined'
			? (/** @type {() => void} */ cb) => setTimeout(cb, 1)
			: requestIdleCallback;

	let is_micro_task_queued$1 = false;
	let is_idle_task_queued = false;

	/** @type {Array<() => void>} */
	let current_queued_micro_tasks = [];
	/** @type {Array<() => void>} */
	let current_queued_idle_tasks = [];

	function process_micro_tasks() {
		is_micro_task_queued$1 = false;
		const tasks = current_queued_micro_tasks.slice();
		current_queued_micro_tasks = [];
		run_all(tasks);
	}

	function process_idle_tasks() {
		is_idle_task_queued = false;
		const tasks = current_queued_idle_tasks.slice();
		current_queued_idle_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (!is_micro_task_queued$1) {
			is_micro_task_queued$1 = true;
			queueMicrotask(process_micro_tasks);
		}
		current_queued_micro_tasks.push(fn);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_idle_task(fn) {
		if (!is_idle_task_queued) {
			is_idle_task_queued = true;
			request_idle_callback(process_idle_tasks);
		}
		current_queued_idle_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		if (is_micro_task_queued$1) {
			process_micro_tasks();
		}
		if (is_idle_task_queued) {
			process_idle_tasks();
		}
	}

	/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	const FLUSH_MICROTASK = 0;
	const FLUSH_SYNC = 1;
	// Used for DEV time error handling
	/** @param {WeakSet<Error>} value */
	const handled_errors = new WeakSet();
	let is_throwing_error = false;

	// Used for controlling the flush of effects.
	let scheduler_mode = FLUSH_MICROTASK;
	// Used for handling scheduling
	let is_micro_task_queued = false;

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing_effect = false;
	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_flushing_effect(value) {
		is_flushing_effect = value;
	}

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	// Handle effect queues

	/** @type {Effect[]} */
	let queued_root_effects = [];

	let flush_count = 0;
	/** @type {Effect[]} Stack of effects, dev only */
	let dev_effect_stack = [];
	// Handle signal reactivity tree dependencies and reactions

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a derived, we record them so that we can safely allow
	 * local mutations to these sources without the side-effect error being invoked unnecessarily.
	 * @type {null | Source[]}
	 */
	let derived_sources = null;

	/**
	 * @param {Source[] | null} sources
	 */
	function set_derived_sources(sources) {
		derived_sources = sources;
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function check_dirtiness(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency
				if (is_disconnected || is_unowned_connected) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (check_dirtiness(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 */
	function propagate_error(error, effect) {
		/** @type {Effect | null} */
		var current = effect;

		while (current !== null) {
			if ((current.f & BOUNDARY_EFFECT) !== 0) {
				try {
					// @ts-expect-error
					current.fn(error);
					return;
				} catch {
					// Remove boundary flag from effect
					current.f ^= BOUNDARY_EFFECT;
				}
			}

			current = current.parent;
		}

		is_throwing_error = false;
		throw error;
	}

	/**
	 * @param {Effect} effect
	 */
	function should_rethrow_error(effect) {
		return (
			(effect.f & DESTROYED) === 0 &&
			(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)
		);
	}

	/**
	 * @param {unknown} error
	 * @param {Effect} effect
	 * @param {Effect | null} previous_effect
	 * @param {ComponentContext | null} component_context
	 */
	function handle_error(error, effect, previous_effect, component_context) {
		if (is_throwing_error) {
			if (previous_effect === null) {
				is_throwing_error = false;
			}

			if (should_rethrow_error(effect)) {
				throw error;
			}

			return;
		}

		if (previous_effect !== null) {
			is_throwing_error = true;
		}

		if (
			component_context === null ||
			!(error instanceof Error) ||
			handled_errors.has(error)
		) {
			propagate_error(error, effect);
			return;
		}

		handled_errors.add(error);

		const component_stack = [];

		const effect_name = effect.fn?.name;

		if (effect_name) {
			component_stack.push(effect_name);
		}

		/** @type {ComponentContext | null} */
		let current_context = component_context;

		while (current_context !== null) {
			{
				/** @type {string} */
				var filename = current_context.function?.[FILENAME];

				if (filename) {
					const file = filename.split('/').pop();
					component_stack.push(file);
				}
			}

			current_context = current_context.p;
		}

		const indent = is_firefox ? '  ' : '\t';
		define_property(error, 'message', {
			value: error.message + `\n${component_stack.map((name) => `\n${indent}in ${name}`).join('')}\n`
		});
		define_property(error, 'component_stack', {
			value: component_stack
		});

		const stack = error.stack;

		// Filter out internal files from callstack
		if (stack) {
			const lines = stack.split('\n');
			const new_lines = [];
			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];
				if (line.includes('svelte/src/internal')) {
					continue;
				}
				new_lines.push(line);
			}
			define_property(error, 'stack', {
				value: new_lines.join('\n')
			});
		}

		propagate_error(error, effect);

		if (should_rethrow_error(effect)) {
			throw error;
		}
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];
			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/**
	 * @template V
	 * @param {Reaction} reaction
	 * @returns {V}
	 */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var prev_derived_sources = derived_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
		skip_reaction =
			(flags & UNOWNED) !== 0 &&
			(!is_flushing_effect || previous_reaction === null || previous_untracking);

		derived_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		read_version++;

		try {
			var result = /** @type {Function} */ (0, reaction.fn)();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (!skip_reaction) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null) {
				read_version++;
			}

			return result;
		} finally {
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			derived_sources = prev_derived_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}
		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var previous_component_context = component_context;

		active_effect = effect;

		{
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			var deps = effect.deps;

			// In DEV, we need to handle a case where $inspect.trace() might
			// incorrectly state a source dependency has not changed when it has.
			// That's beacuse that source was changed by the same effect, causing
			// the versions to match. We can avoid this by incrementing the version
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && deps !== null) ;

			if (DEV) {
				dev_effect_stack.push(effect);
			}
		} catch (error) {
			handle_error(error, effect, previous_effect, previous_component_context || effect.ctx);
		} finally {
			active_effect = previous_effect;

			{
				set_dev_current_component_function(previous_component_fn);
			}
		}
	}

	function log_effect_stack() {
		// eslint-disable-next-line no-console
		console.error(
			'Last ten effects were: ',
			dev_effect_stack.slice(-10).map((d) => d.fn)
		);
		dev_effect_stack = [];
	}

	function infinite_loop_guard() {
		if (flush_count > 1000) {
			flush_count = 0;
			try {
				effect_update_depth_exceeded();
			} catch (error) {
				{
					// stack is garbage, ignore. Instead add a console.error message.
					define_property(error, 'stack', {
						value: ''
					});
				}
				// Try and handle the error so it can be caught at a boundary, that's
				// if there's an effect available from when it was last scheduled
				if (last_scheduled_effect !== null) {
					{
						try {
							handle_error(error, last_scheduled_effect, null, null);
						} catch (e) {
							// Only log the effect stack if the error is re-thrown
							log_effect_stack();
							throw e;
						}
					}
				} else {
					{
						log_effect_stack();
					}
					throw error;
				}
			}
		}
		flush_count++;
	}

	/**
	 * @param {Array<Effect>} root_effects
	 * @returns {void}
	 */
	function flush_queued_root_effects(root_effects) {
		var length = root_effects.length;
		if (length === 0) {
			return;
		}
		infinite_loop_guard();

		var previously_flushing_effect = is_flushing_effect;
		is_flushing_effect = true;

		try {
			for (var i = 0; i < length; i++) {
				var effect = root_effects[i];

				if ((effect.f & CLEAN) === 0) {
					effect.f ^= CLEAN;
				}

				var collected_effects = process_effects(effect);
				flush_queued_effects(collected_effects);
			}
		} finally {
			is_flushing_effect = previously_flushing_effect;
		}
	}

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		for (var i = 0; i < length; i++) {
			var effect = effects[i];

			if ((effect.f & (DESTROYED | INERT)) === 0) {
				try {
					if (check_dirtiness(effect)) {
						update_effect(effect);

						// Effects with no dependencies or teardown do not get added to the effect tree.
						// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
						// don't know if we need to keep them until they are executed. Doing the check
						// here (rather than in `update_effect`) allows us to skip the work for
						// immediate effects.
						if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
							if (effect.teardown === null) {
								// remove this effect from the graph
								unlink_effect(effect);
							} else {
								// keep the effect in the graph, but free up some memory
								effect.fn = null;
							}
						}
					}
				} catch (error) {
					handle_error(error, effect, null, effect.ctx);
				}
			}
		}
	}

	function process_deferred() {
		is_micro_task_queued = false;
		if (flush_count > 1001) {
			return;
		}
		const previous_queued_root_effects = queued_root_effects;
		queued_root_effects = [];
		flush_queued_root_effects(previous_queued_root_effects);

		if (!is_micro_task_queued) {
			flush_count = 0;
			last_scheduled_effect = null;
			{
				dev_effect_stack = [];
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		if (scheduler_mode === FLUSH_MICROTASK) {
			if (!is_micro_task_queued) {
				is_micro_task_queued = true;
				queueMicrotask(process_deferred);
			}
		}

		last_scheduled_effect = signal;

		var effect = signal;

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 *
	 * This function both runs render effects and collects user effects in topological order
	 * from the starting effect passed in. Effects will be collected when they match the filtered
	 * bitwise flag passed in only. The collected effects array will be populated with all the user
	 * effects to be flushed.
	 *
	 * @param {Effect} effect
	 * @returns {Effect[]}
	 */
	function process_effects(effect) {
		/** @type {Effect[]} */
		var effects = [];

		var current_effect = effect.first;

		main_loop: while (current_effect !== null) {
			var flags = current_effect.f;
			var is_branch = (flags & BRANCH_EFFECT) !== 0;
			var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
			var sibling = current_effect.next;

			if (!is_skippable_branch && (flags & INERT) === 0) {
				if ((flags & EFFECT) !== 0) {
					effects.push(current_effect);
				} else if (is_branch) {
					current_effect.f ^= CLEAN;
				} else {
					// Ensure we set the effect to be the active reaction
					// to ensure that unowned deriveds are correctly tracked
					// because we're flushing the current effect
					var previous_active_reaction = active_reaction;
					try {
						active_reaction = current_effect;
						if (check_dirtiness(current_effect)) {
							update_effect(current_effect);
						}
					} catch (error) {
						handle_error(error, current_effect, null, current_effect.ctx);
					} finally {
						active_reaction = previous_active_reaction;
					}
				}

				var child = current_effect.first;

				if (child !== null) {
					current_effect = child;
					continue;
				}
			}

			if (sibling === null) {
				let parent = current_effect.parent;

				while (parent !== null) {
					if (effect === parent) {
						break main_loop;
					}
					var parent_sibling = parent.next;
					if (parent_sibling !== null) {
						current_effect = parent_sibling;
						continue main_loop;
					}
					parent = parent.parent;
				}
			}

			current_effect = sibling;
		}

		return effects;
	}

	/**
	 * Internal version of `flushSync` with the option to not flush previous effects.
	 * Returns the result of the passed function, if given.
	 * @param {() => any} [fn]
	 * @returns {any}
	 */
	function flush_sync(fn) {
		var previous_scheduler_mode = scheduler_mode;
		var previous_queued_root_effects = queued_root_effects;

		try {
			infinite_loop_guard();

			/** @type {Effect[]} */
			const root_effects = [];

			scheduler_mode = FLUSH_SYNC;
			queued_root_effects = root_effects;
			is_micro_task_queued = false;

			flush_queued_root_effects(previous_queued_root_effects);

			var result = fn?.();

			flush_tasks();
			if (queued_root_effects.length > 0 || root_effects.length > 0) {
				flush_sync();
			}

			flush_count = 0;
			last_scheduled_effect = null;
			if (DEV) {
				dev_effect_stack = [];
			}

			return result;
		} finally {
			scheduler_mode = previous_scheduler_mode;
			queued_root_effects = previous_queued_root_effects;
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {
		await Promise.resolve();
		// By calling flush_sync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flush_sync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get$3(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			if (derived_sources !== null && derived_sources.includes(signal)) {
				state_unsafe_local_read();
			}
			var deps = active_reaction.deps;
			if (signal.rv < read_version) {
				signal.rv = read_version;
				// If the signal is accessing the same dependencies in the same
				// order as it did last time, increment `skipped_deps`
				// rather than updating `new_deps`, which creates GC cost
				if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
					skipped_deps++;
				} else if (new_deps === null) {
					new_deps = [signal];
				} else if (!skip_reaction || !new_deps.includes(signal)) {
					// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
					// an unowned derived because skip_reaction is true, then we need to ensure that
					// we don't have duplicates
					new_deps.push(signal);
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (check_dirtiness(derived)) {
				update_derived(derived);
			}
		}

		return signal.v;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	const regex_return_characters = /\r/g;

	/**
	 * @param {string} str
	 * @returns {string}
	 */
	function hash(str) {
		str = str.replace(regex_return_characters, '');
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return (hash >>> 0).toString(36);
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject',
		novalidate: 'noValidate',
		allowfullscreen: 'allowFullscreen',
		disablepictureinpicture: 'disablePictureInPicture',
		disableremoteplayback: 'disableRemotePlayback'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** List of elements that require raw contents and should not have SSR comments put in them */
	const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);

	/** @param {string} name */
	function is_raw_text_element(name) {
		return RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name));
	}

	/**
	 * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
	 * @param {string | undefined} location
	 */
	function sanitize_location(location) {
		return location?.replace(/\//g, '/\u200b');
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	/**
	 * The child of a textarea actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLTextAreaElement} dom
	 * @returns {void}
	 */
	function remove_textarea_child(dom) {
		if (hydrating && get_first_child(dom) !== null) {
			clear_text_content(dom);
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { Location } from 'locate-character' */

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		// @ts-ignore
		if (dom === document.body || dom === window || dom === document) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// @ts-expect-error is added below
		var handled_at = event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated !== undefined &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html;
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function template(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {
			if (hydrating) {
				assign_nodes(hydrate_node, null);
				return hydrate_node;
			}

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text(value = '') {
		if (!hydrating) {
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}

		var node = hydrate_node;

		if (node.nodeType !== 3) {
			// if an {expression} is empty during SSR, we need to insert an empty text node
			node.before((node = create_text()));
			set_hydrate_node(node);
		}

		assign_nodes(node, node);
		return node;
	}

	function comment() {
		// we're not delegating to `template` here for performance reasons
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {
		if (hydrating) {
			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
			hydrate_next();
			return;
		}

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true — block effects should run their intro transitions —
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/** @param {boolean} value */
	function set_should_intro(value) {
		should_intro = value;
	}

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/**
	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {{} extends Props ? {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props?: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	} : {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	}} options
	 * @returns {Exports}
	 */
	function hydrate(component, options) {
		init_operations();
		options.intro = options.intro ?? false;
		const target = options.target;
		const was_hydrating = hydrating;
		const previous_hydrate_node = hydrate_node;

		try {
			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
			while (
				anchor &&
				(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
			) {
				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
			}

			if (!anchor) {
				throw HYDRATION_ERROR;
			}

			set_hydrating(true);
			set_hydrate_node(/** @type {Comment} */ (anchor));
			hydrate_next();

			const instance = _mount(component, { ...options, anchor });

			if (
				hydrate_node === null ||
				hydrate_node.nodeType !== 8 ||
				/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
			) {
				hydration_mismatch();
				throw HYDRATION_ERROR;
			}

			set_hydrating(false);

			return /**  @type {Exports} */ (instance);
		} catch (error) {
			if (error === HYDRATION_ERROR) {
				if (options.recover === false) {
					hydration_failed();
				}

				// If an error occured above, the operations might not yet have been initialised.
				init_operations();
				clear_text_content(target);

				set_hydrating(false);
				return mount(component, options);
			}

			throw error;
		} finally {
			set_hydrating(was_hydrating);
			set_hydrate_node(previous_hydrate_node);
		}
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			branch(() => {
				if (context) {
					push({});
					var ctx = /** @type {ComponentContext} */ (component_context);
					ctx.c = context;
				}

				if (events) {
					// We can't spread the object or else we'd lose the state proxy stuff, if it is one
					/** @type {any} */ (props).$$events = events;
				}

				if (hydrating) {
					assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
				}

				should_intro = intro;
				// @ts-expect-error the public typings are not what the actual function looks like
				component = Component(anchor_node, props) || {};
				should_intro = true;

				if (hydrating) {
					/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
				}

				if (context) {
					pop();
				}
			});

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		{
			lifecycle_double_unmount();
		}

		return Promise.resolve();
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				const is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (!!condition === is_else) {
					// Hydration mismatch: remove everything inside the anchor and start fresh.
					// This could happen with `{#if browser}...{/if}`, for example
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			if (condition) {
				if (consequent_effect) {
					resume_effect(consequent_effect);
				} else if (fn) {
					consequent_effect = branch(() => fn(anchor));
				}

				if (alternate_effect) {
					pause_effect(alternate_effect, () => {
						alternate_effect = null;
					});
				}
			} else {
				if (alternate_effect) {
					resume_effect(alternate_effect);
				} else if (fn) {
					alternate_effect = branch(() => fn(anchor));
				}

				if (consequent_effect) {
					pause_effect(consequent_effect, () => {
						consequent_effect = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * The row of a keyed each block that is currently updating. We track this
	 * so that `animate:` directives have something to attach themselves to
	 * @type {EachItem | null}
	 */
	let current_each_item = null;

	/** @param {EachItem | null} item */
	function set_current_each_item(item) {
		current_each_item = item;
	}

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index$d(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 * @param {Map<any, EachItem>} items_map
	 */
	function pause_effects(state, items, controlled_anchor, items_map) {
		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = hydrating
				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
				: parent_node.appendChild(create_text());
		}

		if (hydrating) {
			hydrate_next();
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		block(() => {
			var array = get$3(each_array);
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				var is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;

				if (is_else !== (length === 0)) {
					// hydration mismatch — remove the server-rendered DOM and start over
					anchor = remove_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			// this is separate to the previous block because `hydrating` might change
			if (hydrating) {
				/** @type {EachItem | null} */
				var prev = null;

				/** @type {EachItem} */
				var item;

				for (var i = 0; i < length; i++) {
					if (
						hydrate_node.nodeType === 8 &&
						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
					) {
						// The server rendered fewer items than expected,
						// so break out and continue appending non-hydrated items
						anchor = /** @type {Comment} */ (hydrate_node);
						mismatch = true;
						set_hydrating(false);
						break;
					}

					var value = array[i];
					var key = get_key(value, i);
					item = create_item(
						hydrate_node,
						state,
						prev,
						null,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
					state.items.set(key, item);

					prev = item;
				}

				// remove excess nodes
				if (length > 0) {
					set_hydrate_node(remove_nodes());
				}
			}

			if (!hydrating) {
				reconcile(array, state, anchor, render_fn, flags, get_key, get_collection);
			}

			if (fallback_fn !== null) {
				if (length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get$3(each_array);
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);
			item = items.get(key);

			if (item === undefined) {
				var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

				prev = create_item(
					child_anchor,
					state,
					prev,
					prev === null ? state.first : prev.next,
					value,
					key,
					i,
					render_fn,
					flags,
					get_collection
				);

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor, items);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		/** @type {Effect} */ (active_effect).first = state.first && state.first.e;
		/** @type {Effect} */ (active_effect).last = prev && prev.e;
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection
	) {
		var previous_each_item = current_each_item;
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).debug = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		current_each_item = item;

		try {
			item.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				state.first = item;
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
			current_each_item = previous_each_item;
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element} element
	 * @param {string | null} server_hash
	 * @param {string} value
	 */
	function check_hash(element, server_hash, value) {
		if (!server_hash || server_hash === hash(String(value ?? ''))) return;

		let location;

		// @ts-expect-error
		const loc = element.__svelte_meta?.loc;
		if (loc) {
			location = `near ${loc.file}:${loc.line}:${loc.column}`;
		} else if (dev_current_component_function?.[FILENAME]) {
			location = `in ${dev_current_component_function[FILENAME]}`;
		}

		hydration_html_changed(sanitize_location(location));
	}

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} svg
	 * @param {boolean} mathml
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg, mathml, skip_warning) {
		var anchor = node;

		var value = '';

		/** @type {Effect | undefined} */
		var effect;

		block(() => {
			if (value === (value = get_value() ?? '')) {
				if (hydrating) {
					hydrate_next();
				}
				return;
			}

			if (effect !== undefined) {
				destroy_effect(effect);
				effect = undefined;
			}

			if (value === '') return;

			effect = branch(() => {
				if (hydrating) {
					// We're deliberately not trying to repair mismatches between server and client,
					// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)
					var hash = /** @type {Comment} */ (hydrate_node).data;
					var next = hydrate_next();
					var last = next;

					while (
						next !== null &&
						(next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')
					) {
						last = next;
						next = /** @type {TemplateNode} */ (get_next_sibling(next));
					}

					if (next === null) {
						hydration_mismatch();
						throw HYDRATION_ERROR;
					}

					{
						check_hash(/** @type {Element} */ (next.parentNode), hash, value);
					}

					assign_nodes(hydrate_node, last);
					anchor = set_hydrate_node(next);
					return;
				}

				var html = value + '';

				// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
				// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
				/** @type {DocumentFragment | Element} */
				var node = create_fragment_from_html(html);

				assign_nodes(
					/** @type {TemplateNode} */ (get_first_child(node)),
					/** @type {TemplateNode} */ (node.lastChild)
				);

				{
					anchor.before(node);
				}
			});
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props[name === 'default' ? 'children' : name];
			is_interop = true;
		}

		if (slot_fn === undefined) {
			if (fallback_fn !== null) {
				fallback_fn(anchor);
			}
		} else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var anchor = node;

		/** @type {SnippetFn | null | undefined} */
		// @ts-ignore
		var snippet = noop;

		/** @type {Effect | null} */
		var snippet_effect;

		block(() => {
			if (snippet === (snippet = get_snippet())) return;

			if (snippet_effect) {
				destroy_effect(snippet_effect);
				snippet_effect = null;
			}

			if (snippet == null) {
				invalid_snippet();
			}

			snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Create a snippet programmatically
	 * @template {unknown[]} Params
	 * @param {(...params: Getters<Params>) => {
	 *   render: () => string
	 *   setup?: (element: Element) => void | (() => void)
	 * }} fn
	 * @returns {Snippet<Params>}
	 */
	function createRawSnippet(fn) {
		// @ts-expect-error the types are a lie
		return (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {
			var snippet = fn(...params);

			/** @type {Element} */
			var element;

			if (hydrating) {
				element = /** @type {Element} */ (hydrate_node);
				hydrate_next();
			} else {
				var html = snippet.render().trim();
				var fragment = create_fragment_from_html(html);
				element = /** @type {Element} */ (get_first_child(fragment));

				if ((get_next_sibling(element) !== null || element.nodeType !== 1)) {
					invalid_raw_snippet_render();
				}

				anchor.before(element);
			}

			const result = snippet.setup?.(element);
			assign_nodes(element, element);

			if (typeof result === 'function') {
				teardown(result);
			}
		};
	}

	/** @import { TemplateNode, Dom, Effect } from '#client' */

	/**
	 * @template P
	 * @template {(props: P) => void} C
	 * @param {TemplateNode} node
	 * @param {() => C} get_component
	 * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn
	 * @returns {void}
	 */
	function component(node, get_component, render_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {C} */
		var component;

		/** @type {Effect | null} */
		var effect;

		block(() => {
			if (component === (component = get_component())) return;

			if (effect) {
				pause_effect(effect);
				effect = null;
			}

			if (component) {
				effect = branch(() => render_fn(anchor, component));
			}
		}, EFFECT_TRANSPARENT);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
		let was_hydrating = hydrating;

		if (hydrating) {
			hydrate_next();
		}

		/** @type {string | null} */
		var tag;

		/** @type {string | null} */
		var current_tag;

		/** @type {null | Element} */
		var element = null;

		if (hydrating && hydrate_node.nodeType === 1) {
			element = /** @type {Element} */ (hydrate_node);
			hydrate_next();
		}

		var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);

		/** @type {Effect | null} */
		var effect;

		/**
		 * The keyed `{#each ...}` item block, if any, that this element is inside.
		 * We track this so we can set it when changing the element, allowing any
		 * `animate:` directive to bind itself to the correct block
		 */
		var each_item_block = current_each_item;

		block(() => {
			const next_tag = get_tag() || null;
			var ns = next_tag === 'svg' ? NAMESPACE_SVG : null;

			// Assumption: Noone changes the namespace but not the tag (what would that even mean?)
			if (next_tag === tag) return;

			// See explanation of `each_item_block` above
			var previous_each_item = current_each_item;
			set_current_each_item(each_item_block);

			if (effect) {
				if (next_tag === null) {
					// start outro
					pause_effect(effect, () => {
						effect = null;
						current_tag = null;
					});
				} else if (next_tag === current_tag) {
					// same tag as is currently rendered — abort outro
					resume_effect(effect);
				} else {
					// tag is changing — destroy immediately, render contents without intro transitions
					destroy_effect(effect);
					set_should_intro(false);
				}
			}

			if (next_tag && next_tag !== current_tag) {
				effect = branch(() => {
					element = hydrating
						? /** @type {Element} */ (element)
						: ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					assign_nodes(element, element);

					if (render_fn) {
						if (hydrating && is_raw_text_element(next_tag)) {
							// prevent hydration glitches
							element.append(document.createComment(''));
						}

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							hydrating ? get_first_child(element) : element.appendChild(create_text())
						);

						if (hydrating) {
							if (child_anchor === null) {
								set_hydrating(false);
							} else {
								set_hydrate_node(child_anchor);
							}
						}

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				});
			}

			tag = next_tag;
			if (tag) current_tag = tag;
			set_should_intro(true);

			set_current_each_item(previous_each_item);
		}, EFFECT_TRANSPARENT);

		if (was_hydrating) {
			set_hydrating(true);
			set_hydrate_node(anchor);
		}
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	/**
	 * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLInputElement} input
	 * @returns {void}
	 */
	function remove_input_defaults(input) {
		if (!hydrating) return;

		var already_removed = false;

		// We try and remove the default attributes later, rather than sync during hydration.
		// Doing it sync during hydration has a negative impact on performance, but deferring the
		// work in an idle task alleviates this greatly. If a form reset event comes in before
		// the idle callback, then we ensure the input defaults are cleared just before.
		var remove_defaults = () => {
			if (already_removed) return;
			already_removed = true;

			// Remove the attributes but preserve the values
			if (input.hasAttribute('value')) {
				var value = input.value;
				set_attribute(input, 'value', null);
				input.value = value;
			}

			if (input.hasAttribute('checked')) {
				var checked = input.checked;
				set_attribute(input, 'checked', null);
				input.checked = checked;
			}
		};

		// @ts-expect-error
		input.__on_r = remove_defaults;
		queue_idle_task(remove_defaults);
		add_form_reset_listener();
	}

	/**
	 * @param {Element} element
	 * @param {any} value
	 */
	function set_value(element, value) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (
			attributes.value ===
				(attributes.value =
					// treat null and undefined the same for the initial value
					value ?? undefined) ||
			// @ts-expect-error
			// `progress` elements always need their value set when it's `0`
			(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))
		) {
			return;
		}

		// @ts-expect-error
		element.value = value ?? '';
	}

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		// @ts-expect-error
		var attributes = (element.__attributes ??= {});

		if (hydrating) {
			attributes[attribute] = element.getAttribute(attribute);

			if (
				attribute === 'src' ||
				attribute === 'srcset' ||
				(attribute === 'href' && element.nodeName === 'LINK')
			) {
				{
					check_src_in_dev_hydration(element, attribute, value ?? '');
				}

				// If we reset these attributes, they would result in another network request, which we want to avoid.
				// We assume they are the same between client and server as checking if they are equal is expensive
				// (we can't just compare the strings as they can be different between client and server but result in the
				// same url, so we would need to create hidden anchor elements to compare them)
				return;
			}
		}

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'style' && '__styles' in element) {
			// reset styles to force style: directive to update
			element.__styles = {};
		}

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string, any> | undefined} prev
	 * @param {Record<string, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [preserve_attribute_case]
	 * @param {boolean} [is_custom_element]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		preserve_attribute_case = false,
		is_custom_element = false,
		skip_warning = false
	) {
		// If we're hydrating but the custom element is from Svelte, and it already scaffolded,
		// then it might run block logic in hydration mode, which we have to prevent.
		let is_hydrating_custom_element = hydrating && is_custom_element;
		if (is_hydrating_custom_element) {
			set_hydrating(false);
		}

		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		}

		if (css_hash !== undefined) {
			next.class = next.class ? next.class + ' ' + css_hash : css_hash;
		}

		var setters = get_setters(element);

		// @ts-expect-error
		var attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			var prev_value = current[key];
			if (value === prev_value) continue;

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style' && value != null) {
				element.style.cssText = value + '';
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {
				// @ts-ignore We're not running this for custom elements because __value is actually
				// how Lit stores the current value on the element, and messing with that would break things.
				element.value = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked — preserve
						let input = /** @type {HTMLInputElement} */ (element);
						const use_default = prev === undefined;
						if (name === 'value') {
							let previous = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = previous;
							// @ts-ignore
							input.value = input.__value = use_default ? previous : null;
						} else {
							let previous = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = previous;
							input.checked = use_default ? previous : false;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
				} else if (typeof value !== 'function') {
					set_attribute(element, name, value);
				}
			}
			if (key === 'style' && '__styles' in element) {
				// reset styles to force style: directive to update
				element.__styles = {};
			}
		}

		if (is_hydrating_custom_element) {
			set_hydrating(true);
		}

		return current;
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var setters = setters_cache.get(element.nodeName);
		if (setters) return setters;
		setters_cache.set(element.nodeName, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/**
	 * @param {any} element
	 * @param {string} attribute
	 * @param {string} value
	 */
	function check_src_in_dev_hydration(element, attribute, value) {
		if (attribute === 'srcset' && srcset_url_equal(element, value)) return;
		if (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;

		hydration_attribute_changed(
			attribute,
			element.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),
			String(value)
		);
	}

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
	}

	/** @param {string} srcset */
	function split_srcset(srcset) {
		return srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));
	}

	/**
	 * @param {HTMLSourceElement | HTMLImageElement} element
	 * @param {string} srcset
	 * @returns {boolean}
	 */
	function srcset_url_equal(element, srcset) {
		var element_urls = split_srcset(element.srcset);
		var urls = split_srcset(srcset);

		return (
			urls.length === element_urls.length &&
			urls.every(
				([url, width], i) =>
					width === element_urls[i][1] &&
					// We need to test both ways because Vite will create an a full URL with
					// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
					// relative URLs inside srcset are not automatically resolved to absolute URLs by
					// browsers (in contrast to img.src). This means both SSR and DOM code could
					// contain relative or absolute URLs.
					(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
			)
		);
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {string} value
	 * @param {string} [hash]
	 * @returns {void}
	 */
	function set_class(dom, value, hash) {
		// @ts-expect-error need to add __className to patched prototype
		var prev_class_name = dom.__className;
		var next_class_name = to_class(value, hash);

		if (hydrating && dom.className === next_class_name) {
			// In case of hydration don't reset the class as it's already correct.
			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		} else if (
			prev_class_name !== next_class_name ||
			(hydrating && dom.className !== next_class_name)
		) {
			// Removing the attribute when the value is only an empty string causes
			// peformance issues vs simply making the className an empty string. So
			// we should only remove the class if the the value is nullish.
			if (value == null && !hash) {
				dom.removeAttribute('class');
			} else {
				dom.className = next_class_name;
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = next_class_name;
		}
	}

	/**
	 * @template V
	 * @param {V} value
	 * @param {string} [hash]
	 * @returns {string | V}
	 */
	function to_class(value, hash) {
		return (value == null ? '' : value) + (hash ? ' ' + hash : '');
	}

	/**
	 * @param {Element} dom
	 * @param {string} class_name
	 * @param {boolean} value
	 * @returns {void}
	 */
	function toggle_class(dom, class_name, value) {
		if (value) {
			if (dom.classList.contains(class_name)) return;
			dom.classList.add(class_name);
		} else {
			if (!dom.classList.contains(class_name)) return;
			dom.classList.remove(class_name);
		}
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @returns {void}
	 */
	function run_tasks() {
		// use `raf.now()` instead of the `requestAnimationFrame` callback argument, because
		// otherwise things can get wonky https://github.com/sveltejs/svelte/pull/14541
		const now = raf.now();

		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		without_reactive_context(() => {
			element.dispatchEvent(new CustomEvent(type));
		});
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear$1 = (t) => t;

	/**
	 * Called inside keyed `{#each ...}` blocks (as `$.animation(...)`). This creates an animation manager
	 * and attaches it to the block, so that moves can be animated following reconciliation.
	 * @template P
	 * @param {Element} element
	 * @param {() => AnimateFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 */
	function animation(element, get_fn, get_params) {
		var item = /** @type {EachItem} */ (current_each_item);

		/** @type {DOMRect} */
		var from;

		/** @type {DOMRect} */
		var to;

		/** @type {Animation | undefined} */
		var animation;

		/** @type {null | { position: string, width: string, height: string, transform: string }} */
		var original_styles = null;

		item.a ??= {
			element,
			measure() {
				from = this.element.getBoundingClientRect();
			},
			apply() {
				animation?.abort();

				to = this.element.getBoundingClientRect();

				if (
					from.left !== to.left ||
					from.right !== to.right ||
					from.top !== to.top ||
					from.bottom !== to.bottom
				) {
					const options = get_fn()(this.element, { from, to }, get_params?.());

					animation = animate(this.element, options, undefined, 1, () => {
						animation?.abort();
						animation = undefined;
					});
				}
			},
			fix() {
				// If an animation is already running, transforming the element is likely to fail,
				// because the styles applied by the animation take precedence. In the case of crossfade,
				// that means the `translate(...)` of the crossfade transition overrules the `translate(...)`
				// we would apply below, leading to the element jumping somewhere to the top left.
				if (element.getAnimations().length) return;

				// It's important to destructure these to get fixed values - the object itself has getters,
				// and changing the style to 'absolute' can for example influence the width.
				var { position, width, height } = getComputedStyle(element);

				if (position !== 'absolute' && position !== 'fixed') {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					original_styles = {
						position: style.position,
						width: style.width,
						height: style.height,
						transform: style.transform
					};

					style.position = 'absolute';
					style.width = width;
					style.height = height;
					var to = element.getBoundingClientRect();

					if (from.left !== to.left || from.top !== to.top) {
						var transform = `translate(${from.left - to.left}px, ${from.top - to.top}px)`;
						style.transform = style.transform ? `${style.transform} ${transform}` : transform;
					}
				}
			},
			unfix() {
				if (original_styles) {
					var style = /** @type {HTMLElement | SVGElement} */ (element).style;

					style.position = original_styles.position;
					style.width = original_styles.width;
					style.height = original_styles.height;
					style.transform = original_styles.transform;
				}
			}
		};

		// in the case of a `<svelte:element>`, it's possible for `$.animation(...)` to be called
		// when an animation manager already exists, if the tag changes. in that case, we need to
		// swap out the element rather than creating a new manager, in case it happened at the same
		// moment as a reconciliation
		item.a.element = element;
	}

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect — later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = 'both' ;

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/**
		 * The default overflow style, stashed so we can revert changes during the transition
		 * that are necessary to work around a Safari <18 bug
		 * TODO 6.0 remove this, if older versions of Safari have died out enough
		 */
		var overflow = element.style.overflow;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			var previous_reaction = active_reaction;
			var previous_effect = active_effect;
			set_active_reaction(null);
			set_active_effect(null);
			try {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			} finally {
				set_active_reaction(previous_reaction);
				set_active_effect(previous_effect);
			}
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;

					element.style.overflow = overflow;
				});
			},
			out(fn) {

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value — `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear$1 } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		var animation = element.animate(keyframes, { duration: delay });

		animation.onfinish = () => {
			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				/**
				 * Whether or not the CSS includes `overflow: hidden`, in which case we need to
				 * add it as an inline style to work around a Safari <18 bug
				 * TODO 6.0 remove this, if possible
				 */
				var needs_overflow_hidden = false;

				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css_to_keyframe(css(t, 1 - t));
						keyframes.push(styles);

						needs_overflow_hidden ||= styles.overflow === 'hidden';
					}
				}

				if (needs_overflow_hidden) {
					/** @type {HTMLElement} */ (element).style.overflow = 'hidden';
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var runes = is_runes();

		listen_to_event_and_reset_event(input, 'input', (is_reset) => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,
			// because we use mutable state which ensures the render effect always runs)
			if (runes && value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			(hydrating && input.defaultValue !== input.value) ||
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);
		}

		render_effect(() => {
			if (input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			var value = get();

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			(hydrating && input.defaultChecked !== input.checked) ||
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Makes an `export`ed (non-prop) variable available on the `$$props` object
	 * so that consumers can do `bind:x` on the component.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} prop
	 * @param {V} value
	 * @returns {void}
	 */
	function bind_prop(props, prop, value) {
		var desc = get_descriptor(props, prop);

		if (desc && desc.set) {
			props[prop] = value;
			teardown(() => {
				props[prop] = null;
			});
		}
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} [mounting]
	 */
	function select_option(select, value, mounting) {
		if (select.multiple) {
			return select_options(select, value);
		}

		for (var option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {() => V} [get_value]
	 */
	function init_select(select, get_value) {
		let mounting = true;
		effect(() => {
			if (get_value) {
				select_option(select, untrack(get_value), mounting);
			}
			mounting = false;

			var observer = new MutationObserver(() => {
				// @ts-ignore
				var value = select.__value;
				select_option(select, value);
				// Deliberately don't update the potential binding value,
				// the model should be preserved unless explicitly changed
			});

			observer.observe(select, {
				// Listen to option element changes
				childList: true,
				subtree: true, // because of <optgroup>
				// Listen to option element value attribute changes
				// (doesn't get notified of select value changes,
				// because that property is not reflected as an attribute)
				attributes: true,
				attributeFilter: ['value']
			});

			return () => {
				observer.disconnect();
			};
		});
	}

	/**
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 */
	function select_options(select, value) {
		for (var option of select.options) {
			// @ts-ignore
			option.selected = ~value.indexOf(get_option_value(option));
		}
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/**
	 * @param {any} bound_value
	 * @param {Element} element_or_component
	 * @returns {boolean}
	 */
	function is_bound_this(bound_value, element_or_component) {
		return (
			bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component
		);
	}

	/**
	 * @param {any} element_or_component
	 * @param {(value: unknown, ...parts: unknown[]) => void} update
	 * @param {(...parts: unknown[]) => unknown} get_value
	 * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,
	 * 										returns all the parts of the each block context that are used in the expression
	 * @returns {void}
	 */
	function bind_this(element_or_component = {}, update, get_value, get_parts) {
		effect(() => {
			/** @type {unknown[]} */
			var old_parts;

			/** @type {unknown[]} */
			var parts;

			render_effect(() => {
				old_parts = parts;
				// We only track changes to the parts, not the value itself to avoid unnecessary reruns.
				parts = get_parts?.() || [];

				untrack(() => {
					if (element_or_component !== get_value(...parts)) {
						update(element_or_component, ...parts);
						// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at
						// the previous position if it isn't already taken over by a different effect.
						if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
							update(null, ...old_parts);
						}
					}
				});
			});

			return () => {
				// We cannot use effects in the teardown phase, we we use a microtask instead.
				queue_micro_task(() => {
					if (parts && is_bound_this(get_value(...parts), element_or_component)) {
						update(null, ...parts);
					}
				});
			};
		});

		return element_or_component;
	}

	/** @import { ActionReturn } from 'svelte/action' */

	/**
	 * Substitute for the `preventDefault` event modifier
	 * @deprecated
	 * @param {(event: Event, ...args: Array<unknown>) => void} fn
	 * @returns {(event: Event, ...args: unknown[]) => void}
	 */
	function preventDefault(fn) {
		return function (...args) {
			var event = /** @type {Event} */ (args[0]);
			event.preventDefault();
			// @ts-ignore
			return fn?.apply(this, args);
		};
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get$3(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get$3(signal);
		}

		props();
	}

	/**
	 * @this {any}
	 * @param {Record<string, unknown>} $$props
	 * @param {Event} event
	 * @returns {void}
	 */
	function bubble_event($$props, event) {
		var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[
			event.type
		];

		var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];

		for (var fn of callbacks) {
			// Preserve "this" context
			fn.call(this, event);
		}
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */
	/** @import { Stores, StoresValues, SubscribeInvalidateTuple } from '../private.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * @template T
	 * @param {Readable<T>} store
	 * @returns {T}
	 */
	function get$2(store) {
		let value;
		subscribe_to_store(store, (_) => (value = _))();
		// @ts-expect-error
		return value;
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	let IS_UNMOUNTED = Symbol();

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		// if the component that setup this is already unmounted we don't want to register a subscription
		if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		// if the component that setup this stores is already unmounted the source will be out of sync
		// so we just use the `get` for the stores, less performant but it avoids to create a memory leak
		// and it will keep the value consistent
		if (store && IS_UNMOUNTED in stores) {
			return get$2(store);
		}

		return get$3(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {[StoreReferencesContainer, ()=>void]}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		function cleanup() {
			teardown(() => {
				for (var store_name in stores) {
					const ref = stores[store_name];
					ref.unsubscribe();
				}
				define_property(stores, IS_UNMOUNTED, {
					enumerable: false,
					value: true
				});
			});
		}

		return [stores, cleanup];
	}

	/**
	 * Updates a store with a new value.
	 * @param {Store<V>} store  the store to update
	 * @param {any} expression  the expression that mutates the store
	 * @param {V} new_value  the new store value
	 * @template V
	 */
	function store_mutate(store, expression, new_value) {
		store.set(new_value);
		return expression;
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Source } from './types.js' */

	/**
	 * @param {((value?: number) => number)} fn
	 * @param {1 | -1} [d]
	 * @returns {number}
	 */
	function update_prop(fn, d = 1) {
		const value = fn();
		fn(value + d);
		return value;
	}

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {
			{
				// TODO should this happen in prod too?
				props_rest_readonly(`${target.name}.${String(key)}`);
			}

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			{ props, exclude, name, other: {}, to_proxy: [] } ,
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for legacy $$restProps and $$props
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}
	 */
	const legacy_rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			get$3(target.version);
			return key in target.special ? target.special[key]() : target.props[key];
		},
		set(target, key, value) {
			if (!(key in target.special)) {
				// Handle props that can temporarily get out of sync with the parent
				/** @type {Record<string, (v?: unknown) => unknown>} */
				target.special[key] = prop(
					{
						get [key]() {
							return target.props[key];
						}
					},
					/** @type {string} */ (key),
					PROPS_IS_UPDATED
				);
			}

			target.special[key](value);
			update(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun
			return true;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		deleteProperty(target, key) {
			// Svelte 4 allowed for deletions on $$restProps
			if (target.exclude.includes(key)) return true;
			target.exclude.push(key);
			update(target.version);
			return true;
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @returns {Record<string, unknown>}
	 */
	function legacy_rest_props(props, exclude) {
		return new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @template {Record<string | symbol, unknown>} T
	 * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
		var is_store_sub = false;
		var prop_value;

		if (bindable) {
			[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			prop_value = /** @type {V} */ (props[key]);
		}

		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

		var setter =
			(bindable &&
				(get_descriptor(props, key)?.set ??
					(is_entry_props && key in props && ((v) => (props[key] = v))))) ||
			undefined;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;
		var fallback_used = false;

		var get_fallback = () => {
			fallback_used = true;
			if (fallback_dirty) {
				fallback_dirty = false;
				if (lazy) {
					fallback_value = untrack(/** @type {() => V} */ (fallback));
				} else {
					fallback_value = /** @type {V} */ (fallback);
				}
			}

			return fallback_value;
		};

		if (prop_value === undefined && fallback !== undefined) {
			if (setter && runes) {
				props_invalid_value(key);
			}

			prop_value = get_fallback();
			if (setter) setter(prop_value);
		}

		/** @type {() => V} */
		var getter;
		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				fallback_used = false;
				return value;
			};
		} else {
			// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
			// Replicate that behavior through using a derived
			var derived_getter = (immutable ? derived : derived_safe_equal)(
				() => /** @type {V} */ (props[key])
			);
			derived_getter.f |= LEGACY_DERIVED_PROP;
			getter = () => {
				var value = get$3(derived_getter);
				if (value !== undefined) fallback_value = /** @type {V} */ (undefined);
				return value === undefined ? fallback_value : value;
			};
		}

		// easy mode — prop is never written to
		if ((flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// intermediate mode — prop is written to, but the parent component had
		// `bind:foo` which means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					// We don't want to notify if the value was mutated and the parent is in runes mode.
					// In that case the state proxy (if it exists) should take care of the notification.
					// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
					// has changed because the parent will not be able to detect the change otherwise.
					if (!runes || !mutation || legacy_parent || is_store_sub) {
						/** @type {Function} */ (setter)(mutation ? getter() : value);
					}
					return value;
				} else {
					return getter();
				}
			};
		}

		// hard mode. this is where it gets ugly — the value in the child should
		// synchronize with the parent, but it should also be possible to temporarily
		// set the value to something else locally.
		var from_child = false;

		// The derived returns the current value. The underlying mutable
		// source is written to from various places to persist this value.
		var inner_current_value = mutable_source(prop_value);
		var current_value = derived(() => {
			var parent_value = getter();
			var child_value = get$3(inner_current_value);

			if (from_child) {
				from_child = false;
				return child_value;
			}
			return (inner_current_value.v = parent_value);
		});

		if (!immutable) current_value.equals = safe_equals;

		return function (/** @type {any} */ value, /** @type {boolean} */ mutation) {

			if (arguments.length > 0) {
				const new_value = mutation ? get$3(current_value) : runes && bindable ? proxy(value) : value;

				if (!current_value.equals(new_value)) {
					from_child = true;
					set(inner_current_value, new_value);
					// To ensure the fallback value is consistent when used with proxies, we
					// update the local fallback_value, but only if the fallback is actively used
					if (fallback_used && fallback_value !== undefined) {
						fallback_value = new_value;
					}
					untrack(() => get$3(current_value)); // force a synchronisation immediately
				}

				return value;
			}
			return get$3(current_value);
		};
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	{
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside [server-side components](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onMount');
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onDestroy');
		}

		onMount(() => () => untrack(fn));
	}

	/**
	 * @template [T=any]
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {any}params_0
	 * @returns {CustomEvent<T>}
	 */
	function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events)
	 * @template {Record<string, any>} [EventMap = any]
	 * @returns {EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const active_component_context = component_context;
		if (active_component_context === null) {
			lifecycle_outside_component('createEventDispatcher');
		}

		return (type, detail, options) => {
			const events = /** @type {Record<string, Function | Function[]>} */ (
				active_component_context.s.$$events
			)?.[/** @type {any} */ (type)];

			if (events) {
				const callbacks = is_array(events) ? events.slice() : [events];
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = create_custom_event(/** @type {string} */ (type), detail, options);
				for (const fn of callbacks) {
					fn.call(active_component_context.x, event);
				}
				return !event.defaultPrevented;
			}

			return true;
		};
	}

	// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6

	/**
	 * Schedules a callback to run immediately before the component is updated after any state change.
	 *
	 * The first time the callback runs will be before the initial `onMount`.
	 *
	 * In runes mode use `$effect.pre` instead.
	 *
	 * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function beforeUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('beforeUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('beforeUpdate');
		}

		init_update_callbacks(component_context).b.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`.
	 *
	 * In runes mode use `$effect` instead.
	 *
	 * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead
	 * @param {() => void} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		if (component_context === null) {
			lifecycle_outside_component('afterUpdate');
		}

		if (component_context.l === null) {
			lifecycle_legacy_only('afterUpdate');
		}

		init_update_callbacks(component_context).a.push(fn);
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/**
	 * Synchronously flushes any pending state changes and those that result from it.
	 * @param {() => void} [fn]
	 * @returns {void}
	 */
	function flushSync(fn) {
		flush_sync(fn);
	}

	var indexClient = /*#__PURE__*/Object.freeze({
		__proto__: null,
		afterUpdate: afterUpdate,
		beforeUpdate: beforeUpdate,
		createEventDispatcher: createEventDispatcher,
		createRawSnippet: createRawSnippet,
		flushSync: flushSync,
		getAllContexts: getAllContexts,
		getContext: getContext,
		hasContext: hasContext,
		hydrate: hydrate,
		mount: mount,
		onDestroy: onDestroy,
		onMount: onMount,
		setContext: setContext,
		tick: tick,
		unmount: unmount,
		untrack: untrack
	});

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);

	function _assertClassBrand(e, t, n) {
	  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
	  throw new TypeError("Private element is not present on this object");
	}
	function _assertThisInitialized(e) {
	  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  return e;
	}
	function _callSuper(t, o, e) {
	  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
	}
	function _checkPrivateRedeclaration(e, t) {
	  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
	}
	function _classCallCheck(a, n) {
	  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}
	function _classPrivateFieldGet2(s, a) {
	  return s.get(_assertClassBrand(s, a));
	}
	function _classPrivateFieldInitSpec(e, t, a) {
	  _checkPrivateRedeclaration(e, t), t.set(e, a);
	}
	function _classPrivateFieldSet2(s, a, r) {
	  return s.set(_assertClassBrand(s, a), r), r;
	}
	function _classPrivateMethodInitSpec(e, a) {
	  _checkPrivateRedeclaration(e, a), a.add(e);
	}
	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: false
	  }), e;
	}
	function _defineProperty(e, r, t) {
	  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: true,
	    configurable: true,
	    writable: true
	  }) : e[r] = t, e;
	}
	function _getPrototypeOf(t) {
	  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
	    return t.__proto__ || Object.getPrototypeOf(t);
	  }, _getPrototypeOf(t);
	}
	function _inherits(t, e) {
	  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	  t.prototype = Object.create(e && e.prototype, {
	    constructor: {
	      value: t,
	      writable: true,
	      configurable: true
	    }
	  }), Object.defineProperty(t, "prototype", {
	    writable: false
	  }), e && _setPrototypeOf(t, e);
	}
	function _isNativeReflectConstruct() {
	  try {
	    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	  } catch (t) {}
	  return (_isNativeReflectConstruct = function () {
	    return !!t;
	  })();
	}
	function _possibleConstructorReturn(t, e) {
	  if (e && ("object" == typeof e || "function" == typeof e)) return e;
	  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	  return _assertThisInitialized(t);
	}
	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}

	const inputValuesExtractors = Object.freeze({
	  checkbox: function (inpEl, defaultValue = undefined) {
	    if (typeof defaultValue == "object" && Object.hasOwn(defaultValue, "checked") && Object.hasOwn(defaultValue, "unchecked")) {
	      return inpEl.checked ? defaultValue.checked : defaultValue.unchecked;
	    } else if (Object.hasOwn(inpEl, "value") && typeof inpEl.value !== "undefined") {
	      return inpEl.checked ? inpEl.value : false;
	    } else {
	      return inpEl.checked;
	    }
	  }
	});

	/**
	 * Collection of common to UI functions and properties
	 *
	 * @class UICommon
	 */
	let UICommon$1 = /*#__PURE__*/function () {
	  function UICommon() {
	    _classCallCheck(this, UICommon);
	  }
	  return _createClass(UICommon, null, [{
	    key: "inputValuesExtractors",
	    get: function () {
	      return inputValuesExtractors;
	    }
	  }, {
	    key: "extractValueFromInput",
	    value: function extractValueFromInput(inpEl, defaultValue = undefined) {
	      if (!inpEl) return defaultValue;
	      if (Object.hasOwn(UICommon.inputValuesExtractors, inpEl.type)) {
	        return UICommon.inputValuesExtractors[inpEl.type](inpEl, defaultValue);
	      }
	      return inpEl.value;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string}      field    field name
	     * @param {import('./events.types').UIEventInputChangeCallback}    onchange
	     * @param {any}         [defaultValue=undefined]
	     * @param {object}      [additional = {}]
	     * @return {import('./events.types').UIEventCallback}
	     * @memberof UICommon
	     */
	  }, {
	    key: "onInput",
	    value: function onInput(field, onchange, defaultValue = undefined, additional = {}) {
	      if (typeof onchange !== "function") {
	        return undefined;
	      }
	      return function (event) {
	        typeof event?.preventDefault === "function" && event?.preventDefault();
	        const value = UICommon.extractValueFromInput(event?.currentTarget, defaultValue);
	        return onchange({
	          field,
	          value
	        }, event, additional);
	      };
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {KeyboardEvent} e
	     * @memberof UICommon
	     */
	  }, {
	    key: "isEnterEvent",
	    value: function isEnterEvent(e) {
	      return e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.shiftKey;
	    }
	  }, {
	    key: "onlyOnEnter",
	    value: function onlyOnEnter(callback) {
	      return function (e) {
	        if (UICommon.isEnterEvent(e)) {
	          return callback(e);
	        } else {
	          return true;
	        }
	      };
	    }
	  }, {
	    key: "isMobile",
	    value: function isMobile() {
	      const testMobile = window.matchMedia || window.msMatchMedia;
	      if (testMobile) {
	        let testQuery = "(pointer:coarse)";
	        if (arguments.length) {
	          const max_width = typeof arguments[0] === "boolean" ? this.MOBILE_WIDTH_BREAK_POINT : arguments[0];
	          testQuery = `only screen and (max-width: ${max_width}px)`;
	        }
	        return testMobile(testQuery).matches;
	      }
	      return false;
	    }
	  }, {
	    key: "removeBodyScroll",
	    value: function removeBodyScroll() {
	      document.body.classList.add(this.SCROLL_DISABLER_CLASS);
	    }
	  }, {
	    key: "restoreBodyScroll",
	    value: function restoreBodyScroll() {
	      document.body.classList.remove(this.SCROLL_DISABLER_CLASS);
	    }

	    /**
	     *  Reformats input from any string to strict phone format
	     *  @param {string}    val    free style phone number
	     *  @param {string}    [filler=UICommon.FILLER]    free style phone number
	     *  @returns {string}          phone number
	     **/
	  }, {
	    key: "formatPhone",
	    value: function formatPhone(val, filler = this.FILLER) {
	      //starting from 11 digits in phone number
	      const slots = [1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5];
	      let digits = val.replace(/\D/g, "");
	      //if there are more, move them to country code slot
	      if (digits.length > 11) {
	        let d = digits.length - 11;
	        while (d > 0) {
	          d--;
	          slots.unshift(1);
	        }
	      }
	      let stack = ["", "", "", "", ""];
	      Array.from(digits).forEach(function (digit, index) {
	        let slot = slots[index];
	        stack[slot - 1] = stack[slot - 1] + digit;
	      });
	      //creating map of parts lengths
	      const lens = slots.reduce(function (acc, curr) {
	        if (typeof acc[curr] === "undefined") {
	          acc[curr] = 1;
	        } else {
	          acc[curr] += 1;
	        }
	        return acc;
	      }, {});
	      //fill empty positions with filler (_)
	      for (let t in stack) {
	        let dif = lens[parseInt(t) + 1] - stack[t].length;
	        while (dif > 0) {
	          stack[t] = stack[t] + filler;
	          dif--;
	        }
	      }
	      return `+${stack[0]} (${stack[1]}) ${stack[2]}-${stack[3]}-${stack[4]}`;
	    }
	  }, {
	    key: "setMoneySign",
	    value: function setMoneySign(val) {
	      this.MONEY_SIGN = val;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {number} price
	     * @return {string}
	     * @memberof UICommon
	     */
	  }, {
	    key: "formatPrice",
	    value: function formatPrice(price) {
	      let major = Math.floor(price / 100),
	        minor = price % 100;
	      return `${this.MONEY_SIGN}${major.toString()}.${minor.toString()}`;
	    }
	  }, {
	    key: "formatLocaleDatetime",
	    value: function formatLocaleDatetime(dt, opts = {
	      date: true,
	      time: true
	    }) {
	      const date = dt.toLocaleDateString(window.navigator.language);
	      const time = dt.toLocaleTimeString(window.navigator.language);
	      if (opts.date && opts.time) {
	        return `${date} ${time}`;
	      } else if (opts.date && !opts.time) {
	        return date;
	      } else {
	        return time;
	      }
	    }
	  }, {
	    key: "tryFormatLocaleDateTime",
	    value: function tryFormatLocaleDateTime(value, opts = {
	      date: true,
	      time: true
	    }) {
	      if (typeof value == "string" || typeof value == "number") {
	        const dt = new Date(value);
	        return UICommon.formatLocaleDatetime(dt, opts);
	      } else if (typeof value == "object") {
	        return UICommon.formatLocaleDatetime(value, opts);
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "formatTimestamp",
	    value: function formatTimestamp(timestamp, offset = 0) {
	      let offsetLocal = new Date().getTimezoneOffset();
	      let deltaOffset = (offsetLocal - offset) * 60 * 1000;
	      let localDateTime = new Date(parseInt(timestamp) - deltaOffset);
	      return localDateTime.toLocaleString(window.navigator.language);
	    }
	  }, {
	    key: "declOfNum",
	    value: function declOfNum(n, text_forms) {
	      n = Math.abs(n) % 100;
	      let n1 = n % 10;
	      if (n > 10 && n < 20) {
	        return text_forms[2];
	      }
	      if (n1 > 1 && n1 < 5) {
	        return text_forms[1];
	      }
	      if (n1 == 1) {
	        return text_forms[0];
	      }
	      return text_forms[2];
	    }
	  }, {
	    key: "humanizedTimeDiff",
	    value: function humanizedTimeDiff(date /* unix time */) {
	      let currentTime = new Date().getTime();
	      let sec = Math.round((currentTime - date) / 1000);
	      let unit;
	      if (sec < 60) {
	        unit = this.declOfNum(sec, this.TIME.SECONDS);
	        return `${sec} ${unit} назад`;
	      } else if (sec < 3600) {
	        let min = Math.floor(sec / 60);
	        unit = this.declOfNum(min, this.TIME.MINUTES);
	        return `${min} ${unit} назад`;
	      } else {
	        let hours = Math.floor(sec / (60 * 60));
	        unit = this.declOfNum(hours, this.TIME.HOURS);
	        return `${hours} ${unit} назад`;
	      }
	    }
	  }, {
	    key: "stylesObjectToString",
	    value: function stylesObjectToString(styles = {}) {
	      if (typeof styles === "object") {
	        Object.keys(styles).map(function (prop) {
	          return `${prop}: ${styles.prop};`;
	        }).join("");
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "stringOrNumber",
	    value: function stringOrNumber(val) {
	      return ["string", "number"].indexOf(typeof val) > -1;
	    }
	  }, {
	    key: "stringsOfNumbers",
	    value: function stringsOfNumbers(list) {
	      return list.every(this.stringOrNumber);
	    }
	  }]);
	}();
	_defineProperty(UICommon$1, "CLEAR_MACRO", "__CLEAR__");
	_defineProperty(UICommon$1, "ERROR_DEFAULT", "Что пошло не так.");
	_defineProperty(UICommon$1, "DEFAULT_REDIRECT_TIMEOUT", 3000);
	_defineProperty(UICommon$1, "CLASS_OK", "is-success");
	_defineProperty(UICommon$1, "CLASS_ERR", "is-danger");
	_defineProperty(UICommon$1, "SCROLL_DISABLER_CLASS", "remove-scroll");
	_defineProperty(UICommon$1, "FILLER", "_");
	_defineProperty(UICommon$1, "SCROLL_OPTIONS", {
	  top: 0,
	  behavior: "smooth"
	});
	_defineProperty(UICommon$1, "MOBILE_WIDTH_BREAK_POINT", 760);
	_defineProperty(UICommon$1, "MONEY_SIGN", "&#8381;");
	_defineProperty(UICommon$1, "TIME", {
	  SECONDS: ["секунду", "секунды", "секунд"],
	  MINUTES: ["минуту", "минуты", "минут"],
	  HOURS: ["час", "часа", "часов"]
	});

	var root$Q = template(`<div><!></div>`);

	function Ui_block($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string}   [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'children'
			]);

		var div = root$Q();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => attributes = set_attributes(div, attributes, {
			class: `block ${classes() ?? ''}`,
			...others
		}));

		append($$anchor, div);
	}

	function Ui_block_inner_vertical($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const DEFAULT_CLASSES_INNER = "block-inner-vertical";
		let classesInner = state(DEFAULT_CLASSES_INNER);

		user_effect(() => {
			set(classesInner, `block-inner-vertical ${classes()}`);
		});

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);

		Ui_block($$anchor, {
			get id() {
				return id();
			},
			get class() {
				return get$3(classesInner);
			},
			get onclick() {
				return onclick();
			},
			onkeyup: onKeyUp,
			get role() {
				return role();
			},
			get tabIndex() {
				return tabIndex();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				snippet(node, () => $$props.children ?? noop);
				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$P = template(`<div><!></div>`);

	function Ui_box($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$P();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_class(div, `box ${classes() ?? ''} `);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root$O = template(`<div><!></div>`);

	function Ui_content($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id]
		 * @property {string}   [class]
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {function} [onclick = () => true]
		 * @property {function} [onkeyup]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, 0),
			onclick = prop($$props, 'onclick', 3, () => true);

		const onKeyUp = $$props.onkeyup ?? (onclick() ? UICommon$1.onlyOnEnter(onclick()) : undefined);
		var div = root$O();

		div.__click = function (...$$args) {
			onclick()?.apply(this, $$args);
		};

		div.__keyup = onKeyUp;

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_class(div, `content ${classes() ?? ''}`);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
		});

		append($$anchor, div);
		pop();
	}

	delegate(['click', 'keyup']);

	var root$N = template(`<div><!></div>`);

	function Ui_clickable_div($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 3, ""),
			preventDefault = prop($$props, 'preventDefault', 3, true),
			click = prop($$props, 'click', 3, true),
			enter = prop($$props, 'enter', 3, true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'preventDefault',
				'click',
				'enter',
				'callback',
				'children'
			]);

		const mouseEvent = (e) => {
			preventDefault() && e.preventDefault();
			$$props.callback(e);
		};

		const keyboardEvent = (e) => {
			preventDefault() && e.preventDefault();

			if (e && e.key == "Enter") {
				$$props.callback(e);
			}
		};

		var div = root$N();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children);
		reset(div);

		template_effect(() => attributes = set_attributes(div, attributes, {
			class: classes(),
			role: 'button',
			tabindex: '0',
			onkeyup: enter() ? keyboardEvent : undefined,
			onclick: click() ? mouseEvent : undefined,
			...others
		}));

		append($$anchor, div);
		pop();
	}

	var index$c = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBlock: Ui_block,
		UIBlockInnerVertical: Ui_block_inner_vertical,
		UIBox: Ui_box,
		UIClickableDiv: Ui_clickable_div,
		UIContent: Ui_content
	});

	function initDict(target = {}) {
	  const handler = {
	    get: function (target, prop) {
	      if (!Object.hasOwn(target, prop)) {
	        return prop;
	      }
	      return Reflect.get(...arguments);
	    }
	  };
	  return new Proxy(target, handler);
	}
	function createLocale() {
	  const {
	    subscribe,
	    set,
	    update
	  } = writable(initDict());
	  return {
	    subscribe,
	    update,
	    set: function (val) {
	      set(initDict(val));
	    },
	    reset: function () {
	      return set(initDict());
	    }
	  };
	}
	const LOCALE = createLocale();

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var EventEmitter$2 = {exports: {}};

	/*!
	 * EventEmitter v5.2.9 - git.io/ee
	 * Unlicense - http://unlicense.org/
	 * Oliver Caldwell - https://oli.me.uk/
	 * @preserve
	 */
	var EventEmitter$1 = EventEmitter$2.exports;

	var hasRequiredEventEmitter;

	function requireEventEmitter () {
		if (hasRequiredEventEmitter) return EventEmitter$2.exports;
		hasRequiredEventEmitter = 1;
		(function (module) {
	(function (exports) {

			    /**
			     * Class for managing events.
			     * Can be extended to provide event functionality in other classes.
			     *
			     * @class EventEmitter Manages event registering and emitting.
			     */
			    function EventEmitter() {}

			    // Shortcuts to improve speed and size
			    var proto = EventEmitter.prototype;
			    var originalGlobalValue = exports.EventEmitter;

			    /**
			     * Finds the index of the listener for the event in its storage array.
			     *
			     * @param {Function[]} listeners Array of listeners to search through.
			     * @param {Function} listener Method to look for.
			     * @return {Number} Index of the specified listener, -1 if not found
			     * @api private
			     */
			    function indexOfListener(listeners, listener) {
			        var i = listeners.length;
			        while (i--) {
			            if (listeners[i].listener === listener) {
			                return i;
			            }
			        }

			        return -1;
			    }

			    /**
			     * Alias a method while keeping the context correct, to allow for overwriting of target method.
			     *
			     * @param {String} name The name of the target method.
			     * @return {Function} The aliased method
			     * @api private
			     */
			    function alias(name) {
			        return function aliasClosure() {
			            return this[name].apply(this, arguments);
			        };
			    }

			    /**
			     * Returns the listener array for the specified event.
			     * Will initialise the event object and listener arrays if required.
			     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
			     * Each property in the object response is an array of listener functions.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Function[]|Object} All listener functions for the event.
			     */
			    proto.getListeners = function getListeners(evt) {
			        var events = this._getEvents();
			        var response;
			        var key;

			        // Return a concatenated array of all matching events if
			        // the selector is a regular expression.
			        if (evt instanceof RegExp) {
			            response = {};
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    response[key] = events[key];
			                }
			            }
			        }
			        else {
			            response = events[evt] || (events[evt] = []);
			        }

			        return response;
			    };

			    /**
			     * Takes a list of listener objects and flattens it into a list of listener functions.
			     *
			     * @param {Object[]} listeners Raw listener objects.
			     * @return {Function[]} Just the listener functions.
			     */
			    proto.flattenListeners = function flattenListeners(listeners) {
			        var flatListeners = [];
			        var i;

			        for (i = 0; i < listeners.length; i += 1) {
			            flatListeners.push(listeners[i].listener);
			        }

			        return flatListeners;
			    };

			    /**
			     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
			     *
			     * @param {String|RegExp} evt Name of the event to return the listeners from.
			     * @return {Object} All listener functions for an event in an object.
			     */
			    proto.getListenersAsObject = function getListenersAsObject(evt) {
			        var listeners = this.getListeners(evt);
			        var response;

			        if (listeners instanceof Array) {
			            response = {};
			            response[evt] = listeners;
			        }

			        return response || listeners;
			    };

			    function isValidListener (listener) {
			        if (typeof listener === 'function' || listener instanceof RegExp) {
			            return true
			        } else if (listener && typeof listener === 'object') {
			            return isValidListener(listener.listener)
			        } else {
			            return false
			        }
			    }

			    /**
			     * Adds a listener function to the specified event.
			     * The listener will not be added if it is a duplicate.
			     * If the listener returns true then it will be removed after it is called.
			     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListener = function addListener(evt, listener) {
			        if (!isValidListener(listener)) {
			            throw new TypeError('listener must be a function');
			        }

			        var listeners = this.getListenersAsObject(evt);
			        var listenerIsWrapped = typeof listener === 'object';
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
			                listeners[key].push(listenerIsWrapped ? listener : {
			                    listener: listener,
			                    once: false
			                });
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of addListener
			     */
			    proto.on = alias('addListener');

			    /**
			     * Semi-alias of addListener. It will add a listener that will be
			     * automatically removed after its first execution.
			     *
			     * @param {String|RegExp} evt Name of the event to attach the listener to.
			     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addOnceListener = function addOnceListener(evt, listener) {
			        return this.addListener(evt, {
			            listener: listener,
			            once: true
			        });
			    };

			    /**
			     * Alias of addOnceListener.
			     */
			    proto.once = alias('addOnceListener');

			    /**
			     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
			     * You need to tell it what event names should be matched by a regex.
			     *
			     * @param {String} evt Name of the event to create.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvent = function defineEvent(evt) {
			        this.getListeners(evt);
			        return this;
			    };

			    /**
			     * Uses defineEvent to define multiple events.
			     *
			     * @param {String[]} evts An array of event names to define.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.defineEvents = function defineEvents(evts) {
			        for (var i = 0; i < evts.length; i += 1) {
			            this.defineEvent(evts[i]);
			        }
			        return this;
			    };

			    /**
			     * Removes a listener function from the specified event.
			     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to remove the listener from.
			     * @param {Function} listener Method to remove from the event.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListener = function removeListener(evt, listener) {
			        var listeners = this.getListenersAsObject(evt);
			        var index;
			        var key;

			        for (key in listeners) {
			            if (listeners.hasOwnProperty(key)) {
			                index = indexOfListener(listeners[key], listener);

			                if (index !== -1) {
			                    listeners[key].splice(index, 1);
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of removeListener
			     */
			    proto.off = alias('removeListener');

			    /**
			     * Adds listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
			     * You can also pass it a regular expression to add the array of listeners to all events that match it.
			     * Yeah, this function does quite a bit. That's probably a bad thing.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.addListeners = function addListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(false, evt, listeners);
			    };

			    /**
			     * Removes listeners in bulk using the manipulateListeners method.
			     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be removed.
			     * You can also pass it a regular expression to remove the listeners from all events that match it.
			     *
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeListeners = function removeListeners(evt, listeners) {
			        // Pass through to manipulateListeners
			        return this.manipulateListeners(true, evt, listeners);
			    };

			    /**
			     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
			     * The first argument will determine if the listeners are removed (true) or added (false).
			     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
			     * You can also pass it an event name and an array of listeners to be added/removed.
			     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
			     *
			     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
			     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
			     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
			        var i;
			        var value;
			        var single = remove ? this.removeListener : this.addListener;
			        var multiple = remove ? this.removeListeners : this.addListeners;

			        // If evt is an object then pass each of its properties to this method
			        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			            for (i in evt) {
			                if (evt.hasOwnProperty(i) && (value = evt[i])) {
			                    // Pass the single listener straight through to the singular method
			                    if (typeof value === 'function') {
			                        single.call(this, i, value);
			                    }
			                    else {
			                        // Otherwise pass back to the multiple function
			                        multiple.call(this, i, value);
			                    }
			                }
			            }
			        }
			        else {
			            // So evt must be a string
			            // And listeners must be an array of listeners
			            // Loop over it and pass each one to the multiple method
			            i = listeners.length;
			            while (i--) {
			                single.call(this, evt, listeners[i]);
			            }
			        }

			        return this;
			    };

			    /**
			     * Removes all listeners from a specified event.
			     * If you do not specify an event then all listeners will be removed.
			     * That means every event will be emptied.
			     * You can also pass a regex to remove all events that match it.
			     *
			     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.removeEvent = function removeEvent(evt) {
			        var type = typeof evt;
			        var events = this._getEvents();
			        var key;

			        // Remove different things depending on the state of evt
			        if (type === 'string') {
			            // Remove all listeners for the specified event
			            delete events[evt];
			        }
			        else if (evt instanceof RegExp) {
			            // Remove all events matching the regex.
			            for (key in events) {
			                if (events.hasOwnProperty(key) && evt.test(key)) {
			                    delete events[key];
			                }
			            }
			        }
			        else {
			            // Remove all listeners in all events
			            delete this._events;
			        }

			        return this;
			    };

			    /**
			     * Alias of removeEvent.
			     *
			     * Added to mirror the node API.
			     */
			    proto.removeAllListeners = alias('removeEvent');

			    /**
			     * Emits an event of your choice.
			     * When emitted, every listener attached to that event will be executed.
			     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
			     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
			     * So they will not arrive within the array on the other side, they will be separate.
			     * You can also pass a regular expression to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {Array} [args] Optional array of arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emitEvent = function emitEvent(evt, args) {
			        var listenersMap = this.getListenersAsObject(evt);
			        var listeners;
			        var listener;
			        var i;
			        var key;
			        var response;

			        for (key in listenersMap) {
			            if (listenersMap.hasOwnProperty(key)) {
			                listeners = listenersMap[key].slice(0);

			                for (i = 0; i < listeners.length; i++) {
			                    // If the listener returns true then it shall be removed from the event
			                    // The function is executed either with a basic call or an apply if there is an args array
			                    listener = listeners[i];

			                    if (listener.once === true) {
			                        this.removeListener(evt, listener.listener);
			                    }

			                    response = listener.listener.apply(this, args || []);

			                    if (response === this._getOnceReturnValue()) {
			                        this.removeListener(evt, listener.listener);
			                    }
			                }
			            }
			        }

			        return this;
			    };

			    /**
			     * Alias of emitEvent
			     */
			    proto.trigger = alias('emitEvent');

			    /**
			     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
			     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
			     *
			     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
			     * @param {...*} Optional additional arguments to be passed to each listener.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.emit = function emit(evt) {
			        var args = Array.prototype.slice.call(arguments, 1);
			        return this.emitEvent(evt, args);
			    };

			    /**
			     * Sets the current value to check against when executing listeners. If a
			     * listeners return value matches the one set here then it will be removed
			     * after execution. This value defaults to true.
			     *
			     * @param {*} value The new value to check for when executing listeners.
			     * @return {Object} Current instance of EventEmitter for chaining.
			     */
			    proto.setOnceReturnValue = function setOnceReturnValue(value) {
			        this._onceReturnValue = value;
			        return this;
			    };

			    /**
			     * Fetches the current value to check against when executing listeners. If
			     * the listeners return value matches this one then it should be removed
			     * automatically. It will return true by default.
			     *
			     * @return {*|Boolean} The current value to check for or the default, true.
			     * @api private
			     */
			    proto._getOnceReturnValue = function _getOnceReturnValue() {
			        if (this.hasOwnProperty('_onceReturnValue')) {
			            return this._onceReturnValue;
			        }
			        else {
			            return true;
			        }
			    };

			    /**
			     * Fetches the events object and creates one if required.
			     *
			     * @return {Object} The events storage object.
			     * @api private
			     */
			    proto._getEvents = function _getEvents() {
			        return this._events || (this._events = {});
			    };

			    /**
			     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
			     *
			     * @return {Function} Non conflicting EventEmitter class.
			     */
			    EventEmitter.noConflict = function noConflict() {
			        exports.EventEmitter = originalGlobalValue;
			        return EventEmitter;
			    };

			    // Expose the class either via AMD, CommonJS or the global object
			    if (module.exports){
			        module.exports = EventEmitter;
			    }
			    else {
			        exports.EventEmitter = EventEmitter;
			    }
			}(typeof window !== 'undefined' ? window : EventEmitter$1 || {})); 
		} (EventEmitter$2));
		return EventEmitter$2.exports;
	}

	var EventEmitterExports = requireEventEmitter();
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(EventEmitterExports);

	/*
		:property.sub1.func().funcProp
		 = return funcProp of function result of sub1 property of property of object
		:{::helperVal}.sub
		 = return sub property of object property with name retrieved from helperVal property of helpers object
		:{::helperFunc()}.sub
		= return sub property of object property with name retrieved from helperVal function result of helpers object.
		if helpersFunx return 'car' then source path becomes :car.sub

	*/

	var src$1;
	var hasRequiredSrc$1;

	function requireSrc$1 () {
		if (hasRequiredSrc$1) return src$1;
		hasRequiredSrc$1 = 1;
		const SUB_PATH_START = "{",
		    SUB_PATH_END = "}",
		    PATH_SPLIT = ".",
		    PATH_START_OBJECT = ":",
		    PATH_START_HELPERS = "::",
		    FUNCTION_MARKER = "()",
		    MAX_DEEP = 10;

		/**
		 * Set of tools to use notPath property access notation
		 * : is for item
		 * :: is for helpers
		 * {} subpath
		 * . path splitter
		 * () function and should be executed with params (item, helper | undefined)
		 * sub-paths will be parsed and replaced by results in source path
		 */
		class notPath {
		    static get SUB_PATH_START() {
		        return SUB_PATH_START;
		    }
		    static get SUB_PATH_END() {
		        return SUB_PATH_END;
		    }
		    static get PATH_SPLIT() {
		        return PATH_SPLIT;
		    }
		    static get PATH_START_OBJECT() {
		        return PATH_START_OBJECT;
		    }
		    static get PATH_START_HELPERS() {
		        return PATH_START_HELPERS;
		    }
		    static get FUNCTION_MARKER() {
		        return FUNCTION_MARKER;
		    }
		    static get MAX_DEEP() {
		        return MAX_DEEP;
		    }

		    /*
				input ':{::helperVal}.sub'
				return ::helperVal
			*/

		    /**
		     * Returns first subpath in path
		     * if subpath not closed will return it anyway
		     * @param {string} path path in string notation
		     * @return {string|null} subpath or null if no sub path were found
		     */
		    static findNextSubPath(path) {
		        let subPath = "",
		            find = false;
		        for (let i = 0; i < path.length; i++) {
		            if (path[i] === SUB_PATH_START) {
		                find = true;
		                subPath = "";
		            } else {
		                if (path[i] === SUB_PATH_END && find) {
		                    return subPath;
		                } else {
		                    subPath += path[i];
		                }
		            }
		        }
		        return find ? subPath : null;
		    }

		    /**
		     * Replace sub-path in parent path by parsed version
		     * @param {string} path path to process
		     * @param {string} sub sub path to replace
		     * @param {string} parsed parsed sub path
		     * @return {string} parsed path
		     */

		    static replaceSubPath(path, sub, parsed) {
		        let subf = SUB_PATH_START + sub + SUB_PATH_END,
		            i = 0;
		        while (path.indexOf(subf) > -1 && i < MAX_DEEP) {
		            path = path.replace(subf, parsed);
		            i++;
		        }
		        return path;
		    }

		    /**
		     * Parses path while there any sub-paths
		     * @param {string} path raw unparsed path
		     * @param {object} item data
		     * @param {object} helpers helpers
		     * @return {string} parsed path
		     */
		    static parseSubs(path, item, helpers) {
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            i++;
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		        }
		        return path;
		    }

		    /**
		     * Get property value
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} [helpers] helpers object
		     */

		    static get(path, item, helpers = undefined) {
		        switch (path) {
		            case PATH_START_OBJECT:
		                return item;
		            case PATH_START_HELPERS:
		                return helpers;
		        }
		        path = this.parseSubs(path, item, helpers);
		        return this.getValueByPath(
		            path.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		            path,
		            item,
		            helpers
		        );
		    }

		    /**
		     * Set property value
		     * @param {string}  path path to property
		     * @param {object}  item item object
		     * @param {object}  helpers         helpers object if 4 arguments or attrValue if only 3 provided
		     * @param {any}     [attrValue]     value we want to assign
		     */

		    static set(path, item, helpers, attrValue = undefined) {
		        if (arguments.length === 3) {
		            attrValue = helpers;
		            helpers = undefined;
		        }
		        let subPath = this.findNextSubPath(path),
		            subPathParsed,
		            i = 0;
		        while (subPath) {
		            subPathParsed = this.getValueByPath(
		                subPath.indexOf(PATH_START_HELPERS) > -1 ? helpers : item,
		                subPath,
		                item,
		                helpers
		            );
		            path = this.replaceSubPath(path, subPath, subPathParsed);
		            if (i > MAX_DEEP) {
		                break;
		            }
		            subPath = this.findNextSubPath(path);
		            i++;
		        }
		        this.setValueByPath(item, path, attrValue);
		        if (
		            item.isRecord &&
		            this.normilizePath(path).length > 1 &&
		            item.__isActive
		        ) {
		            item.trigger("change", item, path, attrValue);
		        }
		    }

		    /**
		     * Set target property to null
		     * @param {string} path path to property
		     * @param {object} item item object
		     * @param {object} helpers helpers object
		     */

		    static unset(path, item, helpers) {
		        this.set(path, item, helpers, null);
		    }

		    /**
		     * Parses step key, transforms it to end-form
		     * @param {string} step not parsed step key
		     * @param {object} item item object
		     * @param {object} helper helpers object
		     * @return {string|number} parsed step key
		     */

		    static parsePathStep(step, item, helper) {
		        let rStep = null;
		        if (step.indexOf(PATH_START_HELPERS) === 0 && helper) {
		            rStep = step.replace(PATH_START_HELPERS, "");
		            if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                rStep = rStep.replace(FUNCTION_MARKER, "");
		                if (Object.prototype.hasOwnProperty.call(helper, rStep)) {
		                    return helper[rStep](item, undefined);
		                }
		            } else {
		                return helper[rStep];
		            }
		        } else {
		            if (step.indexOf(PATH_START_OBJECT) === 0 && item) {
		                rStep = step.replace(PATH_START_OBJECT, "");
		                if (rStep.indexOf(FUNCTION_MARKER) === rStep.length - 2) {
		                    rStep = rStep.replace(FUNCTION_MARKER, "");
		                    if (Object.prototype.hasOwnProperty.call(item, rStep)) {
		                        return item[rStep](item, undefined);
		                    }
		                } else {
		                    return item[rStep];
		                }
		            }
		        }
		        return step;
		    }

		    //::fieldName.result
		    //{}
		    //{fieldName: 'targetRecordField'}
		    ////['targetRecordField', 'result']
		    /**
		     * Transforms path with sub paths to path without
		     * @param {string|array} path path to target property
		     * @param {object} item item object
		     * @param {object} helper helper object
		     * @return {array} parsed path
		     **/
		    static parsePath(path, item, helper) {
		        if (!Array.isArray(path)) {
		            path = path.split(PATH_SPLIT);
		        }
		        for (var i = 0; i < path.length; i++) {
		            path[i] = this.parsePathStep(path[i], item, helper);
		        }
		        return path;
		    }

		    /**
		     * Transforms path from string notation to array of keys
		     * @param {string|array} path  input path, if array does nothing
		     * @return {array} path in array notation
		     */

		    static normilizePath(path) {
		        if (Array.isArray(path)) {
		            return path;
		        } else {
		            while (path.indexOf(PATH_START_OBJECT) > -1) {
		                path = path.replace(PATH_START_OBJECT, "");
		            }
		            return path.split(PATH_SPLIT);
		        }
		    }

		    /*
				small = ["todo"],
				big = ["todo", "length"]
				return true;

			*/

		    /**
		     * Identifies if first path includes second, compared from start,
		     * no floating start position inside ['join', 'me'], ['me']
		     * will result in false
		     * @param {array} big where we will search
		     * @param {array} small what we will search
		     * @return {boolean} if we succeed
		     */

		    static ifFullSubPath(big, small) {
		        if (big.length < small.length) {
		            return false;
		        }
		        for (let t = 0; t < small.length; t++) {
		            if (small[t] !== big[t]) {
		                return false;
		            }
		        }
		        return true;
		    }

		    /**
		     * Getter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be used as getter
		     * @param {string|array} attrPath path to property
		     * @param {object} item supporting data
		     * @param {helpers} object  supporting helpers
		     */

		    static getValueByPath(object, attrPath, item, helpers) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift(),
		            isFunction = attrName.indexOf(FUNCTION_MARKER) > -1;
		        if (isFunction) {
		            attrName = attrName.replace(FUNCTION_MARKER, "");
		        }
		        if (
		            (typeof object === "object" || typeof object === "function") &&
		            typeof object !== "undefined" &&
		            object !== null &&
		            typeof object[attrName] !== "undefined" &&
		            object[attrName] !== null
		        ) {
		            let newObj = isFunction
		                ? object[attrName]({
		                      item,
		                      helpers,
		                  })
		                : object[attrName];
		            if (attrPath.length > 0) {
		                return this.getValueByPath(newObj, attrPath, item, helpers);
		            } else {
		                return newObj;
		            }
		        } else {
		            return undefined;
		        }
		    }

		    /**
		     * Setter through third object
		     * Path is parsed, no event triggering for notRecord
		     * @param {object} object object to be modified
		     * @param {string|array} attrPath path to property
		     * @param {any} attrValue  value to assign
		     */

		    static setValueByPath(object, attrPath, attrValue) {
		        attrPath = this.normilizePath(attrPath);
		        let attrName = attrPath.shift();
		        if (attrPath.length > 0) {
		            if (!Object.prototype.hasOwnProperty.call(object, attrName)) {
		                object[attrName] = {};
		            }
		            this.setValueByPath(object[attrName], attrPath, attrValue);
		        } else {
		            object[attrName] = attrValue;
		        }
		    }

		    /**
		     * Joins passed in strings with PATH_SPLIT
		     * @param {string} arguments path to be glued
		     * @return {string} composite path
		     */

		    static join() {
		        let args = Array.prototype.slice.call(arguments);
		        return args.join(PATH_SPLIT);
		    }
		}

		src$1 = notPath;
		return src$1;
	}

	var notPath$1;
	var hasRequiredNotPath;

	function requireNotPath () {
		if (hasRequiredNotPath) return notPath$1;
		hasRequiredNotPath = 1;
		notPath$1 = requireSrc$1();
		return notPath$1;
	}

	var notPathExports = requireNotPath();
	var notPath = /*@__PURE__*/getDefaultExportFromCjs(notPathExports);

	var _notCommon;

	/*
	https://github.com/TehShrike/is-mergeable-object

	Included for convinience only. All rights belongs to their authors and etc.
	start of my code marked.

	*/

	let isMergeableObject = function isMergeableObject(value) {
	  return isNonNullObject(value) && !isSpecial(value);
	};
	function isNonNullObject(value) {
	  return !!value && typeof value === "object";
	}
	function isSpecial(value) {
	  var stringValue = Object.prototype.toString.call(value);
	  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
	function isReactElement(value) {
	  return value.$$typeof === REACT_ELEMENT_TYPE;
	}

	/*
	https://github.com/KyleAMathews/deepmerge

	The MIT License (MIT)

	Copyright (c) 2012 Nicholas Fisher

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/

	function emptyTarget(val) {
	  return Array.isArray(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	  const clone = !optionsArgument || optionsArgument.clone !== false;
	  return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
	}
	function defaultArrayMerge(target, source, optionsArgument) {
	  return target.concat(source).map(function (element) {
	    return cloneUnlessOtherwiseSpecified(element, optionsArgument);
	  });
	}
	function mergeObject(target, source, optionsArgument) {
	  const destination = {};
	  if (isMergeableObject(target)) {
	    Object.keys(target).forEach(function (key) {
	      destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);
	    });
	  }
	  Object.keys(source).forEach(function (key) {
	    if (!isMergeableObject(source[key]) || !target[key]) {
	      destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);
	    } else {
	      destination[key] = deepmerge(target[key], source[key], optionsArgument);
	    }
	  });
	  return destination;
	}
	function deepmerge(target, source, optionsArgument) {
	  const sourceIsArray = Array.isArray(source);
	  const targetIsArray = Array.isArray(target);
	  const options = optionsArgument || {
	    arrayMerge: defaultArrayMerge
	  };
	  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
	  if (!sourceAndTargetTypesMatch) {
	    return cloneUnlessOtherwiseSpecified(source, optionsArgument);
	  } else if (sourceIsArray) {
	    const arrayMerge = options.arrayMerge || defaultArrayMerge;
	    return arrayMerge(target, source, optionsArgument);
	  } else {
	    return mergeObject(target, source, optionsArgument);
	  }
	}
	deepmerge.all = function deepmergeAll(array, optionsArgument) {
	  if (!Array.isArray(array)) {
	    throw new Error("first argument should be an array");
	  }
	  return array.reduce(function (prev, next) {
	    return deepmerge(prev, next, optionsArgument);
	  }, {});
	};

	/**
	 *  Collection of common functions
	 *  @class
	 */
	let notCommon$1 = /*#__PURE__*/function () {
	  function notCommon() {
	    _classCallCheck(this, notCommon);
	  }
	  return _createClass(notCommon, null, [{
	    key: "isError",
	    value:
	    /**
	     *  @static {function} isError  function to perform object test, if it's an error object or not
	     * @param   {object}    e   object to test
	     */
	    function isError(e) {
	      return e instanceof Error ||
	      // @ts-ignore
	      Object.hasOwn(e, "status") && e.status === "error";
	    }
	  }, {
	    key: "mute",
	    value: function mute() {
	      notCommon.ENV_TYPE = "production";
	    }
	  }, {
	    key: "pad",
	    value: function pad(n) {
	      return n < 10 ? "0" + n : n;
	    }
	    /**
	     *  Returns today Date object without hours, minutes, seconds
	     *  @return {number}  current date with 00:00:00 in ms of unix time
	     */
	  }, {
	    key: "getTodayDate",
	    value: function getTodayDate() {
	      let t = new Date();
	      return new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime();
	    }

	    /**
	     *  Returns true if object has field of name
	     *   @param   {object}    obj    some object
	     *  @param  {string}    name  field name
	     *  @return {boolean}          if object contains field with name
	     **/
	  }, {
	    key: "objHas",
	    value: function objHas(obj, name) {
	      // @ts-ignore
	      return Object.hasOwn(obj, name);
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "copyObj",
	    value: function copyObj(obj) {
	      return JSON.parse(JSON.stringify(obj));
	    }

	    /**
	     * Copies object to secure it from changes
	     * @param {object}   obj     original object
	     * @return {object}          copy of object
	     **/
	  }, {
	    key: "partCopyObj",
	    value: function partCopyObj(obj, list) {
	      let partObj = Object.keys(obj).reduce(function (prev, curr) {
	        if (list.includes(curr)) {
	          prev[curr] = obj[curr];
	        }
	        return prev;
	      }, {});
	      return JSON.parse(JSON.stringify(partObj));
	    }
	  }, {
	    key: "compareTwoArrays",
	    value: function compareTwoArrays(a, b) {
	      return a.length === b.length && a.every(function (element, index) {
	        return element === b[index];
	      });
	    }

	    /**
	     * Test argument type to be 'function'
	     * @param {any}  func    possible function
	     * @return {boolean}     if this is a function
	     **/
	  }, {
	    key: "isFunc",
	    value: function isFunc(func) {
	      return typeof func === "function";
	    }

	    /**
	     * Returns true if argument is Async function
	     * @param {function} func  to test
	     * @return {boolean}       if this function is constructed as AsyncFunction
	     **/
	  }, {
	    key: "isAsync",
	    value: function isAsync(func) {
	      return func.constructor.name === "AsyncFunction";
	    }

	    /**
	     *  Executes method of object in appropriate way inside Promise
	     * @param {object}   obj     original object
	     * @param {string}   name    method name to execute
	     * @param {Array}     params  array of params
	     * @return {Promise}          results of method execution
	     **/
	  }, {
	    key: "executeObjectFunction",
	    value: async function executeObjectFunction(obj, name, params) {
	      if (obj) {
	        // @ts-ignore
	        const proc = notPath.get(":" + name, obj);
	        if (notCommon.isFunc(proc)) {
	          if (notCommon.isAsync(proc)) {
	            return await proc(...params);
	          } else {
	            return proc(...params);
	          }
	        }
	      }
	    }

	    /**
	     *  Executes method of object in apropriate way inside Promise
	     * @param {Object}   from     original object
	     * @param {Object}   to    method name to execute
	     * @param {Array}     list  array of params
	     * @return {undefined}          results of method execution
	     **/
	  }, {
	    key: "mapBind",
	    value: function mapBind(from, to, list) {
	      list.forEach(function (item) {
	        if (typeof from[item] === "function") {
	          to[item] = from[item].bind(from);
	        }
	      });
	    }
	  }, {
	    key: "isClass",
	    value: function isClass(fn) {
	      return /^\s*class/.test(fn.toString());
	    }
	  }, {
	    key: "detectType",
	    value: function detectType(testie) {
	      if (typeof testie !== "function") {
	        return typeof testie;
	      } else {
	        if (notCommon.isClass(testie)) {
	          return "class";
	        } else {
	          return "function";
	        }
	      }
	    }

	    //Проверка является ли переменная массивом
	  }, {
	    key: "isArray",
	    value: function isArray(data) {
	      return typeof data == "object" && data instanceof Array;
	    }
	  }, {
	    key: "localIsoDate",
	    value: function localIsoDate(date) {
	      date = date || new Date();
	      let localIsoString = date.getFullYear() + "-" + notCommon.pad(date.getMonth() + 1) + "-" + notCommon.pad(date.getDate()) + "T" + notCommon.pad(date.getHours()) + ":" + notCommon.pad(date.getMinutes()) + ":" + notCommon.pad(date.getSeconds());
	      return localIsoString;
	    }
	  }, {
	    key: "getToday",
	    value: function getToday() {
	      let today = new Date();
	      let date = today.getFullYear() + "-" + notCommon.pad(today.getMonth() + 1) + "-" + notCommon.pad(today.getDate());
	      return date;
	    }
	  }, {
	    key: "backlogAdd",
	    value: function backlogAdd(msg, type = "log") {
	      if (notCommon.get("backlog") === true) {
	        notCommon.backlog.push({
	          msg,
	          type
	        });
	      }
	    }
	  }, {
	    key: "dumpBacklog",
	    value: function dumpBacklog() {
	      while (notCommon.backlog.length) {
	        let row = notCommon.backlog.shift();
	        window[notCommon.LOG][row.type](...row.msg);
	      }
	    }
	  }, {
	    key: "logMsg",
	    value: function logMsg() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].log(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "log");
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      notCommon.logMsg(...arguments);
	    }
	  }, {
	    key: "createLogger",
	    value: function createLogger(prefix) {
	      return {
	        log: notCommon.genLogMsg(prefix),
	        error: notCommon.genLogError(prefix),
	        debug: notCommon.genLogDebug(prefix),
	        report: notCommon.report
	      };
	    }

	    //Генерация метода вывода сообщений в консоль с указанием префикса.
	  }, {
	    key: "genLogMsg",
	    value: function genLogMsg(prefix) {
	      return function () {
	        //not arrow bc of arguments special var is not available in arrow functions
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].log(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "log");
	      };
	    }

	    /**
	     * Определяет является ли окружение окружением разработки
	     * @returns  {boolean} true если это запущено в окружении разработки
	     **/
	  }, {
	    key: "isDev",
	    value: function isDev() {
	      return notCommon.ENV_TYPE === notCommon.DEV_ENV;
	    }
	  }, {
	    key: "debug",
	    value: function debug() {
	      if (notCommon.isDev()) {
	        return notCommon.logMsg(...arguments);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "genLogDebug",
	    value: function genLogDebug(prefix) {
	      if (notCommon.isDev()) {
	        return notCommon.genLogMsg(prefix);
	      } else {
	        return notCommon.NOOP;
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      notCommon.logError(...arguments);
	    }

	    //Функция вывода сообщения об ошибке
	  }, {
	    key: "logError",
	    value: function logError() {
	      let now = notCommon.localIsoDate();
	      window[notCommon.LOG].error(`[${now}]: `, ...arguments);
	      notCommon.backlogAdd([`[${now}]: `, ...arguments], "error");
	    }
	  }, {
	    key: "genLogError",
	    value: function genLogError(prefix) {
	      return function () {
	        //do not change to arrow function, bc of arguments
	        let now = notCommon.localIsoDate();
	        window[notCommon.LOG].error(`[${now}]: ${prefix}::`, ...arguments);
	        notCommon.backlogAdd([`[${now}]: ${prefix}::`, ...arguments], "error");
	      };
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon.getApp()) {
	        let reporter = notCommon.getApp().getService("nsErrorReporter");
	        if (reporter) {
	          reporter.report(e).catch(notCommon.error);
	        }
	      } else {
	        if (!notCommon.get("production")) {
	          notCommon.error(...arguments);
	        }
	      }
	    }
	  }, {
	    key: "trace",
	    value: function trace() {
	      if (!notCommon.get("production")) {
	        notCommon.trace(...arguments);
	      }
	    }
	  }, {
	    key: "trimBackslash",
	    value: function trimBackslash(str) {
	      if (str.indexOf("/") === 0) {
	        str = str.substring(1);
	      }
	      if (str[str.length - 1] === "/") {
	        str = str.substring(0, str.length - 1);
	      }
	      return str;
	    }

	    /**
	     *  Builds URL with structure like prefix/module/model/id/action
	     * If some part absent or set to false it will be excluded from result
	     *  @param {object} urlParts
	     *  @param {string} [urlParts.prefix='']
	     *  @param {string} [urlParts.module='']
	     *  @param {string} [urlParts.model='']
	     *  @param {string} [urlParts.id='']
	     *  @param {string} [urlParts.action='']
	     *  @return {string}  url path
	     */
	  }, {
	    key: "buildURL",
	    value: function buildURL({
	      prefix,
	      module,
	      model,
	      id,
	      action
	    } = {
	      prefix: "",
	      module: "",
	      model: "",
	      id: "",
	      action: ""
	    }) {
	      let url = ["/"];
	      if (prefix) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(prefix)));
	      }
	      if (module) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(module)));
	      }
	      if (model) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(model)));
	      }
	      if (id) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(id)));
	      }
	      if (action) {
	        url.push(encodeURIComponent(notCommon.trimBackslash(action)));
	      }
	      url = url.filter(function (el) {
	        return el !== "";
	      });
	      return url.join("/").replace(/\/\//g, "/");
	    }
	  }, {
	    key: "capitalizeFirstLetter",
	    value: function capitalizeFirstLetter(name) {
	      return name.charAt(0).toUpperCase() + name.slice(1);
	    }
	  }, {
	    key: "lowerFirstLetter",
	    value: function lowerFirstLetter(string) {
	      return string.charAt(0).toLowerCase() + string.slice(1);
	    }
	  }, {
	    key: "strLengthCap",
	    value: function strLengthCap(str, MAX_TITLE_LENGTH = 50, POST_FIX = "...") {
	      if (typeof str === "string" && str.length > MAX_TITLE_LENGTH) {
	        return str.substr(0, MAX_TITLE_LENGTH) + POST_FIX;
	      } else {
	        return str;
	      }
	    }
	  }, {
	    key: "escapeHtml",
	    value: function escapeHtml(unsafe) {
	      return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
	    }
	  }, {
	    key: "startApp",
	    value: function startApp(starter) {
	      document.addEventListener("DOMContentLoaded", starter);
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon.get("app");
	    }
	  }, {
	    key: "extendAppConfig",
	    value: function extendAppConfig(conf, conf2) {
	      return notCommon.deepMerge(conf, conf2);
	    }
	  }, {
	    key: "absorbModule",
	    value: function absorbModule() {
	      let defaultConf,
	        //app options
	        mod,
	        //module options
	        targets = {}; //various collections
	      if (arguments.length == 1) {
	        targets = {
	          ...arguments[0]
	        };
	        if (Object.hasOwnProperty.call(arguments[0], "defaultConf")) {
	          defaultConf = arguments[0].defaultConf;
	          delete targets.defaultConf;
	        }
	        if (Object.hasOwnProperty.call(arguments[0], "mod")) {
	          mod = arguments[0].mod;
	          delete targets.mod;
	        }
	      } else {
	        notCommon.log("WARNING: absorbModule format obsoleted, use object {defaultConf, mod, services, uis, wsc, etc}");
	        defaultConf = arguments[0];
	        mod = arguments[1];
	        if (arguments.length > 2) {
	          targets.services = arguments[2];
	        }
	        if (arguments.length > 3) {
	          targets.uis = arguments[3];
	        }
	        if (arguments.length > 4) {
	          targets.wcs = arguments[4];
	        }
	      }
	      for (let prop in mod) {
	        //add manifest to other
	        if (prop === "manifest") {
	          defaultConf = notCommon.extendAppConfig(defaultConf, mod.manifest);
	          continue;
	        }
	        if (typeof notCommon.get(`absorb.${prop}`) === "function") {
	          // @ts-ignore
	          if (!Object.hasOwn(targets, prop)) {
	            targets[prop] = {};
	            notCommon.log(`WARNING: no accamulator object provided for '${prop}' collection`);
	          }
	          notCommon.get(`absorb.${prop}`)(targets[prop], mod[prop]);
	        } else if (prop.indexOf("nc") === 0) {
	          // @ts-ignore
	          if (!Object.hasOwn(defaultConf, "controllers")) {
	            defaultConf.controllers = {};
	          }
	          defaultConf.controllers[prop] = mod[prop];
	        } else {
	          //in case of some other stuff presented, isolating it in special var
	          // @ts-ignore
	          if (!Object.hasOwn(window, "notEnv")) {
	            // @ts-ignore
	            window.notEnv = {};
	          }
	          // @ts-ignore
	          window.notEnv[prop] = mod[prop];
	        }
	      }
	      return defaultConf;
	    }
	  }, {
	    key: "defineIfNotExists",
	    value: function defineIfNotExists(obj, key, defaultValue) {
	      // @ts-ignore
	      if (!Object.hasOwn(obj, key)) {
	        obj[key] = defaultValue;
	      }
	    }
	  }, {
	    key: "register",
	    value: function register(key, val) {
	      notCommon.registry[key] = val;
	    }
	  }, {
	    key: "get",
	    value: function get(key) {
	      // @ts-ignore
	      return Object.hasOwn(notCommon.registry, key) ? notCommon.registry[key] : null;
	    }

	    /**
	     * Moves item inside array from old_index to new_index
	     * @static
	     * @param {Array<any>} array
	     * @param {number} old_index
	     * @param {number} new_index
	     * @memberof notCommon
	     */
	  }, {
	    key: "moveItem",
	    value: function moveItem(array, old_index, new_index) {
	      const inRange = function (num) {
	        return num < array.length && num > -1;
	      };
	      if (inRange(new_index) && inRange(old_index)) {
	        array.splice(new_index, 0, array.splice(old_index, 1)[0]);
	      }
	    }
	  }, {
	    key: "stripProxy",
	    value: function stripProxy(obj) {
	      if (typeof obj !== "undefined" && obj !== null) {
	        if (obj.isProxy) {
	          if (Array.isArray(obj)) {
	            obj = Array.from(obj);
	          } else {
	            obj = Object.assign({}, obj);
	          }
	          for (let t in obj) {
	            // @ts-ignore
	            if (Object.hasOwn(obj, t)) {
	              obj[t] = notCommon.stripProxy(obj[t]);
	            }
	          }
	        }
	      }
	      return obj;
	    }
	  }, {
	    key: "pipe",
	    value: function pipe(data /* feed data */, funcs /* functions array */) {
	      let result;
	      for (let func of funcs) {
	        result = func(result || data);
	      }
	      return result;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {string} type
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getAPI",
	    value: function getAPI(type) {
	      return notCommon.getManager()?.getAPI(type) ?? null;
	    }
	  }, {
	    key: "setManager",
	    value: function setManager(v) {
	      notCommon.MANAGER = v;
	    }

	    /**
	     *
	     *
	     * @static
	     * @return {object}
	     * @memberof notCommon
	     */
	  }, {
	    key: "getManager",
	    value: function getManager() {
	      return notCommon.MANAGER;
	    }
	  }, {
	    key: "getJSON",
	    value: function getJSON(url) {
	      return fetch(url).then(function (response) {
	        return response.json();
	      });
	    }
	  }, {
	    key: "wait",
	    value: function wait(sec) {
	      return new Promise(function (res) {
	        setTimeout(res, sec * 1000);
	      });
	    }
	  }, {
	    key: "registerWidgetEvents",
	    value: function registerWidgetEvents(events) {
	      if (notCommon.getApp()) {
	        Object.keys(events).forEach(function (eventName) {
	          notCommon.getApp().on(eventName, events[eventName]);
	        });
	      }
	    }
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      notCommon.getApp() && notCommon.getApp().getWorking("router").navigate(url);
	    }
	  }, {
	    key: "select",
	    value: function select(variantsSet, value, def) {
	      if (variantsSet && typeof variantsSet == "object" && notCommon.objHas(variantsSet, value) && typeof variantsSet[value] !== "undefined" && variantsSet[value] !== null) {
	        return variantsSet[value];
	      } else {
	        return def;
	      }
	    }
	  }]);
	}();
	_notCommon = notCommon$1;
	/**
	 *  @static {Object} [MANAGER=null]  application manager, in some cases used to control initialization routine
	 */
	_defineProperty(notCommon$1, "MANAGER", null);
	/**
	 *  @static {string} [LOG="console"]  logger, window[LOG]
	 */
	_defineProperty(notCommon$1, "LOG", "console");
	/**
	 *  @static {function} deepMerge  function to perform deep merges of objects
	 */
	_defineProperty(notCommon$1, "deepMerge", deepmerge);
	_defineProperty(notCommon$1, "TZ_OFFSET", new Date().getTimezoneOffset() / 60 * -1);
	_defineProperty(notCommon$1, "DEV_ENV", "production");
	// @ts-ignore
	_defineProperty(notCommon$1, "ENV_TYPE", window.NOT_ENV_TYPE ?? _notCommon.DEV_ENV);
	_defineProperty(notCommon$1, "NOOP", function () {});
	_defineProperty(notCommon$1, "backlog", []);
	_defineProperty(notCommon$1, "registry", {});
	function absorbServices(target, src) {
	  if (target) {
	    for (let serv in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, serv)) {
	        notCommon$1.logError(`services property duplication ${serv}`);
	      }
	      target[serv] = src[serv];
	    }
	  }
	}
	function extendWSClient(wcs, wscName, wscOptions) {
	  // @ts-ignore
	  if (!Object.hasOwn(wcs, wscName)) {
	    wcs[wscName] = {
	      connection: {},
	      router: {
	        routes: {}
	      },
	      messenger: {}
	    };
	  }
	  let target = wcs[wscName];
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "router")) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions.router, "routes")) {
	      for (let routeType in wscOptions.router.routes) {
	        // @ts-ignore
	        if (!Object.hasOwn(target.router.routes, routeType)) {
	          target.router.routes[routeType] = {};
	        }
	        Object.assign(target.router.routes[routeType], {
	          ...wscOptions.router.routes[routeType]
	        });
	      }
	    }
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "messenger")) {
	    Object.assign(target.messenger, {
	      ...wscOptions.messenger
	    });
	  }
	  // @ts-ignore
	  if (Object.hasOwn(wscOptions, "connection")) {
	    Object.assign(target.connection, {
	      ...wscOptions.connection
	    });
	  }
	  for (let t of ["name", "getToken", "logger", "identity", "credentials"]) {
	    // @ts-ignore
	    if (Object.hasOwn(wscOptions, t)) {
	      target[t] = wscOptions[t];
	    }
	  }
	}
	function absorbWSC(target, src) {
	  if (target) {
	    for (let wsClientName in src) {
	      extendWSClient(target, wsClientName, src[wsClientName]);
	    }
	  }
	}
	function absorbUIs(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`uis property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	function absorbFields(target, src) {
	  if (target) {
	    for (let ui in src) {
	      // @ts-ignore
	      if (Object.hasOwn(target, ui)) {
	        notCommon$1.logError(`fields property duplication ${ui}`);
	      }
	      target[ui] = src[ui];
	    }
	  }
	}
	notCommon$1.register("absorb.wsc", absorbWSC);
	notCommon$1.register("absorb.services", absorbServices);
	notCommon$1.register("absorb.uis", absorbUIs);
	notCommon$1.register("absorb.uis", absorbFields);

	/**
	 * strings localization and formating model
	 * @class
	 */
	let notLocale = /*#__PURE__*/function (_EventEmitter) {
	  function notLocale() {
	    var _this;
	    _classCallCheck(this, notLocale);
	    _this = _callSuper(this, notLocale);
	    _this.dict = {}; //dictionary of phrases
	    _this.helpers = {}; //additional helper functions and constants
	    let dict = _this.restoreFromStorage();
	    if (dict) {
	      _this.set(dict);
	    }
	    return _this;
	  }

	  /**
	   * String format should comply notPath standart.
	   * {path_to_access} - is
	   * : - is used to access to params
	   * :: - is used to access to helpers
	   * Welcome, {:where}! - will replace {:where} with content of params.where
	   * Welcome, {::where}! - will replace {:where} with content of this.helpers.where
	   * () - after path is to invoke function of target object
	   * Welcome, {::where()}! - will try to exec this.helpers.where(params, undefined)
	   * @param    {string}  str         localized string template with mark to include data
	   * @param    {object}  params      params to use in string
	   * @returns  {string}              localized version of string with
	   */
	  _inherits(notLocale, _EventEmitter);
	  return _createClass(notLocale, [{
	    key: "format",
	    value: function format(str, params) {
	      return notPath.parseSubs(str, params, this.helpers);
	    }

	    /**
	     * Return localized version of string with injected data from provided object
	     * may also use Locale.helpers as source of data
	     * @param {string}   phrase    name of string to localize
	     * @param {object}   params    object with data to inject in phrase template
	     * @return {string}            localized string with injected data
	     */
	  }, {
	    key: "say",
	    value: function say(phrase, params = false) {
	      try {
	        if (notCommon$1.objHas(this.dict, phrase)) {
	          let tmpl = this.dict[phrase],
	            result = "";
	          if (params) {
	            result = this.format(tmpl, params);
	          } else {
	            result = tmpl;
	          }
	          return result;
	        } else {
	          throw new Error(`Unknown locale phrase: ${phrase}`);
	        }
	      } catch (e) {
	        notCommon$1.debug(e);
	        return phrase;
	      }
	    }

	    /**
	     * Setting new dictionary. triggers event 'change'
	     * @param {object}     dict      vocabulary of phrases and templates
	     **/
	  }, {
	    key: "set",
	    value: function set(dict) {
	      LOCALE.set(dict);
	      this.saveToStorage(dict);
	      this.dict = Object.assign({}, {
	        ...dict
	      });
	      this.emit("change");
	    }
	  }, {
	    key: "saveToStorage",
	    value: function saveToStorage(dict) {
	      if (window.localStorage) {
	        try {
	          return window.localStorage.setItem("dictionary", JSON.stringify(dict));
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "restoreFromStorage",
	    value: function restoreFromStorage() {
	      if (window.localStorage) {
	        try {
	          let str = window.localStorage.getItem("dictionary");
	          if (str) {
	            let dict = JSON.parse(str);
	            return dict;
	          } else {
	            return false;
	          }
	        } catch (e) {
	          notCommon$1.debug(e);
	          return false;
	        }
	      }
	      return false;
	    }

	    /**
	     * Returns writable store of phrases
	     * @return {object}  writable store
	     */
	  }, {
	    key: "vocabulary",
	    value: function vocabulary() {
	      return LOCALE;
	    }
	  }]);
	}(EventEmitter);
	var notLocale$1 = new notLocale();

	const say = notLocale$1.say.bind(notLocale$1);

	var root_1$u = template(`<span> </span>`);

	function Ui_tag($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "tagId"]                                  if we want to address this tag, as tag-{id}:{eventName}, ex. tag-tagId:update
		 * @property {string}   [title = "tag"]                                 tag title
		 * @property {string}   [color = "info"]                                bulma color
		 * @property {string}   [size = "normal"]                               bulma size
		 * @property {string}   [padding = "normal"]                            size of left/right paddings (small = 0.5em, normal = 1em, big = 1.5em, large = 2em), class names is is-padded-{padding}
		 * @property {boolean}  [bold = false]                                  title styling
		 * @property {boolean}  [right = false]                                 tag positioning on the right, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [left = false]                                  tag positioning on the left, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [top = false]                                   tag positioning on the top, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {boolean}  [bottom = false]                                tag positioning on the bottom, to see at work look examples of Elements.Icons.UIIconButtonWithTag
		 * @property {string}   [class  = ""]                                   additional css classes list
		 * @property {object}   [events = {}]                                   list of events {name:callback}
		 * @property {function} [register = notCommon.registerWidgetEvents]     register event handlers
		 * @property {function} [onUpdate = (data) => title = data.title;]
		 * @property {function} [action]                                        onclick/onkeydown callback
		 * @property {object}   [vars = {}]                                     css vars list
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "tagId"),
			title = prop($$props, 'title', 7, "tag"),
			color = prop($$props, 'color', 3, "info"),
			size = prop($$props, 'size', 3, "normal"),
			padding = prop($$props, 'padding', 3, "normal"),
			bold = prop($$props, 'bold', 3, false),
			right = prop($$props, 'right', 3, false),
			left = prop($$props, 'left', 3, false),
			top = prop($$props, 'top', 3, false),
			bottom = prop($$props, 'bottom', 3, false),
			classes = prop($$props, 'class', 3, ""),
			events = prop($$props, 'events', 23, () => ({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "title")) {
					title(data.title);
				}
			}),
			vars = prop($$props, 'vars', 19, () => ({})),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		let sided = derived(() => right() || left() || top() || bottom());
		let hCentered = derived(() => !right() && !left() && get$3(sided));
		let vCentered = derived(() => !bottom() && !top() && get$3(sided));

		function getStandartUpdateEventName() {
			return `tag-${id()}:update`;
		}

		let style = state("");

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events()[getStandartUpdateEventName()] = onUpdate();
			}

			register()(events());
		});

		user_effect(() => {
			set(style, proxy(Object.keys(snapshot(vars())).map((varName) => {
				return `${varName}: ${vars()[varName]};`;
			}).join("")));
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$u();

				span.__keydown = function (...$$args) {
					($$props.action ? $$props.action : undefined)?.apply(this, $$args);
				};

				span.__click = function (...$$args) {
					($$props.action ? $$props.action : undefined)?.apply(this, $$args);
				};

				var text = child(span, true);

				reset(span);

				template_effect(() => {
					set_attribute(span, 'role', role());
					set_attribute(span, 'tabindex', tabIndex());
					set_attribute(span, 'id', `tag-${id() ?? ''}`);

					set_class(span, `
  tag
  ${(padding() !== 'normal' ? `is-padded-${padding()}` : '') ?? ''}
  is-${size() ?? ''}
  is-${color() ?? ''}  
  ${classes() ?? ''}`);

					set_attribute(span, 'style', get$3(style));
					toggle_class(span, 'is-clickable', $$props.action);
					toggle_class(span, 'has-text-weight-bold', bold());
					toggle_class(span, 'is-vertical-centered', get$3(vCentered));
					toggle_class(span, 'is-horizontal-centered', get$3(hCentered));
					toggle_class(span, 'is-sided', get$3(sided));
					toggle_class(span, 'is-sided-right', right());
					toggle_class(span, 'is-sided-left', left());
					toggle_class(span, 'is-sided-top', top());
					toggle_class(span, 'is-sided-bottom', bottom());
					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['keydown', 'click']);

	function Ui_boolean($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_TRUE = "not-node:booleans_true"]
		 * @property {string} [LC_FALSE = "not-node:booleans_false"]
		 * @property {any} value
		 * @property {boolean} [inverted = false]
		 */
		/** @type {Props} */
		let LC_TRUE = prop($$props, 'LC_TRUE', 3, "not-node:booleans_true"),
			LC_FALSE = prop($$props, 'LC_FALSE', 3, "not-node:booleans_false"),
			inverted = prop($$props, 'inverted', 3, false);

		const FALSE_VALUE = {
			title: LC_FALSE(),
			color: inverted() ? "success" : "danger"
		};

		const TRUE_VALUE = {
			title: LC_TRUE(),
			color: inverted() ? "danger" : "success"
		};

		//if inverted === true, inverts value
		let tagValue = derived(() => $$props.value ? TRUE_VALUE : FALSE_VALUE);

		Ui_tag($$anchor, spread_props(() => get$3(tagValue)));
	}

	var root$M = template(`<span class="label"> <!></span>`);

	function Ui_boolean_labeled($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		/**
		 * @typedef {Object} Props
		 * @property {boolean} value
		 * @property {boolean} [inverted = false]
		 * @property {string} label
		 */
		/** @type {Props} */
		let inverted = prop($$props, 'inverted', 3, false);
		var span = root$M();
		var text = child(span);
		var node = sibling(text);

		Ui_boolean(node, {
			get value() {
				return $$props.value;
			},
			get inverted() {
				return inverted();
			}
		});

		reset(span);
		template_effect(() => set_text(text, `${$LOCALE()[$$props.label] ?? ''}: `));
		append($$anchor, span);
		pop();
		$$cleanup();
	}

	function Ui_booleans($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {array}    values
		 * @property {boolean}  [inverted = false]
		 * @property {function}      [componentConstructor = UIBoolean]
		 * @property {function} [itemRenderer]                          if supplied will be used instead of componentConstructor
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			inverted = prop($$props, 'inverted', 3, false),
			ItemConstructor = prop($$props, 'componentConstructor', 3, Ui_boolean);

		let _values = state(proxy([]));

		onMount(() => {
			if (typeof values() === "boolean") {
				set(_values, proxy([{ value: values() }]));
			} else if (Array.isArray(values())) {
				if (values().every((itm) => typeof itm === "boolean")) {
					set(_values, proxy(values().map((itm) => {
						return { value: itm };
					})));
				} else {
					set(_values, proxy([...values()]));
				}
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, () => get$3(_values), index$d, ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent = ($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							snippet(node_3, () => $$props.itemRenderer, () => get$3(item), () => index);
							append($$anchor, fragment_3);
						};

						var alternate = ($$anchor) => {
							var fragment_4 = comment();
							var node_4 = first_child(fragment_4);
							const expression = derived(() => inverted() || get$3(item).inverted);

							component(node_4, ItemConstructor, ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$3(item), {
									get inverted() {
										return get$3(expression);
									}
								}));
							});

							append($$anchor, fragment_4);
						};

						if_block(node_2, ($$render) => {
							if ($$props.itemRenderer) $$render(consequent); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$3(_values).length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function toggleView(_, hidden) {
		hidden(!hidden());
	}

	async function copyContent(
		__1,
		value,
		tooltip,
		contentCopied,
		tooltipTarget,
		tooltipText,
		tooltipTTL,
		$$props
	) {
		try {
			await navigator.clipboard.writeText(value());

			if (tooltip()) {
				set(contentCopied, true);
				get$3(tooltipTarget).dataset.tooltip = tooltipText();

				setTimeout(
					() => {
						set(contentCopied, false);
						get$3(tooltipTarget).removeAttribute("data-tooltip");
					},
					tooltipTTL()
				);
			}
		} catch(err) {
			$$props.onerror && $$props.onerror(err);
		}
	}

	var root_1$t = template(`<span role="button" tabindex="0"><i></i></span>`);
	var root_2$l = template(`<span class="icon is-small is-right is-clickable is-vertical-middle" role="button" tabindex="0"><i></i></span>`);
	var root$L = template(`<span> </span> <!> <!>`, 1);

	function Ui_censored($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [hidden = true]
		 * @property {boolean}  [showable = true]
		 * @property {boolean}  [copiable = true]
		 * @property {string}   [copyIcon = 'copy']
		 * @property {string}   [showIcon = 'eye']
		 * @property {string}   [hideIcon = 'eye-slash']
		 * @property {number}   [maxLength = 20]
		 * @property {string}   [shadowClass = "has-background-primary-90"]
		 * @property {boolean}  [tooltip = true]
		 * @property {number}   [tooltipTTL = 2000]
		 * @property {string}   [tooltipText = "Скопировано в буфер"]
		 * @property {string}   [tooltipClass = "has-tooltip-info"]
		 * @property {string}   [value = ""]
		 * @property {function} [onerror]
		 */
		/** @type {Props} */
		let hidden = prop($$props, 'hidden', 15, true),
			showable = prop($$props, 'showable', 3, true),
			copiable = prop($$props, 'copiable', 3, true),
			copyIcon = prop($$props, 'copyIcon', 3, "copy"),
			showIcon = prop($$props, 'showIcon', 3, "eye"),
			hideIcon = prop($$props, 'hideIcon', 3, "eye-slash"),
			maxLength = prop($$props, 'maxLength', 3, 20),
			shadowClass = prop($$props, 'shadowClass', 3, "has-background-primary-90"),
			tooltip = prop($$props, 'tooltip', 3, true),
			tooltipTTL = prop($$props, 'tooltipTTL', 3, 2000),
			tooltipText = prop($$props, 'tooltipText', 3, "Скопировано в буфер"),
			tooltipClass = prop($$props, 'tooltipClass', 3, "has-tooltip-info"),
			value = prop($$props, 'value', 3, "");

		let contentCopied = state(false),
			tooltipActive = derived(() => tooltip() && get$3(contentCopied)),
			tooltipTarget = state(undefined);

		var fragment = root$L();
		var span = first_child(fragment);
		var text = child(span, true);

		reset(span);

		var node = sibling(span, 2);

		{
			var consequent = ($$anchor) => {
				var span_1 = root_1$t();

				span_1.__click = [
					copyContent,
					value,
					tooltip,
					contentCopied,
					tooltipTarget,
					tooltipText,
					tooltipTTL,
					$$props
				];

				span_1.__keydown = [
					copyContent,
					value,
					tooltip,
					contentCopied,
					tooltipTarget,
					tooltipText,
					tooltipTTL,
					$$props
				];

				var i = child(span_1);

				reset(span_1);
				bind_this(span_1, ($$value) => set(tooltipTarget, $$value), () => get$3(tooltipTarget));

				template_effect(() => {
					set_class(span_1, "icon is-small is-right is-clickable " + (get$3(tooltipActive) ? ` ${tooltipClass()} ` : "") + " is-vertical-middle");
					set_class(i, `fas fa-${copyIcon() ?? ''}`);
				});

				append($$anchor, span_1);
			};

			if_block(node, ($$render) => {
				if (copiable()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var span_2 = root_2$l();

				span_2.__click = [toggleView, hidden];
				span_2.__keydown = [toggleView, hidden];

				var i_1 = child(span_2);

				reset(span_2);
				template_effect(() => set_class(i_1, `fas fa-${(hidden() ? showIcon() : hideIcon()) ?? ''}`));
				append($$anchor, span_2);
			};

			if_block(node_1, ($$render) => {
				if (showable()) $$render(consequent_1);
			});
		}

		template_effect(() => {
			set_class(span, (hidden() ? "is-censored " + shadowClass() : "") + " is-vertical-middle ");
			set_attribute(span, 'style', `display:inline-block; width: ${maxLength()}rem; height: var(--bulma-size-medium); overflow-x:hidden;`);
			set_text(text, hidden() ? "" : value());
		});

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keydown']);

	var root$K = template(`<span> </span>`);

	function Ui_indicator($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "tagId"] - if we want to address this indicator
		 * @property {string}   [state = "light"]
		 * @property {string}   [size = "normal"]
		 * @property {any}      [labels = {black, dark, light, white, primary, link, info, success, warning, danger}]
		 * @property {string}   [class = "max-1"]
		 * @property {string}   [padding = "normal"]
		 * @property {boolean}  [bold = false]
		 * @property {boolean}  [right = false]
		 * @property {boolean}  [left = left]
		 * @property {boolean}  [top = false]
		 * @property {boolean}  [bottom = false]
		 * @property {any}      [events = {}]
		 * @property {any}      [register = notCommon.registerWidgetEvents] - register event handlers
		 * @property {any}      [onUpdate = (data) => currentState = data.state]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "tagId"),
			currentState = prop($$props, 'state', 15, "light"),
			size = prop($$props, 'size', 3, "normal"),
			labels = prop($$props, 'labels', 19, () => ({
				black: "black",
				dark: "dark",
				light: "light",
				white: "white",
				primary: "primary",
				link: "link",
				info: "info",
				success: "success",
				warning: "warning",
				danger: "danger"
			})),
			classes = prop($$props, 'class', 3, "mx-1"),
			padding = prop($$props, 'padding', 3, "normal"),
			bold = prop($$props, 'bold', 3, false),
			right = prop($$props, 'right', 3, false),
			left = prop($$props, 'left', 3, false),
			top = prop($$props, 'top', 3, false),
			bottom = prop($$props, 'bottom', 3, false),
			events = prop($$props, 'events', 31, () => proxy({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "state")) {
					currentState(data.state);
				}
			});

		function getStandartUpdateEventName() {
			return `indicator-${id()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		let sided = derived(() => right() || left() || top() || bottom());
		var span = root$K();
		var text = child(span, true);

		reset(span);

		template_effect(() => {
			set_class(span, `tag is-${size() ?? ''} ${(padding() !== 'normal' ? `is-padded-${padding()}` : '') ?? ''} is-${currentState() ?? ''} ${classes() ?? ''}`);
			toggle_class(span, 'has-text-weight-bold', bold());
			toggle_class(span, 'is-sided', get$3(sided));
			toggle_class(span, 'is-sided-right', right());
			toggle_class(span, 'is-sided-left', left());
			toggle_class(span, 'is-sided-top', top());
			toggle_class(span, 'is-sided-bottom', bottom());
			set_text(text, labels()[currentState()]);
		});

		append($$anchor, span);
		pop();
	}

	var root_3$i = template(`<span class="title"> </span>`);
	var root_1$s = template(`<div><!></div>`);

	function Ui_loader($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		//hidden - no loader
		//container - parent container of form
		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [loading = false]       state if form loading
		 * @property {string}   [size = 'container']    (page, container, hidden)
		 * @property {string}   [title = 'Waiting...']  LC string
		 * @property {number}   [ttl]                   time to live, will be closed after ttl ms
		 * @property {snippet}  [children]              snippets may be provided
		 */
		/** @type {Props} */
		let loading = prop($$props, 'loading', 7, false),
			size = prop($$props, 'size', 3, "container"),
			title = prop($$props, 'title', 3, "Waiting...");

		let ttlTimer;

		onMount(() => {
			if ($$props.ttl) {
				ttlTimer = setTimeout(
					() => {
						loading(false);
						$$props.onreject();
					},
					$$props.ttl
				);
			}
		});

		onDestroy(() => {
			if (ttlTimer) {
				clearTimeout(ttlTimer);
			}
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$s();
				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						snippet(node_2, () => $$props.children ?? noop);
						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var span = root_3$i();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span);
					};

					if_block(node_1, ($$render) => {
						if ($$props.children) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(div);

				template_effect(() => {
					set_class(div, clsx(size() === "page" ? "pageloader" : "containerloader"));
					toggle_class(div, 'is-active', loading());
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (size() !== "hidden") $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$J = template(`<option> </option>`);

	function Ui_select_option($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		var option = root$J();
		var option_value = {};
		var text = child(option, true);

		reset(option);

		template_effect(() => {
			if (option_value !== (option_value = $$props.value)) {
				option.value = null == (option.__value = $$props.value) ? '' : $$props.value;
			}

			set_selected(option, $$props.selected);
			set_text(text, $LOCALE()[$$props.title]);
		});

		append($$anchor, option);
		pop();
		$$cleanup();
	}

	var root_3$h = template(`<span class="mr-2"> </span>`);
	var root_4$g = template(`<span class="mr-2"> </span>`);
	var root_5$a = template(`<div><select><!><!></select></div>`);

	function Ui_select($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [value]
		 * @property {any}      [variants]
		 * @property {string} [placeholder]
		 * @property {string} [emptyValueTitle]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {number} [size]
		 * @property {boolean} [valid]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, ""),
			variants = prop($$props, 'variants', 19, () => []),
			placeholder = prop($$props, 'placeholder', 3, ""),
			emptyValueTitle = prop($$props, 'emptyValueTitle', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "select"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'placeholder',
				'emptyValueTitle',
				'fieldname',
				'required',
				'readonly',
				'size',
				'color',
				'valid',
				'class',
				'onchange'
			]);

		let selectedVariants = state(proxy([]));

		function filterSelectedVariants(variant) {
			if (value()) {
				return value() == variant.id;
			} else {
				return false;
			}
		}

		function checkOnClearMacro(newValue) {
			if (newValue === UICommon$1.CLEAR_MACRO) {
				value("");
			} else {
				value(newValue);
			}
		}

		function alreadyProcessed(newValue) {
			if (Array.isArray(newValue) && Array.isArray(value())) {
				if (notCommon$1.compareTwoArrays(value(), newValue)) {
					return true;
				}
			} else {
				if (newValue === value()) {
					return true;
				}
			}

			return false;
		}

		function onInput(ev) {
			const data = {
				field: fieldname(),
				value: ev.currentTarget.value
			};

			if (alreadyProcessed(data.value)) {
				return;
			}

			checkOnClearMacro(data.value);
			onchange()(data);
		}

		user_effect(() => {
			set(selectedVariants, proxy(Array.isArray(variants()) ? variants().filter(filterSelectedVariants) : []));
		});

		let invalid = derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$3(selectedVariants), index$d, ($$anchor, selectedVariant) => {
							var span = root_3$h();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$3(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var span_1 = root_4$g();
						var text_1 = child(span_1, true);

						reset(span_1);
						template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
						append($$anchor, span_1);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var div = root_5$a();
				var select = child(div);
				let attributes;

				init_select(select, () => attributes.value);

				var node_3 = child(select);

				{
					var consequent_2 = ($$anchor) => {
						const expression = derived(() => !value());

						Ui_select_option($$anchor, {
							get value() {
								return UICommon$1.CLEAR_MACRO;
							},
							get selected() {
								return get$3(expression);
							},
							get title() {
								return placeholder();
							}
						});
					};

					if_block(node_3, ($$render) => {
						if (placeholder().length > 0) $$render(consequent_2);
					});
				}

				var node_4 = sibling(node_3);

				each(node_4, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					const expression_1 = derived(() => value() == get$3(variant).id);

					Ui_select_option($$anchor, {
						get value() {
							return get$3(variant).id;
						},
						get selected() {
							return get$3(expression_1);
						},
						get title() {
							return get$3(variant).title;
						}
					});
				});

				reset(select);
				reset(div);

				template_effect(() => {
					set_class(div, `select ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`);

					attributes = set_attributes(select, attributes, {
						id: `form-field-select-${fieldname() ?? ''}`,
						name: fieldname(),
						oninput: onInput,
						onblur: onInput,
						readonly: readonly(),
						required: required(),
						invalid: get$3(invalid),
						size: $$props.size,
						...others
					});

					if ('value' in attributes) {
						select_option(select, attributes.value);
					}
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function onClick$7(event, onclick, $$props, action) {
		event.stopPropagation();
		onclick() && onclick()({ event, value: $$props.value });
		return action() && action()(event, $$props.value);
	}

	var root_4$f = template(`<span class="icon"><i></i></span>`);
	var root_5$9 = template(`<span> </span>`);
	var root_6$b = template(`<span class="icon"><i></i></span>`);
	var root_3$g = template(`<!> <!> <!>`, 1);
	var root$I = template(`<button><!></button>`);

	function Ui_button($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [action]
		 * @property {function} [onclick]
		 * @property {any} value
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			state = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			style = prop($$props, 'style', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			icon = prop($$props, 'icon', 3, false),
			iconSide = prop($$props, 'iconSide', 3, "right"),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			}),
			action = prop($$props, 'action', 3, () => {
				return true;
			});

		var button = root$I();

		button.__click = [onClick$7, onclick, $$props, action];

		var node = child(button);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_4 = ($$anchor) => {
						var fragment_2 = root_3$g();
						var node_3 = first_child(fragment_2);

						{
							var consequent_1 = ($$anchor) => {
								var span = root_4$f();
								var i = child(span);

								reset(span);
								template_effect(() => set_class(i, `fas fa-${icon() ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`));
								append($$anchor, span);
							};

							if_block(node_3, ($$render) => {
								if (iconSide() === "left") $$render(consequent_1);
							});
						}

						var node_4 = sibling(node_3, 2);

						{
							var consequent_2 = ($$anchor) => {
								var span_1 = root_5$9();
								var text = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text, $LOCALE()[title()]));
								append($$anchor, span_1);
							};

							if_block(node_4, ($$render) => {
								if (title()) $$render(consequent_2);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_3 = ($$anchor) => {
								var span_2 = root_6$b();
								var i_1 = child(span_2);

								reset(span_2);
								template_effect(() => set_class(i_1, `fas fa-${icon() ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`));
								append($$anchor, span_2);
							};

							if_block(node_5, ($$render) => {
								if (iconSide() === "right") $$render(consequent_3);
							});
						}

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[title()]));
						append($$anchor, text_1);
					};

					if_block(
						node_2,
						($$render) => {
							if (icon()) $$render(consequent_4); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		reset(button);

		template_effect(() => {
			button.disabled = disabled();
			set_attribute(button, 'type', type() ? type() : "");
			set_attribute(button, 'style', style());

			set_class(button, `
  button
  ${classes() ?? ''}
  ${(state() ? `is-${state()}` : '') ?? ''}
  ${(inverted() ? `is-inverted` : '') ?? ''}
  ${(outlined() ? `is-outlined` : '') ?? ''}
  ${(raised() ? `is-raised` : '') ?? ''}
  ${(rounded() ? `is-rounded` : '') ?? ''}
  ${(light() ? `is-light` : '') ?? ''}
  ${(loading() ? `is-loading` : '') ?? ''}
  ${(color() ? `is-${color()}` : '') ?? ''}
  ${(size() ? `is-${size()}` : '') ?? ''}
  `);
		});

		append($$anchor, button);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	function onClick$6(event, onclick, $$props) {
		event.stopPropagation();
		onclick() && onclick()({ event, value: $$props.value });
	}

	var root$H = template(`<button></button>`);

	function Ui_button_close($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [ariaLabel = "delete button"]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [style]
		 * @property {string} [class]
		 * @property {function} [onclick]
		 * @property {any} value
		 */
		/** @type {Props} */
		let ariaLabel = prop($$props, 'ariaLabel', 3, "delete button");
			prop($$props, 'light', 3, false);
			prop($$props, 'loading', 3, false);
			prop($$props, 'raised', 3, false);
			prop($$props, 'outlined', 3, false);
			prop($$props, 'inverted', 3, false);
			prop($$props, 'rounded', 3, false);
			let disabled = prop($$props, 'disabled', 3, false);
			prop($$props, 'state', 3, "");
			prop($$props, 'color', 3, "");
			let size = prop($$props, 'size', 3, ""),
			style = prop($$props, 'style', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			});

		var button = root$H();

		button.__click = [onClick$6, onclick, $$props];

		template_effect(() => {
			set_attribute(button, 'aria-label', ariaLabel());
			button.disabled = disabled();
			set_attribute(button, 'style', style());

			set_class(button, `
  delete
  ${classes() ?? ''}  
  ${(size() ? `is-${size()}` : '') ?? ''}
  `);
		});

		append($$anchor, button);
		pop();
	}

	delegate(['click']);

	var root$G = template(`<div></div>`);

	function Ui_buttons($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {Array<object>} [values = []]
		 * @property {boolean} [centered = false]
		 * @property {boolean} [right = false]
		 * @property {string} [class = '']
		 * @property {import('svelte').Component} [buttonComponent = UIButton]
		 * @property {import('../events.types').UIEventInputChangeCallback} [action = ()=>true]
		 * @property {import('../events.types').UIEventCallback} [onclick = ()=>true]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			classes = prop($$props, 'class', 3, ""),
			SvelteComponent = prop($$props, 'buttonComponent', 3, Ui_button),
			action = prop($$props, 'action', 3, () => {
				return true;
			}),
			onclick = prop($$props, 'onclick', 3, () => {
				return true;
			});

		let _values = state(proxy([]));

		user_effect(() => {
			set(_values, proxy(values().map((itm) => {
				if (isNaN(itm.id)) {
					itm.id = Math.round(Math.random() * 100);
				}

				return itm;
			})));
		});

		var div = root$G();

		each(div, 21, () => get$3(_values), (item) => item.id, ($$anchor, item, $$index) => {
			var fragment = comment();
			var node = first_child(fragment);

			component(node, SvelteComponent, ($$anchor, $$component) => {
				$$component($$anchor, spread_props(
					{
						get action() {
							return action();
						},
						get onclick() {
							return onclick();
						}
					},
					() => get$3(item),
					{
						get value() {
							return get$3(item).value;
						},
						set value($$value) {
							(get$3(item).value = $$value);
						}
					}
				));
			});

			append($$anchor, fragment);
		});

		reset(div);

		template_effect(() => {
			set_class(div, `buttons has-addons ${classes() ?? ''}`);
			toggle_class(div, 'is-right', right());
			toggle_class(div, 'is-centered', centered());
		});

		append($$anchor, div);
		pop();
	}

	var root$F = template(`<div><div class="column"><!></div> <div class="column"><!></div> <div class="column"><!></div></div>`);

	function Ui_buttons_row($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {any} [left]
		 * @property {any} [center]
		 * @property {any} [right]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			left = prop($$props, 'left', 19, () => []),
			center = prop($$props, 'center', 19, () => []),
			right = prop($$props, 'right', 19, () => []);

		var div = root$F();
		var div_1 = child(div);
		var node = child(div_1);

		Ui_buttons(node, {
			get values() {
				return left();
			}
		});

		reset(div_1);

		var div_2 = sibling(div_1, 2);
		var node_1 = child(div_2);

		Ui_buttons(node_1, {
			get values() {
				return center();
			},
			centered: true
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);
		var node_2 = child(div_3);

		Ui_buttons(node_2, {
			get values() {
				return right();
			},
			right: true
		});

		reset(div_3);
		reset(div);
		template_effect(() => set_class(div, `columns ${classes() ?? ''}`));
		append($$anchor, div);
	}

	function Ui_button_switch($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title]
		 * @property {boolean} [light]
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [disabled]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon]
		 * @property {string} [iconSide]
		 * @property {function} [uiOff]
		 * @property {function} [uiOn]
		 * @property {function} [action]
		 * @property {any} value
		 * @property {boolean} [selected]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			activeState = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			icon = prop($$props, 'icon', 3, false),
			iconSide = prop($$props, 'iconSide', 3, "right"),
			uiOff = prop($$props, 'uiOff', 3, () => {
				return { color: "" };
			}),
			uiOn = prop($$props, 'uiOn', 3, () => {
				return { color: "success" };
			}),
			action = prop($$props, 'action', 3, () => {
				return !selected();
			}),
			onclick = prop($$props, 'onclick', 3, () => {}),
			onchange = prop($$props, 'onchange', 3, () => {}),
			selected = prop($$props, 'selected', 15, false);

		let childProps = state(proxy({
			title: title(),
			light: light(),
			loading: loading(),
			raised: raised(),
			outlined: outlined(),
			inverted: inverted(),
			rounded: rounded(),
			disabled: disabled(),
			type: type(),
			color: color(),
			size: size(),
			class: classes(),
			icon: icon(),
			iconSide: iconSide(),
			value: $$props.value
		}));

		let uiElement = state(undefined);

		onMount(() => {
			updateUI();
		});

		function onClick(event) {
			selected(action()(event, $$props.value, selected()));
			updateUI();

			onclick()({
				value: $$props.value,
				selected: selected()
			});

			onchange()({
				value: $$props.value,
				selected: selected()
			});
		}

		function updateUI() {
			if (get$3(uiElement)) {
				const propsChanges = selected() ? uiOn()($$props.value, selected()) : uiOff()($$props.value, selected());

				Object.keys(propsChanges).forEach((key) => {
					get$3(childProps)[key] = propsChanges[key];
				});

				set(childProps, proxy(get$3(childProps)));
			}
		}

		user_effect(() => {
			if (typeof selected() !== "undefined") updateUI();
		});

		bind_this(
			Ui_button($$anchor, spread_props(() => get$3(childProps), {
				get state() {
					return activeState();
				},
				onclick: onClick
			})),
			($$value) => set(uiElement, proxy($$value)),
			() => get$3(uiElement)
		);

		return pop({ updateUI });
	}

	var root$E = template(`<div></div>`);

	function Ui_buttons_switchers($$anchor, $$props) {
		push($$props, true);

		const uis = {};

		function updateItemUI(item) {
			uis[item.id].updateUI();
		}

		const defaultAction = (ev, value, selected) => {
			const countOfSelected = countSelected();

			if (countOfSelected === min() && selected) {
				return selected;
			}

			if (countOfSelected === max() && selected !== true) {
				return selected;
			}

			const indexOfCurrent = _values.findIndex((itm) => itm.value === value);
			let newSelected = selected;

			if (indexOfCurrent > -1) {
				newSelected = !newSelected;

				const cnt = countSelected() + (newSelected ? 1 : -1);

				if (min()) {
					if (cnt < min()) {
						selectUpToMin(cnt, indexOfCurrent);
					}
				}

				if (max()) {
					if (max() < cnt) {
						deselectDownToMin(cnt, indexOfCurrent);
					}
				}

				return newSelected;
			}

			return newSelected;
		};

		/**
		 * @typedef {Object} Props
		 * @property {array<object>} [values]
		 * @property {boolean} [centered]
		 * @property {boolean} [right]
		 * @property {string} [class]
		 * @property {import('svelte').Component}      [buttonComponent = UIButtonSwitch]
		 * @property {object}   [buttonProps = {}]
		 * @property {function} [action = (event, value, selected) => boolean]  fires on button switch click, returns new state of selected
		 * @property {function} [onclick]
		 * @property {function} [onchange]
		 * @property {number} [min = 0]
		 * @property {number} [max = 100]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 23, () => []),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			classes = prop($$props, 'class', 3, ""),
			buttonComponent = prop($$props, 'buttonComponent', 3, Ui_button_switch),
			buttonProps = prop($$props, 'buttonProps', 19, () => ({})),
			action = prop($$props, 'action', 3, defaultAction),
			onclick = prop($$props, 'onclick', 3, () => true),
			onchange = prop($$props, 'onchange', 3, () => true),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100);
		let _values = proxy(values());

		function onChange() {
			values(snapshot(_values));

			const selected = values().filter((itm) => itm.selected);
			const selectedIds = selected.map((itm) => itm.id);
			const selectedCount = selectedIds.length;

			onchange() && onchange()({
				values: values(),
				selected,
				selectedIds,
				selectedCount
			});
		}

		function selectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = true;
				updateItemUI(itm);
			});

			onChange();
		}

		function deselectAll() {
			_values.forEach((itm, index) => {
				_values[index].selected = false;
				updateItemUI(itm);
			});

			onChange();
		}

		onMount(() => {
			const selectedCount = countSelected();

			if (min() && selectedCount < min()) {
				selectUpToMin(selectedCount, -1);
			}
		});

		function addToHistory(id) {
		}

		function countSelected() {
			const countOfSelected = _values.filter((btn) => {
				return btn.selected;
			}).length;

			return countOfSelected;
		}

		function toggleFirstSuited(toValue) {
			const index = _values.findIndex((itm) => !toValue == itm.selected);

			if (index > -1) {
				_values[index].selected = toValue;
				updateItemUI(_values[index]);
			}
		}

		function selectUpToMin(cnt, indexOfCurrent) {
			let delta = min() - cnt;

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (!_values[t].selected) {
					_values[t].selected = true;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function deselectDownToMin(cnt, indexOfCurrent) {
			let delta = cnt - max();

			if (!delta) {
				return;
			}

			for (let t in _values) {
				if (t === indexOfCurrent) {
					continue;
				}

				if (_values[t].selected) {
					_values[t].selected = false;
					updateItemUI(_values[t]);
					delta--;

					if (!delta) {
						break;
					}
				}
			}

			onChange();
		}

		function updateUI() {
			Object.keys(uis).forEach((itemId) => {
				if (uis[itemId]) {
					uis[itemId].updateUI && uis[itemId].updateUI();
				}
			});
		}

		var div = root$E();

		each(div, 23, () => _values, (item) => item.id, ($$anchor, item, index) => {
			var fragment = comment();
			const SvelteComponent = derived(buttonComponent);
			var node = first_child(fragment);

			component(node, () => get$3(SvelteComponent), ($$anchor, $$component) => {
				bind_this(
					$$component($$anchor, spread_props(
						{
							get action() {
								return action();
							}
						},
						() => get$3(item),
						buttonProps,
						{
							get onclick() {
								return onclick();
							},
							onchange: onChange,
							get selected() {
								return _values[get$3(index)].selected;
							},
							set selected($$value) {
								_values[get$3(index)].selected = $$value;
							}
						}
					)),
					($$value, item) => uis[item.id] = $$value,
					(item) => uis?.[item.id],
					() => [get$3(item)]
				);
			});

			append($$anchor, fragment);
		});

		reset(div);
		template_effect(() => set_class(div, `buttons has-addons ${(centered() ? 'is-centered' : '') ?? ''} ${(right() ? 'is-right' : '') ?? ''} ${classes() ?? ''}`));
		append($$anchor, div);

		return pop({
			selectAll,
			deselectAll,
			addToHistory,
			countSelected,
			toggleFirstSuited,
			selectUpToMin,
			deselectDownToMin,
			updateUI
		});
	}

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIButton: Ui_button,
		UIButtonClose: Ui_button_close,
		UIButtonSwitch: Ui_button_switch,
		UIButtons: Ui_buttons,
		UIButtonsRow: Ui_buttons_row,
		UIButtonsSwitchers: Ui_buttons_switchers
	});

	var root$D = template(`<div><!></div>`);

	function Ui_field($$anchor, $$props) {
		let grouped = prop($$props, 'grouped', 3, false),
			addons = prop($$props, 'addons', 3, false),
			multiline = prop($$props, 'multiline', 3, false),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'grouped',
				'addons',
				'multiline',
				'class',
				'children'
			]);

		var div = root$D();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children);
		reset(div);

		template_effect(() => {
			attributes = set_attributes(div, attributes, {
				class: `field ${classes() ?? ''}`,
				...others
			});

			toggle_class(div, 'has-addons', addons());
			toggle_class(div, 'is-grouped', grouped());
			toggle_class(div, 'is-multiline', multiline());
		});

		append($$anchor, div);
	}

	var root$C = template(`<p><!></p>`);

	function Ui_control($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class='']
		 * @property {boolean} [hasIconsLeft=false]
		 * @property {boolean} [hasIconsRight=false]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			hasIconsLeft = prop($$props, 'hasIconsLeft', 3, false),
			hasIconsRight = prop($$props, 'hasIconsRight', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'hasIconsLeft',
				'hasIconsRight',
				'children'
			]);

		var p = root$C();
		let attributes;
		var node = child(p);

		snippet(node, () => $$props.children ?? noop);
		reset(p);

		template_effect(() => {
			attributes = set_attributes(p, attributes, {
				class: `control ${classes() ?? ''}`,
				...others
			});

			toggle_class(p, 'has-icons-left', hasIconsLeft());
			toggle_class(p, 'has-icons-right', hasIconsRight());
		});

		append($$anchor, p);
	}

	var root_4$e = template(`<!> <!>`, 1);

	function Ui_select_from_model_on_demand_inline($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_API_MODEL_GETTER = (
			modelName,
			actionFilter,
			actionSorter,
			actionPager,
			actionSearch
		) => {
			return notCommon$1.getApp().getModel(modelName).setFilter(actionFilter).setSorter(actionSorter).setPager(actionPager).setSearch(actionSearch);
		};

		const DEFAULT_API_REQUEST = (apiModel, actionName) => {
			return apiModel[`$` + actionName]();
		};

		/**
		 * @typedef {Object} Props
		 * @property {string}   value                                       id of selected variant
		 * @property {array}    [variants = []]                             list of variants
		 * @property {boolean}  [loaded = false]                            true if we already loaded variants from server via API
		 * @property {string}   [placeholder = "empty select item"]         placeholder title
		 * @property {string}   [fieldname = "selectFromModel"]             this input fieldname
		 * @property {string}   [modelName = ""]                            API modelName
		 * @property {string}   [actionName = ""]                           API actionName
		 * @property {object}   [actionFilter = {}]                         API filtering rules
		 * @property {object}   [actionSorter = {}]                         API sorting rules
		 * @property {object}   [actionPager = {}]                          API pager state
		 * @property {object}   [actionSearch = undefined]                  API search string
		 * @property {string}   [optionId = ":_id"]                         variant object id field name
		 * @property {string}   [optionTitle = ":title"]                    variant object title field name
		 * @property {boolean}  [required = false]                          field is required
		 * @property {boolean}  [readonly = false]                          field is reaonly
		 * @property {number}   [size]                                      how many variants would be visible at once, default: 1
		 * @property {boolean}  [valid = true]                              field is valid
		 * @property {function} [onreject = () => false]                    callback on reject of selection process
		 * @property {function} [onresolve = () => true]                    callback on resolve of selection process
		 * @property {function} [onerror = () => true]                      callback on error
		 */
		/** @type {Props} */
		let variants = prop($$props, 'variants', 31, () => proxy([])),
			loaded = prop($$props, 'loaded', 7, false),
			placeholder = prop($$props, 'placeholder', 3, "empty select item"),
			fieldname = prop($$props, 'fieldname', 3, "selectFromModel"),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			apiModelGetter = prop($$props, 'apiModelGetter', 3, DEFAULT_API_MODEL_GETTER),
			apiRequest = prop($$props, 'apiRequest', 3, DEFAULT_API_REQUEST),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			onreject = prop($$props, 'onreject', 3, () => false),
			onresolve = prop($$props, 'onresolve', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => true);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}

		let disabled = derived(() => !loaded());
		let componentState = state("hidden");
		let resultsList = [];

		onMount(async () => {
			if (argumentsSetProvided()) {
				const response = await apiRequest()(apiModelGetter()(modelName(), actionFilter(), actionSorter(), actionPager(), actionSearch()), actionName());

				if (notCommon$1.isError(response)) {
					loaded(false);
					onerror()(response.errors || [response.message]);
				} else {
					resultsList = response.result;

					variants(resultsList.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					}));

					loaded(true);
				}
			}
		});

		let resolvedValue;

		function onModelChanged({ value: selectedValue }) {
			if (resultsList.length > variants().length) {
				resolvedValue = resultsList.find((item) => notPath.get(optionId(), item) == selectedValue);
			} else {
				resolvedValue = variants().find((item) => item.id == selectedValue);
			}
		}

		const ACTIONS = {
			add: {
				color: "primary",
				icon: "plus",
				action() {
					set(componentState, "show");
				}
			},
			resolve: {
				icon: "check",
				color: "primary",
				action() {
					set(componentState, "hidden");
					onresolve()({ field: fieldname(), value: resolvedValue });
				}
			},
			reject: {
				icon: "xmark",
				color: "danger",
				action() {
					set(componentState, "hidden");
					onreject()();
				}
			}
		};

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_button($$anchor, spread_props(() => ACTIONS.add));
			};

			var alternate = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_field($$anchor, {
							addons: true,
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_4$e();
								var node_2 = first_child(fragment_4);

								Ui_control(node_2, {
									children: ($$anchor, $$slotProps) => {
										Ui_select($$anchor, {
											get value() {
												return $$props.value;
											},
											get variants() {
												return variants();
											},
											get placeholder() {
												return placeholder();
											},
											get fieldname() {
												return fieldname();
											},
											get required() {
												return required();
											},
											get readonly() {
												return readonly();
											},
											get disabled() {
												return get$3(disabled);
											},
											get size() {
												return $$props.size;
											},
											get valid() {
												return valid();
											},
											onchange: onModelChanged
										});
									},
									$$slots: { default: true }
								});

								var node_3 = sibling(node_2, 2);

								Ui_control(node_3, {
									children: ($$anchor, $$slotProps) => {
										const expression = derived(() => [ACTIONS.resolve, ACTIONS.reject]);

										Ui_buttons($$anchor, {
											get values() {
												return get$3(expression);
											}
										});
									},
									$$slots: { default: true }
								});

								append($$anchor, fragment_4);
							},
							$$slots: { default: true }
						});
					};

					if_block(
						node_1,
						($$render) => {
							if (get$3(componentState) == "show") $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (get$3(componentState) === "hidden") $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function Ui_select_from_model_with_search_modal($$anchor, $$props) {
		push($$props, true);

		const DEFAULT_SERVICE_GETTER = (serviceName) => {
			if (!serviceName) throw new Error("serviceName is not set");
			return notCommon$1.getApp().getService(serviceName);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string|number}   value
		 * @property {string}   [icon = '']
		 * @property {string}   [fieldname = '']
		 * @property {boolean}  [readonly = false]
		 * @property {string}   [serviceName = ''] - Set this, as ns[ModelName], should be registered in notApp
		 * @property {string}   [serviceOpenSelectorMethod = "openSelector"] - Set this
		 * @property {string}   [serviceLoadDataMethod = "loadData"] - Set this
		 * @property {object}   [modelData = null]
		 * @property {boolean}  [loading = false]
		 * @property {function} [selectedModelTitleFormatter = (data) => data._id]
		 * @property {function} [serviceGetter = (serviceName)=>notCommon.getApp().getService(serviceName)]
		 * @property {string}   [loadingLabel = "not-node:loading_label"]
		 * @property {string}   [isEmptyLabel = "not-node:field_value_is_empty_placeholder"]
		 * @property {function} [onchange = () => true]
		 * @property {object}   [openSelectorButtonProps = {}]
		 * @property {object}   [resetButtonProps = {}]
		 * @property {object}   [emptyButtonProps = {}]
		 * @property {object}   [valueButtonProps = {}]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15),
			icon = prop($$props, 'icon', 3, "search"),
			fieldname = prop($$props, 'fieldname', 3, ""),
			readonly = prop($$props, 'readonly', 3, false),
			serviceName = prop($$props, 'serviceName', 3, ""),
			serviceOpenSelectorMethod = prop($$props, 'serviceOpenSelectorMethod', 3, "openSelector"),
			serviceLoadDataMethod = prop($$props, 'serviceLoadDataMethod', 3, "loadData"),
			modelData = prop($$props, 'modelData', 15, null),
			loading = prop($$props, 'loading', 15, false),
			selectedModelTitleFormatter = prop($$props, 'selectedModelTitleFormatter', 3, (data) => `${data._id}`),
			serviceGetter = prop($$props, 'serviceGetter', 3, DEFAULT_SERVICE_GETTER),
			loadingLabel = prop($$props, 'loadingLabel', 3, "not-node:loading_label"),
			isEmptyLabel = prop($$props, 'isEmptyLabel', 3, "not-node:field_value_is_empty_placeholder"),
			onchange = prop($$props, 'onchange', 3, () => true),
			openSelectorButtonProps = prop($$props, 'openSelectorButtonProps', 19, () => ({})),
			resetButtonProps = prop($$props, 'resetButtonProps', 19, () => ({})),
			emptyButtonProps = prop($$props, 'emptyButtonProps', 19, () => ({})),
			valueButtonProps = prop($$props, 'valueButtonProps', 19, () => ({}));

		function openModelSearchAndSelect() {
			if (!serviceOpenSelectorMethod()) {
				throw new Error("serviceOpenSelectorMethod is not set");
			}

			const service = serviceGetter()(serviceName());

			service[serviceOpenSelectorMethod()]().then((result) => {
				value(result._id);
				modelData(result);
				return value();
			}).then((value) => {
				onchange()({
					field: fieldname(),
					value,
					data: modelData()
				});
			}).catch((e) => {
				notCommon$1.report(e);
			});
		}

		function resetSelectedModel() {
			value(undefined);
			modelData(null);
			onchange()({ field: fieldname(), value: value() });
		}

		async function loadModelData() {
			try {
				if (!modelData() && value()) {
					loading(true);
					modelData(await getService()[serviceLoadDataMethod()](value()));
				}
			} catch(e) {
				notCommon$1.report(e);
			} finally {
				loading(false);
			}
		}

		onMount(() => {
			loadModelData();
		});

		const AVAILABLE_BUTTONS = [
			{
				id: 1,
				action: openModelSearchAndSelect,
				icon: icon(),
				color: "warning",
				...openSelectorButtonProps()
			},
			{
				id: 2,
				action: resetSelectedModel,
				icon: "times",
				color: "danger",
				...resetButtonProps()
			}
		];

		function getModelButton() {
			if (loading()) {
				return {
					disabled: true,
					loading: loading(),
					title: loadingLabel()
				};
			} else {
				if (modelData()) {
					return {
						disabled: readonly(),
						action: openModelSearchAndSelect,
						title: selectedModelTitleFormatter()(modelData()),
						...valueButtonProps()
					};
				} else {
					return {
						disabled: true,
						title: isEmptyLabel(),
						...emptyButtonProps()
					};
				}
			}
		}

		let VISIBLE_BUTTONS = state(proxy([]));

		user_effect(() => {
			if (value()) {
				set(VISIBLE_BUTTONS, proxy([
					getModelButton(),
					...readonly() ? [] : AVAILABLE_BUTTONS
				]));
			} else {
				set(VISIBLE_BUTTONS, proxy([
					getModelButton(),
					...readonly() ? [] : [AVAILABLE_BUTTONS[0]]
				]));
			}
		});

		Ui_control($$anchor, {
			children: ($$anchor, $$slotProps) => {
				Ui_buttons($$anchor, {
					get values() {
						return get$3(VISIBLE_BUTTONS);
					},
					class: "is-no-flex-wrap"
				});
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$B = template(`<progress> </progress>`);

	function Ui_progress($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any}      value
		 * @property {number}   [max = 100]
		 * @property {string}   [color = ""]
		 * @property {string}   [size = ""]
		 * @property {string}   [class = ""]
		 **/
		/** @type {Props} */
		let max = prop($$props, 'max', 3, 100),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, "");

		var progress = root$B();
		var text = child(progress);

		reset(progress);

		template_effect(() => {
			set_class(progress, `
  progress
  ${classes() ?? ''}
  ${(color() ? `is-${color()}` : '') ?? ''}
  ${(size() ? `is-${size()}` : '') ?? ''}`);

			set_value(progress, $$props.value);
			set_attribute(progress, 'max', max());
			set_text(text, `${$$props.value ?? ''}%`);
		});

		append($$anchor, progress);
	}

	function Ui_show_one_from_list($$anchor, $$props) {
		push($$props, true);

		const defaultFilter = (value) => value[idFieldName()] === $$props.id;

		/**
		 * @typedef {Object} Props
		 * @property {string|number}    id                          id of active item
		 * @property {array}            [values = []]               list of items
		 * @property {function}         UIComponent                 component to show active item
		 * @property {function}         component                   snippet to show active item
		 * @property {function}         UIPlaceholder               placeholder if active is unset
		 * @property {function}         placeholder                 snippet to show placeholder
		 * @property {object}           [placeholderProps = {}]     placeholder props
		 * @property {object}           [active = {}]               current active element
		 * @property {string}           [idFieldName = "_id"]       name of item property used as identificator
		 * @property {function}         [filter = (value) => value[idFieldName] === id] filtering function to select active item. default is to search for item with selected id
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			active = prop($$props, 'active', 31, () => proxy({})),
			idFieldName = prop($$props, 'idFieldName', 3, "_id"),
			filter = prop($$props, 'filter', 3, defaultFilter);

		user_effect(() => {
			active(Array.isArray(values()) && values().length && typeof $$props.id !== "undefined" ? values().find(filter() || defaultFilter) : undefined);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						snippet(node_2, () => $$props.component, active);
						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var fragment_4 = comment();
								var node_4 = first_child(fragment_4);

								component(node_4, () => $$props.UIComponent, ($$anchor, $$component) => {
									$$component($$anchor, spread_props(active));
								});

								append($$anchor, fragment_4);
							};

							if_block(
								node_3,
								($$render) => {
									if ($$props.UIComponent) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if ($$props.component) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_2 = ($$anchor) => {
				var fragment_5 = comment();
				var node_5 = first_child(fragment_5);

				{
					var consequent_5 = ($$anchor) => {
						var fragment_6 = comment();
						var node_6 = first_child(fragment_6);

						{
							var consequent_3 = ($$anchor) => {
								var fragment_7 = comment();
								var node_7 = first_child(fragment_7);

								snippet(node_7, () => $$props.placeholder, () => $$props.placeholderProps);
								append($$anchor, fragment_7);
							};

							var alternate_1 = ($$anchor) => {
								var fragment_8 = comment();
								var node_8 = first_child(fragment_8);

								{
									var consequent_4 = ($$anchor) => {
										var fragment_9 = comment();
										var node_9 = first_child(fragment_9);

										component(node_9, () => $$props.UIPlaceholder, ($$anchor, $$component) => {
											$$component($$anchor, spread_props(() => $$props.placeholderProps));
										});

										append($$anchor, fragment_9);
									};

									if_block(
										node_8,
										($$render) => {
											if ($$props.UIPlaceholder) $$render(consequent_4);
										},
										true
									);
								}

								append($$anchor, fragment_8);
							};

							if_block(node_6, ($$render) => {
								if ($$props.placeholder) $$render(consequent_3); else $$render(alternate_1, false);
							});
						}

						append($$anchor, fragment_6);
					};

					if_block(
						node_5,
						($$render) => {
							if ($$props.UIPlaceholder) $$render(consequent_5);
						},
						true
					);
				}

				append($$anchor, fragment_5);
			};

			if_block(node, ($$render) => {
				if (active()) $$render(consequent_2); else $$render(alternate_2, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$A = template(`<div><!> <!></div> <!>`, 1);

	function Ui_tag_value($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = "taggedValueId"] - if we want to address this tag
		 * @property {object}   title
		 * @property {object}   value
		 * @property {array}    [actions = []]
		 * @property {string}   [class = '']
		 * @property {any}      [actionsGroupContructor = UIButtons]
		 * @property {any}      [actionsGroupProps = {}]
		 * @property {boolean}  [readonly = false]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "taggedValueId"),
			actions = prop($$props, 'actions', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			ActionsGroupContructor = prop($$props, 'actionsGroupContructor', 3, Ui_buttons),
			actionsGroupProps = prop($$props, 'actionsGroupProps', 19, () => ({})),
			readonly = prop($$props, 'readonly', 3, false);

		var fragment = root$A();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.title));
			};

			if_block(node, ($$render) => {
				if ($$props.title) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(() => $$props.value));
			};

			if_block(node_1, ($$render) => {
				if ($$props.value) $$render(consequent_1);
			});
		}

		reset(div);

		var node_2 = sibling(div, 2);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				component(node_3, ActionsGroupContructor, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(
						{
							get values() {
								return actions();
							}
						},
						actionsGroupProps
					));
				});

				append($$anchor, fragment_3);
			};

			if_block(node_2, ($$render) => {
				if (!readonly() && actions() && actions().length) $$render(consequent_2);
			});
		}

		template_effect(() => {
			set_class(div, `tags has-addons ${classes() ?? ''}`);
			set_attribute(div, 'id', id());
		});

		append($$anchor, fragment);
		pop();
	}

	enable_legacy_mode_flag();

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/


	/**
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/** @import { FlipParams, AnimationConfig } from './public.js' */

	/**
	 * The flip function calculates the start and end position of an element and animates between them, translating the x and y values.
	 * `flip` stands for [First, Last, Invert, Play](https://aerotwist.com/blog/flip-your-animations/).
	 *
	 * @param {Element} node
	 * @param {{ from: DOMRect; to: DOMRect }} fromTo
	 * @param {FlipParams} params
	 * @returns {AnimationConfig}
	 */
	function flip(node, { from, to }, params = {}) {
		var { delay = 0, duration = (d) => Math.sqrt(d) * 120, easing = cubicOut } = params;

		var style = getComputedStyle(node);

		// find the transform origin, expressed as a pair of values between 0 and 1
		var transform = style.transform === 'none' ? '' : style.transform;
		var [ox, oy] = style.transformOrigin.split(' ').map(parseFloat);
		ox /= node.clientWidth;
		oy /= node.clientHeight;

		// calculate effect of parent transforms and zoom
		var zoom = get_zoom(node); // https://drafts.csswg.org/css-viewport/#effective-zoom
		var sx = node.clientWidth / to.width / zoom;
		var sy = node.clientHeight / to.height / zoom;

		// find the starting position of the transform origin
		var fx = from.left + from.width * ox;
		var fy = from.top + from.height * oy;

		// find the ending position of the transform origin
		var tx = to.left + to.width * ox;
		var ty = to.top + to.height * oy;

		// find the translation at the start of the transform
		var dx = (fx - tx) * sx;
		var dy = (fy - ty) * sy;

		// find the relative scale at the start of the transform
		var dsx = from.width / to.width;
		var dsy = from.height / to.height;

		return {
			delay,
			duration: typeof duration === 'function' ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
			easing,
			css: (t, u) => {
				var x = u * dx;
				var y = u * dy;
				var sx = t + u * dsx;
				var sy = t + u * dsy;

				return `transform: ${transform} translate(${x}px, ${y}px) scale(${sx}, ${sy});`;
			}
		};
	}

	/**
	 * @param {Element} element
	 */
	function get_zoom(element) {
		if ('currentCSSZoom' in element) {
			return /** @type {number} */ (element.currentCSSZoom);
		}

		/** @type {Element | null} */
		var current = element;
		var zoom = 1;

		while (current !== null) {
			zoom *= +getComputedStyle(current).zoom;
			current = /** @type {Element | null} */ (current.parentElement);
		}

		return zoom;
	}

	/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */


	/** @param {number} x */
	const linear = (x) => x;

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * @param {Element} node
	 * @param {FadeParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = linear } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	var root_1$r = template(`<option selected class="svelte-75ckfb"> </option>`);
	var root_4$d = template(`<option selected class="svelte-75ckfb"> </option>`);
	var root_7$3 = template(`<div class="tags has-addons svelte-75ckfb"><span class="tag svelte-75ckfb"> </span> <span class="tag is-delete svelte-75ckfb"></span></div>`);
	var root_6$a = template(`<div class="svelte-75ckfb"><!></div>`);
	var root_8$2 = template(`<span class="autocomplete-clear-button svelte-75ckfb"><!></span>`);
	var root_11$2 = template(`<div class="autocomplete-list-item svelte-75ckfb"><!></div>`);
	var root_17 = template(`<div class="autocomplete-list-item-no-results svelte-75ckfb"> </div>`);
	var root_9$1 = template(`<!> <!> <!>`, 1);
	var root_19$2 = template(`<div class="autocomplete-list-item-loading svelte-75ckfb"><!></div>`);
	var root_22$1 = template(`<div class="autocomplete-list-item-create svelte-75ckfb"><!></div>`);
	var root_25 = template(`<div class="autocomplete-list-item-no-results svelte-75ckfb"><!></div>`);
	var root$z = template(`<div><select class="svelte-75ckfb"><!></select> <div class="input-container svelte-75ckfb"><!> <input> <!></div> <div><!></div></div>`);

	function SimpleAutocomplete($$anchor, $$props) {
		const $$sanitized_props = legacy_rest_props($$props, [
			'children',
			'$$slots',
			'$$events',
			'$$legacy'
		]);

		const $$restProps = legacy_rest_props($$sanitized_props, [
			'highlightFilter',
			'items',
			'searchFunction',
			'labelFieldName',
			'keywordsFieldName',
			'valueFieldName',
			'labelFunction',
			'keywordsFunction',
			'valueFunction',
			'keywordsCleanFunction',
			'textCleanFunction',
			'beforeChange',
			'onChange',
			'onFocus',
			'onBlur',
			'onCreate',
			'selectFirstIfEmpty',
			'minCharactersToSearch',
			'maxItemsToShowInList',
			'multiple',
			'create',
			'ignoreAccents',
			'matchAllKeywords',
			'sortByMatchedKeywords',
			'itemFilterFunction',
			'itemSortFunction',
			'lock',
			'delay',
			'localFiltering',
			'localSorting',
			'cleanUserText',
			'lowercaseKeywords',
			'closeOnBlur',
			'orderableSelection',
			'hideArrow',
			'showClear',
			'clearText',
			'showLoadingIndicator',
			'noResultsText',
			'loadingText',
			'moreItemsText',
			'createText',
			'placeholder',
			'className',
			'inputClassName',
			'inputId',
			'name',
			'selectName',
			'selectId',
			'title',
			'html5autocomplete',
			'autocompleteOffValue',
			'readonly',
			'dropdownClassName',
			'disabled',
			'noInputStyles',
			'required',
			'debug',
			'tabindex',
			'selectedItem',
			'value',
			'highlightedItem',
			'text'
		]);

		push($$props, false);

		const showList = mutable_state();
		const hasSelection = mutable_state();
		const clearable = mutable_state();
		const locked = mutable_state();
		let items = prop($$props, 'items', 28, () => []);
		let searchFunction = prop($$props, 'searchFunction', 8, false);
		let labelFieldName = prop($$props, 'labelFieldName', 8, undefined);
		let keywordsFieldName = prop($$props, 'keywordsFieldName', 24, labelFieldName);
		let valueFieldName = prop($$props, 'valueFieldName', 8, undefined);

		let labelFunction = prop($$props, 'labelFunction', 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return labelFieldName() ? item[labelFieldName()] : item;
		});

		let keywordsFunction = prop($$props, 'keywordsFunction', 8, function (item) {
			if (item === undefined || item === null) {
				return "";
			}

			return keywordsFieldName() ? item[keywordsFieldName()] : labelFunction()(item);
		});

		let valueFunction = prop($$props, 'valueFunction', 8, function (item, forceSingle = false) {
			if (item === undefined || item === null) {
				return item;
			}

			if (!multiple() || forceSingle) {
				return valueFieldName() ? item[valueFieldName()] : item;
			} else {
				return item.map((i) => valueFieldName() ? i[valueFieldName()] : i);
			}
		});

		let keywordsCleanFunction = prop($$props, 'keywordsCleanFunction', 8, function (keywords) {
			return keywords;
		});

		let textCleanFunction = prop($$props, 'textCleanFunction', 8, function (userEnteredText) {
			return userEnteredText;
		});

		let beforeChange = prop($$props, 'beforeChange', 8, function (oldSelectedItem, newSelectedItem) {
			return true;
		});

		let onChange = prop($$props, 'onChange', 8, function (newSelectedItem) {});
		let onFocus = prop($$props, 'onFocus', 8, function () {});
		let onBlur = prop($$props, 'onBlur', 8, function () {});

		let onCreate = prop($$props, 'onCreate', 8, function (text) {
			if (debug()) {
				console.log("onCreate: " + text);
			}
		});

		let selectFirstIfEmpty = prop($$props, 'selectFirstIfEmpty', 8, false);
		let minCharactersToSearch = prop($$props, 'minCharactersToSearch', 8, 1);
		let maxItemsToShowInList = prop($$props, 'maxItemsToShowInList', 8, 0);
		let multiple = prop($$props, 'multiple', 8, false);
		let create = prop($$props, 'create', 8, false);
		let ignoreAccents = prop($$props, 'ignoreAccents', 8, true);
		let matchAllKeywords = prop($$props, 'matchAllKeywords', 8, true);
		let sortByMatchedKeywords = prop($$props, 'sortByMatchedKeywords', 8, false);
		let itemFilterFunction = prop($$props, 'itemFilterFunction', 8, undefined);
		let itemSortFunction = prop($$props, 'itemSortFunction', 8, undefined);
		let lock = prop($$props, 'lock', 8, false);
		let delay = prop($$props, 'delay', 8, 0);
		let localFiltering = prop($$props, 'localFiltering', 8, true);
		let localSorting = prop($$props, 'localSorting', 8, true);
		let cleanUserText = prop($$props, 'cleanUserText', 8, true);
		let lowercaseKeywords = prop($$props, 'lowercaseKeywords', 8, true);
		let closeOnBlur = prop($$props, 'closeOnBlur', 8, false);
		let orderableSelection = prop($$props, 'orderableSelection', 8, false);
		let hideArrow = prop($$props, 'hideArrow', 8, false);
		let showClear = prop($$props, 'showClear', 8, false);
		let clearText = prop($$props, 'clearText', 8, "&#10006;");
		let showLoadingIndicator = prop($$props, 'showLoadingIndicator', 8, false);
		let noResultsText = prop($$props, 'noResultsText', 8, "No results found");
		let loadingText = prop($$props, 'loadingText', 8, "Loading results...");
		let moreItemsText = prop($$props, 'moreItemsText', 8, "items not shown");
		let createText = prop($$props, 'createText', 8, "Not found, add anyway?");
		let placeholder = prop($$props, 'placeholder', 8, undefined);
		let className = prop($$props, 'className', 8, undefined);
		let inputClassName = prop($$props, 'inputClassName', 8, undefined);
		let inputId = prop($$props, 'inputId', 8, undefined);
		let name = prop($$props, 'name', 8, undefined);
		let selectName = prop($$props, 'selectName', 8, undefined);
		let selectId = prop($$props, 'selectId', 8, undefined);
		let title = prop($$props, 'title', 8, undefined);
		let html5autocomplete = prop($$props, 'html5autocomplete', 8, undefined);
		let autocompleteOffValue = prop($$props, 'autocompleteOffValue', 8, "off");
		let readonly = prop($$props, 'readonly', 8, undefined);
		let dropdownClassName = prop($$props, 'dropdownClassName', 8, undefined);
		let disabled = prop($$props, 'disabled', 8, false);
		let noInputStyles = prop($$props, 'noInputStyles', 8, false);
		let required = prop($$props, 'required', 8, null);
		let debug = prop($$props, 'debug', 8, false);
		let tabindex = prop($$props, 'tabindex', 8, 0);
		let selectedItem = prop($$props, 'selectedItem', 28, () => multiple() ? [] : undefined);
		let value = prop($$props, 'value', 12, undefined);
		let highlightedItem = prop($$props, 'highlightedItem', 12, undefined);
		// --- Internal State ----
		const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);
		// HTML elements
		let input = mutable_state();
		let list = mutable_state();
		let inputContainer = mutable_state();
		// UI state
		let opened = mutable_state(false);
		let loading = mutable_state(false);
		let highlightIndex = mutable_state(-1);
		let text$1 = prop($$props, 'text', 12, undefined);
		let filteredTextLength = mutable_state(0);
		// view model
		let filteredListItems = mutable_state();
		let listItems = [];
		// requests/responses counters
		let lastRequestId = 0;
		let lastResponseId = 0;
		// other state
		let inputDelayTimeout;
		let setPositionOnNextUpdate = mutable_state(false);

		// --- Lifecycle events ---
		afterUpdate(() => {
			if (get$3(setPositionOnNextUpdate)) {
				setScrollAwareListPosition();
			}

			set(setPositionOnNextUpdate, false);
		});

		// --- Functions ---
		function safeFunction(theFunction, argument) {
			if (typeof theFunction !== "function") {
				console.error("Not a function: " + theFunction + ", argument: " + argument);
				return undefined;
			}

			let result;

			try {
				result = theFunction(argument);
			} catch(error) {
				console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
			}

			return result;
		}

		function safeStringFunction(theFunction, argument) {
			let result = safeFunction(theFunction, argument);

			if (result === undefined || result === null) {
				result = "";
			}

			if (typeof result !== "string") {
				result = result.toString();
			}

			return result;
		}

		function safeLabelFunction(item) {
			// console.log("labelFunction: " + labelFunction);
			// console.log("safeLabelFunction, item: " + item);
			return safeStringFunction(labelFunction(), item);
		}

		function safeKeywordsFunction(item) {
			// console.log("safeKeywordsFunction");
			const keywords = safeStringFunction(keywordsFunction(), item);
			let result = safeStringFunction(keywordsCleanFunction(), keywords);

			result = lowercaseKeywords() ? result.toLowerCase().trim() : result;

			if (ignoreAccents()) {
				result = removeAccents(result);
			}

			if (debug()) {
				console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
			}

			return result;
		}

		function prepareListItems() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete prepare list ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Prepare items to search");
				console.log("items: " + JSON.stringify(items()));
			}

			if (!Array.isArray(items())) {
				console.warn("Autocomplete items / search function did not return array but", items());
				items([]);
			}

			const length = items() ? items().length : 0;

			listItems = new Array(length);

			if (length > 0) {
				items().forEach((item, i) => {
					const listItem = getListItem(item);

					if (listItem === undefined) {
						console.log("Undefined item for: ", item);
					}

					listItems[i] = listItem;
				});
			}

			set(filteredListItems, listItems);

			if (debug()) {
				console.log(listItems.length + " items to search");
				console.timeEnd(timerId);
			}
		}

		function getListItem(item) {
			return {
				// keywords representation of the item
				keywords: localFiltering() ? safeKeywordsFunction(item) : [],
				// item label
				label: safeLabelFunction(item),
				// store reference to the origial item
				item
			};
		}

		function onSelectedItemChanged() {
			value(valueFunction()(selectedItem()));

			if (selectedItem() && !multiple()) {
				text$1(safeLabelFunction(selectedItem()));
			}

			set(filteredListItems, listItems);
			onChange()(selectedItem());
		}

		function prepareUserEnteredText(userEnteredText) {
			if (userEnteredText === undefined || userEnteredText === null) {
				return "";
			}

			if (!cleanUserText()) {
				return userEnteredText;
			}

			const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
			const cleanUserEnteredText = safeStringFunction(textCleanFunction(), textFiltered);
			const textTrimmed = lowercaseKeywords() ? cleanUserEnteredText.toLowerCase().trim() : cleanUserEnteredText.trim();

			return textTrimmed;
		}

		function numberOfMatches(listItem, searchWords) {
			if (!listItem) {
				return 0;
			}

			const itemKeywords = listItem.keywords;
			let matches = 0;

			searchWords.forEach((searchWord) => {
				if (itemKeywords.includes(searchWord)) {
					matches++;
				}
			});

			return matches;
		}

		async function search() {
			let timerId;

			if (debug()) {
				timerId = `Autocomplete search ${inputId() ? `(id: ${inputId()})` : ""}`;
				console.time(timerId);
				console.log("Searching user entered text: '" + text$1() + "'");
			}

			let textFiltered = prepareUserEnteredText(text$1());

			if (minCharactersToSearch() > 1 && textFiltered.length < minCharactersToSearch()) {
				textFiltered = "";
			}

			set(filteredTextLength, textFiltered.length);

			if (debug()) {
				console.log("Changed user entered text '" + text$1() + "' into '" + textFiltered + "'");
			}

			// if no search text load all items
			if (textFiltered === "") {
				if (searchFunction()) {
					// we will need to rerun the search
					items([]);

					if (debug()) {
						console.log("User entered text is empty clear list of items");
					}
				} else {
					set(filteredListItems, listItems);

					if (debug()) {
						console.log("User entered text is empty set the list of items to all items");
					}
				}

				if (closeIfMinCharsToSearchReached()) {
					if (debug()) {
						console.timeEnd(timerId);
					}

					return;
				}
			}

			if (!searchFunction()) {
				// internal search
				processListItems(textFiltered);
			} else {
				// external search which provides items
				lastRequestId = lastRequestId + 1;

				const currentRequestId = lastRequestId;

				set(loading, true);

				// searchFunction is a generator
				if (searchFunction().constructor.name === "AsyncGeneratorFunction") {
					for await (const chunk of searchFunction()(textFiltered, maxItemsToShowInList())) {
						// a chunk of an old response: throw it away
						if (currentRequestId < lastResponseId) {
							return false;
						}

						// a chunk for a new response: reset the item list
						if (currentRequestId > lastResponseId) {
							items([]);
						}

						lastResponseId = currentRequestId;
						items([...items(), ...chunk]);
						processListItems(textFiltered);
					}

					// there was nothing in the chunk
					if (lastResponseId < currentRequestId) {
						lastResponseId = currentRequestId;
						items([]);
						processListItems(textFiltered);
					}
				} else // searchFunction is a regular function
				{
					let result = await searchFunction()(textFiltered, maxItemsToShowInList());

					// If a response to a newer request has been received
					// while responses to this request were being loaded,
					// then we can just throw away this outdated results.
					if (currentRequestId < lastResponseId) {
						return false;
					}

					lastResponseId = currentRequestId;
					items(result);
					processListItems(textFiltered);
				}

				set(loading, false);
			}

			if (debug()) {
				console.timeEnd(timerId);
				console.log("Search found " + get$3(filteredListItems).length + " items");
			}
		}

		function defaultItemFilterFunction(listItem, searchWords) {
			const matches = numberOfMatches(listItem, searchWords);

			if (matchAllKeywords()) {
				return matches >= searchWords.length;
			} else {
				return matches > 0;
			}
		}

		function defaultItemSortFunction(obj1, obj2, searchWords) {
			return numberOfMatches(obj2, searchWords) - numberOfMatches(obj1, searchWords);
		}

		function processListItems(textFiltered) {
			// cleans, filters, orders, and highlights the list items
			prepareListItems();

			const textFilteredWithoutAccents = ignoreAccents() ? removeAccents(textFiltered) : textFiltered;
			const searchWords = textFilteredWithoutAccents.split(/\s+/g).filter((word) => word !== "");
			// local search
			let tempfilteredListItems;

			if (localFiltering()) {
				if (itemFilterFunction()) {
					tempfilteredListItems = listItems.filter((item) => itemFilterFunction()(item.item, searchWords));
				} else {
					tempfilteredListItems = listItems.filter((item) => defaultItemFilterFunction(item, searchWords));
				}

				if (localSorting()) {
					if (itemSortFunction()) {
						tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => itemSortFunction()(item1.item, item2.item, searchWords));
					} else {
						if (sortByMatchedKeywords()) {
							tempfilteredListItems = tempfilteredListItems.sort((item1, item2) => defaultItemSortFunction(item1, item2, searchWords));
						}
					}
				}
			} else {
				tempfilteredListItems = listItems;
			}

			const hlfilter = highlightFilter(searchWords, "label");

			set(filteredListItems, tempfilteredListItems.map(hlfilter));
			closeIfMinCharsToSearchReached();
			return true;
		}

		// $: text, search();
		function afterCreate(createdItem) {
			let listItem;

			if (debug()) {
				console.log("createdItem", createdItem);
			}

			if ("undefined" !== typeof createdItem) {
				prepareListItems();
				set(filteredListItems, listItems);

				let index = findItemIndex(createdItem, get$3(filteredListItems));

				// if the items array was not updated, add the created item manually
				if (index <= 0) {
					items([createdItem]);
					prepareListItems();
					set(filteredListItems, listItems);
					index = 0;
				}

				if (index >= 0) {
					set(highlightIndex, index);
					listItem = get$3(filteredListItems)[get$3(highlightIndex)];
				}
			}

			return listItem;
		}

		function selectListItem(listItem) {
			if (debug()) {
				console.log("selectListItem", listItem);
			}

			if ("undefined" === typeof listItem && create()) {
				// allow undefined items if create is enabled
				const createdItem = onCreate()(text$1());

				if ("undefined" !== typeof createdItem) {
					if (typeof createdItem.then === "function") {
						createdItem.then((newItem) => {
							if ("undefined" !== typeof newItem) {
								const newListItem = afterCreate(newItem);

								if ("undefined" !== typeof newListItem) {
									selectListItem(newListItem);
								}
							}
						});

						return true;
					} else {
						listItem = afterCreate(createdItem);
					}
				}
			}

			if ("undefined" === typeof listItem) {
				if (debug()) {
					console.log(`listItem is undefined. Can not select.`);
				}

				return false;
			}

			if (get$3(locked)) {
				return true;
			}

			const newSelectedItem = listItem.item;

			if (beforeChange()(selectedItem(), newSelectedItem)) {
				// simple selection
				if (!multiple()) {
					selectedItem(undefined); // triggers change even if the the same item is selected
					selectedItem(newSelectedItem);
				} else // first selection of multiple ones
				if (!selectedItem()) {
					selectedItem([newSelectedItem]);
				} else // selecting something already selected => unselect it
				if (selectedItem().includes(newSelectedItem)) {
					selectedItem(selectedItem().filter((i) => i !== newSelectedItem));
				} else // adds the element to the selection
				{
					selectedItem([...selectedItem(), newSelectedItem]);
				}
			}

			return true;
		}

		function selectItem() {
			if (debug()) {
				console.log("selectItem", get$3(highlightIndex));
			}

			const listItem = get$3(filteredListItems)[get$3(highlightIndex)];

			if (selectListItem(listItem)) {
				if (debug()) {
					console.log("selectListItem true, closing");
				}

				close();

				if (multiple()) {
					text$1("");
					get$3(input).focus();
				}
			} else {
				if (debug()) {
					console.log("selectListItem false, not closing");
				}
			}
		}

		function up() {
			if (debug()) {
				console.log("up");
			}

			open();

			if (get$3(highlightIndex) > 0) {
				update(highlightIndex, -1);
			}

			highlight();
		}

		function down() {
			if (debug()) {
				console.log("down");
			}

			open();

			if (get$3(highlightIndex) < get$3(filteredListItems).length - 1) {
				update(highlightIndex);
			}

			highlight();
		}

		function highlight() {
			if (debug()) {
				console.log("highlight");
			}

			const query = ".selected";

			if (debug()) {
				console.log("Seaching DOM element: " + query + " in " + get$3(list));
			}

			/**
			 * @param {Element} el
			 */
			const el = get$3(list) && get$3(list).querySelector(query);

			if (el) {
				if (typeof el.scrollIntoViewIfNeeded === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoViewIfNeeded();
				} else if (el.scrollIntoView === "function") {
					if (debug()) {
						console.log("Scrolling selected item into view");
					}

					el.scrollIntoView();
				} else {
					if (debug()) {
						console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
					}
				}
			} else {
				if (debug()) {
					console.warn("Selected item not found to scroll into view");
				}
			}
		}

		function onListItemClick(listItem) {
			if (debug()) {
				console.log("onListItemClick");
			}

			if (selectListItem(listItem)) {
				close();

				if (multiple()) {
					text$1("");
					get$3(input).focus();
				}
			}
		}

		function onDocumentClick(e) {
			if (debug()) {
				console.log("onDocumentClick");
			}

			if (e.composedPath().some((path) => path.classList && path.classList.contains(uniqueId))) {
				if (debug()) {
					console.log("onDocumentClick inside");
				}

				// resetListToAllItemsAndOpen();
				highlight();
			} else {
				if (debug()) {
					console.log("onDocumentClick outside");
				}

				close();
			}
		}

		function onKeyDown(e) {
			if (debug()) {
				console.log("onKeyDown");
			}

			let key = e.key;

			if (key === "Tab" && e.shiftKey) key = "ShiftTab";

			const fnmap = {
				Tab: get$3(opened) ? close : null,
				ShiftTab: get$3(opened) ? close : null,
				ArrowDown: down.bind(this),
				ArrowUp: up.bind(this),
				Escape: onEsc.bind(this),
				Backspace: multiple() && get$3(hasSelection) && !text$1() ? onBackspace.bind(this) : null
			};

			const fn = fnmap[key];

			if (typeof fn === "function") {
				fn(e);
			}
		}

		function onKeyPress(e) {
			if (debug()) {
				console.log("onKeyPress");
			}

			if (e.key === "Enter") {
				onEnter(e);
			}
		}

		function onEnter(e) {
			if (get$3(opened)) {
				e.preventDefault();
				selectItem();
			}
		}

		function onInput(e) {
			if (debug()) {
				console.log("onInput");
			}

			text$1(e.target.value);

			if (inputDelayTimeout) {
				clearTimeout(inputDelayTimeout);
			}

			if (delay()) {
				inputDelayTimeout = setTimeout(processInput, delay());
			} else {
				processInput();
			}
		}

		function unselectItem(tag) {
			if (debug()) {
				console.log("unselectItem", tag);
			}

			selectedItem(selectedItem().filter((i) => i !== tag));
			get$3(input).focus();
		}

		function processInput() {
			if (search()) {
				set(highlightIndex, 0);
				open();
			}
		}

		function onInputClick() {
			if (debug()) {
				console.log("onInputClick");
			}

			resetListToAllItemsAndOpen();
		}

		function onEsc(e) {
			if (debug()) {
				console.log("onEsc");
			}

			//if (text) return clear();
			e.stopPropagation();

			if (get$3(opened)) {
				get$3(input).focus();
				close();
			}
		}

		function onBackspace(e) {
			if (debug()) {
				console.log("onBackspace");
			}

			unselectItem(selectedItem()[selectedItem().length - 1]);
		}

		function onFocusInternal() {
			if (debug()) {
				console.log("onFocus");
			}

			onFocus()();
			resetListToAllItemsAndOpen();
		}

		function onBlurInternal() {
			if (debug()) {
				console.log("onBlur");
			}

			if (closeOnBlur()) {
				close();
			}

			onBlur()();
		}

		function resetListToAllItemsAndOpen() {
			if (debug()) {
				console.log("resetListToAllItemsAndOpen");
			}

			if (searchFunction() && !listItems.length) {
				search();
			} else if (!text$1()) {
				set(filteredListItems, listItems);
			}

			open();

			// find selected item
			if (selectedItem()) {
				if (debug()) {
					console.log("Searching currently selected item: " + JSON.stringify(selectedItem()));
				}

				const index = findItemIndex(selectedItem(), get$3(filteredListItems));

				if (index >= 0) {
					set(highlightIndex, index);
					highlight();
				}
			}
		}

		function findItemIndex(item, items) {
			if (debug()) {
				console.log("Finding index for item", item);
			}

			let index = -1;

			for (let i = 0; i < items.length; i++) {
				const listItem = items[i];

				if ("undefined" === typeof listItem) {
					if (debug()) {
						console.log(`listItem ${i} is undefined. Skipping.`);
					}

					continue;
				}

				if (debug()) {
					console.log("Item " + i + ": " + JSON.stringify(listItem));
				}

				if (item === listItem.item) {
					index = i;
					break;
				}
			}

			if (debug()) {
				if (index >= 0) {
					console.log("Found index for item: " + index);
				} else {
					console.warn("Not found index for item: " + item);
				}
			}

			return index;
		}

		function open() {
			if (debug()) {
				console.log("open");
			}

			// check if the search text has more than the min chars required
			if (get$3(locked) || notEnoughSearchText()) {
				return;
			}

			set(setPositionOnNextUpdate, true);
			set(opened, true);
		}

		function close() {
			if (debug()) {
				console.log("close");
			}

			set(opened, false);
			set(loading, false);

			if (!text$1() && selectFirstIfEmpty()) {
				set(highlightIndex, 0);
				selectItem();
			}
		}

		function notEnoughSearchText() {
			return minCharactersToSearch() > 0 && get$3(filteredTextLength) < minCharactersToSearch() && (// When no searchFunction is defined, the menu should always open when the input is focused
			searchFunction() || get$3(filteredTextLength) > 0);
		}

		function closeIfMinCharsToSearchReached() {
			if (notEnoughSearchText()) {
				close();
				return true;
			}

			return false;
		}

		function clear() {
			if (debug()) {
				console.log("clear");
			}

			text$1("");
			selectedItem(multiple() ? [] : undefined);

			setTimeout(() => {
				get$3(input).focus();
			});
		}

		function highlightFilter(keywords, field) {
			return (item) => {
				let label = item[field];
				const newItem = Object.assign({ highlighted: undefined }, item);

				newItem.highlighted = label;

				const labelLowercase = label.toLowerCase();
				const labelLowercaseNoAc = ignoreAccents() ? removeAccents(labelLowercase) : labelLowercase;

				if (keywords && keywords.length) {
					const positions = [];

					for (let i = 0; i < keywords.length; i++) {
						let keyword = keywords[i];

						if (ignoreAccents()) {
							keyword = removeAccents(keyword);
						}

						const keywordLen = keyword.length;
						let pos1 = 0;

						do {
							pos1 = labelLowercaseNoAc.indexOf(keyword, pos1);

							if (pos1 >= 0) {
								let pos2 = pos1 + keywordLen;

								positions.push([pos1, pos2]);
								pos1 = pos2;
							}
						} while (pos1 !== -1);
					}

					if (positions.length > 0) {
						const keywordPatterns = new Set();

						for (let i = 0; i < positions.length; i++) {
							const pair = positions[i];
							const pos1 = pair[0];
							const pos2 = pair[1];
							const keywordPattern = labelLowercase.substring(pos1, pos2);

							keywordPatterns.add(keywordPattern);
						}

						for (let keywordPattern of keywordPatterns) {
							// FIXME pst: workarond for wrong replacement <b> tags
							if (keywordPattern === "b") {
								continue;
							}

							const reg = new RegExp("(" + keywordPattern + ")", "ig");
							const newHighlighted = newItem.highlighted.replace(reg, "<b>$1</b>");

							newItem.highlighted = newHighlighted;
						}
					}
				}

				return newItem;
			};
		}

		function removeAccents(str) {
			return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
		}

		function isConfirmed(listItem) {
			if (!selectedItem()) {
				return false;
			}

			if (multiple()) {
				return selectedItem().includes(listItem);
			} else {
				return listItem === selectedItem();
			}
		}

		let draggingOver = mutable_state(false);

		function dragstart(event, index) {
			if (orderableSelection()) {
				event.dataTransfer.setData("source", index);
			}
		}

		function dragover(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, index);
			}
		}

		function dragleave(event, index) {
			if (orderableSelection()) {
				set(draggingOver, false);
			}
		}

		function drop(event, index) {
			if (orderableSelection()) {
				event.preventDefault();
				set(draggingOver, false);

				let from = parseInt(event.dataTransfer.getData("source"));
				let to = index;

				if (from != to) {
					moveSelectedItem(from, to);
				}
			}
		}

		function moveSelectedItem(from, to) {
			let newSelection = [...selectedItem()];

			if (from < to) {
				newSelection.splice(to + 1, 0, newSelection[from]);
				newSelection.splice(from, 1);
			} else {
				newSelection.splice(to, 0, newSelection[from]);
				newSelection.splice(from + 1, 1);
			}

			selectedItem(newSelection);
		}

		function setScrollAwareListPosition() {
			const { height: viewPortHeight } = window.visualViewport;
			const { bottom: inputButtom, height: inputHeight } = get$3(inputContainer).getBoundingClientRect();
			const { height: listHeight } = get$3(list).getBoundingClientRect();

			if (inputButtom + listHeight > viewPortHeight) {
				mutate(list, get$3(list).style.top = `-${inputHeight + listHeight}px`);
			} else {
				mutate(list, get$3(list).style.top = "0px");
			}
		}

		legacy_pre_effect(
			() => (
				deep_read_state(items()),
				deep_read_state(searchFunction())
			),
			() => {
				(
					items(),
					searchFunction() || prepareListItems()
				);
			}
		);

		legacy_pre_effect(() => (deep_read_state(selectedItem())), () => {
			(
				selectedItem(),
				onSelectedItemChanged()
			);
		});

		legacy_pre_effect(
			() => (
				get$3(filteredListItems),
				get$3(highlightIndex)
			),
			() => {
				highlightedItem(get$3(filteredListItems) && get$3(highlightIndex) && get$3(highlightIndex) >= 0 && get$3(highlightIndex) < get$3(filteredListItems).length ? get$3(filteredListItems)[get$3(highlightIndex)].item : null);
			}
		);

		legacy_pre_effect(
			() => (
				get$3(opened),
				deep_read_state(items()),
				get$3(filteredTextLength)
			),
			() => {
				set(showList, get$3(opened) && (items() && items().length > 0 || get$3(filteredTextLength) > 0));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(multiple()),
				deep_read_state(selectedItem())
			),
			() => {
				set(hasSelection, multiple() && selectedItem() && selectedItem().length > 0 || !multiple() && selectedItem());
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(showClear()),
				deep_read_state(lock()),
				deep_read_state(multiple()),
				get$3(hasSelection)
			),
			() => {
				set(clearable, showClear() || (lock() || multiple()) && get$3(hasSelection));
			}
		);

		legacy_pre_effect(
			() => (
				deep_read_state(lock()),
				get$3(hasSelection)
			),
			() => {
				set(locked, lock() && get$3(hasSelection));
			}
		);

		legacy_pre_effect_reset();
		init();

		var div = root$z();

		event('click', $window, onDocumentClick);
		event('scroll', $window, () => set(setPositionOnNextUpdate, true));

		var select = child(div);
		var node = child(select);

		{
			var consequent = ($$anchor) => {
				var option = root_1$r();
				var option_value = {};
				var text_1 = child(option, true);

				reset(option);

				template_effect(
					($0, $1) => {
						if (option_value !== (option_value = $0)) {
							option.value = null == (option.__value = $0) ? '' : $0;
						}

						set_text(text_1, $1);
					},
					[
						() => valueFunction()(selectedItem(), true),
						() => safeLabelFunction(selectedItem())
					],
					derived_safe_equal
				);

				append($$anchor, option);
			};

			var alternate = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 1, selectedItem, index$d, ($$anchor, i) => {
							var option_1 = root_4$d();
							var option_1_value = {};
							var text_2 = child(option_1, true);

							reset(option_1);

							template_effect(
								($0, $1) => {
									if (option_1_value !== (option_1_value = $0)) {
										option_1.value = null == (option_1.__value = $0) ? '' : $0;
									}

									set_text(text_2, $1);
								},
								[
									() => valueFunction()(get$3(i), true),
									() => safeLabelFunction(get$3(i))
								],
								derived_safe_equal
							);

							append($$anchor, option_1);
						});

						append($$anchor, fragment_1);
					};

					if_block(
						node_1,
						($$render) => {
							if (multiple() && get$3(hasSelection)) $$render(consequent_1);
						},
						true
					);
				}

				append($$anchor, fragment);
			};

			if_block(node, ($$render) => {
				if (!multiple() && get$3(hasSelection)) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(select);

		var div_1 = sibling(select, 2);
		var node_3 = child(div_1);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_2 = comment();
				var node_4 = first_child(fragment_2);

				each(node_4, 11, selectedItem, (tagItem) => valueFunction()(tagItem, true), ($$anchor, tagItem, i) => {
					var div_2 = root_6$a();

					set_attribute(div_2, 'draggable', true);

					var node_5 = child(div_2);
					const expression = derived_safe_equal(() => safeLabelFunction(get$3(tagItem)));

					slot(
						node_5,
						$$props,
						'tag',
						{
							get label() {
								return get$3(expression);
							},
							get item() {
								return get$3(tagItem);
							},
							unselectItem
						},
						($$anchor) => {
							var div_3 = root_7$3();
							var span = child(div_3);
							var text_3 = child(span, true);

							reset(span);

							var span_1 = sibling(span, 2);
							var event_handler = derived(() => unselectItem(get$3(tagItem)));

							reset(div_3);

							template_effect(
								($0) => set_text(text_3, $0),
								[
									() => safeLabelFunction(get$3(tagItem))
								],
								derived_safe_equal
							);

							event('click', span_1, preventDefault(function (...$$args) {
								get$3(event_handler)?.apply(this, $$args);
							}));

							event('keypress', span_1, preventDefault((e) => {
								e.key == "Enter" && unselectItem(get$3(tagItem));
							}));

							append($$anchor, div_3);
						}
					);

					reset(div_2);
					template_effect(() => toggle_class(div_2, 'is-active', get$3(draggingOver) === get$3(i)));
					animation(div_2, () => flip, () => ({ duration: 200 }));
					transition(3, div_2, () => fade, () => ({ duration: 200 }));
					event('dragstart', div_2, (event) => dragstart(event, get$3(i)));
					event('dragover', div_2, (event) => dragover(event, get$3(i)));
					event('dragleave', div_2, (event) => dragleave(event, get$3(i)));
					event('drop', div_2, (event) => drop(event, get$3(i)));
					append($$anchor, div_2);
				});

				append($$anchor, fragment_2);
			};

			if_block(node_3, ($$render) => {
				if (multiple() && get$3(hasSelection)) $$render(consequent_2);
			});
		}

		var input_1 = sibling(node_3, 2);

		remove_input_defaults(input_1);

		let attributes;

		bind_this(input_1, ($$value) => set(input, $$value), () => get$3(input));

		var node_6 = sibling(input_1, 2);

		{
			var consequent_3 = ($$anchor) => {
				var span_2 = root_8$2();
				var node_7 = child(span_2);

				html(node_7, clearText);
				reset(span_2);
				event('click', span_2, clear);

				event('keypress', span_2, (e) => {
					e.key == "Enter" && clear();
				});

				append($$anchor, span_2);
			};

			if_block(node_6, ($$render) => {
				if (get$3(clearable)) $$render(consequent_3);
			});
		}

		reset(div_1);
		bind_this(div_1, ($$value) => set(inputContainer, $$value), () => get$3(inputContainer));

		var div_4 = sibling(div_1, 2);
		var node_8 = child(div_4);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_3 = root_9$1();
				var node_9 = first_child(fragment_3);

				slot(
					node_9,
					$$props,
					'dropdown-header',
					{
						get nbItems() {
							return get$3(filteredListItems).length;
						},
						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					null
				);

				var node_10 = sibling(node_9, 2);

				each(node_10, 1, () => get$3(filteredListItems), index$d, ($$anchor, listItem, i) => {
					var fragment_4 = comment();
					var node_11 = first_child(fragment_4);

					{
						var consequent_5 = ($$anchor) => {
							var div_5 = root_11$2();
							var node_12 = child(div_5);

							slot(
								node_12,
								$$props,
								'item',
								{
									get item() {
										return get$3(listItem).item;
									},
									get label() {
										return get$3(listItem).highlighted ? get$3(listItem).highlighted : get$3(listItem).label;
									}
								},
								($$anchor) => {
									var fragment_5 = comment();
									var node_13 = first_child(fragment_5);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_6 = comment();
											var node_14 = first_child(fragment_6);

											html(node_14, () => get$3(listItem).highlighted);
											append($$anchor, fragment_6);
										};

										var alternate_1 = ($$anchor) => {
											var fragment_7 = comment();
											var node_15 = first_child(fragment_7);

											html(node_15, () => get$3(listItem).label);
											append($$anchor, fragment_7);
										};

										if_block(node_13, ($$render) => {
											if (get$3(listItem).highlighted) $$render(consequent_4); else $$render(alternate_1, false);
										});
									}

									append($$anchor, fragment_5);
								}
							);

							reset(div_5);

							template_effect(
								($0) => {
									toggle_class(div_5, 'selected', i === get$3(highlightIndex));
									toggle_class(div_5, 'confirmed', $0);
								},
								[
									() => isConfirmed(get$3(listItem).item)
								],
								derived_safe_equal
							);

							event('click', div_5, () => onListItemClick(get$3(listItem)));

							event('keypress', div_5, (e) => {
								e.key == "Enter" && onListItemClick(get$3(listItem));
							});

							event('pointerenter', div_5, () => {
								set(highlightIndex, i);
							});

							append($$anchor, div_5);
						};

						if_block(node_11, ($$render) => {
							if (get$3(listItem) && (maxItemsToShowInList() <= 0 || i < maxItemsToShowInList())) $$render(consequent_5);
						});
					}

					append($$anchor, fragment_4);
				});

				var node_16 = sibling(node_10, 2);

				slot(
					node_16,
					$$props,
					'dropdown-footer',
					{
						get nbItems() {
							return get$3(filteredListItems).length;
						},
						get maxItemsToShowInList() {
							return maxItemsToShowInList();
						}
					},
					($$anchor) => {
						var fragment_8 = comment();
						var node_17 = first_child(fragment_8);

						{
							var consequent_7 = ($$anchor) => {
								var fragment_9 = comment();
								var node_18 = first_child(fragment_9);

								{
									var consequent_6 = ($$anchor) => {
										var div_6 = root_17();
										var text_4 = child(div_6);

										reset(div_6);

										template_effect(() => set_text(text_4, `...${get$3(filteredListItems).length - maxItemsToShowInList() ?? ''}
              ${moreItemsText() ?? ''}`));

										append($$anchor, div_6);
									};

									if_block(node_18, ($$render) => {
										if (moreItemsText()) $$render(consequent_6);
									});
								}

								append($$anchor, fragment_9);
							};

							if_block(node_17, ($$render) => {
								if (maxItemsToShowInList() > 0 && get$3(filteredListItems).length > maxItemsToShowInList()) $$render(consequent_7);
							});
						}

						append($$anchor, fragment_8);
					}
				);

				append($$anchor, fragment_3);
			};

			var alternate_4 = ($$anchor) => {
				var fragment_10 = comment();
				var node_19 = first_child(fragment_10);

				{
					var consequent_9 = ($$anchor) => {
						var div_7 = root_19$2();
						var node_20 = child(div_7);

						slot(
							node_20,
							$$props,
							'loading',
							{
								get loadingText() {
									return loadingText();
								}
							},
							($$anchor) => {
								var text_5 = text();

								template_effect(() => set_text(text_5, loadingText()));
								append($$anchor, text_5);
							}
						);

						reset(div_7);
						append($$anchor, div_7);
					};

					var alternate_3 = ($$anchor) => {
						var fragment_12 = comment();
						var node_21 = first_child(fragment_12);

						{
							var consequent_10 = ($$anchor) => {
								var div_8 = root_22$1();
								var node_22 = child(div_8);

								slot(
									node_22,
									$$props,
									'create',
									{
										get createText() {
											return createText();
										}
									},
									($$anchor) => {
										var text_6 = text();

										template_effect(() => set_text(text_6, createText()));
										append($$anchor, text_6);
									}
								);

								reset(div_8);
								event('click', div_8, selectItem);

								event('keypress', div_8, (e) => {
									e.key == "Enter" && selectItem();
								});

								append($$anchor, div_8);
							};

							var alternate_2 = ($$anchor) => {
								var fragment_14 = comment();
								var node_23 = first_child(fragment_14);

								{
									var consequent_11 = ($$anchor) => {
										var div_9 = root_25();
										var node_24 = child(div_9);

										slot(
											node_24,
											$$props,
											'no-results',
											{
												get noResultsText() {
													return noResultsText();
												}
											},
											($$anchor) => {
												var text_7 = text();

												template_effect(() => set_text(text_7, noResultsText()));
												append($$anchor, text_7);
											}
										);

										reset(div_9);
										append($$anchor, div_9);
									};

									if_block(
										node_23,
										($$render) => {
											if (noResultsText()) $$render(consequent_11);
										},
										true
									);
								}

								append($$anchor, fragment_14);
							};

							if_block(
								node_21,
								($$render) => {
									if (create()) $$render(consequent_10); else $$render(alternate_2, false);
								},
								true
							);
						}

						append($$anchor, fragment_12);
					};

					if_block(
						node_19,
						($$render) => {
							if (get$3(loading) && loadingText()) $$render(consequent_9); else $$render(alternate_3, false);
						},
						true
					);
				}

				append($$anchor, fragment_10);
			};

			if_block(node_8, ($$render) => {
				if (get$3(filteredListItems) && get$3(filteredListItems).length > 0) $$render(consequent_8); else $$render(alternate_4, false);
			});
		}

		reset(div_4);
		bind_this(div_4, ($$value) => set(list, $$value), () => get$3(list));
		reset(div);

		template_effect(() => {
			set_class(div, `${(className() ? className() : '') ?? ''} autocomplete select is-fullwidth ${uniqueId ?? ''} svelte-75ckfb`);
			toggle_class(div, 'hide-arrow', hideArrow() || !items().length);
			toggle_class(div, 'is-multiple', multiple());
			toggle_class(div, 'show-clear', get$3(clearable));
			toggle_class(div, 'is-loading', showLoadingIndicator() && get$3(loading));
			set_attribute(select, 'name', selectName());
			set_attribute(select, 'id', selectId());
			select.multiple = multiple();

			attributes = set_attributes(
				input_1,
				attributes,
				{
					type: 'text',
					class: `${(inputClassName() ? inputClassName() : '') ?? ''} ${(noInputStyles() ? '' : 'input autocomplete-input') ?? ''}`,
					id: inputId() ? inputId() : "",
					autocomplete: html5autocomplete() ? "on" : autocompleteOffValue(),
					placeholder: placeholder(),
					name: name(),
					disabled: disabled(),
					required: required(),
					title: title(),
					readonly: readonly() || get$3(locked),
					tabindex: tabindex(),
					...$$restProps
				},
				'svelte-75ckfb'
			);

			set_class(div_4, `${(dropdownClassName() ? dropdownClassName() : '') ?? ''} autocomplete-list ${(get$3(showList) ? '' : 'hidden') ?? ''}
    is-fullwidth svelte-75ckfb`);
		});

		bind_value(input_1, text$1);
		event('input', input_1, onInput);
		event('focus', input_1, onFocusInternal);
		event('blur', input_1, onBlurInternal);
		event('keydown', input_1, onKeyDown);
		event('click', input_1, onInputClick);
		event('keypress', input_1, onKeyPress);
		event('dragover', input_1, (event) => dragover(event, selectedItem().length - 1));
		event('drop', input_1, (event) => drop(event, selectedItem().length - 1));
		append($$anchor, div);
		bind_prop($$props, 'highlightFilter', highlightFilter);
		return pop({ highlightFilter });
	}

	var root_1$q = template(`<p> </p>`);
	var root_2$k = template(`<input>`);

	function Ui_textfield($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "textfield"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			size = prop($$props, 'size', 3, "normal"),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'required',
				'disabled',
				'size',
				'readonly',
				'valid',
				'color',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$q();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$k();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-textfield-${fieldname() ?? ''}`,
					class: `input ${(size() ? `is-${size()}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'text',
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_3$f = template(`<p> </p>`);

	function Ui_autocomplete($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * More properties at https://github.com/pstanoev/simple-svelte-autocomplete#properties
		 * @typedef {Object} Props
		 * @property {any} value
		 * @property {string} [placeholder = '']
		 * @property {string} [fieldname = 'autocomplete']
		 * @property {boolean} [disabled = false]
		 * @property {boolean} [readonly = false]
		 * @property {boolean} [required = false]
		 * @property {boolean} [valid = true]
		 * @property {function} [onchange]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "autocomplete"),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			required = prop($$props, 'required', 3, false),
			valid = prop($$props, 'valid', 3, true),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'disabled',
				'readonly',
				'required',
				'valid',
				'onchange'
			]);

		let invalid = derived(() => !valid());

		function onChange(val) {
			if (onchange()) {
				onchange()({
					value: snapshot(val),
					field: fieldname()
				});
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				const expression = derived(() => value() ? value().title : "");

				Ui_textfield($$anchor, spread_props(
					{
						get value() {
							return get$3(expression);
						},
						get fieldname() {
							return fieldname();
						},
						get placeholder() {
							return placeholder();
						}
					},
					() => others
				));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var p = root_3$f();
						var text = child(p, true);

						reset(p);
						template_effect(() => set_text(text, value() ? value()?.title ?? "" : ""));
						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						SimpleAutocomplete($$anchor, spread_props(
							{
								onChange,
								get placeholder() {
									return $LOCALE()[placeholder()];
								},
								get valid() {
									return valid();
								},
								get invalid() {
									return get$3(invalid);
								},
								get required() {
									return required();
								}
							},
							() => others,
							{
								get selectedItem() {
									return value();
								},
								set selectedItem($$value) {
									value($$value);
								}
							}
						));
					};

					if_block(
						node_1,
						($$render) => {
							if (readonly()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (disabled()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$y = template(`<input>`);

	function Ui_color($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "color"),
			disabled = prop($$props, 'disabled', 3, false),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'size',
				'color',
				'disabled',
				'required',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var input = root$y();

		remove_input_defaults(input);

		let attributes;

		template_effect(() => attributes = set_attributes(input, attributes, {
			id: `form-field-color-${fieldname() ?? ''}`,
			class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
			type: 'color',
			name: fieldname(),
			invalid: get$3(invalid),
			required: required(),
			readonly: readonly(),
			disabled: disabled(),
			placeholder: $LOCALE()[placeholder()],
			autocomplete: fieldname(),
			'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
			'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
			...optionalProps,
			...others
		}));

		bind_value(input, value);
		append($$anchor, input);
		pop();
		$$cleanup();
	}

	var root$x = template(`<label><!></label>`);

	function Ui_label($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} for
		 * @property {string} [label='label']
		 * @property {string} [class = '']
		 */
		/** @type {Props} */
		let label = prop($$props, 'label', 3, "label"),
			labelClass = prop($$props, 'class', 3, "");

		var label_1 = root$x();
		var node = child(label_1);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.children);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var text$1 = text();

				template_effect(() => set_text(text$1, label() ? $LOCALE()[label()] : ""));
				append($$anchor, text$1);
			};

			if_block(node, ($$render) => {
				if ($$props.children) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(label_1);

		template_effect(() => {
			set_class(label_1, `label ${labelClass() ?? ''}`);
			set_attribute(label_1, 'for', $$props.for);
		});

		append($$anchor, label_1);
		pop();
		$$cleanup();
	}

	var root_3$e = template(`<input> `, 1);

	function Ui_checkbox($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, false),
			label = prop($$props, 'label', 3, "checkbox"),
			fieldname = prop($$props, 'fieldname', 3, "checkbox"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			labelClass = prop($$props, 'labelClass', 3, "checkbox"),
			reactOn = prop($$props, 'reactOn', 19, () => ["onchange", "oninput"]),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'label',
				'fieldname',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class',
				'labelClass',
				'reactOn'
			]);

		let invalid = derived(() => !valid());
		const id = `form-field-checkbox-${fieldname()}`;
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange, undefined, { id: $$props?.id });

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		Ui_label($$anchor, {
			get class() {
				return labelClass();
			},
			get disabled() {
				return disabled();
			},
			for: id,
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_boolean($$anchor, {
							get LC_TRUE() {
								return label();
							},
							get LC_FALSE() {
								return label();
							},
							get value() {
								return value();
							}
						});
					};

					var alternate = ($$anchor) => {
						var fragment_3 = root_3$e();
						var input = first_child(fragment_3);

						remove_input_defaults(input);

						let attributes;
						var text = sibling(input);

						template_effect(() => {
							attributes = set_attributes(input, attributes, {
								id,
								class: classes(),
								type: 'checkbox',
								name: fieldname(),
								required: required(),
								readonly: readonly(),
								invalid: get$3(invalid),
								disabled: disabled(),
								'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
								'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
								...optionalProps,
								...others
							});

							set_text(text, ` ${$LOCALE()[label()] ?? ''}`);
						});

						bind_checked(input, value);
						append($$anchor, fragment_3);
					};

					if_block(node, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	function Ui_checkbox_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 27, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "checkbox-list"),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'fieldname'
			]);

		function onchange(data, ev, additional) {
			if (!additional) {
				return;
			}

			console.log(data, additional.id);

			if (data.value) {
				if (!value().includes(additional.id)) {
					value().push(additional.id);
				}
			} else {
				if (value().includes(additional.id)) {
					value().splice(value().indexOf(additional.id), 1);
				}
			}

			$$props?.onchange(
				{
					field: fieldname(),
					value: snapshot(value())
				},
				ev,
				additional
			);
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, variants, (item) => item.id, ($$anchor, item) => {
			const expression = derived(() => `${fieldname()}-${get$3(item).id}`);
			const expression_1 = derived(() => value().includes(get$3(item).id));

			Ui_checkbox($$anchor, spread_props(() => others, () => get$3(item), {
				get fieldname() {
					return get$3(expression);
				},
				get value() {
					return get$3(expression_1);
				},
				onchange
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$p = template(`<p><time> </time></p>`);
	var root_2$j = template(`<input>`);

	function Ui_date($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy(new Date())),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "datetime"),
			pattern = prop($$props, 'pattern', 3, "d{4}-d{2}-d{2}"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'pattern',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		onMount(() => {
			if (value() instanceof Date) {
				value(value().toISOString().split("T")[0]);
			} else if (value().indexOf("T") > 0) {
				value(value().split("T")[0]);
			}
		});

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$p();
				var time = child(p);
				var text = child(time, true);

				reset(time);
				reset(p);

				template_effect(
					($0) => {
						set_attribute(time, 'datetime', value());
						set_text(text, $0);
					},
					[
						() => UICommon$1.tryFormatLocaleDateTime(value())
					]
				);

				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$j();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-date-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'date',
					name: fieldname(),
					invalid: get$3(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					pattern: pattern(),
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$i = template(`<p> </p>`);
	var root_3$d = template(`<input>`);

	function Ui_datetime_in_tz($$anchor, $$props) {
		push($$props, true);

		function removeMsFromDate(isoDate, markAsZULU = false) {
			return isoDate.split(".")[0] + (markAsZULU ? "" : "Z");
		}

		function removeSecFromDate(isoDate, markAsZULU = false) {
			return isoDate.slice(0, isoDate.lastIndexOf(":")) + (markAsZULU ? "" : "Z");
		}

		function shiftDatetime(isoDate, shift) {
			try {
				const dateUtc = new Date(markAsZULU(isoDate)).getTime();
				const offset = shift * -60000;

				if (dateIsValid(dateUtc + offset)) {
					const newDate = new Date(dateUtc + offset);
					const newIsoDate = newDate.toISOString();

					return removeSecFromDate(removeMsFromDate(newIsoDate, true), true);
				}
			} catch {
				return;
			}
		}

		function markAsZULU(dateString) {
			return dateString && dateString.at(-1) !== "Z" ? dateString + "Z" : dateString;
		}

		function humanReadable(isoDate) {
			return UICommon$1.tryFormatLocaleDateTime(isoDate);
		}

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, 'fieldname', 3, "datetimeInTZ"),
			value = prop($$props, 'value', 31, () => proxy(removeSecFromDate(removeMsFromDate(new Date().toISOString())))),
			timezoneOffset = prop($$props, 'timezoneOffset', 3, 0);
			prop($$props, 'human', 3, true);
			let required = prop($$props, 'required', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'fieldname',
				'value',
				'timezoneOffset',
				'human',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class',
				'onchange'
			]);

		let shiftedValue = state(undefined),
			prevShiftedValue;

		const setShifted = (val) => {
			if (dateIsValid(val)) {
				prevShiftedValue = get$3(shiftedValue);
				set(shiftedValue, proxy(val));
			}
		};

		const resetShiftedValue = () => {
			set(shiftedValue, proxy(prevShiftedValue));
		};

		onMount(() => {
			setShifted(shiftDatetime(value(), timezoneOffset()));
		});

		const dateIsValid = (date) => {
			try {
				new Date(date);
				return true;
			} catch {
				return false;
			}
		};

		const changed = () => value() !== shiftDatetime(get$3(shiftedValue), -timezoneOffset());

		const dispatchChange = () => {
			setShifted(get$3(shiftedValue));
			value(markAsZULU(shiftDatetime(get$3(shiftedValue), -timezoneOffset())));

			onchange()({
				field: fieldname(),
				value: snapshot(value())
			});
		};

		function onChange(ev) {
			if (ev.currentTarget.value && get$3(shiftedValue) && dateIsValid(get$3(shiftedValue))) {
				if (changed()) {
					dispatchChange();
				}

				return true;
			} else {
				resetShiftedValue();
			}

			return false;
		}

		let invalid = derived(() => !valid());
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var p = root_2$i();
						var text = child(p, true);

						reset(p);

						template_effect(($0) => set_text(text, $0), [
							() => humanReadable(get$3(shiftedValue))
						]);

						append($$anchor, p);
					};

					var alternate = ($$anchor) => {
						var input = root_3$d();

						remove_input_defaults(input);

						let attributes;

						template_effect(() => attributes = set_attributes(input, attributes, {
							id: `form-field-datetime-in-timezone-${fieldname() ?? ''}`,
							class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
							type: 'datetime-local',
							name: fieldname(),
							invalid: get$3(invalid),
							disabled: disabled(),
							required: required(),
							readonly: readonly(),
							autocomplete: fieldname(),
							onchange: onChange,
							onblur: onChange,
							oninput: onChange,
							'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
							'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
							...others
						}));

						bind_value(input, () => get$3(shiftedValue), ($$value) => set(shiftedValue, $$value));
						append($$anchor, input);
					};

					if_block(node_1, ($$render) => {
						if (readonly()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (get$3(shiftedValue)) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$o = template(`<p> </p>`);
	var root_2$h = template(`<input>`);

	function Ui_email($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "email"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$o();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$h();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-email-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'email',
					name: fieldname(),
					invalid: get$3(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root$w = template(`<input type="hidden">`);

	function Ui_hidden($$anchor, $$props) {
		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			fieldname = prop($$props, 'fieldname', 3, "hidden"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'fieldname',
				'required',
				'readonly'
			]);

		var input = root$w();

		remove_input_defaults(input);

		template_effect(() => {
			set_attribute(input, 'id', `form-field-hidden-${fieldname() ?? ''}`);
			input.required = required();
			input.readOnly = readonly();
			set_attribute(input, 'name', fieldname());
			set_attribute(input, 'others', others);
		});

		bind_value(input, value);
		append($$anchor, input);
	}

	var root_1$n = template(`<p> </p>`);
	var root_2$g = template(`<textarea></textarea>`);

	function Ui_textarea($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "textarea"),
			rows = prop($$props, 'rows', 3, 10),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'rows',
				'size',
				'color',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$n();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var textarea = root_2$g();

				remove_textarea_child(textarea);

				let attributes;

				template_effect(() => attributes = set_attributes(textarea, attributes, {
					id: `form-field-textarea-${fieldname() ?? ''}`,
					class: `textarea ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					placeholder: $LOCALE()[placeholder()],
					rows: rows(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(textarea, value);
				append($$anchor, textarea);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_json_area($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy({})),
			fieldname = prop($$props, 'fieldname', 3, "jsonarea"),
			valid = prop($$props, 'valid', 15, true),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => {}),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur"]),
			colorValid = prop($$props, 'colorValid', 3, "success"),
			colorInvalid = prop($$props, 'colorInvalid', 3, "danger"),
			validationDelay = prop($$props, 'validationDelay', 3, 1000),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'fieldname',
				'valid',
				'onchange',
				'onerror',
				'reactOn',
				'colorValid',
				'colorInvalid',
				'validationDelay'
			]);

		let _value = state("{}");

		onMount(() => {
			try {
				set(_value, proxy(JSON.stringify(snapshot(value()), null, 4)));
			} catch {
				set(_value, "{}");
			}
		});

		let delayedValidation;

		function onChange(val) {
			try {
				value(JSON.parse(val));
				valid(true);

				onchange()({
					field: fieldname(),
					value: snapshot(value())
				});
			} catch(error) {
				valid(false);
				onerror()(error);
			}

			return true;
		}

		function delayedOnChange(data) {
			const { value: val } = data;

			if (delayedValidation) {
				clearTimeout(delayedValidation);
			}

			delayedValidation = setTimeout(
				() => {
					onChange(val);
				},
				validationDelay()
			);
		}

		let color = derived(() => valid() ? colorValid() : colorInvalid());

		Ui_textarea($$anchor, spread_props(
			{
				get fieldname() {
					return fieldname();
				},
				onchange: delayedOnChange,
				get reactOn() {
					return reactOn();
				},
				get valid() {
					return valid();
				},
				get color() {
					return get$3(color);
				}
			},
			() => others,
			{
				get value() {
					return get$3(_value);
				},
				set value($$value) {
					set(_value, proxy($$value));
				}
			}
		));

		pop();
	}

	var _lib = /*#__PURE__*/new WeakMap();
	let Lib = /*#__PURE__*/function () {
	  function Lib(seedLib) {
	    _classCallCheck(this, Lib);
	    _classPrivateFieldInitSpec(this, _lib, {});
	    if (seedLib instanceof Lib) {
	      this.import(seedLib.getContent());
	    }
	  }

	  /**
	   *
	   * @params {string}  mode what to do if element exists [replace|add|skip]
	   */
	  return _createClass(Lib, [{
	    key: "add",
	    value: function add(name, comp, mode = "replace") {
	      if (this.contains(name)) {
	        if (mode === "replace") {
	          _classPrivateFieldGet2(_lib, this)[name] = comp;
	        } else if (mode === "add") {
	          _classPrivateFieldGet2(_lib, this)[name] = Object.assign(_classPrivateFieldGet2(_lib, this)[name], comp);
	        }
	      } else {
	        _classPrivateFieldGet2(_lib, this)[name] = comp;
	      }
	    }
	  }, {
	    key: "get",
	    value: function get(name) {
	      return _classPrivateFieldGet2(_lib, this)[name];
	    }
	  }, {
	    key: "contains",
	    value: function contains(name) {
	      return Object.hasOwn(_classPrivateFieldGet2(_lib, this), name);
	    }
	  }, {
	    key: "import",
	    value: function _import(bulk, mode = "replace") {
	      for (let f in bulk) {
	        this.add(f, bulk[f], mode);
	      }
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return Object.keys(_classPrivateFieldGet2(_lib, this)).length === 0;
	    }
	  }, {
	    key: "getContent",
	    value: function getContent() {
	      return {
	        ..._classPrivateFieldGet2(_lib, this)
	      };
	    }
	  }]);
	}();

	/*
	 * Библиотека UI конструкторов
	 */

	const COMPONENTS$1 = new Lib();
	const FIELDS$1 = new Lib();
	const VARIANTS$1 = new Lib();

	var root$v = template(`<!> <!>`, 1);

	function Ui_title($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [id = `title-${Math.random()}`]
		 * @property {string}   [title = '']
		 * @property {string}   [subtitle]
		 * @property {number}   [size = 1]
		 * @property {number}   [subsize]
		 * @property {boolean}  [spaced = false]
		 * @property {string}   [align = 'left']
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 19, () => `title-${Math.random()}`),
			title = prop($$props, 'title', 3, ""),
			size = prop($$props, 'size', 3, 1),
			spaced = prop($$props, 'spaced', 3, false),
			align = prop($$props, 'align', 3, "left");

		const scrollToTop = (options = UICommon$1.SCROLL_OPTIONS) => {
			setTimeout(
				() => {
					document.getElementById(id()).scrollIntoView(options);
				},
				100
			);
		};

		let size2 = derived(() => $$props.subsize ? $$props.subsize : parseInt(size()) < 6 ? parseInt(size()) + 1 : size());
		let spacedStyle = derived(() => spaced() ? "has-text-justified" : "");
		let resultTitle = derived(() => `<h${size()} id="${id()}" style="text-align: ${align()};" class="title ${get$3(spacedStyle)} is-${size()}">${$LOCALE()[title()]}</h${size()}>`);
		let resultSubtitle = derived(() => `<h${get$3(size2)} id="${id()}" style="text-align: ${align()};" class="subtitle is-${get$3(size2)}">${$LOCALE()[$$props.subtitle]}</h${get$3(size2)}>`);
		var fragment = root$v();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				html(node_1, () => get$3(resultTitle));
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_3 = first_child(fragment_2);

				html(node_3, () => get$3(resultSubtitle));
				append($$anchor, fragment_2);
			};

			if_block(node_2, ($$render) => {
				if ($$props.subtitle) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);

		var $$pop = pop({ scrollToTop });

		$$cleanup();
		return $$pop;
	}

	function Ui_list_empty_placeholder($$anchor, $$props) {
		/**
		 * @typedef {object}    Props
		 * @property {string}   [title = "not-node:empty_list_placeholder"]
		 * @property {number}   [size = 4]
		 * @property {string}   [align = 'center']
		 */
		/**
		 * @type Props
		 */
		let title = prop($$props, 'title', 3, "not-node:empty_list_placeholder"),
			size = prop($$props, 'size', 3, 4),
			align = prop($$props, 'align', 3, "center"),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'title',
				'size',
				'align'
			]);

		Ui_title($$anchor, spread_props(
			{
				get title() {
					return title();
				},
				get size() {
					return size();
				},
				get align() {
					return align();
				}
			},
			() => others
		));
	}

	var root_1$m = template(`<span class="icon"><i></i></span>`);
	var root_4$c = template(`<span> </span>`);
	var root_2$f = template(`<!> <!> <!> <!>`, 1);
	var root_6$9 = template(` <!>`, 1);
	var root$u = template(`<a><!></a>`);

	function Ui_link($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		const sideIcon = ($$anchor) => {
			var span = root_1$m();
			var i = child(span);

			reset(span);
			template_effect(() => set_class(i, `fas fa-${$$props.icon ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`));
			append($$anchor, span);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [title] - attributes
		 * @property {string} [url]
		 * @property {any} download
		 * @property {string} [target]
		 * @property {any} rel
		 * @property {boolean} [light] - visual
		 * @property {boolean} [loading]
		 * @property {boolean} [raised]
		 * @property {boolean} [outlined]
		 * @property {boolean} [inverted]
		 * @property {boolean} [rounded]
		 * @property {boolean} [button]
		 * @property {string} [state]
		 * @property {string} [type]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {string} [class]
		 * @property {boolean} [icon] - icons
		 * @property {string} [iconSide]
		 * @property {any} [action]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			url = prop($$props, 'url', 3, ""),
			target = prop($$props, 'target', 3, "_blank"),
			light = prop($$props, 'light', 3, false),
			loading = prop($$props, 'loading', 3, false),
			raised = prop($$props, 'raised', 3, false),
			outlined = prop($$props, 'outlined', 3, false),
			inverted = prop($$props, 'inverted', 3, false),
			rounded = prop($$props, 'rounded', 3, false),
			button = prop($$props, 'button', 3, true),
			activeState = prop($$props, 'state', 3, ""),
			type = prop($$props, 'type', 3, ""),
			color = prop($$props, 'color', 3, ""),
			size = prop($$props, 'size', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			iconSide = prop($$props, 'iconSide', 3, "right");

		var a = root$u();

		a.__click = function (...$$args) {
			($$props.action || $$props.onclick)?.apply(this, $$args);
		};

		var node = child(a);

		{
			var consequent_3 = ($$anchor) => {
				var fragment = root_2$f();
				var node_1 = first_child(fragment);

				{
					var consequent = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_1, ($$render) => {
						if (iconSide() === "left") $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						var span_1 = root_4$c();
						var text = child(span_1, true);

						reset(span_1);
						template_effect(() => set_text(text, $LOCALE()[title()]));
						append($$anchor, span_1);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_1);
					});
				}

				var node_3 = sibling(node_2, 2);

				snippet(node_3, () => $$props.children ?? noop);

				var node_4 = sibling(node_3, 2);

				{
					var consequent_2 = ($$anchor) => {
						sideIcon($$anchor);
					};

					if_block(node_4, ($$render) => {
						if (iconSide() === "right") $$render(consequent_2);
					});
				}

				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = root_6$9();
				var text_1 = first_child(fragment_3, true);
				var node_5 = sibling(text_1);

				snippet(node_5, () => $$props.children ?? noop);
				template_effect(() => set_text(text_1, $LOCALE()[title()]));
				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if ($$props.icon) $$render(consequent_3); else $$render(alternate, false);
			});
		}

		reset(a);

		template_effect(() => {
			set_attribute(a, 'href', url());
			set_attribute(a, 'target', target());
			set_attribute(a, 'download', $$props.download);
			set_attribute(a, 'rel', $$props.rel);
			set_class(a, `${classes() ?? ''} ${(activeState() ? `is-${activeState()}` : '') ?? ''} ${(color() ? `is-${color()}` : '') ?? ''} ${(type() ? `is-${type()}` : '') ?? ''} ${(size() ? `is-${size()}` : '') ?? ''}`);
			toggle_class(a, 'button', button());
			toggle_class(a, 'is-light', light());
			toggle_class(a, 'is-inverted', inverted());
			toggle_class(a, 'is-outlined', outlined());
			toggle_class(a, 'is-raised', raised());
			toggle_class(a, 'is-rounded', rounded());
			toggle_class(a, 'is-loading', loading());
		});

		append($$anchor, a);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root_3$c = template(`<div><p class="control"><!></p></div>`);
	var root_4$b = template(`<div><!></div>`);

	function Ui_links($$anchor, $$props) {
		const listLinks = ($$anchor) => {
			var fragment = comment();
			var node = first_child(fragment);

			each(node, 17, values, (item) => item.id, ($$anchor, item) => {
				Ui_link($$anchor, spread_props(() => get$3(item), itemsProps));
			});

			append($$anchor, fragment);
		};

		/**
		 * @typedef {Object} Props
		 * @property {array}  [values=[]]
		 * @property {string} [classes='']
		 * @property {boolean} [centered=false]
		 * @property {boolean} [right=false]
		 * @property {boolean} [joined = false]
		 * @property {object}   [itemsProps = {}]
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			centered = prop($$props, 'centered', 3, false),
			right = prop($$props, 'right', 3, false),
			joined = prop($$props, 'joined', 3, true),
			itemsProps = prop($$props, 'itemsProps', 19, () => ({}));

		var fragment_2 = comment();
		var node_1 = first_child(fragment_2);

		{
			var consequent = ($$anchor) => {
				var div = root_3$c();
				var p = child(div);
				var node_2 = child(p);

				listLinks(node_2);
				reset(p);
				reset(div);

				template_effect(() => {
					set_class(div, `field has-addons ${classes() ?? ''}`);
					toggle_class(div, 'is-centered', centered());
					toggle_class(div, 'is-right', right());
				});

				append($$anchor, div);
			};

			var alternate = ($$anchor) => {
				var div_1 = root_4$b();
				var node_3 = child(div_1);

				listLinks(node_3);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, `buttons ${classes() ?? ''}`);
					toggle_class(div_1, 'is-centered', centered());
					toggle_class(div_1, 'is-right', right());
				});

				append($$anchor, div_1);
			};

			if_block(node_1, ($$render) => {
				if (joined()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment_2);
	}

	var root_1$l = template(`<!> <!>`, 1);
	var root_19$1 = template(`<figure class="image is-64x64"><img class="is-rounded"></figure>`);
	var root_24$1 = template(`<div class="list-item-controls"><!> <!></div>`);
	var root$t = template(`<div><!> <!> <!></div>`);

	function Ui_list_item($$anchor, $$props) {
		push($$props, true);

		const itemContent = ($$anchor) => {
			var fragment = root_1$l();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					snippet(node_1, () => $$props.titleRenderer, () => paramsSet);
					append($$anchor, fragment_1);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent_2 = ($$anchor) => {
							const expression = derived(() => callbackTemplate($$props.onclickTitle));

							Ui_clickable_div($$anchor, {
								class: 'list-item-title',
								get callback() {
									return get$3(expression);
								},
								children: ($$anchor, $$slotProps) => {
									var fragment_4 = comment();
									var node_3 = first_child(fragment_4);

									{
										var consequent_1 = ($$anchor) => {
											var fragment_5 = comment();
											var node_4 = first_child(fragment_5);

											component(node_4, UITitleComponent, ($$anchor, $$component) => {
												$$component($$anchor, spread_props(() => get$3(titleProps), titleComponentProps, { onchange }));
											});

											append($$anchor, fragment_5);
										};

										var alternate = ($$anchor) => {
											var text$1 = text();

											template_effect(() => set_text(text$1, $$props.title));
											append($$anchor, text$1);
										};

										if_block(node_3, ($$render) => {
											if (UITitleComponent()) $$render(consequent_1); else $$render(alternate, false);
										});
									}

									append($$anchor, fragment_4);
								},
								$$slots: { default: true }
							});
						};

						if_block(
							node_2,
							($$render) => {
								if ($$props.title) $$render(consequent_2);
							},
							true
						);
					}

					append($$anchor, fragment_2);
				};

				if_block(node, ($$render) => {
					if ($$props.titleRenderer) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			var node_5 = sibling(node, 2);

			{
				var consequent_3 = ($$anchor) => {
					var fragment_7 = comment();
					var node_6 = first_child(fragment_7);

					snippet(node_6, () => $$props.descriptionRenderer, () => paramsSet);
					append($$anchor, fragment_7);
				};

				var alternate_3 = ($$anchor) => {
					var fragment_8 = comment();
					var node_7 = first_child(fragment_8);

					{
						var consequent_5 = ($$anchor) => {
							const expression_1 = derived(() => callbackTemplate($$props.onclickDescription));

							Ui_clickable_div($$anchor, {
								class: 'list-item-description',
								get callback() {
									return get$3(expression_1);
								},
								children: ($$anchor, $$slotProps) => {
									var fragment_10 = comment();
									var node_8 = first_child(fragment_10);

									{
										var consequent_4 = ($$anchor) => {
											var fragment_11 = comment();
											var node_9 = first_child(fragment_11);

											component(node_9, () => $$props.descriptionComponent, ($$anchor, $$component) => {
												$$component($$anchor, spread_props(() => get$3(descriptionProps), descriptionComponentProps, {
													onchange,
													get onclick() {
														return $$props.onclick;
													}
												}));
											});

											append($$anchor, fragment_11);
										};

										var alternate_2 = ($$anchor) => {
											var text_1 = text();

											template_effect(() => set_text(text_1, $$props.description));
											append($$anchor, text_1);
										};

										if_block(node_8, ($$render) => {
											if ($$props.descriptionComponent) $$render(consequent_4); else $$render(alternate_2, false);
										});
									}

									append($$anchor, fragment_10);
								},
								$$slots: { default: true }
							});
						};

						if_block(
							node_7,
							($$render) => {
								if ($$props.description) $$render(consequent_5);
							},
							true
						);
					}

					append($$anchor, fragment_8);
				};

				if_block(node_5, ($$render) => {
					if ($$props.descriptionRenderer) $$render(consequent_3); else $$render(alternate_3, false);
				});
			}

			append($$anchor, fragment);
		};

		/**
		 * @typedef {Object} Props
		 * @property {number}   index
		 * @property {string|object} title
		 * @property {string|object} description
		 * @property {array} [actions = []]
		 * @property {array} [links = []]
		 * @property {array} [listActions = []]
		 * @property {array} [listLinks = []]
		 * @property {string} [class = '']
		 * @property {string} [commonClass = '']
		 * @property {string|object} [image = '']
		 * @property {object} value - value of item, will be passed to event handlers
		 * @property {string|number} [index = -1] - index in array 0-length
		 * @property {boolean} [first = false] - if first
		 * @property {boolean} [last = false] - if last
		 * @property {function} [titleComponent = UITitle] - customization
		 * @property {object} [titleComponentProps]
		 * @property {function} [descriptionComponent]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [imageComponent]
		 * @property {object} [imageComponentProps = {}]
		 * @property {function} [onclick]
		 * @property {function} [onclickTitle]
		 * @property {function} [onclickDescription]
		 * @property {function} [onclickImage]
		 * @property {function} [onclickContent]
		 */
		/** @type {Props} */
		let actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			listActions = prop($$props, 'listActions', 19, () => []),
			listLinks = prop($$props, 'listLinks', 19, () => []),
			classes = prop($$props, 'class', 3, ""),
			commonClass = prop($$props, 'commonClass', 3, ""),
			image = prop($$props, 'image', 3, ""),
			index = prop($$props, 'index', 19, () => -1),
			first = prop($$props, 'first', 3, false),
			last = prop($$props, 'last', 3, false),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			UITitleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({}));
			prop($$props, 'imageComponentProps', 19, () => ({}));

		function onClick() {
			$$props.onclick && $$props.onclick($$props.value);
		}

		let allActions = state(proxy([]));
		let allLinks = state(proxy([]));

		const callbackTemplate = (callback) => {
			return () => {
				if (callback) {
					onClick();
					callback && callback($$props.value);
				}
			};
		};

		user_effect(() => {
			set(allActions, proxy([...actions(), ...listActions()].map((btn, index) => {
				return {
					...btn,
					id: index,
					action: btn.action ? () => btn.action($$props.value) : undefined
				};
			})));

			set(allLinks, proxy([...links(), ...listLinks()].map((link, index) => {
				link.id = index;
				return link;
			})));
		});

		const paramsSet = {
			title: $$props.title,
			description: $$props.description,
			image: image(),
			value: $$props.value,
			index: index()
		};

		const clickableItemElementAttributes = {
			role: "button",
			tabindex: "0",
			onclick: onClick,
			onkeyup: (e) => {
				if (e && e.key == "Enter") {
					onClick();
				}
			}
		};

		const additionalElementAttributes = $$props.onclick ? clickableItemElementAttributes : {};
		let imageProps = state(proxy({}));
		let titleProps = state(proxy({}));
		let descriptionProps = state(proxy({}));

		user_effect(() => {
			if (typeof image() === "object") {
				set(imageProps, proxy({ ...image() }));
			} else {
				set(imageProps, proxy({ image: image() }));
			}
		});

		user_effect(() => {
			if (typeof $$props.title === "object") {
				set(titleProps, proxy({ ...$$props.title }));
			} else {
				set(titleProps, proxy({ title: $$props.title }));
			}
		});

		user_effect(() => {
			if (typeof $$props.description === "object") {
				set(descriptionProps, proxy({ ...$$props.description }));
			} else {
				set(descriptionProps, proxy({ description: $$props.description }));
			}
		});

		var div = root$t();
		let attributes;
		var node_10 = child(div);

		{
			var consequent_8 = ($$anchor) => {
				var fragment_13 = comment();
				var node_11 = first_child(fragment_13);

				{
					var consequent_6 = ($$anchor) => {
						var fragment_14 = comment();
						var node_12 = first_child(fragment_14);

						snippet(node_12, () => $$props.imageRenderer, () => paramsSet);
						append($$anchor, fragment_14);
					};

					var alternate_5 = ($$anchor) => {
						const expression_2 = derived(() => callbackTemplate($$props.onclickImage));

						Ui_clickable_div($$anchor, {
							class: 'list-item-image',
							get callback() {
								return get$3(expression_2);
							},
							children: ($$anchor, $$slotProps) => {
								var fragment_16 = comment();
								var node_13 = first_child(fragment_16);

								{
									var consequent_7 = ($$anchor) => {
										var fragment_17 = comment();
										var node_14 = first_child(fragment_17);

										component(node_14, () => $$props.imageComponent, ($$anchor, $$component) => {
											$$component($$anchor, spread_props(() => get$3(imageProps)));
										});

										append($$anchor, fragment_17);
									};

									var alternate_4 = ($$anchor) => {
										var figure = root_19$1();
										var img = child(figure);

										reset(figure);

										template_effect(() => {
											set_attribute(img, 'src', image());
											set_attribute(img, 'alt', $$props.title ? $$props.title?.title || $$props.title : image());
										});

										append($$anchor, figure);
									};

									if_block(node_13, ($$render) => {
										if ($$props.imageComponent) $$render(consequent_7); else $$render(alternate_4, false);
									});
								}

								append($$anchor, fragment_16);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_11, ($$render) => {
						if ($$props.imageRenderer) $$render(consequent_6); else $$render(alternate_5, false);
					});
				}

				append($$anchor, fragment_13);
			};

			if_block(node_10, ($$render) => {
				if (image()) $$render(consequent_8);
			});
		}

		var node_15 = sibling(node_10, 2);

		{
			var consequent_9 = ($$anchor) => {
				var fragment_18 = comment();
				var node_16 = first_child(fragment_18);

				component(node_16, () => $$props.listItemContentComponent, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(listItemContentComponentProps, {
						children: ($$anchor, $$slotProps) => {
							itemContent($$anchor);
						},
						$$slots: { default: true }
					}));
				});

				append($$anchor, fragment_18);
			};

			var alternate_6 = ($$anchor) => {
				const expression_3 = derived(() => callbackTemplate($$props.onclickContent));

				Ui_clickable_div($$anchor, {
					class: 'list-item-content',
					get callback() {
						return get$3(expression_3);
					},
					children: ($$anchor, $$slotProps) => {
						itemContent($$anchor);
					},
					$$slots: { default: true }
				});
			};

			if_block(node_15, ($$render) => {
				if ($$props.listItemContentComponent) $$render(consequent_9); else $$render(alternate_6, false);
			});
		}

		var node_17 = sibling(node_15, 2);

		{
			var consequent_12 = ($$anchor) => {
				var div_1 = root_24$1();
				var node_18 = child(div_1);

				{
					var consequent_10 = ($$anchor) => {
						Ui_buttons($$anchor, {
							get values() {
								return get$3(allActions);
							},
							right: true
						});
					};

					if_block(node_18, ($$render) => {
						if (get$3(allActions) && get$3(allActions).length) $$render(consequent_10);
					});
				}

				var node_19 = sibling(node_18, 2);

				{
					var consequent_11 = ($$anchor) => {
						Ui_links($$anchor, {
							get values() {
								return get$3(allLinks);
							},
							right: true
						});
					};

					if_block(node_19, ($$render) => {
						if (get$3(allLinks) && get$3(allLinks).length) $$render(consequent_11);
					});
				}

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_17, ($$render) => {
				if (get$3(allActions) && get$3(allActions).length || get$3(allLinks) && get$3(allLinks).length) $$render(consequent_12);
			});
		}

		reset(div);

		template_effect(() => {
			attributes = set_attributes(div, attributes, {
				...additionalElementAttributes,
				class: `list-item ${classes() ?? ''} ${commonClass() ?? ''} ${`list-item-at-${index()}` ?? ''}`
			});

			toggle_class(div, 'is-clickable', $$props.onclick);
			toggle_class(div, 'list-item-last', last());
			toggle_class(div, 'list-item-first', first());
			toggle_class(div, 'list-item-odd', index() % 2 === 1);
			toggle_class(div, 'list-item-even', index() % 2 === 0);
		});

		append($$anchor, div);
		pop();
	}

	function Ui_list_block($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}   [idFieldName = "id"]
		 * @property {array}    [items = []]
		 * @property {array}    [actions = []]
		 * @property {array}    [links = []]
		 * @property {string}   [itemClass = ""]
		 * @property {object}   [listItemContentComponent]
		 * @property {object}   [listItemContentComponentProps = {}]
		 * @property {function} [listItemRenderer]
		 * @property {function} [listItemComponent = UIListItem]
		 * @property {object}   [listItemComponentProps = {}]
		 * @property {function} [titleRenderer]
		 * @property {function} [titleComponent = UITitle]
		 * @property {object}   [titleComponentProps = { size: 6 }]
		 * @property {function} [descriptionRenderer]
		 * @property {function} [descriptionComponent]
		 * @property {object}   [descriptionComponentProps = {}]
		 * @property {function} [imageRenderer]
		 * @property {function} imageComponent
		 * @property {object}   [imageComponentProps = {}]
		 * @property {function} [onclick]
		 * @property {function} [onclickContent]
		 * @property {function} [onclickDescription]
		 * @property {function} [onclickImage]
		 * @property {function} [onclickTitle]
		 */
		/** @type {Props} */
		let idFieldName = prop($$props, 'idFieldName', 3, "id"),
			items = prop($$props, 'items', 19, () => []),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			itemClass = prop($$props, 'itemClass', 3, ""),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			UIListItemComponent = prop($$props, 'listItemComponent', 3, Ui_list_item),
			listItemComponentProps = prop($$props, 'listItemComponentProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 19, items, (item) => item[idFieldName()], ($$anchor, item, index) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					{
						var consequent = ($$anchor) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							snippet(node_3, () => $$props.listItemRenderer, () => get$3(item), () => get$3(index));
							append($$anchor, fragment_3);
						};

						var alternate = ($$anchor) => {
							var fragment_4 = comment();
							var node_4 = first_child(fragment_4);
							const expression = derived(() => get$3(index) === 0);
							const expression_1 = derived(() => get$3(index) === items().length - 1);

							component(node_4, UIListItemComponent, ($$anchor, $$component) => {
								$$component($$anchor, spread_props(
									listItemComponentProps,
									{
										get listItemContentComponent() {
											return $$props.listItemContentComponent;
										},
										get listItemContentComponentProps() {
											return listItemContentComponentProps();
										},
										get titleRenderer() {
											return $$props.titleRenderer;
										},
										get titleComponent() {
											return titleComponent();
										},
										get titleComponentProps() {
											return titleComponentProps();
										},
										get descriptionRenderer() {
											return $$props.descriptionRenderer;
										},
										get descriptionComponent() {
											return $$props.descriptionComponent;
										},
										get descriptionComponentProps() {
											return descriptionComponentProps();
										},
										get imageRenderer() {
											return $$props.imageRenderer;
										},
										get imageComponent() {
											return $$props.imageComponent;
										},
										get imageComponentProps() {
											return imageComponentProps();
										}
									},
									() => items()[get$3(index)],
									{
										get listActions() {
											return actions();
										},
										get listLinks() {
											return links();
										},
										get value() {
											return items()[get$3(index)].value;
										},
										get commonClass() {
											return itemClass();
										},
										get index() {
											return get$3(index);
										},
										get first() {
											return get$3(expression);
										},
										get last() {
											return get$3(expression_1);
										},
										get onclick() {
											return $$props.onclick;
										},
										get onclickContent() {
											return $$props.onclickContent;
										},
										get onclickDescription() {
											return $$props.onclickDescription;
										},
										get onclickImage() {
											return $$props.onclickImage;
										},
										get onclickTitle() {
											return $$props.onclickTitle;
										}
									}
								));
							});

							append($$anchor, fragment_4);
						};

						if_block(node_2, ($$render) => {
							if ($$props.listItemRenderer) $$render(consequent); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_1$k = template(`<div><!></div>`);

	function Ui_list($$anchor, $$props) {
		push($$props, true);

		//customization
		/**
		 * @typedef {Object} Props
		 * @property {string} [class = ""]
		 * @property {array} [items = []]
		 * @property {array} [actions = []]
		 * @property {array} [links = []]
		 * @property {boolean} [actionsVisible = false]
		 * @property {boolean} [itemsHoverable = false]
		 * @property {boolean} [overflowEllipsis = false]
		 * @property {boolean} [hiddenImages = false]
		 * @property {string} [itemClass = '']
		 * @property {number} itemLength
		 * @property {string} [idFieldName = 'id']
		 * @property {function} [emptyListPlaceholderComponent = UIListEmptyPlaceholder] - empty
		 * @property {object} [emptyListPlaceholderComponentProps = {}]
		 * @property {function} [listItemComponent = UIListItem] - item
		 * @property {object} [listItemComponentProps = {}]
		 * @property {function} [titleComponent = UITitle] - item parts
		 * @property {object} [titleComponentProps = {size: 6}]
		 * @property {function} [descriptionComponent]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [imageComponent]
		 * @property {object} [imageComponentProps = {}]
		 * @property {function} [onchange]                  callback
		 * @property {function} [onclick]                   callback
		 * @property {function} [onclickContent]            callback
		 * @property {function} [onclickDescription]        callback
		 * @property {function} [onclickImage]              callback
		 * @property {function} [onclickTitle]              callback
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			actionsVisible = prop($$props, 'actionsVisible', 3, false),
			itemsHoverable = prop($$props, 'itemsHoverable', 3, false),
			overflowEllipsis = prop($$props, 'overflowEllipsis', 3, false),
			hiddenImages = prop($$props, 'hiddenImages', 3, false),
			itemClass = prop($$props, 'itemClass', 3, ""),
			idFieldName = prop($$props, 'idFieldName', 3, "id"),
			UIEmptyListPlaceholderComponent = prop($$props, 'emptyListPlaceholderComponent', 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, 'emptyListPlaceholderComponentProps', 19, () => ({})),
			listItemContentComponentProps = prop($$props, 'listItemContentComponentProps', 19, () => ({})),
			listItemComponent = prop($$props, 'listItemComponent', 3, Ui_list_item),
			listItemComponentProps = prop($$props, 'listItemComponentProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 6 })),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({}));

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$k();
				var node_1 = child(div);

				Ui_list_block(node_1, {
					get items() {
						return items();
					},
					get itemClass() {
						return itemClass();
					},
					get listItemContentComponent() {
						return $$props.listItemContentComponent;
					},
					get listItemContentComponentProps() {
						return listItemContentComponentProps();
					},
					get listItemRenderer() {
						return $$props.listItemRenderer;
					},
					get listItemComponent() {
						return listItemComponent();
					},
					get listItemComponentProps() {
						return listItemComponentProps();
					},
					get idFieldName() {
						return idFieldName();
					},
					get titleRenderer() {
						return $$props.titleRenderer;
					},
					get titleComponent() {
						return titleComponent();
					},
					get titleComponentProps() {
						return titleComponentProps();
					},
					get descriptionRenderer() {
						return $$props.descriptionRenderer;
					},
					get descriptionComponent() {
						return $$props.descriptionComponent;
					},
					get descriptionComponentProps() {
						return descriptionComponentProps();
					},
					get imageRenderer() {
						return $$props.imageRenderer;
					},
					get imageComponent() {
						return $$props.imageComponent;
					},
					get imageComponentProps() {
						return imageComponentProps();
					},
					get actions() {
						return actions();
					},
					get links() {
						return links();
					},
					get onchange() {
						return $$props.onchange;
					},
					get onclick() {
						return $$props.onclick;
					},
					get onclickContent() {
						return $$props.onclickContent;
					},
					get onclickDescription() {
						return $$props.onclickDescription;
					},
					get onclickImage() {
						return $$props.onclickImage;
					},
					get onclickTitle() {
						return $$props.onclickTitle;
					}
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, 'style', $$props.itemLength ? `--length: ${$$props.itemLength};` : "");
					set_class(div, `list ${classes() ?? ''}`);
					toggle_class(div, 'has-visible-pointer-controls', actionsVisible());
					toggle_class(div, 'has-hoverable-list-items', itemsHoverable());
					toggle_class(div, 'has-overflow-ellipsis', overflowEllipsis());
					toggle_class(div, 'has-hidden-images', hiddenImages());
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_2 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_2 = comment();
						var node_3 = first_child(fragment_2);

						snippet(node_3, () => $$props.emptyListRenderer, emptyListPlaceholderComponentProps);
						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_4 = first_child(fragment_3);

						component(node_4, UIEmptyListPlaceholderComponent, ($$anchor, $$component) => {
							$$component($$anchor, spread_props(emptyListPlaceholderComponentProps));
						});

						append($$anchor, fragment_3);
					};

					if_block(
						node_2,
						($$render) => {
							if ($$props.emptyListRenderer) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$s = template(`<!> <!>`, 1);

	function Ui_list_of_models($$anchor, $$props) {
		push($$props, true);

		//field props
		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted] - svelte-ignore unused-export-let
		 * @property {any} [value]
		 * @property {string} [placeholder]
		 * @property {string} [fieldname]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid] - validation
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 * @property {string} [modelName] - model bindings
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId] - presentation
		 * @property {string} [optionTitle]
		 * @property {string} [selectorUI] - selector UI to add new item to list
		 * @property {any} [selectorUIProps]
		 * @property {string} [itemUI] - list item UI to present in readonly or editable variants
		 * @property {any} [itemUIProps]
		 * @property {any} [transformValueItemToListItem]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 31, () => proxy([])),
			placeholder = prop($$props, 'placeholder', 15, ""),
			fieldname = prop($$props, 'fieldname', 15, "selectFromModel"),
			required = prop($$props, 'required', 15, true),
			readonly = prop($$props, 'readonly', 3, false),
			multiple = prop($$props, 'multiple', 15, false),
			size = prop($$props, 'size', 15, 8),
			valid = prop($$props, 'valid', 15, true),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			selectorUI = prop($$props, 'selectorUI', 3, "UISelectFromModelOnDemandInline"),
			selectorUIProps = prop($$props, 'selectorUIProps', 19, () => ({})),
			itemUI = prop($$props, 'itemUI', 3, "UIListItem"),
			itemUIProps = prop($$props, 'itemUIProps', 19, () => ({})),
			transformValueItemToListItem = prop($$props, 'transformValueItemToListItem', 3, (item) => {
				return item
					? {
						id: item._id,
						title: item.title,
						description: item.description,
						value: item
					}
					: undefined;
			});

		function addItem(item) {
			if (!Array.isArray(value())) {
				value([]);
			}

			value().push(item);
			value(value());
		}

		let items = derived(() => value().map ? value().map(transformValueItemToListItem()) : []);

		const ACTIONS = [
			{
				action(listItem) {
					const val = listItem.value;
					const itemIndex = value().findIndex((valueItem) => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex - 1);
						value(valCopy);
					}
				},
				title: "",
				icon: "arrow-up",
				color: "normal"
			},
			{
				action: (listItem) => {
					const val = listItem.value;
					const itemIndex = value().findIndex((valueItem) => valueItem === val);

					if (itemIndex > -1) {
						const valCopy = [...value()];

						notCommon$1.moveItem(valCopy, itemIndex, itemIndex + 1);
						value(valCopy);
					}
				},
				title: "",
				icon: "arrow-down",
				color: "normal"
			},
			{
				action: (listItem) => {
					const val = listItem.value;
					const itemIndex = value().findIndex((valueItem) => valueItem === val);

					if (itemIndex > -1) {
						value().splice(itemIndex, 1);
						value(value());
					}
				},
				title: "",
				icon: "trash",
				color: "danger"
			}
		];

		var fragment = root$s();
		var node = first_child(fragment);
		const expression = derived(() => COMPONENTS$1.get(itemUI()));

		Ui_list(node, spread_props(
			{
				get listItemComponent() {
					return get$3(expression);
				}
			},
			itemUIProps,
			{
				get items() {
					return get$3(items);
				},
				actions: ACTIONS
			}
		));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				const SvelteComponent = derived(() => COMPONENTS$1.get(selectorUI()));
				var node_2 = first_child(fragment_1);

				component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
					$$component($$anchor, spread_props(selectorUIProps, {
						get modelName() {
							return modelName();
						},
						get actionName() {
							return actionName();
						},
						get actionFilter() {
							return actionFilter();
						},
						get actionSorter() {
							return actionSorter();
						},
						get actionPager() {
							return actionPager();
						},
						get actionSearch() {
							return actionSearch();
						},
						get optionId() {
							return optionId();
						},
						get optionTitle() {
							return optionTitle();
						},
						get placeholder() {
							return placeholder();
						},
						set placeholder($$value) {
							placeholder($$value);
						},
						get fieldname() {
							return fieldname();
						},
						set fieldname($$value) {
							fieldname($$value);
						},
						get required() {
							return required();
						},
						set required($$value) {
							required($$value);
						},
						get multiple() {
							return multiple();
						},
						set multiple($$value) {
							multiple($$value);
						},
						get size() {
							return size();
						},
						set size($$value) {
							size($$value);
						},
						get valid() {
							return valid();
						},
						set valid($$value) {
							valid($$value);
						},
						$$events: { resolve: (e) => addItem(e.detail) }
					}));
				});

				append($$anchor, fragment_1);
			};

			if_block(node_1, ($$render) => {
				if (!readonly()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$r = template(`<div><!></div>`);

	function Ui_column($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {boolean} [narrow=false]
		 * @property {any} size
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			narrow = prop($$props, 'narrow', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'size',
				'narrow',
				'children'
			]);

		var div = root$r();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			attributes = set_attributes(div, attributes, {
				class: `column ${classes() ?? ''} ${($$props.size ? `is-${$$props.size}` : '') ?? ''}`,
				...others
			});

			toggle_class(div, 'is-narrow', narrow());
		});

		append($$anchor, div);
	}

	var root$q = template(`<div><!></div>`);

	function Ui_columns($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'class',
				'children'
			]);

		var div = root$q();
		let attributes;
		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => attributes = set_attributes(div, attributes, {
			class: `columns ${classes() ?? ''}`,
			...others
		}));

		append($$anchor, div);
	}

	var root$p = template(`<div><!></div>`);

	function Ui_container($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class = '']
		 * @property {string} [title = '']
		 * @property {string}   [role="button"]
		 * @property {number}   [tabIndex=0]
		 * @property {boolean} [widescreen=false]
		 * @property {boolean} [fullhd=false]
		 * @property {boolean} [maxDesktop=false]
		 * @property {boolean} [maxWidescreen=false]
		 * @property {boolean} [fluid = false]
		 * @property {import('svelte').Snippet} [children]
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			title = prop($$props, 'title', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0"),
			widescreen = prop($$props, 'widescreen', 3, false),
			fullhd = prop($$props, 'fullhd', 3, false),
			maxDesktop = prop($$props, 'maxDesktop', 3, false),
			maxWidescreen = prop($$props, 'maxWidescreen', 3, false),
			fluid = prop($$props, 'fluid', 3, false);

		var div = root$p();

		div.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		div.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(div);

		snippet(node, () => $$props.children ?? noop);
		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', id());
			set_attribute(div, 'title', title());
			set_class(div, `container ${classes() ?? ''}`);
			set_attribute(div, 'role', role());
			set_attribute(div, 'tabindex', tabIndex());
			toggle_class(div, 'is-widescreen', widescreen());
			toggle_class(div, 'is-fullhd', fullhd());
			toggle_class(div, 'is-max-desktop', maxDesktop());
			toggle_class(div, 'is-max-widescreen', maxWidescreen());
			toggle_class(div, 'is-fluid', fluid());
		});

		append($$anchor, div);
	}

	delegate(['click', 'keyup']);

	var root$o = template(`<footer><!></footer>`);

	function Ui_footer($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {string} [class]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, "");

		var footer = root$o();
		var node = child(footer);

		snippet(node, () => $$props.children ?? noop);
		reset(footer);

		template_effect(() => {
			set_attribute(footer, 'id', id());
			set_class(footer, `footer ${classes() ?? ''} `);
		});

		append($$anchor, footer);
	}

	var root$n = template(`<section><!></section>`);

	function Ui_section$2($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [id = '']
		 * @property {string} [class]
		 * @property {string} [role="button"]
		 * @property {number} [tabIndex = 0]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		var section = root$n();

		section.__click = function (...$$args) {
			$$props.onclick?.apply(this, $$args);
		};

		section.__keyup = function (...$$args) {
			$$props.onkeyup?.apply(this, $$args);
		};

		var node = child(section);

		snippet(node, () => $$props.children ?? noop);
		reset(section);

		template_effect(() => {
			set_attribute(section, 'id', id());
			set_class(section, `section ${classes() ?? ''}`);
			set_attribute(section, 'role', role());
			set_attribute(section, 'tabindex', tabIndex());
		});

		append($$anchor, section);
	}

	delegate(['click', 'keyup']);

	function Ui_level_item($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [tag]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let tag = prop($$props, 'tag', 3, "div");
		var fragment = comment();
		var node = first_child(fragment);

		element(node, tag, false, ($$element, $$anchor) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent = ($$anchor) => {
					var fragment_2 = comment();
					var node_2 = first_child(fragment_2);

					snippet(node_2, () => $$props.children ?? noop);
					append($$anchor, fragment_2);
				};

				var alternate = ($$anchor) => {};

				if_block(node_1, ($$render) => {
					if ($$props.children) $$render(consequent); else $$render(alternate, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$m = template(`<nav class="level"><div class="level-left"><!></div> <div class="level-right"><!></div></nav>`);

	function Ui_level($$anchor, $$props) {
		var nav = root$m();
		var div = child(nav);
		var node = child(div);

		snippet(node, () => $$props.left ?? noop);
		reset(div);

		var div_1 = sibling(div, 2);
		var node_1 = child(div_1);

		snippet(node_1, () => $$props.right ?? noop);
		reset(div_1);
		reset(nav);
		append($$anchor, nav);
	}

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIColumn: Ui_column,
		UIColumns: Ui_columns,
		UIContainer: Ui_container,
		UIFooter: Ui_footer,
		UILevel: Ui_level,
		UILevelItem: Ui_level_item,
		UISection: Ui_section$2
	});

	var root_1$j = template(`<p> </p>`);
	var root_2$e = template(`<input>`);

	function Ui_number($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, 0),
			placeholder = prop($$props, 'placeholder', 3, "0.0"),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100),
			step = prop($$props, 'step', 3, 1),
			fieldname = prop($$props, 'fieldname', 3, "number"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'min',
				'max',
				'step',
				'fieldname',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$j();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$e();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-number-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'number',
					name: fieldname(),
					invalid: get$3(invalid),
					disabled: disabled(),
					required: required(),
					readonly: readonly(),
					min: min(),
					max: max(),
					step: step(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_2$d = template(`<!> <!> <!>`, 1);
	var root_8$1 = template(`<!> <!> <!>`, 1);
	var root$l = template(`<!> <!> <!>`, 1);

	function Ui_named_numbers_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let fieldname = prop($$props, 'fieldname', 3, "numbers_list"),
			value = prop($$props, 'value', 23, () => ({})),
			defaultItemTitle = prop($$props, 'defaultItemTitle', 3, ""),
			defaultItemValue = prop($$props, 'defaultItemValue', 3, 0),
			label = prop($$props, 'label', 3, "named numbers list"),
			labelSize = prop($$props, 'labelSize', 3, 5),
			placeholder = prop($$props, 'placeholder', 3, "new item"),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false);
			prop($$props, 'required', 3, true);
			prop($$props, 'valid', 3, true);
			let onchange = prop($$props, 'onchange', 3, () => true),
			classes = prop($$props, 'class', 3, "");

		const createNewVal = () => {
			return {
				id: defaultItemTitle(),
				number: defaultItemValue()
			};
		};

		let newVal = state(proxy(createNewVal()));

		const transformObjectToList = () => {
			return Object.keys(value()).map((name) => {
				return {
					id: name,
					title: name,
					number: value()[name]
				};
			});
		};

		let list = state(proxy(transformObjectToList()));

		function remove(id) {
			if (notCommon$1.objHas(value(), id)) {
				delete value()[id];
				value(value());
				set(list, proxy(transformObjectToList()));
				onchange()({ value: value(), field: fieldname() });
			}
		}

		function add() {
			const id = get$3(newVal).id.trim();
			const number = parseInt(get$3(newVal).number);

			if (id && id !== "" && !isNaN(number) && !notCommon$1.objHas(value(), id)) {
				value()[id] = number;
			}

			set(list, proxy(transformObjectToList()));

			onchange()({
				value: snapshot(value()),
				field: fieldname()
			});

			set(newVal, proxy(createNewVal()));
		}

		var fragment = root$l();
		var node = first_child(fragment);

		Ui_title(node, {
			get title() {
				return label();
			},
			get size() {
				return labelSize();
			}
		});

		var node_1 = sibling(node, 2);

		each(node_1, 17, () => get$3(list), (item) => item.id, ($$anchor, item) => {
			Ui_columns($$anchor, {
				get class() {
					return classes();
				},
				get disabled() {
					return disabled();
				},
				children: ($$anchor, $$slotProps) => {
					var fragment_2 = root_2$d();
					var node_2 = first_child(fragment_2);

					Ui_column(node_2, {
						classes: 'is-6',
						children: ($$anchor, $$slotProps) => {
							next();

							var text$1 = text();

							template_effect(() => set_text(text$1, get$3(item).title));
							append($$anchor, text$1);
						},
						$$slots: { default: true }
					});

					var node_3 = sibling(node_2, 2);

					Ui_column(node_3, {
						classes: 'is-4',
						children: ($$anchor, $$slotProps) => {
							next();

							var text_1 = text();

							template_effect(() => set_text(text_1, get$3(item).number));
							append($$anchor, text_1);
						},
						$$slots: { default: true }
					});

					var node_4 = sibling(node_3, 2);

					{
						var consequent = ($$anchor) => {
							Ui_column($$anchor, {
								classes: 'is-2',
								children: ($$anchor, $$slotProps) => {
									Ui_button($$anchor, {
										icon: "minus",
										action: () => remove(get$3(item).id)
									});
								},
								$$slots: { default: true }
							});
						};

						if_block(node_4, ($$render) => {
							if (!readonly()) $$render(consequent);
						});
					}

					append($$anchor, fragment_2);
				},
				$$slots: { default: true }
			});
		});

		var node_5 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_columns($$anchor, {
					get class() {
						return classes();
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_8 = root_8$1();
						var node_6 = first_child(fragment_8);

						Ui_column(node_6, {
							classes: 'is-6',
							children: ($$anchor, $$slotProps) => {
								Ui_textfield($$anchor, {
									get placeholder() {
										return placeholder();
									},
									required: false,
									get value() {
										return get$3(newVal).id;
									},
									set value($$value) {
										get$3(newVal).id = $$value;
									}
								});
							},
							$$slots: { default: true }
						});

						var node_7 = sibling(node_6, 2);

						Ui_column(node_7, {
							classes: 'is-4',
							children: ($$anchor, $$slotProps) => {
								Ui_number($$anchor, {
									get value() {
										return get$3(newVal).number;
									},
									set value($$value) {
										get$3(newVal).number = $$value;
									}
								});
							},
							$$slots: { default: true }
						});

						var node_8 = sibling(node_7, 2);

						Ui_column(node_8, {
							classes: 'is-2',
							children: ($$anchor, $$slotProps) => {
								Ui_button($$anchor, { icon: "plus", action: () => add() });
							},
							$$slots: { default: true }
						});

						append($$anchor, fragment_8);
					},
					$$slots: { default: true }
				});
			};

			if_block(node_5, ($$render) => {
				if (!readonly()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root$k = template(`<input>`);

	function Ui_password($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "password"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'readonly',
				'disabled',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var input = root$k();

		remove_input_defaults(input);

		let attributes;

		template_effect(() => attributes = set_attributes(input, attributes, {
			id: `form-field-password-${fieldname() ?? ''}`,
			class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
			type: 'password',
			name: fieldname(),
			invalid: get$3(invalid),
			required: required(),
			readonly: readonly(),
			disabled: disabled(),
			placeholder: $LOCALE()[placeholder()],
			autocomplete: fieldname(),
			'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
			'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
			...optionalProps,
			...others
		}));

		bind_value(input, value);
		append($$anchor, input);
		pop();
		$$cleanup();
	}

	var root_1$i = template(`<figure><img></figure>`);
	var root_2$c = template(`<a><!></a>`);

	function Ui_image($$anchor, $$props) {
		const imageFigure = ($$anchor) => {
			var figure = root_1$i();
			var img = child(figure);

			img.__click = function (...$$args) {
				onclick()?.apply(this, $$args);
			};

			img.__keyup = function (...$$args) {
				onkeyup()?.apply(this, $$args);
			};

			reset(figure);

			template_effect(
				($0) => {
					set_class(figure, `image ${classes() ?? ''} ${$0 ?? ''}`);
					set_attribute(figure, 'style', ($$props.width ? `width: ${$$props.width};` : "") + ($$props.height ? `height: ${$$props.height};` : ""));
					toggle_class(figure, 'is-contained', contained());
					toggle_class(figure, 'is-covered', covered());
					toggle_class(figure, 'is-clickable', onclick() && $$props.pointable !== false || $$props.pointable);
					set_attribute(img, 'alt', $$props.alt || $$props.title);
					set_attribute(img, 'title', $$props.title);
					set_attribute(img, 'src', $$props.url || $$props.image);
					set_attribute(img, 'crossorigin', cors());
				},
				[
					() => !$$props.width && !$$props.height ? isNaN(size()) ? `is-${size()}` : `is-${size()}x${size()}` : ''
				]
			);

			append($$anchor, figure);
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [urlFull]
		 * @property {string} url
		 * @property {string} image
		 * @property {string} [title]
		 * @property {string} [alt]
		 * @property {string} [cors='anonymous']
		 * @property {number} [size = 64]
		 * @property {number} [height]
		 * @property {number} [width]
		 * @property {boolean} [contained=false]
		 * @property {boolean} [covered=false]
		 * @property {boolean} [pointable]
		 * @property {string} [class = '']
		 * @property {function} [onclick]
		 * @property {function} [onkeyup]
		 */
		/** @type {Props} */
		let cors = prop($$props, 'cors', 3, "anonymous"),
			size = prop($$props, 'size', 3, 64),
			contained = prop($$props, 'contained', 3, false),
			covered = prop($$props, 'covered', 3, false),
			classes = prop($$props, 'class', 3, ""),
			onclick = prop($$props, 'onclick', 3, undefined),
			onkeyup = prop($$props, 'onkeyup', 3, undefined);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var a = root_2$c();

				a.__click = function (...$$args) {
					onclick()?.apply(this, $$args);
				};

				var node_1 = child(a);

				imageFigure(node_1);
				reset(a);

				template_effect(() => {
					set_attribute(a, 'href', $$props.urlFull);
					set_attribute(a, 'title', $$props.title || $$props.alt);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				imageFigure($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.urlFull) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
	}

	delegate(['click', 'keyup']);

	function Ui_radio_buttons($$anchor, $$props) {
		push($$props, true);

		//
		/**
		 * @typedef {Object} Props
		 * @property {string} [fieldname]
		 * @property {any} [variants] - [
		array of groups
		{
		id:number,
		title:string|object,
		image:string|object,
		variants = [
		array of values variants in group
		{
		id:number,
		title:string|object,
		description:string|object,
		image:string|object,
		value:object
		}]
		}
		]
		 * @property {any} value - multiple && multiple in group
		{
		array of arrays of selected values in group
		if no selection group should be empty array
		[groupId]: [...variantsId]
		}
		multiple && one in group
		{
		[groupId]: variantId
		}
		only one (not multiple && one in group)
		{
		group: groupId
		value: variantId
		}
		 * @property {any} title
		 * @property {any} image
		 * @property {any} [buttonProps]
		 * @property {any} [titleComponent]
		 * @property {any} [titleComponentProps]
		 * @property {any} [imageComponent]
		 * @property {any} [imageComponentProps]
		 * @property {any} [descriptionComponent]
		 * @property {any} [descriptionComponentProps]
		 * @property {any} [listComponent]
		 * @property {any} [listComponentProps]
		 * @property {any} [getUIItem]
		 * @property {any} [getDefaultItemSublime]
		 * @property {any} [uiOn]
		 * @property {any} [uiOff]
		 */
		/** @type {Props} */
		let fieldname = prop($$props, 'fieldname', 3, "radio-buttons"),
			variants = prop($$props, 'variants', 19, () => []),
			value = prop($$props, 'value', 15),
			buttonProps = prop($$props, 'buttonProps', 19, () => ({})),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			listComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({})),
			getUIItem = prop($$props, 'getUIItem', 3, (valueId) => {
				return variantsButtons.find((btnVal) => btnVal.value === valueId);
			}),
			getDefaultItemSublime = prop($$props, 'getDefaultItemSublime', 3, () => {
				return variants()[0].value;
			}),
			uiOn = prop($$props, 'uiOn', 3, (item) => {
				item.color = "success";
				item.outlined = false;
			}),
			uiOff = prop($$props, 'uiOff', 3, (item) => {
				item.color = false;
				item.outlined = true;
			}),
			onchange = prop($$props, 'onchange', 3, () => true);

		onMount(() => {
			initVariantsButton();
			selectDefault();
		});

		let variantsButtons = [],
			listItems = state(proxy([]));

		function initVariantsButton() {
			variantsButtons = variants().map((variant) => {
				return { ...buttonProps(), ...variant };
			});

			set(listItems, proxy([
				{
					id: 0,
					title: $$props.title,
					image: $$props.image,
					description: { values: variantsButtons }
				}
			]));
		}

		//
		function toggle(selectedValue) {
			let ui = { on: undefined, off: undefined };

			//
			if (value()) {
				ui.off = value();
				ui.on = selectedValue;
			}

			value(selectedValue);
			updateUI(ui);
			//
			onchange()({ field: fieldname(), value: value() });
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(getUIItem()(changes.off));
			}

			if (changes.on) {
				uiOn()(getUIItem()(changes.on));
			}

			variantsButtons = variantsButtons;
			set(listItems, proxy(get$3(listItems)));
		}

		//
		function selectDefault() {
			if (variants().length > 0) {
				if (typeof value() !== "undefined") {
					updateUI({ on: value() });
				} else {
					const defValue = getDefaultItemSublime()();

					toggle(defValue);
				}
			}
		}

		const SvelteComponent = derived(listComponent);
		var fragment = comment();
		var node = first_child(fragment);

		const expression = derived(() => ({
			...descriptionComponentProps(),
			action(event, value) {
				toggle(value);
			}
		}));

		component(node, () => get$3(SvelteComponent), ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$3(expression);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return get$3(listItems);
				},
				set items($$value) {
					set(listItems, proxy($$value));
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	var root_1$h = template(`<p> </p>`);
	var root_4$a = template(`<option></option>`);
	var root_3$b = template(`<datalist></datalist>`);
	var root_2$b = template(`<input> <output> </output> <!>`, 1);

	function Ui_range($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, 10),
			min = prop($$props, 'min', 3, 0),
			max = prop($$props, 'max', 3, 100),
			step = prop($$props, 'step', 3, 1),
			tickmarks = prop($$props, 'tickmarks', 3, false),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "range"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'min',
				'max',
				'step',
				'tickmarks',
				'placeholder',
				'fieldname',
				'color',
				'size',
				'required',
				'disabled',
				'readonly',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$h();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var fragment_1 = root_2$b();
				var input = first_child(fragment_1);

				remove_input_defaults(input);

				let attributes;
				var output = sibling(input, 2);
				var text_1 = child(output, true);

				reset(output);

				var node_1 = sibling(output, 2);

				{
					var consequent_1 = ($$anchor) => {
						var datalist = root_3$b();

						each(datalist, 21, tickmarks, index$d, ($$anchor, tickmark) => {
							var option = root_4$a();
							var option_value = {};

							template_effect(() => {
								if (option_value !== (option_value = get$3(tickmark).value)) {
									option.value = null == (option.__value = get$3(tickmark).value) ? '' : get$3(tickmark).value;
								}

								set_attribute(option, 'label', get$3(tickmark).label);
							});

							append($$anchor, option);
						});

						reset(datalist);
						template_effect(() => set_attribute(datalist, 'id', `form-field-range-${fieldname() ?? ''}-tickmarks`));
						append($$anchor, datalist);
					};

					if_block(node_1, ($$render) => {
						if (Array.isArray(tickmarks()) && tickmarks().length) $$render(consequent_1);
					});
				}

				template_effect(() => {
					attributes = set_attributes(input, attributes, {
						id: `form-field-range-${fieldname() ?? ''}`,
						class: `input big-number slider has-output ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''}  ${classes() ?? ''}`,
						type: 'range',
						name: fieldname(),
						min: min(),
						max: max(),
						step: step(),
						list: `form-field-range-${fieldname() ?? ''}-tickmarks`,
						invalid: get$3(invalid),
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						placeholder: $LOCALE()[placeholder()],
						autocomplete: fieldname(),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					});

					set_attribute(output, 'for', `form-field-range-${fieldname() ?? ''}`);
					set_text(text_1, value());
				});

				bind_value(input, value);
				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_3$a = template(`<span class="mr-2"> </span>`);
	var root_5$8 = template(`<span class="mr-2"> </span>`);
	var root_6$8 = template(`<div><select><!><!></select></div>`);

	function Ui_select_multiple($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [value = []]
		 * @property {any}      [variants = []]
		 * @property {string} [placeholder = ""]
		 * @property {boolean}  [emptyValueEnabled = true]
		 * @property {string|number}  [emptyValue]
		 * @property {string} [emptyValueTitle = "no-selection"]
		 * @property {string} [fieldname="select-multiple"]
		 * @property {boolean} [required = true]
		 * @property {boolean} [readonly = false]
		 * @property {number} [rows = 8]
		 * @property {string} [color]
		 * @property {string} [size]
		 * @property {boolean} [valid = true]
		 * @property {string}   [class = ""]
		 * @property {function} [onchange = ({value:array of string|number, field:string, variants:array of object})=>true]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 23, () => []),
			variants = prop($$props, 'variants', 19, () => []);
			prop($$props, 'placeholder', 3, "");
			let emptyValueTitle = prop($$props, 'emptyValueTitle', 3, "no-selection"),
			emptyValueEnabled = prop($$props, 'emptyValueEnabled', 3, true),
			fieldname = prop($$props, 'fieldname', 3, "select-multiple"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			rows = prop($$props, 'rows', 3, 8),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'placeholder',
				'emptyValueTitle',
				'emptyValueEnabled',
				'emptyValue',
				'fieldname',
				'required',
				'readonly',
				'rows',
				'color',
				'size',
				'valid',
				'class',
				'onchange'
			]);

		let lastValue = snapshot(value());

		function isClearValueMacro(plainValue) {
			return plainValue.includes(UICommon$1.CLEAR_MACRO);
		}

		function getSelectedOptionsValues(ev) {
			return Array.from(ev.selectedOptions).map((el) => typeof el.__value !== "undefined" ? el.__value : el.value);
		}

		function getEmptyValue() {
			return typeof $$props.emptyValue === "undefined" ? UICommon$1.CLEAR_MACRO : $$props.emptyValue;
		}

		function idToVariant(id) {
			return variants().find((variant) => variant.id == id);
		}

		function valueIdsToVariants() {
			const ev = getEmptyValue();

			return value().filter((id) => id !== ev).map(idToVariant);
		}

		function onInput(ev) {
			let selectedIds = getSelectedOptionsValues(ev.currentTarget);

			if (isClearValueMacro(selectedIds)) {
				selectedIds = [];
			}

			const newValue = selectedIds;

			value(selectedIds);

			if (notCommon$1.compareTwoArrays(newValue, lastValue)) {
				return;
			}

			lastValue = newValue;

			onchange()({
				value: newValue,
				field: fieldname(),
				variants: valueIdsToVariants()
			});
		}

		let selectedVariants = derived(() => value() && Array.isArray(value()) ? valueIdsToVariants(value()) : []);
		let invalid = derived(() => !valid());
		let UI_CLASSES = derived(() => [$$props.size, $$props.color].filter((val) => val).map((val) => `is-${val}`).join(" "));
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 17, () => get$3(selectedVariants), index$d, ($$anchor, selectedVariant) => {
							var span = root_3$a();
							var text = child(span, true);

							reset(span);
							template_effect(() => set_text(text, $LOCALE()[get$3(selectedVariant).title]));
							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_1 = ($$anchor) => {
								var span_1 = root_5$8();
								var text_1 = child(span_1, true);

								reset(span_1);
								template_effect(() => set_text(text_1, $LOCALE()[emptyValueTitle()]));
								append($$anchor, span_1);
							};

							if_block(
								node_3,
								($$render) => {
									if (emptyValueEnabled()) $$render(consequent_1);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(node_1, ($$render) => {
						if (value() && Array.isArray(value()) && value().length) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var div = root_6$8();
				var select = child(div);
				let attributes;

				init_select(select, () => attributes.value);

				var node_4 = child(select);

				{
					var consequent_3 = ($$anchor) => {
						const expression = derived(() => typeof $$props.emptyValue === "undefined" ? UICommon$1.CLEAR_MACRO : $$props.emptyValue);

						Ui_select_option($$anchor, {
							get value() {
								return get$3(expression);
							},
							get title() {
								return emptyValueTitle();
							}
						});
					};

					if_block(node_4, ($$render) => {
						if (emptyValueEnabled()) $$render(consequent_3);
					});
				}

				var node_5 = sibling(node_4);

				each(node_5, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					Ui_select_option($$anchor, {
						get value() {
							return get$3(variant).id;
						},
						get title() {
							return get$3(variant).title;
						}
					});
				});

				reset(select);
				reset(div);

				template_effect(() => {
					set_class(div, `select is-multiple ${get$3(UI_CLASSES) ?? ''} ${classes() ?? ''} `);

					attributes = set_attributes(select, attributes, {
						multiple: 'true',
						id: `form-field-select-${fieldname() ?? ''}`,
						name: fieldname(),
						oninput: onInput,
						onchange: onInput,
						onblur: onInput,
						value: value(),
						readonly: readonly(),
						required: required(),
						invalid: get$3(invalid),
						size: rows(),
						...others
					});

					if ('value' in attributes) {
						select_option(select, attributes.value);
					}
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_2); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	const DEFAULT_STATUS_SUCCESS = "ok";
	const NAVIGATION_DELAY_SHORT = 500;
	const NAVIGATION_DELAY_NORMAL = 1500;
	const NAVIGATION_DELAY_LONG = 5000;
	const NAVIGATION_DELAYS = {
	  SHORT: NAVIGATION_DELAY_SHORT,
	  NORMAL: NAVIGATION_DELAY_NORMAL,
	  LONG: NAVIGATION_DELAY_LONG
	};
	const NAVIGATION_DELAY_DEFAULT = NAVIGATION_DELAY_NORMAL;

	function Ui_select_from_model($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted]
		 * @property {any} value
		 * @property {string} [placeholder]
		 * @property {string} [emptyValueTitle]
		 * @property {string} [fieldname]
		 * @property {string} [modelName]
		 * @property {string} [actionName]
		 * @property {any} [actionFilter]
		 * @property {any} [actionSorter]
		 * @property {any} [actionPager]
		 * @property {any} [actionSearch]
		 * @property {string} [optionId]
		 * @property {string} [optionTitle]
		 * @property {boolean} [icon]
		 * @property {boolean} [required]
		 * @property {boolean} [readonly]
		 * @property {boolean} [multiple]
		 * @property {number} [size]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 * @property {boolean} [formLevelError]
		 * @property {boolean} [returnVariant]
		 */
		/** @type {Props} */
		let placeholder = prop($$props, 'placeholder', 3, ""),
			emptyValueTitle = prop($$props, 'emptyValueTitle', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "selectFromModel"),
			modelName = prop($$props, 'modelName', 3, ""),
			actionName = prop($$props, 'actionName', 3, ""),
			actionFilter = prop($$props, 'actionFilter', 19, () => ({})),
			actionSorter = prop($$props, 'actionSorter', 19, () => ({})),
			actionPager = prop($$props, 'actionPager', 19, () => ({})),
			actionSearch = prop($$props, 'actionSearch', 3, undefined),
			optionId = prop($$props, 'optionId', 3, ":_id"),
			optionTitle = prop($$props, 'optionTitle', 3, ":title"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			multiple = prop($$props, 'multiple', 3, false),
			size = prop($$props, 'size', 3, 8),
			valid = prop($$props, 'valid', 3, true),
			returnVariant = prop($$props, 'returnVariant', 3, false),
			classes = prop($$props, 'class', 3, ""),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => {}),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'emptyValueTitle',
				'fieldname',
				'modelName',
				'actionName',
				'actionFilter',
				'actionSorter',
				'actionPager',
				'actionSearch',
				'optionId',
				'optionTitle',
				'required',
				'readonly',
				'multiple',
				'size',
				'valid',
				'returnVariant',
				'class',
				'onchange',
				'onerror'
			]);

		function argumentsSetProvided() {
			return modelName() && actionName() && actionFilter();
		}
		let variants = state(proxy([]));
		let disabled = derived(() => true);

		onMount(async () => {
			if (argumentsSetProvided()) {
				const notApp = notCommon$1.getApp();
				const Model = notApp.getModel(modelName()).setFilter(actionFilter()).setSorter(actionSorter()).setPager(actionPager()).setSearch(actionSearch());
				const response = await Model[`$` + actionName()]();

				if (response.status === DEFAULT_STATUS_SUCCESS) {
					const result = response.result;

					set(variants, proxy(result.map((item) => {
						return {
							id: notPath.get(optionId(), item),
							title: notPath.get(optionTitle(), item)
						};
					})));
				} else {
					onerror()(response.errors || response.message);
				}
			}
		});

		function onChange(data) {
			if (returnVariant()) {
				onchange()({
					...data,
					value: get$3(variants).find((itm) => itm.id === data.value)
				});
			} else {
				onchange()(data);
			}
		}

		Ui_select($$anchor, spread_props(
			{
				get value() {
					return $$props.value;
				},
				get class() {
					return classes();
				},
				get placeholder() {
					return placeholder();
				},
				get emptyValueTitle() {
					return emptyValueTitle();
				},
				get fieldname() {
					return fieldname();
				},
				get required() {
					return required();
				},
				get readonly() {
					return readonly();
				},
				get disabled() {
					return get$3(disabled);
				},
				get multiple() {
					return multiple();
				},
				get size() {
					return size();
				},
				get valid() {
					return valid();
				},
				onchange: onChange
			},
			() => others,
			{
				get variants() {
					return get$3(variants);
				},
				set variants($$value) {
					set(variants, proxy($$value));
				}
			}
		));

		pop();
	}

	var root_2$a = template(`<!> <input> <label class="label"><!></label>`, 1);

	function Ui_switch$1($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, false),
			label = prop($$props, 'label', 3, ""),
			hideLabel = prop($$props, 'hideLabel', 3, false),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldname = prop($$props, 'fieldname', 3, "switch"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur", "oninput"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'label',
				'hideLabel',
				'placeholder',
				'fieldname',
				'size',
				'color',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_boolean($$anchor, {
					get LC_TRUE() {
						return label();
					},
					get LC_FALSE() {
						return label();
					},
					get value() {
						return value();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = root_2$a();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_boolean($$anchor, { value: false });
					};

					if_block(node_1, ($$render) => {
						if (!label() && !hideLabel()) $$render(consequent_1);
					});
				}

				var input = sibling(node_1, 2);

				remove_input_defaults(input);

				let attributes;
				var label_1 = sibling(input, 2);
				var node_2 = child(label_1);

				{
					var consequent_3 = ($$anchor) => {
						var fragment_4 = comment();
						var node_3 = first_child(fragment_4);

						{
							var consequent_2 = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[label()]));
								append($$anchor, text$1);
							};

							var alternate = ($$anchor) => {
								Ui_boolean($$anchor, { value: false });
							};

							if_block(node_3, ($$render) => {
								if (label()) $$render(consequent_2); else $$render(alternate, false);
							});
						}

						append($$anchor, fragment_4);
					};

					if_block(node_2, ($$render) => {
						if (!hideLabel()) $$render(consequent_3);
					});
				}

				reset(label_1);

				template_effect(() => {
					attributes = set_attributes(input, attributes, {
						id: `form-field-switch-${fieldname() ?? ''}`,
						class: `switch ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
						type: 'checkbox',
						name: fieldname(),
						placeholder: $LOCALE()[placeholder()],
						disabled: disabled(),
						required: required(),
						readonly: readonly(),
						invalid: get$3(invalid),
						'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
						'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
						...optionalProps,
						...others
					});

					set_attribute(label_1, 'for', `form-field-switch-${fieldname() ?? ''}`);
				});

				bind_checked(input, value);
				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$9 = template(`<div class="switch-list-item"><input> <!></div>`);

	function Ui_switch_list($$anchor, $$props) {
		push($$props, true);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 31, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "switch"),
			required = prop($$props, 'required', 3, true),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			reactOn = prop($$props, 'reactOn', 19, () => ["onblur", "oninput"]),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, " is-rounded "),
			onchange = prop($$props, 'onchange', 3, () => true),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'variants',
				'fieldname',
				'required',
				'readonly',
				'disabled',
				'reactOn',
				'valid',
				'class',
				'onchange'
			]);

		function addId(varId) {
			if (!value().includes(varId)) {
				value().push(varId);
				value(value());
			}
		}

		function remId(varId) {
			if (value().includes(varId)) {
				value().splice(value().indexOf(varId), 1);
				value(value());
			}
		}

		function onChange(eventData, ev) {
			const varId = ev.target.id.split("-variant-").at(-1);

			ev.target.checked ? addId(varId) : remId(varId);

			let data = {
				field: fieldname(),
				value: snapshot(value())
			};

			onchange()(data);
			return true;
		}

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), onChange);

			reactOn().forEach((eventName) => optionalProps[eventName] = oninput);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						var text$1 = text();

						template_effect(($0) => set_text(text$1, $0), [
							() => variants().filter((variant) => value().includes(variant.id)).map((variant) => variant.title).join(", ")
						]);

						append($$anchor, text$1);
					};

					if_block(node_1, ($$render) => {
						if (value()) $$render(consequent);
					});
				}

				append($$anchor, fragment_1);
			};

			var alternate = ($$anchor) => {
				var fragment_3 = comment();
				var node_2 = first_child(fragment_3);

				each(node_2, 17, variants, (variant) => variant.id, ($$anchor, variant) => {
					var div = root_4$9();
					var input = child(div);

					remove_input_defaults(input);

					let attributes;
					var node_3 = sibling(input, 2);

					Ui_label(node_3, {
						class: 'label',
						get for() {
							return `form-field-switch-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`;
						},
						get label() {
							return get$3(variant).title;
						}
					});

					reset(div);

					template_effect(
						($0) => attributes = set_attributes(input, attributes, {
							type: 'checkbox',
							class: `switch ${classes() ?? ''} ${(get$3(variant).type ? `is-${get$3(variant).type}` : '') ?? ''}`,
							id: `form-field-switch-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							checked: $0,
							name: fieldname(),
							disabled: disabled(),
							required: required(),
							readonly: readonly(),
							invalid: get$3(invalid),
							'aria-controls': `input-field-helper-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							'aria-describedby': `input-field-helper-${fieldname() ?? ''}-variant-${get$3(variant).id ?? ''}`,
							...optionalProps,
							...others
						}),
						[
							() => value().includes(get$3(variant).id)
						]
					);

					append($$anchor, div);
				});

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function remove(e, value, changeEvent) {
		e && e.preventDefault();

		let id = e.currentTarget.dataset.id;

		if (value().includes(id)) {
			value().splice(value().indexOf(id), 1);
			value(value());
			changeEvent();
		}

		return false;
	}

	var root_4$8 = template(`<button aria-label="delete button" class="delete is-small"></button>`);
	var root_3$9 = template(`<span> <!></span>`);
	var root_6$7 = template(`<div class="select is-small"><select><!><!></select></div> <!>`, 1);
	var root_1$g = template(`<!> <!>`, 1);

	function Ui_tag_select($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		onMount(() => {
			clearValueFromDeadVariants();
		});

		/**
		 * @typedef {Object} Props
		 * @property {string} [LC_ADD = "not-node:add_label"]
		 * @property {string} [LC_SELECT_FROM_LIST = "not-node:select_from_list_label"]
		 * @property {array<string|number>} [value] - list of item ids
		 * @property {array<object>} [variants]
		 * @property {string} [fieldname = 'tag']
		 * @property {boolean} [readonly = false] - export let required = true;
		 * @property {boolean} [valid = true]
		 * @property {function} [beforeAdd]
		 * @property {function} [getItemId]
		 * @property {function} [getItemTitle]
		 * @property {function} [getItemType]
		 * @property {function} [buildItem]
		 */
		/** @type {Props} */
		let LC_ADD = prop($$props, 'LC_ADD', 3, "not-node:add_label"),
			LC_SELECT_FROM_LIST = prop($$props, 'LC_SELECT_FROM_LIST', 3, "not-node:select_from_list_label"),
			value = prop($$props, 'value', 31, () => proxy([])),
			variants = prop($$props, 'variants', 19, () => []),
			fieldname = prop($$props, 'fieldname', 3, "tag"),
			readonly = prop($$props, 'readonly', 3, false);
			prop($$props, 'valid', 3, true);
			let beforeAdd = prop($$props, 'beforeAdd', 3, () => /*variant, variants*/ {
				return true;
			}),
			getItemId = prop($$props, 'getItemId', 3, (variant) => {
				return variant.id;
			}),
			getItemTitle = prop($$props, 'getItemTitle', 3, (variant) => {
				return variant.title;
			}),
			getItemType = prop($$props, 'getItemType', 3, (variant) => {
				return variant?.type ?? "info";
			}),
			buildItem = prop($$props, 'buildItem', 3, (variant) => {
				return {
					id: getItemId()(variant),
					title: getItemTitle()(variant),
					type: getItemType()(variant)
				};
			}),
			classes = prop($$props, 'class', 3, "");

		function variantIdToVariant(id) {
			return variants().find((variant) => getItemId()(variant) == id);
		}

		function changeEvent() {
			$$props.onchange({ field: fieldname(), value: value() });
		}

		function add(e) {
			e && e.preventDefault();

			let id = e.currentTarget.parentNode.querySelector("select").value;
			const variant = variantIdToVariant(id);

			if (!variant) {
				return false;
			}

			if (!beforeAdd()(variant, variants())) {
				return false;
			}

			if (id && value().indexOf(id) === -1) {
				value().push(id);
				value(value());
				changeEvent();
			}

			return false;
		}

		function clearValueFromDeadVariants() {
			value(value().filter(variantIdToVariant));
			return value();
		}

		/*
		item = {
		  id,        //unique
		  title,     //some text
		  type       //for coloring items, usual html template names danger, success, etc
		}
		*/
		let items = derived(() => value().map(variantIdToVariant).filter((variant) => variant).map(buildItem()));

		Ui_columns($$anchor, {
			get class() {
				return classes();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$g();
				var node = first_child(fragment_1);

				Ui_column(node, {
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, () => get$3(items), (item) => item.id, ($$anchor, item) => {
							var span = root_3$9();
							var text = child(span);
							var node_2 = sibling(text);

							{
								var consequent = ($$anchor) => {
									var button = root_4$8();

									button.__click = [remove, value, changeEvent];
									template_effect(() => set_attribute(button, 'data-id', get$3(item).id));
									append($$anchor, button);
								};

								if_block(node_2, ($$render) => {
									if (!readonly()) $$render(consequent);
								});
							}

							reset(span);

							template_effect(() => {
								set_class(span, `mx-1 tag is-${get$3(item).type ?? ''}`);
								set_text(text, `${$LOCALE()[get$3(item).title] ?? ''} `);
							});

							append($$anchor, span);
						});

						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});

				var node_3 = sibling(node, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_column($$anchor, {
							children: ($$anchor, $$slotProps) => {
								var fragment_4 = root_6$7();
								var div = first_child(fragment_4);
								var select = child(div);
								var node_4 = child(select);

								Ui_select_option(node_4, {
									value: -1,
									selected: true,
									get title() {
										return LC_SELECT_FROM_LIST();
									}
								});

								var node_5 = sibling(node_4);

								each(node_5, 17, variants, index$d, ($$anchor, variant) => {
									Ui_select_option($$anchor, {
										get value() {
											return get$3(variant).id;
										},
										get title() {
											return get$3(variant).title;
										}
									});
								});

								reset(select);
								reset(div);

								var node_6 = sibling(div, 2);

								Ui_button(node_6, {
									color: "primary",
									size: "small",
									action: add,
									get title() {
										return LC_ADD();
									}
								});

								append($$anchor, fragment_4);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_3, ($$render) => {
						if (!readonly()) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	delegate(['click']);

	var root_1$f = template(`<p> </p>`);
	var root_2$9 = template(`<input>`);

	function Ui_telephone($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/** @type {import('./type').UIInputProps} */
		let value = prop($$props, 'value', 15, ""),
			placeholder = prop($$props, 'placeholder', 3, "+7 987 654-32-10"),
			pattern = prop($$props, 'pattern', 3, "\\+[0-9]{1,3}\\s+[0-9]{3}\\s+[0-9]{3}-[0-9]{2}-[0-9]{2}"),
			fieldname = prop($$props, 'fieldname', 3, "telephone"),
			required = prop($$props, 'required', 3, true),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			valid = prop($$props, 'valid', 3, true),
			classes = prop($$props, 'class', 3, ""),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'placeholder',
				'pattern',
				'fieldname',
				'required',
				'disabled',
				'readonly',
				'color',
				'size',
				'valid',
				'class'
			]);

		let invalid = derived(() => !valid());
		const optionalProps = {};

		if (typeof $$props.onchange === "function") {
			const oninput = UICommon$1.onInput(fieldname(), $$props.onchange);

			optionalProps.onchange = oninput;
			optionalProps.oninput = oninput;
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var p = root_1$f();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, value()));
				append($$anchor, p);
			};

			var alternate = ($$anchor) => {
				var input = root_2$9();

				remove_input_defaults(input);

				let attributes;

				template_effect(() => attributes = set_attributes(input, attributes, {
					id: `form-field-telephone-${fieldname() ?? ''}`,
					class: `input ${($$props.size ? `is-${$$props.size}` : '') ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''} ${classes() ?? ''}`,
					type: 'tel',
					name: fieldname(),
					pattern: pattern(),
					invalid: get$3(invalid),
					required: required(),
					readonly: readonly(),
					disabled: disabled(),
					placeholder: $LOCALE()[placeholder()],
					autocomplete: fieldname(),
					'aria-controls': `input-field-helper-${fieldname() ?? ''}`,
					'aria-describedby': `input-field-helper-${fieldname() ?? ''}`,
					...optionalProps,
					...others
				}));

				bind_value(input, value);
				append($$anchor, input);
			};

			if_block(node, ($$render) => {
				if (readonly()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIAutocomplete: Ui_autocomplete,
		UICheckbox: Ui_checkbox,
		UICheckboxList: Ui_checkbox_list,
		UIColor: Ui_color,
		UIControl: Ui_control,
		UIDate: Ui_date,
		UIDatetimeInTZ: Ui_datetime_in_tz,
		UIEmail: Ui_email,
		UIField: Ui_field,
		UIHidden: Ui_hidden,
		UIJSONArea: Ui_json_area,
		UILabel: Ui_label,
		UIListOfModels: Ui_list_of_models,
		UINamedNumbersList: Ui_named_numbers_list,
		UINumber: Ui_number,
		UIPassword: Ui_password,
		UIRadioButtons: Ui_radio_buttons,
		UIRange: Ui_range,
		UISelect: Ui_select,
		UISelectFromModel: Ui_select_from_model,
		UISelectMultiple: Ui_select_multiple,
		UISelectOption: Ui_select_option,
		UISwitch: Ui_switch$1,
		UISwitchList: Ui_switch_list,
		UITagSelect: Ui_tag_select,
		UITelephone: Ui_telephone,
		UITextarea: Ui_textarea,
		UITextfield: Ui_textfield
	});

	function Ui_tag_value_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {object}    Props
		 * @property {array}    values = []
		 * @property {boolean}  [grouped = true]
		 * @property {boolean}  [multiline = true]
		 */
		/**
		 * @type   Props
		 */
		let values = prop($$props, 'values', 19, () => []),
			grouped = prop($$props, 'grouped', 3, true),
			multiline = prop($$props, 'multiline', 3, true);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_field($$anchor, {
					get grouped() {
						return grouped();
					},
					get multiline() {
						return multiline();
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = comment();
						var node_1 = first_child(fragment_2);

						each(node_1, 17, values, index$d, ($$anchor, tagValueProps) => {
							Ui_control($$anchor, {
								children: ($$anchor, $$slotProps) => {
									Ui_tag_value($$anchor, spread_props(() => get$3(tagValueProps)));
								},
								$$slots: { default: true }
							});
						});

						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});
			};

			if_block(node, ($$render) => {
				if (values().length) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	var root_3$8 = template(`<span> </span> `, 1);
	var root_1$e = template(`<p><!></p>`);

	function Ui_errors_list($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {array<string>}  [errors = []]
		 * @property {boolean} [show = false]
		 * @property {string} [class = '']
		 * @property {string} [id = 'errors-list']
		 */
		/** @type {Props} */
		let errors = prop($$props, 'errors', 19, () => []),
			show = prop($$props, 'show', 3, false),
			classes = prop($$props, 'class', 3, ""),
			id = prop($$props, 'id', 3, "errors-list");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var p = root_1$e();
				var node_1 = child(p);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						each(node_2, 17, errors, index$d, ($$anchor, error, index) => {
							var fragment_2 = root_3$8();
							var span = first_child(fragment_2);
							var text = child(span, true);

							reset(span);

							var text_1 = sibling(span, 1, true);

							template_effect(() => {
								set_text(text, $LOCALE()[get$3(error)]);
								set_text(text_1, index < errors().length - 1 ? ", " : "");
							});

							append($$anchor, fragment_2);
						});

						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var text_2 = text(' ');

						append($$anchor, text_2);
					};

					if_block(node_1, ($$render) => {
						if (show()) $$render(consequent); else $$render(alternate, false);
					});
				}

				reset(p);

				template_effect(() => {
					set_class(p, `help ${classes() ?? ''}`);
					set_attribute(p, 'id', id());
				});

				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if (Array.isArray(errors()) && errors().length) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_1$d = template(`<p><strong> </strong> <small>@</small> <strong> </strong></p>`);
	var root$j = template(`<article class="media"><figure class="media-left"><p class="image is-32x32"><img></p></figure> <div class="media-content"><!></div></article>`);

	function Ui_user_card($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [id = "userCard"]
		 * @property {string}       [image = "https://bulma.io/images/placeholders/32x32.png"]
		 * @property {string}       [username = "John Doe"]
		 * @property {string}       [role = "admin"]
		 * @property {object}       [events = {}]
		 * @property {function}     [register = notCommon.registerWidgetEvents] - register event handlers
		 * @property {function}     [onUpdate = (data)=> {username=data.username; role = data.role;}]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, "userCard"),
			image = prop($$props, 'image', 3, "https://bulma.io/images/placeholders/32x32.png"),
			username = prop($$props, 'username', 7, "John Doe"),
			role = prop($$props, 'role', 7, "admin"),
			events = prop($$props, 'events', 23, () => ({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				if (Object.hasOwn(data, "username")) {
					username(data.username);
				}

				if (Object.hasOwn(data, "role")) {
					role(data.role);
				}
			});

		function getCompId() {
			return `usercard-${id()}`;
		}

		function getStandartUpdateEventName() {
			return `${getCompId()}:update`;
		}

		onMount(() => {
			if (!Object.hasOwn(events(), getStandartUpdateEventName())) {
				events()[getStandartUpdateEventName()] = onUpdate();
			}

			register()(events());
		});

		var article = root$j();
		var figure = child(article);
		var p = child(figure);
		var img = child(p);

		reset(p);
		reset(figure);

		var div = sibling(figure, 2);
		var node = child(div);

		Ui_content(node, {
			children: ($$anchor, $$slotProps) => {
				var p_1 = root_1$d();
				var strong = child(p_1);
				var text = child(strong, true);

				reset(strong);

				var strong_1 = sibling(strong, 4);
				var text_1 = child(strong_1, true);

				reset(strong_1);
				reset(p_1);

				template_effect(() => {
					set_text(text, username());
					set_text(text_1, role());
				});

				append($$anchor, p_1);
			},
			$$slots: { default: true }
		});

		reset(div);
		reset(article);

		template_effect(
			($0) => {
				set_attribute(article, 'id', $0);
				set_attribute(img, 'src', image());
				set_attribute(img, 'alt', username());
			},
			[getCompId]
		);

		append($$anchor, article);
		return pop({ getCompId, getStandartUpdateEventName });
	}

	var root_1$c = template(`<span><span><i></i> <span> </span></span></span>`);
	var root_2$8 = template(`<span><i></i></span>`);

	function Ui_icon_font($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""]
		 * @property {string} [font = ""]
		 * @property {string} [size = ""]
		 * @property {string} [side = ""]
		 * @property {string} [class = ""]
		 * @property {boolean} [pointable = false]
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			font = prop($$props, 'font', 3, ""),
			side = prop($$props, 'side', 3, ""),
			size = prop($$props, 'size', 3, ""),
			pointable = prop($$props, 'pointable', 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var span = root_1$c();
				var span_1 = child(span);
				var i = child(span_1);
				var span_2 = sibling(i, 2);
				var text = child(span_2, true);

				reset(span_2);
				reset(span_1);
				reset(span);

				template_effect(() => {
					set_class(span, `icon-text ${(pointable() ? 'is-clickable' : '') ?? ''}`);
					set_class(span_1, `icon ${(size() ? `is-${size()}` : '') ?? ''}`);

					set_class(i, `is-title-icon fas
      fa-${font() ?? ''}
      ${(size() == 'medium' ? 'fa-lg' : '') ?? ''}
      ${(size() == 'large' ? 'fa-2x' : '') ?? ''}
      `);

					set_text(text, $LOCALE()[title()]);
				});

				append($$anchor, span);
			};

			var alternate = ($$anchor) => {
				var span_3 = root_2$8();
				var i_1 = child(span_3);

				reset(span_3);

				template_effect(() => {
					set_class(span_3, `
        ${(pointable() ? 'is-clickable' : '') ?? ''}
        ${(side() ? `is-${side()}` : '') ?? ''}
        icon ${(size() ? `is-${size()}` : '') ?? ''} ${(size() == 'medium' ? 'fa-lg' : '') ?? ''}
${(size() == 'large' ? 'fa-2x' : '') ?? ''}`);

					set_class(i_1, `fas fa-${font() ?? ''}`);
				});

				append($$anchor, span_3);
			};

			if_block(node, ($$render) => {
				if (title()) $$render(consequent); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var root_4$7 = template(`<!> <!>`, 1);

	function Ui_simple_search_input($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string}   [placeholder = 'not-node:field_search_placeholder']
		 * @property {string}   [term = '']
		 * @property {string}   [fieldname = 'searchTermInput']
		 * @property {string}   [icon = 'search']
		 * @property {function} [onchange]
		 */
		/** @type {Props} */
		let placeholder = prop($$props, 'placeholder', 3, "not-node:field_search_placeholder"),
			term = prop($$props, 'term', 15, ""),
			fieldname = prop($$props, 'fieldname', 3, "searchTermInput"),
			icon = prop($$props, 'icon', 3, "search"),
			iconSide = prop($$props, 'iconSide', 3, "left"),
			size = prop($$props, 'size', 3, "normal"),
			required = prop($$props, 'required', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'placeholder',
				'term',
				'fieldname',
				'icon',
				'iconSide',
				'size',
				'required'
			]);

		let hasIconsLeft = derived(() => icon() && iconSide() === "left");
		let hasIconsRight = derived(() => icon() && iconSide() === "right");

		Ui_columns($$anchor, {
			role: 'none',
			children: ($$anchor, $$slotProps) => {
				Ui_column($$anchor, {
					role: 'none',
					children: ($$anchor, $$slotProps) => {
						Ui_field($$anchor, {
							children: ($$anchor, $$slotProps) => {
								Ui_control($$anchor, {
									get hasIconsLeft() {
										return get$3(hasIconsLeft);
									},
									get hasIconsRight() {
										return get$3(hasIconsRight);
									},
									children: ($$anchor, $$slotProps) => {
										var fragment_4 = root_4$7();
										var node = first_child(fragment_4);

										Ui_textfield(node, spread_props(
											{
												get placeholder() {
													return placeholder();
												},
												get fieldname() {
													return fieldname();
												},
												get required() {
													return required();
												},
												get size() {
													return size();
												},
												role: "searchbox"
											},
											() => others,
											{
												get value() {
													return term();
												},
												set value($$value) {
													term($$value);
												}
											}
										));

										var node_1 = sibling(node, 2);

										{
											var consequent = ($$anchor) => {
												Ui_icon_font($$anchor, {
													get font() {
														return icon();
													},
													get side() {
														return iconSide();
													}
												});
											};

											if_block(node_1, ($$render) => {
												if (icon()) $$render(consequent);
											});
										}

										append($$anchor, fragment_4);
									},
									$$slots: { default: true }
								});
							},
							$$slots: { default: true }
						});
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});
	}

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIBoolean: Ui_boolean,
		UIBooleanLabeled: Ui_boolean_labeled,
		UIBooleans: Ui_booleans,
		UICensored: Ui_censored,
		UIErrorsList: Ui_errors_list,
		UIIndicator: Ui_indicator,
		UILoader: Ui_loader,
		UIProgress: Ui_progress,
		UISelectFromModelOnDemandInline: Ui_select_from_model_on_demand_inline,
		UISelectFromModelWithSearchModal: Ui_select_from_model_with_search_modal,
		UIShowOneFromList: Ui_show_one_from_list,
		UISimpleSearchInput: Ui_simple_search_input,
		UITag: Ui_tag,
		UITagValue: Ui_tag_value,
		UITagValueList: Ui_tag_value_list,
		UITitle: Ui_title,
		UIUserCard: Ui_user_card
	});

	function Ui_form_input_errors($$anchor, $$props) {
		push($$props, true);

		let id = prop($$props, 'id', 3, "generic-field"),
			classes = prop($$props, 'class', 3, "");

		let allErrors = state(proxy([]));
		let showErrors = state(true);

		user_effect(() => {
			set(allErrors, proxy([
				...Array.isArray($$props.errors) ? $$props.errors : [],
				...Array.isArray($$props.formErrors) ? $$props.formErrors : []
			]));

			set(showErrors, proxy($$props.inputStarted && $$props.validated && !$$props.valid));
		});

		Ui_errors_list($$anchor, {
			get show() {
				return get$3(showErrors);
			},
			get errors() {
				return get$3(allErrors);
			},
			get class() {
				return classes();
			},
			get id() {
				return id();
			}
		});

		pop();
	}

	var root$i = template(`<span class="is-tag-container"><!> <!></span>`);

	function Ui_icon_button_with_tag($$anchor, $$props) {
		push($$props, true);

		let button = prop($$props, 'button', 19, () => ({})),
			tag = prop($$props, 'tag', 19, () => ({}));

		let vars = state(proxy({}));

		let tagPosition = {
			left: !!$$props.left,
			right: !!$$props.right,
			top: !!$$props.top,
			bottom: !!$$props.bottom
		};

		onMount(() => {
			if ($$props.left) {
				get$3(vars)[`--siding-left-size`] = $$props.left;
			}

			if ($$props.right) {
				get$3(vars)["--siding-right-size"] = $$props.right;
			}

			if ($$props.top) {
				get$3(vars)["--siding-top-size"] = $$props.top;
			}

			if ($$props.bottom) {
				get$3(vars)["--siding-bottom-size"] = $$props.bottom;
			}

			set(vars, proxy(get$3(vars)));
		});

		var span = root$i();
		var node = child(span);

		Ui_button(node, spread_props(button));

		var node_1 = sibling(node, 2);

		Ui_tag(node_1, spread_props(
			tag,
			{
				get vars() {
					return get$3(vars);
				}
			},
			tagPosition
		));

		reset(span);
		append($$anchor, span);
		pop();
	}

	var root$h = template(`<div><!></div>`);

	function Ui_icon_floating($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [trigger] - export let direction = 'left';  //left/right/top/bottom/around
		 */
		/** @type {Props} */
		let trigger = prop($$props, 'trigger', 19, () => ({
				title: "Click me!",
				icon: "plus",
				color: "primary",
				size: "medium",
				onclick: () => true
			})),
			top = prop($$props, 'top', 3, "2em"),
			left = prop($$props, 'left', 3, "2em"),
			classes = prop($$props, 'class', 3, "");

		let positionStyle = state("");

		onMount(() => {
			set(positionStyle, "");

			if (top()) {
				set(positionStyle, get$3(positionStyle) + `top: ${top()};`);
			}

			if (left()) {
				set(positionStyle, get$3(positionStyle) + `left: ${left()};`);
			}

			if ($$props.right) {
				set(positionStyle, get$3(positionStyle) + `right: ${$$props.right};`);
			}

			if ($$props.bottom) {
				set(positionStyle, get$3(positionStyle) + `bottom: ${$$props.bottom};`);
			}
		});

		var div = root$h();
		var node = child(div);

		Ui_button(node, spread_props(trigger));
		reset(div);

		template_effect(() => {
			set_class(div, `is-absolute ${classes() ?? ''}`);
			set_attribute(div, 'style', get$3(positionStyle));
		});

		append($$anchor, div);
		pop();
	}

	var root_3$7 = template(`<span class="icon"><!></span>`);
	var root_5$7 = template(`<figure><img></figure>`);

	function Ui_icon($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [title = ""] - font icon title
		 * @property {string} [size = ""]  - font icon size
		 * @property {string} [font = ""] - font icon name
		 * @property {string} [svg = ""] - svg icon
		 * @property {string} [src = ""] - image icon
		 * @property {number|string} width
		 * @property {number|string} height
		 */
		/** @type {Props} */
		let title = prop($$props, 'title', 3, ""),
			size = prop($$props, 'size', 3, ""),
			font = prop($$props, 'font', 3, ""),
			svg = prop($$props, 'svg', 3, ""),
			src = prop($$props, 'src', 3, "");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return font();
					},
					get size() {
						return size();
					},
					get title() {
						return title();
					}
				});
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var span = root_3$7();
						var node_2 = child(span);

						html(node_2, svg);
						reset(span);
						append($$anchor, span);
					};

					var alternate = ($$anchor) => {
						var fragment_3 = comment();
						var node_3 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								var figure = root_5$7();
								var img = child(figure);

								reset(figure);

								template_effect(() => {
									set_class(figure, `image ${($$props.width && $$props.height ? `is-${$$props.width}x${$$props.height}` : '') ?? ''} `);
									set_attribute(img, 'src', src());
									set_attribute(img, 'title', title());
									set_attribute(img, 'alt', title());
									set_attribute(img, 'width', $$props.width);
									set_attribute(img, 'height', $$props.height);
								});

								append($$anchor, figure);
							};

							if_block(
								node_3,
								($$render) => {
									if (src()) $$render(consequent_2);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (svg()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (font()) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
	}

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIIcon: Ui_icon,
		UIIconButtonWithTag: Ui_icon_button_with_tag,
		UIIconFloating: Ui_icon_floating,
		UIIconFont: Ui_icon_font
	});

	function Ui_form_input_validated_icon($$anchor, $$props) {
		let side = prop($$props, 'side', 3, "right"),
			size = prop($$props, 'size', 3, "small");

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				const expression = derived(() => $$props.valid ? "check" : "exclamation-triangle");

				Ui_icon_font($$anchor, {
					get font() {
						return get$3(expression);
					},
					get side() {
						return side();
					},
					get size() {
						return size();
					}
				});
			};

			if_block(node, ($$render) => {
				if ($$props.validated === true) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root$g = template(`<!> <!> <!>`, 1);

	function Ui_form_input($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {any} [value]
		 * @property {boolean} [readonly]
		 * @property {object}  UIInput
		 * @property {string} fieldtype
		 * @property {string} fieldname
		 * @property {string} [fieldnamePrefix = "form-field-"]
		 * @property {string} [icon]
		 * @property {string} [iconSide = 'left']
		 * @property {string} [iconSize= 'small']
		 * @property {boolean} [valid = true]
		 * @property {boolean} [validated = false]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, "");
			prop($$props, 'fieldnamePrefix', 3, "form-field-");
			let valid = prop($$props, 'valid', 3, true),
			validated = prop($$props, 'validated', 3, false),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'readonly',
				'UIInput',
				'label',
				'fieldtype',
				'fieldname',
				'fieldnamePrefix',
				'icon',
				'valid',
				'validated'
			]);

		var fragment = root$g();
		var node = first_child(fragment);

		component(node, () => $$props.UIInput, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(
				{
					get fieldtype() {
						return $$props.fieldtype;
					},
					get fieldname() {
						return $$props.fieldname;
					},
					get valid() {
						return valid();
					},
					get readonly() {
						return $$props.readonly;
					}
				},
				() => others,
				{
					get value() {
						return value();
					},
					set value($$value) {
						value($$value);
					}
				}
			));
		});

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, {
					get font() {
						return $$props.icon;
					},
					side: iconSide,
					size: iconSize
				});
			};

			if_block(node_1, ($$render) => {
				if ($$props.icon) $$render(consequent);
			});
		}

		var node_2 = sibling(node_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				Ui_form_input_validated_icon($$anchor, {
					get validated() {
						return validated();
					},
					get valid() {
						return valid();
					}
				});
			};

			if_block(node_2, ($$render) => {
				if (!$$props.readonly) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
	}

	var root_4$6 = template(`<!> <!>`, 1);
	var root_6$6 = template(` <!>`, 1);
	var root$f = template(`<!> <!>`, 1);

	function Ui_form_control($$anchor, $$props) {
		const control = ($$anchor) => {
			Ui_control($$anchor, {
				get class() {
					return get$3(iconClasses);
				},
				children: ($$anchor, $$slotProps) => {
					Ui_form_input($$anchor, spread_props(
						{
							get UIInput() {
								return $$props.UIInput;
							},
							get placeholder() {
								return placeholder();
							},
							get fieldtype() {
								return $$props.fieldtype;
							},
							get fieldname() {
								return $$props.fieldname;
							},
							get fieldnamePrefix() {
								return fieldnamePrefix();
							},
							get icon() {
								return icon();
							},
							get iconSide() {
								return iconSide();
							},
							get iconSize() {
								return iconSize();
							},
							get required() {
								return required();
							},
							get readonly() {
								return readonly();
							},
							get disabled() {
								return disabled();
							},
							get inputStarted() {
								return inputStarted();
							},
							get validated() {
								return validated();
							},
							get valid() {
								return valid();
							},
							get onchange() {
								return onchange();
							},
							get onerror() {
								return onerror();
							}
						},
						() => others,
						{
							get value() {
								return value();
							},
							set value($$value) {
								value($$value);
							}
						}
					));
				},
				$$slots: { default: true }
			});
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [inputStarted]
		 * @property {boolean} [value]
		 * @property {string} [label]
		 * @property {string} [placeholder]
		 * @property {string} fieldname
		 * @property {string} fieldtype
		 * @property {string} [icon]
		 * @property {string} [iconSide]
		 * @property {string} [iconSize]
		 * @property {boolean} [required = false]
		 * @property {boolean} [readonly]
		 * @property {boolean} [disabled]
		 * @property {import('../events.types').UIEventInputChangeCallback} [onchange]
		 * @property {boolean} [valid]
		 * @property {boolean} [validated]
		 * @property {boolean} [errors]
		 * @property {boolean} [formErrors]
		 */
		/** @type {Props} */
		let value = prop($$props, 'value', 15, ""),
			inputStarted = prop($$props, 'inputStarted', 3, false),
			labelVertical = prop($$props, 'labelVertical', 3, true),
			placeholder = prop($$props, 'placeholder', 3, ""),
			fieldnamePrefix = prop($$props, 'fieldnamePrefix', 3, "form-field-"),
			icon = prop($$props, 'icon', 3, ""),
			iconSide = prop($$props, 'iconSide', 3, "left"),
			iconSize = prop($$props, 'iconSize', 3, "small"),
			required = prop($$props, 'required', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			disabled = prop($$props, 'disabled', 3, false),
			valid = prop($$props, 'valid', 3, true),
			validated = prop($$props, 'validated', 3, false),
			onchange = prop($$props, 'onchange', 3, () => true),
			onerror = prop($$props, 'onerror', 3, () => true),
			formErrors = prop($$props, 'formErrors', 19, () => []),
			errors = prop($$props, 'errors', 19, () => []),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'value',
				'UIInput',
				'inputStarted',
				'label',
				'labelVertical',
				'placeholder',
				'fieldtype',
				'fieldname',
				'fieldnamePrefix',
				'icon',
				'iconSide',
				'iconSize',
				'required',
				'readonly',
				'disabled',
				'valid',
				'validated',
				'onchange',
				'onerror',
				'formErrors',
				'errors'
			]);

		let iconClasses = derived(() => (icon() ? " has-icons-left " : "") + " has-icons-right ");
		var fragment_2 = root$f();
		var node = first_child(fragment_2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_1 = first_child(fragment_3);

				{
					var consequent = ($$anchor) => {
						var fragment_4 = root_4$6();
						var node_2 = first_child(fragment_4);

						Ui_label(node_2, {
							get class() {
								return $$props.fieldtype;
							},
							get for() {
								return `${fieldnamePrefix() ?? ''}${$$props.fieldtype ?? ''}-${$$props.fieldname ?? ''}`;
							},
							get label() {
								return $$props.label;
							}
						});

						var node_3 = sibling(node_2, 2);

						control(node_3);
						append($$anchor, fragment_4);
					};

					var alternate = ($$anchor) => {
						Ui_label($$anchor, {
							get class() {
								return $$props.fieldtype;
							},
							get for() {
								return `${fieldnamePrefix() ?? ''}${$$props.fieldtype ?? ''}-${$$props.fieldname ?? ''}`;
							},
							children: ($$anchor, $$slotProps) => {
								next();

								var fragment_6 = root_6$6();
								var text = first_child(fragment_6);
								var node_4 = sibling(text);

								control(node_4);
								template_effect(() => set_text(text, `${$$props.label ?? ''}: `));
								append($$anchor, fragment_6);
							},
							$$slots: { default: true }
						});
					};

					if_block(node_1, ($$render) => {
						if (labelVertical()) $$render(consequent); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_3);
			};

			var alternate_1 = ($$anchor) => {
				control($$anchor);
			};

			if_block(node, ($$render) => {
				if ($$props.label) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		var node_5 = sibling(node, 2);

		Ui_form_input_errors(node_5, {
			get inputStarted() {
				return inputStarted();
			},
			get validated() {
				return validated();
			},
			get valid() {
				return valid();
			},
			get errors() {
				return errors();
			},
			get formErrors() {
				return formErrors();
			},
			get id() {
				return `input-field-helper-${$$props.fieldname ?? ''}`;
			}
		});

		append($$anchor, fragment_2);
	}

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIFormControl: Ui_form_control,
		UIFormInput: Ui_form_input,
		UIFormInputErrors: Ui_form_input_errors,
		UIFormInputValidatedIcon: Ui_form_input_validated_icon
	});

	function Ui_images($$anchor, $$props) {
		let values = prop($$props, 'values', 19, () => []),
			override = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'values']);

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.url, ($$anchor, item) => {
			Ui_image($$anchor, spread_props(() => get$3(item), () => override));
		});

		append($$anchor, fragment);
	}

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIImage: Ui_image,
		UIImages: Ui_images
	});

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UILink: Ui_link,
		UILinks: Ui_links
	});

	function Ui_endless_list_navigation($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {number}   [page]                - current page
		 * @property {number}   [pages]               - total count of pages
		 * @property {any}      [buttonsRowComponent = UIButtonsRow] - buttons row ui svelte component
		 * @property {object}   [buttonsRowComponentProps]   - buttons row component properties
		 * @property {object}   [buttonPrevProps]   - prev button ui component properties
		 * @property {object}   [buttonProgressProps]   - center/progress button ui component properties
		 * @property {object}   [buttonNextProps]   - next button ui component properties
		 * @property {function} [onnext]            - callback on next
		 * @property {function} [onprev]            - callback on prev
		 * @property    {string}    [progressTitleStart = '']  - prefix of progress button title
		 * @property    {string}    [progressTitleDelimiter = ' / ']  - text that breaks numbers of current page and total count of pages
		 * @property    {string}    [progressTitleEnd = '']  - suffix of progress button title
		 */
		/** @type {Props} */
		let page = prop($$props, 'page', 7, 0),
			pages = prop($$props, 'pages', 3, 0),
			UIButtonsRowComponent = prop($$props, 'buttonsRowComponent', 3, Ui_buttons_row),
			buttonsRowComponentProps = prop($$props, 'buttonsRowComponentProps', 19, () => ({})),
			buttonPrevProps = prop($$props, 'buttonPrevProps', 19, () => ({
				title: "not-node:list_navigation_prev_button_label"
			})),
			buttonProgressProps = prop($$props, 'buttonProgressProps', 19, () => ({})),
			buttonNextProps = prop($$props, 'buttonNextProps', 19, () => ({
				title: "not-node:list_navigation_next_button_label"
			})),
			onprev = prop($$props, 'onprev', 3, () => {
				page() > 0 && update_prop(page, -1);
			}),
			onnext = prop($$props, 'onnext', 3, () => {
				page() < pages() - 1 && update_prop(page);
			}),
			progressTitleStart = prop($$props, 'progressTitleStart', 3, ""),
			progressTitleDelimiter = prop($$props, 'progressTitleDelimiter', 3, " / "),
			progressTitleEnd = prop($$props, 'progressTitleEnd', 3, "");

		let currentPage = derived(() => page() + 1);
		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);
				const expression = derived(() => get$3(currentPage) > 1
					? [
						{
							...buttonPrevProps(),
							action: onprev()
						}
					]
					: []);
				const expression_1 = derived(() => pages() > 1
					? [
						{
							...buttonProgressProps(),
							title: `${progressTitleStart()}${get$3(currentPage)}${progressTitleDelimiter()}${pages()}${progressTitleEnd()}`,
							disabled: true
						}
					]
					: []);
				const expression_2 = derived(() => get$3(currentPage) < pages()
					? [
						{
							...buttonNextProps(),
							action: onnext()
						}
					]
					: []);

				component(node_1, UIButtonsRowComponent, ($$anchor, $$component) => {
					$$component($$anchor, spread_props(buttonsRowComponentProps, {
						get left() {
							return get$3(expression);
						},
						get center() {
							return get$3(expression_1);
						},
						get right() {
							return get$3(expression_2);
						}
					}));
				});

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (pages() > 0) $$render(consequent);
			});
		}

		append($$anchor, fragment);
	}

	var root_1$b = template(`<span> </span>`);

	function Ui_endless_list_simple_item($$anchor, $$props) {
		push($$props, true);

		function click(e) {
			e.preventDefault();

			$$props.onclick({
				_id: $$props._id,
				id: $$props.id,
				title: $$props.title
			});

			return false;
		}

		Ui_box($$anchor, {
			onclick: click,
			onkeyup: click,
			class: 'list-item-selectable',
			children: ($$anchor, $$slotProps) => {
				var span = root_1$b();
				var text = child(span, true);

				reset(span);
				template_effect(() => set_text(text, $$props.title));
				append($$anchor, span);
			},
			$$slots: { default: true }
		});

		pop();
	}

	var root$e = template(`<!> <!>`, 1);

	function Ui_endless_list($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {any} [data]
		 * @property {any} [itemComponent = UIEndlessListSimpleItem] - list element
		 * @property {any} [itemComponentProps]
		 * @property {any} [emptyListPlaceholderComponent = UIEndlessListEmptyPlaceholder] - if list is empty
		 * @property {any} [emptyListPlaceholderComponentProps]
		 * @property {any} [listNavigationComponent = UIEndlessListNavigation] - prev and next block
		 * @property {any} [listNavigationComponentProps]
		 */
		/** @type {Props} */
		let classes = prop($$props, 'class', 3, ""),
			data = prop($$props, 'data', 31, () => proxy({
				list: [],
				skip: 0,
				count: 0,
				page: 0,
				pages: 0
			})),
			UIItemComponent = prop($$props, 'itemComponent', 3, Ui_endless_list_simple_item),
			itemComponentProps = prop($$props, 'itemComponentProps', 19, () => ({})),
			UIEmptyListPlaceholder = prop($$props, 'emptyListPlaceholderComponent', 3, Ui_list_empty_placeholder),
			emptyListPlaceholderComponentProps = prop($$props, 'emptyListPlaceholderComponentProps', 19, () => ({})),
			UINavigationComponent = prop($$props, 'listNavigationComponent', 3, Ui_endless_list_navigation),
			listNavigationComponentProps = prop($$props, 'listNavigationComponentProps', 19, () => ({}));

		var fragment = root$e();
		var node = first_child(fragment);

		Ui_block(node, {
			get class() {
				return classes();
			},
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_2 = comment();
						var node_2 = first_child(fragment_2);

						each(node_2, 19, () => data().list, (item) => item.id, ($$anchor, item, index) => {
							var fragment_3 = comment();
							var node_3 = first_child(fragment_3);

							{
								var consequent = ($$anchor) => {
									var fragment_4 = comment();
									var node_4 = first_child(fragment_4);

									snippet(node_4, () => $$props.itemRenderer, () => get$3(item), () => get$3(index));
									append($$anchor, fragment_4);
								};

								var alternate = ($$anchor) => {
									var fragment_5 = comment();
									var node_5 = first_child(fragment_5);

									component(node_5, UIItemComponent, ($$anchor, $$component) => {
										$$component($$anchor, spread_props(
											{
												get onclick() {
													return $$props.onselect;
												}
											},
											itemComponentProps,
											() => get$3(item)
										));
									});

									append($$anchor, fragment_5);
								};

								if_block(node_3, ($$render) => {
									if ($$props.itemRenderer) $$render(consequent); else $$render(alternate, false);
								});
							}

							append($$anchor, fragment_3);
						});

						append($$anchor, fragment_2);
					};

					var alternate_1 = ($$anchor) => {
						var fragment_6 = comment();
						var node_6 = first_child(fragment_6);

						component(node_6, UIEmptyListPlaceholder, ($$anchor, $$component) => {
							$$component($$anchor, spread_props(emptyListPlaceholderComponentProps));
						});

						append($$anchor, fragment_6);
					};

					if_block(node_1, ($$render) => {
						if (data()?.list?.length) $$render(consequent_1); else $$render(alternate_1, false);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		});

		var node_7 = sibling(node, 2);

		component(node_7, UINavigationComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listNavigationComponentProps, {
				get onprev() {
					return $$props.onprev;
				},
				get onnext() {
					return $$props.onnext;
				},
				get page() {
					return data().page;
				},
				set page($$value) {
					data(data().page = $$value, true);
				},
				get pages() {
					return data().pages;
				},
				set pages($$value) {
					data(data().pages = $$value, true);
				},
				get skip() {
					return data().skip;
				},
				set skip($$value) {
					data(data().skip = $$value, true);
				},
				get count() {
					return data().count;
				},
				set count($$value) {
					data(data().count = $$value, true);
				}
			}));
		});

		append($$anchor, fragment);
		pop();
	}

	function Ui_list_select($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [fieldname = "list-select"]                             field name
		 * @property {boolean}      [multiple = false]                                      if want not one variant selected
		 * @property {boolean}      [atLeastOne = true]                                     no empty result
		 * @property {array<import('./types.js').Variants>} [variants = []]           variants to select from
		 * @property {array<object>} value                                                  [...selectedItemsValues]
		 * @property {array<string|number>} [selectedVariantsIds = []]                      [...selectedItemsIds]
		 * @property {function}     [titleComponent = UITitle]
		 * @property {object}       [titleComponentProps= { size: 5 }]
		 * @property {function}     [imageComponent = UIImage]
		 * @property {object}       [imageComponentProps= { covered: true }]
		 * @property {function}     [listComponent = UIList]
		 * @property {object}       [listComponentProps = {actionsVisible: true}]
		 * @property {function}     [sublimeValue = (value) => value.id]
		 * @property {function}     [updateVariant = (valueId, props, toggleTitle) => void]
		 * @property {function}     [getItemIndex = (items, valueId) => number]
		 * @property {function}     [getItem = (items, { valueId }) => object]
		 * @property {function}     [getItemValue = (items, { valueId }) => object]
		 * @property {function}     [getDefaultItemSublime = (items) => string]
		 * @property {function}     [updateVariant = (items, valueId, props, toggleTitle) => void]
		 * @property {function}     [uiOn = (items, { valueId }) => void]
		 * @property {function}     [uiOff = (items, { valueId }) => void]
		 * @property {function}     [extendVariantToItemList = (item) => object]
		 */
		let items = state(proxy([]));

		/** @type {Props} */
		let fieldname = prop($$props, 'fieldname', 3, "list-select"),
			multiple = prop($$props, 'multiple', 3, false),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			variants = prop($$props, 'variants', 19, () => []),
			value = prop($$props, 'value', 23, () => []),
			selectedVariantsIds = prop($$props, 'selectedVariantsIds', 23, () => []),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({ actionsVisible: true })),
			sublimeValue = prop($$props, 'sublimeValue', 3, (value) => value.id),
			getItemIndex = prop($$props, 'getItemIndex', 3, (items, valueId) => items.findIndex((val) => val.value.id === valueId)),
			getItem = prop($$props, 'getItem', 3, (items, { valueId }) => {
				const index = getItemIndex()(items, valueId);

				//returns variants by its id
				return index > -1 ? items.find((btnVal) => btnVal.value.id === valueId) : undefined;
			}),
			getItemValue = prop($$props, 'getItemValue', 3, (items, { valueId }) => {
				// returns variant's value by id of variant
				const item = getItem()(items, { valueId });

				return item ? item.value : undefined;
			}),
			getDefaultItemSublime = prop($$props, 'getDefaultItemSublime', 3, (items) => {
				return items && items.length ? items[0].id : undefined;
			}),
			updateVariant = prop($$props, 'updateVariant', 3, (items, valueId, itemProps, buttonProps) => {
				const index = getItemIndex()(items, valueId);

				if (index === -1) {
					return;
				}

				Object.keys(itemProps).forEach((key) => {
					items[index][key] = itemProps[key];
				});

				if (Array.isArray(items[index].actions) && items[index].actions.length) {
					Object.keys(buttonProps).forEach((key) => {
						items[index].actions[0][key] = buttonProps[key];
					});
				}
			}),
			uiOn = prop($$props, 'uiOn', 3, (items, { valueId }) => {
				updateVariant()(items, valueId, { class: "has-background-success" }, {
					title: "not-node:booleans_true",
					color: "success"
				});
			}),
			uiOff = prop($$props, 'uiOff', 3, (items, { valueId }) => {
				updateVariant()(items, valueId, { class: "" }, {
					title: "not-node:booleans_false",
					color: "danger"
				});
			}),
			extendVariantToItemList = prop($$props, 'extendVariantToItemList', 3, (itm) => {
				const res = { ...itm };

				res.actions = [
					{
						title: "not-node:booleans_false",
						color: "danger",
						light: true,
						action: toggle
					}
				];

				return res;
			}),
			others = rest_props($$props, [
				'$$slots',
				'$$events',
				'$$legacy',
				'fieldname',
				'multiple',
				'atLeastOne',
				'variants',
				'value',
				'selectedVariantsIds',
				'titleComponentProps',
				'imageComponent',
				'imageComponentProps',
				'listComponent',
				'listComponentProps',
				'sublimeValue',
				'getItemIndex',
				'getItem',
				'getItemValue',
				'getDefaultItemSublime',
				'updateVariant',
				'uiOn',
				'uiOff',
				'extendVariantToItemList',
				'onchange'
			]);

		onMount(() => {
			set(items, proxy(variants().map(extendVariantToItemList())));

			if (value() && Array.isArray(value())) {
				if (atLeastOne() && value().length) {
					value().forEach((itemValue) => {
						let ui = updateSelected(itemValue);

						updateUI(ui);
					});
				}

				return;
			}

			selectDefault();
		});

		//
		function countOfSelected() {
			return Array.isArray(value()) ? selectedVariantsIds().length : 0;
		}

		const notLastOne = () => !(atLeastOne() && countOfSelected() === 1);

		//
		function updateSelected(detail) {
			const valueId = sublimeValue()(detail);
			let ui = { on: undefined, off: undefined };

			//
			if (!Array.isArray(selectedVariantsIds())) {
				selectedVariantsIds([]);
			}

			if (multiple()) {
				if (selectedVariantsIds().includes(valueId)) {
					if (notLastOne()) {
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
						ui.off = { valueId };
					}
				} else {
					selectedVariantsIds().push(valueId);
					ui.on = { valueId };
				}
			} else {
				if (atLeastOne()) {
					if (!selectedVariantsIds().includes(valueId)) {
						if (countOfSelected() > 0) {
							ui.off = { valueId: selectedVariantsIds().pop() };
						}

						ui.on = { valueId };
						selectedVariantsIds([valueId]);
					}
				} else {
					if (selectedVariantsIds().includes(valueId)) {
						ui.off = { valueId };
						selectedVariantsIds().splice(selectedVariantsIds().indexOf(valueId), 1);
					} else {
						ui.on = { valueId };
						selectedVariantsIds().push(valueId);
					}
				}
			}

			return ui;
		}

		//
		function toggle(detail) {
			let ui = updateSelected(detail);

			updateUI(ui);
			//
			updateValue();

			//
			$$props.onchange({
				field: fieldname(),
				value: snapshot(value()),
				ids: snapshot(selectedVariantsIds())
			});
		}

		//
		function updateUI(changes) {
			if (changes.off) {
				uiOff()(get$3(items), changes.off);
			}

			if (changes.on) {
				uiOn()(get$3(items), changes.on);
			}
		}

		//
		function updateValue() {
			let newVal = [];

			if (typeof selectedVariantsIds() !== "undefined" && Array.isArray(selectedVariantsIds())) {
				newVal = selectedVariantsIds().filter((val) => typeof val !== "undefined").map((valueId) => getItemValue()(get$3(items), { valueId }));
			}

			value(newVal);
		}

		//
		function selectDefault() {
			if (atLeastOne() && get$3(items).length > 0) {
				const defValueId = getDefaultItemSublime()(get$3(items));

				if (defValueId) {
					toggle({ id: defValueId });
				}
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		component(node, UIListComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(
				{
					get titleComponentProps() {
						return titleComponentProps();
					},
					get imageComponent() {
						return imageComponent();
					},
					get imageComponentProps() {
						return imageComponentProps();
					}
				},
				() => others,
				listComponentProps,
				{
					get items() {
						return get$3(items);
					}
				}
			));
		});

		append($$anchor, fragment);
		pop();
	}

	/**
	 * Collection of static methods to work with SelectorGroups objects
	 *
	 * @class ListGroupsUITreeDTO
	 */
	let ListGroupsUITreeDTO = /*#__PURE__*/function () {
	  function ListGroupsUITreeDTO() {
	    _classCallCheck(this, ListGroupsUITreeDTO);
	  }
	  return _createClass(ListGroupsUITreeDTO, null, [{
	    key: "convertGroupTitle",
	    value:
	    /**
	     *
	     * Returns title field from object as string
	     * @static
	     * @param {Object}  val
	     * @param {string}  val.title
	     * @return {string}
	     * @memberof ListGroupsUITreeDTO
	     */
	    function convertGroupTitle({
	      title
	    }) {
	      return title;
	    } //refactored

	    /**
	     *
	     * Returns image field from object as string
	     * @static
	     * @param {Object}  val
	     * @param {string}  val.image
	     * @return {string}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertGroupImage",
	    value: function convertGroupImage({
	      image
	    }) {
	      return image;
	    } //refactored

	    /**
	     * Converts variant object to selector item object
	     *
	     * @static
	     * @param {import('../../types.js').Variant} variant
	     * @return {import('../../types.js').SelectorItem}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertVariant",
	    value: function convertVariant(variant, groupId) {
	      return {
	        id: variant.id,
	        title: variant.title,
	        value: {
	          valueId: variant.id,
	          groupId
	        } //what we will sublime
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').VariantsGroup} group
	     * @return {import('../../types.js').SelectorGroup}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "convertVariantsGroup",
	    value: function convertVariantsGroup(group) {
	      var _this = this;
	      return {
	        id: group.id,
	        title: this.convertGroupTitle(group),
	        image: this.convertGroupImage(group),
	        description: {
	          values: group.variants.map(function (itm) {
	            return _this.convertVariant(itm, group.id);
	          })
	        }
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').VariantsGroups} variants
	     * @return {import('../../types.js').SelectorGroups}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "buildSelectorItemsFromVariants",
	    value: function buildSelectorItemsFromVariants(variants) {
	      var _this2 = this;
	      return variants.map(function (itm) {
	        return _this2.convertVariantsGroup(itm);
	      });
	    } //refactored

	    /**
	     *
	     * Returns {group: number, id: number} as SelectedVariant type {groupId: string|number, valueId: string|number}
	     * @static
	     * @param   {object} value
	     * @return  {import('../../types.js').SelectedVariant}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "sublimeValue",
	    value: function sublimeValue(value) {
	      return {
	        groupId: value.group || value.groupId,
	        valueId: value.id || value.valueId
	      };
	    } //refactored

	    /**
	     * Returns index of group in array by groupId or undefined if its not found
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} groupId
	     * @static
	     * @returns {number|undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroupIndex",
	    value: function getSelectorGroupIndex(selectorGroupsItems, groupId) {
	      const index = selectorGroupsItems.findIndex(function (group) {
	        return group.id === groupId;
	      });
	      return index > -1 ? index : undefined;
	    } //refactored

	    /**
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} index
	     * @return {import('../../types.js').SelectorGroup}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroup",
	    value: function getSelectorGroup(selectorGroupsItems, index) {
	      return selectorGroupsItems[index];
	    } //refactored

	    /**
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroup} group
	     * @return {boolean}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "selectorGroupHasVariants",
	    value: function selectorGroupHasVariants(group) {
	      return group && group.description && Array.isArray(group.description.values);
	    } //refactored

	    /**
	     *
	     *
	     * @param {import('../../types.js').SelectorGroup} group
	     * @return {import("../../types.js").SelectorItems}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorGroupVariants",
	    value: function getSelectorGroupVariants(group) {
	      return group.description.values;
	    }

	    /**
	     * Returns comparation function, (val: SelectorItem)=>boolean,
	     * which checks if val has specified variantId
	     *
	     * @static
	     * @param {import('../../types.js').VariantId} variantId
	     * @return {function}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "compareSelectorGroupValueIdWith",
	    value: function compareSelectorGroupValueIdWith(variantId) {
	      return function (val) {
	        return val?.value?.valueId === variantId;
	      };
	    } //refactored

	    /**
	     * Returns index of item in group by groupIndex and item valueId or undefined if its not found
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {number} groupIndex
	     * @param {import('../../types.js').VariantId} valueId
	     * @returns {number|undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItemIndex",
	    value: function getSelectorItemIndex(selectorGroupsItems, groupIndex, valueId) {
	      const group = this.getSelectorGroup(selectorGroupsItems, groupIndex);
	      if (!this.selectorGroupHasVariants(group)) {
	        return undefined;
	      }
	      const itemIndex = this.getSelectorGroupVariants(group).findIndex(this.compareSelectorGroupValueIdWith(valueId));
	      return itemIndex > -1 ? itemIndex : undefined;
	    } //refactored

	    /**
	     * Returns {groupIndex: number, itemIndex: number} or undefined from VariantsGroups by groupId, valueId
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').VariantId} groupId
	     * @param {import('../../types.js').VariantId} valueId
	     * @return {import('../../types.js').ItemIndexes | undefined}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItemIndexes",
	    value: function getSelectorItemIndexes(selectorGroupsItems, groupId, valueId) {
	      const groupIndex = this.getSelectorGroupIndex(selectorGroupsItems, groupId);
	      if (groupIndex === -1 || typeof groupIndex === "undefined") {
	        return undefined;
	      }
	      const itemIndex = this.getSelectorItemIndex(selectorGroupsItems, groupIndex, valueId);
	      if (itemIndex === -1 || typeof itemIndex === "undefined") {
	        return undefined;
	      }
	      return {
	        groupIndex,
	        itemIndex
	      };
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups}   selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}       itemIds
	     * @return {import('../../types.js').SelectorItem}
	     * @memberof ListGroupsUITreeDTO
	     */
	  }, {
	    key: "getSelectorItem",
	    value: function getSelectorItem(selectorGroupsItems, itemIds) {
	      /** @type {import('../../types.js').ItemIndexes | undefined} */
	      const indexes = this.getSelectorItemIndexes(selectorGroupsItems, itemIds.groupId, itemIds.valueId);
	      if (indexes) {
	        const group = this.getSelectorGroup(selectorGroupsItems, indexes.groupIndex);
	        if (!this.selectorGroupHasVariants(group)) {
	          return undefined;
	        }
	        const groupVariants = this.getSelectorGroupVariants(group);
	        return groupVariants[indexes.itemIndex];
	      }
	      return undefined;
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @return {import('../../types.js').SelectedVariant | undefined}
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "getDefaultSelectorItemSublime",
	    value: function getDefaultSelectorItemSublime(selectorGroupsItems) {
	      if (selectorGroupsItems && selectorGroupsItems.length && this.selectorGroupHasVariants(selectorGroupsItems[0])) {
	        const groupId = selectorGroupsItems[0].id;
	        const valueId = selectorGroupsItems[0].description.values[0]?.value?.valueId;
	        if (UICommon$1.stringsOfNumbers([groupId, valueId])) {
	          return {
	            groupId,
	            valueId
	          };
	        }
	      }
	      return undefined;
	    } //refactored

	    /**
	     * Changes selector items
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds} itemIds
	     * @param {object} itemProps
	     * @param {object} actionsUIProps
	     * @return {undefined}
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "updateSelectorItem",
	    value: function updateSelectorItem(selectorGroupsItems, itemIds, itemProps, actionsUIProps) {
	      const indexes = this.getSelectorItemIndexes(selectorGroupsItems, itemIds.groupId, itemIds.valueId);
	      if (typeof indexes === "undefined") {
	        return;
	      }
	      Object.keys(itemProps).forEach(function (key) {
	        selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex][key] = itemProps[key];
	      });
	      if (Array.isArray(selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex].actions) && selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex].actions.length) {
	        Object.keys(uiProps).forEach(function (key) {
	          selectorGroupsItems[indexes.groupIndex].description.values[indexes.itemIndex][0][key] = actionsUIProps[key];
	        });
	      }
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}   itemIds
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "uiOn",
	    value: function uiOn(selectorGroupsItems, itemIds) {
	      this.updateSelectorItem(selectorGroupsItems, itemIds, {
	        ...this.UI_PROPS_DELTA_ON
	      }, {
	        ...this.UI_PROPS_DELTA_ON_ACTION
	      });
	    } //refactored

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectorGroups} selectorGroupsItems
	     * @param {import('../../types.js').ItemIds}   itemIds
	     * @memberof UIListSelectWithGroupsBehaviour
	     */
	  }, {
	    key: "uiOff",
	    value: function uiOff(selectorGroupsItems, itemIds) {
	      this.updateSelectorItem(selectorGroupsItems, itemIds, {
	        ...this.UI_PROPS_DELTA_OFF
	      }, {
	        ...this.UI_PROPS_DELTA_OFF_ACTION
	      });
	    } //refactored
	  }, {
	    key: "syncUIWithValue",
	    value: function syncUIWithValue(selectorGroups, itemInValue) {
	      for (const group of selectorGroups) {
	        const items = this.getSelectorGroupVariants(group);
	        for (const item of items) {
	          const itemIds = {
	            groupId: group.id,
	            valueId: item.id
	          };
	          if (itemInValue(itemIds)) {
	            this.uiOn(selectorGroups, itemIds);
	          } else {
	            this.uiOff(selectorGroups, itemIds);
	          }
	        }
	      }
	      return selectorGroups;
	    }
	  }]);
	}();
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_ON", {
	  class: "has-background-success"
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_OFF", {
	  class: ""
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_ON_ACTION", {
	  title: "not-node:booleans_true",
	  color: "success"
	});
	_defineProperty(ListGroupsUITreeDTO, "UI_PROPS_DELTA_OFF_ACTION", {
	  title: "not-node:booleans_false",
	  color: "danger"
	});

	let ListGroupsValueDTOMultipleBehaviour = /*#__PURE__*/function () {
	  function ListGroupsValueDTOMultipleBehaviour() {
	    _classCallCheck(this, ListGroupsValueDTOMultipleBehaviour);
	  }
	  return _createClass(ListGroupsValueDTOMultipleBehaviour, null, [{
	    key: "countItemsInValue",
	    value: function countItemsInValue(value) {
	      if (value) {
	        return Object.values(value).reduce(function (a, b) {
	          return a += b.length;
	        }, 0);
	      } else {
	        return 0;
	      }
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value) {
	      return typeof value === "object" && Object.values(value).every(this.groupItemsIsValid) ? value : {};
	    }
	  }, {
	    key: "groupItemsIsValid",
	    value: function groupItemsIsValid(groupItems) {
	      if (!Array.isArray(groupItems)) {
	        return false;
	      }
	      return groupItems.every(function (itm) {
	        return UICommon$1.stringOrNumber(itm);
	      });
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item) {
	      return Object.hasOwn(value, item.groupId) && value[item.groupId].includes(item.valueId);
	    }
	  }, {
	    key: "clearFromEmptyGroups",
	    value: function clearFromEmptyGroups(value) {
	      var _this = this;
	      Object.keys(value).forEach(function (key) {
	        if (_this.groupIsEmpty(value[key])) {
	          delete value[key];
	        }
	      });
	    }
	  }, {
	    key: "groupIsEmpty",
	    value: function groupIsEmpty(group) {
	      if (group && Array.isArray(group)) {
	        if (group.length === 0) {
	          return true;
	        }
	      } else {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "groupIsFull",
	    value: function groupIsFull(valueGroup, variantsGroup) {
	      return valueGroup.length === variantsGroup?.variants?.length;
	    }
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      if (options.atLeastOne && this.countItemsInValue(value) === 1) {
	        return;
	      }
	      value[item.groupId].splice(value[item.groupId].indexOf(item.valueId), 1);
	      this.clearFromEmptyGroups(value, options);
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {*} value
	     * @param {*} item
	     * @param {import('../../types.js').ListGroupsOptions} options
	     * @memberof ListGroupsValueDTOMultipleBehaviour
	     */
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item, options) {
	      if (options.onlyOnePerGroup) {
	        value[item.groupId] = [item.valueId];
	      } else {
	        if (!value[item.groupId] || !Array.isArray(value[item.groupId])) {
	          value[item.groupId] = [item.valueId];
	        } else {
	          if (!value[item.groupId].includes(item.valueId)) {
	            value[item.groupId].push(item.valueId);
	          }
	        }
	      }
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll(variants, value, options) {
	      var _this2 = this;
	      variants.forEach(function (variantsGroup) {
	        variantsGroup.variants.forEach(function (variant) {
	          _this2.addItemToValue(value, {
	            valueId: variant.id,
	            groupId: variantsGroup.id
	          }, options);
	        });
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone(variants, value, options) {
	      Object.keys(value).forEach(function (groupId) {
	        delete value[groupId];
	      });
	    }
	  }, {
	    key: "selectAllInGroup",
	    value: function selectAllInGroup(variants, value, groupId, options) {
	      var _this3 = this;
	      if (!UICommon$1.stringOrNumber(groupId)) {
	        return;
	      }
	      const variantsGroup = variants.find(function (itm) {
	        return itm.id == groupId;
	      });
	      if (!variantsGroup || !variantsGroup.variants || !Array.isArray(variantsGroup.variants)) {
	        return;
	      }
	      variantsGroup.variants.forEach(function (variant) {
	        _this3.addItemToValue(value, {
	          groupId,
	          valueId: variant.id
	        });
	      });
	    }
	  }, {
	    key: "selectNoneInGroup",
	    value: function selectNoneInGroup(variants, value, groupId, options) {
	      if (value[groupId]) {
	        delete value[groupId];
	      }
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      var _this4 = this;
	      const result = {};
	      variants.forEach(function (group) {
	        if (_this4.groupIsEmpty(group.id)) return;
	        group.variants.forEach(function (variant) {
	          if (_this4.itemInValue(value, {
	            groupId: group.id,
	            valueId: variant.id
	          })) {
	            if (Array.isArray(result[group.id])) {
	              result[group.id].push(variant);
	            } else {
	              result[group.id] = [variant];
	            }
	          }
	        });
	      });
	      return result;
	    }
	  }]);
	}();

	let ListGroupsValueDTOSingleBehaviour = /*#__PURE__*/function () {
	  function ListGroupsValueDTOSingleBehaviour() {
	    _classCallCheck(this, ListGroupsValueDTOSingleBehaviour);
	  }
	  return _createClass(ListGroupsValueDTOSingleBehaviour, null, [{
	    key: "countItemsInValue",
	    value: function countItemsInValue(value) {
	      return value && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) ? 1 : 0;
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value) {
	      return value && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) ? value : {
	        valueId: undefined,
	        groupId: undefined
	      };
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item) {
	      return Object.hasOwn(value, "groupId") && Object.hasOwn(value, "valueId") && UICommon$1.stringsOfNumbers([value.valueId, value.groupId]) && value.groupId == item.groupId && value.valueId == item.valueId;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {*} value
	     * @param {*} item
	     * @param {import('../../types.js').ListGroupsOptions} options
	     * @memberof ListGroupsValueDTOSingleBehaviour
	     */
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      if (!options.atLeastOne) {
	        value[item.groupId].splice(value[item.groupId].indexOf(item.valueId), 1);
	      }
	    }
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item) {
	      if (typeof value === "undefined") {
	        value = this.initValue();
	      }
	      value.valueId = item.valueId;
	      value.groupId = item.groupId;
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      if (this.countItemsInValue(value)) {
	        return variants.find(function (group) {
	          return group.id === value.groupId;
	        }).variants.find(function (variant) {
	          return variant.id === value.valueId;
	        });
	      } else {
	        return {};
	      }
	    }
	  }]);
	}();

	let ListGroupsValueDTO = /*#__PURE__*/function () {
	  function ListGroupsValueDTO() {
	    _classCallCheck(this, ListGroupsValueDTO);
	  }
	  return _createClass(ListGroupsValueDTO, null, [{
	    key: "behaviour",
	    value: function behaviour(options) {
	      return options.multiple ? ListGroupsValueDTOMultipleBehaviour : ListGroupsValueDTOSingleBehaviour;
	    }
	  }, {
	    key: "initValue",
	    value: function initValue(value, options) {
	      return this.behaviour(options).initValue(value);
	    }
	  }, {
	    key: "itemInValue",
	    value: function itemInValue(value, item, options) {
	      return this.behaviour(options).itemInValue(value, item, options);
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../../types.js').SelectedValues} value
	     * @param {Object} item
	     * @param {ListGroupsOptions} options
	     * @memberof ListGroupsValueDTO
	     */
	  }, {
	    key: "toggle",
	    value: function toggle(value, item, options) {
	      if (this.itemInValue(value, item, options)) {
	        this.removeItemFromValue(value, item, options);
	      } else {
	        this.addItemToValue(value, item, options);
	      }
	    }
	  }, {
	    key: "removeItemFromValue",
	    value: function removeItemFromValue(value, item, options) {
	      this.behaviour(options).removeItemFromValue(value, item, options);
	    }
	  }, {
	    key: "addItemToValue",
	    value: function addItemToValue(value, item, options) {
	      this.behaviour(options).addItemToValue(value, item, options);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll(variants, value, options) {
	      console.log("selectAll");
	      this.behaviour(options).selectAll(variants, value, options);
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone(variants, value, options) {
	      console.log("selectNone");
	      this.behaviour(options).selectNone(variants, value, options);
	    }
	  }, {
	    key: "selectAllInGroup",
	    value: function selectAllInGroup(variants, value, groupId, options) {
	      console.log("selectAllInGroup");
	      this.behaviour(options).selectAllInGroup(variants, value, groupId, options);
	    }
	  }, {
	    key: "selectNoneInGroup",
	    value: function selectNoneInGroup(variants, value, groupId, options) {
	      console.log("selectNoneInGroup");
	      this.behaviour(options).selectNoneInGroup(variants, value, groupId, options);
	    }
	  }, {
	    key: "valueAsVariants",
	    value: function valueAsVariants(value, variants) {
	      return this.behaviour(options).valueAsVariants(value, variants);
	    }
	  }]);
	}();

	function Ui_list_select_with_groups($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string}       [fieldname = "list-select"]                             field name
		 * @property {function}     [onchange]  callback on value change event
		 * @property {array<import('./types.js').VariantsGroups>}   [variants = []]           variants to select from
		 * @property {array<import('./types.js').SelectedValues}  [variantsSelected] - multiple && multiple in group
		 * @property {array<import('./types.js').SelectedVariants}  value - {[groupId]: [...valuesOfSelectedItems]}
		 * @property {object}       [behaviourUI = ListGroupsUITreeDTO]
		 * @property {object}       [behaviourValue = ListGroupsValueDTO]
		 * @property {boolean}      [multiple = false]                                      if want not one variant selected
		 * @property {boolean}      [onlyOnePerGroup = true]
		 * @property {boolean}      [atLeastOne = true]                                     no empty result
		 * @property {function}     [titleComponent = UITitle]
		 * @property {object}       [titleComponentProps= { size: 5 }]
		 * @property {function}     [imageComponent = UIImage]
		 * @property {object}       [imageComponentProps= { covered: true }]
		 * @property {function}     [descriptionComponent = UIButtons]
		 * @property {object}       [descriptionComponentProps = {}]
		 * @property {function}     [listComponent = UIList]
		 * @property {object}       [listComponentProps = {}]
		 */
		let selectorGroups = state(proxy([]));

		/** @type {Props} */
		let onchange = prop($$props, 'onchange', 3, () => true),
			fieldname = prop($$props, 'fieldname', 3, "list-select-tags"),
			variants = prop($$props, 'variants', 19, () => []),
			variantsSelected = prop($$props, 'variantsSelected', 23, () => ({})),
			value = prop($$props, 'value', 7),
			behaviourUI = prop($$props, 'behaviourUI', 3, ListGroupsUITreeDTO),
			behaviourValue = prop($$props, 'behaviourValue', 3, ListGroupsValueDTO),
			multiple = prop($$props, 'multiple', 3, false),
			onlyOnePerGroup = prop($$props, 'onlyOnePerGroup', 3, true),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({}));

		function updateUI() {
			set(selectorGroups, proxy(behaviourUI().syncUIWithValue(get$3(selectorGroups), (itemIds) => behaviourValue().itemInValue(value(), itemIds, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}))));

			console.log("selectorGroups", get$3(selectorGroups));
		}

		onMount(() => {
			set(selectorGroups, proxy(behaviourUI().buildSelectorItemsFromVariants(variants())));

			value(behaviourValue().initValue(value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}));

			updateUI();
		});

		const valueAsVariants = () => behaviourValue().valueAsVariants(value(), variants());

		function triggerChange() {
			variantsSelected(valueAsVariants());
			onchange()({ field: fieldname(), value: value() });
		}

		const toggleItem = (itemValue) => {
			behaviourValue().toggle(value(), itemValue, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			console.log("value", value());
			updateUI();
			console.log("selectorGroups", get$3(selectorGroups));
			triggerChange();
		};

		var fragment = comment();
		var node = first_child(fragment);

		const expression = derived(() => ({
			action(event, itemValue) {
				toggleItem(itemValue);
			},
			...descriptionComponentProps()
		}));

		component(node, UIListComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$3(expression);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return get$3(selectorGroups);
				}
			}));
		});

		append($$anchor, fragment);
		return pop({ valueAsVariants, toggleItem });
	}

	var root$d = template(`<!> <!>`, 1);

	function Ui_list_select_buttons_with_groups($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {function} [onchange]  callback on value change event
		 * @property {string} [fieldname="list-select-tags"]
		 * @property {import('../types').VariantsGroups} [variants = []] -
		 * @property {import('../types').SelectedValues} [variantsSelected = {}] - multiple && multiple in group
		 * @property {import('../types').SelectedVariants} [value = []]
		 * @property {object} [behaviourUI = ListGroupsUITreeDTO]
		 * @property {object} [behaviourValue = ListGroupsValueDTO]
		 * @property {boolean} [multiple = true]
		 * @property {boolean} [onlyOnePerGroup = true]
		 * @property {boolean} [atLeastOne = true]
		 * @property {function} [titleComponent = UITitle]
		 * @property {object} [titleComponentProps = { size: 5}]
		 * @property {function} [imageComponent = UIImage]
		 * @property {object} [imageComponentProps = { covered: true }]
		 * @property {function} [descriptionComponent = UIButtonsSwitchers]
		 * @property {object} [descriptionComponentProps = {}]
		 * @property {function} [listComponent = UIList]
		 * @property {object} [listComponentProps = {}]
		 * @property {Array<string>} [actionsList=["selectAll", "selectNone"]]
		 */
		/** @type {Props} */
		let onchange = prop($$props, 'onchange', 3, () => true),
			fieldname = prop($$props, 'fieldname', 3, "list-select-tags"),
			variants = prop($$props, 'variants', 19, () => []),
			variantsSelected = prop($$props, 'variantsSelected', 23, () => ({})),
			value = prop($$props, 'value', 7),
			behaviourUI = prop($$props, 'behaviourUI', 3, ListGroupsUITreeDTO),
			behaviourValue = prop($$props, 'behaviourValue', 3, ListGroupsValueDTO),
			multiple = prop($$props, 'multiple', 3, true),
			onlyOnePerGroup = prop($$props, 'onlyOnePerGroup', 3, true),
			atLeastOne = prop($$props, 'atLeastOne', 3, true),
			titleComponent = prop($$props, 'titleComponent', 3, Ui_title),
			titleComponentProps = prop($$props, 'titleComponentProps', 19, () => ({ size: 5 })),
			imageComponent = prop($$props, 'imageComponent', 3, Ui_image),
			imageComponentProps = prop($$props, 'imageComponentProps', 19, () => ({ covered: true })),
			descriptionComponent = prop($$props, 'descriptionComponent', 3, Ui_buttons_switchers),
			descriptionComponentProps = prop($$props, 'descriptionComponentProps', 19, () => ({})),
			UIListComponent = prop($$props, 'listComponent', 3, Ui_list),
			listComponentProps = prop($$props, 'listComponentProps', 19, () => ({})),
			actionsList = prop($$props, 'actionsList', 19, () => ["selectAll", "selectNone"]);

		//
		const AVAILABLE_ACTIONS = {
			selectAll: {
				title: "Выбрать все",
				color: "success",
				action() {
					selectAll();
				}
			},
			selectNone: {
				title: "Снять выделение со всех",
				color: "",
				action() {
					selectNone();
				}
			}
		};

		let ACTIONS = state(proxy([]));
		let selectorGroups = state(proxy([]));

		function updateUI() {
			set(selectorGroups, proxy(behaviourUI().syncUIWithValue(get$3(selectorGroups), (itemIds) => behaviourValue().itemInValue(value(), itemIds, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			}))));

			console.log("selectorGroups", get$3(selectorGroups));
		}

		const valueAsVariants = () => behaviourValue().valueAsVariants(value(), variants());

		function triggerChange() {
			variantsSelected(valueAsVariants());
			onchange()({ field: fieldname(), value: value() });
		}

		onMount(() => {
			actionsList().forEach((name) => {
				Object.hasOwn(AVAILABLE_ACTIONS, name) ? get$3(ACTIONS).push(AVAILABLE_ACTIONS[name]) : false;
			});

			set(ACTIONS, proxy(get$3(ACTIONS)));
			set(selectorGroups, proxy(behaviourUI().buildSelectorItemsFromVariants(variants())));
			value(behaviourValue().initValue(value(), { multiple: multiple() }));
			updateUI();
		});

		const selectAll = () => {
			behaviourValue().selectAll(variants(), value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectNone = () => {
			behaviourValue().selectNone(variants(), value(), {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectAllInGroup = (groupId) => {
			behaviourValue().selectAllInGroup(variants(), value(), groupId, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const selectNoneInGroup = (groupId) => {
			behaviour.selectNoneInGroup(variants(), value(), groupId, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			updateUI();
			triggerChange();
		};

		const toggleItem = (itemValue) => {
			behaviourValue().toggle(value(), itemValue, {
				multiple: multiple(),
				onlyOnePerGroup: onlyOnePerGroup(),
				atLeastOne: atLeastOne()
			});

			console.log("value", value());
			updateUI();
			triggerChange();
		};

		var fragment = root$d();
		var node = first_child(fragment);

		Ui_buttons(node, {
			get values() {
				return get$3(ACTIONS);
			},
			centered: true
		});

		var node_1 = sibling(node, 2);

		const expression = derived(() => ({
			action(event, itemValue) {
				toggleItem(itemValue);
			},
			...descriptionComponentProps()
		}));

		component(node_1, UIListComponent, ($$anchor, $$component) => {
			$$component($$anchor, spread_props(listComponentProps, {
				get titleComponent() {
					return titleComponent();
				},
				get titleComponentProps() {
					return titleComponentProps();
				},
				get descriptionComponent() {
					return descriptionComponent();
				},
				get descriptionComponentProps() {
					return get$3(expression);
				},
				get imageComponent() {
					return imageComponent();
				},
				get imageComponentProps() {
					return imageComponentProps();
				},
				get items() {
					return get$3(selectorGroups);
				}
			}));
		});

		append($$anchor, fragment);

		return pop({
			valueAsVariants,
			selectAll,
			selectNone,
			selectAllInGroup,
			selectNoneInGroup,
			toggleItem
		});
	}

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIEndlessList: Ui_endless_list,
		UIEndlessListNavigation: Ui_endless_list_navigation,
		UIEndlessListSimpleItem: Ui_endless_list_simple_item,
		UIList: Ui_list,
		UIListBlock: Ui_list_block,
		UIListEmptyPlaceholder: Ui_list_empty_placeholder,
		UIListItem: Ui_list_item,
		UIListSelect: Ui_list_select,
		UIListSelectButtonsWithGroups: Ui_list_select_buttons_with_groups,
		UIListSelectWithGroups: Ui_list_select_with_groups
	});

	function overlayClick(e, closeOnClick, closeOverlay) {
		if (closeOnClick()) {
			closeOverlay(e);
		}
	}

	var root_1$a = template(`<div><!> <!></div>`);

	function Ui_overlay($$anchor, $$props) {
		push($$props, true);

		let overflowSave = state("");

		const defaultCloseButtonProps = {
			class: "is-absolute is-sided-right is-sided-top",
			style: "--siding-right-size: 2rem; --siding-top-size: 2rem",
			size: "normal"
		};

		/**
		 * @typedef {Object} Props
		 * @property {boolean}  [closeButton = false]
		 * @property {object}   [closeButtonProps = defaultCloseButtonProps]
		 * @property {boolean}  [show = true]
		 * @property {boolean}  [closeOnClick = true]
		 * @property {number}   [layer = 1]
		 * @property {string}   [class = ""]
		 * @property {number}   [zIndexStep = 1000]
		 * @property {string}   [role = 'button']
		 * @property {string}   [tabIndex = 'button']
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let closeButton = prop($$props, 'closeButton', 3, false),
			closeButtonProps = prop($$props, 'closeButtonProps', 3, defaultCloseButtonProps),
			show = prop($$props, 'show', 7, true),
			closeOnClick = prop($$props, 'closeOnClick', 3, true),
			layer = prop($$props, 'layer', 3, 1),
			classes = prop($$props, 'class', 3, ""),
			onreject = prop($$props, 'onreject', 3, () => false),
			zIndexStep = prop($$props, 'zIndexStep', 3, 1000),
			role = prop($$props, 'role', 3, "button"),
			tabIndex = prop($$props, 'tabIndex', 3, "0");

		function closeButtonClick() {
			rejectOverlay();
		}

		function closeOverlay(e) {
			try {
				if (e && e.originalTarget) {
					const target = e.originalTarget;

					if (target.classList && target.classList.contains("is-overlay")) {
						rejectOverlay();
					}
				} //eslint-disable-next-line no-empty
			} catch {}
		}

		function rejectOverlay(data = {}) {
			show(false);
			onreject()(data);
		}

		onMount(() => {
			set(overflowSave, proxy(document.body.style.overflow));

			if (show()) {
				document.body.style.overflow = "hidden";
			} else {
				document.body.style.overflow = get$3(overflowSave);
			}
		});

		onDestroy(() => {
			document.body.style.overflow = get$3(overflowSave);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_1 = ($$anchor) => {
				var div = root_1$a();

				div.__click = [overlayClick, closeOnClick, closeOverlay];
				div.__keyup = [overlayClick, closeOnClick, closeOverlay];

				var node_1 = child(div);

				{
					var consequent = ($$anchor) => {
						Ui_button_close($$anchor, spread_props(closeButtonProps, { onclick: closeButtonClick }));
					};

					if_block(node_1, ($$render) => {
						if (closeButton()) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				snippet(node_2, () => $$props.children ?? noop);
				reset(div);

				template_effect(() => {
					set_class(div, `is-overlay not-overlay ${classes() ?? ''}`);
					set_attribute(div, 'role', role());
					set_attribute(div, 'tabindex', tabIndex());
					set_attribute(div, 'style', `z-index: ${zIndexStep() * layer() ?? ''};`);
				});

				transition(3, div, () => fade);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent_1);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_5$6 = template(`<!> <!> <!> <!>`, 1);
	var root_3$6 = template(`<!> <!> <!>`, 1);

	function Ui_modal($$anchor, $$props) {
		const buttons = ($$anchor, $$arg0) => {
			let moreClassess = derived_safe_equal(() => fallback($$arg0?.(), ""));
			const expression = derived(() => buttonsClass() || get$3(moreClassess));
			const expression_1 = derived(() => closeButton() ? [closeButton()] : []);
			const expression_2 = derived(() => applyButton() ? [applyButton()] : []);

			Ui_buttons_row($$anchor, {
				get class() {
					return get$3(expression);
				},
				get left() {
					return get$3(expression_1);
				},
				get right() {
					return get$3(expression_2);
				}
			});
		};

		/**
		 * @typedef {Object} Props
		 * @property {string} [buttonsPosition = "bottom"]           top, topOfContent, bottom
		 * @property {boolean} [fullscreen = false]
		 * @property {boolean} [closeButton = false]
		 * @property {boolean} [applyButton = false]
		 * @property {number} [titleSize = 2]
		 * @property {boolean} [show = false]
		 * @property {boolean} [loading = false]
		 * @property {string} [title= "Modal window"]
		 * @property {string} [subtitle = ""]
		 * @property {string} [class = ""]
		 * @property {string} [overlayClass = ""]
		 * @property {string} [buttonsClass = ""]
		 * @property {string} [WAITING_TEXT = "Обработка"]
		 * @property {import('svelte').Snippet} [children]
		 */
		/** @type {Props} */
		let buttonsPosition = prop($$props, 'buttonsPosition', 3, "bottom"),
			fullscreen = prop($$props, 'fullscreen', 3, false),
			closeButton = prop($$props, 'closeButton', 3, false),
			applyButton = prop($$props, 'applyButton', 3, false),
			titleSize = prop($$props, 'titleSize', 3, 2),
			show = prop($$props, 'show', 3, false),
			loading = prop($$props, 'loading', 3, false),
			title = prop($$props, 'title', 3, "Modal window"),
			subtitle = prop($$props, 'subtitle', 3, ""),
			classes = prop($$props, 'class', 3, ""),
			overlayClass = prop($$props, 'overlayClass', 3, ""),
			buttonsClass = prop($$props, 'buttonsClass', 3, ""),
			WAITING_TEXT = prop($$props, 'WAITING_TEXT', 3, "Обработка");

		Ui_overlay($$anchor, {
			get show() {
				return show();
			},
			closeOnClick: false,
			closeButton: false,
			get class() {
				return overlayClass();
			},
			children: ($$anchor, $$slotProps) => {
				const expression_3 = derived(() => `${classes()} ${fullscreen() ? "is-fullscreen" : ""}`);

				Ui_box($$anchor, {
					get class() {
						return get$3(expression_3);
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_3 = root_3$6();
						var node = first_child(fragment_3);

						{
							var consequent = ($$anchor) => {
								buttons($$anchor, () => "");
							};

							if_block(node, ($$render) => {
								if (buttonsPosition() === "top") $$render(consequent);
							});
						}

						var node_1 = sibling(node, 2);

						Ui_title(node_1, {
							get size() {
								return titleSize();
							},
							get title() {
								return title();
							},
							get subtitle() {
								return subtitle();
							}
						});

						var node_2 = sibling(node_1, 2);

						Ui_content(node_2, {
							children: ($$anchor, $$slotProps) => {
								var fragment_5 = root_5$6();
								var node_3 = first_child(fragment_5);

								Ui_loader(node_3, {
									size: 'page',
									get loading() {
										return loading();
									},
									get title() {
										return WAITING_TEXT();
									}
								});

								var node_4 = sibling(node_3, 2);

								{
									var consequent_1 = ($$anchor) => {
										buttons($$anchor, () => "");
									};

									if_block(node_4, ($$render) => {
										if (buttonsPosition() === "topOfContent") $$render(consequent_1);
									});
								}

								var node_5 = sibling(node_4, 2);

								snippet(node_5, () => $$props.children ?? noop);

								var node_6 = sibling(node_5, 2);

								{
									var consequent_2 = ($$anchor) => {
										buttons($$anchor, () => `is-mobile ${fullscreen() ? "is-footer" : ""}`);
									};

									if_block(node_6, ($$render) => {
										if (buttonsPosition() === "bottom") $$render(consequent_2);
									});
								}

								append($$anchor, fragment_5);
							},
							$$slots: { default: true }
						});

						append($$anchor, fragment_3);
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});
	}

	var root_2$7 = template(`<!> <!> <!>`, 1);

	function Ui_generic_selector($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef     {Object} Props
		 * @property    {boolean}   [show]
		 * @property    {boolean}   [showSearch = true]
		 * @property    {string}    [term]
		 * @property    {(fullscreen|wide|normal|narrow)} [size]   100vw, 75vw, 50vw, 25vw
		 * @property    {any}       [inputComponent]
		 * @property    {object}    [inputComponentProps]
		 * @property    {any}       [outputComponent]
		 * @property    {object}    [outputComponentProps]
		 * @property    {object}    [buttonsProps = { centered: true, class: "mt-5",}]
		 * @property    {object}    [results]
		 * @property    {function}  [onprev]
		 * @property    {function}  [onnext]
		 * @property    {function}  [onchange]
		 * @property    {function}  [onreject]
		 * @property    {function}  [onresolve]
		 */
		/** @type {Props} */
		let show = prop($$props, 'show', 3, true),
			showSearch = prop($$props, 'showSearch', 3, true),
			term = prop($$props, 'term', 15, ""),
			size = prop($$props, 'size', 3, "narrow"),
			UIInputComponent = prop($$props, 'inputComponent', 3, Ui_simple_search_input),
			inputComponentProps = prop($$props, 'inputComponentProps', 19, () => ({})),
			UIOutputComponent = prop($$props, 'outputComponent', 3, Ui_endless_list),
			outputComponentProps = prop($$props, 'outputComponentProps', 19, () => ({})),
			buttonsProps = prop($$props, 'buttonsProps', 19, () => ({ centered: true, class: "mt-5" })),
			rejectButtonProps = prop($$props, 'rejectButtonProps', 19, () => ({})),
			results = prop($$props, 'results', 31, () => proxy({
				list: [],
				page: 0,
				pages: 0,
				skip: 0,
				count: 0
			}));

		const buttons = [
			{
				title: $LOCALE()["not-node:button_cancel_label"],
				action: $$props.onreject,
				...rejectButtonProps()
			}
		];

		Ui_overlay($$anchor, {
			get onreject() {
				return $$props.onreject;
			},
			get show() {
				return show();
			},
			closeOnClick: true,
			closeButton: false,
			children: ($$anchor, $$slotProps) => {
				Ui_box($$anchor, {
					get class() {
						return `modal-selector ${size() ?? ''}`;
					},
					children: ($$anchor, $$slotProps) => {
						var fragment_2 = root_2$7();
						var node = first_child(fragment_2);

						{
							var consequent = ($$anchor) => {
								var fragment_3 = comment();
								var node_1 = first_child(fragment_3);

								component(node_1, UIInputComponent, ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get onchange() {
												return $$props.onchange;
											}
										},
										inputComponentProps,
										{
											get term() {
												return term();
											},
											set term($$value) {
												term($$value);
											}
										}
									));
								});

								append($$anchor, fragment_3);
							};

							if_block(node, ($$render) => {
								if (showSearch()) $$render(consequent);
							});
						}

						var node_2 = sibling(node, 2);

						component(node_2, UIOutputComponent, ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get onprev() {
										return $$props.onprev;
									},
									get onnext() {
										return $$props.onnext;
									},
									get onselect() {
										return $$props.onresolve;
									},
									class: 'has-height-up-to-60 overflow-scroll'
								},
								outputComponentProps,
								{
									get itemRenderer() {
										return $$props.itemRenderer;
									},
									get data() {
										return results();
									},
									set data($$value) {
										results($$value);
									}
								}
							));
						});

						var node_3 = sibling(node_2, 2);

						Ui_buttons(node_3, spread_props(buttonsProps, { values: buttons }));
						append($$anchor, fragment_2);
					},
					$$slots: { default: true }
				});
			},
			$$slots: { default: true }
		});

		pop();
		$$cleanup();
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UIGenericSelector: Ui_generic_selector,
		UIModal: Ui_modal,
		UIOverlay: Ui_overlay
	});

	var root_2$6 = template(`<p> </p>`);
	var root_4$5 = template(`<p> </p>`);
	var root$c = template(`<article><div class="message-header"><!></div> <div class="message-body"><!></div></article>`);

	function Ui_message($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let classes = prop($$props, 'class', 3, "");
		var article = root$c();
		var div = child(article);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				snippet(node_1, () => $$props.titleSnip, () => $$props.title);
				append($$anchor, fragment);
			};

			var alternate = ($$anchor) => {
				var p = root_2$6();
				var text = child(p, true);

				reset(p);
				template_effect(() => set_text(text, $LOCALE()[$$props.title]));
				append($$anchor, p);
			};

			if_block(node, ($$render) => {
				if ($$props.titleSnip) $$render(consequent); else $$render(alternate, false);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var node_2 = child(div_1);

		{
			var consequent_1 = ($$anchor) => {
				var fragment_1 = comment();
				var node_3 = first_child(fragment_1);

				snippet(node_3, () => $$props.messageSnip, () => $$props.message);
				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var p_1 = root_4$5();
				var text_1 = child(p_1, true);

				reset(p_1);
				template_effect(() => set_text(text_1, $LOCALE()[$$props.message]));
				append($$anchor, p_1);
			};

			if_block(node_2, ($$render) => {
				if ($$props.messageSnip) $$render(consequent_1); else $$render(alternate_1, false);
			});
		}

		reset(div_1);
		reset(article);
		template_effect(() => set_class(article, `message ${classes() ?? ''} ${($$props.color ? `is-${$$props.color}` : '') ?? ''}`));
		append($$anchor, article);
		pop();
		$$cleanup();
	}

	function Ui_error($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 19, () => UICommon$1.CLASS_ERR),
			props = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class']);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	function Ui_success($$anchor, $$props) {
		push($$props, true);

		let classes = prop($$props, 'class', 19, () => UICommon$1.CLASS_OK),
			props = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'class']);

		Ui_message($$anchor, spread_props(() => props, {
			get class() {
				return classes();
			}
		}));

		pop();
	}

	var root_1$9 = template(`<div><p> </p> <!></div>`);

	function Ui_cookie_notification($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {boolean} [show = false]
		 * @property {string} [message]
		 * @property {string} [agree]
		 */
		/** @type {Props} */
		let show = prop($$props, 'show', 15, false),
			message = prop($$props, 'message', 3, "Для улучшения работы сайта и его взаимодействия с пользователями мы используем файлы cookie. Продолжая работу с сайтом, Вы разрешаете использование cookie-файлов. Вы всегда можете отключить файлы cookie в настройках Вашего браузера."),
			agree = prop($$props, 'agree', 3, "Хорошо"),
			cooldown = prop($$props, 'cooldown', 3, 31536000000),
			lsKey = prop($$props, 'lsKey', 3, "cookie_date"),
			id = prop($$props, 'id', 3, "cookie_notification");

		onMount(() => {
			let cookieDate = localStorage.getItem(lsKey());

			if (!cookieDate || +cookieDate + cooldown() < Date.now()) {
				show(true);
			}
		});

		function accept() {
			localStorage.setItem(lsKey(), Date.now());
			show(false);
		}

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$9();
				var p = child(div);
				var text$1 = child(p, true);

				reset(p);

				var node_1 = sibling(p, 2);

				Ui_button(node_1, {
					onclick: accept,
					color: 'success',
					class: 'cookie_accept',
					children: ($$anchor, $$slotProps) => {
						next();

						var text_1 = text();

						template_effect(() => set_text(text_1, $LOCALE()[agree()]));
						append($$anchor, text_1);
					},
					$$slots: { default: true }
				});

				reset(div);

				template_effect(() => {
					set_attribute(div, 'id', id());
					set_text(text$1, $LOCALE()[message()]);
				});

				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (show()) $$render(consequent);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		UICookieNotification: Ui_cookie_notification,
		UIError: Ui_error,
		UIMessage: Ui_message,
		UISuccess: Ui_success
	});

	//block elements

	var Elements = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Blocks: index$c,
		Buttons: index$b,
		Forms: index$6,
		Icons: index$7,
		Images: index$5,
		Inputs: index$9,
		Layouts: index$a,
		Links: index$4,
		Lists: index$3,
		Modals: index$2,
		Notifications: index$1,
		UICommon: UICommon$1,
		Various: index$8
	});

	const META_METHOD_INIT = Symbol("init"),
	  META_DATA = Symbol("data"),
	  META_WORKING = Symbol("working"),
	  META_OPTIONS = Symbol("options");
	let notBase = /*#__PURE__*/function (_EventEmitter) {
	  function notBase(input) {
	    var _this;
	    _classCallCheck(this, notBase);
	    _this = _callSuper(this, notBase);
	    _this[META_DATA] = {};
	    _this[META_WORKING] = {};
	    _this[META_OPTIONS] = {};
	    _this[META_METHOD_INIT](input);
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notBase, _EventEmitter);
	  return _createClass(notBase, [{
	    key: META_METHOD_INIT,
	    value: function (input) {
	      if (!input) {
	        input = {};
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "data")) {
	        this.setData(input.data);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "working")) {
	        this.setWorking(input.working);
	      }

	      // @ts-ignore
	      if (Object.hasOwn(input, "options")) {
	        this.setOptions(input.options);
	      }
	      this.log = notCommon$1.genLogMsg(this.getWorking("name"));
	      this.info = this.log;
	      this.debug = notCommon$1.genLogDebug(this.getWorking("name"));
	      this.error = notCommon$1.genLogError(this.getWorking("name"));
	    }
	  }, {
	    key: "setCommon",
	    value: function setCommon(what, args) {
	      switch (args.length) {
	        case 1:
	          {
	            /* set collection */
	            what = args[0];
	            break;
	          }
	        case 2:
	          {
	            /* set collection element */
	            notPath.set(args[0] /* path */, what /* collection */, undefined /* helpers */, args[1] /* value */);
	            break;
	          }
	      }
	      return this;
	    }
	  }, {
	    key: "getCommon",
	    value: function getCommon(what, args) {
	      switch (args.length) {
	        /* if we want get data by path */
	        case 1:
	          {
	            return notPath.get(args[0], what);
	          }
	        /* if we want get data by path with default value */
	        case 2:
	          {
	            let res = notPath.get(args[0], what);
	            if (res === undefined) {
	              /* no data, return default value */
	              return args[1];
	            } else {
	              /* data, return it */
	              return res;
	            }
	          }
	        /* return full collection */
	        default:
	          {
	            return what;
	          }
	      }
	    }

	    /*
	    CORE OBJECT
	      DATA - information
	      OPTIONS - how to work
	      WORKING - temporarily generated in proccess
	    */
	  }, {
	    key: "setData",
	    value: function setData() {
	      if (arguments.length === 1) {
	        this[META_DATA] = arguments[0];
	      } else {
	        this.setCommon(this.getData(), arguments);
	      }
	      this.emit("change");
	      return this;
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.getCommon(this[META_DATA], arguments);
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions() {
	      if (arguments.length === 1) {
	        this[META_OPTIONS] = arguments[0];
	      } else {
	        this.setCommon(this.getOptions(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      return this.getCommon(this[META_OPTIONS], arguments);
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking() {
	      if (arguments.length === 1) {
	        this[META_WORKING] = arguments[0];
	      } else {
	        this.setCommon(this.getWorking(), arguments);
	      }
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking() {
	      return this.getCommon(this[META_WORKING], arguments);
	    }
	  }, {
	    key: "report",
	    value: function report(e) {
	      if (notCommon$1.report) {
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.removeEvent();
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	      this.emit("destroy");
	    }
	  }]);
	}(EventEmitter);

	const OPT_MODE_HISTORY = Symbol("history"),
	  OPT_MODE_HASH = Symbol("hash"),
	  OPT_DEFAULT_CHECK_INTERVAL = 50;
	let notRouter = /*#__PURE__*/function (_notBase) {
	  function notRouter() {
	    var _this;
	    _classCallCheck(this, notRouter);
	    _this = _callSuper(this, notRouter, [{
	      working: {
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/",
	        //always in slashes /user/, /, /input/. and no /user or input/level
	        initialized: false,
	        delays: NAVIGATION_DELAYS,
	        delay_default: NAVIGATION_DELAY_DEFAULT
	      }
	    }]);
	    _defineProperty(_this, "host", "");
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Set object with named delays
	   * @param {Object.<string, number>} delays
	   * @returns {notRouter}
	   */
	  _inherits(notRouter, _notBase);
	  return _createClass(notRouter, [{
	    key: "setDelays",
	    value: function setDelays(delays) {
	      this.setWorking("delays", delays);
	      return this;
	    }

	    /**
	     * Set default navigation delay, provided as name of one of `delays` or in number form
	     * @param {string|number} delay
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setDefaultNavigationDelay",
	    value: function setDefaultNavigationDelay(delay) {
	      this.setWorking("delay_default", this.delayAsMs(delay));
	      return this;
	    }

	    /**
	     * Returns number of ms, if not set returns NAVIGATION_DELAY_DEFAULT
	     * @returns {number}
	     */
	  }, {
	    key: "getDefaultNavigationDelay",
	    value: function getDefaultNavigationDelay() {
	      return this.getWorking(`delay_default`, NAVIGATION_DELAY_DEFAULT);
	    }

	    /**
	     *  Ensures that delay is in ms, if its provided as name of alias, searches for it and returns, if not found - returns working default_delay
	     * @param {string|number} delay    name of delay alias or number of ms
	     * @returns {number}               delay in ms
	     */
	  }, {
	    key: "delayAsMs",
	    value: function delayAsMs(delay) {
	      if (typeof delay === "number") {
	        return delay;
	      } else {
	        if (typeof delay === "string" && delay.length > 0) {
	          return this.getWorking(`delays.${delay}`, this.getDefaultNavigationDelay());
	        } else {
	          return this.getDefaultNavigationDelay();
	        }
	      }
	    }

	    /**
	     *
	     *  @param {string}              url     we go to url
	     *  @param {string|number}       delay   name of delay alias or number of ms
	     *  @returns {NodeJS.Timeout}            timeout identificator
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay, doBefore) {
	      var _this2 = this;
	      return setTimeout(function () {
	        typeof doBefore === "function" && doBefore();
	        _this2.navigate(url);
	      }, this.delayAsMs(delay));
	    }

	    /**
	     * Use browser History API
	     */
	  }, {
	    key: "history",
	    value: function history() {
	      this.setWorking("mode", OPT_MODE_HISTORY);
	    }

	    /**
	     * Use hash part as container for location information
	     */
	  }, {
	    key: "hash",
	    value: function hash() {
	      this.setWorking("mode", OPT_MODE_HASH);
	    }

	    /**
	     * root should start and end with
	     * @param {string} root
	     * @returns {notRouter}
	     */
	  }, {
	    key: "setRoot",
	    value: function setRoot(root) {
	      this.setWorking("root", root && root !== "/" ? "/" + this.clearSlashes(root) + "/" : "/");
	      return this;
	    }

	    /**
	     * clear first and last slashes from string
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "clearSlashes",
	    value: function clearSlashes(path) {
	      return path.toString().replace(/\/$/, "").replace(/^\//, "");
	    }
	  }, {
	    key: "add",
	    value: function add(re, handler) {
	      if (typeof re == "function") {
	        handler = re;
	        re = "";
	      }
	      let rule = {
	        re: re,
	        handler: handler
	      };
	      this.getWorking("routes").push(rule);
	      return this;
	    }
	  }, {
	    key: "addList",
	    value: function addList(list) {
	      for (let t in list) {
	        this.add(t, list[t]);
	      }
	      return this;
	    }
	  }, {
	    key: "remove",
	    value: function remove(param) {
	      for (var i = 0, r; i < this.getWorking("routes").length, r = this.getWorking("routes")[i]; i++) {
	        if (r.handler === param || r.re === param) {
	          this.getWorking("routes").splice(i, 1);
	          return this;
	        }
	      }
	      return this;
	    }
	  }, {
	    key: "flush",
	    value: function flush() {
	      this.setWorking({
	        routes: [],
	        mode: OPT_MODE_HISTORY,
	        root: "/"
	      });
	      return this;
	    }
	  }, {
	    key: "isInitialized",
	    value: function isInitialized() {
	      return this.getWorking("initialized");
	    }
	  }, {
	    key: "setInitialized",
	    value: function setInitialized(val = true) {
	      return this.setWorking("initialized", val);
	    }
	  }, {
	    key: "getFragment",
	    value: function getFragment() {
	      var fragment = "";
	      if (this.getWorking("mode") === OPT_MODE_HISTORY) {
	        if (!location) return "";
	        fragment = this.clearSlashes(decodeURI(location.pathname + location.search));
	        fragment = fragment.replace(/\?(.*)$/, "");
	        fragment = this.getWorking("root") != "/" ? fragment.replace(this.getWorking("root"), "") : fragment;
	      } else {
	        if (!window) return "";
	        var match = window.location.href.match(/#(.*)$/);
	        fragment = match ? match[1] : "";
	      }
	      return this.clearSlashes(fragment);
	    }
	  }, {
	    key: "checkLocation",
	    value: function checkLocation() {
	      let current = this.getWorking("current"),
	        fragment = this.getFragment(),
	        init = this.isInitialized();
	      if (current !== fragment || !init) {
	        this.setWorking("current", fragment);
	        this.check(fragment);
	        this.setInitialized(true);
	      }
	    }
	  }, {
	    key: "hrefClick",
	    value: function hrefClick() {
	      //console.log(...arguments);
	    }
	  }, {
	    key: "getRoot",
	    value: function getRoot() {
	      return this.getWorking("root");
	    }
	  }, {
	    key: "listen",
	    value: function listen(loopInterval = OPT_DEFAULT_CHECK_INTERVAL) {
	      this.setWorking("current", "notInitialized");
	      clearInterval(this.getWorking("interval"));
	      this.setWorking("interval", setInterval(this.checkLocation.bind(this), loopInterval));
	      window.addEventListener("popstate", this.hrefClick.bind(this));
	      return this;
	    }
	  }, {
	    key: "check",
	    value: function check(f) {
	      let fragment = f || this.getFragment(),
	        failBack = null;
	      for (let i = 0; i < this.getWorking("routes").length; i++) {
	        let path = this.getWorking("root") + this.getWorking("routes")[i].re,
	          fullRE = this.clearSlashes(decodeURI(path)),
	          match = fragment.match(fullRE);
	        if (match && match.length) {
	          if (fullRE === "") {
	            match.shift();
	            failBack = {
	              route: this.getWorking("routes")[i],
	              match
	            };
	          } else {
	            match.shift();
	            this.getWorking("routes")[i].handler.apply(this.host || {}, match);
	            this.emit("afterRoute", this.getWorking("routes")[i]);
	            return this;
	          }
	        }
	      }
	      if (failBack) {
	        failBack.route.handler.apply(this.host || {}, failBack.match);
	        this.emit("afterRoute", failBack.route);
	      }
	      return this;
	    }

	    /**
	     *  Refreshes page
	     * @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      var _this3 = this;
	      if (timeout > 0) {
	        setTimeout(function () {
	          return _this3.refresh();
	        }, timeout);
	      } else {
	        this.check(this.getWorking("current"));
	      }
	    }

	    /**
	     * Changes locations
	     * @param {string} path
	     * @returns
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(path) {
	      path = path ? path : "";
	      switch (this.getWorking("mode")) {
	        case OPT_MODE_HISTORY:
	          {
	            const newRoute = this.getFullRoute(path);
	            if (newRoute === this.lastRoute) {
	              this.refresh();
	            } else {
	              this.lastRoute = newRoute;
	              history.pushState(null, "", this.lastRoute);
	            }
	            break;
	          }
	        case OPT_MODE_HASH:
	          {
	            window.location.href.match(/#(.*)$/);
	            window.location.href = window.location.href.replace(/#(.*)$/, "") + "#" + path;
	            break;
	          }
	      }
	      return this;
	    }

	    /**
	     *  returns app root + path
	     * @param {string} path
	     * @returns {string}
	     */
	  }, {
	    key: "getFullRoute",
	    value: function getFullRoute(path = "") {
	      path = this.clearSlashes(path);
	      const root = this.getWorking("root");
	      if (root !== "/") {
	        if (path.indexOf(root.substring(1)) === 0) {
	          return "/" + path;
	        }
	      }
	      return this.getWorking("root") + this.clearSlashes(path);
	    }

	    /**
	     * Returns all links with n-href attribute
	     * @returns {Array<HTMLAnchorElement>}
	     */
	  }, {
	    key: "getAllLinks",
	    value: function getAllLinks() {
	      const allElements = document.body.querySelectorAll("a");
	      let list = [];
	      for (let j = 0; j < allElements.length; j++) {
	        for (let i = 0, atts = allElements[j].attributes, n = atts.length; i < n; i++) {
	          if (atts[i].nodeName.indexOf("n-href") === 0) {
	            list.push(allElements[j]);
	            break;
	          }
	        }
	      }
	      return list;
	    }

	    /**
	     * Reroute all links(anchor tags) with n-href attribute.
	     * Disable navigation to href.
	     * @returns {notRouter}
	     */
	  }, {
	    key: "reRouteExisted",
	    value: function reRouteExisted() {
	      const list = this.getAllLinks();
	      for (let t = 0; t < list.length; t++) {
	        this.initRerouting(list[t], list[t].getAttribute("n-href"));
	      }
	      return this;
	    }

	    /**
	     * If `el` is not initialized, adds onclick listener to navigate to `link` location.
	     * Disables default navigation to href.
	     * @param {HTMLAnchorElement}   el
	     * @param {string}              link
	     * @returns
	     */
	  }, {
	    key: "initRerouting",
	    value: function initRerouting(el, link) {
	      var _this4 = this;
	      // @ts-ignore
	      if (!el.notRouterInitialized) {
	        let fullLink = this.getFullRoute(link);
	        el.setAttribute("href", fullLink);
	        el.addEventListener("click", function (e) {
	          e.preventDefault();
	          _this4.navigate(link);
	          return false;
	        });
	        // @ts-ignore
	        el.notRouterInitialized = true;
	      }
	      return this;
	    }
	  }]);
	}(notBase);
	var notRouter$1 = new notRouter();

	const LOG_PREFIX$1 = "APIQuee";
	let notAPIQueue = /*#__PURE__*/function (_notBase) {
	  function notAPIQueue(options = {}) {
	    var _this;
	    _classCallCheck(this, notAPIQueue);
	    _this = _callSuper(this, notAPIQueue, [{
	      working: {
	        name: options.name ? options.name : LOG_PREFIX$1
	      },
	      options
	    }]);
	    _this.busy = false;
	    _this.queue = [];
	    _this.busySince = -1;
	    _this.afterEmpty = undefined;
	    _this.start();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIQueue, _notBase);
	  return _createClass(notAPIQueue, [{
	    key: "stop",
	    value: function stop() {
	      if (this.interval) {
	        clearInterval(this.interval);
	        this.interval = undefined;
	        this.busy = false;
	        this.busySince = -1;
	      }
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      this.stop();
	      this.interval = setInterval(this.checkQueue.bind(this), this.QUEUE_CHECK_INTERVAL);
	    }
	  }, {
	    key: "checkQueue",
	    value: function checkQueue() {
	      var _this2 = this;
	      if (!this.isEmpty() && !this.isBusy()) {
	        this.setBusy().runNext().then(this.setFree.bind(this)).catch(function (e) {
	          _this2.error && _this2.error(e);
	          _this2.setFree();
	        });
	      } else {
	        if (!this.isBusy()) {
	          if (this.afterEmpty) {
	            let t = this.afterEmpty;
	            this.afterEmpty = undefined;
	            t();
	          }
	        }
	      }
	    }
	  }, {
	    key: "addToQueue",
	    value: function addToQueue(task) {
	      this.queue.push(task);
	    }
	  }, {
	    key: "runNext",
	    value: function runNext() {
	      let list = this.queue.map(function (action) {
	        return action.title;
	      }).join(", ");
	      this.debug && this.debug(`tasks [${list}]`);
	      let task = this.queue.shift();
	      if (!notCommon$1.isFunc(task.action)) {
	        this.error && this.error("В задании нет исполнимой части, action не функция", task.title);
	        return Promise.resolve();
	      }
	      if (!notCommon$1.isFunc(task.resolve)) {
	        this.error && this.error("В задании нет возвратной части, resolve не функция", task.title);
	        return task.action();
	      }
	      return task.action().then(task.resolve);
	    }
	  }, {
	    key: "isBusy",
	    value: function isBusy() {
	      let busy = !!this.busy,
	        now = Date.now() / 1000;
	      if (busy && this.busySince > -1) {
	        if (now - this.busySince > notAPIQueue.MAX_BUSY_TIME) {
	          this.setFree();
	          return false;
	        } else {
	          return true;
	        }
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "setBusy",
	    value: function setBusy() {
	      this.busy = true;
	      this.busySince = Date.now() / 1000;
	      return this;
	    }
	  }, {
	    key: "setFree",
	    value: function setFree() {
	      this.busy = false;
	      this.busySince = -1;
	      return this;
	    }
	  }, {
	    key: "isEmpty",
	    value: function isEmpty() {
	      return this.queue.length === 0;
	    }

	    /**
	     * Исполнитель запросов
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @returns    {Promise}    результат функции
	     **/
	  }, {
	    key: "run",
	    value: function run(action, afterEmpty = undefined, title = "") {
	      var _this3 = this;
	      if (afterEmpty && typeof this.afterEmpty === "undefined") {
	        this.afterEmpty = afterEmpty;
	      }
	      return new Promise(function (resolve, reject) {
	        try {
	          _this3.addToQueue({
	            action,
	            resolve,
	            title
	          });
	        } catch (e) {
	          _this3.error && _this3.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "actionIsQueued",
	    value: function actionIsQueued(title) {
	      return this.queue.some(function (queued) {
	        return queued.title == title;
	      });
	    }

	    /**
	     *
	     *
	     * @param      {function}   action      должна возвращать Promise
	     * @param      {function}   [afterEmpty = undefined]  будет выполнена когда очурудь опустеет и будет свободна. полезна при пачке однотипных заданий
	     * @param       {string}    [title = '']    optional title of request
	     * @return    {Promise}
	     * @memberof notAPIQueue
	     */
	  }, {
	    key: "runIfNotQueued",
	    value: function runIfNotQueued(action, afterEmpty = undefined, title = "") {
	      if (this.actionIsQueued(title)) {
	        return Promise.resolve();
	      } else {
	        return this.run(action, afterEmpty, title);
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIQueue, "QUEUE_CHECK_INTERVAL", 100);
	_defineProperty(notAPIQueue, "MAX_BUSY_TIME", 300);

	let notAPIOptions = {
	  rps: 50,
	  protocol: 'http',
	  host: 'localhost',
	  port: 9000
	};

	const LOG_PREFIX = 'APIConnection';
	let notAPIConnection = /*#__PURE__*/function (_notBase) {
	  function notAPIConnection(options) {
	    var _this;
	    _classCallCheck(this, notAPIConnection);
	    _this = _callSuper(this, notAPIConnection, [{
	      options,
	      working: {
	        name: options.name ? options.name : LOG_PREFIX
	      }
	    }]);
	    _this.online = null;
	    _this.run();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notAPIConnection, _notBase);
	  return _createClass(notAPIConnection, [{
	    key: "run",
	    value: function run() {
	      this.int = window.setInterval(this.check.bind(this), 1000);
	    }
	  }, {
	    key: "pause",
	    value: function pause() {
	      window.clearInterval(this.int);
	    }
	  }, {
	    key: "resume",
	    value: function resume() {
	      this.run();
	    }
	  }, {
	    key: "isOnline",
	    value: function isOnline() {
	      return window.navigator.onLine;
	    }
	  }, {
	    key: "check",
	    value: function check() {
	      let t = this.isOnline();
	      if (this.online !== null) {
	        if (this.online !== t) {
	          this.changeState(t);
	        }
	      }
	      this.online = t;
	    }
	  }, {
	    key: "changeState",
	    value: function changeState(online = false) {
	      if (online) {
	        this.emit('online');
	      } else {
	        this.emit('offline');
	      }
	    }
	  }]);
	}(notBase);
	_defineProperty(notAPIConnection, "int", void 0);
	_defineProperty(notAPIConnection, "online", void 0);

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		notAPIConnection: notAPIConnection,
		notAPIOptions: notAPIOptions,
		notAPIQueue: notAPIQueue
	});

	const ALL$1 = {};
	function exist$1(key) {
	  return notCommon$1.objHas(ALL$1, key);
	}
	function get$1(key) {
	  if (exist$1(key)) {
	    return ALL$1[key];
	  } else {
	    return false;
	  }
	}
	function create$1(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist$1(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL$1[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL$1[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL$1[key];
	}

	/**
	 * Creates object that is fake Store
	 * Some time this is useful when you need to initialize local var,
	 * before you could get actual Stores from central storage by its ID
	 *	@params {mixed} val 	data of type that is actual storage will contain
	 * @returns {Object}
	 */

	function fake(val) {
	  return {
	    subscribe(f) {
	      f(val);
	      return function () {};
	    },
	    set() {}
	  };
	}

	var stores = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		fake: fake,
		get: get$1
	});

	const //record
	  META_INTERFACE = Symbol('interface'),
	  META_MAP_TO_INTERFACE = ['getActionsCount', 'getActions', 'setFindBy', 'resetFilter', 'setFilter', 'getFilter', 'setSorter', 'getSorter', 'resetSorter', 'setPageNumber', 'setPageSize', 'setPager', 'setReturn', 'setSearch', 'getSearch', 'resetSearch', 'resetPager', 'getPager', 'addFormFieldType', 'addFormField', 'getFieldTypes', 'getActionFormFields'],
	  DEFAULT_ACTION_PREFIX$1 = '$';

	const OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY = ["_id", "id", "ID"],
	  DEFAULT_FILTER = {},
	  DEFAULT_SEARCH = "",
	  DEFAULT_RETURN = {},
	  DEFAULT_PAGE_NUMBER = 0,
	  DEFAULT_PAGE_SIZE = 10,
	  DEFAULT_ACTION_PREFIX = "$",
	  DEFAULT_WS_ROUTE_ACTION_SPLITTER = "//";
	let notInterface = /*#__PURE__*/function (_notBase) {
	  function notInterface(manifest, options) {
	    var _this;
	    _classCallCheck(this, notInterface);
	    _this = _callSuper(this, notInterface, [{
	      working: {
	        name: "network interface for: " + (manifest.model ? manifest.model : "unknown"),
	        filter: DEFAULT_FILTER,
	        search: DEFAULT_SEARCH,
	        return: DEFAULT_RETURN,
	        pager: {
	          size: DEFAULT_PAGE_SIZE,
	          page: DEFAULT_PAGE_NUMBER
	        }
	      },
	      options
	    }]);
	    _this.manifest = manifest;
	    _this.initActions();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notInterface, _notBase);
	  return _createClass(notInterface, [{
	    key: "initActions",
	    value: function initActions() {
	      if (this.getActionsCount() > 0) {
	        let actions = this.getActions();
	        for (let actionName in actions) {
	          this.initAction(actionName);
	        }
	      }
	    }
	  }, {
	    key: "initAction",
	    value: function initAction(actionName) {
	      var _this2 = this;
	      if (!notCommon$1.objHas(this, DEFAULT_ACTION_PREFIX + actionName)) {
	        this[DEFAULT_ACTION_PREFIX + actionName] = function (opts, headers, fileUpload = false, files) {
	          return _this2.request(_this2, actionName, opts, headers, fileUpload, files);
	        };
	      }
	    }
	  }, {
	    key: "requestHTTP",
	    value: function requestHTTP(record, actionName, params, headers = {}, fileUpload = false, files) {
	      try {
	        let compositeData = Object.assign({}, record.getData && typeof record.getData === "function" ? record.getData() : record, params);
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData),
	          requestParamsEncoded = this.encodeRequest(requestParams),
	          //id = this.getID(compositeData, actionData, actionName),
	          apiServerURL = this.getServerURL(),
	          url = this.getURL(compositeData, actionData, actionName),
	          opts = {};
	        if (fileUpload) {
	          url = this.getURL(params, actionData, actionName);
	          const fd = new FormData();
	          fd.append("file", files);
	          opts.body = fd;
	        } else {
	          if (["OPTIONS", "GET"].indexOf(actionData.method.toUpperCase()) === -1) {
	            opts = {
	              method: actionData.method,
	              body: JSON.stringify(record.getData && typeof record.getData === "function" ? record.getData() : record),
	              headers: {
	                Accept: "application/json",
	                "Content-Type": "application/json"
	              }
	            };
	          }
	        }
	        opts.method = actionData.method.toUpperCase();
	        if (headers && Object.keys(headers).length) {
	          opts.headers = headers;
	        }
	        return fetch(apiServerURL + url + requestParamsEncoded, opts).then(function (response) {
	          return response.json();
	        });
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "requestWS",
	    value: function requestWS(record, actionName) {
	      try {
	        let actionData = this.getActionData(actionName),
	          requestParams = this.collectRequestData(actionData);
	        const WS = notCommon$1.getApp().getWSClient();
	        const messageName = this.getWSRequestName(actionName);
	        const payload = Object.assign({}, requestParams, record.getData());
	        if (notCommon$1.objHas(actionData, "type") && typeof actionData.type === "string" && actionData.type.length && actionData.type !== "request") {
	          return WS.message(actionData.type, messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        } else {
	          return WS.request(messageName, payload).then(function (response) {
	            return response.payload;
	          });
	        }
	      } catch (e) {
	        notCommon$1.error(e);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "request",
	    value: function request() {
	      let actionData = this.getActionData(arguments[1]);
	      switch (this.selectTransport(actionData)) {
	        case "ws":
	          return this.requestWS(...arguments);
	        case "http":
	          return this.requestHTTP(...arguments);
	        default:
	          throw new Error("Offline");
	      }
	    }
	  }, {
	    key: "wsIsUp",
	    value: function wsIsUp(actionData) {
	      if (actionData.ws === true) {
	        let client;
	        if (notCommon$1.objHas(actionData, "wsClient") && actionData.wsClient) {
	          client = notCommon$1.getApp().getWSClient(actionData.wsClient);
	        } else {
	          client = notCommon$1.getApp().getWSClient();
	        }
	        if (client) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "selectTransport",
	    value: function selectTransport(actionData) {
	      if (this.wsIsUp(actionData)) {
	        return "ws"; //for ws/wss
	      }
	      if (notCommon$1.objHas(actionData, "method")) {
	        return "http"; //for http/https
	      }
	      return false; //for offline
	    }
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this && this.manifest ? this.manifest.model : null;
	    }
	  }, {
	    key: "getActionData",
	    value: function getActionData(actionName) {
	      return this.getActions() && this.getActions()[actionName] ? this.getActions()[actionName] : null;
	    }
	  }, {
	    key: "getActionsCount",
	    value: function getActionsCount() {
	      return this.getActions() ? Object.keys(this.getActions()).length : 0;
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.manifest && this.manifest.actions ? this.manifest.actions : {};
	    }
	  }, {
	    key: "parseParams",
	    value: function parseParams(start, end, line, record) {
	      let fieldName = "";
	      let len = start.length;
	      while (line.indexOf(start) > -1) {
	        let ind = line.indexOf(start);
	        let startSlice = ind + len;
	        let endSlice = line.indexOf(end);
	        if (ind > endSlice) {
	          break;
	        }
	        fieldName = line.slice(startSlice, endSlice);
	        if (fieldName == "") break;
	        this.log && this.log(start + fieldName + end, notPath.get(fieldName, record));
	        line = line.replace(start + fieldName + end, notPath.get(fieldName, record));
	      }
	      return line;
	    }
	  }, {
	    key: "parseLine",
	    value: function parseLine(line, record, actionName) {
	      line = line.replace(":modelName", this.manifest.model);
	      line = line.replace(":actionName", actionName);
	      line = this.parseParams(":record[", "]", line, record);
	      line = this.parseParams(":", "?", line, record);
	      return line;
	    }
	  }, {
	    key: "getURL",
	    value: function getURL(record, actionData, actionName) {
	      var line = this.parseLine(this.manifest.url, record, actionName) + (notCommon$1.objHas(actionData, "postFix") ? this.parseLine(actionData.postFix, record, actionName) : "");
	      return line;
	    }
	  }, {
	    key: "getServerURL",
	    value: function getServerURL() {
	      return notCommon$1.getApp() ? notCommon$1.getApp().getOptions("api.server.url", "") : "";
	    }
	  }, {
	    key: "getWSRequestName",
	    value: function getWSRequestName(actionName) {
	      const modelName = this.manifest.model;
	      return `${modelName}${DEFAULT_WS_ROUTE_ACTION_SPLITTER}${actionName}`;
	    }
	  }, {
	    key: "encodeRequest",
	    value: function encodeRequest(data) {
	      let p = "?";
	      for (let t in data) {
	        if (typeof data[t] !== "undefined" && data[t] !== null) {
	          p += encodeURIComponent(t) + "=" + encodeURIComponent(data[t].constructor === Object ? JSON.stringify(data[t]) : data[t]) + "&";
	        }
	      }
	      //for test purpose only, special test server needed
	      if (this.getOptions("test")) {
	        p += "&test=1";
	        if (this.getOptions("test.session")) {
	          p += "&session=" + this.getOptions("test.session");
	        }
	        if (this.getOptions("test.session")) {
	          p += "&role=" + this.getOptions("test.role");
	        }
	      }
	      return p;
	    }
	  }, {
	    key: "collectRequestData",
	    value: function collectRequestData(actionData) {
	      let requestData = {};
	      if (notCommon$1.objHas(actionData, "data") && Array.isArray(actionData.data)) {
	        for (let i = 0; i < actionData.data.length; i++) {
	          let dataProviderName = "get" + notCommon$1.capitalizeFirstLetter(actionData.data[i]);
	          if (this[dataProviderName] && typeof this[dataProviderName] === "function") {
	            let data = this[dataProviderName](),
	              res = {};
	            if (["pager", "sorter", "filter", "search", "return"].indexOf(actionData.data[i]) > -1) {
	              res[actionData.data[i]] = data;
	            } else {
	              res = data;
	            }
	            requestData = Object.assign(requestData, res);
	          }
	        }
	      }
	      return requestData;
	    }
	  }, {
	    key: "getID",
	    value: function getID(record, actionData) {
	      let resultId,
	        list = OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY,
	        prefixes = ["", this.manifest.model];
	      if (notCommon$1.objHas(actionData, "index") && actionData.index) {
	        list = [actionData.index].concat(OPT_DEFAULT_INDEX_FIELD_NAME_PRIORITY);
	      }
	      for (let pre of prefixes) {
	        for (let t of list) {
	          if (notCommon$1.objHas(record, pre + t)) {
	            resultId = record[pre + t];
	            break;
	          }
	        }
	      }
	      return resultId;
	    }
	  }, {
	    key: "setFindBy",
	    value: function setFindBy(key, value) {
	      var obj = {};
	      obj[key] = value;
	      return this.setFilter(obj);
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(filterData = DEFAULT_FILTER) {
	      this.setWorking("filter", filterData);
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      return this.setFilter();
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getWorking("filter");
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(searchData = DEFAULT_SEARCH) {
	      this.setWorking("search", searchData);
	      return this;
	    }
	  }, {
	    key: "resetSearch",
	    value: function resetSearch() {
	      return this.setSearch();
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      return this.getWorking("search");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(sorterData) {
	      this.setWorking("sorter", sorterData);
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter() {
	      return this.setSorter({});
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(returnData = DEFAULT_RETURN) {
	      this.setWorking("return", returnData);
	      return this;
	    }
	  }, {
	    key: "resetReturn",
	    value: function resetReturn() {
	      return this.setReturn({});
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setPageNumber",
	    value: function setPageNumber(pageNumber) {
	      this.setWorking("pager.page", pageNumber);
	      return this;
	    }
	  }, {
	    key: "setPageSize",
	    value: function setPageSize(pageSize) {
	      this.setWorking("pager.size", pageSize);
	      return this;
	    }

	    //pageSize = DEFAULT_PAGE_SIZE, pageNumber = DEFAULT_PAGE_NUMBER
	  }, {
	    key: "setPager",
	    value: function setPager() {
	      if ((arguments.length < 2 || isNaN(arguments[0]) || isNaN(arguments[1])) && arguments[0].constructor === Object && notCommon$1.objHas(arguments[0], "page") && notCommon$1.objHas(arguments[0], "size")) {
	        const pager = arguments[0];
	        this.setWorking("pager", {
	          size: pager.size || DEFAULT_PAGE_SIZE,
	          page: pager.page || DEFAULT_PAGE_NUMBER
	        });
	      } else if (arguments.length === 2 && !isNaN(arguments[0]) && !isNaN(arguments[1])) {
	        this.setWorking("pager", {
	          size: arguments[0] || DEFAULT_PAGE_SIZE,
	          page: arguments[1] || DEFAULT_PAGE_NUMBER
	        });
	      }
	      return this;
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      return this.setPager();
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getWorking("pager");
	    }
	  }, {
	    key: "getRecord",
	    value: function getRecord() {
	      this.getData();
	    }
	  }, {
	    key: "getDefaultAsPlainObject",
	    value: function getDefaultAsPlainObject() {
	      if (!this.manifest || !this.manifest.fields) {
	        return {};
	      }
	      const result = {};
	      for (const fieldName of Object.keys(this.manifest.fields)) {
	        if (Object.hasOwn(this.manifest.fields[fieldName], "default")) {
	          const defaultValue = this.manifest.fields[fieldName].default;
	          if (Array.isArray(defaultValue)) {
	            result[fieldName] = [...defaultValue];
	          } else if (typeof defaultValue === "object") {
	            result[fieldName] = {
	              ...defaultValue
	            };
	          } else {
	            result[fieldName] = defaultValue;
	          }
	        }
	      }
	      return result;
	    }
	  }]);
	}(notBase);

	let notRecord = /*#__PURE__*/function (_notBase) {
	  function notRecord(manifest, item) {
	    var _this;
	    _classCallCheck(this, notRecord);
	    _this = _callSuper(this, notRecord);
	    if (typeof item === "undefined" || item === null || typeof item !== "object") {
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && item.isProxy) {
	      notCommon$1.error("this is Proxy item");
	      return _possibleConstructorReturn(_this, item);
	    }
	    if (item && (item.isRecord || item.isProperty)) {
	      return _possibleConstructorReturn(_this, item);
	    } else {
	      if (Array.isArray(item)) {
	        return _possibleConstructorReturn(_this, _this.createCollection(manifest, item));
	      }
	    }
	    _this.setOptions({});
	    _this[META_INTERFACE] = new notInterface(manifest, {});
	    _this.setData(item);
	    _this.interfaceUp();
	    _this.mapToInterface();
	    _this.mapToMethods();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notRecord, _notBase);
	  return _createClass(notRecord, [{
	    key: "toDefault",
	    value: function toDefault() {
	      return this.setData(this[META_INTERFACE].getDefaultAsPlainObject());
	    }
	  }, {
	    key: "mapToInterface",
	    value: function mapToInterface() {
	      let rec = this;
	      for (let t of META_MAP_TO_INTERFACE) {
	        if (this[META_INTERFACE][t] && typeof this[META_INTERFACE][t] === "function") {
	          this[t] = function () {
	            let res = rec[META_INTERFACE][t](...arguments);
	            return res == rec[META_INTERFACE] ? rec : res;
	          };
	        }
	      }
	    }
	  }, {
	    key: "mapToMethods",
	    value: function mapToMethods() {
	      let manifest = this[META_INTERFACE].manifest,
	        app = notCommon$1.getApp(),
	        methods = {};
	      if (manifest.methods) {
	        methods = manifest.methods;
	      } else if (app) {
	        methods = app.getOptions(["models", this[META_INTERFACE].manifest.model].join("."), {});
	      }
	      if (methods) {
	        for (let t in methods) {
	          if (Object.hasOwn(methods, t)) {
	            this[t] = methods[t];
	          }
	        }
	      }
	    }
	  }, {
	    key: "createCollection",
	    value: function createCollection(manifest, items) {
	      var collection = [];
	      for (var i = 0; i < items.length; i++) {
	        collection.push(new notRecord(manifest, items[i]));
	      }
	      return collection;
	    }
	  }, {
	    key: "interfaceUp",
	    value: function interfaceUp() {
	      if (this[META_INTERFACE].getActionsCount() > 0) {
	        let actions = this[META_INTERFACE].getActions();
	        for (let i in actions) {
	          this.actionUp(i, actions[i]);
	        }
	      }
	    }
	  }, {
	    key: "actionUp",
	    value: function actionUp(index) {
	      var _this2 = this;
	      if (!Object.hasOwn(this, [DEFAULT_ACTION_PREFIX$1 + index])) {
	        this[DEFAULT_ACTION_PREFIX$1 + index] = function (...params) {
	          return _this2[META_INTERFACE].request(_this2, index, ...params);
	        };
	      }
	    }
	    /*
	    -> 'path.to.key', valueOfKey
	    <- ok, with one onChange event triggered
	    */
	  }, {
	    key: "setAttr",
	    value: function setAttr(key, value) {
	      return this.setData(key, value);
	    }

	    /*
	    ->
	    {
	    'keyPath': value,
	    'key.subPath': value2,
	    'keyPath.0.title': value3
	    }
	    <- ok, with bunch of onChange events triggered
	    */
	  }, {
	    key: "setAttrs",
	    value: function setAttrs(objectPart) {
	      //notCommon.log('setAttrs', objectPart, Object.keys(objectPart));
	      if (objectPart && typeof objectPart === "object" && Object.keys(objectPart).length > 0) {
	        for (let path in objectPart) {
	          //notCommon.log('setAttrs one to go', path);
	          this.setAttr(path, objectPart[path]);
	        }
	      }
	    }

	    /*
	    -> 'pathToKey'
	    <- value1
	    */
	  }, {
	    key: "getAttr",
	    value: function getAttr(what, plain = false) {
	      let prx = this.getData(what, {});
	      if (plain) {
	        return notCommon$1.stripProxy(prx);
	      } else {
	        return prx;
	      }
	    }

	    /*
	    -> ['pathToKey', 'path.to.key', 'simpleKey',...]
	    <- [value1, value2, value3,...]
	    */
	  }, {
	    key: "getAttrs",
	    value: function getAttrs(what) {
	      let result = [];
	      if (what && what.length > 0) {
	        for (let path of what) {
	          result.push(this.getAttr(path));
	        }
	      }
	      return result;
	    }
	  }, {
	    key: "getManifest",
	    value: function getManifest() {
	      if (this[META_INTERFACE]) {
	        return this[META_INTERFACE].manifest;
	      } else {
	        return {};
	      }
	    }
	  }, {
	    key: "setItem",
	    value: function setItem(item) {
	      this.setData(item);
	      return this;
	    }
	  }]);
	}(notBase);

	/**
	 * @const {string} [OPT_CONTROLLER_PREFIX = "nc"] controller names prefix nc aka NotController
	 */
	const OPT_CONTROLLER_PREFIX = "nc";
	/**
	 * @const {string} [OPT_RECORD_PREFIX = "nr"] record names prefix nr aka NotRecord
	 */
	const OPT_RECORD_PREFIX = "nr";
	/**
	 * @const {string} [DEFAULT_WS_CLIENT_NAME = "main"] default name of WS client
	 */
	const DEFAULT_WS_CLIENT_NAME = "main";

	/**
	 * Class of application
	 * @class
	 */
	let notApp = /*#__PURE__*/function (_notBase) {
	  /**
	   * @class
	   * @param {object} options              application options
	   * @param {string} options.name         name
	   * @param {object} options.controllers  controllers
	   * @param {string}  options.manifestURL URL of network manifest with all available models/actions/fields requests options
	   */
	  function notApp(options) {
	    var _this;
	    _classCallCheck(this, notApp);
	    _this = _callSuper(this, notApp, [{
	      working: {
	        name: options.name,
	        interfaces: {},
	        controllers: notCommon$1.objHas(options, "controllers") ? options.controllers : {},
	        initController: null,
	        currentController: null,
	        uis: {},
	        wsc: {},
	        wss: {},
	        services: {}
	      },
	      options
	    }]);
	    _this?.log && _this.log("start app");
	    notCommon$1.register("app", _this);
	    _this.initManifest();
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   * Initializes application according to network manifest, which is retrieved from server
	   */
	  _inherits(notApp, _notBase);
	  return _createClass(notApp, [{
	    key: "initManifest",
	    value: function initManifest() {
	      var _this2 = this;
	      notCommon$1.getJSON(this.getOptions("manifestURL")).then(function (manifest) {
	        return _this2.setInterfaceManifest(manifest);
	      }).catch(function (e) {
	        return notCommon$1.report(e);
	      });
	    }

	    /**
	     * One page routing initialization
	     */
	  }, {
	    key: "initRouter",
	    value: function initRouter() {
	      this.setWorking("router", notRouter$1);
	      this.getWorking("router").setRoot(this.getOptions("router.root"));
	      notRouter$1.reRouteExisted();
	    }

	    /**
	     * Creates all the routes handlers and pushes them into router
	     */
	  }, {
	    key: "execRouter",
	    value: function execRouter() {
	      var routieInput = {};
	      for (let t = 0; t < this.getOptions("router.manifest").length; t++) {
	        let routeBlock = this.getOptions("router.manifest")[t],
	          paths = routeBlock.paths,
	          schemes = routeBlock.schemes,
	          controller = routeBlock.controller;
	        for (let i = 0; i < paths.length; i++) {
	          let pathScheme = schemes && Array.isArray(schemes) && schemes.length > i ? schemes[i] : false;
	          routieInput[paths[i]] = this.bindController(controller, pathScheme);
	        }
	      }
	      this.getWorking("router").addList(routieInput).listen(); //.navigate(this.getOptions('router.index'));
	    }

	    /**
	     * Sets interface manifest option
	     * @param {object}  manifest    interface manifest
	     */
	  }, {
	    key: "setInterfaceManifest",
	    value: function setInterfaceManifest(manifest) {
	      Object.freeze(manifest);
	      this.setOptions("interfaceManifest", manifest);
	      this.initRouter();
	      this.update();
	    }

	    /**
	     * returns constructor of interface model
	     * @param {string}  modelName   model name
	     * @returns {object}    interface model constructor
	     */
	  }, {
	    key: "getInterfaceManifest",
	    value: function getInterfaceManifest(modelName) {
	      if (modelName) {
	        return this.getOptions("interfaceManifest")[modelName];
	      } else {
	        return this.getOptions("interfaceManifest");
	      }
	    }

	    /**
	     * Updating Application, reloads interfaces, init controller launched, start again
	     */
	  }, {
	    key: "update",
	    value: function update() {
	      //нужно инициализировать
	      //модели полученными интерфейсами
	      this.updateInterfaces();
	      //иницилицировать и запустить контроллер инициализации
	      this.initController();
	      this.startApp();
	    }

	    /**
	     * Initialization of services, startup of routing
	     */
	  }, {
	    key: "startApp",
	    value: function startApp() {
	      this.initServices();
	      //создать контроллеры
	      //роутер и привязать к нему контроллеры
	      this.execRouter();
	      this.emit("afterStarted", this);
	    }

	    /**
	     *
	     * @param {object} controllerName controller constructor
	     * @param {string[]} controllerPathScheme
	     * @returns {function} function creates new controller instance and pass in notApp instance, arguments from router parser and pathScheme
	     */
	  }, {
	    key: "bindController",
	    value: function bindController(controllerName, controllerPathScheme) {
	      let app = this;
	      return function () {
	        new controllerName(app, arguments, controllerPathScheme);
	      };
	    }

	    /**
	     * Initializes 'initialization' controller which is runs once,
	     * to perform custom initializations routines by application code
	     */
	  }, {
	    key: "initController",
	    value: function initController() {
	      if (typeof this.getOptions("initController") !== "undefined") {
	        let initController = this.getOptions("initController");
	        this.setWorking("initController", new initController(this));
	      }
	    }

	    /**
	     * Returns working controller
	     * @returns {object} working controller
	     */
	  }, {
	    key: "getCurrentController",
	    value: function getCurrentController() {
	      return this.getWorking("currentController");
	    }

	    /**
	     * Destroyes working controller then sets provided as working
	     * @param {object} ctrl controller instance
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "setCurrentController",
	    value: function setCurrentController(ctrl) {
	      let oldCtrl = this.getCurrentController();
	      if (oldCtrl && oldCtrl.destroy) {
	        oldCtrl.destroy();
	      }
	      this.setWorking("currentController", ctrl);
	      return this;
	    }

	    /**
	     * Creates arrow function: (modelInitData = {}) => notRecord
	     * Factory that creates notRecord instances with binded
	     * recordManifest and provided data to initialize record
	     * @param {Object} recordManifest
	     * @return {function}
	     * @memberof notApp
	     */
	  }, {
	    key: "createInterfaceModelFactory",
	    value: function createInterfaceModelFactory(recordManifest) {
	      return function (recordData) {
	        return new notRecord(recordManifest, recordData);
	      };
	    }

	    /**
	     * Clears interfaces, recreates all according to Options.interafaceManifest
	     */
	  }, {
	    key: "updateInterfaces",
	    value: function updateInterfaces() {
	      this.clearInterfaces();
	      let manifests = this.getOptions("interfaceManifest");
	      if (manifests) {
	        for (let name in manifests) {
	          let recordManifest = manifests[name],
	            recordMethods = this.getOptions(["models", name].join("."), {});
	          recordManifest.methods = recordMethods;
	          const nameInt = this.createInterfaceModelFactory(recordManifest);
	          this.setInterface(name, nameInt);
	        }
	      }
	    }

	    /**
	     * Converts interface name (modelName) to standartizied prefixModelName
	     * @param {string} name interface model name
	     * @returns {string}    not record name
	     */
	  }, {
	    key: "getRecordName",
	    value: function getRecordName(name) {
	      return OPT_RECORD_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Converts controller name (controllerName) to standartizied prefixControllerName
	     * @param {string} name controller name
	     * @returns {string}    not controller name
	     */
	  }, {
	    key: "getControllerName",
	    value: function getControllerName(name) {
	      return OPT_CONTROLLER_PREFIX + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     * Sets named interface factory function
	     *
	     * @param {string} name
	     * @param {function} modelFactory
	     * @return {notApp}
	     * @memberof notApp
	     */
	  }, {
	    key: "setInterface",
	    value: function setInterface(name, modelFactory) {
	      return this.setWorking(`interfaces.${name}`, modelFactory);
	    }

	    /**
	     * Returns all network interfaces
	     * @returns {object} all network insterfaces
	     */
	  }, {
	    key: "getInterfaces",
	    value: function getInterfaces() {
	      return this.getWorking("interfaces");
	    }

	    /**
	     * Sets interfaces list clear
	     * @returns {object} notApp instance
	     */
	  }, {
	    key: "clearInterfaces",
	    value: function clearInterfaces() {
	      this.setWorking("interfaces", {});
	      return this;
	    }

	    /**
	     * Sets WebSockets client
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME] name of client
	     * @param {object} wsc  notWSClient instance
	     * @returns {object} notApp instance
	     */
	    // @ts-ignore
	  }, {
	    key: "setWSClient",
	    value: function setWSClient(name = DEFAULT_WS_CLIENT_NAME, wsc) {
	      return this.setWorking(`wsc.${name}`, wsc);
	    }

	    /**
	     * Returns web sockets client instance by name
	     * @param {string} [name=DEFAULT_WS_CLIENT_NAME]
	     * @returns {object} instance of notWSClient
	     */
	  }, {
	    key: "getWSClient",
	    value: function getWSClient(name = DEFAULT_WS_CLIENT_NAME) {
	      return this.getWorking(`wsc.${name}`);
	    }

	    /**
	     * returns network interface class initializator
	     * @param {string} name name of network interface
	     * @returns {function} interface class initializator
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name) {
	      return this.getInterfaces()[name];
	    }

	    /**
	     * Returns network interface (model) initialized with provided data
	     * @param {string} name interface(modelName)
	     * @param {object} [data={}]    model data
	     * @returns network interface initializes with provided data
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data = {}) {
	      return this.getInterface(name)(data);
	    }

	    /**
	     * Sets service
	     * @param {string} name name of the service
	     * @param {object|function} val service
	     */
	  }, {
	    key: "setService",
	    value: function setService(name, val) {
	      return this.setWorking(`services.${name}`, val);
	    }

	    /**
	     * Returns service
	     * @param {string} name name of the service
	     * @returns {object|function} service
	     */
	  }, {
	    key: "getService",
	    value: function getService(name) {
	      return this.getWorking(`services.${name}`);
	    }

	    /**
	     * Initializes all provided services
	     */
	  }, {
	    key: "initServices",
	    value: function initServices() {
	      if (this.getOptions("services")) {
	        for (let servName in this.getOptions("services")) {
	          try {
	            let serv = this.getOptions(`services.${servName}`);
	            const servType = notCommon$1.detectType(serv);
	            switch (servType) {
	              case "function":
	              case "class":
	                this.setService(servName, new serv(this));
	                break;
	              default:
	                this.setService(servName, serv);
	            }
	          } catch (e) {
	            this?.error && this.error(`Service (${servName}) init error`, e);
	          }
	        }
	      }
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} moduleName   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "getConfigReaderForModule",
	    value: function getConfigReaderForModule(moduleName = "") {
	      var _this3 = this;
	      const modConfPath = ["modules", moduleName].join(".");
	      return {
	        get: function (subPath, fallback) {
	          if (subPath && typeof subPath == "string" && subPath.length) {
	            return _this3.getOptions([modConfPath, subPath].join("."), fallback);
	          } else {
	            return _this3.getOptions(modConfPath, fallback);
	          }
	        }
	      };
	    }

	    /**
	     * Returns module dedicated options reader
	     * @param {string} [moduleName='']   module name
	     * @returns {object} reader object {get(pathToValue, defaultValue)}
	     */
	  }, {
	    key: "moduleConfig",
	    value: function moduleConfig(moduleName = "") {
	      return this.getConfigReaderForModule(moduleName);
	    }
	  }]);
	}(notBase);
	/**
	 *  @static {function} DEFAULT_WS_CLIENT_NAME  function to perform deep merges of objects
	 */
	_defineProperty(notApp, "DEFAULT_WS_CLIENT_NAME", DEFAULT_WS_CLIENT_NAME);

	/**
	 * @const {string}  [OPT_DEFAULT_ACTION_NAME = "default"]      default action name
	 */
	const OPT_DEFAULT_ACTION_NAME = "default";

	/**
	 * @const {string}  [OPT_DEFAULT_CONTAINER_SELECTOR = "main.content"]  selector of container HTML
	 *                          element
	 */
	const OPT_DEFAULT_CONTAINER_SELECTOR = "main.content";

	/**
	 * @const {string}  [OPT_DEFAULT_PLURAL_NAME = "Models"]  default plural name of entities
	 */
	const OPT_DEFAULT_PLURAL_NAME = "Models";

	/**
	 * @const {string}  [OPT_DEFAULT_SINGLE_NAME = "Model"]  default single name of entities
	 */
	const OPT_DEFAULT_SINGLE_NAME = "Model";

	/**
	 * @const {string}  [OPT_DEFAULT_MODULE_NAME="main"]  default module name
	 */
	const OPT_DEFAULT_MODULE_NAME = "main";

	/**
	 * @const {boolean}  [OPT_DEFAULT_AUTO_NAME = true]  if shoould be used auto name generator
	 */
	const OPT_DEFAULT_AUTO_NAME = true;

	/**
	 *  Basic class for user controller
	 *  @extends notBase
	 */
	let notController = /*#__PURE__*/function (_notBase) {
	  /**
	   *  @class
	   *  @param {import('./app.js').default} app
	   *  @param  {string}    name
	   */
	  function notController(app, name) {
	    var _this;
	    _classCallCheck(this, notController);
	    _this = _callSuper(this, notController, [{}]);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "els", void 0);
	    /**
	     *
	     * @type    {object|null}
	     * @memberof notController
	     */
	    _defineProperty(_this, "make", void 0);
	    /**
	     *
	     * @type    {null|import('./app.js').default}
	     * @memberof notController
	     */
	    _defineProperty(_this, "app", void 0);
	    _this.app = app;
	    _this.app.setCurrentController(_this);
	    _this.setWorking({
	      name,
	      ready: false,
	      views: {},
	      libs: {},
	      helpers: {}
	    });
	    _this.ui = {};
	    _this.els = {};
	    _this.setData({});
	    _this.setOptions({
	      moduleName: OPT_DEFAULT_MODULE_NAME,
	      containerSelector: OPT_DEFAULT_CONTAINER_SELECTOR,
	      prefix: app.getOptions("paths.module"),
	      names: {
	        plural: OPT_DEFAULT_PLURAL_NAME,
	        single: OPT_DEFAULT_SINGLE_NAME
	      }
	    });
	    _this.setURLPrefix(app.getOptions("router.root"));
	    /*
	    сразу делаем доступными модели notRecord из nc`ControllerName` будут доступны как this.nr`ModelName`
	    */
	    let interfaces = app.getInterfaces();
	    _this.make = {};
	    for (let t in interfaces) {
	      // @ts-ignore
	      if (Object.hasOwn(interfaces, t)) {
	        _this.make[t] = interfaces[t];
	      }
	    }
	    _this.on("destroy", function () {
	      _this.app = null;
	      for (let uiName in _this.ui) {
	        _this.ui[uiName].destroy && _this.ui[uiName].destroy();
	        _this.ui[uiName].$destroy && _this.ui[uiName].$destroy();
	        _this.ui[uiName] = null;
	      }
	      _this.els = null;
	      _this.make = null;
	    });
	    return _possibleConstructorReturn(_this, _this);
	  }

	  /**
	   *  Returns current notApp
	   *  @return {import('./app.js').default}
	   */
	  _inherits(notController, _notBase);
	  return _createClass(notController, [{
	    key: "getApp",
	    value: function getApp() {
	      return notCommon$1.getApp();
	    }

	    /**
	     *  Sets default controller model
	     *  @param {import('./record.js')}  model  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModel",
	    value: function setModel(model) {
	      this.setWorking("model", model);
	      return this;
	    }

	    /**
	     *  If zero or one argument provided this modelName instance will be returned
	     *  If two provided and first is a string than instance of name will be returned initialized with second object param or empty object
	     *  @param {string|object}      [name]    modelName of instance to return or initial data for instance
	     *  @param {object}             [data]    model data
	     *  @return {import('./record.js').default}
	     */
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        const int = this.getInterface(name);
	        return int && int(data || {});
	      } else {
	        const int = this.getInterface();
	        return int && int(name || {});
	      }
	    }

	    /**
	     * Returns controller interface if name is not specified or interface of specified
	     *
	     * @param {string} [name=""]
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = "") {
	      return this.app?.getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getWorking("modelName");
	    }
	    /**
	     *  Sets default controller model name
	     *  @param {string}  modelName  notRecord interface object
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelName",
	    value: function setModelName(modelName) {
	      this.setWorking("modelName", notCommon$1.lowerFirstLetter(modelName));
	      return this;
	    }

	    /**
	     *  Returns current model primary ID field name
	     *  @return {import('./record.js')}
	     */
	  }, {
	    key: "getModelIDFieldName",
	    value: function getModelIDFieldName() {
	      return this.getWorking("modelIDFieldName", "_id");
	    }

	    /**
	     *  Sets current model primary ID field name
	     *  @return {notController}
	     */
	  }, {
	    key: "setModelIDFieldName",
	    value: function setModelIDFieldName(val = "_id") {
	      return this.setWorking("modelIDFieldName", val);
	    }

	    /**
	     *  Marks this controller as ready
	     *  emits "ready"/"busy" events
	     *  @param {Boolean}  val  true/false
	     */
	  }, {
	    key: "setReady",
	    value: function setReady(val = true) {
	      this.setWorking("ready", val);
	      val ? this.emit("ready") : this.emit("busy");
	    }

	    /**
	     *  Sets module URL prefix
	     *  @param {string} val URL prefix
	     *  @return {notController} this
	     */
	  }, {
	    key: "setURLPrefix",
	    value: function setURLPrefix(val) {
	      this.setOptions("urlPrefix", val);
	      this.updateAutoName();
	      return this;
	    }

	    /**
	     *  Returns module url prefix
	     *  @return  {string} prefix
	     */
	  }, {
	    key: "getURLPrefix",
	    value: function getURLPrefix() {
	      return this.getOptions("urlPrefix");
	    }

	    /**
	     *  Sets module name
	     *  @param {string} val name of the module
	     *  @return {notController} this
	     */
	  }, {
	    key: "setModuleName",
	    value: function setModuleName(val) {
	      this.setOptions("moduleName", notCommon$1.lowerFirstLetter(val));
	      this.updateAutoName();
	      return this;
	    }
	    /**
	     *  Returns module name
	     *  @return  {string} module name
	     */
	  }, {
	    key: "getModuleName",
	    value: function getModuleName() {
	      return this.getOptions("moduleName");
	    }

	    /**
	     *  Returns this module path prefix
	     *  @return {string}  path to module dir
	     */
	  }, {
	    key: "getModulePrefix",
	    value: function getModulePrefix() {
	      return [notCommon$1.getApp().getOptions("paths.modules"), this.getModuleName()].join("/");
	    }

	    /**
	     *  Returns this model URL with URL prefix
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelURL",
	    value: function getModelURL() {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName()
	      });
	    }

	    /**
	     *  Returns this model action URL with URL prefix
	     * @param  {string}   id       some identificator of model
	     * @param  {string}   action   action name
	     *  @return {string}  url path
	     */
	  }, {
	    key: "getModelActionURL",
	    value: function getModelActionURL(id, action = "") {
	      return notCommon$1.buildURL({
	        prefix: this.getURLPrefix(),
	        module: this.getModuleName(),
	        model: this.getModelName(),
	        id,
	        action
	      });
	    }

	    /**
	     * Creates url from value content
	     * @param {object}  val
	     **/
	  }, {
	    key: "buildURL",
	    value: function buildURL(val) {
	      return notCommon$1.buildURL(val);
	    }

	    /**
	     *  Updates working name
	     *  @return {notController} this
	     */
	  }, {
	    key: "updateAutoName",
	    value: function updateAutoName() {
	      if (this.getOptions("autoName", OPT_DEFAULT_AUTO_NAME)) ;
	      return this;
	    }

	    /**
	     *  Sets object name
	     *  @param {string} val name of the object
	     *  @return {notController} this
	     */
	  }, {
	    key: "setName",
	    value: function setName(val) {
	      this.setWorking("name", val);
	      this.setOptions("autoName", false);
	      return this;
	    }

	    /**
	     *  Gets object name
	     *  @return {string}
	     */
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }

	    /**
	     *  Preload records from server, using listAll method,
	     *  returns Promise
	     *  @param {object}  list  map of preloaded records
	     *  @return {Promise}
	     */
	  }, {
	    key: "preloadLib",
	    value: function preloadLib(list = {}) {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        if (typeof list !== "object") {
	          resolve(undefined);
	        } else {
	          _this2.setWorking("loading", []);
	          for (let t in list) {
	            _this2.getWorking("loading").push(list[t]);
	            _this2.make[list[t]]({}).$listAll().then(function (data) {
	              if (!_this2.getOptions("libs")) {
	                _this2.setOptions("libs", {});
	              }
	              _this2.getOptions("libs")[t] = data;
	              if (_this2.getWorking("loading").indexOf(list[t]) > -1) {
	                _this2.getWorking("loading").splice(_this2.getWorking("loading").indexOf(list[t]), 1);
	              }
	              if (_this2.getWorking("loading").length === 0) {
	                resolve(undefined);
	              }
	            }).catch(function (err) {
	              _this2.report(err);
	              reject();
	            });
	          }
	          if (_this2.getWorking("loading").length === 0) {
	            resolve(undefined);
	          }
	        }
	      });
	    }

	    /**
	     * emits afterRender event
	     */
	  }, {
	    key: "onAfterRender",
	    value: function onAfterRender() {
	      this.emit("afterRender");
	    }

	    /**
	     *  Transform route name in action name
	     *  @param {String}   name tranform action name
	     *  @return {String}
	     */
	  }, {
	    key: "getActionName",
	    value: function getActionName(name = OPT_DEFAULT_ACTION_NAME) {
	      return "run" + notCommon$1.capitalizeFirstLetter(name);
	    }

	    /**
	     *  Get default controller action name
	     *  @return {String} default action from options
	     */
	  }, {
	    key: "getDefaultActionName",
	    value: function getDefaultActionName() {
	      return this.getActionName(this.getOptions("defaultAction", OPT_DEFAULT_ACTION_NAME));
	    }

	    /**
	     *  Route params into specific run[Route_name] function
	     *  @param {array}   params   controller input params
	     *  @return {undefined}
	     */
	  }, {
	    key: "route",
	    value: function route(params) {
	      let [routerName, ...subParams] = params,
	        actionName = this.getActionName(routerName ? routerName : OPT_DEFAULT_ACTION_NAME);
	      if (typeof this[actionName] === "function") {
	        this.setCurrentAction(actionName);
	        this[actionName](subParams);
	      } else if (this[this.getDefaultActionName()]) {
	        this.setCurrentAction(this.getDefaultActionName());
	        this[this.getDefaultActionName()](subParams);
	      } else {
	        this.setCurrentAction(undefined);
	        this.error && this.error("No action in router", params);
	      }
	    }

	    /**
	     * Sets working action
	     * @params {string} actionName current action name
	     */
	  }, {
	    key: "setCurrentAction",
	    value: function setCurrentAction(actionName) {
	      this.setWorking("action", actionName);
	    }

	    /**
	     * Gets working action
	     * @returns {string} current action name
	     */
	  }, {
	    key: "getCurrentAction",
	    value: function getCurrentAction() {
	      return this.getWorking("action");
	    }

	    /**
	     *  Return application options
	     *  @return {object}
	     */
	  }, {
	    key: "getAppOptions",
	    value: function getAppOptions() {
	      try {
	        return this.getApp().getOptions();
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module options
	     *  @param  {string}   [moduleName]    name of the module which options requested
	     *  @return {object}
	     */
	  }, {
	    key: "getModuleOptions",
	    value: function getModuleOptions(moduleName) {
	      try {
	        return this.getApp().getOptions(["modules", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module services
	     *  @param  {string}   moduleName    name of the module which services requested
	     *  @return {object}
	     */
	  }, {
	    key: "getServices",
	    value: function getServices(moduleName) {
	      try {
	        return this.getApp().getOptions(["services", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Returns module components
	     *  @param  {string}   moduleName    name of the module which components requested
	     *  @return {object}
	     */
	  }, {
	    key: "getComponents",
	    value: function getComponents(moduleName) {
	      try {
	        return this.getApp().getOptions(["components", moduleName || this.getModuleName()].join("."));
	      } catch (e) {
	        this.error && this.error(e);
	      }
	    }

	    /**
	     *  Refreshes current URL, re-run all action
	     *  @param {number} timeout time to wait in ms
	     */
	  }, {
	    key: "refresh",
	    value: function refresh(timeout = 0) {
	      this.app?.getWorking("router").refresh(timeout);
	    }

	    /**
	     * Returns path pattern for router
	     * @params {number} [0] paramsCount   number of params
	     * @return {string}  pattern for controller supported url
	     */
	  }, {
	    key: "getRouter",
	    value:
	    /**
	     * Returns Application router
	     * @returns {import('./router.js').default}
	     */
	    function getRouter() {
	      return this.app?.getWorking("router");
	    }

	    /**
	     * Changes location to `url` after `delay` ms
	     * @param {string} url
	     * @param {number|string}   delay   number in ms or name of delay
	     */
	  }, {
	    key: "navigateWithDelay",
	    value: function navigateWithDelay(url, delay = NAVIGATION_DELAY_DEFAULT, doBefore = function () {}) {
	      return this.getRouter().navigateWithDelay(url, delay, doBefore);
	    }

	    /**
	     * Changes location to `url`
	     * @param {string} url
	     */
	  }, {
	    key: "navigate",
	    value: function navigate(url) {
	      return this.getRouter().navigate(url);
	    }

	    /**
	     *  Navigating to this controller main model `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateAction",
	    value: function navigateAction(id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), this.getModelName(), id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to this controller module model of `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModelAction",
	    value: function navigateModelAction(modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      return this.navigateModuleAction(this.getModuleName(), modelName, id, action, delay, doBefore);
	    }

	    /**
	     *  Navigating to `moduleName` `modelName` `action` with provided `id`,
	     *  empty `id` will be dropped from resulting url
	     *
	     * @param {string} moduleName
	     * @param {string} modelName
	     * @param {string} id
	     * @param {string} [action=""]
	     * @param {number} [delay=0]            delay in ms before navigate
	     * @param   {function}  [doBefore]      will executed only if delayed after delay but before navigate
	     * @return {*}
	     * @memberof notController
	     */
	  }, {
	    key: "navigateModuleAction",
	    value: function navigateModuleAction(moduleName, modelName, id, action = "", delay = 0, doBefore = function () {}) {
	      if (delay) {
	        return this.getRouter().navigateWithDelay(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }), delay, doBefore);
	      } else {
	        return this.getRouter().navigate(notCommon$1.buildURL({
	          prefix: this.getURLPrefix(),
	          module: moduleName,
	          model: modelName,
	          id,
	          action
	        }));
	      }
	    }

	    /**
	     * Creates menu item from child class constructor
	     *
	     * @static
	     * @param {notController} childConstructor
	     * @return {Array<import('./types.js').NavigationItem>}
	     * @memberof notController
	     */
	  }], [{
	    key: "MODULE_NAME",
	    get:
	    /**
	     *  @static {string} MODULE_NAME  name of module
	     */
	    function () {
	      return OPT_DEFAULT_MODULE_NAME;
	    }
	    /**
	     *  @static {string} MODEL_NAME  name of model
	     */
	  }, {
	    key: "MODEL_NAME",
	    get: function () {
	      return "ModelName";
	    }
	  }, {
	    key: "LABELS",
	    get: function () {
	      return {
	        plural: `${OPT_DEFAULT_MODULE_NAME}:model_label_plural`,
	        single: `${OPT_DEFAULT_MODULE_NAME}:model_label_single`
	      };
	    }
	  }, {
	    key: "getControllerRoute",
	    value: function getControllerRoute(paramsCount = 0) {
	      let path = [];
	      if (this.MODULE_NAME && this.MODULE_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODULE_NAME));
	      }
	      if (this.MODEL_NAME && this.MODEL_NAME.length > 0) {
	        path.push(notCommon$1.lowerFirstLetter(this.MODEL_NAME));
	      }
	      path = [path.join("/")];
	      for (let i = 0; i < paramsCount; i++) {
	        path.push("/([^/]+)");
	      }
	      return path.join("");
	    }

	    /**
	     * Returns path patterns for router
	     * @params {number} [0] paramsDeep   how many paths with params in the end
	     * @return {string[]}  patterns for controller supported url in order of simplification
	     */
	  }, {
	    key: "getControllerRoutes",
	    value: function getControllerRoutes(paramsDeep = 0) {
	      let routes = [this.getControllerRoute(0)];
	      for (let i = 0; i < paramsDeep; i++) {
	        routes.unshift(this.getControllerRoute(i + 1));
	      }
	      return routes;
	    }

	    /**
	     * Returns router rule.
	     * @returns {Object} router rule {paths:String[], controller:notController}
	     */
	  }, {
	    key: "getRoutes",
	    value: function getRoutes() {
	      return {
	        paths: this.getControllerRoutes(this.PARAMS_LENGTH),
	        controller: this
	      };
	    }
	  }, {
	    key: "getCommonMenu",
	    value: function getCommonMenu(childConstructor) {
	      return [{
	        // @ts-ignore
	        section: childConstructor.MODULE_NAME,
	        // @ts-ignore
	        title: childConstructor.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(
        // @ts-ignore
        childConstructor.MODULE_NAME
        // @ts-ignore
        )}/${notCommon$1.lowerFirstLetter(childConstructor.MODEL_NAME)}`
	      }];
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu() {}
	  }]);
	}(notBase);
	/**
	 *  @static {number} PARAMS_LENGTH  number of params in URL path
	 */
	_defineProperty(notController, "PARAMS_LENGTH", 2);

	const ALL = {};
	function exist(key) {
	  return Object.hasOwn(ALL, key);
	}
	function get(key) {
	  if (exist(key)) {
	    return ALL[key];
	  } else {
	    return false;
	  }
	}
	function create(key, props = {
	  raw: [],
	  filtered: [],
	  selected: {}
	}) {
	  if (!exist(key)) {
	    if (Object.keys(props).length > 0) {
	      ALL[key] = {};
	      Object.keys(props).forEach(function (name) {
	        ALL[key][name] = writable(props[name]);
	      });
	    } else {
	      throw new Error("store's props wasn't specified");
	    }
	  }
	  return ALL[key];
	}

	function onInput(ev, id, fieldname, dispatch) {
		let data = {
			id: id(),
			field: fieldname(),
			value: ev.target.type === 'checkbox' ? ev.target.checked : ev.target.value
		};

		dispatch('change', data);
		return true;
	}

	var root$b = template(`<input type="checkbox"> <label class="label"></label>`, 1);

	function Ui_switch($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [id]
		 * @property {boolean} [value]
		 * @property {string} [fieldname]
		 * @property {boolean} [disabled]
		 * @property {boolean} [readonly]
		 * @property {string} [styling]
		 */
		/** @type {Props} */
		let id = prop($$props, 'id', 3, ''),
			value = prop($$props, 'value', 15, false),
			fieldname = prop($$props, 'fieldname', 3, 'switch'),
			disabled = prop($$props, 'disabled', 3, false),
			readonly = prop($$props, 'readonly', 3, false),
			styling = prop($$props, 'styling', 3, " is-rounded is-success ");

		var fragment = root$b();
		var input = first_child(fragment);

		remove_input_defaults(input);
		input.__input = [onInput, id, fieldname, dispatch];

		var label = sibling(input, 2);

		template_effect(() => {
			set_class(input, `switch ${styling() ?? ''}`);
			set_attribute(input, 'id', `edit-table-row-cell-inline-switch-${fieldname() ?? ''}-${id() ?? ''}`);
			set_attribute(input, 'name', fieldname());
			input.readOnly = readonly();
			input.disabled = disabled();
			set_attribute(label, 'for', `edit-table-row-cell-inline-switch-${fieldname() ?? ''}-${id() ?? ''}`);
		});

		bind_checked(input, value);
		append($$anchor, fragment);
		pop();
	}

	delegate(['input']);

	var root_3$5 = template(`<a> </a>`);
	var root_2$5 = template(`<div class="mx-1 tags has-addons svelte-38rpfk"><span class="tag"> </span> <span><!></span></div>`);
	var root_6$5 = template(`<a> </a>`);
	var root_5$5 = template(`<span><!></span>`);

	function Ui_tags($$anchor, $$props) {
		/*
		  import { createEventDispatcher } from 'svelte';
		  let dispatch = createEventDispatcher();
		*/
		/**
		 * @typedef {Object} Props
		 * @property {any} [values] - item = {
		id,        //unique
		title,     //some text
		value,      //for double tags
		color       //coloring
		}
		 */
		/** @type {Props} */
		let values = prop($$props, 'values', 19, () => []);
		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, values, (item) => item.id, ($$anchor, item) => {
			var fragment_1 = comment();
			var node_1 = first_child(fragment_1);

			{
				var consequent_1 = ($$anchor) => {
					var div = root_2$5();
					var span = child(div);
					var text$1 = child(span, true);

					reset(span);

					var span_1 = sibling(span, 2);
					var node_2 = child(span_1);

					{
						var consequent = ($$anchor) => {
							var a = root_3$5();
							var text_1 = child(a, true);

							reset(a);

							template_effect(() => {
								set_attribute(a, 'href', get$3(item).url);
								set_class(a, clsx(get$3(item).urlCustomClasses), 'svelte-38rpfk');
								set_text(text_1, get$3(item).value);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							var text_2 = text();

							template_effect(() => set_text(text_2, get$3(item).value));
							append($$anchor, text_2);
						};

						if_block(node_2, ($$render) => {
							if (get$3(item).url) $$render(consequent); else $$render(alternate, false);
						});
					}

					reset(span_1);
					reset(div);

					template_effect(() => {
						set_text(text$1, get$3(item).title);
						set_class(span_1, `tag is-${get$3(item).color ?? ''} ${get$3(item).customClasses ?? ''} svelte-38rpfk`);
					});

					append($$anchor, div);
				};

				var alternate_2 = ($$anchor) => {
					var span_2 = root_5$5();
					var node_3 = child(span_2);

					{
						var consequent_2 = ($$anchor) => {
							var a_1 = root_6$5();
							var text_3 = child(a_1, true);

							reset(a_1);

							template_effect(() => {
								set_attribute(a_1, 'href', get$3(item).url);
								set_class(a_1, clsx(get$3(item).urlCustomClasses), 'svelte-38rpfk');
								set_text(text_3, get$3(item).title);
							});

							append($$anchor, a_1);
						};

						var alternate_1 = ($$anchor) => {
							var text_4 = text();

							template_effect(() => set_text(text_4, get$3(item).title));
							append($$anchor, text_4);
						};

						if_block(node_3, ($$render) => {
							if (get$3(item).url) $$render(consequent_2); else $$render(alternate_1, false);
						});
					}

					reset(span_2);
					template_effect(() => set_class(span_2, `mx-1 tag is-${get$3(item).color ?? ''} ${get$3(item).customClasses ?? ''} svelte-38rpfk`));
					append($$anchor, span_2);
				};

				if_block(node_1, ($$render) => {
					if (Object.hasOwn(get$3(item), "value")) $$render(consequent_1); else $$render(alternate_2, false);
				});
			}

			append($$anchor, fragment_1);
		});

		append($$anchor, fragment);
	}

	var root$a = template(`<td><!></td>`);

	function NotTableCell($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let title = state("");

		onMount(() => {
			if (typeof field().type === "undefined") {
				if (Object.hasOwn(field(), "titlePath")) {
					set(title, proxy(notPath.get(field().titlePath, item(), helpers())));
				} else if (Object.hasOwn(field(), "titleComposer") && typeof field().titleComposer === "function") {
					set(title, proxy(field().titleComposer(item(), helpers())));
				} else {
					set(title, proxy(notPath.get(field().path, item(), helpers())));
				}
			}
		});

		let getItemId = prop($$props, 'getItemId', 3, (item) => item._id),
			field = prop($$props, 'field', 19, () => ({})),
			item = prop($$props, 'item', 19, () => ({})),
			helpers = prop($$props, 'helpers', 19, () => ({}));

		var td = root$a();
		var node = child(td);

		{
			var consequent = ($$anchor) => {
				const expression = derived(() => notPath.get(field().path, item(), helpers()));

				Ui_links($$anchor, {
					get values() {
						return get$3(expression);
					}
				});
			};

			var alternate_7 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						const expression_1 = derived(() => notPath.get(field().path, item(), helpers()));

						Ui_buttons($$anchor, {
							get values() {
								return get$3(expression_1);
							}
						});
					};

					var alternate_6 = ($$anchor) => {
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								const expression_2 = derived(() => notPath.get(field().path, item(), helpers()));

								Ui_images($$anchor, {
									get values() {
										return get$3(expression_2);
									}
								});
							};

							var alternate_5 = ($$anchor) => {
								var fragment_5 = comment();
								var node_3 = first_child(fragment_5);

								{
									var consequent_3 = ($$anchor) => {
										const expression_3 = derived(() => notPath.get(field().path, item(), helpers()));

										Ui_booleans($$anchor, {
											get values() {
												return get$3(expression_3);
											}
										});
									};

									var alternate_4 = ($$anchor) => {
										var fragment_7 = comment();
										var node_4 = first_child(fragment_7);

										{
											var consequent_4 = ($$anchor) => {
												const expression_4 = derived(() => notPath.get(field().path, item(), helpers()));

												Ui_tags($$anchor, {
													get values() {
														return get$3(expression_4);
													}
												});
											};

											var alternate_3 = ($$anchor) => {
												var fragment_9 = comment();
												var node_5 = first_child(fragment_9);

												{
													var consequent_5 = ($$anchor) => {
														const expression_5 = derived(() => getItemId()(item()));
														const expression_6 = derived(() => notPath.get(field().path, item(), helpers()));

														Ui_switch($$anchor, {
															get id() {
																return get$3(expression_5);
															},
															get fieldname() {
																return field().path;
															},
															get value() {
																return get$3(expression_6);
															},
															get disabled() {
																return field().disabled;
															},
															get readonly() {
																return field().readonly;
															},
															$$events: {
																change(...$$args) {
																	field().onChange?.apply(this, $$args);
																}
															}
														});
													};

													var alternate_2 = ($$anchor) => {
														var fragment_11 = comment();
														var node_6 = first_child(fragment_11);

														{
															var consequent_6 = ($$anchor) => {
																var fragment_12 = comment();
																var node_7 = first_child(fragment_12);
																const expression_7 = derived(() => getItemId()(item()));
																const expression_8 = derived(() => notPath.get(field().path, item(), helpers()));

																component(node_7, () => field().component, ($$anchor, $$component) => {
																	$$component($$anchor, spread_props(
																		{
																			get id() {
																				return get$3(expression_7);
																			},
																			get fieldname() {
																				return field().path;
																			},
																			get disabled() {
																				return field().disabled;
																			},
																			get readonly() {
																				return field().readonly;
																			},
																			get value() {
																				return get$3(expression_8);
																			}
																		},
																		() => field().options,
																		{
																			$$events: {
																				change(...$$args) {
																					field().onChange?.apply(this, $$args);
																				}
																			}
																		}
																	));
																});

																append($$anchor, fragment_12);
															};

															var alternate_1 = ($$anchor) => {
																var fragment_13 = comment();
																var node_8 = first_child(fragment_13);

																{
																	var consequent_7 = ($$anchor) => {
																		var text$1 = text();

																		template_effect(($0) => set_text(text$1, $0), [
																			() => notCommon$1.strLengthCap(notPath.get(field().path, item(), helpers()), field().maxLength)
																		]);

																		append($$anchor, text$1);
																	};

																	var alternate = ($$anchor) => {
																		var text_1 = text();

																		template_effect(($0) => set_text(text_1, $0), [
																			() => $LOCALE()[notPath.get(field().path, item(), helpers())]
																		]);

																		append($$anchor, text_1);
																	};

																	if_block(
																		node_8,
																		($$render) => {
																			if (field() && typeof field() !== "undefined" && !isNaN(field().maxLength) && field().maxLength) $$render(consequent_7); else $$render(alternate, false);
																		},
																		true
																	);
																}

																append($$anchor, fragment_13);
															};

															if_block(
																node_6,
																($$render) => {
																	if (field().component) $$render(consequent_6); else $$render(alternate_1, false);
																},
																true
															);
														}

														append($$anchor, fragment_11);
													};

													if_block(
														node_5,
														($$render) => {
															if (field().type === "switch") $$render(consequent_5); else $$render(alternate_2, false);
														},
														true
													);
												}

												append($$anchor, fragment_9);
											};

											if_block(
												node_4,
												($$render) => {
													if (field().type === "tag") $$render(consequent_4); else $$render(alternate_3, false);
												},
												true
											);
										}

										append($$anchor, fragment_7);
									};

									if_block(
										node_3,
										($$render) => {
											if (field().type === "boolean") $$render(consequent_3); else $$render(alternate_4, false);
										},
										true
									);
								}

								append($$anchor, fragment_5);
							};

							if_block(
								node_2,
								($$render) => {
									if (field().type === "image") $$render(consequent_2); else $$render(alternate_5, false);
								},
								true
							);
						}

						append($$anchor, fragment_3);
					};

					if_block(
						node_1,
						($$render) => {
							if (field().type === "button") $$render(consequent_1); else $$render(alternate_6, false);
						},
						true
					);
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if (field().type === "link") $$render(consequent); else $$render(alternate_7, false);
			});
		}

		reset(td);

		template_effect(() => {
			set_class(td, (field().hideOnMobile ? " is-hidden-touch " : "") + (field().classes ? ` ${field().classes} ` : ""));
			set_attribute(td, 'title', get$3(title));
		});

		append($$anchor, td);
		pop();
		$$cleanup();
	}

	function onRowSelect(
		e,
		dispatch,
		itemId,
		$selectedList,
		selectedList
	) {
		e.preventDefault();

		dispatch('rowSelectChange', {
			id: get$3(itemId),
			selected: $selectedList()[get$3(itemId)]
		});

		return false;
	}

	var root_1$8 = template(`<td><input type="checkbox" placeholder=""></td>`);
	var root$9 = template(`<tr><!><!></tr>`);

	function NotTableRow($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $selectedList = () => store_get(selectedList, '$selectedList', $$stores);
		let dispatch = createEventDispatcher();

		let itemId = state(undefined),
			selectedList;

		onMount(() => {
			set(itemId, proxy(getItemId()(item())));
			selectedList = get($$props.id).selected;
		});

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} [item]
		 * @property {any} [helpers]
		 * @property {any} [fields]
		 * @property {boolean} [showSelect]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let item = prop($$props, 'item', 19, () => ({})),
			helpers = prop($$props, 'helpers', 19, () => ({})),
			fields = prop($$props, 'fields', 19, () => []),
			showSelect = prop($$props, 'showSelect', 3, false),
			getItemId = prop($$props, 'getItemId', 3, () => {});

		var tr = root$9();
		var node = child(tr);

		{
			var consequent = ($$anchor) => {
				var td = root_1$8();
				var input = child(td);

				remove_input_defaults(input);

				input.__change = [
					onRowSelect,
					dispatch,
					itemId,
					$selectedList,
					selectedList
				];

				reset(td);

				template_effect(
					($0) => {
						set_attribute(input, 'id', `table-row-select-${$0 ?? ''}`);
						set_attribute(input, 'data-id', $0);
						set_attribute(input, 'name', `row_selected_${$0 ?? ''}`);
					},
					[() => getItemId()(item())]
				);

				bind_checked(input, () => $selectedList()[get$3(itemId)], ($$value) => store_mutate(selectedList, untrack($selectedList)[get$3(itemId)] = $$value, untrack($selectedList)));
				append($$anchor, td);
			};

			if_block(node, ($$render) => {
				if (showSelect() && $selectedList()) $$render(consequent);
			});
		}

		var node_1 = sibling(node);

		each(node_1, 17, fields, index$d, ($$anchor, field) => {
			NotTableCell($$anchor, {
				get field() {
					return get$3(field);
				},
				get helpers() {
					return helpers();
				},
				get item() {
					return item();
				},
				get getItemId() {
					return getItemId();
				}
			});
		});

		reset(tr);
		append($$anchor, tr);
		pop();
		$$cleanup();
	}

	delegate(['change']);

	function onSearchInput(ev, dispatch) {
		try {
			let data = ev.currentTarget.value.trim();

			dispatch("searchChange", data);
		} catch {
			return;
		}
	}

	function goPrev(_, dispatch) {
		dispatch("goToPrevPage");
	}

	function goNext(__1, dispatch) {
		dispatch("goToNextPage");
	}

	function goTo(e, dispatch) {
		e.preventDefault();

		let el = e.target;

		dispatch("goToPage", parseInt(el.dataset.page));
		return false;
	}

	function onSelectAll(__2, $$props, items, getItemId, selectAll) {
		get($$props.id).selected.update((value) => {
			items().forEach((item) => {
				value[getItemId()(item)] = selectAll();
			});

			return value;
		});
	}

	var root_1$7 = template(`<div class="field is-grouped"><!></div>`);
	var root_2$4 = template(`<div class="field is-grouped"><!></div>`);
	var root_5$4 = template(`<div class="field"><div class="control"><input class="input" type="text" placeholder="Поиск"></div></div>`);
	var root_6$4 = template(`<th><input type="checkbox" id="table-row-select-page" placeholder="" name="row_selected_all"></th>`);
	var root_7$2 = template(`<th><!></th>`);
	var root_14$1 = template(`<a href="" class="pagination-link is-current" aria-current="page"> </a>`);
	var root_15$1 = template(`<a href="" class="pagination-link"> </a>`);
	var root_13 = template(`<li><!></li>`);
	var root_11$1 = template(`<nav class="pagination is-centered" aria-label="pagination"><a href="" class="pagination-previous">Назад</a> <a href="" class="pagination-next">Вперед</a> <ul class="pagination-list"><!></ul></nav>`);
	var root$8 = template(`<!> <!> <!> <table class="table"><thead><tr><!><!></tr></thead><tbody></tbody></table> <!>`, 1);

	function NotTable($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} id
		 * @property {any} filterUI
		 * @property {any} [helpers]
		 * @property {any} [state]
		 * @property {any} [filter]
		 * @property {any} [sorter]
		 * @property {any} [fields]
		 * @property {any} [selected]
		 * @property {any} [items]
		 * @property {any} [actions]
		 * @property {any} [links]
		 * @property {string} [search]
		 * @property {boolean} [showSearch]
		 * @property {boolean} [showSelect]
		 * @property {boolean} [selectAll]
		 * @property {any} [getItemId]
		 */
		/** @type {Props} */
		let helpers = prop($$props, 'helpers', 19, () => ({})),
			state = prop($$props, 'state', 31, () => proxy({})),
			filter = prop($$props, 'filter', 31, () => proxy({})),
			sorter = prop($$props, 'sorter', 31, () => proxy({})),
			fields = prop($$props, 'fields', 19, () => []),
			selected = prop($$props, 'selected', 31, () => proxy({})),
			items = prop($$props, 'items', 31, () => proxy([])),
			actions = prop($$props, 'actions', 19, () => []),
			links = prop($$props, 'links', 19, () => []),
			search = prop($$props, 'search', 15, ""),
			showSearch = prop($$props, 'showSearch', 3, true),
			showSelect = prop($$props, 'showSelect', 3, true),
			selectAll = prop($$props, 'selectAll', 15, false),
			getItemId = prop($$props, 'getItemId', 3, (item) => item._id);

		onMount(() => {
			if (showSelect()) {
				get($$props.id).selected.subscribe((value) => {
					selected(value);
				});
			}

			get($$props.id).refined.subscribe((value) => {
				items(value);

				if (showSelect()) {
					for (let itemId in selected()) {
						if (!items().some((item) => getItemId()(item) === itemId)) {
							delete selected()[itemId];
						} else {
							if (!Object.hasOwn(selected(), itemId)) {
								selected(selected()[itemId] = false, true);
							}
						}
					}

					selected(selected());
				}
			});

			get($$props.id).state.subscribe((value) => {
				state(value);
			});
		});

		function onSearchChange({ detail }) {
			try {
				dispatch("searchChange", detail);
			} catch {
				return;
			}
		}

		function onFilterChange({ detail }) {
			try {
				dispatch("filterChange", detail);
			} catch {
				return;
			}
		}

		function onFieldHeadClick(field) {
			const propPath = field.path.substring(1);

			if (Object.hasOwn(sorter(), propPath)) {
				sorter(sorter()[propPath] = parseInt(sorter()[propPath]) * -1, true);
			} else {
				sorter({ [propPath]: 1 });
			}

			dispatch("sorterChange", sorter());
		}

		var fragment = root$8();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_1$7();
				var node_1 = child(div);

				Ui_links(node_1, {
					get values() {
						return links();
					}
				});

				reset(div);
				append($$anchor, div);
			};

			if_block(node, ($$render) => {
				if (links().length) $$render(consequent);
			});
		}

		var node_2 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_1 = root_2$4();
				var node_3 = child(div_1);

				Ui_buttons(node_3, {
					get values() {
						return actions();
					}
				});

				reset(div_1);
				append($$anchor, div_1);
			};

			if_block(node_2, ($$render) => {
				if (actions().length) $$render(consequent_1);
			});
		}

		var node_4 = sibling(node_2, 2);

		{
			var consequent_3 = ($$anchor) => {
				var fragment_1 = comment();
				var node_5 = first_child(fragment_1);

				{
					var consequent_2 = ($$anchor) => {
						var fragment_2 = comment();
						const SvelteComponent = derived(() => $$props.filterUI);
						var node_6 = first_child(fragment_2);

						component(node_6, () => get$3(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, {
								get filter() {
									return filter();
								},
								set filter($$value) {
									filter($$value);
								},
								$$events: {
									change: onFilterChange,
									searchChange: onSearchChange
								}
							});
						});

						append($$anchor, fragment_2);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_5$4();
						var div_3 = child(div_2);
						var input = child(div_3);

						remove_input_defaults(input);
						input.__input = [onSearchInput, dispatch];
						reset(div_3);
						reset(div_2);
						bind_value(input, search);
						append($$anchor, div_2);
					};

					if_block(node_5, ($$render) => {
						if ($$props.filterUI) $$render(consequent_2); else $$render(alternate, false);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node_4, ($$render) => {
				if (showSearch()) $$render(consequent_3);
			});
		}

		var table = sibling(node_4, 2);
		var thead = child(table);
		var tr = child(thead);
		var node_7 = child(tr);

		{
			var consequent_4 = ($$anchor) => {
				var th = root_6$4();
				var input_1 = child(th);

				remove_input_defaults(input_1);

				input_1.__change = [
					onSelectAll,
					$$props,
					items,
					getItemId,
					selectAll
				];

				reset(th);
				bind_checked(input_1, selectAll);
				append($$anchor, th);
			};

			if_block(node_7, ($$render) => {
				if (showSelect()) $$render(consequent_4);
			});
		}

		var node_8 = sibling(node_7);

		each(node_8, 17, fields, index$d, ($$anchor, field) => {
			var th_1 = root_7$2();
			const propPath = derived(() => get$3(field).path.substring(1));
			var event_handler = derived(() => onFieldHeadClick(get$3(field)));

			th_1.__click = function (...$$args) {
				get$3(event_handler)?.apply(this, $$args);
			};

			var node_9 = child(th_1);

			{
				var consequent_5 = ($$anchor) => {
					const expression = derived(() => sorter()[get$3(propPath)] > 0 ? "sort-up" : "sort-down");

					Ui_icon_font($$anchor, {
						get font() {
							return get$3(expression);
						},
						get title() {
							return get$3(field).title;
						},
						pointable: true
					});
				};

				var alternate_1 = ($$anchor) => {
					var text$1 = text();

					template_effect(() => set_text(text$1, $LOCALE()[get$3(field).title]));
					append($$anchor, text$1);
				};

				if_block(node_9, ($$render) => {
					if (get$3(field).sortable && Object.hasOwn(sorter(), get$3(propPath))) $$render(consequent_5); else $$render(alternate_1, false);
				});
			}

			reset(th_1);
			template_effect(() => set_class(th_1, (get$3(field).hideOnMobile ? " is-hidden-touch" : "") + (get$3(field).sortable ? " is-clickable" : "")));
			append($$anchor, th_1);
		});

		reset(tr);
		reset(thead);

		var tbody = sibling(thead);

		each(tbody, 21, items, (item) => item._id, ($$anchor, item) => {
			NotTableRow($$anchor, {
				get id() {
					return $$props.id;
				},
				get item() {
					return get$3(item);
				},
				get fields() {
					return fields();
				},
				get helpers() {
					return helpers();
				},
				get showSelect() {
					return showSelect();
				},
				get getItemId() {
					return getItemId();
				},
				$$events: {
					rowSelectChange($$arg) {
						bubble_event.call(this, $$props, $$arg);
					}
				}
			});
		});

		reset(tbody);
		reset(table);

		var node_10 = sibling(table, 2);

		{
			var consequent_8 = ($$anchor) => {
				var nav = root_11$1();
				var a = child(nav);

				a.__click = [goPrev, dispatch];

				var a_1 = sibling(a, 2);

				a_1.__click = [goNext, dispatch];

				var ul = sibling(a_1, 2);
				var node_11 = child(ul);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_6 = comment();
						var node_12 = first_child(fragment_6);

						each(node_12, 17, () => state().pagination.pages.list, index$d, ($$anchor, page) => {
							var li = root_13();
							var node_13 = child(li);

							{
								var consequent_6 = ($$anchor) => {
									var a_2 = root_14$1();
									var text_1 = child(a_2, true);

									reset(a_2);

									template_effect(() => {
										set_attribute(a_2, 'aria-label', `Страница ${get$3(page).index ?? ''}`);
										set_text(text_1, get$3(page).index + 1);
									});

									append($$anchor, a_2);
								};

								var alternate_2 = ($$anchor) => {
									var a_3 = root_15$1();

									a_3.__click = [goTo, dispatch];

									var text_2 = child(a_3, true);

									reset(a_3);

									template_effect(() => {
										set_attribute(a_3, 'aria-label', `Страница ${get$3(page).index ?? ''}`);
										set_attribute(a_3, 'data-page', get$3(page).index);
										set_text(text_2, get$3(page).index + 1);
									});

									append($$anchor, a_3);
								};

								if_block(node_13, ($$render) => {
									if (get$3(page).active) $$render(consequent_6); else $$render(alternate_2, false);
								});
							}

							reset(li);
							append($$anchor, li);
						});

						append($$anchor, fragment_6);
					};

					if_block(node_11, ($$render) => {
						if (state().pagination && state().pagination.pages && state().pagination.pages.list) $$render(consequent_7);
					});
				}

				reset(ul);
				reset(nav);
				append($$anchor, nav);
			};

			if_block(node_10, ($$render) => {
				if (state()?.pagination?.pages?.list.length > 1) $$render(consequent_8);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['input', 'change', 'click']);

	const CONST_ID_DUBLICATE_POSTFIX = "__dublicate__";
	const OPT_DEFAULT_PAGE_SIZE = 20,
	  OPT_DEFAULT_PAGE_NUMBER = 0,
	  OPT_DEFAULT_PAGE_RANGE = 6,
	  OPT_DEFAULT_SORT_DIRECTION = 1,
	  OPT_DEFAULT_SEARCH = "",
	  OPT_DEFAULT_RETURN = {},
	  OPT_DEFAULT_COMBINED = false,
	  OPT_DEFAULT_COMBINED_ACTION = "listAndCount",
	  OPT_DEFAULT_COUNT_ACTION = "count",
	  OPT_DEFAULT_LIST_ACTION = "list",
	  OPT_DEFAULT_SORT_FIELD = "_id",
	  OPT_FIELD_NAME_PRE_PROC = "preprocessor";
	const DEFAULT_OPTIONS = {
	  ui: NotTable,
	  links: [],
	  actions: [],
	  endless: false,
	  idField: "_id",
	  getItemId: function (item) {
	    return item._id;
	  }
	};
	let notTable = /*#__PURE__*/function (_EventEmitter) {
	  function notTable(input = {}) {
	    var _this;
	    _classCallCheck(this, notTable);
	    _this = _callSuper(this, notTable);
	    _this.id = "table-" + Math.random();
	    _this.options = {
	      ...DEFAULT_OPTIONS,
	      ...(input.options ? input.options : {})
	    };
	    _this.ui = {};
	    _this.data = {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {}
	    };
	    _this.state = {
	      pagination: {
	        items: {
	          count: 0,
	          from: 0,
	          to: 0
	        },
	        pages: {
	          count: 0,
	          from: 0,
	          to: 0,
	          current: 0,
	          list: []
	        }
	      }
	    };
	    _this.working = {};
	    _this.stores = create(_this.id, {
	      raw: [],
	      filtered: [],
	      refined: [],
	      selected: {},
	      state: _this.state,
	      working: _this.working
	    });
	    _this.stores.working.subscribe(_this.onWorkingUpdate.bind(_this));
	    //полученные из сети
	    _this.stores.raw.subscribe(_this.onRawUpdate.bind(_this));
	    //применены фильтры, сортировки и т.д.
	    _this.stores.filtered.subscribe(_this.onFilteredUpdate.bind(_this));
	    //урезаны до минимального набора, точно соотвествующего табличному формату
	    _this.stores.refined.subscribe(_this.onRefinedUpdate.bind(_this));
	    //словарь с идентификаторами выбранных строк
	    _this.stores.selected.subscribe(_this.onSelectedUpdate.bind(_this));
	    //pagination, items information
	    _this.stores.state.subscribe(_this.onStateUpdate.bind(_this));
	    if (notCommon$1.objHas(input, "data") && Array.isArray(input.data)) {
	      _this.stores.raw.update(function (val) {
	        val = input.data;
	        return val;
	      });
	    }
	    _this.setCombinedActionName(_this.getOptions("interface.combinedAction", OPT_DEFAULT_COMBINED_ACTION));
	    if (notCommon$1.objHas(_this.options, "filter")) {
	      _this.setFilter(_this.options.filter, true);
	    } else {
	      _this.resetFilter();
	    }
	    if (notCommon$1.objHas(_this.options, "pager")) {
	      _this.setPager(_this.options.pager, true);
	    } else {
	      _this.resetPager();
	    }
	    if (notCommon$1.objHas(_this.options, "sorter")) {
	      _this.setSorter(_this.options.sorter, true);
	    } else {
	      _this.resetSorter(true);
	    }
	    if (notCommon$1.objHas(_this.options, "return")) {
	      _this.setReturn(_this.options.return);
	    } else {
	      _this.setReturn();
	    }
	    if (notCommon$1.objHas(_this.options, "search")) {
	      _this.setSearch(_this.options.search, true);
	    } else {
	      _this.setSearch();
	    }
	    _this.render();
	    _this.updateData();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notTable, _EventEmitter);
	  return _createClass(notTable, [{
	    key: "onWorkingUpdate",
	    value: function onWorkingUpdate(val) {
	      this.working = val;
	      return val;
	    }
	  }, {
	    key: "onRawUpdate",
	    value: function onRawUpdate(val) {
	      this.data.raw = val;
	      return val;
	    }
	  }, {
	    key: "onFilteredUpdate",
	    value: function onFilteredUpdate(val) {
	      this.data.filtered = val;
	      this.refineFiltered();
	      return val;
	    }
	  }, {
	    key: "onRefinedUpdate",
	    value: function onRefinedUpdate(val) {
	      this.data.refined = val;
	      this.clearSelected();
	      return val;
	    }
	  }, {
	    key: "onStateUpdate",
	    value: function onStateUpdate(val) {
	      this.state = val;
	      return val;
	    }
	  }, {
	    key: "onSearchChange",
	    value: function onSearchChange(line) {
	      if (line.length > 3) {
	        this.setSearch(line);
	      } else {
	        this.setSearch();
	      }
	    }
	  }, {
	    key: "onSorterChange",
	    value: function onSorterChange(sorter) {
	      if (sorter) {
	        this.setSorter(sorter);
	      } else {
	        this.resetSorter();
	      }
	    }
	  }, {
	    key: "onFilterChange",
	    value: function onFilterChange({
	      filter,
	      actionName
	    }) {
	      if (actionName.indexOf(OPT_DEFAULT_COMBINED_ACTION) === 0) {
	        this.setCombinedActionName(actionName);
	      }
	      if (filter) {
	        this.setFilter(filter);
	      } else {
	        this.resetFilter();
	      }
	    }
	  }, {
	    key: "onSelectedUpdate",
	    value: function onSelectedUpdate(val) {
	      this.data.selected = val;
	    }
	  }, {
	    key: "clearSelected",
	    value: function clearSelected() {
	      this.data.selected = {};
	    }
	  }, {
	    key: "getSelected",
	    value: function getSelected(object = false, store = "refined") {
	      let res = [];
	      for (let id in this.data.selected) {
	        if (this.data.selected[id]) {
	          if (object) {
	            let indx = this.data[store].findIndex(function (item) {
	              return item._id === id;
	            });
	            if (indx > -1) {
	              res.push(this.data[store][indx]);
	            }
	          } else {
	            res.push(id);
	          }
	        }
	      }
	      return res;
	    }
	  }, {
	    key: "getItemId",
	    value: function getItemId(item) {
	      return this.getOptions("getItemId", DEFAULT_OPTIONS.getItemId)(item);
	    }
	  }, {
	    key: "selectAll",
	    value: function selectAll() {
	      var _this2 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this2.data.filtered.forEach(function (item) {
	          value[_this2.getItemId(item)] = true;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "selectNone",
	    value: function selectNone() {
	      var _this3 = this;
	      this.stores.selected.update(function () {
	        let value = {};
	        _this3.data.filtered.forEach(function (item) {
	          value[_this3.getItemId(item)] = false;
	        });
	        return value;
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;
	      if (!this.ui.table) {
	        this.ui.table = new this.options.ui({
	          target: this.options.targetEl,
	          props: {
	            filterUI: this.getOptions("filterUI", undefined),
	            id: this.id,
	            helpers: Object.assign({}, this.getHelpers()),
	            fields: this.getOptions("fields"),
	            actions: this.getActions(),
	            links: this.getLinks(),
	            search: "",
	            showSelect: this.getOptions("showSelect"),
	            showSearch: this.getOptions("showSearch"),
	            showSort: this.getOptions("showSort"),
	            idField: this.getOptions("idField"),
	            getItemId: this.getOptions("getItemId"),
	            filter: this.getFilter()
	          }
	        });
	      }
	      this.ui.table.$on("searchChange", function (e) {
	        return _this4.onSearchChange(e.detail);
	      });
	      this.ui.table.$on("sorterChange", function (e) {
	        return _this4.onSorterChange(e.detail);
	      });
	      this.ui.table.$on("filterChange", function (e) {
	        return _this4.onFilterChange(e.detail);
	      });
	      this.ui.table.$on("goToPage", function (e) {
	        return _this4.goToPage(e.detail);
	      });
	      this.ui.table.$on("goToNextPage", function () {
	        return _this4.goToNext();
	      });
	      this.ui.table.$on("goToPrevPage", function () {
	        return _this4.goToPrev();
	      });
	    }
	  }, {
	    key: "getActions",
	    value: function getActions() {
	      return this.getOptions("actions", []);
	    }
	  }, {
	    key: "getLinks",
	    value: function getLinks() {
	      return this.getOptions("links", []);
	    }
	  }, {
	    key: "getHelpers",
	    value: function getHelpers() {
	      return this.options.helpers || {};
	    }
	  }, {
	    key: "setWorking",
	    value: function setWorking(key, value) {
	      var _this5 = this;
	      this.stores.working.update(function (val) {
	        notPath.set(key, val, _this5.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getWorking",
	    value: function getWorking(key, def) {
	      let res = notPath.get(key, this.working, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setState",
	    value: function setState(key, value) {
	      var _this6 = this;
	      this.stores.state.update(function (val) {
	        notPath.set(key, val, _this6.getHelpers(), value);
	        return val;
	      });
	      return this;
	    }
	  }, {
	    key: "getState",
	    value: function getState(key, def) {
	      let res = notPath.get(key, this.state, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(key, value) {
	      notPath.set(key, this.options, this.getHelpers(), value);
	      return this;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions(key, def) {
	      let res = notPath.get(key, this.options, this.getHelpers());
	      if (res === undefined) {
	        return def;
	      } else {
	        return res;
	      }
	    }
	  }, {
	    key: "setFilter",
	    value: function setFilter(hash, withoutInvalidation = false) {
	      this.setState("filter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetFilter",
	    value: function resetFilter() {
	      this.setState("filter", {});
	      return this;
	    }
	  }, {
	    key: "getFilter",
	    value: function getFilter() {
	      return this.getState("filter");
	    }
	  }, {
	    key: "setPager",
	    value: function setPager(hash, withoutInvalidation = false) {
	      this.setState("pager", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getDefaultPageNumber",
	    value: function getDefaultPageNumber() {
	      return isNaN(this.getOptions("pager.page")) ? OPT_DEFAULT_PAGE_NUMBER : this.getOptions("pager.page");
	    }
	  }, {
	    key: "getDefaultPageSize",
	    value: function getDefaultPageSize() {
	      return isNaN(this.getOptions("pager.size")) ? OPT_DEFAULT_PAGE_SIZE : this.getOptions("pager.size");
	    }
	  }, {
	    key: "resetPager",
	    value: function resetPager() {
	      this.setState("pager", {
	        size: this.getDefaultPageSize(),
	        page: this.getDefaultPageNumber()
	      });
	    }
	  }, {
	    key: "getPager",
	    value: function getPager() {
	      return this.getState("pager");
	    }
	  }, {
	    key: "setSorter",
	    value: function setSorter(hash, withoutInvalidation = false) {
	      this.setWorking("sorter", hash);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "resetSorter",
	    value: function resetSorter(withoutInvalidation = false) {
	      let t = {};
	      t[OPT_DEFAULT_SORT_FIELD] = OPT_DEFAULT_SORT_DIRECTION;
	      return this.setSorter(t, withoutInvalidation);
	    }
	  }, {
	    key: "getSorter",
	    value: function getSorter() {
	      return this.getWorking("sorter");
	    }
	  }, {
	    key: "getSorterDirection",
	    value: function getSorterDirection() {
	      try {
	        let names = Object.keys(this.getSorter());
	        return this.getSorter()[names[0]];
	      } catch {
	        return OPT_DEFAULT_SORT_DIRECTION;
	      }
	    }
	  }, {
	    key: "getSearch",
	    value: function getSearch() {
	      let search = typeof this.getWorking("search") !== "undefined" && this.getWorking("search") !== null;
	      return search ? this.getWorking("search") : "";
	    }
	  }, {
	    key: "setSearch",
	    value: function setSearch(line = OPT_DEFAULT_SEARCH, withoutInvalidation = false) {
	      this.setWorking("search", line);
	      if (withoutInvalidation) {
	        return this;
	      }
	      this.invalidateData();
	      this.updateData();
	      return this;
	    }
	  }, {
	    key: "getReturn",
	    value: function getReturn() {
	      return this.getWorking("return");
	    }
	  }, {
	    key: "setReturn",
	    value: function setReturn(ret = OPT_DEFAULT_RETURN) {
	      this.setWorking("return", ret);
	      return this;
	    }
	  }, {
	    key: "clearFilteredData",
	    value: function clearFilteredData() {
	      this.stores.filtered.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRawData",
	    value: function clearRawData() {
	      this.stores.raw.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "clearRefinedData",
	    value: function clearRefinedData() {
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length);
	        return val;
	      });
	    }
	  }, {
	    key: "invalidateData",
	    value: function invalidateData() {
	      //clearing filtered and sorted
	      this.clearFilteredData();
	      //in case live loading from server
	      if (this.isLive()) {
	        //clearing loaded data
	        this.clearRawData();
	      }
	      //resset pager anyway
	      this.resetPager();
	    }
	  }, {
	    key: "isLive",
	    value: function isLive() {
	      return this.getOptions("interface") && this.getOptions("interface.factory");
	    }
	  }, {
	    key: "setUpdating",
	    value: function setUpdating() {
	      this.setState("updating", true);
	    }
	  }, {
	    key: "setUpdated",
	    value: function setUpdated() {
	      this.setState("updating", false);
	    }
	  }, {
	    key: "ifUpdating",
	    value: function ifUpdating() {
	      return this.getState("updating");
	    }
	  }, {
	    key: "getDataInterface",
	    value: function getDataInterface() {
	      let factory = this.getOptions("interface.factory");
	      if (typeof factory === "function") {
	        return factory({});
	      } else {
	        return factory;
	      }
	    }
	  }, {
	    key: "getLoadDataActionName",
	    value: function getLoadDataActionName() {
	      return this.getOptions("interface.listAction") ? this.getOptions("interface.listAction") : OPT_DEFAULT_LIST_ACTION;
	    }
	  }, {
	    key: "setCombinedActionName",
	    value: function setCombinedActionName(actionName = OPT_DEFAULT_COUNT_ACTION) {
	      this.setWorking("interface.combinedAction", actionName);
	    }
	  }, {
	    key: "getCombinedActionName",
	    value: function getCombinedActionName() {
	      return this.getWorking("interface.combinedAction") ? this.getWorking("interface.combinedAction") : OPT_DEFAULT_COMBINED_ACTION;
	    }
	  }, {
	    key: "getCountActionName",
	    value: function getCountActionName() {
	      return this.getOptions("interface.countAction") ? this.getOptions("interface.countAction") : OPT_DEFAULT_COUNT_ACTION;
	    }
	  }, {
	    key: "loadData",
	    value: function loadData() {
	      //load from server
	      let query = this.getDataInterface().setFilter(this.getFilter()).setSorter(this.getSorter()).setReturn(this.getReturn()).setSearch(this.getSearch()).setPager(this.getPager()),
	        actionName;
	      if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	        actionName = this.getCombinedActionName();
	      } else {
	        actionName = this.getLoadDataActionName();
	      }
	      return query["$" + actionName]();
	    }
	  }, {
	    key: "goToNext",
	    value: function goToNext() {
	      let next = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") + 1;
	      this.setState("pager.page", Math.min(next, this.getState("pagination.pages.to")));
	      this.updateData();
	    }
	  }, {
	    key: "goToPrev",
	    value: function goToPrev() {
	      let prev = isNaN(this.getState("pager.page")) ? this.getDefaultPageNumber() : this.getState("pager.page") - 1;
	      this.setState("pager.page", Math.max(prev, this.getState("pagination.pages.from")));
	      this.updateData();
	    }
	  }, {
	    key: "goToFirst",
	    value: function goToFirst() {
	      this.setState("pager.page", this.getState("pagination.pages.from"));
	      this.updateData();
	    }
	  }, {
	    key: "goToLast",
	    value: function goToLast() {
	      this.setState("pager.page", this.getState("pagination.pages.to"));
	      this.updateData();
	    }
	  }, {
	    key: "goToPage",
	    value: function goToPage(pageNumber) {
	      this.setState("pager.page", pageNumber);
	      this.updateData();
	    }
	  }, {
	    key: "testDataItem",
	    value: function testDataItem(item) {
	      var strValue = this.getSearch().toLowerCase();
	      for (var k in item) {
	        var toComp = item[k].toString().toLowerCase();
	        if (toComp.indexOf(strValue) > -1) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: "getRowsCount",
	    value: function getRowsCount() {
	      var _this7 = this;
	      let query = this.getDataInterface().setFilter(this.getFilter());
	      return query["$" + this.getCountActionName()]().then(function (data) {
	        _this7.updatePagination(data.count);
	      }).catch(function (e) {
	        _this7.error(e);
	      });
	    }
	  }, {
	    key: "updatePagination",
	    value: function updatePagination(itemsCount) {
	      var _this8 = this;
	      this.log("update pagination", itemsCount);
	      this.state.pagination.pages.list.splice(0, this.state.pagination.pages.list.length);
	      let itemsFrom = (this.getPager().page - OPT_DEFAULT_PAGE_NUMBER) * this.getPager().size + 1,
	        pagesCount = itemsCount % this.getPager().size ? Math.floor(itemsCount / this.getPager().size) + 1 : Math.round(itemsCount / this.getPager().size),
	        pagesFrom = Math.max(OPT_DEFAULT_PAGE_NUMBER, this.getPager().page - OPT_DEFAULT_PAGE_RANGE),
	        pagesTo = Math.min(pagesCount - (1 - OPT_DEFAULT_PAGE_NUMBER), this.getPager().page + OPT_DEFAULT_PAGE_RANGE),
	        list = [],
	        itemsTo = Math.min(itemsFrom + this.getPager().size - 1, itemsCount);
	      for (let t = pagesFrom; t <= pagesTo; t++) {
	        list.push({
	          index: t,
	          active: t === this.getPager().page
	        });
	      }
	      this.stores.state.update(function (val) {
	        _this8.log("update pagination", val);
	        val.pagination.items.count = itemsCount;
	        val.pagination.items.from = itemsFrom;
	        val.pagination.items.to = itemsTo;
	        val.pagination.pages.count = pagesCount;
	        val.pagination.pages.from = pagesFrom;
	        val.pagination.pages.to = pagesTo;
	        val.pagination.pages.current = _this8.getPager().page;
	        val.pagination.pages.list.splice(0, val.pagination.pages.list.length, ...list);
	        return val;
	      });
	    }
	  }, {
	    key: "updateData",
	    value: function updateData() {
	      var _this9 = this;
	      if (this.isLive()) {
	        if (this.ifUpdating()) {
	          return;
	        }
	        if (!this.getOptions("endless", false)) {
	          this.clearRawData();
	        }
	        this.setUpdating();
	        if (this.getOptions("interface.combined", OPT_DEFAULT_COMBINED)) {
	          this.loadData().then(function (data) {
	            let full = notCommon$1.objHas(data, "status") && notCommon$1.objHas(data, "result");
	            _this9.stores.filtered.update(function (val) {
	              if (!_this9.getOptions("endless", false)) {
	                _this9.clearFilteredData();
	              }
	              if (full) {
	                val.push(...data.result.list);
	              } else {
	                if (notCommon$1.objHas(data, "list") && Array.isArray(data.list)) {
	                  val.push(...data.list);
	                } else if (Array.isArray(data)) {
	                  val.push(...data);
	                }
	              }
	              return val;
	            });
	            _this9.setWorking("lastCount", full ? data.result.count : data.count);
	          }).then(function () {
	            _this9.updatePagination(_this9.getWorking("lastCount"));
	          }).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        } else {
	          this.loadData().then(function (data) {
	            _this9.stores.filtered.update(function (val) {
	              val.push(...data);
	              return val;
	            });
	          }).then(this.getRowsCount.bind(this)).catch(this.error.bind(this)).then(this.setUpdated.bind(this));
	        }
	      } else {
	        //local magic
	        this.setUpdating();
	        this.processData();
	        this.setUpdated();
	      }
	    }
	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.data;
	    }
	  }, {
	    key: "processData",
	    value: function processData() {
	      var _this10 = this;
	      let thatFilter = this.getFilter();
	      //this.getData('rows').__setPassive;
	      this.log(this.getData());
	      if (typeof thatFilter !== "undefined" && thatFilter !== null && typeof thatFilter.filterSearch !== "undefined" && thatFilter.filterSearch !== null && thatFilter.filterSearch.length > 0) {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this10.data.raw.filter(_this10.testDataItem.bind(_this10)));
	          return val;
	        });
	      } else {
	        this.stores.filtered.update(function (val) {
	          val.splice(0, val.length, ..._this10.data.raw);
	          return val;
	        });
	      }
	      ////sorter
	      let thatSorter = this.getSorter();
	      if (typeof thatSorter !== "undefined" && thatSorter !== null) {
	        this.stores.filtered.update(function (val) {
	          val.sort(function (item1, item2) {
	            let t1 = notPath.get(thatSorter.sortByField, item1, {}),
	              t2 = notPath.get(thatSorter.sortByField, item2, {});
	            if (isNaN(t1)) {
	              if (typeof t1 !== "undefined" && typeof t2 !== "undefined" && t1.localeCompare) {
	                return t1.localeCompare() * -thatSorter.sortDirection;
	              } else {
	                return 0;
	              }
	            } else {
	              return (t1 < t2 ? 1 : -1) * thatSorter.sortDirection;
	            }
	          });
	          return val;
	        });
	      }
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      if (this.options.logger) {
	        this.options.logger.error(...arguments);
	      }
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      if (this.options.logger) {
	        this.options.logger.log(...arguments);
	      }
	    }
	  }, {
	    key: "checkFieldsNames",
	    value: function checkFieldsNames() {
	      const fieldId = this.getOptions("idField");
	      const pathId = ":" + fieldId;
	      let fields = this.getOptions("fields", []);
	      fields.forEach(function (field) {
	        if (pathId === field.path) {
	          field.path = field.path + CONST_ID_DUBLICATE_POSTFIX;
	        }
	      });
	    }
	  }, {
	    key: "readFieldValue",
	    value: function readFieldValue(path, item, helpers) {
	      if (path.indexOf(CONST_ID_DUBLICATE_POSTFIX) > -1) {
	        const fieldId = this.getOptions("idField");
	        const pathId = ":" + fieldId;
	        return notPath.get(pathId, item, helpers);
	      } else {
	        return notPath.get(path, item, helpers);
	      }
	    }
	  }, {
	    key: "refineFiltered",
	    value: function refineFiltered() {
	      var _this11 = this;
	      let result = [];
	      this.checkFieldsNames();
	      this.data.filtered.forEach(function (item, index) {
	        let refined = {};
	        if (_this11.getOptions("idField")) {
	          refined[_this11.getOptions("idField")] = item[_this11.getOptions("idField")];
	        }
	        _this11.getOptions("fields", []).forEach(function (field) {
	          let preprocessed = null,
	            val = _this11.readFieldValue(field.path, item, _this11.getOptions("helpers"));
	          if (notCommon$1.objHas(field, OPT_FIELD_NAME_PRE_PROC)) {
	            try {
	              preprocessed = field[OPT_FIELD_NAME_PRE_PROC](val, item, index);
	            } catch (e) {
	              _this11.error("Error while preprocessing cell value", val, item, index);
	              _this11.error(e);
	            }
	            notPath.set(field.path, refined, preprocessed);
	          } else {
	            notPath.set(field.path, refined, val);
	          }
	        });
	        result.push(refined);
	      });
	      this.stores.refined.update(function (val) {
	        val.splice(0, val.length, ...result);
	        return val;
	      });
	    }
	  }, {
	    key: "$destroy",
	    value: function $destroy() {
	      for (let name in this.ui) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        delete this.ui[name];
	      }
	    }
	  }]);
	}(EventEmitter);

	var root_1$6 = template(`<!> <!>`, 1);
	var root$7 = template(`<!> <!>`, 1);

	function Ui_action_container($$anchor, $$props) {
		push($$props, true);

		//hidden - no loader
		//container - parent container of form
		let success = state(false);
		let error = state(false);

		/**
		 * @typedef {Object} Props
		 * @property {any} [container]
		 * @property {string} [loaderTitle]
		 * @property {boolean} [loaderActive] - state if form loading
		 * @property {string} [loaderSize] - page - whole page
		 * @property {string} [successTitle]
		 * @property {string} [successMessage]
		 * @property {string} [errorTitle]
		 * @property {string} [errorMessage]
		 */
		/** @type {Props} */
		let container = prop($$props, 'container', 19, () => ({})),
			loaderTitle = prop($$props, 'loaderTitle', 15, "Отправка данных на сервер"),
			loaderActive = prop($$props, 'loaderActive', 15, false),
			loaderSize = prop($$props, 'loaderSize', 15, "container"),
			successTitle = prop($$props, 'successTitle', 15, "OK"),
			successMessage = prop($$props, 'successMessage', 15, ""),
			errorTitle = prop($$props, 'errorTitle', 15, "Error"),
			errorMessage = prop($$props, 'errorMessage', 15, "");

		function showSuccess(title, message) {
			set(error, false);
			set(success, true);

			if (message != undefined) {
				successMessage(message);
			}

			if (title != undefined) {
				successTitle(title);
			}
		}

		function showError(title, message) {
			set(success, false);
			set(error, true);

			if (message != undefined) {
				errorMessage(message);
			}

			if (title != undefined) {
				errorTitle(title);
			}
		}

		function setLoading() {
			loaderActive(true);
			set(success, false);
			set(error, false);
		}

		function resetLoading() {
			loaderActive(false);
		}

		function hideAll() {
			loaderActive(false);
			set(success, false);
			set(error, false);
		}

		var fragment = root$7();
		var node = first_child(fragment);

		Ui_loader(node, {
			get loading() {
				return loaderActive();
			},
			set loading($$value) {
				loaderActive($$value);
			},
			get title() {
				return loaderTitle();
			},
			set title($$value) {
				loaderTitle($$value);
			},
			get size() {
				return loaderSize();
			},
			set size($$value) {
				loaderSize($$value);
			}
		});

		var node_1 = sibling(node, 2);

		Ui_container(node_1, spread_props(container, {
			children: ($$anchor, $$slotProps) => {
				var fragment_1 = root_1$6();
				var node_2 = first_child(fragment_1);

				{
					var consequent = ($$anchor) => {
						Ui_error($$anchor, {
							get title() {
								return errorTitle();
							},
							set title($$value) {
								errorTitle($$value);
							},
							get message() {
								return errorMessage();
							},
							set message($$value) {
								errorMessage($$value);
							}
						});
					};

					if_block(node_2, ($$render) => {
						if (get$3(error)) $$render(consequent);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_success($$anchor, {
							get title() {
								return successTitle();
							},
							set title($$value) {
								successTitle($$value);
							},
							get message() {
								return successMessage();
							},
							set message($$value) {
								successMessage($$value);
							}
						});
					};

					if_block(node_3, ($$render) => {
						if (get$3(success)) $$render(consequent_1);
					});
				}

				append($$anchor, fragment_1);
			},
			$$slots: { default: true }
		}));

		append($$anchor, fragment);

		return pop({
			showSuccess,
			showError,
			setLoading,
			resetLoading,
			hideAll
		});
	}

	const DEFAULT_CONTAINER_SELECTOR$2 = ".container";
	var _uiComponent$1 = /*#__PURE__*/new WeakMap();
	var _ui = /*#__PURE__*/new WeakMap();
	let notActionUI = /*#__PURE__*/function (_notBase) {
	  function notActionUI({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data = {},
	    ui = Ui_action_container //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notActionUI);
	    _this = _callSuper(this, notActionUI, [{
	      working: {
	        name: `${name}ActionUI`,
	        ...working
	      },
	      options,
	      data
	    }]);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent$1, null);
	    _classPrivateFieldInitSpec(_this, _ui, null);
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent$1, _this, ui);
	    _this.initUI();
	    return _this;
	  }
	  _inherits(notActionUI, _notBase);
	  return _createClass(notActionUI, [{
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const target = this.getTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_ui, this, new (_classPrivateFieldGet2(_uiComponent$1, this))({
	          target,
	          props: this.getOptions()
	        }));
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_ui, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_ui, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_ui, this)) {
	        _classPrivateFieldGet2(_ui, this).$destroy && _classPrivateFieldGet2(_ui, this).$destroy();
	        _classPrivateFieldGet2(_ui, this).destroy && _classPrivateFieldGet2(_ui, this).destroy();
	        _classPrivateFieldSet2(_ui, this, null);
	      }
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_ui, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_ui, this).showError(status);
	      this.emit("error", status);
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getTargetEl",
	    value: function getTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$2);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("ActionUI parent element is not defined");
	      }
	    }
	  }]);
	}(notBase);

	let notFormUtils$1 = /*#__PURE__*/function () {
	  function notFormUtils() {
	    _classCallCheck(this, notFormUtils);
	  }
	  return _createClass(notFormUtils, null, [{
	    key: "addComponent",
	    value: function addComponent(name, value) {
	      COMPONENTS$1.add(name, value);
	    }
	  }, {
	    key: "addVariants",
	    value: function addVariants(name, value) {
	      VARIANTS$1.add(name, value);
	    }
	  }, {
	    key: "addField",
	    value: function addField(name, field) {
	      FIELDS$1.add(name, field);
	    }
	  }, {
	    key: "actionFieldsInit",
	    value: function actionFieldsInit(fieldName, options, data) {
	      var _this = this;
	      if (Array.isArray(fieldName)) {
	        fieldName.forEach(function (subFieldName) {
	          _this.actionFieldsInit(subFieldName, options, data);
	        });
	      } else {
	        if (!notCommon$1.objHas(options, "fields")) {
	          options.fields = {};
	        }
	        if (!notCommon$1.objHas(options.fields, fieldName)) {
	          options.fields[fieldName] = {};
	        }
	        //copying initial data
	        if (typeof data !== "undefined" && data !== null && typeof data[fieldName] !== "undefined" && data[fieldName] !== null) {
	          options.fields[fieldName].value = data[fieldName];
	        }
	      }
	    }
	  }]);
	}();
	_defineProperty(notFormUtils$1, "validator", null);

	const DEFAULT_FIELD = {
	  label: "",
	  placeholder: "",
	  enabled: true,
	  visible: true,
	  required: true,
	  validated: false,
	  valid: false,
	  errors: false
	};

	/**
	 * Creates field manifest
	 * @param {string} type      name/type of the field
	 * @param {Object} mutation  mutation to manifest from library
	 * @param {Object} VARIANTS  store which contains named lists of field value variants
	 * @param {Object} FIELDS    store which contains named lists of field manifests
	 * @return {Object}          field manifest
	 **/
	function fieldInit(type, mutation = {}, VARIANTS, FIELDS) {
	  let field = {
	    ...DEFAULT_FIELD
	  };
	  //getting field core manifest
	  if (FIELDS.contains(type)) {
	    field = {
	      ...field,
	      ...FIELDS.get(type)
	    };
	  }
	  //adding mutations
	  if (mutation) {
	    field = {
	      ...field,
	      ...mutation
	    };
	  }
	  //adding variants list to field from VARIANTS store
	  if (notCommon$1.objHas(field, "variantsSource") && VARIANTS.contains(field.variantsSource)) {
	    field.variants = VARIANTS.get(field.variantsSource);
	  } else {
	    if (!field.variants || field.variants.length === 0) {
	      field.variants = [];
	    }
	  }
	  return field;
	}

	/**
	 * Initialization of form structure object
	 * @param {object}               form          form structure object
	 * @param {string|Array<string>} fieldName     name of the field type if string, array of strings = subform
	 * @param {Object}               VARIANTS      store which contains named lists of field value variants
	 * @param {Object}               FIELDS        store which contains named lists of field manifests
	 * @param {Object}               formFieldsOptions   form wide options
	 * @returns {Object}                           form structure object
	 **/
	function initFormByField(form = {}, fieldName = [], VARIANTS, FIELDS, formFieldsOptions, data) {
	  if (Array.isArray(fieldName)) {
	    fieldName.forEach(function (subFormFieldName) {
	      return initFormByField(form, subFormFieldName, VARIANTS, FIELDS, formFieldsOptions, data);
	    });
	  } else {
	    let opts = {};
	    if (formFieldsOptions && notCommon$1.objHas(formFieldsOptions, "mutations") && notCommon$1.objHas(formFieldsOptions.mutations, fieldName)) {
	      opts = formFieldsOptions.mutations[fieldName]; //option mutation for field
	    }
	    if (data && notCommon$1.objHas(data, fieldName)) {
	      opts.value = data[fieldName];
	    }
	    form[fieldName] = fieldInit(fieldName, opts, VARIANTS, FIELDS);
	    //if form readonly, marking every field as readonly
	    if (formFieldsOptions && formFieldsOptions.readonly) {
	      form[fieldName].readonly = true;
	    }
	  }
	  return form;
	}

	/**
	 *  Marking field as invalid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFieldInvalid(form, fieldName, value, errors) {
	  form[fieldName].errors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].valid = false;
	  form[fieldName].value = value;
	  return form;
	}

	/**
	 *  Marking field as valid by own validator
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param {any}              value         value of field
	 * @return {Object}                        form structure object
	 **/
	function setFieldValid(form, fieldName, value) {
	  form[fieldName].errors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].value = value;
	  for (let fname in form) {
	    if (fname !== fieldName) {
	      if (Array.isArray(form[fname].errors) && form[fname].errors.length === 0) {
	        form[fname].errors = false;
	      }
	      if (form[fname].errors !== false) {
	        break;
	      }
	    }
	  }
	  return form;
	}

	/**
	 * Checks if field has errors
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @returns {boolean}                      true - valid, false -invalid
	 **/
	function isFieldValid(form, fieldName) {
	  return !Array.isArray(form[fieldName].errors);
	}

	/**
	 * Form level validator error in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @param  {Array<string>}   errors        list of errors
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldInvalid(form, fieldName, errors) {
	  form[fieldName].formErrors = [...errors];
	  form[fieldName].validated = true;
	  form[fieldName].inputStarted = true;
	  form[fieldName].valid = false;
	  form[fieldName].formLevelError = true;
	  return form;
	}
	/**
	 * Form level validator success in this field
	 * @param {Object}           form          form structure object
	 * @param {string}           fieldName     name of the field
	 * @return {Object}                        form structure object
	 **/
	function setFormFieldValid(form, fieldName) {
	  form[fieldName].formErrors = false;
	  form[fieldName].validated = true;
	  form[fieldName].valid = true;
	  form[fieldName].formLevelError = false;
	  return form;
	}

	/**
	 * Updates fields and form error labels
	 * @param {Object}           form                  form structure object
	 * @param {Object}           validationStatus      results of validation
	 **/
	function updateFormValidationStatus({
	  form,
	  formErrors,
	  validationStatus
	} /* FormValidationSession.getCompleteResult() */) {
	  if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
	    formErrors.splice(0, formErrors.length, ...validationStatus.form);
	  } else {
	    formErrors.splice(0, formErrors.length);
	  }
	  if (validationStatus.fields) {
	    for (let fieldName in validationStatus.fields) {
	      if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
	        setFormFieldInvalid(form, fieldName, validationStatus.fields[fieldName]);
	      } else {
	        setFormFieldValid(form, fieldName);
	      }
	    }
	  }
	}
	function setFieldsVisibility(form, fieldsList, val) {
	  if (Array.isArray(fieldsList)) {
	    Object.keys(form).forEach(function (fieldName) {
	      form[fieldName].visible = fieldsList.includes(fieldName) ? val : !val;
	    });
	    return true;
	  }
	  return false;
	}
	function setFieldValue(form, fieldName, value) {
	  if (notCommon$1.objHas(form, fieldName)) {
	    form[fieldName].value = value;
	    return true;
	  }
	  return false;
	}
	function fieldIsVisibleAndFilled(form, fieldName) {
	  return notCommon$1.objHas(form, fieldName) && form[fieldName].enabled && form[fieldName].visible && typeof form[fieldName].value !== "undefined";
	}
	function collectData(fields, form) {
	  let result = {};
	  fields.flat().forEach(function (fieldName) {
	    if (fieldIsVisibleAndFilled(form, fieldName)) {
	      result[fieldName] = form[fieldName].value;
	    }
	  });
	  return result;
	}
	var FormHelpers = {
	  fieldInit,
	  initFormByField,
	  setFieldInvalid,
	  setFieldValid,
	  isFieldValid,
	  setFormFieldInvalid,
	  setFormFieldValid,
	  updateFormValidationStatus,
	  fieldIsVisibleAndFilled,
	  setFieldsVisibility,
	  setFieldValue,
	  collectData
	};

	var result;
	var hasRequiredResult;

	function requireResult () {
		if (hasRequiredResult) return result;
		hasRequiredResult = 1;
		const emptyFieldsResults = (data) => {
		    return Object.keys(data).reduce((acc, curr) => {
		        acc[curr] = [];
		        return acc;
		    }, {});
		};

		const FIELDS = ["fields", "form"];

		result = class ValidationResult {
		    #clean = true;
		    #result;

		    constructor(result) {
		        this.#result = JSON.parse(JSON.stringify(result));
		        Object.keys(this.#result).forEach((fieldName) => {
		            if (!FIELDS.includes(fieldName)) {
		                delete this.#result[fieldName];
		            }
		        });
		        this.#clean = this.#result.form.errors.length === 0;
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            if (this.isFieldDirty(fieldName)) {
		                this.#clean = false;
		            }
		        }
		    }

		    destroy() {
		        this.#result = undefined;
		    }

		    get clean() {
		        return this.#clean;
		    }

		    static getDefaultResult(data) {
		        return {
		            fields: emptyFieldsResults(data),
		            form: {
		                fields: emptyFieldsResults(data),
		                errors: [],
		                exceptions: [],
		            },
		        };
		    }

		    getReport() {
		        return JSON.parse(JSON.stringify(this.#getCompleteResult()));
		    }

		    getDetailedReport() {
		        if (typeof this.#result === "object") {
		            return JSON.parse(JSON.stringify(this.#result));
		        } else {
		            return undefined;
		        }
		    }

		    isFieldDirty(fieldName) {
		        if (
		            Array.isArray(this.#result.fields[fieldName]) &&
		            this.#result.fields[fieldName].length
		        ) {
		            return true;
		        }
		        if (
		            Array.isArray(this.#result.form.fields[fieldName]) &&
		            this.#result.form.fields[fieldName].length
		        ) {
		            return true;
		        }
		        return false;
		    }

		    getCompleteResultForField(fieldName) {
		        const fieldResult = [];
		        if (Array.isArray(this.#result.fields[fieldName])) {
		            fieldResult.push(...this.#result.fields[fieldName]);
		        }
		        if (Array.isArray(this.#result.form.fields[fieldName])) {
		            fieldResult.push(...this.#result.form.fields[fieldName]);
		        }
		        return fieldResult;
		    }

		    #getCompleteResult() {
		        const resultComplete = {
		            clean: this.#clean,
		            fields: {},
		            form: [],
		        };
		        const list = this.#getFieldsList();
		        for (let fieldName of list) {
		            const errors = this.getCompleteResultForField(fieldName);
		            if (errors.length) {
		                resultComplete.fields[fieldName] = errors;
		            }
		        }
		        resultComplete.form = [...this.#result.form.errors];
		        if (resultComplete.form.length === 0) {
		            delete resultComplete.form;
		        }
		        return resultComplete;
		    }

		    #getFieldsList() {
		        const fields = Object.keys(this.#result.fields);
		        const fieldsInForm = Object.keys(this.#result.form.fields);
		        return [...new Set([...fieldsInForm, ...fields])];
		    }
		};
		return result;
	}

	/**
	*	Template of error.js
	*	For building for specific environment.
	*	Node.js or Browser
	*	@param {string}	env	node|browser in wich env it will be running
	*	@param {string}	url	URL of report collector
	*	@param {string}	key	key to indetificate reporter
	*/

	var error_node;
	var hasRequiredError_node;

	function requireError_node () {
		if (hasRequiredError_node) return error_node;
		hasRequiredError_node = 1;
		/**
		* Error reporting with features, saving browser info, uri and so on.
		* @module not-error/error
		*/
		class notError extends Error {
			constructor(message, options = {}, error = null){
				super(message);
				this.options = options;
				this.adopt(error);
				this.fill();
				this.getTime();
				return this;
			}

			/**
			*	Adopting native error object
			*	@param {Error}	error 	Error object
			*	@return {notError}		chainable
			*/
			adopt(error){
				if(error instanceof Error){
					this.parent = error;
				}
				return this;
			}

			getStack(){
				if(this.parent){
					return this.parent.stack;
				}else {
					return this.stack;
				}
			}

			getDetails(){
				let src = this;
				if(this.parent){
					src = this.parent;
				}
				return {
					columnNumber:    	src.columnNumber,
					fileName:        	src.fileName,
					lineNumber:      	src.lineNumber,
					name:            	src.name,
					message:        	src.message,
					stack:          	src.stack
				};
			}

			/**
			*	Updating this.env.date property
			*	@return  {object}	{timestamp, offset}
			*/
			getTime(){
				let date = new Date();
				this.env.date = {
					timestamp : date.getTime(),
					offset: date.getTimezoneOffset()
				};
				return this.env.date;
			}


			/**
			******************************************************************************************************
			******************************************************************************************************
			***	Node.js Section
			******************************************************************************************************
			******************************************************************************************************
			**/

			/**
			*	Filtering out key by `white` list
			*	@param {object} object hash to be copied according filter `white` list
			*	@param {array} filter array of sting, which represents keys we want to be
			*						copied in resulting object from source
			*	@return {object}		white listed hash
			*/
			filterEnv(object, filter){
				let result = {};
				for(let t of filter){
					if(Object.prototype.hasOwnProperty.call(object, t)){
						result[t] = object[t];
					}
				}
				return result;
			}

			/**
			*	Collecting information specific for Node.js V8
			*	@return {notError}		chainable
			*/
			fill(){
				/**
				*	You want some fields from env but not all, cause there are passwords
				*	from db, api keys and etc
				*/
				this.env = {
					browser: 	false,
					node: 		true,
					versions: Object.assign({}, process.versions),
					vars: 		this.filterEnv(process.env, this.options.whitelist || ['NODE_ENV'])
				};
				return this;
			}


		}


		error_node = notError;
		return error_node;
	}

	var validation_error_node;
	var hasRequiredValidation_error_node;

	function requireValidation_error_node () {
		if (hasRequiredValidation_error_node) return validation_error_node;
		hasRequiredValidation_error_node = 1;
		const notError = requireError_node();


		//reportable
		class notValidationError extends notError{
		  constructor(message, fields = {}, err = null, params = {}){
		    super(message, {fields, params}, err);
		    return this;
		  }

		  /**
		  * Sets hash of fields errors messages for usage in forms
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  setFieldsErrors(messages){
		    this.options.fields = messages;
		  }

		  /**
		  * Returns hash of errors
		  *	@return {Object}	hash of field->errors [key:string]: Array<string>
		  **/
		  getFieldsErrors(){
		    return this.options.fields;
		  }

		}


		validation_error_node = notValidationError;
		return validation_error_node;
	}

	/**
	 * Test argument type to be 'function'
	 * @param {any}  func    possible function
	 * @return {boolean}     if this is a function
	 **/

	var common;
	var hasRequiredCommon;

	function requireCommon () {
		if (hasRequiredCommon) return common;
		hasRequiredCommon = 1;
		const isFunc = (func) => {
		    return typeof func === "function";
		};

		/**
		 * Returns true if argument is Async function
		 * @param {function} func  to test
		 * @return {boolean}       if this function is constructed as AsyncFunction
		 **/
		const isAsync = (func) => {
		    return func.constructor.name === "AsyncFunction";
		};

		common = async (proc, params) => {
		    if (isFunc(proc)) {
		        if (isAsync(proc)) {
		            return await proc(...params);
		        } else {
		            return proc(...params);
		        }
		    }
		};
		return common;
	}

	var session;
	var hasRequiredSession;

	function requireSession () {
		if (hasRequiredSession) return session;
		hasRequiredSession = 1;
		const ValidationResult = requireResult();
		const notVaildationError = requireValidation_error_node();
		const executeObjectFunction = requireCommon();

		const ValidationSession = async (validators, data) => {
		    const result = ValidationResult.getDefaultResult(data);
		    await validateFields({ validators, data, result });
		    await validateForm({ validators, data, result });
		    return new ValidationResult(result);
		};

		session = ValidationSession;

		const validateFields = async ({ validators, data, result }) => {
		    for (let t in data) {
		        await validateField(t, data[t], validators, result);
		    }
		};

		const validateField = async (fieldName, value, validators, result) => {
		    const fieldValidators = getFieldValidators(fieldName, validators);
		    return await runFieldValidators(fieldName, value, fieldValidators, result);
		};

		const getFieldValidators = (name, validators) => {
		    return validators && validators.fields && validators.fields[name]
		        ? validators.fields[name]
		        : [];
		};

		const runFieldValidators = async (fieldName, value, validators, result) => {
		    for (let validatorRule of validators) {
		        try {
		            const valid = await executeObjectFunction(
		                validatorRule["validator"],
		                [value]
		            );
		            if (!valid) {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        } catch (e) {
		            if (e instanceof notVaildationError || !validatorRule.message) {
		                setFieldError(fieldName, e.message, result);
		            } else {
		                setFieldError(fieldName, validatorRule.message, result);
		            }
		        }
		    }
		};

		const setFieldError = (fieldName, errorMessage, result) => {
		    if (!result.fields[fieldName].includes(errorMessage)) {
		        result.fields[fieldName].push(errorMessage);
		    }
		};

		const validateForm = async ({ validators, data, result }) => {
		    const formValidators = getFormValidators(validators);
		    await runFormValidators(data, formValidators, result);
		};

		const getFormValidators = (validators) => {
		    return validators && validators.form ? validators.form : [];
		};

		const runFormValidators = async (data, formValidators, result) => {
		    for (let validator of formValidators) {
		        try {
		            await validator(data);
		        } catch (e) {
		            if (e && typeof e.getFieldsErrors === "function") {
		                const formErrors = e.getFieldsErrors();
		                Array.isArray(formErrors.form) &&
		                    addFormErrors(formErrors.form, result);
		                formErrors.fields &&
		                    addFormFieldsErrors(formErrors.fields, result);
		            } else {
		                throw e;
		            }
		        }
		    }
		};

		const addFormErrors = (errors, result) => {
		    errors.forEach((error) => {
		        addFormError(error, result);
		    });
		};

		const addFormError = (errorMessage, result) => {
		    if (!result.form.errors.includes(errorMessage)) {
		        result.form.errors.push(errorMessage);
		    }
		};

		const addFormFieldsErrors = (fieldsErrors, result) => {
		    for (let fieldName in fieldsErrors) {
		        addFormFieldErrors(fieldName, fieldsErrors[fieldName], result);
		    }
		};

		const addFormFieldErrors = (fieldName, errorMessages, result) => {
		    errorMessages.forEach((error) => {
		        addFormFieldError(fieldName, error, result);
		    });
		};

		const addFormFieldError = (fieldName, errorMessage, result) => {
		    if (!Array.isArray(result.form.fields[fieldName])) {
		        result.form.fields[fieldName] = [];
		    }
		    if (!result.form.fields[fieldName].includes(errorMessage)) {
		        result.form.fields[fieldName].push(errorMessage);
		    }
		};
		return session;
	}

	var runner_utils;
	var hasRequiredRunner_utils;

	function requireRunner_utils () {
		if (hasRequiredRunner_utils) return runner_utils;
		hasRequiredRunner_utils = 1;
		const composeFieldsValidators = (data, validatorsLib) => {
		    if (validatorsLib && validatorsLib.fields) {
		        const list = Object.keys(data);
		        const result = {};
		        list.forEach((fieldName) => {
		            if (Array.isArray(validatorsLib.fields[fieldName])) {
		                result[fieldName] = validatorsLib.fields[fieldName];
		            }
		        });
		        return result;
		    } else {
		        return {};
		    }
		};

		const composeFormValidators = (name, validatorsLib) => {
		    if (!validatorsLib) return [];
		    if (validatorsLib.forms && Array.isArray(validatorsLib.forms[name])) {
		        return validatorsLib.forms[name];
		    }
		    if (Array.isArray(validatorsLib.form)) {
		        return validatorsLib.form;
		    }
		    return [];
		};

		runner_utils = {
		    composeFieldsValidators,
		    composeFormValidators,
		};
		return runner_utils;
	}

	var runner;
	var hasRequiredRunner;

	function requireRunner () {
		if (hasRequiredRunner) return runner;
		hasRequiredRunner = 1;
		const {
		    composeFieldsValidators,
		    composeFormValidators,
		} = requireRunner_utils();

		const ValidationSession = requireSession();

		/**
		 * Creates validation runner function from provided validation rules lib
		 * @param {object}     validationLib object containing fields validation rules and form specific rules
		 * @returns {function} (data: object, formName: string)=>Promise<ValidationResult>
		 **/
		const ValidationRunner = (validatorsLib) => {
		    /**
		     * Validation session runner
		     * @param {object} data      object to validate
		     * @param {string} formName
		     * @returns {Promise}
		     **/
		    return (data, formName) => {
		        const validators = {
		            //fields specific validators
		            fields: composeFieldsValidators(data, validatorsLib),
		            //form specific validators
		            form: composeFormValidators(formName, validatorsLib),
		        };
		        return ValidationSession(validators, data);
		    };
		};

		runner = ValidationRunner;
		return runner;
	}

	var builder_utils;
	var hasRequiredBuilder_utils;

	function requireBuilder_utils () {
		if (hasRequiredBuilder_utils) return builder_utils;
		hasRequiredBuilder_utils = 1;
		const augmentFieldsValidators = (fieldValidators, getValidatorEnv) => {
		    return fieldValidators.map((fieldRule) =>
		        augmentFieldValidator(fieldRule, getValidatorEnv)
		    );
		};

		const augmentFieldValidator = (rule, getValidatorEnv) => {
		    if (rule.validator && typeof rule.validator === "function") {
		        const ruleValidator = rule.validator;
		        const result = {
		            ...rule,
		        };
		        delete result.validator;
		        result.validator = (val) => ruleValidator(val, getValidatorEnv());
		        return result;
		    }
		    return rule;
		};

		const augmentFormValidators = (rules, getValidatorEnv) => {
		    return rules.map((rule) => augmentFormValidator(rule, getValidatorEnv));
		};

		const augmentFormValidator = (rule, getValidatorEnv) => {
		    return (val) => rule(val, getValidatorEnv());
		};

		builder_utils = {
		    augmentFieldsValidators,
		    augmentFieldValidator,
		    augmentFormValidators,
		    augmentFormValidator,
		};
		return builder_utils;
	}

	var builder;
	var hasRequiredBuilder;

	function requireBuilder () {
		if (hasRequiredBuilder) return builder;
		hasRequiredBuilder = 1;
		const objHas = (obj, name) => {
		    return Object.prototype.hasOwnProperty.call(obj, name);
		};
		const {
		    augmentFieldsValidators,
		    augmentFormValidators,
		} = requireBuilder_utils();

		/**
		 * @typedef   {object}    notValidationSchema
		 * @property  {object}    [fields]
		 * @property  {array}     [form]
		 * @property  {object}    [forms]
		 */

		/**
		 * returns valid empty validation scheme
		 *
		 * @return {notValidationSchema}
		 */
		const emptyScheme = () => {
		    return {
		        fields: {},
		        forms: {},
		    };
		};
		/**
		 *
		 *
		 * @param {object} validators
		 * @param {function} getValidatorEnv
		 * @return {notValidationSchema}
		 */
		const validationBuilder = (validators, getValidatorEnv) => {
		    if (typeof validators === "undefined" || validators === null) {
		        return emptyScheme();
		    }
		    const augmented = {};
		    if (objHas(validators, "fields")) {
		        augmented.fields = transformFieldsValidators(
		            validators.fields,
		            getValidatorEnv
		        );
		    }
		    if (objHas(validators, "forms")) {
		        augmented.forms = transformFormsValidators(
		            validators.forms,
		            getValidatorEnv
		        );
		    } else {
		        if (objHas(validators, "form")) {
		            augmented.form = augmentFormValidators(
		                validators.form,
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		builder = validationBuilder;

		const transformFieldsValidators = (fields, getValidatorEnv) => {
		    const augmented = {};
		    for (let fieldName in fields) {
		        if (Array.isArray(fields[fieldName])) {
		            augmented[fieldName] = augmentFieldsValidators(
		                fields[fieldName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};

		const transformFormsValidators = (formsValidators, getValidatorEnv) => {
		    const augmented = {};
		    for (let formName in formsValidators) {
		        if (Array.isArray(formsValidators[formName])) {
		            augmented[formName] = augmentFormValidators(
		                formsValidators[formName],
		                getValidatorEnv
		            );
		        }
		    }
		    return augmented;
		};
		return builder;
	}

	var src;
	var hasRequiredSrc;

	function requireSrc () {
		if (hasRequiredSrc) return src;
		hasRequiredSrc = 1;
		const Session = requireSession();
		const Runner = requireRunner();
		const Builder = requireBuilder();
		const Result = requireResult();

		src = {
		    name: "not-validation",
		    Session,
		    Runner,
		    Builder,
		    Result,
		};
		return src;
	}

	var srcExports = requireSrc();

	var root_4$4 = template(`<div><div class="field-label is-normal"><!></div> <div class="field-body"></div></div>`);
	var root_7$1 = template(`<!> <!>`, 1);
	var root_6$3 = template(`<div></div>`);

	function Field($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [label]
		 * @property {string} [name]
		 * @property {boolean} [readonly]
		 * @property {boolean} [horizontal]
		 * @property {any} [controls]
		 * @property {import('../../../elements/events.types').UIEventInputChangeCallback} onchange
		 * @property {string} [classes] - field style modification
		 * @property {boolean} [addons] - //addons
		 * @property {boolean} [addonsCentered]
		 * @property {boolean} [addonsRight]
		 * @property {boolean} [grouped] - //group flag
		 * @property {boolean} [groupedMultiline]
		 * @property {boolean} [groupedRight]
		 * @property {boolean} [groupedCentered]
		 */
		/** @type {Props} */
		let label = prop($$props, 'label', 3, ""),
			name = prop($$props, 'name', 3, "generic field"),
			readonly = prop($$props, 'readonly', 3, false),
			horizontal = prop($$props, 'horizontal', 3, false),
			controls = prop($$props, 'controls', 19, () => []),
			classes = prop($$props, 'classes', 3, ""),
			addons = prop($$props, 'addons', 3, false),
			addonsCentered = prop($$props, 'addonsCentered', 3, false),
			addonsRight = prop($$props, 'addonsRight', 3, false),
			grouped = prop($$props, 'grouped', 3, false),
			groupedMultiline = prop($$props, 'groupedMultiline', 3, false),
			groupedRight = prop($$props, 'groupedRight', 3, false),
			groupedCentered = prop($$props, 'groupedCentered', 3, false),
			onchange = prop($$props, 'onchange', 3, () => true),
			formFieldPrefix = prop($$props, 'formFieldPrefix', 3, "form-field-");

		let fieldClasses = state("");
		let hidden = state(false);
		let fieldId = state(undefined);

		onMount(() => {
			set(fieldClasses, get$3(fieldClasses) + (" " + classes()));
			set(fieldClasses, get$3(fieldClasses) + (addons() ? " has-addons " : ""));
			set(fieldClasses, get$3(fieldClasses) + (addonsCentered() ? " has-addons-centered " : ""));
			set(fieldClasses, get$3(fieldClasses) + (addonsRight() ? " has-addons-right " : ""));
			set(fieldClasses, get$3(fieldClasses) + (grouped() ? " is-grouped " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedMultiline() ? " is-grouped-multiline " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedRight() ? " is-grouped-right " : ""));
			set(fieldClasses, get$3(fieldClasses) + (groupedCentered() ? " is-grouped-centered " : ""));

			if (readonly()) {
				controls().forEach((control) => {
					control.readonly = true;
				});
			}

			let notHidden = controls().filter((control) => control.component !== "UIHidden");

			set(hidden, notHidden.length === 0);

			let tmp = controls().map((itm) => itm.component).join("_");

			set(fieldId, `${formFieldPrefix()}${tmp}-${name()}`);
		});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				each(node_1, 17, controls, index$d, ($$anchor, control) => {
					var fragment_2 = comment();
					const SvelteComponent = derived(() => COMPONENTS$1.get(get$3(control).component));
					var node_2 = first_child(fragment_2);

					component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
						$$component($$anchor, spread_props(() => get$3(control), {
							get onchange() {
								return onchange();
							},
							get fieldname() {
								return name();
							}
						}));
					});

					append($$anchor, fragment_2);
				});

				append($$anchor, fragment_1);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_3 = comment();
				var node_3 = first_child(fragment_3);

				{
					var consequent_1 = ($$anchor) => {
						var div = root_4$4();
						var div_1 = child(div);
						var node_4 = child(div_1);
						const expression = derived(() => label() || controls()[0].label);

						Ui_label(node_4, {
							get for() {
								return get$3(fieldId);
							},
							get label() {
								return get$3(expression);
							}
						});

						reset(div_1);

						var div_2 = sibling(div_1, 2);

						each(div_2, 21, controls, index$d, ($$anchor, control) => {
							var fragment_4 = comment();
							const SvelteComponent_1 = derived(() => COMPONENTS$1.get(get$3(control).component));
							var node_5 = first_child(fragment_4);

							component(node_5, () => get$3(SvelteComponent_1), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$3(control), {
									get onchange() {
										return onchange();
									},
									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_4);
						});

						reset(div_2);
						reset(div);

						template_effect(() => {
							set_class(div, `field is-horizontal ${get$3(fieldClasses) ?? ''} ${get$3(fieldId) ?? ''}`);
							set_attribute(div_2, 'id', get$3(fieldId));
						});

						append($$anchor, div);
					};

					var alternate = ($$anchor) => {
						var div_3 = root_6$3();

						each(div_3, 21, controls, index$d, ($$anchor, control) => {
							var fragment_5 = root_7$1();
							const SvelteComponent_2 = derived(() => COMPONENTS$1.get(get$3(control).component));
							var node_6 = first_child(fragment_5);

							Ui_label(node_6, {
								get for() {
									return `form-field-${get$3(control).component ?? ''}-${name() ?? ''}`;
								},
								get label() {
									return get$3(control).label;
								}
							});

							var node_7 = sibling(node_6, 2);

							component(node_7, () => get$3(SvelteComponent_2), ($$anchor, $$component) => {
								$$component($$anchor, spread_props(() => get$3(control), {
									get onchange() {
										return onchange();
									},
									get fieldname() {
										return name();
									}
								}));
							});

							append($$anchor, fragment_5);
						});

						reset(div_3);
						template_effect(() => set_class(div_3, `field ${get$3(fieldClasses) ?? ''} ${get$3(fieldId) ?? ''}`));
						append($$anchor, div_3);
					};

					if_block(
						node_3,
						($$render) => {
							if (horizontal()) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_3);
			};

			if_block(node, ($$render) => {
				if (get$3(hidden)) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	function submitForm(e, dispatch, collectData) {
		e && e.preventDefault();
		dispatch("submit", collectData());
		return false;
	}

	function rejectForm(_, dispatch) {
		dispatch("reject");
	}

	var root_1$5 = template(`<div><span class="title"> </span></div>`);
	var root_2$3 = template(`<div class="notification is-success"><h3 class="form-success-message"> </h3></div>`);
	var root_4$3 = template(`<h5 class="title is-5"> </h5>`);
	var root_5$3 = template(`<h6 class="subtitle is-6"> </h6>`);
	var root_7 = template(`<button> </button>`);
	var root_8 = template(`<button> </button>`);
	var root_9 = template(`<div class="edit-form-error notification is-danger"> </div>`);
	var root_6$2 = template(`<div class="buttons is-grouped is-centered"><!> <!></div> <!>`, 1);
	var root_14 = template(`<div><!></div>`);
	var root_15 = template(`<div class="column notification is-danger"> </div>`);
	var root_11 = template(`<div class="columns"></div>`);
	var root_19 = template(`<div class="notification is-danger"> </div>`);
	var root_22 = template(`<span> </span>`);
	var root_21 = template(`<div class="edit-form-error notification is-danger"></div>`);
	var root_23 = template(`<button> </button>`);
	var root_24 = template(`<button> </button>`);
	var root_20 = template(`<!> <div class="buttons is-grouped is-centered"><!> <!></div>`, 1);
	var root_3$4 = template(`<!> <!> <!> <!> <!>`, 1);
	var root$6 = template(`<div class="form-container"><!> <!></div>`);

	function Form($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let dispatch = createEventDispatcher();
		//validation status
		let formErrors = state(proxy([]));
		let formHasErrors = state(false);
		let fieldsHasErrors = state(false);
		let success = state(false);

		//input data
		//form structure object
		//hidden - no loader
		//container - parent container of form
		//fields list structure
		/**
		 * @typedef {Object} Props
		 * @property {any} [form] - {
		[fieldName: string] => description: object
		}
		 * @property {boolean} [loading] - state if form loading
		 * @property {string} [loader] - page - whole page
		 * @property {any} [fields] - each item is a row
		if item is array, then there few fields in a row
		[
		[name, age],
		[email, telephone]
		bio,
		agreed
		]
		 * @property {string} [SUCCESS_TEXT] - form result labels
		 * @property {string} [WAITING_TEXT]
		 * @property {string} [title] - form labels
		 * @property {string} [description]
		 * @property {boolean} [buttonsFirst] - if you want button on top
		 * @property {boolean} [horizontal] - if form fields should have horizontal layout
		 * @property {any} [submit] - buttons labels and availability
		 * @property {any} [cancel]
		 */
		/** @type {Props} */
		let form = prop($$props, 'form', 31, () => proxy({})),
			loading = prop($$props, 'loading', 15, false),
			loader = prop($$props, 'loader', 3, "container"),
			fields = prop($$props, 'fields', 19, () => []),
			SUCCESS_TEXT = prop($$props, 'SUCCESS_TEXT', 3, "Операция завершена"),
			WAITING_TEXT = prop($$props, 'WAITING_TEXT', 3, "Отправка данных на сервер"),
			title = prop($$props, 'title', 3, ""),
			description = prop($$props, 'description', 3, ""),
			buttonsFirst = prop($$props, 'buttonsFirst', 3, false),
			horizontal = prop($$props, 'horizontal', 3, false),
			submit = prop($$props, 'submit', 19, () => ({ caption: "Отправить", enabled: true })),
			cancel = prop($$props, 'cancel', 19, () => ({ caption: "Назад", enabled: true }));

		let formInvalid = derived(() => get$3(formHasErrors) || get$3(fieldsHasErrors));

		function collectData() {
			return FormHelpers.collectData(fields(), form());
		}

		function setFieldInvalid(fieldName, value, errors) {
			form(FormHelpers.setFieldInvalid(form(), fieldName, value, errors));
			set(fieldsHasErrors, true);
		}

		function setFieldValid(fieldName, value) {
			form(FormHelpers.setFieldValid(form(), fieldName, value));
		}

		function isFieldValid(fieldName) {
			return FormHelpers.isFieldValid(form(), fieldName);
		}

		function setFormFieldInvalid(fieldName, errors) {
			form(FormHelpers.setFormFieldInvalid(form(), fieldName, errors));
			dispatch(`field.invalid`, { fieldName });
		}

		function setFormFieldValid(fieldName) {
			form(FormHelpers.setFormFieldValid(form(), fieldName));
			dispatch(`field.valid`, { fieldName });
		}

		function updateFormValidationStatus(
			validationStatus /* FormValidationSession.getCompleteResult() */
		) {
			set(formHasErrors, false);
			set(fieldsHasErrors, false);

			if (Array.isArray(validationStatus.form) && validationStatus.form.length) {
				get$3(formErrors).splice(0, get$3(formErrors).length, ...validationStatus.form);
				set(formHasErrors, true);
			} else {
				get$3(formErrors).splice(0, get$3(formErrors).length);
			}

			set(formErrors, proxy(get$3(formErrors)));

			if (validationStatus.fields) {
				for (let fieldName of Object.keys(form())) {
					if (Array.isArray(validationStatus.fields[fieldName]) && validationStatus.fields[fieldName].length) {
						FormHelpers.setFormFieldInvalid(form(), fieldName, validationStatus.fields[fieldName]);
						set(fieldsHasErrors, true);
					} else {
						FormHelpers.setFormFieldValid(form(), fieldName);
					}
				}
			}
		}

		function showSuccess() {
			set(success, true);
		}

		function setLoading() {
			loading(true);
		}

		function resetLoading() {
			loading(false);
		}

		function setFieldsVisibility(fieldsList, val) {
			if (FormHelpers.setFieldsVisibility(form(), fieldsList, val)) {
				form(form());
			}
		}

		function setVisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, true);
		}

		function setInvisibleFields(fieldsList) {
			setFieldsVisibility(fieldsList, false);
		}

		function setFieldValue(fieldName, value) {
			if (FormHelpers.setFieldValue(form(), fieldName, value)) {
				onFieldChange({ detail: { field: fieldName, value } });
			}
		}

		function updateField(fieldName, props) {
			form(form()[fieldName] = { ...form()[fieldName], ...props }, true);
			form(form());
		}

		function onFieldChange(ev) {
			let data = ev.detail;

			form(form()[data.field].value = data.value, true);
			form(form());
			dispatch("change", data);
		}

		var div = root$6();
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var div_1 = root_1$5();
				var span = child(div_1);
				var text = child(span, true);

				reset(span);
				reset(div_1);

				template_effect(() => {
					set_class(div_1, `${(loader() === 'page' ? 'pageloader' : 'containerloader') ?? ''} ${(loading() ? 'is-active' : '') ?? ''}`);
					set_text(text, $LOCALE()[WAITING_TEXT()]);
				});

				append($$anchor, div_1);
			};

			if_block(node, ($$render) => {
				if (loader() !== "hidden") $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var div_2 = root_2$3();
				var h3 = child(div_2);
				var text_1 = child(h3, true);

				reset(h3);
				reset(div_2);
				template_effect(() => set_text(text_1, $LOCALE()[SUCCESS_TEXT()]));
				append($$anchor, div_2);
			};

			var alternate_3 = ($$anchor) => {
				var fragment = root_3$4();
				var node_2 = first_child(fragment);

				{
					var consequent_2 = ($$anchor) => {
						var h5 = root_4$3();
						var text_2 = child(h5, true);

						reset(h5);
						template_effect(() => set_text(text_2, $LOCALE()[title()]));
						append($$anchor, h5);
					};

					if_block(node_2, ($$render) => {
						if (title()) $$render(consequent_2);
					});
				}

				var node_3 = sibling(node_2, 2);

				{
					var consequent_3 = ($$anchor) => {
						var h6 = root_5$3();
						var text_3 = child(h6, true);

						reset(h6);
						template_effect(() => set_text(text_3, $LOCALE()[description()]));
						append($$anchor, h6);
					};

					if_block(node_3, ($$render) => {
						if (description()) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_7 = ($$anchor) => {
						var fragment_1 = root_6$2();
						var div_3 = first_child(fragment_1);
						var node_5 = child(div_3);

						{
							var consequent_4 = ($$anchor) => {
								var button = root_7();

								button.__click = [rejectForm, dispatch];

								var text_4 = child(button, true);

								reset(button);

								template_effect(() => {
									set_class(button, `button is-outlined ${cancel().classes ?? ''}`);
									set_text(text_4, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button);
							};

							if_block(node_5, ($$render) => {
								if (cancel().enabled) $$render(consequent_4);
							});
						}

						var node_6 = sibling(node_5, 2);

						{
							var consequent_5 = ($$anchor) => {
								var button_1 = root_8();

								button_1.__click = [submitForm, dispatch, collectData];

								var text_5 = child(button_1, true);

								reset(button_1);

								template_effect(() => {
									button_1.disabled = get$3(formInvalid);
									set_class(button_1, `button is-primary is-hovered ${submit().classes ?? ''}`);
									set_text(text_5, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_1);
							};

							if_block(node_6, ($$render) => {
								if (submit().enabled) $$render(consequent_5);
							});
						}

						reset(div_3);

						var node_7 = sibling(div_3, 2);

						{
							var consequent_6 = ($$anchor) => {
								var div_4 = root_9();
								var text_6 = child(div_4, true);

								reset(div_4);
								template_effect(($0) => set_text(text_6, $0), [() => get$3(formErrors).join(", ")]);
								append($$anchor, div_4);
							};

							if_block(node_7, ($$render) => {
								if (get$3(formErrors).length > 0) $$render(consequent_6);
							});
						}

						append($$anchor, fragment_1);
					};

					if_block(node_4, ($$render) => {
						if (buttonsFirst()) $$render(consequent_7);
					});
				}

				var node_8 = sibling(node_4, 2);

				each(node_8, 17, fields, index$d, ($$anchor, field) => {
					var fragment_2 = comment();
					var node_9 = first_child(fragment_2);

					{
						var consequent_10 = ($$anchor) => {
							var div_5 = root_11();

							each(div_5, 21, () => get$3(field), index$d, ($$anchor, subfield) => {
								var fragment_3 = comment();
								var node_10 = first_child(fragment_3);

								{
									var consequent_9 = ($$anchor) => {
										var fragment_4 = comment();
										var node_11 = first_child(fragment_4);

										{
											var consequent_8 = ($$anchor) => {
												var div_6 = root_14();
												var node_12 = child(div_6);
												const expression = derived(() => [form()[get$3(subfield)]]);

												Field(node_12, {
													get controls() {
														return get$3(expression);
													},
													get name() {
														return get$3(subfield);
													},
													get horizontal() {
														return horizontal();
													},
													get label() {
														return form()[get$3(subfield)].label;
													},
													$$events: { change: onFieldChange }
												});

												reset(div_6);
												template_effect(() => set_class(div_6, `column ${(form()[get$3(subfield)].fieldSize ? 'is-' + form()[get$3(subfield)].fieldSize : '') ?? ''} `));
												append($$anchor, div_6);
											};

											if_block(node_11, ($$render) => {
												if (form()[get$3(subfield)].visible) $$render(consequent_8);
											});
										}

										append($$anchor, fragment_4);
									};

									var alternate = ($$anchor) => {
										var div_7 = root_15();
										var text_7 = child(div_7);

										reset(div_7);
										template_effect(() => set_text(text_7, `Subfield '${get$3(subfield) ?? ''}' is not registered`));
										append($$anchor, div_7);
									};

									if_block(node_10, ($$render) => {
										if (form()[get$3(subfield)] && form()[get$3(subfield)].component) $$render(consequent_9); else $$render(alternate, false);
									});
								}

								append($$anchor, fragment_3);
							});

							reset(div_5);
							append($$anchor, div_5);
						};

						var alternate_2 = ($$anchor) => {
							var fragment_5 = comment();
							var node_13 = first_child(fragment_5);

							{
								var consequent_12 = ($$anchor) => {
									var fragment_6 = comment();
									var node_14 = first_child(fragment_6);

									{
										var consequent_11 = ($$anchor) => {
											const expression_1 = derived(() => [form()[get$3(field)]]);

											Field($$anchor, {
												get controls() {
													return get$3(expression_1);
												},
												get name() {
													return get$3(field);
												},
												get horizontal() {
													return horizontal();
												},
												get label() {
													return form()[get$3(field)].label;
												},
												$$events: { change: onFieldChange }
											});
										};

										if_block(node_14, ($$render) => {
											if (form()[get$3(field)].visible) $$render(consequent_11);
										});
									}

									append($$anchor, fragment_6);
								};

								var alternate_1 = ($$anchor) => {
									var div_8 = root_19();
									var text_8 = child(div_8);

									reset(div_8);
									template_effect(() => set_text(text_8, `Field '${get$3(field) ?? ''}' is not registered`));
									append($$anchor, div_8);
								};

								if_block(
									node_13,
									($$render) => {
										if (form()[get$3(field)] && form()[get$3(field)].component) $$render(consequent_12); else $$render(alternate_1, false);
									},
									true
								);
							}

							append($$anchor, fragment_5);
						};

						if_block(node_9, ($$render) => {
							if (Array.isArray(get$3(field))) $$render(consequent_10); else $$render(alternate_2, false);
						});
					}

					append($$anchor, fragment_2);
				});

				var node_15 = sibling(node_8, 2);

				{
					var consequent_16 = ($$anchor) => {
						var fragment_8 = root_20();
						var node_16 = first_child(fragment_8);

						{
							var consequent_13 = ($$anchor) => {
								var div_9 = root_21();

								each(div_9, 21, () => get$3(formErrors), index$d, ($$anchor, formError) => {
									var span_1 = root_22();
									var text_9 = child(span_1, true);

									reset(span_1);
									template_effect(() => set_text(text_9, $LOCALE()[get$3(formError)]));
									append($$anchor, span_1);
								});

								reset(div_9);
								append($$anchor, div_9);
							};

							if_block(node_16, ($$render) => {
								if (get$3(formErrors).length > 0) $$render(consequent_13);
							});
						}

						var div_10 = sibling(node_16, 2);
						var node_17 = child(div_10);

						{
							var consequent_14 = ($$anchor) => {
								var button_2 = root_23();

								button_2.__click = [rejectForm, dispatch];

								var text_10 = child(button_2, true);

								reset(button_2);

								template_effect(() => {
									set_class(button_2, `button ${(cancel().classes ? cancel().classes : '') ?? ''}`);
									set_text(text_10, $LOCALE()[cancel().caption]);
								});

								append($$anchor, button_2);
							};

							if_block(node_17, ($$render) => {
								if (cancel().enabled) $$render(consequent_14);
							});
						}

						var node_18 = sibling(node_17, 2);

						{
							var consequent_15 = ($$anchor) => {
								var button_3 = root_24();

								button_3.__click = [submitForm, dispatch, collectData];

								var text_11 = child(button_3, true);

								reset(button_3);

								template_effect(() => {
									button_3.disabled = get$3(formInvalid);
									set_class(button_3, `button is-primary is-hovered ${(submit().classes ? submit().classes : '') ?? ''}`);
									set_text(text_11, $LOCALE()[submit().caption]);
								});

								append($$anchor, button_3);
							};

							if_block(node_18, ($$render) => {
								if (submit().enabled) $$render(consequent_15);
							});
						}

						reset(div_10);
						append($$anchor, fragment_8);
					};

					if_block(node_15, ($$render) => {
						if (!buttonsFirst()) $$render(consequent_16);
					});
				}

				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (get$3(success)) $$render(consequent_1); else $$render(alternate_3, false);
			});
		}

		reset(div);
		append($$anchor, div);

		var $$pop = pop({
			collectData,
			setFieldInvalid,
			setFieldValid,
			isFieldValid,
			setFormFieldInvalid,
			setFormFieldValid,
			updateFormValidationStatus,
			showSuccess,
			setLoading,
			resetLoading,
			setFieldsVisibility,
			setVisibleFields,
			setInvisibleFields,
			setFieldValue,
			updateField
		});

		$$cleanup();
		return $$pop;
	}

	delegate(['click']);

	const DEFAULT_RULES = {
	  notReadonly(v) {
	    return {
	      readonly: !v
	    };
	  },
	  readonly(v) {
	    return {
	      readonly: v
	    };
	  },
	  enable(v) {
	    return {
	      disabled: !v
	    };
	  },
	  disable(v) {
	    return {
	      disabled: v
	    };
	  }
	};
	let notFormRules = /*#__PURE__*/function () {
	  function notFormRules() {
	    _classCallCheck(this, notFormRules);
	  }
	  return _createClass(notFormRules, null, [{
	    key: "add",
	    value: function add(name, func) {
	      if (!notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name)) {
	        _assertClassBrand(notFormRules, this, _RULES)._[name] = func;
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove(name) {
	      if (notCommon$1.objHas(_assertClassBrand(notFormRules, this, _RULES)._, name) && !Object.keys(DEFAULT_RULES).includes(name)) {
	        delete _assertClassBrand(notFormRules, this, _RULES)._[name];
	      }
	    }
	  }, {
	    key: "exec",
	    value: function exec(rule, master, slaves, value, form) {
	      return _assertClassBrand(notFormRules, this, _RULES)._[rule](value, master, slaves, form);
	    }
	  }]);
	}();
	var _RULES = {
	  _: {
	    ...DEFAULT_RULES
	  }
	};

	const DEFAULT_CONTAINER_SELECTOR$1 = ".form";
	const DEFAULT_ACTION_NAME = "default";
	var _uiComponent = /*#__PURE__*/new WeakMap();
	var _validationRunner = /*#__PURE__*/new WeakMap();
	var _form$1 = /*#__PURE__*/new WeakMap();
	var _action = /*#__PURE__*/new WeakMap();
	var _fields = /*#__PURE__*/new WeakMap();
	var _variants = /*#__PURE__*/new WeakMap();
	var _notForm_brand = /*#__PURE__*/new WeakSet();
	let notForm = /*#__PURE__*/function (_notBase) {
	  //variants for UI

	  function notForm({
	    target = null,
	    name = "Default",
	    options = {},
	    working = {},
	    data: _data = {},
	    ui = Form //default UI
	  }) {
	    var _this;
	    _classCallCheck(this, notForm);
	    _this = _callSuper(this, notForm, [{
	      working: {
	        name: `${name}Form`,
	        ...working
	      },
	      options,
	      data: _data
	    }]);
	    _classPrivateMethodInitSpec(_this, _notForm_brand);
	    //UI renderer component class constructor
	    _classPrivateFieldInitSpec(_this, _uiComponent, null);
	    //form validation
	    _classPrivateFieldInitSpec(_this, _validationRunner, null);
	    //ui component
	    _classPrivateFieldInitSpec(_this, _form$1, null);
	    //model.action
	    _classPrivateFieldInitSpec(_this, _action, DEFAULT_ACTION_NAME);
	    //fields schemas
	    _classPrivateFieldInitSpec(_this, _fields, new Lib());
	    //fields of UI
	    //variants sets for select menus and so on
	    _classPrivateFieldInitSpec(_this, _variants, null);
	    _classPrivateFieldSet2(_variants, _this, new Lib(VARIANTS$1.getContent()));
	    if (target) {
	      _this.setOptions("target", target);
	    }
	    _classPrivateFieldSet2(_uiComponent, _this, ui);
	    if (notCommon$1.objHas(options, "action")) {
	      _classPrivateFieldSet2(_action, _this, options.action);
	    }
	    _this.initForm();
	    return _this;
	  }
	  _inherits(notForm, _notBase);
	  return _createClass(notForm, [{
	    key: "initForm",
	    value: function initForm() {
	      if (this.getOptions("autoInit", true)) {
	        this.initLibs();
	      }
	      if (this.getOptions("autoRender", true)) {
	        this.initUI();
	      }
	    }
	  }, {
	    key: "initLibs",
	    value: function initLibs() {
	      this.initFields();
	      this.initVariants();
	      this.initValidator();
	    }
	  }, {
	    key: "reInit",
	    value: function reInit() {
	      this.initLibs();
	      this.updateUI();
	      this.resetLoading();
	    }
	  }, {
	    key: "initFields",
	    value: function initFields() {
	      const manifest = this.getFormManifest();
	      if (notCommon$1.objHas(manifest, "fields") && _classPrivateFieldGet2(_fields, this).isEmpty()) {
	        _classPrivateFieldGet2(_fields, this).import(manifest.fields); //all fields available in model manifest
	      }
	    }
	  }, {
	    key: "initVariants",
	    value: function initVariants() {
	      if (this.getOptions("variants")) {
	        _classPrivateFieldGet2(_variants, this).import(this.getOptions("variants"));
	      }
	    }

	    //creating validators runner for this specific form
	  }, {
	    key: "initValidator",
	    value: function initValidator() {
	      _classPrivateFieldSet2(_validationRunner, this, srcExports.Runner(this.getFormValidators()));
	    }
	  }, {
	    key: "initUI",
	    value: function initUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        const target = this.getFormTargetEl();
	        while (target.children.length) target.removeChild(target.firstChild);
	        _classPrivateFieldSet2(_form$1, this, new (_classPrivateFieldGet2(_uiComponent, this))({
	          target,
	          props
	        }));
	        _assertClassBrand(_notForm_brand, this, _bindUIEvents).call(this);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "updateUI",
	    value: function updateUI() {
	      try {
	        const props = _assertClassBrand(_notForm_brand, this, _getFormProps).call(this, {
	          manifest: this.getFormManifest(),
	          formOptions: this.getFormOptions(),
	          data: this.getFormData(),
	          injectedProps: this.getFormInjectedProps()
	        });
	        _classPrivateFieldGet2(_form$1, this).$set(props);
	        this.validateForm();
	      } catch (e) {
	        this.error(e);
	      }
	    }
	  }, {
	    key: "validateForm",
	    value: async function validateForm() {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      try {
	        const validationResult = await _classPrivateFieldGet2(_validationRunner, this).call(this, _classPrivateFieldGet2(_form$1, this).collectData(), this.getFormAction());
	        _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(validationResult.getReport());
	        if (!validationResult.clean) {
	          this.emit("error", validationResult.getReport());
	        }
	      } catch (e) {
	        const report = {
	          form: [UICommon$1.ERROR_DEFAULT, e.message]
	        };
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(report);
	        this.emit("error", report);
	        notCommon$1.report(e);
	      }
	    }
	  }, {
	    key: "submit",
	    value: function submit(data) {
	      this.emit("submit", data);
	    }
	  }, {
	    key: "reject",
	    value: function reject() {
	      this.emit("reject");
	    }

	    //binding event to actual UI
	  }, {
	    key: "$on",
	    value: function $on() {
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$on(...arguments);
	      }
	    }
	  }, {
	    key: "setLoading",
	    value: function setLoading() {
	      this.emit("loading");
	      _classPrivateFieldGet2(_form$1, this).setLoading();
	    }
	  }, {
	    key: "resetLoading",
	    value: function resetLoading() {
	      this.emit("loaded");
	      _classPrivateFieldGet2(_form$1, this).resetLoading();
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.emit("destroy");
	      if (_classPrivateFieldGet2(_form$1, this)) {
	        _classPrivateFieldGet2(_form$1, this).$destroy && _classPrivateFieldGet2(_form$1, this).$destroy();
	        _classPrivateFieldGet2(_form$1, this).destroy && _classPrivateFieldGet2(_form$1, this).destroy();
	        _classPrivateFieldSet2(_form$1, this, null);
	      }
	      _classPrivateFieldSet2(_validationRunner, this, null);
	      _classPrivateFieldSet2(_action, this, null);
	      _classPrivateFieldSet2(_fields, this, null);
	      _classPrivateFieldSet2(_variants, this, null);
	      this.setOptions(null);
	      this.setWorking(null);
	      this.setData(null);
	    }
	  }, {
	    key: "getName",
	    value: function getName() {
	      return this.getWorking("name");
	    }
	  }, {
	    key: "getFormAction",
	    value: function getFormAction() {
	      return _classPrivateFieldGet2(_action, this);
	    }
	  }, {
	    key: "setFormAction",
	    value: function setFormAction(val) {
	      if (val && val !== _classPrivateFieldGet2(_action, this)) {
	        _classPrivateFieldSet2(_action, this, val);
	        _classPrivateFieldGet2(_form$1, this) && _classPrivateFieldGet2(_form$1, this).$destroy();
	        this.initForm();
	      }
	    }
	  }, {
	    key: "processResult",
	    value: function processResult(result) {
	      if (result.status === DEFAULT_STATUS_SUCCESS) {
	        this.setFormSuccess();
	        return true;
	      } else {
	        this.setFormErrors(result);
	        return false;
	      }
	    }

	    /**
	     *   Form validation result
	     **/
	  }, {
	    key: "setFormSuccess",
	    value: function setFormSuccess() {
	      _classPrivateFieldGet2(_form$1, this).showSuccess();
	      this.emit("success");
	    }
	  }, {
	    key: "setFormErrors",
	    value: function setFormErrors(result) {
	      if (this.getOptions("readonly", false)) {
	        return;
	      }
	      const status = {
	        form: [],
	        fields: {}
	      };
	      if (result.message) {
	        status.form.push(result.message);
	      }
	      if (result.errors && Object.keys(result.errors).length > 0) {
	        status.fields = {
	          ...result.errors
	        };
	      }
	      _classPrivateFieldGet2(_form$1, this).updateFormValidationStatus(status);
	      this.emit("error", status);
	    }

	    /**
	     * Returns variant by collection name and item id
	     * @param {string}         name  name of the variants collection
	     * @param {string|number}  id    item identificator
	     * @returns {object}             item
	     **/
	  }, {
	    key: "getVariant",
	    value: function getVariant(name, id) {
	      let lib = _classPrivateFieldGet2(_variants, this).get(name);
	      let result = lib.find(function (item) {
	        return item.id === id;
	      });
	      if (result) {
	        return result;
	      }
	      return null;
	    }

	    /***
	     * Redefinable getters
	     **/
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const targetEl = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR$1);
	      if (targetEl instanceof HTMLElement) {
	        return targetEl;
	      } else if (typeof targetEl === "string") {
	        return document.querySelector(targetEl);
	      } else {
	        throw new Error("Form parent element is not defined");
	      }
	    }
	  }, {
	    key: "getFormValidators",
	    value: function getFormValidators() {
	      if (this.getOptions("validators")) {
	        return this.getOptions("validators", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "validators");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormManifest",
	    value: function getFormManifest() {
	      const modelName = this.getModelName();
	      if (modelName && notCommon$1.getApp()) {
	        return notCommon$1.getApp().getInterfaceManifest(modelName);
	      }
	      if (this.getOptions("manifest", undefined)) {
	        return this.getOptions("manifest", {});
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "manifest");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormData",
	    value: function getFormData() {
	      if (this.getData()) {
	        return this.getData();
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "data");
	        return {};
	      }
	    }
	  }, {
	    key: "getFormOptions",
	    value: function getFormOptions() {
	      if (this.getOptions("ui", undefined) || this.getOptions("fields", undefined)) {
	        return {
	          ui: this.getOptions("ui", {}),
	          fields: this.getOptions("fields", {})
	        };
	      } else {
	        _assertClassBrand(_notForm_brand, this, _missingOverrideWarning).call(this, "options");
	        return {
	          ui: {},
	          fields: {}
	        };
	      }
	    }
	  }, {
	    key: "getFormInjectedProps",
	    value: function getFormInjectedProps() {
	      return this.getOptions("injected", {});
	    }

	    /**
	     * Override empty message
	     **/
	  }, {
	    key: "collectData",
	    value:
	    /**
	     * Form operations
	     **/
	    function collectData() {
	      if (this.getOptions("readonly", false)) {
	        return this.getData();
	      }
	      const data = _classPrivateFieldGet2(_form$1, this).collectData();
	      this.setData({
	        ...data
	      }); //update in inner store
	      return data;
	    }
	  }, {
	    key: "updateField",
	    value: function updateField(fieldName, props) {
	      _classPrivateFieldGet2(_form$1, this).updateField(fieldName, props);
	    }
	  }, {
	    key: "getModel",
	    value: function getModel(name, data) {
	      if (typeof name === "string") {
	        return this.getInterface(name)(data || {});
	      } else {
	        return this.getInterface()(name || {});
	      }
	    }
	  }, {
	    key: "getInterface",
	    value: function getInterface(name = false) {
	      return notCommon$1.getApp().getInterface(name || this.getModelName());
	    }

	    /**
	     *  Returns current model name
	     *  @return {string}
	     */
	  }, {
	    key: "getModelName",
	    value: function getModelName() {
	      return this.getOptions("model");
	    }
	  }]);
	}(notBase);
	function _bindUIEvents() {
	  var _this2 = this;
	  _classPrivateFieldGet2(_form$1, this).$on("change", function () {
	    return _this2.validateForm();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("change", function (ev) {
	    _this2.emit("change", ev.detail);
	    _this2.emit(`change.${ev.detail.field}`, ev.detail.value);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("submit", function (ev) {
	    return _this2.submit(ev.detail);
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("reject", function () {
	    return _this2.reject();
	  });
	  _classPrivateFieldGet2(_form$1, this).$on("error", function ({
	    detail
	  }) {
	    return _this2.emit("error", detail);
	  });
	  _assertClassBrand(_notForm_brand, this, _bindMasterSlaveEvents).call(this);
	}
	function _bindMasterSlaveEvents() {
	  const masters = this.getOptions("masters", false);
	  if (!masters) {
	    return;
	  }
	  for (let master in masters) {
	    const rules = masters[master];
	    for (let ruleName in rules) {
	      const ruleSlaves = rules[ruleName];
	      _assertClassBrand(_notForm_brand, this, _addMasterSlaveEvents).call(this, ruleName, master, ruleSlaves);
	    }
	  }
	}
	function _addMasterSlaveEvents(rule, master, slaves = []) {
	  var _this3 = this;
	  this.on(`change.${master}`, function (value) {
	    _assertClassBrand(_notForm_brand, _this3, _execSlaveRule).call(_this3, rule, master, slaves, value);
	  });
	  this.emit(`change.${master}`, this.getFormData()[master]);
	}
	function _execSlaveRule(rule, master, slaves, value) {
	  var _this4 = this;
	  const cmd = notFormRules.exec(rule, master, slaves, value, this);
	  slaves.forEach(function (slaveField) {
	    _this4.updateField(slaveField, cmd);
	  });
	}
	function _getFormProps({
	  manifest,
	  //model manifest
	  formOptions = {
	    ui: {},
	    fields: {}
	  },
	  //some options
	  data = null,
	  //initial data for form
	  injectedProps = {}
	}) {
	  const action = _classPrivateFieldGet2(_action, this);
	  if (typeof formOptions === "undefined" || formOptions === null) {
	    formOptions = {
	      ui: {},
	      fields: {}
	    };
	  }
	  const form = FormHelpers.initFormByField(
	  //form seed object
	  {},
	  /*
	  Form structure
	  [
	  //each item is line of form
	  //field - field takes whole line of form
	  //[field1, field2] - few fields in one line
	  nameFirst, nameLast
	  [age, country, language],
	  [email, telephone]
	  ]
	  */
	  manifest.actions[action].fields,
	  //form fields structure
	  _classPrivateFieldGet2(_variants, this),
	  //variants library
	  _classPrivateFieldGet2(_fields, this),
	  //fields library
	  formOptions.fields,
	  //form wide fields options
	  data);
	  return {
	    //if no auto init of form structure, set to loading state
	    loading: !this.getOptions("autoInit", true),
	    title: manifest.actions[action].title,
	    description: manifest.actions[action].description,
	    fields: manifest.actions[action].fields,
	    form,
	    //injecting options to UI from top level input
	    ...formOptions.ui,
	    //form UI options
	    ...injectedProps
	  };
	}
	function _missingOverrideWarning(missing) {
	  this.error(`${missing} for ${this.getWorking("name")} form is not defined`);
	}

	var root$5 = template(`<div class="block-container"><div class="form-paper"></div> <!></div>`);

	function Form_set($$anchor, $$props) {
		push($$props, true);

		let dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [name]
		 * @property {boolean} [showModes]
		 * @property {string} [mode]
		 * @property {any} [forms]
		 */
		/** @type {Props} */
		let name = prop($$props, 'name', 3, 'default-form'),
			showModes = prop($$props, 'showModes', 3, false),
			mode = prop($$props, 'mode', 15, 'default'),
			forms = prop($$props, 'forms', 19, () => []);

		function setMode(val) {
			mode(val);
			dispatch('mode', val);
			updateModesButtons();
		}

		let FORMS_BUTTONS = state(proxy([]));

		function updateModesButtons() {
			set(FORMS_BUTTONS, proxy(forms().filter((form) => {
				return mode() !== form.mode;
			}).map((form) => {
				return {
					title: form.title,
					outlined: true,
					type: 'link',
					action() {
						setMode(form.mode);
					}
				};
			})));
		}

		onMount(() => {
			updateModesButtons();
		});

		var div = root$5();
		var div_1 = child(div);
		var node = sibling(div_1, 2);

		{
			var consequent = ($$anchor) => {
				Ui_buttons($$anchor, {
					centered: true,
					classes: 'mt-4',
					get values() {
						return get$3(FORMS_BUTTONS);
					},
					set values($$value) {
						set(FORMS_BUTTONS, proxy($$value));
					}
				});
			};

			if_block(node, ($$render) => {
				if (showModes()) $$render(consequent);
			});
		}

		reset(div);

		template_effect(() => {
			set_attribute(div, 'id', `${name() ?? ''}-form-set`);
			set_attribute(div_1, 'id', `${name() ?? ''}-form-set-container`);
		});

		append($$anchor, div);
		pop();
	}

	const DEFAULT_CONTAINER_SELECTOR = ".form-set";
	const DEFAULT_FORM_SET_NAME = "form-set";
	var _formSetComponent = /*#__PURE__*/new WeakMap();
	var _formComponent = /*#__PURE__*/new WeakMap();
	var _form = /*#__PURE__*/new WeakMap();
	var _frame = /*#__PURE__*/new WeakMap();
	var _notFormSet_brand = /*#__PURE__*/new WeakSet();
	let notFormSet = /*#__PURE__*/function (_notBase) {
	  /*
	  new notFormSet({
	  options:{
	    target: el,
	    forms: [{
	      mode: 'form1',
	      title: 'Form 1',
	      form: formConstructor1 //custom constructors
	    },{
	      mode: 'form2',
	      title: 'Form 2',
	      props: {}             //params to create notForm instance
	    },{
	      mode: 'form3',
	      title: 'Form 3',
	      form: formConstructor3 //custom constructors
	    }]
	  }
	  });
	  */

	  function notFormSet({
	    options = {},
	    formComponent = Form,
	    formSetComponent = Form_set
	  }) {
	    var _this;
	    _classCallCheck(this, notFormSet);
	    _this = _callSuper(this, notFormSet, [{
	      options: {
	        name: DEFAULT_FORM_SET_NAME,
	        mode: "default",
	        showModes: true,
	        ...options
	      }
	    }]);
	    _classPrivateMethodInitSpec(_this, _notFormSet_brand);
	    _classPrivateFieldInitSpec(_this, _formSetComponent, null);
	    _classPrivateFieldInitSpec(_this, _formComponent, null);
	    _classPrivateFieldInitSpec(_this, _form, null);
	    _classPrivateFieldInitSpec(_this, _frame, null);
	    _classPrivateFieldSet2(_formComponent, _this, formComponent);
	    _classPrivateFieldSet2(_formSetComponent, _this, formSetComponent);
	    _this.setFormMode(_this.getOptions("mode"));
	    _this.initUI();
	    return _this;
	  }

	  /**
	   * Initalizing form frame mode, with switchers between modes
	   **/
	  _inherits(notFormSet, _notBase);
	  return _createClass(notFormSet, [{
	    key: "initUI",
	    value: function initUI() {
	      var _this2 = this;
	      const target = this.getFrameTargetEl();
	      while (target.children.length) target.removeChild(target.firstChild);
	      _classPrivateFieldSet2(_frame, this, new (_classPrivateFieldGet2(_formSetComponent, this))({
	        target,
	        props: _assertClassBrand(_notFormSet_brand, this, _getFrameProps).call(this)
	      }));
	      _classPrivateFieldGet2(_frame, this).$on("mode", function (ev) {
	        _this2.setFormMode(ev.detail);
	        _this2.updateForm();
	      });
	      this.updateForm();
	    }
	  }, {
	    key: "setFormMode",
	    value: function setFormMode(name) {
	      if (this.isModeExists(name)) {
	        this.setWorking("mode", name);
	      } else {
	        this.setWorking("mode", this.getFirstMode());
	        this.updateFormModeInUI();
	      }
	    }
	  }, {
	    key: "updateFormModeInUI",
	    value: function updateFormModeInUI() {
	      if (_classPrivateFieldGet2(_frame, this) && this.getWorking("mode") !== null) {
	        _classPrivateFieldGet2(_frame, this).$set({
	          mode: this.getWorking("mode")
	        });
	      }
	    }
	  }, {
	    key: "getFormMode",
	    value: function getFormMode() {
	      return this.getWorking("mode");
	    }
	  }, {
	    key: "updateForm",
	    value: function updateForm() {
	      this.destroyForm();
	      if (this.getWorking("mode") !== null) {
	        this.renderForm();
	      }
	    }
	  }, {
	    key: "renderForm",
	    value: function renderForm() {
	      var _this3 = this;
	      const targetEl = this.getFormTargetEl();
	      const formConfig = this.getFormConfig();
	      if (!(targetEl instanceof HTMLElement && formConfig)) {
	        throw new Error("error while form rendering");
	      }
	      const changeMode = function (mode) {
	        _this3.setFormMode(mode);
	        _this3.updateForm();
	      };
	      if (formConfig.form) {
	        while (targetEl.children.length) targetEl.removeChild(targetEl.firstChild);
	        _classPrivateFieldSet2(_form, this, new formConfig.form({
	          options: {
	            target: targetEl,
	            changeMode
	          }
	        }));
	      } else if (formConfig.props) {
	        _classPrivateFieldSet2(_form, this, new (_classPrivateFieldGet2(_formComponent, this))({
	          target: targetEl,
	          ...formConfig.props,
	          changeMode
	        }));
	      }
	    }
	  }, {
	    key: "getFormConfig",
	    value: function getFormConfig() {
	      var _this4 = this;
	      return this.getOptions("forms").find(function (form) {
	        return form.mode === _this4.getFormMode();
	      });
	    }
	  }, {
	    key: "destroyForm",
	    value: function destroyForm() {
	      const containerEl = this.getFormTargetEl();
	      if (containerEl) {
	        while (containerEl.firstChild) {
	          containerEl.removeChild(containerEl.lastChild);
	        }
	      }
	      if (_classPrivateFieldGet2(_form, this) && _classPrivateFieldGet2(_form, this).$destroy) {
	        _classPrivateFieldGet2(_form, this).$destroy();
	      }
	      _classPrivateFieldSet2(_form, this, null);
	    }
	  }, {
	    key: "destroyFrame",
	    value: function destroyFrame() {
	      if (_classPrivateFieldGet2(_frame, this) && _classPrivateFieldGet2(_frame, this).$destroy) {
	        _classPrivateFieldGet2(_frame, this).$destroy();
	      }
	      _classPrivateFieldSet2(_frame, this, null);
	    }
	  }, {
	    key: "isModeExists",
	    value: function isModeExists(mode) {
	      const forms = this.getOptions("forms", []);
	      return forms.some(function (item) {
	        return item.mode === mode;
	      });
	    }
	  }, {
	    key: "getFirstMode",
	    value: function getFirstMode() {
	      const forms = this.getOptions("forms", []);
	      if (forms.length > 0) {
	        return forms[0].mode;
	      }
	      return null;
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      _classPrivateFieldSet2(_formSetComponent, this, null);
	      _classPrivateFieldSet2(_formComponent, this, null);
	      this.destroyForm();
	      this.destroyFrame();
	      this.setData(null);
	      this.setOptions(null);
	      this.setWorking(null);
	    }
	  }, {
	    key: "getFrameTargetEl",
	    value: function getFrameTargetEl() {
	      const target = this.getOptions("target", DEFAULT_CONTAINER_SELECTOR);
	      if (target instanceof HTMLElement) {
	        return target;
	      } else if (typeof target === "string") {
	        return document.querySelector(target);
	      } else {
	        throw new Error("form set target is not HTMLElement or string");
	      }
	    }
	  }, {
	    key: "getFormTargetEl",
	    value: function getFormTargetEl() {
	      const name = this.getOptions("name", DEFAULT_FORM_SET_NAME);
	      return document.querySelector(`#${name}-form-set-container`);
	    }
	  }]);
	}(notBase);
	function _getFrameProps() {
	  return {
	    showModes: this.getOptions("showModes", true),
	    mode: this.getFormMode(),
	    forms: this.getOptions("forms", []),
	    name: this.getOptions("name", DEFAULT_FORM_SET_NAME)
	  };
	}

	function onClick$5(ev, go) {
		if (typeof go() === 'function') {
			ev.preventDefault();
			go()(ev.currentTarget.dataset.href);
			return false;
		} else {
			return true;
		}
	}

	var root_3$3 = template(`<li class="is-active"><a aria-current="page"> </a></li>`);
	var root_5$2 = template(`<li class="is-plain-crumb"> </li>`);
	var root_6$1 = template(`<li><a> </a></li>`);
	var root_1$4 = template(`<nav class="breadcrumb" aria-label="breadcrumbs"><ul></ul></nav>`);

	function Ui_breadcrumbs($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [go]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ''),
			items = prop($$props, 'items', 19, () => []),
			go = prop($$props, 'go', 3, null);

		var nav = root_1$4();
		var ul = child(nav);

		each(ul, 21, items, index$d, ($$anchor, link, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent = ($$anchor) => {
					var li = root_3$3();
					var a = child(li);
					var text = child(a, true);

					reset(a);
					reset(li);

					template_effect(() => {
						set_attribute(a, 'href', `${root() ?? ''}${get$3(link).url ?? ''}`);
						set_attribute(a, 'data-href', get$3(link).url);
						set_text(text, $LOCALE()[get$3(link).title]);
					});

					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					var fragment_1 = comment();
					var node_1 = first_child(fragment_1);

					{
						var consequent_1 = ($$anchor) => {
							var li_1 = root_5$2();
							var text_1 = child(li_1, true);

							reset(li_1);
							template_effect(() => set_text(text_1, $LOCALE()[get$3(link).title]));
							append($$anchor, li_1);
						};

						var alternate = ($$anchor) => {
							var li_2 = root_6$1();
							var a_1 = child(li_2);

							a_1.__click = [onClick$5, go];

							var text_2 = child(a_1, true);

							reset(a_1);
							reset(li_2);

							template_effect(() => {
								set_attribute(a_1, 'href', `${root() ?? ''}${get$3(link).url ?? ''}`);
								set_attribute(a_1, 'data-href', get$3(link).url);
								set_text(text_2, $LOCALE()[get$3(link).title]);
							});

							append($$anchor, li_2);
						};

						if_block(node_1, ($$render) => {
							if (get$3(link).url === false) $$render(consequent_1); else $$render(alternate, false);
						});
					}

					append($$anchor, fragment_1);
				};

				if_block(node, ($$render) => {
					if (items().length === index + 1) $$render(consequent); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		reset(nav);
		append($$anchor, nav);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	let notBreadcrumbs = /*#__PURE__*/function () {
	  function notBreadcrumbs() {
	    _classCallCheck(this, notBreadcrumbs);
	  }
	  return _createClass(notBreadcrumbs, null, [{
	    key: "render",
	    value: function render({
	      target,
	      root = '',
	      navigate
	    }) {
	      this.remove();
	      if (notBreadcrumbs.UIConstructor) {
	        this.ui = new notBreadcrumbs.UIConstructor({
	          target,
	          props: {
	            items: this.getBreadcrumbs(),
	            root: root,
	            go: navigate
	          }
	        });
	      }
	    }
	  }, {
	    key: "setHead",
	    value: function setHead(head) {
	      this.head.splice(0, this.head.length, ...head);
	      return this;
	    }
	  }, {
	    key: "setTail",
	    value: function setTail(tail) {
	      this.tail.splice(0, this.tail.length, ...tail);
	      return this;
	    }
	  }, {
	    key: "getBreadcrumbs",
	    value: function getBreadcrumbs() {
	      let crumbs = [];
	      crumbs.push(...this.head);
	      crumbs.push(...this.tail);
	      return crumbs;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.ui) {
	        this.ui.$set({
	          items: this.getBreadcrumbs()
	        });
	      }
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.ui) {
	        this.ui.$destroy();
	        this.ui = null;
	      }
	      return this;
	    }
	  }]);
	}();
	_defineProperty(notBreadcrumbs, "UIConstructor", null);
	_defineProperty(notBreadcrumbs, "ui", null);
	_defineProperty(notBreadcrumbs, "head", []);
	_defineProperty(notBreadcrumbs, "tail", []);

	notBreadcrumbs.UIConstructor = Ui_breadcrumbs;

	var _Menu;
	let Menu = /*#__PURE__*/function () {
	  function Menu() {
	    _classCallCheck(this, Menu);
	  }
	  return _createClass(Menu, null, [{
	    key: "hide",
	    value: function hide() {}
	  }, {
	    key: "setApp",
	    value: function setApp(app) {
	      if (!this.app) {
	        this.app = app;
	      }
	      return this;
	    }
	  }, {
	    key: "setOptions",
	    value: function setOptions(options) {
	      this.options = {
	        ...this.options,
	        ...options
	      };
	      return this;
	    }
	  }, {
	    key: "getOptionsPathTo",
	    value: function getOptionsPathTo(what) {
	      return `menu.${this.options.type}.${what}`;
	    }
	  }, {
	    key: "isDirectNavigation",
	    value: function isDirectNavigation() {
	      return this.app ? this.app.getOptions(this.getOptionsPathTo("directNavigation"), this.options.directNavigation) : this.options.directNavigation;
	    }
	  }, {
	    key: "getOptions",
	    value: function getOptions() {
	      if (this.app) {
	        return {
	          brand: this.app.getOptions("brand", this.options.brand),
	          items: this.app.getOptions(this.getOptionsPathTo("items"), this.options.items),
	          sections: this.app.getOptions(this.getOptionsPathTo("sections"), this.options.sections),
	          targetSelector: this.app.getOptions(this.getOptionsPathTo("targetSelector"), this.options.targetSelector),
	          toggleSelector: this.app.getOptions(this.getOptionsPathTo("toggleSelector"), this.options.toggleSelector),
	          open: this.app.getOptions(this.getOptionsPathTo("open"), this.options.open),
	          directNavigation: this.app.getOptions(this.getOptionsPathTo("directNavigation"), this.options.directNavigation),
	          root: this.app.getOptions("router.root", this.options.root),
	          navigate: this.options.navigate.bind(this),
	          getComponent: this.getComponent.bind(this)
	        };
	      } else {
	        return this.options;
	      }
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(name) {
	      if (COMPONENTS$1.contains(name)) {
	        return COMPONENTS$1.get(name);
	      } else {
	        return false;
	      }
	    }
	  }, {
	    key: "initField",
	    value: function initField(list, fields = []) {
	      var _this = this;
	      list.forEach(function (item) {
	        fields.forEach(function (field) {
	          if (!Object.hasOwn(item, field)) {
	            item[field] = _this.DEFAULT[field];
	          }
	        });
	        if (Object.hasOwn(item, "items")) {
	          _this.initField(item.items, fields);
	        }
	      });
	    }
	  }, {
	    key: "sortList",
	    value: function sortList(list) {
	      var _this2 = this;
	      list.sort(function (item1, item2) {
	        if (Object.hasOwn(item1, "items")) {
	          _this2.sortList(item1.items);
	        }
	        if (Object.hasOwn(item2, "items")) {
	          _this2.sortList(item2.items);
	        }
	        if (item1.priority === item2.priority) {
	          return item1.title > item2.title ? 1 : -1;
	        } else {
	          return item1.priority < item2.priority ? 1 : -1;
	        }
	      });
	    }
	  }, {
	    key: "removeDublicates",
	    value: function removeDublicates(sections) {
	      for (let i = 0; i < sections.length; i++) {
	        let priority = sections[i].priority;
	        sections.filter(function (section) {
	          return section.id === sections[i].id;
	        }).forEach(function (item, indx) {
	          if (indx === 0) {
	            return;
	          }
	          if (item.priority < priority) {
	            priority = item.priority;
	          }
	          sections.splice(sections.indexOf(item), 1);
	        });
	        sections[i].priority = priority;
	      }
	      return sections;
	    }
	  }, {
	    key: "prepareData",
	    value: function prepareData() {
	      let items = [];
	      items.push(...this.getOptions().items);
	      let sections = [];
	      sections.push(...this.getOptions().sections);
	      this.initField(sections, ["priority"]);
	      this.removeDublicates(sections);
	      this.initField(items, ["priority", "section", "type"]);
	      this.sortList(sections);
	      sections.push({
	        id: this.DEFAULT.section,
	        title: this.DEFAULT.sectionTitle
	      });
	      this.sortList(items);
	      this.sections = sections;
	      this.items = items;
	    }
	  }, {
	    key: "remove",
	    value: function remove() {
	      if (this.menu) {
	        this.menu.$destroy();
	        this.menu = null;
	        clearInterval(this.interval);
	      }
	    }
	  }, {
	    key: "updateIndicator",
	    value: function updateIndicator(sectionId, itemId, state) {
	      this.updateSection(sectionId, function (section) {
	        section.indicator.state = state;
	      });
	      this.updateItem(itemId, function (item) {
	        item.indicator.state = state;
	      });
	    }
	  }, {
	    key: "updateTag",
	    value: function updateTag(sectionId, itemId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = tag;
	      });
	      this.updateItem(itemId, function (item) {
	        item.tag = tag;
	      });
	    }
	  }, {
	    key: "updateSectionTag",
	    value: function updateSectionTag(sectionId, tag) {
	      this.updateSection(sectionId, function (section) {
	        section.tag = {
	          ...section.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateItemTag",
	    value: function updateItemTag(itemId, tag) {
	      this.updateItem(itemId, function (item) {
	        item.tag = {
	          ...item.tag,
	          ...tag
	        };
	      });
	    }
	  }, {
	    key: "updateSection",
	    value: function updateSection(sectionId, proc) {
	      if (this.sections && sectionId) {
	        for (let section in this.sections) {
	          if (this.sections[section].id !== sectionId) continue;
	          proc(this.sections[section]);
	        }
	        if (this.menu) {
	          this.menu.$set({
	            sections: this.sections
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateSectionItems",
	    value: function updateSectionItems(sectionId, proc) {
	      if (this.sections && sectionId) {
	        let oldList = this.items.filter(function (item) {
	          return item.section === sectionId;
	        });
	        for (let i of oldList) {
	          this.items.splice(this.items.indexOf(i), 1);
	        }
	        this.items.push(...proc(oldList));
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "updateItem",
	    value: function updateItem(itemId, proc) {
	      if (itemId && this.items) {
	        this.items.forEach(function (item) {
	          if (item.id !== itemId) return;
	          proc(item);
	        });
	        if (this.menu) {
	          this.menu.$set({
	            items: this.items
	          });
	        }
	      }
	    }
	  }, {
	    key: "isTouch",
	    value: function isTouch() {
	      return UICommon$1.isMobile(true);
	    }
	  }, {
	    key: "getSectionComponent",
	    value: function getSectionComponent() {}
	  }]);
	}();
	_Menu = Menu;
	_defineProperty(Menu, "MAX_TOUCH_WIDTH", 1023);
	_defineProperty(Menu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  open: false
	});
	/**
	 *
	 * @type {import('../../app.js').default | null}
	 * @static
	 * @memberof Menu
	 */
	_defineProperty(Menu, "app", null);
	_defineProperty(Menu, "directNavigation", false);
	_defineProperty(Menu, "menu", void 0);
	_defineProperty(Menu, "options", {
	  directNavigation: false,
	  navigate: function (urls) {
	    _Menu.hide();
	    if (!_Menu.isDirectNavigation() && _Menu.app) {
	      let func = _Menu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});
	_defineProperty(Menu, "items", []);
	_defineProperty(Menu, "sections", []);
	_defineProperty(Menu, "location", void 0);
	_defineProperty(Menu, "interval", void 0);

	function onClick$4(ev, onnavigate) {
		ev.preventDefault();

		onnavigate()({
			full: ev.target.getAttribute("href"),
			short: ev.target.dataset.href
		});

		return false;
	}

	var root_2$2 = template(`<li><a> <!> <!></a></li>`);
	var root_5$1 = template(`<li> <!> <!></li>`);

	function Ui_item_without_children($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			item = prop($$props, 'item', 19, () => ({})),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent_2 = ($$anchor) => {
				var li = root_2$2();
				var a = child(li);

				a.__click = [onClick$4, onnavigate];

				var text = child(a);
				var node_1 = sibling(text);

				{
					var consequent = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_1, ($$render) => {
						if (item().tag) $$render(consequent);
					});
				}

				var node_2 = sibling(node_1, 2);

				{
					var consequent_1 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_2, ($$render) => {
						if (item().indicator) $$render(consequent_1);
					});
				}

				reset(a);
				reset(li);

				template_effect(() => {
					set_class(li, clsx(item().classes));
					set_attribute(a, 'href', `${root() ?? ''}${item().url ?? ''}`);
					set_attribute(a, 'data-href', item().url);
					set_text(text, `${$LOCALE()[item().title] ?? ''} `);
				});

				append($$anchor, li);
			};

			var alternate = ($$anchor) => {
				var li_1 = root_5$1();
				var text_1 = child(li_1);
				var node_3 = sibling(text_1);

				{
					var consequent_3 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().tag
						));
					};

					if_block(node_3, ($$render) => {
						if (item().tag) $$render(consequent_3);
					});
				}

				var node_4 = sibling(node_3, 2);

				{
					var consequent_4 = ($$anchor) => {
						Ui_indicator($$anchor, spread_props(
							{
								get id() {
									return item().id;
								}
							},
							() => item().indicator
						));
					};

					if_block(node_4, ($$render) => {
						if (item().indicator) $$render(consequent_4);
					});
				}

				reset(li_1);

				template_effect(() => {
					set_class(li_1, `is-no-follow-subtitle ${item().classes ?? ''}`);
					set_text(text_1, `${$LOCALE()[item().title] ?? ''} `);
				});

				append($$anchor, li_1);
			};

			if_block(node, ($$render) => {
				if (typeof item().url !== "undefined" && item().url !== false) $$render(consequent_2); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	delegate(['click']);

	function onClick$3(e, closed, ontoggle) {
		e && e.preventDefault() && e.stopPropagation();
		closed(!closed());

		if (!ontoggle()(closed())) {
			closed(!closed());
		}

		return false;
	}

	var root$4 = template(`<span class="icon is-small is-toggle-submenu is-pulled-right" role="button" tabindex="0"><i aria-hidden="true"></i></span>`);

	function Ui_trigger($$anchor, $$props) {
		push($$props, true);

		const CLASS_ICON = {
			OPENED: "fa-angle-down",
			CLOSED: "fa-angle-up"
		};

		/**
		 * @typedef {Object} Props
		 * @property {any} [icon_opened]
		 * @property {any} [icon_closed]
		 * @property {boolean} [closed]    returns if we should apply toggle or if false - reject it and toggle backward
		 */
		/** @type {Props} */
		let icon_opened = prop($$props, 'icon_opened', 19, () => CLASS_ICON.OPENED),
			icon_closed = prop($$props, 'icon_closed', 19, () => CLASS_ICON.CLOSED),
			closed = prop($$props, 'closed', 7),
			ontoggle = prop($$props, 'ontoggle', 3, () => {
				return true;
			});

		var span = root$4();

		span.__click = [onClick$3, closed, ontoggle];
		span.__keyup = [onClick$3, closed, ontoggle];

		var i = child(span);

		reset(span);
		template_effect(() => set_class(i, `fas ${(closed() ? icon_closed() : icon_opened()) ?? ''}`));
		append($$anchor, span);
		pop();
	}

	delegate(['click', 'keyup']);

	var root_4$2 = template(`<span class="is-no-link"> </span>`);
	var root$3 = template(`<!> <!> <!> <!>`, 1);

	function Ui_item_label($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		let item = prop($$props, 'item', 19, () => ({}));
		var fragment = root$3();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon_font($$anchor, spread_props(() => item().icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent = derived(() => COMPONENTS$1.get(item().component));
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get id() {
										return item().id;
									}
								},
								() => item().props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var span = root_4$2();
						var text = child(span, true);

						reset(span);
						template_effect(() => set_text(text, $LOCALE()[item().title]));
						append($$anchor, span);
					};

					if_block(
						node_1,
						($$render) => {
							if (item().type === "component" && item().component && COMPONENTS$1.contains(item().component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (item().icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().tag
				));
			};

			if_block(node_3, ($$render) => {
				if (item().tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return item().id;
						}
					},
					() => item().indicator
				));
			};

			if_block(node_4, ($$render) => {
				if (item().indicator) $$render(consequent_3);
			});
		}

		var node_5 = sibling(node_4, 2);

		snippet(node_5, () => $$props.children ?? noop);
		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function onClick$2(ev, onnavigate) {
		ev.preventDefault();

		onnavigate()({
			full: ev.target.getAttribute("href"),
			short: ev.target.dataset.href
		});

		return false;
	}

	var root_4$1 = template(`<a class="has-subitems"><!></a>`);
	var root_3$2 = template(`<li><!> <!></li>`);
	var root_1$3 = template(`<ul></ul>`);

	function Ui_items_1($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {boolean} [closed]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		const createClosedItemsLib = (lst) => {
			const lib = {};

			lst.forEach((itm, index) => lib[index] = itm.closed);
			return lib;
		};

		let closedChildren = proxy(createClosedItemsLib(items()));
		var ul = root_1$3();

		each(ul, 21, items, index$d, ($$anchor, item, index) => {
			var fragment = comment();
			var node = first_child(fragment);

			{
				var consequent_1 = ($$anchor) => {
					var li = root_3$2();
					var node_1 = child(li);

					{
						var consequent = ($$anchor) => {
							var a = root_4$1();

							a.__click = [onClick$2, onnavigate];

							var node_2 = child(a);

							Ui_item_label(node_2, {
								get item() {
									return get$3(item);
								},
								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},
										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},
								$$slots: { default: true }
							});

							reset(a);

							template_effect(() => {
								set_attribute(a, 'href', `${root() ?? ''}${get$3(item).url ?? ''}`);
								set_attribute(a, 'data-href', get$3(item).url);
							});

							append($$anchor, a);
						};

						var alternate = ($$anchor) => {
							Ui_item_label($$anchor, {
								get item() {
									return get$3(item);
								},
								children: ($$anchor, $$slotProps) => {
									Ui_trigger($$anchor, {
										get closed() {
											return closedChildren[index];
										},
										set closed($$value) {
											closedChildren[index] = $$value;
										}
									});
								},
								$$slots: { default: true }
							});
						};

						if_block(node_1, ($$render) => {
							if (typeof get$3(item).url !== "undefined" && get$3(item).url !== false) $$render(consequent); else $$render(alternate, false);
						});
					}

					var node_3 = sibling(node_1, 2);

					Ui_items_1(node_3, {
						get root() {
							return root();
						},
						get items() {
							return get$3(item).items;
						},
						get onnavigate() {
							return onnavigate();
						},
						get closed() {
							return closedChildren[index];
						},
						set closed($$value) {
							closedChildren[index] = $$value;
						}
					});

					reset(li);
					template_effect(() => set_class(li, `is-no-follow-subtitle ${get$3(item).classes ?? ''}`));
					append($$anchor, li);
				};

				var alternate_1 = ($$anchor) => {
					Ui_item_without_children($$anchor, {
						get root() {
							return root();
						},
						get item() {
							return get$3(item);
						},
						get onnavigate() {
							return onnavigate();
						}
					});
				};

				if_block(node, ($$render) => {
					if (get$3(item).items && get$3(item).items.length) $$render(consequent_1); else $$render(alternate_1, false);
				});
			}

			append($$anchor, fragment);
		});

		reset(ul);
		template_effect(() => set_class(ul, `menu-list ${($$props.closed ? 'is-closed' : '') ?? ''}`));
		append($$anchor, ul);
		pop();
	}

	delegate(['click']);

	var root_3$1 = template(`<p><!> <!> <!></p>`);
	var root_1$2 = template(`<!> <!>`, 1);

	function Ui_section$1($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);

		/**
		 * @typedef {Object} Props
		 * @property {any}      section
		 * @property {any}      [items]
		 * @property {string}   [root]
		 * @property {function} [onnavigate]
		 */
		/** @type {Props} */
		let items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			onnavigate = prop($$props, 'onnavigate', 3, () => {});

		let sectionItems = derived(() => items().filter((item) => $$props.section.id === item.section));
		var fragment = root_1$2();
		var node = first_child(fragment);

		{
			var consequent_4 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_3 = ($$anchor) => {
						var p = root_3$1();
						var node_2 = child(p);

						{
							var consequent = ($$anchor) => {
								var fragment_2 = comment();
								const SvelteComponent = derived(() => COMPONENTS$1.get($$props.section.component));
								var node_3 = first_child(fragment_2);

								component(node_3, () => get$3(SvelteComponent), ($$anchor, $$component) => {
									$$component($$anchor, spread_props(
										{
											get id() {
												return $$props.section.id;
											}
										},
										() => $$props.section.props
									));
								});

								append($$anchor, fragment_2);
							};

							var alternate = ($$anchor) => {
								var text$1 = text();

								template_effect(() => set_text(text$1, $LOCALE()[$$props.section.title]));
								append($$anchor, text$1);
							};

							if_block(node_2, ($$render) => {
								if ($$props.section.type === "component" && $$props.section.component && COMPONENTS$1.contains($$props.section.component)) $$render(consequent); else $$render(alternate, false);
							});
						}

						var node_4 = sibling(node_2, 2);

						{
							var consequent_1 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.tag
								));
							};

							if_block(node_4, ($$render) => {
								if ($$props.section.tag) $$render(consequent_1);
							});
						}

						var node_5 = sibling(node_4, 2);

						{
							var consequent_2 = ($$anchor) => {
								Ui_indicator($$anchor, spread_props(
									{
										get id() {
											return $$props.section.id;
										}
									},
									() => $$props.section.indicator
								));
							};

							if_block(node_5, ($$render) => {
								if ($$props.section.indicator) $$render(consequent_2);
							});
						}

						reset(p);
						template_effect(() => set_class(p, `menu-label ${$$props.section.classes ?? ''}`));
						append($$anchor, p);
					};

					if_block(node_1, ($$render) => {
						if (get$3(sectionItems).length || $$props.section.component || $$props.section.tag || $$props.section.indicator) $$render(consequent_3);
					});
				}

				append($$anchor, fragment_1);
			};

			if_block(node, ($$render) => {
				if ($$props.section) $$render(consequent_4);
			});
		}

		var node_6 = sibling(node, 2);

		{
			var consequent_5 = ($$anchor) => {
				Ui_items_1($$anchor, {
					get root() {
						return root();
					},
					get items() {
						return get$3(sectionItems);
					},
					get onnavigate() {
						return onnavigate();
					}
				});
			};

			if_block(node_6, ($$render) => {
				if (get$3(sectionItems).length) $$render(consequent_5);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function Ui_side_menu($$anchor, $$props) {
		push($$props, true);

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [items]
		 * @property {any} [sections]
		 * @property {any} [navigate = ()=>undefined]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			items = prop($$props, 'items', 19, () => []),
			sections = prop($$props, 'sections', 19, () => []),
			navigate = prop($$props, 'navigate', 3, null);

		function onClick(ev) {
			if (typeof navigate() === "function") {
				navigate()(ev);
			}
		}

		var fragment = comment();
		var node = first_child(fragment);

		each(node, 17, sections, index$d, ($$anchor, section) => {
			Ui_section$1($$anchor, {
				get section() {
					return get$3(section);
				},
				get items() {
					return items();
				},
				get root() {
					return root();
				},
				onnavigate: onClick
			});
		});

		append($$anchor, fragment);
		pop();
	}

	const SideMenuState = writable({
	  open: true
	});

	var _notSideMenu;
	const TYPE$1 = "side";
	let notSideMenu = /*#__PURE__*/function (_Menu) {
	  function notSideMenu() {
	    _classCallCheck(this, notSideMenu);
	    return _callSuper(this, notSideMenu, arguments);
	  }
	  _inherits(notSideMenu, _Menu);
	  return _createClass(notSideMenu, null, [{
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        this.createUI();
	      }
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      if (this.menu) {
	        this.menu.$destroy();
	        this.createUI();
	      }
	    }
	  }, {
	    key: "createUI",
	    value: function createUI() {
	      let target = document.querySelector(this.getOptions().targetSelector);
	      if (!target) {
	        return;
	      }
	      this.menu = mount(Ui_side_menu, {
	        target,
	        props: {
	          items: this.items,
	          sections: this.sections,
	          root: this.getOptions().root,
	          navigate: this.getOptions().navigate
	        }
	      });
	      this.initSizeResponse();
	      this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	      this.bindToggle();
	    }
	  }, {
	    key: "itemIsActive",
	    value: function itemIsActive(itemURL) {
	      return (this.location + "/").indexOf(itemURL + "/") > -1;
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu() {
	      var _this = this;
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " a")).forEach(function (item) {
	        if (_this.itemIsActive(item.getAttribute("href"))) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu();
	        }
	      } else {
	        this.location = url;
	        this.updateMenu();
	      }
	    }
	  }, {
	    key: "initSizeResponse",
	    value: function initSizeResponse() {
	      this.nav = document.querySelector("nav.navbar");
	      this.aside = document.querySelector("aside");
	      this.main = document.querySelector("main");
	      this.resizeAsideAndMain(this.aside, this.main, this.nav);
	      this.resizeMain(this.main, this.aside);
	      window.addEventListener("resize", this.resizeMain.bind(this));
	      if (this.isTouch()) {
	        if (this.getOptions().open) {
	          this.show();
	        } else {
	          this.hide();
	        }
	      }
	    }
	  }, {
	    key: "resizeMain",
	    value: function resizeMain() {
	      if (this.isTouch()) {
	        if (this.aside.classList.contains("is-active")) {
	          this.main.style.display = "none";
	        } else {
	          this.main.style.display = "block";
	          this.main.style.marginLeft = "0px";
	        }
	      } else {
	        let rect = this.aside.getBoundingClientRect();
	        this.main.style.display = "block";
	        if (this.main.style.height === "0px") {
	          this.main.style.height = "auto";
	        }
	        this.main.style.marginLeft = rect.width + rect.left + "px";
	      }
	    }
	  }, {
	    key: "resizeAside",
	    value: function resizeAside() {
	      if (this.aside.style.display !== "none") {
	        let rect = this.nav.getBoundingClientRect();
	        this.aside.style.height = window.innerHeight - rect.height + "px";
	        this.aside.style.marginTop = rect.height + "px";
	      }
	    }
	  }, {
	    key: "resizeAsideAndMain",
	    value: function resizeAsideAndMain() {
	      let rect = this.nav.getBoundingClientRect();
	      this.aside.style.height = window.innerHeight - rect.height + "px";
	      //this.aside.style.paddingTop = (rect.height) + 'px';
	      //this.main.style.marginTop = (rect.height) + 'px';
	    }
	  }, {
	    key: "bindToggle",
	    value: function bindToggle() {
	      var _this2 = this;
	      let els = document.querySelectorAll(this.getOptions().toggleSelector);
	      Array.from(els).forEach(function (el) {
	        el.removeEventListener("click", _this2.toggle.bind(_this2));
	        el.addEventListener("click", _this2.toggle.bind(_this2));
	      });
	    }
	  }, {
	    key: "toggle",
	    value: function toggle(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.toggle("is-active");
	        } else {
	          this.aside.classList.toggle("is-closed");
	        }
	        this.resizeMain();
	      }
	      return false;
	    }
	  }, {
	    key: "hide",
	    value: function hide(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.remove("is-active");
	        } else {
	          this.aside.classList.add("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = false;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "show",
	    value: function show(e) {
	      e && e.preventDefault();
	      if (this.aside) {
	        if (this.isTouch()) {
	          this.aside.classList.add("is-active");
	        } else {
	          this.aside.classList.remove("is-closed");
	        }
	        this.resizeMain();
	      }
	      SideMenuState.update(function (val) {
	        val.open = true;
	        return val;
	      });
	      return false;
	    }
	  }, {
	    key: "isOpen",
	    value: function isOpen() {
	      if (this.aside) {
	        if (this.isTouch()) {
	          return this.aside.classList.contains("is-active");
	        } else {
	          return !this.aside.classList.contains("is-closed");
	        }
	      } else {
	        return true;
	      }
	    }
	  }]);
	}(Menu);
	_notSideMenu = notSideMenu;
	_defineProperty(notSideMenu, "nav", void 0);
	_defineProperty(notSideMenu, "main", void 0);
	_defineProperty(notSideMenu, "aside", void 0);
	_defineProperty(notSideMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  open: true,
	  type: "link"
	});
	_defineProperty(notSideMenu, "options", {
	  directNavigation: false,
	  type: TYPE$1,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE$1}-menu`,
	  toggleSelector: `.${TYPE$1}-menu-toggle`,
	  root: "/",
	  open: true,
	  navigate: function (urls) {
	    if (_notSideMenu.isTouch()) {
	      _notSideMenu.hide();
	      _notSideMenu.app && _notSideMenu.app.emit("top-navbar-burger:update", {
	        closed: true
	      });
	    }
	    if (!_notSideMenu.isDirectNavigation() && _notSideMenu.app) {
	      let func = _notSideMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	var root$2 = template(`<a class="navbar-item"><!> <!></a>`);

	function Ui_brand($$anchor, $$props) {
		/**
		 * @typedef {Object} Props
		 * @property {string} [url]
		 * @property {string} [title]
		 * @property {any} [icon]
		 */
		/** @type {Props} */
		let url = prop($$props, 'url', 3, "/"),
			title = prop($$props, 'title', 3, ""),
			icon = prop($$props, 'icon', 19, () => ({
				src: "https://via.placeholder.com/56x28",
				width: 28,
				height: 56
			}));

		var a = root$2();
		var node = child(a);

		Ui_icon(node, spread_props(icon));

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				var fragment = comment();
				var node_2 = first_child(fragment);

				html(node_2, () => `<span class="navbar-item-brand-title">${title()}</span>`);
				append($$anchor, fragment);
			};

			if_block(node_1, ($$render) => {
				if (title()) $$render(consequent);
			});
		}

		reset(a);
		template_effect(() => set_attribute(a, 'href', url()));
		append($$anchor, a);
	}

	var root$1 = template(`<!> <!> <!>`, 1);

	function Ui_item_content($$anchor, $$props) {
		push($$props, true);

		const [$$stores, $$cleanup] = setup_stores();
		const $LOCALE = () => store_get(LOCALE, '$LOCALE', $$stores);
		var fragment = root$1();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				Ui_icon($$anchor, spread_props(() => $$props.item.icon));
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_1 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var fragment_3 = comment();
						const SvelteComponent = derived(() => COMPONENTS$1.get($$props.item.component));
						var node_2 = first_child(fragment_3);

						component(node_2, () => get$3(SvelteComponent), ($$anchor, $$component) => {
							$$component($$anchor, spread_props(
								{
									get id() {
										return $$props.item.id;
									}
								},
								() => $$props.item.props
							));
						});

						append($$anchor, fragment_3);
					};

					var alternate = ($$anchor) => {
						var text$1 = text();

						template_effect(() => set_text(text$1, $LOCALE()[$$props.item.title]));
						append($$anchor, text$1);
					};

					if_block(
						node_1,
						($$render) => {
							if ($$props.item.type === 'component' && $$props.item.component && COMPONENTS$1.contains($$props.item.component)) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if ($$props.item.icon) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		var node_3 = sibling(node, 2);

		{
			var consequent_2 = ($$anchor) => {
				Ui_tag($$anchor, spread_props(
					{
						top: true,
						right: true,
						size: 'small',
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.tag
				));
			};

			if_block(node_3, ($$render) => {
				if ($$props.item.tag) $$render(consequent_2);
			});
		}

		var node_4 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_indicator($$anchor, spread_props(
					{
						get id() {
							return $$props.item.id;
						}
					},
					() => $$props.item.indicator
				));
			};

			if_block(node_4, ($$render) => {
				if ($$props.item.indicator) $$render(consequent_3);
			});
		}

		append($$anchor, fragment);
		pop();
		$$cleanup();
	}

	function onClick$1(event, dispatch, item) {
		dispatch("click", { event, element: item() });
	}

	var root_2$1 = template(`<hr>`);
	var root_3 = template(`<a><!></a>`);
	var root_4 = template(`<div role="button" tabindex="0"><!></div>`);
	var root_1$1 = template(`<!> <!>`, 1);

	function Ui_item($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [item]
		 * @property {string} [hidden]
		 * @property {string} [classes]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			item = prop($$props, 'item', 19, () => ({})),
			hidden = prop($$props, 'hidden', 3, ""),
			classes = prop($$props, 'classes', 3, "");

		var fragment = root_1$1();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var hr = root_2$1();

				template_effect(() => set_class(hr, `navbar-divider ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `));
				append($$anchor, hr);
			};

			if_block(node, ($$render) => {
				if (item().break) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		{
			var consequent_1 = ($$anchor) => {
				var a = root_3();

				a.__click = [onClick$1, dispatch, item];

				var node_2 = child(a);

				Ui_item_content(node_2, {
					get item() {
						return item();
					}
				});

				reset(a);

				template_effect(() => {
					set_class(a, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} ${item().classes ?? ''} ${classes() ?? ''} `);
					set_attribute(a, 'href', `${root() ?? ''}${item().url ?? ''}`);
					set_attribute(a, 'data-href', item().url);
				});

				append($$anchor, a);
			};

			var alternate = ($$anchor) => {
				var div = root_4();

				div.__click = [onClick$1, dispatch, item];
				div.__keyup = [onClick$1, dispatch, item];

				var node_3 = child(div);

				Ui_item_content(node_3, {
					get item() {
						return item();
					}
				});

				reset(div);
				template_effect(() => set_class(div, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} ${item().classes ?? ''} ${classes() ?? ''}`));
				append($$anchor, div);
			};

			if_block(node_1, ($$render) => {
				if (item().url) $$render(consequent_1); else $$render(alternate, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	function onClick(event, dispatch, section) {
		dispatch("click", { event, element: section() });
	}

	var root_2 = template(`<div><a href=""><!></a> <div></div></div>`);
	var root_5 = template(`<a><!></a>`);
	var root_6 = template(`<div role="button" tabindex="0"><!></div>`);

	function Ui_section($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {string} [root]
		 * @property {any} [section]
		 * @property {any} [items]
		 * @property {string} [hidden]
		 * @property {boolean} [hoverable]
		 * @property {boolean} [arrowless]
		 * @property {boolean} [right]
		 */
		/** @type {Props} */
		let root = prop($$props, 'root', 3, ""),
			section = prop($$props, 'section', 19, () => ({})),
			items = prop($$props, 'items', 19, () => []),
			hidden = prop($$props, 'hidden', 3, ""),
			hoverable = prop($$props, 'hoverable', 3, true),
			arrowless = prop($$props, 'arrowless', 3, false),
			right = prop($$props, 'right', 3, false);

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				var div = root_2();
				var a = child(div);

				a.__click = [onClick, dispatch, section];

				var node_1 = child(a);

				Ui_item_content(node_1, {
					get item() {
						return section();
					}
				});

				reset(a);

				var div_1 = sibling(a, 2);

				each(div_1, 21, items, (item) => item.id, ($$anchor, item) => {
					Ui_item($$anchor, {
						get root() {
							return root();
						},
						get item() {
							return get$3(item);
						},
						$$events: {
							click($$arg) {
								bubble_event.call(this, $$props, $$arg);
							}
						}
					});
				});

				reset(div_1);
				reset(div);

				template_effect(() => {
					set_class(div, `navbar-item has-dropdown ${(hoverable() ? 'is-hoverable' : '') ?? ''} ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `);
					set_class(a, `navbar-link ${(arrowless() ? 'is-arrowless' : '') ?? ''}`);
					set_class(div_1, `navbar-dropdown ${(right() ? 'is-right' : '') ?? ''}`);
				});

				append($$anchor, div);
			};

			var alternate_1 = ($$anchor) => {
				var fragment_2 = comment();
				var node_2 = first_child(fragment_2);

				{
					var consequent_1 = ($$anchor) => {
						var a_1 = root_5();

						a_1.__click = [onClick, dispatch, section];

						var node_3 = child(a_1);

						Ui_item_content(node_3, {
							get item() {
								return section();
							}
						});

						reset(a_1);

						template_effect(() => {
							set_class(a_1, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `);
							set_attribute(a_1, 'href', `${root() ?? ''}${section().url ?? ''}`);
							set_attribute(a_1, 'data-href', section().url);
						});

						append($$anchor, a_1);
					};

					var alternate = ($$anchor) => {
						var div_2 = root_6();

						div_2.__click = [onClick, dispatch, section];
						div_2.__keyup = [onClick, dispatch, section];

						var node_4 = child(div_2);

						Ui_item_content(node_4, {
							get item() {
								return section();
							}
						});

						reset(div_2);
						template_effect(() => set_class(div_2, `navbar-item ${(hidden() ? `is-hidden-${hidden()}` : '') ?? ''} `));
						append($$anchor, div_2);
					};

					if_block(
						node_2,
						($$render) => {
							if (section().url) $$render(consequent_1); else $$render(alternate, false);
						},
						true
					);
				}

				append($$anchor, fragment_2);
			};

			if_block(node, ($$render) => {
				if (items().length) $$render(consequent); else $$render(alternate_1, false);
			});
		}

		append($$anchor, fragment);
		pop();
	}

	delegate(['click', 'keyup']);

	function toggle(e, closed, dispatch) {
		e.preventDefault();
		closed(!closed());
		dispatch("toggle", { closed: closed() });
		return false;
	}

	var root = template(`<a href="" role="button" aria-label="menu" aria-expanded="false" data-target="navbar"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a>`);

	function Ui_burger($$anchor, $$props) {
		push($$props, true);

		const COMPONENT_NAME = "top-navbar-burger";
		const dispatch = createEventDispatcher();

		function getStandartUpdateEventName() {
			return COMPONENT_NAME + ":update";
		}

		/**
		 * @typedef {Object} Props
		 * @property {any} [events]
		 * @property {any} [register]
		 * @property {boolean} [closed]
		 * @property {any} [onUpdate]
		 */
		/** @type {Props} */
		let events = prop($$props, 'events', 31, () => proxy({})),
			register = prop($$props, 'register', 19, () => notCommon$1.registerWidgetEvents.bind(notCommon$1)),
			closed = prop($$props, 'closed', 15, true),
			onUpdate = prop($$props, 'onUpdate', 3, (data) => {
				closed(data.closed);
			});

		onMount(() => {
			if (!notCommon$1.objHas(events(), getStandartUpdateEventName())) {
				events(events()[getStandartUpdateEventName()] = onUpdate(), true);
			}

			register()(events());
		});

		SideMenuState.subscribe((val) => {
			closed(!val.open);
			return val;
		});

		var a = root();

		a.__click = [toggle, closed, dispatch];
		template_effect(() => set_class(a, `navbar-burger ${(closed() ? '' : 'is-active') ?? ''}`));
		append($$anchor, a);
		pop();
	}

	delegate(['click']);

	var root_1 = template(`<div class="navbar-brand"><!> <!> <!> <!></div> <div id="navbar"><div class="navbar-start"></div> <div class="navbar-end"></div></div>`, 1);

	function Ui_top($$anchor, $$props) {
		push($$props, true);

		const dispatch = createEventDispatcher();

		/**
		 * @typedef {Object} Props
		 * @property {any} [sections] - import { beforeUpdate } from "svelte";
		 * @property {any} [items]
		 * @property {string} [root]
		 * @property {any} [navigate]
		 * @property {boolean} [brand]
		 * @property {boolean} [showBurger]
		 * @property {boolean} [burgerControlsSidemenu]
		 */
		/** @type {Props} */
		let sections = prop($$props, 'sections', 19, () => []),
			items = prop($$props, 'items', 19, () => []),
			root = prop($$props, 'root', 3, ""),
			navigate = prop($$props, 'navigate', 3, null),
			brand = prop($$props, 'brand', 3, false),
			showBurger = prop($$props, 'showBurger', 3, true),
			burgerControlsSidemenu = prop($$props, 'burgerControlsSidemenu', 3, true);

		let menuClosed = state(true);

		function onClick({ detail }) {
			let { event, element } = detail;

			if (Object.hasOwn(element, "action")) {
				return element.action(event, element);
			}

			event.preventDefault();

			if (typeof navigate() === "function") {
				navigate()({
					full: event.currentTarget.getAttribute("href"),
					short: event.currentTarget.dataset.href
				});
			}

			return false;
		}

		let sectionsItemsCount = {};
		let sectionsItems = {};

		/*
		beforeUpdate(() => {
		    for (let section of sections) {
		        sectionsItems[section.id] = items.filter(
		            (t) => t.section === section.id
		        );
		        sectionsItemsCount[section.id] = items.filter(
		            (t) => t.section === section.id
		        ).length;
		    }
		});
		*/
		function toggleBurger({ detail }) {
			if (burgerControlsSidemenu()) {
				notSideMenu.toggle();
			} else {
				dispatch("toggleBurger", detail);
				set(menuClosed, proxy(detail.closed));
			}
		}

		var fragment = root_1();
		var div = first_child(fragment);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				Ui_brand($$anchor, spread_props(brand));
			};

			if_block(node, ($$render) => {
				if (brand()) $$render(consequent);
			});
		}

		var node_1 = sibling(node, 2);

		each(node_1, 17, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_2 = comment();
			var node_2 = first_child(fragment_2);

			{
				var consequent_1 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'desktop',
						get item() {
							return get$3(section);
						},
						get root() {
							return root();
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_2, ($$render) => {
					if (get$3(section).showOnTouch) $$render(consequent_1);
				});
			}

			append($$anchor, fragment_2);
		});

		var node_3 = sibling(node_1, 2);

		each(node_3, 17, items, (item) => item.id, ($$anchor, item) => {
			var fragment_4 = comment();
			var node_4 = first_child(fragment_4);

			{
				var consequent_2 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'desktop',
						get item() {
							return get$3(item);
						},
						get root() {
							return root();
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_4, ($$render) => {
					if (get$3(item).showOnTouch) $$render(consequent_2);
				});
			}

			append($$anchor, fragment_4);
		});

		var node_5 = sibling(node_3, 2);

		{
			var consequent_3 = ($$anchor) => {
				Ui_burger($$anchor, { $$events: { toggle: toggleBurger } });
			};

			if_block(node_5, ($$render) => {
				if (showBurger()) $$render(consequent_3);
			});
		}

		reset(div);

		var div_1 = sibling(div, 2);
		var div_2 = child(div_1);

		each(div_2, 21, items, index$d, ($$anchor, item) => {
			var fragment_7 = comment();
			var node_6 = first_child(fragment_7);

			{
				var consequent_4 = ($$anchor) => {
					Ui_item($$anchor, {
						hidden: 'touch',
						get item() {
							return get$3(item);
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_6, ($$render) => {
					if (get$3(item).place === "start") $$render(consequent_4);
				});
			}

			append($$anchor, fragment_7);
		});

		reset(div_2);

		var div_3 = sibling(div_2, 2);

		each(div_3, 21, sections, (section) => section.id, ($$anchor, section) => {
			var fragment_9 = comment();
			var node_7 = first_child(fragment_9);

			{
				var consequent_5 = ($$anchor) => {
					Ui_section($$anchor, {
						right: true,
						get hidden() {
							return get$3(section).hidden;
						},
						get root() {
							return root();
						},
						get section() {
							return get$3(section);
						},
						get items() {
							return sectionsItems[get$3(section).id];
						},
						$$events: { click: onClick }
					});
				};

				if_block(node_7, ($$render) => {
					if ((sectionsItemsCount[get$3(section).id] || get$3(section).indicator || get$3(section).tag) && get$3(section).place == "end") $$render(consequent_5);
				});
			}

			append($$anchor, fragment_9);
		});

		reset(div_3);
		reset(div_1);
		template_effect(() => set_class(div_1, `navbar-menu ${(get$3(menuClosed) ? '' : 'is-active') ?? ''}`));
		append($$anchor, fragment);
		pop();
	}

	var _notTopMenu;
	const TYPE = "top";
	let notTopMenu = /*#__PURE__*/function (_Menu) {
	  function notTopMenu() {
	    _classCallCheck(this, notTopMenu);
	    return _callSuper(this, notTopMenu, arguments);
	  }
	  _inherits(notTopMenu, _Menu);
	  return _createClass(notTopMenu, null, [{
	    key: "render",
	    value: function render(app) {
	      if (app) {
	        this.setApp(app);
	      }
	      this.prepareData();
	      if (!this.menu) {
	        let target = document.querySelector(this.getOptions().targetSelector);
	        if (!target) {
	          return;
	        }
	        this.menu = mount(Ui_top, {
	          target,
	          props: {
	            brand: this.getOptions().brand,
	            items: this.items,
	            sections: this.sections,
	            root: this.getOptions().root,
	            navigate: this.getOptions().navigate
	          }
	        });
	        this.interval = setInterval(this.updateMenuActiveItem.bind(this), 200);
	      }
	    }
	  }, {
	    key: "updateMenu",
	    value: function updateMenu(url) {
	      Array.from(document.querySelectorAll(this.getOptions().targetSelector + " aside.menu a")).forEach(function (item) {
	        if (item.href == url || url.href && url.href.indexOf(item.href) == 0) {
	          item.classList.add("is-active");
	        } else {
	          item.classList.remove("is-active");
	        }
	      });
	    }
	  }, {
	    key: "updateMenuActiveItem",
	    value: function updateMenuActiveItem() {
	      let url = window.location.toString(),
	        lastLocation = this.location;
	      if (lastLocation) {
	        if (url !== lastLocation) {
	          this.location = url;
	          this.updateMenu(url);
	        }
	      } else {
	        this.location = url;
	        this.updateMenu(url);
	      }
	    }
	  }, {
	    key: "toggle",
	    value: function toggle() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.toggle("is-active");
	    }
	  }, {
	    key: "hide",
	    value: function hide() {
	      let el = document.querySelector(this.getOptions().targetSelector);
	      el.classList.remove("is-active");
	    }
	  }, {
	    key: "setBurgerState",
	    value: function setBurgerState(menuClosed) {
	      this.menu.$set({
	        menuClosed
	      });
	    }
	  }]);
	}(Menu);
	_notTopMenu = notTopMenu;
	_defineProperty(notTopMenu, "DEFAULT", {
	  section: "any",
	  sectionTitle: "Меню",
	  priority: 0,
	  //link, button, dropdown, component
	  type: "link",
	  place: "main"
	});
	_defineProperty(notTopMenu, "options", {
	  brand: false,
	  type: TYPE,
	  items: [],
	  sections: [],
	  targetSelector: `#${TYPE}-menu`,
	  root: "/",
	  directNavigation: false,
	  navigate: function (urls) {
	    _notTopMenu.hide();
	    if (!_notTopMenu.isDirectNavigation() && _notTopMenu.app) {
	      let func = _notTopMenu.app.getWorking("router");
	      if (func) {
	        return func.navigate(urls.short);
	      }
	    }
	    document.location.assign(urls.full);
	  }
	});

	const DEFAULT_TRASFORMER = function (res) {
	  // @ts-ignore
	  return Object.hasOwn(res, "status") && Object.hasOwn(res, "result") ? res.result : res;
	};

	var create_crud_action_ui_view = (function ({
	  ACTION,
	  TITLE,
	  UIConstructor,
	  dataProvider,
	  goBack
	}) {
	  return /*#__PURE__*/function () {
	    function _class() {
	      _classCallCheck(this, _class);
	    }
	    return _createClass(_class, null, [{
	      key: "run",
	      value: async function run(controller, params) {
	        try {
	          controller.setBreadcrumbs([{
	            title: `Просмотр "${TITLE}"`
	          }]);
	          await controller.preloadVariants(ACTION);
	          if (controller.ui[ACTION]) {
	            return;
	          } else {
	            controller.$destroyUI();
	          }
	          let data = {};
	          if (dataProvider) {
	            if (notCommon$1.isFunc(dataProvider)) {
	              if (notCommon$1.isAsync(dataProvider)) {
	                data = await dataProvider(params);
	              } else {
	                data = dataProvider(params);
	              }
	            } else {
	              data = {
	                ...dataProvider
	              };
	            }
	          }
	          const resultTransformer = controller.getOptions(`${ACTION}.transformer`, DEFAULT_TRASFORMER);
	          controller.ui[ACTION] = new UIConstructor({
	            target: controller.getContainerInnerElement(),
	            props: {
	              params,
	              ...resultTransformer(data)
	            }
	          });
	          controller.emit(`after:render:${ACTION}`);
	          if (goBack && notCommon$1.isFunc(goBack)) {
	            controller.ui[ACTION].on("reject", function () {
	              return goBack();
	            });
	          }
	        } catch (e) {
	          controller.report(e);
	          controller.showErrorMessage(e);
	        }
	      }
	    }]);
	  }();
	});

	const PRELOADABLE = ["create", "update", "list", "delete", "details"];
	let CRUDVariantsPreloader = /*#__PURE__*/function () {
	  function CRUDVariantsPreloader() {
	    _classCallCheck(this, CRUDVariantsPreloader);
	  }
	  return _createClass(CRUDVariantsPreloader, null, [{
	    key: "preload",
	    value: async function preload(controller, type = "list") {
	      try {
	        if (!PRELOADABLE.includes(type)) {
	          return;
	        }
	        let preload = controller.getOptions(`${type}.preload`, {});
	        if (Object.keys(preload).length == 0) {
	          preload = controller.getOptions(`preload`, {});
	        }
	        if (Object.keys(preload).length > 0) {
	          let libProps = Object.keys(preload);
	          let proms = [];
	          libProps.forEach(function (prop) {
	            let modelName = notCommon$1.lowerFirstLetter(preload[prop]);
	            let Model = controller.make[modelName]({});
	            proms.push(Model.$listAll());
	          });
	          let results = await Promise.all(proms);
	          for (let i = 0; i < libProps.length; i++) {
	            const propName = libProps[i];
	            if (results[i].status === "ok" && Array.isArray(results[i].result)) {
	              const resultsList = results[i].result;
	              const variants = resultsList.map(function (item) {
	                return {
	                  id: item._id,
	                  title: item.title
	                };
	              });
	              controller.setOptions(`variants.${type}.${propName}`, variants);
	            }
	          }
	        }
	        controller.log("preload finished");
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const DEFAULT_ACTION = "list";
	let notCRUDRouter = /*#__PURE__*/function () {
	  function notCRUDRouter() {
	    _classCallCheck(this, notCRUDRouter);
	  }
	  return _createClass(notCRUDRouter, null, [{
	    key: "extractActionName",
	    value: function extractActionName(controller, params) {
	      let actionName = DEFAULT_ACTION;
	      if (params.length === 1) {
	        if (params[0] === "create") {
	          actionName = "create";
	        } else if (controller.actionHandlerExists(params[0])) {
	          actionName = params[0];
	        } else {
	          actionName = "details";
	        }
	      } else if (params.length > 1) {
	        if (params[1] === "delete") {
	          actionName = "delete";
	        } else if (params[1] === "update") {
	          actionName = "update";
	        } else {
	          actionName = params[1];
	        }
	      }
	      return actionName;
	    }
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = notCRUDRouter.extractActionName(controller, params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	let CRUDMessage = /*#__PURE__*/function () {
	  function CRUDMessage() {
	    _classCallCheck(this, CRUDMessage);
	  }
	  return _createClass(CRUDMessage, null, [{
	    key: "error",
	    value: function error(controller, title, message) {
	      controller.setUI("__message__", new Ui_error({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }, {
	    key: "success",
	    value: function success(controller, title, message) {
	      controller.setUI("__message__", new Ui_success({
	        target: controller.getContainerInnerElement(),
	        props: {
	          title,
	          message
	        }
	      }));
	    }
	  }]);
	}();

	const DEFAULT_BREADCRUMB_TAIL$2 = "Просмотр";

	/**
	 * Generic CRUD action class
	 * @class
	 */
	let CRUDGenericAction = /*#__PURE__*/function () {
	  function CRUDGenericAction() {
	    _classCallCheck(this, CRUDGenericAction);
	  }
	  return _createClass(CRUDGenericAction, null, [{
	    key: "NAVIGATION_DELAY",
	    get: function () {
	      return NAVIGATION_DELAY_DEFAULT;
	    }
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	  }, {
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$2;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL$2,
	        set: 'Просмотр, "{:title}"'
	      };
	    }

	    /**
	     * Returns template of breadcrumbs tail
	     * @param   {string}    name
	     * @returns {string}    template string
	     */
	  }, {
	    key: "getBreadcrumbsTail",
	    value: function getBreadcrumbsTail(name) {
	      if (!this.breadcrumbsTails) {
	        return "";
	      }
	      return notCommon$1.select(this.breadcrumbsTails, name, this.deafultBreadcrumbsTail);
	    }
	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "details";
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "get";
	    }

	    /**
	     * @static {object} UIConstructor    constructor of UI component
	     */
	  }, {
	    key: "UIConstructor",
	    get: function () {
	      return notForm;
	    }
	    /**
	     * @static {function}   TRANSFORMER     response.result transformation function if want to change it's structure
	     */
	  }, {
	    key: "TRANSFORMER",
	    get: function () {
	      return DEFAULT_TRASFORMER;
	    }
	    /**
	     * Returns name of model identificaiton field
	     * @param {object} controller instance of controller
	     * @returns {string}    default id field name is '_id'
	     */
	  }, {
	    key: "getIdField",
	    value: function getIdField(controller) {
	      return controller.getOptions(`${this.ACTION}.idField`, "_id");
	    }
	  }, {
	    key: "loadDataQuery",
	    value: function loadDataQuery(controller, params) {
	      const idField = this.getIdField(controller);
	      return {
	        [idField]: params[0]
	      };
	    }

	    /**
	     * Return Promise of API reponse
	     * @param {object} controller instance of controller
	     * @param {string[]} params     array of strings parsed from URI by router and passed to controller
	     * @returns {Promise}   API response {status:string, result:any, message:string, errors: {[fieldname]:[...errorMessages]}}
	     */
	  }, {
	    key: "loadData",
	    value: async function loadData(controller, params) {
	      const query = this.loadDataQuery(controller, params);
	      const actionName = this.getModelActionName(controller);
	      return await controller.getModel(query)[`$${actionName}`]();
	    }

	    /**
	     * Returns model API action name
	     * @param {object} controller instance of controller
	     * @returns {string}    network interface model action name, for API; default: this.MODEL_ACTION_GET
	     */
	  }, {
	    key: "getModelActionName",
	    value: function getModelActionName(controller) {
	      return controller.getOptions(`${this.ACTION}.actionName`, this.MODEL_ACTION_GET);
	    }

	    /**
	     * Sets breadcrumbs tail, without result details
	     * @param {object} controller instance of controller
	     * @param {string[]} params     list of route params
	     */
	  }, {
	    key: "presetBreadcrumbs",
	    value: function presetBreadcrumbs(controller, params) {
	      controller.setBreadcrumbs([{
	        title: this.getBreadcrumbsTail("preset"),
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response.result);
	    }

	    /**
	     * Sets breadcrumbs tail with response details, aka title of loaded item
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response in wrapper
	     * @param {object} response.result  API response result
	     */
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(controller, params, response) {
	      const title = this.getTitle(controller, params, response);
	      const breadcrumbsTailTemplate = this.getBreadcrumbsTail("set");
	      controller.setBreadcrumbs([{
	        title: breadcrumbsTailTemplate ? notLocale$1.format(breadcrumbsTailTemplate, {
	          title
	        }) : title,
	        url: controller.getModelActionURL(params[0], false)
	      }]);
	    }

	    /**
	     * Checks response on success
	     * @param {object} response
	     * @param {string} response.status
	     * @returns {boolean}   true if response is bad
	     */
	  }, {
	    key: "isResponseBad",
	    value: function isResponseBad(response) {
	      return !response || response.status !== "ok";
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators(controller) {
	      return controller.getValidators && controller.getValidators() || controller.getOptions("Validators");
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const detailsActionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: detailsActionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          fields: {
	            readonly: true
	          },
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {}),
	          injected: controller.getOptions(`${this.ACTION}.injected`, {})
	        },
	        data: this.TRANSFORMER(response.result)
	      };
	    }

	    /**
	     * Returns instance of this action UI component from controller
	     * @param {object} controller   instance of controller
	     * @returns {object}    instance of UI component
	     */
	  }, {
	    key: "getUI",
	    value: function getUI(controller) {
	      return controller.getUI(this.ACTION);
	    }

	    /**
	     * Sets UI of this action in controller
	     * @param {object} controller   instance of controller
	     * @param {object} ui           instance of UI component
	     */
	  }, {
	    key: "setUI",
	    value: function setUI(controller, ui) {
	      controller.setUI(this.ACTION, ui);
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `true`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoading",
	    value: function setUILoading(controller) {
	      this.getUI(controller).$set({
	        loading: true
	      });
	    }

	    /**
	     *  Sets via `.$set` method `loading` to `false`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUILoaded",
	    value: function setUILoaded(controller) {
	      this.getUI(controller).$set({
	        loading: false
	      });
	    }

	    /**
	     *  Sets via `.$set` method `error` to `message`
	     *
	     * @static
	     * @param {import('../../controller.crud')} controller
	     * @param   {Error} message     error message
	     * @memberof CRUDGenericAction
	     */
	  }, {
	    key: "setUIError",
	    value: function setUIError(controller, message) {
	      this.getUI(controller).$set({
	        error: message
	      });
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} response     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return controller.goBack();
	        });
	      }
	    }

	    /**
	     * Bind event handler named event to UI. Checks different binder notation $on/on
	     * @param {object} controller   instance of controller
	     * @param {string} event        event name
	     * @param {function} callback   callback function on event
	     * @returns
	     */
	  }, {
	    key: "bindUIEvent",
	    value: function bindUIEvent(controller, event, callback) {
	      const ui = this.getUI(controller);
	      if (ui.$on) {
	        return ui.$on(event, callback);
	      }
	      if (ui.on) {
	        return ui.on(event, callback);
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }
	  }, {
	    key: "createUI",
	    value: function createUI(uiComponent, controller, response) {
	      if (notCommon$1.isFunc(uiComponent)) {
	        return mount(uiComponent, this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      } else {
	        return new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response)));
	      }
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        //eslint-disable-next-line no-unused-vars
	        const uiComponent = this.UIConstructor;
	        //eslint-disable-next-line no-unused-vars
	        const ui = this.createUI();
	        this.setUI(controller);
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "goBackAfterDelay",
	    value: function goBackAfterDelay(controller) {
	      controller.goBack(this.NAVIGATION_DELAY);
	    }
	  }, {
	    key: "goBack",
	    value: function goBack(controller) {
	      controller.goBack(0);
	    }
	  }]);
	}();

	const ACTION$2 = "create";
	const DEFAULT_BREADCRUMB_TAIL$1 = "Создание";
	let CRUDGenericActionCreate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionCreate() {
	    _classCallCheck(this, CRUDGenericActionCreate);
	    return _callSuper(this, CRUDGenericActionCreate, arguments);
	  }
	  _inherits(CRUDGenericActionCreate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionCreate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get: function () {
	      return DEFAULT_BREADCRUMB_TAIL$1;
	    }
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return undefined;
	    }
	  }, {
	    key: "ACTION",
	    get: function () {
	      return ACTION$2;
	    }
	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     * @static {string} MODEL_ACTION    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return ACTION$2;
	    }

	    /**
	     *
	     * @param {import('../../controller.crud')} controller
	     * @param {any}                         [params]
	     * @returns {import('not-node/src/types').notAppResponse}
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "loadData",
	    value: function loadData(controller, params = {}) {
	      let defData = controller.createDefault();
	      if (defData.getData) {
	        defData = defData.getData();
	      }
	      return {
	        status: "ok",
	        result: defData
	      };
	    }
	  }, {
	    key: "getTitle",
	    value: function getTitle(contoller, params, response) {
	      return contoller.getItemTitle(response);
	    }
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      const actionName = this.getModelActionName(controller);
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: actionName,
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(response)
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    //eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	let CRUDActionCreate = /*#__PURE__*/function (_CRUDGenericActionCre) {
	  function CRUDActionCreate() {
	    _classCallCheck(this, CRUDActionCreate);
	    return _callSuper(this, CRUDActionCreate, arguments);
	  }
	  _inherits(CRUDActionCreate, _CRUDGenericActionCre);
	  return _createClass(CRUDActionCreate);
	}(CRUDGenericActionCreate);

	/**
	 * Generic CRUD Details action class
	 * @class
	 */
	let CRUDGenericActionRead = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionRead() {
	    _classCallCheck(this, CRUDGenericActionRead);
	    return _callSuper(this, CRUDGenericActionRead, arguments);
	  }
	  _inherits(CRUDGenericActionRead, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionRead, null, [{
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      options.options.ui = {
	        submit: {
	          enabled: false
	        }
	      };
	      return options;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, params);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params, response);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action details
	 */
	let CRUDActionDetails = /*#__PURE__*/function (_CRUDGenericActionRea) {
	  function CRUDActionDetails() {
	    _classCallCheck(this, CRUDActionDetails);
	    return _callSuper(this, CRUDActionDetails, arguments);
	  }
	  _inherits(CRUDActionDetails, _CRUDGenericActionRea);
	  return _createClass(CRUDActionDetails);
	}(CRUDGenericActionRead);

	const DEFAULT_BREADCRUMB_TAIL = "Редактирование";
	/**
	 * Generic CRUD Update action class
	 * @class
	 */
	let CRUDGenericActionUpdate = /*#__PURE__*/function (_CRUDGenericAction) {
	  function CRUDGenericActionUpdate() {
	    _classCallCheck(this, CRUDGenericActionUpdate);
	    return _callSuper(this, CRUDGenericActionUpdate, arguments);
	  }
	  _inherits(CRUDGenericActionUpdate, _CRUDGenericAction);
	  return _createClass(CRUDGenericActionUpdate, null, [{
	    key: "deafultBreadcrumbsTail",
	    get:
	    /**
	     * Default breadcrumbs tail template string
	     * @returns {string}
	     */
	    function () {
	      return DEFAULT_BREADCRUMB_TAIL;
	    }

	    /**
	     * Libarary of breadcrumbs tails strings templates
	     * @returns {Object}
	     */
	  }, {
	    key: "breadcrumbsTails",
	    get: function () {
	      return {
	        preset: DEFAULT_BREADCRUMB_TAIL,
	        set: `${DEFAULT_BREADCRUMB_TAIL}: "{:title}"`
	      };
	    }

	    /**
	     * @static {string} ACTION this controller action name, used in URI
	     */
	  }, {
	    key: "ACTION",
	    get: function () {
	      return "update";
	    }

	    /**
	     * @static {string} MODEL_ACTION_GET    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_GET",
	    get: function () {
	      return "getRaw";
	    }

	    /**
	     * @static {string} MODEL_ACTION_PUT    network model interface action name, used in API
	     */
	  }, {
	    key: "MODEL_ACTION_PUT",
	    get: function () {
	      return "update";
	    }

	    /**
	     * Creates object with all options needed to initialize UI component
	     * @param {object} controller   instance of controller
	     * @param {object} response     API reponse object
	     * @returns {object}    ui options object
	     */
	  }, {
	    key: "prepareUIOptions",
	    value: function prepareUIOptions(controller, response) {
	      return {
	        options: {
	          target: controller.getContainerInnerElement(),
	          model: controller.getModelName(),
	          action: this.MODEL_ACTION_PUT,
	          //will be used to get form fields information from manifest
	          name: `${controller.getName()}.${this.ACTION}Form`,
	          validators: this.getValidators(controller),
	          variants: controller.getOptions(`variants.${this.ACTION}`, {}),
	          ui: controller.getOptions(`${this.ACTION}.ui`, {}),
	          fields: controller.getOptions(`${this.ACTION}.fields`, {}),
	          masters: controller.getOptions(`${this.ACTION}.masters`, {})
	        },
	        data: this.TRANSFORMER(notCommon$1.stripProxy(response.result))
	      };
	    }

	    /**
	     * Binds events to action UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @param {object} [response]     API response
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "bindUIEvents",
	    value: function bindUIEvents(controller, params, response) {
	      var _this = this;
	      if (notCommon$1.isFunc(controller.goBack)) {
	        this.bindUIEvent(controller, "reject", function () {
	          return _this.goBack(controller);
	        });
	      }
	      if (notCommon$1.isFunc(controller.onActionSubmit)) {
	        this.bindUIEvent(controller, "submit", async function (ev) {
	          const success = await controller.onActionSubmit(_this.ACTION, {
	            ..._this.loadDataQuery(controller, params),
	            ...ev.detail
	          });
	          if (success) {
	            _this.goBackAfterDelay(controller);
	          }
	        });
	      }
	    }

	    /**
	     * true, if UI of this action already exists,
	     * false, if UI of this action wasn't existed and other UIs were destoryed
	     * @param {object} controller   instance of controller
	     * @returns {boolean}   true if UI of this action exists, false if UI of other was destroyed
	     */
	  }, {
	    key: "isUIRendered",
	    value: function isUIRendered(controller) {
	      if (this.getUI(controller)) {
	        return true;
	      } else {
	        controller.$destroyUI();
	      }
	      return false;
	    }

	    /**
	     * Performing action preparation and renders UI
	     * @param {object} controller   instance of controller
	     * @param {string[]} params     list of route params
	     * @returns {Promise<undefined>}
	     */
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //inform that we are starting
	        controller.emit(`before:render:${this.ACTION}`, [params]);
	        //if UI for this action exists exiting
	        if (this.isUIRendered(controller)) {
	          return;
	        }
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        //preloading form variants
	        await controller.preloadVariants(this.ACTION);
	        //setting initial state of breadcrumbs tail
	        this.presetBreadcrumbs(controller, params);
	        //loading data
	        const response = await this.loadData(controller, params);
	        //showing error message if response is 'bad'
	        if (this.isResponseBad(response)) {
	          return controller.showErrorMessage(response);
	        }
	        //updating breadcrumbs tail with more details from response
	        this.setBreadcrumbs(controller, params, response);
	        //creating action UI component
	        const uiComponent = this.UIConstructor;
	        this.setUI(controller, new uiComponent(this.tweakUIOptions(this.prepareUIOptions(controller, response))));
	        //bind events to UI
	        this.bindUIEvents(controller, params, response);
	        //inform that we are ready
	        controller.emit(`after:render:${this.ACTION}`, params);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${this.ACTION}`, params, e);
	        //reporting exception
	        controller.report(e);
	        //showing error message
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }]);
	}(CRUDGenericAction);

	/**
	 * CRUD action update
	 */
	let CRUDActionUpdate = /*#__PURE__*/function (_CRUDGenericActionUpd) {
	  function CRUDActionUpdate() {
	    _classCallCheck(this, CRUDActionUpdate);
	    return _callSuper(this, CRUDActionUpdate, arguments);
	  }
	  _inherits(CRUDActionUpdate, _CRUDGenericActionUpd);
	  return _createClass(CRUDActionUpdate);
	}(CRUDGenericActionUpdate);

	const ACTION$1 = "delete";
	const MODEL_ACTION = "delete";
	let CRUDActionDelete = /*#__PURE__*/function () {
	  function CRUDActionDelete() {
	    _classCallCheck(this, CRUDActionDelete);
	  }
	  return _createClass(CRUDActionDelete, null, [{
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        if (controller.ui[ACTION$1]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION$1] = new notActionUI({
	          name: "CRUDDelete",
	          target: controller.getContainerInnerElement(),
	          options: {
	            loaderActive: true,
	            loaderStyle: "container",
	            loaderTitle: "not-node:crud_delete_action_waiting",
	            container: {
	              id: `crud-delete-action-${params[0]}`
	            }
	          }
	        });
	        controller.setBreadcrumbs([{
	          title: "Удаление",
	          url: controller.getModelActionURL(params[0], ACTION$1)
	        }]);
	        if (confirm("Удалить запись?")) {
	          const deleteActionName = controller.getOptions(`${ACTION$1}.actionName`, MODEL_ACTION);
	          const success = await controller.onActionSubmit(deleteActionName, {
	            _id: params[0]
	          });
	          if (success) {
	            controller.goList();
	          }
	          return;
	        }
	        controller.goList();
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const ACTION = "list";
	let CRUDActionList = /*#__PURE__*/function () {
	  function CRUDActionList() {
	    _classCallCheck(this, CRUDActionList);
	  }
	  return _createClass(CRUDActionList, null, [{
	    key: "tweakActionsList",
	    value: function tweakActionsList(controller, ACTIONS_LIST) {
	      if (controller.getOptions(`${ACTION}.createAction`, true)) {
	        ACTIONS_LIST.push({
	          title: "Создать",
	          action: function () {
	            return controller.goCreate();
	          }
	        });
	      }
	      return ACTIONS_LIST;
	    }
	  }, {
	    key: "tweakUIOptions",
	    value: function tweakUIOptions(options) {
	      return options;
	    }

	    /**
	     *
	     *
	     * @static
	     * @param {import('../controller.crud').default} controller
	     * @param {string} value
	     * @param {number} [delay=0]
	     * @param {Array<string>} [actions=["details", "update", "delete"]]
	     * @param {Array<object>} [prepend=[]]
	     * @param {Array<object>} [append=[]]
	     * @param {boolean} [onlyIcons=true]
	     * @return {Array<object>}
	     * @memberof CRUDActionList
	     */
	  }, {
	    key: "createActionsButtons",
	    value: function createActionsButtons(controller, value, delay = 0, actions = ["details", "update", "delete"], prepend = [], append = [], onlyIcons = true) {
	      const ACTIONS = {
	        details: {
	          action: function () {
	            return controller.goDetails(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "circle-info"
	          } : {
	            title: "Подробнее"
	          }),
	          size: "small"
	        },
	        update: {
	          action: function () {
	            return controller.goUpdate(value, delay);
	          },
	          ...(onlyIcons ? {
	            icon: "edit"
	          } : {
	            title: "Изменить"
	          }),
	          color: "warning",
	          size: "small"
	        },
	        delete: {
	          action: function () {
	            return controller.goDelete(value, delay);
	          },
	          color: "danger",
	          ...(onlyIcons ? {
	            icon: "trash"
	          } : {
	            title: "Удалить"
	          }),
	          size: "small",
	          style: "outlined"
	        }
	      };
	      const actionsButtons = [...prepend];
	      if (Array.isArray(actions)) {
	        actions.forEach(function (actionName) {
	          return actionsButtons.push(ACTIONS[actionName]);
	        });
	      }
	      actionsButtons.push(...append);
	      return actionsButtons;
	    }
	  }, {
	    key: "run",
	    value: async function run(controller, params) {
	      try {
	        //indicating that we are working
	        controller.renderLoadingScreen && controller.renderLoadingScreen();
	        await controller.preloadVariants(ACTION);
	        controller.setBreadcrumbs([{
	          title: "Список",
	          url: controller.getModelURL()
	        }]);
	        if (controller.ui[ACTION]) {
	          return;
	        } else {
	          controller.$destroyUI();
	        }
	        controller.ui[ACTION] = new notTable(this.tweakUIOptions(CRUDActionList.prepareOptions(controller)));
	        controller.emit(`after:render:${ACTION}`, params, controller.ui[ACTION]);
	      } catch (e) {
	        //informing about exception
	        controller.emit(`exception:render:${ACTION}`, params, e);
	        controller.report(e);
	        controller.showErrorMessage(e);
	      } finally {
	        controller.removeLoadingScreen && controller.removeLoadingScreen();
	      }
	    }
	  }, {
	    key: "prepareOptions",
	    value: function prepareOptions(controller) {
	      const DEFAULT_OPTIONS_TABLE = {
	        interface: controller.getOptions(`${ACTION}.interface`, {
	          combined: true,
	          factory: controller.getInterface()
	        }),
	        fields: undefined,
	        showSelect: undefined,
	        getItemId: undefined,
	        idField: undefined,
	        preload: {},
	        filterUI: controller.getOptions(`${ACTION}.filterUI`),
	        pager: {
	          size: 50,
	          page: 0
	        },
	        sorter: {
	          id: -1
	        },
	        filter: undefined,
	        ui: undefined
	      };
	      //forming actions buttons list
	      let ACTIONS_LIST = [...controller.getOptions(`${ACTION}.actions`, [])];
	      ACTIONS_LIST = this.tweakActionsList(controller, ACTIONS_LIST);
	      //
	      const TABLE_OPTIONS = {
	        options: {
	          targetEl: controller.getContainerInnerElement(),
	          endless: false,
	          actions: ACTIONS_LIST
	        }
	      };
	      Object.keys(DEFAULT_OPTIONS_TABLE).forEach(function (key) {
	        let optVal = controller.getOptions(`${ACTION}.${key}`, DEFAULT_OPTIONS_TABLE[key]);
	        if (typeof optVal !== "undefined") {
	          TABLE_OPTIONS.options[key] = optVal;
	        }
	      });
	      return TABLE_OPTIONS;
	    }
	  }]);
	}();

	var CRUDActions = {
	  create: CRUDActionCreate,
	  details: CRUDActionDetails,
	  update: CRUDActionUpdate,
	  delete: CRUDActionDelete,
	  list: CRUDActionList
	};

	const BREADCRUMBS = [];
	const TITLE_FIELDS_PRIORITY = ["title", "label", "id", "name"];
	const LOADING_SCREEN_UI_NAME = "loading_screen";
	var _actions = /*#__PURE__*/new WeakMap();
	var _router = /*#__PURE__*/new WeakMap();
	var _preloader = /*#__PURE__*/new WeakMap();
	let notCRUD = /*#__PURE__*/function (_notController) {
	  function notCRUD(app, name, {
	    actions,
	    router,
	    preloader
	  } = {
	    actions: undefined,
	    router: undefined,
	    preloader: undefined
	  }) {
	    var _this;
	    _classCallCheck(this, notCRUD);
	    _this = _callSuper(this, notCRUD, [app, `CRUD.${name}`]);
	    _classPrivateFieldInitSpec(_this, _actions, {
	      ...CRUDActions
	    });
	    _classPrivateFieldInitSpec(_this, _router, notCRUDRouter);
	    _classPrivateFieldInitSpec(_this, _preloader, CRUDVariantsPreloader);
	    _defineProperty(_this, "TITLE_FIELDS_PRIORITY", TITLE_FIELDS_PRIORITY);
	    _defineProperty(_this, "TOP_CLASS", ["box"]);
	    _defineProperty(_this, "MAIN_CLASS", ["box"]);
	    _defineProperty(_this, "BOTTOM_CLASS", ["box"]);
	    _defineProperty(_this, "WS_CHECK_INTERVAL", 200);
	    if (actions) {
	      // @ts-ignore
	      _classPrivateFieldSet2(_actions, _this, {
	        ..._classPrivateFieldGet2(_actions, _this),
	        ...actions
	      });
	    }
	    if (router) {
	      _classPrivateFieldSet2(_router, _this, router);
	    }
	    if (preloader) {
	      _classPrivateFieldSet2(_preloader, _this, preloader);
	    }
	    _this.ui = {};
	    _this.els = {};
	    _this.setOptions("names", {
	      module: "",
	      plural: "plural",
	      single: "single"
	    });
	    _this.setOptions("containerSelector", _this.app?.getOptions("crud.containerSelector"));
	    _this.buildFrame();
	    return _possibleConstructorReturn(_this, _this);
	  }
	  _inherits(notCRUD, _notController);
	  return _createClass(notCRUD, [{
	    key: "setValidators",
	    value: function setValidators(validators) {
	      //not-module-name -> [not,module,name]
	      const ModuleNameParts = this.getModuleName().split("-");
	      //[not,module,name] -> ModuleName
	      const ModuleName = (ModuleNameParts[0] === "not" ? ModuleNameParts.splice(1) : ModuleNameParts).map(notCommon$1.capitalizeFirstLetter).join("");
	      const serviceName = `ns${ModuleName}Common`;
	      const CommonModuleService = this.app?.getService(serviceName);
	      this.setWorking("validators", CommonModuleService.augmentValidators(validators));
	    }
	  }, {
	    key: "getValidators",
	    value: function getValidators() {
	      return this.getWorking("validators");
	    }
	  }, {
	    key: "start",
	    value: function start() {
	      var _this2 = this;
	      let newHead = [];
	      if (this.getModuleName() && this.getOptions("names.module")) {
	        newHead.push({
	          title: this.getOptions("names.module"),
	          url: false
	        });
	      }
	      newHead.push({
	        title: this.getOptions("names.plural"),
	        url: this.getModelURL()
	      });
	      BREADCRUMBS.splice(0, BREADCRUMBS.length, ...newHead);
	      notBreadcrumbs.setHead(BREADCRUMBS).render({
	        root: "",
	        target: this.els.top,
	        navigate: function (url) {
	          return _this2.app?.getWorking("router").navigate(url);
	        }
	      });
	      this.route(this.getOptions("params"));
	    }
	  }, {
	    key: "startWhenWSClientReady",
	    value: function startWhenWSClientReady() {
	      var _this3 = this;
	      if (this.app?.getWSClient()) {
	        if (this.app?.getWSClient().isConnected()) {
	          this.start();
	        } else {
	          this.app.getWSClient().once("connected", this.startWhenWSClientReady.bind(this));
	        }
	      } else {
	        setTimeout(function () {
	          return _this3.startWhenWSClientReady();
	        }, this.WS_CHECK_INTERVAL);
	      }
	    }
	  }, {
	    key: "setBreadcrumbs",
	    value: function setBreadcrumbs(tail) {
	      notBreadcrumbs.setTail(tail).update();
	    }
	  }, {
	    key: "backToList",
	    value: function backToList() {
	      this.navigate(this.linkBackToList());
	    }
	  }, {
	    key: "linkBackToList",
	    value: function linkBackToList() {
	      return this.getModelURL();
	    }
	  }, {
	    key: "afterAction",
	    value: function afterAction(action = "list") {
	      let navBack = this.app?.getOptions("crud.navigateBackAfter", []);
	      if (navBack && Array.isArray(navBack) && navBack.indexOf(action) > -1) {
	        window.history.back();
	      } else {
	        this.backToList();
	      }
	    }
	  }, {
	    key: "buildFrame",
	    value: function buildFrame() {
	      var _this4 = this;
	      let el = document.querySelector(this.app?.getOptions("crud.containerSelector", "body"));
	      while (el.firstChild) {
	        el.removeChild(el.firstChild);
	      }
	      this.els.top = document.createElement("div");
	      this.els.top.id = "crud-top";
	      this.getFrameClasses().TOP_CLASS.forEach(function (name) {
	        return _this4.els.top.classList.add(name);
	      });
	      el.appendChild(this.els.top);
	      this.els.main = document.createElement("div");
	      this.els.main.id = "crud-main";
	      this.getFrameClasses().MAIN_CLASS.forEach(function (name) {
	        return _this4.els.main.classList.add(name);
	      });
	      el.appendChild(this.els.main);
	      this.els.bottom = document.createElement("div");
	      this.els.bottom.id = "crud-bottom";
	      this.getFrameClasses().BOTTOM_CLASS.forEach(function (name) {
	        return _this4.els.bottom.classList.add(name);
	      });
	      el.appendChild(this.els.bottom);
	    }
	  }, {
	    key: "getFrameClasses",
	    value: function getFrameClasses() {
	      return {
	        TOP_CLASS: this.TOP_CLASS,
	        MAIN_CLASS: this.MAIN_CLASS,
	        BOTTOM_CLASS: this.BOTTOM_CLASS
	      };
	    }
	  }, {
	    key: "getContainerTopElement",
	    value: function getContainerTopElement() {
	      return this.els.top;
	    }
	  }, {
	    key: "getContainerInnerElement",
	    value: function getContainerInnerElement() {
	      return this.els.main;
	    }
	  }, {
	    key: "getContainerBottomElement",
	    value: function getContainerBottomElement() {
	      return this.els.bottom;
	    }
	  }, {
	    key: "preloadVariants",
	    value: async function preloadVariants(type = "list") {
	      await _classPrivateFieldGet2(_preloader, this).preload(this, type);
	    }
	  }, {
	    key: "getTitleFromLib",
	    value: function getTitleFromLib(propName, id) {
	      const actionName = this.getCurrentAction();
	      this.debug && this.debug("notCRUD.getTitleFromLib is obsolete, use notCRUD.getPreloadedVariantTitle(actionName, propName, id)");
	      return this.getPreloadedVariantTitle(actionName, propName, id);
	    }
	  }, {
	    key: "getPreloadedVariants",
	    value: function getPreloadedVariants(actionName, propName) {
	      return this.getOptions(`variants.${actionName}.${propName}`, []);
	    }
	  }, {
	    key: "getPreloadedVariantTitle",
	    value: function getPreloadedVariantTitle(actionName, propName, id) {
	      const variants = this.getPreloadedVariants(actionName, propName);
	      const item = variants.find(function (item) {
	        return item.id === id;
	      });
	      if (item) {
	        return item.title;
	      } else {
	        return id;
	      }
	    }
	  }, {
	    key: "getItemTitle",
	    value: function getItemTitle(item) {
	      const fieldName = this.TITLE_FIELDS_PRIORITY.find(function (key) {
	        return notCommon$1.objHas(item, key);
	      });
	      if (fieldName) {
	        return item[fieldName];
	      } else {
	        return "";
	      }
	    }
	  }, {
	    key: "createDefault",
	    value: function createDefault() {
	      return this.getModel({}).toDefault();
	    }
	  }, {
	    key: "route",
	    value: function route(params = []) {
	      try {
	        return _classPrivateFieldGet2(_router, this).route(this, params);
	      } catch (e) {
	        this.report(e);
	        this.showErrorMessage(e);
	      }
	    }
	  }, {
	    key: "actionHandlerExists",
	    value: function actionHandlerExists(actionName) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return true;
	      }
	      if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return true;
	      }
	      return false;
	    }
	  }, {
	    key: "runAction",
	    value: function runAction(actionName, params) {
	      if (Object.keys(_classPrivateFieldGet2(_actions, this)).includes(actionName)) {
	        return _classPrivateFieldGet2(_actions, this)[actionName].run(this, params);
	      } else if (typeof this["run" + notCommon$1.capitalizeFirstLetter(actionName)] === "function") {
	        return this["run" + notCommon$1.capitalizeFirstLetter(actionName)](params);
	      } else {
	        throw new Error(`No such action: ${actionName} in contoller ${this.getWorking("name")}`);
	      }
	    }

	    /**
	     *  Changes location to create page, after delay
	     *  @param {number|string} [delay=0] number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goCreate",
	    value: function goCreate(delay = 0) {
	      this.goAfterDelay(this.getModelActionURL("", "create"), delay);
	    }

	    /**
	     *  Changes location to document details page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDetails",
	    value: function goDetails(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, ""), delay);
	    }

	    /**
	     * Changes location to document update page, after delay
	     * @param {string}          id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goUpdate",
	    value: function goUpdate(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "update"), delay);
	    }

	    /**
	     *  Changes location to document delete page, after delay
	     *  @param {string}         id          target document id
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goDelete",
	    value: function goDelete(id, delay = 0) {
	      this.goAfterDelay(this.getModelActionURL(id, "delete"), delay);
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goList",
	    value: function goList(delay = 0) {
	      this.goAfterDelay(this.getModelURL(), delay);
	    }

	    /**
	     *
	     * @param {string} url
	     * @param {number|string} delay
	     */
	  }, {
	    key: "goAfterDelay",
	    value: function goAfterDelay(url, delay = 0) {
	      var _this5 = this;
	      this.navigateWithDelay(url, delay, function () {
	        return _this5.$destroyUI();
	      });
	    }

	    /**
	     *  Changes location to documents list page, after delay
	     *  @param {number|string}  [delay=0]   number for ms, or string if we use `delays` alises aka SHORT, NORMAL, LONG
	     */
	  }, {
	    key: "goBack",
	    value: function goBack(delay = 0) {
	      this.goList(delay);
	    }
	  }, {
	    key: "onActionSubmit",
	    value: async function onActionSubmit(action, item) {
	      let state = true;
	      const actionUI = this.ui[action];
	      if (actionUI) {
	        try {
	          actionUI.setLoading();
	          let result = await this.getModel(item)[`$${action}`]();
	          state = actionUI.processResult(result);
	        } catch (e) {
	          state = actionUI.processResult(e);
	        } finally {
	          actionUI.resetLoading();
	          // eslint-disable-next-line no-unsafe-finally
	          return state;
	        }
	      } else {
	        throw new Error("Action UI doesnt exist");
	      }
	    }
	  }, {
	    key: "$destroyUI",
	    value: function $destroyUI() {
	      for (let name in this.ui) {
	        this.destroyUIByName(name);
	      }
	    }
	  }, {
	    key: "destroyUIByName",
	    value: function destroyUIByName(name) {
	      // @ts-ignore
	      if (Object.hasOwn(this.ui, name)) {
	        this.ui[name].$destroy && this.ui[name].$destroy();
	        this.ui[name].destroy && this.ui[name].destroy();
	        delete this.ui[name];
	      }
	    }
	  }, {
	    key: "showErrorMessage",
	    value: function showErrorMessage(res) {
	      this.error && this.error(res);
	      this.app && this.app.emit("error", {
	        title: "Произошла ошибка",
	        message: res.message ? res.message : UICommon$1.ERROR_DEFAULT
	      });
	      CRUDMessage.error(this, "Произошла ошибка", res.message ? res.message : UICommon$1.ERROR_DEFAULT);
	    }
	  }, {
	    key: "showSuccessMessage",
	    value: function showSuccessMessage(title, message) {
	      this.app && this.app.emit("success", {
	        title,
	        message
	      });
	      CRUDMessage.success(this, title, message);
	    }
	  }, {
	    key: "setUI",
	    value: function setUI(name, val, singleUI = true) {
	      if (singleUI) {
	        this.$destroyUI();
	      }
	      this.ui[name] = val;
	    }
	  }, {
	    key: "getUI",
	    value: function getUI(name) {
	      return this.ui[name];
	    }
	  }, {
	    key: "getActionUI",
	    value: function getActionUI() {
	      return this.ui[this.getCurrentAction()];
	    }
	  }, {
	    key: "renderLoadingScreen",
	    value: function renderLoadingScreen() {
	      this.setUI(LOADING_SCREEN_UI_NAME, this.createLoaderUI());
	    }
	  }, {
	    key: "removeLoadingScreen",
	    value: function removeLoadingScreen() {
	      this.destroyUIByName(LOADING_SCREEN_UI_NAME);
	    }
	  }, {
	    key: "createLoaderUI",
	    value: function createLoaderUI() {
	      return mount(Ui_loader, {
	        target: this.getContainerInnerElement(),
	        props: {
	          loading: true,
	          title: ""
	        }
	      });
	    }
	  }], [{
	    key: "LABELS",
	    get: function () {
	      return Object.freeze({
	        plural: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_plural`,
	        single: `${this.MODULE_NAME}:${this.MODEL_NAME}_label_single`
	      });
	    }
	  }, {
	    key: "getMenu",
	    value: function getMenu(itemCustomProps = {}) {
	      return [{
	        section: this.MODULE_NAME,
	        title: this.LABELS.plural,
	        url: `/${notCommon$1.lowerFirstLetter(this.MODULE_NAME)}/${notCommon$1.lowerFirstLetter(this.MODEL_NAME)}`,
	        ...itemCustomProps
	      }];
	    }
	  }]);
	}(notController);
	_defineProperty(notCRUD, "ERROR_DEFAULT", UICommon$1.ERROR_DEFAULT);

	const ROUTE_LIST = "list";
	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDPlainRouter = /*#__PURE__*/function () {
	  function notCRUDPlainRouter() {
	    _classCallCheck(this, notCRUDPlainRouter);
	  }
	  return _createClass(notCRUDPlainRouter, null, [{
	    key: "extractActionName",
	    value:
	    /**
	     * Returns first item from params or throws Error
	     * @param {string[]} params array of strings parsed from URI by route rules
	     * @returns {string}
	     */
	    function extractActionName(params) {
	      if (params.length > 0) {
	        return params[0];
	      }
	      return this.DEFAULT_ROUTE;
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: function route(controller, params) {
	      try {
	        const actionName = this.extractActionName(params);
	        controller.setCurrentAction(actionName);
	        return controller.runAction(actionName, params);
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();
	_defineProperty(notCRUDPlainRouter, "DEFAULT_ROUTE", ROUTE_LIST);

	/**
	 * Runs controller action by name that gets from URI params
	 * @class
	 */
	let notCRUDRouterSwitch = /*#__PURE__*/function () {
	  function notCRUDRouterSwitch() {
	    _classCallCheck(this, notCRUDRouterSwitch);
	  }
	  return _createClass(notCRUDRouterSwitch, null, [{
	    key: "routesVariants",
	    get:
	    /**
	     * Variants of this action
	     */
	    function () {
	      return {
	        /**
	        routeName: Action
	         */
	      };
	    }

	    /**
	     * Returns true if variant name is valid
	     * @param {string} name    name of route variant
	     * @returns {boolean}
	     */
	  }, {
	    key: "isRouteVariantValid",
	    value: function isRouteVariantValid(name) {
	      return name !== "" && notCommon$1.objHas(this.routesVariants, name);
	    }

	    /**
	     * This function returns which of routes variant should be executed
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]}    params  params passed to router
	     * @returns {Promise<string>}    name of route variant
	     */
	    // eslint-disable-next-line no-unused-vars
	  }, {
	    key: "determineRoute",
	    value: async function determineRoute(controller, params = []) {
	      return "";
	    }

	    /**
	     * Runs controller action or throws
	     * @param {object} controller   instance of notController descendant
	     * @param {string[]} params
	     */
	  }, {
	    key: "route",
	    value: async function route(controller, params) {
	      try {
	        const actionName = await this.determineRoute(controller, params);
	        if (this.isRouteVariantValid(actionName)) {
	          controller.setCurrentAction(actionName);
	          const routerAction = this.routesVariants[actionName];
	          if (notCommon$1.isAsync(routerAction.run)) {
	            await routerAction.run(controller, params);
	          } else {
	            routerAction.run(controller, params);
	          }
	        } else {
	          throw new Error(`No such action: ${actionName} in contoller ${controller.getWorking("name")}`);
	        }
	      } catch (e) {
	        controller.report(e);
	        controller.showErrorMessage(e);
	      }
	    }
	  }]);
	}();

	const emptyResult = function () {
	  return {
	    list: [],
	    count: 0,
	    page: 0,
	    pages: 0,
	    skip: 0
	  };
	};
	let notServiceModelSearch = /*#__PURE__*/function () {
	  function notServiceModelSearch(app, modelName) {
	    _classCallCheck(this, notServiceModelSearch);
	    this.modelName = modelName;
	    this.app = app;
	  }
	  return _createClass(notServiceModelSearch, [{
	    key: "destroy",
	    value: function destroy() {
	      delete this.app;
	    }
	  }, {
	    key: "getSearchRouteName",
	    value: function getSearchRouteName() {
	      return "listAndCount";
	    }
	  }, {
	    key: "getDataLoadRouteName",
	    value: function getDataLoadRouteName() {
	      return "get";
	    }
	  }, {
	    key: "transformSearchResult",
	    value: function transformSearchResult(result) {
	      var _this = this;
	      result.list = result.list.map(function (item) {
	        return {
	          _id: item._id,
	          id: item[`${_this.modelName}ID`],
	          title: item.name || item.title || item.label || item.username
	        };
	      });
	      return result;
	    }
	  }, {
	    key: "transformSelectedResult",
	    value: function transformSelectedResult(result) {
	      return {
	        _id: result._id,
	        [`${this.modelName}ID`]: result.id,
	        title: result.title
	      };
	    }
	  }, {
	    key: "searchByTerm",
	    value: async function searchByTerm(term) {
	      try {
	        if (term.value.length > 2) {
	          const model = this.app.getModel(this.modelName);
	          model.setSearch(term.value);
	          const response = await model[`$${this.getSearchRouteName()}`]();
	          if (response.status === "ok") {
	            return this.transformSearchResult(response.result);
	          } else {
	            return emptyResult();
	          }
	        } else {
	          return emptyResult();
	        }
	      } catch {
	        return emptyResult();
	      }
	    }
	  }, {
	    key: "openSelector",
	    value: function openSelector() {
	      var _this2 = this;
	      return new Promise(function (resolve, reject) {
	        try {
	          const el = mount(Ui_generic_selector, {
	            target: document.body,
	            props: {}
	          });
	          el.$on("termChange", async function ({
	            detail
	          }) {
	            const results = await _this2.searchByTerm(detail);
	            el.$set({
	              results
	            });
	          });
	          el.$on("next", function () {
	            console.log("next selector results");
	          });
	          el.$on("prev", function () {
	            console.log("prev selector results");
	          });
	          el.$on("reject", function () {
	            unmount(el);
	            reject();
	          });
	          el.$on("resolve", function ({
	            detail
	          }) {
	            unmount(el);
	            resolve(_this2.transformSelectedResult(detail));
	          });
	        } catch (e) {
	          _this2.app.error(e);
	          reject(e);
	        }
	      });
	    }
	  }, {
	    key: "loadData",
	    value: async function loadData(_id) {
	      try {
	        if (_id && _id.length > 10) {
	          const model = this.app.getModel(this.modelName, {
	            _id
	          });
	          const response = await model[`$${this.getDataLoadRouteName()}`]();
	          if (response.status === "ok") {
	            return response.result;
	          } else {
	            return null;
	          }
	        } else {
	          return null;
	        }
	      } catch (e) {
	        this.app.error(e);
	        return null;
	      }
	    }
	  }]);
	}();

	//import 'babel-polyfill/dist/polyfill';

	const ncCRUD = notCRUD; //legacy alias

	var Frame = /*#__PURE__*/Object.freeze({
		__proto__: null,
		COMPONENTS: COMPONENTS$1,
		FIELDS: FIELDS$1,
		UIForm: Form,
		VARIANTS: VARIANTS$1,
		createCRUDActionUIView: create_crud_action_ui_view,
		ncCRUD: ncCRUD,
		notAPI: index,
		notApp: notApp,
		notBase: notBase,
		notBreadcrumbs: notBreadcrumbs,
		notCRUD: notCRUD,
		notCRUDRouter: notCRUDRouter,
		notCRUDRouterPlain: notCRUDPlainRouter,
		notCRUDRouterSwitch: notCRUDRouterSwitch,
		notCommon: notCommon$1,
		notController: notController,
		notForm: notForm,
		notFormHelpers: FormHelpers,
		notFormRules: notFormRules,
		notFormSet: notFormSet,
		notFormUtils: notFormUtils$1,
		notInterface: notInterface,
		notPath: notPath,
		notRecord: notRecord,
		notRouter: notRouter$1,
		notServiceModelSearch: notServiceModelSearch,
		notSideMenu: notSideMenu,
		notStores: stores,
		notTable: notTable,
		notTopMenu: notTopMenu
	});

	const Locale = {
	  LOCALE,
	  say,
	  notLocale: notLocale$1
	};
	const UICommon = UICommon$1;
	const {
	  notCommon,
	  COMPONENTS,
	  FIELDS,
	  VARIANTS,
	  notFormUtils
	} = Frame;
	Object.keys(Elements).forEach(function (componentsSetName) {
	  Object.keys(Elements[componentsSetName]).forEach(function (componentName) {
	    notFormUtils$1.addComponent(componentName, Elements[componentsSetName][componentName]);
	  });
	});

	exports.COMPONENTS = COMPONENTS;
	exports.Elements = Elements;
	exports.FIELDS = FIELDS;
	exports.Frame = Frame;
	exports.LOCALE = LOCALE;
	exports.Locale = Locale;
	exports.UICommon = UICommon;
	exports.VARIANTS = VARIANTS;
	exports.notCommon = notCommon;
	exports.notFormUtils = notFormUtils;
	exports.notLocale = notLocale$1;
	exports.say = say;
	exports.svelte = indexClient;

	return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90QnVsbWEuanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9lc20tZW52L3RydWUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvY2xvbmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L293bmVyc2hpcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9lcnJvcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3NvdXJjZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2h5ZHJhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9wcm94eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL29wZXJhdGlvbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9kZXJpdmVkcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VmZmVjdHMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL3Rhc2suanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9taXNjLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vcmVjb25jaWxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vdGVtcGxhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvaWYuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9lYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvaHRtbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3Nsb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zbmlwcGV0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc3ZlbHRlLWNvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3N2ZWx0ZS1lbGVtZW50LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm1qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9hdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9hdHRyaWJ1dGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9jbGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC90aW1pbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvbG9vcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvdHJhbnNpdGlvbnMuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL2lucHV0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9wcm9wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3Mvc2VsZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy90aGlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvZXZlbnQtbW9kaWZpZXJzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbGlmZWN5Y2xlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbWlzYy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3N0b3JlL3V0aWxzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvc3RvcmUuanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9wcm9wcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2luZGV4LWNsaWVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3ZlcnNpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9kaXNjbG9zZS12ZXJzaW9uLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2NvbW1vbi5qcyIsIi4uL3NyYy9lbGVtZW50cy9ibG9jay91aS5ibG9jay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuYmxvY2suaW5uZXIudmVydGljYWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Jsb2NrL3VpLmJveC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuY29udGVudC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYmxvY2svdWkuY2xpY2thYmxlLmRpdi5zdmVsdGUiLCIuLi9zcmMvbG9jYWxlL3N0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dvbGZ5ODctZXZlbnRlbWl0dGVyL0V2ZW50RW1pdHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtcGF0aC9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXBhdGgvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tbW9uLmpzIiwiLi4vc3JjL2xvY2FsZS9ub3RMb2NhbGUuanMiLCIuLi9zcmMvbG9jYWxlL2luZGV4LmpzIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuYm9vbGVhbi5sYWJlbGVkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW5zLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmNlbnNvcmVkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLmluZGljYXRvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5sb2FkZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5jbG9zZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnJvdy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvYnV0dG9uL3VpLmJ1dHRvbi5zd2l0Y2guc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN3aXRjaGVycy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuZmllbGQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmNvbnRyb2wuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkuc2VsZWN0LmZyb20ubW9kZWwub24uZGVtYW5kLmlubGluZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zZWxlY3QuZnJvbS5tb2RlbC53aXRoLnNlYXJjaC5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5wcm9ncmVzcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5zaG93Lm9uZS5mcm9tLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL3ZhcmlvdXMvdWkudGFnLnZhbHVlLnN2ZWx0ZSIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2ZsYWdzL2xlZ2FjeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2Vhc2luZy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2FuaW1hdGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy90cmFuc2l0aW9uL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlL3NyYy9TaW1wbGVBdXRvY29tcGxldGUuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuYXV0b2NvbXBsZXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jb2xvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubGFiZWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmNoZWNrYm94LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5jaGVja2JveC5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5kYXRlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5kYXRldGltZS5pbi50ei5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuZW1haWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmhpZGRlbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkudGV4dGFyZWEuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLmpzb24uYXJlYS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvbGliLmpzIiwiLi4vc3JjL2ZyYW1lL0xJQi5qcyIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3VpLmxpc3QuZW1wdHkucGxhY2Vob2xkZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpbmsvdWkubGluay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGluay91aS5saW5rcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC91aS5saXN0Lml0ZW0uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3QvdWkubGlzdC5ibG9jay5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC91aS5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5saXN0Lm9mLm1vZGVscy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmNvbHVtbi5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGF5b3V0L3VpLmNvbHVtbnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5jb250YWluZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5mb290ZXIuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2xheW91dC91aS5zZWN0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9sYXlvdXQvdWkubGV2ZWwuaXRlbS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkubnVtYmVyLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbnB1dC91aS5uYW1lZC5udW1iZXJzLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnBhc3N3b3JkLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbWFnZS91aS5pbWFnZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucmFkaW8uYnV0dG9ucy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkucmFuZ2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnNlbGVjdC5tdWx0aXBsZS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29uc3QuanMiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc2VsZWN0LmZyb20ubW9kZWwuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnN3aXRjaC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaW5wdXQvdWkuc3dpdGNoLmxpc3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRhZy5zZWxlY3Quc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2lucHV0L3VpLnRlbGVwaG9uZS5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS50YWcudmFsdWUubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS5lcnJvcnMubGlzdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvdmFyaW91cy91aS51c2VyLmNhcmQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mb250LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC5lcnJvcnMuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5idXR0b24ud2l0aC50YWcuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mbG9hdGluZy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvaWNvbi91aS5pY29uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9mb3JtL3VpLmZvcm0uaW5wdXQudmFsaWRhdGVkLmljb24uc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2Zvcm0vdWkuZm9ybS5pbnB1dC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvZm9ybS91aS5mb3JtLmNvbnRyb2wuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL2ltYWdlL3VpLmltYWdlcy5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC9lbmRsZXNzL3VpLmVuZGxlc3MubGlzdC5uYXZpZ2F0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0LnNpbXBsZS5pdGVtLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L2VuZGxlc3MvdWkuZW5kbGVzcy5saXN0LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC91aS5saXN0LnNlbGVjdC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbGlzdC9zZWxlY3QvZHRvL2xpc3QuZ3JvdXBzLnVpLnRyZWUuZHRvLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8ubXVsdGlwbGUuYmVoYXZpb3VyLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L2R0by9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8uc2luZ2xlLmJlaGF2aW91ci5qcyIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC9kdG8vbGlzdC5ncm91cHMudmFsdWUuZHRvLmpzIiwiLi4vc3JjL2VsZW1lbnRzL2xpc3Qvc2VsZWN0L3VpLmxpc3Quc2VsZWN0LndpdGguZ3JvdXBzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9saXN0L3NlbGVjdC91aS5saXN0LnNlbGVjdC5idXR0b25zLndpdGguZ3JvdXBzLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9tb2RhbC91aS5vdmVybGF5LnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9tb2RhbC91aS5tb2RhbC5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbW9kYWwvdWkuZ2VuZXJpYy5zZWxlY3Rvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLm1lc3NhZ2Uuc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5lcnJvci5zdmVsdGUiLCIuLi9zcmMvZWxlbWVudHMvbm90aWZpY2F0aW9uL3VpLnN1Y2Nlc3Muc3ZlbHRlIiwiLi4vc3JjL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5jb29raWUubm90aWZpY2F0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9lbGVtZW50cy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9iYXNlLmpzIiwiLi4vc3JjL2ZyYW1lL3JvdXRlci5qcyIsIi4uL3NyYy9mcmFtZS9hcGkvcXVldWUuanMiLCIuLi9zcmMvZnJhbWUvYXBpL29wdGlvbnMuanMiLCIuLi9zcmMvZnJhbWUvYXBpL2Nvbm5lY3Rpb24uanMiLCIuLi9zcmMvZnJhbWUvc3RvcmVzLmpzIiwiLi4vc3JjL2ZyYW1lL29wdGlvbnMuanMiLCIuLi9zcmMvZnJhbWUvaW50ZXJmYWNlLmpzIiwiLi4vc3JjL2ZyYW1lL3JlY29yZC5qcyIsIi4uL3NyYy9mcmFtZS9hcHAuanMiLCIuLi9zcmMvZnJhbWUvY29udHJvbGxlci5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL3N0b3Jlcy5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL2NvbnRyb2xzL3VpLnN3aXRjaC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9jb250cm9scy91aS50YWdzLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL3RhYmxlL25vdFRhYmxlQ2VsbC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZVJvdy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy90YWJsZS9ub3RUYWJsZS5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2FjdGlvbi91aS5hY3Rpb24uY29udGFpbmVyLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2FjdGlvbi9hY3Rpb24udWkuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL3V0aWxzLmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvZm9ybS9mb3JtLmhlbHBlcnMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL3Jlc3VsdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtZXJyb3Ivc3JjL2Vycm9yLm5vZGUuY2pzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC1lcnJvci9zcmMvdmFsaWRhdGlvbi5lcnJvci5ub2RlLmNqcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvY29tbW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9zZXNzaW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL25vdC12YWxpZGF0aW9uL3NyYy9ydW5uZXIudXRpbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbm90LXZhbGlkYXRpb24vc3JjL3J1bm5lci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvYnVpbGRlci51dGlscy5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvYnVpbGRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9ub3QtdmFsaWRhdGlvbi9zcmMvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2ZpZWxkLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0ucnVsZXMuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9mb3JtL2Zvcm0uc2V0LnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2Zvcm0vZm9ybS5zZXQuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy91aS5icmVhZGNydW1icy5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9icmVhZGNydW1icy9icmVhZGNydW1icy5qcyIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2luZGV4LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9tZW51LmpzIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLml0ZW0ud2l0aG91dC5jaGlsZHJlbi5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvdWkudHJpZ2dlci5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvdWkuaXRlbS5sYWJlbC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvdWkuaXRlbXMuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLnNlY3Rpb24uc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9zaWRlL3VpLnNpZGUubWVudS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvc3RvcmUuanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3NpZGUvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS5icmFuZC5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS5pdGVtLmNvbnRlbnQuc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvdWkuaXRlbS5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS5zZWN0aW9uLnN2ZWx0ZSIsIi4uL3NyYy9mcmFtZS9jb21wb25lbnRzL25hdmlnYXRpb24vdG9wL3VpLmJ1cmdlci5zdmVsdGUiLCIuLi9zcmMvZnJhbWUvY29tcG9uZW50cy9uYXZpZ2F0aW9uL3RvcC91aS50b3Auc3ZlbHRlIiwiLi4vc3JjL2ZyYW1lL2NvbXBvbmVudHMvbmF2aWdhdGlvbi90b3AvaW5kZXguanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9jb25zdC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2NyZWF0ZS5jcnVkLmFjdGlvbi51aS52aWV3LmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvdmFyaWFudHMucHJlbG9hZGVyLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvcm91dGVyLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvbWVzc2FnZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZ2VuZXJpYy9hY3Rpb24uanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvY3JlYXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9jcmVhdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL2dlbmVyaWMvcmVhZC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZGV0YWlscy5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZ2VuZXJpYy91cGRhdGUuanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9hY3Rpb25zL3VwZGF0ZS5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2FjdGlvbnMvZGVsZXRlLmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9saXN0LmpzIiwiLi4vc3JjL2ZyYW1lL2NydWQvYWN0aW9ucy9pbmRleC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL2NvbnRyb2xsZXIuY3J1ZC5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3JvdXRlci5wbGFpbi5qcyIsIi4uL3NyYy9mcmFtZS9jcnVkL3JvdXRlci5zd2l0Y2guanMiLCIuLi9zcmMvZnJhbWUvY3J1ZC9zZWFyY2guc2VydmljZS5qcyIsIi4uL3NyYy9mcmFtZS9pbmRleC5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB0cnVlO1xuIiwiLy8gU3RvcmUgdGhlIHJlZmVyZW5jZXMgdG8gZ2xvYmFscyBpbiBjYXNlIHNvbWVvbmUgdHJpZXMgdG8gbW9ua2V5IHBhdGNoIHRoZXNlLCBjYXVzaW5nIHRoZSBiZWxvd1xuLy8gdG8gZGUtb3B0ICh0aGlzIG9jY3VycyBvZnRlbiB3aGVuIHVzaW5nIHBvcHVsYXIgZXh0ZW5zaW9ucykuXG5leHBvcnQgdmFyIGlzX2FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydCB2YXIgaW5kZXhfb2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbmV4cG9ydCB2YXIgYXJyYXlfZnJvbSA9IEFycmF5LmZyb207XG5leHBvcnQgdmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXM7XG5leHBvcnQgdmFyIGRlZmluZV9wcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydCB2YXIgZ2V0X2Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZXhwb3J0IHZhciBnZXRfZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbmV4cG9ydCB2YXIgb2JqZWN0X3Byb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5leHBvcnQgdmFyIGFycmF5X3Byb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgZ2V0X3Byb3RvdHlwZV9vZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBjb25zdCBub29wID0gKCkgPT4ge307XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuLyoqXG4gKiBAdGVtcGxhdGUgW1Q9YW55XVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUHJvbWlzZUxpa2U8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWU/LnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuLyoqIEBwYXJhbSB7QXJyYXk8KCkgPT4gdm9pZD59IGFyciAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoYXJyKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJyW2ldKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUT0RPIHJlcGxhY2Ugd2l0aCBQcm9taXNlLndpdGhSZXNvbHZlcnMgb25jZSBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaFxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuXHQvKiogQHR5cGUgeyh2YWx1ZTogVCkgPT4gdm9pZH0gKi9cblx0dmFyIHJlc29sdmU7XG5cblx0LyoqIEB0eXBlIHsocmVhc29uOiBhbnkpID0+IHZvaWR9ICovXG5cdHZhciByZWplY3Q7XG5cblx0LyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqL1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdHJlc29sdmUgPSByZXM7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHR9KTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge1YgfCAoKCkgPT4gVil9IGZhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsYXp5XVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWxsYmFjayh2YWx1ZSwgZmFsbGJhY2ssIGxhenkgPSBmYWxzZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuXHRcdD8gbGF6eVxuXHRcdFx0PyAvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykoKVxuXHRcdFx0OiAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjaylcblx0XHQ6IHZhbHVlO1xufVxuIiwiZXhwb3J0IGNvbnN0IERFUklWRUQgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgRUZGRUNUID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFJFTkRFUl9FRkZFQ1QgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgQkxPQ0tfRUZGRUNUID0gMSA8PCA0O1xuZXhwb3J0IGNvbnN0IEJSQU5DSF9FRkZFQ1QgPSAxIDw8IDU7XG5leHBvcnQgY29uc3QgUk9PVF9FRkZFQ1QgPSAxIDw8IDY7XG5leHBvcnQgY29uc3QgQk9VTkRBUllfRUZGRUNUID0gMSA8PCA3O1xuZXhwb3J0IGNvbnN0IFVOT1dORUQgPSAxIDw8IDg7XG5leHBvcnQgY29uc3QgRElTQ09OTkVDVEVEID0gMSA8PCA5O1xuZXhwb3J0IGNvbnN0IENMRUFOID0gMSA8PCAxMDtcbmV4cG9ydCBjb25zdCBESVJUWSA9IDEgPDwgMTE7XG5leHBvcnQgY29uc3QgTUFZQkVfRElSVFkgPSAxIDw8IDEyO1xuZXhwb3J0IGNvbnN0IElORVJUID0gMSA8PCAxMztcbmV4cG9ydCBjb25zdCBERVNUUk9ZRUQgPSAxIDw8IDE0O1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9SQU4gPSAxIDw8IDE1O1xuLyoqICdUcmFuc3BhcmVudCcgZWZmZWN0cyBkbyBub3QgY3JlYXRlIGEgdHJhbnNpdGlvbiBib3VuZGFyeSAqL1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9UUkFOU1BBUkVOVCA9IDEgPDwgMTY7XG4vKiogU3ZlbHRlIDQgbGVnYWN5IG1vZGUgcHJvcHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggZGVyaXZlZHMgYW5kIGJlIHJlY29nbml6ZWQgZWxzZXdoZXJlLCBoZW5jZSB0aGUgZGVkaWNhdGVkIGZsYWcgKi9cbmV4cG9ydCBjb25zdCBMRUdBQ1lfREVSSVZFRF9QUk9QID0gMSA8PCAxNztcbmV4cG9ydCBjb25zdCBJTlNQRUNUX0VGRkVDVCA9IDEgPDwgMTg7XG5leHBvcnQgY29uc3QgSEVBRF9FRkZFQ1QgPSAxIDw8IDE5O1xuZXhwb3J0IGNvbnN0IEVGRkVDVF9IQVNfREVSSVZFRCA9IDEgPDwgMjA7XG5cbmV4cG9ydCBjb25zdCBTVEFURV9TWU1CT0wgPSBTeW1ib2woJyRzdGF0ZScpO1xuZXhwb3J0IGNvbnN0IFNUQVRFX1NZTUJPTF9NRVRBREFUQSA9IFN5bWJvbCgnJHN0YXRlIG1ldGFkYXRhJyk7XG5leHBvcnQgY29uc3QgTEVHQUNZX1BST1BTID0gU3ltYm9sKCdsZWdhY3kgcHJvcHMnKTtcbmV4cG9ydCBjb25zdCBMT0FESU5HX0FUVFJfU1lNQk9MID0gU3ltYm9sKCcnKTtcbiIsIi8qKiBAaW1wb3J0IHsgRXF1YWxzIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAdHlwZSB7RXF1YWxzfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHRoaXMudjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGFcblx0XHQ/IGIgPT0gYlxuXHRcdDogYSAhPT0gYiB8fCAoYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gYVxuICogQHBhcmFtIHt1bmtub3dufSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9PSBiO1xufVxuXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX2VxdWFscyh2YWx1ZSkge1xuXHRyZXR1cm4gIXNhZmVfbm90X2VxdWFsKHZhbHVlLCB0aGlzLnYpO1xufVxuIiwiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuLyoqXG4gKiBVc2luZyBgYmluZDp2YWx1ZWAgdG9nZXRoZXIgd2l0aCBhIGNoZWNrYm94IGlucHV0IGlzIG5vdCBhbGxvd2VkLiBVc2UgYGJpbmQ6Y2hlY2tlZGAgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZVxcblVzaW5nIFxcYGJpbmQ6dmFsdWVcXGAgdG9nZXRoZXIgd2l0aCBhIGNoZWNrYm94IGlucHV0IGlzIG5vdCBhbGxvd2VkLiBVc2UgXFxgYmluZDpjaGVja2VkXFxgIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogQ29tcG9uZW50ICVjb21wb25lbnQlIGhhcyBhbiBleHBvcnQgbmFtZWQgYCVrZXklYCB0aGF0IGEgY29uc3VtZXIgY29tcG9uZW50IGlzIHRyeWluZyB0byBhY2Nlc3MgdXNpbmcgYGJpbmQ6JWtleSVgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgYGJpbmQ6dGhpc2AgKGUuZy4gYDwlbmFtZSUgYmluZDp0aGlzPXtjb21wb25lbnR9IC8+YCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIGBjb21wb25lbnQuJWtleSVgKVxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfaW52YWxpZF9leHBvcnQoY29tcG9uZW50LCBrZXksIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX2ludmFsaWRfZXhwb3J0XFxuQ29tcG9uZW50ICR7Y29tcG9uZW50fSBoYXMgYW4gZXhwb3J0IG5hbWVkIFxcYCR7a2V5fVxcYCB0aGF0IGEgY29uc3VtZXIgY29tcG9uZW50IGlzIHRyeWluZyB0byBhY2Nlc3MgdXNpbmcgXFxgYmluZDoke2tleX1cXGAsIHdoaWNoIGlzIGRpc2FsbG93ZWQuIEluc3RlYWQsIHVzZSBcXGBiaW5kOnRoaXNcXGAgKGUuZy4gXFxgPCR7bmFtZX0gYmluZDp0aGlzPXtjb21wb25lbnR9IC8+XFxgKSBhbmQgdGhlbiBhY2Nlc3MgdGhlIHByb3BlcnR5IG9uIHRoZSBib3VuZCBjb21wb25lbnQgaW5zdGFuY2UgKGUuZy4gXFxgY29tcG9uZW50LiR7a2V5fVxcYClcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgYCVrZXklYCBiZWxvbmdpbmcgdG8gJWNvbXBvbmVudCUgKGkuZS4gYDwlbmFtZSUgYmluZDola2V5JT17Li4ufT5gKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBgbGV0IHsgJWtleSUgPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClgXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ub3RfYmluZGFibGUoa2V5LCBjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX25vdF9iaW5kYWJsZVxcbkEgY29tcG9uZW50IGlzIGF0dGVtcHRpbmcgdG8gYmluZCB0byBhIG5vbi1iaW5kYWJsZSBwcm9wZXJ0eSBcXGAke2tleX1cXGAgYmVsb25naW5nIHRvICR7Y29tcG9uZW50fSAoaS5lLiBcXGA8JHtuYW1lfSBiaW5kOiR7a2V5fT17Li4ufT5cXGApLiBUbyBtYXJrIGEgcHJvcGVydHkgYXMgYmluZGFibGU6IFxcYGxldCB7ICR7a2V5fSA9ICRiaW5kYWJsZSgpIH0gPSAkcHJvcHMoKVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfbm90X2JpbmRhYmxlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX25vdF9iaW5kYWJsZWApO1xuXHR9XG59XG5cbi8qKlxuICogJXBhcmVudCUgY2FsbGVkIGAlbWV0aG9kJWAgb24gYW4gaW5zdGFuY2Ugb2YgJWNvbXBvbmVudCUsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X2FwaV9jaGFuZ2VkKHBhcmVudCwgbWV0aG9kLCBjb21wb25lbnQpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjb21wb25lbnRfYXBpX2NoYW5nZWRcXG4ke3BhcmVudH0gY2FsbGVkIFxcYCR7bWV0aG9kfVxcYCBvbiBhbiBpbnN0YW5jZSBvZiAke2NvbXBvbmVudH0sIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0ZWQgdG8gaW5zdGFudGlhdGUgJWNvbXBvbmVudCUgd2l0aCBgbmV3ICVuYW1lJWAsIHdoaWNoIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNS4gSWYgdGhpcyBjb21wb25lbnQgaXMgbm90IHVuZGVyIHlvdXIgY29udHJvbCwgc2V0IHRoZSBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGlgIGNvbXBpbGVyIG9wdGlvbiB0byBgNGAgdG8ga2VlcCBpdCB3b3JraW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfaW52YWxpZF9uZXcoY29tcG9uZW50LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld1xcbkF0dGVtcHRlZCB0byBpbnN0YW50aWF0ZSAke2NvbXBvbmVudH0gd2l0aCBcXGBuZXcgJHtuYW1lfVxcYCwgd2hpY2ggaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1LiBJZiB0aGlzIGNvbXBvbmVudCBpcyBub3QgdW5kZXIgeW91ciBjb250cm9sLCBzZXQgdGhlIFxcYGNvbXBhdGliaWxpdHkuY29tcG9uZW50QXBpXFxgIGNvbXBpbGVyIG9wdGlvbiB0byBcXGA0XFxgIHRvIGtlZXAgaXQgd29ya2luZy5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2ludmFsaWRfbmV3YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGRlcml2ZWQgdmFsdWUgY2Fubm90IHJlZmVyZW5jZSBpdHNlbGYgcmVjdXJzaXZlbHlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGRlcml2ZWRfcmVmZXJlbmNlc19zZWxmXFxuQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGZgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IGAldmFsdWUlYCBhdCBpbmRleGVzICVhJSBhbmQgJWIlXG4gKiBAcGFyYW0ge3N0cmluZ30gYVxuICogQHBhcmFtIHtzdHJpbmd9IGJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW3ZhbHVlXVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaF9rZXlfZHVwbGljYXRlKGEsIGIsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWFjaF9rZXlfZHVwbGljYXRlXFxuJHt2YWx1ZSA/IGBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IFxcYCR7dmFsdWV9XFxgIGF0IGluZGV4ZXMgJHthfSBhbmQgJHtifWAgOiBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWFjaF9rZXlfZHVwbGljYXRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJXJ1bmUlYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW4gZWZmZWN0IGNsZWFudXAgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdGVhcmRvd24ocnVuZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl90ZWFyZG93blxcblxcYCR7cnVuZX1cXGAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X2luX3RlYXJkb3duYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdGVhcmRvd25gKTtcblx0fVxufVxuXG4vKipcbiAqIEVmZmVjdCBjYW5ub3QgYmUgY3JlYXRlZCBpbnNpZGUgYSBgJGRlcml2ZWRgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRcXG5FZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgXFxgJGRlcml2ZWRcXGAgdmFsdWUgdGhhdCB3YXMgbm90IGl0c2VsZiBjcmVhdGVkIGluc2lkZSBhbiBlZmZlY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJXJ1bmUlYCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgKGUuZy4gZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbilcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3Rfb3JwaGFuKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3Rfb3JwaGFuXFxuXFxgJHtydW5lfVxcYCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgKGUuZy4gZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbilcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3Rfb3JwaGFuYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3Rfb3JwaGFuYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSByZWFjdGl2ZSBibG9jayBvciBlZmZlY3QgcmVwZWF0ZWRseSBzZXRzIGEgbmV3IHZhbHVlLiBTdmVsdGUgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkXFxuTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgcmVhY3RpdmUgYmxvY2sgb3IgZWZmZWN0IHJlcGVhdGVkbHkgc2V0cyBhIG5ldyB2YWx1ZS4gU3ZlbHRlIGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBGYWlsZWQgdG8gaHlkcmF0ZSB0aGUgYXBwbGljYXRpb25cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9mYWlsZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaHlkcmF0aW9uX2ZhaWxlZFxcbkZhaWxlZCB0byBoeWRyYXRlIHRoZSBhcHBsaWNhdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9mYWlsZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9mYWlsZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENvdWxkIG5vdCBge0ByZW5kZXJ9YCBzbmlwcGV0IGR1ZSB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuIENvbnNpZGVyIHVzaW5nIG9wdGlvbmFsIGNoYWluaW5nIGB7QHJlbmRlciBzbmlwcGV0Py4oKX1gXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9zbmlwcGV0XFxuQ291bGQgbm90IFxcYHtAcmVuZGVyfVxcYCBzbmlwcGV0IGR1ZSB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYC4gQ29uc2lkZXIgdXNpbmcgb3B0aW9uYWwgY2hhaW5pbmcgXFxge0ByZW5kZXIgc25pcHBldD8uKCl9XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2Fubm90IGJlIHVzZWQgaW4gcnVuZXMgbW9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9sZWdhY3lfb25seShuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5XFxuXFxgJHtuYW1lfSguLi4pXFxgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfbGVnYWN5X29ubHlgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9sZWdhY3lfb25seWApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IGRvIGBiaW5kOiVrZXklPXt1bmRlZmluZWR9YCB3aGVuIGAla2V5JWAgaGFzIGEgZmFsbGJhY2sgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX2ludmFsaWRfdmFsdWUoa2V5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfaW52YWxpZF92YWx1ZVxcbkNhbm5vdCBkbyBcXGBiaW5kOiR7a2V5fT17dW5kZWZpbmVkfVxcYCB3aGVuIFxcYCR7a2V5fVxcYCBoYXMgYSBmYWxsYmFjayB2YWx1ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX2ludmFsaWRfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX2ludmFsaWRfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIFJlc3QgZWxlbWVudCBwcm9wZXJ0aWVzIG9mIGAkcHJvcHMoKWAgc3VjaCBhcyBgJXByb3BlcnR5JWAgYXJlIHJlYWRvbmx5XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX3Jlc3RfcmVhZG9ubHkocHJvcGVydHkpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBwcm9wc19yZXN0X3JlYWRvbmx5XFxuUmVzdCBlbGVtZW50IHByb3BlcnRpZXMgb2YgXFxgJHByb3BzKClcXGAgc3VjaCBhcyBcXGAke3Byb3BlcnR5fVxcYCBhcmUgcmVhZG9ubHlcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9wcm9wc19yZXN0X3JlYWRvbmx5YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYCVydW5lJWAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgYC5zdmVsdGVgIGFuZCBgLnN2ZWx0ZS5qcy90c2AgZmlsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBydW5lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBydW5lX291dHNpZGVfc3ZlbHRlXFxuVGhlIFxcYCR7cnVuZX1cXGAgcnVuZSBpcyBvbmx5IGF2YWlsYWJsZSBpbnNpZGUgXFxgLnN2ZWx0ZVxcYCBhbmQgXFxgLnN2ZWx0ZS5qcy90c1xcYCBmaWxlc1xcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblx0fVxufVxuXG4vKipcbiAqIFByb3BlcnR5IGRlc2NyaXB0b3JzIGRlZmluZWQgb24gYCRzdGF0ZWAgb2JqZWN0cyBtdXN0IGNvbnRhaW4gYHZhbHVlYCBhbmQgYWx3YXlzIGJlIGBlbnVtZXJhYmxlYCwgYGNvbmZpZ3VyYWJsZWAgYW5kIGB3cml0YWJsZWAuXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9kZXNjcmlwdG9yc19maXhlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV9kZXNjcmlwdG9yc19maXhlZFxcblByb3BlcnR5IGRlc2NyaXB0b3JzIGRlZmluZWQgb24gXFxgJHN0YXRlXFxgIG9iamVjdHMgbXVzdCBjb250YWluIFxcYHZhbHVlXFxgIGFuZCBhbHdheXMgYmUgXFxgZW51bWVyYWJsZVxcYCwgXFxgY29uZmlndXJhYmxlXFxgIGFuZCBcXGB3cml0YWJsZVxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9kZXNjcmlwdG9yc19maXhlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCBzZXQgcHJvdG90eXBlIG9mIGAkc3RhdGVgIG9iamVjdFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Byb3RvdHlwZV9maXhlZFxcbkNhbm5vdCBzZXQgcHJvdG90eXBlIG9mIFxcYCRzdGF0ZVxcYCBvYmplY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm90b3R5cGVfZml4ZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3RvdHlwZV9maXhlZGApO1xuXHR9XG59XG5cbi8qKlxuICogUmVhZGluZyBzdGF0ZSB0aGF0IHdhcyBjcmVhdGVkIGluc2lkZSB0aGUgc2FtZSBkZXJpdmVkIGlzIGZvcmJpZGRlbi4gQ29uc2lkZXIgdXNpbmcgYHVudHJhY2tgIHRvIHJlYWQgbG9jYWxseSBjcmVhdGVkIHN0YXRlXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV91bnNhZmVfbG9jYWxfcmVhZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV91bnNhZmVfbG9jYWxfcmVhZFxcblJlYWRpbmcgc3RhdGUgdGhhdCB3YXMgY3JlYXRlZCBpbnNpZGUgdGhlIHNhbWUgZGVyaXZlZCBpcyBmb3JiaWRkZW4uIENvbnNpZGVyIHVzaW5nIFxcYHVudHJhY2tcXGAgdG8gcmVhZCBsb2NhbGx5IGNyZWF0ZWQgc3RhdGVcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbG9jYWxfcmVhZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfdW5zYWZlX2xvY2FsX3JlYWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFVwZGF0aW5nIHN0YXRlIGluc2lkZSBhIGRlcml2ZWQgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBgJHN0YXRlYFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfdW5zYWZlX211dGF0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX3Vuc2FmZV9tdXRhdGlvblxcblVwZGF0aW5nIHN0YXRlIGluc2lkZSBhIGRlcml2ZWQgb3IgYSB0ZW1wbGF0ZSBleHByZXNzaW9uIGlzIGZvcmJpZGRlbi4gSWYgdGhlIHZhbHVlIHNob3VsZCBub3QgYmUgcmVhY3RpdmUsIGRlY2xhcmUgaXQgd2l0aG91dCBcXGAkc3RhdGVcXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbXV0YXRpb25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9tdXRhdGlvbmApO1xuXHR9XG59IiwiZXhwb3J0IGxldCBsZWdhY3lfbW9kZV9mbGFnID0gZmFsc2U7XG5leHBvcnQgbGV0IHRyYWNpbmdfbW9kZV9mbGFnID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVfbGVnYWN5X21vZGVfZmxhZygpIHtcblx0bGVnYWN5X21vZGVfZmxhZyA9IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVfdHJhY2luZ19tb2RlX2ZsYWcoKSB7XG5cdHRyYWNpbmdfbW9kZV9mbGFnID0gdHJ1ZTtcbn1cbiIsImV4cG9ydCBjb25zdCBFQUNIX0lURU1fUkVBQ1RJVkUgPSAxO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSU5ERVhfUkVBQ1RJVkUgPSAxIDw8IDE7XG4vKiogU2VlIEVhY2hCbG9jayBpbnRlcmZhY2UgbWV0YWRhdGEuaXNfY29udHJvbGxlZCBmb3IgYW4gZXhwbGFuYXRpb24gd2hhdCB0aGlzIGlzICovXG5leHBvcnQgY29uc3QgRUFDSF9JU19DT05UUk9MTEVEID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IEVBQ0hfSVNfQU5JTUFURUQgPSAxIDw8IDM7XG5leHBvcnQgY29uc3QgRUFDSF9JVEVNX0lNTVVUQUJMRSA9IDEgPDwgNDtcblxuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0lNTVVUQUJMRSA9IDE7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfUlVORVMgPSAxIDw8IDE7XG5leHBvcnQgY29uc3QgUFJPUFNfSVNfVVBEQVRFRCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19CSU5EQUJMRSA9IDEgPDwgMztcbmV4cG9ydCBjb25zdCBQUk9QU19JU19MQVpZX0lOSVRJQUwgPSAxIDw8IDQ7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX0lOID0gMTtcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX09VVCA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBUUkFOU0lUSU9OX0dMT0JBTCA9IDEgPDwgMjtcblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX0ZSQUdNRU5UID0gMTtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfSU1QT1JUX05PREUgPSAxIDw8IDE7XG5cbmV4cG9ydCBjb25zdCBIWURSQVRJT05fU1RBUlQgPSAnWyc7XG4vKiogdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGFuIGB7OmVsc2V9Li4uYCBibG9jayB3YXMgcmVuZGVyZWQgKi9cbmV4cG9ydCBjb25zdCBIWURSQVRJT05fU1RBUlRfRUxTRSA9ICdbISc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VORCA9ICddJztcbmV4cG9ydCBjb25zdCBIWURSQVRJT05fRVJST1IgPSB7fTtcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfSVNfTkFNRVNQQUNFRCA9IDE7XG5leHBvcnQgY29uc3QgRUxFTUVOVF9QUkVTRVJWRV9BVFRSSUJVVEVfQ0FTRSA9IDEgPDwgMTtcblxuZXhwb3J0IGNvbnN0IFVOSU5JVElBTElaRUQgPSBTeW1ib2woKTtcblxuLy8gRGV2LXRpbWUgY29tcG9uZW50IHByb3BlcnRpZXNcbmV4cG9ydCBjb25zdCBGSUxFTkFNRSA9IFN5bWJvbCgnZmlsZW5hbWUnKTtcbmV4cG9ydCBjb25zdCBITVIgPSBTeW1ib2woJ2htcicpO1xuXG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX01BVEhNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcblxuLy8gd2UgdXNlIGEgbGlzdCBvZiBpZ25vcmFibGUgcnVudGltZSB3YXJuaW5ncyBiZWNhdXNlIG5vdCBldmVyeSBydW50aW1lIHdhcm5pbmdcbi8vIGNhbiBiZSBpZ25vcmVkIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIHZhbGlkYXRpb24gZm9yIHN2ZWx0ZS1pZ25vcmUgaW4gcGxhY2VcbmV4cG9ydCBjb25zdCBJR05PUkFCTEVfUlVOVElNRV9XQVJOSU5HUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdzdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZScsXG5cdCdiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZScsXG5cdCdoeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQnLFxuXHQnaHlkcmF0aW9uX2h0bWxfY2hhbmdlZCcsXG5cdCdvd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nJyxcblx0J293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uJ1xuXSk7XG5cbi8qKlxuICogV2hpdGVzcGFjZSBpbnNpZGUgb25lIG9mIHRoZXNlIGVsZW1lbnRzIHdpbGwgbm90IHJlc3VsdCBpblxuICogYSB3aGl0ZXNwYWNlIG5vZGUgYmVpbmcgY3JlYXRlZCBpbiBhbnkgY2lyY3Vtc3RhbmNlcy4gKFRoaXNcbiAqIGxpc3QgaXMgYWxtb3N0IGNlcnRhaW5seSB2ZXJ5IGluY29tcGxldGUpXG4gKiBUT0RPIHRoaXMgaXMgY3VycmVudGx5IHVudXNlZFxuICovXG5leHBvcnQgY29uc3QgRUxFTUVOVFNfV0lUSE9VVF9URVhUID0gWydhdWRpbycsICdkYXRhbGlzdCcsICdkbCcsICdvcHRncm91cCcsICdzZWxlY3QnLCAndmlkZW8nXTtcbiIsIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJXRhZyVcIj5gIGlzIGEgdm9pZCBlbGVtZW50IOKAlCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50KHRhZykge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGR5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRcXG4lY1xcYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+XFxgIGlzIGEgdm9pZCBlbGVtZW50IOKAlCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9keW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIOKAlCB0aGUgcmV0dXJuIHZhbHVlIGNvbnRhaW5zIHRoZSBvcmlnaW5hbHM6XG4gKiBcbiAqICVwcm9wZXJ0aWVzJVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbcHJvcGVydGllc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHByb3BlcnRpZXMpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBzdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZVxcbiVjJHtwcm9wZXJ0aWVzXG5cdFx0XHQ/IGBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIGNsb25lZCB3aXRoIFxcYCRzdGF0ZS5zbmFwc2hvdFxcYCDigJQgdGhlIHJldHVybiB2YWx1ZSBjb250YWlucyB0aGUgb3JpZ2luYWxzOlxuXG4ke3Byb3BlcnRpZXN9YFxuXHRcdFx0OiAnVmFsdWUgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIOKAlCB0aGUgb3JpZ2luYWwgdmFsdWUgd2FzIHJldHVybmVkJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBTbmFwc2hvdCB9IGZyb20gJy4vdHlwZXMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfcHJvdG90eXBlX29mLCBpc19hcnJheSwgb2JqZWN0X3Byb3RvdHlwZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEluIGRldiwgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGNvdWxkIG5vdCBiZSBjbG9uZWQuIEluIHByb2RcbiAqIHdlIGRvbid0IGJvdGhlciwgYnV0IHdlIGtlZXAgYSBkdW1teSBhcnJheSBhcm91bmQgc28gdGhhdCB0aGVcbiAqIHNpZ25hdHVyZSBzdGF5cyB0aGUgc2FtZVxuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG5jb25zdCBlbXB0eSA9IFtdO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwc2hvdCh2YWx1ZSwgc2tpcF93YXJuaW5nID0gZmFsc2UpIHtcblx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0LyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cblx0XHRjb25zdCBwYXRocyA9IFtdO1xuXG5cdFx0Y29uc3QgY29weSA9IGNsb25lKHZhbHVlLCBuZXcgTWFwKCksICcnLCBwYXRocyk7XG5cdFx0aWYgKHBhdGhzLmxlbmd0aCA9PT0gMSAmJiBwYXRoc1swXSA9PT0gJycpIHtcblx0XHRcdC8vIHZhbHVlIGNvdWxkIG5vdCBiZSBjbG9uZWRcblx0XHRcdHcuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUoKTtcblx0XHR9IGVsc2UgaWYgKHBhdGhzLmxlbmd0aCA+IDApIHtcblx0XHRcdC8vIHNvbWUgcHJvcGVydGllcyBjb3VsZCBub3QgYmUgY2xvbmVkXG5cdFx0XHRjb25zdCBzbGljZSA9IHBhdGhzLmxlbmd0aCA+IDEwID8gcGF0aHMuc2xpY2UoMCwgNykgOiBwYXRocy5zbGljZSgwLCAxMCk7XG5cdFx0XHRjb25zdCBleGNlc3MgPSBwYXRocy5sZW5ndGggLSBzbGljZS5sZW5ndGg7XG5cblx0XHRcdGxldCB1bmNsb25lZCA9IHNsaWNlLm1hcCgocGF0aCkgPT4gYC0gPHZhbHVlPiR7cGF0aH1gKS5qb2luKCdcXG4nKTtcblx0XHRcdGlmIChleGNlc3MgPiAwKSB1bmNsb25lZCArPSBgXFxuLSAuLi5hbmQgJHtleGNlc3N9IG1vcmVgO1xuXG5cdFx0XHR3LnN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHVuY2xvbmVkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29weTtcblx0fVxuXG5cdHJldHVybiBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgZW1wdHkpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge01hcDxULCBTbmFwc2hvdDxUPj59IGNsb25lZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzXG4gKiBAcGFyYW0ge251bGwgfCBUfSBvcmlnaW5hbCBUaGUgb3JpZ2luYWwgdmFsdWUsIGlmIGB2YWx1ZWAgd2FzIHByb2R1Y2VkIGZyb20gYSBgdG9KU09OYCBjYWxsXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlLCBjbG9uZWQsIHBhdGgsIHBhdGhzLCBvcmlnaW5hbCA9IG51bGwpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHR2YXIgdW53cmFwcGVkID0gY2xvbmVkLmdldCh2YWx1ZSk7XG5cdFx0aWYgKHVud3JhcHBlZCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdW53cmFwcGVkO1xuXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSByZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKG5ldyBNYXAodmFsdWUpKTtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAobmV3IFNldCh2YWx1ZSkpO1xuXG5cdFx0aWYgKGlzX2FycmF5KHZhbHVlKSkge1xuXHRcdFx0dmFyIGNvcHkgPSAvKiogQHR5cGUge1NuYXBzaG90PGFueT59ICovIChBcnJheSh2YWx1ZS5sZW5ndGgpKTtcblx0XHRcdGNsb25lZC5zZXQodmFsdWUsIGNvcHkpO1xuXG5cdFx0XHRpZiAob3JpZ2luYWwgIT09IG51bGwpIHtcblx0XHRcdFx0Y2xvbmVkLnNldChvcmlnaW5hbCwgY29weSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB2YWx1ZVtpXTtcblx0XHRcdFx0aWYgKGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRjb3B5W2ldID0gY2xvbmUoZWxlbWVudCwgY2xvbmVkLCBERVYgPyBgJHtwYXRofVske2l9XWAgOiBwYXRoLCBwYXRocyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fVxuXG5cdFx0aWYgKGdldF9wcm90b3R5cGVfb2YodmFsdWUpID09PSBvYmplY3RfcHJvdG90eXBlKSB7XG5cdFx0XHQvKiogQHR5cGUge1NuYXBzaG90PGFueT59ICovXG5cdFx0XHRjb3B5ID0ge307XG5cdFx0XHRjbG9uZWQuc2V0KHZhbHVlLCBjb3B5KTtcblxuXHRcdFx0aWYgKG9yaWdpbmFsICE9PSBudWxsKSB7XG5cdFx0XHRcdGNsb25lZC5zZXQob3JpZ2luYWwsIGNvcHkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRjb3B5W2tleV0gPSBjbG9uZSh2YWx1ZVtrZXldLCBjbG9uZWQsIERFViA/IGAke3BhdGh9LiR7a2V5fWAgOiBwYXRoLCBwYXRocyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiAoLyoqIEB0eXBlIHtUICYgeyB0b0pTT04/OiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGNsb25lKFxuXHRcdFx0XHQvKiogQHR5cGUge1QgJiB7IHRvSlNPTigpOiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKCksXG5cdFx0XHRcdGNsb25lZCxcblx0XHRcdFx0REVWID8gYCR7cGF0aH0udG9KU09OKClgIDogcGF0aCxcblx0XHRcdFx0cGF0aHMsXG5cdFx0XHRcdC8vIEFzc29jaWF0ZSB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgdG9KU09OIGNsb25lXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0Ly8gY2FuJ3QgYmUgY2xvbmVkXG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovICh2YWx1ZSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAodmFsdWUpO1xuXHR9XG59XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG52YXIgYm9sZCA9ICdmb250LXdlaWdodDogYm9sZCc7XG52YXIgbm9ybWFsID0gJ2ZvbnQtd2VpZ2h0OiBub3JtYWwnO1xuXG4vKipcbiAqIEFzc2lnbm1lbnQgdG8gYCVwcm9wZXJ0eSVgIHByb3BlcnR5ICglbG9jYXRpb24lKSB3aWxsIGV2YWx1YXRlIHRvIHRoZSByaWdodC1oYW5kIHNpZGUsIG5vdCB0aGUgdmFsdWUgb2YgYCVwcm9wZXJ0eSVgIGZvbGxvd2luZyB0aGUgYXNzaWdubWVudC4gVGhpcyBtYXkgcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbm1lbnRfdmFsdWVfc3RhbGUocHJvcGVydHksIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYXNzaWdubWVudF92YWx1ZV9zdGFsZVxcbiVjQXNzaWdubWVudCB0byBcXGAke3Byb3BlcnR5fVxcYCBwcm9wZXJ0eSAoJHtsb2NhdGlvbn0pIHdpbGwgZXZhbHVhdGUgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSwgbm90IHRoZSB2YWx1ZSBvZiBcXGAke3Byb3BlcnR5fVxcYCBmb2xsb3dpbmcgdGhlIGFzc2lnbm1lbnQuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hc3NpZ25tZW50X3ZhbHVlX3N0YWxlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Fzc2lnbm1lbnRfdmFsdWVfc3RhbGVgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlYmluZGluZyVgICglbG9jYXRpb24lKSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ1xuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZShiaW5kaW5nLCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlXFxuJWMke2xvY2F0aW9uID8gYFxcYCR7YmluZGluZ31cXGAgKCR7bG9jYXRpb259KSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5YCA6IGBcXGAke2JpbmRpbmd9XFxgIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlgfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBZb3VyIGBjb25zb2xlLiVtZXRob2QlYCBjb250YWluZWQgYCRzdGF0ZWAgcHJveGllcy4gQ29uc2lkZXIgdXNpbmcgYCRpbnNwZWN0KC4uLilgIG9yIGAkc3RhdGUuc25hcHNob3QoLi4uKWAgaW5zdGVhZFxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uc29sZV9sb2dfc3RhdGUobWV0aG9kKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gY29uc29sZV9sb2dfc3RhdGVcXG4lY1lvdXIgXFxgY29uc29sZS4ke21ldGhvZH1cXGAgY29udGFpbmVkIFxcYCRzdGF0ZVxcYCBwcm94aWVzLiBDb25zaWRlciB1c2luZyBcXGAkaW5zcGVjdCguLi4pXFxgIG9yIFxcYCRzdGF0ZS5zbmFwc2hvdCguLi4pXFxgIGluc3RlYWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9jb25zb2xlX2xvZ19zdGF0ZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb25zb2xlX2xvZ19zdGF0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogJWhhbmRsZXIlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gdG8gJXN1Z2dlc3Rpb24lP1xuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWdnZXN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmVudF9oYW5kbGVyX2ludmFsaWQoaGFuZGxlciwgc3VnZ2VzdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGV2ZW50X2hhbmRsZXJfaW52YWxpZFxcbiVjJHtoYW5kbGVyfSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gRGlkIHlvdSBtZWFuIHRvICR7c3VnZ2VzdGlvbn0/XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZXZlbnRfaGFuZGxlcl9pbnZhbGlkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2V2ZW50X2hhbmRsZXJfaW52YWxpZGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGAlYXR0cmlidXRlJWAgYXR0cmlidXRlIG9uIGAlaHRtbCVgIGNoYW5nZWQgaXRzIHZhbHVlIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSwgYCV2YWx1ZSVgLCB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZChhdHRyaWJ1dGUsIGh0bWwsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkXFxuJWNUaGUgXFxgJHthdHRyaWJ1dGV9XFxgIGF0dHJpYnV0ZSBvbiBcXGAke2h0bWx9XFxgIGNoYW5nZWQgaXRzIHZhbHVlIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSwgXFxgJHt2YWx1ZX1cXGAsIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrICVsb2NhdGlvbiUgY2hhbmdlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZCB8IG51bGx9IFtsb2NhdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9odG1sX2NoYW5nZWQobG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBoeWRyYXRpb25faHRtbF9jaGFuZ2VkXFxuJWMke2xvY2F0aW9uID8gYFRoZSB2YWx1ZSBvZiBhbiBcXGB7QGh0bWwgLi4ufVxcYCBibG9jayAke2xvY2F0aW9ufSBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVgIDogJ1RoZSB2YWx1ZSBvZiBhbiBge0BodG1sIC4uLn1gIGJsb2NrIGNoYW5nZWQgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZSd9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2h0bWxfY2hhbmdlZGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25faHRtbF9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci4gVGhlIGVycm9yIG9jY3VycmVkIG5lYXIgJWxvY2F0aW9uJVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fbWlzbWF0Y2gobG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBoeWRyYXRpb25fbWlzbWF0Y2hcXG4lYyR7bG9jYXRpb24gPyBgSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuIFRoZSBlcnJvciBvY2N1cnJlZCBuZWFyICR7bG9jYXRpb259YCA6ICdIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlcid9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX21pc21hdGNoYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9taXNtYXRjaGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGByZW5kZXJgIGZ1bmN0aW9uIHBhc3NlZCB0byBgY3JlYXRlUmF3U25pcHBldGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBpbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlclxcbiVjVGhlIFxcYHJlbmRlclxcYCBmdW5jdGlvbiBwYXNzZWQgdG8gXFxgY3JlYXRlUmF3U25pcHBldFxcYCBzaG91bGQgcmV0dXJuIEhUTUwgZm9yIGEgc2luZ2xlIGVsZW1lbnRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3Jhd19zbmlwcGV0X3JlbmRlcmApO1xuXHR9XG59XG5cbi8qKlxuICogRGV0ZWN0ZWQgYSBtaWdyYXRlZCBgJDpgIHJlYWN0aXZlIGJsb2NrIGluIGAlZmlsZW5hbWUlYCB0aGF0IGJvdGggYWNjZXNzZXMgYW5kIHVwZGF0ZXMgdGhlIHNhbWUgcmVhY3RpdmUgdmFsdWUuIFRoaXMgbWF5IGNhdXNlIHJlY3Vyc2l2ZSB1cGRhdGVzIHdoZW4gY29udmVydGVkIHRvIGFuIGAkZWZmZWN0YC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9jayhmaWxlbmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tcXG4lY0RldGVjdGVkIGEgbWlncmF0ZWQgXFxgJDpcXGAgcmVhY3RpdmUgYmxvY2sgaW4gXFxgJHtmaWxlbmFtZX1cXGAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBcXGAkZWZmZWN0XFxgLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGVnYWN5X3JlY3Vyc2l2ZV9yZWFjdGl2ZV9ibG9ja2ApO1xuXHR9XG59XG5cbi8qKlxuICogVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudFxcbiVjVHJpZWQgdG8gdW5tb3VudCBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgbW91bnRlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9kb3VibGVfdW5tb3VudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgKTtcblx0fVxufVxuXG4vKipcbiAqICVwYXJlbnQlIHBhc3NlZCBhIHZhbHVlIHRvICVjaGlsZCUgd2l0aCBgYmluZDpgLCBidXQgdGhlIHZhbHVlIGlzIG93bmVkIGJ5ICVvd25lciUuIENvbnNpZGVyIGNyZWF0aW5nIGEgYmluZGluZyBiZXR3ZWVuICVvd25lciUgYW5kICVwYXJlbnQlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvd25lclxuICovXG5leHBvcnQgZnVuY3Rpb24gb3duZXJzaGlwX2ludmFsaWRfYmluZGluZyhwYXJlbnQsIGNoaWxkLCBvd25lcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdcXG4lYyR7cGFyZW50fSBwYXNzZWQgYSB2YWx1ZSB0byAke2NoaWxkfSB3aXRoIFxcYGJpbmQ6XFxgLCBidXQgdGhlIHZhbHVlIGlzIG93bmVkIGJ5ICR7b3duZXJ9LiBDb25zaWRlciBjcmVhdGluZyBhIGJpbmRpbmcgYmV0d2VlbiAke293bmVyfSBhbmQgJHtwYXJlbnR9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ2AsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nYCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlY29tcG9uZW50JSBtdXRhdGVkIGEgdmFsdWUgb3duZWQgYnkgJW93bmVyJS4gVGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgcGFzc2luZyB2YWx1ZXMgdG8gY2hpbGQgY29tcG9uZW50cyB3aXRoIGBiaW5kOmAsIG9yIHVzZSBhIGNhbGxiYWNrIGluc3RlYWRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2NvbXBvbmVudF1cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW293bmVyXVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24oY29tcG9uZW50LCBvd25lcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIG93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uXFxuJWMke2NvbXBvbmVudCA/IGAke2NvbXBvbmVudH0gbXV0YXRlZCBhIHZhbHVlIG93bmVkIGJ5ICR7b3duZXJ9LiBUaGlzIGlzIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkLiBDb25zaWRlciBwYXNzaW5nIHZhbHVlcyB0byBjaGlsZCBjb21wb25lbnRzIHdpdGggXFxgYmluZDpcXGAsIG9yIHVzZSBhIGNhbGxiYWNrIGluc3RlYWRgIDogJ011dGF0aW5nIGEgdmFsdWUgb3V0c2lkZSB0aGUgY29tcG9uZW50IHRoYXQgY3JlYXRlZCBpdCBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgcGFzc2luZyB2YWx1ZXMgdG8gY2hpbGQgY29tcG9uZW50cyB3aXRoIGBiaW5kOmAsIG9yIHVzZSBhIGNhbGxiYWNrIGluc3RlYWQnfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWFjdGl2ZSBgJHN0YXRlKC4uLilgIHByb3hpZXMgYW5kIHRoZSB2YWx1ZXMgdGhleSBwcm94eSBoYXZlIGRpZmZlcmVudCBpZGVudGl0aWVzLiBCZWNhdXNlIG9mIHRoaXMsIGNvbXBhcmlzb25zIHdpdGggYCVvcGVyYXRvciVgIHdpbGwgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2gob3BlcmF0b3IpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBzdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaFxcbiVjUmVhY3RpdmUgXFxgJHN0YXRlKC4uLilcXGAgcHJveGllcyBhbmQgdGhlIHZhbHVlcyB0aGV5IHByb3h5IGhhdmUgZGlmZmVyZW50IGlkZW50aXRpZXMuIEJlY2F1c2Ugb2YgdGhpcywgY29tcGFyaXNvbnMgd2l0aCBcXGAke29wZXJhdG9yfVxcYCB3aWxsIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2hgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgc2xpZGVgIHRyYW5zaXRpb24gZG9lcyBub3Qgd29yayBjb3JyZWN0bHkgZm9yIGVsZW1lbnRzIHdpdGggYGRpc3BsYXk6ICV2YWx1ZSVgXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb25fc2xpZGVfZGlzcGxheSh2YWx1ZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHRyYW5zaXRpb25fc2xpZGVfZGlzcGxheVxcbiVjVGhlIFxcYHNsaWRlXFxgIHRyYW5zaXRpb24gZG9lcyBub3Qgd29yayBjb3JyZWN0bHkgZm9yIGVsZW1lbnRzIHdpdGggXFxgZGlzcGxheTogJHt2YWx1ZX1cXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS90cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXlgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5YCk7XG5cdH1cbn0iLCIvKiogQGltcG9ydCB7IFByb3h5TWV0YWRhdGEgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEB0eXBlZGVmIHt7IGZpbGU6IHN0cmluZywgbGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlciB9fSBMb2NhdGlvbiAqL1xuXG5pbXBvcnQgeyBTVEFURV9TWU1CT0xfTUVUQURBVEEgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdXNlcl9wcmVfZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZ2V0X3Byb3RvdHlwZV9vZiB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FLCBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcblxuLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBBcnJheTx7IHN0YXJ0OiBMb2NhdGlvbiwgZW5kOiBMb2NhdGlvbiwgY29tcG9uZW50OiBGdW5jdGlvbiB9Pj59ICovXG5jb25zdCBib3VuZGFyaWVzID0ge307XG5cbmNvbnN0IGNocm9tZV9wYXR0ZXJuID0gL2F0ICg/Oi4rIFxcKCk/KC4rKTooXFxkKyk6KFxcZCspXFwpPyQvO1xuY29uc3QgZmlyZWZveF9wYXR0ZXJuID0gL0AoLispOihcXGQrKTooXFxkKykkLztcblxuZnVuY3Rpb24gZ2V0X3N0YWNrKCkge1xuXHRjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSByZXR1cm4gbnVsbDtcblxuXHRjb25zdCBlbnRyaWVzID0gW107XG5cblx0Zm9yIChjb25zdCBsaW5lIG9mIHN0YWNrLnNwbGl0KCdcXG4nKSkge1xuXHRcdGxldCBtYXRjaCA9IGNocm9tZV9wYXR0ZXJuLmV4ZWMobGluZSkgPz8gZmlyZWZveF9wYXR0ZXJuLmV4ZWMobGluZSk7XG5cblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGVudHJpZXMucHVzaCh7XG5cdFx0XHRcdGZpbGU6IG1hdGNoWzFdLFxuXHRcdFx0XHRsaW5lOiArbWF0Y2hbMl0sXG5cdFx0XHRcdGNvbHVtbjogK21hdGNoWzNdXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZW50cmllcztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIGAuc3ZlbHRlYCBjb21wb25lbnQgaXMgcmVzcG9uc2libGUgZm9yIGEgZ2l2ZW4gc3RhdGUgY2hhbmdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb24gfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2NvbXBvbmVudCgpIHtcblx0Ly8gZmlyc3QgNCBsaW5lcyBhcmUgc3ZlbHRlIGludGVybmFsczsgYWRqdXN0IHRoaXMgbnVtYmVyIGlmIHdlIGNoYW5nZSB0aGUgaW50ZXJuYWwgY2FsbCBzdGFja1xuXHRjb25zdCBzdGFjayA9IGdldF9zdGFjaygpPy5zbGljZSg0KTtcblx0aWYgKCFzdGFjaykgcmV0dXJuIG51bGw7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGVudHJ5ID0gc3RhY2tbaV07XG5cdFx0Y29uc3QgbW9kdWxlcyA9IGJvdW5kYXJpZXNbZW50cnkuZmlsZV07XG5cdFx0aWYgKCFtb2R1bGVzKSB7XG5cdFx0XHQvLyBJZiB0aGUgZmlyc3QgZW50cnkgaXMgbm90IGEgY29tcG9uZW50LCB0aGF0IG1lYW5zIHRoZSBtb2RpZmljYXRpb24gdmVyeSBsaWtlbHkgaGFwcGVuZWRcblx0XHRcdC8vIHdpdGhpbiBhIC5zdmVsdGUuanMgZmlsZSwgcG9zc2libHkgdHJpZ2dlcmVkIGJ5IGEgY29tcG9uZW50LiBTaW5jZSB0aGVzZSBmaWxlcyBhcmUgbm90IHBhcnRcblx0XHRcdC8vIG9mIHRoZSBib25kYXJpZXMvY29tcG9uZW50IGNvbnRleHQgaGV1cmlzdGljLCB3ZSBuZWVkIHRvIGJhaWwgaW4gdGhpcyBjYXNlLCBlbHNlIHdlIHdvdWxkXG5cdFx0XHQvLyBoYXZlIGZhbHNlIHBvc2l0aXZlcyB3aGVuIHRoZSAuc3ZlbHRlLnRzIGZpbGUgcHJvdmlkZXMgYSBzdGF0ZSBjcmVhdG9yIGZ1bmN0aW9uLCBlbmNhcHN1bGF0aW5nXG5cdFx0XHQvLyB0aGUgc3RhdGUgYW5kIGl0cyBtdXRhdGlvbnMsIGFuZCBpcyBiZWluZyBjYWxsZWQgZnJvbSBhIGNvbXBvbmVudCBvdGhlciB0aGFuIHRoZSBvbmUgd2hvXG5cdFx0XHQvLyBjYWxsZWQgdGhlIHN0YXRlIGNyZWF0b3IgZnVuY3Rpb24uXG5cdFx0XHRpZiAoaSA9PT0gMCkgcmV0dXJuIG51bGw7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG5cdFx0XHRpZiAobW9kdWxlLmVuZCA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vZHVsZS5zdGFydC5saW5lIDwgZW50cnkubGluZSAmJiBtb2R1bGUuZW5kLmxpbmUgPiBlbnRyeS5saW5lKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuY29tcG9uZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgY29uc3QgQUREX09XTkVSID0gU3ltYm9sKCdBRERfT1dORVInKTtcblxuLyoqXG4gKiBUb2dldGhlciB3aXRoIGBtYXJrX21vZHVsZV9lbmRgLCB0aGlzIGZ1bmN0aW9uIGVzdGFibGlzaGVzIHRoZSBib3VuZGFyaWVzIG9mIGEgYC5zdmVsdGVgIGZpbGUsXG4gKiBzdWNoIHRoYXQgc3Vic2VxdWVudCBjYWxscyB0byBgZ2V0X2NvbXBvbmVudGAgY2FuIHRlbGwgdXMgd2hpY2ggY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlXG4gKiBmb3IgYSBnaXZlbiBzdGF0ZSBjaGFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtfbW9kdWxlX3N0YXJ0KCkge1xuXHRjb25zdCBzdGFydCA9IGdldF9zdGFjaygpPy5bMl07XG5cblx0aWYgKHN0YXJ0KSB7XG5cdFx0KGJvdW5kYXJpZXNbc3RhcnQuZmlsZV0gPz89IFtdKS5wdXNoKHtcblx0XHRcdHN0YXJ0LFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0ZW5kOiBudWxsLFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3ZSBhZGQgdGhlIGNvbXBvbmVudCBhdCB0aGUgZW5kLCBzaW5jZSBITVIgd2lsbCBvdmVyd3JpdGUgdGhlIGZ1bmN0aW9uXG5cdFx0XHRjb21wb25lbnQ6IG51bGxcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBvbmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya19tb2R1bGVfZW5kKGNvbXBvbmVudCkge1xuXHRjb25zdCBlbmQgPSBnZXRfc3RhY2soKT8uWzJdO1xuXG5cdGlmIChlbmQpIHtcblx0XHRjb25zdCBib3VuZGFyaWVzX2ZpbGUgPSBib3VuZGFyaWVzW2VuZC5maWxlXTtcblx0XHRjb25zdCBib3VuZGFyeSA9IGJvdW5kYXJpZXNfZmlsZVtib3VuZGFyaWVzX2ZpbGUubGVuZ3RoIC0gMV07XG5cblx0XHRib3VuZGFyeS5lbmQgPSBlbmQ7XG5cdFx0Ym91bmRhcnkuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHthbnkgfCBudWxsfSBvd25lclxuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsXVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX293bmVyKG9iamVjdCwgb3duZXIsIGdsb2JhbCA9IGZhbHNlLCBza2lwX3dhcm5pbmcgPSBmYWxzZSkge1xuXHRpZiAob2JqZWN0ICYmICFnbG9iYWwpIHtcblx0XHRjb25zdCBjb21wb25lbnQgPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb247XG5cdFx0Y29uc3QgbWV0YWRhdGEgPSBvYmplY3RbU1RBVEVfU1lNQk9MX01FVEFEQVRBXTtcblx0XHRpZiAobWV0YWRhdGEgJiYgIWhhc19vd25lcihtZXRhZGF0YSwgY29tcG9uZW50KSkge1xuXHRcdFx0bGV0IG9yaWdpbmFsID0gZ2V0X293bmVyKG1ldGFkYXRhKTtcblxuXHRcdFx0aWYgKG93bmVyICYmIG93bmVyW0ZJTEVOQU1FXSAhPT0gY29tcG9uZW50W0ZJTEVOQU1FXSAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdHcub3duZXJzaGlwX2ludmFsaWRfYmluZGluZyhjb21wb25lbnRbRklMRU5BTUVdLCBvd25lcltGSUxFTkFNRV0sIG9yaWdpbmFsW0ZJTEVOQU1FXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YWRkX293bmVyX3RvX29iamVjdChvYmplY3QsIG93bmVyLCBuZXcgU2V0KCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0X29iamVjdFxuICogQHBhcmFtIHthbnl9IENvbXBvbmVudFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX293bmVyX2VmZmVjdChnZXRfb2JqZWN0LCBDb21wb25lbnQsIHNraXBfd2FybmluZyA9IGZhbHNlKSB7XG5cdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0YWRkX293bmVyKGdldF9vYmplY3QoKSwgQ29tcG9uZW50LCBmYWxzZSwgc2tpcF93YXJuaW5nKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IF90aGlzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvd25lclxuICogQHBhcmFtIHtBcnJheTwoKSA9PiBhbnk+fSBnZXR0ZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNraXBfd2FybmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX293bmVyX3RvX2NsYXNzKF90aGlzLCBvd25lciwgZ2V0dGVycywgc2tpcF93YXJuaW5nKSB7XG5cdF90aGlzW0FERF9PV05FUl0uY3VycmVudCB8fD0gZ2V0dGVycy5tYXAoKCkgPT4gVU5JTklUSUFMSVpFRCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBnZXR0ZXJzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IGdldHRlcnNbaV0oKTtcblx0XHQvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB3ZSBvbmx5IHJlLWFkZCB0aGUgb3duZXIgaWYgdGhlIHN0YXRlIGhhcyBjaGFuZ2VkXG5cdFx0aWYgKGN1cnJlbnQgIT09IF90aGlzW0FERF9PV05FUl1baV0pIHtcblx0XHRcdF90aGlzW0FERF9PV05FUl0uY3VycmVudFtpXSA9IGN1cnJlbnQ7XG5cdFx0XHRhZGRfb3duZXIoY3VycmVudCwgb3duZXIsIGZhbHNlLCBza2lwX3dhcm5pbmcpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YSB8IG51bGx9IGZyb21cbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gdG9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpZGVuX293bmVyc2hpcChmcm9tLCB0bykge1xuXHRpZiAodG8ub3duZXJzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0d2hpbGUgKGZyb20pIHtcblx0XHRpZiAoZnJvbS5vd25lcnMgPT09IG51bGwpIHtcblx0XHRcdHRvLm93bmVycyA9IG51bGw7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IG93bmVyIG9mIGZyb20ub3duZXJzKSB7XG5cdFx0XHR0by5vd25lcnMuYWRkKG93bmVyKTtcblx0XHR9XG5cblx0XHRmcm9tID0gZnJvbS5wYXJlbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9uIHwgbnVsbH0gb3duZXIgSWYgYG51bGxgLCB0aGVuIHRoZSBvYmplY3QgaXMgZ2xvYmFsbHkgb3duZWQgYW5kIHdpbGwgbm90IGJlIGNoZWNrZWRcbiAqIEBwYXJhbSB7U2V0PGFueT59IHNlZW5cbiAqL1xuZnVuY3Rpb24gYWRkX293bmVyX3RvX29iamVjdChvYmplY3QsIG93bmVyLCBzZWVuKSB7XG5cdGNvbnN0IG1ldGFkYXRhID0gLyoqIEB0eXBlIHtQcm94eU1ldGFkYXRhfSAqLyAob2JqZWN0Py5bU1RBVEVfU1lNQk9MX01FVEFEQVRBXSk7XG5cblx0aWYgKG1ldGFkYXRhKSB7XG5cdFx0Ly8gdGhpcyBpcyBhIHN0YXRlIHByb3h5LCBhZGQgb3duZXIgZGlyZWN0bHksIGlmIG5vdCBnbG9iYWxseSBzaGFyZWRcblx0XHRpZiAoJ293bmVycycgaW4gbWV0YWRhdGEgJiYgbWV0YWRhdGEub3duZXJzICE9IG51bGwpIHtcblx0XHRcdGlmIChvd25lcikge1xuXHRcdFx0XHRtZXRhZGF0YS5vd25lcnMuYWRkKG93bmVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1ldGFkYXRhLm93bmVycyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChzZWVuLmhhcyhvYmplY3QpKSByZXR1cm47XG5cdFx0c2Vlbi5hZGQob2JqZWN0KTtcblx0XHRpZiAoQUREX09XTkVSIGluIG9iamVjdCAmJiBvYmplY3RbQUREX09XTkVSXSkge1xuXHRcdFx0Ly8gdGhpcyBpcyBhIGNsYXNzIHdpdGggc3RhdGUgZmllbGRzLiB3ZSBwdXQgdGhpcyBpbiBhIHJlbmRlciBlZmZlY3Rcblx0XHRcdC8vIHNvIHRoYXQgaWYgc3RhdGUgaXMgcmVwbGFjZWQgKGUuZy4gYGluc3RhbmNlLm5hbWUgPSB7IGZpcnN0LCBsYXN0IH1gKVxuXHRcdFx0Ly8gdGhlIG5ldyBzdGF0ZSBpcyBhbHNvIGNvLW93bmVkIGJ5IHRoZSBjYWxsZXIgb2YgYGdldENvbnRleHRgXG5cdFx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0b2JqZWN0W0FERF9PV05FUl0ob3duZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwcm90byA9IGdldF9wcm90b3R5cGVfb2Yob2JqZWN0KTtcblxuXHRcdFx0aWYgKHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKSB7XG5cdFx0XHRcdC8vIHJlY3Vyc2UgdW50aWwgd2UgZmluZCBhIHN0YXRlIHByb3h5XG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwga2V5KT8uZ2V0KSB7XG5cdFx0XHRcdFx0XHQvLyBTaW1pbGFyIHRvIHRoZSBjbGFzcyBjYXNlOyB0aGUgZ2V0dGVyIGNvdWxkIHVwZGF0ZSB3aXRoIGEgbmV3IHN0YXRlXG5cdFx0XHRcdFx0XHRsZXQgY3VycmVudCA9IFVOSU5JVElBTElaRUQ7XG5cdFx0XHRcdFx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmV4dCA9IG9iamVjdFtrZXldO1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudCAhPT0gbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0XHRcdGFkZF9vd25lcl90b19vYmplY3QobmV4dCwgb3duZXIsIHNlZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWRkX293bmVyX3RvX29iamVjdChvYmplY3Rba2V5XSwgb3duZXIsIHNlZW4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChwcm90byA9PT0gQXJyYXkucHJvdG90eXBlKSB7XG5cdFx0XHRcdC8vIHJlY3Vyc2UgdW50aWwgd2UgZmluZCBhIHN0YXRlIHByb3h5XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0YWRkX293bmVyX3RvX29iamVjdChvYmplY3RbaV0sIG93bmVyLCBzZWVuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UHJveHlNZXRhZGF0YX0gbWV0YWRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc19vd25lcihtZXRhZGF0YSwgY29tcG9uZW50KSB7XG5cdGlmIChtZXRhZGF0YS5vd25lcnMgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiAoXG5cdFx0bWV0YWRhdGEub3duZXJzLmhhcyhjb21wb25lbnQpIHx8XG5cdFx0Ly8gVGhpcyBoZWxwcyBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMgd2hlbiB1c2luZyBITVIsIHdoZXJlIHRoZSBjb21wb25lbnQgZnVuY3Rpb24gaXMgcmVwbGFjZWRcblx0XHQoRklMRU5BTUUgaW4gY29tcG9uZW50ICYmXG5cdFx0XHRbLi4ubWV0YWRhdGEub3duZXJzXS5zb21lKFxuXHRcdFx0XHQob3duZXIpID0+IC8qKiBAdHlwZSB7YW55fSAqLyAob3duZXIpW0ZJTEVOQU1FXSA9PT0gY29tcG9uZW50W0ZJTEVOQU1FXVxuXHRcdFx0KSkgfHxcblx0XHQobWV0YWRhdGEucGFyZW50ICE9PSBudWxsICYmIGhhc19vd25lcihtZXRhZGF0YS5wYXJlbnQsIGNvbXBvbmVudCkpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQcm94eU1ldGFkYXRhfSBtZXRhZGF0YVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0X293bmVyKG1ldGFkYXRhKSB7XG5cdHJldHVybiAoXG5cdFx0bWV0YWRhdGE/Lm93bmVycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlID8/XG5cdFx0Z2V0X293bmVyKC8qKiBAdHlwZSB7UHJveHlNZXRhZGF0YX0gKi8gKG1ldGFkYXRhLnBhcmVudCkpXG5cdCk7XG59XG5cbmxldCBza2lwID0gZmFsc2U7XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBza2lwX293bmVyc2hpcF92YWxpZGF0aW9uKGZuKSB7XG5cdHNraXAgPSB0cnVlO1xuXHRmbigpO1xuXHRza2lwID0gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQcm94eU1ldGFkYXRhfSBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tfb3duZXJzaGlwKG1ldGFkYXRhKSB7XG5cdGlmIChza2lwKSByZXR1cm47XG5cblx0Y29uc3QgY29tcG9uZW50ID0gZ2V0X2NvbXBvbmVudCgpO1xuXG5cdGlmIChjb21wb25lbnQgJiYgIWhhc19vd25lcihtZXRhZGF0YSwgY29tcG9uZW50KSkge1xuXHRcdGxldCBvcmlnaW5hbCA9IGdldF9vd25lcihtZXRhZGF0YSk7XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0aWYgKG9yaWdpbmFsW0ZJTEVOQU1FXSAhPT0gY29tcG9uZW50W0ZJTEVOQU1FXSkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbihjb21wb25lbnRbRklMRU5BTUVdLCBvcmlnaW5hbFtGSUxFTkFNRV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3Lm93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKCk7XG5cdFx0fVxuXHR9XG59XG4iLCIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIENhbm5vdCB1c2UgYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9YCBpZiB0aGUgcGFyZW50IGNvbXBvbmVudCB1c2VzIGBsZXQ6YCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9kZWZhdWx0X3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRcXG5DYW5ub3QgdXNlIFxcYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9XFxgIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgXFxgbGV0OlxcYCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX2RlZmF1bHRfc25pcHBldGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJSguLi4pYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudFxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb25cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudGApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJWAgaXMgbm90IGEgc3RvcmUgd2l0aCBhIGBzdWJzY3JpYmVgIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0b3JlX2ludmFsaWRfc2hhcGVcXG5cXGAke25hbWV9XFxgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBcXGBzdWJzY3JpYmVcXGAgbWV0aG9kXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGB0aGlzYCBwcm9wIG9uIGA8c3ZlbHRlOmVsZW1lbnQ+YCBtdXN0IGJlIGEgc3RyaW5nLCBpZiBkZWZpbmVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWUoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3ZlbHRlX2VsZW1lbnRfaW52YWxpZF90aGlzX3ZhbHVlXFxuVGhlIFxcYHRoaXNcXGAgcHJvcCBvbiBcXGA8c3ZlbHRlOmVsZW1lbnQ+XFxgIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZWApO1xuXHR9XG59IiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0IH0gZnJvbSAnI2NsaWVudCcgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBhZGRfb3duZXIgfSBmcm9tICcuL2Rldi9vd25lcnNoaXAuanMnO1xuaW1wb3J0IHsgbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50IH0gZnJvbSAnLi4vc2hhcmVkL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzb3VyY2UgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHR1bnRyYWNrXG59IGZyb20gJy4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlZmZlY3QgfSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vKiogQHR5cGUge0NvbXBvbmVudENvbnRleHQgfCBudWxsfSAqL1xuZXhwb3J0IGxldCBjb21wb25lbnRfY29udGV4dCA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHQgfCBudWxsfSBjb250ZXh0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2NvbXBvbmVudF9jb250ZXh0KGNvbnRleHQpIHtcblx0Y29tcG9uZW50X2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IGNvbXBvbmVudCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gY3VycmVudCBjb21wb25lbnQgY29udGV4dDpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gQXBwLnN2ZWx0ZSAtLT5cbiAqIDxGb28+XG4gKiAgIDxCYXIgLz4gPCEtLSBjb250ZXh0ID09IEZvby5zdmVsdGUsIGZ1bmN0aW9uID09IEFwcC5zdmVsdGUgLS0+XG4gKiA8L0Zvbz5cbiAqIGBgYFxuICogQHR5cGUge0NvbXBvbmVudENvbnRleHRbJ2Z1bmN0aW9uJ119XG4gKi9cbmV4cG9ydCBsZXQgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dFsnZnVuY3Rpb24nXX0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uKGZuKSB7XG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IGZuO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY29udGV4dCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgYGtleWAuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ2dldENvbnRleHQnKTtcblx0Y29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXAuZ2V0KGtleSkpO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gYXJiaXRyYXJ5IGBjb250ZXh0YCBvYmplY3Qgd2l0aCB0aGUgY3VycmVudCBjb21wb25lbnQgYW5kIHRoZSBzcGVjaWZpZWQgYGtleWBcbiAqIGFuZCByZXR1cm5zIHRoYXQgb2JqZWN0LiBUaGUgY29udGV4dCBpcyB0aGVuIGF2YWlsYWJsZSB0byBjaGlsZHJlbiBvZiB0aGUgY29tcG9uZW50XG4gKiAoaW5jbHVkaW5nIHNsb3R0ZWQgY29udGVudCkgd2l0aCBgZ2V0Q29udGV4dGAuXG4gKlxuICogTGlrZSBsaWZlY3ljbGUgZnVuY3Rpb25zLCB0aGlzIG11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEBwYXJhbSB7VH0gY29udGV4dFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdzZXRDb250ZXh0Jyk7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIFdoZW4gc3RhdGUgaXMgcHV0IGludG8gY29udGV4dCwgd2UgdHJlYXQgYXMgaWYgaXQncyBnbG9iYWwgZnJvbSBub3cgb24uXG5cdFx0Ly8gV2UgZG8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKGl0J3MgZm9yIGV4YW1wbGUgdmVyeSBleHBlbnNpdmUgdG8gY2FsbFxuXHRcdC8vIGdldENvbnRleHQgb24gYSBiaWcgb2JqZWN0IG1hbnkgdGltZXMgd2hlbiBwYXJ0IG9mIGEgbGlzdCBjb21wb25lbnQpXG5cdFx0Ly8gYW5kIGRhbmdlciBvZiBmYWxzZSBwb3NpdGl2ZXMuXG5cdFx0dW50cmFjaygoKSA9PiBhZGRfb3duZXIoY29udGV4dCwgbnVsbCwgdHJ1ZSkpO1xuXHR9XG5cblx0Y29udGV4dF9tYXAuc2V0KGtleSwgY29udGV4dCk7XG5cdHJldHVybiBjb250ZXh0O1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250ZXh0KGtleSkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdoYXNDb250ZXh0Jyk7XG5cdHJldHVybiBjb250ZXh0X21hcC5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHdob2xlIGNvbnRleHQgbWFwIHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50LlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi4gVXNlZnVsLCBmb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbXBvbmVudCBhbmQgd2FudCB0byBwYXNzIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGl0LlxuICpcbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gW1Q9TWFwPGFueSwgYW55Pl1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG5cdGNvbnN0IGNvbnRleHRfbWFwID0gZ2V0X29yX2luaXRfY29udGV4dF9tYXAoJ2dldEFsbENvbnRleHRzJyk7XG5cdHJldHVybiAvKiogQHR5cGUge1R9ICovIChjb250ZXh0X21hcCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7YW55fSBydW5lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoKHByb3BzLCBydW5lcyA9IGZhbHNlLCBmbikge1xuXHRjb21wb25lbnRfY29udGV4dCA9IHtcblx0XHRwOiBjb21wb25lbnRfY29udGV4dCxcblx0XHRjOiBudWxsLFxuXHRcdGU6IG51bGwsXG5cdFx0bTogZmFsc2UsXG5cdFx0czogcHJvcHMsXG5cdFx0eDogbnVsbCxcblx0XHRsOiBudWxsXG5cdH07XG5cblx0aWYgKGxlZ2FjeV9tb2RlX2ZsYWcgJiYgIXJ1bmVzKSB7XG5cdFx0Y29tcG9uZW50X2NvbnRleHQubCA9IHtcblx0XHRcdHM6IG51bGwsXG5cdFx0XHR1OiBudWxsLFxuXHRcdFx0cjE6IFtdLFxuXHRcdFx0cjI6IHNvdXJjZShmYWxzZSlcblx0XHR9O1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdC8vIGNvbXBvbmVudCBmdW5jdGlvblxuXHRcdGNvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uID0gZm47XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFRcbiAqIEBwYXJhbSB7VH0gW2NvbXBvbmVudF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wKGNvbXBvbmVudCkge1xuXHRjb25zdCBjb250ZXh0X3N0YWNrX2l0ZW0gPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGNvbnRleHRfc3RhY2tfaXRlbSAhPT0gbnVsbCkge1xuXHRcdGlmIChjb21wb25lbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29udGV4dF9zdGFja19pdGVtLnggPSBjb21wb25lbnQ7XG5cdFx0fVxuXHRcdGNvbnN0IGNvbXBvbmVudF9lZmZlY3RzID0gY29udGV4dF9zdGFja19pdGVtLmU7XG5cdFx0aWYgKGNvbXBvbmVudF9lZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0XHRcdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRcdGNvbnRleHRfc3RhY2tfaXRlbS5lID0gbnVsbDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50X2VmZmVjdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY29tcG9uZW50X2VmZmVjdCA9IGNvbXBvbmVudF9lZmZlY3RzW2ldO1xuXHRcdFx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KGNvbXBvbmVudF9lZmZlY3QuZWZmZWN0KTtcblx0XHRcdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKGNvbXBvbmVudF9lZmZlY3QucmVhY3Rpb24pO1xuXHRcdFx0XHRcdGVmZmVjdChjb21wb25lbnRfZWZmZWN0LmZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dF9zdGFja19pdGVtLnA7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gY29udGV4dF9zdGFja19pdGVtLnA/LmZ1bmN0aW9uID8/IG51bGw7XG5cdFx0fVxuXHRcdGNvbnRleHRfc3RhY2tfaXRlbS5tID0gdHJ1ZTtcblx0fVxuXHQvLyBNaWNyby1vcHRpbWl6YXRpb246IERvbid0IHNldCAuYSBhYm92ZSB0byB0aGUgZW1wdHkgb2JqZWN0XG5cdC8vIHNvIGl0IGNhbiBiZSBnYXJiYWdlLWNvbGxlY3RlZCB3aGVuIHRoZSByZXR1cm4gaGVyZSBpcyB1bnVzZWRcblx0cmV0dXJuIGNvbXBvbmVudCB8fCAvKiogQHR5cGUge1R9ICovICh7fSk7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19ydW5lcygpIHtcblx0cmV0dXJuICFsZWdhY3lfbW9kZV9mbGFnIHx8IChjb21wb25lbnRfY29udGV4dCAhPT0gbnVsbCAmJiBjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge01hcDx1bmtub3duLCB1bmtub3duPn1cbiAqL1xuZnVuY3Rpb24gZ2V0X29yX2luaXRfY29udGV4dF9tYXAobmFtZSkge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQobmFtZSk7XG5cdH1cblxuXHRyZXR1cm4gKGNvbXBvbmVudF9jb250ZXh0LmMgPz89IG5ldyBNYXAoZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB8fCB1bmRlZmluZWQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHR9IGNvbXBvbmVudF9jb250ZXh0XG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X3BhcmVudF9jb250ZXh0KGNvbXBvbmVudF9jb250ZXh0KSB7XG5cdGxldCBwYXJlbnQgPSBjb21wb25lbnRfY29udGV4dC5wO1xuXHR3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgY29udGV4dF9tYXAgPSBwYXJlbnQuYztcblx0XHRpZiAoY29udGV4dF9tYXAgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBjb250ZXh0X21hcDtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnA7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG4iLCIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVudHJhY2tlZF93cml0ZXMsXG5cdGdldCxcblx0c2NoZWR1bGVfZWZmZWN0LFxuXHRzZXRfdW50cmFja2VkX3dyaXRlcyxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVudHJhY2ssXG5cdGluY3JlbWVudF93cml0ZV92ZXJzaW9uLFxuXHR1cGRhdGVfZWZmZWN0LFxuXHRkZXJpdmVkX3NvdXJjZXMsXG5cdHNldF9kZXJpdmVkX3NvdXJjZXMsXG5cdGNoZWNrX2RpcnRpbmVzcyxcblx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCxcblx0aXNfZmx1c2hpbmdfZWZmZWN0LFxuXHR1bnRyYWNraW5nXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZXF1YWxzLCBzYWZlX2VxdWFscyB9IGZyb20gJy4vZXF1YWxpdHkuanMnO1xuaW1wb3J0IHtcblx0Q0xFQU4sXG5cdERFUklWRUQsXG5cdERJUlRZLFxuXHRCUkFOQ0hfRUZGRUNULFxuXHRJTlNQRUNUX0VGRkVDVCxcblx0VU5PV05FRCxcblx0TUFZQkVfRElSVFksXG5cdEJMT0NLX0VGRkVDVCxcblx0Uk9PVF9FRkZFQ1Rcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcsIHRyYWNpbmdfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrIH0gZnJvbSAnLi4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGlzX3J1bmVzIH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5cbmV4cG9ydCBsZXQgaW5zcGVjdF9lZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnNwZWN0X2VmZmVjdHModikge1xuXHRpbnNwZWN0X2VmZmVjdHMgPSB2O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZcbiAqIEBwYXJhbSB7RXJyb3IgfCBudWxsfSBbc3RhY2tdXG4gKiBAcmV0dXJucyB7U291cmNlPFY+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc291cmNlKHYsIHN0YWNrKSB7XG5cdC8qKiBAdHlwZSB7VmFsdWV9ICovXG5cdHZhciBzaWduYWwgPSB7XG5cdFx0ZjogMCwgLy8gVE9ETyBpZGVhbGx5IHdlIGNvdWxkIHNraXAgdGhpcyBhbHRvZ2V0aGVyLCBidXQgaXQgY2F1c2VzIHR5cGUgZXJyb3JzXG5cdFx0dixcblx0XHRyZWFjdGlvbnM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdHJ2OiAwLFxuXHRcdHd2OiAwXG5cdH07XG5cblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHNpZ25hbC5jcmVhdGVkID0gc3RhY2sgPz8gZ2V0X3N0YWNrKCdDcmVhdGVkQXQnKTtcblx0XHRzaWduYWwuZGVidWcgPSBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZSh2KSB7XG5cdHJldHVybiBwdXNoX2Rlcml2ZWRfc291cmNlKHNvdXJjZSh2KSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gaW5pdGlhbF92YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gbXV0YWJsZV9zb3VyY2UoaW5pdGlhbF92YWx1ZSwgaW1tdXRhYmxlID0gZmFsc2UpIHtcblx0Y29uc3QgcyA9IHNvdXJjZShpbml0aWFsX3ZhbHVlKTtcblx0aWYgKCFpbW11dGFibGUpIHtcblx0XHRzLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHR9XG5cblx0Ly8gYmluZCB0aGUgc2lnbmFsIHRvIHRoZSBjb21wb25lbnQgY29udGV4dCwgaW4gY2FzZSB3ZSBuZWVkIHRvXG5cdC8vIHRyYWNrIHVwZGF0ZXMgdG8gdHJpZ2dlciBiZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzXG5cdGlmIChsZWdhY3lfbW9kZV9mbGFnICYmIGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsICYmIGNvbXBvbmVudF9jb250ZXh0LmwgIT09IG51bGwpIHtcblx0XHQoY29tcG9uZW50X2NvbnRleHQubC5zID8/PSBbXSkucHVzaChzKTtcblx0fVxuXG5cdHJldHVybiBzO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqIEByZXR1cm5zIHtTb3VyY2U8Vj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXRhYmxlX3N0YXRlKHYsIGltbXV0YWJsZSA9IGZhbHNlKSB7XG5cdHJldHVybiBwdXNoX2Rlcml2ZWRfc291cmNlKG11dGFibGVfc291cmNlKHYsIGltbXV0YWJsZSkpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1NvdXJjZTxWPn0gc291cmNlXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZnVuY3Rpb24gcHVzaF9kZXJpdmVkX3NvdXJjZShzb3VyY2UpIHtcblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAhdW50cmFja2luZyAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdGlmIChkZXJpdmVkX3NvdXJjZXMgPT09IG51bGwpIHtcblx0XHRcdHNldF9kZXJpdmVkX3NvdXJjZXMoW3NvdXJjZV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXJpdmVkX3NvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzb3VyY2U7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VmFsdWU8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXV0YXRlKHNvdXJjZSwgdmFsdWUpIHtcblx0c2V0KFxuXHRcdHNvdXJjZSxcblx0XHR1bnRyYWNrKCgpID0+IGdldChzb3VyY2UpKVxuXHQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U291cmNlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHNvdXJjZSwgdmFsdWUpIHtcblx0aWYgKFxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdCF1bnRyYWNraW5nICYmXG5cdFx0aXNfcnVuZXMoKSAmJlxuXHRcdChhY3RpdmVfcmVhY3Rpb24uZiAmIChERVJJVkVEIHwgQkxPQ0tfRUZGRUNUKSkgIT09IDAgJiZcblx0XHQvLyBJZiB0aGUgc291cmNlIHdhcyBjcmVhdGVkIGxvY2FsbHkgd2l0aGluIHRoZSBjdXJyZW50IGRlcml2ZWQsIHRoZW5cblx0XHQvLyB3ZSBhbGxvdyB0aGUgbXV0YXRpb24uXG5cdFx0KGRlcml2ZWRfc291cmNlcyA9PT0gbnVsbCB8fCAhZGVyaXZlZF9zb3VyY2VzLmluY2x1ZGVzKHNvdXJjZSkpXG5cdCkge1xuXHRcdGUuc3RhdGVfdW5zYWZlX211dGF0aW9uKCk7XG5cdH1cblxuXHRyZXR1cm4gaW50ZXJuYWxfc2V0KHNvdXJjZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1NvdXJjZTxWPn0gc291cmNlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVybmFsX3NldChzb3VyY2UsIHZhbHVlKSB7XG5cdGlmICghc291cmNlLmVxdWFscyh2YWx1ZSkpIHtcblx0XHR2YXIgb2xkX3ZhbHVlID0gc291cmNlLnY7XG5cdFx0c291cmNlLnYgPSB2YWx1ZTtcblx0XHRzb3VyY2Uud3YgPSBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpO1xuXG5cdFx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdFx0c291cmNlLnVwZGF0ZWQgPSBnZXRfc3RhY2soJ1VwZGF0ZWRBdCcpO1xuXHRcdFx0aWYgKGFjdGl2ZV9lZmZlY3QgIT0gbnVsbCkge1xuXHRcdFx0XHRzb3VyY2UudHJhY2VfbmVlZF9pbmNyZWFzZSA9IHRydWU7XG5cdFx0XHRcdHNvdXJjZS50cmFjZV92ID8/PSBvbGRfdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWFya19yZWFjdGlvbnMoc291cmNlLCBESVJUWSk7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGN1cnJlbnQgcmVhY3Rpb24gbWlnaHQgbm90IGhhdmUgdXAtdG8tZGF0ZSBkZXBlbmRlbmNpZXNcblx0XHQvLyB3aGlsc3QgaXQncyBhY3RpdmVseSBydW5uaW5nLiBTbyBpbiB0aGUgY2FzZSBvZiBlbnN1cmluZyBpdCByZWdpc3RlcnMgdGhlIHJlYWN0aW9uXG5cdFx0Ly8gcHJvcGVybHkgZm9yIGl0c2VsZiwgd2UgbmVlZCB0byBlbnN1cmUgdGhlIGN1cnJlbnQgZWZmZWN0IGFjdHVhbGx5IGdldHNcblx0XHQvLyBzY2hlZHVsZWQuIGkuZTogYCRlZmZlY3QoKCkgPT4geCsrKWBcblx0XHRpZiAoXG5cdFx0XHRpc19ydW5lcygpICYmXG5cdFx0XHRhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmXG5cdFx0XHQoYWN0aXZlX2VmZmVjdC5mICYgQ0xFQU4pICE9PSAwICYmXG5cdFx0XHQoYWN0aXZlX2VmZmVjdC5mICYgKEJSQU5DSF9FRkZFQ1QgfCBST09UX0VGRkVDVCkpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRpZiAodW50cmFja2VkX3dyaXRlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHRzZXRfdW50cmFja2VkX3dyaXRlcyhbc291cmNlXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR1bnRyYWNrZWRfd3JpdGVzLnB1c2goc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoREVWICYmIGluc3BlY3RfZWZmZWN0cy5zaXplID4gMCkge1xuXHRcdFx0Y29uc3QgaW5zcGVjdHMgPSBBcnJheS5mcm9tKGluc3BlY3RfZWZmZWN0cyk7XG5cdFx0XHR2YXIgcHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QgPSBpc19mbHVzaGluZ19lZmZlY3Q7XG5cdFx0XHRzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHRydWUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm9yIChjb25zdCBlZmZlY3Qgb2YgaW5zcGVjdHMpIHtcblx0XHRcdFx0XHQvLyBNYXJrIGNsZWFuIGluc3BlY3QtZWZmZWN0cyBhcyBtYXliZSBkaXJ0eSBhbmQgdGhlbiBjaGVjayB0aGVpciBkaXJ0aW5lc3Ncblx0XHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGp1c3QgdXBkYXRpbmcgdGhlIGVmZmVjdHMgLSB0aGlzIHdheSB3ZSBhdm9pZCBvdmVyZmlyaW5nLlxuXHRcdFx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgTUFZQkVfRElSVFkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2hlY2tfZGlydGluZXNzKGVmZmVjdCkpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdHNldF9pc19mbHVzaGluZ19lZmZlY3QocHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QpO1xuXHRcdFx0fVxuXHRcdFx0aW5zcGVjdF9lZmZlY3RzLmNsZWFyKCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7bnVtYmVyIHwgYmlnaW50fSBUXG4gKiBAcGFyYW0ge1NvdXJjZTxUPn0gc291cmNlXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZShzb3VyY2UsIGQgPSAxKSB7XG5cdHZhciB2YWx1ZSA9IGdldChzb3VyY2UpO1xuXHR2YXIgcmVzdWx0ID0gZCA9PT0gMSA/IHZhbHVlKysgOiB2YWx1ZS0tO1xuXG5cdHNldChzb3VyY2UsIHZhbHVlKTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtudW1iZXIgfCBiaWdpbnR9IFRcbiAqIEBwYXJhbSB7U291cmNlPFQ+fSBzb3VyY2VcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3ByZShzb3VyY2UsIGQgPSAxKSB7XG5cdHZhciB2YWx1ZSA9IGdldChzb3VyY2UpO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHNldChzb3VyY2UsIGQgPT09IDEgPyArK3ZhbHVlIDogLS12YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzIHNob3VsZCBiZSBESVJUWSBvciBNQVlCRV9ESVJUWVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIG1hcmtfcmVhY3Rpb25zKHNpZ25hbCwgc3RhdHVzKSB7XG5cdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zID09PSBudWxsKSByZXR1cm47XG5cblx0dmFyIHJ1bmVzID0gaXNfcnVuZXMoKTtcblx0dmFyIGxlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGg7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhciByZWFjdGlvbiA9IHJlYWN0aW9uc1tpXTtcblx0XHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdFx0Ly8gU2tpcCBhbnkgZWZmZWN0cyB0aGF0IGFyZSBhbHJlYWR5IGRpcnR5XG5cdFx0aWYgKChmbGFncyAmIERJUlRZKSAhPT0gMCkgY29udGludWU7XG5cblx0XHQvLyBJbiBsZWdhY3kgbW9kZSwgc2tpcCB0aGUgY3VycmVudCBlZmZlY3QgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdGlmICghcnVuZXMgJiYgcmVhY3Rpb24gPT09IGFjdGl2ZV9lZmZlY3QpIGNvbnRpbnVlO1xuXG5cdFx0Ly8gSW5zcGVjdCBlZmZlY3RzIG5lZWQgdG8gcnVuIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHRoZSBzdGFjayB0cmFjZSBtYWtlcyBzZW5zZVxuXHRcdGlmIChERVYgJiYgKGZsYWdzICYgSU5TUEVDVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRpbnNwZWN0X2VmZmVjdHMuYWRkKHJlYWN0aW9uKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBzdGF0dXMpO1xuXG5cdFx0Ly8gSWYgdGhlIHNpZ25hbCBhKSB3YXMgcHJldmlvdXNseSBjbGVhbiBvciBiKSBpcyBhbiB1bm93bmVkIGRlcml2ZWQsIHRoZW4gbWFyayBpdFxuXHRcdGlmICgoZmxhZ3MgJiAoQ0xFQU4gfCBVTk9XTkVEKSkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0XHRtYXJrX3JlYWN0aW9ucygvKiogQHR5cGUge0Rlcml2ZWR9ICovIChyZWFjdGlvbiksIE1BWUJFX0RJUlRZKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjaGVkdWxlX2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKHJlYWN0aW9uKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5cbmltcG9ydCB7XG5cdEhZRFJBVElPTl9FTkQsXG5cdEhZRFJBVElPTl9FUlJPUixcblx0SFlEUkFUSU9OX1NUQVJULFxuXHRIWURSQVRJT05fU1RBUlRfRUxTRVxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcblxuLyoqXG4gKiBVc2UgdGhpcyB2YXJpYWJsZSB0byBndWFyZCBldmVyeXRoaW5nIHJlbGF0ZWQgdG8gaHlkcmF0aW9uIGNvZGUgc28gaXQgY2FuIGJlIHRyZWVzaGFrZW4gb3V0XG4gKiBpZiB0aGUgdXNlciBkb2Vzbid0IHVzZSB0aGUgYGh5ZHJhdGVgIG1ldGhvZCBhbmQgdGhlc2UgY29kZSBwYXRocyBhcmUgdGhlcmVmb3JlIG5vdCBuZWVkZWQuXG4gKi9cbmV4cG9ydCBsZXQgaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2h5ZHJhdGluZyh2YWx1ZSkge1xuXHRoeWRyYXRpbmcgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgbm9kZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBoeWRyYXRlZC4gVGhpcyBzdGFydHMgb3V0IGFzIHRoZSBmaXJzdCBub2RlIGluc2lkZSB0aGUgb3BlbmluZ1xuICogPCEtLVstLT4gY29tbWVudCwgYW5kIHVwZGF0ZXMgZWFjaCB0aW1lIGEgY29tcG9uZW50IGNhbGxzIGAkLmNoaWxkKC4uLilgIG9yIGAkLnNpYmxpbmcoLi4uKWAuXG4gKiBXaGVuIGVudGVyaW5nIGEgYmxvY2sgKGUuZy4gYHsjaWYgLi4ufWApLCBgaHlkcmF0ZV9ub2RlYCBpcyB0aGUgYmxvY2sgb3BlbmluZyBjb21tZW50OyBieSB0aGVcbiAqIHRpbWUgd2UgbGVhdmUgdGhlIGJsb2NrIGl0IGlzIHRoZSBjbG9zaW5nIGNvbW1lbnQsIHdoaWNoIHNlcnZlcyBhcyB0aGUgYmxvY2sncyBhbmNob3IuXG4gKiBAdHlwZSB7VGVtcGxhdGVOb2RlfVxuICovXG5leHBvcnQgbGV0IGh5ZHJhdGVfbm9kZTtcblxuLyoqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2h5ZHJhdGVfbm9kZShub2RlKSB7XG5cdGlmIChub2RlID09PSBudWxsKSB7XG5cdFx0dy5oeWRyYXRpb25fbWlzbWF0Y2goKTtcblx0XHR0aHJvdyBIWURSQVRJT05fRVJST1I7XG5cdH1cblxuXHRyZXR1cm4gKGh5ZHJhdGVfbm9kZSA9IG5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZV9uZXh0KCkge1xuXHRyZXR1cm4gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoaHlkcmF0ZV9ub2RlKSkpO1xufVxuXG4vKiogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNldChub2RlKSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0Ly8gSWYgdGhlIG5vZGUgaGFzIHJlbWFpbmluZyBzaWJsaW5ncywgc29tZXRoaW5nIGhhcyBnb25lIHdyb25nXG5cdGlmIChnZXRfbmV4dF9zaWJsaW5nKGh5ZHJhdGVfbm9kZSkgIT09IG51bGwpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdGh5ZHJhdGVfbm9kZSA9IG5vZGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZV90ZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUZW1wbGF0ZU5vZGUgZG9lc24ndCBpbmNsdWRlIERvY3VtZW50RnJhZ21lbnQsIGJ1dCBpdCdzIGFjdHVhbGx5IGZpbmVcblx0XHRoeWRyYXRlX25vZGUgPSB0ZW1wbGF0ZS5jb250ZW50O1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0KGNvdW50ID0gMSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0dmFyIGkgPSBjb3VudDtcblx0XHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdG5vZGUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdH1cblxuXHRcdGh5ZHJhdGVfbm9kZSA9IG5vZGU7XG5cdH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBub2RlcyBzdGFydGluZyBhdCBgaHlkcmF0ZV9ub2RlYCB1cCB1bnRpbCB0aGUgbmV4dCBoeWRyYXRpb24gZW5kIGNvbW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9ub2RlcygpIHtcblx0dmFyIGRlcHRoID0gMDtcblx0dmFyIG5vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0d2hpbGUgKHRydWUpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCkge1xuXHRcdFx0dmFyIGRhdGEgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChub2RlKS5kYXRhO1xuXG5cdFx0XHRpZiAoZGF0YSA9PT0gSFlEUkFUSU9OX0VORCkge1xuXHRcdFx0XHRpZiAoZGVwdGggPT09IDApIHJldHVybiBub2RlO1xuXHRcdFx0XHRkZXB0aCAtPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChkYXRhID09PSBIWURSQVRJT05fU1RBUlQgfHwgZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0UpIHtcblx0XHRcdFx0ZGVwdGggKz0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbmV4dCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRub2RlID0gbmV4dDtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBQcm94eU1ldGFkYXRhLCBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBnZXQsIGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0IHtcblx0YXJyYXlfcHJvdG90eXBlLFxuXHRnZXRfZGVzY3JpcHRvcixcblx0Z2V0X3Byb3RvdHlwZV9vZixcblx0aXNfYXJyYXksXG5cdG9iamVjdF9wcm90b3R5cGVcbn0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGNoZWNrX293bmVyc2hpcCwgd2lkZW5fb3duZXJzaGlwIH0gZnJvbSAnLi9kZXYvb3duZXJzaGlwLmpzJztcbmltcG9ydCB7IHNvdXJjZSwgc2V0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgU1RBVEVfU1lNQk9MLCBTVEFURV9TWU1CT0xfTUVUQURBVEEgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgZ2V0X3N0YWNrIH0gZnJvbSAnLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtQcm94eU1ldGFkYXRhIHwgbnVsbH0gW3BhcmVudF1cbiAqIEBwYXJhbSB7U291cmNlPFQ+fSBbcHJldl0gZGV2IG1vZGUgb25seVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm94eSh2YWx1ZSwgcGFyZW50ID0gbnVsbCwgcHJldikge1xuXHQvKiogQHR5cGUge0Vycm9yIHwgbnVsbH0gKi9cblx0dmFyIHN0YWNrID0gbnVsbDtcblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHN0YWNrID0gZ2V0X3N0YWNrKCdDcmVhdGVkQXQnKTtcblx0fVxuXHQvLyBpZiBub24tcHJveHlhYmxlLCBvciBpcyBhbHJlYWR5IGEgcHJveHksIHJldHVybiBgdmFsdWVgXG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsIHx8IFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGNvbnN0IHByb3RvdHlwZSA9IGdldF9wcm90b3R5cGVfb2YodmFsdWUpO1xuXG5cdGlmIChwcm90b3R5cGUgIT09IG9iamVjdF9wcm90b3R5cGUgJiYgcHJvdG90eXBlICE9PSBhcnJheV9wcm90b3R5cGUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHQvKiogQHR5cGUge01hcDxhbnksIFNvdXJjZTxhbnk+Pn0gKi9cblx0dmFyIHNvdXJjZXMgPSBuZXcgTWFwKCk7XG5cdHZhciBpc19wcm94aWVkX2FycmF5ID0gaXNfYXJyYXkodmFsdWUpO1xuXHR2YXIgdmVyc2lvbiA9IHNvdXJjZSgwKTtcblxuXHRpZiAoaXNfcHJveGllZF9hcnJheSkge1xuXHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIHRoZSBsZW5ndGggc291cmNlIGVhZ2VybHkgdG8gZW5zdXJlIHRoYXRcblx0XHQvLyBtdXRhdGlvbnMgdG8gdGhlIGFycmF5IGFyZSBwcm9wZXJseSBzeW5jZWQgd2l0aCBvdXIgcHJveHlcblx0XHRzb3VyY2VzLnNldCgnbGVuZ3RoJywgc291cmNlKC8qKiBAdHlwZSB7YW55W119ICovICh2YWx1ZSkubGVuZ3RoLCBzdGFjaykpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtQcm94eU1ldGFkYXRhfSAqL1xuXHR2YXIgbWV0YWRhdGE7XG5cblx0aWYgKERFVikge1xuXHRcdG1ldGFkYXRhID0ge1xuXHRcdFx0cGFyZW50LFxuXHRcdFx0b3duZXJzOiBudWxsXG5cdFx0fTtcblxuXHRcdGlmIChwcmV2KSB7XG5cdFx0XHQvLyBSZXVzZSBvd25lcnMgZnJvbSBwcmV2aW91cyBzdGF0ZTsgbmVjZXNzYXJ5IGJlY2F1c2UgcmVhc3NpZ25tZW50IGlzIG5vdCBndWFyYW50ZWVkIHRvIGhhdmUgY29ycmVjdCBjb21wb25lbnQgY29udGV4dC5cblx0XHRcdC8vIElmIG5vIHByZXZpb3VzIHByb3h5IGV4aXN0cyB3ZSBwbGF5IGl0IHNhZmUgYW5kIGFzc3VtZSBvd25lcmxlc3Mgc3RhdGVcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdGNvbnN0IHByZXZfb3duZXJzID0gcHJldi52Py5bU1RBVEVfU1lNQk9MX01FVEFEQVRBXT8ub3duZXJzO1xuXHRcdFx0bWV0YWRhdGEub3duZXJzID0gcHJldl9vd25lcnMgPyBuZXcgU2V0KHByZXZfb3duZXJzKSA6IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1ldGFkYXRhLm93bmVycyA9XG5cdFx0XHRcdHBhcmVudCA9PT0gbnVsbFxuXHRcdFx0XHRcdD8gY29tcG9uZW50X2NvbnRleHQgIT09IG51bGxcblx0XHRcdFx0XHRcdD8gbmV3IFNldChbY29tcG9uZW50X2NvbnRleHQuZnVuY3Rpb25dKVxuXHRcdFx0XHRcdFx0OiBudWxsXG5cdFx0XHRcdFx0OiBuZXcgU2V0KCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBQcm94eSgvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKSwge1xuXHRcdGRlZmluZVByb3BlcnR5KF8sIHByb3AsIGRlc2NyaXB0b3IpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0ISgndmFsdWUnIGluIGRlc2NyaXB0b3IpIHx8XG5cdFx0XHRcdGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRkZXNjcmlwdG9yLmVudW1lcmFibGUgPT09IGZhbHNlIHx8XG5cdFx0XHRcdGRlc2NyaXB0b3Iud3JpdGFibGUgPT09IGZhbHNlXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gd2UgZGlzYWxsb3cgbm9uLWJhc2ljIGRlc2NyaXB0b3JzLCBiZWNhdXNlIHVubGVzcyB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZVxuXHRcdFx0XHQvLyB0YXJnZXQgb2JqZWN0IOKAlCB3aGljaCB3ZSBhdm9pZCwgc28gdGhhdCBzdGF0ZSBjYW4gYmUgZm9ya2VkIOKAlCB3ZSB3aWxsIHJ1blxuXHRcdFx0XHQvLyBhZm91bCBvZiB0aGUgdmFyaW91cyBpbnZhcmlhbnRzXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5L1Byb3h5L2dldE93blByb3BlcnR5RGVzY3JpcHRvciNpbnZhcmlhbnRzXG5cdFx0XHRcdGUuc3RhdGVfZGVzY3JpcHRvcnNfZml4ZWQoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzID0gc291cmNlKGRlc2NyaXB0b3IudmFsdWUsIHN0YWNrKTtcblx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXQocywgcHJveHkoZGVzY3JpcHRvci52YWx1ZSwgbWV0YWRhdGEpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAocHJvcCBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzb3VyY2UoVU5JTklUSUFMSVpFRCwgc3RhY2spKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2hlbiB3b3JraW5nIHdpdGggYXJyYXlzLCB3ZSBuZWVkIHRvIGFsc28gZW5zdXJlIHdlIHVwZGF0ZSB0aGUgbGVuZ3RoIHdoZW4gcmVtb3Zpbmdcblx0XHRcdFx0Ly8gYW4gaW5kZXhlZCBwcm9wZXJ0eVxuXHRcdFx0XHRpZiAoaXNfcHJveGllZF9hcnJheSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YXIgbHMgPSAvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAoc291cmNlcy5nZXQoJ2xlbmd0aCcpKTtcblx0XHRcdFx0XHR2YXIgbiA9IE51bWJlcihwcm9wKTtcblxuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKG4pICYmIG4gPCBscy52KSB7XG5cdFx0XHRcdFx0XHRzZXQobHMsIG4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzZXQocywgVU5JTklUSUFMSVpFRCk7XG5cdFx0XHRcdHVwZGF0ZV92ZXJzaW9uKHZlcnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Z2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcblx0XHRcdGlmIChERVYgJiYgcHJvcCA9PT0gU1RBVEVfU1lNQk9MX01FVEFEQVRBKSB7XG5cdFx0XHRcdHJldHVybiBtZXRhZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHByb3AgPT09IFNUQVRFX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgZXhpc3RzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIGNyZWF0ZSBhIHNvdXJjZSwgYnV0IG9ubHkgaWYgaXQncyBhbiBvd24gcHJvcGVydHkgYW5kIG5vdCBhIHByb3RvdHlwZSBwcm9wZXJ0eVxuXHRcdFx0aWYgKHMgPT09IHVuZGVmaW5lZCAmJiAoIWV4aXN0cyB8fCBnZXRfZGVzY3JpcHRvcih0YXJnZXQsIHByb3ApPy53cml0YWJsZSkpIHtcblx0XHRcdFx0cyA9IHNvdXJjZShwcm94eShleGlzdHMgPyB0YXJnZXRbcHJvcF0gOiBVTklOSVRJQUxJWkVELCBtZXRhZGF0YSksIHN0YWNrKTtcblx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIHYgPSBnZXQocyk7XG5cblx0XHRcdFx0Ly8gSW4gY2FzZSBvZiBzb21ldGhpbmcgbGlrZSBgZm9vID0gYmFyLm1hcCguLi4pYCwgZm9vIHdvdWxkIGhhdmUgb3duZXJzaGlwXG5cdFx0XHRcdC8vIG9mIHRoZSBhcnJheSBpdHNlbGYsIHdoaWxlIHRoZSBpbmRpdmlkdWFsIGl0ZW1zIHdvdWxkIGhhdmUgb3duZXJzaGlwXG5cdFx0XHRcdC8vIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjcmVhdGVkIGJhci4gVGhhdCBtZWFucyBpZiB3ZSBsYXRlciBkbyBgZm9vWzBdLmJheiA9IDQyYCxcblx0XHRcdFx0Ly8gd2UgY291bGQgZ2V0IGEgZmFsc2UtcG9zaXRpdmUgb3duZXJzaGlwIHZpb2xhdGlvbiwgc2luY2UgdGhlIHR3byBwcm94aWVzXG5cdFx0XHRcdC8vIGFyZSBub3QgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgdmlhIHRoZSBwYXJlbnQgbWV0YWRhdGEgcmVsYXRpb25zaGlwLlxuXHRcdFx0XHQvLyBGb3IgdGhpcyByZWFzb24sIHdlIG5lZWQgdG8gd2lkZW4gdGhlIG93bmVyc2hpcCBvZiB0aGUgY2hpbGRyZW5cblx0XHRcdFx0Ly8gdXBvbiBhY2Nlc3Mgd2hlbiB3ZSBkZXRlY3QgdGhleSBhcmUgbm90IGNvbm5lY3RlZC5cblx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7UHJveHlNZXRhZGF0YSB8IHVuZGVmaW5lZH0gKi9cblx0XHRcdFx0XHR2YXIgcHJvcF9tZXRhZGF0YSA9IHY/LltTVEFURV9TWU1CT0xfTUVUQURBVEFdO1xuXHRcdFx0XHRcdGlmIChwcm9wX21ldGFkYXRhICYmIHByb3BfbWV0YWRhdGE/LnBhcmVudCAhPT0gbWV0YWRhdGEpIHtcblx0XHRcdFx0XHRcdHdpZGVuX293bmVyc2hpcChtZXRhZGF0YSwgcHJvcF9tZXRhZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHYgPT09IFVOSU5JVElBTElaRUQgPyB1bmRlZmluZWQgOiB2O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cdFx0fSxcblxuXHRcdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHRcdGlmIChzKSBkZXNjcmlwdG9yLnZhbHVlID0gZ2V0KHMpO1xuXHRcdFx0fSBlbHNlIGlmIChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBzb3VyY2U/LnY7XG5cblx0XHRcdFx0aWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblx0XHR9LFxuXG5cdFx0aGFzKHRhcmdldCwgcHJvcCkge1xuXHRcdFx0aWYgKERFViAmJiBwcm9wID09PSBTVEFURV9TWU1CT0xfTUVUQURBVEEpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcm9wID09PSBTVEFURV9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gKHMgIT09IHVuZGVmaW5lZCAmJiBzLnYgIT09IFVOSU5JVElBTElaRUQpIHx8IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0cyAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdChhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICghaGFzIHx8IGdldF9kZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LndyaXRhYmxlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cyA9IHNvdXJjZShoYXMgPyBwcm94eSh0YXJnZXRbcHJvcF0sIG1ldGFkYXRhKSA6IFVOSU5JVElBTElaRUQsIHN0YWNrKTtcblx0XHRcdFx0XHRzb3VyY2VzLnNldChwcm9wLCBzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdldChzKTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBVTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoYXM7XG5cdFx0fSxcblxuXHRcdHNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdHZhciBoYXMgPSBwcm9wIGluIHRhcmdldDtcblxuXHRcdFx0Ly8gdmFyaWFibGUubGVuZ3RoID0gdmFsdWUgLT4gY2xlYXIgYWxsIHNpZ25hbHMgd2l0aCBpbmRleCA+PSB2YWx1ZVxuXHRcdFx0aWYgKGlzX3Byb3hpZWRfYXJyYXkgJiYgcHJvcCA9PT0gJ2xlbmd0aCcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHZhbHVlOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHMpLnY7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHZhciBvdGhlcl9zID0gc291cmNlcy5nZXQoaSArICcnKTtcblx0XHRcdFx0XHRpZiAob3RoZXJfcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRzZXQob3RoZXJfcywgVU5JTklUSUFMSVpFRCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpIGluIHRhcmdldCkge1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGl0ZW0gZXhpc3RzIGluIHRoZSBvcmlnaW5hbCwgd2UgbmVlZCB0byBjcmVhdGUgYSB1bmluaXRpYWxpemVkIHNvdXJjZSxcblx0XHRcdFx0XHRcdC8vIGVsc2UgYSBsYXRlciByZWFkIG9mIHRoZSBwcm9wZXJ0eSB3b3VsZCByZXN1bHQgaW4gYSBzb3VyY2UgYmVpbmcgY3JlYXRlZCB3aXRoXG5cdFx0XHRcdFx0XHQvLyB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsIGl0ZW0gYXQgdGhhdCBpbmRleC5cblx0XHRcdFx0XHRcdG90aGVyX3MgPSBzb3VyY2UoVU5JTklUSUFMSVpFRCwgc3RhY2spO1xuXHRcdFx0XHRcdFx0c291cmNlcy5zZXQoaSArICcnLCBvdGhlcl9zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZW4ndCB5ZXQgY3JlYXRlZCBhIHNvdXJjZSBmb3IgdGhpcyBwcm9wZXJ0eSwgd2UgbmVlZCB0byBlbnN1cmVcblx0XHRcdC8vIHdlIGRvIHNvIG90aGVyd2lzZSBpZiB3ZSByZWFkIGl0IGxhdGVyLCB0aGVuIHRoZSB3cml0ZSB3b24ndCBiZSB0cmFja2VkIGFuZFxuXHRcdFx0Ly8gdGhlIGhldXJpc3RpY3Mgb2YgZWZmZWN0cyB3aWxsIGJlIGRpZmZlcmVudCB2cyBpZiB3ZSBoYWQgcmVhZCB0aGUgcHJveGllZFxuXHRcdFx0Ly8gb2JqZWN0IHByb3BlcnR5IGJlZm9yZSB3cml0aW5nIHRvIHRoYXQgcHJvcGVydHkuXG5cdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmICghaGFzIHx8IGdldF9kZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LndyaXRhYmxlKSB7XG5cdFx0XHRcdFx0cyA9IHNvdXJjZSh1bmRlZmluZWQsIHN0YWNrKTtcblx0XHRcdFx0XHRzZXQocywgcHJveHkodmFsdWUsIG1ldGFkYXRhKSk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhcyA9IHMudiAhPT0gVU5JTklUSUFMSVpFRDtcblx0XHRcdFx0c2V0KHMsIHByb3h5KHZhbHVlLCBtZXRhZGF0YSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7UHJveHlNZXRhZGF0YSB8IHVuZGVmaW5lZH0gKi9cblx0XHRcdFx0dmFyIHByb3BfbWV0YWRhdGEgPSB2YWx1ZT8uW1NUQVRFX1NZTUJPTF9NRVRBREFUQV07XG5cdFx0XHRcdGlmIChwcm9wX21ldGFkYXRhICYmIHByb3BfbWV0YWRhdGE/LnBhcmVudCAhPT0gbWV0YWRhdGEpIHtcblx0XHRcdFx0XHR3aWRlbl9vd25lcnNoaXAobWV0YWRhdGEsIHByb3BfbWV0YWRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoZWNrX293bmVyc2hpcChtZXRhZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgdmFsdWUgYmVmb3JlIHVwZGF0aW5nIGFueSBzaWduYWxzIHNvIHRoYXQgYW55IGxpc3RlbmVycyBnZXQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0aWYgKGRlc2NyaXB0b3I/LnNldCkge1xuXHRcdFx0XHRkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaGFzKSB7XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgbXV0YXRlZCBhbiBhcnJheSBkaXJlY3RseSwgd2UgbWlnaHQgbmVlZCB0b1xuXHRcdFx0XHQvLyBzaWduYWwgdGhhdCBsZW5ndGggaGFzIGFsc28gY2hhbmdlZC4gRG8gaXQgYmVmb3JlIHVwZGF0aW5nIG1ldGFkYXRhXG5cdFx0XHRcdC8vIHRvIGVuc3VyZSB0aGF0IGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSBhcyBhIHJlc3VsdCBvZiBhIG1ldGFkYXRhIHVwZGF0ZVxuXHRcdFx0XHQvLyB3aWxsIG5vdCBjYXVzZSB0aGUgbGVuZ3RoIHRvIGJlIG91dCBvZiBzeW5jLlxuXHRcdFx0XHRpZiAoaXNfcHJveGllZF9hcnJheSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YXIgbHMgPSAvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAoc291cmNlcy5nZXQoJ2xlbmd0aCcpKTtcblx0XHRcdFx0XHR2YXIgbiA9IE51bWJlcihwcm9wKTtcblxuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKG4pICYmIG4gPj0gbHMudikge1xuXHRcdFx0XHRcdFx0c2V0KGxzLCBuICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dXBkYXRlX3ZlcnNpb24odmVyc2lvbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRvd25LZXlzKHRhcmdldCkge1xuXHRcdFx0Z2V0KHZlcnNpb24pO1xuXG5cdFx0XHR2YXIgb3duX2tleXMgPSBSZWZsZWN0Lm93bktleXModGFyZ2V0KS5maWx0ZXIoKGtleSkgPT4ge1xuXHRcdFx0XHR2YXIgc291cmNlID0gc291cmNlcy5nZXQoa2V5KTtcblx0XHRcdFx0cmV0dXJuIHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHNvdXJjZS52ICE9PSBVTklOSVRJQUxJWkVEO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAodmFyIFtrZXksIHNvdXJjZV0gb2Ygc291cmNlcykge1xuXHRcdFx0XHRpZiAoc291cmNlLnYgIT09IFVOSU5JVElBTElaRUQgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuXHRcdFx0XHRcdG93bl9rZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3duX2tleXM7XG5cdFx0fSxcblxuXHRcdHNldFByb3RvdHlwZU9mKCkge1xuXHRcdFx0ZS5zdGF0ZV9wcm90b3R5cGVfZml4ZWQoKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U291cmNlPG51bWJlcj59IHNpZ25hbFxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICovXG5mdW5jdGlvbiB1cGRhdGVfdmVyc2lvbihzaWduYWwsIGQgPSAxKSB7XG5cdHNldChzaWduYWwsIHNpZ25hbC52ICsgZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcHJveGllZF92YWx1ZSh2YWx1ZSkge1xuXHRpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTVEFURV9TWU1CT0wgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWVbU1RBVEVfU1lNQk9MXTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKGEsIGIpIHtcblx0cmV0dXJuIE9iamVjdC5pcyhnZXRfcHJveGllZF92YWx1ZShhKSwgZ2V0X3Byb3hpZWRfdmFsdWUoYikpO1xufVxuIiwiaW1wb3J0ICogYXMgdyBmcm9tICcuLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfcHJveGllZF92YWx1ZSB9IGZyb20gJy4uL3Byb3h5LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzKCkge1xuXHRjb25zdCBhcnJheV9wcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cdC8vIFRoZSBSRVBMIGVuZHMgdXAgaGVyZSBvdmVyIGFuZCBvdmVyLCBhbmQgdGhpcyBwcmV2ZW50cyBpdCBmcm9tIGFkZGluZyBtb3JlIGFuZCBtb3JlIHBhdGNoZXNcblx0Ly8gb2YgdGhlIHNhbWUga2luZCB0byB0aGUgcHJvdG90eXBlLCB3aGljaCB3b3VsZCBzbG93IGRvd24gZXZlcnl0aGluZyBvdmVyIHRpbWUuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgY2xlYW51cCA9IEFycmF5Ll9fc3ZlbHRlX2NsZWFudXA7XG5cdGlmIChjbGVhbnVwKSB7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cblx0Y29uc3QgeyBpbmRleE9mLCBsYXN0SW5kZXhPZiwgaW5jbHVkZXMgfSA9IGFycmF5X3Byb3RvdHlwZTtcblxuXHRhcnJheV9wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Y29uc3QgaW5kZXggPSBpbmRleE9mLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCk7XG5cblx0XHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gZnJvbV9pbmRleCA/PyAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRpZiAoZ2V0X3Byb3hpZWRfdmFsdWUodGhpc1tpXSkgPT09IGl0ZW0pIHtcblx0XHRcdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKCdhcnJheS5pbmRleE9mKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fTtcblxuXHRhcnJheV9wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdC8vIHdlIG5lZWQgdG8gc3BlY2lmeSB0aGlzLmxlbmd0aCAtIDEgYmVjYXVzZSBpdCdzIHByb2JhYmx5IHVzaW5nIHNvbWV0aGluZyBsaWtlXG5cdFx0Ly8gYGFyZ3VtZW50c2AgaW5zaWRlIHNvIHBhc3NpbmcgdW5kZWZpbmVkIGlzIGRpZmZlcmVudCBmcm9tIG5vdCBwYXNzaW5nIGFueXRoaW5nXG5cdFx0Y29uc3QgaW5kZXggPSBsYXN0SW5kZXhPZi5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXggPz8gdGhpcy5sZW5ndGggLSAxKTtcblxuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDw9IChmcm9tX2luZGV4ID8/IHRoaXMubGVuZ3RoIC0gMSk7IGkgKz0gMSkge1xuXHRcdFx0XHRpZiAoZ2V0X3Byb3hpZWRfdmFsdWUodGhpc1tpXSkgPT09IGl0ZW0pIHtcblx0XHRcdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKCdhcnJheS5sYXN0SW5kZXhPZiguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0YXJyYXlfcHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHRjb25zdCBoYXMgPSBpbmNsdWRlcy5jYWxsKHRoaXMsIGl0ZW0sIGZyb21faW5kZXgpO1xuXG5cdFx0aWYgKCFoYXMpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRpZiAoZ2V0X3Byb3hpZWRfdmFsdWUodGhpc1tpXSkgPT09IGl0ZW0pIHtcblx0XHRcdFx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKCdhcnJheS5pbmNsdWRlcyguLi4pJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gaGFzO1xuXHR9O1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0QXJyYXkuX19zdmVsdGVfY2xlYW51cCA9ICgpID0+IHtcblx0XHRhcnJheV9wcm90b3R5cGUuaW5kZXhPZiA9IGluZGV4T2Y7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG5cdFx0YXJyYXlfcHJvdG90eXBlLmluY2x1ZGVzID0gaW5jbHVkZXM7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVxdWFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmljdF9lcXVhbHMoYSwgYiwgZXF1YWwgPSB0cnVlKSB7XG5cdC8vIHRyeS1jYXRjaCBuZWVkZWQgYmVjYXVzZSB0aGlzIHRyaWVzIHRvIHJlYWQgcHJvcGVydGllcyBvZiBgYWAgYW5kIGBiYCxcblx0Ly8gd2hpY2ggY291bGQgYmUgZGlzYWxsb3dlZCBmb3IgZXhhbXBsZSBpbiBhIHNlY3VyZSBjb250ZXh0XG5cdHRyeSB7XG5cdFx0aWYgKChhID09PSBiKSAhPT0gKGdldF9wcm94aWVkX3ZhbHVlKGEpID09PSBnZXRfcHJveGllZF92YWx1ZShiKSkpIHtcblx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goZXF1YWwgPyAnPT09JyA6ICchPT0nKTtcblx0XHR9XG5cdH0gY2F0Y2gge31cblxuXHRyZXR1cm4gKGEgPT09IGIpID09PSBlcXVhbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXF1YWxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIsIGVxdWFsID0gdHJ1ZSkge1xuXHRpZiAoKGEgPT0gYikgIT09IChnZXRfcHJveGllZF92YWx1ZShhKSA9PSBnZXRfcHJveGllZF92YWx1ZShiKSkpIHtcblx0XHR3LnN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoKGVxdWFsID8gJz09JyA6ICchPScpO1xuXHR9XG5cblx0cmV0dXJuIChhID09IGIpID09PSBlcXVhbDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncyB9IGZyb20gJy4uL2Rldi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8vIGV4cG9ydCB0aGVzZSBmb3IgcmVmZXJlbmNlIGluIHRoZSBjb21waWxlZCBjb2RlLCBtYWtpbmcgZ2xvYmFsIG5hbWUgZGVkdXBsaWNhdGlvbiB1bm5lY2Vzc2FyeVxuLyoqIEB0eXBlIHtXaW5kb3d9ICovXG5leHBvcnQgdmFyICR3aW5kb3c7XG5cbi8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG5leHBvcnQgdmFyICRkb2N1bWVudDtcblxuLyoqIEB0eXBlIHtib29sZWFufSAqL1xuZXhwb3J0IHZhciBpc19maXJlZm94O1xuXG4vKiogQHR5cGUgeygpID0+IE5vZGUgfCBudWxsfSAqL1xudmFyIGZpcnN0X2NoaWxkX2dldHRlcjtcbi8qKiBAdHlwZSB7KCkgPT4gTm9kZSB8IG51bGx9ICovXG52YXIgbmV4dF9zaWJsaW5nX2dldHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZXNlIGxhemlseSB0byBhdm9pZCBpc3N1ZXMgd2hlbiB1c2luZyB0aGUgcnVudGltZSBpbiBhIHNlcnZlciBjb250ZXh0XG4gKiB3aGVyZSB0aGVzZSBnbG9iYWxzIGFyZSBub3QgYXZhaWxhYmxlIHdoaWxlIGF2b2lkaW5nIGEgc2VwYXJhdGUgc2VydmVyIGVudHJ5IHBvaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X29wZXJhdGlvbnMoKSB7XG5cdGlmICgkd2luZG93ICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQkd2luZG93ID0gd2luZG93O1xuXHQkZG9jdW1lbnQgPSBkb2N1bWVudDtcblx0aXNfZmlyZWZveCA9IC9GaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdHZhciBlbGVtZW50X3Byb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuXHR2YXIgbm9kZV9wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdGZpcnN0X2NoaWxkX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnZmlyc3RDaGlsZCcpLmdldDtcblx0Ly8gQHRzLWlnbm9yZVxuXHRuZXh0X3NpYmxpbmdfZ2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3Iobm9kZV9wcm90b3R5cGUsICduZXh0U2libGluZycpLmdldDtcblxuXHQvLyB0aGUgZm9sbG93aW5nIGFzc2lnbm1lbnRzIGltcHJvdmUgcGVyZiBvZiBsb29rdXBzIG9uIERPTSBub2Rlc1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnRfcHJvdG90eXBlLl9fY2xpY2sgPSB1bmRlZmluZWQ7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudF9wcm90b3R5cGUuX19jbGFzc05hbWUgPSAnJztcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX2F0dHJpYnV0ZXMgPSBudWxsO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnRfcHJvdG90eXBlLl9fc3R5bGVzID0gbnVsbDtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50X3Byb3RvdHlwZS5fX2UgPSB1bmRlZmluZWQ7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRUZXh0LnByb3RvdHlwZS5fX3QgPSB1bmRlZmluZWQ7XG5cblx0aWYgKERFVikge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX3N2ZWx0ZV9tZXRhID0gbnVsbDtcblxuXHRcdGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtUZXh0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3RleHQodmFsdWUgPSAnJykge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7Tm9kZX0gTlxuICogQHBhcmFtIHtOfSBub2RlXG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbi8qQF9fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9maXJzdF9jaGlsZChub2RlKSB7XG5cdHJldHVybiBmaXJzdF9jaGlsZF9nZXR0ZXIuY2FsbChub2RlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfbmV4dF9zaWJsaW5nKG5vZGUpIHtcblx0cmV0dXJuIG5leHRfc2libGluZ19nZXR0ZXIuY2FsbChub2RlKTtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBpc190ZXh0XG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZChub2RlLCBpc190ZXh0KSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0cmV0dXJuIGdldF9maXJzdF9jaGlsZChub2RlKTtcblx0fVxuXG5cdHZhciBjaGlsZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGh5ZHJhdGVfbm9kZSkpO1xuXG5cdC8vIENoaWxkIGNhbiBiZSBudWxsIGlmIHdlIGhhdmUgYW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIGNoaWxkLCBsaWtlIGA8cD57dGV4dH08L3A+YCwgd2hlcmUgYHRleHRgIGlzIGVtcHR5XG5cdGlmIChjaGlsZCA9PT0gbnVsbCkge1xuXHRcdGNoaWxkID0gaHlkcmF0ZV9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9IGVsc2UgaWYgKGlzX3RleHQgJiYgY2hpbGQubm9kZVR5cGUgIT09IDMpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0Y2hpbGQ/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZCk7XG5cdHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBUZW1wbGF0ZU5vZGVbXX0gZnJhZ21lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RfY2hpbGQoZnJhZ21lbnQsIGlzX3RleHQpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHQvLyB3aGVuIG5vdCBoeWRyYXRpbmcsIGBmcmFnbWVudGAgaXMgYSBgRG9jdW1lbnRGcmFnbWVudGAgKHRoZSByZXN1bHQgb2YgY2FsbGluZyBgb3Blbl9mcmFnYClcblx0XHR2YXIgZmlyc3QgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZnJhZ21lbnQpKSk7XG5cblx0XHQvLyBUT0RPIHByZXZlbnQgdXNlciBjb21tZW50cyB3aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBwcmVzZXJ2ZUNvbW1lbnRzIGlzIHRydWVcblx0XHRpZiAoZmlyc3QgaW5zdGFuY2VvZiBDb21tZW50ICYmIGZpcnN0LmRhdGEgPT09ICcnKSByZXR1cm4gZ2V0X25leHRfc2libGluZyhmaXJzdCk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH1cblxuXHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUg4oCUIHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgaHlkcmF0ZV9ub2RlPy5ub2RlVHlwZSAhPT0gMykge1xuXHRcdHZhciB0ZXh0ID0gY3JlYXRlX3RleHQoKTtcblxuXHRcdGh5ZHJhdGVfbm9kZT8uYmVmb3JlKHRleHQpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUodGV4dCk7XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cblxuXHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2libGluZyhub2RlLCBjb3VudCA9IDEsIGlzX3RleHQgPSBmYWxzZSkge1xuXHRsZXQgbmV4dF9zaWJsaW5nID0gaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZTtcblx0dmFyIGxhc3Rfc2libGluZztcblxuXHR3aGlsZSAoY291bnQtLSkge1xuXHRcdGxhc3Rfc2libGluZyA9IG5leHRfc2libGluZztcblx0XHRuZXh0X3NpYmxpbmcgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobmV4dF9zaWJsaW5nKSk7XG5cdH1cblxuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBuZXh0X3NpYmxpbmc7XG5cdH1cblxuXHR2YXIgdHlwZSA9IG5leHRfc2libGluZz8ubm9kZVR5cGU7XG5cblx0Ly8gaWYgYSBzaWJsaW5nIHtleHByZXNzaW9ufSBpcyBlbXB0eSBkdXJpbmcgU1NSLCB0aGVyZSBtaWdodCBiZSBub1xuXHQvLyB0ZXh0IG5vZGUgdG8gaHlkcmF0ZSDigJQgd2UgbXVzdCB0aGVyZWZvcmUgY3JlYXRlIG9uZVxuXHRpZiAoaXNfdGV4dCAmJiB0eXBlICE9PSAzKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdC8vIElmIHRoZSBuZXh0IHNpYmxpbmcgaXMgYG51bGxgIGFuZCB3ZSdyZSBoYW5kbGluZyB0ZXh0IHRoZW4gaXQncyBiZWNhdXNlXG5cdFx0Ly8gdGhlIFNTUiBjb250ZW50IHdhcyBlbXB0eSBmb3IgdGhlIHRleHQsIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgYSBuZXcgdGV4dFxuXHRcdC8vIG5vZGUgYW5kIGluc2VydCBpdCBhZnRlciB0aGUgbGFzdCBzaWJsaW5nXG5cdFx0aWYgKG5leHRfc2libGluZyA9PT0gbnVsbCkge1xuXHRcdFx0bGFzdF9zaWJsaW5nPy5hZnRlcih0ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV4dF9zaWJsaW5nLmJlZm9yZSh0ZXh0KTtcblx0XHR9XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHNldF9oeWRyYXRlX25vZGUobmV4dF9zaWJsaW5nKTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dF9zaWJsaW5nKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcl90ZXh0X2NvbnRlbnQobm9kZSkge1xuXHRub2RlLnRleHRDb250ZW50ID0gJyc7XG59XG4iLCIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IENMRUFOLCBERVJJVkVELCBESVJUWSwgRUZGRUNUX0hBU19ERVJJVkVELCBNQVlCRV9ESVJUWSwgVU5PV05FRCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHRza2lwX3JlYWN0aW9uLFxuXHR1cGRhdGVfcmVhY3Rpb24sXG5cdGluY3JlbWVudF93cml0ZV92ZXJzaW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdFxufSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGVxdWFscywgc2FmZV9lcXVhbHMgfSBmcm9tICcuL2VxdWFsaXR5LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGRlc3Ryb3lfZWZmZWN0IH0gZnJvbSAnLi9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGluc3BlY3RfZWZmZWN0cywgc2V0X2luc3BlY3RfZWZmZWN0cyB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKGZuKSB7XG5cdHZhciBmbGFncyA9IERFUklWRUQgfCBESVJUWTtcblx0dmFyIHBhcmVudF9kZXJpdmVkID1cblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDBcblx0XHRcdD8gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKVxuXHRcdFx0OiBudWxsO1xuXG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsIHx8IChwYXJlbnRfZGVyaXZlZCAhPT0gbnVsbCAmJiAocGFyZW50X2Rlcml2ZWQuZiAmIFVOT1dORUQpICE9PSAwKSkge1xuXHRcdGZsYWdzIHw9IFVOT1dORUQ7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2luY2UgZGVyaXZlZHMgYXJlIGV2YWx1YXRlZCBsYXppbHksIGFueSBlZmZlY3RzIGNyZWF0ZWQgaW5zaWRlIHRoZW0gYXJlXG5cdFx0Ly8gY3JlYXRlZCB0b28gbGF0ZSB0byBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IGVmZmVjdCBpcyBhZGRlZCB0byB0aGUgdHJlZVxuXHRcdGFjdGl2ZV9lZmZlY3QuZiB8PSBFRkZFQ1RfSEFTX0RFUklWRUQ7XG5cdH1cblxuXHQvKiogQHR5cGUge0Rlcml2ZWQ8Vj59ICovXG5cdGNvbnN0IHNpZ25hbCA9IHtcblx0XHRjdHg6IGNvbXBvbmVudF9jb250ZXh0LFxuXHRcdGRlcHM6IG51bGwsXG5cdFx0ZWZmZWN0czogbnVsbCxcblx0XHRlcXVhbHMsXG5cdFx0ZjogZmxhZ3MsXG5cdFx0Zm4sXG5cdFx0cmVhY3Rpb25zOiBudWxsLFxuXHRcdHJ2OiAwLFxuXHRcdHY6IC8qKiBAdHlwZSB7Vn0gKi8gKG51bGwpLFxuXHRcdHd2OiAwLFxuXHRcdHBhcmVudDogcGFyZW50X2Rlcml2ZWQgPz8gYWN0aXZlX2VmZmVjdFxuXHR9O1xuXG5cdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcpIHtcblx0XHRzaWduYWwuY3JlYXRlZCA9IGdldF9zdGFjaygnQ3JlYXRlZEF0Jyk7XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0geygpID0+IFZ9IGZuXG4gKiBAcmV0dXJucyB7RGVyaXZlZDxWPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZF9zYWZlX2VxdWFsKGZuKSB7XG5cdGNvbnN0IHNpZ25hbCA9IGRlcml2ZWQoZm4pO1xuXHRzaWduYWwuZXF1YWxzID0gc2FmZV9lcXVhbHM7XG5cdHJldHVybiBzaWduYWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpIHtcblx0dmFyIGVmZmVjdHMgPSBkZXJpdmVkLmVmZmVjdHM7XG5cblx0aWYgKGVmZmVjdHMgIT09IG51bGwpIHtcblx0XHRkZXJpdmVkLmVmZmVjdHMgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCgvKiogQHR5cGUge0VmZmVjdH0gKi8gKGVmZmVjdHNbaV0pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IHVwZGF0aW5nIGRlcml2ZWRzLCB1c2VkIHRvIGRldGVjdCBpbmZpbml0ZSByZWN1cnNpb25cbiAqIGluIGRldiBtb2RlIGFuZCBwcm92aWRlIGEgbmljZXIgZXJyb3IgdGhhbiAndG9vIG11Y2ggcmVjdXJzaW9uJ1xuICogQHR5cGUge0Rlcml2ZWRbXX1cbiAqL1xubGV0IHN0YWNrID0gW107XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7RWZmZWN0IHwgbnVsbH1cbiAqL1xuZnVuY3Rpb24gZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSB7XG5cdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmICgocGFyZW50LmYgJiBERVJJVkVEKSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocGFyZW50KTtcblx0XHR9XG5cdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudDtcblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZTtcblx0dmFyIHByZXZfYWN0aXZlX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0c2V0X2FjdGl2ZV9lZmZlY3QoZ2V0X2Rlcml2ZWRfcGFyZW50X2VmZmVjdChkZXJpdmVkKSk7XG5cblx0aWYgKERFVikge1xuXHRcdGxldCBwcmV2X2luc3BlY3RfZWZmZWN0cyA9IGluc3BlY3RfZWZmZWN0cztcblx0XHRzZXRfaW5zcGVjdF9lZmZlY3RzKG5ldyBTZXQoKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGlmIChzdGFjay5pbmNsdWRlcyhkZXJpdmVkKSkge1xuXHRcdFx0XHRlLmRlcml2ZWRfcmVmZXJlbmNlc19zZWxmKCk7XG5cdFx0XHR9XG5cblx0XHRcdHN0YWNrLnB1c2goZGVyaXZlZCk7XG5cblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0XHRzZXRfaW5zcGVjdF9lZmZlY3RzKHByZXZfaW5zcGVjdF9lZmZlY3RzKTtcblx0XHRcdHN0YWNrLnBvcCgpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0cnkge1xuXHRcdFx0ZGVzdHJveV9kZXJpdmVkX2VmZmVjdHMoZGVyaXZlZCk7XG5cdFx0XHR2YWx1ZSA9IHVwZGF0ZV9yZWFjdGlvbihkZXJpdmVkKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldl9hY3RpdmVfZWZmZWN0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZXJpdmVkfSBkZXJpdmVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9kZXJpdmVkKGRlcml2ZWQpIHtcblx0dmFyIHZhbHVlID0gZXhlY3V0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXHR2YXIgc3RhdHVzID1cblx0XHQoc2tpcF9yZWFjdGlvbiB8fCAoZGVyaXZlZC5mICYgVU5PV05FRCkgIT09IDApICYmIGRlcml2ZWQuZGVwcyAhPT0gbnVsbCA/IE1BWUJFX0RJUlRZIDogQ0xFQU47XG5cblx0c2V0X3NpZ25hbF9zdGF0dXMoZGVyaXZlZCwgc3RhdHVzKTtcblxuXHRpZiAoIWRlcml2ZWQuZXF1YWxzKHZhbHVlKSkge1xuXHRcdGRlcml2ZWQudiA9IHZhbHVlO1xuXHRcdGRlcml2ZWQud3YgPSBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpO1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIENvbXBvbmVudENvbnRleHRMZWdhY3ksIERlcml2ZWQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlLCBUcmFuc2l0aW9uTWFuYWdlciB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQge1xuXHRjaGVja19kaXJ0aW5lc3MsXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0Z2V0LFxuXHRpc19kZXN0cm95aW5nX2VmZmVjdCxcblx0aXNfZmx1c2hpbmdfZWZmZWN0LFxuXHRyZW1vdmVfcmVhY3Rpb25zLFxuXHRzY2hlZHVsZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCxcblx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVudHJhY2ssXG5cdHNraXBfcmVhY3Rpb24sXG5cdHVudHJhY2tpbmdcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQge1xuXHRESVJUWSxcblx0QlJBTkNIX0VGRkVDVCxcblx0UkVOREVSX0VGRkVDVCxcblx0RUZGRUNULFxuXHRERVNUUk9ZRUQsXG5cdElORVJULFxuXHRFRkZFQ1RfUkFOLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRFRkZFQ1RfVFJBTlNQQVJFTlQsXG5cdERFUklWRUQsXG5cdFVOT1dORUQsXG5cdENMRUFOLFxuXHRJTlNQRUNUX0VGRkVDVCxcblx0SEVBRF9FRkZFQ1QsXG5cdE1BWUJFX0RJUlRZLFxuXHRFRkZFQ1RfSEFTX0RFUklWRUQsXG5cdEJPVU5EQVJZX0VGRkVDVFxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vY29udGV4dC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsnJGVmZmVjdCcgfCAnJGVmZmVjdC5wcmUnIHwgJyRpbnNwZWN0J30gcnVuZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfZWZmZWN0KHJ1bmUpIHtcblx0aWYgKGFjdGl2ZV9lZmZlY3QgPT09IG51bGwgJiYgYWN0aXZlX3JlYWN0aW9uID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3Rfb3JwaGFuKHJ1bmUpO1xuXHR9XG5cblx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBVTk9XTkVEKSAhPT0gMCAmJiBhY3RpdmVfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCk7XG5cdH1cblxuXHRpZiAoaXNfZGVzdHJveWluZ19lZmZlY3QpIHtcblx0XHRlLmVmZmVjdF9pbl90ZWFyZG93bihydW5lKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7RWZmZWN0fSBwYXJlbnRfZWZmZWN0XG4gKi9cbmZ1bmN0aW9uIHB1c2hfZWZmZWN0KGVmZmVjdCwgcGFyZW50X2VmZmVjdCkge1xuXHR2YXIgcGFyZW50X2xhc3QgPSBwYXJlbnRfZWZmZWN0Lmxhc3Q7XG5cdGlmIChwYXJlbnRfbGFzdCA9PT0gbnVsbCkge1xuXHRcdHBhcmVudF9lZmZlY3QubGFzdCA9IHBhcmVudF9lZmZlY3QuZmlyc3QgPSBlZmZlY3Q7XG5cdH0gZWxzZSB7XG5cdFx0cGFyZW50X2xhc3QubmV4dCA9IGVmZmVjdDtcblx0XHRlZmZlY3QucHJldiA9IHBhcmVudF9sYXN0O1xuXHRcdHBhcmVudF9lZmZlY3QubGFzdCA9IGVmZmVjdDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcGFyYW0ge251bGwgfCAoKCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKSl9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHVzaFxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2VmZmVjdCh0eXBlLCBmbiwgc3luYywgcHVzaCA9IHRydWUpIHtcblx0dmFyIGlzX3Jvb3QgPSAodHlwZSAmIFJPT1RfRUZGRUNUKSAhPT0gMDtcblx0dmFyIHBhcmVudF9lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBFbnN1cmUgdGhlIHBhcmVudCBpcyBuZXZlciBhbiBpbnNwZWN0IGVmZmVjdFxuXHRcdHdoaWxlIChwYXJlbnRfZWZmZWN0ICE9PSBudWxsICYmIChwYXJlbnRfZWZmZWN0LmYgJiBJTlNQRUNUX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdHBhcmVudF9lZmZlY3QgPSBwYXJlbnRfZWZmZWN0LnBhcmVudDtcblx0XHR9XG5cdH1cblxuXHQvKiogQHR5cGUge0VmZmVjdH0gKi9cblx0dmFyIGVmZmVjdCA9IHtcblx0XHRjdHg6IGNvbXBvbmVudF9jb250ZXh0LFxuXHRcdGRlcHM6IG51bGwsXG5cdFx0bm9kZXNfc3RhcnQ6IG51bGwsXG5cdFx0bm9kZXNfZW5kOiBudWxsLFxuXHRcdGY6IHR5cGUgfCBESVJUWSxcblx0XHRmaXJzdDogbnVsbCxcblx0XHRmbixcblx0XHRsYXN0OiBudWxsLFxuXHRcdG5leHQ6IG51bGwsXG5cdFx0cGFyZW50OiBpc19yb290ID8gbnVsbCA6IHBhcmVudF9lZmZlY3QsXG5cdFx0cHJldjogbnVsbCxcblx0XHR0ZWFyZG93bjogbnVsbCxcblx0XHR0cmFuc2l0aW9uczogbnVsbCxcblx0XHR3djogMFxuXHR9O1xuXG5cdGlmIChERVYpIHtcblx0XHRlZmZlY3QuY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHR9XG5cblx0aWYgKHN5bmMpIHtcblx0XHR2YXIgcHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QgPSBpc19mbHVzaGluZ19lZmZlY3Q7XG5cblx0XHR0cnkge1xuXHRcdFx0c2V0X2lzX2ZsdXNoaW5nX2VmZmVjdCh0cnVlKTtcblx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdGVmZmVjdC5mIHw9IEVGRkVDVF9SQU47XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdHRocm93IGU7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9pc19mbHVzaGluZ19lZmZlY3QocHJldmlvdXNseV9mbHVzaGluZ19lZmZlY3QpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChmbiAhPT0gbnVsbCkge1xuXHRcdHNjaGVkdWxlX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0Ly8gaWYgYW4gZWZmZWN0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG5vIERPTSBhbmQgbm8gdGVhcmRvd24gZnVuY3Rpb24sXG5cdC8vIGRvbid0IGJvdGhlciBhZGRpbmcgaXQgdG8gdGhlIGVmZmVjdCB0cmVlXG5cdHZhciBpbmVydCA9XG5cdFx0c3luYyAmJlxuXHRcdGVmZmVjdC5kZXBzID09PSBudWxsICYmXG5cdFx0ZWZmZWN0LmZpcnN0ID09PSBudWxsICYmXG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID09PSBudWxsICYmXG5cdFx0ZWZmZWN0LnRlYXJkb3duID09PSBudWxsICYmXG5cdFx0KGVmZmVjdC5mICYgKEVGRkVDVF9IQVNfREVSSVZFRCB8IEJPVU5EQVJZX0VGRkVDVCkpID09PSAwO1xuXG5cdGlmICghaW5lcnQgJiYgIWlzX3Jvb3QgJiYgcHVzaCkge1xuXHRcdGlmIChwYXJlbnRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRwdXNoX2VmZmVjdChlZmZlY3QsIHBhcmVudF9lZmZlY3QpO1xuXHRcdH1cblxuXHRcdC8vIGlmIHdlJ3JlIGluIGEgZGVyaXZlZCwgYWRkIHRoZSBlZmZlY3QgdGhlcmUgdG9vXG5cdFx0aWYgKGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChhY3RpdmVfcmVhY3Rpb24pO1xuXHRcdFx0KGRlcml2ZWQuZWZmZWN0cyA/Pz0gW10pLnB1c2goZWZmZWN0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnRyYWNraW5nKClgXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF90cmFja2luZygpIHtcblx0cmV0dXJuIGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJiAhdW50cmFja2luZztcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZWFyZG93bihmbikge1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJFTkRFUl9FRkZFQ1QsIG51bGwsIGZhbHNlKTtcblx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBDTEVBTik7XG5cdGVmZmVjdC50ZWFyZG93biA9IGZuO1xuXHRyZXR1cm4gZWZmZWN0O1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0KC4uLilgXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX2VmZmVjdChmbikge1xuXHR2YWxpZGF0ZV9lZmZlY3QoJyRlZmZlY3QnKTtcblxuXHQvLyBOb24tbmVzdGVkIGAkZWZmZWN0KC4uLilgIGluIGEgY29tcG9uZW50IHNob3VsZCBiZSBkZWZlcnJlZFxuXHQvLyB1bnRpbCB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWRcblx0dmFyIGRlZmVyID1cblx0XHRhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmXG5cdFx0KGFjdGl2ZV9lZmZlY3QuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwICYmXG5cdFx0Y29tcG9uZW50X2NvbnRleHQgIT09IG51bGwgJiZcblx0XHQhY29tcG9uZW50X2NvbnRleHQubTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnJGVmZmVjdCdcblx0XHR9KTtcblx0fVxuXG5cdGlmIChkZWZlcikge1xuXHRcdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdChjb250ZXh0LmUgPz89IFtdKS5wdXNoKHtcblx0XHRcdGZuLFxuXHRcdFx0ZWZmZWN0OiBhY3RpdmVfZWZmZWN0LFxuXHRcdFx0cmVhY3Rpb246IGFjdGl2ZV9yZWFjdGlvblxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzaWduYWwgPSBlZmZlY3QoZm4pO1xuXHRcdHJldHVybiBzaWduYWw7XG5cdH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC5wcmUoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VyX3ByZV9lZmZlY3QoZm4pIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckZWZmZWN0LnByZScpO1xuXHRpZiAoREVWKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGZuLCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAnJGVmZmVjdC5wcmUnXG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHJlbmRlcl9lZmZlY3QoZm4pO1xufVxuXG4vKiogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3RfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KElOU1BFQ1RfRUZGRUNULCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYCRlZmZlY3Qucm9vdCguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3Rfcm9vdChmbikge1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJPT1RfRUZGRUNULCBmbiwgdHJ1ZSk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHR9O1xufVxuXG4vKipcbiAqIEFuIGVmZmVjdCByb290IHdob3NlIGNoaWxkcmVuIGNhbiB0cmFuc2l0aW9uIG91dFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhvcHRpb25zPzogeyBvdXRybz86IGJvb2xlYW4gfSkgPT4gUHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9yb290KGZuKSB7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUk9PVF9FRkZFQ1QsIGZuLCB0cnVlKTtcblxuXHRyZXR1cm4gKG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsKSA9PiB7XG5cdFx0XHRpZiAob3B0aW9ucy5vdXRybykge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0XHRmdWxmaWwodW5kZWZpbmVkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRmdWxmaWwodW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEVGRkVDVCwgZm4sIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJDogLi5gXG4gKiBAcGFyYW0geygpID0+IGFueX0gZGVwc1xuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3ByZV9lZmZlY3QoZGVwcywgZm4pIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0LyoqIEB0eXBlIHt7IGVmZmVjdDogbnVsbCB8IEVmZmVjdCwgcmFuOiBib29sZWFuIH19ICovXG5cdHZhciB0b2tlbiA9IHsgZWZmZWN0OiBudWxsLCByYW46IGZhbHNlIH07XG5cdGNvbnRleHQubC5yMS5wdXNoKHRva2VuKTtcblxuXHR0b2tlbi5lZmZlY3QgPSByZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRkZXBzKCk7XG5cblx0XHQvLyBJZiB0aGlzIGxlZ2FjeSBwcmUgZWZmZWN0IGhhcyBhbHJlYWR5IHJ1biBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgcmVzZXQsIHRoZW5cblx0XHQvLyBiYWlsIG91dCB0byBlbXVsYXRlIHRoZSBzYW1lIGJlaGF2aW9yLlxuXHRcdGlmICh0b2tlbi5yYW4pIHJldHVybjtcblxuXHRcdHRva2VuLnJhbiA9IHRydWU7XG5cdFx0c2V0KGNvbnRleHQubC5yMiwgdHJ1ZSk7XG5cdFx0dW50cmFjayhmbik7XG5cdH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X3ByZV9lZmZlY3RfcmVzZXQoKSB7XG5cdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmICghZ2V0KGNvbnRleHQubC5yMikpIHJldHVybjtcblxuXHRcdC8vIFJ1biBkaXJ0eSBgJDpgIHN0YXRlbWVudHNcblx0XHRmb3IgKHZhciB0b2tlbiBvZiBjb250ZXh0LmwucjEpIHtcblx0XHRcdHZhciBlZmZlY3QgPSB0b2tlbi5lZmZlY3Q7XG5cblx0XHRcdC8vIElmIHRoZSBlZmZlY3QgaXMgQ0xFQU4sIHRoZW4gbWFrZSBpdCBNQVlCRV9ESVJUWS4gVGhpcyBlbnN1cmVzIHdlIHRyYXZlcnNlIHRocm91Z2hcblx0XHRcdC8vIHRoZSBlZmZlY3RzIGRlcGVuZGVuY2llcyBhbmQgY29ycmVjdGx5IGVuc3VyZSBlYWNoIGRlcGVuZGVuY3kgaXMgdXAtdG8tZGF0ZS5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoZWZmZWN0KSkge1xuXHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRva2VuLnJhbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnRleHQubC5yMi52ID0gZmFsc2U7IC8vIHNldCBkaXJlY3RseSB0byBhdm9pZCByZXJ1bm5pbmcgdGhpcyBlZmZlY3Rcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcl9lZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KC4uLmV4cHJlc3Npb25zOiBhbnkpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IGFueT59IHRodW5rc1xuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlX2VmZmVjdChmbiwgdGh1bmtzID0gW10sIGQgPSBkZXJpdmVkKSB7XG5cdGNvbnN0IGRlcml2ZWRzID0gdGh1bmtzLm1hcChkKTtcblx0Y29uc3QgZWZmZWN0ID0gKCkgPT4gZm4oLi4uZGVyaXZlZHMubWFwKGdldCkpO1xuXG5cdGlmIChERVYpIHtcblx0XHRkZWZpbmVfcHJvcGVydHkoZWZmZWN0LCAnbmFtZScsIHtcblx0XHRcdHZhbHVlOiAne2V4cHJlc3Npb259J1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIGJsb2NrKGVmZmVjdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrKGZuLCBmbGFncyA9IDApIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IEJMT0NLX0VGRkVDVCB8IGZsYWdzLCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwdXNoXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoKGZuLCBwdXNoID0gdHJ1ZSkge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNUIHwgQlJBTkNIX0VGRkVDVCwgZm4sIHRydWUsIHB1c2gpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCkge1xuXHR2YXIgdGVhcmRvd24gPSBlZmZlY3QudGVhcmRvd247XG5cdGlmICh0ZWFyZG93biAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QgPSBpc19kZXN0cm95aW5nX2VmZmVjdDtcblx0XHRjb25zdCBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHR0cnkge1xuXHRcdFx0dGVhcmRvd24uY2FsbChudWxsKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QpO1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHBhcmFtIHtib29sZWFufSByZW1vdmVfZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKHNpZ25hbCwgcmVtb3ZlX2RvbSA9IGZhbHNlKSB7XG5cdHZhciBlZmZlY3QgPSBzaWduYWwuZmlyc3Q7XG5cdHNpZ25hbC5maXJzdCA9IHNpZ25hbC5sYXN0ID0gbnVsbDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QsIHJlbW92ZV9kb20pO1xuXHRcdGVmZmVjdCA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuKHNpZ25hbCkge1xuXHR2YXIgZWZmZWN0ID0gc2lnbmFsLmZpcnN0O1xuXG5cdHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcblx0XHR2YXIgbmV4dCA9IGVmZmVjdC5uZXh0O1xuXHRcdGlmICgoZWZmZWN0LmYgJiBCUkFOQ0hfRUZGRUNUKSA9PT0gMCkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHR9XG5cdFx0ZWZmZWN0ID0gbmV4dDtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZV9kb21dXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCwgcmVtb3ZlX2RvbSA9IHRydWUpIHtcblx0dmFyIHJlbW92ZWQgPSBmYWxzZTtcblxuXHRpZiAoKHJlbW92ZV9kb20gfHwgKGVmZmVjdC5mICYgSEVBRF9FRkZFQ1QpICE9PSAwKSAmJiBlZmZlY3Qubm9kZXNfc3RhcnQgIT09IG51bGwpIHtcblx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZSB8IG51bGx9ICovXG5cdFx0dmFyIG5vZGUgPSBlZmZlY3Qubm9kZXNfc3RhcnQ7XG5cdFx0dmFyIGVuZCA9IGVmZmVjdC5ub2Rlc19lbmQ7XG5cblx0XHR3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSAqL1xuXHRcdFx0dmFyIG5leHQgPSBub2RlID09PSBlbmQgPyBudWxsIDogLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblxuXHRcdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRcdG5vZGUgPSBuZXh0O1xuXHRcdH1cblxuXHRcdHJlbW92ZWQgPSB0cnVlO1xuXHR9XG5cblx0ZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4oZWZmZWN0LCByZW1vdmVfZG9tICYmICFyZW1vdmVkKTtcblx0cmVtb3ZlX3JlYWN0aW9ucyhlZmZlY3QsIDApO1xuXHRzZXRfc2lnbmFsX3N0YXR1cyhlZmZlY3QsIERFU1RST1lFRCk7XG5cblx0dmFyIHRyYW5zaXRpb25zID0gZWZmZWN0LnRyYW5zaXRpb25zO1xuXG5cdGlmICh0cmFuc2l0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiB0cmFuc2l0aW9ucykge1xuXHRcdFx0dHJhbnNpdGlvbi5zdG9wKCk7XG5cdFx0fVxuXHR9XG5cblx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KTtcblxuXHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblxuXHQvLyBJZiB0aGUgcGFyZW50IGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4sIHRoZW4gc2tpcCB0aGlzIHdvcmsgYWx0b2dldGhlclxuXHRpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5maXJzdCAhPT0gbnVsbCkge1xuXHRcdHVubGlua19lZmZlY3QoZWZmZWN0KTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHRlZmZlY3QuY29tcG9uZW50X2Z1bmN0aW9uID0gbnVsbDtcblx0fVxuXG5cdC8vIGBmaXJzdGAgYW5kIGBjaGlsZGAgYXJlIG51bGxlZCBvdXQgaW4gZGVzdHJveV9lZmZlY3RfY2hpbGRyZW5cblx0Ly8gd2UgZG9uJ3QgbnVsbCBvdXQgYHBhcmVudGAgc28gdGhhdCBlcnJvciBwcm9wYWdhdGlvbiBjYW4gd29yayBjb3JyZWN0bHlcblx0ZWZmZWN0Lm5leHQgPVxuXHRcdGVmZmVjdC5wcmV2ID1cblx0XHRlZmZlY3QudGVhcmRvd24gPVxuXHRcdGVmZmVjdC5jdHggPVxuXHRcdGVmZmVjdC5kZXBzID1cblx0XHRlZmZlY3QuZm4gPVxuXHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9XG5cdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9XG5cdFx0XHRudWxsO1xufVxuXG4vKipcbiAqIERldGFjaCBhbiBlZmZlY3QgZnJvbSB0aGUgZWZmZWN0IHRyZWUsIGZyZWVpbmcgdXAgbWVtb3J5IGFuZFxuICogcmVkdWNpbmcgdGhlIGFtb3VudCBvZiB3b3JrIHRoYXQgaGFwcGVucyBvbiBzdWJzZXF1ZW50IHRyYXZlcnNhbHNcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlua19lZmZlY3QoZWZmZWN0KSB7XG5cdHZhciBwYXJlbnQgPSBlZmZlY3QucGFyZW50O1xuXHR2YXIgcHJldiA9IGVmZmVjdC5wcmV2O1xuXHR2YXIgbmV4dCA9IGVmZmVjdC5uZXh0O1xuXG5cdGlmIChwcmV2ICE9PSBudWxsKSBwcmV2Lm5leHQgPSBuZXh0O1xuXHRpZiAobmV4dCAhPT0gbnVsbCkgbmV4dC5wcmV2ID0gcHJldjtcblxuXHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0aWYgKHBhcmVudC5maXJzdCA9PT0gZWZmZWN0KSBwYXJlbnQuZmlyc3QgPSBuZXh0O1xuXHRcdGlmIChwYXJlbnQubGFzdCA9PT0gZWZmZWN0KSBwYXJlbnQubGFzdCA9IHByZXY7XG5cdH1cbn1cblxuLyoqXG4gKiBXaGVuIGEgYmxvY2sgZWZmZWN0IGlzIHJlbW92ZWQsIHdlIGRvbid0IGltbWVkaWF0ZWx5IGRlc3Ryb3kgaXQgb3IgeWFuayBpdFxuICogb3V0IG9mIHRoZSBET00sIGJlY2F1c2UgaXQgbWlnaHQgaGF2ZSB0cmFuc2l0aW9ucy4gSW5zdGVhZCwgd2UgJ3BhdXNlJyBpdC5cbiAqIEl0IHN0YXlzIGFyb3VuZCAoaW4gbWVtb3J5LCBhbmQgaW4gdGhlIERPTSkgdW50aWwgb3V0cm8gdHJhbnNpdGlvbnMgaGF2ZVxuICogY29tcGxldGVkLCBhbmQgaWYgdGhlIHN0YXRlIGNoYW5nZSBpcyByZXZlcnNlZCB0aGVuIHdlIF9yZXN1bWVfIGl0LlxuICogQSBwYXVzZWQgZWZmZWN0IGRvZXMgbm90IHVwZGF0ZSwgYW5kIHRoZSBET00gc3VidHJlZSBiZWNvbWVzIGluZXJ0LlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9lZmZlY3QoZWZmZWN0LCBjYWxsYmFjaykge1xuXHQvKiogQHR5cGUge1RyYW5zaXRpb25NYW5hZ2VyW119ICovXG5cdHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuXG5cdHBhdXNlX2NoaWxkcmVuKGVmZmVjdCwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2l0aW9uTWFuYWdlcltdfSB0cmFuc2l0aW9uc1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX291dF90cmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgZm4pIHtcblx0dmFyIHJlbWFpbmluZyA9IHRyYW5zaXRpb25zLmxlbmd0aDtcblx0aWYgKHJlbWFpbmluZyA+IDApIHtcblx0XHR2YXIgY2hlY2sgPSAoKSA9PiAtLXJlbWFpbmluZyB8fCBmbigpO1xuXHRcdGZvciAodmFyIHRyYW5zaXRpb24gb2YgdHJhbnNpdGlvbnMpIHtcblx0XHRcdHRyYW5zaXRpb24ub3V0KGNoZWNrKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm4oKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gdHJhbnNpdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdXNlX2NoaWxkcmVuKGVmZmVjdCwgdHJhbnNpdGlvbnMsIGxvY2FsKSB7XG5cdGlmICgoZWZmZWN0LmYgJiBJTkVSVCkgIT09IDApIHJldHVybjtcblx0ZWZmZWN0LmYgXj0gSU5FUlQ7XG5cblx0aWYgKGVmZmVjdC50cmFuc2l0aW9ucyAhPT0gbnVsbCkge1xuXHRcdGZvciAoY29uc3QgdHJhbnNpdGlvbiBvZiBlZmZlY3QudHJhbnNpdGlvbnMpIHtcblx0XHRcdGlmICh0cmFuc2l0aW9uLmlzX2dsb2JhbCB8fCBsb2NhbCkge1xuXHRcdFx0XHR0cmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBjaGlsZCA9IGVmZmVjdC5maXJzdDtcblxuXHR3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcblx0XHR2YXIgc2libGluZyA9IGNoaWxkLm5leHQ7XG5cdFx0dmFyIHRyYW5zcGFyZW50ID0gKGNoaWxkLmYgJiBFRkZFQ1RfVFJBTlNQQVJFTlQpICE9PSAwIHx8IChjaGlsZC5mICYgQlJBTkNIX0VGRkVDVCkgIT09IDA7XG5cdFx0Ly8gVE9ETyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgcGF1c2VfY2hpbGRyZW4gcmVjdXJzaXZlbHkgd2l0aCBhIGxpbmtlZCBsaXN0IGluIHBsYWNlXG5cdFx0Ly8gaXQncyBzbGlnaHRseSBtb3JlIGludm9sdmVkIHRob3VnaCBhcyB3ZSBoYXZlIHRvIGFjY291bnQgZm9yIGB0cmFuc3BhcmVudGAgY2hhbmdpbmdcblx0XHQvLyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRcdHBhdXNlX2NoaWxkcmVuKGNoaWxkLCB0cmFuc2l0aW9ucywgdHJhbnNwYXJlbnQgPyBsb2NhbCA6IGZhbHNlKTtcblx0XHRjaGlsZCA9IHNpYmxpbmc7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYHBhdXNlX2VmZmVjdGAuIFdlIGNhbGwgdGhpcyBpZiAoZm9yIGV4YW1wbGUpXG4gKiBgeGAgYmVjb21lcyBmYWxzeSB0aGVuIHRydXRoeTogYHsjaWYgeH0uLi57L2lmfWBcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3VtZV9lZmZlY3QoZWZmZWN0KSB7XG5cdHJlc3VtZV9jaGlsZHJlbihlZmZlY3QsIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWxcbiAqL1xuZnVuY3Rpb24gcmVzdW1lX2NoaWxkcmVuKGVmZmVjdCwgbG9jYWwpIHtcblx0aWYgKChlZmZlY3QuZiAmIElORVJUKSA9PT0gMCkgcmV0dXJuO1xuXHRlZmZlY3QuZiBePSBJTkVSVDtcblxuXHQvLyBFbnN1cmUgdGhlIGVmZmVjdCBpcyBtYXJrZWQgYXMgY2xlYW4gYWdhaW4gc28gdGhhdCBhbnkgZGlydHkgY2hpbGRcblx0Ly8gZWZmZWN0cyBjYW4gc2NoZWR1bGUgdGhlbXNlbHZlcyBmb3IgZXhlY3V0aW9uXG5cdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgPT09IDApIHtcblx0XHRlZmZlY3QuZiBePSBDTEVBTjtcblx0fVxuXG5cdC8vIElmIGEgZGVwZW5kZW5jeSBvZiB0aGlzIGVmZmVjdCBjaGFuZ2VkIHdoaWxlIGl0IHdhcyBwYXVzZWQsXG5cdC8vIHNjaGVkdWxlIHRoZSBlZmZlY3QgdG8gdXBkYXRlXG5cdGlmIChjaGVja19kaXJ0aW5lc3MoZWZmZWN0KSkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgRElSVFkpO1xuXHRcdHNjaGVkdWxlX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0dmFyIGNoaWxkID0gZWZmZWN0LmZpcnN0O1xuXG5cdHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdHZhciBzaWJsaW5nID0gY2hpbGQubmV4dDtcblx0XHR2YXIgdHJhbnNwYXJlbnQgPSAoY2hpbGQuZiAmIEVGRkVDVF9UUkFOU1BBUkVOVCkgIT09IDAgfHwgKGNoaWxkLmYgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMDtcblx0XHQvLyBUT0RPIHdlIGRvbid0IG5lZWQgdG8gY2FsbCByZXN1bWVfY2hpbGRyZW4gcmVjdXJzaXZlbHkgd2l0aCBhIGxpbmtlZCBsaXN0IGluIHBsYWNlXG5cdFx0Ly8gaXQncyBzbGlnaHRseSBtb3JlIGludm9sdmVkIHRob3VnaCBhcyB3ZSBoYXZlIHRvIGFjY291bnQgZm9yIGB0cmFuc3BhcmVudGAgY2hhbmdpbmdcblx0XHQvLyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRcdHJlc3VtZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNwYXJlbnQgPyBsb2NhbCA6IGZhbHNlKTtcblx0XHRjaGlsZCA9IHNpYmxpbmc7XG5cdH1cblxuXHRpZiAoZWZmZWN0LnRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIGVmZmVjdC50cmFuc2l0aW9ucykge1xuXHRcdFx0aWYgKHRyYW5zaXRpb24uaXNfZ2xvYmFsIHx8IGxvY2FsKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24uaW4oKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCB7IHJ1bl9hbGwgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vLyBGYWxsYmFjayBmb3Igd2hlbiByZXF1ZXN0SWRsZUNhbGxiYWNrIGlzIG5vdCBhdmFpbGFibGVcbmV4cG9ydCBjb25zdCByZXF1ZXN0X2lkbGVfY2FsbGJhY2sgPVxuXHR0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCdcblx0XHQ/ICgvKiogQHR5cGUgeygpID0+IHZvaWR9ICovIGNiKSA9PiBzZXRUaW1lb3V0KGNiLCAxKVxuXHRcdDogcmVxdWVzdElkbGVDYWxsYmFjaztcblxubGV0IGlzX21pY3JvX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5sZXQgaXNfaWRsZV90YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXG4vKiogQHR5cGUge0FycmF5PCgpID0+IHZvaWQ+fSAqL1xubGV0IGN1cnJlbnRfcXVldWVkX21pY3JvX3Rhc2tzID0gW107XG4vKiogQHR5cGUge0FycmF5PCgpID0+IHZvaWQ+fSAqL1xubGV0IGN1cnJlbnRfcXVldWVkX2lkbGVfdGFza3MgPSBbXTtcblxuZnVuY3Rpb24gcHJvY2Vzc19taWNyb190YXNrcygpIHtcblx0aXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcblx0Y29uc3QgdGFza3MgPSBjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcy5zbGljZSgpO1xuXHRjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcyA9IFtdO1xuXHRydW5fYWxsKHRhc2tzKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pZGxlX3Rhc2tzKCkge1xuXHRpc19pZGxlX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cdGNvbnN0IHRhc2tzID0gY3VycmVudF9xdWV1ZWRfaWRsZV90YXNrcy5zbGljZSgpO1xuXHRjdXJyZW50X3F1ZXVlZF9pZGxlX3Rhc2tzID0gW107XG5cdHJ1bl9hbGwodGFza3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXVlX21pY3JvX3Rhc2soZm4pIHtcblx0aWYgKCFpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gdHJ1ZTtcblx0XHRxdWV1ZU1pY3JvdGFzayhwcm9jZXNzX21pY3JvX3Rhc2tzKTtcblx0fVxuXHRjdXJyZW50X3F1ZXVlZF9taWNyb190YXNrcy5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWV1ZV9pZGxlX3Rhc2soZm4pIHtcblx0aWYgKCFpc19pZGxlX3Rhc2tfcXVldWVkKSB7XG5cdFx0aXNfaWRsZV90YXNrX3F1ZXVlZCA9IHRydWU7XG5cdFx0cmVxdWVzdF9pZGxlX2NhbGxiYWNrKHByb2Nlc3NfaWRsZV90YXNrcyk7XG5cdH1cblx0Y3VycmVudF9xdWV1ZWRfaWRsZV90YXNrcy5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHJ1biBhbnkgcXVldWVkIHRhc2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hfdGFza3MoKSB7XG5cdGlmIChpc19taWNyb190YXNrX3F1ZXVlZCkge1xuXHRcdHByb2Nlc3NfbWljcm9fdGFza3MoKTtcblx0fVxuXHRpZiAoaXNfaWRsZV90YXNrX3F1ZXVlZCkge1xuXHRcdHByb2Nlc3NfaWRsZV90YXNrcygpO1xuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNpZ25hbCwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlZmluZV9wcm9wZXJ0eSwgZ2V0X2Rlc2NyaXB0b3JzLCBnZXRfcHJvdG90eXBlX29mLCBpbmRleF9vZiB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbixcblx0ZGVzdHJveV9lZmZlY3RfY2hpbGRyZW4sXG5cdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duLFxuXHR1bmxpbmtfZWZmZWN0XG59IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdEVGRkVDVCxcblx0UkVOREVSX0VGRkVDVCxcblx0RElSVFksXG5cdE1BWUJFX0RJUlRZLFxuXHRDTEVBTixcblx0REVSSVZFRCxcblx0VU5PV05FRCxcblx0REVTVFJPWUVELFxuXHRJTkVSVCxcblx0QlJBTkNIX0VGRkVDVCxcblx0U1RBVEVfU1lNQk9MLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRMRUdBQ1lfREVSSVZFRF9QUk9QLFxuXHRESVNDT05ORUNURUQsXG5cdEJPVU5EQVJZX0VGRkVDVFxufSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBmbHVzaF90YXNrcyB9IGZyb20gJy4vZG9tL3Rhc2suanMnO1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZGVzdHJveV9kZXJpdmVkX2VmZmVjdHMsIHVwZGF0ZV9kZXJpdmVkIH0gZnJvbSAnLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX2V4cHJlc3Npb25zLCBnZXRfc3RhY2sgfSBmcm9tICcuL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7XG5cdGNvbXBvbmVudF9jb250ZXh0LFxuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24sXG5cdGlzX3J1bmVzLFxuXHRzZXRfY29tcG9uZW50X2NvbnRleHQsXG5cdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb25cbn0gZnJvbSAnLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGlzX2ZpcmVmb3ggfSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcblxuY29uc3QgRkxVU0hfTUlDUk9UQVNLID0gMDtcbmNvbnN0IEZMVVNIX1NZTkMgPSAxO1xuLy8gVXNlZCBmb3IgREVWIHRpbWUgZXJyb3IgaGFuZGxpbmdcbi8qKiBAcGFyYW0ge1dlYWtTZXQ8RXJyb3I+fSB2YWx1ZSAqL1xuY29uc3QgaGFuZGxlZF9lcnJvcnMgPSBuZXcgV2Vha1NldCgpO1xuZXhwb3J0IGxldCBpc190aHJvd2luZ19lcnJvciA9IGZhbHNlO1xuXG4vLyBVc2VkIGZvciBjb250cm9sbGluZyB0aGUgZmx1c2ggb2YgZWZmZWN0cy5cbmxldCBzY2hlZHVsZXJfbW9kZSA9IEZMVVNIX01JQ1JPVEFTSztcbi8vIFVzZWQgZm9yIGhhbmRsaW5nIHNjaGVkdWxpbmdcbmxldCBpc19taWNyb190YXNrX3F1ZXVlZCA9IGZhbHNlO1xuXG4vKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5sZXQgbGFzdF9zY2hlZHVsZWRfZWZmZWN0ID0gbnVsbDtcblxuZXhwb3J0IGxldCBpc19mbHVzaGluZ19lZmZlY3QgPSBmYWxzZTtcbmV4cG9ydCBsZXQgaXNfZGVzdHJveWluZ19lZmZlY3QgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaXNfZmx1c2hpbmdfZWZmZWN0KHZhbHVlKSB7XG5cdGlzX2ZsdXNoaW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc19kZXN0cm95aW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG4vLyBIYW5kbGUgZWZmZWN0IHF1ZXVlc1xuXG4vKiogQHR5cGUge0VmZmVjdFtdfSAqL1xubGV0IHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxubGV0IGZsdXNoX2NvdW50ID0gMDtcbi8qKiBAdHlwZSB7RWZmZWN0W119IFN0YWNrIG9mIGVmZmVjdHMsIGRldiBvbmx5ICovXG5sZXQgZGV2X2VmZmVjdF9zdGFjayA9IFtdO1xuLy8gSGFuZGxlIHNpZ25hbCByZWFjdGl2aXR5IHRyZWUgZGVwZW5kZW5jaWVzIGFuZCByZWFjdGlvbnNcblxuLyoqIEB0eXBlIHtudWxsIHwgUmVhY3Rpb259ICovXG5leHBvcnQgbGV0IGFjdGl2ZV9yZWFjdGlvbiA9IG51bGw7XG5cbmV4cG9ydCBsZXQgdW50cmFja2luZyA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgUmVhY3Rpb259IHJlYWN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2FjdGl2ZV9yZWFjdGlvbihyZWFjdGlvbikge1xuXHRhY3RpdmVfcmVhY3Rpb24gPSByZWFjdGlvbjtcbn1cblxuLyoqIEB0eXBlIHtudWxsIHwgRWZmZWN0fSAqL1xuZXhwb3J0IGxldCBhY3RpdmVfZWZmZWN0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IEVmZmVjdH0gZWZmZWN0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2FjdGl2ZV9lZmZlY3QoZWZmZWN0KSB7XG5cdGFjdGl2ZV9lZmZlY3QgPSBlZmZlY3Q7XG59XG5cbi8qKlxuICogV2hlbiBzb3VyY2VzIGFyZSBjcmVhdGVkIHdpdGhpbiBhIGRlcml2ZWQsIHdlIHJlY29yZCB0aGVtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBhbGxvd1xuICogbG9jYWwgbXV0YXRpb25zIHRvIHRoZXNlIHNvdXJjZXMgd2l0aG91dCB0aGUgc2lkZS1lZmZlY3QgZXJyb3IgYmVpbmcgaW52b2tlZCB1bm5lY2Vzc2FyaWx5LlxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCBkZXJpdmVkX3NvdXJjZXMgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7U291cmNlW10gfCBudWxsfSBzb3VyY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVyaXZlZF9zb3VyY2VzKHNvdXJjZXMpIHtcblx0ZGVyaXZlZF9zb3VyY2VzID0gc291cmNlcztcbn1cblxuLyoqXG4gKiBUaGUgZGVwZW5kZW5jaWVzIG9mIHRoZSByZWFjdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBleGVjdXRlZC4gSW4gbWFueSBjYXNlcyxcbiAqIHRoZSBkZXBlbmRlbmNpZXMgYXJlIHVuY2hhbmdlZCBiZXR3ZWVuIHJ1bnMsIGFuZCBzbyB0aGlzIHdpbGwgYmUgYG51bGxgIHVubGVzc1xuICogYW5kIHVudGlsIGEgbmV3IGRlcGVuZGVuY3kgaXMgYWNjZXNzZWQg4oCUIHdlIHRyYWNrIHRoaXMgdmlhIGBza2lwcGVkX2RlcHNgXG4gKiBAdHlwZSB7bnVsbCB8IFZhbHVlW119XG4gKi9cbmV4cG9ydCBsZXQgbmV3X2RlcHMgPSBudWxsO1xuXG5sZXQgc2tpcHBlZF9kZXBzID0gMDtcblxuLyoqXG4gKiBUcmFja3Mgd3JpdGVzIHRoYXQgdGhlIGVmZmVjdCBpdCdzIGV4ZWN1dGVkIGluIGRvZXNuJ3QgbGlzdGVuIHRvIHlldCxcbiAqIHNvIHRoYXQgdGhlIGRlcGVuZGVuY3kgY2FuIGJlIGFkZGVkIHRvIHRoZSBlZmZlY3QgbGF0ZXIgb24gaWYgaXQgdGhlbiByZWFkcyBpdFxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCB1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7bnVsbCB8IFNvdXJjZVtdfSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF91bnRyYWNrZWRfd3JpdGVzKHZhbHVlKSB7XG5cdHVudHJhY2tlZF93cml0ZXMgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfSBVc2VkIGJ5IHNvdXJjZXMgYW5kIGRlcml2ZWRzIGZvciBoYW5kbGluZyB1cGRhdGVzLlxuICogVmVyc2lvbiBzdGFydHMgZnJvbSAxIHNvIHRoYXQgdW5vd25lZCBkZXJpdmVkcyBkaWZmZXJlbnRpYXRlIGJldHdlZW4gYSBjcmVhdGVkIGVmZmVjdCBhbmQgYSBydW4gb25lIGZvciB0cmFjaW5nXG4gKiovXG5sZXQgd3JpdGVfdmVyc2lvbiA9IDE7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSBVc2VkIHRvIHZlcnNpb24gZWFjaCByZWFkIG9mIGEgc291cmNlIG9mIGRlcml2ZWQgdG8gYXZvaWQgZHVwbGljYXRpbmcgZGVwZWRlbmNpZXMgaW5zaWRlIGEgcmVhY3Rpb24gKi9cbmxldCByZWFkX3ZlcnNpb24gPSAwO1xuXG4vLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZ2V0KCkgY2hhaW4gdGhhdCBoYXMgbm8gYWN0aXZlIGNvbnRhaW5lcixcbi8vIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLCB3ZSBza2lwIGFkZGluZyB0aGUgcmVhY3Rpb24uXG5leHBvcnQgbGV0IHNraXBfcmVhY3Rpb24gPSBmYWxzZTtcbi8vIEhhbmRsZSBjb2xsZWN0aW5nIGFsbCBzaWduYWxzIHdoaWNoIGFyZSByZWFkIGR1cmluZyBhIHNwZWNpZmljIHRpbWUgZnJhbWVcbi8qKiBAdHlwZSB7U2V0PFZhbHVlPiB8IG51bGx9ICovXG5leHBvcnQgbGV0IGNhcHR1cmVkX3NpZ25hbHMgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtTZXQ8VmFsdWU+IHwgbnVsbH0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2FwdHVyZWRfc2lnbmFscyh2YWx1ZSkge1xuXHRjYXB0dXJlZF9zaWduYWxzID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpIHtcblx0cmV0dXJuICsrd3JpdGVfdmVyc2lvbjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBkZXJpdmVkIG9yIGVmZmVjdCBpcyBkaXJ0eS5cbiAqIElmIGl0IGlzIE1BWUJFX0RJUlRZLCB3aWxsIHNldCB0aGUgc3RhdHVzIHRvIENMRUFOXG4gKiBAcGFyYW0ge1JlYWN0aW9ufSByZWFjdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja19kaXJ0aW5lc3MocmVhY3Rpb24pIHtcblx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRpZiAoKGZsYWdzICYgRElSVFkpICE9PSAwKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoKGZsYWdzICYgTUFZQkVfRElSVFkpICE9PSAwKSB7XG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IHJlYWN0aW9uLmRlcHM7XG5cdFx0dmFyIGlzX3Vub3duZWQgPSAoZmxhZ3MgJiBVTk9XTkVEKSAhPT0gMDtcblxuXHRcdGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0dmFyIGRlcGVuZGVuY3k7XG5cdFx0XHR2YXIgaXNfZGlzY29ubmVjdGVkID0gKGZsYWdzICYgRElTQ09OTkVDVEVEKSAhPT0gMDtcblx0XHRcdHZhciBpc191bm93bmVkX2Nvbm5lY3RlZCA9IGlzX3Vub3duZWQgJiYgYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAhc2tpcF9yZWFjdGlvbjtcblx0XHRcdHZhciBsZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZGlzY29ubmVjdGVkIG9yIGFuIHVub3duZWQgc2lnbmFsIHRoYXQgaXMgbm93IGNvbm5lY3RlZCAoZHVlIHRvIGFuIGFjdGl2ZSBlZmZlY3QpXG5cdFx0XHQvLyB0aGVuIHdlIG5lZWQgdG8gcmUtY29ubmVjdCB0aGUgcmVhY3Rpb24gdG8gdGhlIGRlcGVuZGVuY3lcblx0XHRcdGlmIChpc19kaXNjb25uZWN0ZWQgfHwgaXNfdW5vd25lZF9jb25uZWN0ZWQpIHtcblx0XHRcdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChyZWFjdGlvbik7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuXG5cdFx0XHRcdFx0Ly8gV2UgYWx3YXlzIHJlLWFkZCBhbGwgcmVhY3Rpb25zIChldmVuIGR1cGxpY2F0ZXMpIGlmIHRoZSBkZXJpdmVkIHdhc1xuXHRcdFx0XHRcdC8vIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkLCBob3dldmVyIHdlIGRvbid0IGlmIGl0IHdhcyB1bm93bmVkIGFzIHdlXG5cdFx0XHRcdFx0Ly8gZGUtZHVwbGljYXRlIGRlcGVuZGVuY2llcyBpbiB0aGF0IGNhc2Vcblx0XHRcdFx0XHRpZiAoaXNfZGlzY29ubmVjdGVkIHx8ICFkZXBlbmRlbmN5Py5yZWFjdGlvbnM/LmluY2x1ZGVzKGRlcml2ZWQpKSB7XG5cdFx0XHRcdFx0XHQoZGVwZW5kZW5jeS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKGRlcml2ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc19kaXNjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRkZXJpdmVkLmYgXj0gRElTQ09OTkVDVEVEO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB1bm93bmVkIGRlcml2ZWQgaXMgbm93IGZ1bGx5IGNvbm5lY3RlZCB0byB0aGUgZ3JhcGggYWdhaW4gKGl0J3MgdW5vd25lZCBhbmQgcmVjb25uZWN0ZWQsIGhhcyBhIHBhcmVudFxuXHRcdFx0XHQvLyBhbmQgdGhlIHBhcmVudCBpcyBub3QgdW5vd25lZCksIHRoZW4gd2UgY2FuIG1hcmsgaXQgYXMgY29ubmVjdGVkIGFnYWluLCByZW1vdmluZyB0aGUgbmVlZCBmb3IgdGhlIHVub3duZWRcblx0XHRcdFx0Ly8gZmxhZ1xuXHRcdFx0XHRpZiAoaXNfdW5vd25lZF9jb25uZWN0ZWQgJiYgcGFyZW50ICE9PSBudWxsICYmIChwYXJlbnQuZiAmIFVOT1dORUQpID09PSAwKSB7XG5cdFx0XHRcdFx0ZGVyaXZlZC5mIF49IFVOT1dORUQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG5cblx0XHRcdFx0aWYgKGNoZWNrX2RpcnRpbmVzcygvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXBlbmRlbmN5KSkpIHtcblx0XHRcdFx0XHR1cGRhdGVfZGVyaXZlZCgvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXBlbmRlbmN5KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGVwZW5kZW5jeS53diA+IHJlYWN0aW9uLnd2KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBVbm93bmVkIHNpZ25hbHMgc2hvdWxkIG5ldmVyIGJlIG1hcmtlZCBhcyBjbGVhbiB1bmxlc3MgdGhleVxuXHRcdC8vIGFyZSB1c2VkIHdpdGhpbiBhbiBhY3RpdmVfZWZmZWN0IHdpdGhvdXQgc2tpcF9yZWFjdGlvblxuXHRcdGlmICghaXNfdW5vd25lZCB8fCAoYWN0aXZlX2VmZmVjdCAhPT0gbnVsbCAmJiAhc2tpcF9yZWFjdGlvbikpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBDTEVBTik7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZnVuY3Rpb24gcHJvcGFnYXRlX2Vycm9yKGVycm9yLCBlZmZlY3QpIHtcblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgY3VycmVudCA9IGVmZmVjdDtcblxuXHR3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuXHRcdGlmICgoY3VycmVudC5mICYgQk9VTkRBUllfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRjdXJyZW50LmZuKGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdC8vIFJlbW92ZSBib3VuZGFyeSBmbGFnIGZyb20gZWZmZWN0XG5cdFx0XHRcdGN1cnJlbnQuZiBePSBCT1VOREFSWV9FRkZFQ1Q7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuXHR9XG5cblx0aXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcblx0dGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICovXG5mdW5jdGlvbiBzaG91bGRfcmV0aHJvd19lcnJvcihlZmZlY3QpIHtcblx0cmV0dXJuIChcblx0XHQoZWZmZWN0LmYgJiBERVNUUk9ZRUQpID09PSAwICYmXG5cdFx0KGVmZmVjdC5wYXJlbnQgPT09IG51bGwgfHwgKGVmZmVjdC5wYXJlbnQuZiAmIEJPVU5EQVJZX0VGRkVDVCkgPT09IDApXG5cdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldF9pc190aHJvd2luZ19lcnJvcigpIHtcblx0aXNfdGhyb3dpbmdfZXJyb3IgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdCB8IG51bGx9IHByZXZpb3VzX2VmZmVjdFxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29tcG9uZW50X2NvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZV9lcnJvcihlcnJvciwgZWZmZWN0LCBwcmV2aW91c19lZmZlY3QsIGNvbXBvbmVudF9jb250ZXh0KSB7XG5cdGlmIChpc190aHJvd2luZ19lcnJvcikge1xuXHRcdGlmIChwcmV2aW91c19lZmZlY3QgPT09IG51bGwpIHtcblx0XHRcdGlzX3Rocm93aW5nX2Vycm9yID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3VsZF9yZXRocm93X2Vycm9yKGVmZmVjdCkpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChwcmV2aW91c19lZmZlY3QgIT09IG51bGwpIHtcblx0XHRpc190aHJvd2luZ19lcnJvciA9IHRydWU7XG5cdH1cblxuXHRpZiAoXG5cdFx0IURFViB8fFxuXHRcdGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsIHx8XG5cdFx0IShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB8fFxuXHRcdGhhbmRsZWRfZXJyb3JzLmhhcyhlcnJvcilcblx0KSB7XG5cdFx0cHJvcGFnYXRlX2Vycm9yKGVycm9yLCBlZmZlY3QpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGhhbmRsZWRfZXJyb3JzLmFkZChlcnJvcik7XG5cblx0Y29uc3QgY29tcG9uZW50X3N0YWNrID0gW107XG5cblx0Y29uc3QgZWZmZWN0X25hbWUgPSBlZmZlY3QuZm4/Lm5hbWU7XG5cblx0aWYgKGVmZmVjdF9uYW1lKSB7XG5cdFx0Y29tcG9uZW50X3N0YWNrLnB1c2goZWZmZWN0X25hbWUpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cblx0bGV0IGN1cnJlbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXG5cdHdoaWxlIChjdXJyZW50X2NvbnRleHQgIT09IG51bGwpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHQvKiogQHR5cGUge3N0cmluZ30gKi9cblx0XHRcdHZhciBmaWxlbmFtZSA9IGN1cnJlbnRfY29udGV4dC5mdW5jdGlvbj8uW0ZJTEVOQU1FXTtcblxuXHRcdFx0aWYgKGZpbGVuYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSBmaWxlbmFtZS5zcGxpdCgnLycpLnBvcCgpO1xuXHRcdFx0XHRjb21wb25lbnRfc3RhY2sucHVzaChmaWxlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdXJyZW50X2NvbnRleHQgPSBjdXJyZW50X2NvbnRleHQucDtcblx0fVxuXG5cdGNvbnN0IGluZGVudCA9IGlzX2ZpcmVmb3ggPyAnICAnIDogJ1xcdCc7XG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ21lc3NhZ2UnLCB7XG5cdFx0dmFsdWU6IGVycm9yLm1lc3NhZ2UgKyBgXFxuJHtjb21wb25lbnRfc3RhY2subWFwKChuYW1lKSA9PiBgXFxuJHtpbmRlbnR9aW4gJHtuYW1lfWApLmpvaW4oJycpfVxcbmBcblx0fSk7XG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ2NvbXBvbmVudF9zdGFjaycsIHtcblx0XHR2YWx1ZTogY29tcG9uZW50X3N0YWNrXG5cdH0pO1xuXG5cdGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2s7XG5cblx0Ly8gRmlsdGVyIG91dCBpbnRlcm5hbCBmaWxlcyBmcm9tIGNhbGxzdGFja1xuXHRpZiAoc3RhY2spIHtcblx0XHRjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcblx0XHRjb25zdCBuZXdfbGluZXMgPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAobGluZS5pbmNsdWRlcygnc3ZlbHRlL3NyYy9pbnRlcm5hbCcpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0bmV3X2xpbmVzLnB1c2gobGluZSk7XG5cdFx0fVxuXHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywge1xuXHRcdFx0dmFsdWU6IG5ld19saW5lcy5qb2luKCdcXG4nKVxuXHRcdH0pO1xuXHR9XG5cblx0cHJvcGFnYXRlX2Vycm9yKGVycm9yLCBlZmZlY3QpO1xuXG5cdGlmIChzaG91bGRfcmV0aHJvd19lcnJvcihlZmZlY3QpKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jvb3RdXG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbihzaWduYWwsIGVmZmVjdCwgcm9vdCA9IHRydWUpIHtcblx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJlYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciByZWFjdGlvbiA9IHJlYWN0aW9uc1tpXTtcblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0c2NoZWR1bGVfcG9zc2libGVfZWZmZWN0X3NlbGZfaW52YWxpZGF0aW9uKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgZWZmZWN0LCBmYWxzZSk7XG5cdFx0fSBlbHNlIGlmIChlZmZlY3QgPT09IHJlYWN0aW9uKSB7XG5cdFx0XHRpZiAocm9vdCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgRElSVFkpO1xuXHRcdFx0fSBlbHNlIGlmICgocmVhY3Rpb24uZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXHRcdFx0c2NoZWR1bGVfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gcmVhY3Rpb25cbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdHZhciBwcmV2aW91c19kZXBzID0gbmV3X2RlcHM7XG5cdHZhciBwcmV2aW91c19za2lwcGVkX2RlcHMgPSBza2lwcGVkX2RlcHM7XG5cdHZhciBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID0gdW50cmFja2VkX3dyaXRlcztcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfc2tpcF9yZWFjdGlvbiA9IHNraXBfcmVhY3Rpb247XG5cdHZhciBwcmV2X2Rlcml2ZWRfc291cmNlcyA9IGRlcml2ZWRfc291cmNlcztcblx0dmFyIHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cdHZhciBwcmV2aW91c191bnRyYWNraW5nID0gdW50cmFja2luZztcblx0dmFyIGZsYWdzID0gcmVhY3Rpb24uZjtcblxuXHRuZXdfZGVwcyA9IC8qKiBAdHlwZSB7bnVsbCB8IFZhbHVlW119ICovIChudWxsKTtcblx0c2tpcHBlZF9kZXBzID0gMDtcblx0dW50cmFja2VkX3dyaXRlcyA9IG51bGw7XG5cdGFjdGl2ZV9yZWFjdGlvbiA9IChmbGFncyAmIChCUkFOQ0hfRUZGRUNUIHwgUk9PVF9FRkZFQ1QpKSA9PT0gMCA/IHJlYWN0aW9uIDogbnVsbDtcblx0c2tpcF9yZWFjdGlvbiA9XG5cdFx0KGZsYWdzICYgVU5PV05FRCkgIT09IDAgJiZcblx0XHQoIWlzX2ZsdXNoaW5nX2VmZmVjdCB8fCBwcmV2aW91c19yZWFjdGlvbiA9PT0gbnVsbCB8fCBwcmV2aW91c191bnRyYWNraW5nKTtcblxuXHRkZXJpdmVkX3NvdXJjZXMgPSBudWxsO1xuXHRzZXRfY29tcG9uZW50X2NvbnRleHQocmVhY3Rpb24uY3R4KTtcblx0dW50cmFja2luZyA9IGZhbHNlO1xuXHRyZWFkX3ZlcnNpb24rKztcblxuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSAvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAoMCwgcmVhY3Rpb24uZm4pKCk7XG5cdFx0dmFyIGRlcHMgPSByZWFjdGlvbi5kZXBzO1xuXG5cdFx0aWYgKG5ld19kZXBzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblxuXHRcdFx0aWYgKGRlcHMgIT09IG51bGwgJiYgc2tpcHBlZF9kZXBzID4gMCkge1xuXHRcdFx0XHRkZXBzLmxlbmd0aCA9IHNraXBwZWRfZGVwcyArIG5ld19kZXBzLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5ld19kZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGVwc1tza2lwcGVkX2RlcHMgKyBpXSA9IG5ld19kZXBzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWFjdGlvbi5kZXBzID0gZGVwcyA9IG5ld19kZXBzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNraXBfcmVhY3Rpb24pIHtcblx0XHRcdFx0Zm9yIChpID0gc2tpcHBlZF9kZXBzOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdChkZXBzW2ldLnJlYWN0aW9ucyA/Pz0gW10pLnB1c2gocmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA8IGRlcHMubGVuZ3RoKSB7XG5cdFx0XHRyZW1vdmVfcmVhY3Rpb25zKHJlYWN0aW9uLCBza2lwcGVkX2RlcHMpO1xuXHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHM7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGFuIGVmZmVjdCBhbmQgd2UgaGF2ZSB1bnRyYWNrZWQgd3JpdGVzLCB0aGVuIHdlIG5lZWQgdG9cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiBhbnkgb2YgdGhvc2UgdW50cmFja2VkIHdyaXRlcyByZXN1bHQgaW4gcmUtaW52YWxpZGF0aW9uXG5cdFx0Ly8gb2YgdGhlIGN1cnJlbnQgZWZmZWN0LCB0aGVuIHRoYXQgaGFwcGVucyBhY2NvcmRpbmdseVxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdHVudHJhY2tlZF93cml0ZXMgIT09IG51bGwgJiZcblx0XHRcdCF1bnRyYWNraW5nICYmXG5cdFx0XHRkZXBzICE9PSBudWxsICYmXG5cdFx0XHQocmVhY3Rpb24uZiAmIChERVJJVkVEIHwgTUFZQkVfRElSVFkgfCBESVJUWSkpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2VbXX0gKi8gKHVudHJhY2tlZF93cml0ZXMpLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbihcblx0XHRcdFx0XHR1bnRyYWNrZWRfd3JpdGVzW2ldLFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgYXJlIHJldHVybmluZyB0byBhbiBwcmV2aW91cyByZWFjdGlvbiB0aGVuXG5cdFx0Ly8gd2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIHJlYWQgdmVyc2lvbiB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIGFueSBkZXBlbmRlbmNpZXMgaW4gdGhpcyByZWFjdGlvbiBhcmVuJ3QgbWFya2VkIHdpdGhcblx0XHQvLyB0aGUgc2FtZSB2ZXJzaW9uXG5cdFx0aWYgKHByZXZpb3VzX3JlYWN0aW9uICE9PSBudWxsKSB7XG5cdFx0XHRyZWFkX3ZlcnNpb24rKztcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9IGZpbmFsbHkge1xuXHRcdG5ld19kZXBzID0gcHJldmlvdXNfZGVwcztcblx0XHRza2lwcGVkX2RlcHMgPSBwcmV2aW91c19za2lwcGVkX2RlcHM7XG5cdFx0dW50cmFja2VkX3dyaXRlcyA9IHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXM7XG5cdFx0YWN0aXZlX3JlYWN0aW9uID0gcHJldmlvdXNfcmVhY3Rpb247XG5cdFx0c2tpcF9yZWFjdGlvbiA9IHByZXZpb3VzX3NraXBfcmVhY3Rpb247XG5cdFx0ZGVyaXZlZF9zb3VyY2VzID0gcHJldl9kZXJpdmVkX3NvdXJjZXM7XG5cdFx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0KTtcblx0XHR1bnRyYWNraW5nID0gcHJldmlvdXNfdW50cmFja2luZztcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1JlYWN0aW9ufSBzaWduYWxcbiAqIEBwYXJhbSB7VmFsdWU8Vj59IGRlcGVuZGVuY3lcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiByZW1vdmVfcmVhY3Rpb24oc2lnbmFsLCBkZXBlbmRlbmN5KSB7XG5cdGxldCByZWFjdGlvbnMgPSBkZXBlbmRlbmN5LnJlYWN0aW9ucztcblx0aWYgKHJlYWN0aW9ucyAhPT0gbnVsbCkge1xuXHRcdHZhciBpbmRleCA9IGluZGV4X29mLmNhbGwocmVhY3Rpb25zLCBzaWduYWwpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHZhciBuZXdfbGVuZ3RoID0gcmVhY3Rpb25zLmxlbmd0aCAtIDE7XG5cdFx0XHRpZiAobmV3X2xlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZWFjdGlvbnMgPSBkZXBlbmRlbmN5LnJlYWN0aW9ucyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBTd2FwIHdpdGggbGFzdCBlbGVtZW50IGFuZCB0aGVuIHJlbW92ZS5cblx0XHRcdFx0cmVhY3Rpb25zW2luZGV4XSA9IHJlYWN0aW9uc1tuZXdfbGVuZ3RoXTtcblx0XHRcdFx0cmVhY3Rpb25zLnBvcCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBJZiB0aGUgZGVyaXZlZCBoYXMgbm8gcmVhY3Rpb25zLCB0aGVuIHdlIGNhbiBkaXNjb25uZWN0IGl0IGZyb20gdGhlIGdyYXBoLFxuXHQvLyBhbGxvd2luZyBpdCB0byBlaXRoZXIgcmVjb25uZWN0IGluIHRoZSBmdXR1cmUsIG9yIGJlIEdDJ2QgYnkgdGhlIFZNLlxuXHRpZiAoXG5cdFx0cmVhY3Rpb25zID09PSBudWxsICYmXG5cdFx0KGRlcGVuZGVuY3kuZiAmIERFUklWRUQpICE9PSAwICYmXG5cdFx0Ly8gRGVzdHJveWluZyBhIGNoaWxkIGVmZmVjdCB3aGlsZSB1cGRhdGluZyBhIHBhcmVudCBlZmZlY3QgY2FuIGNhdXNlIGEgZGVwZW5kZW5jeSB0byBhcHBlYXJcblx0XHQvLyB0byBiZSB1bnVzZWQsIHdoZW4gaW4gZmFjdCBpdCBpcyB1c2VkIGJ5IHRoZSBjdXJyZW50bHktdXBkYXRpbmcgcGFyZW50LiBDaGVja2luZyBgbmV3X2RlcHNgXG5cdFx0Ly8gYWxsb3dzIHVzIHRvIHNraXAgdGhlIGV4cGVuc2l2ZSB3b3JrIG9mIGRpc2Nvbm5lY3RpbmcgYW5kIGltbWVkaWF0ZWx5IHJlY29ubmVjdGluZyBpdFxuXHRcdChuZXdfZGVwcyA9PT0gbnVsbCB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoZGVwZW5kZW5jeSkpXG5cdCkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGRlcGVuZGVuY3ksIE1BWUJFX0RJUlRZKTtcblx0XHQvLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZGVyaXZlZCB0aGF0IGlzIG93bmVkIGJ5IGFuIGVmZmVjdCwgdGhlbiBtYXJrIGl0IGFzIGJlaW5nXG5cdFx0Ly8gZGlzY29ubmVjdGVkLlxuXHRcdGlmICgoZGVwZW5kZW5jeS5mICYgKFVOT1dORUQgfCBESVNDT05ORUNURUQpKSA9PT0gMCkge1xuXHRcdFx0ZGVwZW5kZW5jeS5mIF49IERJU0NPTk5FQ1RFRDtcblx0XHR9XG5cdFx0Ly8gRGlzY29ubmVjdCBhbnkgcmVhY3Rpb25zIG93bmVkIGJ5IHRoaXMgcmVhY3Rpb25cblx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cygvKiogQHR5cGUge0Rlcml2ZWR9ICoqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdHJlbW92ZV9yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqKi8gKGRlcGVuZGVuY3kpLCAwKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2luZGV4XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbnMoc2lnbmFsLCBzdGFydF9pbmRleCkge1xuXHR2YXIgZGVwZW5kZW5jaWVzID0gc2lnbmFsLmRlcHM7XG5cdGlmIChkZXBlbmRlbmNpZXMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gc3RhcnRfaW5kZXg7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZW1vdmVfcmVhY3Rpb24oc2lnbmFsLCBkZXBlbmRlbmNpZXNbaV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRpZiAoKGZsYWdzICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblxuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xuXG5cdGlmIChERVYpIHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2ZuID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbik7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICgoZmxhZ3MgJiBCTE9DS19FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihlZmZlY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihlZmZlY3QpO1xuXHRcdH1cblxuXHRcdGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCk7XG5cdFx0dmFyIHRlYXJkb3duID0gdXBkYXRlX3JlYWN0aW9uKGVmZmVjdCk7XG5cdFx0ZWZmZWN0LnRlYXJkb3duID0gdHlwZW9mIHRlYXJkb3duID09PSAnZnVuY3Rpb24nID8gdGVhcmRvd24gOiBudWxsO1xuXHRcdGVmZmVjdC53diA9IHdyaXRlX3ZlcnNpb247XG5cblx0XHR2YXIgZGVwcyA9IGVmZmVjdC5kZXBzO1xuXG5cdFx0Ly8gSW4gREVWLCB3ZSBuZWVkIHRvIGhhbmRsZSBhIGNhc2Ugd2hlcmUgJGluc3BlY3QudHJhY2UoKSBtaWdodFxuXHRcdC8vIGluY29ycmVjdGx5IHN0YXRlIGEgc291cmNlIGRlcGVuZGVuY3kgaGFzIG5vdCBjaGFuZ2VkIHdoZW4gaXQgaGFzLlxuXHRcdC8vIFRoYXQncyBiZWFjdXNlIHRoYXQgc291cmNlIHdhcyBjaGFuZ2VkIGJ5IHRoZSBzYW1lIGVmZmVjdCwgY2F1c2luZ1xuXHRcdC8vIHRoZSB2ZXJzaW9ucyB0byBtYXRjaC4gV2UgY2FuIGF2b2lkIHRoaXMgYnkgaW5jcmVtZW50aW5nIHRoZSB2ZXJzaW9uXG5cdFx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZyAmJiAoZWZmZWN0LmYgJiBESVJUWSkgIT09IDAgJiYgZGVwcyAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkZXAgPSBkZXBzW2ldO1xuXHRcdFx0XHRpZiAoZGVwLnRyYWNlX25lZWRfaW5jcmVhc2UpIHtcblx0XHRcdFx0XHRkZXAud3YgPSBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpO1xuXHRcdFx0XHRcdGRlcC50cmFjZV9uZWVkX2luY3JlYXNlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGRlcC50cmFjZV92ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZGV2X2VmZmVjdF9zdGFjay5wdXNoKGVmZmVjdCk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGhhbmRsZV9lcnJvcihlcnJvciwgZWZmZWN0LCBwcmV2aW91c19lZmZlY3QsIHByZXZpb3VzX2NvbXBvbmVudF9jb250ZXh0IHx8IGVmZmVjdC5jdHgpO1xuXHR9IGZpbmFsbHkge1xuXHRcdGFjdGl2ZV9lZmZlY3QgPSBwcmV2aW91c19lZmZlY3Q7XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uKHByZXZpb3VzX2NvbXBvbmVudF9mbik7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxvZ19lZmZlY3Rfc3RhY2soKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUuZXJyb3IoXG5cdFx0J0xhc3QgdGVuIGVmZmVjdHMgd2VyZTogJyxcblx0XHRkZXZfZWZmZWN0X3N0YWNrLnNsaWNlKC0xMCkubWFwKChkKSA9PiBkLmZuKVxuXHQpO1xuXHRkZXZfZWZmZWN0X3N0YWNrID0gW107XG59XG5cbmZ1bmN0aW9uIGluZmluaXRlX2xvb3BfZ3VhcmQoKSB7XG5cdGlmIChmbHVzaF9jb3VudCA+IDEwMDApIHtcblx0XHRmbHVzaF9jb3VudCA9IDA7XG5cdFx0dHJ5IHtcblx0XHRcdGUuZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZCgpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdC8vIHN0YWNrIGlzIGdhcmJhZ2UsIGlnbm9yZS4gSW5zdGVhZCBhZGQgYSBjb25zb2xlLmVycm9yIG1lc3NhZ2UuXG5cdFx0XHRcdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywge1xuXHRcdFx0XHRcdHZhbHVlOiAnJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIFRyeSBhbmQgaGFuZGxlIHRoZSBlcnJvciBzbyBpdCBjYW4gYmUgY2F1Z2h0IGF0IGEgYm91bmRhcnksIHRoYXQnc1xuXHRcdFx0Ly8gaWYgdGhlcmUncyBhbiBlZmZlY3QgYXZhaWxhYmxlIGZyb20gd2hlbiBpdCB3YXMgbGFzdCBzY2hlZHVsZWRcblx0XHRcdGlmIChsYXN0X3NjaGVkdWxlZF9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCwgbnVsbCwgbnVsbCk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gT25seSBsb2cgdGhlIGVmZmVjdCBzdGFjayBpZiB0aGUgZXJyb3IgaXMgcmUtdGhyb3duXG5cdFx0XHRcdFx0XHRsb2dfZWZmZWN0X3N0YWNrKCk7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCwgbnVsbCwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRsb2dfZWZmZWN0X3N0YWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZsdXNoX2NvdW50Kys7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFZmZlY3Q+fSByb290X2VmZmVjdHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBmbHVzaF9xdWV1ZWRfcm9vdF9lZmZlY3RzKHJvb3RfZWZmZWN0cykge1xuXHR2YXIgbGVuZ3RoID0gcm9vdF9lZmZlY3RzLmxlbmd0aDtcblx0aWYgKGxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXHRpbmZpbml0ZV9sb29wX2d1YXJkKCk7XG5cblx0dmFyIHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0ID0gaXNfZmx1c2hpbmdfZWZmZWN0O1xuXHRpc19mbHVzaGluZ19lZmZlY3QgPSB0cnVlO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGVmZmVjdCA9IHJvb3RfZWZmZWN0c1tpXTtcblxuXHRcdFx0aWYgKChlZmZlY3QuZiAmIENMRUFOKSA9PT0gMCkge1xuXHRcdFx0XHRlZmZlY3QuZiBePSBDTEVBTjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbGxlY3RlZF9lZmZlY3RzID0gcHJvY2Vzc19lZmZlY3RzKGVmZmVjdCk7XG5cdFx0XHRmbHVzaF9xdWV1ZWRfZWZmZWN0cyhjb2xsZWN0ZWRfZWZmZWN0cyk7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlzX2ZsdXNoaW5nX2VmZmVjdCA9IHByZXZpb3VzbHlfZmx1c2hpbmdfZWZmZWN0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFZmZlY3Q+fSBlZmZlY3RzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcXVldWVkX2VmZmVjdHMoZWZmZWN0cykge1xuXHR2YXIgbGVuZ3RoID0gZWZmZWN0cy5sZW5ndGg7XG5cdGlmIChsZW5ndGggPT09IDApIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVmZmVjdCA9IGVmZmVjdHNbaV07XG5cblx0XHRpZiAoKGVmZmVjdC5mICYgKERFU1RST1lFRCB8IElORVJUKSkgPT09IDApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChjaGVja19kaXJ0aW5lc3MoZWZmZWN0KSkge1xuXHRcdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblxuXHRcdFx0XHRcdC8vIEVmZmVjdHMgd2l0aCBubyBkZXBlbmRlbmNpZXMgb3IgdGVhcmRvd24gZG8gbm90IGdldCBhZGRlZCB0byB0aGUgZWZmZWN0IHRyZWUuXG5cdFx0XHRcdFx0Ly8gRGVmZXJyZWQgZWZmZWN0cyAoZS5nLiBgJGVmZmVjdCguLi4pYCkgX2FyZV8gYWRkZWQgdG8gdGhlIHRyZWUgYmVjYXVzZSB3ZVxuXHRcdFx0XHRcdC8vIGRvbid0IGtub3cgaWYgd2UgbmVlZCB0byBrZWVwIHRoZW0gdW50aWwgdGhleSBhcmUgZXhlY3V0ZWQuIERvaW5nIHRoZSBjaGVja1xuXHRcdFx0XHRcdC8vIGhlcmUgKHJhdGhlciB0aGFuIGluIGB1cGRhdGVfZWZmZWN0YCkgYWxsb3dzIHVzIHRvIHNraXAgdGhlIHdvcmsgZm9yXG5cdFx0XHRcdFx0Ly8gaW1tZWRpYXRlIGVmZmVjdHMuXG5cdFx0XHRcdFx0aWYgKGVmZmVjdC5kZXBzID09PSBudWxsICYmIGVmZmVjdC5maXJzdCA9PT0gbnVsbCAmJiBlZmZlY3Qubm9kZXNfc3RhcnQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmIChlZmZlY3QudGVhcmRvd24gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHRoaXMgZWZmZWN0IGZyb20gdGhlIGdyYXBoXG5cdFx0XHRcdFx0XHRcdHVubGlua19lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIGtlZXAgdGhlIGVmZmVjdCBpbiB0aGUgZ3JhcGgsIGJ1dCBmcmVlIHVwIHNvbWUgbWVtb3J5XG5cdFx0XHRcdFx0XHRcdGVmZmVjdC5mbiA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRoYW5kbGVfZXJyb3IoZXJyb3IsIGVmZmVjdCwgbnVsbCwgZWZmZWN0LmN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NfZGVmZXJyZWQoKSB7XG5cdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gZmFsc2U7XG5cdGlmIChmbHVzaF9jb3VudCA+IDEwMDEpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0Y29uc3QgcHJldmlvdXNfcXVldWVkX3Jvb3RfZWZmZWN0cyA9IHF1ZXVlZF9yb290X2VmZmVjdHM7XG5cdHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblx0Zmx1c2hfcXVldWVkX3Jvb3RfZWZmZWN0cyhwcmV2aW91c19xdWV1ZWRfcm9vdF9lZmZlY3RzKTtcblxuXHRpZiAoIWlzX21pY3JvX3Rhc2tfcXVldWVkKSB7XG5cdFx0Zmx1c2hfY291bnQgPSAwO1xuXHRcdGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZGV2X2VmZmVjdF9zdGFjayA9IFtdO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBzaWduYWxcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVfZWZmZWN0KHNpZ25hbCkge1xuXHRpZiAoc2NoZWR1bGVyX21vZGUgPT09IEZMVVNIX01JQ1JPVEFTSykge1xuXHRcdGlmICghaXNfbWljcm9fdGFza19xdWV1ZWQpIHtcblx0XHRcdGlzX21pY3JvX3Rhc2tfcXVldWVkID0gdHJ1ZTtcblx0XHRcdHF1ZXVlTWljcm90YXNrKHByb2Nlc3NfZGVmZXJyZWQpO1xuXHRcdH1cblx0fVxuXG5cdGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IHNpZ25hbDtcblxuXHR2YXIgZWZmZWN0ID0gc2lnbmFsO1xuXG5cdHdoaWxlIChlZmZlY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRcdGlmICgoZmxhZ3MgJiAoUk9PVF9FRkZFQ1QgfCBCUkFOQ0hfRUZGRUNUKSkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBDTEVBTikgPT09IDApIHJldHVybjtcblx0XHRcdGVmZmVjdC5mIF49IENMRUFOO1xuXHRcdH1cblx0fVxuXG5cdHF1ZXVlZF9yb290X2VmZmVjdHMucHVzaChlZmZlY3QpO1xufVxuXG4vKipcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGJvdGggcnVucyByZW5kZXIgZWZmZWN0cyBhbmQgY29sbGVjdHMgdXNlciBlZmZlY3RzIGluIHRvcG9sb2dpY2FsIG9yZGVyXG4gKiBmcm9tIHRoZSBzdGFydGluZyBlZmZlY3QgcGFzc2VkIGluLiBFZmZlY3RzIHdpbGwgYmUgY29sbGVjdGVkIHdoZW4gdGhleSBtYXRjaCB0aGUgZmlsdGVyZWRcbiAqIGJpdHdpc2UgZmxhZyBwYXNzZWQgaW4gb25seS4gVGhlIGNvbGxlY3RlZCBlZmZlY3RzIGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggYWxsIHRoZSB1c2VyXG4gKiBlZmZlY3RzIHRvIGJlIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHJldHVybnMge0VmZmVjdFtdfVxuICovXG5mdW5jdGlvbiBwcm9jZXNzX2VmZmVjdHMoZWZmZWN0KSB7XG5cdC8qKiBAdHlwZSB7RWZmZWN0W119ICovXG5cdHZhciBlZmZlY3RzID0gW107XG5cblx0dmFyIGN1cnJlbnRfZWZmZWN0ID0gZWZmZWN0LmZpcnN0O1xuXG5cdG1haW5fbG9vcDogd2hpbGUgKGN1cnJlbnRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIGZsYWdzID0gY3VycmVudF9lZmZlY3QuZjtcblx0XHR2YXIgaXNfYnJhbmNoID0gKGZsYWdzICYgQlJBTkNIX0VGRkVDVCkgIT09IDA7XG5cdFx0dmFyIGlzX3NraXBwYWJsZV9icmFuY2ggPSBpc19icmFuY2ggJiYgKGZsYWdzICYgQ0xFQU4pICE9PSAwO1xuXHRcdHZhciBzaWJsaW5nID0gY3VycmVudF9lZmZlY3QubmV4dDtcblxuXHRcdGlmICghaXNfc2tpcHBhYmxlX2JyYW5jaCAmJiAoZmxhZ3MgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBFRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRcdGVmZmVjdHMucHVzaChjdXJyZW50X2VmZmVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGlzX2JyYW5jaCkge1xuXHRcdFx0XHRjdXJyZW50X2VmZmVjdC5mIF49IENMRUFOO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRW5zdXJlIHdlIHNldCB0aGUgZWZmZWN0IHRvIGJlIHRoZSBhY3RpdmUgcmVhY3Rpb25cblx0XHRcdFx0Ly8gdG8gZW5zdXJlIHRoYXQgdW5vd25lZCBkZXJpdmVkcyBhcmUgY29ycmVjdGx5IHRyYWNrZWRcblx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSdyZSBmbHVzaGluZyB0aGUgY3VycmVudCBlZmZlY3Rcblx0XHRcdFx0dmFyIHByZXZpb3VzX2FjdGl2ZV9yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhY3RpdmVfcmVhY3Rpb24gPSBjdXJyZW50X2VmZmVjdDtcblx0XHRcdFx0XHRpZiAoY2hlY2tfZGlydGluZXNzKGN1cnJlbnRfZWZmZWN0KSkge1xuXHRcdFx0XHRcdFx0dXBkYXRlX2VmZmVjdChjdXJyZW50X2VmZmVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGhhbmRsZV9lcnJvcihlcnJvciwgY3VycmVudF9lZmZlY3QsIG51bGwsIGN1cnJlbnRfZWZmZWN0LmN0eCk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0YWN0aXZlX3JlYWN0aW9uID0gcHJldmlvdXNfYWN0aXZlX3JlYWN0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjaGlsZCA9IGN1cnJlbnRfZWZmZWN0LmZpcnN0O1xuXG5cdFx0XHRpZiAoY2hpbGQgIT09IG51bGwpIHtcblx0XHRcdFx0Y3VycmVudF9lZmZlY3QgPSBjaGlsZDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNpYmxpbmcgPT09IG51bGwpIHtcblx0XHRcdGxldCBwYXJlbnQgPSBjdXJyZW50X2VmZmVjdC5wYXJlbnQ7XG5cblx0XHRcdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKGVmZmVjdCA9PT0gcGFyZW50KSB7XG5cdFx0XHRcdFx0YnJlYWsgbWFpbl9sb29wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBwYXJlbnRfc2libGluZyA9IHBhcmVudC5uZXh0O1xuXHRcdFx0XHRpZiAocGFyZW50X3NpYmxpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0XHRjdXJyZW50X2VmZmVjdCA9IHBhcmVudF9zaWJsaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlIG1haW5fbG9vcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnJlbnRfZWZmZWN0ID0gc2libGluZztcblx0fVxuXG5cdHJldHVybiBlZmZlY3RzO1xufVxuXG4vKipcbiAqIEludGVybmFsIHZlcnNpb24gb2YgYGZsdXNoU3luY2Agd2l0aCB0aGUgb3B0aW9uIHRvIG5vdCBmbHVzaCBwcmV2aW91cyBlZmZlY3RzLlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBwYXNzZWQgZnVuY3Rpb24sIGlmIGdpdmVuLlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IFtmbl1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9zeW5jKGZuKSB7XG5cdHZhciBwcmV2aW91c19zY2hlZHVsZXJfbW9kZSA9IHNjaGVkdWxlcl9tb2RlO1xuXHR2YXIgcHJldmlvdXNfcXVldWVkX3Jvb3RfZWZmZWN0cyA9IHF1ZXVlZF9yb290X2VmZmVjdHM7XG5cblx0dHJ5IHtcblx0XHRpbmZpbml0ZV9sb29wX2d1YXJkKCk7XG5cblx0XHQvKiogQHR5cGUge0VmZmVjdFtdfSAqL1xuXHRcdGNvbnN0IHJvb3RfZWZmZWN0cyA9IFtdO1xuXG5cdFx0c2NoZWR1bGVyX21vZGUgPSBGTFVTSF9TWU5DO1xuXHRcdHF1ZXVlZF9yb290X2VmZmVjdHMgPSByb290X2VmZmVjdHM7XG5cdFx0aXNfbWljcm9fdGFza19xdWV1ZWQgPSBmYWxzZTtcblxuXHRcdGZsdXNoX3F1ZXVlZF9yb290X2VmZmVjdHMocHJldmlvdXNfcXVldWVkX3Jvb3RfZWZmZWN0cyk7XG5cblx0XHR2YXIgcmVzdWx0ID0gZm4/LigpO1xuXG5cdFx0Zmx1c2hfdGFza3MoKTtcblx0XHRpZiAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPiAwIHx8IHJvb3RfZWZmZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRmbHVzaF9zeW5jKCk7XG5cdFx0fVxuXG5cdFx0Zmx1c2hfY291bnQgPSAwO1xuXHRcdGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0ZGV2X2VmZmVjdF9zdGFjayA9IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0gZmluYWxseSB7XG5cdFx0c2NoZWR1bGVyX21vZGUgPSBwcmV2aW91c19zY2hlZHVsZXJfbW9kZTtcblx0XHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gcHJldmlvdXNfcXVldWVkX3Jvb3RfZWZmZWN0cztcblx0fVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbnkgcGVuZGluZyBzdGF0ZSBjaGFuZ2VzIGhhdmUgYmVlbiBhcHBsaWVkLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0aWNrKCkge1xuXHRhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcblx0Ly8gQnkgY2FsbGluZyBmbHVzaF9zeW5jIHdlIGd1YXJhbnRlZSB0aGF0IGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgYXJlIGFwcGxpZWQgYWZ0ZXIgb25lIHRpY2suXG5cdC8vIFRPRE8gbG9vayBpbnRvIHdoZXRoZXIgd2UgY2FuIG1ha2UgZmx1c2hpbmcgc3Vic2VxdWVudCB1cGRhdGVzIHN5bmNocm9ub3VzbHkgaW4gdGhlIGZ1dHVyZS5cblx0Zmx1c2hfc3luYygpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBzaWduYWxcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHNpZ25hbCkge1xuXHR2YXIgZmxhZ3MgPSBzaWduYWwuZjtcblx0dmFyIGlzX2Rlcml2ZWQgPSAoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMDtcblxuXHRpZiAoY2FwdHVyZWRfc2lnbmFscyAhPT0gbnVsbCkge1xuXHRcdGNhcHR1cmVkX3NpZ25hbHMuYWRkKHNpZ25hbCk7XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgZGVwZW5kZW5jeSBvbiB0aGUgY3VycmVudCByZWFjdGlvbiBzaWduYWwuXG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmcpIHtcblx0XHRpZiAoZGVyaXZlZF9zb3VyY2VzICE9PSBudWxsICYmIGRlcml2ZWRfc291cmNlcy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0XHRlLnN0YXRlX3Vuc2FmZV9sb2NhbF9yZWFkKCk7XG5cdFx0fVxuXHRcdHZhciBkZXBzID0gYWN0aXZlX3JlYWN0aW9uLmRlcHM7XG5cdFx0aWYgKHNpZ25hbC5ydiA8IHJlYWRfdmVyc2lvbikge1xuXHRcdFx0c2lnbmFsLnJ2ID0gcmVhZF92ZXJzaW9uO1xuXHRcdFx0Ly8gSWYgdGhlIHNpZ25hbCBpcyBhY2Nlc3NpbmcgdGhlIHNhbWUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lXG5cdFx0XHQvLyBvcmRlciBhcyBpdCBkaWQgbGFzdCB0aW1lLCBpbmNyZW1lbnQgYHNraXBwZWRfZGVwc2Bcblx0XHRcdC8vIHJhdGhlciB0aGFuIHVwZGF0aW5nIGBuZXdfZGVwc2AsIHdoaWNoIGNyZWF0ZXMgR0MgY29zdFxuXHRcdFx0aWYgKG5ld19kZXBzID09PSBudWxsICYmIGRlcHMgIT09IG51bGwgJiYgZGVwc1tza2lwcGVkX2RlcHNdID09PSBzaWduYWwpIHtcblx0XHRcdFx0c2tpcHBlZF9kZXBzKys7XG5cdFx0XHR9IGVsc2UgaWYgKG5ld19kZXBzID09PSBudWxsKSB7XG5cdFx0XHRcdG5ld19kZXBzID0gW3NpZ25hbF07XG5cdFx0XHR9IGVsc2UgaWYgKCFza2lwX3JlYWN0aW9uIHx8ICFuZXdfZGVwcy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0XHRcdC8vIE5vcm1hbGx5IHdlIGNhbiBwdXNoIGR1cGxpY2F0ZWQgZGVwZW5kZW5jaWVzIHRvIGBuZXdfZGVwc2AsIGJ1dCBpZiB3ZSdyZSBpbnNpZGVcblx0XHRcdFx0Ly8gYW4gdW5vd25lZCBkZXJpdmVkIGJlY2F1c2Ugc2tpcF9yZWFjdGlvbiBpcyB0cnVlLCB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXRcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgaGF2ZSBkdXBsaWNhdGVzXG5cdFx0XHRcdG5ld19kZXBzLnB1c2goc2lnbmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoXG5cdFx0aXNfZGVyaXZlZCAmJlxuXHRcdC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCkuZGVwcyA9PT0gbnVsbCAmJlxuXHRcdC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCkuZWZmZWN0cyA9PT0gbnVsbFxuXHQpIHtcblx0XHR2YXIgZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCk7XG5cdFx0dmFyIHBhcmVudCA9IGRlcml2ZWQucGFyZW50O1xuXG5cdFx0aWYgKHBhcmVudCAhPT0gbnVsbCAmJiAocGFyZW50LmYgJiBVTk9XTkVEKSA9PT0gMCkge1xuXHRcdFx0Ly8gSWYgdGhlIGRlcml2ZWQgaXMgb3duZWQgYnkgYW5vdGhlciBkZXJpdmVkIHRoZW4gbWFyayBpdCBhcyB1bm93bmVkXG5cdFx0XHQvLyBhcyB0aGUgZGVyaXZlZCB2YWx1ZSBtaWdodCBoYXZlIGJlZW4gcmVmZXJlbmNlZCBpbiBhIGRpZmZlcmVudCBjb250ZXh0XG5cdFx0XHQvLyBzaW5jZSBhbmQgdGh1cyBpdHMgcGFyZW50IG1pZ2h0IG5vdCBiZSBpdHMgdHJ1ZSBvd25lciBhbnltb3JlXG5cdFx0XHRkZXJpdmVkLmYgXj0gVU5PV05FRDtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfZGVyaXZlZCkge1xuXHRcdGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXG5cdFx0aWYgKGNoZWNrX2RpcnRpbmVzcyhkZXJpdmVkKSkge1xuXHRcdFx0dXBkYXRlX2Rlcml2ZWQoZGVyaXZlZCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKFxuXHRcdERFViAmJlxuXHRcdHRyYWNpbmdfbW9kZV9mbGFnICYmXG5cdFx0dHJhY2luZ19leHByZXNzaW9ucyAhPT0gbnVsbCAmJlxuXHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMucmVhY3Rpb24gPT09IGFjdGl2ZV9yZWFjdGlvblxuXHQpIHtcblx0XHQvLyBVc2VkIHdoZW4gbWFwcGluZyBzdGF0ZSBiZXR3ZWVuIHNwZWNpYWwgYmxvY2tzIGxpa2UgYGVhY2hgXG5cdFx0aWYgKHNpZ25hbC5kZWJ1Zykge1xuXHRcdFx0c2lnbmFsLmRlYnVnKCk7XG5cdFx0fSBlbHNlIGlmIChzaWduYWwuY3JlYXRlZCkge1xuXHRcdFx0dmFyIGVudHJ5ID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLmdldChzaWduYWwpO1xuXG5cdFx0XHRpZiAoZW50cnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRlbnRyeSA9IHsgcmVhZDogW10gfTtcblx0XHRcdFx0dHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLnNldChzaWduYWwsIGVudHJ5KTtcblx0XHRcdH1cblxuXHRcdFx0ZW50cnkucmVhZC5wdXNoKGdldF9zdGFjaygnVHJhY2VkQXQnKSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNpZ25hbC52O1xufVxuXG4vKipcbiAqIExpa2UgYGdldGAsIGJ1dCBjaGVja3MgZm9yIGB1bmRlZmluZWRgLiBVc2VkIGZvciBgdmFyYCBkZWNsYXJhdGlvbnMgYmVjYXVzZSB0aGV5IGNhbiBiZSBhY2Nlc3NlZCBiZWZvcmUgYmVpbmcgZGVjbGFyZWRcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+IHwgdW5kZWZpbmVkfSBzaWduYWxcbiAqIEByZXR1cm5zIHtWIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9nZXQoc2lnbmFsKSB7XG5cdHJldHVybiBzaWduYWwgJiYgZ2V0KHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ2FwdHVyZSBhbiBhcnJheSBvZiBhbGwgdGhlIHNpZ25hbHMgdGhhdCBhcmUgcmVhZCB3aGVuIGBmbmAgaXMgY2FsbGVkXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZV9zaWduYWxzKGZuKSB7XG5cdHZhciBwcmV2aW91c19jYXB0dXJlZF9zaWduYWxzID0gY2FwdHVyZWRfc2lnbmFscztcblx0Y2FwdHVyZWRfc2lnbmFscyA9IG5ldyBTZXQoKTtcblxuXHR2YXIgY2FwdHVyZWQgPSBjYXB0dXJlZF9zaWduYWxzO1xuXHR2YXIgc2lnbmFsO1xuXG5cdHRyeSB7XG5cdFx0dW50cmFjayhmbik7XG5cdFx0aWYgKHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHMgIT09IG51bGwpIHtcblx0XHRcdGZvciAoc2lnbmFsIG9mIGNhcHR1cmVkX3NpZ25hbHMpIHtcblx0XHRcdFx0cHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscy5hZGQoc2lnbmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Y2FwdHVyZWRfc2lnbmFscyA9IHByZXZpb3VzX2NhcHR1cmVkX3NpZ25hbHM7XG5cdH1cblxuXHRyZXR1cm4gY2FwdHVyZWQ7XG59XG5cbi8qKlxuICogSW52b2tlcyBhIGZ1bmN0aW9uIGFuZCBjYXB0dXJlcyBhbGwgc2lnbmFscyB0aGF0IGFyZSByZWFkIGR1cmluZyB0aGUgaW52b2NhdGlvbixcbiAqIHRoZW4gaW52YWxpZGF0ZXMgdGhlbS5cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzKGZuKSB7XG5cdHZhciBjYXB0dXJlZCA9IGNhcHR1cmVfc2lnbmFscygoKSA9PiB1bnRyYWNrKGZuKSk7XG5cblx0Zm9yICh2YXIgc2lnbmFsIG9mIGNhcHR1cmVkKSB7XG5cdFx0Ly8gR28gb25lIGxldmVsIHVwIGJlY2F1c2UgZGVyaXZlZCBzaWduYWxzIGNyZWF0ZWQgYXMgcGFydCBvZiBwcm9wcyBpbiBsZWdhY3kgbW9kZVxuXHRcdGlmICgoc2lnbmFsLmYgJiBMRUdBQ1lfREVSSVZFRF9QUk9QKSAhPT0gMCkge1xuXHRcdFx0Zm9yIChjb25zdCBkZXAgb2YgLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKS5kZXBzIHx8IFtdKSB7XG5cdFx0XHRcdGlmICgoZGVwLmYgJiBERVJJVkVEKSA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIFVzZSBpbnRlcm5hbF9zZXQgaW5zdGVhZCBvZiBzZXQgaGVyZSBhbmQgYmVsb3cgdG8gYXZvaWQgbXV0YXRpb24gdmFsaWRhdGlvblxuXHRcdFx0XHRcdGludGVybmFsX3NldChkZXAsIGRlcC52KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCBzaWduYWwudik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogV2hlbiB1c2VkIGluc2lkZSBhIFtgJGRlcml2ZWRgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtgJGVmZmVjdGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSxcbiAqIGFueSBzdGF0ZSByZWFkIGluc2lkZSBgZm5gIHdpbGwgbm90IGJlIHRyZWF0ZWQgYXMgYSBkZXBlbmRlbmN5LlxuICpcbiAqIGBgYHRzXG4gKiAkZWZmZWN0KCgpID0+IHtcbiAqICAgLy8gdGhpcyB3aWxsIHJ1biB3aGVuIGBkYXRhYCBjaGFuZ2VzLCBidXQgbm90IHdoZW4gYHRpbWVgIGNoYW5nZXNcbiAqICAgc2F2ZShkYXRhLCB7XG4gKiAgICAgdGltZXN0YW1wOiB1bnRyYWNrKCgpID0+IHRpbWUpXG4gKiAgIH0pO1xuICogfSk7XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2soZm4pIHtcblx0dmFyIHByZXZpb3VzX3VudHJhY2tpbmcgPSB1bnRyYWNraW5nO1xuXHR0cnkge1xuXHRcdHVudHJhY2tpbmcgPSB0cnVlO1xuXHRcdHJldHVybiBmbigpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHVudHJhY2tpbmcgPSBwcmV2aW91c191bnRyYWNraW5nO1xuXHR9XG59XG5cbmNvbnN0IFNUQVRVU19NQVNLID0gfihESVJUWSB8IE1BWUJFX0RJUlRZIHwgQ0xFQU4pO1xuXG4vKipcbiAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NpZ25hbF9zdGF0dXMoc2lnbmFsLCBzdGF0dXMpIHtcblx0c2lnbmFsLmYgPSAoc2lnbmFsLmYgJiBTVEFUVVNfTUFTSykgfCBzdGF0dXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlX2Zyb21fb2JqZWN0KG9iaiwga2V5cykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuXHR2YXIgcmVzdWx0ID0ge307XG5cblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IG9ialtrZXldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUG9zc2libHkgdHJhdmVyc2UgYW4gb2JqZWN0IGFuZCByZWFkIGFsbCBpdHMgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkncmUgYWxsIHJlYWN0aXZlIGluIGNhc2UgdGhpcyBpcyBgJHN0YXRlYC5cbiAqIERvZXMgb25seSBjaGVjayBmaXJzdCBsZXZlbCBvZiBhbiBvYmplY3QgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKGhldXJpc3RpYyBzaG91bGQgYmUgZ29vZCBmb3IgOTklIG9mIGFsbCBjYXNlcykuXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkX3N0YXRlKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8ICF2YWx1ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdGRlZXBfcmVhZCh2YWx1ZSk7XG5cdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRjb25zdCBwcm9wID0gdmFsdWVba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAmJiBTVEFURV9TWU1CT0wgaW4gcHJvcCkge1xuXHRcdFx0XHRkZWVwX3JlYWQocHJvcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRGVlcGx5IHRyYXZlcnNlIGFuIG9iamVjdCBhbmQgcmVhZCBhbGwgaXRzIHByb3BlcnRpZXNcbiAqIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVhY3RpdmUgaW4gY2FzZSB0aGlzIGlzIGAkc3RhdGVgXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZpc2l0ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkKHZhbHVlLCB2aXNpdGVkID0gbmV3IFNldCgpKSB7XG5cdGlmIChcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlIERPTSBlbGVtZW50c1xuXHRcdCEodmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkgJiZcblx0XHQhdmlzaXRlZC5oYXModmFsdWUpXG5cdCkge1xuXHRcdHZpc2l0ZWQuYWRkKHZhbHVlKTtcblx0XHQvLyBXaGVuIHdvcmtpbmcgd2l0aCBhIHBvc3NpYmxlIFN2ZWx0ZURhdGUsIHRoaXNcblx0XHQvLyB3aWxsIGVuc3VyZSB3ZSBjYXB0dXJlIGNoYW5nZXMgdG8gaXQuXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0dmFsdWUuZ2V0VGltZSgpO1xuXHRcdH1cblx0XHRmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlZXBfcmVhZCh2YWx1ZVtrZXldLCB2aXNpdGVkKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblx0XHRpZiAoXG5cdFx0XHRwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IEFycmF5LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IE1hcC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBTZXQucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gRGF0ZS5wcm90b3R5cGVcblx0XHQpIHtcblx0XHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblx0XHRcdGZvciAobGV0IGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0XHRjb25zdCBnZXQgPSBkZXNjcmlwdG9yc1trZXldLmdldDtcblx0XHRcdFx0aWYgKGdldCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRnZXQuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsImNvbnN0IHJlZ2V4X3JldHVybl9jaGFyYWN0ZXJzID0gL1xcci9nO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHN0cikge1xuXHRzdHIgPSBzdHIucmVwbGFjZShyZWdleF9yZXR1cm5fY2hhcmFjdGVycywgJycpO1xuXHRsZXQgaGFzaCA9IDUzODE7XG5cdGxldCBpID0gc3RyLmxlbmd0aDtcblxuXHR3aGlsZSAoaS0tKSBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcblx0cmV0dXJuIChoYXNoID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbmNvbnN0IFZPSURfRUxFTUVOVF9OQU1FUyA9IFtcblx0J2FyZWEnLFxuXHQnYmFzZScsXG5cdCdicicsXG5cdCdjb2wnLFxuXHQnY29tbWFuZCcsXG5cdCdlbWJlZCcsXG5cdCdocicsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQna2V5Z2VuJyxcblx0J2xpbmsnLFxuXHQnbWV0YScsXG5cdCdwYXJhbScsXG5cdCdzb3VyY2UnLFxuXHQndHJhY2snLFxuXHQnd2JyJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgb2YgYSB2b2lkIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc192b2lkKG5hbWUpIHtcblx0cmV0dXJuIFZPSURfRUxFTUVOVF9OQU1FUy5pbmNsdWRlcyhuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IFJFU0VSVkVEX1dPUkRTID0gW1xuXHQnYXJndW1lbnRzJyxcblx0J2F3YWl0Jyxcblx0J2JyZWFrJyxcblx0J2Nhc2UnLFxuXHQnY2F0Y2gnLFxuXHQnY2xhc3MnLFxuXHQnY29uc3QnLFxuXHQnY29udGludWUnLFxuXHQnZGVidWdnZXInLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWxldGUnLFxuXHQnZG8nLFxuXHQnZWxzZScsXG5cdCdlbnVtJyxcblx0J2V2YWwnLFxuXHQnZXhwb3J0Jyxcblx0J2V4dGVuZHMnLFxuXHQnZmFsc2UnLFxuXHQnZmluYWxseScsXG5cdCdmb3InLFxuXHQnZnVuY3Rpb24nLFxuXHQnaWYnLFxuXHQnaW1wbGVtZW50cycsXG5cdCdpbXBvcnQnLFxuXHQnaW4nLFxuXHQnaW5zdGFuY2VvZicsXG5cdCdpbnRlcmZhY2UnLFxuXHQnbGV0Jyxcblx0J25ldycsXG5cdCdudWxsJyxcblx0J3BhY2thZ2UnLFxuXHQncHJpdmF0ZScsXG5cdCdwcm90ZWN0ZWQnLFxuXHQncHVibGljJyxcblx0J3JldHVybicsXG5cdCdzdGF0aWMnLFxuXHQnc3VwZXInLFxuXHQnc3dpdGNoJyxcblx0J3RoaXMnLFxuXHQndGhyb3cnLFxuXHQndHJ1ZScsXG5cdCd0cnknLFxuXHQndHlwZW9mJyxcblx0J3ZhcicsXG5cdCd2b2lkJyxcblx0J3doaWxlJyxcblx0J3dpdGgnLFxuXHQneWllbGQnXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGB3b3JkYCBpcyBhIHJlc2VydmVkIEphdmFTY3JpcHQga2V5d29yZFxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Jlc2VydmVkKHdvcmQpIHtcblx0cmV0dXJuIFJFU0VSVkVEX1dPUkRTLmluY2x1ZGVzKHdvcmQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jYXB0dXJlX2V2ZW50KG5hbWUpIHtcblx0cmV0dXJuIG5hbWUuZW5kc1dpdGgoJ2NhcHR1cmUnKSAmJiBuYW1lICE9PSAnZ290cG9pbnRlcmNhcHR1cmUnICYmIG5hbWUgIT09ICdsb3N0cG9pbnRlcmNhcHR1cmUnO1xufVxuXG4vKiogTGlzdCBvZiBFbGVtZW50IGV2ZW50cyB0aGF0IHdpbGwgYmUgZGVsZWdhdGVkICovXG5jb25zdCBERUxFR0FURURfRVZFTlRTID0gW1xuXHQnYmVmb3JlaW5wdXQnLFxuXHQnY2xpY2snLFxuXHQnY2hhbmdlJyxcblx0J2RibGNsaWNrJyxcblx0J2NvbnRleHRtZW51Jyxcblx0J2ZvY3VzaW4nLFxuXHQnZm9jdXNvdXQnLFxuXHQnaW5wdXQnLFxuXHQna2V5ZG93bicsXG5cdCdrZXl1cCcsXG5cdCdtb3VzZWRvd24nLFxuXHQnbW91c2Vtb3ZlJyxcblx0J21vdXNlb3V0Jyxcblx0J21vdXNlb3ZlcicsXG5cdCdtb3VzZXVwJyxcblx0J3BvaW50ZXJkb3duJyxcblx0J3BvaW50ZXJtb3ZlJyxcblx0J3BvaW50ZXJvdXQnLFxuXHQncG9pbnRlcm92ZXInLFxuXHQncG9pbnRlcnVwJyxcblx0J3RvdWNoZW5kJyxcblx0J3RvdWNobW92ZScsXG5cdCd0b3VjaHN0YXJ0J1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgZXZlbnRfbmFtZWAgaXMgYSBkZWxlZ2F0ZWQgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kZWxlZ2F0ZWQoZXZlbnRfbmFtZSkge1xuXHRyZXR1cm4gREVMRUdBVEVEX0VWRU5UUy5pbmNsdWRlcyhldmVudF9uYW1lKTtcbn1cblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHRoYXQgYXJlIGJvb2xlYW4sIGkuZS4gdGhleSBhcmUgcHJlc2VudCBvciBub3QgcHJlc2VudC5cbiAqL1xuY29uc3QgRE9NX0JPT0xFQU5fQVRUUklCVVRFUyA9IFtcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhc3luYycsXG5cdCdhdXRvZm9jdXMnLFxuXHQnYXV0b3BsYXknLFxuXHQnY2hlY2tlZCcsXG5cdCdjb250cm9scycsXG5cdCdkZWZhdWx0Jyxcblx0J2Rpc2FibGVkJyxcblx0J2Zvcm1ub3ZhbGlkYXRlJyxcblx0J2hpZGRlbicsXG5cdCdpbmRldGVybWluYXRlJyxcblx0J2luZXJ0Jyxcblx0J2lzbWFwJyxcblx0J2xvb3AnLFxuXHQnbXVsdGlwbGUnLFxuXHQnbXV0ZWQnLFxuXHQnbm9tb2R1bGUnLFxuXHQnbm92YWxpZGF0ZScsXG5cdCdvcGVuJyxcblx0J3BsYXlzaW5saW5lJyxcblx0J3JlYWRvbmx5Jyxcblx0J3JlcXVpcmVkJyxcblx0J3JldmVyc2VkJyxcblx0J3NlYW1sZXNzJyxcblx0J3NlbGVjdGVkJyxcblx0J3dlYmtpdGRpcmVjdG9yeScsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsXG5cdCdkaXNhYmxlcmVtb3RlcGxheWJhY2snXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGBuYW1lYCBpcyBhIGJvb2xlYW4gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfYm9vbGVhbl9hdHRyaWJ1dGUobmFtZSkge1xuXHRyZXR1cm4gRE9NX0JPT0xFQU5fQVRUUklCVVRFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRoYXQgc2hvdWxkIGJlIGFsaWFzZWQgdG8gdGhlaXIgcHJvcGVydHkgbmFtZXNcbiAqIGJlY2F1c2UgdGhleSBiZWhhdmUgZGlmZmVyZW50bHkgYmV0d2VlbiBzZXR0aW5nIHRoZW0gYXMgYW4gYXR0cmlidXRlIGFuZFxuICogc2V0dGluZyB0aGVtIGFzIGEgcHJvcGVydHkuXG4gKi9cbmNvbnN0IEFUVFJJQlVURV9BTElBU0VTID0ge1xuXHQvLyBubyBgY2xhc3M6ICdjbGFzc05hbWUnYCBiZWNhdXNlIHdlIGhhbmRsZSB0aGF0IHNlcGFyYXRlbHlcblx0Zm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG5cdGlzbWFwOiAnaXNNYXAnLFxuXHRub21vZHVsZTogJ25vTW9kdWxlJyxcblx0cGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG5cdHJlYWRvbmx5OiAncmVhZE9ubHknLFxuXHRkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuXHRkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcblx0c3Jjb2JqZWN0OiAnc3JjT2JqZWN0Jyxcblx0bm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuXHRhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxzY3JlZW4nLFxuXHRkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcblx0ZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplX2F0dHJpYnV0ZShuYW1lKSB7XG5cdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdHJldHVybiBBVFRSSUJVVEVfQUxJQVNFU1tuYW1lXSA/PyBuYW1lO1xufVxuXG5jb25zdCBET01fUFJPUEVSVElFUyA9IFtcblx0Li4uRE9NX0JPT0xFQU5fQVRUUklCVVRFUyxcblx0J2Zvcm1Ob1ZhbGlkYXRlJyxcblx0J2lzTWFwJyxcblx0J25vTW9kdWxlJyxcblx0J3BsYXlzSW5saW5lJyxcblx0J3JlYWRPbmx5Jyxcblx0J3ZhbHVlJyxcblx0J3ZvbHVtZScsXG5cdCdkZWZhdWx0VmFsdWUnLFxuXHQnZGVmYXVsdENoZWNrZWQnLFxuXHQnc3JjT2JqZWN0Jyxcblx0J25vVmFsaWRhdGUnLFxuXHQnYWxsb3dGdWxsc2NyZWVuJyxcblx0J2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcblx0J2Rpc2FibGVSZW1vdGVQbGF5YmFjaydcbl07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2RvbV9wcm9wZXJ0eShuYW1lKSB7XG5cdHJldHVybiBET01fUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTk9OX1NUQVRJQ19QUk9QRVJUSUVTID0gWydhdXRvZm9jdXMnLCAnbXV0ZWQnLCAnZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZSBjYW5ub3QgYmUgc2V0IHRocm91Z2ggdGhlIHRlbXBsYXRlXG4gKiBzdHJpbmcsIGkuZS4gbmVlZHMgc29tZSBraW5kIG9mIEphdmFTY3JpcHQgaGFuZGxpbmcgdG8gd29yay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RfYmVfc2V0X3N0YXRpY2FsbHkobmFtZSkge1xuXHRyZXR1cm4gTk9OX1NUQVRJQ19QUk9QRVJUSUVTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG4vKipcbiAqIFN1YnNldCBvZiBkZWxlZ2F0ZWQgZXZlbnRzIHdoaWNoIHNob3VsZCBiZSBwYXNzaXZlIGJ5IGRlZmF1bHQuXG4gKiBUaGVzZSB0d28gYXJlIGFscmVhZHkgcGFzc2l2ZSB2aWEgYnJvd3NlciBkZWZhdWx0cyBvbiB3aW5kb3csIGRvY3VtZW50IGFuZCBib2R5LlxuICogQnV0IHNpbmNlXG4gKiAtIHdlJ3JlIGRlbGVnYXRpbmcgdGhlbVxuICogLSB0aGV5IGhhcHBlbiBvZnRlblxuICogLSB0aGV5IGFwcGx5IHRvIG1vYmlsZSB3aGljaCBpcyBnZW5lcmFsbHkgbGVzcyBwZXJmb3JtYW50XG4gKiB3ZSdyZSBtYXJraW5nIHRoZW0gYXMgcGFzc2l2ZSBieSBkZWZhdWx0IGZvciBvdGhlciBlbGVtZW50cywgdG9vLlxuICovXG5jb25zdCBQQVNTSVZFX0VWRU5UUyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBwYXNzaXZlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcGFzc2l2ZV9ldmVudChuYW1lKSB7XG5cdHJldHVybiBQQVNTSVZFX0VWRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgQ09OVEVOVF9FRElUQUJMRV9CSU5ESU5HUyA9IFsndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJywgJ2lubmVyVGV4dCddO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19jb250ZW50X2VkaXRhYmxlX2JpbmRpbmcobmFtZSkge1xuXHRyZXR1cm4gQ09OVEVOVF9FRElUQUJMRV9CSU5ESU5HUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgTE9BRF9FUlJPUl9FTEVNRU5UUyA9IFtcblx0J2JvZHknLFxuXHQnZW1iZWQnLFxuXHQnaWZyYW1lJyxcblx0J2ltZycsXG5cdCdsaW5rJyxcblx0J29iamVjdCcsXG5cdCdzY3JpcHQnLFxuXHQnc3R5bGUnLFxuXHQndHJhY2snXG5dO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbGVtZW50IGVtaXRzIGBsb2FkYCBhbmQgYGVycm9yYCBldmVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19sb2FkX2Vycm9yX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gTE9BRF9FUlJPUl9FTEVNRU5UUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuY29uc3QgU1ZHX0VMRU1FTlRTID0gW1xuXHQnYWx0R2x5cGgnLFxuXHQnYWx0R2x5cGhEZWYnLFxuXHQnYWx0R2x5cGhJdGVtJyxcblx0J2FuaW1hdGUnLFxuXHQnYW5pbWF0ZUNvbG9yJyxcblx0J2FuaW1hdGVNb3Rpb24nLFxuXHQnYW5pbWF0ZVRyYW5zZm9ybScsXG5cdCdjaXJjbGUnLFxuXHQnY2xpcFBhdGgnLFxuXHQnY29sb3ItcHJvZmlsZScsXG5cdCdjdXJzb3InLFxuXHQnZGVmcycsXG5cdCdkZXNjJyxcblx0J2Rpc2NhcmQnLFxuXHQnZWxsaXBzZScsXG5cdCdmZUJsZW5kJyxcblx0J2ZlQ29sb3JNYXRyaXgnLFxuXHQnZmVDb21wb25lbnRUcmFuc2ZlcicsXG5cdCdmZUNvbXBvc2l0ZScsXG5cdCdmZUNvbnZvbHZlTWF0cml4Jyxcblx0J2ZlRGlmZnVzZUxpZ2h0aW5nJyxcblx0J2ZlRGlzcGxhY2VtZW50TWFwJyxcblx0J2ZlRGlzdGFudExpZ2h0Jyxcblx0J2ZlRHJvcFNoYWRvdycsXG5cdCdmZUZsb29kJyxcblx0J2ZlRnVuY0EnLFxuXHQnZmVGdW5jQicsXG5cdCdmZUZ1bmNHJyxcblx0J2ZlRnVuY1InLFxuXHQnZmVHYXVzc2lhbkJsdXInLFxuXHQnZmVJbWFnZScsXG5cdCdmZU1lcmdlJyxcblx0J2ZlTWVyZ2VOb2RlJyxcblx0J2ZlTW9ycGhvbG9neScsXG5cdCdmZU9mZnNldCcsXG5cdCdmZVBvaW50TGlnaHQnLFxuXHQnZmVTcGVjdWxhckxpZ2h0aW5nJyxcblx0J2ZlU3BvdExpZ2h0Jyxcblx0J2ZlVGlsZScsXG5cdCdmZVR1cmJ1bGVuY2UnLFxuXHQnZmlsdGVyJyxcblx0J2ZvbnQnLFxuXHQnZm9udC1mYWNlJyxcblx0J2ZvbnQtZmFjZS1mb3JtYXQnLFxuXHQnZm9udC1mYWNlLW5hbWUnLFxuXHQnZm9udC1mYWNlLXNyYycsXG5cdCdmb250LWZhY2UtdXJpJyxcblx0J2ZvcmVpZ25PYmplY3QnLFxuXHQnZycsXG5cdCdnbHlwaCcsXG5cdCdnbHlwaFJlZicsXG5cdCdoYXRjaCcsXG5cdCdoYXRjaHBhdGgnLFxuXHQnaGtlcm4nLFxuXHQnaW1hZ2UnLFxuXHQnbGluZScsXG5cdCdsaW5lYXJHcmFkaWVudCcsXG5cdCdtYXJrZXInLFxuXHQnbWFzaycsXG5cdCdtZXNoJyxcblx0J21lc2hncmFkaWVudCcsXG5cdCdtZXNocGF0Y2gnLFxuXHQnbWVzaHJvdycsXG5cdCdtZXRhZGF0YScsXG5cdCdtaXNzaW5nLWdseXBoJyxcblx0J21wYXRoJyxcblx0J3BhdGgnLFxuXHQncGF0dGVybicsXG5cdCdwb2x5Z29uJyxcblx0J3BvbHlsaW5lJyxcblx0J3JhZGlhbEdyYWRpZW50Jyxcblx0J3JlY3QnLFxuXHQnc2V0Jyxcblx0J3NvbGlkY29sb3InLFxuXHQnc3RvcCcsXG5cdCdzdmcnLFxuXHQnc3dpdGNoJyxcblx0J3N5bWJvbCcsXG5cdCd0ZXh0Jyxcblx0J3RleHRQYXRoJyxcblx0J3RyZWYnLFxuXHQndHNwYW4nLFxuXHQndW5rbm93bicsXG5cdCd1c2UnLFxuXHQndmlldycsXG5cdCd2a2Vybidcbl07XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3N2ZyhuYW1lKSB7XG5cdHJldHVybiBTVkdfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE1BVEhNTF9FTEVNRU5UUyA9IFtcblx0J2Fubm90YXRpb24nLFxuXHQnYW5ub3RhdGlvbi14bWwnLFxuXHQnbWFjdGlvbicsXG5cdCdtYXRoJyxcblx0J21lcnJvcicsXG5cdCdtZnJhYycsXG5cdCdtaScsXG5cdCdtbXVsdGlzY3JpcHRzJyxcblx0J21uJyxcblx0J21vJyxcblx0J21vdmVyJyxcblx0J21wYWRkZWQnLFxuXHQnbXBoYW50b20nLFxuXHQnbXByZXNjcmlwdHMnLFxuXHQnbXJvb3QnLFxuXHQnbXJvdycsXG5cdCdtcycsXG5cdCdtc3BhY2UnLFxuXHQnbXNxcnQnLFxuXHQnbXN0eWxlJyxcblx0J21zdWInLFxuXHQnbXN1YnN1cCcsXG5cdCdtc3VwJyxcblx0J210YWJsZScsXG5cdCdtdGQnLFxuXHQnbXRleHQnLFxuXHQnbXRyJyxcblx0J211bmRlcicsXG5cdCdtdW5kZXJvdmVyJyxcblx0J3NlbWFudGljcydcbl07XG5cbi8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX21hdGhtbChuYW1lKSB7XG5cdHJldHVybiBNQVRITUxfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFJVTkVTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcblx0JyRzdGF0ZScsXG5cdCckc3RhdGUucmF3Jyxcblx0JyRzdGF0ZS5zbmFwc2hvdCcsXG5cdCckcHJvcHMnLFxuXHQnJHByb3BzLmlkJyxcblx0JyRiaW5kYWJsZScsXG5cdCckZGVyaXZlZCcsXG5cdCckZGVyaXZlZC5ieScsXG5cdCckZWZmZWN0Jyxcblx0JyRlZmZlY3QucHJlJyxcblx0JyRlZmZlY3QudHJhY2tpbmcnLFxuXHQnJGVmZmVjdC5yb290Jyxcblx0JyRpbnNwZWN0Jyxcblx0JyRpbnNwZWN0KCkud2l0aCcsXG5cdCckaW5zcGVjdC50cmFjZScsXG5cdCckaG9zdCdcbl0pO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBSVU5FU1tudW1iZXJdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfcnVuZShuYW1lKSB7XG5cdHJldHVybiBSVU5FUy5pbmNsdWRlcygvKiogQHR5cGUge1JVTkVTW251bWJlcl19ICovIChuYW1lKSk7XG59XG5cbi8qKiBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgcmVxdWlyZSByYXcgY29udGVudHMgYW5kIHNob3VsZCBub3QgaGF2ZSBTU1IgY29tbWVudHMgcHV0IGluIHRoZW0gKi9cbmNvbnN0IFJBV19URVhUX0VMRU1FTlRTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3RpdGxlJ10pO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yYXdfdGV4dF9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIFJBV19URVhUX0VMRU1FTlRTLmluY2x1ZGVzKC8qKiBAdHlwZSB7UkFXX1RFWFRfRUxFTUVOVFNbbnVtYmVyXX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqXG4gKiBQcmV2ZW50IGRldnRvb2xzIHRyeWluZyB0byBtYWtlIGBsb2NhdGlvbmAgYSBjbGlja2FibGUgbGluayBieSBpbnNlcnRpbmcgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSB7XG5cdHJldHVybiBsb2NhdGlvbj8ucmVwbGFjZSgvXFwvL2csICcvXFx1MjAwYicpO1xufVxuIiwiaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNsZWFyX3RleHRfY29udGVudCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9mb2N1cyhkb20sIHZhbHVlKSB7XG5cdGlmICh2YWx1ZSkge1xuXHRcdGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHRcdGRvbS5hdXRvZm9jdXMgPSB0cnVlO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gYm9keSkge1xuXHRcdFx0XHRkb20uZm9jdXMoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBjaGlsZCBvZiBhIHRleHRhcmVhIGFjdHVhbGx5IGNvcnJlc3BvbmRzIHRvIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHksIHNvIHdlIG5lZWRcbiAqIHRvIHJlbW92ZSBpdCB1cG9uIGh5ZHJhdGlvbiB0byBhdm9pZCBhIGJ1ZyB3aGVuIHNvbWVvbmUgcmVzZXRzIHRoZSBmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtIVE1MVGV4dEFyZWFFbGVtZW50fSBkb21cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX3RleHRhcmVhX2NoaWxkKGRvbSkge1xuXHRpZiAoaHlkcmF0aW5nICYmIGdldF9maXJzdF9jaGlsZChkb20pICE9PSBudWxsKSB7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KGRvbSk7XG5cdH1cbn1cblxubGV0IGxpc3RlbmluZ190b19mb3JtX3Jlc2V0ID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRfZm9ybV9yZXNldF9saXN0ZW5lcigpIHtcblx0aWYgKCFsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCkge1xuXHRcdGxpc3RlbmluZ190b19mb3JtX3Jlc2V0ID0gdHJ1ZTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0J3Jlc2V0Jyxcblx0XHRcdChldnQpID0+IHtcblx0XHRcdFx0Ly8gTmVlZHMgdG8gaGFwcGVuIG9uZSB0aWNrIGxhdGVyIG9yIGVsc2UgdGhlIGRvbSBwcm9wZXJ0aWVzIG9mIHRoZSBmb3JtXG5cdFx0XHRcdC8vIGVsZW1lbnRzIGhhdmUgbm90IHVwZGF0ZWQgdG8gdGhlaXIgcmVzZXQgdmFsdWVzIHlldFxuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoIWV2dC5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGUgb2YgLyoqQHR5cGUge0hUTUxGb3JtRWxlbWVudH0gKi8gKGV2dC50YXJnZXQpLmVsZW1lbnRzKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdFx0ZS5fX29uX3I/LigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSW4gdGhlIGNhcHR1cmUgcGhhc2UgdG8gZ3VhcmFudGVlIHdlIGdldCBub3RpY2VkIG9mIGl0IChubyBwb3NzaWJsaXR5IG9mIHN0b3BQcm9wYWdhdGlvbilcblx0XHRcdHsgY2FwdHVyZTogdHJ1ZSB9XG5cdFx0KTtcblx0fVxufVxuIiwiaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyIH0gZnJvbSAnLi4vbWlzYy5qcyc7XG5cbi8qKlxuICogRmlyZXMgdGhlIGhhbmRsZXIgb25jZSBpbW1lZGlhdGVseSAodW5sZXNzIGNvcnJlc3BvbmRpbmcgYXJnIGlzIHNldCB0byBgZmFsc2VgKSxcbiAqIHRoZW4gbGlzdGVucyB0byB0aGUgZ2l2ZW4gZXZlbnRzIHVudGlsIHRoZSByZW5kZXIgZWZmZWN0IGNvbnRleHQgaXMgZGVzdHJveWVkXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzXG4gKiBAcGFyYW0geyhldmVudD86IEV2ZW50KSA9PiB2b2lkfSBoYW5kbGVyXG4gKiBAcGFyYW0ge2FueX0gY2FsbF9oYW5kbGVyX2ltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudHMsIGhhbmRsZXIsIGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSA9IHRydWUpIHtcblx0aWYgKGNhbGxfaGFuZGxlcl9pbW1lZGlhdGVseSkge1xuXHRcdGhhbmRsZXIoKTtcblx0fVxuXG5cdGZvciAodmFyIG5hbWUgb2YgZXZlbnRzKSB7XG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG5cdH1cblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Zm9yICh2YXIgbmFtZSBvZiBldmVudHMpIHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dChmbikge1xuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZm4oKTtcblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogTGlzdGVuIHRvIHRoZSBnaXZlbiBldmVudCwgYW5kIHRoZW4gaW5zdGFudGlhdGUgYSBnbG9iYWwgZm9ybSByZXNldCBsaXN0ZW5lciBpZiBub3QgYWxyZWFkeSBkb25lLFxuICogdG8gbm90aWZ5IGFsbCBiaW5kaW5ncyB3aGVuIHRoZSBmb3JtIGlzIHJlc2V0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7KGlzX3Jlc2V0PzogdHJ1ZSkgPT4gdm9pZH0gaGFuZGxlclxuICogQHBhcmFtIHsoaXNfcmVzZXQ/OiB0cnVlKSA9PiB2b2lkfSBbb25fcmVzZXRdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBvbl9yZXNldCA9IGhhbmRsZXIpIHtcblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCAoKSA9PiB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoaGFuZGxlcikpO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IHByZXYgPSBlbGVtZW50Ll9fb25fcjtcblx0aWYgKHByZXYpIHtcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIGNoZWNrYm94IHRoYXQgY2FuIGhhdmUgbXVsdGlwbGUgYmluZHMgKGdyb3VwICYgY2hlY2tlZClcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX29uX3IgPSAoKSA9PiB7XG5cdFx0XHRwcmV2KCk7XG5cdFx0XHRvbl9yZXNldCh0cnVlKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50Ll9fb25fciA9ICgpID0+IG9uX3Jlc2V0KHRydWUpO1xuXHR9XG5cblx0YWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKTtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgTG9jYXRpb24gfSBmcm9tICdsb2NhdGUtY2hhcmFjdGVyJyAqL1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0IH0gZnJvbSAnLi9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG4vKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuZXhwb3J0IGNvbnN0IGFsbF9yZWdpc3RlcmVkX2V2ZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtTZXQ8KGV2ZW50czogQXJyYXk8c3RyaW5nPikgPT4gdm9pZD59ICovXG5leHBvcnQgY29uc3Qgcm9vdF9ldmVudF9oYW5kbGVzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIFNTUiBhZGRzIG9ubG9hZCBhbmQgb25lcnJvciBhdHRyaWJ1dGVzIHRvIGNhdGNoIHRob3NlIGV2ZW50cyBiZWZvcmUgdGhlIGh5ZHJhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB0aG9zZSBjYXNlcywgcmVtb3ZlcyB0aGUgYXR0cmlidXRlcyBhbmQgcmVwbGF5cyB0aGUgZXZlbnRzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYXlfZXZlbnRzKGRvbSkge1xuXHRpZiAoIWh5ZHJhdGluZykgcmV0dXJuO1xuXG5cdGlmIChkb20ub25sb2FkKSB7XG5cdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25sb2FkJyk7XG5cdH1cblx0aWYgKGRvbS5vbmVycm9yKSB7XG5cdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25lcnJvcicpO1xuXHR9XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgZXZlbnQgPSBkb20uX19lO1xuXHRpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRkb20uX19lID0gdW5kZWZpbmVkO1xuXHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdGlmIChkb20uaXNDb25uZWN0ZWQpIHtcblx0XHRcdFx0ZG9tLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGRvbVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBbaGFuZGxlcl1cbiAqIEBwYXJhbSB7QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGRvbSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG5cdC8qKlxuXHQgKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG5cdCAqL1xuXHRmdW5jdGlvbiB0YXJnZXRfaGFuZGxlcigvKiogQHR5cGUge0V2ZW50fSAqLyBldmVudCkge1xuXHRcdGlmICghb3B0aW9ucy5jYXB0dXJlKSB7XG5cdFx0XHQvLyBPbmx5IGNhbGwgaW4gdGhlIGJ1YmJsZSBwaGFzZSwgZWxzZSBkZWxlZ2F0ZWQgZXZlbnRzIHdvdWxkIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGNhcHR1cmluZyBldmVudHNcblx0XHRcdGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbi5jYWxsKGRvbSwgZXZlbnQpO1xuXHRcdH1cblx0XHRpZiAoIWV2ZW50LmNhbmNlbEJ1YmJsZSkge1xuXHRcdFx0cmV0dXJuIHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyPy5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIENocm9tZSBoYXMgYSBidWcgd2hlcmUgcG9pbnRlciBldmVudHMgZG9uJ3Qgd29yayB3aGVuIGF0dGFjaGVkIHRvIGEgRE9NIGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBjbG9uZWRcblx0Ly8gd2l0aCBjbG9uZU5vZGUoKSBhbmQgdGhlIERPTSBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBkb2N1bWVudC4gVG8gZW5zdXJlIHRoZSBldmVudCB3b3Jrcywgd2Vcblx0Ly8gZGVmZXIgdGhlIGF0dGFjaG1lbnQgdGlsbCBhZnRlciBpdCdzIGJlZW4gYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50LiBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIENocm9tZSBmaXhlc1xuXHQvLyB0aGlzIGJ1Zy4gVGhlIHNhbWUgYXBwbGllcyB0byB3aGVlbCBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy5cblx0aWYgKFxuXHRcdGV2ZW50X25hbWUuc3RhcnRzV2l0aCgncG9pbnRlcicpIHx8XG5cdFx0ZXZlbnRfbmFtZS5zdGFydHNXaXRoKCd0b3VjaCcpIHx8XG5cdFx0ZXZlbnRfbmFtZSA9PT0gJ3doZWVsJ1xuXHQpIHtcblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0X2hhbmRsZXI7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50IGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBoYW5kbGVyLiBVc2luZyB0aGlzXG4gKiByYXRoZXIgdGhhbiBgYWRkRXZlbnRMaXN0ZW5lcmAgd2lsbCBwcmVzZXJ2ZSB0aGUgY29ycmVjdCBvcmRlciByZWxhdGl2ZSB0byBoYW5kbGVycyBhZGRlZCBkZWNsYXJhdGl2ZWx5XG4gKiAod2l0aCBhdHRyaWJ1dGVzIGxpa2UgYG9uY2xpY2tgKSwgd2hpY2ggdXNlIGV2ZW50IGRlbGVnYXRpb24gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBoYW5kbGVyXG4gKiBAcGFyYW0ge0FkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuXHR2YXIgdGFyZ2V0X2hhbmRsZXIgPSBjcmVhdGVfZXZlbnQodHlwZSwgZWxlbWVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBbaGFuZGxlcl1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhcHR1cmVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXNzaXZlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmVudChldmVudF9uYW1lLCBkb20sIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUpIHtcblx0dmFyIG9wdGlvbnMgPSB7IGNhcHR1cmUsIHBhc3NpdmUgfTtcblx0dmFyIHRhcmdldF9oYW5kbGVyID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGRvbSwgaGFuZGxlciwgb3B0aW9ucyk7XG5cblx0Ly8gQHRzLWlnbm9yZVxuXHRpZiAoZG9tID09PSBkb2N1bWVudC5ib2R5IHx8IGRvbSA9PT0gd2luZG93IHx8IGRvbSA9PT0gZG9jdW1lbnQpIHtcblx0XHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxlZ2F0ZShldmVudHMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhbGxfcmVnaXN0ZXJlZF9ldmVudHMuYWRkKGV2ZW50c1tpXSk7XG5cdH1cblxuXHRmb3IgKHZhciBmbiBvZiByb290X2V2ZW50X2hhbmRsZXMpIHtcblx0XHRmbihldmVudHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKGV2ZW50KSB7XG5cdHZhciBoYW5kbGVyX2VsZW1lbnQgPSB0aGlzO1xuXHR2YXIgb3duZXJfZG9jdW1lbnQgPSAvKiogQHR5cGUge05vZGV9ICovIChoYW5kbGVyX2VsZW1lbnQpLm93bmVyRG9jdW1lbnQ7XG5cdHZhciBldmVudF9uYW1lID0gZXZlbnQudHlwZTtcblx0dmFyIHBhdGggPSBldmVudC5jb21wb3NlZFBhdGg/LigpIHx8IFtdO1xuXHR2YXIgY3VycmVudF90YXJnZXQgPSAvKiogQHR5cGUge251bGwgfCBFbGVtZW50fSAqLyAocGF0aFswXSB8fCBldmVudC50YXJnZXQpO1xuXG5cdC8vIGNvbXBvc2VkUGF0aCBjb250YWlucyBsaXN0IG9mIG5vZGVzIHRoZSBldmVudCBoYXMgcHJvcGFnYXRlZCB0aHJvdWdoLlxuXHQvLyBXZSBjaGVjayBfX3Jvb3QgdG8gc2tpcCBhbGwgbm9kZXMgYmVsb3cgaXQgaW4gY2FzZSB0aGlzIGlzIGFcblx0Ly8gcGFyZW50IG9mIHRoZSBfX3Jvb3Qgbm9kZSwgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhlcmUncyBuZXN0ZWRcblx0Ly8gbW91bnRlZCBhcHBzLiBJbiB0aGlzIGNhc2Ugd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGV2ZW50cyBtdWx0aXBsZSB0aW1lcy5cblx0dmFyIHBhdGhfaWR4ID0gMDtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yIGlzIGFkZGVkIGJlbG93XG5cdHZhciBoYW5kbGVkX2F0ID0gZXZlbnQuX19yb290O1xuXG5cdGlmIChoYW5kbGVkX2F0KSB7XG5cdFx0dmFyIGF0X2lkeCA9IHBhdGguaW5kZXhPZihoYW5kbGVkX2F0KTtcblx0XHRpZiAoXG5cdFx0XHRhdF9pZHggIT09IC0xICYmXG5cdFx0XHQoaGFuZGxlcl9lbGVtZW50ID09PSBkb2N1bWVudCB8fCBoYW5kbGVyX2VsZW1lbnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAod2luZG93KSlcblx0XHQpIHtcblx0XHRcdC8vIFRoaXMgaXMgdGhlIGZhbGxiYWNrIGRvY3VtZW50IGxpc3RlbmVyIG9yIGEgd2luZG93IGxpc3RlbmVyLCBidXQgdGhlIGV2ZW50IHdhcyBhbHJlYWR5IGhhbmRsZWRcblx0XHRcdC8vIC0+IGlnbm9yZSwgYnV0IHNldCBoYW5kbGVfYXQgdG8gZG9jdW1lbnQvd2luZG93IHNvIHRoYXQgd2UncmUgcmVzZXR0aW5nIHRoZSBldmVudFxuXHRcdFx0Ly8gY2hhaW4gaW4gY2FzZSBzb21lb25lIG1hbnVhbGx5IGRpc3BhdGNoZXMgdGhlIHNhbWUgZXZlbnQgb2JqZWN0IGFnYWluLlxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0ZXZlbnQuX19yb290ID0gaGFuZGxlcl9lbGVtZW50O1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3Qgc2tpcHBpbmcgaWYgdGhlIGluZGV4IGlzIGhpZ2hlciwgYmVjYXVzZVxuXHRcdC8vIHNvbWVvbmUgY291bGQgY3JlYXRlIGFuIGV2ZW50IHByb2dyYW1tYXRpY2FsbHkgYW5kIGVtaXQgaXQgbXVsdGlwbGUgdGltZXMsXG5cdFx0Ly8gaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGhhbmRsZSB0aGUgd2hvbGUgcHJvcGFnYXRpb24gY2hhaW4gcHJvcGVybHkgZWFjaCB0aW1lLlxuXHRcdC8vICh0aGlzIHdpbGwgb25seSBiZSBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkIG11bHRpcGxlIHRpbWVzIGFuZFxuXHRcdC8vIHRoZSBmYWxsYmFjayBkb2N1bWVudCBsaXN0ZW5lciBpc24ndCByZWFjaGVkIGluIGJldHdlZW4sIGJ1dCB0aGF0J3Mgc3VwZXIgcmFyZSlcblx0XHR2YXIgaGFuZGxlcl9pZHggPSBwYXRoLmluZGV4T2YoaGFuZGxlcl9lbGVtZW50KTtcblx0XHRpZiAoaGFuZGxlcl9pZHggPT09IC0xKSB7XG5cdFx0XHQvLyBoYW5kbGVfaWR4IGNhbiB0aGVvcmV0aWNhbGx5IGJlIC0xIChoYXBwZW5lZCBpbiBzb21lIEpTRE9NIHRlc3Rpbmcgc2NlbmFyaW9zIHdpdGggYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHdpbmRvdyBvYmplY3QpXG5cdFx0XHQvLyBzbyBndWFyZCBhZ2FpbnN0IHRoYXQsIHRvbywgYW5kIGFzc3VtZSB0aGF0IGV2ZXJ5dGhpbmcgd2FzIGhhbmRsZWQgYXQgdGhpcyBwb2ludC5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoYXRfaWR4IDw9IGhhbmRsZXJfaWR4KSB7XG5cdFx0XHRwYXRoX2lkeCA9IGF0X2lkeDtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50X3RhcmdldCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKHBhdGhbcGF0aF9pZHhdIHx8IGV2ZW50LnRhcmdldCk7XG5cdC8vIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBkZWxlZ2F0ZWQgZXZlbnQgcGVyIGVsZW1lbnQsIGFuZCB3ZSBlaXRoZXIgYWxyZWFkeSBoYW5kbGVkIHRoZSBjdXJyZW50IHRhcmdldCxcblx0Ly8gb3IgdGhpcyBpcyB0aGUgdmVyeSBmaXJzdCB0YXJnZXQgaW4gdGhlIGNoYWluIHdoaWNoIGhhcyBhIG5vbi1kZWxlZ2F0ZWQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgaXQncyBzYWZlXG5cdC8vIHRvIGhhbmRsZSBhIHBvc3NpYmxlIGRlbGVnYXRlZCBldmVudCBvbiBpdCBsYXRlciAodGhyb3VnaCB0aGUgcm9vdCBkZWxlZ2F0aW9uIGxpc3RlbmVyIGZvciBleGFtcGxlKS5cblx0aWYgKGN1cnJlbnRfdGFyZ2V0ID09PSBoYW5kbGVyX2VsZW1lbnQpIHJldHVybjtcblxuXHQvLyBQcm94eSBjdXJyZW50VGFyZ2V0IHRvIGNvcnJlY3QgdGFyZ2V0XG5cdGRlZmluZV9wcm9wZXJ0eShldmVudCwgJ2N1cnJlbnRUYXJnZXQnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBjdXJyZW50X3RhcmdldCB8fCBvd25lcl9kb2N1bWVudDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFRoaXMgc3RhcnRlZCBiZWNhdXNlIG9mIENocm9taXVtIGlzc3VlIGh0dHBzOi8vY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzUxMjg2OTY4MjM1NDU4NTYsXG5cdC8vIHdoZXJlIHJlbW92YWwgb3IgbW92aW5nIG9mIG9mIHRoZSBET00gY2FuIGNhdXNlIHN5bmMgYGJsdXJgIGV2ZW50cyB0byBmaXJlLCB3aGljaCBjYW4gY2F1c2UgbG9naWNcblx0Ly8gdG8gcnVuIGluc2lkZSB0aGUgY3VycmVudCBgYWN0aXZlX3JlYWN0aW9uYCwgd2hpY2ggaXNuJ3Qgd2hhdCB3ZSB3YW50IGF0IGFsbC4gSG93ZXZlciwgb24gcmVmbGVjdGlvbixcblx0Ly8gaXQncyBwcm9iYWJseSBiZXN0IHRoYXQgYWxsIGV2ZW50IGhhbmRsZWQgYnkgU3ZlbHRlIGhhdmUgdGhpcyBiZWhhdmlvdXIsIGFzIHdlIGRvbid0IHJlYWxseSB3YW50XG5cdC8vIGFuIGV2ZW50IGhhbmRsZXIgdG8gcnVuIGluIHRoZSBjb250ZXh0IG9mIGFub3RoZXIgcmVhY3Rpb24gb3IgZWZmZWN0LlxuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblxuXHR0cnkge1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHt1bmtub3dufVxuXHRcdCAqL1xuXHRcdHZhciB0aHJvd19lcnJvcjtcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7dW5rbm93bltdfVxuXHRcdCAqL1xuXHRcdHZhciBvdGhlcl9lcnJvcnMgPSBbXTtcblxuXHRcdHdoaWxlIChjdXJyZW50X3RhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0LyoqIEB0eXBlIHtudWxsIHwgRWxlbWVudH0gKi9cblx0XHRcdHZhciBwYXJlbnRfZWxlbWVudCA9XG5cdFx0XHRcdGN1cnJlbnRfdGFyZ2V0LmFzc2lnbmVkU2xvdCB8fFxuXHRcdFx0XHRjdXJyZW50X3RhcmdldC5wYXJlbnROb2RlIHx8XG5cdFx0XHRcdC8qKiBAdHlwZSB7YW55fSAqLyAoY3VycmVudF90YXJnZXQpLmhvc3QgfHxcblx0XHRcdFx0bnVsbDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHR2YXIgZGVsZWdhdGVkID0gY3VycmVudF90YXJnZXRbJ19fJyArIGV2ZW50X25hbWVdO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRkZWxlZ2F0ZWQgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdCghKC8qKiBAdHlwZSB7YW55fSAqLyAoY3VycmVudF90YXJnZXQpLmRpc2FibGVkKSB8fFxuXHRcdFx0XHRcdFx0Ly8gRE9NIGNvdWxkJ3ZlIGJlZW4gdXBkYXRlZCBhbHJlYWR5IGJ5IHRoZSB0aW1lIHRoaXMgaXMgcmVhY2hlZCwgc28gd2UgY2hlY2sgdGhpcyBhcyB3ZWxsXG5cdFx0XHRcdFx0XHQvLyAtPiB0aGUgdGFyZ2V0IGNvdWxkIG5vdCBoYXZlIGJlZW4gZGlzYWJsZWQgYmVjYXVzZSBpdCBlbWl0cyB0aGUgZXZlbnQgaW4gdGhlIGZpcnN0IHBsYWNlXG5cdFx0XHRcdFx0XHRldmVudC50YXJnZXQgPT09IGN1cnJlbnRfdGFyZ2V0KVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRpZiAoaXNfYXJyYXkoZGVsZWdhdGVkKSkge1xuXHRcdFx0XHRcdFx0dmFyIFtmbiwgLi4uZGF0YV0gPSBkZWxlZ2F0ZWQ7XG5cdFx0XHRcdFx0XHRmbi5hcHBseShjdXJyZW50X3RhcmdldCwgW2V2ZW50LCAuLi5kYXRhXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRlbGVnYXRlZC5jYWxsKGN1cnJlbnRfdGFyZ2V0LCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdFx0XHRvdGhlcl9lcnJvcnMucHVzaChlcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3dfZXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50LmNhbmNlbEJ1YmJsZSB8fCBwYXJlbnRfZWxlbWVudCA9PT0gaGFuZGxlcl9lbGVtZW50IHx8IHBhcmVudF9lbGVtZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudF90YXJnZXQgPSBwYXJlbnRfZWxlbWVudDtcblx0XHR9XG5cblx0XHRpZiAodGhyb3dfZXJyb3IpIHtcblx0XHRcdGZvciAobGV0IGVycm9yIG9mIG90aGVyX2Vycm9ycykge1xuXHRcdFx0XHQvLyBUaHJvdyB0aGUgcmVzdCBvZiB0aGUgZXJyb3JzLCBvbmUtYnktb25lIG9uIGEgbWljcm90YXNrXG5cdFx0XHRcdHF1ZXVlTWljcm90YXNrKCgpID0+IHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyB0aHJvd19lcnJvcjtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBpcyB1c2VkIGFib3ZlXG5cdFx0ZXZlbnQuX19yb290ID0gaGFuZGxlcl9lbGVtZW50O1xuXHRcdC8vIEB0cy1pZ25vcmUgcmVtb3ZlIHByb3h5IG9uIGN1cnJlbnRUYXJnZXRcblx0XHRkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2LCB3YXJuIGlmIGFuIGV2ZW50IGhhbmRsZXIgaXMgbm90IGEgZnVuY3Rpb24sIGFzIGl0IG1lYW5zIHRoZVxuICogdXNlciBwcm9iYWJseSBjYWxsZWQgdGhlIGhhbmRsZXIgb3IgZm9yZ290IHRvIGFkZCBhIGAoKSA9PmBcbiAqIEBwYXJhbSB7KCkgPT4gKGV2ZW50OiBFdmVudCwgLi4uYXJnczogYW55KSA9PiB2b2lkfSB0aHVua1xuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudFxuICogQHBhcmFtIHtbRXZlbnQsIC4uLmFueV19IGFyZ3NcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7W251bWJlciwgbnVtYmVyXX0gW2xvY11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZV9wYXJlbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseShcblx0dGh1bmssXG5cdGVsZW1lbnQsXG5cdGFyZ3MsXG5cdGNvbXBvbmVudCxcblx0bG9jLFxuXHRoYXNfc2lkZV9lZmZlY3RzID0gZmFsc2UsXG5cdHJlbW92ZV9wYXJlbnMgPSBmYWxzZVxuKSB7XG5cdGxldCBoYW5kbGVyO1xuXHRsZXQgZXJyb3I7XG5cblx0dHJ5IHtcblx0XHRoYW5kbGVyID0gdGh1bmsoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGVycm9yID0gZTtcblx0fVxuXG5cdGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhhbmRsZXIuYXBwbHkoZWxlbWVudCwgYXJncyk7XG5cdH0gZWxzZSBpZiAoaGFzX3NpZGVfZWZmZWN0cyB8fCBoYW5kbGVyICE9IG51bGwgfHwgZXJyb3IpIHtcblx0XHRjb25zdCBmaWxlbmFtZSA9IGNvbXBvbmVudD8uW0ZJTEVOQU1FXTtcblx0XHRjb25zdCBsb2NhdGlvbiA9IGxvYyA/IGAgYXQgJHtmaWxlbmFtZX06JHtsb2NbMF19OiR7bG9jWzFdfWAgOiBgIGluICR7ZmlsZW5hbWV9YDtcblxuXHRcdGNvbnN0IGV2ZW50X25hbWUgPSBhcmdzWzBdLnR5cGU7XG5cdFx0Y29uc3QgZGVzY3JpcHRpb24gPSBgXFxgJHtldmVudF9uYW1lfVxcYCBoYW5kbGVyJHtsb2NhdGlvbn1gO1xuXHRcdGNvbnN0IHN1Z2dlc3Rpb24gPSByZW1vdmVfcGFyZW5zID8gJ3JlbW92ZSB0aGUgdHJhaWxpbmcgYCgpYCcgOiAnYWRkIGEgbGVhZGluZyBgKCkgPT5gJztcblxuXHRcdHcuZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGRlc2NyaXB0aW9uLCBzdWdnZXN0aW9uKTtcblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59XG4iLCIvKiogQHBhcmFtIHtzdHJpbmd9IGh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpIHtcblx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRlbGVtLmlubmVySFRNTCA9IGh0bWw7XG5cdHJldHVybiBlbGVtLmNvbnRlbnQ7XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkLCBpc19maXJlZm94IH0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgVEVNUExBVEVfRlJBR01FTlQsIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZSB8IG51bGx9IGVuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpIHtcblx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cdGlmIChlZmZlY3Qubm9kZXNfc3RhcnQgPT09IG51bGwpIHtcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBzdGFydDtcblx0XHRlZmZlY3Qubm9kZXNfZW5kID0gZW5kO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHVzZV9pbXBvcnRfbm9kZSA9IChmbGFncyAmIFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHtOb2RlfSAqL1xuXHR2YXIgbm9kZTtcblxuXHQvKipcblx0ICogV2hldGhlciBvciBub3QgdGhlIGZpcnN0IGl0ZW0gaXMgYSB0ZXh0L2VsZW1lbnQgbm9kZS4gSWYgbm90LCB3ZSBuZWVkIHRvXG5cdCAqIGNyZWF0ZSBhbiBhZGRpdGlvbmFsIGNvbW1lbnQgbm9kZSB0byBhY3QgYXMgYGVmZmVjdC5ub2Rlcy5zdGFydGBcblx0ICovXG5cdHZhciBoYXNfc3RhcnQgPSAhY29udGVudC5zdGFydHNXaXRoKCc8IT4nKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChoYXNfc3RhcnQgPyBjb250ZW50IDogJzwhPicgKyBjb250ZW50KTtcblx0XHRcdGlmICghaXNfZnJhZ21lbnQpIG5vZGUgPSAvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpO1xuXHRcdH1cblxuXHRcdHZhciBjbG9uZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoXG5cdFx0XHR1c2VfaW1wb3J0X25vZGUgfHwgaXNfZmlyZWZveCA/IGRvY3VtZW50LmltcG9ydE5vZGUobm9kZSwgdHJ1ZSkgOiBub2RlLmNsb25lTm9kZSh0cnVlKVxuXHRcdCk7XG5cblx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdHZhciBzdGFydCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGNsb25lKSk7XG5cdFx0XHR2YXIgZW5kID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjbG9uZS5sYXN0Q2hpbGQpO1xuXG5cdFx0XHRhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhjbG9uZSwgY2xvbmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcmV0dXJucyB7KCkgPT4gTm9kZSB8IE5vZGVbXX1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVfd2l0aF9zY3JpcHQoY29udGVudCwgZmxhZ3MpIHtcblx0dmFyIGZuID0gdGVtcGxhdGUoY29udGVudCwgZmxhZ3MpO1xuXHRyZXR1cm4gKCkgPT4gcnVuX3NjcmlwdHMoLyoqIEB0eXBlIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gKi8gKGZuKCkpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geydzdmcnIHwgJ21hdGgnfSBuc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG5zX3RlbXBsYXRlKGNvbnRlbnQsIGZsYWdzLCBucyA9ICdzdmcnKSB7XG5cdC8qKlxuXHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZmlyc3QgaXRlbSBpcyBhIHRleHQvZWxlbWVudCBub2RlLiBJZiBub3QsIHdlIG5lZWQgdG9cblx0ICogY3JlYXRlIGFuIGFkZGl0aW9uYWwgY29tbWVudCBub2RlIHRvIGFjdCBhcyBgZWZmZWN0Lm5vZGVzLnN0YXJ0YFxuXHQgKi9cblx0dmFyIGhhc19zdGFydCA9ICFjb250ZW50LnN0YXJ0c1dpdGgoJzwhPicpO1xuXG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHdyYXBwZWQgPSBgPCR7bnN9PiR7aGFzX3N0YXJ0ID8gY29udGVudCA6ICc8IT4nICsgY29udGVudH08LyR7bnN9PmA7XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gKi9cblx0dmFyIG5vZGU7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKHdyYXBwZWQpKTtcblx0XHRcdHZhciByb290ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGZyYWdtZW50KSk7XG5cblx0XHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR3aGlsZSAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZCgvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChyb290KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNsb25lID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG5cblx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdHZhciBzdGFydCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGNsb25lKSk7XG5cdFx0XHR2YXIgZW5kID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjbG9uZS5sYXN0Q2hpbGQpO1xuXG5cdFx0XHRhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhjbG9uZSwgY2xvbmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcmV0dXJucyB7KCkgPT4gTm9kZSB8IE5vZGVbXX1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gc3ZnX3RlbXBsYXRlX3dpdGhfc2NyaXB0KGNvbnRlbnQsIGZsYWdzKSB7XG5cdHZhciBmbiA9IG5zX3RlbXBsYXRlKGNvbnRlbnQsIGZsYWdzKTtcblx0cmV0dXJuICgpID0+IHJ1bl9zY3JpcHRzKC8qKiBAdHlwZSB7RWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9ICovIChmbigpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGhtbF90ZW1wbGF0ZShjb250ZW50LCBmbGFncykge1xuXHRyZXR1cm4gbnNfdGVtcGxhdGUoY29udGVudCwgZmxhZ3MsICdtYXRoJyk7XG59XG5cbi8qKlxuICogQ3JlYXRpbmcgYSBkb2N1bWVudCBmcmFnbWVudCBmcm9tIEhUTUwgdGhhdCBjb250YWlucyBzY3JpcHQgdGFncyB3aWxsIG5vdCBleGVjdXRlXG4gKiB0aGUgc2NyaXB0cy4gV2UgbmVlZCB0byByZXBsYWNlIHRoZSBzY3JpcHQgdGFncyB3aXRoIG5ldyBvbmVzIHNvIHRoYXQgdGhleSBhcmUgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7Tm9kZSB8IE5vZGVbXX1cbiAqL1xuZnVuY3Rpb24gcnVuX3NjcmlwdHMobm9kZSkge1xuXHQvLyBzY3JpcHRzIHdlcmUgU1NSJ2QsIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIHJ1blxuXHRpZiAoaHlkcmF0aW5nKSByZXR1cm4gbm9kZTtcblxuXHRjb25zdCBpc19mcmFnbWVudCA9IG5vZGUubm9kZVR5cGUgPT09IDExO1xuXHRjb25zdCBzY3JpcHRzID1cblx0XHQvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSkudGFnTmFtZSA9PT0gJ1NDUklQVCdcblx0XHRcdD8gWy8qKiBAdHlwZSB7SFRNTFNjcmlwdEVsZW1lbnR9ICovIChub2RlKV1cblx0XHRcdDogbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcblx0Y29uc3QgZWZmZWN0ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KTtcblxuXHRmb3IgKGNvbnN0IHNjcmlwdCBvZiBzY3JpcHRzKSB7XG5cdFx0Y29uc3QgY2xvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRmb3IgKHZhciBhdHRyaWJ1dGUgb2Ygc2NyaXB0LmF0dHJpYnV0ZXMpIHtcblx0XHRcdGNsb25lLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcblx0XHR9XG5cblx0XHRjbG9uZS50ZXh0Q29udGVudCA9IHNjcmlwdC50ZXh0Q29udGVudDtcblxuXHRcdC8vIFRoZSBzY3JpcHQgaGFzIGNoYW5nZWQgLSBpZiBpdCdzIGF0IHRoZSBlZGdlcywgdGhlIGVmZmVjdCBub3cgcG9pbnRzIGF0IGRlYWQgbm9kZXNcblx0XHRpZiAoaXNfZnJhZ21lbnQgPyBub2RlLmZpcnN0Q2hpbGQgPT09IHNjcmlwdCA6IG5vZGUgPT09IHNjcmlwdCkge1xuXHRcdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID0gY2xvbmU7XG5cdFx0fVxuXHRcdGlmIChpc19mcmFnbWVudCA/IG5vZGUubGFzdENoaWxkID09PSBzY3JpcHQgOiBub2RlID09PSBzY3JpcHQpIHtcblx0XHRcdGVmZmVjdC5ub2Rlc19lbmQgPSBjbG9uZTtcblx0XHR9XG5cblx0XHRzY3JpcHQucmVwbGFjZVdpdGgoY2xvbmUpO1xuXHR9XG5cdHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIERvbid0IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdC1mcmVlLCBoeWRyYXRpb24gbmVlZHMgdG8gd2FsayBhbGwgbm9kZXNcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dCh2YWx1ZSA9ICcnKSB7XG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0dmFyIHQgPSBjcmVhdGVfdGV4dCh2YWx1ZSArICcnKTtcblx0XHRhc3NpZ25fbm9kZXModCwgdCk7XG5cdFx0cmV0dXJuIHQ7XG5cdH1cblxuXHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHRpZiAobm9kZS5ub2RlVHlwZSAhPT0gMykge1xuXHRcdC8vIGlmIGFuIHtleHByZXNzaW9ufSBpcyBlbXB0eSBkdXJpbmcgU1NSLCB3ZSBuZWVkIHRvIGluc2VydCBhbiBlbXB0eSB0ZXh0IG5vZGVcblx0XHRub2RlLmJlZm9yZSgobm9kZSA9IGNyZWF0ZV90ZXh0KCkpKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKG5vZGUpO1xuXHR9XG5cblx0YXNzaWduX25vZGVzKG5vZGUsIG5vZGUpO1xuXHRyZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1lbnQoKSB7XG5cdC8vIHdlJ3JlIG5vdCBkZWxlZ2F0aW5nIHRvIGB0ZW1wbGF0ZWAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0cmV0dXJuIGh5ZHJhdGVfbm9kZTtcblx0fVxuXG5cdHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHR2YXIgc3RhcnQgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKTtcblx0dmFyIGFuY2hvciA9IGNyZWF0ZV90ZXh0KCk7XG5cdGZyYWcuYXBwZW5kKHN0YXJ0LCBhbmNob3IpO1xuXG5cdGFzc2lnbl9ub2RlcyhzdGFydCwgYW5jaG9yKTtcblxuXHRyZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBBc3NpZ24gdGhlIGNyZWF0ZWQgKG9yIGluIGh5ZHJhdGlvbiBtb2RlLCB0cmF2ZXJzZWQpIGRvbSBlbGVtZW50cyB0byB0aGUgY3VycmVudCBibG9ja1xuICogYW5kIGluc2VydCB0aGUgZWxlbWVudHMgaW50byB0aGUgZG9tIChpbiBjbGllbnQgbW9kZSkuXG4gKiBAcGFyYW0ge1RleHQgfCBDb21tZW50IHwgRWxlbWVudH0gYW5jaG9yXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBFbGVtZW50fSBkb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZChhbmNob3IsIGRvbSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGFuY2hvciA9PT0gbnVsbCkge1xuXHRcdC8vIGVkZ2UgY2FzZSDigJQgdm9pZCBgPHN2ZWx0ZTplbGVtZW50PmAgd2l0aCBjb250ZW50XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YW5jaG9yLmJlZm9yZSgvKiogQHR5cGUge05vZGV9ICovIChkb20pKTtcbn1cblxubGV0IHVpZCA9IDE7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldF9wcm9wc19pZCgpIHtcblx0dWlkID0gMTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgKG9yIGh5ZHJhdGUpIGFuIHVuaXF1ZSBVSUQgZm9yIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wc19pZCgpIHtcblx0aWYgKFxuXHRcdGh5ZHJhdGluZyAmJlxuXHRcdGh5ZHJhdGVfbm9kZSAmJlxuXHRcdGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gOCAmJlxuXHRcdGh5ZHJhdGVfbm9kZS50ZXh0Q29udGVudD8uc3RhcnRzV2l0aCgnI3MnKVxuXHQpIHtcblx0XHRjb25zdCBpZCA9IGh5ZHJhdGVfbm9kZS50ZXh0Q29udGVudC5zdWJzdHJpbmcoMSk7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0cmV0dXJuIGlkO1xuXHR9XG5cblx0cmV0dXJuICdjJyArIHVpZCsrO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0LCBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50VHlwZSwgU3ZlbHRlQ29tcG9uZW50LCBNb3VudE9wdGlvbnMgfSBmcm9tICcuLi8uLi9pbmRleC5qcycgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0Y2xlYXJfdGV4dF9jb250ZW50LFxuXHRjcmVhdGVfdGV4dCxcblx0Z2V0X2ZpcnN0X2NoaWxkLFxuXHRnZXRfbmV4dF9zaWJsaW5nLFxuXHRpbml0X29wZXJhdGlvbnNcbn0gZnJvbSAnLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fRU5ELCBIWURSQVRJT05fRVJST1IsIEhZRFJBVElPTl9TVEFSVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHB1c2gsIHBvcCwgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X3Jvb3QsIGJyYW5jaCB9IGZyb20gJy4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGFycmF5X2Zyb20gfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWxsX3JlZ2lzdGVyZWRfZXZlbnRzLFxuXHRoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sXG5cdHJvb3RfZXZlbnRfaGFuZGxlc1xufSBmcm9tICcuL2RvbS9lbGVtZW50cy9ldmVudHMuanMnO1xuaW1wb3J0IHsgcmVzZXRfaGVhZF9hbmNob3IgfSBmcm9tICcuL2RvbS9ibG9ja3Mvc3ZlbHRlLWhlYWQuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi9kb20vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgaXNfcGFzc2l2ZV9ldmVudCB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBUaGlzIGlzIG5vcm1hbGx5IHRydWUg4oCUIGJsb2NrIGVmZmVjdHMgc2hvdWxkIHJ1biB0aGVpciBpbnRybyB0cmFuc2l0aW9ucyDigJRcbiAqIGJ1dCBpcyBmYWxzZSBkdXJpbmcgaHlkcmF0aW9uICh1bmxlc3MgYG9wdGlvbnMuaW50cm9gIGlzIGB0cnVlYCkgYW5kXG4gKiB3aGVuIGNyZWF0aW5nIHRoZSBjaGlsZHJlbiBvZiBhIGA8c3ZlbHRlOmVsZW1lbnQ+YCB0aGF0IGp1c3QgY2hhbmdlZCB0YWdcbiAqL1xuZXhwb3J0IGxldCBzaG91bGRfaW50cm8gPSB0cnVlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zaG91bGRfaW50cm8odmFsdWUpIHtcblx0c2hvdWxkX2ludHJvID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3RleHQodGV4dCwgdmFsdWUpIHtcblx0Ly8gRm9yIG9iamVjdHMsIHdlIGFwcGx5IHN0cmluZyBjb2VyY2lvbiAod2hpY2ggbWlnaHQgbWFrZSB0aGluZ3MgbGlrZSAkc3RhdGUgYXJyYXkgcmVmZXJlbmNlcyBpbiB0aGUgdGVtcGxhdGUgcmVhY3RpdmUpIGJlZm9yZSBkaWZmaW5nXG5cdHZhciBzdHIgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgKyAnJyA6IHZhbHVlO1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlmIChzdHIgIT09ICh0ZXh0Ll9fdCA/Pz0gdGV4dC5ub2RlVmFsdWUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHQuX190ID0gc3RyO1xuXHRcdHRleHQubm9kZVZhbHVlID0gc3RyICsgJyc7XG5cdH1cbn1cblxuLyoqXG4gKiBNb3VudHMgYSBjb21wb25lbnQgdG8gdGhlIGdpdmVuIHRhcmdldCBhbmQgcmV0dXJucyB0aGUgZXhwb3J0cyBhbmQgcG90ZW50aWFsbHkgdGhlIHByb3BzIChpZiBjb21waWxlZCB3aXRoIGBhY2Nlc3NvcnM6IHRydWVgKSBvZiB0aGUgY29tcG9uZW50LlxuICogVHJhbnNpdGlvbnMgd2lsbCBwbGF5IGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIgdW5sZXNzIHRoZSBgaW50cm9gIG9wdGlvbiBpcyBzZXQgdG8gYGZhbHNlYC5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEBwYXJhbSB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHM+PiB8IENvbXBvbmVudDxQcm9wcywgRXhwb3J0cywgYW55Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge01vdW50T3B0aW9uczxQcm9wcz59IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFeHBvcnRzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbW91bnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdHJldHVybiBfbW91bnQoY29tcG9uZW50LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBIeWRyYXRlcyBhIGNvbXBvbmVudCBvbiB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCByZXR1cm5zIHRoZSBleHBvcnRzIGFuZCBwb3RlbnRpYWxseSB0aGUgcHJvcHMgKGlmIGNvbXBpbGVkIHdpdGggYGFjY2Vzc29yczogdHJ1ZWApIG9mIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEBwYXJhbSB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHM+PiB8IENvbXBvbmVudDxQcm9wcywgRXhwb3J0cywgYW55Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge3t9IGV4dGVuZHMgUHJvcHMgPyB7XG4gKiBcdFx0dGFyZ2V0OiBEb2N1bWVudCB8IEVsZW1lbnQgfCBTaGFkb3dSb290O1xuICogXHRcdHByb3BzPzogUHJvcHM7XG4gKiBcdFx0ZXZlbnRzPzogUmVjb3JkPHN0cmluZywgKGU6IGFueSkgPT4gYW55PjtcbiAqICBcdGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+O1xuICogXHRcdGludHJvPzogYm9vbGVhbjtcbiAqIFx0XHRyZWNvdmVyPzogYm9vbGVhbjtcbiAqIFx0fSA6IHtcbiAqIFx0XHR0YXJnZXQ6IERvY3VtZW50IHwgRWxlbWVudCB8IFNoYWRvd1Jvb3Q7XG4gKiBcdFx0cHJvcHM6IFByb3BzO1xuICogXHRcdGV2ZW50cz86IFJlY29yZDxzdHJpbmcsIChlOiBhbnkpID0+IGFueT47XG4gKiAgXHRjb250ZXh0PzogTWFwPGFueSwgYW55PjtcbiAqIFx0XHRpbnRybz86IGJvb2xlYW47XG4gKiBcdFx0cmVjb3Zlcj86IGJvb2xlYW47XG4gKiBcdH19IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFeHBvcnRzfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZShjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0aW5pdF9vcGVyYXRpb25zKCk7XG5cdG9wdGlvbnMuaW50cm8gPSBvcHRpb25zLmludHJvID8/IGZhbHNlO1xuXHRjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcblx0Y29uc3Qgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblx0Y29uc3QgcHJldmlvdXNfaHlkcmF0ZV9ub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHRhcmdldCkpO1xuXHRcdHdoaWxlIChcblx0XHRcdGFuY2hvciAmJlxuXHRcdFx0KGFuY2hvci5ub2RlVHlwZSAhPT0gOCB8fCAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgIT09IEhZRFJBVElPTl9TVEFSVClcblx0XHQpIHtcblx0XHRcdGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhhbmNob3IpKTtcblx0XHR9XG5cblx0XHRpZiAoIWFuY2hvcikge1xuXHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdH1cblxuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpKTtcblx0XHRoeWRyYXRlX25leHQoKTtcblxuXHRcdGNvbnN0IGluc3RhbmNlID0gX21vdW50KGNvbXBvbmVudCwgeyAuLi5vcHRpb25zLCBhbmNob3IgfSk7XG5cblx0XHRpZiAoXG5cdFx0XHRoeWRyYXRlX25vZGUgPT09IG51bGwgfHxcblx0XHRcdGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSAhPT0gOCB8fFxuXHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhICE9PSBIWURSQVRJT05fRU5EXG5cdFx0KSB7XG5cdFx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdH1cblxuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXG5cdFx0cmV0dXJuIC8qKiAgQHR5cGUge0V4cG9ydHN9ICovIChpbnN0YW5jZSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKGVycm9yID09PSBIWURSQVRJT05fRVJST1IpIHtcblx0XHRcdGlmIChvcHRpb25zLnJlY292ZXIgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGUuaHlkcmF0aW9uX2ZhaWxlZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhbiBlcnJvciBvY2N1cmVkIGFib3ZlLCB0aGUgb3BlcmF0aW9ucyBtaWdodCBub3QgeWV0IGhhdmUgYmVlbiBpbml0aWFsaXNlZC5cblx0XHRcdGluaXRfb3BlcmF0aW9ucygpO1xuXHRcdFx0Y2xlYXJfdGV4dF9jb250ZW50KHRhcmdldCk7XG5cblx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG1vdW50KGNvbXBvbmVudCwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZmluYWxseSB7XG5cdFx0c2V0X2h5ZHJhdGluZyh3YXNfaHlkcmF0aW5nKTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHByZXZpb3VzX2h5ZHJhdGVfbm9kZSk7XG5cdFx0cmVzZXRfaGVhZF9hbmNob3IoKTtcblx0fVxufVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59ICovXG5jb25zdCBkb2N1bWVudF9saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFeHBvcnRzXG4gKiBAcGFyYW0ge0NvbXBvbmVudFR5cGU8U3ZlbHRlQ29tcG9uZW50PGFueT4+IHwgQ29tcG9uZW50PGFueT59IENvbXBvbmVudFxuICogQHBhcmFtIHtNb3VudE9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtFeHBvcnRzfVxuICovXG5mdW5jdGlvbiBfbW91bnQoQ29tcG9uZW50LCB7IHRhcmdldCwgYW5jaG9yLCBwcm9wcyA9IHt9LCBldmVudHMsIGNvbnRleHQsIGludHJvID0gdHJ1ZSB9KSB7XG5cdGluaXRfb3BlcmF0aW9ucygpO1xuXG5cdHZhciByZWdpc3RlcmVkX2V2ZW50cyA9IG5ldyBTZXQoKTtcblxuXHQvKiogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHMgKi9cblx0dmFyIGV2ZW50X2hhbmRsZSA9IChldmVudHMpID0+IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGV2ZW50X25hbWUgPSBldmVudHNbaV07XG5cblx0XHRcdGlmIChyZWdpc3RlcmVkX2V2ZW50cy5oYXMoZXZlbnRfbmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0cmVnaXN0ZXJlZF9ldmVudHMuYWRkKGV2ZW50X25hbWUpO1xuXG5cdFx0XHR2YXIgcGFzc2l2ZSA9IGlzX3Bhc3NpdmVfZXZlbnQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdC8vIEFkZCB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gYm90aCB0aGUgY29udGFpbmVyIGFuZCB0aGUgZG9jdW1lbnQuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIGxpc3RlbmVyIGVuc3VyZXMgd2UgY2F0Y2ggZXZlbnRzIGZyb20gd2l0aGluIGluIGNhc2Vcblx0XHRcdC8vIHRoZSBvdXRlciBjb250ZW50IHN0b3BzIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudC5cblx0XHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbiwgeyBwYXNzaXZlIH0pO1xuXG5cdFx0XHR2YXIgbiA9IGRvY3VtZW50X2xpc3RlbmVycy5nZXQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gVGhlIGRvY3VtZW50IGxpc3RlbmVyIGVuc3VyZXMgd2UgY2F0Y2ggZXZlbnRzIHRoYXQgb3JpZ2luYXRlIGZyb20gZWxlbWVudHMgdGhhdCB3ZXJlXG5cdFx0XHRcdC8vIG1hbnVhbGx5IG1vdmVkIG91dHNpZGUgb2YgdGhlIGNvbnRhaW5lciAoZS5nLiB2aWEgbWFudWFsIHBvcnRhbHMpLlxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbiwgeyBwYXNzaXZlIH0pO1xuXHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuc2V0KGV2ZW50X25hbWUsIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCBuICsgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGV2ZW50X2hhbmRsZShhcnJheV9mcm9tKGFsbF9yZWdpc3RlcmVkX2V2ZW50cykpO1xuXHRyb290X2V2ZW50X2hhbmRsZXMuYWRkKGV2ZW50X2hhbmRsZSk7XG5cblx0LyoqIEB0eXBlIHtFeHBvcnRzfSAqL1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIHdpbGwgYmUgZGVmaW5lZCBiZWNhdXNlIHRoZSByZW5kZXIgZWZmZWN0IHJ1bnMgc3luY2hyb25vdXNseVxuXHR2YXIgY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG5cdHZhciB1bm1vdW50ID0gY29tcG9uZW50X3Jvb3QoKCkgPT4ge1xuXHRcdHZhciBhbmNob3Jfbm9kZSA9IGFuY2hvciA/PyB0YXJnZXQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSk7XG5cblx0XHRicmFuY2goKCkgPT4ge1xuXHRcdFx0aWYgKGNvbnRleHQpIHtcblx0XHRcdFx0cHVzaCh7fSk7XG5cdFx0XHRcdHZhciBjdHggPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHR9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cdFx0XHRcdGN0eC5jID0gY29udGV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHQvLyBXZSBjYW4ndCBzcHJlYWQgdGhlIG9iamVjdCBvciBlbHNlIHdlJ2QgbG9zZSB0aGUgc3RhdGUgcHJveHkgc3R1ZmYsIGlmIGl0IGlzIG9uZVxuXHRcdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKHByb3BzKS4kJGV2ZW50cyA9IGV2ZW50cztcblx0XHRcdH1cblxuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRhc3NpZ25fbm9kZXMoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChhbmNob3Jfbm9kZSksIG51bGwpO1xuXHRcdFx0fVxuXG5cdFx0XHRzaG91bGRfaW50cm8gPSBpbnRybztcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHB1YmxpYyB0eXBpbmdzIGFyZSBub3Qgd2hhdCB0aGUgYWN0dWFsIGZ1bmN0aW9uIGxvb2tzIGxpa2Vcblx0XHRcdGNvbXBvbmVudCA9IENvbXBvbmVudChhbmNob3Jfbm9kZSwgcHJvcHMpIHx8IHt9O1xuXHRcdFx0c2hvdWxkX2ludHJvID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLm5vZGVzX2VuZCA9IGh5ZHJhdGVfbm9kZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvbnRleHQpIHtcblx0XHRcdFx0cG9wKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Zm9yICh2YXIgZXZlbnRfbmFtZSBvZiByZWdpc3RlcmVkX2V2ZW50cykge1xuXHRcdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24pO1xuXG5cdFx0XHRcdHZhciBuID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpKTtcblxuXHRcdFx0XHRpZiAoLS1uID09PSAwKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24pO1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5kZWxldGUoZXZlbnRfbmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCBuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyb290X2V2ZW50X2hhbmRsZXMuZGVsZXRlKGV2ZW50X2hhbmRsZSk7XG5cblx0XHRcdGlmIChhbmNob3Jfbm9kZSAhPT0gYW5jaG9yKSB7XG5cdFx0XHRcdGFuY2hvcl9ub2RlLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKGFuY2hvcl9ub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblxuXHRtb3VudGVkX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudCwgdW5tb3VudCk7XG5cdHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUmVmZXJlbmNlcyBvZiB0aGUgY29tcG9uZW50cyB0aGF0IHdlcmUgbW91bnRlZCBvciBoeWRyYXRlZC5cbiAqIFVzZXMgYSBgV2Vha01hcGAgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICovXG5sZXQgbW91bnRlZF9jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCB0aGF0IHdhcyBwcmV2aW91c2x5IG1vdW50ZWQgdXNpbmcgYG1vdW50YCBvciBgaHlkcmF0ZWAuXG4gKlxuICogU2luY2UgNS4xMy4wLCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgYHRydWVgLCBbdHJhbnNpdGlvbnNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS90cmFuc2l0aW9uKSB3aWxsIHBsYXkgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gKlxuICogUmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGFmdGVyIHRyYW5zaXRpb25zIGhhdmUgY29tcGxldGVkIGlmIGBvcHRpb25zLm91dHJvYCBpcyB0cnVlLCBvciBpbW1lZGlhdGVseSBvdGhlcndpc2UgKHByaW9yIHRvIDUuMTMuMCwgcmV0dXJucyBgdm9pZGApLlxuICpcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBtb3VudCwgdW5tb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG4gKiBpbXBvcnQgQXBwIGZyb20gJy4vQXBwLnN2ZWx0ZSc7XG4gKlxuICogY29uc3QgYXBwID0gbW91bnQoQXBwLCB7IHRhcmdldDogZG9jdW1lbnQuYm9keSB9KTtcbiAqXG4gKiAvLyBsYXRlci4uLlxuICogdW5tb3VudChhcHAsIHsgb3V0cm86IHRydWUgfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gY29tcG9uZW50XG4gKiBAcGFyYW0ge3sgb3V0cm8/OiBib29sZWFuIH19IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRjb25zdCBmbiA9IG1vdW50ZWRfY29tcG9uZW50cy5nZXQoY29tcG9uZW50KTtcblxuXHRpZiAoZm4pIHtcblx0XHRtb3VudGVkX2NvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudCk7XG5cdFx0cmV0dXJuIGZuKG9wdGlvbnMpO1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdHcubGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50KCk7XG5cdH1cblxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG4iLCIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRyZW1vdmVfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIHBhdXNlX2VmZmVjdCwgcmVzdW1lX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlRfRUxTRSwgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KGJyYW5jaDogKGZuOiAoYW5jaG9yOiBOb2RlKSA9PiB2b2lkLCBmbGFnPzogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZH0gZm5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Vsc2VpZl0gVHJ1ZSBpZiB0aGlzIGlzIGFuIGB7OmVsc2UgaWYgLi4ufWAgYmxvY2sgcmF0aGVyIHRoYW4gYW4gYHsjaWYgLi4ufWAsIGFzIHRoYXQgYWZmZWN0cyB3aGljaCB0cmFuc2l0aW9ucyBhcmUgY29uc2lkZXJlZCAnbG9jYWwnXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlmX2Jsb2NrKG5vZGUsIGZuLCBlbHNlaWYgPSBmYWxzZSkge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBjb25zZXF1ZW50X2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgYWx0ZXJuYXRlX2VmZmVjdCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtVTklOSVRJQUxJWkVEIHwgYm9vbGVhbiB8IG51bGx9ICovXG5cdHZhciBjb25kaXRpb24gPSBVTklOSVRJQUxJWkVEO1xuXG5cdHZhciBmbGFncyA9IGVsc2VpZiA/IEVGRkVDVF9UUkFOU1BBUkVOVCA6IDA7XG5cblx0dmFyIGhhc19icmFuY2ggPSBmYWxzZTtcblxuXHRjb25zdCBzZXRfYnJhbmNoID0gKC8qKiBAdHlwZSB7KGFuY2hvcjogTm9kZSkgPT4gdm9pZH0gKi8gZm4sIGZsYWcgPSB0cnVlKSA9PiB7XG5cdFx0aGFzX2JyYW5jaCA9IHRydWU7XG5cdFx0dXBkYXRlX2JyYW5jaChmbGFnLCBmbik7XG5cdH07XG5cblx0Y29uc3QgdXBkYXRlX2JyYW5jaCA9IChcblx0XHQvKiogQHR5cGUge2Jvb2xlYW4gfCBudWxsfSAqLyBuZXdfY29uZGl0aW9uLFxuXHRcdC8qKiBAdHlwZSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gKi8gZm5cblx0KSA9PiB7XG5cdFx0aWYgKGNvbmRpdGlvbiA9PT0gKGNvbmRpdGlvbiA9IG5ld19jb25kaXRpb24pKSByZXR1cm47XG5cblx0XHQvKiogV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGEgaHlkcmF0aW9uIG1pc21hdGNoLiBOZWVkcyB0byBiZSBhIGBsZXRgIG9yIGVsc2UgaXQgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgKi9cblx0XHRsZXQgbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGNvbnN0IGlzX2Vsc2UgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoISFjb25kaXRpb24gPT09IGlzX2Vsc2UpIHtcblx0XHRcdFx0Ly8gSHlkcmF0aW9uIG1pc21hdGNoOiByZW1vdmUgZXZlcnl0aGluZyBpbnNpZGUgdGhlIGFuY2hvciBhbmQgc3RhcnQgZnJlc2guXG5cdFx0XHRcdC8vIFRoaXMgY291bGQgaGFwcGVuIHdpdGggYHsjaWYgYnJvd3Nlcn0uLi57L2lmfWAsIGZvciBleGFtcGxlXG5cdFx0XHRcdGFuY2hvciA9IHJlbW92ZV9ub2RlcygpO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY29uZGl0aW9uKSB7XG5cdFx0XHRpZiAoY29uc2VxdWVudF9lZmZlY3QpIHtcblx0XHRcdFx0cmVzdW1lX2VmZmVjdChjb25zZXF1ZW50X2VmZmVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGZuKSB7XG5cdFx0XHRcdGNvbnNlcXVlbnRfZWZmZWN0ID0gYnJhbmNoKCgpID0+IGZuKGFuY2hvcikpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWx0ZXJuYXRlX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoYWx0ZXJuYXRlX2VmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdGFsdGVybmF0ZV9lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFsdGVybmF0ZV9lZmZlY3QpIHtcblx0XHRcdFx0cmVzdW1lX2VmZmVjdChhbHRlcm5hdGVfZWZmZWN0KTtcblx0XHRcdH0gZWxzZSBpZiAoZm4pIHtcblx0XHRcdFx0YWx0ZXJuYXRlX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBmbihhbmNob3IpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNvbnNlcXVlbnRfZWZmZWN0KSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChjb25zZXF1ZW50X2VmZmVjdCwgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnNlcXVlbnRfZWZmZWN0ID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBjb250aW51ZSBpbiBoeWRyYXRpb24gbW9kZVxuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGhhc19icmFuY2ggPSBmYWxzZTtcblx0XHRmbihzZXRfYnJhbmNoKTtcblx0XHRpZiAoIWhhc19icmFuY2gpIHtcblx0XHRcdHVwZGF0ZV9icmFuY2gobnVsbCwgbnVsbCk7XG5cdFx0fVxuXHR9LCBmbGFncyk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFYWNoSXRlbSwgRWFjaFN0YXRlLCBFZmZlY3QsIE1heWJlU291cmNlLCBTb3VyY2UsIFRlbXBsYXRlTm9kZSwgVHJhbnNpdGlvbk1hbmFnZXIsIFZhbHVlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7XG5cdEVBQ0hfSU5ERVhfUkVBQ1RJVkUsXG5cdEVBQ0hfSVNfQU5JTUFURUQsXG5cdEVBQ0hfSVNfQ09OVFJPTExFRCxcblx0RUFDSF9JVEVNX0lNTVVUQUJMRSxcblx0RUFDSF9JVEVNX1JFQUNUSVZFLFxuXHRIWURSQVRJT05fRU5ELFxuXHRIWURSQVRJT05fU1RBUlRfRUxTRVxufSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0cmVtb3ZlX25vZGVzLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQge1xuXHRjbGVhcl90ZXh0X2NvbnRlbnQsXG5cdGNyZWF0ZV90ZXh0LFxuXHRnZXRfZmlyc3RfY2hpbGQsXG5cdGdldF9uZXh0X3NpYmxpbmdcbn0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQge1xuXHRibG9jayxcblx0YnJhbmNoLFxuXHRkZXN0cm95X2VmZmVjdCxcblx0cnVuX291dF90cmFuc2l0aW9ucyxcblx0cGF1c2VfY2hpbGRyZW4sXG5cdHBhdXNlX2VmZmVjdCxcblx0cmVzdW1lX2VmZmVjdFxufSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgc291cmNlLCBtdXRhYmxlX3NvdXJjZSwgaW50ZXJuYWxfc2V0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGFycmF5X2Zyb20sIGlzX2FycmF5IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IElORVJUIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QsIGFjdGl2ZV9yZWFjdGlvbiwgZ2V0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRlcml2ZWRfc2FmZV9lcXVhbCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuXG4vKipcbiAqIFRoZSByb3cgb2YgYSBrZXllZCBlYWNoIGJsb2NrIHRoYXQgaXMgY3VycmVudGx5IHVwZGF0aW5nLiBXZSB0cmFjayB0aGlzXG4gKiBzbyB0aGF0IGBhbmltYXRlOmAgZGlyZWN0aXZlcyBoYXZlIHNvbWV0aGluZyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0b1xuICogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X2VhY2hfaXRlbSA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gaXRlbSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXJyZW50X2VhY2hfaXRlbShpdGVtKSB7XG5cdGN1cnJlbnRfZWFjaF9pdGVtID0gaXRlbTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gX1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KF8sIGkpIHtcblx0cmV0dXJuIGk7XG59XG5cbi8qKlxuICogUGF1c2UgbXVsdGlwbGUgZWZmZWN0cyBzaW11bHRhbmVvdXNseSwgYW5kIGNvb3JkaW5hdGUgdGhlaXJcbiAqIHN1YnNlcXVlbnQgZGVzdHJ1Y3Rpb24uIFVzZWQgaW4gZWFjaCBibG9ja3NcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbVtdfSBpdGVtc1xuICogQHBhcmFtIHtudWxsIHwgTm9kZX0gY29udHJvbGxlZF9hbmNob3JcbiAqIEBwYXJhbSB7TWFwPGFueSwgRWFjaEl0ZW0+fSBpdGVtc19tYXBcbiAqL1xuZnVuY3Rpb24gcGF1c2VfZWZmZWN0cyhzdGF0ZSwgaXRlbXMsIGNvbnRyb2xsZWRfYW5jaG9yLCBpdGVtc19tYXApIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0cGF1c2VfY2hpbGRyZW4oaXRlbXNbaV0uZSwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXHR9XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSBsZW5ndGggPiAwICYmIHRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCAmJiBjb250cm9sbGVkX2FuY2hvciAhPT0gbnVsbDtcblx0Ly8gSWYgd2UgaGF2ZSBhIGNvbnRyb2xsZWQgYW5jaG9yLCBpdCBtZWFucyB0aGF0IHRoZSBlYWNoIGJsb2NrIGlzIGluc2lkZSBhIHNpbmdsZVxuXHQvLyBET00gZWxlbWVudCwgc28gd2UgY2FuIGFwcGx5IGEgZmFzdC1wYXRoIGZvciBjbGVhcmluZyB0aGUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoXG5cdFx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovIChjb250cm9sbGVkX2FuY2hvcikucGFyZW50Tm9kZVxuXHRcdCk7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KHBhcmVudF9ub2RlKTtcblx0XHRwYXJlbnRfbm9kZS5hcHBlbmQoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoY29udHJvbGxlZF9hbmNob3IpKTtcblx0XHRpdGVtc19tYXAuY2xlYXIoKTtcblx0XHRsaW5rKHN0YXRlLCBpdGVtc1swXS5wcmV2LCBpdGVtc1tsZW5ndGggLSAxXS5uZXh0KTtcblx0fVxuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKCFpc19jb250cm9sbGVkKSB7XG5cdFx0XHRcdGl0ZW1zX21hcC5kZWxldGUoaXRlbS5rKTtcblx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0fVxuXHRcdFx0ZGVzdHJveV9lZmZlY3QoaXRlbS5lLCAhaXNfY29udHJvbGxlZCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudH0gbm9kZSBUaGUgbmV4dCBzaWJsaW5nIG5vZGUsIG9yIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGlzIGlzIGEgJ2NvbnRyb2xsZWQnIGJsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IE1heWJlU291cmNlPG51bWJlcj4pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG5vZGUsIGZsYWdzLCBnZXRfY29sbGVjdGlvbiwgZ2V0X2tleSwgcmVuZGVyX2ZuLCBmYWxsYmFja19mbiA9IG51bGwpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoU3RhdGV9ICovXG5cdHZhciBzdGF0ZSA9IHsgZmxhZ3MsIGl0ZW1zOiBuZXcgTWFwKCksIGZpcnN0OiBudWxsIH07XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwO1xuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSk7XG5cblx0XHRhbmNob3IgPSBoeWRyYXRpbmdcblx0XHRcdD8gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge0NvbW1lbnQgfCBUZXh0fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHBhcmVudF9ub2RlKSkpXG5cdFx0XHQ6IHBhcmVudF9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZmFsbGJhY2sgPSBudWxsO1xuXG5cdHZhciB3YXNfZW1wdHkgPSBmYWxzZTtcblxuXHQvLyBUT0RPOiBpZGVhbGx5IHdlIGNvdWxkIHVzZSBkZXJpdmVkIGZvciBydW5lcyBtb2RlIGJ1dCBiZWNhdXNlIG9mIHRoZSBhYmlsaXR5XG5cdC8vIHRvIHVzZSBhIHN0b3JlIHdoaWNoIGNhbiBiZSBtdXRhdGVkLCB3ZSBjYW4ndCBkbyB0aGF0IGhlcmUgYXMgbXV0YXRpbmcgYSBzdG9yZVxuXHQvLyB3aWxsIHN0aWxsIHJlc3VsdCBpbiB0aGUgY29sbGVjdGlvbiBhcnJheSBiZWluZyB0aGUgc2FtZSBmcm9tIHRoZSBzdG9yZVxuXHR2YXIgZWFjaF9hcnJheSA9IGRlcml2ZWRfc2FmZV9lcXVhbCgoKSA9PiB7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSBnZXRfY29sbGVjdGlvbigpO1xuXG5cdFx0cmV0dXJuIGlzX2FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IGNvbGxlY3Rpb24gPT0gbnVsbCA/IFtdIDogYXJyYXlfZnJvbShjb2xsZWN0aW9uKTtcblx0fSk7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdHZhciBhcnJheSA9IGdldChlYWNoX2FycmF5KTtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG5cdFx0aWYgKHdhc19lbXB0eSAmJiBsZW5ndGggPT09IDApIHtcblx0XHRcdC8vIGlnbm9yZSB1cGRhdGVzIGlmIHRoZSBhcnJheSBpcyBlbXB0eSxcblx0XHRcdC8vIGFuZCBpdCBhbHJlYWR5IHdhcyBlbXB0eSBvbiBwcmV2aW91cyBydW5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0d2FzX2VtcHR5ID0gbGVuZ3RoID09PSAwO1xuXG5cdFx0LyoqIGB0cnVlYCBpZiB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdGxldCBtaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0dmFyIGlzX2Vsc2UgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChhbmNob3IpLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoaXNfZWxzZSAhPT0gKGxlbmd0aCA9PT0gMCkpIHtcblx0XHRcdFx0Ly8gaHlkcmF0aW9uIG1pc21hdGNoIOKAlCByZW1vdmUgdGhlIHNlcnZlci1yZW5kZXJlZCBET00gYW5kIHN0YXJ0IG92ZXJcblx0XHRcdFx0YW5jaG9yID0gcmVtb3ZlX25vZGVzKCk7XG5cblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0bWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoaXMgaXMgc2VwYXJhdGUgdG8gdGhlIHByZXZpb3VzIGJsb2NrIGJlY2F1c2UgYGh5ZHJhdGluZ2AgbWlnaHQgY2hhbmdlXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdFx0XHR2YXIgcHJldiA9IG51bGw7XG5cblx0XHRcdC8qKiBAdHlwZSB7RWFjaEl0ZW19ICovXG5cdFx0XHR2YXIgaXRlbTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLm5vZGVUeXBlID09PSA4ICYmXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhID09PSBIWURSQVRJT05fRU5EXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIFRoZSBzZXJ2ZXIgcmVuZGVyZWQgZmV3ZXIgaXRlbXMgdGhhbiBleHBlY3RlZCxcblx0XHRcdFx0XHQvLyBzbyBicmVhayBvdXQgYW5kIGNvbnRpbnVlIGFwcGVuZGluZyBub24taHlkcmF0ZWQgaXRlbXNcblx0XHRcdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0XHR2YXIga2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRcdGl0ZW0gPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRoeWRyYXRlX25vZGUsXG5cdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0cHJldixcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdHJlbmRlcl9mbixcblx0XHRcdFx0XHRmbGFncyxcblx0XHRcdFx0XHRnZXRfY29sbGVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0XHRzdGF0ZS5pdGVtcy5zZXQoa2V5LCBpdGVtKTtcblxuXHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVtb3ZlIGV4Y2VzcyBub2Rlc1xuXHRcdFx0aWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShyZW1vdmVfbm9kZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHRcdHJlY29uY2lsZShhcnJheSwgc3RhdGUsIGFuY2hvciwgcmVuZGVyX2ZuLCBmbGFncywgZ2V0X2tleSwgZ2V0X2NvbGxlY3Rpb24pO1xuXHRcdH1cblxuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0aWYgKGxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoZmFsbGJhY2spIHtcblx0XHRcdFx0XHRyZXN1bWVfZWZmZWN0KGZhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IGJyYW5jaCgoKSA9PiBmYWxsYmFja19mbihhbmNob3IpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChmYWxsYmFjayAhPT0gbnVsbCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoZmFsbGJhY2ssICgpID0+IHtcblx0XHRcdFx0XHRmYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB3ZSBtb3VudCB0aGUgZWFjaCBibG9jayBmb3IgdGhlIGZpcnN0IHRpbWUsIHRoZSBjb2xsZWN0aW9uIHdvbid0IGJlXG5cdFx0Ly8gY29ubmVjdGVkIHRvIHRoaXMgZWZmZWN0IGFzIHRoZSBlZmZlY3QgaGFzbid0IGZpbmlzaGVkIHJ1bm5pbmcgeWV0IGFuZCBpdHMgZGVwc1xuXHRcdC8vIHdvbid0IGJlIGFzc2lnbmVkLiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgd2hlbiByZWNvbmNpbGluZyB0aGUgZWFjaCBibG9ja1xuXHRcdC8vIHRoYXQgYSBtdXRhdGlvbiBvY2N1cnJlZCBhbmQgaXQncyBtYWRlIHRoZSBjb2xsZWN0aW9uIE1BWUJFX0RJUlRZLCBzbyByZWFkaW5nIHRoZVxuXHRcdC8vIGNvbGxlY3Rpb24gYWdhaW4gY2FuIHByb3ZpZGUgY29uc2lzdGVuY3kgdG8gdGhlIHJlYWN0aXZlIGdyYXBoIGFnYWluIGFzIHRoZSBkZXJpdmVkc1xuXHRcdC8vIHdpbGwgbm93IGJlIGBDTEVBTmAuXG5cdFx0Z2V0KGVhY2hfYXJyYXkpO1xuXHR9KTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogQWRkLCByZW1vdmUsIG9yIHJlb3JkZXIgaXRlbXMgb3V0cHV0IGJ5IGFuIGVhY2ggYmxvY2sgYXMgaXRzIGlucHV0IGNoYW5nZXNcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0FycmF5PFY+fSBhcnJheVxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBDb21tZW50IHwgVGV4dH0gYW5jaG9yXG4gKiBAcGFyYW0geyhhbmNob3I6IE5vZGUsIGl0ZW06IE1heWJlU291cmNlPFY+LCBpbmRleDogbnVtYmVyIHwgU291cmNlPG51bWJlcj4sIGNvbGxlY3Rpb246ICgpID0+IFZbXSkgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KHZhbHVlOiBWLCBpbmRleDogbnVtYmVyKSA9PiBhbnl9IGdldF9rZXlcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJlY29uY2lsZShhcnJheSwgc3RhdGUsIGFuY2hvciwgcmVuZGVyX2ZuLCBmbGFncywgZ2V0X2tleSwgZ2V0X2NvbGxlY3Rpb24pIHtcblx0dmFyIGlzX2FuaW1hdGVkID0gKGZsYWdzICYgRUFDSF9JU19BTklNQVRFRCkgIT09IDA7XG5cdHZhciBzaG91bGRfdXBkYXRlID0gKGZsYWdzICYgKEVBQ0hfSVRFTV9SRUFDVElWRSB8IEVBQ0hfSU5ERVhfUkVBQ1RJVkUpKSAhPT0gMDtcblxuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR2YXIgaXRlbXMgPSBzdGF0ZS5pdGVtcztcblx0dmFyIGZpcnN0ID0gc3RhdGUuZmlyc3Q7XG5cdHZhciBjdXJyZW50ID0gZmlyc3Q7XG5cblx0LyoqIEB0eXBlIHt1bmRlZmluZWQgfCBTZXQ8RWFjaEl0ZW0+fSAqL1xuXHR2YXIgc2VlbjtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH0gKi9cblx0dmFyIHByZXYgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHRvX2FuaW1hdGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbVtdfSAqL1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIHN0YXNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge1Z9ICovXG5cdHZhciB2YWx1ZTtcblxuXHQvKiogQHR5cGUge2FueX0gKi9cblx0dmFyIGtleTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaXRlbTtcblxuXHQvKiogQHR5cGUge251bWJlcn0gKi9cblx0dmFyIGk7XG5cblx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0a2V5ID0gZ2V0X2tleSh2YWx1ZSwgaSk7XG5cdFx0XHRpdGVtID0gaXRlbXMuZ2V0KGtleSk7XG5cblx0XHRcdGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aXRlbS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdCh0b19hbmltYXRlID8/PSBuZXcgU2V0KCkpLmFkZChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdGl0ZW0gPSBpdGVtcy5nZXQoa2V5KTtcblxuXHRcdGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSBjdXJyZW50ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjdXJyZW50LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdFx0XHRwcmV2ID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdGNoaWxkX2FuY2hvcixcblx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdHByZXYsXG5cdFx0XHRcdHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGtleSxcblx0XHRcdFx0aSxcblx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRmbGFncyxcblx0XHRcdFx0Z2V0X2NvbGxlY3Rpb25cblx0XHRcdCk7XG5cblx0XHRcdGl0ZW1zLnNldChrZXksIHByZXYpO1xuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdGN1cnJlbnQgPSBwcmV2Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkX3VwZGF0ZSkge1xuXHRcdFx0dXBkYXRlX2l0ZW0oaXRlbSwgdmFsdWUsIGksIGZsYWdzKTtcblx0XHR9XG5cblx0XHRpZiAoKGl0ZW0uZS5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0XHRyZXN1bWVfZWZmZWN0KGl0ZW0uZSk7XG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0aXRlbS5hPy51bmZpeCgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5kZWxldGUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gIT09IGN1cnJlbnQpIHtcblx0XHRcdGlmIChzZWVuICE9PSB1bmRlZmluZWQgJiYgc2Vlbi5oYXMoaXRlbSkpIHtcblx0XHRcdFx0aWYgKG1hdGNoZWQubGVuZ3RoIDwgc3Rhc2hlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGxhdGVyIGl0ZW1zIHRvIHRoZSBmcm9udFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHN0YXNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGo7XG5cblx0XHRcdFx0XHRwcmV2ID0gc3RhcnQucHJldjtcblxuXHRcdFx0XHRcdHZhciBhID0gbWF0Y2hlZFswXTtcblx0XHRcdFx0XHR2YXIgYiA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRtb3ZlKG1hdGNoZWRbal0sIHN0YXJ0LCBhbmNob3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzdGFzaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRzZWVuLmRlbGV0ZShzdGFzaGVkW2pdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBhLnByZXYsIGIubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgYSk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYiwgc3RhcnQpO1xuXG5cdFx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHByZXYgPSBiO1xuXHRcdFx0XHRcdGkgLT0gMTtcblxuXHRcdFx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdFx0XHRzdGFzaGVkID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBlYXJsaWVyIGl0ZW1zIHRvIHRoZSBiYWNrXG5cdFx0XHRcdFx0c2Vlbi5kZWxldGUoaXRlbSk7XG5cdFx0XHRcdFx0bW92ZShpdGVtLCBjdXJyZW50LCBhbmNob3IpO1xuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0sIHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuayAhPT0ga2V5KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0IGFuZCBhbiBpdGVtIGhhcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGluZXJ0LFxuXHRcdFx0XHQvLyBza2lwIG92ZXIgYWRkaW5nIGl0IHRvIG91ciBzZWVuIFNldCBhcyB0aGUgaXRlbSBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcblx0XHRcdFx0aWYgKChjdXJyZW50LmUuZiAmIElORVJUKSA9PT0gMCkge1xuXHRcdFx0XHRcdChzZWVuID8/PSBuZXcgU2V0KCkpLmFkZChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFzaGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtID0gY3VycmVudDtcblx0XHR9XG5cblx0XHRtYXRjaGVkLnB1c2goaXRlbSk7XG5cdFx0cHJldiA9IGl0ZW07XG5cdFx0Y3VycmVudCA9IGl0ZW0ubmV4dDtcblx0fVxuXG5cdGlmIChjdXJyZW50ICE9PSBudWxsIHx8IHNlZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciB0b19kZXN0cm95ID0gc2VlbiA9PT0gdW5kZWZpbmVkID8gW10gOiBhcnJheV9mcm9tKHNlZW4pO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0LCB0aGVuIGluZXJ0IGVmZmVjdHMgYXJlIGN1cnJlbnRseSBvdXRyb2luZyBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWRcblx0XHRcdGlmICgoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0dG9fZGVzdHJveS5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdHJveV9sZW5ndGggPSB0b19kZXN0cm95Lmxlbmd0aDtcblxuXHRcdGlmIChkZXN0cm95X2xlbmd0aCA+IDApIHtcblx0XHRcdHZhciBjb250cm9sbGVkX2FuY2hvciA9IChmbGFncyAmIEVBQ0hfSVNfQ09OVFJPTExFRCkgIT09IDAgJiYgbGVuZ3RoID09PSAwID8gYW5jaG9yIDogbnVsbDtcblxuXHRcdFx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZXN0cm95X2xlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dG9fZGVzdHJveVtpXS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8uZml4KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGF1c2VfZWZmZWN0cyhzdGF0ZSwgdG9fZGVzdHJveSwgY29udHJvbGxlZF9hbmNob3IsIGl0ZW1zKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdGlmICh0b19hbmltYXRlID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XHRcdGZvciAoaXRlbSBvZiB0b19hbmltYXRlKSB7XG5cdFx0XHRcdGl0ZW0uYT8uYXBwbHkoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZmlyc3QgPSBzdGF0ZS5maXJzdCAmJiBzdGF0ZS5maXJzdC5lO1xuXHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmxhc3QgPSBwcmV2ICYmIHByZXYuZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VhY2hJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB1cGRhdGVfaXRlbShpdGVtLCB2YWx1ZSwgaW5kZXgsIHR5cGUpIHtcblx0aWYgKCh0eXBlICYgRUFDSF9JVEVNX1JFQUNUSVZFKSAhPT0gMCkge1xuXHRcdGludGVybmFsX3NldChpdGVtLnYsIHZhbHVlKTtcblx0fVxuXG5cdGlmICgodHlwZSAmIEVBQ0hfSU5ERVhfUkVBQ1RJVkUpICE9PSAwKSB7XG5cdFx0aW50ZXJuYWxfc2V0KC8qKiBAdHlwZSB7VmFsdWU8bnVtYmVyPn0gKi8gKGl0ZW0uaSksIGluZGV4KTtcblx0fSBlbHNlIHtcblx0XHRpdGVtLmkgPSBpbmRleDtcblx0fVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge05vZGV9IGFuY2hvclxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7dW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogViB8IFNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFZhbHVlPG51bWJlcj4sIGNvbGxlY3Rpb246ICgpID0+IFZbXSkgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHJldHVybnMge0VhY2hJdGVtfVxuICovXG5mdW5jdGlvbiBjcmVhdGVfaXRlbShcblx0YW5jaG9yLFxuXHRzdGF0ZSxcblx0cHJldixcblx0bmV4dCxcblx0dmFsdWUsXG5cdGtleSxcblx0aW5kZXgsXG5cdHJlbmRlcl9mbixcblx0ZmxhZ3MsXG5cdGdldF9jb2xsZWN0aW9uXG4pIHtcblx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHR2YXIgcmVhY3RpdmUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwO1xuXHR2YXIgbXV0YWJsZSA9IChmbGFncyAmIEVBQ0hfSVRFTV9JTU1VVEFCTEUpID09PSAwO1xuXG5cdHZhciB2ID0gcmVhY3RpdmUgPyAobXV0YWJsZSA/IG11dGFibGVfc291cmNlKHZhbHVlKSA6IHNvdXJjZSh2YWx1ZSkpIDogdmFsdWU7XG5cdHZhciBpID0gKGZsYWdzICYgRUFDSF9JTkRFWF9SRUFDVElWRSkgPT09IDAgPyBpbmRleCA6IHNvdXJjZShpbmRleCk7XG5cblx0aWYgKERFViAmJiByZWFjdGl2ZSkge1xuXHRcdC8vIEZvciB0cmFjaW5nIHB1cnBvc2VzLCB3ZSBuZWVkIHRvIGxpbmsgdGhlIHNvdXJjZSBzaWduYWwgd2UgY3JlYXRlIHdpdGggdGhlXG5cdFx0Ly8gY29sbGVjdGlvbiArIGluZGV4IHNvIHRoYXQgdHJhY2luZyB3b3JrcyBhcyBpbnRlbmRlZFxuXHRcdC8qKiBAdHlwZSB7VmFsdWV9ICovICh2KS5kZWJ1ZyA9ICgpID0+IHtcblx0XHRcdHZhciBjb2xsZWN0aW9uX2luZGV4ID0gdHlwZW9mIGkgPT09ICdudW1iZXInID8gaW5kZXggOiBpLnY7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0Z2V0X2NvbGxlY3Rpb24oKVtjb2xsZWN0aW9uX2luZGV4XTtcblx0XHR9O1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbX0gKi9cblx0dmFyIGl0ZW0gPSB7XG5cdFx0aSxcblx0XHR2LFxuXHRcdGs6IGtleSxcblx0XHRhOiBudWxsLFxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlOiBudWxsLFxuXHRcdHByZXYsXG5cdFx0bmV4dFxuXHR9O1xuXG5cdGN1cnJlbnRfZWFjaF9pdGVtID0gaXRlbTtcblxuXHR0cnkge1xuXHRcdGl0ZW0uZSA9IGJyYW5jaCgoKSA9PiByZW5kZXJfZm4oYW5jaG9yLCB2LCBpLCBnZXRfY29sbGVjdGlvbiksIGh5ZHJhdGluZyk7XG5cblx0XHRpdGVtLmUucHJldiA9IHByZXYgJiYgcHJldi5lO1xuXHRcdGl0ZW0uZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cblx0XHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdFx0c3RhdGUuZmlyc3QgPSBpdGVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmV2Lm5leHQgPSBpdGVtO1xuXHRcdFx0cHJldi5lLm5leHQgPSBpdGVtLmU7XG5cdFx0fVxuXG5cdFx0aWYgKG5leHQgIT09IG51bGwpIHtcblx0XHRcdG5leHQucHJldiA9IGl0ZW07XG5cdFx0XHRuZXh0LmUucHJldiA9IGl0ZW0uZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fSBmaW5hbGx5IHtcblx0XHRjdXJyZW50X2VhY2hfaXRlbSA9IHByZXZpb3VzX2VhY2hfaXRlbTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaEl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKiBAcGFyYW0ge1RleHQgfCBFbGVtZW50IHwgQ29tbWVudH0gYW5jaG9yXG4gKi9cbmZ1bmN0aW9uIG1vdmUoaXRlbSwgbmV4dCwgYW5jaG9yKSB7XG5cdHZhciBlbmQgPSBpdGVtLm5leHQgPyAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGl0ZW0ubmV4dC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblxuXHR2YXIgZGVzdCA9IG5leHQgPyAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5leHQuZS5ub2Rlc19zdGFydCkgOiBhbmNob3I7XG5cdHZhciBub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChpdGVtLmUubm9kZXNfc3RhcnQpO1xuXG5cdHdoaWxlIChub2RlICE9PSBlbmQpIHtcblx0XHR2YXIgbmV4dF9ub2RlID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblx0XHRkZXN0LmJlZm9yZShub2RlKTtcblx0XHRub2RlID0gbmV4dF9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqL1xuZnVuY3Rpb24gbGluayhzdGF0ZSwgcHJldiwgbmV4dCkge1xuXHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdHN0YXRlLmZpcnN0ID0gbmV4dDtcblx0fSBlbHNlIHtcblx0XHRwcmV2Lm5leHQgPSBuZXh0O1xuXHRcdHByZXYuZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cdH1cblxuXHRpZiAobmV4dCAhPT0gbnVsbCkge1xuXHRcdG5leHQucHJldiA9IHByZXY7XG5cdFx0bmV4dC5lLnByZXYgPSBwcmV2ICYmIHByZXYuZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgSFlEUkFUSU9OX0VSUk9SIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIGRlc3Ryb3lfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbCB9IGZyb20gJy4uL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYXNzaWduX25vZGVzIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBoYXNoLCBzYW5pdGl6ZV9sb2NhdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBnZXRfZmlyc3RfY2hpbGQsIGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gc2VydmVyX2hhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBjaGVja19oYXNoKGVsZW1lbnQsIHNlcnZlcl9oYXNoLCB2YWx1ZSkge1xuXHRpZiAoIXNlcnZlcl9oYXNoIHx8IHNlcnZlcl9oYXNoID09PSBoYXNoKFN0cmluZyh2YWx1ZSA/PyAnJykpKSByZXR1cm47XG5cblx0bGV0IGxvY2F0aW9uO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgbG9jID0gZWxlbWVudC5fX3N2ZWx0ZV9tZXRhPy5sb2M7XG5cdGlmIChsb2MpIHtcblx0XHRsb2NhdGlvbiA9IGBuZWFyICR7bG9jLmZpbGV9OiR7bG9jLmxpbmV9OiR7bG9jLmNvbHVtbn1gO1xuXHR9IGVsc2UgaWYgKGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbj8uW0ZJTEVOQU1FXSkge1xuXHRcdGxvY2F0aW9uID0gYGluICR7ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uW0ZJTEVOQU1FXX1gO1xuXHR9XG5cblx0dy5oeWRyYXRpb25faHRtbF9jaGFuZ2VkKHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50IHwgVGV4dCB8IENvbW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc3ZnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1hdGhtbFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sKG5vZGUsIGdldF92YWx1ZSwgc3ZnLCBtYXRobWwsIHNraXBfd2FybmluZykge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHR2YXIgdmFsdWUgPSAnJztcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGVmZmVjdDtcblxuXHRibG9jaygoKSA9PiB7XG5cdFx0aWYgKHZhbHVlID09PSAodmFsdWUgPSBnZXRfdmFsdWUoKSA/PyAnJykpIHtcblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGVmZmVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0ZWZmZWN0ID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuXHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3QgdHJ5aW5nIHRvIHJlcGFpciBtaXNtYXRjaGVzIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsXG5cdFx0XHRcdC8vIGFzIGl0J3MgY29zdGx5IGFuZCBlcnJvci1wcm9uZSAoYW5kIGl0J3MgYW4gZWRnZSBjYXNlIHRvIGhhdmUgYSBtaXNtYXRjaCBhbnl3YXkpXG5cdFx0XHRcdHZhciBoYXNoID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhO1xuXHRcdFx0XHR2YXIgbmV4dCA9IGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0XHR2YXIgbGFzdCA9IG5leHQ7XG5cblx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdG5leHQgIT09IG51bGwgJiZcblx0XHRcdFx0XHQobmV4dC5ub2RlVHlwZSAhPT0gOCB8fCAvKiogQHR5cGUge0NvbW1lbnR9ICovIChuZXh0KS5kYXRhICE9PSAnJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0bGFzdCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhuZXh0KSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0XHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdFx0Y2hlY2tfaGFzaCgvKiogQHR5cGUge0VsZW1lbnR9ICovIChuZXh0LnBhcmVudE5vZGUpLCBoYXNoLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBsYXN0KTtcblx0XHRcdFx0YW5jaG9yID0gc2V0X2h5ZHJhdGVfbm9kZShuZXh0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaHRtbCA9IHZhbHVlICsgJyc7XG5cdFx0XHRpZiAoc3ZnKSBodG1sID0gYDxzdmc+JHtodG1sfTwvc3ZnPmA7XG5cdFx0XHRlbHNlIGlmIChtYXRobWwpIGh0bWwgPSBgPG1hdGg+JHtodG1sfTwvbWF0aD5gO1xuXG5cdFx0XHQvLyBEb24ndCB1c2UgY3JlYXRlX2ZyYWdtZW50X3dpdGhfc2NyaXB0X2Zyb21faHRtbCBoZXJlIGJlY2F1c2UgdGhhdCB3b3VsZCBtZWFuIHNjcmlwdCB0YWdzIGFyZSBleGVjdXRlZC5cblx0XHRcdC8vIEBodG1sIGlzIGJhc2ljYWxseSBgLmlubmVySFRNTCA9IC4uLmAgYW5kIHRoYXQgZG9lc24ndCBleGVjdXRlIHNjcmlwdHMgZWl0aGVyIGR1ZSB0byBzZWN1cml0eSByZWFzb25zLlxuXHRcdFx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gKi9cblx0XHRcdHZhciBub2RlID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKTtcblxuXHRcdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0XHR9XG5cblx0XHRcdGFzc2lnbl9ub2Rlcyhcblx0XHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpLFxuXHRcdFx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKG5vZGUubGFzdENoaWxkKVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdFx0d2hpbGUgKGdldF9maXJzdF9jaGlsZChub2RlKSkge1xuXHRcdFx0XHRcdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuY2hvci5iZWZvcmUobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuIiwiaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29tbWVudH0gYW5jaG9yXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBzbG90X3Byb3BzXG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogQ29tbWVudCkgPT4gdm9pZCl9IGZhbGxiYWNrX2ZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbG90KGFuY2hvciwgJCRwcm9wcywgbmFtZSwgc2xvdF9wcm9wcywgZmFsbGJhY2tfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIHNsb3RfZm4gPSAkJHByb3BzLiQkc2xvdHM/LltuYW1lXTtcblx0Ly8gSW50ZXJvcDogQ2FuIHVzZSBzbmlwcGV0cyB0byBmaWxsIHNsb3RzXG5cdHZhciBpc19pbnRlcm9wID0gZmFsc2U7XG5cdGlmIChzbG90X2ZuID09PSB0cnVlKSB7XG5cdFx0c2xvdF9mbiA9ICQkcHJvcHNbbmFtZSA9PT0gJ2RlZmF1bHQnID8gJ2NoaWxkcmVuJyA6IG5hbWVdO1xuXHRcdGlzX2ludGVyb3AgPSB0cnVlO1xuXHR9XG5cblx0aWYgKHNsb3RfZm4gPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChmYWxsYmFja19mbiAhPT0gbnVsbCkge1xuXHRcdFx0ZmFsbGJhY2tfZm4oYW5jaG9yKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c2xvdF9mbihhbmNob3IsIGlzX2ludGVyb3AgPyAoKSA9PiBzbG90X3Byb3BzIDogc2xvdF9wcm9wcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZV9zbG90cyhwcm9wcykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuXHRjb25zdCBzYW5pdGl6ZWQgPSB7fTtcblx0aWYgKHByb3BzLmNoaWxkcmVuKSBzYW5pdGl6ZWQuZGVmYXVsdCA9IHRydWU7XG5cdGZvciAoY29uc3Qga2V5IGluIHByb3BzLiQkc2xvdHMpIHtcblx0XHRzYW5pdGl6ZWRba2V5XSA9IHRydWU7XG5cdH1cblx0cmV0dXJuIHNhbml0aXplZDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgU25pcHBldCB9IGZyb20gJ3N2ZWx0ZScgKi9cbi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBHZXR0ZXJzIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBicmFuY2gsIGJsb2NrLCBkZXN0cm95X2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uXG59IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgeyhub2RlOiBUZW1wbGF0ZU5vZGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBTbmlwcGV0Rm5cbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IFNuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9IGdldF9zbmlwcGV0XG4gKiBAcGFyYW0geygoKSA9PiBhbnkpW119IGFyZ3NcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc25pcHBldChub2RlLCBnZXRfc25pcHBldCwgLi4uYXJncykge1xuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge1NuaXBwZXRGbiB8IG51bGwgfCB1bmRlZmluZWR9ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0dmFyIHNuaXBwZXQgPSBub29wO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIHNuaXBwZXRfZWZmZWN0O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoc25pcHBldCA9PT0gKHNuaXBwZXQgPSBnZXRfc25pcHBldCgpKSkgcmV0dXJuO1xuXG5cdFx0aWYgKHNuaXBwZXRfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdChzbmlwcGV0X2VmZmVjdCk7XG5cdFx0XHRzbmlwcGV0X2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKERFViAmJiBzbmlwcGV0ID09IG51bGwpIHtcblx0XHRcdGUuaW52YWxpZF9zbmlwcGV0KCk7XG5cdFx0fVxuXG5cdFx0c25pcHBldF9lZmZlY3QgPSBicmFuY2goKCkgPT4gLyoqIEB0eXBlIHtTbmlwcGV0Rm59ICovIChzbmlwcGV0KShhbmNob3IsIC4uLmFyZ3MpKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YW5jaG9yID0gaHlkcmF0ZV9ub2RlO1xuXHR9XG59XG5cbi8qKlxuICogSW4gZGV2ZWxvcG1lbnQsIHdyYXAgdGhlIHNuaXBwZXQgZnVuY3Rpb24gc28gdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbiwgYW5kIHNvIHRoYXQgdGhlXG4gKiBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0IGlzIHNldCBmb3Igb3duZXJzaGlwIGNoZWNrc1xuICogQHBhcmFtIHthbnl9IGNvbXBvbmVudFxuICogQHBhcmFtIHsobm9kZTogVGVtcGxhdGVOb2RlLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBfc25pcHBldChjb21wb25lbnQsIGZuKSB7XG5cdHJldHVybiAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIG5vZGUsIC8qKiBAdHlwZSB7YW55W119ICovIC4uLmFyZ3MpID0+IHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oY29tcG9uZW50KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZm4obm9kZSwgLi4uYXJncyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24ocHJldmlvdXNfY29tcG9uZW50X2Z1bmN0aW9uKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc25pcHBldCBwcm9ncmFtbWF0aWNhbGx5XG4gKiBAdGVtcGxhdGUge3Vua25vd25bXX0gUGFyYW1zXG4gKiBAcGFyYW0geyguLi5wYXJhbXM6IEdldHRlcnM8UGFyYW1zPikgPT4ge1xuICogICByZW5kZXI6ICgpID0+IHN0cmluZ1xuICogICBzZXR1cD86IChlbGVtZW50OiBFbGVtZW50KSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpXG4gKiB9fSBmblxuICogQHJldHVybnMge1NuaXBwZXQ8UGFyYW1zPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhd1NuaXBwZXQoZm4pIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgdHlwZXMgYXJlIGEgbGllXG5cdHJldHVybiAoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIGFuY2hvciwgLyoqIEB0eXBlIHtHZXR0ZXJzPFBhcmFtcz59ICovIC4uLnBhcmFtcykgPT4ge1xuXHRcdHZhciBzbmlwcGV0ID0gZm4oLi4ucGFyYW1zKTtcblxuXHRcdC8qKiBAdHlwZSB7RWxlbWVudH0gKi9cblx0XHR2YXIgZWxlbWVudDtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBodG1sID0gc25pcHBldC5yZW5kZXIoKS50cmltKCk7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpO1xuXHRcdFx0ZWxlbWVudCA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChmcmFnbWVudCkpO1xuXG5cdFx0XHRpZiAoREVWICYmIChnZXRfbmV4dF9zaWJsaW5nKGVsZW1lbnQpICE9PSBudWxsIHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpKSB7XG5cdFx0XHRcdHcuaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSBzbmlwcGV0LnNldHVwPy4oZWxlbWVudCk7XG5cdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRlYXJkb3duKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUsIERvbSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBwYXVzZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFBcbiAqIEB0ZW1wbGF0ZSB7KHByb3BzOiBQKSA9PiB2b2lkfSBDXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBDfSBnZXRfY29tcG9uZW50XG4gKiBAcGFyYW0geyhhbmNob3I6IFRlbXBsYXRlTm9kZSwgY29tcG9uZW50OiBDKSA9PiBEb20gfCB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50KG5vZGUsIGdldF9jb21wb25lbnQsIHJlbmRlcl9mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0N9ICovXG5cdHZhciBjb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoY29tcG9uZW50ID09PSAoY29tcG9uZW50ID0gZ2V0X2NvbXBvbmVudCgpKSkgcmV0dXJuO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChjb21wb25lbnQpIHtcblx0XHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiByZW5kZXJfZm4oYW5jaG9yLCBjb21wb25lbnQpKTtcblx0XHR9XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBGSUxFTkFNRSwgTkFNRVNQQUNFX1NWRyB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRzZXRfaHlkcmF0ZV9ub2RlLFxuXHRzZXRfaHlkcmF0aW5nXG59IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgZ2V0X2ZpcnN0X2NoaWxkIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQge1xuXHRibG9jayxcblx0YnJhbmNoLFxuXHRkZXN0cm95X2VmZmVjdCxcblx0cGF1c2VfZWZmZWN0LFxuXHRyZXN1bWVfZWZmZWN0XG59IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzZXRfc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfZWFjaF9pdGVtLCBzZXRfY3VycmVudF9lYWNoX2l0ZW0gfSBmcm9tICcuL2VhY2guanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCB7IGlzX3Jhd190ZXh0X2VsZW1lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtDb21tZW50IHwgRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF90YWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc3ZnXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoZWxlbWVudDogRWxlbWVudCwgYW5jaG9yOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCl9IHJlbmRlcl9mbixcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgKCgpID0+IHN0cmluZyl9IGdldF9uYW1lc3BhY2VcbiAqIEBwYXJhbSB7dW5kZWZpbmVkIHwgW251bWJlciwgbnVtYmVyXX0gbG9jYXRpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudChub2RlLCBnZXRfdGFnLCBpc19zdmcsIHJlbmRlcl9mbiwgZ2V0X25hbWVzcGFjZSwgbG9jYXRpb24pIHtcblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGZpbGVuYW1lID0gREVWICYmIGxvY2F0aW9uICYmIGNvbXBvbmVudF9jb250ZXh0Py5mdW5jdGlvbltGSUxFTkFNRV07XG5cblx0LyoqIEB0eXBlIHtzdHJpbmcgfCBudWxsfSAqL1xuXHR2YXIgdGFnO1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cblx0dmFyIGN1cnJlbnRfdGFnO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovXG5cdHZhciBlbGVtZW50ID0gbnVsbDtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGh5ZHJhdGVfbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZSk7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdC8qKlxuXHQgKiBUaGUga2V5ZWQgYHsjZWFjaCAuLi59YCBpdGVtIGJsb2NrLCBpZiBhbnksIHRoYXQgdGhpcyBlbGVtZW50IGlzIGluc2lkZS5cblx0ICogV2UgdHJhY2sgdGhpcyBzbyB3ZSBjYW4gc2V0IGl0IHdoZW4gY2hhbmdpbmcgdGhlIGVsZW1lbnQsIGFsbG93aW5nIGFueVxuXHQgKiBgYW5pbWF0ZTpgIGRpcmVjdGl2ZSB0byBiaW5kIGl0c2VsZiB0byB0aGUgY29ycmVjdCBibG9ja1xuXHQgKi9cblx0dmFyIGVhY2hfaXRlbV9ibG9jayA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRjb25zdCBuZXh0X3RhZyA9IGdldF90YWcoKSB8fCBudWxsO1xuXHRcdHZhciBucyA9IGdldF9uYW1lc3BhY2UgPyBnZXRfbmFtZXNwYWNlKCkgOiBpc19zdmcgfHwgbmV4dF90YWcgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG51bGw7XG5cblx0XHQvLyBBc3N1bXB0aW9uOiBOb29uZSBjaGFuZ2VzIHRoZSBuYW1lc3BhY2UgYnV0IG5vdCB0aGUgdGFnICh3aGF0IHdvdWxkIHRoYXQgZXZlbiBtZWFuPylcblx0XHRpZiAobmV4dF90YWcgPT09IHRhZykgcmV0dXJuO1xuXG5cdFx0Ly8gU2VlIGV4cGxhbmF0aW9uIG9mIGBlYWNoX2l0ZW1fYmxvY2tgIGFib3ZlXG5cdFx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShlYWNoX2l0ZW1fYmxvY2spO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0aWYgKG5leHRfdGFnID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIHN0YXJ0IG91dHJvXG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRfdGFnID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKG5leHRfdGFnID09PSBjdXJyZW50X3RhZykge1xuXHRcdFx0XHQvLyBzYW1lIHRhZyBhcyBpcyBjdXJyZW50bHkgcmVuZGVyZWQg4oCUIGFib3J0IG91dHJvXG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRhZyBpcyBjaGFuZ2luZyDigJQgZGVzdHJveSBpbW1lZGlhdGVseSwgcmVuZGVyIGNvbnRlbnRzIHdpdGhvdXQgaW50cm8gdHJhbnNpdGlvbnNcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0c2V0X3Nob3VsZF9pbnRybyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRfdGFnICYmIG5leHRfdGFnICE9PSBjdXJyZW50X3RhZykge1xuXHRcdFx0ZWZmZWN0ID0gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0ZWxlbWVudCA9IGh5ZHJhdGluZ1xuXHRcdFx0XHRcdD8gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZWxlbWVudClcblx0XHRcdFx0XHQ6IG5zXG5cdFx0XHRcdFx0XHQ/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgbmV4dF90YWcpXG5cdFx0XHRcdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dF90YWcpO1xuXG5cdFx0XHRcdGlmIChERVYgJiYgbG9jYXRpb24pIHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdFx0XHRcdFx0bG9jOiB7XG5cdFx0XHRcdFx0XHRcdGZpbGU6IGZpbGVuYW1lLFxuXHRcdFx0XHRcdFx0XHRsaW5lOiBsb2NhdGlvblswXSxcblx0XHRcdFx0XHRcdFx0Y29sdW1uOiBsb2NhdGlvblsxXVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ25fbm9kZXMoZWxlbWVudCwgZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKHJlbmRlcl9mbikge1xuXHRcdFx0XHRcdGlmIChoeWRyYXRpbmcgJiYgaXNfcmF3X3RleHRfZWxlbWVudChuZXh0X3RhZykpIHtcblx0XHRcdFx0XHRcdC8vIHByZXZlbnQgaHlkcmF0aW9uIGdsaXRjaGVzXG5cdFx0XHRcdFx0XHRlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgaHlkcmF0aW5nLCB1c2UgdGhlIGV4aXN0aW5nIHNzciBjb21tZW50IGFzIHRoZSBhbmNob3Igc28gdGhhdCB0aGVcblx0XHRcdFx0XHQvLyBpbm5lciBvcGVuIGFuZCBjbG9zZSBtZXRob2RzIGNhbiBwaWNrIHVwIHRoZSBleGlzdGluZyBub2RlcyBjb3JyZWN0bHlcblx0XHRcdFx0XHR2YXIgY2hpbGRfYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdFx0XHRcdGh5ZHJhdGluZyA/IGdldF9maXJzdF9jaGlsZChlbGVtZW50KSA6IGVsZW1lbnQuYXBwZW5kQ2hpbGQoY3JlYXRlX3RleHQoKSlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkX2FuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBgY2hpbGRfYW5jaG9yYCBpcyB1bmRlZmluZWQgaWYgdGhpcyBpcyBhIHZvaWQgZWxlbWVudCwgYnV0IHdlIHN0aWxsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjYWxsIGByZW5kZXJfZm5gIGluIG9yZGVyIHRvIHJ1biBhY3Rpb25zIGV0Yy4gSWYgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHQvLyBjb250YWlucyBjaGlsZHJlbiwgaXQncyBhIHVzZXIgZXJyb3IgKHdoaWNoIGlzIHdhcm5lZCBvbiBlbHNld2hlcmUpXG5cdFx0XHRcdFx0Ly8gYW5kIHRoZSBET00gd2lsbCBiZSBzaWxlbnRseSBkaXNjYXJkZWRcblx0XHRcdFx0XHRyZW5kZXJfZm4oZWxlbWVudCwgY2hpbGRfYW5jaG9yKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHdlIGRvIHRoaXMgYWZ0ZXIgY2FsbGluZyBgcmVuZGVyX2ZuYCBzbyB0aGF0IGNoaWxkIGVmZmVjdHMgZG9uJ3Qgb3ZlcnJpZGUgYG5vZGVzLmVuZGBcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBlbGVtZW50O1xuXG5cdFx0XHRcdGFuY2hvci5iZWZvcmUoZWxlbWVudCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0YWcgPSBuZXh0X3RhZztcblx0XHRpZiAodGFnKSBjdXJyZW50X3RhZyA9IHRhZztcblx0XHRzZXRfc2hvdWxkX2ludHJvKHRydWUpO1xuXG5cdFx0c2V0X2N1cnJlbnRfZWFjaF9pdGVtKHByZXZpb3VzX2VhY2hfaXRlbSk7XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKHdhc19oeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0fVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBvPWUubGVuZ3RoO2Zvcih0PTA7dDxvO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zil9ZWxzZSBmb3IoZiBpbiBlKWVbZl0mJihuJiYobis9XCIgXCIpLG4rPWYpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIixvPWFyZ3VtZW50cy5sZW5ndGg7ZjxvO2YrKykoZT1hcmd1bWVudHNbZl0pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgeyBlc2NhcGVfaHRtbCB9IGZyb20gJy4uLy4uL2VzY2FwaW5nLmpzJztcbmltcG9ydCB7IGNsc3ggYXMgX2Nsc3ggfSBmcm9tICdjbHN4JztcblxuLyoqXG4gKiBgPGRpdiB0cmFuc2xhdGU9e2ZhbHNlfT5gIHNob3VsZCBiZSByZW5kZXJlZCBhcyBgPGRpdiB0cmFuc2xhdGU9XCJub1wiPmAgYW5kIF9ub3RfXG4gKiBgPGRpdiB0cmFuc2xhdGU9XCJmYWxzZVwiPmAsIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYDxkaXYgdHJhbnNsYXRlPVwieWVzXCI+YC4gVGhlcmVcbiAqIG1heSBiZSBvdGhlciBvZGQgY2FzZXMgdGhhdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoaXMgbGlzdCBpbiBmdXR1cmVcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBNYXA8YW55LCBzdHJpbmc+Pn1cbiAqL1xuY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuXHR0cmFuc2xhdGU6IG5ldyBNYXAoW1xuXHRcdFt0cnVlLCAneWVzJ10sXG5cdFx0W2ZhbHNlLCAnbm8nXVxuXHRdKVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzX2Jvb2xlYW5dXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSwgaXNfYm9vbGVhbiA9IGZhbHNlKSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsIHx8ICghdmFsdWUgJiYgaXNfYm9vbGVhbikgfHwgKHZhbHVlID09PSAnJyAmJiBuYW1lID09PSAnY2xhc3MnKSkgcmV0dXJuICcnO1xuXHRjb25zdCBub3JtYWxpemVkID0gKG5hbWUgaW4gcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1tuYW1lXS5nZXQodmFsdWUpKSB8fCB2YWx1ZTtcblx0Y29uc3QgYXNzaWdubWVudCA9IGlzX2Jvb2xlYW4gPyAnJyA6IGA9XCIke2VzY2FwZV9odG1sKG5vcm1hbGl6ZWQsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKipcbiAqIFNtYWxsIHdyYXBwZXIgYXJvdW5kIGNsc3ggdG8gcHJlc2VydmUgU3ZlbHRlJ3MgKHdlaXJkKSBoYW5kbGluZyBvZiBmYWxzeSB2YWx1ZXMuXG4gKiBUT0RPIFN2ZWx0ZSA2IHJldmlzaXQgdGhpcywgYW5kIGxpa2VseSB0dXJuIGFsbCBmYWxzeSB2YWx1ZXMgaW50byB0aGUgZW1wdHkgc3RyaW5nICh3aGF0IGNsc3ggYWxzbyBkb2VzKVxuICogQHBhcmFtICB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xzeCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBfY2xzeCh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlID8/ICcnO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGh5ZHJhdGluZywgc2V0X2h5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvcnMsIGdldF9wcm90b3R5cGVfb2YgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlX2V2ZW50LCBkZWxlZ2F0ZSB9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyLCBhdXRvZm9jdXMgfSBmcm9tICcuL21pc2MuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBMT0FESU5HX0FUVFJfU1lNQk9MIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHF1ZXVlX2lkbGVfdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgaXNfY2FwdHVyZV9ldmVudCwgaXNfZGVsZWdhdGVkLCBub3JtYWxpemVfYXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNsc3ggfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5cbi8qKlxuICogVGhlIHZhbHVlL2NoZWNrZWQgYXR0cmlidXRlIGluIHRoZSB0ZW1wbGF0ZSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX2lucHV0X2RlZmF1bHRzKGlucHV0KSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0dmFyIGFscmVhZHlfcmVtb3ZlZCA9IGZhbHNlO1xuXG5cdC8vIFdlIHRyeSBhbmQgcmVtb3ZlIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXMgbGF0ZXIsIHJhdGhlciB0aGFuIHN5bmMgZHVyaW5nIGh5ZHJhdGlvbi5cblx0Ly8gRG9pbmcgaXQgc3luYyBkdXJpbmcgaHlkcmF0aW9uIGhhcyBhIG5lZ2F0aXZlIGltcGFjdCBvbiBwZXJmb3JtYW5jZSwgYnV0IGRlZmVycmluZyB0aGVcblx0Ly8gd29yayBpbiBhbiBpZGxlIHRhc2sgYWxsZXZpYXRlcyB0aGlzIGdyZWF0bHkuIElmIGEgZm9ybSByZXNldCBldmVudCBjb21lcyBpbiBiZWZvcmVcblx0Ly8gdGhlIGlkbGUgY2FsbGJhY2ssIHRoZW4gd2UgZW5zdXJlIHRoZSBpbnB1dCBkZWZhdWx0cyBhcmUgY2xlYXJlZCBqdXN0IGJlZm9yZS5cblx0dmFyIHJlbW92ZV9kZWZhdWx0cyA9ICgpID0+IHtcblx0XHRpZiAoYWxyZWFkeV9yZW1vdmVkKSByZXR1cm47XG5cdFx0YWxyZWFkeV9yZW1vdmVkID0gdHJ1ZTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlcyBidXQgcHJlc2VydmUgdGhlIHZhbHVlc1xuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ3ZhbHVlJywgbnVsbCk7XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuXHRcdFx0dmFyIGNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ2NoZWNrZWQnLCBudWxsKTtcblx0XHRcdGlucHV0LmNoZWNrZWQgPSBjaGVja2VkO1xuXHRcdH1cblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlucHV0Ll9fb25fciA9IHJlbW92ZV9kZWZhdWx0cztcblx0cXVldWVfaWRsZV90YXNrKHJlbW92ZV9kZWZhdWx0cyk7XG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBhdHRyaWJ1dGVzID0gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMudmFsdWUgPT09XG5cdFx0XHQoYXR0cmlidXRlcy52YWx1ZSA9XG5cdFx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdFx0dmFsdWUgPz8gdW5kZWZpbmVkKSB8fFxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHQvLyBgcHJvZ3Jlc3NgIGVsZW1lbnRzIGFsd2F5cyBuZWVkIHRoZWlyIHZhbHVlIHNldCB3aGVuIGl0J3MgYDBgXG5cdFx0KGVsZW1lbnQudmFsdWUgPT09IHZhbHVlICYmICh2YWx1ZSAhPT0gMCB8fCBlbGVtZW50Lm5vZGVOYW1lICE9PSAnUFJPR1JFU1MnKSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50LnZhbHVlID0gdmFsdWUgPz8gJyc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YXIgYXR0cmlidXRlcyA9IChlbGVtZW50Ll9fYXR0cmlidXRlcyA/Pz0ge30pO1xuXG5cdGlmIChcblx0XHRhdHRyaWJ1dGVzLmNoZWNrZWQgPT09XG5cdFx0KGF0dHJpYnV0ZXMuY2hlY2tlZCA9XG5cdFx0XHQvLyB0cmVhdCBudWxsIGFuZCB1bmRlZmluZWQgdGhlIHNhbWUgZm9yIHRoZSBpbml0aWFsIHZhbHVlXG5cdFx0XHRjaGVja2VkID8/IHVuZGVmaW5lZClcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRlbGVtZW50LmNoZWNrZWQgPSBjaGVja2VkO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGBzZWxlY3RlZGAgYXR0cmlidXRlIG9uIGFuIGBvcHRpb25gIGVsZW1lbnQuXG4gKiBOb3Qgc2V0IHRocm91Z2ggdGhlIHByb3BlcnR5IGJlY2F1c2UgdGhhdCBkb2Vzbid0IHJlZmxlY3QgdG8gdGhlIERPTSxcbiAqIHdoaWNoIG1lYW5zIGl0IHdvdWxkbid0IGJlIHRha2VuIGludG8gYWNjb3VudCB3aGVuIGEgZm9ybSBpcyByZXNldC5cbiAqIEBwYXJhbSB7SFRNTE9wdGlvbkVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9zZWxlY3RlZChlbGVtZW50LCBzZWxlY3RlZCkge1xuXHRpZiAoc2VsZWN0ZWQpIHtcblx0XHQvLyBUaGUgc2VsZWN0ZWQgb3B0aW9uIGNvdWxkJ3ZlIGNoYW5nZWQgdmlhIHVzZXIgc2VsZWN0aW9uLCBhbmRcblx0XHQvLyBzZXR0aW5nIHRoZSB2YWx1ZSB3aXRob3V0IHRoaXMgY2hlY2sgd291bGQgc2V0IGl0IGJhY2suXG5cdFx0aWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJycpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcblx0fVxufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGRlZmF1bHQgY2hlY2tlZCBwcm9wZXJ0eSB3aXRob3V0IGluZmx1ZW5jaW5nIHRoZSBjdXJyZW50IGNoZWNrZWQgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RlZmF1bHRfY2hlY2tlZChlbGVtZW50LCBjaGVja2VkKSB7XG5cdGNvbnN0IGV4aXN0aW5nX3ZhbHVlID0gZWxlbWVudC5jaGVja2VkO1xuXHRlbGVtZW50LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcblx0ZWxlbWVudC5jaGVja2VkID0gZXhpc3RpbmdfdmFsdWU7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZGVmYXVsdCB2YWx1ZSBwcm9wZXJ0eSB3aXRob3V0IGluZmx1ZW5jaW5nIHRoZSBjdXJyZW50IHZhbHVlIHByb3BlcnR5LlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVmYXVsdF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHRjb25zdCBleGlzdGluZ192YWx1ZSA9IGVsZW1lbnQudmFsdWU7XG5cdGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG5cdGVsZW1lbnQudmFsdWUgPSBleGlzdGluZ192YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGUoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSwgc2tpcF93YXJuaW5nKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0dmFyIGF0dHJpYnV0ZXMgPSAoZWxlbWVudC5fX2F0dHJpYnV0ZXMgPz89IHt9KTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YXR0cmlidXRlc1thdHRyaWJ1dGVdID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblxuXHRcdGlmIChcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyYycgfHxcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgfHxcblx0XHRcdChhdHRyaWJ1dGUgPT09ICdocmVmJyAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSAnTElOSycpXG5cdFx0KSB7XG5cdFx0XHRpZiAoIXNraXBfd2FybmluZykge1xuXHRcdFx0XHRjaGVja19zcmNfaW5fZGV2X2h5ZHJhdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlID8/ICcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgcmVzZXQgdGhlc2UgYXR0cmlidXRlcywgdGhleSB3b3VsZCByZXN1bHQgaW4gYW5vdGhlciBuZXR3b3JrIHJlcXVlc3QsIHdoaWNoIHdlIHdhbnQgdG8gYXZvaWQuXG5cdFx0XHQvLyBXZSBhc3N1bWUgdGhleSBhcmUgdGhlIHNhbWUgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBhcyBjaGVja2luZyBpZiB0aGV5IGFyZSBlcXVhbCBpcyBleHBlbnNpdmVcblx0XHRcdC8vICh3ZSBjYW4ndCBqdXN0IGNvbXBhcmUgdGhlIHN0cmluZ3MgYXMgdGhleSBjYW4gYmUgZGlmZmVyZW50IGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIgYnV0IHJlc3VsdCBpbiB0aGVcblx0XHRcdC8vIHNhbWUgdXJsLCBzbyB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBoaWRkZW4gYW5jaG9yIGVsZW1lbnRzIHRvIGNvbXBhcmUgdGhlbSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWUpKSByZXR1cm47XG5cblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ3N0eWxlJyAmJiAnX19zdHlsZXMnIGluIGVsZW1lbnQpIHtcblx0XHQvLyByZXNldCBzdHlsZXMgdG8gZm9yY2Ugc3R5bGU6IGRpcmVjdGl2ZSB0byB1cGRhdGVcblx0XHRlbGVtZW50Ll9fc3R5bGVzID0ge307XG5cdH1cblxuXHRpZiAoYXR0cmlidXRlID09PSAnbG9hZGluZycpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudFtMT0FESU5HX0FUVFJfU1lNQk9MXSA9IHZhbHVlO1xuXHR9XG5cblx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgZ2V0X3NldHRlcnMoZWxlbWVudCkuaW5jbHVkZXMoYXR0cmlidXRlKSkge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRlbGVtZW50W2F0dHJpYnV0ZV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF94bGlua19hdHRyaWJ1dGUoZG9tLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdGRvbS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG5cdC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgc2V0dGluZyBjdXN0b20gZWxlbWVudCBwcm9wcywgd2hpY2ggY2FuXG5cdC8vIGludm9rZSBsaWZlY3ljbGUgbWV0aG9kcyBvbiBvdGhlciBjdXN0b20gZWxlbWVudHMsIGRvZXMgbm90IGFsc29cblx0Ly8gYXNzb2NpYXRlIHRob3NlIGxpZmVjeWNsZSBtZXRob2RzIHdpdGggdGhlIGN1cnJlbnQgYWN0aXZlIHJlYWN0aW9uXG5cdC8vIG9yIGVmZmVjdFxuXHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHQvLyBJZiB3ZSdyZSBoeWRyYXRpbmcgYnV0IHRoZSBjdXN0b20gZWxlbWVudCBpcyBmcm9tIFN2ZWx0ZSwgYW5kIGl0IGFscmVhZHkgc2NhZmZvbGRlZCxcblx0Ly8gdGhlbiBpdCBtaWdodCBydW4gYmxvY2sgbG9naWMgaW4gaHlkcmF0aW9uIG1vZGUsIHdoaWNoIHdlIGhhdmUgdG8gcHJldmVudC5cblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0fVxuXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXHR0cnkge1xuXHRcdGlmIChcblx0XHRcdC8vIERvbid0IGNvbXB1dGUgc2V0dGVycyBmb3IgY3VzdG9tIGVsZW1lbnRzIHdoaWxlIHRoZXkgYXJlbid0IHJlZ2lzdGVyZWQgeWV0LFxuXHRcdFx0Ly8gYmVjYXVzZSBkdXJpbmcgdGhlaXIgdXBncmFkZS9pbnN0YW50aWF0aW9uIHRoZXkgbWlnaHQgYWRkIG1vcmUgc2V0dGVycy5cblx0XHRcdC8vIEluc3RlYWQsIGZhbGwgYmFjayB0byBhIHNpbXBsZSBcImFuIG9iamVjdCwgdGhlbiBzZXQgYXMgcHJvcGVydHlcIiBoZXVyaXN0aWMuXG5cdFx0XHRzZXR0ZXJzX2NhY2hlLmhhcyhub2RlLm5vZGVOYW1lKSB8fFxuXHRcdFx0Ly8gY3VzdG9tRWxlbWVudHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaW4gYnJvd3NlciBleHRlbnNpb24gY29udGV4dHNcblx0XHRcdCFjdXN0b21FbGVtZW50cyB8fFxuXHRcdFx0Y3VzdG9tRWxlbWVudHMuZ2V0KG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ/IGdldF9zZXR0ZXJzKG5vZGUpLmluY2x1ZGVzKHByb3ApXG5cdFx0XHRcdDogdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0bm9kZVtwcm9wXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBXZSBkaWQgZ2V0dGVycyBldGMgY2hlY2tzIGFscmVhZHksIHN0cmluZ2lmeSBiZWZvcmUgcGFzc2luZyB0byBzZXRfYXR0cmlidXRlXG5cdFx0XHQvLyB0byBlbnN1cmUgaXQgZG9lc24ndCBpbnZva2UgdGhlIHNhbWUgbG9naWMgYWdhaW4sIGFuZCBwb3RlbnRpYWxseSBwb3B1bGF0aW5nXG5cdFx0XHQvLyB0aGUgc2V0dGVycyBjYWNoZSB0b28gZWFybHkuXG5cdFx0XHRzZXRfYXR0cmlidXRlKG5vZGUsIHByb3AsIHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSkpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFNwcmVhZHMgYXR0cmlidXRlcyBvbnRvIGEgRE9NIGVsZW1lbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnRseSBzZXQgYXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWR9IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gbmV4dCBOZXcgYXR0cmlidXRlcyAtIHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlXVxuICogQHBhcmFtIHtib29sZWFufSBbaXNfY3VzdG9tX2VsZW1lbnRdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKFxuXHRlbGVtZW50LFxuXHRwcmV2LFxuXHRuZXh0LFxuXHRjc3NfaGFzaCxcblx0cHJlc2VydmVfYXR0cmlidXRlX2Nhc2UgPSBmYWxzZSxcblx0aXNfY3VzdG9tX2VsZW1lbnQgPSBmYWxzZSxcblx0c2tpcF93YXJuaW5nID0gZmFsc2Vcbikge1xuXHQvLyBJZiB3ZSdyZSBoeWRyYXRpbmcgYnV0IHRoZSBjdXN0b20gZWxlbWVudCBpcyBmcm9tIFN2ZWx0ZSwgYW5kIGl0IGFscmVhZHkgc2NhZmZvbGRlZCxcblx0Ly8gdGhlbiBpdCBtaWdodCBydW4gYmxvY2sgbG9naWMgaW4gaHlkcmF0aW9uIG1vZGUsIHdoaWNoIHdlIGhhdmUgdG8gcHJldmVudC5cblx0bGV0IGlzX2h5ZHJhdGluZ19jdXN0b21fZWxlbWVudCA9IGh5ZHJhdGluZyAmJiBpc19jdXN0b21fZWxlbWVudDtcblx0aWYgKGlzX2h5ZHJhdGluZ19jdXN0b21fZWxlbWVudCkge1xuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHR9XG5cblx0dmFyIGN1cnJlbnQgPSBwcmV2IHx8IHt9O1xuXHR2YXIgaXNfb3B0aW9uX2VsZW1lbnQgPSBlbGVtZW50LnRhZ05hbWUgPT09ICdPUFRJT04nO1xuXG5cdGZvciAodmFyIGtleSBpbiBwcmV2KSB7XG5cdFx0aWYgKCEoa2V5IGluIG5leHQpKSB7XG5cdFx0XHRuZXh0W2tleV0gPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGlmIChuZXh0LmNsYXNzKSB7XG5cdFx0bmV4dC5jbGFzcyA9IGNsc3gobmV4dC5jbGFzcyk7XG5cdH1cblxuXHRpZiAoY3NzX2hhc2ggIT09IHVuZGVmaW5lZCkge1xuXHRcdG5leHQuY2xhc3MgPSBuZXh0LmNsYXNzID8gbmV4dC5jbGFzcyArICcgJyArIGNzc19oYXNoIDogY3NzX2hhc2g7XG5cdH1cblxuXHR2YXIgc2V0dGVycyA9IGdldF9zZXR0ZXJzKGVsZW1lbnQpO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0dmFyIGF0dHJpYnV0ZXMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqKi8gKGVsZW1lbnQuX19hdHRyaWJ1dGVzID8/PSB7fSk7XG5cblx0Ly8gc2luY2Uga2V5IGlzIGNhcHR1cmVkIHdlIHVzZSBjb25zdFxuXHRmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG5cdFx0Ly8gbGV0IGluc3RlYWQgb2YgdmFyIGJlY2F1c2UgcmVmZXJlbmNlZCBpbiBhIGNsb3N1cmVcblx0XHRsZXQgdmFsdWUgPSBuZXh0W2tleV07XG5cblx0XHQvLyBVcCBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBkbyB0aGlzIGZvciB0aGUgaW5pdGlhbCB2YWx1ZSwgdG9vLCBldmVuIGlmIGl0J3MgdW5kZWZpbmVkLFxuXHRcdC8vIGFuZCB0aGlzIHdvdWxkbid0IGJlIHJlYWNoZWQgaW4gY2FzZSBvZiB1bmRlZmluZWQgYmVjYXVzZSBvZiB0aGUgZXF1YWxpdHkgY2hlY2sgYmVsb3dcblx0XHRpZiAoaXNfb3B0aW9uX2VsZW1lbnQgJiYga2V5ID09PSAndmFsdWUnICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdC8vIFRoZSA8b3B0aW9uPiBlbGVtZW50IGlzIGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgcmVtb3ZpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSBtZWFuc1xuXHRcdFx0Ly8gdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBvcHRpb24gZWxlbWVudCwgYW5kIHNldHRpbmcgdGhlIHZhbHVlXG5cdFx0XHQvLyB0byBudWxsIG9yIHVuZGVmaW5lZCBtZWFucyB0aGUgdmFsdWUgaXMgc2V0IHRvIHRoZSBzdHJpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIi5cblx0XHRcdC8vIFRvIGFsaWduIHdpdGggaG93IHdlIGhhbmRsZSB0aGlzIGNhc2UgaW4gbm9uLXNwcmVhZC1zY2VuYXJpb3MsIHRoaXMgbG9naWMgaXMgbmVlZGVkLlxuXHRcdFx0Ly8gVGhlcmUncyBhIHN1cGVyLWVkZ2UtY2FzZSBidWcgaGVyZSB0aGF0IGlzIGxlZnQgaW4gaW4gZmF2b3Igb2Ygc21hbGxlciBjb2RlIHNpemU6XG5cdFx0XHQvLyBCZWNhdXNlIG9mIHRoZSBcInNldCBtaXNzaW5nIHByb3BzIHRvIG51bGxcIiBsb2dpYyBhYm92ZSwgd2UgY2FuJ3QgZGlmZmVyZW50aWF0ZVxuXHRcdFx0Ly8gYmV0d2VlbiBhIG1pc3NpbmcgdmFsdWUgYW5kIGFuIGV4cGxpY2l0bHkgc2V0IHZhbHVlIG9mIG51bGwgb3IgdW5kZWZpbmVkLiBUaGF0IG1lYW5zXG5cdFx0XHQvLyB0aGF0IG9uY2Ugc2V0LCB0aGUgdmFsdWUgYXR0cmlidXRlIG9mIGFuIDxvcHRpb24+IGVsZW1lbnQgY2FuJ3QgYmUgcmVtb3ZlZC4gVGhpcyBpc1xuXHRcdFx0Ly8gYSB2ZXJ5IHJhcmUgZWRnZSBjYXNlLCBhbmQgcmVtb3ZpbmcgdGhlIGF0dHJpYnV0ZSBhbHRvZ2V0aGVyIGlzbid0IHBvc3NpYmxlIGVpdGhlclxuXHRcdFx0Ly8gZm9yIHRoZSA8b3B0aW9uIHZhbHVlPXt1bmRlZmluZWR9PiBjYXNlLCBzbyB3ZSdyZSBub3QgbG9zaW5nIGFueSBmdW5jdGlvbmFsaXR5IGhlcmUuXG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRlbGVtZW50LnZhbHVlID0gZWxlbWVudC5fX3ZhbHVlID0gJyc7XG5cdFx0XHRjdXJyZW50W2tleV0gPSB2YWx1ZTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciBwcmV2X3ZhbHVlID0gY3VycmVudFtrZXldO1xuXHRcdGlmICh2YWx1ZSA9PT0gcHJldl92YWx1ZSkgY29udGludWU7XG5cblx0XHRjdXJyZW50W2tleV0gPSB2YWx1ZTtcblxuXHRcdHZhciBwcmVmaXggPSBrZXlbMF0gKyBrZXlbMV07IC8vIHRoaXMgaXMgZmFzdGVyIHRoYW4ga2V5LnNsaWNlKDAsIDIpXG5cdFx0aWYgKHByZWZpeCA9PT0gJyQkJykgY29udGludWU7XG5cblx0XHRpZiAocHJlZml4ID09PSAnb24nKSB7XG5cdFx0XHQvKiogQHR5cGUge3sgY2FwdHVyZT86IHRydWUgfX0gKi9cblx0XHRcdGNvbnN0IG9wdHMgPSB7fTtcblx0XHRcdGNvbnN0IGV2ZW50X2hhbmRsZV9rZXkgPSAnJCQnICsga2V5O1xuXHRcdFx0bGV0IGV2ZW50X25hbWUgPSBrZXkuc2xpY2UoMik7XG5cdFx0XHR2YXIgZGVsZWdhdGVkID0gaXNfZGVsZWdhdGVkKGV2ZW50X25hbWUpO1xuXG5cdFx0XHRpZiAoaXNfY2FwdHVyZV9ldmVudChldmVudF9uYW1lKSkge1xuXHRcdFx0XHRldmVudF9uYW1lID0gZXZlbnRfbmFtZS5zbGljZSgwLCAtNyk7XG5cdFx0XHRcdG9wdHMuY2FwdHVyZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGVsZWdhdGVkICYmIHByZXZfdmFsdWUpIHtcblx0XHRcdFx0Ly8gTGlzdGVuaW5nIHRvIHNhbWUgZXZlbnQgYnV0IGRpZmZlcmVudCBoYW5kbGVyIC0+IG91ciBoYW5kbGUgZnVuY3Rpb24gYmVsb3cgdGFrZXMgY2FyZSBvZiB0aGlzXG5cdFx0XHRcdC8vIElmIHdlIHdlcmUgdG8gcmVtb3ZlIGFuZCBhZGQgbGlzdGVuZXJzIGluIHRoaXMgY2FzZSwgaXQgY291bGQgaGFwcGVuIHRoYXQgdGhlIGV2ZW50IGlzIFwic3dhbGxvd2VkXCJcblx0XHRcdFx0Ly8gKHRoZSBicm93c2VyIHNlZW1zIHRvIG5vdCBrbm93IHlldCB0aGF0IGEgbmV3IG9uZSBleGlzdHMgbm93KSBhbmQgZG9lc24ndCByZWFjaCB0aGUgaGFuZGxlclxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xMTkwM1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkgY29udGludWU7XG5cblx0XHRcdFx0ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0sIG9wdHMpO1xuXHRcdFx0XHRjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKCFkZWxlZ2F0ZWQpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiBAdGhpcyB7YW55fVxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdGZ1bmN0aW9uIGhhbmRsZShldnQpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRba2V5XS5jYWxsKHRoaXMsIGV2dCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudFtldmVudF9oYW5kbGVfa2V5XSA9IGNyZWF0ZV9ldmVudChldmVudF9uYW1lLCBlbGVtZW50LCBoYW5kbGUsIG9wdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRlbGVtZW50W2BfXyR7ZXZlbnRfbmFtZX1gXSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlbGVnYXRlKFtldmVudF9uYW1lXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZGVsZWdhdGVkKSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0ZWxlbWVudFtgX18ke2V2ZW50X25hbWV9YF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScgJiYgdmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0ZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgKyAnJztcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2F1dG9mb2N1cycpIHtcblx0XHRcdGF1dG9mb2N1cygvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCksIEJvb2xlYW4odmFsdWUpKTtcblx0XHR9IGVsc2UgaWYgKCFpc19jdXN0b21fZWxlbWVudCAmJiAoa2V5ID09PSAnX192YWx1ZScgfHwgKGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSAhPSBudWxsKSkpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgV2UncmUgbm90IHJ1bm5pbmcgdGhpcyBmb3IgY3VzdG9tIGVsZW1lbnRzIGJlY2F1c2UgX192YWx1ZSBpcyBhY3R1YWxseVxuXHRcdFx0Ly8gaG93IExpdCBzdG9yZXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gdGhlIGVsZW1lbnQsIGFuZCBtZXNzaW5nIHdpdGggdGhhdCB3b3VsZCBicmVhayB0aGluZ3MuXG5cdFx0XHRlbGVtZW50LnZhbHVlID0gZWxlbWVudC5fX3ZhbHVlID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzZWxlY3RlZCcgJiYgaXNfb3B0aW9uX2VsZW1lbnQpIHtcblx0XHRcdHNldF9zZWxlY3RlZCgvKiogQHR5cGUge0hUTUxPcHRpb25FbGVtZW50fSAqLyAoZWxlbWVudCksIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5hbWUgPSBrZXk7XG5cdFx0XHRpZiAoIXByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlKSB7XG5cdFx0XHRcdG5hbWUgPSBub3JtYWxpemVfYXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXNfZGVmYXVsdCA9IG5hbWUgPT09ICdkZWZhdWx0VmFsdWUnIHx8IG5hbWUgPT09ICdkZWZhdWx0Q2hlY2tlZCc7XG5cblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFpc19jdXN0b21fZWxlbWVudCAmJiAhaXNfZGVmYXVsdCkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuXG5cdFx0XHRcdGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJykge1xuXHRcdFx0XHRcdC8vIHJlbW92aW5nIHZhbHVlL2NoZWNrZWQgYWxzbyByZW1vdmVzIGRlZmF1bHRWYWx1ZS9kZWZhdWx0Q2hlY2tlZCDigJQgcHJlc2VydmVcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovIChlbGVtZW50KTtcblx0XHRcdFx0XHRjb25zdCB1c2VfZGVmYXVsdCA9IHByZXYgPT09IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdFZhbHVlO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdFZhbHVlID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRpbnB1dC52YWx1ZSA9IGlucHV0Ll9fdmFsdWUgPSB1c2VfZGVmYXVsdCA/IHByZXZpb3VzIDogbnVsbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdENoZWNrZWQ7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0aW5wdXQuY2hlY2tlZCA9IHVzZV9kZWZhdWx0ID8gcHJldmlvdXMgOiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aXNfZGVmYXVsdCB8fFxuXHRcdFx0XHQoc2V0dGVycy5pbmNsdWRlcyhuYW1lKSAmJiAoaXNfY3VzdG9tX2VsZW1lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W25hbWVdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzZXRfYXR0cmlidXRlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGtleSA9PT0gJ3N0eWxlJyAmJiAnX19zdHlsZXMnIGluIGVsZW1lbnQpIHtcblx0XHRcdC8vIHJlc2V0IHN0eWxlcyB0byBmb3JjZSBzdHlsZTogZGlyZWN0aXZlIHRvIHVwZGF0ZVxuXHRcdFx0ZWxlbWVudC5fX3N0eWxlcyA9IHt9O1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc19oeWRyYXRpbmdfY3VzdG9tX2VsZW1lbnQpIHtcblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nW10+fSAqL1xudmFyIHNldHRlcnNfY2FjaGUgPSBuZXcgTWFwKCk7XG5cbi8qKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgKi9cbmZ1bmN0aW9uIGdldF9zZXR0ZXJzKGVsZW1lbnQpIHtcblx0dmFyIHNldHRlcnMgPSBzZXR0ZXJzX2NhY2hlLmdldChlbGVtZW50Lm5vZGVOYW1lKTtcblx0aWYgKHNldHRlcnMpIHJldHVybiBzZXR0ZXJzO1xuXHRzZXR0ZXJzX2NhY2hlLnNldChlbGVtZW50Lm5vZGVOYW1lLCAoc2V0dGVycyA9IFtdKSk7XG5cblx0dmFyIGRlc2NyaXB0b3JzO1xuXHR2YXIgcHJvdG8gPSBlbGVtZW50OyAvLyBJbiB0aGUgY2FzZSBvZiBjdXN0b20gZWxlbWVudHMgdGhlcmUgbWlnaHQgYmUgc2V0dGVycyBvbiB0aGUgaW5zdGFuY2Vcblx0dmFyIGVsZW1lbnRfcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcblxuXHQvLyBTdG9wIGF0IEVsZW1lbnQsIGZyb20gdGhlcmUgb24gdGhlcmUncyBvbmx5IHVubmVjZXNzYXJ5IHNldHRlcnMgd2UncmUgbm90IGludGVyZXN0ZWQgaW5cblx0Ly8gRG8gbm90IHVzZSBjb250cnVjdG9yLm5hbWUgaGVyZSBhcyB0aGF0J3MgdW5yZWxpYWJsZSBpbiBzb21lIGJyb3dzZXIgZW52aXJvbm1lbnRzXG5cdHdoaWxlIChlbGVtZW50X3Byb3RvICE9PSBwcm90bykge1xuXHRcdGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0aWYgKGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG5cdFx0XHRcdHNldHRlcnMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0X3Byb3RvdHlwZV9vZihwcm90byk7XG5cdH1cblxuXHRyZXR1cm4gc2V0dGVycztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrX3NyY19pbl9kZXZfaHlkcmF0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKCFERVYpIHJldHVybjtcblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgJiYgc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50LCB2YWx1ZSkpIHJldHVybjtcblx0aWYgKHNyY191cmxfZXF1YWwoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSA/PyAnJywgdmFsdWUpKSByZXR1cm47XG5cblx0dy5oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQoXG5cdFx0YXR0cmlidXRlLFxuXHRcdGVsZW1lbnQub3V0ZXJIVE1MLnJlcGxhY2UoZWxlbWVudC5pbm5lckhUTUwsIGVsZW1lbnQuaW5uZXJIVE1MICYmICcuLi4nKSxcblx0XHRTdHJpbmcodmFsdWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRfc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIG5ldyBVUkwoZWxlbWVudF9zcmMsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWYgPT09IG5ldyBVUkwodXJsLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmO1xufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd9IHNyY3NldCAqL1xuZnVuY3Rpb24gc3BsaXRfc3Jjc2V0KHNyY3NldCkge1xuXHRyZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKChzcmMpID0+IHNyYy50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNvdXJjZUVsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50LCBzcmNzZXQpIHtcblx0dmFyIGVsZW1lbnRfdXJscyA9IHNwbGl0X3NyY3NldChlbGVtZW50LnNyY3NldCk7XG5cdHZhciB1cmxzID0gc3BsaXRfc3Jjc2V0KHNyY3NldCk7XG5cblx0cmV0dXJuIChcblx0XHR1cmxzLmxlbmd0aCA9PT0gZWxlbWVudF91cmxzLmxlbmd0aCAmJlxuXHRcdHVybHMuZXZlcnkoXG5cdFx0XHQoW3VybCwgd2lkdGhdLCBpKSA9PlxuXHRcdFx0XHR3aWR0aCA9PT0gZWxlbWVudF91cmxzW2ldWzFdICYmXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBib3RoIHdheXMgYmVjYXVzZSBWaXRlIHdpbGwgY3JlYXRlIGFuIGEgZnVsbCBVUkwgd2l0aFxuXHRcdFx0XHQvLyBgbmV3IFVSTChhc3NldCwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmYCBmb3IgdGhlIGNsaWVudCB3aGVuIGBiYXNlOiAnLi8nYCwgYW5kIHRoZVxuXHRcdFx0XHQvLyByZWxhdGl2ZSBVUkxzIGluc2lkZSBzcmNzZXQgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIHRvIGFic29sdXRlIFVSTHMgYnlcblx0XHRcdFx0Ly8gYnJvd3NlcnMgKGluIGNvbnRyYXN0IHRvIGltZy5zcmMpLiBUaGlzIG1lYW5zIGJvdGggU1NSIGFuZCBET00gY29kZSBjb3VsZFxuXHRcdFx0XHQvLyBjb250YWluIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTHMuXG5cdFx0XHRcdChzcmNfdXJsX2VxdWFsKGVsZW1lbnRfdXJsc1tpXVswXSwgdXJsKSB8fCBzcmNfdXJsX2VxdWFsKHVybCwgZWxlbWVudF91cmxzW2ldWzBdKSlcblx0XHQpXG5cdCk7XG59XG4iLCJpbXBvcnQgeyBoeWRyYXRpbmcgfSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT09ICcnKSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWF0aE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X21hdGhtbF9jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdGlmIChuZXh0X2NsYXNzX25hbWUgPT09ICcnKSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKCdjbGFzcycsIG5leHRfY2xhc3NfbmFtZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHRcdGRvbS5fX2NsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jbGFzcyhkb20sIHZhbHVlLCBoYXNoKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0dmFyIHByZXZfY2xhc3NfbmFtZSA9IGRvbS5fX2NsYXNzTmFtZTtcblx0dmFyIG5leHRfY2xhc3NfbmFtZSA9IHRvX2NsYXNzKHZhbHVlLCBoYXNoKTtcblxuXHRpZiAoaHlkcmF0aW5nICYmIGRvbS5jbGFzc05hbWUgPT09IG5leHRfY2xhc3NfbmFtZSkge1xuXHRcdC8vIEluIGNhc2Ugb2YgaHlkcmF0aW9uIGRvbid0IHJlc2V0IHRoZSBjbGFzcyBhcyBpdCdzIGFscmVhZHkgY29ycmVjdC5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9IGVsc2UgaWYgKFxuXHRcdHByZXZfY2xhc3NfbmFtZSAhPT0gbmV4dF9jbGFzc19uYW1lIHx8XG5cdFx0KGh5ZHJhdGluZyAmJiBkb20uY2xhc3NOYW1lICE9PSBuZXh0X2NsYXNzX25hbWUpXG5cdCkge1xuXHRcdC8vIFJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgd2hlbiB0aGUgdmFsdWUgaXMgb25seSBhbiBlbXB0eSBzdHJpbmcgY2F1c2VzXG5cdFx0Ly8gcGVmb3JtYW5jZSBpc3N1ZXMgdnMgc2ltcGx5IG1ha2luZyB0aGUgY2xhc3NOYW1lIGFuIGVtcHR5IHN0cmluZy4gU29cblx0XHQvLyB3ZSBzaG91bGQgb25seSByZW1vdmUgdGhlIGNsYXNzIGlmIHRoZSB0aGUgdmFsdWUgaXMgbnVsbGlzaC5cblx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhaGFzaCkge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLmNsYXNzTmFtZSA9IG5leHRfY2xhc3NfbmFtZTtcblx0XHR9XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIG5lZWQgdG8gYWRkIF9fY2xhc3NOYW1lIHRvIHBhdGNoZWQgcHJvdG90eXBlXG5cdFx0ZG9tLl9fY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbaGFzaF1cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBWfVxuICovXG5mdW5jdGlvbiB0b19jbGFzcyh2YWx1ZSwgaGFzaCkge1xuXHRyZXR1cm4gKHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKSArIChoYXNoID8gJyAnICsgaGFzaCA6ICcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzX25hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGRvbSwgY2xhc3NfbmFtZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlKSB7XG5cdFx0aWYgKGRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NfbmFtZSkpIHJldHVybjtcblx0XHRkb20uY2xhc3NMaXN0LmFkZChjbGFzc19uYW1lKTtcblx0fSBlbHNlIHtcblx0XHRpZiAoIWRvbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NfbmFtZSkpIHJldHVybjtcblx0XHRkb20uY2xhc3NMaXN0LnJlbW92ZShjbGFzc19uYW1lKTtcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBSYWYgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbmltcG9ydCB7IEJST1dTRVIgfSBmcm9tICdlc20tZW52JztcblxuY29uc3Qgbm93ID0gQlJPV1NFUiA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogKCkgPT4gRGF0ZS5ub3coKTtcblxuLyoqIEB0eXBlIHtSYWZ9ICovXG5leHBvcnQgY29uc3QgcmFmID0ge1xuXHQvLyBkb24ndCBhY2Nlc3MgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGVhZ2VybHkgb3V0c2lkZSBtZXRob2Rcblx0Ly8gdGhpcyBhbGxvd3MgYmFzaWMgdGVzdGluZyBvZiB1c2VyIGNvZGUgd2l0aG91dCBKU0RPTVxuXHQvLyBidW5kZXIgd2lsbCBldmFsIGFuZCByZW1vdmUgdGVybmFyeSB3aGVuIHRoZSB1c2VyJ3MgYXBwIGlzIGJ1aWx0XG5cdHRpY2s6IC8qKiBAcGFyYW0ge2FueX0gXyAqLyAoXykgPT4gKEJST1dTRVIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBub29wKShfKSxcblx0bm93OiAoKSA9PiBub3coKSxcblx0dGFza3M6IG5ldyBTZXQoKVxufTtcbiIsIi8qKiBAaW1wb3J0IHsgVGFza0NhbGxiYWNrLCBUYXNrLCBUYXNrRW50cnkgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgcmFmIH0gZnJvbSAnLi90aW1pbmcuanMnO1xuXG4vLyBUT0RPIG1vdmUgdGhpcyBpbnRvIHRpbWluZy5qcyB3aGVyZSBpdCBwcm9iYWJseSBiZWxvbmdzXG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJ1bl90YXNrcygpIHtcblx0Ly8gdXNlIGByYWYubm93KClgIGluc3RlYWQgb2YgdGhlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrIGFyZ3VtZW50LCBiZWNhdXNlXG5cdC8vIG90aGVyd2lzZSB0aGluZ3MgY2FuIGdldCB3b25reSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvMTQ1NDFcblx0Y29uc3Qgbm93ID0gcmFmLm5vdygpO1xuXG5cdHJhZi50YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB7XG5cdFx0aWYgKCF0YXNrLmMobm93KSkge1xuXHRcdFx0cmFmLnRhc2tzLmRlbGV0ZSh0YXNrKTtcblx0XHRcdHRhc2suZigpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKHJhZi50YXNrcy5zaXplICE9PSAwKSB7XG5cdFx0cmFmLnRpY2socnVuX3Rhc2tzKTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKiBAcGFyYW0ge1Rhc2tDYWxsYmFja30gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtUYXNrfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9vcChjYWxsYmFjaykge1xuXHQvKiogQHR5cGUge1Rhc2tFbnRyeX0gKi9cblx0bGV0IHRhc2s7XG5cblx0aWYgKHJhZi50YXNrcy5zaXplID09PSAwKSB7XG5cdFx0cmFmLnRpY2socnVuX3Rhc2tzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0cHJvbWlzZTogbmV3IFByb21pc2UoKGZ1bGZpbGwpID0+IHtcblx0XHRcdHJhZi50YXNrcy5hZGQoKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pKTtcblx0XHR9KSxcblx0XHRhYm9ydCgpIHtcblx0XHRcdHJhZi50YXNrcy5kZWxldGUodGFzayk7XG5cdFx0fVxuXHR9O1xufVxuIiwiLyoqIEBpbXBvcnQgeyBBbmltYXRlRm4sIEFuaW1hdGlvbiwgQW5pbWF0aW9uQ29uZmlnLCBFYWNoSXRlbSwgRWZmZWN0LCBUcmFuc2l0aW9uRm4sIFRyYW5zaXRpb25NYW5hZ2VyIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IG5vb3AsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGVmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uLFxuXHR1bnRyYWNrXG59IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgbG9vcCB9IGZyb20gJy4uLy4uL2xvb3AuanMnO1xuaW1wb3J0IHsgc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfZWFjaF9pdGVtIH0gZnJvbSAnLi4vYmxvY2tzL2VhY2guanMnO1xuaW1wb3J0IHsgVFJBTlNJVElPTl9HTE9CQUwsIFRSQU5TSVRJT05fSU4sIFRSQU5TSVRJT05fT1VUIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IEJMT0NLX0VGRkVDVCwgRUZGRUNUX1JBTiwgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vYmluZGluZ3Mvc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7J2ludHJvc3RhcnQnIHwgJ2ludHJvZW5kJyB8ICdvdXRyb3N0YXJ0JyB8ICdvdXRyb2VuZCd9IHR5cGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaF9ldmVudChlbGVtZW50LCB0eXBlKSB7XG5cdHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiB7XG5cdFx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlKSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJvcGVydHkgdG8gdGhlIGNhbWVsLWNhc2UgZm9ybWF0IGV4cGVjdGVkIGJ5IEVsZW1lbnQuYW5pbWF0ZSgpLCBLZXlmcmFtZUVmZmVjdCgpLCBhbmQgS2V5ZnJhbWVFZmZlY3Quc2V0S2V5ZnJhbWVzKCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNzc19wcm9wZXJ0eV90b19jYW1lbGNhc2Uoc3R5bGUpIHtcblx0Ly8gaW4gY29tcGxpYW5jZSB3aXRoIHNwZWNcblx0aWYgKHN0eWxlID09PSAnZmxvYXQnKSByZXR1cm4gJ2Nzc0Zsb2F0Jztcblx0aWYgKHN0eWxlID09PSAnb2Zmc2V0JykgcmV0dXJuICdjc3NPZmZzZXQnO1xuXG5cdC8vIGRvIG5vdCByZW5hbWUgY3VzdG9tIEBwcm9wZXJ0aWVzXG5cdGlmIChzdHlsZS5zdGFydHNXaXRoKCctLScpKSByZXR1cm4gc3R5bGU7XG5cblx0Y29uc3QgcGFydHMgPSBzdHlsZS5zcGxpdCgnLScpO1xuXHRpZiAocGFydHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydHNbMF07XG5cdHJldHVybiAoXG5cdFx0cGFydHNbMF0gK1xuXHRcdHBhcnRzXG5cdFx0XHQuc2xpY2UoMSlcblx0XHRcdC5tYXAoLyoqIEBwYXJhbSB7YW55fSB3b3JkICovICh3b3JkKSA9PiB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuXHRcdFx0LmpvaW4oJycpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1xuICogQHJldHVybnMge0tleWZyYW1lfVxuICovXG5mdW5jdGlvbiBjc3NfdG9fa2V5ZnJhbWUoY3NzKSB7XG5cdC8qKiBAdHlwZSB7S2V5ZnJhbWV9ICovXG5cdGNvbnN0IGtleWZyYW1lID0ge307XG5cdGNvbnN0IHBhcnRzID0gY3NzLnNwbGl0KCc7Jyk7XG5cdGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuXHRcdGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdID0gcGFydC5zcGxpdCgnOicpO1xuXHRcdGlmICghcHJvcGVydHkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG5cblx0XHRjb25zdCBmb3JtYXR0ZWRfcHJvcGVydHkgPSBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHByb3BlcnR5LnRyaW0oKSk7XG5cdFx0a2V5ZnJhbWVbZm9ybWF0dGVkX3Byb3BlcnR5XSA9IHZhbHVlLnRyaW0oKTtcblx0fVxuXHRyZXR1cm4ga2V5ZnJhbWU7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdCAqL1xuY29uc3QgbGluZWFyID0gKHQpID0+IHQ7XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBrZXllZCBgeyNlYWNoIC4uLn1gIGJsb2NrcyAoYXMgYCQuYW5pbWF0aW9uKC4uLilgKS4gVGhpcyBjcmVhdGVzIGFuIGFuaW1hdGlvbiBtYW5hZ2VyXG4gKiBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIGJsb2NrLCBzbyB0aGF0IG1vdmVzIGNhbiBiZSBhbmltYXRlZCBmb2xsb3dpbmcgcmVjb25jaWxpYXRpb24uXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IEFuaW1hdGVGbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuaW1hdGlvbihlbGVtZW50LCBnZXRfZm4sIGdldF9wYXJhbXMpIHtcblx0dmFyIGl0ZW0gPSAvKiogQHR5cGUge0VhY2hJdGVtfSAqLyAoY3VycmVudF9lYWNoX2l0ZW0pO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIGZyb207XG5cblx0LyoqIEB0eXBlIHtET01SZWN0fSAqL1xuXHR2YXIgdG87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBhbmltYXRpb247XG5cblx0LyoqIEB0eXBlIHtudWxsIHwgeyBwb3NpdGlvbjogc3RyaW5nLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZywgdHJhbnNmb3JtOiBzdHJpbmcgfX0gKi9cblx0dmFyIG9yaWdpbmFsX3N0eWxlcyA9IG51bGw7XG5cblx0aXRlbS5hID8/PSB7XG5cdFx0ZWxlbWVudCxcblx0XHRtZWFzdXJlKCkge1xuXHRcdFx0ZnJvbSA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9LFxuXHRcdGFwcGx5KCkge1xuXHRcdFx0YW5pbWF0aW9uPy5hYm9ydCgpO1xuXG5cdFx0XHR0byA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRmcm9tLmxlZnQgIT09IHRvLmxlZnQgfHxcblx0XHRcdFx0ZnJvbS5yaWdodCAhPT0gdG8ucmlnaHQgfHxcblx0XHRcdFx0ZnJvbS50b3AgIT09IHRvLnRvcCB8fFxuXHRcdFx0XHRmcm9tLmJvdHRvbSAhPT0gdG8uYm90dG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3Qgb3B0aW9ucyA9IGdldF9mbigpKHRoaXMuZWxlbWVudCwgeyBmcm9tLCB0byB9LCBnZXRfcGFyYW1zPy4oKSk7XG5cblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSh0aGlzLmVsZW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCwgMSwgKCkgPT4ge1xuXHRcdFx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblx0XHRcdFx0XHRhbmltYXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Zml4KCkge1xuXHRcdFx0Ly8gSWYgYW4gYW5pbWF0aW9uIGlzIGFscmVhZHkgcnVubmluZywgdHJhbnNmb3JtaW5nIHRoZSBlbGVtZW50IGlzIGxpa2VseSB0byBmYWlsLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgc3R5bGVzIGFwcGxpZWQgYnkgdGhlIGFuaW1hdGlvbiB0YWtlIHByZWNlZGVuY2UuIEluIHRoZSBjYXNlIG9mIGNyb3NzZmFkZSxcblx0XHRcdC8vIHRoYXQgbWVhbnMgdGhlIGB0cmFuc2xhdGUoLi4uKWAgb2YgdGhlIGNyb3NzZmFkZSB0cmFuc2l0aW9uIG92ZXJydWxlcyB0aGUgYHRyYW5zbGF0ZSguLi4pYFxuXHRcdFx0Ly8gd2Ugd291bGQgYXBwbHkgYmVsb3csIGxlYWRpbmcgdG8gdGhlIGVsZW1lbnQganVtcGluZyBzb21ld2hlcmUgdG8gdGhlIHRvcCBsZWZ0LlxuXHRcdFx0aWYgKGVsZW1lbnQuZ2V0QW5pbWF0aW9ucygpLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBJdCdzIGltcG9ydGFudCB0byBkZXN0cnVjdHVyZSB0aGVzZSB0byBnZXQgZml4ZWQgdmFsdWVzIC0gdGhlIG9iamVjdCBpdHNlbGYgaGFzIGdldHRlcnMsXG5cdFx0XHQvLyBhbmQgY2hhbmdpbmcgdGhlIHN0eWxlIHRvICdhYnNvbHV0ZScgY2FuIGZvciBleGFtcGxlIGluZmx1ZW5jZSB0aGUgd2lkdGguXG5cdFx0XHR2YXIgeyBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSAqLyAoZWxlbWVudCkuc3R5bGU7XG5cblx0XHRcdFx0b3JpZ2luYWxfc3R5bGVzID0ge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBzdHlsZS5wb3NpdGlvbixcblx0XHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG5cdFx0XHRcdFx0dHJhbnNmb3JtOiBzdHlsZS50cmFuc2Zvcm1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdFx0dmFyIHRvID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRpZiAoZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8IGZyb20udG9wICE9PSB0by50b3ApIHtcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2Zyb20ubGVmdCAtIHRvLmxlZnR9cHgsICR7ZnJvbS50b3AgLSB0by50b3B9cHgpYDtcblx0XHRcdFx0XHRzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPyBgJHtzdHlsZS50cmFuc2Zvcm19ICR7dHJhbnNmb3JtfWAgOiB0cmFuc2Zvcm07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuZml4KCkge1xuXHRcdFx0aWYgKG9yaWdpbmFsX3N0eWxlcykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdHN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxfc3R5bGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IG9yaWdpbmFsX3N0eWxlcy53aWR0aDtcblx0XHRcdFx0c3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxfc3R5bGVzLmhlaWdodDtcblx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gb3JpZ2luYWxfc3R5bGVzLnRyYW5zZm9ybTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gaW4gdGhlIGNhc2Ugb2YgYSBgPHN2ZWx0ZTplbGVtZW50PmAsIGl0J3MgcG9zc2libGUgZm9yIGAkLmFuaW1hdGlvbiguLi4pYCB0byBiZSBjYWxsZWRcblx0Ly8gd2hlbiBhbiBhbmltYXRpb24gbWFuYWdlciBhbHJlYWR5IGV4aXN0cywgaWYgdGhlIHRhZyBjaGFuZ2VzLiBpbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG9cblx0Ly8gc3dhcCBvdXQgdGhlIGVsZW1lbnQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgbWFuYWdlciwgaW4gY2FzZSBpdCBoYXBwZW5lZCBhdCB0aGUgc2FtZVxuXHQvLyBtb21lbnQgYXMgYSByZWNvbmNpbGlhdGlvblxuXHRpdGVtLmEuZWxlbWVudCA9IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2FsbGVkIGluc2lkZSBibG9jayBlZmZlY3RzIGFzIGAkLnRyYW5zaXRpb24oLi4uKWAuIFRoaXMgY3JlYXRlcyBhIHRyYW5zaXRpb24gbWFuYWdlciBhbmRcbiAqIGF0dGFjaGVzIGl0IHRvIHRoZSBjdXJyZW50IGVmZmVjdCDigJQgbGF0ZXIsIGluc2lkZSBgcGF1c2VfZWZmZWN0YCBhbmQgYHJlc3VtZV9lZmZlY3RgLCB3ZVxuICogdXNlIHRoaXMgdG8gY3JlYXRlIGBpbnRyb2AgYW5kIGBvdXRyb2AgdHJhbnNpdGlvbnMuXG4gKiBAdGVtcGxhdGUgUFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geygpID0+IFRyYW5zaXRpb25GbjxQIHwgdW5kZWZpbmVkPn0gZ2V0X2ZuXG4gKiBAcGFyYW0geygoKSA9PiBQKSB8IG51bGx9IGdldF9wYXJhbXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNpdGlvbihmbGFncywgZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpc19pbnRybyA9IChmbGFncyAmIFRSQU5TSVRJT05fSU4pICE9PSAwO1xuXHR2YXIgaXNfb3V0cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX09VVCkgIT09IDA7XG5cdHZhciBpc19ib3RoID0gaXNfaW50cm8gJiYgaXNfb3V0cm87XG5cdHZhciBpc19nbG9iYWwgPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0dMT0JBTCkgIT09IDA7XG5cblx0LyoqIEB0eXBlIHsnaW4nIHwgJ291dCcgfCAnYm90aCd9ICovXG5cdHZhciBkaXJlY3Rpb24gPSBpc19ib3RoID8gJ2JvdGgnIDogaXNfaW50cm8gPyAnaW4nIDogJ291dCc7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb25Db25maWcgfCAoKG9wdHM6IHsgZGlyZWN0aW9uOiAnaW4nIHwgJ291dCcgfSkgPT4gQW5pbWF0aW9uQ29uZmlnKSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGN1cnJlbnRfb3B0aW9ucztcblxuXHR2YXIgaW5lcnQgPSBlbGVtZW50LmluZXJ0O1xuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBvdmVyZmxvdyBzdHlsZSwgc3Rhc2hlZCBzbyB3ZSBjYW4gcmV2ZXJ0IGNoYW5nZXMgZHVyaW5nIHRoZSB0cmFuc2l0aW9uXG5cdCAqIHRoYXQgYXJlIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSA8MTggYnVnXG5cdCAqIFRPRE8gNi4wIHJlbW92ZSB0aGlzLCBpZiBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgaGF2ZSBkaWVkIG91dCBlbm91Z2hcblx0ICovXG5cdHZhciBvdmVyZmxvdyA9IGVsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBpbnRybztcblxuXHQvKiogQHR5cGUge0FuaW1hdGlvbiB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIG91dHJvO1xuXG5cdGZ1bmN0aW9uIGdldF9vcHRpb25zKCkge1xuXHRcdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRcdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBJZiBhIHRyYW5zaXRpb24gaXMgc3RpbGwgb25nb2luZywgd2UgdXNlIHRoZSBleGlzdGluZyBvcHRpb25zIHJhdGhlciB0aGFuIGdlbmVyYXRpbmdcblx0XHRcdC8vIG5ldyBvbmVzLiBUaGlzIGVuc3VyZXMgdGhhdCByZXZlcnNpYmxlIHRyYW5zaXRpb25zIHJldmVyc2Ugc21vb3RobHksIHJhdGhlciB0aGFuXG5cdFx0XHQvLyBqdW1waW5nIHRvIGEgbmV3IHNwb3QgYmVjYXVzZSAoZm9yIGV4YW1wbGUpIGEgZGlmZmVyZW50IGBkdXJhdGlvbmAgd2FzIHVzZWRcblx0XHRcdHJldHVybiAoY3VycmVudF9vcHRpb25zID8/PSBnZXRfZm4oKShlbGVtZW50LCBnZXRfcGFyYW1zPy4oKSA/PyAvKiogQHR5cGUge1B9ICovICh7fSksIHtcblx0XHRcdFx0ZGlyZWN0aW9uXG5cdFx0XHR9KSk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHR9XG5cdH1cblxuXHQvKiogQHR5cGUge1RyYW5zaXRpb25NYW5hZ2VyfSAqL1xuXHR2YXIgdHJhbnNpdGlvbiA9IHtcblx0XHRpc19nbG9iYWwsXG5cdFx0aW4oKSB7XG5cdFx0XHRlbGVtZW50LmluZXJ0ID0gaW5lcnQ7XG5cblx0XHRcdGlmICghaXNfaW50cm8pIHtcblx0XHRcdFx0b3V0cm8/LmFib3J0KCk7XG5cdFx0XHRcdG91dHJvPy5yZXNldD8uKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc19vdXRybykge1xuXHRcdFx0XHQvLyBpZiB3ZSBpbnRybyB0aGVuIG91dHJvIHRoZW4gaW50cm8gYWdhaW4sIHdlIHdhbnQgdG8gYWJvcnQgdGhlIGZpcnN0IGludHJvLFxuXHRcdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJpZGlyZWN0aW9uYWwgdHJhbnNpdGlvblxuXHRcdFx0XHRpbnRybz8uYWJvcnQoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ2ludHJvc3RhcnQnKTtcblxuXHRcdFx0aW50cm8gPSBhbmltYXRlKGVsZW1lbnQsIGdldF9vcHRpb25zKCksIG91dHJvLCAxLCAoKSA9PiB7XG5cdFx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdpbnRyb2VuZCcpO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB3ZSBjYW5jZWwgdGhlIGFuaW1hdGlvbiB0byBwcmV2ZW50IGxlYWtpbmdcblx0XHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHRcdGludHJvID0gY3VycmVudF9vcHRpb25zID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvdztcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0b3V0KGZuKSB7XG5cdFx0XHRpZiAoIWlzX291dHJvKSB7XG5cdFx0XHRcdGZuPy4oKTtcblx0XHRcdFx0Y3VycmVudF9vcHRpb25zID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQuaW5lcnQgPSB0cnVlO1xuXG5cdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnb3V0cm9zdGFydCcpO1xuXG5cdFx0XHRvdXRybyA9IGFuaW1hdGUoZWxlbWVudCwgZ2V0X29wdGlvbnMoKSwgaW50cm8sIDAsICgpID0+IHtcblx0XHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ291dHJvZW5kJyk7XG5cdFx0XHRcdGZuPy4oKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0c3RvcDogKCkgPT4ge1xuXHRcdFx0aW50cm8/LmFib3J0KCk7XG5cdFx0XHRvdXRybz8uYWJvcnQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGUgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdChlLnRyYW5zaXRpb25zID8/PSBbXSkucHVzaCh0cmFuc2l0aW9uKTtcblxuXHQvLyBpZiB0aGlzIGlzIGEgbG9jYWwgdHJhbnNpdGlvbiwgd2Ugb25seSB3YW50IHRvIHJ1biBpdCBpZiB0aGUgcGFyZW50IChicmFuY2gpIGVmZmVjdCdzXG5cdC8vIHBhcmVudCAoYmxvY2spIGVmZmVjdCBpcyB3aGVyZSB0aGUgc3RhdGUgY2hhbmdlIGhhcHBlbmVkLiB3ZSBjYW4gZGV0ZXJtaW5lIHRoYXQgYnlcblx0Ly8gbG9va2luZyBhdCB3aGV0aGVyIHRoZSBibG9jayBlZmZlY3QgaXMgY3VycmVudGx5IGluaXRpYWxpemluZ1xuXHRpZiAoaXNfaW50cm8gJiYgc2hvdWxkX2ludHJvKSB7XG5cdFx0dmFyIHJ1biA9IGlzX2dsb2JhbDtcblxuXHRcdGlmICghcnVuKSB7XG5cdFx0XHR2YXIgYmxvY2sgPSAvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovIChlLnBhcmVudCk7XG5cblx0XHRcdC8vIHNraXAgb3ZlciB0cmFuc3BhcmVudCBibG9ja3MgKGUuZy4gc25pcHBldHMsIGVsc2UtaWYgYmxvY2tzKVxuXHRcdFx0d2hpbGUgKGJsb2NrICYmIChibG9jay5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCkge1xuXHRcdFx0XHR3aGlsZSAoKGJsb2NrID0gYmxvY2sucGFyZW50KSkge1xuXHRcdFx0XHRcdGlmICgoYmxvY2suZiAmIEJMT0NLX0VGRkVDVCkgIT09IDApIGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJ1biA9ICFibG9jayB8fCAoYmxvY2suZiAmIEVGRkVDVF9SQU4pICE9PSAwO1xuXHRcdH1cblxuXHRcdGlmIChydW4pIHtcblx0XHRcdGVmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdHVudHJhY2soKCkgPT4gdHJhbnNpdGlvbi5pbigpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEFuaW1hdGVzIGFuIGVsZW1lbnQsIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge0FuaW1hdGlvbkNvbmZpZyB8ICgob3B0czogeyBkaXJlY3Rpb246ICdpbicgfCAnb3V0JyB9KSA9PiBBbmltYXRpb25Db25maWcpfSBvcHRpb25zXG4gKiBAcGFyYW0ge0FuaW1hdGlvbiB8IHVuZGVmaW5lZH0gY291bnRlcnBhcnQgVGhlIGNvcnJlc3BvbmRpbmcgaW50cm8vb3V0cm8gdG8gdGhpcyBvdXRyby9pbnRyb1xuICogQHBhcmFtIHtudW1iZXJ9IHQyIFRoZSB0YXJnZXQgYHRgIHZhbHVlIOKAlCBgMWAgZm9yIGludHJvLCBgMGAgZm9yIG91dHJvXG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gb25fZmluaXNoIENhbGxlZCBhZnRlciBzdWNjZXNzZnVsbHkgY29tcGxldGluZyB0aGUgYW5pbWF0aW9uXG4gKiBAcmV0dXJucyB7QW5pbWF0aW9ufVxuICovXG5mdW5jdGlvbiBhbmltYXRlKGVsZW1lbnQsIG9wdGlvbnMsIGNvdW50ZXJwYXJ0LCB0Miwgb25fZmluaXNoKSB7XG5cdHZhciBpc19pbnRybyA9IHQyID09PSAxO1xuXG5cdGlmIChpc19mdW5jdGlvbihvcHRpb25zKSkge1xuXHRcdC8vIEluIHRoZSBjYXNlIG9mIGEgZGVmZXJyZWQgdHJhbnNpdGlvbiAoc3VjaCBhcyBgY3Jvc3NmYWRlYCksIGBvcHRpb25gIHdpbGwgYmVcblx0XHQvLyBhIGZ1bmN0aW9uIHJhdGhlciB0aGFuIGFuIGBBbmltYXRpb25Db25maWdgLiBXZSBuZWVkIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuXHRcdC8vIG9uY2UgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkLi4uXG5cdFx0LyoqIEB0eXBlIHtBbmltYXRpb259ICovXG5cdFx0dmFyIGE7XG5cdFx0dmFyIGFib3J0ZWQgPSBmYWxzZTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGFib3J0ZWQpIHJldHVybjtcblx0XHRcdHZhciBvID0gb3B0aW9ucyh7IGRpcmVjdGlvbjogaXNfaW50cm8gPyAnaW4nIDogJ291dCcgfSk7XG5cdFx0XHRhID0gYW5pbWF0ZShlbGVtZW50LCBvLCBjb3VudGVycGFydCwgdDIsIG9uX2ZpbmlzaCk7XG5cdFx0fSk7XG5cblx0XHQvLyAuLi5idXQgd2Ugd2FudCB0byBkbyBzbyB3aXRob3V0IHVzaW5nIGBhc3luY2AvYGF3YWl0YCBldmVyeXdoZXJlLCBzb1xuXHRcdC8vIHdlIHJldHVybiBhIGZhY2FkZSB0aGF0IGFsbG93cyBldmVyeXRoaW5nIHRvIHJlbWFpbiBzeW5jaHJvbm91c1xuXHRcdHJldHVybiB7XG5cdFx0XHRhYm9ydDogKCkgPT4ge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0YT8uYWJvcnQoKTtcblx0XHRcdH0sXG5cdFx0XHRkZWFjdGl2YXRlOiAoKSA9PiBhLmRlYWN0aXZhdGUoKSxcblx0XHRcdHJlc2V0OiAoKSA9PiBhLnJlc2V0KCksXG5cdFx0XHR0OiAoKSA9PiBhLnQoKVxuXHRcdH07XG5cdH1cblxuXHRjb3VudGVycGFydD8uZGVhY3RpdmF0ZSgpO1xuXG5cdGlmICghb3B0aW9ucz8uZHVyYXRpb24pIHtcblx0XHRvbl9maW5pc2goKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRhYm9ydDogbm9vcCxcblx0XHRcdGRlYWN0aXZhdGU6IG5vb3AsXG5cdFx0XHRyZXNldDogbm9vcCxcblx0XHRcdHQ6ICgpID0+IHQyXG5cdFx0fTtcblx0fVxuXG5cdGNvbnN0IHsgZGVsYXkgPSAwLCBjc3MsIHRpY2ssIGVhc2luZyA9IGxpbmVhciB9ID0gb3B0aW9ucztcblxuXHR2YXIga2V5ZnJhbWVzID0gW107XG5cblx0aWYgKGlzX2ludHJvICYmIGNvdW50ZXJwYXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAodGljaykge1xuXHRcdFx0dGljaygwLCAxKTsgLy8gVE9ETyBwdXQgaW4gbmVzdGVkIGVmZmVjdCwgdG8gYXZvaWQgaW50ZXJsZWF2ZWQgcmVhZHMvd3JpdGVzP1xuXHRcdH1cblxuXHRcdGlmIChjc3MpIHtcblx0XHRcdHZhciBzdHlsZXMgPSBjc3NfdG9fa2V5ZnJhbWUoY3NzKDAsIDEpKTtcblx0XHRcdGtleWZyYW1lcy5wdXNoKHN0eWxlcywgc3R5bGVzKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgZ2V0X3QgPSAoKSA9PiAxIC0gdDI7XG5cblx0Ly8gY3JlYXRlIGEgZHVtbXkgYW5pbWF0aW9uIHRoYXQgbGFzdHMgYXMgbG9uZyBhcyB0aGUgZGVsYXkgKGJ1dCB3aXRoIHdoYXRldmVyIGRldnRvb2xzXG5cdC8vIG11bHRpcGxpZXIgaXMgaW4gZWZmZWN0KS4gaW4gdGhlIGNvbW1vbiBjYXNlIHRoYXQgaXQgaXMgYDBgLCB3ZSBrZWVwIGl0IGFueXdheSBzbyB0aGF0XG5cdC8vIHRoZSBDU1Mga2V5ZnJhbWVzIGFyZW4ndCBjcmVhdGVkIHVudGlsIHRoZSBET00gaXMgdXBkYXRlZFxuXHR2YXIgYW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbjogZGVsYXkgfSk7XG5cblx0YW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuXHRcdC8vIGZvciBiaWRpcmVjdGlvbmFsIHRyYW5zaXRpb25zLCB3ZSBzdGFydCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLFxuXHRcdC8vIHJhdGhlciB0aGFuIGRvaW5nIGEgZnVsbCBpbnRyby9vdXRyb1xuXHRcdHZhciB0MSA9IGNvdW50ZXJwYXJ0Py50KCkgPz8gMSAtIHQyO1xuXHRcdGNvdW50ZXJwYXJ0Py5hYm9ydCgpO1xuXG5cdFx0dmFyIGRlbHRhID0gdDIgLSB0MTtcblx0XHR2YXIgZHVyYXRpb24gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKG9wdGlvbnMuZHVyYXRpb24pICogTWF0aC5hYnMoZGVsdGEpO1xuXHRcdHZhciBrZXlmcmFtZXMgPSBbXTtcblxuXHRcdGlmIChkdXJhdGlvbiA+IDApIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogV2hldGhlciBvciBub3QgdGhlIENTUyBpbmNsdWRlcyBgb3ZlcmZsb3c6IGhpZGRlbmAsIGluIHdoaWNoIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdFx0ICogYWRkIGl0IGFzIGFuIGlubGluZSBzdHlsZSB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSA8MTggYnVnXG5cdFx0XHQgKiBUT0RPIDYuMCByZW1vdmUgdGhpcywgaWYgcG9zc2libGVcblx0XHRcdCAqL1xuXHRcdFx0dmFyIG5lZWRzX292ZXJmbG93X2hpZGRlbiA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoY3NzKSB7XG5cdFx0XHRcdHZhciBuID0gTWF0aC5jZWlsKGR1cmF0aW9uIC8gKDEwMDAgLyA2MCkpOyAvLyBgbmAgbXVzdCBiZSBhbiBpbnRlZ2VyLCBvciB3ZSByaXNrIG1pc3NpbmcgdGhlIGB0MmAgdmFsdWVcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBuOyBpICs9IDEpIHtcblx0XHRcdFx0XHR2YXIgdCA9IHQxICsgZGVsdGEgKiBlYXNpbmcoaSAvIG4pO1xuXHRcdFx0XHRcdHZhciBzdHlsZXMgPSBjc3NfdG9fa2V5ZnJhbWUoY3NzKHQsIDEgLSB0KSk7XG5cdFx0XHRcdFx0a2V5ZnJhbWVzLnB1c2goc3R5bGVzKTtcblxuXHRcdFx0XHRcdG5lZWRzX292ZXJmbG93X2hpZGRlbiB8fD0gc3R5bGVzLm92ZXJmbG93ID09PSAnaGlkZGVuJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVlZHNfb3ZlcmZsb3dfaGlkZGVuKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChlbGVtZW50KS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXHRcdFx0fVxuXG5cdFx0XHRnZXRfdCA9ICgpID0+IHtcblx0XHRcdFx0dmFyIHRpbWUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7Z2xvYmFsVGhpcy5BbmltYXRpb259ICovIChhbmltYXRpb24pLmN1cnJlbnRUaW1lXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cmV0dXJuIHQxICsgZGVsdGEgKiBlYXNpbmcodGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdH07XG5cblx0XHRcdGlmICh0aWNrKSB7XG5cdFx0XHRcdGxvb3AoKCkgPT4ge1xuXHRcdFx0XHRcdGlmIChhbmltYXRpb24ucGxheVN0YXRlICE9PSAncnVubmluZycpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdHZhciB0ID0gZ2V0X3QoKTtcblx0XHRcdFx0XHR0aWNrKHQsIDEgLSB0KTtcblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhbmltYXRpb24gPSBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCB7IGR1cmF0aW9uLCBmaWxsOiAnZm9yd2FyZHMnIH0pO1xuXG5cdFx0YW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuXHRcdFx0Z2V0X3QgPSAoKSA9PiB0Mjtcblx0XHRcdHRpY2s/Lih0MiwgMSAtIHQyKTtcblx0XHRcdG9uX2ZpbmlzaCgpO1xuXHRcdH07XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRhYm9ydDogKCkgPT4ge1xuXHRcdFx0aWYgKGFuaW1hdGlvbikge1xuXHRcdFx0XHRhbmltYXRpb24uY2FuY2VsKCk7XG5cdFx0XHRcdC8vIFRoaXMgcHJldmVudHMgbWVtb3J5IGxlYWtzIGluIENocm9taXVtXG5cdFx0XHRcdGFuaW1hdGlvbi5lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHQvLyBUaGlzIHByZXZlbnRzIG9uZmluaXNoIHRvIGJlIGxhdW5jaGVkIGFmdGVyIGNhbmNlbCgpLFxuXHRcdFx0XHQvLyB3aGljaCBjYW4gaGFwcGVuIGluIHNvbWUgcmFyZSBjYXNlc1xuXHRcdFx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMTM2ODFcblx0XHRcdFx0YW5pbWF0aW9uLm9uZmluaXNoID0gbm9vcDtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlYWN0aXZhdGU6ICgpID0+IHtcblx0XHRcdG9uX2ZpbmlzaCA9IG5vb3A7XG5cdFx0fSxcblx0XHRyZXNldDogKCkgPT4ge1xuXHRcdFx0aWYgKHQyID09PSAwKSB7XG5cdFx0XHRcdHRpY2s/LigxLCAwKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHQ6ICgpID0+IGdldF90KClcblx0fTtcbn1cbiIsImltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgcmVuZGVyX2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudCB9IGZyb20gJy4vc2hhcmVkLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi4vLi4vLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uLy4uL3Rhc2suanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGlzX3J1bmVzIH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF92YWx1ZShpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIHJ1bmVzID0gaXNfcnVuZXMoKTtcblxuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnaW5wdXQnLCAoaXNfcmVzZXQpID0+IHtcblx0XHRpZiAoREVWICYmIGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKTtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge2FueX0gKi9cblx0XHR2YXIgdmFsdWUgPSBpc19yZXNldCA/IGlucHV0LmRlZmF1bHRWYWx1ZSA6IGlucHV0LnZhbHVlO1xuXHRcdHZhbHVlID0gaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkgPyB0b19udW1iZXIodmFsdWUpIDogdmFsdWU7XG5cdFx0c2V0KHZhbHVlKTtcblxuXHRcdC8vIEluIHJ1bmVzIG1vZGUsIHJlc3BlY3QgYW55IHZhbGlkYXRpb24gaW4gYWNjZXNzb3JzIChkb2Vzbid0IGFwcGx5IGluIGxlZ2FjeSBtb2RlLFxuXHRcdC8vIGJlY2F1c2Ugd2UgdXNlIG11dGFibGUgc3RhdGUgd2hpY2ggZW5zdXJlcyB0aGUgcmVuZGVyIGVmZmVjdCBhbHdheXMgcnVucylcblx0XHRpZiAocnVuZXMgJiYgdmFsdWUgIT09ICh2YWx1ZSA9IGdldCgpKSkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQ7XG5cdFx0XHR2YXIgZW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuXG5cdFx0XHQvLyB0aGUgdmFsdWUgaXMgY29lcmNlZCBvbiBhc3NpZ25tZW50XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlID8/ICcnO1xuXG5cdFx0XHQvLyBSZXN0b3JlIHNlbGVjdGlvblxuXHRcdFx0aWYgKGVuZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLFxuXHRcdC8vIHRoZW4gdXNlIHRoZSB1cGRhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0KGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0VmFsdWUgIT09IGlucHV0LnZhbHVlKSB8fFxuXHRcdC8vIElmIGRlZmF1bHRWYWx1ZSBpcyBzZXQsIHRoZW4gdmFsdWUgPT0gZGVmYXVsdFZhbHVlXG5cdFx0Ly8gVE9ETyBTdmVsdGUgNjogcmVtb3ZlIGlucHV0LnZhbHVlIGNoZWNrIGFuZCBzZXQgdG8gZW1wdHkgc3RyaW5nP1xuXHRcdCh1bnRyYWNrKGdldCkgPT0gbnVsbCAmJiBpbnB1dC52YWx1ZSlcblx0KSB7XG5cdFx0c2V0KGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpID8gdG9fbnVtYmVyKGlucHV0LnZhbHVlKSA6IGlucHV0LnZhbHVlKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChERVYgJiYgaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLmJpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZSgpO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXG5cdFx0aWYgKGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpICYmIHZhbHVlID09PSB0b19udW1iZXIoaW5wdXQudmFsdWUpKSB7XG5cdFx0XHQvLyBoYW5kbGVzIDAgdnMgMDAgY2FzZSAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzk5NTkpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGlucHV0LnR5cGUgPT09ICdkYXRlJyAmJiAhdmFsdWUgJiYgIWlucHV0LnZhbHVlKSB7XG5cdFx0XHQvLyBIYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgdGVtcG9yYXJpbHkgaW52YWxpZCBkYXRlIGlzIHNldCAod2hpbGUgdHlwaW5nLCBmb3IgZXhhbXBsZSB3aXRoIGEgbGVhZGluZyAwIGZvciB0aGUgZGF5KVxuXHRcdFx0Ly8gYW5kIHByZXZlbnRzIHRoaXMgc3RhdGUgZnJvbSBjbGVhcmluZyB0aGUgb3RoZXIgcGFydHMgb2YgdGhlIGRhdGUgaW5wdXQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy83ODk3KVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IHNldCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGlmIGl0J3MgdGhlIHNhbWUgdG8gYWxsb3dcblx0XHQvLyBtaW5sZW5ndGggdG8gd29yayBwcm9wZXJseVxuXHRcdGlmICh2YWx1ZSAhPT0gaW5wdXQudmFsdWUpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHZhbHVlIGlzIGNvZXJjZWQgb24gYXNzaWdubWVudFxuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZSA/PyAnJztcblx0XHR9XG5cdH0pO1xufVxuXG4vKiogQHR5cGUge1NldDxIVE1MSW5wdXRFbGVtZW50W10+fSAqL1xuY29uc3QgcGVuZGluZyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnRbXX0gaW5wdXRzXG4gKiBAcGFyYW0ge251bGwgfCBbbnVtYmVyXX0gZ3JvdXBfaW5kZXhcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZ3JvdXAoaW5wdXRzLCBncm91cF9pbmRleCwgaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBpc19jaGVja2JveCA9IGlucHV0LmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnY2hlY2tib3gnO1xuXHR2YXIgYmluZGluZ19ncm91cCA9IGlucHV0cztcblxuXHQvLyBuZWVkcyB0byBiZSBsZXQgb3IgcmVsYXRlZCBjb2RlIGlzbid0IHRyZWVzaGFrZW4gb3V0IGlmIGl0J3MgYWx3YXlzIGZhbHNlXG5cdGxldCBoeWRyYXRpb25fbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRpZiAoZ3JvdXBfaW5kZXggIT09IG51bGwpIHtcblx0XHRmb3IgKHZhciBpbmRleCBvZiBncm91cF9pbmRleCkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0YmluZGluZ19ncm91cCA9IGJpbmRpbmdfZ3JvdXBbaW5kZXhdID8/PSBbXTtcblx0XHR9XG5cdH1cblxuXHRiaW5kaW5nX2dyb3VwLnB1c2goaW5wdXQpO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoXG5cdFx0aW5wdXQsXG5cdFx0J2NoYW5nZScsXG5cdFx0KCkgPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dmFyIHZhbHVlID0gaW5wdXQuX192YWx1ZTtcblxuXHRcdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoYmluZGluZ19ncm91cCwgdmFsdWUsIGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXQodmFsdWUpO1xuXHRcdH0sXG5cdFx0Ly8gVE9ETyBiZXR0ZXIgZGVmYXVsdCB2YWx1ZSBoYW5kbGluZ1xuXHRcdCgpID0+IHNldChpc19jaGVja2JveCA/IFtdIDogbnVsbClcblx0KTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCwgdGhlbiB1c2UgdGhlIHVwZGF0ZSB2YWx1ZVxuXHRcdC8vIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0aWYgKGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0Q2hlY2tlZCAhPT0gaW5wdXQuY2hlY2tlZCkge1xuXHRcdFx0aHlkcmF0aW9uX21pc21hdGNoID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgW107XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRpbnB1dC5jaGVja2VkID0gdmFsdWUuaW5jbHVkZXMoaW5wdXQuX192YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGlucHV0LmNoZWNrZWQgPSBpcyhpbnB1dC5fX3ZhbHVlLCB2YWx1ZSk7XG5cdFx0fVxuXHR9KTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0dmFyIGluZGV4ID0gYmluZGluZ19ncm91cC5pbmRleE9mKGlucHV0KTtcblxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGJpbmRpbmdfZ3JvdXAuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmICghcGVuZGluZy5oYXMoYmluZGluZ19ncm91cCkpIHtcblx0XHRwZW5kaW5nLmFkZChiaW5kaW5nX2dyb3VwKTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0Ly8gbmVjZXNzYXJ5IHRvIG1haW50YWluIGJpbmRpbmcgZ3JvdXAgb3JkZXIgaW4gYWxsIGluc2VydGlvbiBzY2VuYXJpb3Ncblx0XHRcdGJpbmRpbmdfZ3JvdXAuc29ydCgoYSwgYikgPT4gKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgPT09IDQgPyAtMSA6IDEpKTtcblx0XHRcdHBlbmRpbmcuZGVsZXRlKGJpbmRpbmdfZ3JvdXApO1xuXHRcdH0pO1xuXHR9XG5cblx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGlvbl9taXNtYXRjaCkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXG5cdFx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfYmluZGluZ19ncm91cF92YWx1ZShiaW5kaW5nX2dyb3VwLCB2YWx1ZSwgaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaHlkcmF0aW9uX2lucHV0ID0gYmluZGluZ19ncm91cC5maW5kKChpbnB1dCkgPT4gaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0dmFsdWUgPSBoeWRyYXRpb25faW5wdXQ/Ll9fdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHNldCh2YWx1ZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2NoZWNrZWQoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdjaGFuZ2UnLCAoaXNfcmVzZXQpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBpc19yZXNldCA/IGlucHV0LmRlZmF1bHRDaGVja2VkIDogaW5wdXQuY2hlY2tlZDtcblx0XHRzZXQodmFsdWUpO1xuXHR9KTtcblxuXHRpZiAoXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLFxuXHRcdC8vIHRoZW4gdXNlIHRoZSB1cGRhdGUgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHQoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRDaGVja2VkICE9PSBpbnB1dC5jaGVja2VkKSB8fFxuXHRcdC8vIElmIGRlZmF1bHRDaGVja2VkIGlzIHNldCwgdGhlbiBjaGVja2VkID09IGRlZmF1bHRDaGVja2VkXG5cdFx0dW50cmFjayhnZXQpID09IG51bGxcblx0KSB7XG5cdFx0c2V0KGlucHV0LmNoZWNrZWQpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cdFx0aW5wdXQuY2hlY2tlZCA9IEJvb2xlYW4odmFsdWUpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtBcnJheTxIVE1MSW5wdXRFbGVtZW50Pn0gZ3JvdXBcbiAqIEBwYXJhbSB7Vn0gX192YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKiBAcmV0dXJucyB7VltdfVxuICovXG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuXHR2YXIgdmFsdWUgPSBuZXcgU2V0KCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChncm91cFtpXS5jaGVja2VkKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHR2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFjaGVja2VkKSB7XG5cdFx0dmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaXNfbnVtYmVybGlrZV9pbnB1dChpbnB1dCkge1xuXHR2YXIgdHlwZSA9IGlucHV0LnR5cGU7XG5cdHJldHVybiB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAncmFuZ2UnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiArdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHsoKSA9PiBGaWxlTGlzdCB8IG51bGx9IGdldFxuICogQHBhcmFtIHsodmFsdWU6IEZpbGVMaXN0IHwgbnVsbCkgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ZpbGVzKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHRsaXN0ZW5fdG9fZXZlbnRfYW5kX3Jlc2V0X2V2ZW50KGlucHV0LCAnY2hhbmdlJywgKCkgPT4ge1xuXHRcdHNldChpbnB1dC5maWxlcyk7XG5cdH0pO1xuXG5cdGlmIChcblx0XHQvLyBJZiB3ZSBhcmUgaHlkcmF0aW5nIGFuZCB0aGUgdmFsdWUgaGFzIHNpbmNlIGNoYW5nZWQsXG5cdFx0Ly8gdGhlbiB1c2UgdGhlIHVwZGF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHRoeWRyYXRpbmcgJiZcblx0XHRpbnB1dC5maWxlc1xuXHQpIHtcblx0XHRzZXQoaW5wdXQuZmlsZXMpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aW5wdXQuZmlsZXMgPSBnZXQoKTtcblx0fSk7XG59XG4iLCJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogTWFrZXMgYW4gYGV4cG9ydGBlZCAobm9uLXByb3ApIHZhcmlhYmxlIGF2YWlsYWJsZSBvbiB0aGUgYCQkcHJvcHNgIG9iamVjdFxuICogc28gdGhhdCBjb25zdW1lcnMgY2FuIGRvIGBiaW5kOnhgIG9uIHRoZSBjb21wb25lbnQuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcHJvcChwcm9wcywgcHJvcCwgdmFsdWUpIHtcblx0dmFyIGRlc2MgPSBnZXRfZGVzY3JpcHRvcihwcm9wcywgcHJvcCk7XG5cblx0aWYgKGRlc2MgJiYgZGVzYy5zZXQpIHtcblx0XHRwcm9wc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdHByb3BzW3Byb3BdID0gbnVsbDtcblx0XHR9KTtcblx0fVxufVxuIiwiaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcblxuLyoqXG4gKiBTZWxlY3RzIHRoZSBjb3JyZWN0IG9wdGlvbihzKSAoZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdClcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW21vdW50aW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZykge1xuXHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0cmV0dXJuIHNlbGVjdF9vcHRpb25zKHNlbGVjdCwgdmFsdWUpO1xuXHR9XG5cblx0Zm9yICh2YXIgb3B0aW9uIG9mIHNlbGVjdC5vcHRpb25zKSB7XG5cdFx0dmFyIG9wdGlvbl92YWx1ZSA9IGdldF9vcHRpb25fdmFsdWUob3B0aW9uKTtcblx0XHRpZiAoaXMob3B0aW9uX3ZhbHVlLCB2YWx1ZSkpIHtcblx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFtb3VudGluZyB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxuXHR9XG59XG5cbi8qKlxuICogU2VsZWN0cyB0aGUgY29ycmVjdCBvcHRpb24ocykgaWYgYHZhbHVlYCBpcyBnaXZlbixcbiAqIGFuZCB0aGVuIHNldHMgdXAgYSBtdXRhdGlvbiBvYnNlcnZlciB0byBzeW5jIHRoZVxuICogY3VycmVudCBzZWxlY3Rpb24gdG8gdGhlIGRvbSB3aGVuIGl0IGNoYW5nZXMuIFN1Y2hcbiAqIGNoYW5nZXMgY291bGQgZm9yIGV4YW1wbGUgb2NjdXIgd2hlbiBvcHRpb25zIGFyZVxuICogaW5zaWRlIGFuIGAjZWFjaGAgYmxvY2suXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0geygpID0+IFZ9IFtnZXRfdmFsdWVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X3NlbGVjdChzZWxlY3QsIGdldF92YWx1ZSkge1xuXHRsZXQgbW91bnRpbmcgPSB0cnVlO1xuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdGlmIChnZXRfdmFsdWUpIHtcblx0XHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCB1bnRyYWNrKGdldF92YWx1ZSksIG1vdW50aW5nKTtcblx0XHR9XG5cdFx0bW91bnRpbmcgPSBmYWxzZTtcblxuXHRcdHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHZhciB2YWx1ZSA9IHNlbGVjdC5fX3ZhbHVlO1xuXHRcdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKTtcblx0XHRcdC8vIERlbGliZXJhdGVseSBkb24ndCB1cGRhdGUgdGhlIHBvdGVudGlhbCBiaW5kaW5nIHZhbHVlLFxuXHRcdFx0Ly8gdGhlIG1vZGVsIHNob3VsZCBiZSBwcmVzZXJ2ZWQgdW5sZXNzIGV4cGxpY2l0bHkgY2hhbmdlZFxuXHRcdH0pO1xuXG5cdFx0b2JzZXJ2ZXIub2JzZXJ2ZShzZWxlY3QsIHtcblx0XHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCBjaGFuZ2VzXG5cdFx0XHRjaGlsZExpc3Q6IHRydWUsXG5cdFx0XHRzdWJ0cmVlOiB0cnVlLCAvLyBiZWNhdXNlIG9mIDxvcHRncm91cD5cblx0XHRcdC8vIExpc3RlbiB0byBvcHRpb24gZWxlbWVudCB2YWx1ZSBhdHRyaWJ1dGUgY2hhbmdlc1xuXHRcdFx0Ly8gKGRvZXNuJ3QgZ2V0IG5vdGlmaWVkIG9mIHNlbGVjdCB2YWx1ZSBjaGFuZ2VzLFxuXHRcdFx0Ly8gYmVjYXVzZSB0aGF0IHByb3BlcnR5IGlzIG5vdCByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlKVxuXHRcdFx0YXR0cmlidXRlczogdHJ1ZSxcblx0XHRcdGF0dHJpYnV0ZUZpbHRlcjogWyd2YWx1ZSddXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHRcdH07XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9zZWxlY3RfdmFsdWUoc2VsZWN0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgbW91bnRpbmcgPSB0cnVlO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoc2VsZWN0LCAnY2hhbmdlJywgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0dmFyIHF1ZXJ5ID0gaXNfcmVzZXQgPyAnW3NlbGVjdGVkXScgOiAnOmNoZWNrZWQnO1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bn0gKi9cblx0XHR2YXIgdmFsdWU7XG5cblx0XHRpZiAoc2VsZWN0Lm11bHRpcGxlKSB7XG5cdFx0XHR2YWx1ZSA9IFtdLm1hcC5jYWxsKHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSwgZ2V0X29wdGlvbl92YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qKiBAdHlwZSB7SFRNTE9wdGlvbkVsZW1lbnQgfCBudWxsfSAqL1xuXHRcdFx0dmFyIHNlbGVjdGVkX29wdGlvbiA9XG5cdFx0XHRcdHNlbGVjdC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSA/P1xuXHRcdFx0XHQvLyB3aWxsIGZhbGwgYmFjayB0byBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uIGlmIG5vIG9wdGlvbiBpcyBzZWxlY3RlZFxuXHRcdFx0XHRzZWxlY3QucXVlcnlTZWxlY3Rvcignb3B0aW9uOm5vdChbZGlzYWJsZWRdKScpO1xuXHRcdFx0dmFsdWUgPSBzZWxlY3RlZF9vcHRpb24gJiYgZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdH1cblxuXHRcdHNldCh2YWx1ZSk7XG5cdH0pO1xuXG5cdC8vIE5lZWRzIHRvIGJlIGFuIGVmZmVjdCwgbm90IGEgcmVuZGVyX2VmZmVjdCwgc28gdGhhdCBpbiBjYXNlIG9mIGVhY2ggbG9vcHMgdGhlIGxvZ2ljIHJ1bnMgYWZ0ZXIgdGhlIGVhY2ggYmxvY2sgaGFzIHVwZGF0ZWRcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblx0XHRzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKTtcblxuXHRcdC8vIE1vdW50aW5nIGFuZCB2YWx1ZSB1bmRlZmluZWQgLT4gdGFrZSBzZWxlY3Rpb24gZnJvbSBkb21cblx0XHRpZiAobW91bnRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0LyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudCB8IG51bGx9ICovXG5cdFx0XHR2YXIgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdFx0XHRpZiAoc2VsZWN0ZWRfb3B0aW9uICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X29wdGlvbl92YWx1ZShzZWxlY3RlZF9vcHRpb24pO1xuXHRcdFx0XHRzZXQodmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzZWxlY3QuX192YWx1ZSA9IHZhbHVlO1xuXHRcdG1vdW50aW5nID0gZmFsc2U7XG5cdH0pO1xuXG5cdC8vIGRvbid0IHBhc3MgZ2V0X3ZhbHVlLCB3ZSBhbHJlYWR5IGluaXRpYWxpemUgaXQgaW4gdGhlIGVmZmVjdCBhYm92ZVxuXHRpbml0X3NlbGVjdChzZWxlY3QpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBvcHRpb24gb2Ygc2VsZWN0Lm9wdGlvbnMpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0b3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2YoZ2V0X29wdGlvbl92YWx1ZShvcHRpb24pKTtcblx0fVxufVxuXG4vKiogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gb3B0aW9uICovXG5mdW5jdGlvbiBnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbikge1xuXHQvLyBfX3ZhbHVlIG9ubHkgZXhpc3RzIGlmIHRoZSA8b3B0aW9uPiBoYXMgYSB2YWx1ZSBhdHRyaWJ1dGVcblx0aWYgKCdfX3ZhbHVlJyBpbiBvcHRpb24pIHtcblx0XHRyZXR1cm4gb3B0aW9uLl9fdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG9wdGlvbi52YWx1ZTtcblx0fVxufVxuIiwiaW1wb3J0IHsgU1RBVEVfU1lNQk9MIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGVmZmVjdCwgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vLi4vdGFzay5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGJvdW5kX3ZhbHVlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRfb3JfY29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNfYm91bmRfdGhpcyhib3VuZF92YWx1ZSwgZWxlbWVudF9vcl9jb21wb25lbnQpIHtcblx0cmV0dXJuIChcblx0XHRib3VuZF92YWx1ZSA9PT0gZWxlbWVudF9vcl9jb21wb25lbnQgfHwgYm91bmRfdmFsdWU/LltTVEFURV9TWU1CT0xdID09PSBlbGVtZW50X29yX2NvbXBvbmVudFxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlbGVtZW50X29yX2NvbXBvbmVudFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24sIC4uLnBhcnRzOiB1bmtub3duW10pID0+IHZvaWR9IHVwZGF0ZVxuICogQHBhcmFtIHsoLi4ucGFydHM6IHVua25vd25bXSkgPT4gdW5rbm93bn0gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0geygpID0+IHVua25vd25bXX0gW2dldF9wYXJ0c10gU2V0IGlmIHRoZSB0aGlzIGJpbmRpbmcgaXMgdXNlZCBpbnNpZGUgYW4gZWFjaCBibG9jayxcbiAqIFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJucyBhbGwgdGhlIHBhcnRzIG9mIHRoZSBlYWNoIGJsb2NrIGNvbnRleHQgdGhhdCBhcmUgdXNlZCBpbiB0aGUgZXhwcmVzc2lvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3RoaXMoZWxlbWVudF9vcl9jb21wb25lbnQgPSB7fSwgdXBkYXRlLCBnZXRfdmFsdWUsIGdldF9wYXJ0cykge1xuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuXHRcdHZhciBvbGRfcGFydHM7XG5cblx0XHQvKiogQHR5cGUge3Vua25vd25bXX0gKi9cblx0XHR2YXIgcGFydHM7XG5cblx0XHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9sZF9wYXJ0cyA9IHBhcnRzO1xuXHRcdFx0Ly8gV2Ugb25seSB0cmFjayBjaGFuZ2VzIHRvIHRoZSBwYXJ0cywgbm90IHRoZSB2YWx1ZSBpdHNlbGYgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVydW5zLlxuXHRcdFx0cGFydHMgPSBnZXRfcGFydHM/LigpIHx8IFtdO1xuXG5cdFx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdFx0aWYgKGVsZW1lbnRfb3JfY29tcG9uZW50ICE9PSBnZXRfdmFsdWUoLi4ucGFydHMpKSB7XG5cdFx0XHRcdFx0dXBkYXRlKGVsZW1lbnRfb3JfY29tcG9uZW50LCAuLi5wYXJ0cyk7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlZmZlY3QgcmVydW4gKGNhdXNlOiBlYWNoIGJsb2NrIGNvbnRleHQgY2hhbmdlcyksIHRoZW4gbnVsbGZpeSB0aGUgYmluZGluZyBhdFxuXHRcdFx0XHRcdC8vIHRoZSBwcmV2aW91cyBwb3NpdGlvbiBpZiBpdCBpc24ndCBhbHJlYWR5IHRha2VuIG92ZXIgYnkgYSBkaWZmZXJlbnQgZWZmZWN0LlxuXHRcdFx0XHRcdGlmIChvbGRfcGFydHMgJiYgaXNfYm91bmRfdGhpcyhnZXRfdmFsdWUoLi4ub2xkX3BhcnRzKSwgZWxlbWVudF9vcl9jb21wb25lbnQpKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUobnVsbCwgLi4ub2xkX3BhcnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdC8vIFdlIGNhbm5vdCB1c2UgZWZmZWN0cyBpbiB0aGUgdGVhcmRvd24gcGhhc2UsIHdlIHdlIHVzZSBhIG1pY3JvdGFzayBpbnN0ZWFkLlxuXHRcdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRcdGlmIChwYXJ0cyAmJiBpc19ib3VuZF90aGlzKGdldF92YWx1ZSguLi5wYXJ0cyksIGVsZW1lbnRfb3JfY29tcG9uZW50KSkge1xuXHRcdFx0XHRcdHVwZGF0ZShudWxsLCAuLi5wYXJ0cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50X29yX2NvbXBvbmVudDtcbn1cbiIsIi8qKiBAaW1wb3J0IHsgQWN0aW9uUmV0dXJuIH0gZnJvbSAnc3ZlbHRlL2FjdGlvbicgKi9cbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgdXNlcl9wcmVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG9uIH0gZnJvbSAnLi4vZWxlbWVudHMvZXZlbnRzLmpzJztcblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHRydXN0ZWRgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRpZiAoZXZlbnQuaXNUcnVzdGVkKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc2VsZmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGYoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc3RvcFByb3BhZ2F0aW9uYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYG9uY2VgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdHZhciByYW4gPSBmYWxzZTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHByZXZlbnREZWZhdWx0YCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBwYXNzaXZlYCBldmVudCBtb2RpZmllciwgaW1wbGVtZW50ZWQgYXMgYW4gYWN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtbZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKCkgPT4gRXZlbnRMaXN0ZW5lcl19IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3NpdmUobm9kZSwgW2V2ZW50LCBoYW5kbGVyXSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHJldHVybiBvbihub2RlLCBldmVudCwgaGFuZGxlcigpID8/IG5vb3AsIHtcblx0XHRcdHBhc3NpdmU6IHRydWVcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBub25wYXNzaXZlYCBldmVudCBtb2RpZmllciwgaW1wbGVtZW50ZWQgYXMgYW4gYWN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtbZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKCkgPT4gRXZlbnRMaXN0ZW5lcl19IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbnBhc3NpdmUobm9kZSwgW2V2ZW50LCBoYW5kbGVyXSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHJldHVybiBvbihub2RlLCBldmVudCwgaGFuZGxlcigpID8/IG5vb3AsIHtcblx0XHRcdHBhc3NpdmU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xufVxuIiwiLyoqIEBpbXBvcnQgeyBDb21wb25lbnRDb250ZXh0TGVnYWN5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJ1biwgcnVuX2FsbCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgdXNlcl9wcmVfZWZmZWN0LCB1c2VyX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBkZWVwX3JlYWRfc3RhdGUsIGdldCwgdW50cmFjayB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIExlZ2FjeS1tb2RlIG9ubHk6IENhbGwgYG9uTW91bnRgIGNhbGxiYWNrcyBhbmQgc2V0IHVwIGBiZWZvcmVVcGRhdGVgL2BhZnRlclVwZGF0ZWAgZWZmZWN0c1xuICogQHBhcmFtIHtib29sZWFufSBbaW1tdXRhYmxlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChpbW11dGFibGUgPSBmYWxzZSkge1xuXHRjb25zdCBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXG5cdGNvbnN0IGNhbGxiYWNrcyA9IGNvbnRleHQubC51O1xuXHRpZiAoIWNhbGxiYWNrcykgcmV0dXJuO1xuXG5cdGxldCBwcm9wcyA9ICgpID0+IGRlZXBfcmVhZF9zdGF0ZShjb250ZXh0LnMpO1xuXG5cdGlmIChpbW11dGFibGUpIHtcblx0XHRsZXQgdmVyc2lvbiA9IDA7XG5cdFx0bGV0IHByZXYgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cblx0XHQvLyBJbiBsZWdhY3kgaW1tdXRhYmxlIG1vZGUsIGJlZm9yZS9hZnRlclVwZGF0ZSBvbmx5IGZpcmUgaWYgdGhlIG9iamVjdCBpZGVudGl0eSBvZiBhIHByb3AgY2hhbmdlc1xuXHRcdGNvbnN0IGQgPSBkZXJpdmVkKCgpID0+IHtcblx0XHRcdGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRjb25zdCBwcm9wcyA9IGNvbnRleHQucztcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wc1trZXldICE9PSBwcmV2W2tleV0pIHtcblx0XHRcdFx0XHRwcmV2W2tleV0gPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hhbmdlZCkgdmVyc2lvbisrO1xuXHRcdFx0cmV0dXJuIHZlcnNpb247XG5cdFx0fSk7XG5cblx0XHRwcm9wcyA9ICgpID0+IGdldChkKTtcblx0fVxuXG5cdC8vIGJlZm9yZVVwZGF0ZVxuXHRpZiAoY2FsbGJhY2tzLmIubGVuZ3RoKSB7XG5cdFx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmIpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gb25Nb3VudCAobXVzdCBydW4gYmVmb3JlIGFmdGVyVXBkYXRlKVxuXHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgZm5zID0gdW50cmFjaygoKSA9PiBjYWxsYmFja3MubS5tYXAocnVuKSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRmbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gYWZ0ZXJVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5hLmxlbmd0aCkge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdG9ic2VydmVfYWxsKGNvbnRleHQsIHByb3BzKTtcblx0XHRcdHJ1bl9hbGwoY2FsbGJhY2tzLmEpO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogSW52b2tlIHRoZSBnZXR0ZXIgb2YgYWxsIHNpZ25hbHMgYXNzb2NpYXRlZCB3aXRoIGEgY29tcG9uZW50XG4gKiBzbyB0aGV5IGNhbiBiZSByZWdpc3RlcmVkIHRvIHRoZSBlZmZlY3QgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgaW4uXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRMZWdhY3l9IGNvbnRleHRcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBwcm9wc1xuICovXG5mdW5jdGlvbiBvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcykge1xuXHRpZiAoY29udGV4dC5sLnMpIHtcblx0XHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBjb250ZXh0LmwucykgZ2V0KHNpZ25hbCk7XG5cdH1cblxuXHRwcm9wcygpO1xufVxuIiwiaW1wb3J0IHsgc2V0LCBzb3VyY2UgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8qKlxuICogVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzLCBpbXBvcnRzIG1heSBiZSByZWFjdGl2ZSBpbiBsZWdhY3kgbW9kZS4gSW4gdGhhdCBjYXNlLFxuICogdGhleSBzaG91bGQgYmUgdXNpbmcgYHJlYWN0aXZlX2ltcG9ydGAgYXMgcGFydCBvZiB0aGUgdHJhbnNmb3JtYXRpb25cbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhY3RpdmVfaW1wb3J0KGZuKSB7XG5cdHZhciBzID0gc291cmNlKDApO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHNldChzLCBnZXQocykgKyAxKTtcblx0XHRcdHJldHVybiBhcmd1bWVudHNbMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldChzKTtcblx0XHRcdHJldHVybiBmbigpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAdGhpcyB7YW55fVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gJCRwcm9wc1xuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnViYmxlX2V2ZW50KCQkcHJvcHMsIGV2ZW50KSB7XG5cdHZhciBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10gfCBGdW5jdGlvbj59ICovICgkJHByb3BzLiQkZXZlbnRzKT8uW1xuXHRcdGV2ZW50LnR5cGVcblx0XTtcblxuXHR2YXIgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogZXZlbnRzID09IG51bGwgPyBbXSA6IFtldmVudHNdO1xuXG5cdGZvciAodmFyIGZuIG9mIGNhbGxiYWNrcykge1xuXHRcdC8vIFByZXNlcnZlIFwidGhpc1wiIGNvbnRleHRcblx0XHRmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fVxufVxuXG4vKipcbiAqIFVzZWQgdG8gc2ltdWxhdGUgYCRvbmAgb24gYSBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbiBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGkgPT09IDRgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudF9jYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkX2xlZ2FjeV9ldmVudF9saXN0ZW5lcigkJHByb3BzLCBldmVudF9uYW1lLCBldmVudF9jYWxsYmFjaykge1xuXHQkJHByb3BzLiQkZXZlbnRzIHx8PSB7fTtcblx0JCRwcm9wcy4kJGV2ZW50c1tldmVudF9uYW1lXSB8fD0gW107XG5cdCQkcHJvcHMuJCRldmVudHNbZXZlbnRfbmFtZV0ucHVzaChldmVudF9jYWxsYmFjayk7XG59XG5cbi8qKlxuICogVXNlZCB0byBzaW11bGF0ZSBgJHNldGAgb24gYSBjb21wb25lbnQgaW5zdGFuY2Ugd2hlbiBgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGkgPT09IDRgLlxuICogTmVlZHMgY29tcG9uZW50IGFjY2Vzc29ycyBzbyB0aGF0IGl0IGNhbiBjYWxsIHRoZSBzZXR0ZXIgb2YgdGhlIHByb3AuIFRoZXJlZm9yZSBkb2Vzbid0XG4gKiB3b3JrIGZvciB1cGRhdGluZyBwcm9wcyBpbiBgJCRwcm9wc2Agb3IgYCQkcmVzdFByb3BzYC5cbiAqIEB0aGlzIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJG5ld19wcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX2xlZ2FjeV9wcm9wcygkJG5ld19wcm9wcykge1xuXHRmb3IgKHZhciBrZXkgaW4gJCRuZXdfcHJvcHMpIHtcblx0XHRpZiAoa2V5IGluIHRoaXMpIHtcblx0XHRcdHRoaXNba2V5XSA9ICQkbmV3X3Byb3BzW2tleV07XG5cdFx0fVxuXHR9XG59XG4iLCIvKiogQGltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnLi9wdWJsaWMnICovXG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vaW5kZXgtY2xpZW50LmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBydW5cbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBbaW52YWxpZGF0ZV1cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCBydW4sIGludmFsaWRhdGUpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0cnVuKHVuZGVmaW5lZCk7XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0aWYgKGludmFsaWRhdGUpIGludmFsaWRhdGUodW5kZWZpbmVkKTtcblxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cblx0Ly8gU3ZlbHRlIHN0b3JlIHRha2VzIGEgcHJpdmF0ZSBzZWNvbmQgYXJndW1lbnRcblx0Ly8gU3RhcnRTdG9wTm90aWZpZXIgY291bGQgbXV0YXRlIHN0YXRlLCBhbmQgd2Ugd2FudCB0byBzaWxlbmNlIHRoZSBjb3JyZXNwb25kaW5nIHZhbGlkYXRpb24gZXJyb3Jcblx0Y29uc3QgdW5zdWIgPSB1bnRyYWNrKCgpID0+XG5cdFx0c3RvcmUuc3Vic2NyaWJlKFxuXHRcdFx0cnVuLFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0aW52YWxpZGF0ZVxuXHRcdClcblx0KTtcblxuXHQvLyBBbHNvIHN1cHBvcnQgUnhKU1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IHRoaXMgaW4gdGhlIHR5cGVzP1xuXHRyZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG4iLCIvKiogQGltcG9ydCB7IFJlYWRhYmxlLCBTdGFydFN0b3BOb3RpZmllciwgU3Vic2NyaWJlciwgVW5zdWJzY3JpYmVyLCBVcGRhdGVyLCBXcml0YWJsZSB9IGZyb20gJy4uL3B1YmxpYy5qcycgKi9cbi8qKiBAaW1wb3J0IHsgU3RvcmVzLCBTdG9yZXNWYWx1ZXMsIFN1YnNjcmliZUludmFsaWRhdGVUdXBsZSB9IGZyb20gJy4uL3ByaXZhdGUuanMnICovXG5pbXBvcnQgeyBub29wLCBydW5fYWxsIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHNhZmVfbm90X2VxdWFsIH0gZnJvbSAnLi4vLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMnO1xuaW1wb3J0IHsgc3Vic2NyaWJlX3RvX3N0b3JlIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8YW55PiB8IGFueT59XG4gKi9cbmNvbnN0IHN1YnNjcmliZXJfcXVldWUgPSBbXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYFJlYWRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlKHZhbHVlLCBzdGFydCkge1xuXHRyZXR1cm4ge1xuXHRcdHN1YnNjcmliZTogd3JpdGFibGUodmFsdWUsIHN0YXJ0KS5zdWJzY3JpYmVcblx0fTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcjxUPn0gW3N0YXJ0XVxuICogQHJldHVybnMge1dyaXRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGFibGUodmFsdWUsIHN0YXJ0ID0gbm9vcCkge1xuXHQvKiogQHR5cGUge1Vuc3Vic2NyaWJlciB8IG51bGx9ICovXG5cdGxldCBzdG9wID0gbnVsbDtcblxuXHQvKiogQHR5cGUge1NldDxTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGU8VD4+fSAqL1xuXHRjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtUfSBuZXdfdmFsdWVcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG5cdFx0aWYgKHNhZmVfbm90X2VxdWFsKHZhbHVlLCBuZXdfdmFsdWUpKSB7XG5cdFx0XHR2YWx1ZSA9IG5ld192YWx1ZTtcblx0XHRcdGlmIChzdG9wKSB7XG5cdFx0XHRcdC8vIHN0b3JlIGlzIHJlYWR5XG5cdFx0XHRcdGNvbnN0IHJ1bl9xdWV1ZSA9ICFzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChjb25zdCBzdWJzY3JpYmVyIG9mIHN1YnNjcmliZXJzKSB7XG5cdFx0XHRcdFx0c3Vic2NyaWJlclsxXSgpO1xuXHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWUucHVzaChzdWJzY3JpYmVyLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJ1bl9xdWV1ZSkge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZVtpXVswXShzdWJzY3JpYmVyX3F1ZXVlW2kgKyAxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWUubGVuZ3RoID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1VwZGF0ZXI8VD59IGZuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG5cdFx0c2V0KGZuKC8qKiBAdHlwZSB7VH0gKi8gKHZhbHVlKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7U3Vic2NyaWJlcjxUPn0gcnVuXG5cdCAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2ludmFsaWRhdGVdXG5cdCAqIEByZXR1cm5zIHtVbnN1YnNjcmliZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xuXHRcdC8qKiBAdHlwZSB7U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+fSAqL1xuXHRcdGNvbnN0IHN1YnNjcmliZXIgPSBbcnVuLCBpbnZhbGlkYXRlXTtcblx0XHRzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcblx0XHRcdHN0b3AgPSBzdGFydChzZXQsIHVwZGF0ZSkgfHwgbm9vcDtcblx0XHR9XG5cdFx0cnVuKC8qKiBAdHlwZSB7VH0gKi8gKHZhbHVlKSk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcblx0XHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAwICYmIHN0b3ApIHtcblx0XHRcdFx0c3RvcCgpO1xuXHRcdFx0XHRzdG9wID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdHJldHVybiB7IHNldCwgdXBkYXRlLCBzdWJzY3JpYmUgfTtcbn1cblxuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICpcbiAqIEB0ZW1wbGF0ZSB7U3RvcmVzfSBTXG4gKiBAdGVtcGxhdGUgVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHsodmFsdWVzOiBTdG9yZXNWYWx1ZXM8Uz4sIHNldDogKHZhbHVlOiBUKSA9PiB2b2lkLCB1cGRhdGU6IChmbjogVXBkYXRlcjxUPikgPT4gdm9pZCkgPT4gVW5zdWJzY3JpYmVyIHwgdm9pZH0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBAdGVtcGxhdGUge1N0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogU3RvcmVzVmFsdWVzPFM+KSA9PiBUfSBmblxuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV1cbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuLyoqXG4gKiBAdGVtcGxhdGUge1N0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV1cbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuXHRjb25zdCBzaW5nbGUgPSAhQXJyYXkuaXNBcnJheShzdG9yZXMpO1xuXHQvKiogQHR5cGUge0FycmF5PFJlYWRhYmxlPGFueT4+fSAqL1xuXHRjb25zdCBzdG9yZXNfYXJyYXkgPSBzaW5nbGUgPyBbc3RvcmVzXSA6IHN0b3Jlcztcblx0aWYgKCFzdG9yZXNfYXJyYXkuZXZlcnkoQm9vbGVhbikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWQoKSBleHBlY3RzIHN0b3JlcyBhcyBpbnB1dCwgZ290IGEgZmFsc3kgdmFsdWUnKTtcblx0fVxuXHRjb25zdCBhdXRvID0gZm4ubGVuZ3RoIDwgMjtcblx0cmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQsIHVwZGF0ZSkgPT4ge1xuXHRcdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdFx0LyoqIEB0eXBlIHtUW119ICovXG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0bGV0IHBlbmRpbmcgPSAwO1xuXHRcdGxldCBjbGVhbnVwID0gbm9vcDtcblx0XHRjb25zdCBzeW5jID0gKCkgPT4ge1xuXHRcdFx0aWYgKHBlbmRpbmcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZm4oc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzLCBzZXQsIHVwZGF0ZSk7XG5cdFx0XHRpZiAoYXV0bykge1xuXHRcdFx0XHRzZXQocmVzdWx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsZWFudXAgPSB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nID8gcmVzdWx0IDogbm9vcDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKChzdG9yZSwgaSkgPT5cblx0XHRcdHN1YnNjcmliZV90b19zdG9yZShcblx0XHRcdFx0c3RvcmUsXG5cdFx0XHRcdCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHBlbmRpbmcgJj0gfigxIDw8IGkpO1xuXHRcdFx0XHRcdGlmIChzdGFydGVkKSB7XG5cdFx0XHRcdFx0XHRzeW5jKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0cGVuZGluZyB8PSAxIDw8IGk7XG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHQpO1xuXHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdHN5bmMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRcdHJ1bl9hbGwodW5zdWJzY3JpYmVycyk7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB0aGlzIHRvIGZhbHNlIGJlY2F1c2UgY2FsbGJhY2tzIGNhbiBzdGlsbCBoYXBwZW4gZGVzcGl0ZSBoYXZpbmcgdW5zdWJzY3JpYmVkOlxuXHRcdFx0Ly8gQ2FsbGJhY2tzIG1pZ2h0IGFscmVhZHkgYmUgcGxhY2VkIGluIHRoZSBxdWV1ZSB3aGljaCBkb2Vzbid0IGtub3cgaXQgc2hvdWxkIG5vIGxvbmdlclxuXHRcdFx0Ly8gaW52b2tlIHRoaXMgZGVyaXZlZCBzdG9yZS5cblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHN0b3JlIGFuZCByZXR1cm5zIGEgbmV3IG9uZSBkZXJpdmVkIGZyb20gdGhlIG9sZCBvbmUgdGhhdCBpcyByZWFkYWJsZS5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPn0gc3RvcmUgIC0gc3RvcmUgdG8gbWFrZSByZWFkb25seVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZG9ubHkoc3RvcmUpIHtcblx0cmV0dXJuIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gaSBzdXNwZWN0IHRoZSBiaW5kIGlzIHVubmVjZXNzYXJ5XG5cdFx0c3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUuYmluZChzdG9yZSlcblx0fTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSBhIHN0b3JlIGJ5IHN1YnNjcmliaW5nIGFuZCBpbW1lZGlhdGVseSB1bnN1YnNjcmliaW5nLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+fSBzdG9yZVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoc3RvcmUpIHtcblx0bGV0IHZhbHVlO1xuXHRzdWJzY3JpYmVfdG9fc3RvcmUoc3RvcmUsIChfKSA9PiAodmFsdWUgPSBfKSkoKTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gdmFsdWU7XG59XG4iLCIvKiogQGltcG9ydCB7IFN0b3JlUmVmZXJlbmNlc0NvbnRhaW5lciB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IFN0b3JlIH0gZnJvbSAnI3NoYXJlZCcgKi9cbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uLy4uLy4uL3N0b3JlL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldCBhcyBnZXRfc3RvcmUgfSBmcm9tICcuLi8uLi8uLi9zdG9yZS9zaGFyZWQvaW5kZXguanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBub29wIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbXV0YWJsZV9zb3VyY2UsIHNldCB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHByb3AgY3VycmVudGx5IGJlaW5nIHJlYWQgaXMgYSBzdG9yZSBiaW5kaW5nLCBhcyBpblxuICogYDxDaGlsZCBiaW5kOng9eyR5fSAvPmAuIElmIGl0IGlzLCB3ZSB0cmVhdCB0aGUgcHJvcCBhcyBtdXRhYmxlIGV2ZW4gaW5cbiAqIHJ1bmVzIG1vZGUsIGFuZCBza2lwIGBiaW5kaW5nX3Byb3BlcnR5X25vbl9yZWFjdGl2ZWAgdmFsaWRhdGlvblxuICovXG5sZXQgaXNfc3RvcmVfYmluZGluZyA9IGZhbHNlO1xuXG5sZXQgSVNfVU5NT1VOVEVEID0gU3ltYm9sKCk7XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIHN0b3JlLiBJZiB0aGUgc3RvcmUgaXNuJ3Qgc3Vic2NyaWJlZCB0byB5ZXQsIGl0IHdpbGwgY3JlYXRlIGEgcHJveHlcbiAqIHNpZ25hbCB0aGF0IHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZSBzdG9yZSBpcy4gVGhlIHN0b3JlIHJlZmVyZW5jZXMgY29udGFpbmVyIGlzIG5lZWRlZCB0b1xuICogdHJhY2sgcmVhc3NpZ25tZW50cyB0byBzdG9yZXMgYW5kIHRvIHRyYWNrIHRoZSBjb3JyZWN0IGNvbXBvbmVudCBjb250ZXh0LlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqIEByZXR1cm5zIHtWfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVfZ2V0KHN0b3JlLCBzdG9yZV9uYW1lLCBzdG9yZXMpIHtcblx0Y29uc3QgZW50cnkgPSAoc3RvcmVzW3N0b3JlX25hbWVdID8/PSB7XG5cdFx0c3RvcmU6IG51bGwsXG5cdFx0c291cmNlOiBtdXRhYmxlX3NvdXJjZSh1bmRlZmluZWQpLFxuXHRcdHVuc3Vic2NyaWJlOiBub29wXG5cdH0pO1xuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgdGhhdCBzZXR1cCB0aGlzIGlzIGFscmVhZHkgdW5tb3VudGVkIHdlIGRvbid0IHdhbnQgdG8gcmVnaXN0ZXIgYSBzdWJzY3JpcHRpb25cblx0aWYgKGVudHJ5LnN0b3JlICE9PSBzdG9yZSAmJiAhKElTX1VOTU9VTlRFRCBpbiBzdG9yZXMpKSB7XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS5zdG9yZSA9IHN0b3JlID8/IG51bGw7XG5cblx0XHRpZiAoc3RvcmUgPT0gbnVsbCkge1xuXHRcdFx0ZW50cnkuc291cmNlLnYgPSB1bmRlZmluZWQ7IC8vIHNlZSBzeW5jaHJvbm91cyBjYWxsYmFjayBjb21tZW50IGJlbG93XG5cdFx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBpc19zeW5jaHJvbm91c19jYWxsYmFjayA9IHRydWU7XG5cblx0XHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAodikgPT4ge1xuXHRcdFx0XHRpZiAoaXNfc3luY2hyb25vdXNfY2FsbGJhY2spIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgZmlyc3QgdXBkYXRlcyB0byB0aGUgc3RvcmUgdmFsdWUgKHBvc3NpYmx5IG11bHRpcGxlIG9mIHRoZW0pIGFyZSBzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0Ly8gaW5zaWRlIGEgZGVyaXZlZCwgd2Ugd2lsbCBoaXQgdGhlIGBzdGF0ZV91bnNhZmVfbXV0YXRpb25gIGVycm9yIGlmIHdlIGBzZXRgIHRoZSB2YWx1ZVxuXHRcdFx0XHRcdGVudHJ5LnNvdXJjZS52ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXQoZW50cnkuc291cmNlLCB2KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCB0aGF0IHNldHVwIHRoaXMgc3RvcmVzIGlzIGFscmVhZHkgdW5tb3VudGVkIHRoZSBzb3VyY2Ugd2lsbCBiZSBvdXQgb2Ygc3luY1xuXHQvLyBzbyB3ZSBqdXN0IHVzZSB0aGUgYGdldGAgZm9yIHRoZSBzdG9yZXMsIGxlc3MgcGVyZm9ybWFudCBidXQgaXQgYXZvaWRzIHRvIGNyZWF0ZSBhIG1lbW9yeSBsZWFrXG5cdC8vIGFuZCBpdCB3aWxsIGtlZXAgdGhlIHZhbHVlIGNvbnNpc3RlbnRcblx0aWYgKHN0b3JlICYmIElTX1VOTU9VTlRFRCBpbiBzdG9yZXMpIHtcblx0XHRyZXR1cm4gZ2V0X3N0b3JlKHN0b3JlKTtcblx0fVxuXG5cdHJldHVybiBnZXQoZW50cnkuc291cmNlKTtcbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgaWYgaXQncyBub3QgdGhlIHNhbWUgYXMgdGhlIG9uZSBpbiB0aGUgc3RvcmUgcmVmZXJlbmNlcyBjb250YWluZXIuXG4gKiBXZSBuZWVkIHRoaXMgaW4gYWRkaXRpb24gdG8gYHN0b3JlX2dldGAgYmVjYXVzZSBzb21lb25lIGNvdWxkIHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBidXRcbiAqIHRoZW4gbmV2ZXIgc3Vic2NyaWJlIHRvIHRoZSBuZXcgb25lIChpZiBhbnkpLCBjYXVzaW5nIHRoZSBzdWJzY3JpcHRpb24gdG8gc3RheSBvcGVuIHdyb25nZnVsbHkuXG4gKiBAcGFyYW0ge1N0b3JlPGFueT4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3Vuc3ViKHN0b3JlLCBzdG9yZV9uYW1lLCBzdG9yZXMpIHtcblx0LyoqIEB0eXBlIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJbJyddIHwgdW5kZWZpbmVkfSAqL1xuXHRsZXQgZW50cnkgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cblx0aWYgKGVudHJ5ICYmIGVudHJ5LnN0b3JlICE9PSBzdG9yZSkge1xuXHRcdC8vIERvbid0IHJlc2V0IHN0b3JlIHlldCwgc28gdGhhdCBzdG9yZV9nZXQgYWJvdmUgY2FuIHJlc3Vic2NyaWJlIHRvIG5ldyBzdG9yZSBpZiBuZWNlc3Nhcnlcblx0XHRlbnRyeS51bnN1YnNjcmliZSgpO1xuXHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gbm9vcDtcblx0fVxuXG5cdHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBuZXcgdmFsdWUgb2YgYSBzdG9yZSBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3NldChzdG9yZSwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlX3N0b3JlKHN0b3Jlcywgc3RvcmVfbmFtZSkge1xuXHR2YXIgZW50cnkgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cdGlmIChlbnRyeS5zdG9yZSAhPT0gbnVsbCkge1xuXHRcdHN0b3JlX3NldChlbnRyeS5zdG9yZSwgZW50cnkuc291cmNlLnYpO1xuXHR9XG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmVzIGZyb20gYWxsIGF1dG8tc3Vic2NyaWJlZCBzdG9yZXMgb24gZGVzdHJveVxuICogQHJldHVybnMge1tTdG9yZVJlZmVyZW5jZXNDb250YWluZXIsICgpPT52b2lkXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwX3N0b3JlcygpIHtcblx0LyoqIEB0eXBlIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9ICovXG5cdGNvbnN0IHN0b3JlcyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0Zm9yICh2YXIgc3RvcmVfbmFtZSBpbiBzdG9yZXMpIHtcblx0XHRcdFx0Y29uc3QgcmVmID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXHRcdFx0XHRyZWYudW5zdWJzY3JpYmUoKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZV9wcm9wZXJ0eShzdG9yZXMsIElTX1VOTU9VTlRFRCwge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIFtzdG9yZXMsIGNsZWFudXBdO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzdG9yZSB3aXRoIGEgbmV3IHZhbHVlLlxuICogQHBhcmFtIHtTdG9yZTxWPn0gc3RvcmUgIHRoZSBzdG9yZSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBleHByZXNzaW9uICB0aGUgZXhwcmVzc2lvbiB0aGF0IG11dGF0ZXMgdGhlIHN0b3JlXG4gKiBAcGFyYW0ge1Z9IG5ld192YWx1ZSAgdGhlIG5ldyBzdG9yZSB2YWx1ZVxuICogQHRlbXBsYXRlIFZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX211dGF0ZShzdG9yZSwgZXhwcmVzc2lvbiwgbmV3X3ZhbHVlKSB7XG5cdHN0b3JlLnNldChuZXdfdmFsdWUpO1xuXHRyZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcmVfdmFsdWVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc3RvcmUoc3RvcmUsIHN0b3JlX3ZhbHVlLCBkID0gMSkge1xuXHRzdG9yZS5zZXQoc3RvcmVfdmFsdWUgKyBkKTtcblx0cmV0dXJuIHN0b3JlX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmU8bnVtYmVyPn0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdG9yZV92YWx1ZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmVfc3RvcmUoc3RvcmUsIHN0b3JlX3ZhbHVlLCBkID0gMSkge1xuXHRjb25zdCB2YWx1ZSA9IHN0b3JlX3ZhbHVlICsgZDtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUgcHJvcCBnZXR0ZXJzIHRvIGNvbW11bmljYXRlIHRoYXQgdGhlIHByb3AgaXMgYSBzdG9yZSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrX3N0b3JlX2JpbmRpbmcoKSB7XG5cdGlzX3N0b3JlX2JpbmRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGBmbigpYCByZWFkcyBhIHByb3AgdGhhdCBpcyBhIHN0b3JlIGJpbmRpbmcuXG4gKiBVc2VkIHRvIHByZXZlbnQgYGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCB2YWxpZGF0aW9uIGZhbHNlIHBvc2l0aXZlcyBhbmRcbiAqIGVuc3VyZSB0aGF0IHRoZXNlIHByb3BzIGFyZSB0cmVhdGVkIGFzIG11dGFibGUgZXZlbiBpbiBydW5lcyBtb2RlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1tULCBib29sZWFuXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVfc3RvcmVfYmluZGluZyhmbikge1xuXHR2YXIgcHJldmlvdXNfaXNfc3RvcmVfYmluZGluZyA9IGlzX3N0b3JlX2JpbmRpbmc7XG5cblx0dHJ5IHtcblx0XHRpc19zdG9yZV9iaW5kaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIFtmbigpLCBpc19zdG9yZV9iaW5kaW5nXTtcblx0fSBmaW5hbGx5IHtcblx0XHRpc19zdG9yZV9iaW5kaW5nID0gcHJldmlvdXNfaXNfc3RvcmVfYmluZGluZztcblx0fVxufVxuIiwiLyoqIEBpbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcuL3R5cGVzLmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRQUk9QU19JU19CSU5EQUJMRSxcblx0UFJPUFNfSVNfSU1NVVRBQkxFLFxuXHRQUk9QU19JU19MQVpZX0lOSVRJQUwsXG5cdFBST1BTX0lTX1JVTkVTLFxuXHRQUk9QU19JU19VUERBVEVEXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgbXV0YWJsZV9zb3VyY2UsIHNldCwgc291cmNlLCB1cGRhdGUgfSBmcm9tICcuL3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgZGVyaXZlZCwgZGVyaXZlZF9zYWZlX2VxdWFsIH0gZnJvbSAnLi9kZXJpdmVkcy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRnZXQsXG5cdGNhcHR1cmVkX3NpZ25hbHMsXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHR1bnRyYWNrLFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBzYWZlX2VxdWFscyB9IGZyb20gJy4vZXF1YWxpdHkuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHtcblx0QlJBTkNIX0VGRkVDVCxcblx0TEVHQUNZX0RFUklWRURfUFJPUCxcblx0TEVHQUNZX1BST1BTLFxuXHRST09UX0VGRkVDVCxcblx0U1RBVEVfU1lNQk9MXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBwcm94eSB9IGZyb20gJy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGNhcHR1cmVfc3RvcmVfYmluZGluZyB9IGZyb20gJy4vc3RvcmUuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygodmFsdWU/OiBudW1iZXIpID0+IG51bWJlcil9IGZuXG4gKiBAcGFyYW0gezEgfCAtMX0gW2RdXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKTtcblx0Zm4odmFsdWUgKyBkKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlX3Byb3AoZm4sIGQgPSAxKSB7XG5cdGNvbnN0IHZhbHVlID0gZm4oKSArIGQ7XG5cdGZuKHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciByZXN0IHByb3BzIChpLmUuIGBjb25zdCB7IHgsIC4uLnJlc3QgfSA9ICRwcm9wcygpYCkuXG4gKiBJcyBwYXNzZWQgdGhlIGZ1bGwgYCQkcHJvcHNgIG9iamVjdCBhbmQgZXhjbHVkZXMgdGhlIG5hbWVkIHByb3BzLlxuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgbmFtZT86IHN0cmluZyB9Pn19XG4gKi9cbmNvbnN0IHJlc3RfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmIChERVYpIHtcblx0XHRcdC8vIFRPRE8gc2hvdWxkIHRoaXMgaGFwcGVuIGluIHByb2QgdG9vP1xuXHRcdFx0ZS5wcm9wc19yZXN0X3JlYWRvbmx5KGAke3RhcmdldC5uYW1lfS4ke1N0cmluZyhrZXkpfWApO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRpZiAoa2V5IGluIHRhcmdldC5wcm9wcykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdGFyZ2V0LnByb3BzW2tleV1cblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3RfcHJvcHMocHJvcHMsIGV4Y2x1ZGUsIG5hbWUpIHtcblx0cmV0dXJuIG5ldyBQcm94eShcblx0XHRERVYgPyB7IHByb3BzLCBleGNsdWRlLCBuYW1lLCBvdGhlcjoge30sIHRvX3Byb3h5OiBbXSB9IDogeyBwcm9wcywgZXhjbHVkZSB9LFxuXHRcdHJlc3RfcHJvcHNfaGFuZGxlclxuXHQpO1xufVxuXG4vKipcbiAqIFRoZSBwcm94eSBoYW5kbGVyIGZvciBsZWdhY3kgJCRyZXN0UHJvcHMgYW5kICQkcHJvcHNcbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4sIGV4Y2x1ZGU6IEFycmF5PHN0cmluZyB8IHN5bWJvbD4sIHNwZWNpYWw6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj4sIHZlcnNpb246IFNvdXJjZTxudW1iZXI+IH0+fX1cbiAqL1xuY29uc3QgbGVnYWN5X3Jlc3RfcHJvcHNfaGFuZGxlciA9IHtcblx0Z2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybjtcblx0XHRnZXQodGFyZ2V0LnZlcnNpb24pO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnNwZWNpYWwgPyB0YXJnZXQuc3BlY2lhbFtrZXldKCkgOiB0YXJnZXQucHJvcHNba2V5XTtcblx0fSxcblx0c2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuXHRcdGlmICghKGtleSBpbiB0YXJnZXQuc3BlY2lhbCkpIHtcblx0XHRcdC8vIEhhbmRsZSBwcm9wcyB0aGF0IGNhbiB0ZW1wb3JhcmlseSBnZXQgb3V0IG9mIHN5bmMgd2l0aCB0aGUgcGFyZW50XG5cdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsICh2PzogdW5rbm93bikgPT4gdW5rbm93bj59ICovXG5cdFx0XHR0YXJnZXQuc3BlY2lhbFtrZXldID0gcHJvcChcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGdldCBba2V5XSgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0YXJnZXQucHJvcHNba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoa2V5KSxcblx0XHRcdFx0UFJPUFNfSVNfVVBEQVRFRFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0YXJnZXQuc3BlY2lhbFtrZXldKHZhbHVlKTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pOyAvLyAkJHByb3BzIGlzIGNvYXJzZS1ncmFpbmVkOiB3aGVuICQkcHJvcHMueCBpcyB1cGRhdGVkLCB1c2FnZXMgb2YgJCRwcm9wcy55IGV0YyBhcmUgYWxzbyByZXJ1blxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG5cdFx0Ly8gU3ZlbHRlIDQgYWxsb3dlZCBmb3IgZGVsZXRpb25zIG9uICQkcmVzdFByb3BzXG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiB0cnVlO1xuXHRcdHRhcmdldC5leGNsdWRlLnB1c2goa2V5KTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KHsgcHJvcHMsIGV4Y2x1ZGUsIHNwZWNpYWw6IHt9LCB2ZXJzaW9uOiBzb3VyY2UoMCkgfSwgbGVnYWN5X3Jlc3RfcHJvcHNfaGFuZGxlcik7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHNwcmVhZCBwcm9wcy4gSGFuZGxlcyB0aGUgaW5jb21pbmcgYXJyYXkgb2YgcHJvcHNcbiAqIHRoYXQgbG9va3MgbGlrZSBgKCkgPT4geyBkeW5hbWljOiBwcm9wcyB9LCB7IHN0YXRpYzogcHJvcCB9LCAuLmAgYW5kIHdyYXBzXG4gKiB0aGVtIHNvIHRoYXQgdGhlIHdob2xlIHRoaW5nIGlzIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGFzIHRoZSBgJCRwcm9wc2AgYXJndW1lbnQuXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+fSBUXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IEFycmF5PFQgfCAoKCkgPT4gVCk+IH0+fX1cbiAqL1xuY29uc3Qgc3ByZWFkX3Byb3BzX2hhbmRsZXIgPSB7XG5cdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmICh0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCAmJiBrZXkgaW4gcCkgcmV0dXJuIHBba2V5XTtcblx0XHR9XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRjb25zdCBkZXNjID0gZ2V0X2Rlc2NyaXB0b3IocCwga2V5KTtcblx0XHRcdGlmIChkZXNjICYmIGRlc2Muc2V0KSB7XG5cdFx0XHRcdGRlc2Muc2V0KHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwID09PSAnb2JqZWN0JyAmJiBwICE9PSBudWxsICYmIGtleSBpbiBwKSB7XG5cdFx0XHRcdGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRfZGVzY3JpcHRvcihwLCBrZXkpO1xuXHRcdFx0XHRpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHQvLyBQcmV2ZW50IGEgXCJOb24tY29uZmlndXJhYmlsaXR5IFJlcG9ydCBFcnJvclwiOiBUaGUgdGFyZ2V0IGlzIGFuIGFycmF5LCBpdCBkb2VzXG5cdFx0XHRcdFx0Ly8gbm90IGFjdHVhbGx5IGNvbnRhaW4gdGhpcyBwcm9wZXJ0eS4gSWYgaXQgaXMgbm93IGRlc2NyaWJlZCBhcyBub24tY29uZmlndXJhYmxlLFxuXHRcdFx0XHRcdC8vIHRoZSBwcm94eSB0aHJvd3MgYSB2YWxpZGF0aW9uIGVycm9yLiBTZXR0aW5nIGl0IHRvIHRydWUgYXZvaWRzIHRoYXQuXG5cdFx0XHRcdFx0ZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkZXNjcmlwdG9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzKHRhcmdldCwga2V5KSB7XG5cdFx0Ly8gVG8gcHJldmVudCBhIGZhbHNlIHBvc2l0aXZlIGBpc19lbnRyeV9wcm9wc2AgaW4gdGhlIGBwcm9wYCBmdW5jdGlvblxuXHRcdGlmIChrZXkgPT09IFNUQVRFX1NZTUJPTCB8fCBrZXkgPT09IExFR0FDWV9QUk9QUykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Zm9yIChsZXQgcCBvZiB0YXJnZXQucHJvcHMpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmIChwICE9IG51bGwgJiYga2V5IGluIHApIHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHQvKiogQHR5cGUge0FycmF5PHN0cmluZyB8IHN5bWJvbD59ICovXG5cdFx0Y29uc3Qga2V5cyA9IFtdO1xuXG5cdFx0Zm9yIChsZXQgcCBvZiB0YXJnZXQucHJvcHMpIHtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHApIHtcblx0XHRcdFx0aWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIGtleXMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBrZXlzO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCAoKCkgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj4pPn0gcHJvcHNcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWRfcHJvcHMoLi4ucHJvcHMpIHtcblx0cmV0dXJuIG5ldyBQcm94eSh7IHByb3BzIH0sIHNwcmVhZF9wcm9wc19oYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBzeW5jaHJvbml6aW5nIGEgcG9zc2libHkgYm91bmQgcHJvcCB3aXRoIHRoZSBpbm5lciBjb21wb25lbnQgc3RhdGUuXG4gKiBJdCBpcyB1c2VkIHdoZW5ldmVyIHRoZSBjb21waWxlciBzZWVzIHRoYXQgdGhlIGNvbXBvbmVudCB3cml0ZXMgdG8gdGhlIHByb3AsIG9yIHdoZW4gaXQgaGFzIGEgZGVmYXVsdCBwcm9wX3ZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7ViB8ICgoKSA9PiBWKX0gW2ZhbGxiYWNrXVxuICogQHJldHVybnMgeygoKSA9PiBWIHwgKChhcmc6IFYpID0+IFYpIHwgKChhcmc6IFYsIG11dGF0aW9uOiBib29sZWFuKSA9PiBWKSl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wKHByb3BzLCBrZXksIGZsYWdzLCBmYWxsYmFjaykge1xuXHR2YXIgaW1tdXRhYmxlID0gKGZsYWdzICYgUFJPUFNfSVNfSU1NVVRBQkxFKSAhPT0gMDtcblx0dmFyIHJ1bmVzID0gIWxlZ2FjeV9tb2RlX2ZsYWcgfHwgKGZsYWdzICYgUFJPUFNfSVNfUlVORVMpICE9PSAwO1xuXHR2YXIgYmluZGFibGUgPSAoZmxhZ3MgJiBQUk9QU19JU19CSU5EQUJMRSkgIT09IDA7XG5cdHZhciBsYXp5ID0gKGZsYWdzICYgUFJPUFNfSVNfTEFaWV9JTklUSUFMKSAhPT0gMDtcblx0dmFyIGlzX3N0b3JlX3N1YiA9IGZhbHNlO1xuXHR2YXIgcHJvcF92YWx1ZTtcblxuXHRpZiAoYmluZGFibGUpIHtcblx0XHRbcHJvcF92YWx1ZSwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZygoKSA9PiAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKSk7XG5cdH0gZWxzZSB7XG5cdFx0cHJvcF92YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pO1xuXHR9XG5cblx0Ly8gQ2FuIGJlIHRoZSBjYXNlIHdoZW4gc29tZW9uZSBkb2VzIGBtb3VudChDb21wb25lbnQsIHByb3BzKWAgd2l0aCBgbGV0IHByb3BzID0gJHN0YXRlKHsuLi59KWBcblx0Ly8gb3IgYGNyZWF0ZUNsYXNzQ29tcG9uZW50KENvbXBvbmVudCwgcHJvcHMpYFxuXHR2YXIgaXNfZW50cnlfcHJvcHMgPSBTVEFURV9TWU1CT0wgaW4gcHJvcHMgfHwgTEVHQUNZX1BST1BTIGluIHByb3BzO1xuXG5cdHZhciBzZXR0ZXIgPVxuXHRcdChiaW5kYWJsZSAmJlxuXHRcdFx0KGdldF9kZXNjcmlwdG9yKHByb3BzLCBrZXkpPy5zZXQgPz9cblx0XHRcdFx0KGlzX2VudHJ5X3Byb3BzICYmIGtleSBpbiBwcm9wcyAmJiAoKHYpID0+IChwcm9wc1trZXldID0gdikpKSkpIHx8XG5cdFx0dW5kZWZpbmVkO1xuXG5cdHZhciBmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKGZhbGxiYWNrKTtcblx0dmFyIGZhbGxiYWNrX2RpcnR5ID0gdHJ1ZTtcblx0dmFyIGZhbGxiYWNrX3VzZWQgPSBmYWxzZTtcblxuXHR2YXIgZ2V0X2ZhbGxiYWNrID0gKCkgPT4ge1xuXHRcdGZhbGxiYWNrX3VzZWQgPSB0cnVlO1xuXHRcdGlmIChmYWxsYmFja19kaXJ0eSkge1xuXHRcdFx0ZmFsbGJhY2tfZGlydHkgPSBmYWxzZTtcblx0XHRcdGlmIChsYXp5KSB7XG5cdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gdW50cmFjaygvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbGxiYWNrX3ZhbHVlO1xuXHR9O1xuXG5cdGlmIChwcm9wX3ZhbHVlID09PSB1bmRlZmluZWQgJiYgZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChzZXR0ZXIgJiYgcnVuZXMpIHtcblx0XHRcdGUucHJvcHNfaW52YWxpZF92YWx1ZShrZXkpO1xuXHRcdH1cblxuXHRcdHByb3BfdmFsdWUgPSBnZXRfZmFsbGJhY2soKTtcblx0XHRpZiAoc2V0dGVyKSBzZXR0ZXIocHJvcF92YWx1ZSk7XG5cdH1cblxuXHQvKiogQHR5cGUgeygpID0+IFZ9ICovXG5cdHZhciBnZXR0ZXI7XG5cdGlmIChydW5lcykge1xuXHRcdGdldHRlciA9ICgpID0+IHtcblx0XHRcdHZhciB2YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pO1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBnZXRfZmFsbGJhY2soKTtcblx0XHRcdGZhbGxiYWNrX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdGZhbGxiYWNrX3VzZWQgPSBmYWxzZTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN2ZWx0ZSA0IGRpZCBub3QgdHJpZ2dlciB1cGRhdGVzIHdoZW4gYSBwcmltaXRpdmUgdmFsdWUgd2FzIHVwZGF0ZWQgdG8gdGhlIHNhbWUgdmFsdWUuXG5cdFx0Ly8gUmVwbGljYXRlIHRoYXQgYmVoYXZpb3IgdGhyb3VnaCB1c2luZyBhIGRlcml2ZWRcblx0XHR2YXIgZGVyaXZlZF9nZXR0ZXIgPSAoaW1tdXRhYmxlID8gZGVyaXZlZCA6IGRlcml2ZWRfc2FmZV9lcXVhbCkoXG5cdFx0XHQoKSA9PiAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKVxuXHRcdCk7XG5cdFx0ZGVyaXZlZF9nZXR0ZXIuZiB8PSBMRUdBQ1lfREVSSVZFRF9QUk9QO1xuXHRcdGdldHRlciA9ICgpID0+IHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldChkZXJpdmVkX2dldHRlcik7XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgZmFsbGJhY2tfdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovICh1bmRlZmluZWQpO1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBmYWxsYmFja192YWx1ZSA6IHZhbHVlO1xuXHRcdH07XG5cdH1cblxuXHQvLyBlYXN5IG1vZGUg4oCUIHByb3AgaXMgbmV2ZXIgd3JpdHRlbiB0b1xuXHRpZiAoKGZsYWdzICYgUFJPUFNfSVNfVVBEQVRFRCkgPT09IDApIHtcblx0XHRyZXR1cm4gZ2V0dGVyO1xuXHR9XG5cblx0Ly8gaW50ZXJtZWRpYXRlIG1vZGUg4oCUIHByb3AgaXMgd3JpdHRlbiB0bywgYnV0IHRoZSBwYXJlbnQgY29tcG9uZW50IGhhZFxuXHQvLyBgYmluZDpmb29gIHdoaWNoIG1lYW5zIHdlIGNhbiBqdXN0IGNhbGwgYCQkcHJvcHMuZm9vID0gdmFsdWVgIGRpcmVjdGx5XG5cdGlmIChzZXR0ZXIpIHtcblx0XHR2YXIgbGVnYWN5X3BhcmVudCA9IHByb3BzLiQkbGVnYWN5O1xuXHRcdHJldHVybiBmdW5jdGlvbiAoLyoqIEB0eXBlIHthbnl9ICovIHZhbHVlLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIG11dGF0aW9uKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byBub3RpZnkgaWYgdGhlIHZhbHVlIHdhcyBtdXRhdGVkIGFuZCB0aGUgcGFyZW50IGlzIGluIHJ1bmVzIG1vZGUuXG5cdFx0XHRcdC8vIEluIHRoYXQgY2FzZSB0aGUgc3RhdGUgcHJveHkgKGlmIGl0IGV4aXN0cykgc2hvdWxkIHRha2UgY2FyZSBvZiB0aGUgbm90aWZpY2F0aW9uLlxuXHRcdFx0XHQvLyBJZiB0aGUgcGFyZW50IGlzIG5vdCBpbiBydW5lcyBtb2RlLCB3ZSBuZWVkIHRvIG5vdGlmeSBvbiBtdXRhdGlvbiwgdG9vLCB0aGF0IHRoZSBwcm9wXG5cdFx0XHRcdC8vIGhhcyBjaGFuZ2VkIGJlY2F1c2UgdGhlIHBhcmVudCB3aWxsIG5vdCBiZSBhYmxlIHRvIGRldGVjdCB0aGUgY2hhbmdlIG90aGVyd2lzZS5cblx0XHRcdFx0aWYgKCFydW5lcyB8fCAhbXV0YXRpb24gfHwgbGVnYWN5X3BhcmVudCB8fCBpc19zdG9yZV9zdWIpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0Z1bmN0aW9ufSAqLyAoc2V0dGVyKShtdXRhdGlvbiA/IGdldHRlcigpIDogdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBnZXR0ZXIoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gaGFyZCBtb2RlLiB0aGlzIGlzIHdoZXJlIGl0IGdldHMgdWdseSDigJQgdGhlIHZhbHVlIGluIHRoZSBjaGlsZCBzaG91bGRcblx0Ly8gc3luY2hyb25pemUgd2l0aCB0aGUgcGFyZW50LCBidXQgaXQgc2hvdWxkIGFsc28gYmUgcG9zc2libGUgdG8gdGVtcG9yYXJpbHlcblx0Ly8gc2V0IHRoZSB2YWx1ZSB0byBzb21ldGhpbmcgZWxzZSBsb2NhbGx5LlxuXHR2YXIgZnJvbV9jaGlsZCA9IGZhbHNlO1xuXHR2YXIgd2FzX2Zyb21fY2hpbGQgPSBmYWxzZTtcblxuXHQvLyBUaGUgZGVyaXZlZCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLiBUaGUgdW5kZXJseWluZyBtdXRhYmxlXG5cdC8vIHNvdXJjZSBpcyB3cml0dGVuIHRvIGZyb20gdmFyaW91cyBwbGFjZXMgdG8gcGVyc2lzdCB0aGlzIHZhbHVlLlxuXHR2YXIgaW5uZXJfY3VycmVudF92YWx1ZSA9IG11dGFibGVfc291cmNlKHByb3BfdmFsdWUpO1xuXHR2YXIgY3VycmVudF92YWx1ZSA9IGRlcml2ZWQoKCkgPT4ge1xuXHRcdHZhciBwYXJlbnRfdmFsdWUgPSBnZXR0ZXIoKTtcblx0XHR2YXIgY2hpbGRfdmFsdWUgPSBnZXQoaW5uZXJfY3VycmVudF92YWx1ZSk7XG5cblx0XHRpZiAoZnJvbV9jaGlsZCkge1xuXHRcdFx0ZnJvbV9jaGlsZCA9IGZhbHNlO1xuXHRcdFx0d2FzX2Zyb21fY2hpbGQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGNoaWxkX3ZhbHVlO1xuXHRcdH1cblxuXHRcdHdhc19mcm9tX2NoaWxkID0gZmFsc2U7XG5cdFx0cmV0dXJuIChpbm5lcl9jdXJyZW50X3ZhbHVlLnYgPSBwYXJlbnRfdmFsdWUpO1xuXHR9KTtcblxuXHRpZiAoIWltbXV0YWJsZSkgY3VycmVudF92YWx1ZS5lcXVhbHMgPSBzYWZlX2VxdWFscztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKC8qKiBAdHlwZSB7YW55fSAqLyB2YWx1ZSwgLyoqIEB0eXBlIHtib29sZWFufSAqLyBtdXRhdGlvbikge1xuXHRcdC8vIGxlZ2FjeSBub25zZW5zZSDigJQgbmVlZCB0byBlbnN1cmUgdGhlIHNvdXJjZSBpcyBpbnZhbGlkYXRlZCB3aGVuIG5lY2Vzc2FyeVxuXHRcdC8vIGFsc28gbmVlZGVkIGZvciB3aGVuIGhhbmRsaW5nIGluc3BlY3QgbG9naWMgc28gd2UgY2FuIGluc3BlY3QgdGhlIGNvcnJlY3Qgc291cmNlIHNpZ25hbFxuXHRcdGlmIChjYXB0dXJlZF9zaWduYWxzICE9PSBudWxsKSB7XG5cdFx0XHQvLyBzZXQgdGhpcyBzbyB0aGF0IHdlIGRvbid0IHJlc2V0IHRvIHRoZSBwYXJlbnQgdmFsdWUgaWYgYGRgXG5cdFx0XHQvLyBpcyBpbnZhbGlkYXRlZCBiZWNhdXNlIG9mIGBpbnZhbGlkYXRlX2lubmVyX3NpZ25hbHNgIChyYXRoZXJcblx0XHRcdC8vIHRoYW4gYmVjYXVzZSB0aGUgcGFyZW50IG9yIGNoaWxkIHZhbHVlIGNoYW5nZWQpXG5cdFx0XHRmcm9tX2NoaWxkID0gd2FzX2Zyb21fY2hpbGQ7XG5cdFx0XHQvLyBpbnZva2UgZ2V0dGVycyBzbyB0aGF0IHNpZ25hbHMgYXJlIHBpY2tlZCB1cCBieSBgaW52YWxpZGF0ZV9pbm5lcl9zaWduYWxzYFxuXHRcdFx0Z2V0dGVyKCk7XG5cdFx0XHRnZXQoaW5uZXJfY3VycmVudF92YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zdCBuZXdfdmFsdWUgPSBtdXRhdGlvbiA/IGdldChjdXJyZW50X3ZhbHVlKSA6IHJ1bmVzICYmIGJpbmRhYmxlID8gcHJveHkodmFsdWUpIDogdmFsdWU7XG5cblx0XHRcdGlmICghY3VycmVudF92YWx1ZS5lcXVhbHMobmV3X3ZhbHVlKSkge1xuXHRcdFx0XHRmcm9tX2NoaWxkID0gdHJ1ZTtcblx0XHRcdFx0c2V0KGlubmVyX2N1cnJlbnRfdmFsdWUsIG5ld192YWx1ZSk7XG5cdFx0XHRcdC8vIFRvIGVuc3VyZSB0aGUgZmFsbGJhY2sgdmFsdWUgaXMgY29uc2lzdGVudCB3aGVuIHVzZWQgd2l0aCBwcm94aWVzLCB3ZVxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIGxvY2FsIGZhbGxiYWNrX3ZhbHVlLCBidXQgb25seSBpZiB0aGUgZmFsbGJhY2sgaXMgYWN0aXZlbHkgdXNlZFxuXHRcdFx0XHRpZiAoZmFsbGJhY2tfdXNlZCAmJiBmYWxsYmFja192YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZmFsbGJhY2tfdmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dW50cmFjaygoKSA9PiBnZXQoY3VycmVudF92YWx1ZSkpOyAvLyBmb3JjZSBhIHN5bmNocm9uaXNhdGlvbiBpbW1lZGlhdGVseVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBnZXQoY3VycmVudF92YWx1ZSk7XG5cdH07XG59XG4iLCIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIENvbXBvbmVudENvbnRleHRMZWdhY3kgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL2luZGV4LmpzJyAqL1xuLyoqIEBpbXBvcnQgeyBOb3RGdW5jdGlvbiB9IGZyb20gJy4vaW50ZXJuYWwvdHlwZXMuanMnICovXG5pbXBvcnQgeyBmbHVzaF9zeW5jLCB1bnRyYWNrIH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4vaW50ZXJuYWwvc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHVzZXJfZWZmZWN0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9lcnJvcnMuanMnO1xuaW1wb3J0IHsgbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50IH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQvZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcgfSBmcm9tICcuL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuaWYgKERFVikge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcblx0ICovXG5cdGZ1bmN0aW9uIHRocm93X3J1bmVfZXJyb3IocnVuZSkge1xuXHRcdGlmICghKHJ1bmUgaW4gZ2xvYmFsVGhpcykpIHtcblx0XHRcdC8vIFRPRE8gaWYgcGVvcGxlIHN0YXJ0IGFkanVzdGluZyB0aGUgXCJ0aGlzIGNhbiBjb250YWluIHJ1bmVzXCIgY29uZmlnIHRocm91Z2ggdi1wLXMgbW9yZSwgYWRqdXN0IHRoaXMgbWVzc2FnZVxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWU7IC8vIGxldCdzIGhvcGUgbm9vbmUgbW9kaWZpZXMgdGhpcyBnbG9iYWwsIGJ1dCBiZWx0cyBhbmQgYnJhY2VzXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgcnVuZSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZS5ydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6ICh2KSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvd19ydW5lX2Vycm9yKCckc3RhdGUnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGVmZmVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckZGVyaXZlZCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckaW5zcGVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckcHJvcHMnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGJpbmRhYmxlJyk7XG59XG5cbi8qKlxuICogVGhlIGBvbk1vdW50YCBmdW5jdGlvbiBzY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gYXMgc29vbiBhcyB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgdG8gdGhlIERPTS5cbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSAqaW5zaWRlKiB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuXG4gKlxuICogSWYgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCBfc3luY2hyb25vdXNseV8gZnJvbSBgb25Nb3VudGAsIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogYG9uTW91bnRgIGRvZXMgbm90IHJ1biBpbnNpZGUgW3NlcnZlci1zaWRlIGNvbXBvbmVudHNdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUtc2VydmVyI3JlbmRlcikuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPE5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnb25Nb3VudCcpO1xuXHR9XG5cblx0aWYgKGxlZ2FjeV9tb2RlX2ZsYWcgJiYgY29tcG9uZW50X2NvbnRleHQubCAhPT0gbnVsbCkge1xuXHRcdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkubS5wdXNoKGZuKTtcblx0fSBlbHNlIHtcblx0XHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRjb25zdCBjbGVhbnVwID0gdW50cmFjayhmbik7XG5cdFx0XHRpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHJldHVybiAvKiogQHR5cGUgeygpID0+IHZvaWR9ICovIChjbGVhbnVwKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gKlxuICogT3V0IG9mIGBvbk1vdW50YCwgYGJlZm9yZVVwZGF0ZWAsIGBhZnRlclVwZGF0ZWAgYW5kIGBvbkRlc3Ryb3lgLCB0aGlzIGlzIHRoZVxuICogb25seSBvbmUgdGhhdCBydW5zIGluc2lkZSBhIHNlcnZlci1zaWRlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnb25EZXN0cm95Jyk7XG5cdH1cblxuXHRvbk1vdW50KCgpID0+ICgpID0+IHVudHJhY2soZm4pKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgW1Q9YW55XVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7VH0gW2RldGFpbF1cbiAqIEBwYXJhbSB7YW55fXBhcmFtc18wXG4gKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnQ8VD59XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9jdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuXHRyZXR1cm4gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHsgZGV0YWlsLCBidWJibGVzLCBjYW5jZWxhYmxlIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXZlbnQgZGlzcGF0Y2hlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BhdGNoIFtjb21wb25lbnQgZXZlbnRzXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvbGVnYWN5LW9uI0NvbXBvbmVudC1ldmVudHMpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogVGhlIGV2ZW50IGRpc3BhdGNoZXIgY2FuIGJlIHR5cGVkIHRvIG5hcnJvdyB0aGUgYWxsb3dlZCBldmVudCBuYW1lcyBhbmQgdGhlIHR5cGUgb2YgdGhlIGBkZXRhaWxgIGFyZ3VtZW50OlxuICogYGBgdHNcbiAqIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyPHtcbiAqICBsb2FkZWQ6IG5ldmVyOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgY2FsbGJhY2sgcHJvcHMgYW5kL29yIHRoZSBgJGhvc3QoKWAgcnVuZSBpbnN0ZWFkIOKAlCBzZWUgW21pZ3JhdGlvbiBndWlkZV0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3Y1LW1pZ3JhdGlvbi1ndWlkZSNFdmVudC1jaGFuZ2VzLUNvbXBvbmVudC1ldmVudHMpXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcCA9IGFueV1cbiAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnY3JlYXRlRXZlbnREaXNwYXRjaGVyJyk7XG5cdH1cblxuXHRyZXR1cm4gKHR5cGUsIGRldGFpbCwgb3B0aW9ucykgPT4ge1xuXHRcdGNvbnN0IGV2ZW50cyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb24gfCBGdW5jdGlvbltdPn0gKi8gKFxuXHRcdFx0YWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LnMuJCRldmVudHNcblx0XHQpPy5bLyoqIEB0eXBlIHthbnl9ICovICh0eXBlKV07XG5cblx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFja3MgPSBpc19hcnJheShldmVudHMpID8gZXZlbnRzLnNsaWNlKCkgOiBbZXZlbnRzXTtcblx0XHRcdC8vIFRPRE8gYXJlIHRoZXJlIHNpdHVhdGlvbnMgd2hlcmUgZXZlbnRzIGNvdWxkIGJlIGRpc3BhdGNoZWRcblx0XHRcdC8vIGluIGEgc2VydmVyIChub24tRE9NKSBlbnZpcm9ubWVudD9cblx0XHRcdGNvbnN0IGV2ZW50ID0gY3JlYXRlX2N1c3RvbV9ldmVudCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBkZXRhaWwsIG9wdGlvbnMpO1xuXHRcdFx0Zm9yIChjb25zdCBmbiBvZiBjYWxsYmFja3MpIHtcblx0XHRcdFx0Zm4uY2FsbChhY3RpdmVfY29tcG9uZW50X2NvbnRleHQueCwgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xufVxuXG4vLyBUT0RPIG1hcmsgYmVmb3JlVXBkYXRlIGFuZCBhZnRlclVwZGF0ZSBhcyBkZXByZWNhdGVkIGluIFN2ZWx0ZSA2XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVwZGF0ZWQgYWZ0ZXIgYW55IHN0YXRlIGNoYW5nZS5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGJlZm9yZSB0aGUgaW5pdGlhbCBgb25Nb3VudGAuXG4gKlxuICogSW4gcnVuZXMgbW9kZSB1c2UgYCRlZmZlY3QucHJlYCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBbYCRlZmZlY3QucHJlYF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLyRlZmZlY3QjJGVmZmVjdC5wcmUpIGluc3RlYWRcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlVXBkYXRlKGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KCdiZWZvcmVVcGRhdGUnKTtcblx0fVxuXG5cdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkuYi5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0YCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCkgaW5zdGVhZFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ2FmdGVyVXBkYXRlJyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KCdhZnRlclVwZGF0ZScpO1xuXHR9XG5cblx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5hLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIExlZ2FjeS1tb2RlOiBJbml0IGNhbGxiYWNrcyBvYmplY3QgZm9yIG9uTW91bnQvYmVmb3JlVXBkYXRlL2FmdGVyVXBkYXRlXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHR9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbnRleHQpIHtcblx0dmFyIGwgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb250ZXh0KS5sO1xuXHRyZXR1cm4gKGwudSA/Pz0geyBhOiBbXSwgYjogW10sIG06IFtdIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZmx1c2hlcyBhbnkgcGVuZGluZyBzdGF0ZSBjaGFuZ2VzIGFuZCB0aG9zZSB0aGF0IHJlc3VsdCBmcm9tIGl0LlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbZm5dXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuXHRmbHVzaF9zeW5jKGZuKTtcbn1cblxuZXhwb3J0IHsgZ2V0Q29udGV4dCwgZ2V0QWxsQ29udGV4dHMsIGhhc0NvbnRleHQsIHNldENvbnRleHQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9jb250ZXh0LmpzJztcbmV4cG9ydCB7IGh5ZHJhdGUsIG1vdW50LCB1bm1vdW50IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzJztcbmV4cG9ydCB7IHRpY2ssIHVudHJhY2sgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9ydW50aW1lLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVJhd1NuaXBwZXQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3NuaXBwZXQuanMnO1xuIiwiLy8gZ2VuZXJhdGVkIGR1cmluZyByZWxlYXNlLCBkbyBub3QgbW9kaWZ5XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgdmVyc2lvbiwgYXMgc2V0IGluIHBhY2thZ2UuanNvbi5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzUuMjAuMic7XG5leHBvcnQgY29uc3QgUFVCTElDX1ZFUlNJT04gPSAnNSc7XG4iLCJpbXBvcnQgeyBQVUJMSUNfVkVSU0lPTiB9IGZyb20gJy4uL3ZlcnNpb24uanMnO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG5cdC8vIEB0cy1pZ25vcmVcblx0KHdpbmRvdy5fX3N2ZWx0ZSB8fD0geyB2OiBuZXcgU2V0KCkgfSkudi5hZGQoUFVCTElDX1ZFUlNJT04pO1xuIiwiY29uc3QgaW5wdXRWYWx1ZXNFeHRyYWN0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgY2hlY2tib3g6IChpbnBFbCwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgT2JqZWN0Lmhhc093bihkZWZhdWx0VmFsdWUsIFwiY2hlY2tlZFwiKSAmJlxuICAgICAgICAgICAgT2JqZWN0Lmhhc093bihkZWZhdWx0VmFsdWUsIFwidW5jaGVja2VkXCIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGlucEVsLmNoZWNrZWRcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jaGVja2VkXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUudW5jaGVja2VkO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgT2JqZWN0Lmhhc093bihpbnBFbCwgXCJ2YWx1ZVwiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGlucEVsLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGlucEVsLmNoZWNrZWQgPyBpbnBFbC52YWx1ZSA6IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlucEVsLmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBjb21tb24gdG8gVUkgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzXG4gKlxuICogQGNsYXNzIFVJQ29tbW9uXG4gKi9cbmNsYXNzIFVJQ29tbW9uIHtcbiAgICBzdGF0aWMgQ0xFQVJfTUFDUk8gPSBcIl9fQ0xFQVJfX1wiO1xuICAgIHN0YXRpYyBFUlJPUl9ERUZBVUxUID0gXCLQp9GC0L4g0L/QvtGI0LvQviDQvdC1INGC0LDQui5cIjtcbiAgICBzdGF0aWMgREVGQVVMVF9SRURJUkVDVF9USU1FT1VUID0gMzAwMDtcbiAgICBzdGF0aWMgQ0xBU1NfT0sgPSBcImlzLXN1Y2Nlc3NcIjtcbiAgICBzdGF0aWMgQ0xBU1NfRVJSID0gXCJpcy1kYW5nZXJcIjtcbiAgICBzdGF0aWMgU0NST0xMX0RJU0FCTEVSX0NMQVNTID0gXCJyZW1vdmUtc2Nyb2xsXCI7XG4gICAgc3RhdGljIEZJTExFUiA9IFwiX1wiO1xuXG4gICAgc3RhdGljIFNDUk9MTF9PUFRJT05TID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0IGlucHV0VmFsdWVzRXh0cmFjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWVzRXh0cmFjdG9ycztcbiAgICB9XG5cbiAgICBzdGF0aWMgZXh0cmFjdFZhbHVlRnJvbUlucHV0KGlucEVsLCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFpbnBFbCkgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oVUlDb21tb24uaW5wdXRWYWx1ZXNFeHRyYWN0b3JzLCBpbnBFbC50eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFVJQ29tbW9uLmlucHV0VmFsdWVzRXh0cmFjdG9yc1tpbnBFbC50eXBlXShcbiAgICAgICAgICAgICAgICBpbnBFbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucEVsLnZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgZmllbGQgICAgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuL2V2ZW50cy50eXBlcycpLlVJRXZlbnRJbnB1dENoYW5nZUNhbGxiYWNrfSAgICBvbmNoYW5nZVxuICAgICAqIEBwYXJhbSB7YW55fSAgICAgICAgIFtkZWZhdWx0VmFsdWU9dW5kZWZpbmVkXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIFthZGRpdGlvbmFsID0ge31dXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuL2V2ZW50cy50eXBlcycpLlVJRXZlbnRDYWxsYmFja31cbiAgICAgKiBAbWVtYmVyb2YgVUlDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgb25JbnB1dChmaWVsZCwgb25jaGFuZ2UsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCwgYWRkaXRpb25hbCA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25jaGFuZ2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0eXBlb2YgZXZlbnQ/LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudD8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gVUlDb21tb24uZXh0cmFjdFZhbHVlRnJvbUlucHV0KFxuICAgICAgICAgICAgICAgIGV2ZW50Py5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBvbmNoYW5nZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICAgKiBAbWVtYmVyb2YgVUlDb21tb25cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbnRlckV2ZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUua2V5ID09PSBcIkVudGVyXCIgJiYgIWUuYWx0S2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXk7XG4gICAgfVxuXG4gICAgc3RhdGljIG9ubHlPbkVudGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFVJQ29tbW9uLmlzRW50ZXJFdmVudChlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIE1PQklMRV9XSURUSF9CUkVBS19QT0lOVCA9IDc2MDtcblxuICAgIHN0YXRpYyBpc01vYmlsZSgpIHtcbiAgICAgICAgY29uc3QgdGVzdE1vYmlsZSA9IHdpbmRvdy5tYXRjaE1lZGlhIHx8IHdpbmRvdy5tc01hdGNoTWVkaWE7XG4gICAgICAgIGlmICh0ZXN0TW9iaWxlKSB7XG4gICAgICAgICAgICBsZXQgdGVzdFF1ZXJ5ID0gXCIocG9pbnRlcjpjb2Fyc2UpXCI7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heF93aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuTU9CSUxFX1dJRFRIX0JSRUFLX1BPSU5UXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICB0ZXN0UXVlcnkgPSBgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6ICR7bWF4X3dpZHRofXB4KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVzdE1vYmlsZSh0ZXN0UXVlcnkpLm1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVCb2R5U2Nyb2xsKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQodGhpcy5TQ1JPTExfRElTQUJMRVJfQ0xBU1MpO1xuICAgIH1cblxuICAgIHN0YXRpYyByZXN0b3JlQm9keVNjcm9sbCgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuU0NST0xMX0RJU0FCTEVSX0NMQVNTKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmVmb3JtYXRzIGlucHV0IGZyb20gYW55IHN0cmluZyB0byBzdHJpY3QgcGhvbmUgZm9ybWF0XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICB2YWwgICAgZnJlZSBzdHlsZSBwaG9uZSBudW1iZXJcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9ICAgIFtmaWxsZXI9VUlDb21tb24uRklMTEVSXSAgICBmcmVlIHN0eWxlIHBob25lIG51bWJlclxuICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSAgICAgICAgICBwaG9uZSBudW1iZXJcbiAgICAgKiovXG4gICAgc3RhdGljIGZvcm1hdFBob25lKHZhbCwgZmlsbGVyID0gdGhpcy5GSUxMRVIpIHtcbiAgICAgICAgLy9zdGFydGluZyBmcm9tIDExIGRpZ2l0cyBpbiBwaG9uZSBudW1iZXJcbiAgICAgICAgY29uc3Qgc2xvdHMgPSBbMSwgMiwgMiwgMiwgMywgMywgMywgNCwgNCwgNSwgNV07XG4gICAgICAgIGxldCBkaWdpdHMgPSB2YWwucmVwbGFjZSgvXFxEL2csIFwiXCIpO1xuICAgICAgICAvL2lmIHRoZXJlIGFyZSBtb3JlLCBtb3ZlIHRoZW0gdG8gY291bnRyeSBjb2RlIHNsb3RcbiAgICAgICAgaWYgKGRpZ2l0cy5sZW5ndGggPiAxMSkge1xuICAgICAgICAgICAgbGV0IGQgPSBkaWdpdHMubGVuZ3RoIC0gMTE7XG4gICAgICAgICAgICB3aGlsZSAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICBkLS07XG4gICAgICAgICAgICAgICAgc2xvdHMudW5zaGlmdCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhY2sgPSBbXCJcIiwgXCJcIiwgXCJcIiwgXCJcIiwgXCJcIl07XG4gICAgICAgIEFycmF5LmZyb20oZGlnaXRzKS5mb3JFYWNoKChkaWdpdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBzbG90ID0gc2xvdHNbaW5kZXhdO1xuICAgICAgICAgICAgc3RhY2tbc2xvdCAtIDFdID0gc3RhY2tbc2xvdCAtIDFdICsgZGlnaXQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvL2NyZWF0aW5nIG1hcCBvZiBwYXJ0cyBsZW5ndGhzXG4gICAgICAgIGNvbnN0IGxlbnMgPSBzbG90cy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhY2NbY3Vycl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhY2NbY3Vycl0gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2NbY3Vycl0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy9maWxsIGVtcHR5IHBvc2l0aW9ucyB3aXRoIGZpbGxlciAoXylcbiAgICAgICAgZm9yIChsZXQgdCBpbiBzdGFjaykge1xuICAgICAgICAgICAgbGV0IGRpZiA9IGxlbnNbcGFyc2VJbnQodCkgKyAxXSAtIHN0YWNrW3RdLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChkaWYgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tbdF0gPSBzdGFja1t0XSArIGZpbGxlcjtcbiAgICAgICAgICAgICAgICBkaWYtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCske3N0YWNrWzBdfSAoJHtzdGFja1sxXX0pICR7c3RhY2tbMl19LSR7c3RhY2tbM119LSR7c3RhY2tbNF19YDtcbiAgICB9XG5cbiAgICBzdGF0aWMgTU9ORVlfU0lHTiA9IFwiJiM4MzgxO1wiO1xuXG4gICAgc3RhdGljIHNldE1vbmV5U2lnbih2YWwpIHtcbiAgICAgICAgdGhpcy5NT05FWV9TSUdOID0gdmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByaWNlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBVSUNvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JtYXRQcmljZShwcmljZSkge1xuICAgICAgICBsZXQgbWFqb3IgPSBNYXRoLmZsb29yKHByaWNlIC8gMTAwKSxcbiAgICAgICAgICAgIG1pbm9yID0gcHJpY2UgJSAxMDA7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLk1PTkVZX1NJR059JHttYWpvci50b1N0cmluZygpfS4ke21pbm9yLnRvU3RyaW5nKCl9YDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZm9ybWF0TG9jYWxlRGF0ZXRpbWUoZHQsIG9wdHMgPSB7IGRhdGU6IHRydWUsIHRpbWU6IHRydWUgfSkge1xuICAgICAgICBjb25zdCBkYXRlID0gZHQudG9Mb2NhbGVEYXRlU3RyaW5nKHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UpO1xuICAgICAgICBjb25zdCB0aW1lID0gZHQudG9Mb2NhbGVUaW1lU3RyaW5nKHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAob3B0cy5kYXRlICYmIG9wdHMudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2RhdGV9ICR7dGltZX1gO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMuZGF0ZSAmJiAhb3B0cy50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHRyeUZvcm1hdExvY2FsZURhdGVUaW1lKHZhbHVlLCBvcHRzID0geyBkYXRlOiB0cnVlLCB0aW1lOiB0cnVlIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBVSUNvbW1vbi5mb3JtYXRMb2NhbGVEYXRldGltZShkdCwgb3B0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBVSUNvbW1vbi5mb3JtYXRMb2NhbGVEYXRldGltZSh2YWx1ZSwgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBmb3JtYXRUaW1lc3RhbXAodGltZXN0YW1wLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBvZmZzZXRMb2NhbCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgbGV0IGRlbHRhT2Zmc2V0ID0gKG9mZnNldExvY2FsIC0gb2Zmc2V0KSAqIDYwICogMTAwMDtcbiAgICAgICAgbGV0IGxvY2FsRGF0ZVRpbWUgPSBuZXcgRGF0ZShwYXJzZUludCh0aW1lc3RhbXApIC0gZGVsdGFPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbG9jYWxEYXRlVGltZS50b0xvY2FsZVN0cmluZyh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgVElNRSA9IHtcbiAgICAgICAgU0VDT05EUzogW1wi0YHQtdC60YPQvdC00YNcIiwgXCLRgdC10LrRg9C90LTRi1wiLCBcItGB0LXQutGD0L3QtFwiXSxcbiAgICAgICAgTUlOVVRFUzogW1wi0LzQuNC90YPRgtGDXCIsIFwi0LzQuNC90YPRgtGLXCIsIFwi0LzQuNC90YPRglwiXSxcbiAgICAgICAgSE9VUlM6IFtcItGH0LDRgVwiLCBcItGH0LDRgdCwXCIsIFwi0YfQsNGB0L7QslwiXSxcbiAgICB9O1xuXG4gICAgc3RhdGljIGRlY2xPZk51bShuLCB0ZXh0X2Zvcm1zKSB7XG4gICAgICAgIG4gPSBNYXRoLmFicyhuKSAlIDEwMDtcbiAgICAgICAgbGV0IG4xID0gbiAlIDEwO1xuICAgICAgICBpZiAobiA+IDEwICYmIG4gPCAyMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRfZm9ybXNbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4xID4gMSAmJiBuMSA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0X2Zvcm1zWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dF9mb3Jtc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dF9mb3Jtc1syXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaHVtYW5pemVkVGltZURpZmYoZGF0ZSAvKiB1bml4IHRpbWUgKi8pIHtcbiAgICAgICAgbGV0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBzZWMgPSBNYXRoLnJvdW5kKChjdXJyZW50VGltZSAtIGRhdGUpIC8gMTAwMCk7XG4gICAgICAgIGxldCB1bml0O1xuICAgICAgICBpZiAoc2VjIDwgNjApIHtcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmRlY2xPZk51bShzZWMsIHRoaXMuVElNRS5TRUNPTkRTKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtzZWN9ICR7dW5pdH0g0L3QsNC30LDQtGA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjIDwgMzYwMCkge1xuICAgICAgICAgICAgbGV0IG1pbiA9IE1hdGguZmxvb3Ioc2VjIC8gNjApO1xuICAgICAgICAgICAgdW5pdCA9IHRoaXMuZGVjbE9mTnVtKG1pbiwgdGhpcy5USU1FLk1JTlVURVMpO1xuICAgICAgICAgICAgcmV0dXJuIGAke21pbn0gJHt1bml0fSDQvdCw0LfQsNC0YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBob3VycyA9IE1hdGguZmxvb3Ioc2VjIC8gKDYwICogNjApKTtcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmRlY2xPZk51bShob3VycywgdGhpcy5USU1FLkhPVVJTKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtob3Vyc30gJHt1bml0fSDQvdCw0LfQsNC0YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBzdHlsZXNPYmplY3RUb1N0cmluZyhzdHlsZXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKVxuICAgICAgICAgICAgICAgIC5tYXAoKHByb3ApID0+IGAke3Byb3B9OiAke3N0eWxlcy5wcm9wfTtgKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgc3RyaW5nT3JOdW1iZXIodmFsKSB7XG4gICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0uaW5kZXhPZih0eXBlb2YgdmFsKSA+IC0xO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdHJpbmdzT2ZOdW1iZXJzKGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QuZXZlcnkodGhpcy5zdHJpbmdPck51bWJlcik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVSUNvbW1vbjtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBjbGFzczogY2xhc3NlcyA9IFwiXCIsIGNoaWxkcmVuLCAuLi5vdGhlcnMgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJibG9jayB7Y2xhc3Nlc31cIiB7Li4ub3RoZXJzfT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICBpbXBvcnQgVUlCbG9jayBmcm9tIFwiLi91aS5ibG9jay5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleD0wXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrID0gKCkgPT4gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25rZXl1cF1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gMCxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgb25jbGljayA9ICgpID0+IHRydWUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IERFRkFVTFRfQ0xBU1NFU19JTk5FUiA9IFwiYmxvY2staW5uZXItdmVydGljYWxcIjtcblxuICAgIGxldCBjbGFzc2VzSW5uZXIgPSAkc3RhdGUoREVGQVVMVF9DTEFTU0VTX0lOTkVSKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBjbGFzc2VzSW5uZXIgPSBgYmxvY2staW5uZXItdmVydGljYWwgJHtjbGFzc2VzfWA7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbktleVVwID1cbiAgICAgICAgb25rZXl1cCA/PyAob25jbGljayA/IFVJQ29tbW9uLm9ubHlPbkVudGVyKG9uY2xpY2spIDogdW5kZWZpbmVkKTtcbjwvc2NyaXB0PlxuXG48VUlCbG9ja1xuICAgIHtpZH1cbiAgICBjbGFzcz17Y2xhc3Nlc0lubmVyfVxuICAgIHtvbmNsaWNrfVxuICAgIG9ua2V5dXA9e29uS2V5VXB9XG4gICAge3JvbGV9XG4gICAge3RhYkluZGV4fVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvVUlCbG9jaz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdGFiSW5kZXg9MF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGljayA9ICgpID0+IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IDAsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBvbktleVVwID1cbiAgICAgICAgb25rZXl1cCA/PyAob25jbGljayA/IFVJQ29tbW9uLm9ubHlPbkVudGVyKG9uY2xpY2spIDogdW5kZWZpbmVkKTtcbjwvc2NyaXB0PlxuXG48ZGl2IHtpZH0gY2xhc3M9XCJib3gge2NsYXNzZXN9IFwiIHtvbmNsaWNrfSBvbmtleXVwPXtvbktleVVwfSB7cm9sZX0ge3RhYkluZGV4fT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3JvbGU9XCJidXR0b25cIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdGFiSW5kZXg9MF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGljayA9ICgpID0+IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IDAsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBvbktleVVwID1cbiAgICAgICAgb25rZXl1cCA/PyAob25jbGljayA/IFVJQ29tbW9uLm9ubHlPbkVudGVyKG9uY2xpY2spIDogdW5kZWZpbmVkKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAge2lkfVxuICAgIGNsYXNzPVwiY29udGVudCB7Y2xhc3Nlc31cIlxuICAgIHtvbmNsaWNrfVxuICAgIG9ua2V5dXA9e29uS2V5VXB9XG4gICAge3JvbGV9XG4gICAge3RhYkluZGV4fVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBsZXQge1xuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZSxcbiAgICAgICAgY2xpY2sgPSB0cnVlLFxuICAgICAgICBlbnRlciA9IHRydWUsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgY29uc3QgbW91c2VFdmVudCA9IChlKSA9PiB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGtleWJvYXJkRXZlbnQgPSAoZSkgPT4ge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChlICYmIGUua2V5ID09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgIH1cbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz17Y2xhc3Nlc31cbiAgICByb2xlPVwiYnV0dG9uXCJcbiAgICB0YWJpbmRleD1cIjBcIlxuICAgIG9ua2V5dXA9e2VudGVyID8ga2V5Ym9hcmRFdmVudCA6IHVuZGVmaW5lZH1cbiAgICBvbmNsaWNrPXtjbGljayA/IG1vdXNlRXZlbnQgOiB1bmRlZmluZWR9XG4gICAgey4uLm90aGVyc31cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbigpfVxuPC9kaXY+XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblxuZnVuY3Rpb24gaW5pdERpY3QodGFyZ2V0ID0ge30pIHtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bih0YXJnZXQsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCBoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxlKCkge1xuICAgIGNvbnN0IHsgc3Vic2NyaWJlLCBzZXQsIHVwZGF0ZSB9ID0gd3JpdGFibGUoaW5pdERpY3QoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICB1cGRhdGUsXG4gICAgICAgIHNldDogKHZhbCkgPT4ge1xuICAgICAgICAgICAgc2V0KGluaXREaWN0KHZhbCkpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogKCkgPT4gc2V0KGluaXREaWN0KCkpLFxuICAgIH07XG59XG5cbmNvbnN0IExPQ0FMRSA9IGNyZWF0ZUxvY2FsZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBMT0NBTEU7XG4iLCIvKiFcbiAqIEV2ZW50RW1pdHRlciB2NS4yLjkgLSBnaXQuaW8vZWVcbiAqIFVubGljZW5zZSAtIGh0dHA6Ly91bmxpY2Vuc2Uub3JnL1xuICogT2xpdmVyIENhbGR3ZWxsIC0gaHR0cHM6Ly9vbGkubWUudWsvXG4gKiBAcHJlc2VydmVcbiAqL1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cy5cbiAgICAgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgRXZlbnRFbWl0dGVyIE1hbmFnZXMgZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGVtaXR0aW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XG5cbiAgICAvLyBTaG9ydGN1dHMgdG8gaW1wcm92ZSBzcGVlZCBhbmQgc2l6ZVxuICAgIHZhciBwcm90byA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG4gICAgdmFyIG9yaWdpbmFsR2xvYmFsVmFsdWUgPSBleHBvcnRzLkV2ZW50RW1pdHRlcjtcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBpbiBpdHMgc3RvcmFnZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gbG9vayBmb3IuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyLCAtMSBpZiBub3QgZm91bmRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXMgYSBtZXRob2Qgd2hpbGUga2VlcGluZyB0aGUgY29udGV4dCBjb3JyZWN0LCB0byBhbGxvdyBmb3Igb3ZlcndyaXRpbmcgb2YgdGFyZ2V0IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgYWxpYXNlZCBtZXRob2RcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbGlhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhbGlhc0Nsb3N1cmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFdpbGwgaW5pdGlhbGlzZSB0aGUgZXZlbnQgb2JqZWN0IGFuZCBsaXN0ZW5lciBhcnJheXMgaWYgcmVxdWlyZWQuXG4gICAgICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxuICAgICAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXG4gICAgICovXG4gICAgcHJvdG8uZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAvLyBSZXR1cm4gYSBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGV2ZW50cyBpZlxuICAgICAgICAvLyB0aGUgc2VsZWN0b3IgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICAgIGlmIChldnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtrZXldID0gZXZlbnRzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBldmVudHNbZXZ0XSB8fCAoZXZlbnRzW2V2dF0gPSBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgbGlzdCBvZiBsaXN0ZW5lciBvYmplY3RzIGFuZCBmbGF0dGVucyBpdCBpbnRvIGEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBsaXN0ZW5lcnMgUmF3IGxpc3RlbmVyIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb25bXX0gSnVzdCB0aGUgbGlzdGVuZXIgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHByb3RvLmZsYXR0ZW5MaXN0ZW5lcnMgPSBmdW5jdGlvbiBmbGF0dGVuTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgICAgICB2YXIgZmxhdExpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGF0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzW2ldLmxpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGF0TGlzdGVuZXJzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSByZXF1ZXN0ZWQgbGlzdGVuZXJzIHZpYSBnZXRMaXN0ZW5lcnMgYnV0IHdpbGwgYWx3YXlzIHJldHVybiB0aGUgcmVzdWx0cyBpbnNpZGUgYW4gb2JqZWN0LiBUaGlzIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlIGJ1dCBvdGhlcnMgbWF5IGZpbmQgaXQgdXNlZnVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmV0dXJuIHRoZSBsaXN0ZW5lcnMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IGluIGFuIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcm90by5nZXRMaXN0ZW5lcnNBc09iamVjdCA9IGZ1bmN0aW9uIGdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIHJlc3BvbnNlW2V2dF0gPSBsaXN0ZW5lcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UgfHwgbGlzdGVuZXJzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkTGlzdGVuZXIgKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgfHwgbGlzdGVuZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRMaXN0ZW5lcihsaXN0ZW5lci5saXN0ZW5lcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxuICAgICAqIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgY2FsbGVkLlxuICAgICAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcklzV3JhcHBlZCA/IGxpc3RlbmVyIDoge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgYWRkTGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcm90by5vbiA9IGFsaWFzKCdhZGRMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgaXRzIGZpcnN0IGV4ZWN1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNhbGxpbmcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkT25jZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZ0LCB7XG4gICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBhZGRPbmNlTGlzdGVuZXIuXG4gICAgICovXG4gICAgcHJvdG8ub25jZSA9IGFsaWFzKCdhZGRPbmNlTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYW4gZXZlbnQgbmFtZS4gVGhpcyBpcyByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSByZWdleCB0byBhZGQgYSBsaXN0ZW5lciB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gSWYgeW91IGRvbid0IGRvIHRoaXMgdGhlbiBob3cgZG8geW91IGV4cGVjdCBpdCB0byBrbm93IHdoYXQgZXZlbnQgdG8gYWRkIHRvPyBTaG91bGQgaXQganVzdCBhZGQgdG8gZXZlcnkgcG9zc2libGUgbWF0Y2ggZm9yIGEgcmVnZXg/IE5vLiBUaGF0IGlzIHNjYXJ5IGFuZCBiYWQuXG4gICAgICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50KGV2dCkge1xuICAgICAgICB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlcyBkZWZpbmVFdmVudCB0byBkZWZpbmUgbXVsdGlwbGUgZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZXZ0cyBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkZWZpbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uZGVmaW5lRXZlbnRzID0gZnVuY3Rpb24gZGVmaW5lRXZlbnRzKGV2dHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmluZUV2ZW50KGV2dHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIFdoZW4gcGFzc2VkIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lLCBpdCB3aWxsIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgcmVtb3ZlTGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcm90by5vZmYgPSBhbGlhcygncmVtb3ZlTGlzdGVuZXInKTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IGNhbiBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy4gWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIGFkZCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKiBZZWFoLCB0aGlzIGZ1bmN0aW9uIGRvZXMgcXVpdGUgYSBiaXQuIFRoYXQncyBwcm9iYWJseSBhIGJhZCB0aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKGZhbHNlLCBldnQsIGxpc3RlbmVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuICAgICAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IGNhbiByZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSByZW1vdmVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyh0cnVlLCBldnQsIGxpc3RlbmVycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVkaXRzIGxpc3RlbmVycyBpbiBidWxrLiBUaGUgYWRkTGlzdGVuZXJzIGFuZCByZW1vdmVMaXN0ZW5lcnMgbWV0aG9kcyBib3RoIHVzZSB0aGlzIHRvIGRvIHRoZWlyIGpvYi4gWW91IHNob3VsZCByZWFsbHkgdXNlIHRob3NlIGluc3RlYWQsIHRoaXMgaXMgYSBsaXR0bGUgbG93ZXIgbGV2ZWwuXG4gICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgZGV0ZXJtaW5lIGlmIHRoZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgKHRydWUpIG9yIGFkZGVkIChmYWxzZSkuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQvcmVtb3ZlZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYW5pcHVsYXRlIHRoZSBsaXN0ZW5lcnMgb2YgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgVHJ1ZSBpZiB5b3Ugd2FudCB0byByZW1vdmUgbGlzdGVuZXJzLCBmYWxzZSBpZiB5b3Ugd2FudCB0byBhZGQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQvcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLm1hbmlwdWxhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBtYW5pcHVsYXRlTGlzdGVuZXJzKHJlbW92ZSwgZXZ0LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIHNpbmdsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyO1xuICAgICAgICB2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xuXG4gICAgICAgIC8vIElmIGV2dCBpcyBhbiBvYmplY3QgdGhlbiBwYXNzIGVhY2ggb2YgaXRzIHByb3BlcnRpZXMgdG8gdGhpcyBtZXRob2RcbiAgICAgICAgaWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgICAgZm9yIChpIGluIGV2dCkge1xuICAgICAgICAgICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkgJiYgKHZhbHVlID0gZXZ0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXNzIGJhY2sgdG8gdGhlIG11bHRpcGxlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNvIGV2dCBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICAgICAgICAvLyBBbmQgbGlzdGVuZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgbGlzdGVuZXJzXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgaXQgYW5kIHBhc3MgZWFjaCBvbmUgdG8gdGhlIG11bHRpcGxlIG1ldGhvZFxuICAgICAgICAgICAgaSA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50LlxuICAgICAqIElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbiBldmVudCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxuICAgICAqIFRoYXQgbWVhbnMgZXZlcnkgZXZlbnQgd2lsbCBiZSBlbXB0aWVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVnZXggdG8gcmVtb3ZlIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gW2V2dF0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLiBXaWxsIHJlbW92ZSBmcm9tIGV2ZXJ5IGV2ZW50IGlmIG5vdCBwYXNzZWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChldnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZXZ0O1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZ2V0RXZlbnRzKCk7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZiBldnRcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tldnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBldmVudHMgbWF0Y2hpbmcgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgZm9yIChrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGluIGFsbCBldmVudHNcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgcmVtb3ZlRXZlbnQuXG4gICAgICpcbiAgICAgKiBBZGRlZCB0byBtaXJyb3IgdGhlIG5vZGUgQVBJLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUFsbExpc3RlbmVycyA9IGFsaWFzKCdyZW1vdmVFdmVudCcpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgb2YgeW91ciBjaG9pY2UuXG4gICAgICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXG4gICAgICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxuICAgICAqIEJlY2F1c2UgaXQgdXNlcyBgYXBwbHlgLCB5b3VyIGFycmF5IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBpZiB5b3Ugd3JvdGUgdGhlbSBvdXQgc2VwYXJhdGVseS5cbiAgICAgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnNNYXAgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG4gICAgICAgIHZhciBsaXN0ZW5lcnM7XG4gICAgICAgIHZhciBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciByZXNwb25zZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnNNYXApIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcFtrZXldLnNsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJucyB0cnVlIHRoZW4gaXQgc2hhbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm9uY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGxpc3RlbmVyLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MgfHwgW10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdGhpcy5fZ2V0T25jZVJldHVyblZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxpYXMgb2YgZW1pdEV2ZW50XG4gICAgICovXG4gICAgcHJvdG8udHJpZ2dlciA9IGFsaWFzKCdlbWl0RXZlbnQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cbiAgICAgKiBBcyB3aXRoIGVtaXRFdmVudCwgeW91IGNhbiBwYXNzIGEgcmVnZXggaW4gcGxhY2Ugb2YgdGhlIGV2ZW50IG5hbWUgdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4qfSBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZXZ0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWYgYVxuICAgICAqIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGUgb25lIHNldCBoZXJlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkXG4gICAgICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gY2hlY2sgZm9yIHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5zZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBzZXRPbmNlUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb25jZVJldHVyblZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZlxuICAgICAqIHRoZSBsaXN0ZW5lcnMgcmV0dXJuIHZhbHVlIG1hdGNoZXMgdGhpcyBvbmUgdGhlbiBpdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgICAqIGF1dG9tYXRpY2FsbHkuIEl0IHdpbGwgcmV0dXJuIHRydWUgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp8Qm9vbGVhbn0gVGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgZm9yIG9yIHRoZSBkZWZhdWx0LCB0cnVlLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLl9nZXRPbmNlUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiBfZ2V0T25jZVJldHVyblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnX29uY2VSZXR1cm5WYWx1ZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25jZVJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgZXZlbnRzIG9iamVjdCBhbmQgY3JlYXRlcyBvbmUgaWYgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgZ2xvYmFsIHtAbGluayBFdmVudEVtaXR0ZXJ9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTm9uIGNvbmZsaWN0aW5nIEV2ZW50RW1pdHRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gb3JpZ2luYWxHbG9iYWxWYWx1ZTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIHRoZSBjbGFzcyBlaXRoZXIgdmlhIEFNRCwgQ29tbW9uSlMgb3IgdGhlIGdsb2JhbCBvYmplY3RcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpe1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuICAgIH1cbn0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzIHx8IHt9KSk7XG4iLCIvKlxuXHQ6cHJvcGVydHkuc3ViMS5mdW5jKCkuZnVuY1Byb3Bcblx0ID0gcmV0dXJuIGZ1bmNQcm9wIG9mIGZ1bmN0aW9uIHJlc3VsdCBvZiBzdWIxIHByb3BlcnR5IG9mIHByb3BlcnR5IG9mIG9iamVjdFxuXHQ6ezo6aGVscGVyVmFsfS5zdWJcblx0ID0gcmV0dXJuIHN1YiBwcm9wZXJ0eSBvZiBvYmplY3QgcHJvcGVydHkgd2l0aCBuYW1lIHJldHJpZXZlZCBmcm9tIGhlbHBlclZhbCBwcm9wZXJ0eSBvZiBoZWxwZXJzIG9iamVjdFxuXHQ6ezo6aGVscGVyRnVuYygpfS5zdWJcblx0PSByZXR1cm4gc3ViIHByb3BlcnR5IG9mIG9iamVjdCBwcm9wZXJ0eSB3aXRoIG5hbWUgcmV0cmlldmVkIGZyb20gaGVscGVyVmFsIGZ1bmN0aW9uIHJlc3VsdCBvZiBoZWxwZXJzIG9iamVjdC5cblx0aWYgaGVscGVyc0Z1bnggcmV0dXJuICdjYXInIHRoZW4gc291cmNlIHBhdGggYmVjb21lcyA6Y2FyLnN1YlxuXG4qL1xuXG5jb25zdCBTVUJfUEFUSF9TVEFSVCA9IFwie1wiLFxuICAgIFNVQl9QQVRIX0VORCA9IFwifVwiLFxuICAgIFBBVEhfU1BMSVQgPSBcIi5cIixcbiAgICBQQVRIX1NUQVJUX09CSkVDVCA9IFwiOlwiLFxuICAgIFBBVEhfU1RBUlRfSEVMUEVSUyA9IFwiOjpcIixcbiAgICBGVU5DVElPTl9NQVJLRVIgPSBcIigpXCIsXG4gICAgTUFYX0RFRVAgPSAxMDtcblxuLyoqXG4gKiBTZXQgb2YgdG9vbHMgdG8gdXNlIG5vdFBhdGggcHJvcGVydHkgYWNjZXNzIG5vdGF0aW9uXG4gKiA6IGlzIGZvciBpdGVtXG4gKiA6OiBpcyBmb3IgaGVscGVyc1xuICoge30gc3VicGF0aFxuICogLiBwYXRoIHNwbGl0dGVyXG4gKiAoKSBmdW5jdGlvbiBhbmQgc2hvdWxkIGJlIGV4ZWN1dGVkIHdpdGggcGFyYW1zIChpdGVtLCBoZWxwZXIgfCB1bmRlZmluZWQpXG4gKiBzdWItcGF0aHMgd2lsbCBiZSBwYXJzZWQgYW5kIHJlcGxhY2VkIGJ5IHJlc3VsdHMgaW4gc291cmNlIHBhdGhcbiAqL1xuY2xhc3Mgbm90UGF0aCB7XG4gICAgc3RhdGljIGdldCBTVUJfUEFUSF9TVEFSVCgpIHtcbiAgICAgICAgcmV0dXJuIFNVQl9QQVRIX1NUQVJUO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFNVQl9QQVRIX0VORCgpIHtcbiAgICAgICAgcmV0dXJuIFNVQl9QQVRIX0VORDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBQQVRIX1NQTElUKCkge1xuICAgICAgICByZXR1cm4gUEFUSF9TUExJVDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBQQVRIX1NUQVJUX09CSkVDVCgpIHtcbiAgICAgICAgcmV0dXJuIFBBVEhfU1RBUlRfT0JKRUNUO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IFBBVEhfU1RBUlRfSEVMUEVSUygpIHtcbiAgICAgICAgcmV0dXJuIFBBVEhfU1RBUlRfSEVMUEVSUztcbiAgICB9XG4gICAgc3RhdGljIGdldCBGVU5DVElPTl9NQVJLRVIoKSB7XG4gICAgICAgIHJldHVybiBGVU5DVElPTl9NQVJLRVI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTUFYX0RFRVAoKSB7XG4gICAgICAgIHJldHVybiBNQVhfREVFUDtcbiAgICB9XG5cbiAgICAvKlxuXHRcdGlucHV0ICc6ezo6aGVscGVyVmFsfS5zdWInXG5cdFx0cmV0dXJuIDo6aGVscGVyVmFsXG5cdCovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IHN1YnBhdGggaW4gcGF0aFxuICAgICAqIGlmIHN1YnBhdGggbm90IGNsb3NlZCB3aWxsIHJldHVybiBpdCBhbnl3YXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIGluIHN0cmluZyBub3RhdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSBzdWJwYXRoIG9yIG51bGwgaWYgbm8gc3ViIHBhdGggd2VyZSBmb3VuZFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5kTmV4dFN1YlBhdGgocGF0aCkge1xuICAgICAgICBsZXQgc3ViUGF0aCA9IFwiXCIsXG4gICAgICAgICAgICBmaW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09IFNVQl9QQVRIX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgZmluZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3ViUGF0aCA9IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwYXRoW2ldID09PSBTVUJfUEFUSF9FTkQgJiYgZmluZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViUGF0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXRoICs9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kID8gc3ViUGF0aCA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBzdWItcGF0aCBpbiBwYXJlbnQgcGF0aCBieSBwYXJzZWQgdmVyc2lvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdWIgc3ViIHBhdGggdG8gcmVwbGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJzZWQgcGFyc2VkIHN1YiBwYXRoXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBwYXJzZWQgcGF0aFxuICAgICAqL1xuXG4gICAgc3RhdGljIHJlcGxhY2VTdWJQYXRoKHBhdGgsIHN1YiwgcGFyc2VkKSB7XG4gICAgICAgIGxldCBzdWJmID0gU1VCX1BBVEhfU1RBUlQgKyBzdWIgKyBTVUJfUEFUSF9FTkQsXG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKHBhdGguaW5kZXhPZihzdWJmKSA+IC0xICYmIGkgPCBNQVhfREVFUCkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShzdWJmLCBwYXJzZWQpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBwYXRoIHdoaWxlIHRoZXJlIGFueSBzdWItcGF0aHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCByYXcgdW5wYXJzZWQgcGF0aFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVscGVycyBoZWxwZXJzXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBwYXJzZWQgcGF0aFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVN1YnMocGF0aCwgaXRlbSwgaGVscGVycykge1xuICAgICAgICBsZXQgc3ViUGF0aCA9IHRoaXMuZmluZE5leHRTdWJQYXRoKHBhdGgpLFxuICAgICAgICAgICAgc3ViUGF0aFBhcnNlZCxcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoc3ViUGF0aCkge1xuICAgICAgICAgICAgc3ViUGF0aFBhcnNlZCA9IHRoaXMuZ2V0VmFsdWVCeVBhdGgoXG4gICAgICAgICAgICAgICAgc3ViUGF0aC5pbmRleE9mKFBBVEhfU1RBUlRfSEVMUEVSUykgPiAtMSA/IGhlbHBlcnMgOiBpdGVtLFxuICAgICAgICAgICAgICAgIHN1YlBhdGgsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBoZWxwZXJzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcGF0aCA9IHRoaXMucmVwbGFjZVN1YlBhdGgocGF0aCwgc3ViUGF0aCwgc3ViUGF0aFBhcnNlZCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA+IE1BWF9ERUVQKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJQYXRoID0gdGhpcy5maW5kTmV4dFN1YlBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtoZWxwZXJzXSBoZWxwZXJzIG9iamVjdFxuICAgICAqL1xuXG4gICAgc3RhdGljIGdldChwYXRoLCBpdGVtLCBoZWxwZXJzID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgY2FzZSBQQVRIX1NUQVJUX09CSkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIGNhc2UgUEFUSF9TVEFSVF9IRUxQRVJTOlxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSB0aGlzLnBhcnNlU3VicyhwYXRoLCBpdGVtLCBoZWxwZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVCeVBhdGgoXG4gICAgICAgICAgICBwYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9IRUxQRVJTKSA+IC0xID8gaGVscGVycyA6IGl0ZW0sXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIGhlbHBlcnNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHBhdGggcGF0aCB0byBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgaGVscGVycyAgICAgICAgIGhlbHBlcnMgb2JqZWN0IGlmIDQgYXJndW1lbnRzIG9yIGF0dHJWYWx1ZSBpZiBvbmx5IDMgcHJvdmlkZWRcbiAgICAgKiBAcGFyYW0ge2FueX0gICAgIFthdHRyVmFsdWVdICAgICB2YWx1ZSB3ZSB3YW50IHRvIGFzc2lnblxuICAgICAqL1xuXG4gICAgc3RhdGljIHNldChwYXRoLCBpdGVtLCBoZWxwZXJzLCBhdHRyVmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGF0dHJWYWx1ZSA9IGhlbHBlcnM7XG4gICAgICAgICAgICBoZWxwZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJQYXRoID0gdGhpcy5maW5kTmV4dFN1YlBhdGgocGF0aCksXG4gICAgICAgICAgICBzdWJQYXRoUGFyc2VkLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChzdWJQYXRoKSB7XG4gICAgICAgICAgICBzdWJQYXRoUGFyc2VkID0gdGhpcy5nZXRWYWx1ZUJ5UGF0aChcbiAgICAgICAgICAgICAgICBzdWJQYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9IRUxQRVJTKSA+IC0xID8gaGVscGVycyA6IGl0ZW0sXG4gICAgICAgICAgICAgICAgc3ViUGF0aCxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgIGhlbHBlcnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5yZXBsYWNlU3ViUGF0aChwYXRoLCBzdWJQYXRoLCBzdWJQYXRoUGFyc2VkKTtcbiAgICAgICAgICAgIGlmIChpID4gTUFYX0RFRVApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YlBhdGggPSB0aGlzLmZpbmROZXh0U3ViUGF0aChwYXRoKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFZhbHVlQnlQYXRoKGl0ZW0sIHBhdGgsIGF0dHJWYWx1ZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGl0ZW0uaXNSZWNvcmQgJiZcbiAgICAgICAgICAgIHRoaXMubm9ybWlsaXplUGF0aChwYXRoKS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICBpdGVtLl9faXNBY3RpdmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpdGVtLnRyaWdnZXIoXCJjaGFuZ2VcIiwgaXRlbSwgcGF0aCwgYXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0YXJnZXQgcHJvcGVydHkgdG8gbnVsbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWxwZXJzIGhlbHBlcnMgb2JqZWN0XG4gICAgICovXG5cbiAgICBzdGF0aWMgdW5zZXQocGF0aCwgaXRlbSwgaGVscGVycykge1xuICAgICAgICB0aGlzLnNldChwYXRoLCBpdGVtLCBoZWxwZXJzLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgc3RlcCBrZXksIHRyYW5zZm9ybXMgaXQgdG8gZW5kLWZvcm1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RlcCBub3QgcGFyc2VkIHN0ZXAga2V5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gaXRlbSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVscGVyIGhlbHBlcnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bWJlcn0gcGFyc2VkIHN0ZXAga2V5XG4gICAgICovXG5cbiAgICBzdGF0aWMgcGFyc2VQYXRoU3RlcChzdGVwLCBpdGVtLCBoZWxwZXIpIHtcbiAgICAgICAgbGV0IHJTdGVwID0gbnVsbDtcbiAgICAgICAgaWYgKHN0ZXAuaW5kZXhPZihQQVRIX1NUQVJUX0hFTFBFUlMpID09PSAwICYmIGhlbHBlcikge1xuICAgICAgICAgICAgclN0ZXAgPSBzdGVwLnJlcGxhY2UoUEFUSF9TVEFSVF9IRUxQRVJTLCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChyU3RlcC5pbmRleE9mKEZVTkNUSU9OX01BUktFUikgPT09IHJTdGVwLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICByU3RlcCA9IHJTdGVwLnJlcGxhY2UoRlVOQ1RJT05fTUFSS0VSLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlbHBlciwgclN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJbclN0ZXBdKGl0ZW0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyW3JTdGVwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGVwLmluZGV4T2YoUEFUSF9TVEFSVF9PQkpFQ1QpID09PSAwICYmIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByU3RlcCA9IHN0ZXAucmVwbGFjZShQQVRIX1NUQVJUX09CSkVDVCwgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJTdGVwLmluZGV4T2YoRlVOQ1RJT05fTUFSS0VSKSA9PT0gclN0ZXAubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgICAgICByU3RlcCA9IHJTdGVwLnJlcGxhY2UoRlVOQ1RJT05fTUFSS0VSLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpdGVtLCByU3RlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtW3JTdGVwXShpdGVtLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bclN0ZXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICB9XG5cbiAgICAvLzo6ZmllbGROYW1lLnJlc3VsdFxuICAgIC8ve31cbiAgICAvL3tmaWVsZE5hbWU6ICd0YXJnZXRSZWNvcmRGaWVsZCd9XG4gICAgLy8vL1sndGFyZ2V0UmVjb3JkRmllbGQnLCAncmVzdWx0J11cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHBhdGggd2l0aCBzdWIgcGF0aHMgdG8gcGF0aCB3aXRob3V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHBhdGggcGF0aCB0byB0YXJnZXQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBpdGVtIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBoZWxwZXIgaGVscGVyIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2FycmF5fSBwYXJzZWQgcGF0aFxuICAgICAqKi9cbiAgICBzdGF0aWMgcGFyc2VQYXRoKHBhdGgsIGl0ZW0sIGhlbHBlcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFBBVEhfU1BMSVQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0aFtpXSA9IHRoaXMucGFyc2VQYXRoU3RlcChwYXRoW2ldLCBpdGVtLCBoZWxwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgcGF0aCBmcm9tIHN0cmluZyBub3RhdGlvbiB0byBhcnJheSBvZiBrZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHBhdGggIGlucHV0IHBhdGgsIGlmIGFycmF5IGRvZXMgbm90aGluZ1xuICAgICAqIEByZXR1cm4ge2FycmF5fSBwYXRoIGluIGFycmF5IG5vdGF0aW9uXG4gICAgICovXG5cbiAgICBzdGF0aWMgbm9ybWlsaXplUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChwYXRoLmluZGV4T2YoUEFUSF9TVEFSVF9PQkpFQ1QpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKFBBVEhfU1RBUlRfT0JKRUNULCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoLnNwbGl0KFBBVEhfU1BMSVQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcblx0XHRzbWFsbCA9IFtcInRvZG9cIl0sXG5cdFx0YmlnID0gW1widG9kb1wiLCBcImxlbmd0aFwiXVxuXHRcdHJldHVybiB0cnVlO1xuXG5cdCovXG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGlmIGZpcnN0IHBhdGggaW5jbHVkZXMgc2Vjb25kLCBjb21wYXJlZCBmcm9tIHN0YXJ0LFxuICAgICAqIG5vIGZsb2F0aW5nIHN0YXJ0IHBvc2l0aW9uIGluc2lkZSBbJ2pvaW4nLCAnbWUnXSwgWydtZSddXG4gICAgICogd2lsbCByZXN1bHQgaW4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBiaWcgd2hlcmUgd2Ugd2lsbCBzZWFyY2hcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBzbWFsbCB3aGF0IHdlIHdpbGwgc2VhcmNoXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gaWYgd2Ugc3VjY2VlZFxuICAgICAqL1xuXG4gICAgc3RhdGljIGlmRnVsbFN1YlBhdGgoYmlnLCBzbWFsbCkge1xuICAgICAgICBpZiAoYmlnLmxlbmd0aCA8IHNtYWxsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgc21hbGwubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGlmIChzbWFsbFt0XSAhPT0gYmlnW3RdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRlciB0aHJvdWdoIHRoaXJkIG9iamVjdFxuICAgICAqIFBhdGggaXMgcGFyc2VkLCBubyBldmVudCB0cmlnZ2VyaW5nIGZvciBub3RSZWNvcmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IG9iamVjdCB0byBiZSB1c2VkIGFzIGdldHRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBhdHRyUGF0aCBwYXRoIHRvIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gc3VwcG9ydGluZyBkYXRhXG4gICAgICogQHBhcmFtIHtoZWxwZXJzfSBvYmplY3QgIHN1cHBvcnRpbmcgaGVscGVyc1xuICAgICAqL1xuXG4gICAgc3RhdGljIGdldFZhbHVlQnlQYXRoKG9iamVjdCwgYXR0clBhdGgsIGl0ZW0sIGhlbHBlcnMpIHtcbiAgICAgICAgYXR0clBhdGggPSB0aGlzLm5vcm1pbGl6ZVBhdGgoYXR0clBhdGgpO1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSBhdHRyUGF0aC5zaGlmdCgpLFxuICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGF0dHJOYW1lLmluZGV4T2YoRlVOQ1RJT05fTUFSS0VSKSA+IC0xO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyTmFtZS5yZXBsYWNlKEZVTkNUSU9OX01BUktFUiwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHR5cGVvZiBvYmplY3QgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iamVjdCA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iamVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqZWN0W2F0dHJOYW1lXSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgb2JqZWN0W2F0dHJOYW1lXSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGxldCBuZXdPYmogPSBpc0Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgPyBvYmplY3RbYXR0ck5hbWVdKHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgIGhlbHBlcnMsXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogb2JqZWN0W2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVCeVBhdGgobmV3T2JqLCBhdHRyUGF0aCwgaXRlbSwgaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIHRocm91Z2ggdGhpcmQgb2JqZWN0XG4gICAgICogUGF0aCBpcyBwYXJzZWQsIG5vIGV2ZW50IHRyaWdnZXJpbmcgZm9yIG5vdFJlY29yZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3Qgb2JqZWN0IHRvIGJlIG1vZGlmaWVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IGF0dHJQYXRoIHBhdGggdG8gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2FueX0gYXR0clZhbHVlICB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cblxuICAgIHN0YXRpYyBzZXRWYWx1ZUJ5UGF0aChvYmplY3QsIGF0dHJQYXRoLCBhdHRyVmFsdWUpIHtcbiAgICAgICAgYXR0clBhdGggPSB0aGlzLm5vcm1pbGl6ZVBhdGgoYXR0clBhdGgpO1xuICAgICAgICBsZXQgYXR0ck5hbWUgPSBhdHRyUGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAoYXR0clBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbYXR0ck5hbWVdID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlQnlQYXRoKG9iamVjdFthdHRyTmFtZV0sIGF0dHJQYXRoLCBhdHRyVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0W2F0dHJOYW1lXSA9IGF0dHJWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEpvaW5zIHBhc3NlZCBpbiBzdHJpbmdzIHdpdGggUEFUSF9TUExJVFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmd1bWVudHMgcGF0aCB0byBiZSBnbHVlZFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gY29tcG9zaXRlIHBhdGhcbiAgICAgKi9cblxuICAgIHN0YXRpYyBqb2luKCkge1xuICAgICAgICBsZXQgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBhcmdzLmpvaW4oUEFUSF9TUExJVCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdFBhdGg7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL2luZGV4LmpzJyk7XG4iLCIvLyBAdHMtaWdub3JlXG5pbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcblxuLypcbmh0dHBzOi8vZ2l0aHViLmNvbS9UZWhTaHJpa2UvaXMtbWVyZ2VhYmxlLW9iamVjdFxuXG5JbmNsdWRlZCBmb3IgY29udmluaWVuY2Ugb25seS4gQWxsIHJpZ2h0cyBiZWxvbmdzIHRvIHRoZWlyIGF1dGhvcnMgYW5kIGV0Yy5cbnN0YXJ0IG9mIG15IGNvZGUgbWFya2VkLlxuXG4qL1xuXG5sZXQgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpICYmICFpc1NwZWNpYWwodmFsdWUpO1xufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcbiAgICB2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgc3RyaW5nVmFsdWUgPT09IFwiW29iamVjdCBSZWdFeHBdXCIgfHxcbiAgICAgICAgc3RyaW5nVmFsdWUgPT09IFwiW29iamVjdCBEYXRlXVwiIHx8XG4gICAgICAgIGlzUmVhY3RFbGVtZW50KHZhbHVlKVxuICAgICk7XG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG4vKlxuaHR0cHM6Ly9naXRodWIuY29tL0t5bGVBTWF0aGV3cy9kZWVwbWVyZ2VcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxMiBOaWNob2xhcyBGaXNoZXJcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge307XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICBjb25zdCBjbG9uZSA9ICFvcHRpb25zQXJndW1lbnQgfHwgb3B0aW9uc0FyZ3VtZW50LmNsb25lICE9PSBmYWxzZTtcblxuICAgIHJldHVybiBjbG9uZSAmJiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSlcbiAgICAgICAgPyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9uc0FyZ3VtZW50KVxuICAgICAgICA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgcmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHt9O1xuICAgIGlmIChpc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc0FyZ3VtZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkgfHwgIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoXG4gICAgICAgICAgICAgICAgc291cmNlW2tleV0sXG4gICAgICAgICAgICAgICAgb3B0aW9uc0FyZ3VtZW50XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGRlZXBtZXJnZShcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSxcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgICAgICBvcHRpb25zQXJndW1lbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG4gICAgY29uc3Qgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcbiAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zQXJndW1lbnQgfHwge1xuICAgICAgICBhcnJheU1lcmdlOiBkZWZhdWx0QXJyYXlNZXJnZSxcbiAgICB9O1xuICAgIGNvbnN0IHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG4gICAgaWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG4gICAgICAgIHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG4gICAgICAgIGNvbnN0IGFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG4gICAgICAgIHJldHVybiBhcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KTtcbiAgICB9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnNBcmd1bWVudCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zQXJndW1lbnQpO1xuICAgIH0sIHt9KTtcbn07XG5cbi8qKlxuICogIENvbGxlY3Rpb24gb2YgY29tbW9uIGZ1bmN0aW9uc1xuICogIEBjbGFzc1xuICovXG5jbGFzcyBub3RDb21tb24ge1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtPYmplY3R9IFtNQU5BR0VSPW51bGxdICBhcHBsaWNhdGlvbiBtYW5hZ2VyLCBpbiBzb21lIGNhc2VzIHVzZWQgdG8gY29udHJvbCBpbml0aWFsaXphdGlvbiByb3V0aW5lXG4gICAgICovXG4gICAgc3RhdGljIE1BTkFHRVIgPSBudWxsO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtzdHJpbmd9IFtMT0c9XCJjb25zb2xlXCJdICBsb2dnZXIsIHdpbmRvd1tMT0ddXG4gICAgICovXG4gICAgc3RhdGljIExPRyA9IFwiY29uc29sZVwiO1xuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtmdW5jdGlvbn0gZGVlcE1lcmdlICBmdW5jdGlvbiB0byBwZXJmb3JtIGRlZXAgbWVyZ2VzIG9mIG9iamVjdHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVlcE1lcmdlID0gZGVlcG1lcmdlO1xuXG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge2Z1bmN0aW9ufSBpc0Vycm9yICBmdW5jdGlvbiB0byBwZXJmb3JtIG9iamVjdCB0ZXN0LCBpZiBpdCdzIGFuIGVycm9yIG9iamVjdCBvciBub3RcbiAgICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgICBlICAgb2JqZWN0IHRvIHRlc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFcnJvcihlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChPYmplY3QuaGFzT3duKGUsIFwic3RhdHVzXCIpICYmIGUuc3RhdHVzID09PSBcImVycm9yXCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc3RhdGljIFRaX09GRlNFVCA9IChuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MCkgKiAtMTtcbiAgICBzdGF0aWMgREVWX0VOViA9IFwicHJvZHVjdGlvblwiO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzdGF0aWMgRU5WX1RZUEUgPSB3aW5kb3cuTk9UX0VOVl9UWVBFID8/IG5vdENvbW1vbi5ERVZfRU5WO1xuICAgIHN0YXRpYyBOT09QID0gKCkgPT4ge307XG5cbiAgICBzdGF0aWMgbXV0ZSgpIHtcbiAgICAgICAgbm90Q29tbW9uLkVOVl9UWVBFID0gXCJwcm9kdWN0aW9uXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhZChuKSB7XG4gICAgICAgIHJldHVybiBuIDwgMTAgPyBcIjBcIiArIG4gOiBuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0b2RheSBEYXRlIG9iamVjdCB3aXRob3V0IGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzXG4gICAgICogIEByZXR1cm4ge251bWJlcn0gIGN1cnJlbnQgZGF0ZSB3aXRoIDAwOjAwOjAwIGluIG1zIG9mIHVuaXggdGltZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUb2RheURhdGUoKSB7XG4gICAgICAgIGxldCB0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwgdC5nZXRNb250aCgpLCB0LmdldERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBmaWVsZCBvZiBuYW1lXG4gICAgICogICBAcGFyYW0gICB7b2JqZWN0fSAgICBvYmogICAgc29tZSBvYmplY3RcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgICBuYW1lICBmaWVsZCBuYW1lXG4gICAgICogIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgIGlmIG9iamVjdCBjb250YWlucyBmaWVsZCB3aXRoIG5hbWVcbiAgICAgKiovXG4gICAgc3RhdGljIG9iakhhcyhvYmosIG5hbWUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bihvYmosIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvYmplY3QgdG8gc2VjdXJlIGl0IGZyb20gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iaiAgICAgb3JpZ2luYWwgb2JqZWN0XG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBjb3B5IG9mIG9iamVjdFxuICAgICAqKi9cbiAgICBzdGF0aWMgY29weU9iaihvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG9iamVjdCB0byBzZWN1cmUgaXQgZnJvbSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgb2JqICAgICBvcmlnaW5hbCBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIGNvcHkgb2Ygb2JqZWN0XG4gICAgICoqL1xuICAgIHN0YXRpYyBwYXJ0Q29weU9iaihvYmosIGxpc3QpIHtcbiAgICAgICAgbGV0IHBhcnRPYmogPSBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoY3VycikpIHtcbiAgICAgICAgICAgICAgICBwcmV2W2N1cnJdID0gb2JqW2N1cnJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFydE9iaikpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21wYXJlVHdvQXJyYXlzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgICAgICAgICAgYS5ldmVyeSgoZWxlbWVudCwgaW5kZXgpID0+IGVsZW1lbnQgPT09IGJbaW5kZXhdKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgYXJndW1lbnQgdHlwZSB0byBiZSAnZnVuY3Rpb24nXG4gICAgICogQHBhcmFtIHthbnl9ICBmdW5jICAgIHBvc3NpYmxlIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgIGlmIHRoaXMgaXMgYSBmdW5jdGlvblxuICAgICAqKi9cbiAgICBzdGF0aWMgaXNGdW5jKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFyZ3VtZW50IGlzIEFzeW5jIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgIGlmIHRoaXMgZnVuY3Rpb24gaXMgY29uc3RydWN0ZWQgYXMgQXN5bmNGdW5jdGlvblxuICAgICAqKi9cbiAgICBzdGF0aWMgaXNBc3luYyhmdW5jKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQXN5bmNGdW5jdGlvblwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBFeGVjdXRlcyBtZXRob2Qgb2Ygb2JqZWN0IGluIGFwcHJvcHJpYXRlIHdheSBpbnNpZGUgUHJvbWlzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iaiAgICAgb3JpZ2luYWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgbmFtZSAgICBtZXRob2QgbmFtZSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gICAgIHBhcmFtcyAgYXJyYXkgb2YgcGFyYW1zXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgcmVzdWx0cyBvZiBtZXRob2QgZXhlY3V0aW9uXG4gICAgICoqL1xuICAgIHN0YXRpYyBhc3luYyBleGVjdXRlT2JqZWN0RnVuY3Rpb24ob2JqLCBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcHJvYyA9IG5vdFBhdGguZ2V0KFwiOlwiICsgbmFtZSwgb2JqKTtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKHByb2MpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0FzeW5jKHByb2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jKC4uLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2MoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgRXhlY3V0ZXMgbWV0aG9kIG9mIG9iamVjdCBpbiBhcHJvcHJpYXRlIHdheSBpbnNpZGUgUHJvbWlzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIGZyb20gICAgIG9yaWdpbmFsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIHRvICAgIG1ldGhvZCBuYW1lIHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgICAgbGlzdCAgYXJyYXkgb2YgcGFyYW1zXG4gICAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICByZXN1bHRzIG9mIG1ldGhvZCBleGVjdXRpb25cbiAgICAgKiovXG4gICAgc3RhdGljIG1hcEJpbmQoZnJvbSwgdG8sIGxpc3QpIHtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb21baXRlbV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRvW2l0ZW1dID0gZnJvbVtpdGVtXS5iaW5kKGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNDbGFzcyhmbikge1xuICAgICAgICByZXR1cm4gL15cXHMqY2xhc3MvLnRlc3QoZm4udG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGRldGVjdFR5cGUodGVzdGllKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVzdGllICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGVzdGllO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0NsYXNzKHRlc3RpZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjbGFzc1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy/Qn9GA0L7QstC10YDQutCwINGP0LLQu9GP0LXRgtGB0Y8g0LvQuCDQv9C10YDQtdC80LXQvdC90LDRjyDQvNCw0YHRgdC40LLQvtC8XG4gICAgc3RhdGljIGlzQXJyYXkoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIiAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvY2FsSXNvRGF0ZShkYXRlKSB7XG4gICAgICAgIGRhdGUgPSBkYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBsb2NhbElzb1N0cmluZyA9XG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldE1vbnRoKCkgKyAxKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0RGF0ZSgpKSArXG4gICAgICAgICAgICBcIlRcIiArXG4gICAgICAgICAgICBub3RDb21tb24ucGFkKGRhdGUuZ2V0SG91cnMoKSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldE1pbnV0ZXMoKSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZChkYXRlLmdldFNlY29uZHMoKSk7XG4gICAgICAgIHJldHVybiBsb2NhbElzb1N0cmluZztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VG9kYXkoKSB7XG4gICAgICAgIGxldCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBkYXRlID1cbiAgICAgICAgICAgIHRvZGF5LmdldEZ1bGxZZWFyKCkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZCh0b2RheS5nZXRNb250aCgpICsgMSkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgbm90Q29tbW9uLnBhZCh0b2RheS5nZXREYXRlKCkpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYmFja2xvZyA9IFtdO1xuXG4gICAgc3RhdGljIGJhY2tsb2dBZGQobXNnLCB0eXBlID0gXCJsb2dcIikge1xuICAgICAgICBpZiAobm90Q29tbW9uLmdldChcImJhY2tsb2dcIikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nLnB1c2goeyBtc2csIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZHVtcEJhY2tsb2coKSB7XG4gICAgICAgIHdoaWxlIChub3RDb21tb24uYmFja2xvZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByb3cgPSBub3RDb21tb24uYmFja2xvZy5zaGlmdCgpO1xuICAgICAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddW3Jvdy50eXBlXSguLi5yb3cubXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBsb2dNc2coKSB7XG4gICAgICAgIGxldCBub3cgPSBub3RDb21tb24ubG9jYWxJc29EYXRlKCk7XG5cbiAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddLmxvZyhgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFtgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50c10sIFwibG9nXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2coKSB7XG4gICAgICAgIG5vdENvbW1vbi5sb2dNc2coLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTG9nZ2VyKHByZWZpeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9nOiBub3RDb21tb24uZ2VuTG9nTXNnKHByZWZpeCksXG4gICAgICAgICAgICBlcnJvcjogbm90Q29tbW9uLmdlbkxvZ0Vycm9yKHByZWZpeCksXG4gICAgICAgICAgICBkZWJ1Zzogbm90Q29tbW9uLmdlbkxvZ0RlYnVnKHByZWZpeCksXG4gICAgICAgICAgICByZXBvcnQ6IG5vdENvbW1vbi5yZXBvcnQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy/Qk9C10L3QtdGA0LDRhtC40Y8g0LzQtdGC0L7QtNCwINCy0YvQstC+0LTQsCDRgdC+0L7QsdGJ0LXQvdC40Lkg0LIg0LrQvtC90YHQvtC70Ywg0YEg0YPQutCw0LfQsNC90LjQtdC8INC/0YDQtdGE0LjQutGB0LAuXG4gICAgc3RhdGljIGdlbkxvZ01zZyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vbm90IGFycm93IGJjIG9mIGFyZ3VtZW50cyBzcGVjaWFsIHZhciBpcyBub3QgYXZhaWxhYmxlIGluIGFycm93IGZ1bmN0aW9uc1xuICAgICAgICAgICAgbGV0IG5vdyA9IG5vdENvbW1vbi5sb2NhbElzb0RhdGUoKTtcblxuICAgICAgICAgICAgd2luZG93W25vdENvbW1vbi5MT0ddLmxvZyhgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFxuICAgICAgICAgICAgICAgIFtgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzXSxcbiAgICAgICAgICAgICAgICBcImxvZ1wiXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqINCe0L/RgNC10LTQtdC70Y/QtdGCINGP0LLQu9GP0LXRgtGB0Y8g0LvQuCDQvtC60YDRg9C20LXQvdC40LUg0L7QutGA0YPQttC10L3QuNC10Lwg0YDQsNC30YDQsNCx0L7RgtC60LhcbiAgICAgKiBAcmV0dXJucyAge2Jvb2xlYW59IHRydWUg0LXRgdC70Lgg0Y3RgtC+INC30LDQv9GD0YnQtdC90L4g0LIg0L7QutGA0YPQttC10L3QuNC4INGA0LDQt9GA0LDQsdC+0YLQutC4XG4gICAgICoqL1xuICAgIHN0YXRpYyBpc0RldigpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5FTlZfVFlQRSA9PT0gbm90Q29tbW9uLkRFVl9FTlY7XG4gICAgfVxuXG4gICAgc3RhdGljIGRlYnVnKCkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRGV2KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24ubG9nTXNnKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Q29tbW9uLk5PT1A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2VuTG9nRGVidWcocHJlZml4KSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNEZXYoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZW5Mb2dNc2cocHJlZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub3RDb21tb24uTk9PUDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBlcnJvcigpIHtcbiAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy/QpNGD0L3QutGG0LjRjyDQstGL0LLQvtC00LAg0YHQvtC+0LHRidC10L3QuNGPINC+0LEg0L7RiNC40LHQutC1XG4gICAgc3RhdGljIGxvZ0Vycm9yKCkge1xuICAgICAgICBsZXQgbm93ID0gbm90Q29tbW9uLmxvY2FsSXNvRGF0ZSgpO1xuXG4gICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5lcnJvcihgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFtgWyR7bm93fV06IGAsIC4uLmFyZ3VtZW50c10sIFwiZXJyb3JcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGdlbkxvZ0Vycm9yKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9kbyBub3QgY2hhbmdlIHRvIGFycm93IGZ1bmN0aW9uLCBiYyBvZiBhcmd1bWVudHNcbiAgICAgICAgICAgIGxldCBub3cgPSBub3RDb21tb24ubG9jYWxJc29EYXRlKCk7XG5cbiAgICAgICAgICAgIHdpbmRvd1tub3RDb21tb24uTE9HXS5lcnJvcihgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIG5vdENvbW1vbi5iYWNrbG9nQWRkKFxuICAgICAgICAgICAgICAgIFtgWyR7bm93fV06ICR7cHJlZml4fTo6YCwgLi4uYXJndW1lbnRzXSxcbiAgICAgICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhdGljIHJlcG9ydChlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uZ2V0QXBwKCkpIHtcbiAgICAgICAgICAgIGxldCByZXBvcnRlciA9IG5vdENvbW1vbi5nZXRBcHAoKS5nZXRTZXJ2aWNlKFwibnNFcnJvclJlcG9ydGVyXCIpO1xuICAgICAgICAgICAgaWYgKHJlcG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZXIucmVwb3J0KGUpLmNhdGNoKG5vdENvbW1vbi5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5vdENvbW1vbi5nZXQoXCJwcm9kdWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmVycm9yKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdHJhY2UoKSB7XG4gICAgICAgIGlmICghbm90Q29tbW9uLmdldChcInByb2R1Y3Rpb25cIikpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi50cmFjZSguLi5hcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHRyaW1CYWNrc2xhc2goc3RyKSB7XG4gICAgICAgIGlmIChzdHIuaW5kZXhPZihcIi9cIikgPT09IDApIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBCdWlsZHMgVVJMIHdpdGggc3RydWN0dXJlIGxpa2UgcHJlZml4L21vZHVsZS9tb2RlbC9pZC9hY3Rpb25cbiAgICAgKiBJZiBzb21lIHBhcnQgYWJzZW50IG9yIHNldCB0byBmYWxzZSBpdCB3aWxsIGJlIGV4Y2x1ZGVkIGZyb20gcmVzdWx0XG4gICAgICogIEBwYXJhbSB7b2JqZWN0fSB1cmxQYXJ0c1xuICAgICAqICBAcGFyYW0ge3N0cmluZ30gW3VybFBhcnRzLnByZWZpeD0nJ11cbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFt1cmxQYXJ0cy5tb2R1bGU9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMubW9kZWw9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMuaWQ9JyddXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSBbdXJsUGFydHMuYWN0aW9uPScnXVxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9ICB1cmwgcGF0aFxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFVSTChcbiAgICAgICAgeyBwcmVmaXgsIG1vZHVsZSwgbW9kZWwsIGlkLCBhY3Rpb24gfSA9IHtcbiAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgIG1vZHVsZTogXCJcIixcbiAgICAgICAgICAgIG1vZGVsOiBcIlwiLFxuICAgICAgICAgICAgaWQ6IFwiXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiXCIsXG4gICAgICAgIH1cbiAgICApIHtcbiAgICAgICAgbGV0IHVybCA9IFtcIi9cIl07XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChwcmVmaXgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgICAgdXJsLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5vdENvbW1vbi50cmltQmFja3NsYXNoKG1vZHVsZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChtb2RlbCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHVybC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChub3RDb21tb24udHJpbUJhY2tzbGFzaChpZCkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB1cmwucHVzaChlbmNvZGVVUklDb21wb25lbnQobm90Q29tbW9uLnRyaW1CYWNrc2xhc2goYWN0aW9uKSkpO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHVybC5maWx0ZXIoKGVsKSA9PiBlbCAhPT0gXCJcIik7XG4gICAgICAgIHJldHVybiB1cmwuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvL2csIFwiL1wiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb3dlckZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdHJMZW5ndGhDYXAoc3RyLCBNQVhfVElUTEVfTEVOR1RIID0gNTAsIFBPU1RfRklYID0gXCIuLi5cIikge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiBzdHIubGVuZ3RoID4gTUFYX1RJVExFX0xFTkdUSCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgTUFYX1RJVExFX0xFTkdUSCkgKyBQT1NUX0ZJWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZXNjYXBlSHRtbCh1bnNhZmUpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIHN0YXJ0QXBwKHN0YXJ0ZXIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgc3RhcnRlcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEFwcCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXQoXCJhcHBcIik7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4dGVuZEFwcENvbmZpZyhjb25mLCBjb25mMikge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmRlZXBNZXJnZShjb25mLCBjb25mMik7XG4gICAgfVxuXG4gICAgc3RhdGljIGFic29yYk1vZHVsZSgpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRDb25mLCAvL2FwcCBvcHRpb25zXG4gICAgICAgICAgICBtb2QsIC8vbW9kdWxlIG9wdGlvbnNcbiAgICAgICAgICAgIHRhcmdldHMgPSB7fTsgLy92YXJpb3VzIGNvbGxlY3Rpb25zXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHRhcmdldHMgPSB7IC4uLmFyZ3VtZW50c1swXSB9O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1swXSwgXCJkZWZhdWx0Q29uZlwiKSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mID0gYXJndW1lbnRzWzBdLmRlZmF1bHRDb25mO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRzLmRlZmF1bHRDb25mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1swXSwgXCJtb2RcIikpIHtcbiAgICAgICAgICAgICAgICBtb2QgPSBhcmd1bWVudHNbMF0ubW9kO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRzLm1vZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5sb2coXG4gICAgICAgICAgICAgICAgXCJXQVJOSU5HOiBhYnNvcmJNb2R1bGUgZm9ybWF0IG9ic29sZXRlZCwgdXNlIG9iamVjdCB7ZGVmYXVsdENvbmYsIG1vZCwgc2VydmljZXMsIHVpcywgd3NjLCBldGN9XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkZWZhdWx0Q29uZiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIG1vZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRhcmdldHMuc2VydmljZXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRzLnVpcyA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMud2NzID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbW9kKSB7XG4gICAgICAgICAgICAvL2FkZCBtYW5pZmVzdCB0byBvdGhlclxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibWFuaWZlc3RcIikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mID0gbm90Q29tbW9uLmV4dGVuZEFwcENvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdENvbmYsXG4gICAgICAgICAgICAgICAgICAgIG1vZC5tYW5pZmVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vdENvbW1vbi5nZXQoYGFic29yYi4ke3Byb3B9YCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24odGFyZ2V0cywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0c1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFdBUk5JTkc6IG5vIGFjY2FtdWxhdG9yIG9iamVjdCBwcm92aWRlZCBmb3IgJyR7cHJvcH0nIGNvbGxlY3Rpb25gXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5nZXQoYGFic29yYi4ke3Byb3B9YCkodGFyZ2V0c1twcm9wXSwgbW9kW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcC5pbmRleE9mKFwibmNcIikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGRlZmF1bHRDb25mLCBcImNvbnRyb2xsZXJzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mLmNvbnRyb2xsZXJzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHRDb25mLmNvbnRyb2xsZXJzW3Byb3BdID0gbW9kW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2luIGNhc2Ugb2Ygc29tZSBvdGhlciBzdHVmZiBwcmVzZW50ZWQsIGlzb2xhdGluZyBpdCBpbiBzcGVjaWFsIHZhclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24od2luZG93LCBcIm5vdEVudlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5ub3RFbnYgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5ub3RFbnZbcHJvcF0gPSBtb2RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25mO1xuICAgIH1cblxuICAgIHN0YXRpYyBkZWZpbmVJZk5vdEV4aXN0cyhvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVnaXN0cnkgPSB7fTtcblxuICAgIHN0YXRpYyByZWdpc3RlcihrZXksIHZhbCkge1xuICAgICAgICBub3RDb21tb24ucmVnaXN0cnlba2V5XSA9IHZhbDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0KGtleSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3QuaGFzT3duKG5vdENvbW1vbi5yZWdpc3RyeSwga2V5KVxuICAgICAgICAgICAgPyBub3RDb21tb24ucmVnaXN0cnlba2V5XVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGl0ZW0gaW5zaWRlIGFycmF5IGZyb20gb2xkX2luZGV4IHRvIG5ld19pbmRleFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9sZF9pbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdfaW5kZXhcbiAgICAgKiBAbWVtYmVyb2Ygbm90Q29tbW9uXG4gICAgICovXG4gICAgc3RhdGljIG1vdmVJdGVtKGFycmF5LCBvbGRfaW5kZXgsIG5ld19pbmRleCkge1xuICAgICAgICBjb25zdCBpblJhbmdlID0gKG51bSkgPT4gbnVtIDwgYXJyYXkubGVuZ3RoICYmIG51bSA+IC0xO1xuICAgICAgICBpZiAoaW5SYW5nZShuZXdfaW5kZXgpICYmIGluUmFuZ2Uob2xkX2luZGV4KSkge1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKG5ld19pbmRleCwgMCwgYXJyYXkuc3BsaWNlKG9sZF9pbmRleCwgMSlbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHN0cmlwUHJveHkob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG9iai5pc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBBcnJheS5mcm9tKG9iaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihvYmosIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpbdF0gPSBub3RDb21tb24uc3RyaXBQcm94eShvYmpbdF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RhdGljIHBpcGUoZGF0YSAvKiBmZWVkIGRhdGEgKi8sIGZ1bmNzIC8qIGZ1bmN0aW9ucyBhcnJheSAqLykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBmb3IgKGxldCBmdW5jIG9mIGZ1bmNzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKHJlc3VsdCB8fCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBUEkodHlwZSkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLmdldE1hbmFnZXIoKT8uZ2V0QVBJKHR5cGUpID8/IG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldE1hbmFnZXIodikge1xuICAgICAgICBub3RDb21tb24uTUFOQUdFUiA9IHY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbW1vblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gbm90Q29tbW9uLk1BTkFHRVI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyB3YWl0KHNlYykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dChyZXMsIHNlYyAqIDEwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVnaXN0ZXJXaWRnZXRFdmVudHMoZXZlbnRzKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uZ2V0QXBwKCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmdldEFwcCgpLm9uKGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbmF2aWdhdGUodXJsKSB7XG4gICAgICAgIG5vdENvbW1vbi5nZXRBcHAoKSAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLmdldEFwcCgpLmdldFdvcmtpbmcoXCJyb3V0ZXJcIikubmF2aWdhdGUodXJsKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0KHZhcmlhbnRzU2V0LCB2YWx1ZSwgZGVmKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHZhcmlhbnRzU2V0ICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFyaWFudHNTZXQgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyh2YXJpYW50c1NldCwgdmFsdWUpICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFyaWFudHNTZXRbdmFsdWVdICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB2YXJpYW50c1NldFt2YWx1ZV0gIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudHNTZXRbdmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWJzb3JiU2VydmljZXModGFyZ2V0LCBzcmMpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IHNlcnYgaW4gc3JjKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0YXJnZXQsIHNlcnYpKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKGBzZXJ2aWNlcyBwcm9wZXJ0eSBkdXBsaWNhdGlvbiAke3NlcnZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbc2Vydl0gPSBzcmNbc2Vydl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZFdTQ2xpZW50KHdjcywgd3NjTmFtZSwgd3NjT3B0aW9ucykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoIU9iamVjdC5oYXNPd24od2NzLCB3c2NOYW1lKSkge1xuICAgICAgICB3Y3Nbd3NjTmFtZV0gPSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uOiB7fSxcbiAgICAgICAgICAgIHJvdXRlcjoge1xuICAgICAgICAgICAgICAgIHJvdXRlczoge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2VuZ2VyOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHRhcmdldCA9IHdjc1t3c2NOYW1lXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKE9iamVjdC5oYXNPd24od3NjT3B0aW9ucywgXCJyb3V0ZXJcIikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLnJvdXRlciwgXCJyb3V0ZXNcIikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdXRlVHlwZSBpbiB3c2NPcHRpb25zLnJvdXRlci5yb3V0ZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHRhcmdldC5yb3V0ZXIucm91dGVzLCByb3V0ZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yb3V0ZXIucm91dGVzW3JvdXRlVHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQucm91dGVyLnJvdXRlc1tyb3V0ZVR5cGVdLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLndzY09wdGlvbnMucm91dGVyLnJvdXRlc1tyb3V0ZVR5cGVdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLCBcIm1lc3NlbmdlclwiKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldC5tZXNzZW5nZXIsIHsgLi4ud3NjT3B0aW9ucy5tZXNzZW5nZXIgfSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoT2JqZWN0Lmhhc093bih3c2NPcHRpb25zLCBcImNvbm5lY3Rpb25cIikpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQuY29ubmVjdGlvbiwgeyAuLi53c2NPcHRpb25zLmNvbm5lY3Rpb24gfSk7XG4gICAgfVxuICAgIGZvciAobGV0IHQgb2YgW1wibmFtZVwiLCBcImdldFRva2VuXCIsIFwibG9nZ2VyXCIsIFwiaWRlbnRpdHlcIiwgXCJjcmVkZW50aWFsc1wiXSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHdzY09wdGlvbnMsIHQpKSB7XG4gICAgICAgICAgICB0YXJnZXRbdF0gPSB3c2NPcHRpb25zW3RdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhYnNvcmJXU0ModGFyZ2V0LCBzcmMpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IHdzQ2xpZW50TmFtZSBpbiBzcmMpIHtcbiAgICAgICAgICAgIGV4dGVuZFdTQ2xpZW50KHRhcmdldCwgd3NDbGllbnROYW1lLCBzcmNbd3NDbGllbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFic29yYlVJcyh0YXJnZXQsIHNyYykge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgdWkgaW4gc3JjKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0YXJnZXQsIHVpKSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5sb2dFcnJvcihgdWlzIHByb3BlcnR5IGR1cGxpY2F0aW9uICR7dWl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbdWldID0gc3JjW3VpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWJzb3JiRmllbGRzKHRhcmdldCwgc3JjKSB7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCB1aSBpbiBzcmMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRhcmdldCwgdWkpKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmxvZ0Vycm9yKGBmaWVsZHMgcHJvcGVydHkgZHVwbGljYXRpb24gJHt1aX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFt1aV0gPSBzcmNbdWldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ub3RDb21tb24ucmVnaXN0ZXIoXCJhYnNvcmIud3NjXCIsIGFic29yYldTQyk7XG5ub3RDb21tb24ucmVnaXN0ZXIoXCJhYnNvcmIuc2VydmljZXNcIiwgYWJzb3JiU2VydmljZXMpO1xubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLnVpc1wiLCBhYnNvcmJVSXMpO1xubm90Q29tbW9uLnJlZ2lzdGVyKFwiYWJzb3JiLnVpc1wiLCBhYnNvcmJGaWVsZHMpO1xuXG5leHBvcnQgZGVmYXVsdCBub3RDb21tb247XG4iLCIvKipcbiAqIFB1cnBvc2Ugb2YgdGhpcyBMb2NhbGUgb2JqZWN0IGlzIHRoYXQgaXQgd2lsbCBob2xkIGxpYnJhcnkgb2YgbG9jYWxpemF0aW9uXG4gKiB0ZW1wbGF0ZXMgYW5kIHByb3ZpZGUgYmFzaWMgbG9jYWxpemF0aW9uIHNlcnZpY2UgdG8gb3RoZXIgbW9kdWxlc1xuICoqL1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJ3b2xmeTg3LWV2ZW50ZW1pdHRlclwiO1xuXG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9mcmFtZS9jb21tb24uanNcIjtcbmltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG5pbXBvcnQgTE9DQUxFIGZyb20gXCIuL3N0b3JlXCI7XG5cbi8qKlxuICogc3RyaW5ncyBsb2NhbGl6YXRpb24gYW5kIGZvcm1hdGluZyBtb2RlbFxuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdExvY2FsZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGljdCA9IHt9OyAvL2RpY3Rpb25hcnkgb2YgcGhyYXNlc1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSB7fTsgLy9hZGRpdGlvbmFsIGhlbHBlciBmdW5jdGlvbnMgYW5kIGNvbnN0YW50c1xuICAgICAgICBsZXQgZGljdCA9IHRoaXMucmVzdG9yZUZyb21TdG9yYWdlKCk7XG4gICAgICAgIGlmIChkaWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldChkaWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmluZyBmb3JtYXQgc2hvdWxkIGNvbXBseSBub3RQYXRoIHN0YW5kYXJ0LlxuICAgICAqIHtwYXRoX3RvX2FjY2Vzc30gLSBpc1xuICAgICAqIDogLSBpcyB1c2VkIHRvIGFjY2VzcyB0byBwYXJhbXNcbiAgICAgKiA6OiAtIGlzIHVzZWQgdG8gYWNjZXNzIHRvIGhlbHBlcnNcbiAgICAgKiBXZWxjb21lLCB7OndoZXJlfSEgLSB3aWxsIHJlcGxhY2Ugezp3aGVyZX0gd2l0aCBjb250ZW50IG9mIHBhcmFtcy53aGVyZVxuICAgICAqIFdlbGNvbWUsIHs6OndoZXJlfSEgLSB3aWxsIHJlcGxhY2Ugezp3aGVyZX0gd2l0aCBjb250ZW50IG9mIHRoaXMuaGVscGVycy53aGVyZVxuICAgICAqICgpIC0gYWZ0ZXIgcGF0aCBpcyB0byBpbnZva2UgZnVuY3Rpb24gb2YgdGFyZ2V0IG9iamVjdFxuICAgICAqIFdlbGNvbWUsIHs6OndoZXJlKCl9ISAtIHdpbGwgdHJ5IHRvIGV4ZWMgdGhpcy5oZWxwZXJzLndoZXJlKHBhcmFtcywgdW5kZWZpbmVkKVxuICAgICAqIEBwYXJhbSAgICB7c3RyaW5nfSAgc3RyICAgICAgICAgbG9jYWxpemVkIHN0cmluZyB0ZW1wbGF0ZSB3aXRoIG1hcmsgdG8gaW5jbHVkZSBkYXRhXG4gICAgICogQHBhcmFtICAgIHtvYmplY3R9ICBwYXJhbXMgICAgICBwYXJhbXMgdG8gdXNlIGluIHN0cmluZ1xuICAgICAqIEByZXR1cm5zICB7c3RyaW5nfSAgICAgICAgICAgICAgbG9jYWxpemVkIHZlcnNpb24gb2Ygc3RyaW5nIHdpdGhcbiAgICAgKi9cbiAgICBmb3JtYXQoc3RyLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5vdFBhdGgucGFyc2VTdWJzKHN0ciwgcGFyYW1zLCB0aGlzLmhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBsb2NhbGl6ZWQgdmVyc2lvbiBvZiBzdHJpbmcgd2l0aCBpbmplY3RlZCBkYXRhIGZyb20gcHJvdmlkZWQgb2JqZWN0XG4gICAgICogbWF5IGFsc28gdXNlIExvY2FsZS5oZWxwZXJzIGFzIHNvdXJjZSBvZiBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgcGhyYXNlICAgIG5hbWUgb2Ygc3RyaW5nIHRvIGxvY2FsaXplXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgcGFyYW1zICAgIG9iamVjdCB3aXRoIGRhdGEgdG8gaW5qZWN0IGluIHBocmFzZSB0ZW1wbGF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBsb2NhbGl6ZWQgc3RyaW5nIHdpdGggaW5qZWN0ZWQgZGF0YVxuICAgICAqL1xuICAgIHNheShwaHJhc2UsIHBhcmFtcyA9IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLmRpY3QsIHBocmFzZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wbCA9IHRoaXMuZGljdFtwaHJhc2VdLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXQodG1wbCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0bXBsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9jYWxlIHBocmFzZTogJHtwaHJhc2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5kZWJ1ZyhlKTtcbiAgICAgICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIG5ldyBkaWN0aW9uYXJ5LiB0cmlnZ2VycyBldmVudCAnY2hhbmdlJ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgZGljdCAgICAgIHZvY2FidWxhcnkgb2YgcGhyYXNlcyBhbmQgdGVtcGxhdGVzXG4gICAgICoqL1xuICAgIHNldChkaWN0KSB7XG4gICAgICAgIExPQ0FMRS5zZXQoZGljdCk7XG4gICAgICAgIHRoaXMuc2F2ZVRvU3RvcmFnZShkaWN0KTtcbiAgICAgICAgdGhpcy5kaWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgeyAuLi5kaWN0IH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gICAgfVxuXG4gICAgc2F2ZVRvU3RvcmFnZShkaWN0KSB7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIFwiZGljdGlvbmFyeVwiLFxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkaWN0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmRlYnVnKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdG9yZUZyb21TdG9yYWdlKCkge1xuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgc3RyID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiZGljdGlvbmFyeVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWN0ID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGljdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5kZWJ1ZyhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd3JpdGFibGUgc3RvcmUgb2YgcGhyYXNlc1xuICAgICAqIEByZXR1cm4ge29iamVjdH0gIHdyaXRhYmxlIHN0b3JlXG4gICAgICovXG4gICAgdm9jYWJ1bGFyeSgpIHtcbiAgICAgICAgcmV0dXJuIExPQ0FMRTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBub3RMb2NhbGUoKTtcbiIsImltcG9ydCBMT0NBTEUgZnJvbSBcIi4vc3RvcmUuanNcIjtcbmltcG9ydCBub3RMb2NhbGUgZnJvbSBcIi4vbm90TG9jYWxlLmpzXCI7XG5jb25zdCBzYXkgPSBub3RMb2NhbGUuc2F5LmJpbmQobm90TG9jYWxlKTtcblxuZXhwb3J0IHsgTE9DQUxFLCBzYXksIG5vdExvY2FsZSB9O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lkID0gXCJ0YWdJZFwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyB0YWcsIGFzIHRhZy17aWR9OntldmVudE5hbWV9LCBleC4gdGFnLXRhZ0lkOnVwZGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0aXRsZSA9IFwidGFnXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NvbG9yID0gXCJpbmZvXCJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWxtYSBjb2xvclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaXplID0gXCJub3JtYWxcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVsbWEgc2l6ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtwYWRkaW5nID0gXCJub3JtYWxcIl0gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSBvZiBsZWZ0L3JpZ2h0IHBhZGRpbmdzIChzbWFsbCA9IDAuNWVtLCBub3JtYWwgPSAxZW0sIGJpZyA9IDEuNWVtLCBsYXJnZSA9IDJlbSksIGNsYXNzIG5hbWVzIGlzIGlzLXBhZGRlZC17cGFkZGluZ31cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbYm9sZCA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSBzdHlsaW5nXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JpZ2h0ID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSByaWdodCwgdG8gc2VlIGF0IHdvcmsgbG9vayBleGFtcGxlcyBvZiBFbGVtZW50cy5JY29ucy5VSUljb25CdXR0b25XaXRoVGFnXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xlZnQgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSBsZWZ0LCB0byBzZWUgYXQgd29yayBsb29rIGV4YW1wbGVzIG9mIEVsZW1lbnRzLkljb25zLlVJSWNvbkJ1dHRvbldpdGhUYWdcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbdG9wID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgcG9zaXRpb25pbmcgb24gdGhlIHRvcCwgdG8gc2VlIGF0IHdvcmsgbG9vayBleGFtcGxlcyBvZiBFbGVtZW50cy5JY29ucy5VSUljb25CdXR0b25XaXRoVGFnXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2JvdHRvbSA9IGZhbHNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHBvc2l0aW9uaW5nIG9uIHRoZSBib3R0b20sIHRvIHNlZSBhdCB3b3JrIGxvb2sgZXhhbXBsZXMgb2YgRWxlbWVudHMuSWNvbnMuVUlJY29uQnV0dG9uV2l0aFRhZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzcyAgPSBcIlwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbCBjc3MgY2xhc3NlcyBsaXN0XG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2V2ZW50cyA9IHt9XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCBvZiBldmVudHMge25hbWU6Y2FsbGJhY2t9XG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3JlZ2lzdGVyID0gbm90Q29tbW9uLnJlZ2lzdGVyV2lkZ2V0RXZlbnRzXSAgICAgcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25VcGRhdGUgPSAoZGF0YSkgPT4gdGl0bGUgPSBkYXRhLnRpdGxlO11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbYWN0aW9uXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrL29ua2V5ZG93biBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFt2YXJzID0ge31dICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcyB2YXJzIGxpc3RcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInRhZ0lkXCIsXG4gICAgICAgIHRpdGxlID0gXCJ0YWdcIixcbiAgICAgICAgY29sb3IgPSBcImluZm9cIixcbiAgICAgICAgc2l6ZSA9IFwibm9ybWFsXCIsXG4gICAgICAgIHBhZGRpbmcgPSBcIm5vcm1hbFwiLFxuICAgICAgICBib2xkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxlZnQgPSBmYWxzZSxcbiAgICAgICAgdG9wID0gZmFsc2UsXG4gICAgICAgIGJvdHRvbSA9IGZhbHNlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGV2ZW50cyA9IHt9LFxuICAgICAgICByZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50cy5iaW5kKG5vdENvbW1vbiksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwidGl0bGVcIikpIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgdmFycyA9IHt9LFxuICAgICAgICByb2xlID0gXCJidXR0b25cIixcbiAgICAgICAgdGFiSW5kZXggPSBcIjBcIixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgc2lkZWQgPSAkZGVyaXZlZChyaWdodCB8fCBsZWZ0IHx8IHRvcCB8fCBib3R0b20pO1xuXG4gICAgbGV0IGhDZW50ZXJlZCA9ICRkZXJpdmVkKCFyaWdodCAmJiAhbGVmdCAmJiBzaWRlZCk7XG4gICAgbGV0IHZDZW50ZXJlZCA9ICRkZXJpdmVkKCFib3R0b20gJiYgIXRvcCAmJiBzaWRlZCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGB0YWctJHtpZH06dXBkYXRlYDtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGV2ZW50cywgZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpXSA9IG9uVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyKGV2ZW50cyk7XG4gICAgfSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3R5bGUgPSBPYmplY3Qua2V5cygkc3RhdGUuc25hcHNob3QodmFycykpXG4gICAgICAgICAgICAubWFwKCh2YXJOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3Zhck5hbWV9OiAke3ZhcnNbdmFyTmFtZV19O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiB0aXRsZX1cbiAgICA8c3BhblxuICAgICAgICB7cm9sZX1cbiAgICAgICAge3RhYkluZGV4fVxuICAgICAgICBvbmtleWRvd249e2FjdGlvbiA/IGFjdGlvbiA6IHVuZGVmaW5lZH1cbiAgICAgICAgb25jbGljaz17YWN0aW9uID8gYWN0aW9uIDogdW5kZWZpbmVkfVxuICAgICAgICBpZD1cInRhZy17aWR9XCJcbiAgICAgICAgY2xhc3M9XCJcbiAgdGFnXG4gIHtwYWRkaW5nICE9PSAnbm9ybWFsJyA/IGBpcy1wYWRkZWQtJHtwYWRkaW5nfWAgOiAnJ31cbiAgaXMte3NpemV9XG4gIGlzLXtjb2xvcn0gIFxuICB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jbGlja2FibGU9e2FjdGlvbn1cbiAgICAgICAgY2xhc3M6aGFzLXRleHQtd2VpZ2h0LWJvbGQ9e2JvbGR9XG4gICAgICAgIGNsYXNzOmlzLXZlcnRpY2FsLWNlbnRlcmVkPXt2Q2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLWhvcml6b250YWwtY2VudGVyZWQ9e2hDZW50ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtc2lkZWQ9e3NpZGVkfVxuICAgICAgICBjbGFzczppcy1zaWRlZC1yaWdodD17cmlnaHR9XG4gICAgICAgIGNsYXNzOmlzLXNpZGVkLWxlZnQ9e2xlZnR9XG4gICAgICAgIGNsYXNzOmlzLXNpZGVkLXRvcD17dG9wfVxuICAgICAgICBjbGFzczppcy1zaWRlZC1ib3R0b209e2JvdHRvbX1cbiAgICAgICAge3N0eWxlfT57JExPQ0FMRVt0aXRsZV19PC9zcGFuXG4gICAgPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuL3VpLnRhZy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19UUlVFID0gXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtMQ19GQUxTRSA9IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZCA9IGZhbHNlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBMQ19UUlVFID0gXCJub3Qtbm9kZTpib29sZWFuc190cnVlXCIsXG4gICAgICAgIExDX0ZBTFNFID0gXCJub3Qtbm9kZTpib29sZWFuc19mYWxzZVwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBGQUxTRV9WQUxVRSA9IHtcbiAgICAgICAgdGl0bGU6IExDX0ZBTFNFLFxuICAgICAgICBjb2xvcjogaW52ZXJ0ZWQgPyBcInN1Y2Nlc3NcIiA6IFwiZGFuZ2VyXCIsXG4gICAgfTtcblxuICAgIGNvbnN0IFRSVUVfVkFMVUUgPSB7XG4gICAgICAgIHRpdGxlOiBMQ19UUlVFLFxuICAgICAgICBjb2xvcjogaW52ZXJ0ZWQgPyBcImRhbmdlclwiIDogXCJzdWNjZXNzXCIsXG4gICAgfTtcblxuICAgIC8vaWYgaW52ZXJ0ZWQgPT09IHRydWUsIGludmVydHMgdmFsdWVcbiAgICBsZXQgdGFnVmFsdWUgPSAkZGVyaXZlZCh2YWx1ZSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRSk7XG48L3NjcmlwdD5cblxuPFVJVGFnIHsuLi50YWdWYWx1ZX0gLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4vdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGxhYmVsXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHZhbHVlLCBsYWJlbCwgaW52ZXJ0ZWQgPSBmYWxzZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHNwYW4gY2xhc3M9XCJsYWJlbFwiPnskTE9DQUxFW2xhYmVsXX06IDxVSUJvb2xlYW4ge3ZhbHVlfSB7aW52ZXJ0ZWR9IC8+PC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW4gZnJvbSBcIi4vdWkuYm9vbGVhbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgdmFsdWVzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2ludmVydGVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICBbY29tcG9uZW50Q29uc3RydWN0b3IgPSBVSUJvb2xlYW5dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2l0ZW1SZW5kZXJlcl0gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN1cHBsaWVkIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIGNvbXBvbmVudENvbnN0cnVjdG9yXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICBjb21wb25lbnRDb25zdHJ1Y3RvcjogSXRlbUNvbnN0cnVjdG9yID0gVUlCb29sZWFuLFxuICAgICAgICBpdGVtUmVuZGVyZXIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IF92YWx1ZXMgPSAkc3RhdGUoW10pO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgX3ZhbHVlcyA9IFt7IHZhbHVlOiB2YWx1ZXMgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmV2ZXJ5KChpdG0pID0+IHR5cGVvZiBpdG0gPT09IFwiYm9vbGVhblwiKSkge1xuICAgICAgICAgICAgICAgIF92YWx1ZXMgPSB2YWx1ZXMubWFwKChpdG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0bSB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdmFsdWVzID0gWy4uLnZhbHVlc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG57I2lmIF92YWx1ZXMubGVuZ3RofVxuICAgIHsjZWFjaCBfdmFsdWVzIGFzIGl0ZW0sIGluZGV4fVxuICAgICAgICB7I2lmIGl0ZW1SZW5kZXJlcn1cbiAgICAgICAgICAgIHtAcmVuZGVyIGl0ZW1SZW5kZXJlcihpdGVtLCBpbmRleCl9XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxJdGVtQ29uc3RydWN0b3Igey4uLml0ZW19IGludmVydGVkPXtpbnZlcnRlZCB8fCBpdGVtLmludmVydGVkfSAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBcImJ1bG1hLXRvb2x0aXAvZGlzdC9jc3MvYnVsbWEtdG9vbHRpcC5taW4uY3NzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtoaWRkZW4gPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtzaG93YWJsZSA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2NvcGlhYmxlID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY29weUljb24gPSAnY29weSddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Nob3dJY29uID0gJ2V5ZSddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2hpZGVJY29uID0gJ2V5ZS1zbGFzaCddXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW21heExlbmd0aCA9IDIwXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtzaGFkb3dDbGFzcyA9IFwiaGFzLWJhY2tncm91bmQtcHJpbWFyeS05MFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFt0b29sdGlwID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbdG9vbHRpcFRUTCA9IDIwMDBdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Rvb2x0aXBUZXh0ID0gXCLQodC60L7Qv9C40YDQvtCy0LDQvdC+INCyINCx0YPRhNC10YBcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdG9vbHRpcENsYXNzID0gXCJoYXMtdG9vbHRpcC1pbmZvXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3ZhbHVlID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25lcnJvcl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaGlkZGVuID0gJGJpbmRhYmxlKHRydWUpLFxuICAgICAgICBzaG93YWJsZSA9IHRydWUsXG4gICAgICAgIGNvcGlhYmxlID0gdHJ1ZSxcbiAgICAgICAgY29weUljb24gPSBcImNvcHlcIixcbiAgICAgICAgc2hvd0ljb24gPSBcImV5ZVwiLFxuICAgICAgICBoaWRlSWNvbiA9IFwiZXllLXNsYXNoXCIsXG4gICAgICAgIG1heExlbmd0aCA9IDIwLFxuICAgICAgICBzaGFkb3dDbGFzcyA9IFwiaGFzLWJhY2tncm91bmQtcHJpbWFyeS05MFwiLFxuICAgICAgICB0b29sdGlwID0gdHJ1ZSxcbiAgICAgICAgdG9vbHRpcFRUTCA9IDIwMDAsXG4gICAgICAgIHRvb2x0aXBUZXh0ID0gXCLQodC60L7Qv9C40YDQvtCy0LDQvdC+INCyINCx0YPRhNC10YBcIixcbiAgICAgICAgdG9vbHRpcENsYXNzID0gXCJoYXMtdG9vbHRpcC1pbmZvXCIsXG4gICAgICAgIHZhbHVlID0gXCJcIixcbiAgICAgICAgb25lcnJvcixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiB0b2dnbGVWaWV3KCkge1xuICAgICAgICBoaWRkZW4gPSAhaGlkZGVuO1xuICAgIH1cblxuICAgIGxldCBjb250ZW50Q29waWVkID0gJHN0YXRlKGZhbHNlKSxcbiAgICAgICAgdG9vbHRpcEFjdGl2ZSA9ICRkZXJpdmVkKHRvb2x0aXAgJiYgY29udGVudENvcGllZCksXG4gICAgICAgIHRvb2x0aXBUYXJnZXQgPSAkc3RhdGUoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvcHlDb250ZW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50Q29waWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0b29sdGlwVGFyZ2V0LmRhdGFzZXQudG9vbHRpcCA9IHRvb2x0aXBUZXh0O1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Q29waWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBUYXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10b29sdGlwXCIpO1xuICAgICAgICAgICAgICAgIH0sIHRvb2x0aXBUVEwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG9uZXJyb3IgJiYgb25lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzcGFuXG4gICAgY2xhc3M9eyhoaWRkZW4gPyBcImlzLWNlbnNvcmVkIFwiICsgc2hhZG93Q2xhc3MgOiBcIlwiKSArXG4gICAgICAgIFwiIGlzLXZlcnRpY2FsLW1pZGRsZSBcIn1cbiAgICBzdHlsZT17YGRpc3BsYXk6aW5saW5lLWJsb2NrOyB3aWR0aDogJHttYXhMZW5ndGh9cmVtOyBoZWlnaHQ6IHZhcigtLWJ1bG1hLXNpemUtbWVkaXVtKTsgb3ZlcmZsb3cteDpoaWRkZW47YH1cbiAgICA+e2hpZGRlbiA/IFwiXCIgOiB2YWx1ZX08L3NwYW5cbj5cbnsjaWYgY29waWFibGV9XG4gICAgPHNwYW5cbiAgICAgICAgYmluZDp0aGlzPXt0b29sdGlwVGFyZ2V0fVxuICAgICAgICBvbmNsaWNrPXtjb3B5Q29udGVudH1cbiAgICAgICAgb25rZXlkb3duPXtjb3B5Q29udGVudH1cbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIGNsYXNzPXtcImljb24gaXMtc21hbGwgaXMtcmlnaHQgaXMtY2xpY2thYmxlIFwiICtcbiAgICAgICAgICAgICh0b29sdGlwQWN0aXZlID8gYCAke3Rvb2x0aXBDbGFzc30gYCA6IFwiXCIpICtcbiAgICAgICAgICAgIFwiIGlzLXZlcnRpY2FsLW1pZGRsZVwifT48aSBjbGFzcz1cImZhcyBmYS17Y29weUljb259XCI+PC9pPjwvc3BhblxuICAgID5cbnsvaWZ9XG57I2lmIHNob3dhYmxlfVxuICAgIDxzcGFuXG4gICAgICAgIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1yaWdodCBpcy1jbGlja2FibGUgaXMtdmVydGljYWwtbWlkZGxlXCJcbiAgICAgICAgb25jbGljaz17dG9nZ2xlVmlld31cbiAgICAgICAgb25rZXlkb3duPXt0b2dnbGVWaWV3fVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCI+PGkgY2xhc3M9XCJmYXMgZmEte2hpZGRlbiA/IHNob3dJY29uIDogaGlkZUljb259XCI+PC9pPjwvc3BhblxuICAgID5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZCA9IFwidGFnSWRcIl0gLSBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyBpbmRpY2F0b3JcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc3RhdGUgPSBcImxpZ2h0XCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NpemUgPSBcIm5vcm1hbFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtsYWJlbHMgPSB7YmxhY2ssIGRhcmssIGxpZ2h0LCB3aGl0ZSwgcHJpbWFyeSwgbGluaywgaW5mbywgc3VjY2Vzcywgd2FybmluZywgZGFuZ2VyfV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgPSBcIm1heC0xXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3BhZGRpbmcgPSBcIm5vcm1hbFwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtib2xkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JpZ2h0ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xlZnQgPSBsZWZ0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFt0b3AgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbYm90dG9tID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW2V2ZW50cyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtyZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50c10gLSByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtvblVwZGF0ZSA9IChkYXRhKSA9PiBjdXJyZW50U3RhdGUgPSBkYXRhLnN0YXRlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwidGFnSWRcIixcbiAgICAgICAgc3RhdGU6IGN1cnJlbnRTdGF0ZSA9ICRiaW5kYWJsZShcImxpZ2h0XCIpLFxuICAgICAgICBzaXplID0gXCJub3JtYWxcIixcbiAgICAgICAgbGFiZWxzID0ge1xuICAgICAgICAgICAgYmxhY2s6IFwiYmxhY2tcIixcbiAgICAgICAgICAgIGRhcms6IFwiZGFya1wiLFxuICAgICAgICAgICAgbGlnaHQ6IFwibGlnaHRcIixcbiAgICAgICAgICAgIHdoaXRlOiBcIndoaXRlXCIsXG4gICAgICAgICAgICBwcmltYXJ5OiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGxpbms6IFwibGlua1wiLFxuICAgICAgICAgICAgaW5mbzogXCJpbmZvXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHdhcm5pbmc6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgZGFuZ2VyOiBcImRhbmdlclwiLFxuICAgICAgICB9LFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwibXgtMVwiLFxuICAgICAgICBwYWRkaW5nID0gXCJub3JtYWxcIixcbiAgICAgICAgYm9sZCA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgICAgICBsZWZ0ID0gZmFsc2UsXG4gICAgICAgIHRvcCA9IGZhbHNlLFxuICAgICAgICBib3R0b20gPSBmYWxzZSxcbiAgICAgICAgZXZlbnRzID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgcmVnaXN0ZXIgPSBub3RDb21tb24ucmVnaXN0ZXJXaWRnZXRFdmVudHMuYmluZChub3RDb21tb24pLFxuICAgICAgICBvblVwZGF0ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkYXRhLCBcInN0YXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gZGF0YS5zdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGBpbmRpY2F0b3ItJHtpZH06dXBkYXRlYDtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGV2ZW50cywgZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpXSA9IG9uVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyKGV2ZW50cyk7XG4gICAgfSk7XG5cbiAgICBsZXQgc2lkZWQgPSAkZGVyaXZlZChyaWdodCB8fCBsZWZ0IHx8IHRvcCB8fCBib3R0b20pO1xuPC9zY3JpcHQ+XG5cbjxzcGFuXG4gICAgY2xhc3M9XCJ0YWcgaXMte3NpemV9IHtwYWRkaW5nICE9PSAnbm9ybWFsJ1xuICAgICAgICA/IGBpcy1wYWRkZWQtJHtwYWRkaW5nfWBcbiAgICAgICAgOiAnJ30gaXMte2N1cnJlbnRTdGF0ZX0ge2NsYXNzZXN9XCJcbiAgICBjbGFzczpoYXMtdGV4dC13ZWlnaHQtYm9sZD17Ym9sZH1cbiAgICBjbGFzczppcy1zaWRlZD17c2lkZWR9XG4gICAgY2xhc3M6aXMtc2lkZWQtcmlnaHQ9e3JpZ2h0fVxuICAgIGNsYXNzOmlzLXNpZGVkLWxlZnQ9e2xlZnR9XG4gICAgY2xhc3M6aXMtc2lkZWQtdG9wPXt0b3B9XG4gICAgY2xhc3M6aXMtc2lkZWQtYm90dG9tPXtib3R0b219PntsYWJlbHNbY3VycmVudFN0YXRlXX08L3NwYW5cbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFwiYnVsbWEtcGFnZWxvYWRlclwiO1xuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIGltcG9ydCB7IG9uRGVzdHJveSwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8vaGlkZGVuIC0gbm8gbG9hZGVyXG4gICAgLy9jb250YWluZXIgLSBwYXJlbnQgY29udGFpbmVyIG9mIGZvcm1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2xvYWRpbmcgPSBmYWxzZV0gICAgICAgc3RhdGUgaWYgZm9ybSBsb2FkaW5nXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NpemUgPSAnY29udGFpbmVyJ10gICAgKHBhZ2UsIGNvbnRhaW5lciwgaGlkZGVuKVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFt0aXRsZSA9ICdXYWl0aW5nLi4uJ10gIExDIHN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0dGxdICAgICAgICAgICAgICAgICAgIHRpbWUgdG8gbGl2ZSwgd2lsbCBiZSBjbG9zZWQgYWZ0ZXIgdHRsIG1zXG4gICAgICogQHByb3BlcnR5IHtzbmlwcGV0fSAgW2NoaWxkcmVuXSAgICAgICAgICAgICAgc25pcHBldHMgbWF5IGJlIHByb3ZpZGVkXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgc2l6ZSA9IFwiY29udGFpbmVyXCIsXG4gICAgICAgIHRpdGxlID0gXCJXYWl0aW5nLi4uXCIsXG4gICAgICAgIHR0bCxcbiAgICAgICAgb25yZWplY3QsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCB0dGxUaW1lcjtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAodHRsKSB7XG4gICAgICAgICAgICB0dGxUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBvbnJlamVjdCgpO1xuICAgICAgICAgICAgfSwgdHRsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgaWYgKHR0bFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodHRsVGltZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxueyNpZiBzaXplICE9PSBcImhpZGRlblwifVxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9e3NpemUgPT09IFwicGFnZVwiID8gXCJwYWdlbG9hZGVyXCIgOiBcImNvbnRhaW5lcmxvYWRlclwifVxuICAgICAgICBjbGFzczppcy1hY3RpdmU9e2xvYWRpbmd9XG4gICAgPlxuICAgICAgICB7I2lmIGNoaWxkcmVufVxuICAgICAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRpdGxlXCI+eyRMT0NBTEVbdGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBsZXQgeyB2YWx1ZSwgdGl0bGUsIHNlbGVjdGVkIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48b3B0aW9uIHt2YWx1ZX0ge3NlbGVjdGVkfT57JExPQ0FMRVt0aXRsZV19PC9vcHRpb24+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJU2VsZWN0T3B0aW9uIGZyb20gXCIuL3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFt2YXJpYW50c11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZW1wdHlWYWx1ZVRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZW1wdHlWYWx1ZVRpdGxlID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWxlY3RcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHNlbGVjdGVkVmFyaWFudHMgPSAkc3RhdGUoW10pO1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyU2VsZWN0ZWRWYXJpYW50cyh2YXJpYW50KSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IHZhcmlhbnQuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja09uQ2xlYXJNYWNybyhuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IFVJQ29tbW9uLkNMRUFSX01BQ1JPKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxyZWFkeVByb2Nlc3NlZChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChub3RDb21tb24uY29tcGFyZVR3b0FycmF5cyh2YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoZXYpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogZXYuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFscmVhZHlQcm9jZXNzZWQoZGF0YS52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGVja09uQ2xlYXJNYWNybyhkYXRhLnZhbHVlKTtcbiAgICAgICAgb25jaGFuZ2UoZGF0YSk7XG4gICAgfVxuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNlbGVjdGVkVmFyaWFudHMgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRzKVxuICAgICAgICAgICAgPyB2YXJpYW50cy5maWx0ZXIoZmlsdGVyU2VsZWN0ZWRWYXJpYW50cylcbiAgICAgICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICB7I2lmIHZhbHVlfVxuICAgICAgICB7I2VhY2ggc2VsZWN0ZWRWYXJpYW50cyBhcyBzZWxlY3RlZFZhcmlhbnR9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1yLTJcIj57JExPQ0FMRVtzZWxlY3RlZFZhcmlhbnQudGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9lYWNofVxuICAgIHs6ZWxzZX1cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJtci0yXCI+eyRMT0NBTEVbZW1wdHlWYWx1ZVRpdGxlXX08L3NwYW4+XG4gICAgey9pZn1cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwic2VsZWN0IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgID5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXNlbGVjdC17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBvbmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgb25ibHVyPXtvbklucHV0fVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICB7c2l6ZX1cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgcGxhY2Vob2xkZXIubGVuZ3RoID4gMH1cbiAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e1VJQ29tbW9uLkNMRUFSX01BQ1JPfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17IXZhbHVlfVxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2VhY2ggdmFyaWFudHMgYXMgdmFyaWFudCAodmFyaWFudC5pZCl9XG4gICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt2YXJpYW50LmlkfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZD17dmFsdWUgPT0gdmFyaWFudC5pZH1cbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3ZhcmlhbnQudGl0bGV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGlnaHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWlzZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbb3V0bGluZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW52ZXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcm91bmRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0eWxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ljb25TaWRlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFthY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBsaWdodCA9IGZhbHNlLFxuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHJhaXNlZCA9IGZhbHNlLFxuICAgICAgICBvdXRsaW5lZCA9IGZhbHNlLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICByb3VuZGVkID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHN0YXRlID0gXCJcIixcbiAgICAgICAgdHlwZSA9IFwiXCIsXG4gICAgICAgIGNvbG9yID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIHN0eWxlID0gXCJcIixcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBpY29uID0gZmFsc2UsXG4gICAgICAgIGljb25TaWRlID0gXCJyaWdodFwiLFxuICAgICAgICBvbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgb25jbGljayAmJiBvbmNsaWNrKHsgZXZlbnQsIHZhbHVlIH0pO1xuICAgICAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbihldmVudCwgdmFsdWUpO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uXG4gICAgb25jbGljaz17b25DbGlja31cbiAgICB7ZGlzYWJsZWR9XG4gICAgdHlwZT17dHlwZSA/IHR5cGUgOiBcIlwifVxuICAgIHtzdHlsZX1cbiAgICBjbGFzcz1cIlxuICBidXR0b25cbiAge2NsYXNzZXN9XG4gIHtzdGF0ZSA/IGBpcy0ke3N0YXRlfWAgOiAnJ31cbiAge2ludmVydGVkID8gYGlzLWludmVydGVkYCA6ICcnfVxuICB7b3V0bGluZWQgPyBgaXMtb3V0bGluZWRgIDogJyd9XG4gIHtyYWlzZWQgPyBgaXMtcmFpc2VkYCA6ICcnfVxuICB7cm91bmRlZCA/IGBpcy1yb3VuZGVkYCA6ICcnfVxuICB7bGlnaHQgPyBgaXMtbGlnaHRgIDogJyd9XG4gIHtsb2FkaW5nID8gYGlzLWxvYWRpbmdgIDogJyd9XG4gIHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ31cbiAge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cbiAgXCJcbj5cbiAgICB7I2lmIGNoaWxkcmVufXtAcmVuZGVyIGNoaWxkcmVuKCl9ezplbHNlIGlmIGljb259XG4gICAgICAgIHsjaWYgaWNvblNpZGUgPT09IFwibGVmdFwifVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCJcbiAgICAgICAgICAgICAgICA+PGkgY2xhc3M9XCJmYXMgZmEte2ljb259IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCI+PC9pPjwvc3BhblxuICAgICAgICAgICAgPlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIHRpdGxlfVxuICAgICAgICAgICAgPHNwYW4+eyRMT0NBTEVbdGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJyaWdodFwifVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCJcbiAgICAgICAgICAgICAgICA+PGkgY2xhc3M9XCJmYXMgZmEte2ljb259IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCI+PC9pPjwvc3BhblxuICAgICAgICAgICAgPlxuICAgICAgICB7L2lmfVxuICAgIHs6ZWxzZX1cbiAgICAgICAgeyRMT0NBTEVbdGl0bGVdfVxuICAgIHsvaWZ9XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FyaWFMYWJlbCA9IFwiZGVsZXRlIGJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmFpc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dGxpbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdW5kZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZGlzYWJsZWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbG9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0eWxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHZhbHVlXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGFyaWFMYWJlbCA9IFwiZGVsZXRlIGJ1dHRvblwiLFxuICAgICAgICBsaWdodCA9IGZhbHNlLFxuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHJhaXNlZCA9IGZhbHNlLFxuICAgICAgICBvdXRsaW5lZCA9IGZhbHNlLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICByb3VuZGVkID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHN0YXRlID0gXCJcIixcbiAgICAgICAgY29sb3IgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgc3R5bGUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgb25jbGljayAmJiBvbmNsaWNrKHsgZXZlbnQsIHZhbHVlIH0pO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uXG4gICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAge2Rpc2FibGVkfVxuICAgIHtzdHlsZX1cbiAgICBjbGFzcz1cIlxuICBkZWxldGVcbiAge2NsYXNzZXN9ICBcbiAge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cbiAgXCJcbj48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQnV0dG9uIGZyb20gXCIuL3VpLmJ1dHRvbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxvYmplY3Q+fSBbdmFsdWVzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2VudGVyZWQgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyaWdodCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuQ29tcG9uZW50fSBbYnV0dG9uQ29tcG9uZW50ID0gVUlCdXR0b25dXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uL2V2ZW50cy50eXBlcycpLlVJRXZlbnRJbnB1dENoYW5nZUNhbGxiYWNrfSBbYWN0aW9uID0gKCk9PnRydWVdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJy4uL2V2ZW50cy50eXBlcycpLlVJRXZlbnRDYWxsYmFja30gW29uY2xpY2sgPSAoKT0+dHJ1ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGNlbnRlcmVkID0gZmFsc2UsXG4gICAgICAgIHJpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgYnV0dG9uQ29tcG9uZW50OiBTdmVsdGVDb21wb25lbnQgPSBVSUJ1dHRvbixcbiAgICAgICAgYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgX3ZhbHVlcyA9ICRzdGF0ZShbXSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgX3ZhbHVlcyA9IHZhbHVlcy5tYXAoKGl0bSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTmFOKGl0bS5pZCkpIHtcbiAgICAgICAgICAgICAgICBpdG0uaWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0bTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPGRpdlxuICAgIGNsYXNzPVwiYnV0dG9ucyBoYXMtYWRkb25zIHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6aXMtcmlnaHQ9e3JpZ2h0fVxuICAgIGNsYXNzOmlzLWNlbnRlcmVkPXtjZW50ZXJlZH1cbj5cbiAgICB7I2VhY2ggX3ZhbHVlcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudCB7YWN0aW9ufSB7b25jbGlja30gey4uLml0ZW19IGJpbmQ6dmFsdWU9e2l0ZW0udmFsdWV9IC8+XG4gICAgey9lYWNofVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4vdWkuYnV0dG9ucy5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xlZnRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtjZW50ZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtyaWdodF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLCBsZWZ0ID0gW10sIGNlbnRlciA9IFtdLCByaWdodCA9IFtdIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiY29sdW1ucyB7Y2xhc3Nlc31cIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgIDxVSUJ1dHRvbnMgdmFsdWVzPXtsZWZ0fT48L1VJQnV0dG9ucz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgIDxVSUJ1dHRvbnMgdmFsdWVzPXtjZW50ZXJ9IGNlbnRlcmVkPXt0cnVlfT48L1VJQnV0dG9ucz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1uXCI+XG4gICAgICAgIDxVSUJ1dHRvbnMgdmFsdWVzPXtyaWdodH0gcmlnaHQ9e3RydWV9PjwvVUlCdXR0b25zPlxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9uIGZyb20gXCIuL3VpLmJ1dHRvbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhaXNlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvdXRsaW5lZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnZlcnRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3VuZGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ljb25TaWRlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt1aU9mZl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbdWlPbl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbYWN0aW9uXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGxpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmFpc2VkID0gZmFsc2UsXG4gICAgICAgIG91dGxpbmVkID0gZmFsc2UsXG4gICAgICAgIGludmVydGVkID0gZmFsc2UsXG4gICAgICAgIHJvdW5kZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgc3RhdGU6IGFjdGl2ZVN0YXRlID0gXCJcIixcbiAgICAgICAgdHlwZSA9IFwiXCIsXG4gICAgICAgIGNvbG9yID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgaWNvbiA9IGZhbHNlLFxuICAgICAgICBpY29uU2lkZSA9IFwicmlnaHRcIixcbiAgICAgICAgdWlPZmYgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdWlPbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICFzZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbGljayA9ICgpID0+IHt9LFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHt9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgc2VsZWN0ZWQgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBjaGlsZFByb3BzID0gJHN0YXRlKHtcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGxpZ2h0LFxuICAgICAgICBsb2FkaW5nLFxuICAgICAgICByYWlzZWQsXG4gICAgICAgIG91dGxpbmVkLFxuICAgICAgICBpbnZlcnRlZCxcbiAgICAgICAgcm91bmRlZCxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICBjbGFzczogY2xhc3NlcyxcbiAgICAgICAgaWNvbixcbiAgICAgICAgaWNvblNpZGUsXG4gICAgICAgIHZhbHVlLFxuICAgIH0pO1xuXG4gICAgbGV0IHVpRWxlbWVudCA9ICRzdGF0ZSgpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIHNlbGVjdGVkID0gYWN0aW9uKGV2ZW50LCB2YWx1ZSwgc2VsZWN0ZWQpO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICBvbmNsaWNrKHsgdmFsdWUsIHNlbGVjdGVkIH0pO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gdXBkYXRlVUkoKSB7XG4gICAgICAgIGlmICh1aUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzQ2hhbmdlcyA9IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyB1aU9uKHZhbHVlLCBzZWxlY3RlZClcbiAgICAgICAgICAgICAgICA6IHVpT2ZmKHZhbHVlLCBzZWxlY3RlZCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wc0NoYW5nZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkUHJvcHNba2V5XSA9IHByb3BzQ2hhbmdlc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGlsZFByb3BzID0gY2hpbGRQcm9wcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdGVkICE9PSBcInVuZGVmaW5lZFwiKSB1cGRhdGVVSSgpO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxVSUJ1dHRvblxuICAgIGJpbmQ6dGhpcz17dWlFbGVtZW50fVxuICAgIHsuLi5jaGlsZFByb3BzfVxuICAgIHN0YXRlPXthY3RpdmVTdGF0ZX1cbiAgICBvbmNsaWNrPXtvbkNsaWNrfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSUJ1dHRvblN3aXRjaCBmcm9tIFwiLi91aS5idXR0b24uc3dpdGNoLnN2ZWx0ZVwiO1xuXG4gICAgY29uc3QgdWlzID0ge307XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVJdGVtVUkoaXRlbSkge1xuICAgICAgICB1aXNbaXRlbS5pZF0udXBkYXRlVUkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0QWN0aW9uID0gKGV2LCB2YWx1ZSwgc2VsZWN0ZWQpID0+IHtcbiAgICAgICAgY29uc3QgY291bnRPZlNlbGVjdGVkID0gY291bnRTZWxlY3RlZCgpO1xuICAgICAgICBpZiAoY291bnRPZlNlbGVjdGVkID09PSBtaW4gJiYgc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnRPZlNlbGVjdGVkID09PSBtYXggJiYgc2VsZWN0ZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleE9mQ3VycmVudCA9IF92YWx1ZXMuZmluZEluZGV4KChpdG0pID0+IGl0bS52YWx1ZSA9PT0gdmFsdWUpO1xuICAgICAgICBsZXQgbmV3U2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgaWYgKGluZGV4T2ZDdXJyZW50ID4gLTEpIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkID0gIW5ld1NlbGVjdGVkO1xuICAgICAgICAgICAgY29uc3QgY250ID0gY291bnRTZWxlY3RlZCgpICsgKG5ld1NlbGVjdGVkID8gMSA6IC0xKTtcbiAgICAgICAgICAgIGlmIChtaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY250IDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdFVwVG9NaW4oY250LCBpbmRleE9mQ3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPCBjbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzZWxlY3REb3duVG9NaW4oY250LCBpbmRleE9mQ3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYWRkVG9IaXN0b3J5KGluZGV4T2ZDdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U2VsZWN0ZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheTxvYmplY3Q+fSBbdmFsdWVzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NlbnRlcmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JpZ2h0XVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLkNvbXBvbmVudH0gICAgICBbYnV0dG9uQ29tcG9uZW50ID0gVUlCdXR0b25Td2l0Y2hdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2J1dHRvblByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2FjdGlvbiA9IChldmVudCwgdmFsdWUsIHNlbGVjdGVkKSA9PiBib29sZWFuXSAgZmlyZXMgb24gYnV0dG9uIHN3aXRjaCBjbGljaywgcmV0dXJucyBuZXcgc3RhdGUgb2Ygc2VsZWN0ZWRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW4gPSAwXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4ID0gMTAwXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgY2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBidXR0b25Db21wb25lbnQgPSBVSUJ1dHRvblN3aXRjaCxcbiAgICAgICAgYnV0dG9uUHJvcHMgPSB7fSxcbiAgICAgICAgYWN0aW9uID0gZGVmYXVsdEFjdGlvbixcbiAgICAgICAgb25jbGljayA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbWF4ID0gMTAwLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IHNlbGVjdEhpc3RvcnkgPSBbXTtcbiAgICBsZXQgX3ZhbHVlcyA9ICRzdGF0ZSh2YWx1ZXMpO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICAgIHZhbHVlcyA9ICRzdGF0ZS5zbmFwc2hvdChfdmFsdWVzKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB2YWx1ZXMuZmlsdGVyKChpdG0pID0+IGl0bS5zZWxlY3RlZCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSWRzID0gc2VsZWN0ZWQubWFwKChpdG0pID0+IGl0bS5pZCk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkQ291bnQgPSBzZWxlY3RlZElkcy5sZW5ndGg7XG4gICAgICAgIG9uY2hhbmdlICYmXG4gICAgICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSWRzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkQ291bnQsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2VsZWN0QWxsKCkge1xuICAgICAgICBfdmFsdWVzLmZvckVhY2goKGl0bSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIF92YWx1ZXNbaW5kZXhdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW1VSShpdG0pO1xuICAgICAgICB9KTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZGVzZWxlY3RBbGwoKSB7XG4gICAgICAgIF92YWx1ZXMuZm9yRWFjaCgoaXRtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgX3ZhbHVlc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW1VSShpdG0pO1xuICAgICAgICB9KTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb3VudCA9IGNvdW50U2VsZWN0ZWQoKTtcbiAgICAgICAgaWYgKG1pbiAmJiBzZWxlY3RlZENvdW50IDwgbWluKSB7XG4gICAgICAgICAgICBzZWxlY3RVcFRvTWluKHNlbGVjdGVkQ291bnQsIC0xKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGFkZFRvSGlzdG9yeShpZCkge1xuICAgICAgICBpZiAoc2VsZWN0SGlzdG9yeS5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgICAgIHNlbGVjdEhpc3Rvcnkuc3BsaWNlKHNlbGVjdEhpc3RvcnkuaW5kZXhPZihpZCksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdEhpc3RvcnkucHVzaChpZCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGNvdW50U2VsZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50T2ZTZWxlY3RlZCA9IF92YWx1ZXMuZmlsdGVyKChidG4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBidG4uc2VsZWN0ZWQ7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvdW50T2ZTZWxlY3RlZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gdG9nZ2xlRmlyc3RTdWl0ZWQodG9WYWx1ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IF92YWx1ZXMuZmluZEluZGV4KChpdG0pID0+ICF0b1ZhbHVlID09IGl0bS5zZWxlY3RlZCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBfdmFsdWVzW2luZGV4XS5zZWxlY3RlZCA9IHRvVmFsdWU7XG4gICAgICAgICAgICB1cGRhdGVJdGVtVUkoX3ZhbHVlc1tpbmRleF0pO1xuICAgICAgICAgICAgYWRkVG9IaXN0b3J5KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZWxlY3RVcFRvTWluKGNudCwgaW5kZXhPZkN1cnJlbnQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gbWluIC0gY250O1xuICAgICAgICBpZiAoIWRlbHRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCBpbiBfdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gaW5kZXhPZkN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX3ZhbHVlc1t0XS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIF92YWx1ZXNbdF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1VSShfdmFsdWVzW3RdKTtcbiAgICAgICAgICAgICAgICBhZGRUb0hpc3RvcnkodCk7XG4gICAgICAgICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbkNoYW5nZSgpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBkZXNlbGVjdERvd25Ub01pbihjbnQsIGluZGV4T2ZDdXJyZW50KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNudCAtIG1heDtcbiAgICAgICAgaWYgKCFkZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHQgaW4gX3ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHQgPT09IGluZGV4T2ZDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3ZhbHVlc1t0XS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIF92YWx1ZXNbdF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtVUkoX3ZhbHVlc1t0XSk7XG4gICAgICAgICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbkNoYW5nZSgpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1cGRhdGVVSSgpIHtcbiAgICAgICAgT2JqZWN0LmtleXModWlzKS5mb3JFYWNoKChpdGVtSWQpID0+IHtcbiAgICAgICAgICAgIGlmICh1aXNbaXRlbUlkXSkge1xuICAgICAgICAgICAgICAgIHVpc1tpdGVtSWRdLnVwZGF0ZVVJICYmIHVpc1tpdGVtSWRdLnVwZGF0ZVVJKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJidXR0b25zIGhhcy1hZGRvbnMge2NlbnRlcmVkID8gJ2lzLWNlbnRlcmVkJyA6ICcnfSB7cmlnaHRcbiAgICAgICAgPyAnaXMtcmlnaHQnXG4gICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4+XG4gICAgeyNlYWNoIF92YWx1ZXMgYXMgaXRlbSwgaW5kZXggKGl0ZW0uaWQpfVxuICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IGJ1dHRvbkNvbXBvbmVudH1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICAgICAgYmluZDp0aGlzPXt1aXNbaXRlbS5pZF19XG4gICAgICAgICAgICB7YWN0aW9ufVxuICAgICAgICAgICAgey4uLml0ZW19XG4gICAgICAgICAgICB7Li4uYnV0dG9uUHJvcHN9XG4gICAgICAgICAgICB7b25jbGlja31cbiAgICAgICAgICAgIGJpbmQ6c2VsZWN0ZWQ9e192YWx1ZXNbaW5kZXhdLnNlbGVjdGVkfVxuICAgICAgICAgICAgb25jaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAvPlxuICAgIHsvZWFjaH1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBsZXQge1xuICAgICAgICBncm91cGVkID0gZmFsc2UsXG4gICAgICAgIGFkZG9ucyA9IGZhbHNlLFxuICAgICAgICBtdWx0aWxpbmUgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICBjbGFzcz1cImZpZWxkIHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6aGFzLWFkZG9ucz17YWRkb25zfVxuICAgIGNsYXNzOmlzLWdyb3VwZWQ9e2dyb3VwZWR9XG4gICAgY2xhc3M6aXMtbXVsdGlsaW5lPXttdWx0aWxpbmV9XG4gICAgey4uLm90aGVyc31cbj5cbiAgICB7QHJlbmRlciBjaGlsZHJlbigpfVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcz0nJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtoYXNJY29uc0xlZnQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaGFzSWNvbnNSaWdodD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGhhc0ljb25zTGVmdCA9IGZhbHNlLFxuICAgICAgICBoYXNJY29uc1JpZ2h0ID0gZmFsc2UsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHBcbiAgICBjbGFzcz1cImNvbnRyb2wge2NsYXNzZXN9XCJcbiAgICBjbGFzczpoYXMtaWNvbnMtbGVmdD17aGFzSWNvbnNMZWZ0fVxuICAgIGNsYXNzOmhhcy1pY29ucy1yaWdodD17aGFzSWNvbnNSaWdodH1cbiAgICB7Li4ub3RoZXJzfVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvcD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG4gICAgaW1wb3J0IFVJU2VsZWN0IGZyb20gXCIuLi9pbnB1dC91aS5zZWxlY3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVUlCdXR0b25zLCBVSUJ1dHRvbiB9IGZyb20gXCIuLi9idXR0b25cIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJRmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLmZpZWxkLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbnRyb2wgZnJvbSBcIi4uL2lucHV0L3VpLmNvbnRyb2wuc3ZlbHRlXCI7XG5cbiAgICBjb25zdCBERUZBVUxUX0FQSV9NT0RFTF9HRVRURVIgPSAoXG4gICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgYWN0aW9uRmlsdGVyLFxuICAgICAgICBhY3Rpb25Tb3J0ZXIsXG4gICAgICAgIGFjdGlvblBhZ2VyLFxuICAgICAgICBhY3Rpb25TZWFyY2hcbiAgICApID0+IHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vblxuICAgICAgICAgICAgLmdldEFwcCgpXG4gICAgICAgICAgICAuZ2V0TW9kZWwobW9kZWxOYW1lKVxuICAgICAgICAgICAgLnNldEZpbHRlcihhY3Rpb25GaWx0ZXIpXG4gICAgICAgICAgICAuc2V0U29ydGVyKGFjdGlvblNvcnRlcilcbiAgICAgICAgICAgIC5zZXRQYWdlcihhY3Rpb25QYWdlcilcbiAgICAgICAgICAgIC5zZXRTZWFyY2goYWN0aW9uU2VhcmNoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgREVGQVVMVF9BUElfUkVRVUVTVCA9IChhcGlNb2RlbCwgYWN0aW9uTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gYXBpTW9kZWxbYCRgICsgYWN0aW9uTmFtZV0oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIG9mIHNlbGVjdGVkIHZhcmlhbnRcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICBbdmFyaWFudHMgPSBbXV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgb2YgdmFyaWFudHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbbG9hZGVkID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUgaWYgd2UgYWxyZWFkeSBsb2FkZWQgdmFyaWFudHMgZnJvbSBzZXJ2ZXIgdmlhIEFQSVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtwbGFjZWhvbGRlciA9IFwiZW1wdHkgc2VsZWN0IGl0ZW1cIl0gICAgICAgICBwbGFjZWhvbGRlciB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtmaWVsZG5hbWUgPSBcInNlbGVjdEZyb21Nb2RlbFwiXSAgICAgICAgICAgICB0aGlzIGlucHV0IGZpZWxkbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFttb2RlbE5hbWUgPSBcIlwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICBBUEkgbW9kZWxOYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2FjdGlvbk5hbWUgPSBcIlwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgIEFQSSBhY3Rpb25OYW1lXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2FjdGlvbkZpbHRlciA9IHt9XSAgICAgICAgICAgICAgICAgICAgICAgICBBUEkgZmlsdGVyaW5nIHJ1bGVzXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2FjdGlvblNvcnRlciA9IHt9XSAgICAgICAgICAgICAgICAgICAgICAgICBBUEkgc29ydGluZyBydWxlc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFthY3Rpb25QYWdlciA9IHt9XSAgICAgICAgICAgICAgICAgICAgICAgICAgQVBJIHBhZ2VyIHN0YXRlXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2FjdGlvblNlYXJjaCA9IHVuZGVmaW5lZF0gICAgICAgICAgICAgICAgICBBUEkgc2VhcmNoIHN0cmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtvcHRpb25JZCA9IFwiOl9pZFwiXSAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50IG9iamVjdCBpZCBmaWVsZCBuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW29wdGlvblRpdGxlID0gXCI6dGl0bGVcIl0gICAgICAgICAgICAgICAgICAgIHZhcmlhbnQgb2JqZWN0IHRpdGxlIGZpZWxkIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbcmVxdWlyZWQgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkIGlzIHJlcXVpcmVkXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW3JlYWRvbmx5ID0gZmFsc2VdICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZCBpcyByZWFvbmx5XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3NpemVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3cgbWFueSB2YXJpYW50cyB3b3VsZCBiZSB2aXNpYmxlIGF0IG9uY2UsIGRlZmF1bHQ6IDFcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbdmFsaWQgPSB0cnVlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkIGlzIHZhbGlkXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ucmVqZWN0ID0gKCkgPT4gZmFsc2VdICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayBvbiByZWplY3Qgb2Ygc2VsZWN0aW9uIHByb2Nlc3NcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25yZXNvbHZlID0gKCkgPT4gdHJ1ZV0gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrIG9uIHJlc29sdmUgb2Ygc2VsZWN0aW9uIHByb2Nlc3NcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25lcnJvciA9ICgpID0+IHRydWVdICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrIG9uIGVycm9yXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YXJpYW50cyA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIGxvYWRlZCA9IGZhbHNlLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiZW1wdHkgc2VsZWN0IGl0ZW1cIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWxlY3RGcm9tTW9kZWxcIixcbiAgICAgICAgbW9kZWxOYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbkZpbHRlciA9IHt9LFxuICAgICAgICBhY3Rpb25Tb3J0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uUGFnZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU2VhcmNoID0gdW5kZWZpbmVkLFxuICAgICAgICBhcGlNb2RlbEdldHRlciA9IERFRkFVTFRfQVBJX01PREVMX0dFVFRFUixcbiAgICAgICAgYXBpUmVxdWVzdCA9IERFRkFVTFRfQVBJX1JFUVVFU1QsXG4gICAgICAgIG9wdGlvbklkID0gXCI6X2lkXCIsXG4gICAgICAgIG9wdGlvblRpdGxlID0gXCI6dGl0bGVcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBzaXplLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIG9ucmVqZWN0ID0gKCkgPT4gZmFsc2UsXG4gICAgICAgIG9ucmVzb2x2ZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB0cnVlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFyZ3VtZW50c1NldFByb3ZpZGVkKCkge1xuICAgICAgICByZXR1cm4gbW9kZWxOYW1lICYmIGFjdGlvbk5hbWUgJiYgYWN0aW9uRmlsdGVyO1xuICAgIH1cblxuICAgIGxldCBkaXNhYmxlZCA9ICRkZXJpdmVkKCFsb2FkZWQpO1xuICAgIGxldCBjb21wb25lbnRTdGF0ZSA9ICRzdGF0ZShcImhpZGRlblwiKTtcbiAgICBsZXQgcmVzdWx0c0xpc3QgPSBbXTtcblxuICAgIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYXJndW1lbnRzU2V0UHJvdmlkZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGFwaU1vZGVsR2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uU29ydGVyLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25QYWdlcixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uU2VhcmNoXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9uZXJyb3IocmVzcG9uc2UuZXJyb3JzIHx8IFtyZXNwb25zZS5tZXNzYWdlXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNMaXN0ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhcmlhbnRzID0gcmVzdWx0c0xpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm90UGF0aC5nZXQob3B0aW9uSWQsIGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5vdFBhdGguZ2V0KG9wdGlvblRpdGxlLCBpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzb2x2ZWRWYWx1ZTtcblxuICAgIGZ1bmN0aW9uIG9uTW9kZWxDaGFuZ2VkKHsgdmFsdWU6IHNlbGVjdGVkVmFsdWUgfSkge1xuICAgICAgICBpZiAocmVzdWx0c0xpc3QubGVuZ3RoID4gdmFyaWFudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gcmVzdWx0c0xpc3QuZmluZChcbiAgICAgICAgICAgICAgICAoaXRlbSkgPT4gbm90UGF0aC5nZXQob3B0aW9uSWQsIGl0ZW0pID09IHNlbGVjdGVkVmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZFZhbHVlID0gdmFyaWFudHMuZmluZCgoaXRlbSkgPT4gaXRlbS5pZCA9PSBzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IEFDVElPTlMgPSB7XG4gICAgICAgIGFkZDoge1xuICAgICAgICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgaWNvbjogXCJwbHVzXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RhdGUgPSBcInNob3dcIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmU6IHtcbiAgICAgICAgICAgIGljb246IFwiY2hlY2tcIixcbiAgICAgICAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIGFjdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRTdGF0ZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgb25yZXNvbHZlKHsgZmllbGQ6IGZpZWxkbmFtZSwgdmFsdWU6IHJlc29sdmVkVmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6IHtcbiAgICAgICAgICAgIGljb246IFwieG1hcmtcIixcbiAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgYWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0YXRlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICBvbnJlamVjdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbnsjaWYgY29tcG9uZW50U3RhdGUgPT09IFwiaGlkZGVuXCJ9XG4gICAgPFVJQnV0dG9uIHsuLi5BQ1RJT05TLmFkZH0+PC9VSUJ1dHRvbj5cbns6ZWxzZSBpZiBjb21wb25lbnRTdGF0ZSA9PSBcInNob3dcIn1cbiAgICA8VUlGaWVsZCBhZGRvbnM9e3RydWV9PlxuICAgICAgICA8VUlDb250cm9sPlxuICAgICAgICAgICAgPFVJU2VsZWN0XG4gICAgICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAgICAgIHt2YXJpYW50c31cbiAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAge2ZpZWxkbmFtZX1cbiAgICAgICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICB7c2l6ZX1cbiAgICAgICAgICAgICAgICB7dmFsaWR9XG4gICAgICAgICAgICAgICAgb25jaGFuZ2U9e29uTW9kZWxDaGFuZ2VkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgPC9VSUNvbnRyb2w+XG4gICAgICAgIDxVSUNvbnRyb2w+XG4gICAgICAgICAgICA8VUlCdXR0b25zIHZhbHVlcz17W0FDVElPTlMucmVzb2x2ZSwgQUNUSU9OUy5yZWplY3RdfT48L1VJQnV0dG9ucz5cbiAgICAgICAgPC9VSUNvbnRyb2w+XG4gICAgPC9VSUZpZWxkPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG5cbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGNvbnN0IERFRkFVTFRfU0VSVklDRV9HRVRURVIgPSAoc2VydmljZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFzZXJ2aWNlTmFtZSkgdGhyb3cgbmV3IEVycm9yKFwic2VydmljZU5hbWUgaXMgbm90IHNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudW1iZXJ9ICAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWNvbiA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtmaWVsZG5hbWUgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc2VydmljZU5hbWUgPSAnJ10gLSBTZXQgdGhpcywgYXMgbnNbTW9kZWxOYW1lXSwgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgaW4gbm90QXBwXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NlcnZpY2VPcGVuU2VsZWN0b3JNZXRob2QgPSBcIm9wZW5TZWxlY3RvclwiXSAtIFNldCB0aGlzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3NlcnZpY2VMb2FkRGF0YU1ldGhvZCA9IFwibG9hZERhdGFcIl0gLSBTZXQgdGhpc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFttb2RlbERhdGEgPSBudWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtsb2FkaW5nID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3NlbGVjdGVkTW9kZWxUaXRsZUZvcm1hdHRlciA9IChkYXRhKSA9PiBkYXRhLl9pZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbc2VydmljZUdldHRlciA9IChzZXJ2aWNlTmFtZSk9Pm5vdENvbW1vbi5nZXRBcHAoKS5nZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbbG9hZGluZ0xhYmVsID0gXCJub3Qtbm9kZTpsb2FkaW5nX2xhYmVsXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2lzRW1wdHlMYWJlbCA9IFwibm90LW5vZGU6ZmllbGRfdmFsdWVfaXNfZW1wdHlfcGxhY2Vob2xkZXJcIl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2UgPSAoKSA9PiB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtvcGVuU2VsZWN0b3JCdXR0b25Qcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtyZXNldEJ1dHRvblByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2VtcHR5QnV0dG9uUHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbdmFsdWVCdXR0b25Qcm9wcyA9IHt9XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICBpY29uID0gXCJzZWFyY2hcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJcIixcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgc2VydmljZU5hbWUgPSBcIlwiLFxuICAgICAgICBzZXJ2aWNlT3BlblNlbGVjdG9yTWV0aG9kID0gXCJvcGVuU2VsZWN0b3JcIixcbiAgICAgICAgc2VydmljZUxvYWREYXRhTWV0aG9kID0gXCJsb2FkRGF0YVwiLFxuICAgICAgICBtb2RlbERhdGEgPSAkYmluZGFibGUobnVsbCksXG4gICAgICAgIGxvYWRpbmcgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBzZWxlY3RlZE1vZGVsVGl0bGVGb3JtYXR0ZXIgPSAoZGF0YSkgPT4gYCR7ZGF0YS5faWR9YCxcbiAgICAgICAgc2VydmljZUdldHRlciA9IERFRkFVTFRfU0VSVklDRV9HRVRURVIsXG4gICAgICAgIGxvYWRpbmdMYWJlbCA9IFwibm90LW5vZGU6bG9hZGluZ19sYWJlbFwiLFxuICAgICAgICBpc0VtcHR5TGFiZWwgPSBcIm5vdC1ub2RlOmZpZWxkX3ZhbHVlX2lzX2VtcHR5X3BsYWNlaG9sZGVyXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgb3BlblNlbGVjdG9yQnV0dG9uUHJvcHMgPSB7fSxcbiAgICAgICAgcmVzZXRCdXR0b25Qcm9wcyA9IHt9LFxuICAgICAgICBlbXB0eUJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIHZhbHVlQnV0dG9uUHJvcHMgPSB7fSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvcGVuTW9kZWxTZWFyY2hBbmRTZWxlY3QoKSB7XG4gICAgICAgIGlmICghc2VydmljZU9wZW5TZWxlY3Rvck1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VydmljZU9wZW5TZWxlY3Rvck1ldGhvZCBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSBzZXJ2aWNlR2V0dGVyKHNlcnZpY2VOYW1lKTtcbiAgICAgICAgc2VydmljZVtzZXJ2aWNlT3BlblNlbGVjdG9yTWV0aG9kXSgpXG4gICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQuX2lkO1xuICAgICAgICAgICAgICAgIG1vZGVsRGF0YSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9kZWxEYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFNlbGVjdGVkTW9kZWwoKSB7XG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBtb2RlbERhdGEgPSBudWxsO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNb2RlbERhdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIW1vZGVsRGF0YSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1vZGVsRGF0YSA9IGF3YWl0IGdldFNlcnZpY2UoKVtzZXJ2aWNlTG9hZERhdGFNZXRob2RdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBsb2FkTW9kZWxEYXRhKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBBVkFJTEFCTEVfQlVUVE9OUyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBhY3Rpb246IG9wZW5Nb2RlbFNlYXJjaEFuZFNlbGVjdCxcbiAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICBjb2xvcjogXCJ3YXJuaW5nXCIsXG4gICAgICAgICAgICAuLi5vcGVuU2VsZWN0b3JCdXR0b25Qcm9wcyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IDIsXG4gICAgICAgICAgICBhY3Rpb246IHJlc2V0U2VsZWN0ZWRNb2RlbCxcbiAgICAgICAgICAgIGljb246IFwidGltZXNcIixcbiAgICAgICAgICAgIGNvbG9yOiBcImRhbmdlclwiLFxuICAgICAgICAgICAgLi4ucmVzZXRCdXR0b25Qcm9wcyxcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZ2V0TW9kZWxCdXR0b24oKSB7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvYWRpbmdMYWJlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHJlYWRvbmx5LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG9wZW5Nb2RlbFNlYXJjaEFuZFNlbGVjdCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkTW9kZWxUaXRsZUZvcm1hdHRlcihtb2RlbERhdGEpLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZUJ1dHRvblByb3BzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXNFbXB0eUxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAuLi5lbXB0eUJ1dHRvblByb3BzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgVklTSUJMRV9CVVRUT05TID0gJHN0YXRlKFtdKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIFZJU0lCTEVfQlVUVE9OUyA9IFtcbiAgICAgICAgICAgICAgICBnZXRNb2RlbEJ1dHRvbigpLFxuICAgICAgICAgICAgICAgIC4uLihyZWFkb25seSA/IFtdIDogQVZBSUxBQkxFX0JVVFRPTlMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFZJU0lCTEVfQlVUVE9OUyA9IFtcbiAgICAgICAgICAgICAgICBnZXRNb2RlbEJ1dHRvbigpLFxuICAgICAgICAgICAgICAgIC4uLihyZWFkb25seSA/IFtdIDogW0FWQUlMQUJMRV9CVVRUT05TWzBdXSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfSk7XG48L3NjcmlwdD5cblxuPFVJQ29udHJvbD5cbiAgICA8VUlCdXR0b25zIHZhbHVlcz17VklTSUJMRV9CVVRUT05TfSBjbGFzcz17XCJpcy1uby1mbGV4LXdyYXBcIn0+PC9VSUJ1dHRvbnM+XG48L1VJQ29udHJvbD5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFttYXggPSAxMDBdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NvbG9yID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbc2l6ZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2NsYXNzID0gXCJcIl1cbiAgICAgKiovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtYXggPSAxMDAsXG4gICAgICAgIGNvbG9yID0gXCJcIixcbiAgICAgICAgc2l6ZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHByb2dyZXNzXG4gICAgY2xhc3M9XCJcbiAgcHJvZ3Jlc3NcbiAge2NsYXNzZXN9XG4gIHtjb2xvciA/IGBpcy0ke2NvbG9yfWAgOiAnJ31cbiAge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIlxuICAgIHt2YWx1ZX1cbiAgICB7bWF4fT57dmFsdWV9JTwvcHJvZ3Jlc3Ncbj5cbiIsIjxzY3JpcHQ+XG4gICAgY29uc3QgZGVmYXVsdEZpbHRlciA9ICh2YWx1ZSkgPT4gdmFsdWVbaWRGaWVsZE5hbWVdID09PSBpZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVtYmVyfSAgICBpZCAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgb2YgYWN0aXZlIGl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICAgICAgICAgIFt2YWx1ZXMgPSBbXV0gICAgICAgICAgICAgICBsaXN0IG9mIGl0ZW1zXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgICAgICBVSUNvbXBvbmVudCAgICAgICAgICAgICAgICAgY29tcG9uZW50IHRvIHNob3cgYWN0aXZlIGl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIGNvbXBvbmVudCAgICAgICAgICAgICAgICAgICBzbmlwcGV0IHRvIHNob3cgYWN0aXZlIGl0ZW1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIFVJUGxhY2Vob2xkZXIgICAgICAgICAgICAgICBwbGFjZWhvbGRlciBpZiBhY3RpdmUgaXMgdW5zZXRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIHBsYWNlaG9sZGVyICAgICAgICAgICAgICAgICBzbmlwcGV0IHRvIHNob3cgcGxhY2Vob2xkZXJcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgICAgIFtwbGFjZWhvbGRlclByb3BzID0ge31dICAgICBwbGFjZWhvbGRlciBwcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICAgICAgW2FjdGl2ZSA9IHt9XSAgICAgICAgICAgICAgIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICAgICAgICAgIFtpZEZpZWxkTmFtZSA9IFwiX2lkXCJdICAgICAgIG5hbWUgb2YgaXRlbSBwcm9wZXJ0eSB1c2VkIGFzIGlkZW50aWZpY2F0b3JcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgICAgIFtmaWx0ZXIgPSAodmFsdWUpID0+IHZhbHVlW2lkRmllbGROYW1lXSA9PT0gaWRdIGZpbHRlcmluZyBmdW5jdGlvbiB0byBzZWxlY3QgYWN0aXZlIGl0ZW0uIGRlZmF1bHQgaXMgdG8gc2VhcmNoIGZvciBpdGVtIHdpdGggc2VsZWN0ZWQgaWRcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgICBhY3RpdmUgPSAkYmluZGFibGUoe30pLFxuICAgICAgICBpZEZpZWxkTmFtZSA9IFwiX2lkXCIsXG4gICAgICAgIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICAgIFVJQ29tcG9uZW50LFxuICAgICAgICBjb21wb25lbnQsXG4gICAgICAgIFVJUGxhY2Vob2xkZXIsXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBwbGFjZWhvbGRlclByb3BzLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBhY3RpdmUgPVxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggJiYgdHlwZW9mIGlkICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyB2YWx1ZXMuZmluZChmaWx0ZXIgfHwgZGVmYXVsdEZpbHRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG57I2lmIGFjdGl2ZX1cbiAgICB7I2lmIGNvbXBvbmVudH1cbiAgICAgICAge0ByZW5kZXIgY29tcG9uZW50KGFjdGl2ZSl9XG4gICAgezplbHNlIGlmIFVJQ29tcG9uZW50fVxuICAgICAgICA8VUlDb21wb25lbnQgey4uLmFjdGl2ZX0gLz5cbiAgICB7L2lmfVxuezplbHNlIGlmIFVJUGxhY2Vob2xkZXJ9XG4gICAgeyNpZiBwbGFjZWhvbGRlcn1cbiAgICAgICAge0ByZW5kZXIgcGxhY2Vob2xkZXIocGxhY2Vob2xkZXJQcm9wcyl9XG4gICAgezplbHNlIGlmIFVJUGxhY2Vob2xkZXJ9XG4gICAgICAgIDxVSVBsYWNlaG9sZGVyIHsuLi5wbGFjZWhvbGRlclByb3BzfSAvPlxuICAgIHsvaWZ9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlUYWcgZnJvbSBcIi4vdWkudGFnLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWQgPSBcInRhZ2dlZFZhbHVlSWRcIl0gLSBpZiB3ZSB3YW50IHRvIGFkZHJlc3MgdGhpcyB0YWdcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgW2FjdGlvbnMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbYWN0aW9uc0dyb3VwQ29udHJ1Y3RvciA9IFVJQnV0dG9uc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gICAgICBbYWN0aW9uc0dyb3VwUHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcInRhZ2dlZFZhbHVlSWRcIixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgYWN0aW9uc0dyb3VwQ29udHJ1Y3RvcjogQWN0aW9uc0dyb3VwQ29udHJ1Y3RvciA9IFVJQnV0dG9ucyxcbiAgICAgICAgYWN0aW9uc0dyb3VwUHJvcHMgPSB7fSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInRhZ3MgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIiB7aWR9PlxuICAgIHsjaWYgdGl0bGV9PFVJVGFnIHsuLi50aXRsZX0gLz57L2lmfVxuICAgIHsjaWYgdmFsdWV9PFVJVGFnIHsuLi52YWx1ZX0gLz57L2lmfVxuPC9kaXY+XG57I2lmICFyZWFkb25seSAmJiBhY3Rpb25zICYmIGFjdGlvbnMubGVuZ3RofVxuICAgIDxBY3Rpb25zR3JvdXBDb250cnVjdG9yIHZhbHVlcz17YWN0aW9uc30gey4uLmFjdGlvbnNHcm91cFByb3BzfSAvPlxuey9pZn1cbiIsImltcG9ydCB7IGVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi9pbmRleC5qcyc7XG5cbmVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnKCk7XG4iLCIvKlxuQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbFxuRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Vhc2VzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuXHRyZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG5cdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tJbih0KSB7XG5cdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRyZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuXHRjb25zdCBzID0gMS43MDE1ODtcblx0cmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuY2VPdXQodCkge1xuXHRjb25zdCBhID0gNC4wIC8gMTEuMDtcblx0Y29uc3QgYiA9IDguMCAvIDExLjA7XG5cdGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuXHRjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuXHRjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG5cdGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcblx0Y29uc3QgdDIgPSB0ICogdDtcblx0cmV0dXJuIHQgPCBhXG5cdFx0PyA3LjU2MjUgKiB0MlxuXHRcdDogdCA8IGJcblx0XHRcdD8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjRcblx0XHRcdDogdCA8IGNcblx0XHRcdFx0PyBjYSAqIHQyIC0gY2IgKiB0ICsgY2Ncblx0XHRcdFx0OiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcblx0cmV0dXJuIHQgPCAwLjUgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKSA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcblx0cmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG5cdGlmICgodCAqPSAyKSA8IDEpIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG5cdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaXJjSW4odCkge1xuXHRyZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNpcmNPdXQodCkge1xuXHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdWJpY0luKHQpIHtcblx0cmV0dXJuIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuXHRyZXR1cm4gdCA8IDAuNVxuXHRcdD8gMC41ICogTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcblx0XHQ6IDAuNSAqXG5cdFx0XHRcdE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG5cdFx0XHRcdE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcblx0XHRcdFx0MS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcblx0cmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcblx0XHQ/IHRcblx0XHQ6IHQgPCAwLjVcblx0XHRcdD8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuXHRcdFx0OiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb0luKHQpIHtcblx0cmV0dXJuIHQgPT09IDAuMCA/IHQgOiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb091dCh0KSB7XG5cdHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcblx0dCAvPSAwLjU7XG5cdGlmICh0IDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0O1xuXHR0LS07XG5cdHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkSW4odCkge1xuXHRyZXR1cm4gdCAqIHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFkT3V0KHQpIHtcblx0cmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gKzguMCAqIE1hdGgucG93KHQsIDQuMCkgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuXHRyZXR1cm4gTWF0aC5wb3codCwgNC4wKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YXJ0T3V0KHQpIHtcblx0cmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWludEluT3V0KHQpIHtcblx0aWYgKCh0ICo9IDIpIDwgMSkgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVpbnRJbih0KSB7XG5cdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcblx0cmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcblx0cmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5lSW4odCkge1xuXHRjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuXHRpZiAoTWF0aC5hYnModikgPCAxZS0xNCkgcmV0dXJuIDE7XG5cdGVsc2UgcmV0dXJuIDEgLSB2O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZU91dCh0KSB7XG5cdHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG4iLCIvKiogQGltcG9ydCB7IEZsaXBQYXJhbXMsIEFuaW1hdGlvbkNvbmZpZyB9IGZyb20gJy4vcHVibGljLmpzJyAqL1xuaW1wb3J0IHsgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXguanMnO1xuXG4vKipcbiAqIFRoZSBmbGlwIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24gb2YgYW4gZWxlbWVudCBhbmQgYW5pbWF0ZXMgYmV0d2VlbiB0aGVtLCB0cmFuc2xhdGluZyB0aGUgeCBhbmQgeSB2YWx1ZXMuXG4gKiBgZmxpcGAgc3RhbmRzIGZvciBbRmlyc3QsIExhc3QsIEludmVydCwgUGxheV0oaHR0cHM6Ly9hZXJvdHdpc3QuY29tL2Jsb2cvZmxpcC15b3VyLWFuaW1hdGlvbnMvKS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7eyBmcm9tOiBET01SZWN0OyB0bzogRE9NUmVjdCB9fSBmcm9tVG9cbiAqIEBwYXJhbSB7RmxpcFBhcmFtc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxpcChub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyA9IHt9KSB7XG5cdHZhciB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAoZCkgPT4gTWF0aC5zcXJ0KGQpICogMTIwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gcGFyYW1zO1xuXG5cdHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cblx0Ly8gZmluZCB0aGUgdHJhbnNmb3JtIG9yaWdpbiwgZXhwcmVzc2VkIGFzIGEgcGFpciBvZiB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxXG5cdHZhciB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHR2YXIgW294LCBveV0gPSBzdHlsZS50cmFuc2Zvcm1PcmlnaW4uc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdCk7XG5cdG94IC89IG5vZGUuY2xpZW50V2lkdGg7XG5cdG95IC89IG5vZGUuY2xpZW50SGVpZ2h0O1xuXG5cdC8vIGNhbGN1bGF0ZSBlZmZlY3Qgb2YgcGFyZW50IHRyYW5zZm9ybXMgYW5kIHpvb21cblx0dmFyIHpvb20gPSBnZXRfem9vbShub2RlKTsgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12aWV3cG9ydC8jZWZmZWN0aXZlLXpvb21cblx0dmFyIHN4ID0gbm9kZS5jbGllbnRXaWR0aCAvIHRvLndpZHRoIC8gem9vbTtcblx0dmFyIHN5ID0gbm9kZS5jbGllbnRIZWlnaHQgLyB0by5oZWlnaHQgLyB6b29tO1xuXG5cdC8vIGZpbmQgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm0gb3JpZ2luXG5cdHZhciBmeCA9IGZyb20ubGVmdCArIGZyb20ud2lkdGggKiBveDtcblx0dmFyIGZ5ID0gZnJvbS50b3AgKyBmcm9tLmhlaWdodCAqIG95O1xuXG5cdC8vIGZpbmQgdGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgdHJhbnNmb3JtIG9yaWdpblxuXHR2YXIgdHggPSB0by5sZWZ0ICsgdG8ud2lkdGggKiBveDtcblx0dmFyIHR5ID0gdG8udG9wICsgdG8uaGVpZ2h0ICogb3k7XG5cblx0Ly8gZmluZCB0aGUgdHJhbnNsYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSB0cmFuc2Zvcm1cblx0dmFyIGR4ID0gKGZ4IC0gdHgpICogc3g7XG5cdHZhciBkeSA9IChmeSAtIHR5KSAqIHN5O1xuXG5cdC8vIGZpbmQgdGhlIHJlbGF0aXZlIHNjYWxlIGF0IHRoZSBzdGFydCBvZiB0aGUgdHJhbnNmb3JtXG5cdHZhciBkc3ggPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG5cdHZhciBkc3kgPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcblxuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uOiB0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicgPyBkdXJhdGlvbihNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKSA6IGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0LCB1KSA9PiB7XG5cdFx0XHR2YXIgeCA9IHUgKiBkeDtcblx0XHRcdHZhciB5ID0gdSAqIGR5O1xuXHRcdFx0dmFyIHN4ID0gdCArIHUgKiBkc3g7XG5cdFx0XHR2YXIgc3kgPSB0ICsgdSAqIGRzeTtcblxuXHRcdFx0cmV0dXJuIGB0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpIHNjYWxlKCR7c3h9LCAke3N5fSk7YDtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldF96b29tKGVsZW1lbnQpIHtcblx0aWYgKCdjdXJyZW50Q1NTWm9vbScgaW4gZWxlbWVudCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKGVsZW1lbnQuY3VycmVudENTU1pvb20pO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50IHwgbnVsbH0gKi9cblx0dmFyIGN1cnJlbnQgPSBlbGVtZW50O1xuXHR2YXIgem9vbSA9IDE7XG5cblx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHR6b29tICo9ICtnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnQpLnpvb207XG5cdFx0Y3VycmVudCA9IC8qKiBAdHlwZSB7RWxlbWVudCB8IG51bGx9ICovIChjdXJyZW50LnBhcmVudEVsZW1lbnQpO1xuXHR9XG5cblx0cmV0dXJuIHpvb207XG59XG4iLCIvKiogQGltcG9ydCB7IEJsdXJQYXJhbXMsIENyb3NzZmFkZVBhcmFtcywgRHJhd1BhcmFtcywgRmFkZVBhcmFtcywgRmx5UGFyYW1zLCBTY2FsZVBhcmFtcywgU2xpZGVQYXJhbXMsIFRyYW5zaXRpb25Db25maWcgfSBmcm9tICcuL3B1YmxpYycgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC93YXJuaW5ncy5qcyc7XG5cbi8qKiBAcGFyYW0ge251bWJlcn0geCAqL1xuY29uc3QgbGluZWFyID0gKHgpID0+IHg7XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdCAqL1xuZnVuY3Rpb24gY3ViaWNfb3V0KHQpIHtcblx0Y29uc3QgZiA9IHQgLSAxLjA7XG5cdHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGN1YmljX2luX291dCh0KSB7XG5cdHJldHVybiB0IDwgMC41ID8gNC4wICogdCAqIHQgKiB0IDogMC41ICogTWF0aC5wb3coMi4wICogdCAtIDIuMCwgMy4wKSArIDEuMDtcbn1cblxuLyoqIEBwYXJhbSB7bnVtYmVyIHwgc3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1tudW1iZXIsIHN0cmluZ119XG4gKi9cbmZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG5cdGNvbnN0IHNwbGl0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCgvXlxccyooLT9bXFxkLl0rKShbXlxcc10qKVxccyokLyk7XG5cdHJldHVybiBzcGxpdCA/IFtwYXJzZUZsb2F0KHNwbGl0WzFdKSwgc3BsaXRbMl0gfHwgJ3B4J10gOiBbLyoqIEB0eXBlIHtudW1iZXJ9ICovICh2YWx1ZSksICdweCddO1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIGEgYGJsdXJgIGZpbHRlciBhbG9uZ3NpZGUgYW4gZWxlbWVudCdzIG9wYWNpdHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0JsdXJQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsdXIoXG5cdG5vZGUsXG5cdHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNfaW5fb3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9ID0ge31cbikge1xuXHRjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cdGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG5cdGNvbnN0IGYgPSBzdHlsZS5maWx0ZXIgPT09ICdub25lJyA/ICcnIDogc3R5bGUuZmlsdGVyO1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0Y29uc3QgW3ZhbHVlLCB1bml0XSA9IHNwbGl0X2Nzc191bml0KGFtb3VudCk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIG9kICogdX07IGZpbHRlcjogJHtmfSBibHVyKCR7dSAqIHZhbHVlfSR7dW5pdH0pO2Bcblx0fTtcbn1cblxuLyoqXG4gKiBBbmltYXRlcyB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50IGZyb20gMCB0byB0aGUgY3VycmVudCBvcGFjaXR5IGZvciBgaW5gIHRyYW5zaXRpb25zIGFuZCBmcm9tIHRoZSBjdXJyZW50IG9wYWNpdHkgdG8gMCBmb3IgYG91dGAgdHJhbnNpdGlvbnMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0ZhZGVQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIgfSA9IHt9KSB7XG5cdGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0KSA9PiBgb3BhY2l0eTogJHt0ICogb31gXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIHggYW5kIHkgcG9zaXRpb25zIGFuZCB0aGUgb3BhY2l0eSBvZiBhbiBlbGVtZW50LiBgaW5gIHRyYW5zaXRpb25zIGFuaW1hdGUgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWVzLCBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byB0aGUgZWxlbWVudCdzIGRlZmF1bHQgdmFsdWVzLiBgb3V0YCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gdGhlIGVsZW1lbnQncyBkZWZhdWx0IHZhbHVlcyB0byB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtGbHlQYXJhbXN9IFtwYXJhbXNdXG4gKiBAcmV0dXJucyB7VHJhbnNpdGlvbkNvbmZpZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZseShcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19vdXQsIHggPSAwLCB5ID0gMCwgb3BhY2l0eSA9IDAgfSA9IHt9XG4pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcblx0Y29uc3QgW3hfdmFsdWUsIHhfdW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh4KTtcblx0Y29uc3QgW3lfdmFsdWUsIHlfdW5pdF0gPSBzcGxpdF9jc3NfdW5pdCh5KTtcblx0cmV0dXJuIHtcblx0XHRkZWxheSxcblx0XHRkdXJhdGlvbixcblx0XHRlYXNpbmcsXG5cdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHhfdmFsdWV9JHt4X3VuaXR9LCAkeygxIC0gdCkgKiB5X3ZhbHVlfSR7eV91bml0fSk7XG5cdFx0XHRvcGFjaXR5OiAke3RhcmdldF9vcGFjaXR5IC0gb2QgKiB1fWBcblx0fTtcbn1cblxudmFyIHNsaWRlX3dhcm5pbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBTbGlkZXMgYW4gZWxlbWVudCBpbiBhbmQgb3V0LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtTbGlkZVBhcmFtc30gW3BhcmFtc11cbiAqIEByZXR1cm5zIHtUcmFuc2l0aW9uQ29uZmlnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19vdXQsIGF4aXMgPSAneScgfSA9IHt9KSB7XG5cdGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuXHRpZiAoREVWICYmICFzbGlkZV93YXJuaW5nICYmIC8oY29udGVudHN8aW5saW5lfHRhYmxlKS8udGVzdChzdHlsZS5kaXNwbGF5KSkge1xuXHRcdHNsaWRlX3dhcm5pbmcgPSB0cnVlO1xuXHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gKHNsaWRlX3dhcm5pbmcgPSBmYWxzZSkpO1xuXHRcdHcudHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5KHN0eWxlLmRpc3BsYXkpO1xuXHR9XG5cblx0Y29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCBwcmltYXJ5X3Byb3BlcnR5ID0gYXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXHRjb25zdCBwcmltYXJ5X3Byb3BlcnR5X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtwcmltYXJ5X3Byb3BlcnR5XSk7XG5cdGNvbnN0IHNlY29uZGFyeV9wcm9wZXJ0aWVzID0gYXhpcyA9PT0gJ3knID8gWyd0b3AnLCAnYm90dG9tJ10gOiBbJ2xlZnQnLCAncmlnaHQnXTtcblx0Y29uc3QgY2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXMgPSBzZWNvbmRhcnlfcHJvcGVydGllcy5tYXAoXG5cdFx0KGUpID0+IC8qKiBAdHlwZSB7J0xlZnQnIHwgJ1JpZ2h0JyB8ICdUb3AnIHwgJ0JvdHRvbSd9ICovIChgJHtlWzBdLnRvVXBwZXJDYXNlKCl9JHtlLnNsaWNlKDEpfWApXG5cdCk7XG5cdGNvbnN0IHBhZGRpbmdfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BwYWRkaW5nJHtjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllc1swXX1gXSk7XG5cdGNvbnN0IHBhZGRpbmdfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuXHRjb25zdCBtYXJnaW5fc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BtYXJnaW4ke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfWBdKTtcblx0Y29uc3QgbWFyZ2luX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuXHRjb25zdCBib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KFxuXHRcdHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfVdpZHRoYF1cblx0KTtcblx0Y29uc3QgYm9yZGVyX3dpZHRoX2VuZF92YWx1ZSA9IHBhcnNlRmxvYXQoXG5cdFx0c3R5bGVbYGJvcmRlciR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19V2lkdGhgXVxuXHQpO1xuXHRyZXR1cm4ge1xuXHRcdGRlbGF5LFxuXHRcdGR1cmF0aW9uLFxuXHRcdGVhc2luZyxcblx0XHRjc3M6ICh0KSA9PlxuXHRcdFx0J292ZXJmbG93OiBoaWRkZW47JyArXG5cdFx0XHRgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG5cdFx0XHRgJHtwcmltYXJ5X3Byb3BlcnR5fTogJHt0ICogcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZX1weDtgICtcblx0XHRcdGBwYWRkaW5nLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBwYWRkaW5nX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX06ICR7dCAqIHBhZGRpbmdfZW5kX3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfTogJHt0ICogbWFyZ2luX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuXHRcdFx0YG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogbWFyZ2luX2VuZF92YWx1ZX1weDtgICtcblx0XHRcdGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZX1weDtgICtcblx0XHRcdGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9lbmRfdmFsdWV9cHg7YCArXG5cdFx0XHRgbWluLSR7cHJpbWFyeV9wcm9wZXJ0eX06IDBgXG5cdH07XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgdGhlIG9wYWNpdHkgYW5kIHNjYWxlIG9mIGFuIGVsZW1lbnQuIGBpbmAgdHJhbnNpdGlvbnMgYW5pbWF0ZSBmcm9tIHRoZSBwcm92aWRlZCB2YWx1ZXMsIHBhc3NlZCBhcyBwYXJhbWV0ZXJzLCB0byBhbiBlbGVtZW50J3MgY3VycmVudCAoZGVmYXVsdCkgdmFsdWVzLiBgb3V0YCB0cmFuc2l0aW9ucyBhbmltYXRlIGZyb20gYW4gZWxlbWVudCdzIGRlZmF1bHQgdmFsdWVzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge1NjYWxlUGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShcblx0bm9kZSxcblx0eyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY19vdXQsIHN0YXJ0ID0gMCwgb3BhY2l0eSA9IDAgfSA9IHt9XG4pIHtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuXHRjb25zdCBzZCA9IDEgLSBzdGFydDtcblx0Y29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSBzZCAqIHV9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSBvZCAqIHV9XG5cdFx0YFxuXHR9O1xufVxuXG4vKipcbiAqIEFuaW1hdGVzIHRoZSBzdHJva2Ugb2YgYW4gU1ZHIGVsZW1lbnQsIGxpa2UgYSBzbmFrZSBpbiBhIHR1YmUuIGBpbmAgdHJhbnNpdGlvbnMgYmVnaW4gd2l0aCB0aGUgcGF0aCBpbnZpc2libGUgYW5kIGRyYXcgdGhlIHBhdGggdG8gdGhlIHNjcmVlbiBvdmVyIHRpbWUuIGBvdXRgIHRyYW5zaXRpb25zIHN0YXJ0IGluIGEgdmlzaWJsZSBzdGF0ZSBhbmQgZ3JhZHVhbGx5IGVyYXNlIHRoZSBwYXRoLiBgZHJhd2Agb25seSB3b3JrcyB3aXRoIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGBnZXRUb3RhbExlbmd0aGAgbWV0aG9kLCBsaWtlIGA8cGF0aD5gIGFuZCBgPHBvbHlsaW5lPmAuXG4gKlxuICogQHBhcmFtIHtTVkdFbGVtZW50ICYgeyBnZXRUb3RhbExlbmd0aCgpOiBudW1iZXIgfX0gbm9kZVxuICogQHBhcmFtIHtEcmF3UGFyYW1zfSBbcGFyYW1zXVxuICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3KG5vZGUsIHsgZGVsYXkgPSAwLCBzcGVlZCwgZHVyYXRpb24sIGVhc2luZyA9IGN1YmljX2luX291dCB9ID0ge30pIHtcblx0bGV0IGxlbiA9IG5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcblx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRpZiAoc3R5bGUuc3Ryb2tlTGluZWNhcCAhPT0gJ2J1dHQnKSB7XG5cdFx0bGVuICs9IHBhcnNlSW50KHN0eWxlLnN0cm9rZVdpZHRoKTtcblx0fVxuXHRpZiAoZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdXJhdGlvbiA9IDgwMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0ZGVsYXksXG5cdFx0ZHVyYXRpb24sXG5cdFx0ZWFzaW5nLFxuXHRcdGNzczogKF8sIHUpID0+IGBcblx0XHRcdHN0cm9rZS1kYXNoYXJyYXk6ICR7bGVufTtcblx0XHRcdHN0cm9rZS1kYXNob2Zmc2V0OiAke3UgKiBsZW59O1xuXHRcdGBcblx0fTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFNcbiAqIEBwYXJhbSB7VH0gdGFyXG4gKiBAcGFyYW0ge1N9IHNyY1xuICogQHJldHVybnMge1QgJiBTfVxuICovXG5mdW5jdGlvbiBhc3NpZ24odGFyLCBzcmMpIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRmb3IgKGNvbnN0IGsgaW4gc3JjKSB0YXJba10gPSBzcmNba107XG5cdHJldHVybiAvKiogQHR5cGUge1QgJiBTfSAqLyAodGFyKTtcbn1cblxuLyoqXG4gKiBUaGUgYGNyb3NzZmFkZWAgZnVuY3Rpb24gY3JlYXRlcyBhIHBhaXIgb2YgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgY2FsbGVkIGBzZW5kYCBhbmQgYHJlY2VpdmVgLiBXaGVuIGFuIGVsZW1lbnQgaXMgJ3NlbnQnLCBpdCBsb29rcyBmb3IgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgYmVpbmcgJ3JlY2VpdmVkJywgYW5kIGdlbmVyYXRlcyBhIHRyYW5zaXRpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSBlbGVtZW50IHRvIGl0cyBjb3VudGVycGFydCdzIHBvc2l0aW9uIGFuZCBmYWRlcyBpdCBvdXQuIFdoZW4gYW4gZWxlbWVudCBpcyAncmVjZWl2ZWQnLCB0aGUgcmV2ZXJzZSBoYXBwZW5zLiBJZiB0aGVyZSBpcyBubyBjb3VudGVycGFydCwgdGhlIGBmYWxsYmFja2AgdHJhbnNpdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7Q3Jvc3NmYWRlUGFyYW1zICYge1xuICogXHRmYWxsYmFjaz86IChub2RlOiBFbGVtZW50LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcywgaW50cm86IGJvb2xlYW4pID0+IFRyYW5zaXRpb25Db25maWc7XG4gKiB9fSBwYXJhbXNcbiAqIEByZXR1cm5zIHtbKG5vZGU6IGFueSwgcGFyYW1zOiBDcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBUcmFuc2l0aW9uQ29uZmlnLCAobm9kZTogYW55LCBwYXJhbXM6IENyb3NzZmFkZVBhcmFtcyAmIHsga2V5OiBhbnk7IH0pID0+ICgpID0+IFRyYW5zaXRpb25Db25maWddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3NmYWRlKHsgZmFsbGJhY2ssIC4uLmRlZmF1bHRzIH0pIHtcblx0LyoqIEB0eXBlIHtNYXA8YW55LCBFbGVtZW50Pn0gKi9cblx0Y29uc3QgdG9fcmVjZWl2ZSA9IG5ldyBNYXAoKTtcblx0LyoqIEB0eXBlIHtNYXA8YW55LCBFbGVtZW50Pn0gKi9cblx0Y29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBmcm9tX25vZGVcblx0ICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG5cdCAqIEBwYXJhbSB7Q3Jvc3NmYWRlUGFyYW1zfSBwYXJhbXNcblx0ICogQHJldHVybnMge1RyYW5zaXRpb25Db25maWd9XG5cdCAqL1xuXHRmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbV9ub2RlLCBub2RlLCBwYXJhbXMpIHtcblx0XHRjb25zdCB7XG5cdFx0XHRkZWxheSA9IDAsXG5cdFx0XHRkdXJhdGlvbiA9IC8qKiBAcGFyYW0ge251bWJlcn0gZCAqLyAoZCkgPT4gTWF0aC5zcXJ0KGQpICogMzAsXG5cdFx0XHRlYXNpbmcgPSBjdWJpY19vdXRcblx0XHR9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuXHRcdGNvbnN0IGZyb20gPSBmcm9tX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0Y29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcblx0XHRjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuXHRcdGNvbnN0IGR3ID0gZnJvbS53aWR0aCAvIHRvLndpZHRoO1xuXHRcdGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG5cdFx0Y29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0Y29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG5cdFx0Y29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuXHRcdHJldHVybiB7XG5cdFx0XHRkZWxheSxcblx0XHRcdGR1cmF0aW9uOiB0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuXHRcdFx0ZWFzaW5nLFxuXHRcdFx0Y3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0ICAgb3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHQgICB0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcblx0XHRcdCAgIHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwke3UgKiBkeX1weCkgc2NhbGUoJHt0ICsgKDEgLSB0KSAqIGR3fSwgJHtcblx0XHRcdFx0XHRcdHQgKyAoMSAtIHQpICogZGhcblx0XHRcdFx0XHR9KTtcblx0XHQgICBgXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBpdGVtc1xuXHQgKiBAcGFyYW0ge01hcDxhbnksIEVsZW1lbnQ+fSBjb3VudGVycGFydHNcblx0ICogQHBhcmFtIHtib29sZWFufSBpbnRyb1xuXHQgKiBAcmV0dXJucyB7KG5vZGU6IGFueSwgcGFyYW1zOiBDcm9zc2ZhZGVQYXJhbXMgJiB7IGtleTogYW55OyB9KSA9PiAoKSA9PiBUcmFuc2l0aW9uQ29uZmlnfVxuXHQgKi9cblx0ZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBpbXByb3ZlIHR5cGluZ3MgKGFyZSB0aGUgcHVibGljIHR5cGVzIHdyb25nPylcblx0XHRyZXR1cm4gKG5vZGUsIHBhcmFtcykgPT4ge1xuXHRcdFx0aXRlbXMuc2V0KHBhcmFtcy5rZXksIG5vZGUpO1xuXHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0aWYgKGNvdW50ZXJwYXJ0cy5oYXMocGFyYW1zLmtleSkpIHtcblx0XHRcdFx0XHRjb25zdCBvdGhlcl9ub2RlID0gY291bnRlcnBhcnRzLmdldChwYXJhbXMua2V5KTtcblx0XHRcdFx0XHRjb3VudGVycGFydHMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRcdHJldHVybiBjcm9zc2ZhZGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAob3RoZXJfbm9kZSksIG5vZGUsIHBhcmFtcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcblx0XHRcdFx0Ly8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG5cdFx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cblx0XHRcdFx0aXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuXHRcdFx0XHRyZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFt0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSwgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKV07XG59XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBmbGlwIH0gZnJvbSBcInN2ZWx0ZS9hbmltYXRlXCJcbiAgaW1wb3J0IHsgZmFkZSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiXG4gIGltcG9ydCB7YWZ0ZXJVcGRhdGV9IGZyb20gJ3N2ZWx0ZSdcblxuICAvLyB0aGUgbGlzdCBvZiBpdGVtcyAgdGhlIHVzZXIgY2FuIHNlbGVjdCBmcm9tXG4gIGV4cG9ydCBsZXQgaXRlbXMgPSBbXVxuXG4gIC8qKlxuICAgKiBmdW5jdGlvbiB0byB1c2UgdG8gZ2V0IGFsbCBpdGVtcyAoYWx0ZXJuYXRpdmUgdG8gcHJvdmlkaW5nIGl0ZW1zKVxuICAgKiBAdHlwZSB7Ym9vbGVhbnxmdW5jdGlvbn1cbiAgICovXG4gIGV4cG9ydCBsZXQgc2VhcmNoRnVuY3Rpb24gPSBmYWxzZVxuXG4gIC8vIGZpZWxkIG9mIGVhY2ggaXRlbSB0aGF0J3MgdXNlZCBmb3IgdGhlIGxhYmVscyBpbiB0aGUgbGlzdFxuICBleHBvcnQgbGV0IGxhYmVsRmllbGROYW1lID0gdW5kZWZpbmVkXG4gIGV4cG9ydCBsZXQga2V5d29yZHNGaWVsZE5hbWUgPSBsYWJlbEZpZWxkTmFtZVxuICBleHBvcnQgbGV0IHZhbHVlRmllbGROYW1lID0gdW5kZWZpbmVkXG5cbiAgZXhwb3J0IGxldCBsYWJlbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBsYWJlbEZpZWxkTmFtZSA/IGl0ZW1bbGFiZWxGaWVsZE5hbWVdIDogaXRlbVxuICB9XG5cbiAgZXhwb3J0IGxldCBrZXl3b3Jkc0Z1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIHJldHVybiBrZXl3b3Jkc0ZpZWxkTmFtZSA/IGl0ZW1ba2V5d29yZHNGaWVsZE5hbWVdIDogbGFiZWxGdW5jdGlvbihpdGVtKVxuICB9XG5cbiAgZXhwb3J0IGxldCB2YWx1ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGl0ZW0sIGZvcmNlU2luZ2xlID0gZmFsc2UpIHtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpdGVtXG4gICAgfVxuICAgIGlmICghbXVsdGlwbGUgfHwgZm9yY2VTaW5nbGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZUZpZWxkTmFtZSA/IGl0ZW1bdmFsdWVGaWVsZE5hbWVdIDogaXRlbVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbS5tYXAoKGkpID0+ICh2YWx1ZUZpZWxkTmFtZSA/IGlbdmFsdWVGaWVsZE5hbWVdIDogaSkpXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0IGxldCBrZXl3b3Jkc0NsZWFuRnVuY3Rpb24gPSBmdW5jdGlvbiAoa2V5d29yZHMpIHtcbiAgICByZXR1cm4ga2V5d29yZHNcbiAgfVxuXG4gIGV4cG9ydCBsZXQgdGV4dENsZWFuRnVuY3Rpb24gPSBmdW5jdGlvbiAodXNlckVudGVyZWRUZXh0KSB7XG4gICAgcmV0dXJuIHVzZXJFbnRlcmVkVGV4dFxuICB9XG5cbiAgLy8gZXZlbnRzXG4gIGV4cG9ydCBsZXQgYmVmb3JlQ2hhbmdlID0gZnVuY3Rpb24gKG9sZFNlbGVjdGVkSXRlbSwgbmV3U2VsZWN0ZWRJdGVtKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBleHBvcnQgbGV0IG9uQ2hhbmdlID0gZnVuY3Rpb24gKG5ld1NlbGVjdGVkSXRlbSkge31cbiAgZXhwb3J0IGxldCBvbkZvY3VzID0gZnVuY3Rpb24gKCkge31cbiAgZXhwb3J0IGxldCBvbkJsdXIgPSBmdW5jdGlvbiAoKSB7fVxuICBleHBvcnQgbGV0IG9uQ3JlYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25DcmVhdGU6IFwiICsgdGV4dClcbiAgICB9XG4gIH1cblxuICAvLyBCZWhhdmlvdXIgcHJvcGVydGllc1xuICBleHBvcnQgbGV0IHNlbGVjdEZpcnN0SWZFbXB0eSA9IGZhbHNlXG4gIGV4cG9ydCBsZXQgbWluQ2hhcmFjdGVyc1RvU2VhcmNoID0gMVxuICBleHBvcnQgbGV0IG1heEl0ZW1zVG9TaG93SW5MaXN0ID0gMFxuICBleHBvcnQgbGV0IG11bHRpcGxlID0gZmFsc2VcbiAgZXhwb3J0IGxldCBjcmVhdGUgPSBmYWxzZVxuXG4gIC8vIGlnbm9yZXMgdGhlIGFjY2VudHMgd2hlbiBtYXRjaGluZyBpdGVtc1xuICBleHBvcnQgbGV0IGlnbm9yZUFjY2VudHMgPSB0cnVlXG5cbiAgLy8gYWxsIHRoZSBpbnB1dCBrZXl3b3JkcyBzaG91bGQgYmUgbWF0Y2hlZCBpbiB0aGUgaXRlbSBrZXl3b3Jkc1xuICBleHBvcnQgbGV0IG1hdGNoQWxsS2V5d29yZHMgPSB0cnVlXG5cbiAgLy8gc29ydHMgdGhlIGl0ZW1zIGJ5IHRoZSBudW1iZXIgb2YgbWF0Y2hpbmsga2V5d29yZHNcbiAgZXhwb3J0IGxldCBzb3J0QnlNYXRjaGVkS2V5d29yZHMgPSBmYWxzZVxuXG4gIC8vIGFsbG93IHVzZXJzIHRvIHVzZSBhIGN1c3RvbSBpdGVtIGZpbHRlciBmdW5jdGlvblxuICBleHBvcnQgbGV0IGl0ZW1GaWx0ZXJGdW5jdGlvbiA9IHVuZGVmaW5lZFxuXG4gIC8vIGFsbG93IHVzZXJzIHRvIHVzZSBhIGN1c3RvbSBpdGVtIHNvcnQgZnVuY3Rpb25cbiAgZXhwb3J0IGxldCBpdGVtU29ydEZ1bmN0aW9uID0gdW5kZWZpbmVkXG5cbiAgLy8gZG8gbm90IGFsbG93IHJlLXNlbGVjdGlvbiBhZnRlciBpbml0aWFsIHNlbGVjdGlvblxuICBleHBvcnQgbGV0IGxvY2sgPSBmYWxzZVxuXG4gIC8vIGRlbGF5IHRvIHdhaXQgYWZ0ZXIgYSBrZXlwcmVzcyB0byBzZWFyY2ggZm9yIG5ldyBpdGVtc1xuICBleHBvcnQgbGV0IGRlbGF5ID0gMFxuXG4gIC8vIHRydWUgdG8gcGVyZm9ybSBsb2NhbCBmaWx0ZXJpbmcgb2YgaXRlbXMsIGV2ZW4gaWYgc2VhcmNoRnVuY3Rpb24gaXMgcHJvdmlkZWRcbiAgZXhwb3J0IGxldCBsb2NhbEZpbHRlcmluZyA9IHRydWVcblxuICAvLyB0cnVlIHRvIHBlcmZvcm0gbG9jYWwgc29ydHlpbmcgb2YgaXRlbXNcbiAgZXhwb3J0IGxldCBsb2NhbFNvcnRpbmcgPSB0cnVlXG5cbiAgLy8gdHJ1ZSB0byBjbGVhbiB0aGUgdXNlciBlbnRlcmVkIHRleHQgKHJlbW92ZXMgc3BhY2VzKVxuICBleHBvcnQgbGV0IGNsZWFuVXNlclRleHQgPSB0cnVlXG5cbiAgLy8gdHJ1ZSB0byBsb3dlcmNhc2UgdGhlIGtleXdvcmRzIGRlcml2ZWQgZnJvbSBlYWNoIGl0ZW0gKGxvd2VyY2FzZSlcbiAgZXhwb3J0IGxldCBsb3dlcmNhc2VLZXl3b3JkcyA9IHRydWVcblxuICAvLyB0cnVlIHRvIGNsb3NlIHRoZSBkcm9wZG93biB3aGVuIHRoZSBjb21wb25lbnQgbG9zZXMgZm9jdXNcbiAgZXhwb3J0IGxldCBjbG9zZU9uQmx1ciA9IGZhbHNlXG5cbiAgLy8gdHJ1ZSB0byBhbGxvdyBzZWxlY3Rpb24gcmVvcmRlcmluZyBieSBkcmFnIGFuZCBkcm9wLCBuZWVkcyBtdWx0aXBsZSB0byB0cnVlXG4gIGV4cG9ydCBsZXQgb3JkZXJhYmxlU2VsZWN0aW9uID0gZmFsc2VcblxuICAvLyBVSSBwcm9wZXJ0aWVzXG5cbiAgLy8gb3B0aW9uIHRvIGhpZGUgdGhlIGRyb3Bkb3duIGFycm93XG4gIGV4cG9ydCBsZXQgaGlkZUFycm93ID0gZmFsc2VcblxuICAvLyBvcHRpb24gdG8gc2hvdyBjbGVhciBzZWxlY3Rpb24gYnV0dG9uXG4gIGV4cG9ydCBsZXQgc2hvd0NsZWFyID0gZmFsc2VcblxuICAvLyB0ZXh0IHRvIHVzZSBmb3IgY2xlYXJcbiAgZXhwb3J0IGxldCBjbGVhclRleHQgPSBcIiYjMTAwMDY7XCJcblxuICAvLyBvcHRpb24gdG8gc2hvdyBsb2FkaW5nIGluZGljYXRvciB3aGVuIHRoZSBhc3luYyBmdW5jdGlvbiBpcyBleGVjdXRlZFxuICBleHBvcnQgbGV0IHNob3dMb2FkaW5nSW5kaWNhdG9yID0gZmFsc2VcblxuICAvLyB0ZXh0IGRpc3BsYXllZCB3aGVuIG5vIGl0ZW1zIG1hdGNoIHRoZSBpbnB1dCB0ZXh0XG4gIGV4cG9ydCBsZXQgbm9SZXN1bHRzVGV4dCA9IFwiTm8gcmVzdWx0cyBmb3VuZFwiXG5cbiAgLy8gdGV4dCBkaXNwbGF5ZWQgd2hlbiBhc3luYyBkYXRhIGlzIGJlaW5nIGxvYWRlZFxuICBleHBvcnQgbGV0IGxvYWRpbmdUZXh0ID0gXCJMb2FkaW5nIHJlc3VsdHMuLi5cIlxuXG4gIC8vIHRleHQgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgdGV4dCBtYXRjaGVzIGEgbG90IG9mIGl0ZW1zIGFuZCB3ZSBjYW4gbm90IGRpc3BsYXkgdGhlbSBhbGwgaW4gdGhlIGRyb3Bkb3duXG4gIGV4cG9ydCBsZXQgbW9yZUl0ZW1zVGV4dCA9IFwiaXRlbXMgbm90IHNob3duXCJcblxuICAvLyB0ZXh0IGRpc3BsYXllZCB3aGVuIGFzeW5jIGRhdGEgaXMgYmVpbmcgbG9hZGVkXG4gIGV4cG9ydCBsZXQgY3JlYXRlVGV4dCA9IFwiTm90IGZvdW5kLCBhZGQgYW55d2F5P1wiXG5cbiAgLy8gdGhlIHRleHQgZGlzcGxheWVkIHdoZW4gbm8gb3B0aW9uIGlzIHNlbGVjdGVkXG4gIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXIgPSB1bmRlZmluZWRcblxuICAvLyBhcHBseSBhIGNsYXNzTmFtZSB0byB0aGUgY29udHJvbFxuICBleHBvcnQgbGV0IGNsYXNzTmFtZSA9IHVuZGVmaW5lZFxuXG4gIC8vIEhUTUwgaW5wdXQgVUkgcHJvcGVydGllc1xuICAvLyBhcHBseSBhIGNsYXNzTmFtZSB0byB0aGUgaW5wdXQgY29udHJvbFxuICBleHBvcnQgbGV0IGlucHV0Q2xhc3NOYW1lID0gdW5kZWZpbmVkXG4gIC8vIGFwcGx5IGEgaWQgdG8gdGhlIGlucHV0IGNvbnRyb2xcbiAgZXhwb3J0IGxldCBpbnB1dElkID0gdW5kZWZpbmVkXG4gIC8vIGdlbmVyYXRlIGFuIEhUTUwgaW5wdXQgd2l0aCB0aGlzIG5hbWVcbiAgZXhwb3J0IGxldCBuYW1lID0gdW5kZWZpbmVkXG4gIC8vIGdlbmVyYXRlIGEgPHNlbGVjdD4gdGFnIHRoYXQgaG9sZHMgdGhlIHZhbHVlXG4gIGV4cG9ydCBsZXQgc2VsZWN0TmFtZSA9IHVuZGVmaW5lZFxuICAvLyBhcHBseSBhIGlkIHRvIHRoZSA8c2VsZWN0PlxuICBleHBvcnQgbGV0IHNlbGVjdElkID0gdW5kZWZpbmVkXG4gIC8vIGFkZCB0aGUgdGl0bGUgdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZFxuICAvLyBlbmFibGUgdGhlIGh0bWw1IGF1dG9jb21wbGV0aW9uIHRvIHRoZSBIVE1MIGlucHV0XG4gIGV4cG9ydCBsZXQgaHRtbDVhdXRvY29tcGxldGUgPSB1bmRlZmluZWRcbiAgLy8gZW5hYmxlIHRoZSBodG1sNSBhdXRvY29tcGxldGlvbiB2YWx1ZVxuICBleHBvcnQgbGV0IGF1dG9jb21wbGV0ZU9mZlZhbHVlID0gXCJvZmZcIlxuICAvLyBtYWtlIHRoZSBpbnB1dCByZWFkb25seVxuICBleHBvcnQgbGV0IHJlYWRvbmx5ID0gdW5kZWZpbmVkXG4gIC8vIGFwcGx5IGEgY2xhc3NOYW1lIHRvIHRoZSBkcm9wZG93biBkaXZcbiAgZXhwb3J0IGxldCBkcm9wZG93bkNsYXNzTmFtZSA9IHVuZGVmaW5lZFxuICAvLyBhZGRzIHRoZSBkaXNhYmxlZCB0YWcgdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlXG4gIC8vIHJlbW92ZSB0aGUgYXV0b2NvbXBsZXRlLWlucHV0IGNsYXNzIG9mIHRoZSBpbnB1dFxuICBleHBvcnQgbGV0IG5vSW5wdXRTdHlsZXMgPSBmYWxzZVxuICAvLyBhZGRzIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgdG8gdGhlIEhUTUwgaW5wdXRcbiAgZXhwb3J0IGxldCByZXF1aXJlZCA9IG51bGxcblxuICBleHBvcnQgbGV0IGRlYnVnID0gZmFsc2VcblxuICAvLyBhZGQgdGFiaW5kZXggc3VwcG9ydCBmb3IgdGhlIGlucHV0XG4gIC8vIHNldCBzdGFuZGFyZCB0byAwOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XG4gIGV4cG9ydCBsZXQgdGFiaW5kZXggPSAwXG5cbiAgLy8gLS0tIFB1YmxpYyBTdGF0ZSAtLS0tXG5cbiAgLy8gc2VsZWN0ZWQgaXRlbSBzdGF0ZVxuICBleHBvcnQgbGV0IHNlbGVjdGVkSXRlbSA9IG11bHRpcGxlID8gW10gOiB1bmRlZmluZWRcbiAgZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZFxuICBleHBvcnQgbGV0IGhpZ2hsaWdodGVkSXRlbSA9IHVuZGVmaW5lZFxuXG4gIC8vIC0tLSBJbnRlcm5hbCBTdGF0ZSAtLS0tXG4gIGNvbnN0IHVuaXF1ZUlkID0gXCJzYXV0b2NvbXBsZXRlLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMClcblxuICAvLyBIVE1MIGVsZW1lbnRzXG4gIGxldCBpbnB1dFxuICBsZXQgbGlzdFxuICBsZXQgaW5wdXRDb250YWluZXJcblxuICAvLyBVSSBzdGF0ZVxuICBsZXQgb3BlbmVkID0gZmFsc2VcbiAgbGV0IGxvYWRpbmcgPSBmYWxzZVxuICBsZXQgaGlnaGxpZ2h0SW5kZXggPSAtMVxuICBleHBvcnQgbGV0IHRleHQgPSB1bmRlZmluZWRcbiAgbGV0IGZpbHRlcmVkVGV4dExlbmd0aCA9IDBcblxuICAvLyB2aWV3IG1vZGVsXG4gIGxldCBmaWx0ZXJlZExpc3RJdGVtc1xuICBsZXQgbGlzdEl0ZW1zID0gW11cblxuICAvLyByZXF1ZXN0cy9yZXNwb25zZXMgY291bnRlcnNcbiAgbGV0IGxhc3RSZXF1ZXN0SWQgPSAwXG4gIGxldCBsYXN0UmVzcG9uc2VJZCA9IDBcblxuICAvLyBvdGhlciBzdGF0ZVxuICBsZXQgaW5wdXREZWxheVRpbWVvdXRcblxuICBsZXQgc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUgPSBmYWxzZTtcblxuICAvLyAtLS0gTGlmZWN5Y2xlIGV2ZW50cyAtLS1cblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYoc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUpIHtcbiAgICAgIHNldFNjcm9sbEF3YXJlTGlzdFBvc2l0aW9uKClcbiAgICB9XG4gICAgc2V0UG9zaXRpb25Pbk5leHRVcGRhdGUgPSBmYWxzZVxuICB9KVxuXG4gIC8vIC0tLSBGdW5jdGlvbnMgLS0tXG5cbiAgZnVuY3Rpb24gc2FmZUZ1bmN0aW9uKHRoZUZ1bmN0aW9uLCBhcmd1bWVudCkge1xuICAgIGlmICh0eXBlb2YgdGhlRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5vdCBhIGZ1bmN0aW9uOiBcIiArIHRoZUZ1bmN0aW9uICsgXCIsIGFyZ3VtZW50OiBcIiArIGFyZ3VtZW50KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgICBsZXQgcmVzdWx0XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoZUZ1bmN0aW9uKGFyZ3VtZW50KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRXJyb3IgZXhlY3V0aW5nIEF1dG9jb21wbGV0ZSBmdW5jdGlvbiBvbiB2YWx1ZTogXCIgKyBhcmd1bWVudCArIFwiIGZ1bmN0aW9uOiBcIiArIHRoZUZ1bmN0aW9uXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVTdHJpbmdGdW5jdGlvbih0aGVGdW5jdGlvbiwgYXJndW1lbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gc2FmZUZ1bmN0aW9uKHRoZUZ1bmN0aW9uLCBhcmd1bWVudClcbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgfHwgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBcIlwiXG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQudG9TdHJpbmcoKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlTGFiZWxGdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJsYWJlbEZ1bmN0aW9uOiBcIiArIGxhYmVsRnVuY3Rpb24pO1xuICAgIC8vIGNvbnNvbGUubG9nKFwic2FmZUxhYmVsRnVuY3Rpb24sIGl0ZW06IFwiICsgaXRlbSk7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdGdW5jdGlvbihsYWJlbEZ1bmN0aW9uLCBpdGVtKVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZUtleXdvcmRzRnVuY3Rpb24oaXRlbSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwic2FmZUtleXdvcmRzRnVuY3Rpb25cIik7XG4gICAgY29uc3Qga2V5d29yZHMgPSBzYWZlU3RyaW5nRnVuY3Rpb24oa2V5d29yZHNGdW5jdGlvbiwgaXRlbSlcbiAgICBsZXQgcmVzdWx0ID0gc2FmZVN0cmluZ0Z1bmN0aW9uKGtleXdvcmRzQ2xlYW5GdW5jdGlvbiwga2V5d29yZHMpXG4gICAgcmVzdWx0ID0gbG93ZXJjYXNlS2V5d29yZHMgPyByZXN1bHQudG9Mb3dlckNhc2UoKS50cmltKCkgOiByZXN1bHRcbiAgICBpZiAoaWdub3JlQWNjZW50cykge1xuICAgICAgcmVzdWx0ID0gcmVtb3ZlQWNjZW50cyhyZXN1bHQpXG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RlZCBrZXl3b3JkczogJ1wiICsgcmVzdWx0ICsgXCInIGZyb20gaXRlbTogXCIgKyBKU09OLnN0cmluZ2lmeShpdGVtKSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZUxpc3RJdGVtcygpIHtcbiAgICBsZXQgdGltZXJJZFxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgdGltZXJJZCA9IGBBdXRvY29tcGxldGUgcHJlcGFyZSBsaXN0ICR7aW5wdXRJZCA/IGAoaWQ6ICR7aW5wdXRJZH0pYCA6IFwiXCJ9YFxuICAgICAgY29uc29sZS50aW1lKHRpbWVySWQpXG4gICAgICBjb25zb2xlLmxvZyhcIlByZXBhcmUgaXRlbXMgdG8gc2VhcmNoXCIpXG4gICAgICBjb25zb2xlLmxvZyhcIml0ZW1zOiBcIiArIEpTT04uc3RyaW5naWZ5KGl0ZW1zKSlcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJBdXRvY29tcGxldGUgaXRlbXMgLyBzZWFyY2ggZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYXJyYXkgYnV0XCIsIGl0ZW1zKVxuICAgICAgaXRlbXMgPSBbXVxuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aCA9IGl0ZW1zID8gaXRlbXMubGVuZ3RoIDogMFxuICAgIGxpc3RJdGVtcyA9IG5ldyBBcnJheShsZW5ndGgpXG5cbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbSA9IGdldExpc3RJdGVtKGl0ZW0pXG4gICAgICAgIGlmIChsaXN0SXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmRlZmluZWQgaXRlbSBmb3I6IFwiLCBpdGVtKVxuICAgICAgICB9XG4gICAgICAgIGxpc3RJdGVtc1tpXSA9IGxpc3RJdGVtXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGxpc3RJdGVtcy5sZW5ndGggKyBcIiBpdGVtcyB0byBzZWFyY2hcIilcbiAgICAgIGNvbnNvbGUudGltZUVuZCh0aW1lcklkKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpc3RJdGVtKGl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8ga2V5d29yZHMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGl0ZW1cbiAgICAgIGtleXdvcmRzOiBsb2NhbEZpbHRlcmluZyA/IHNhZmVLZXl3b3Jkc0Z1bmN0aW9uKGl0ZW0pIDogW10sXG4gICAgICAvLyBpdGVtIGxhYmVsXG4gICAgICBsYWJlbDogc2FmZUxhYmVsRnVuY3Rpb24oaXRlbSksXG4gICAgICAvLyBzdG9yZSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpYWwgaXRlbVxuICAgICAgaXRlbTogaXRlbSxcbiAgICB9XG4gIH1cblxuICAvLyAtLSBSZWFjdGl2aXR5IC0tXG4gICQ6IGl0ZW1zLCBzZWFyY2hGdW5jdGlvbiB8fCBwcmVwYXJlTGlzdEl0ZW1zKClcblxuICBmdW5jdGlvbiBvblNlbGVjdGVkSXRlbUNoYW5nZWQoKSB7XG4gICAgdmFsdWUgPSB2YWx1ZUZ1bmN0aW9uKHNlbGVjdGVkSXRlbSlcbiAgICBpZiAoc2VsZWN0ZWRJdGVtICYmICFtdWx0aXBsZSkge1xuICAgICAgdGV4dCA9IHNhZmVMYWJlbEZ1bmN0aW9uKHNlbGVjdGVkSXRlbSlcbiAgICB9XG5cbiAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgIG9uQ2hhbmdlKHNlbGVjdGVkSXRlbSlcbiAgfVxuXG4gICQ6IHNlbGVjdGVkSXRlbSwgb25TZWxlY3RlZEl0ZW1DaGFuZ2VkKClcblxuICAkOiBoaWdobGlnaHRlZEl0ZW0gPVxuICAgIGZpbHRlcmVkTGlzdEl0ZW1zICYmXG4gICAgaGlnaGxpZ2h0SW5kZXggJiZcbiAgICBoaWdobGlnaHRJbmRleCA+PSAwICYmXG4gICAgaGlnaGxpZ2h0SW5kZXggPCBmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGhcbiAgICAgID8gZmlsdGVyZWRMaXN0SXRlbXNbaGlnaGxpZ2h0SW5kZXhdLml0ZW1cbiAgICAgIDogbnVsbFxuXG4gICQ6IHNob3dMaXN0ID0gb3BlbmVkICYmICgoaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkgfHwgZmlsdGVyZWRUZXh0TGVuZ3RoID4gMClcblxuICAkOiBoYXNTZWxlY3Rpb24gPVxuICAgIChtdWx0aXBsZSAmJiBzZWxlY3RlZEl0ZW0gJiYgc2VsZWN0ZWRJdGVtLmxlbmd0aCA+IDApIHx8ICghbXVsdGlwbGUgJiYgc2VsZWN0ZWRJdGVtKVxuXG4gICQ6IGNsZWFyYWJsZSA9IHNob3dDbGVhciB8fCAoKGxvY2sgfHwgbXVsdGlwbGUpICYmIGhhc1NlbGVjdGlvbilcblxuICAkOiBsb2NrZWQgPSBsb2NrICYmIGhhc1NlbGVjdGlvblxuXG4gIGZ1bmN0aW9uIHByZXBhcmVVc2VyRW50ZXJlZFRleHQodXNlckVudGVyZWRUZXh0KSB7XG4gICAgaWYgKHVzZXJFbnRlcmVkVGV4dCA9PT0gdW5kZWZpbmVkIHx8IHVzZXJFbnRlcmVkVGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG5cbiAgICBpZiAoIWNsZWFuVXNlclRleHQpIHtcbiAgICAgIHJldHVybiB1c2VyRW50ZXJlZFRleHRcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0RmlsdGVyZWQgPSB1c2VyRW50ZXJlZFRleHQucmVwbGFjZSgvWyYvXFxcXCMsKygpJH4lLidcIjoqPzw+e31dL2csIFwiIFwiKS50cmltKClcblxuICAgIGNvbnN0IGNsZWFuVXNlckVudGVyZWRUZXh0ID0gc2FmZVN0cmluZ0Z1bmN0aW9uKHRleHRDbGVhbkZ1bmN0aW9uLCB0ZXh0RmlsdGVyZWQpXG4gICAgY29uc3QgdGV4dFRyaW1tZWQgPSBsb3dlcmNhc2VLZXl3b3Jkc1xuICAgICAgPyBjbGVhblVzZXJFbnRlcmVkVGV4dC50b0xvd2VyQ2FzZSgpLnRyaW0oKVxuICAgICAgOiBjbGVhblVzZXJFbnRlcmVkVGV4dC50cmltKClcblxuICAgIHJldHVybiB0ZXh0VHJpbW1lZFxuICB9XG5cbiAgZnVuY3Rpb24gbnVtYmVyT2ZNYXRjaGVzKGxpc3RJdGVtLCBzZWFyY2hXb3Jkcykge1xuICAgIGlmICghbGlzdEl0ZW0pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgY29uc3QgaXRlbUtleXdvcmRzID0gbGlzdEl0ZW0ua2V5d29yZHNcblxuICAgIGxldCBtYXRjaGVzID0gMFxuICAgIHNlYXJjaFdvcmRzLmZvckVhY2goKHNlYXJjaFdvcmQpID0+IHtcbiAgICAgIGlmIChpdGVtS2V5d29yZHMuaW5jbHVkZXMoc2VhcmNoV29yZCkpIHtcbiAgICAgICAgbWF0Y2hlcysrXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZWFyY2goKSB7XG4gICAgbGV0IHRpbWVySWRcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIHRpbWVySWQgPSBgQXV0b2NvbXBsZXRlIHNlYXJjaCAke2lucHV0SWQgPyBgKGlkOiAke2lucHV0SWR9KWAgOiBcIlwifWBcbiAgICAgIGNvbnNvbGUudGltZSh0aW1lcklkKVxuICAgICAgY29uc29sZS5sb2coXCJTZWFyY2hpbmcgdXNlciBlbnRlcmVkIHRleHQ6ICdcIiArIHRleHQgKyBcIidcIilcbiAgICB9XG5cbiAgICBsZXQgdGV4dEZpbHRlcmVkID0gcHJlcGFyZVVzZXJFbnRlcmVkVGV4dCh0ZXh0KVxuICAgIGlmIChtaW5DaGFyYWN0ZXJzVG9TZWFyY2ggPiAxICYmIHRleHRGaWx0ZXJlZC5sZW5ndGggPCBtaW5DaGFyYWN0ZXJzVG9TZWFyY2gpIHtcbiAgICAgIHRleHRGaWx0ZXJlZCA9IFwiXCJcbiAgICB9XG4gICAgZmlsdGVyZWRUZXh0TGVuZ3RoID0gdGV4dEZpbHRlcmVkLmxlbmd0aFxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkNoYW5nZWQgdXNlciBlbnRlcmVkIHRleHQgJ1wiICsgdGV4dCArIFwiJyBpbnRvICdcIiArIHRleHRGaWx0ZXJlZCArIFwiJ1wiKVxuICAgIH1cblxuICAgIC8vIGlmIG5vIHNlYXJjaCB0ZXh0IGxvYWQgYWxsIGl0ZW1zXG4gICAgaWYgKHRleHRGaWx0ZXJlZCA9PT0gXCJcIikge1xuICAgICAgaWYgKHNlYXJjaEZ1bmN0aW9uKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byByZXJ1biB0aGUgc2VhcmNoXG4gICAgICAgIGl0ZW1zID0gW11cbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIGVudGVyZWQgdGV4dCBpcyBlbXB0eSBjbGVhciBsaXN0IG9mIGl0ZW1zXCIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBlbnRlcmVkIHRleHQgaXMgZW1wdHkgc2V0IHRoZSBsaXN0IG9mIGl0ZW1zIHRvIGFsbCBpdGVtc1wiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VJZk1pbkNoYXJzVG9TZWFyY2hSZWFjaGVkKCkpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS50aW1lRW5kKHRpbWVySWQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZWFyY2hGdW5jdGlvbikge1xuICAgICAgLy8gaW50ZXJuYWwgc2VhcmNoXG4gICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXh0ZXJuYWwgc2VhcmNoIHdoaWNoIHByb3ZpZGVzIGl0ZW1zXG4gICAgICBsYXN0UmVxdWVzdElkID0gbGFzdFJlcXVlc3RJZCArIDFcbiAgICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0SWQgPSBsYXN0UmVxdWVzdElkXG4gICAgICBsb2FkaW5nID0gdHJ1ZVxuXG4gICAgICAvLyBzZWFyY2hGdW5jdGlvbiBpcyBhIGdlbmVyYXRvclxuICAgICAgaWYgKHNlYXJjaEZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc2VhcmNoRnVuY3Rpb24odGV4dEZpbHRlcmVkLCBtYXhJdGVtc1RvU2hvd0luTGlzdCkpIHtcbiAgICAgICAgICAvLyBhIGNodW5rIG9mIGFuIG9sZCByZXNwb25zZTogdGhyb3cgaXQgYXdheVxuICAgICAgICAgIGlmIChjdXJyZW50UmVxdWVzdElkIDwgbGFzdFJlc3BvbnNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGEgY2h1bmsgZm9yIGEgbmV3IHJlc3BvbnNlOiByZXNldCB0aGUgaXRlbSBsaXN0XG4gICAgICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0SWQgPiBsYXN0UmVzcG9uc2VJZCkge1xuICAgICAgICAgICAgaXRlbXMgPSBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3RSZXNwb25zZUlkID0gY3VycmVudFJlcXVlc3RJZFxuICAgICAgICAgIGl0ZW1zID0gWy4uLml0ZW1zLCAuLi5jaHVua11cbiAgICAgICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXJlIHdhcyBub3RoaW5nIGluIHRoZSBjaHVua1xuICAgICAgICBpZiAobGFzdFJlc3BvbnNlSWQgPCBjdXJyZW50UmVxdWVzdElkKSB7XG4gICAgICAgICAgbGFzdFJlc3BvbnNlSWQgPSBjdXJyZW50UmVxdWVzdElkXG4gICAgICAgICAgaXRlbXMgPSBbXVxuICAgICAgICAgIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlYXJjaEZ1bmN0aW9uIGlzIGEgcmVndWxhciBmdW5jdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzZWFyY2hGdW5jdGlvbih0ZXh0RmlsdGVyZWQsIG1heEl0ZW1zVG9TaG93SW5MaXN0KVxuXG4gICAgICAgIC8vIElmIGEgcmVzcG9uc2UgdG8gYSBuZXdlciByZXF1ZXN0IGhhcyBiZWVuIHJlY2VpdmVkXG4gICAgICAgIC8vIHdoaWxlIHJlc3BvbnNlcyB0byB0aGlzIHJlcXVlc3Qgd2VyZSBiZWluZyBsb2FkZWQsXG4gICAgICAgIC8vIHRoZW4gd2UgY2FuIGp1c3QgdGhyb3cgYXdheSB0aGlzIG91dGRhdGVkIHJlc3VsdHMuXG4gICAgICAgIGlmIChjdXJyZW50UmVxdWVzdElkIDwgbGFzdFJlc3BvbnNlSWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RSZXNwb25zZUlkID0gY3VycmVudFJlcXVlc3RJZFxuICAgICAgICBpdGVtcyA9IHJlc3VsdFxuICAgICAgICBwcm9jZXNzTGlzdEl0ZW1zKHRleHRGaWx0ZXJlZClcbiAgICAgIH1cblxuICAgICAgbG9hZGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQodGltZXJJZClcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VhcmNoIGZvdW5kIFwiICsgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoICsgXCIgaXRlbXNcIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0SXRlbUZpbHRlckZ1bmN0aW9uKGxpc3RJdGVtLCBzZWFyY2hXb3Jkcykge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBudW1iZXJPZk1hdGNoZXMobGlzdEl0ZW0sIHNlYXJjaFdvcmRzKVxuICAgIGlmIChtYXRjaEFsbEtleXdvcmRzKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyA+PSBzZWFyY2hXb3Jkcy5sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hdGNoZXMgPiAwXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEl0ZW1Tb3J0RnVuY3Rpb24ob2JqMSwgb2JqMiwgc2VhcmNoV29yZHMpIHtcbiAgICByZXR1cm4gbnVtYmVyT2ZNYXRjaGVzKG9iajIsIHNlYXJjaFdvcmRzKSAtIG51bWJlck9mTWF0Y2hlcyhvYmoxLCBzZWFyY2hXb3JkcylcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMaXN0SXRlbXModGV4dEZpbHRlcmVkKSB7XG4gICAgLy8gY2xlYW5zLCBmaWx0ZXJzLCBvcmRlcnMsIGFuZCBoaWdobGlnaHRzIHRoZSBsaXN0IGl0ZW1zXG4gICAgcHJlcGFyZUxpc3RJdGVtcygpXG5cbiAgICBjb25zdCB0ZXh0RmlsdGVyZWRXaXRob3V0QWNjZW50cyA9IGlnbm9yZUFjY2VudHMgPyByZW1vdmVBY2NlbnRzKHRleHRGaWx0ZXJlZCkgOiB0ZXh0RmlsdGVyZWRcbiAgICBjb25zdCBzZWFyY2hXb3JkcyA9IHRleHRGaWx0ZXJlZFdpdGhvdXRBY2NlbnRzLnNwbGl0KC9cXHMrL2cpLmZpbHRlcigod29yZCkgPT4gd29yZCAhPT0gXCJcIilcblxuICAgIC8vIGxvY2FsIHNlYXJjaFxuICAgIGxldCB0ZW1wZmlsdGVyZWRMaXN0SXRlbXNcbiAgICBpZiAobG9jYWxGaWx0ZXJpbmcpIHtcbiAgICAgIGlmIChpdGVtRmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgICBpdGVtRmlsdGVyRnVuY3Rpb24oaXRlbS5pdGVtLCBzZWFyY2hXb3JkcylcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgICBkZWZhdWx0SXRlbUZpbHRlckZ1bmN0aW9uKGl0ZW0sIHNlYXJjaFdvcmRzKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhbFNvcnRpbmcpIHtcbiAgICAgICAgaWYgKGl0ZW1Tb3J0RnVuY3Rpb24pIHtcbiAgICAgICAgICB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMgPSB0ZW1wZmlsdGVyZWRMaXN0SXRlbXMuc29ydCgoaXRlbTEsIGl0ZW0yKSA9PlxuICAgICAgICAgICAgaXRlbVNvcnRGdW5jdGlvbihpdGVtMS5pdGVtLCBpdGVtMi5pdGVtLCBzZWFyY2hXb3JkcylcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNvcnRCeU1hdGNoZWRLZXl3b3Jkcykge1xuICAgICAgICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gdGVtcGZpbHRlcmVkTGlzdEl0ZW1zLnNvcnQoKGl0ZW0xLCBpdGVtMikgPT5cbiAgICAgICAgICAgICAgZGVmYXVsdEl0ZW1Tb3J0RnVuY3Rpb24oaXRlbTEsIGl0ZW0yLCBzZWFyY2hXb3JkcylcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGZpbHRlcmVkTGlzdEl0ZW1zID0gbGlzdEl0ZW1zXG4gICAgfVxuXG4gICAgY29uc3QgaGxmaWx0ZXIgPSBoaWdobGlnaHRGaWx0ZXIoc2VhcmNoV29yZHMsIFwibGFiZWxcIilcbiAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IHRlbXBmaWx0ZXJlZExpc3RJdGVtcy5tYXAoaGxmaWx0ZXIpXG4gICAgY2xvc2VJZk1pbkNoYXJzVG9TZWFyY2hSZWFjaGVkKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gJDogdGV4dCwgc2VhcmNoKCk7XG5cbiAgZnVuY3Rpb24gYWZ0ZXJDcmVhdGUoY3JlYXRlZEl0ZW0pIHtcbiAgICBsZXQgbGlzdEl0ZW1cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiY3JlYXRlZEl0ZW1cIiwgY3JlYXRlZEl0ZW0pXG4gICAgfVxuICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY3JlYXRlZEl0ZW0pIHtcbiAgICAgIHByZXBhcmVMaXN0SXRlbXMoKVxuICAgICAgZmlsdGVyZWRMaXN0SXRlbXMgPSBsaXN0SXRlbXNcbiAgICAgIGxldCBpbmRleCA9IGZpbmRJdGVtSW5kZXgoY3JlYXRlZEl0ZW0sIGZpbHRlcmVkTGlzdEl0ZW1zKVxuXG4gICAgICAvLyBpZiB0aGUgaXRlbXMgYXJyYXkgd2FzIG5vdCB1cGRhdGVkLCBhZGQgdGhlIGNyZWF0ZWQgaXRlbSBtYW51YWxseVxuICAgICAgaWYgKGluZGV4IDw9IDApIHtcbiAgICAgICAgaXRlbXMgPSBbY3JlYXRlZEl0ZW1dXG4gICAgICAgIHByZXBhcmVMaXN0SXRlbXMoKVxuICAgICAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgICAgICBpbmRleCA9IDBcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaGlnaGxpZ2h0SW5kZXggPSBpbmRleFxuICAgICAgICBsaXN0SXRlbSA9IGZpbHRlcmVkTGlzdEl0ZW1zW2hpZ2hsaWdodEluZGV4XVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdEl0ZW1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdExpc3RJdGVtKGxpc3RJdGVtKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNlbGVjdExpc3RJdGVtXCIsIGxpc3RJdGVtKVxuICAgIH1cbiAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGxpc3RJdGVtICYmIGNyZWF0ZSkge1xuICAgICAgLy8gYWxsb3cgdW5kZWZpbmVkIGl0ZW1zIGlmIGNyZWF0ZSBpcyBlbmFibGVkXG4gICAgICBjb25zdCBjcmVhdGVkSXRlbSA9IG9uQ3JlYXRlKHRleHQpXG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNyZWF0ZWRJdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlZEl0ZW0udGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY3JlYXRlZEl0ZW0udGhlbigobmV3SXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBuZXdJdGVtKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gYWZ0ZXJDcmVhdGUobmV3SXRlbSlcbiAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBuZXdMaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdExpc3RJdGVtKG5ld0xpc3RJdGVtKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RJdGVtID0gYWZ0ZXJDcmVhdGUoY3JlYXRlZEl0ZW0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGxpc3RJdGVtKSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYGxpc3RJdGVtIGlzIHVuZGVmaW5lZC4gQ2FuIG5vdCBzZWxlY3QuYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgbmV3U2VsZWN0ZWRJdGVtID0gbGlzdEl0ZW0uaXRlbVxuICAgIGlmIChiZWZvcmVDaGFuZ2Uoc2VsZWN0ZWRJdGVtLCBuZXdTZWxlY3RlZEl0ZW0pKSB7XG4gICAgICAvLyBzaW1wbGUgc2VsZWN0aW9uXG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IHVuZGVmaW5lZCAvLyB0cmlnZ2VycyBjaGFuZ2UgZXZlbiBpZiB0aGUgdGhlIHNhbWUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAgICBzZWxlY3RlZEl0ZW0gPSBuZXdTZWxlY3RlZEl0ZW1cbiAgICAgIH1cbiAgICAgIC8vIGZpcnN0IHNlbGVjdGlvbiBvZiBtdWx0aXBsZSBvbmVzXG4gICAgICBlbHNlIGlmICghc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IFtuZXdTZWxlY3RlZEl0ZW1dXG4gICAgICB9XG4gICAgICAvLyBzZWxlY3Rpbmcgc29tZXRoaW5nIGFscmVhZHkgc2VsZWN0ZWQgPT4gdW5zZWxlY3QgaXRcbiAgICAgIGVsc2UgaWYgKHNlbGVjdGVkSXRlbS5pbmNsdWRlcyhuZXdTZWxlY3RlZEl0ZW0pKSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkSXRlbS5maWx0ZXIoKGkpID0+IGkgIT09IG5ld1NlbGVjdGVkSXRlbSlcbiAgICAgIH1cbiAgICAgIC8vIGFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIHNlbGVjdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IFsuLi5zZWxlY3RlZEl0ZW0sIG5ld1NlbGVjdGVkSXRlbV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEl0ZW0oKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNlbGVjdEl0ZW1cIiwgaGlnaGxpZ2h0SW5kZXgpXG4gICAgfVxuICAgIGNvbnN0IGxpc3RJdGVtID0gZmlsdGVyZWRMaXN0SXRlbXNbaGlnaGxpZ2h0SW5kZXhdXG4gICAgaWYgKHNlbGVjdExpc3RJdGVtKGxpc3RJdGVtKSkge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0TGlzdEl0ZW0gdHJ1ZSwgY2xvc2luZ1wiKVxuICAgICAgfVxuICAgICAgY2xvc2UoKVxuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIHRleHQgPSBcIlwiXG4gICAgICAgIGlucHV0LmZvY3VzKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0TGlzdEl0ZW0gZmFsc2UsIG5vdCBjbG9zaW5nXCIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXAoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInVwXCIpXG4gICAgfVxuXG4gICAgb3BlbigpXG4gICAgaWYgKGhpZ2hsaWdodEluZGV4ID4gMCkge1xuICAgICAgaGlnaGxpZ2h0SW5kZXgtLVxuICAgIH1cblxuICAgIGhpZ2hsaWdodCgpXG4gIH1cblxuICBmdW5jdGlvbiBkb3duKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJkb3duXCIpXG4gICAgfVxuXG4gICAgb3BlbigpXG4gICAgaWYgKGhpZ2hsaWdodEluZGV4IDwgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgaGlnaGxpZ2h0SW5kZXgrK1xuICAgIH1cblxuICAgIGhpZ2hsaWdodCgpXG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHQoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImhpZ2hsaWdodFwiKVxuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5ID0gXCIuc2VsZWN0ZWRcIlxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJTZWFjaGluZyBET00gZWxlbWVudDogXCIgKyBxdWVyeSArIFwiIGluIFwiICsgbGlzdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAgICovXG4gICAgY29uc3QgZWwgPSBsaXN0ICYmIGxpc3QucXVlcnlTZWxlY3RvcihxdWVyeSlcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmICh0eXBlb2YgZWwuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2Nyb2xsaW5nIHNlbGVjdGVkIGl0ZW0gaW50byB2aWV3XCIpXG4gICAgICAgIH1cbiAgICAgICAgZWwuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpXG4gICAgICB9IGVsc2UgaWYgKGVsLnNjcm9sbEludG9WaWV3ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTY3JvbGxpbmcgc2VsZWN0ZWQgaXRlbSBpbnRvIHZpZXdcIilcbiAgICAgICAgfVxuICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIkNvdWxkIG5vdCBzY3JvbGwgc2VsZWN0ZWQgaXRlbSBpbnRvIHZpZXcsIHNjcm9sbEludG9WaWV3SWZOZWVkZWQgbm90IHN1cHBvcnRlZFwiXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJTZWxlY3RlZCBpdGVtIG5vdCBmb3VuZCB0byBzY3JvbGwgaW50byB2aWV3XCIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uTGlzdEl0ZW1DbGlja1wiKVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RMaXN0SXRlbShsaXN0SXRlbSkpIHtcbiAgICAgIGNsb3NlKClcbiAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICB0ZXh0ID0gXCJcIlxuICAgICAgICBpbnB1dC5mb2N1cygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Eb2N1bWVudENsaWNrKGUpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25Eb2N1bWVudENsaWNrXCIpXG4gICAgfVxuICAgIGlmIChlLmNvbXBvc2VkUGF0aCgpLnNvbWUoKHBhdGgpID0+IHBhdGguY2xhc3NMaXN0ICYmIHBhdGguY2xhc3NMaXN0LmNvbnRhaW5zKHVuaXF1ZUlkKSkpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uRG9jdW1lbnRDbGljayBpbnNpZGVcIilcbiAgICAgIH1cbiAgICAgIC8vIHJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuKCk7XG4gICAgICBoaWdobGlnaHQoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkRvY3VtZW50Q2xpY2sgb3V0c2lkZVwiKVxuICAgICAgfVxuICAgICAgY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uS2V5RG93blwiKVxuICAgIH1cblxuICAgIGxldCBrZXkgPSBlLmtleVxuICAgIGlmIChrZXkgPT09IFwiVGFiXCIgJiYgZS5zaGlmdEtleSkga2V5ID0gXCJTaGlmdFRhYlwiXG4gICAgY29uc3QgZm5tYXAgPSB7XG4gICAgICBUYWI6IG9wZW5lZCA/IGNsb3NlIDogbnVsbCxcbiAgICAgIFNoaWZ0VGFiOiBvcGVuZWQgPyBjbG9zZSA6IG51bGwsXG4gICAgICBBcnJvd0Rvd246IGRvd24uYmluZCh0aGlzKSxcbiAgICAgIEFycm93VXA6IHVwLmJpbmQodGhpcyksXG4gICAgICBFc2NhcGU6IG9uRXNjLmJpbmQodGhpcyksXG4gICAgICBCYWNrc3BhY2U6IG11bHRpcGxlICYmIGhhc1NlbGVjdGlvbiAmJiAhdGV4dCA/IG9uQmFja3NwYWNlLmJpbmQodGhpcykgOiBudWxsLFxuICAgIH1cbiAgICBjb25zdCBmbiA9IGZubWFwW2tleV1cbiAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZuKGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uS2V5UHJlc3NcIilcbiAgICB9XG5cbiAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgb25FbnRlcihlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW50ZXIoZSkge1xuICAgIGlmIChvcGVuZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgc2VsZWN0SXRlbSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25JbnB1dChlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9uSW5wdXRcIilcbiAgICB9XG5cbiAgICB0ZXh0ID0gZS50YXJnZXQudmFsdWVcbiAgICBpZiAoaW5wdXREZWxheVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnB1dERlbGF5VGltZW91dClcbiAgICB9XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGlucHV0RGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dChwcm9jZXNzSW5wdXQsIGRlbGF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzSW5wdXQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2VsZWN0SXRlbSh0YWcpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidW5zZWxlY3RJdGVtXCIsIHRhZylcbiAgICB9XG4gICAgc2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtLmZpbHRlcigoaSkgPT4gaSAhPT0gdGFnKVxuICAgIGlucHV0LmZvY3VzKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJbnB1dCgpIHtcbiAgICBpZiAoc2VhcmNoKCkpIHtcbiAgICAgIGhpZ2hsaWdodEluZGV4ID0gMFxuICAgICAgb3BlbigpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25JbnB1dENsaWNrKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbklucHV0Q2xpY2tcIilcbiAgICB9XG4gICAgcmVzZXRMaXN0VG9BbGxJdGVtc0FuZE9wZW4oKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Fc2MoZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkVzY1wiKVxuICAgIH1cblxuICAgIC8vaWYgKHRleHQpIHJldHVybiBjbGVhcigpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICBpbnB1dC5mb2N1cygpXG4gICAgICBjbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25CYWNrc3BhY2UoZSkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkJhY2tzcGFjZVwiKVxuICAgIH1cblxuICAgIHVuc2VsZWN0SXRlbShzZWxlY3RlZEl0ZW1bc2VsZWN0ZWRJdGVtLmxlbmd0aCAtIDFdKVxuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2N1c0ludGVybmFsKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJvbkZvY3VzXCIpXG4gICAgfVxuXG4gICAgb25Gb2N1cygpXG5cbiAgICByZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlbigpXG4gIH1cblxuICBmdW5jdGlvbiBvbkJsdXJJbnRlcm5hbCgpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwib25CbHVyXCIpXG4gICAgfVxuXG4gICAgaWYgKGNsb3NlT25CbHVyKSB7XG4gICAgICBjbG9zZSgpXG4gICAgfVxuXG4gICAgb25CbHVyKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0TGlzdFRvQWxsSXRlbXNBbmRPcGVuKCkge1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJyZXNldExpc3RUb0FsbEl0ZW1zQW5kT3BlblwiKVxuICAgIH1cblxuICAgIGlmIChzZWFyY2hGdW5jdGlvbiAmJiAhbGlzdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgc2VhcmNoKClcbiAgICB9IGVsc2UgaWYgKCF0ZXh0KSB7XG4gICAgICBmaWx0ZXJlZExpc3RJdGVtcyA9IGxpc3RJdGVtc1xuICAgIH1cblxuICAgIG9wZW4oKVxuXG4gICAgLy8gZmluZCBzZWxlY3RlZCBpdGVtXG4gICAgaWYgKHNlbGVjdGVkSXRlbSkge1xuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VhcmNoaW5nIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtOiBcIiArIEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkSXRlbSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gZmluZEl0ZW1JbmRleChzZWxlY3RlZEl0ZW0sIGZpbHRlcmVkTGlzdEl0ZW1zKVxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaGlnaGxpZ2h0SW5kZXggPSBpbmRleFxuICAgICAgICBoaWdobGlnaHQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJdGVtSW5kZXgoaXRlbSwgaXRlbXMpIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRmluZGluZyBpbmRleCBmb3IgaXRlbVwiLCBpdGVtKVxuICAgIH1cbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpc3RJdGVtID0gaXRlbXNbaV1cbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgbGlzdEl0ZW0pIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGxpc3RJdGVtICR7aX0gaXMgdW5kZWZpbmVkLiBTa2lwcGluZy5gKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJdGVtIFwiICsgaSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGxpc3RJdGVtKSlcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtID09PSBsaXN0SXRlbS5pdGVtKSB7XG4gICAgICAgIGluZGV4ID0gaVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJGb3VuZCBpbmRleCBmb3IgaXRlbTogXCIgKyBpbmRleClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vdCBmb3VuZCBpbmRleCBmb3IgaXRlbTogXCIgKyBpdGVtKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXhcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm9wZW5cIilcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgc2VhcmNoIHRleHQgaGFzIG1vcmUgdGhhbiB0aGUgbWluIGNoYXJzIHJlcXVpcmVkXG4gICAgaWYgKGxvY2tlZCB8fCBub3RFbm91Z2hTZWFyY2hUZXh0KCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFBvc2l0aW9uT25OZXh0VXBkYXRlID0gdHJ1ZVxuXG4gICAgb3BlbmVkID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImNsb3NlXCIpXG4gICAgfVxuICAgIG9wZW5lZCA9IGZhbHNlXG4gICAgbG9hZGluZyA9IGZhbHNlXG5cbiAgICBpZiAoIXRleHQgJiYgc2VsZWN0Rmlyc3RJZkVtcHR5KSB7XG4gICAgICBoaWdobGlnaHRJbmRleCA9IDBcbiAgICAgIHNlbGVjdEl0ZW0oKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdEVub3VnaFNlYXJjaFRleHQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG1pbkNoYXJhY3RlcnNUb1NlYXJjaCA+IDAgJiZcbiAgICAgIGZpbHRlcmVkVGV4dExlbmd0aCA8IG1pbkNoYXJhY3RlcnNUb1NlYXJjaCAmJlxuICAgICAgLy8gV2hlbiBubyBzZWFyY2hGdW5jdGlvbiBpcyBkZWZpbmVkLCB0aGUgbWVudSBzaG91bGQgYWx3YXlzIG9wZW4gd2hlbiB0aGUgaW5wdXQgaXMgZm9jdXNlZFxuICAgICAgKHNlYXJjaEZ1bmN0aW9uIHx8IGZpbHRlcmVkVGV4dExlbmd0aCA+IDApXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VJZk1pbkNoYXJzVG9TZWFyY2hSZWFjaGVkKCkge1xuICAgIGlmIChub3RFbm91Z2hTZWFyY2hUZXh0KCkpIHtcbiAgICAgIGNsb3NlKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImNsZWFyXCIpXG4gICAgfVxuXG4gICAgdGV4dCA9IFwiXCJcbiAgICBzZWxlY3RlZEl0ZW0gPSBtdWx0aXBsZSA/IFtdIDogdW5kZWZpbmVkXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlucHV0LmZvY3VzKClcbiAgICB9KVxuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodEZpbHRlcihrZXl3b3JkcywgZmllbGQpIHtcbiAgICByZXR1cm4gKGl0ZW0pID0+IHtcbiAgICAgIGxldCBsYWJlbCA9IGl0ZW1bZmllbGRdXG5cbiAgICAgIGNvbnN0IG5ld0l0ZW0gPSBPYmplY3QuYXNzaWduKHsgaGlnaGxpZ2h0ZWQ6IHVuZGVmaW5lZCB9LCBpdGVtKVxuICAgICAgbmV3SXRlbS5oaWdobGlnaHRlZCA9IGxhYmVsXG5cbiAgICAgIGNvbnN0IGxhYmVsTG93ZXJjYXNlID0gbGFiZWwudG9Mb3dlckNhc2UoKVxuICAgICAgY29uc3QgbGFiZWxMb3dlcmNhc2VOb0FjID0gaWdub3JlQWNjZW50cyA/IHJlbW92ZUFjY2VudHMobGFiZWxMb3dlcmNhc2UpIDogbGFiZWxMb3dlcmNhc2VcblxuICAgICAgaWYgKGtleXdvcmRzICYmIGtleXdvcmRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5d29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQga2V5d29yZCA9IGtleXdvcmRzW2ldXG4gICAgICAgICAgaWYgKGlnbm9yZUFjY2VudHMpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSByZW1vdmVBY2NlbnRzKGtleXdvcmQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleXdvcmRMZW4gPSBrZXl3b3JkLmxlbmd0aFxuXG4gICAgICAgICAgbGV0IHBvczEgPSAwXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zMSA9IGxhYmVsTG93ZXJjYXNlTm9BYy5pbmRleE9mKGtleXdvcmQsIHBvczEpXG4gICAgICAgICAgICBpZiAocG9zMSA+PSAwKSB7XG4gICAgICAgICAgICAgIGxldCBwb3MyID0gcG9zMSArIGtleXdvcmRMZW5cbiAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goW3BvczEsIHBvczJdKVxuICAgICAgICAgICAgICBwb3MxID0gcG9zMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKHBvczEgIT09IC0xKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qga2V5d29yZFBhdHRlcm5zID0gbmV3IFNldCgpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBwb3NpdGlvbnNbaV1cbiAgICAgICAgICAgIGNvbnN0IHBvczEgPSBwYWlyWzBdXG4gICAgICAgICAgICBjb25zdCBwb3MyID0gcGFpclsxXVxuXG4gICAgICAgICAgICBjb25zdCBrZXl3b3JkUGF0dGVybiA9IGxhYmVsTG93ZXJjYXNlLnN1YnN0cmluZyhwb3MxLCBwb3MyKVxuICAgICAgICAgICAga2V5d29yZFBhdHRlcm5zLmFkZChrZXl3b3JkUGF0dGVybilcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQga2V5d29yZFBhdHRlcm4gb2Yga2V5d29yZFBhdHRlcm5zKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBwc3Q6IHdvcmthcm9uZCBmb3Igd3JvbmcgcmVwbGFjZW1lbnQgPGI+IHRhZ3NcbiAgICAgICAgICAgIGlmIChrZXl3b3JkUGF0dGVybiA9PT0gXCJiXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoXCIoXCIgKyBrZXl3b3JkUGF0dGVybiArIFwiKVwiLCBcImlnXCIpXG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0hpZ2hsaWdodGVkID0gbmV3SXRlbS5oaWdobGlnaHRlZC5yZXBsYWNlKHJlZywgXCI8Yj4kMTwvYj5cIilcbiAgICAgICAgICAgIG5ld0l0ZW0uaGlnaGxpZ2h0ZWQgPSBuZXdIaWdobGlnaHRlZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SXRlbVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFjY2VudHMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoXCJORkRcIikucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29uZmlybWVkKGxpc3RJdGVtKSB7XG4gICAgaWYgKCFzZWxlY3RlZEl0ZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZEl0ZW0uaW5jbHVkZXMobGlzdEl0ZW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaXN0SXRlbSA9PT0gc2VsZWN0ZWRJdGVtXG4gICAgfVxuICB9XG5cbiAgbGV0IGRyYWdnaW5nT3ZlciA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gZHJhZ3N0YXJ0KGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwic291cmNlXCIsIGluZGV4KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdvdmVyKGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGRyYWdnaW5nT3ZlciA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhZ2xlYXZlKGV2ZW50LCBpbmRleCkge1xuICAgIGlmIChvcmRlcmFibGVTZWxlY3Rpb24pIHtcbiAgICAgIGRyYWdnaW5nT3ZlciA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJvcChldmVudCwgaW5kZXgpIHtcbiAgICBpZiAob3JkZXJhYmxlU2VsZWN0aW9uKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBkcmFnZ2luZ092ZXIgPSBmYWxzZVxuICAgICAgbGV0IGZyb20gPSBwYXJzZUludChldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcInNvdXJjZVwiKSlcbiAgICAgIGxldCB0byA9IGluZGV4XG4gICAgICBpZiAoZnJvbSAhPSB0bykge1xuICAgICAgICBtb3ZlU2VsZWN0ZWRJdGVtKGZyb20sIHRvKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVTZWxlY3RlZEl0ZW0oZnJvbSwgdG8pIHtcbiAgICBsZXQgbmV3U2VsZWN0aW9uID0gWy4uLnNlbGVjdGVkSXRlbV1cbiAgICBpZiAoZnJvbSA8IHRvKSB7XG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKHRvICsgMSwgMCwgbmV3U2VsZWN0aW9uW2Zyb21dKVxuICAgICAgbmV3U2VsZWN0aW9uLnNwbGljZShmcm9tLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKHRvLCAwLCBuZXdTZWxlY3Rpb25bZnJvbV0pXG4gICAgICBuZXdTZWxlY3Rpb24uc3BsaWNlKGZyb20gKyAxLCAxKVxuICAgIH1cbiAgICBzZWxlY3RlZEl0ZW0gPSBuZXdTZWxlY3Rpb25cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbEF3YXJlTGlzdFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgaGVpZ2h0OiB2aWV3UG9ydEhlaWdodCB9ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0XG4gICAgY29uc3QgeyBib3R0b206IGlucHV0QnV0dG9tLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH0gPSBpbnB1dENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHsgaGVpZ2h0OiBsaXN0SGVpZ2h0IH0gPSBsaXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICBpZiAoaW5wdXRCdXR0b20gKyBsaXN0SGVpZ2h0ID4gdmlld1BvcnRIZWlnaHQpIHtcbiAgICAgIGxpc3Quc3R5bGUudG9wID0gYC0ke2lucHV0SGVpZ2h0ICsgbGlzdEhlaWdodH1weGBcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zdHlsZS50b3AgPSBcIjBweFwiXG4gICAgfVxuICB9XG48L3NjcmlwdD5cbjxkaXZcbiAgY2xhc3M9XCJ7Y2xhc3NOYW1lID8gY2xhc3NOYW1lIDogJyd9IGF1dG9jb21wbGV0ZSBzZWxlY3QgaXMtZnVsbHdpZHRoIHt1bmlxdWVJZH1cIlxuICBjbGFzczpoaWRlLWFycm93PXtoaWRlQXJyb3cgfHwgIWl0ZW1zLmxlbmd0aH1cbiAgY2xhc3M6aXMtbXVsdGlwbGU9e211bHRpcGxlfVxuICBjbGFzczpzaG93LWNsZWFyPXtjbGVhcmFibGV9XG4gIGNsYXNzOmlzLWxvYWRpbmc9e3Nob3dMb2FkaW5nSW5kaWNhdG9yICYmIGxvYWRpbmd9XG4+XG4gIDxzZWxlY3QgbmFtZT17c2VsZWN0TmFtZX0gaWQ9e3NlbGVjdElkfSB7bXVsdGlwbGV9PlxuICAgIHsjaWYgIW11bHRpcGxlICYmIGhhc1NlbGVjdGlvbn1cbiAgICAgIDxvcHRpb24gdmFsdWU9e3ZhbHVlRnVuY3Rpb24oc2VsZWN0ZWRJdGVtLCB0cnVlKX0gc2VsZWN0ZWQ+XG4gICAgICAgIHtzYWZlTGFiZWxGdW5jdGlvbihzZWxlY3RlZEl0ZW0pfVxuICAgICAgPC9vcHRpb24+XG4gICAgezplbHNlIGlmIG11bHRpcGxlICYmIGhhc1NlbGVjdGlvbn1cbiAgICAgIHsjZWFjaCBzZWxlY3RlZEl0ZW0gYXMgaX1cbiAgICAgICAgPG9wdGlvbiB2YWx1ZT17dmFsdWVGdW5jdGlvbihpLCB0cnVlKX0gc2VsZWN0ZWQ+XG4gICAgICAgICAge3NhZmVMYWJlbEZ1bmN0aW9uKGkpfVxuICAgICAgICA8L29wdGlvbj5cbiAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuICA8L3NlbGVjdD5cbiAgPGRpdiBjbGFzcz1cImlucHV0LWNvbnRhaW5lclwiIGJpbmQ6dGhpcz17aW5wdXRDb250YWluZXJ9PlxuICAgIHsjaWYgbXVsdGlwbGUgJiYgaGFzU2VsZWN0aW9ufVxuICAgICAgeyNlYWNoIHNlbGVjdGVkSXRlbSBhcyB0YWdJdGVtLCBpICh2YWx1ZUZ1bmN0aW9uKHRhZ0l0ZW0sIHRydWUpKX1cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGRyYWdnYWJsZT17dHJ1ZX1cbiAgICAgICAgICBhbmltYXRlOmZsaXA9e3sgZHVyYXRpb246IDIwMCB9fVxuICAgICAgICAgIHRyYW5zaXRpb246ZmFkZT17eyBkdXJhdGlvbjogMjAwIH19XG4gICAgICAgICAgb246ZHJhZ3N0YXJ0PXsoZXZlbnQpID0+IGRyYWdzdGFydChldmVudCwgaSl9XG4gICAgICAgICAgb246ZHJhZ292ZXI9eyhldmVudCkgPT4gZHJhZ292ZXIoZXZlbnQsIGkpfVxuICAgICAgICAgIG9uOmRyYWdsZWF2ZT17KGV2ZW50KSA9PiBkcmFnbGVhdmUoZXZlbnQsIGkpfVxuICAgICAgICAgIG9uOmRyb3A9eyhldmVudCkgPT4gZHJvcChldmVudCwgaSl9XG4gICAgICAgICAgY2xhc3M6aXMtYWN0aXZlPXtkcmFnZ2luZ092ZXIgPT09IGl9XG4gICAgICAgID5cbiAgICAgICAgICA8c2xvdCBuYW1lPVwidGFnXCIgbGFiZWw9e3NhZmVMYWJlbEZ1bmN0aW9uKHRhZ0l0ZW0pfSBpdGVtPXt0YWdJdGVtfSB7dW5zZWxlY3RJdGVtfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWdzIGhhcy1hZGRvbnNcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWdcIj57c2FmZUxhYmVsRnVuY3Rpb24odGFnSXRlbSl9PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgIGNsYXNzPVwidGFnIGlzLWRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e3Vuc2VsZWN0SXRlbSh0YWdJdGVtKX1cbiAgICAgICAgICAgICAgICBvbjprZXlwcmVzc3xwcmV2ZW50RGVmYXVsdD17KGUpID0+IHtlLmtleSA9PSBcIkVudGVyXCIgJiYgdW5zZWxlY3RJdGVtKHRhZ0l0ZW0pfX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2VhY2h9XG4gICAgey9pZn1cbiAgICA8aW5wdXRcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIGNsYXNzPVwie2lucHV0Q2xhc3NOYW1lID8gaW5wdXRDbGFzc05hbWUgOiAnJ30ge25vSW5wdXRTdHlsZXNcbiAgICAgICAgPyAnJ1xuICAgICAgICA6ICdpbnB1dCBhdXRvY29tcGxldGUtaW5wdXQnfVwiXG4gICAgICBpZD17aW5wdXRJZCA/IGlucHV0SWQgOiBcIlwifVxuICAgICAgYXV0b2NvbXBsZXRlPXtodG1sNWF1dG9jb21wbGV0ZSA/IFwib25cIiA6IGF1dG9jb21wbGV0ZU9mZlZhbHVlfVxuICAgICAge3BsYWNlaG9sZGVyfVxuICAgICAge25hbWV9XG4gICAgICB7ZGlzYWJsZWR9XG4gICAgICB7cmVxdWlyZWR9XG4gICAgICB7dGl0bGV9XG4gICAgICByZWFkb25seT17cmVhZG9ubHkgfHwgbG9ja2VkfVxuICAgICAge3RhYmluZGV4fVxuICAgICAgYmluZDp0aGlzPXtpbnB1dH1cbiAgICAgIGJpbmQ6dmFsdWU9e3RleHR9XG4gICAgICBvbjppbnB1dD17b25JbnB1dH1cbiAgICAgIG9uOmZvY3VzPXtvbkZvY3VzSW50ZXJuYWx9XG4gICAgICBvbjpibHVyPXtvbkJsdXJJbnRlcm5hbH1cbiAgICAgIG9uOmtleWRvd249e29uS2V5RG93bn1cbiAgICAgIG9uOmNsaWNrPXtvbklucHV0Q2xpY2t9XG4gICAgICBvbjprZXlwcmVzcz17b25LZXlQcmVzc31cbiAgICAgIG9uOmRyYWdvdmVyPXsoZXZlbnQpID0+IGRyYWdvdmVyKGV2ZW50LCBzZWxlY3RlZEl0ZW0ubGVuZ3RoIC0gMSl9XG4gICAgICBvbjpkcm9wPXsoZXZlbnQpID0+IGRyb3AoZXZlbnQsIHNlbGVjdGVkSXRlbS5sZW5ndGggLSAxKX1cbiAgICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICAvPlxuICAgIHsjaWYgY2xlYXJhYmxlfVxuICAgICAgPHNwYW5cbiAgICAgICAgb246Y2xpY2s9e2NsZWFyfVxuICAgICAgICBvbjprZXlwcmVzcz17KGUpID0+IHtlLmtleSA9PSBcIkVudGVyXCIgJiYgY2xlYXIoKX19XG4gICAgICAgIGNsYXNzPVwiYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvblwiXG4gICAgICAgID57QGh0bWwgY2xlYXJUZXh0fTwvc3Bhbj5cbiAgICB7L2lmfVxuICA8L2Rpdj5cbiAgPGRpdlxuICAgIGNsYXNzPVwie2Ryb3Bkb3duQ2xhc3NOYW1lID8gZHJvcGRvd25DbGFzc05hbWUgOiAnJ30gYXV0b2NvbXBsZXRlLWxpc3Qge3Nob3dMaXN0ID8gJycgOiAnaGlkZGVuJ31cbiAgICBpcy1mdWxsd2lkdGhcIlxuICAgIGJpbmQ6dGhpcz17bGlzdH1cbiAgPlxuICAgIHsjaWYgZmlsdGVyZWRMaXN0SXRlbXMgJiYgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoID4gMH1cbiAgICAgIDxzbG90IG5hbWU9XCJkcm9wZG93bi1oZWFkZXJcIiBuYkl0ZW1zPXtmaWx0ZXJlZExpc3RJdGVtcy5sZW5ndGh9IHttYXhJdGVtc1RvU2hvd0luTGlzdH0gLz5cblxuICAgICAgeyNlYWNoIGZpbHRlcmVkTGlzdEl0ZW1zIGFzIGxpc3RJdGVtLCBpfVxuICAgICAgICB7I2lmIGxpc3RJdGVtICYmIChtYXhJdGVtc1RvU2hvd0luTGlzdCA8PSAwIHx8IGkgPCBtYXhJdGVtc1RvU2hvd0luTGlzdCl9XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtXCJcbiAgICAgICAgICAgIGNsYXNzOnNlbGVjdGVkPXtpID09PSBoaWdobGlnaHRJbmRleH1cbiAgICAgICAgICAgIGNsYXNzOmNvbmZpcm1lZD17aXNDb25maXJtZWQobGlzdEl0ZW0uaXRlbSl9XG4gICAgICAgICAgICBvbjpjbGljaz17KCkgPT4gb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKX1cbiAgICAgICAgICAgIG9uOmtleXByZXNzPXsoZSkgPT4ge2Uua2V5ID09IFwiRW50ZXJcIiAmJiBvbkxpc3RJdGVtQ2xpY2sobGlzdEl0ZW0pfX1cbiAgICAgICAgICAgIG9uOnBvaW50ZXJlbnRlcj17KCkgPT4ge1xuICAgICAgICAgICAgICBoaWdobGlnaHRJbmRleCA9IGlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNsb3RcbiAgICAgICAgICAgICAgbmFtZT1cIml0ZW1cIlxuICAgICAgICAgICAgICBpdGVtPXtsaXN0SXRlbS5pdGVtfVxuICAgICAgICAgICAgICBsYWJlbD17bGlzdEl0ZW0uaGlnaGxpZ2h0ZWQgPyBsaXN0SXRlbS5oaWdobGlnaHRlZCA6IGxpc3RJdGVtLmxhYmVsfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7I2lmIGxpc3RJdGVtLmhpZ2hsaWdodGVkfVxuICAgICAgICAgICAgICAgIHtAaHRtbCBsaXN0SXRlbS5oaWdobGlnaHRlZH1cbiAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIHtAaHRtbCBsaXN0SXRlbS5sYWJlbH1cbiAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICAgIHsvZWFjaH1cblxuICAgICAgPHNsb3QgbmFtZT1cImRyb3Bkb3duLWZvb3RlclwiIG5iSXRlbXM9e2ZpbHRlcmVkTGlzdEl0ZW1zLmxlbmd0aH0ge21heEl0ZW1zVG9TaG93SW5MaXN0fT5cbiAgICAgICAgeyNpZiBtYXhJdGVtc1RvU2hvd0luTGlzdCA+IDAgJiYgZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoID4gbWF4SXRlbXNUb1Nob3dJbkxpc3R9XG4gICAgICAgICAgeyNpZiBtb3JlSXRlbXNUZXh0fVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbm8tcmVzdWx0c1wiPlxuICAgICAgICAgICAgICAuLi57ZmlsdGVyZWRMaXN0SXRlbXMubGVuZ3RoIC0gbWF4SXRlbXNUb1Nob3dJbkxpc3R9XG4gICAgICAgICAgICAgIHttb3JlSXRlbXNUZXh0fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgey9pZn1cbiAgICAgICAgey9pZn1cbiAgICAgIDwvc2xvdD5cbiAgICB7OmVsc2UgaWYgbG9hZGluZyAmJiBsb2FkaW5nVGV4dH1cbiAgICAgIDxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtbGlzdC1pdGVtLWxvYWRpbmdcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxvYWRpbmdcIiB7bG9hZGluZ1RleHR9Pntsb2FkaW5nVGV4dH08L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICB7OmVsc2UgaWYgY3JlYXRlfVxuICAgICAgPGRpdlxuICAgICAgICBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tY3JlYXRlXCJcbiAgICAgICAgb246Y2xpY2s9e3NlbGVjdEl0ZW19XG4gICAgICAgIG9uOmtleXByZXNzPXsoZSkgPT4ge2Uua2V5ID09IFwiRW50ZXJcIiAmJiBzZWxlY3RJdGVtKCl9fVxuICAgICAgPlxuICAgICAgICA8c2xvdCBuYW1lPVwiY3JlYXRlXCIge2NyZWF0ZVRleHR9PntjcmVhdGVUZXh0fTwvc2xvdD5cbiAgICAgIDwvZGl2PlxuICAgIHs6ZWxzZSBpZiBub1Jlc3VsdHNUZXh0fVxuICAgICAgPGRpdiBjbGFzcz1cImF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbm8tcmVzdWx0c1wiPlxuICAgICAgICA8c2xvdCBuYW1lPVwibm8tcmVzdWx0c1wiIHtub1Jlc3VsdHNUZXh0fT57bm9SZXN1bHRzVGV4dH08L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICA8L2Rpdj5cbjwvZGl2PlxuXG48c3ZlbHRlOndpbmRvdyBvbjpjbGljaz17b25Eb2N1bWVudENsaWNrfSBvbjpzY3JvbGw9eygpID0+IHNldFBvc2l0aW9uT25OZXh0VXBkYXRlID0gdHJ1ZX0gLz5cblxuPHN0eWxlPlxuICAuYXV0b2NvbXBsZXRlIHtcbiAgICBtaW4td2lkdGg6IDIwMHB4O1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgaGVpZ2h0OiAyLjI1ZW07XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlOm5vdCguaGlkZS1hcnJvdyk6bm90KC5pcy1sb2FkaW5nKTo6YWZ0ZXIge1xuICAgIGJvcmRlcjogM3B4IHNvbGlkO1xuICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICBib3JkZXItcmlnaHQ6IDA7XG4gICAgYm9yZGVyLXRvcDogMDtcbiAgICBjb250ZW50OiBcIiBcIjtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBoZWlnaHQ6IDAuNjI1ZW07XG4gICAgbWFyZ2luLXRvcDogLTAuNDM3NWVtO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDUwJTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlcjtcbiAgICB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7XG4gICAgd2lkdGg6IDAuNjI1ZW07XG4gICAgYm9yZGVyLWNvbG9yOiAjMzI3M2RjO1xuICAgIHJpZ2h0OiAxLjEyNWVtO1xuICAgIHotaW5kZXg6IDQ7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLnNob3ctY2xlYXI6bm90KC5oaWRlLWFycm93KTo6YWZ0ZXIge1xuICAgIHJpZ2h0OiAyLjNlbTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUgKiB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBmb250OiBpbmhlcml0O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBwYWRkaW5nOiA1cHggMTFweDtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGU6bm90KC5oaWRlLWFycm93KSAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyZW07XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS5zaG93LWNsZWFyOm5vdCguaGlkZS1hcnJvdykgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgcGFkZGluZy1yaWdodDogMy4yZW07XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS5oaWRlLWFycm93LnNob3ctY2xlYXIgLmF1dG9jb21wbGV0ZS1pbnB1dCB7XG4gICAgcGFkZGluZy1yaWdodDogMmVtO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS1saXN0IHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIHotaW5kZXg6IDk5O1xuICAgIHBhZGRpbmc6IDEwcHggMDtcbiAgICB0b3A6IDBweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTUgKiAoMXJlbSArIDEwcHgpICsgMTVweCk7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0OmVtcHR5IHtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG4gIC5hdXRvY29tcGxldGUtbGlzdC1pdGVtIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBjb2xvcjogIzMzMztcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS5jb25maXJtZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM3ODlmZWQ7XG4gICAgY29sb3I6ICNmZmY7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0uc2VsZWN0ZWQge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMyZTY5ZTI7XG4gICAgY29sb3I6ICNmZmY7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tbm8tcmVzdWx0cyB7XG4gICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgY29sb3I6ICM5OTk7XG4gICAgbGluZS1oZWlnaHQ6IDE7XG4gIH1cbiAgLmF1dG9jb21wbGV0ZS1saXN0LWl0ZW0tY3JlYXRlIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuICAuYXV0b2NvbXBsZXRlLWxpc3QtaXRlbS1sb2FkaW5nIHtcbiAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICBsaW5lLWhlaWdodDogMTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUtbGlzdC5oaWRkZW4ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuc2hvdy1jbGVhciAuYXV0b2NvbXBsZXRlLWNsZWFyLWJ1dHRvbiB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgcmlnaHQ6IDAuMWVtO1xuICAgIHBhZGRpbmc6IDAuM2VtIDAuNmVtO1xuICAgIHRvcDogNTAlO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuICAgIHotaW5kZXg6IDQ7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlOm5vdCguc2hvdy1jbGVhcikgLmF1dG9jb21wbGV0ZS1jbGVhci1idXR0b24ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cblxuICAuYXV0b2NvbXBsZXRlIHNlbGVjdCB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuXG4gIC5hdXRvY29tcGxldGUuaXMtbXVsdGlwbGUgLmlucHV0LWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICAgIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDJweCByZ2JhKDEwLCAxMCwgMTAsIDAuMSk7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNiNWI1YjU7XG4gICAgcGFkZGluZy1sZWZ0OiAwLjRlbTtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwLjRlbTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAudGFnIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbi10b3A6IDAuNWVtO1xuICAgIG1hcmdpbi1ib3R0b206IDAuM2VtO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAudGFnLmlzLWRlbGV0ZSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAudGFncyB7XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjNlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG5cbiAgLmF1dG9jb21wbGV0ZS5pcy1tdWx0aXBsZSAuYXV0b2NvbXBsZXRlLWlucHV0IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGZsZXg6IDEgMSA1MHB4O1xuICAgIG1pbi13aWR0aDogM2VtO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3gtc2hhZG93OiBub25lO1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRleHRmaWVsZFwiLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHNpemUgPSBcIm5vcm1hbFwiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtdGV4dGZpZWxkLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBBdXRvQ29tcGxldGUgZnJvbSBcInNpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlXCI7XG5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJVGV4dGZpZWxkSW5wdXQgZnJvbSBcIi4vdWkudGV4dGZpZWxkLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICAvKipcbiAgICAgKiBNb3JlIHByb3BlcnRpZXMgYXQgaHR0cHM6Ly9naXRodWIuY29tL3BzdGFub2V2L3NpbXBsZS1zdmVsdGUtYXV0b2NvbXBsZXRlI3Byb3BlcnRpZXNcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXIgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZSA9ICdhdXRvY29tcGxldGUnXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIC8vZ2VuZXJpYyBpbnB1dCBwcm9wc1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZSgpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiYXV0b2NvbXBsZXRlXCIsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHJlcXVpcmVkID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UodmFsKSB7XG4gICAgICAgIGlmIChvbmNoYW5nZSkge1xuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsKSxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBkaXNhYmxlZH1cbiAgICA8VUlUZXh0ZmllbGRJbnB1dFxuICAgICAgICB2YWx1ZT17dmFsdWUgPyB2YWx1ZS50aXRsZSA6IFwiXCJ9XG4gICAgICAgIHtmaWVsZG5hbWV9XG4gICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuezplbHNlIGlmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZSA/ICh2YWx1ZT8udGl0bGUgPz8gXCJcIikgOiBcIlwifTwvcD5cbns6ZWxzZX1cbiAgICA8QXV0b0NvbXBsZXRlXG4gICAgICAgIGJpbmQ6c2VsZWN0ZWRJdGVtPXt2YWx1ZX1cbiAgICAgICAge29uQ2hhbmdlfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIHt2YWxpZH1cbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCB7IFVJQ29tbW9uIH0gZnJvbSBcIi4uLy4uXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICBwbGFjZWhvbGRlciA9IFwiXCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY29sb3JcIixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxpbnB1dFxuICAgIGlkPVwiZm9ybS1maWVsZC1jb2xvci17ZmllbGRuYW1lfVwiXG4gICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgdHlwZT1cImNvbG9yXCJcbiAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgYmluZDp2YWx1ZVxuICAgIHtpbnZhbGlkfVxuICAgIHtyZXF1aXJlZH1cbiAgICB7cmVhZG9ubHl9XG4gICAge2Rpc2FibGVkfVxuICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICB7Li4ub3RoZXJzfVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZm9yXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbD0nbGFiZWwnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZm9yOiBmb3JJZCxcbiAgICAgICAgbGFiZWwgPSBcImxhYmVsXCIsXG4gICAgICAgIGNsYXNzOiBsYWJlbENsYXNzID0gXCJcIixcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxsYWJlbCBjbGFzcz1cImxhYmVsIHtsYWJlbENsYXNzfVwiIGZvcj17Zm9ySWR9PlxuICAgIHsjaWYgY2hpbGRyZW59XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuKCl9XG4gICAgezplbHNlfXtsYWJlbCA/ICRMT0NBTEVbbGFiZWxdIDogXCJcIn17L2lmfVxuPC9sYWJlbD5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQGNvbXBvbmVudFxuICAgICAqIGNoZWNrYm94IHdpdGggdHJ1ZSBvciBmYWxzZSB2YWx1ZXNcbiAgICAgKiovXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbiAgICBpbXBvcnQgVUlMYWJlbCBmcm9tIFwiLi91aS5sYWJlbC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlCb29sZWFuIGZyb20gXCIuLi92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbGFiZWwgPSBcImNoZWNrYm94XCIsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY2hlY2tib3hcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgbGFiZWxDbGFzcyA9IFwiY2hlY2tib3hcIixcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uY2hhbmdlXCIsIFwib25pbnB1dFwiXSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IGlkID0gYGZvcm0tZmllbGQtY2hlY2tib3gtJHtmaWVsZG5hbWV9YDtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KFxuICAgICAgICAgICAgZmllbGRuYW1lLFxuICAgICAgICAgICAgb3RoZXJzLm9uY2hhbmdlLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiBvdGhlcnM/LmlkLFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZWFjdE9uLmZvckVhY2goKGV2ZW50TmFtZSkgPT4gKG9wdGlvbmFsUHJvcHNbZXZlbnROYW1lXSA9IG9uaW5wdXQpKTtcbiAgICB9XG48L3NjcmlwdD5cblxuPFVJTGFiZWwgY2xhc3M9e2xhYmVsQ2xhc3N9IHtkaXNhYmxlZH0gZm9yPXtpZH0+XG4gICAgeyNpZiByZWFkb25seX1cbiAgICAgICAgPFVJQm9vbGVhbiBMQ19UUlVFPXtsYWJlbH0gTENfRkFMU0U9e2xhYmVsfSB7dmFsdWV9IC8+XG4gICAgezplbHNlfVxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHtpZH1cbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc2VzfVxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIGJpbmQ6Y2hlY2tlZD17dmFsdWV9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgICAgIHskTE9DQUxFW2xhYmVsXX1cbiAgICB7L2lmfVxuPC9VSUxhYmVsPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlDaGVja2JveElucHV0IGZyb20gXCIuL3VpLmNoZWNrYm94LnN2ZWx0ZVwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIGZpZWxkbmFtZSA9IFwiY2hlY2tib3gtbGlzdFwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbmNoYW5nZShkYXRhLCBldiwgYWRkaXRpb25hbCkge1xuICAgICAgICBpZiAoIWFkZGl0aW9uYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhLCBhZGRpdGlvbmFsLmlkKTtcbiAgICAgICAgaWYgKGRhdGEudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUuaW5jbHVkZXMoYWRkaXRpb25hbC5pZCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGFkZGl0aW9uYWwuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGFkZGl0aW9uYWwuaWQpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHZhbHVlLmluZGV4T2YoYWRkaXRpb25hbC5pZCksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG90aGVycz8ub25jaGFuZ2UoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBldixcbiAgICAgICAgICAgIGFkZGl0aW9uYWxcbiAgICAgICAgKTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNlYWNoIHZhcmlhbnRzIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgIDxVSUNoZWNrYm94SW5wdXRcbiAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgey4uLml0ZW19XG4gICAgICAgIGZpZWxkbmFtZT17YCR7ZmllbGRuYW1lfS0ke2l0ZW0uaWR9YH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlLmluY2x1ZGVzKGl0ZW0uaWQpfVxuICAgICAgICB7b25jaGFuZ2V9XG4gICAgLz5cbnsvZWFjaH1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZS9pbmRleFwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUobmV3IERhdGUoKSksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJkYXRldGltZVwiLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcGF0dGVybiA9IFwiZHs0fS1kezJ9LWR7Mn1cIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF07XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZihcIlRcIikgPiAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiVFwiKVswXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGludmFsaWQgPSAkZGVyaXZlZCghdmFsaWQpO1xuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD5cbiAgICAgICAgPHRpbWUgZGF0ZXRpbWU9e3ZhbHVlfT57VUlDb21tb24udHJ5Rm9ybWF0TG9jYWxlRGF0ZVRpbWUodmFsdWUpfTwvdGltZT5cbiAgICA8L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC1kYXRlLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgY2xhc3M9XCJpbnB1dCB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7Y29sb3JcbiAgICAgICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgdHlwZT1cImRhdGVcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAge3BhdHRlcm59XG4gICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vY29tbW9uLmpzXCI7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVNc0Zyb21EYXRlKGlzb0RhdGUsIG1hcmtBc1pVTFUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gaXNvRGF0ZS5zcGxpdChcIi5cIilbMF0gKyAobWFya0FzWlVMVSA/IFwiXCIgOiBcIlpcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VjRnJvbURhdGUoaXNvRGF0ZSwgbWFya0FzWlVMVSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc29EYXRlLnNsaWNlKDAsIGlzb0RhdGUubGFzdEluZGV4T2YoXCI6XCIpKSArIChtYXJrQXNaVUxVID8gXCJcIiA6IFwiWlwiKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNoaWZ0RGF0ZXRpbWUoaXNvRGF0ZSwgc2hpZnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVVdGMgPSBuZXcgRGF0ZShtYXJrQXNaVUxVKGlzb0RhdGUpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzaGlmdCAqIC02MDAwMDtcbiAgICAgICAgICAgIGlmIChkYXRlSXNWYWxpZChkYXRlVXRjICsgb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlVXRjICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJc29EYXRlID0gbmV3RGF0ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVTZWNGcm9tRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTXNGcm9tRGF0ZShuZXdJc29EYXRlLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFya0FzWlVMVShkYXRlU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyaW5nICYmIGRhdGVTdHJpbmcuYXQoLTEpICE9PSBcIlpcIlxuICAgICAgICAgICAgPyBkYXRlU3RyaW5nICsgXCJaXCJcbiAgICAgICAgICAgIDogZGF0ZVN0cmluZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hblJlYWRhYmxlKGlzb0RhdGUpIHtcbiAgICAgICAgcmV0dXJuIFVJQ29tbW9uLnRyeUZvcm1hdExvY2FsZURhdGVUaW1lKGlzb0RhdGUpO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZmllbGRuYW1lID0gXCJkYXRldGltZUluVFpcIixcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXG4gICAgICAgICAgICByZW1vdmVTZWNGcm9tRGF0ZShyZW1vdmVNc0Zyb21EYXRlKG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSkpXG4gICAgICAgICksXG4gICAgICAgIHRpbWV6b25lT2Zmc2V0ID0gMCxcbiAgICAgICAgaHVtYW4gPSB0cnVlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgcmVxdWlyZWQgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHNoaWZ0ZWRWYWx1ZSA9ICRzdGF0ZSgpLFxuICAgICAgICBwcmV2U2hpZnRlZFZhbHVlO1xuXG4gICAgY29uc3Qgc2V0U2hpZnRlZCA9ICh2YWwpID0+IHtcbiAgICAgICAgaWYgKGRhdGVJc1ZhbGlkKHZhbCkpIHtcbiAgICAgICAgICAgIHByZXZTaGlmdGVkVmFsdWUgPSBzaGlmdGVkVmFsdWU7XG4gICAgICAgICAgICBzaGlmdGVkVmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVzZXRTaGlmdGVkVmFsdWUgPSAoKSA9PiB7XG4gICAgICAgIHNoaWZ0ZWRWYWx1ZSA9IHByZXZTaGlmdGVkVmFsdWU7XG4gICAgfTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBzZXRTaGlmdGVkKHNoaWZ0RGF0ZXRpbWUodmFsdWUsIHRpbWV6b25lT2Zmc2V0KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkYXRlSXNWYWxpZCA9IChkYXRlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjaGFuZ2VkID0gKCkgPT5cbiAgICAgICAgdmFsdWUgIT09IHNoaWZ0RGF0ZXRpbWUoc2hpZnRlZFZhbHVlLCAtdGltZXpvbmVPZmZzZXQsIHRydWUpO1xuXG4gICAgY29uc3QgZGlzcGF0Y2hDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIHNldFNoaWZ0ZWQoc2hpZnRlZFZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBtYXJrQXNaVUxVKHNoaWZ0RGF0ZXRpbWUoc2hpZnRlZFZhbHVlLCAtdGltZXpvbmVPZmZzZXQsIHRydWUpKTtcbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZXYpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXYuY3VycmVudFRhcmdldC52YWx1ZSAmJlxuICAgICAgICAgICAgc2hpZnRlZFZhbHVlICYmXG4gICAgICAgICAgICBkYXRlSXNWYWxpZChzaGlmdGVkVmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQoKSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0U2hpZnRlZFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbjwvc2NyaXB0PlxuXG57I2lmIHNoaWZ0ZWRWYWx1ZX1cbiAgICB7I2lmIHJlYWRvbmx5fVxuICAgICAgICA8cD57aHVtYW5SZWFkYWJsZShzaGlmdGVkVmFsdWUpfTwvcD5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLWRhdGV0aW1lLWluLXRpbWV6b25lLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICAgICAgOiAnJ30ge2NsYXNzZXN9XCJcbiAgICAgICAgICAgIHR5cGU9XCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICBiaW5kOnZhbHVlPXtzaGlmdGVkVmFsdWV9XG4gICAgICAgICAgICB7aW52YWxpZH1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICAgICAgb25jaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgb25ibHVyPXtvbkNoYW5nZX1cbiAgICAgICAgICAgIG9uaW5wdXQ9e29uQ2hhbmdlfVxuICAgICAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgey9pZn1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGUvaW5kZXhcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImVtYWlsXCIsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZX08L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC1lbWFpbC17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJlbWFpbFwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJoaWRkZW5cIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGlucHV0XG4gICAgaWQ9XCJmb3JtLWZpZWxkLWhpZGRlbi17ZmllbGRuYW1lfVwiXG4gICAgdHlwZT1cImhpZGRlblwiXG4gICAgYmluZDp2YWx1ZVxuICAgIHtyZXF1aXJlZH1cbiAgICB7cmVhZG9ubHl9XG4gICAgbmFtZT17ZmllbGRuYW1lfVxuICAgIHtvdGhlcnN9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJ0ZXh0YXJlYVwiLFxuICAgICAgICByb3dzID0gMTAsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWN0T24gPSBbXCJvbmJsdXJcIl0sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIHJlYWN0T24uZm9yRWFjaCgoZXZlbnROYW1lKSA9PiAob3B0aW9uYWxQcm9wc1tldmVudE5hbWVdID0gb25pbnB1dCkpO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZX08L3A+XG57OmVsc2V9XG4gICAgPHRleHRhcmVhXG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC10ZXh0YXJlYS17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwidGV4dGFyZWEge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICB7cm93c31cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgey4uLm90aGVyc31cbiAgICA+PC90ZXh0YXJlYT5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGV4dGFyZWEgZnJvbSBcIi4vdWkudGV4dGFyZWEuc3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJqc29uYXJlYVwiLFxuICAgICAgICB2YWxpZCA9ICRiaW5kYWJsZSh0cnVlKSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBvbmVycm9yID0gKCkgPT4ge30sXG4gICAgICAgIHJlYWN0T24gPSBbXCJvbmJsdXJcIl0sXG4gICAgICAgIGNvbG9yVmFsaWQgPSBcInN1Y2Nlc3NcIixcbiAgICAgICAgY29sb3JJbnZhbGlkID0gXCJkYW5nZXJcIixcbiAgICAgICAgdmFsaWRhdGlvbkRlbGF5ID0gMTAwMCxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IF92YWx1ZSA9ICRzdGF0ZShcInt9XCIpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfdmFsdWUgPSBKU09OLnN0cmluZ2lmeSgkc3RhdGUuc25hcHNob3QodmFsdWUpLCBudWxsLCA0KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBfdmFsdWUgPSBcInt9XCI7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBkZWxheWVkVmFsaWRhdGlvbjtcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbCk7XG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGF5ZWRPbkNoYW5nZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHZhbCB9ID0gZGF0YTtcbiAgICAgICAgaWYgKGRlbGF5ZWRWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXllZFZhbGlkYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGF5ZWRWYWxpZGF0aW9uID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBvbkNoYW5nZSh2YWwpO1xuICAgICAgICB9LCB2YWxpZGF0aW9uRGVsYXkpO1xuICAgIH1cblxuICAgIGxldCBjb2xvciA9ICRkZXJpdmVkKHZhbGlkID8gY29sb3JWYWxpZCA6IGNvbG9ySW52YWxpZCk7XG48L3NjcmlwdD5cblxuPFVJVGV4dGFyZWFcbiAgICBiaW5kOnZhbHVlPXtfdmFsdWV9XG4gICAge2ZpZWxkbmFtZX1cbiAgICBvbmNoYW5nZT17ZGVsYXllZE9uQ2hhbmdlfVxuICAgIHtyZWFjdE9ufVxuICAgIHt2YWxpZH1cbiAgICB7Y29sb3J9XG4gICAgey4uLm90aGVyc31cbi8+XG4iLCJjbGFzcyBMaWIge1xuICAgICNsaWIgPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHNlZWRMaWIpIHtcbiAgICAgICAgaWYgKHNlZWRMaWIgaW5zdGFuY2VvZiBMaWIpIHtcbiAgICAgICAgICAgIHRoaXMuaW1wb3J0KHNlZWRMaWIuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtcyB7c3RyaW5nfSAgbW9kZSB3aGF0IHRvIGRvIGlmIGVsZW1lbnQgZXhpc3RzIFtyZXBsYWNlfGFkZHxza2lwXVxuICAgICAqL1xuICAgIGFkZChuYW1lLCBjb21wLCBtb2RlID0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbnMobmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xpYltuYW1lXSA9IGNvbXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsaWJbbmFtZV0gPSBPYmplY3QuYXNzaWduKHRoaXMuI2xpYltuYW1lXSwgY29tcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNsaWJbbmFtZV0gPSBjb21wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xpYltuYW1lXTtcbiAgICB9XG5cbiAgICBjb250YWlucyhuYW1lKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuaGFzT3duKHRoaXMuI2xpYiwgbmFtZSk7XG4gICAgfVxuXG4gICAgaW1wb3J0KGJ1bGssIG1vZGUgPSBcInJlcGxhY2VcIikge1xuICAgICAgICBmb3IgKGxldCBmIGluIGJ1bGspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGYsIGJ1bGtbZl0sIG1vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuI2xpYikubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIGdldENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLiNsaWIsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaWI7XG4iLCIvKlxuICog0JHQuNCx0LvQuNC+0YLQtdC60LAgVUkg0LrQvtC90YHRgtGA0YPQutGC0L7RgNC+0LJcbiAqL1xuXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgTGliIGZyb20gXCIuL2xpYi5qc1wiO1xuXG5jb25zdCBDT01QT05FTlRTID0gbmV3IExpYigpO1xuY29uc3QgRklFTERTID0gbmV3IExpYigpO1xuY29uc3QgVkFSSUFOVFMgPSBuZXcgTGliKCk7XG5cbmV4cG9ydCB7IENPTVBPTkVOVFMsIEZJRUxEUywgVkFSSUFOVFMgfTtcbiIsIjxzY3JpcHQ+XG4gICAgLyogZXNsaW50IHN2ZWx0ZS9uby1hdC1odG1sLXRhZ3M6IDAgKi9cblxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbaWQgPSBgdGl0bGUtJHtNYXRoLnJhbmRvbSgpfWBdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3RpdGxlID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3N1YnRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFtzaXplID0gMV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbc3Vic2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbc3BhY2VkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2FsaWduID0gJ2xlZnQnXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IGB0aXRsZS0ke01hdGgucmFuZG9tKCl9YCxcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBzdWJ0aXRsZSxcbiAgICAgICAgc2l6ZSA9IDEsXG4gICAgICAgIHN1YnNpemUsXG4gICAgICAgIHNwYWNlZCA9IGZhbHNlLFxuICAgICAgICBhbGlnbiA9IFwibGVmdFwiLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGV4cG9ydCBjb25zdCBzY3JvbGxUb1RvcCA9IChvcHRpb25zID0gVUlDb21tb24uU0NST0xMX09QVElPTlMpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkuc2Nyb2xsSW50b1ZpZXcob3B0aW9ucyk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfTtcblxuICAgIGxldCBzaXplMiA9ICRkZXJpdmVkKFxuICAgICAgICBzdWJzaXplID8gc3Vic2l6ZSA6IHBhcnNlSW50KHNpemUpIDwgNiA/IHBhcnNlSW50KHNpemUpICsgMSA6IHNpemVcbiAgICApO1xuXG4gICAgbGV0IHNwYWNlZFN0eWxlID0gJGRlcml2ZWQoc3BhY2VkID8gXCJoYXMtdGV4dC1qdXN0aWZpZWRcIiA6IFwiXCIpO1xuXG4gICAgbGV0IHJlc3VsdFRpdGxlID0gJGRlcml2ZWQoXG4gICAgICAgIGA8aCR7c2l6ZX0gaWQ9XCIke2lkfVwiIHN0eWxlPVwidGV4dC1hbGlnbjogJHthbGlnbn07XCIgY2xhc3M9XCJ0aXRsZSAke3NwYWNlZFN0eWxlfSBpcy0ke3NpemV9XCI+JHskTE9DQUxFW3RpdGxlXX08L2gke3NpemV9PmBcbiAgICApO1xuICAgIGxldCByZXN1bHRTdWJ0aXRsZSA9ICRkZXJpdmVkKFxuICAgICAgICBgPGgke3NpemUyfSBpZD1cIiR7aWR9XCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiAke2FsaWdufTtcIiBjbGFzcz1cInN1YnRpdGxlIGlzLSR7c2l6ZTJ9XCI+JHskTE9DQUxFW3N1YnRpdGxlXX08L2gke3NpemUyfT5gXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I2lmIHRpdGxlfVxuICAgIHtAaHRtbCByZXN1bHRUaXRsZX1cbnsvaWZ9XG5cbnsjaWYgc3VidGl0bGV9XG4gICAge0BodG1sIHJlc3VsdFN1YnRpdGxlfVxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge29iamVjdH0gICAgUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbdGl0bGUgPSBcIm5vdC1ub2RlOmVtcHR5X2xpc3RfcGxhY2Vob2xkZXJcIl1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbc2l6ZSA9IDRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2FsaWduID0gJ2NlbnRlciddXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBQcm9wc1xuICAgICAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlID0gXCJub3Qtbm9kZTplbXB0eV9saXN0X3BsYWNlaG9sZGVyXCIsXG4gICAgICAgIHNpemUgPSA0LFxuICAgICAgICBhbGlnbiA9IFwiY2VudGVyXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlUaXRsZSB7dGl0bGV9IHtzaXplfSB7YWxpZ259IHsuLi5vdGhlcnN9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV0gLSBhdHRyaWJ1dGVzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gICAgICogQHByb3BlcnR5IHthbnl9IGRvd25sb2FkXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YXJnZXRdXG4gICAgICogQHByb3BlcnR5IHthbnl9IHJlbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpZ2h0XSAtIHZpc3VhbFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRpbmddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmFpc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dGxpbmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludmVydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdW5kZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnV0dG9uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3RhdGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaWNvbl0gLSBpY29uc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25dXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICB1cmwgPSBcIlwiLFxuICAgICAgICBkb3dubG9hZCxcbiAgICAgICAgdGFyZ2V0ID0gXCJfYmxhbmtcIixcbiAgICAgICAgcmVsLFxuICAgICAgICBsaWdodCA9IGZhbHNlLFxuICAgICAgICBsb2FkaW5nID0gZmFsc2UsXG4gICAgICAgIHJhaXNlZCA9IGZhbHNlLFxuICAgICAgICBvdXRsaW5lZCA9IGZhbHNlLFxuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlLFxuICAgICAgICByb3VuZGVkID0gZmFsc2UsXG4gICAgICAgIGJ1dHRvbiA9IHRydWUsXG4gICAgICAgIHN0YXRlOiBhY3RpdmVTdGF0ZSA9IFwiXCIsXG4gICAgICAgIHR5cGUgPSBcIlwiLFxuICAgICAgICBjb2xvciA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGljb24sXG4gICAgICAgIGljb25TaWRlID0gXCJyaWdodFwiLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgc2lkZUljb24oKX1cbiAgICA8c3BhbiBjbGFzcz1cImljb25cIlxuICAgICAgICA+PGkgY2xhc3M9XCJmYXMgZmEte2ljb259IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCI+PC9pPjwvc3BhblxuICAgID5cbnsvc25pcHBldH1cblxuPGFcbiAgICBvbmNsaWNrPXthY3Rpb24gfHwgb25jbGlja31cbiAgICBocmVmPXt1cmx9XG4gICAge3RhcmdldH1cbiAgICB7ZG93bmxvYWR9XG4gICAge3JlbH1cbiAgICBjbGFzcz1cIntjbGFzc2VzfSB7YWN0aXZlU3RhdGUgPyBgaXMtJHthY3RpdmVTdGF0ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgOiAnJ30ge3R5cGUgPyBgaXMtJHt0eXBlfWAgOiAnJ30ge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ31cIlxuICAgIGNsYXNzOmJ1dHRvblxuICAgIGNsYXNzOmlzLWxpZ2h0PXtsaWdodH1cbiAgICBjbGFzczppcy1pbnZlcnRlZD17aW52ZXJ0ZWR9XG4gICAgY2xhc3M6aXMtb3V0bGluZWQ9e291dGxpbmVkfVxuICAgIGNsYXNzOmlzLXJhaXNlZD17cmFpc2VkfVxuICAgIGNsYXNzOmlzLXJvdW5kZWQ9e3JvdW5kZWR9XG4gICAgY2xhc3M6aXMtbG9hZGluZz17bG9hZGluZ31cbj5cbiAgICB7I2lmIGljb259XG4gICAgICAgIHsjaWYgaWNvblNpZGUgPT09IFwibGVmdFwifXtAcmVuZGVyIHNpZGVJY29uKCl9ey9pZn1cbiAgICAgICAgeyNpZiB0aXRsZX08c3Bhbj57JExPQ0FMRVt0aXRsZV19PC9zcGFuPnsvaWZ9XG4gICAgICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbiAgICAgICAgeyNpZiBpY29uU2lkZSA9PT0gXCJyaWdodFwifXtAcmVuZGVyIHNpZGVJY29uKCl9ey9pZn1cbiAgICB7OmVsc2V9eyRMT0NBTEVbdGl0bGVdfXtAcmVuZGVyIGNoaWxkcmVuPy4oKX17L2lmfVxuPC9hPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMaW5rIGZyb20gXCIuL3VpLmxpbmsuc3ZlbHRlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgW3ZhbHVlcz1bXV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzZXM9JyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2VudGVyZWQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHQ9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbam9pbmVkID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2l0ZW1zUHJvcHMgPSB7fV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWVzID0gW10sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgY2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgcmlnaHQgPSBmYWxzZSxcbiAgICAgICAgam9pbmVkID0gdHJ1ZSxcbiAgICAgICAgaXRlbXNQcm9wcyA9IHt9LFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgbGlzdExpbmtzKCl9XG4gICAgeyNlYWNoIHZhbHVlcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgPFVJTGluayB7Li4uaXRlbX0gey4uLml0ZW1zUHJvcHN9IC8+XG4gICAgey9lYWNofVxuey9zbmlwcGV0fVxuXG57I2lmIGpvaW5lZH1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiZmllbGQgaGFzLWFkZG9ucyB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICA+XG4gICAgICAgIDxwIGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAge0ByZW5kZXIgbGlzdExpbmtzKCl9XG4gICAgICAgIDwvcD5cbiAgICA8L2Rpdj5cbns6ZWxzZX1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwiYnV0dG9ucyB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczppcy1jZW50ZXJlZD17Y2VudGVyZWR9XG4gICAgICAgIGNsYXNzOmlzLXJpZ2h0PXtyaWdodH1cbiAgICA+XG4gICAgICAgIHtAcmVuZGVyIGxpc3RMaW5rcygpfVxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpbmtzIGZyb20gXCIuLi9saW5rL3VpLmxpbmtzLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUNsaWNrYWJsZURpdiBmcm9tIFwiLi4vYmxvY2svdWkuY2xpY2thYmxlLmRpdi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgaW5kZXhcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R9IHRpdGxlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBkZXNjcmlwdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IFthY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpbmtzID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpc3RBY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpc3RMaW5rcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NvbW1vbkNsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBbaW1hZ2UgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gdmFsdWUgLSB2YWx1ZSBvZiBpdGVtLCB3aWxsIGJlIHBhc3NlZCB0byBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bWJlcn0gW2luZGV4ID0gLTFdIC0gaW5kZXggaW4gYXJyYXkgMC1sZW5ndGhcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmaXJzdCA9IGZhbHNlXSAtIGlmIGZpcnN0XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbGFzdCA9IGZhbHNlXSAtIGlmIGxhc3RcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlXSAtIGN1c3RvbWl6YXRpb25cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbWFnZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW2ltYWdlQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja1RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrRGVzY3JpcHRpb25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja0NvbnRlbnRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgICBsaW5rcyA9IFtdLFxuICAgICAgICBsaXN0QWN0aW9ucyA9IFtdLFxuICAgICAgICBsaXN0TGlua3MgPSBbXSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjb21tb25DbGFzcyA9IFwiXCIsXG4gICAgICAgIGltYWdlID0gXCJcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGZpcnN0ID0gZmFsc2UsXG4gICAgICAgIGxhc3QgPSBmYWxzZSxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50OiBVSUxpc3RJdGVtQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgdGl0bGVSZW5kZXJlcixcbiAgICAgICAgdGl0bGVDb21wb25lbnQ6IFVJVGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA2IH0sXG4gICAgICAgIGRlc2NyaXB0aW9uUmVuZGVyZXIsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50OiBVSURlc2NyaXB0aW9uQ29tcG9uZW50LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGltYWdlUmVuZGVyZXIsXG4gICAgICAgIGltYWdlQ29tcG9uZW50OiBVSUltYWdlQ29tcG9uZW50LFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIG9uY2xpY2ssXG4gICAgICAgIG9uY2xpY2tJbWFnZSxcbiAgICAgICAgb25jbGlja0NvbnRlbnQsXG4gICAgICAgIG9uY2xpY2tUaXRsZSxcbiAgICAgICAgb25jbGlja0Rlc2NyaXB0aW9uLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgIG9uY2xpY2sgJiYgb25jbGljayh2YWx1ZSk7XG4gICAgfVxuXG4gICAgbGV0IGFsbEFjdGlvbnMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBhbGxMaW5rcyA9ICRzdGF0ZShbXSk7XG5cbiAgICBjb25zdCBjYWxsYmFja1RlbXBsYXRlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgYWxsQWN0aW9ucyA9IFsuLi5hY3Rpb25zLCAuLi5saXN0QWN0aW9uc10ubWFwKChidG4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmJ0bixcbiAgICAgICAgICAgICAgICBpZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBidG4uYWN0aW9uID8gKCkgPT4gYnRuLmFjdGlvbih2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICBhbGxMaW5rcyA9IFsuLi5saW5rcywgLi4ubGlzdExpbmtzXS5tYXAoKGxpbmssIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsaW5rLmlkID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbGluaztcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwYXJhbXNTZXQgPSB7IHRpdGxlLCBkZXNjcmlwdGlvbiwgaW1hZ2UsIHZhbHVlLCBpbmRleCB9O1xuXG4gICAgY29uc3QgY2xpY2thYmxlSXRlbUVsZW1lbnRBdHRyaWJ1dGVzID0ge1xuICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICB0YWJpbmRleDogXCIwXCIsXG4gICAgICAgIG9uY2xpY2s6IG9uQ2xpY2ssXG4gICAgICAgIG9ua2V5dXA6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLmtleSA9PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGFkZGl0aW9uYWxFbGVtZW50QXR0cmlidXRlcyA9IG9uY2xpY2tcbiAgICAgICAgPyBjbGlja2FibGVJdGVtRWxlbWVudEF0dHJpYnV0ZXNcbiAgICAgICAgOiB7fTtcblxuICAgIGxldCBpbWFnZVByb3BzID0gJHN0YXRlKHt9KTtcbiAgICBsZXQgdGl0bGVQcm9wcyA9ICRzdGF0ZSh7fSk7XG4gICAgbGV0IGRlc2NyaXB0aW9uUHJvcHMgPSAkc3RhdGUoe30pO1xuXG4gICAgJGVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGltYWdlUHJvcHMgPSB7IC4uLmltYWdlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWFnZVByb3BzID0geyBpbWFnZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGl0bGVQcm9wcyA9IHsgLi4udGl0bGUgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlUHJvcHMgPSB7IHRpdGxlIH07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgICRlZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGRlc2NyaXB0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvblByb3BzID0geyAuLi5kZXNjcmlwdGlvbiB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25Qcm9wcyA9IHsgZGVzY3JpcHRpb24gfTtcbiAgICAgICAgfVxuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjc25pcHBldCBpdGVtQ29udGVudCgpfVxuICAgIHsjaWYgdGl0bGVSZW5kZXJlcn1cbiAgICAgICAge0ByZW5kZXIgdGl0bGVSZW5kZXJlcihwYXJhbXNTZXQpfVxuICAgIHs6ZWxzZSBpZiB0aXRsZX1cbiAgICAgICAgPFVJQ2xpY2thYmxlRGl2XG4gICAgICAgICAgICBjbGFzcz1cImxpc3QtaXRlbS10aXRsZVwiXG4gICAgICAgICAgICBjYWxsYmFjaz17Y2FsbGJhY2tUZW1wbGF0ZShvbmNsaWNrVGl0bGUpfVxuICAgICAgICA+XG4gICAgICAgICAgICB7I2lmIFVJVGl0bGVDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgPFVJVGl0bGVDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgey4uLnRpdGxlUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHsuLi50aXRsZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgICAgICB7b25jaGFuZ2V9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHs6ZWxzZX17dGl0bGV9ey9pZn1cbiAgICAgICAgPC9VSUNsaWNrYWJsZURpdj5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBkZXNjcmlwdGlvblJlbmRlcmVyfVxuICAgICAgICB7QHJlbmRlciBkZXNjcmlwdGlvblJlbmRlcmVyKHBhcmFtc1NldCl9XG4gICAgezplbHNlIGlmIGRlc2NyaXB0aW9ufVxuICAgICAgICA8VUlDbGlja2FibGVEaXZcbiAgICAgICAgICAgIGNsYXNzPVwibGlzdC1pdGVtLWRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgIGNhbGxiYWNrPXtjYWxsYmFja1RlbXBsYXRlKG9uY2xpY2tEZXNjcmlwdGlvbil9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgVUlEZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICA8VUlEZXNjcmlwdGlvbkNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICB7Li4uZGVzY3JpcHRpb25Qcm9wc31cbiAgICAgICAgICAgICAgICAgICAgey4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIHtvbmNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAge29uY2xpY2t9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHs6ZWxzZX17ZGVzY3JpcHRpb259ey9pZn1cbiAgICAgICAgPC9VSUNsaWNrYWJsZURpdj5cbiAgICB7L2lmfVxuey9zbmlwcGV0fVxuXG48ZGl2XG4gICAgey4uLmFkZGl0aW9uYWxFbGVtZW50QXR0cmlidXRlc31cbiAgICBjbGFzczppcy1jbGlja2FibGU9e29uY2xpY2t9XG4gICAgY2xhc3M6bGlzdC1pdGVtLWxhc3Q9e2xhc3R9XG4gICAgY2xhc3M6bGlzdC1pdGVtLWZpcnN0PXtmaXJzdH1cbiAgICBjbGFzczpsaXN0LWl0ZW0tb2RkPXtpbmRleCAlIDIgPT09IDF9XG4gICAgY2xhc3M6bGlzdC1pdGVtLWV2ZW49e2luZGV4ICUgMiA9PT0gMH1cbiAgICBjbGFzcz1cImxpc3QtaXRlbSB7Y2xhc3Nlc30ge2NvbW1vbkNsYXNzfSB7YGxpc3QtaXRlbS1hdC0ke2luZGV4fWB9XCJcbj5cbiAgICB7I2lmIGltYWdlfVxuICAgICAgICB7I2lmIGltYWdlUmVuZGVyZXJ9XG4gICAgICAgICAgICB7QHJlbmRlciBpbWFnZVJlbmRlcmVyKHBhcmFtc1NldCl9XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxVSUNsaWNrYWJsZURpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwibGlzdC1pdGVtLWltYWdlXCJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaz17Y2FsbGJhY2tUZW1wbGF0ZShvbmNsaWNrSW1hZ2UpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsjaWYgVUlJbWFnZUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgPFVJSW1hZ2VDb21wb25lbnQgey4uLmltYWdlUHJvcHN9IC8+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVwiaW1hZ2UgaXMtNjR4NjRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImlzLXJvdW5kZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17aW1hZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PXt0aXRsZSA/IHRpdGxlPy50aXRsZSB8fCB0aXRsZSA6IGltYWdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9maWd1cmU+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvVUlDbGlja2FibGVEaXY+XG4gICAgICAgIHsvaWZ9XG4gICAgey9pZn1cblxuICAgIHsjaWYgVUlMaXN0SXRlbUNvbnRlbnRDb21wb25lbnR9XG4gICAgICAgIDxVSUxpc3RJdGVtQ29udGVudENvbXBvbmVudCB7Li4ubGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHN9PlxuICAgICAgICAgICAge0ByZW5kZXIgaXRlbUNvbnRlbnQoKX1cbiAgICAgICAgPC9VSUxpc3RJdGVtQ29udGVudENvbXBvbmVudD5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxVSUNsaWNrYWJsZURpdlxuICAgICAgICAgICAgY2xhc3M9XCJsaXN0LWl0ZW0tY29udGVudFwiXG4gICAgICAgICAgICBjYWxsYmFjaz17Y2FsbGJhY2tUZW1wbGF0ZShvbmNsaWNrQ29udGVudCl9XG4gICAgICAgID5cbiAgICAgICAgICAgIHtAcmVuZGVyIGl0ZW1Db250ZW50KCl9PC9VSUNsaWNrYWJsZURpdlxuICAgICAgICA+XG4gICAgey9pZn1cblxuICAgIHsjaWYgKGFsbEFjdGlvbnMgJiYgYWxsQWN0aW9ucy5sZW5ndGgpIHx8IChhbGxMaW5rcyAmJiBhbGxMaW5rcy5sZW5ndGgpfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdC1pdGVtLWNvbnRyb2xzXCI+XG4gICAgICAgICAgICB7I2lmIGFsbEFjdGlvbnMgJiYgYWxsQWN0aW9ucy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e2FsbEFjdGlvbnN9IHJpZ2h0PXt0cnVlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgYWxsTGlua3MgJiYgYWxsTGlua3MubGVuZ3RofVxuICAgICAgICAgICAgICAgIDxVSUxpbmtzIHZhbHVlcz17YWxsTGlua3N9IHJpZ2h0PXt0cnVlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlMaXN0SXRlbSBmcm9tIFwiLi91aS5saXN0Lml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpZEZpZWxkTmFtZSA9IFwiaWRcIl1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICBbaXRlbXMgPSBbXV1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSAgICBbYWN0aW9ucyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9ICAgIFtsaW5rcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtpdGVtQ2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtsaXN0SXRlbUNvbnRlbnRDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2xpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2xpc3RJdGVtUmVuZGVyZXJdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2xpc3RJdGVtQ29tcG9uZW50ID0gVUlMaXN0SXRlbV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbbGlzdEl0ZW1Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZVJlbmRlcmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW3RpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDYgfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25SZW5kZXJlcl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25Db21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW1hZ2VSZW5kZXJlcl1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBpbWFnZUNvbXBvbmVudFxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgIFtpbWFnZUNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tDb250ZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrRGVzY3JpcHRpb25dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tJbWFnZV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jbGlja1RpdGxlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZEZpZWxkTmFtZSA9IFwiaWRcIixcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgICBsaW5rcyA9IFtdLFxuICAgICAgICBpdGVtQ2xhc3MgPSBcIlwiLFxuICAgICAgICBsaXN0SXRlbUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIGxpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RJdGVtUmVuZGVyZXIsXG4gICAgICAgIGxpc3RJdGVtQ29tcG9uZW50OiBVSUxpc3RJdGVtQ29tcG9uZW50ID0gVUlMaXN0SXRlbSxcbiAgICAgICAgbGlzdEl0ZW1Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICB0aXRsZVJlbmRlcmVyLFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDYgfSxcbiAgICAgICAgZGVzY3JpcHRpb25SZW5kZXJlcixcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnQsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgaW1hZ2VSZW5kZXJlcixcbiAgICAgICAgaW1hZ2VDb21wb25lbnQsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25jbGlja0NvbnRlbnQsXG4gICAgICAgIG9uY2xpY2tEZXNjcmlwdGlvbixcbiAgICAgICAgb25jbGlja0ltYWdlLFxuICAgICAgICBvbmNsaWNrVGl0bGUsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXN9XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0sIGluZGV4IChpdGVtW2lkRmllbGROYW1lXSl9XG4gICAgICAgIHsjaWYgbGlzdEl0ZW1SZW5kZXJlcn1cbiAgICAgICAgICAgIHtAcmVuZGVyIGxpc3RJdGVtUmVuZGVyZXIoaXRlbSwgaW5kZXgpfVxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8VUlMaXN0SXRlbUNvbXBvbmVudFxuICAgICAgICAgICAgICAgIHsuLi5saXN0SXRlbUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHtsaXN0SXRlbUNvbnRlbnRDb21wb25lbnR9XG4gICAgICAgICAgICAgICAge2xpc3RJdGVtQ29udGVudENvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHt0aXRsZVJlbmRlcmVyfVxuICAgICAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb25SZW5kZXJlcn1cbiAgICAgICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgICAgICAgICAgICAge2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICAgICAge2ltYWdlUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAgICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgIHsuLi5pdGVtc1tpbmRleF19XG4gICAgICAgICAgICAgICAgbGlzdEFjdGlvbnM9e2FjdGlvbnN9XG4gICAgICAgICAgICAgICAgbGlzdExpbmtzPXtsaW5rc31cbiAgICAgICAgICAgICAgICB2YWx1ZT17aXRlbXNbaW5kZXhdLnZhbHVlfVxuICAgICAgICAgICAgICAgIGNvbW1vbkNsYXNzPXtpdGVtQ2xhc3N9XG4gICAgICAgICAgICAgICAge2luZGV4fVxuICAgICAgICAgICAgICAgIGZpcnN0PXtpbmRleCA9PT0gMH1cbiAgICAgICAgICAgICAgICBsYXN0PXtpbmRleCA9PT0gaXRlbXMubGVuZ3RoIC0gMX1cbiAgICAgICAgICAgICAgICB7b25jbGlja31cbiAgICAgICAgICAgICAgICB7b25jbGlja0NvbnRlbnR9XG4gICAgICAgICAgICAgICAge29uY2xpY2tEZXNjcmlwdGlvbn1cbiAgICAgICAgICAgICAgICB7b25jbGlja0ltYWdlfVxuICAgICAgICAgICAgICAgIHtvbmNsaWNrVGl0bGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxpc3RFbXB0eVBsYWNlaG9sZGVyIGZyb20gXCIuL3VpLmxpc3QuZW1wdHkucGxhY2Vob2xkZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTGlzdEl0ZW0gZnJvbSBcIi4vdWkubGlzdC5pdGVtLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpc3RCbG9jayBmcm9tIFwiLi91aS5saXN0LmJsb2NrLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuXG4gICAgLy9jdXN0b21pemF0aW9uXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IFtpdGVtcyA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IFthY3Rpb25zID0gW11dXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gW2xpbmtzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWN0aW9uc1Zpc2libGUgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpdGVtc0hvdmVyYWJsZSA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJmbG93RWxsaXBzaXMgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtoaWRkZW5JbWFnZXMgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2l0ZW1DbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVtTGVuZ3RoXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZEZpZWxkTmFtZSA9ICdpZCddXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2VtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50ID0gVUlMaXN0RW1wdHlQbGFjZWhvbGRlcl0gLSBlbXB0eVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtsaXN0SXRlbUNvbXBvbmVudCA9IFVJTGlzdEl0ZW1dIC0gaXRlbVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbbGlzdEl0ZW1Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFt0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGVdIC0gaXRlbSBwYXJ0c1xuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdGl0bGVDb21wb25lbnRQcm9wcyA9IHtzaXplOiA2fV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZGVzY3JpcHRpb25Db21wb25lbnRdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2ltYWdlQ29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbaW1hZ2VDb21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNoYW5nZV0gICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrXSAgICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrQ29udGVudF0gICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrRGVzY3JpcHRpb25dICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrSW1hZ2VdICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNsaWNrVGl0bGVdICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgIGFjdGlvbnMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgYWN0aW9uc1Zpc2libGUgPSBmYWxzZSxcbiAgICAgICAgaXRlbXNIb3ZlcmFibGUgPSBmYWxzZSxcbiAgICAgICAgb3ZlcmZsb3dFbGxpcHNpcyA9IGZhbHNlLFxuICAgICAgICBoaWRkZW5JbWFnZXMgPSBmYWxzZSxcbiAgICAgICAgaXRlbUNsYXNzID0gXCJcIixcbiAgICAgICAgaXRlbUxlbmd0aCxcbiAgICAgICAgaWRGaWVsZE5hbWUgPSBcImlkXCIsXG4gICAgICAgIGVtcHR5TGlzdFJlbmRlcmVyLFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudDpcbiAgICAgICAgICAgIFVJRW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnQgPSBVSUxpc3RFbXB0eVBsYWNlaG9sZGVyLFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RJdGVtQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgbGlzdEl0ZW1Db250ZW50Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdEl0ZW1SZW5kZXJlcixcbiAgICAgICAgbGlzdEl0ZW1Db21wb25lbnQgPSBVSUxpc3RJdGVtLFxuICAgICAgICBsaXN0SXRlbUNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIHRpdGxlUmVuZGVyZXIsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50ID0gVUlUaXRsZSxcbiAgICAgICAgdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNiB9LFxuICAgICAgICBkZXNjcmlwdGlvblJlbmRlcmVyLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBpbWFnZVJlbmRlcmVyLFxuICAgICAgICBpbWFnZUNvbXBvbmVudCxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBvbmNoYW5nZSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25jbGlja0NvbnRlbnQsXG4gICAgICAgIG9uY2xpY2tEZXNjcmlwdGlvbixcbiAgICAgICAgb25jbGlja0ltYWdlLFxuICAgICAgICBvbmNsaWNrVGl0bGUsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbXMubGVuZ3RofVxuICAgIDxkaXZcbiAgICAgICAgc3R5bGU9e2l0ZW1MZW5ndGggPyBgLS1sZW5ndGg6ICR7aXRlbUxlbmd0aH07YCA6IFwiXCJ9XG4gICAgICAgIGNsYXNzPVwibGlzdCB7Y2xhc3Nlc31cIlxuICAgICAgICBjbGFzczpoYXMtdmlzaWJsZS1wb2ludGVyLWNvbnRyb2xzPXthY3Rpb25zVmlzaWJsZX1cbiAgICAgICAgY2xhc3M6aGFzLWhvdmVyYWJsZS1saXN0LWl0ZW1zPXtpdGVtc0hvdmVyYWJsZX1cbiAgICAgICAgY2xhc3M6aGFzLW92ZXJmbG93LWVsbGlwc2lzPXtvdmVyZmxvd0VsbGlwc2lzfVxuICAgICAgICBjbGFzczpoYXMtaGlkZGVuLWltYWdlcz17aGlkZGVuSW1hZ2VzfVxuICAgID5cbiAgICAgICAgPFVJTGlzdEJsb2NrXG4gICAgICAgICAgICB7aXRlbXN9XG4gICAgICAgICAgICB7aXRlbUNsYXNzfVxuICAgICAgICAgICAge2xpc3RJdGVtQ29udGVudENvbXBvbmVudH1cbiAgICAgICAgICAgIHtsaXN0SXRlbUNvbnRlbnRDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtsaXN0SXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAge2xpc3RJdGVtQ29tcG9uZW50fVxuICAgICAgICAgICAge2xpc3RJdGVtQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7aWRGaWVsZE5hbWV9XG4gICAgICAgICAgICB7dGl0bGVSZW5kZXJlcn1cbiAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICAgICAgICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAge2Rlc2NyaXB0aW9uUmVuZGVyZXJ9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgICAgICAgICB7ZGVzY3JpcHRpb25Db21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtpbWFnZVJlbmRlcmVyfVxuICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50fVxuICAgICAgICAgICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4gICAgICAgICAgICB7YWN0aW9uc31cbiAgICAgICAgICAgIHtsaW5rc31cbiAgICAgICAgICAgIHtvbmNoYW5nZX1cbiAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAge29uY2xpY2tDb250ZW50fVxuICAgICAgICAgICAge29uY2xpY2tEZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIHtvbmNsaWNrSW1hZ2V9XG4gICAgICAgICAgICB7b25jbGlja1RpdGxlfVxuICAgICAgICAvPlxuICAgIDwvZGl2PlxuezplbHNlIGlmIGVtcHR5TGlzdFJlbmRlcmVyfVxuICAgIHtAcmVuZGVyIGVtcHR5TGlzdFJlbmRlcmVyKGVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHMpfVxuezplbHNlfVxuICAgIDxVSUVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50IHsuLi5lbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudFByb3BzfSAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi9mcmFtZS9MSUIuanNcIjtcbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb24uanNcIjtcbiAgICBpbXBvcnQgVUlMaXN0IGZyb20gXCIuLi9saXN0L3VpLmxpc3Quc3ZlbHRlXCI7XG5cbiAgICAvL2ZpZWxkIHByb3BzXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lucHV0U3RhcnRlZF0gLSBzdmVsdGUtaWdub3JlIHVudXNlZC1leHBvcnQtbGV0XG4gICAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW211bHRpcGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZF0gLSB2YWxpZGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Vycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtRXJyb3JzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zvcm1MZXZlbEVycm9yXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbW9kZWxOYW1lXSAtIG1vZGVsIGJpbmRpbmdzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpb25OYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uRmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uU29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uUGFnZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25TZWFyY2hdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25JZF0gLSBwcmVzZW50YXRpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvblRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VsZWN0b3JVSV0gLSBzZWxlY3RvciBVSSB0byBhZGQgbmV3IGl0ZW0gdG8gbGlzdFxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VsZWN0b3JVSVByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaXRlbVVJXSAtIGxpc3QgaXRlbSBVSSB0byBwcmVzZW50IGluIHJlYWRvbmx5IG9yIGVkaXRhYmxlIHZhcmlhbnRzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtVUlQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RyYW5zZm9ybVZhbHVlSXRlbVRvTGlzdEl0ZW1dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFtdKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIGZpZWxkbmFtZSA9ICRiaW5kYWJsZShcInNlbGVjdEZyb21Nb2RlbFwiKSxcbiAgICAgICAgcmVxdWlyZWQgPSAkYmluZGFibGUodHJ1ZSksXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIG11bHRpcGxlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgc2l6ZSA9ICRiaW5kYWJsZSg4KSxcbiAgICAgICAgdmFsaWQgPSAkYmluZGFibGUodHJ1ZSksXG4gICAgICAgIG1vZGVsTmFtZSA9IFwiXCIsXG4gICAgICAgIGFjdGlvbk5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25GaWx0ZXIgPSB7fSxcbiAgICAgICAgYWN0aW9uU29ydGVyID0ge30sXG4gICAgICAgIGFjdGlvblBhZ2VyID0ge30sXG4gICAgICAgIGFjdGlvblNlYXJjaCA9IHVuZGVmaW5lZCxcbiAgICAgICAgb3B0aW9uSWQgPSBcIjpfaWRcIixcbiAgICAgICAgb3B0aW9uVGl0bGUgPSBcIjp0aXRsZVwiLFxuICAgICAgICBzZWxlY3RvclVJID0gXCJVSVNlbGVjdEZyb21Nb2RlbE9uRGVtYW5kSW5saW5lXCIsXG4gICAgICAgIHNlbGVjdG9yVUlQcm9wcyA9IHt9LFxuICAgICAgICBpdGVtVUkgPSBcIlVJTGlzdEl0ZW1cIixcbiAgICAgICAgaXRlbVVJUHJvcHMgPSB7fSxcbiAgICAgICAgdHJhbnNmb3JtVmFsdWVJdGVtVG9MaXN0SXRlbSA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5faWQsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogaXRlbS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFkZEl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlLnB1c2goaXRlbSk7XG4gICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGl0ZW1zID0gJGRlcml2ZWQoXG4gICAgICAgIHZhbHVlLm1hcCA/IHZhbHVlLm1hcCh0cmFuc2Zvcm1WYWx1ZUl0ZW1Ub0xpc3RJdGVtKSA6IFtdXG4gICAgKTtcblxuICAgIGNvbnN0IEFDVElPTlMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbihsaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGxpc3RJdGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHZhbHVlLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlSXRlbSkgPT4gdmFsdWVJdGVtID09PSB2YWxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxDb3B5ID0gWy4uLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm1vdmVJdGVtKHZhbENvcHksIGl0ZW1JbmRleCwgaXRlbUluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsQ29weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICBpY29uOiBcImFycm93LXVwXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJub3JtYWxcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAobGlzdEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0SXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSW5kZXggPSB2YWx1ZS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUl0ZW0pID0+IHZhbHVlSXRlbSA9PT0gdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsQ29weSA9IFsuLi52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5tb3ZlSXRlbSh2YWxDb3B5LCBpdGVtSW5kZXgsIGl0ZW1JbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbENvcHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICAgICAgaWNvbjogXCJhcnJvdy1kb3duXCIsXG4gICAgICAgICAgICBjb2xvcjogXCJub3JtYWxcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAobGlzdEl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0SXRlbS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSW5kZXggPSB2YWx1ZS5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZUl0ZW0pID0+IHZhbHVlSXRlbSA9PT0gdmFsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpdGxlOiBcIlwiLFxuICAgICAgICAgICAgaWNvbjogXCJ0cmFzaFwiLFxuICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgIH0sXG4gICAgXTtcbjwvc2NyaXB0PlxuXG48VUlMaXN0XG4gICAgbGlzdEl0ZW1Db21wb25lbnQ9e0NPTVBPTkVOVFMuZ2V0KGl0ZW1VSSl9XG4gICAgey4uLml0ZW1VSVByb3BzfVxuICAgIHtpdGVtc31cbiAgICBhY3Rpb25zPXtBQ1RJT05TfVxuLz5cbnsjaWYgIXJlYWRvbmx5fVxuICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gQ09NUE9ORU5UUy5nZXQoc2VsZWN0b3JVSSl9XG4gICAgPFN2ZWx0ZUNvbXBvbmVudFxuICAgICAgICB7Li4uc2VsZWN0b3JVSVByb3BzfVxuICAgICAgICB7bW9kZWxOYW1lfVxuICAgICAgICB7YWN0aW9uTmFtZX1cbiAgICAgICAge2FjdGlvbkZpbHRlcn1cbiAgICAgICAge2FjdGlvblNvcnRlcn1cbiAgICAgICAge2FjdGlvblBhZ2VyfVxuICAgICAgICB7YWN0aW9uU2VhcmNofVxuICAgICAgICB7b3B0aW9uSWR9XG4gICAgICAgIHtvcHRpb25UaXRsZX1cbiAgICAgICAgYmluZDpwbGFjZWhvbGRlclxuICAgICAgICBiaW5kOmZpZWxkbmFtZVxuICAgICAgICBiaW5kOnJlcXVpcmVkXG4gICAgICAgIGJpbmQ6bXVsdGlwbGVcbiAgICAgICAgYmluZDpzaXplXG4gICAgICAgIGJpbmQ6dmFsaWRcbiAgICAgICAgb246cmVzb2x2ZT17KGUpID0+IGFkZEl0ZW0oZS5kZXRhaWwpfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbmFycm93PWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBzaXplXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBzaXplLFxuICAgICAgICBuYXJyb3cgPSBmYWxzZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2XG4gICAgY2xhc3M9XCJjb2x1bW4ge2NsYXNzZXN9IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9XCJcbiAgICBjbGFzczppcy1uYXJyb3c9e25hcnJvd31cbiAgICB7Li4ub3RoZXJzfVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLCBjaGlsZHJlbiwgLi4ub3RoZXJzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiY29sdW1ucyB7Y2xhc3Nlc31cIiB7Li4ub3RoZXJzfT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkID0gJyddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGUgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9sZT1cImJ1dHRvblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSAgIFt0YWJJbmRleD0wXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dpZGVzY3JlZW49ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZnVsbGhkPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21heERlc2t0b3A9ZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbWF4V2lkZXNjcmVlbj1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmbHVpZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdzdmVsdGUnKS5TbmlwcGV0fSBbY2hpbGRyZW5dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJcIixcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IFwiMFwiLFxuICAgICAgICB3aWRlc2NyZWVuID0gZmFsc2UsXG4gICAgICAgIGZ1bGxoZCA9IGZhbHNlLFxuICAgICAgICBtYXhEZXNrdG9wID0gZmFsc2UsXG4gICAgICAgIG1heFdpZGVzY3JlZW4gPSBmYWxzZSxcbiAgICAgICAgZmx1aWQgPSBmYWxzZSxcbiAgICAgICAgb25jbGljayxcbiAgICAgICAgb25rZXl1cCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxkaXZcbiAgICB7aWR9XG4gICAge3RpdGxlfVxuICAgIGNsYXNzPVwiY29udGFpbmVyIHtjbGFzc2VzfVwiXG4gICAgY2xhc3M6aXMtd2lkZXNjcmVlbj17d2lkZXNjcmVlbn1cbiAgICBjbGFzczppcy1mdWxsaGQ9e2Z1bGxoZH1cbiAgICBjbGFzczppcy1tYXgtZGVza3RvcD17bWF4RGVza3RvcH1cbiAgICBjbGFzczppcy1tYXgtd2lkZXNjcmVlbj17bWF4V2lkZXNjcmVlbn1cbiAgICBjbGFzczppcy1mbHVpZD17Zmx1aWR9XG4gICAge29uY2xpY2t9XG4gICAge29ua2V5dXB9XG4gICAge3JvbGV9XG4gICAge3RhYkluZGV4fVxuPlxuICAgIHtAcmVuZGVyIGNoaWxkcmVuPy4oKX1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc11cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnc3ZlbHRlJykuU25pcHBldH0gW2NoaWxkcmVuXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQgeyBpZCA9IFwiXCIsIGNsYXNzOiBjbGFzc2VzID0gXCJcIiwgY2hpbGRyZW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxmb290ZXIge2lkfSBjbGFzcz1cImZvb3RlciB7Y2xhc3Nlc30gXCI+XG4gICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuPC9mb290ZXI+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZCA9ICcnXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb2xlPVwiYnV0dG9uXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YWJJbmRleCA9IDBdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQgPSBcIlwiLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIHJvbGUgPSBcImJ1dHRvblwiLFxuICAgICAgICB0YWJJbmRleCA9IFwiMFwiLFxuICAgICAgICBvbmNsaWNrLFxuICAgICAgICBvbmtleXVwLFxuICAgICAgICBjaGlsZHJlbixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPHNlY3Rpb24ge2lkfSBjbGFzcz1cInNlY3Rpb24ge2NsYXNzZXN9XCIge29uY2xpY2t9IHtvbmtleXVwfSB7cm9sZX0ge3RhYkluZGV4fT5cbiAgICB7QHJlbmRlciBjaGlsZHJlbj8uKCl9XG48L3NlY3Rpb24+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YWddXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgdGFnID0gXCJkaXZcIiwgY2hpbGRyZW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6ZWxlbWVudCB0aGlzPXt0YWd9PlxuICAgIHsjaWYgY2hpbGRyZW59e0ByZW5kZXIgY2hpbGRyZW4/LigpfXs6ZWxzZX08IS0tIG9wdGlvbmFsIGZhbGxiYWNrIC0tPnsvaWZ9XG48L3N2ZWx0ZTplbGVtZW50PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoMCksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCIwLjBcIixcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbWF4ID0gMTAwLFxuICAgICAgICBzdGVwID0gMSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJudW1iZXJcIixcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNpemUsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG5cbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmNoYW5nZSA9IG9uaW5wdXQ7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25pbnB1dCA9IG9uaW5wdXQ7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPHA+e3ZhbHVlfTwvcD5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLW51bWJlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgICAgICA/IGBpcy0ke2NvbG9yfWBcbiAgICAgICAgICAgIDogJyd9IHtjbGFzc2VzfVwiXG4gICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHttaW59XG4gICAgICAgIHttYXh9XG4gICAgICAgIHtzdGVwfVxuICAgICAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9mcmFtZS9jb21tb25cIjtcblxuICAgIGltcG9ydCB7IFVJQ29sdW1ucywgVUlDb2x1bW4gfSBmcm9tIFwiLi4vbGF5b3V0XCI7XG4gICAgaW1wb3J0IHsgVUlCdXR0b24gfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG4gICAgaW1wb3J0IFVJTnVtYmVyIGZyb20gXCIuL3VpLm51bWJlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUZXh0ZmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSVRpdGxlIH0gZnJvbSBcIi4uL3ZhcmlvdXNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZmllbGRuYW1lID0gXCJudW1iZXJzX2xpc3RcIixcbiAgICAgICAgdmFsdWUgPSB7fSxcbiAgICAgICAgZGVmYXVsdEl0ZW1UaXRsZSA9IFwiXCIsXG4gICAgICAgIGRlZmF1bHRJdGVtVmFsdWUgPSAwLFxuICAgICAgICBsYWJlbCA9IFwibmFtZWQgbnVtYmVycyBsaXN0XCIsXG4gICAgICAgIGxhYmVsU2l6ZSA9IDUsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJuZXcgaXRlbVwiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGNvbnN0IGNyZWF0ZU5ld1ZhbCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBkZWZhdWx0SXRlbVRpdGxlLFxuICAgICAgICAgICAgbnVtYmVyOiBkZWZhdWx0SXRlbVZhbHVlLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBsZXQgbmV3VmFsID0gJHN0YXRlKGNyZWF0ZU5ld1ZhbCgpKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybU9iamVjdFRvTGlzdCA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IG5hbWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgbnVtYmVyOiB2YWx1ZVtuYW1lXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBsZXQgbGlzdCA9ICRzdGF0ZSh0cmFuc2Zvcm1PYmplY3RUb0xpc3QoKSk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModmFsdWUsIGlkKSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2lkXTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBsaXN0ID0gdHJhbnNmb3JtT2JqZWN0VG9MaXN0KCk7XG4gICAgICAgICAgICBvbmNoYW5nZSh7IHZhbHVlLCBmaWVsZDogZmllbGRuYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKCkge1xuICAgICAgICBjb25zdCBpZCA9IG5ld1ZhbC5pZC50cmltKCk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KG5ld1ZhbC5udW1iZXIpO1xuICAgICAgICBpZiAoaWQgJiYgaWQgIT09IFwiXCIgJiYgIWlzTmFOKG51bWJlcikgJiYgIW5vdENvbW1vbi5vYmpIYXModmFsdWUsIGlkKSkge1xuICAgICAgICAgICAgdmFsdWVbaWRdID0gbnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QgPSB0cmFuc2Zvcm1PYmplY3RUb0xpc3QoKTtcbiAgICAgICAgb25jaGFuZ2UoeyB2YWx1ZTogJHN0YXRlLnNuYXBzaG90KHZhbHVlKSwgZmllbGQ6IGZpZWxkbmFtZSB9KTtcbiAgICAgICAgbmV3VmFsID0gY3JlYXRlTmV3VmFsKCk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxVSVRpdGxlIHRpdGxlPXtsYWJlbH0gc2l6ZT17bGFiZWxTaXplfSAvPlxueyNlYWNoIGxpc3QgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgPFVJQ29sdW1ucyBjbGFzcz17Y2xhc3Nlc30ge2Rpc2FibGVkfT5cbiAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy02XCI+XG4gICAgICAgICAgICB7aXRlbS50aXRsZX1cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy00XCI+XG4gICAgICAgICAgICB7aXRlbS5udW1iZXJ9XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgICAgIHsjaWYgIXJlYWRvbmx5fVxuICAgICAgICAgICAgPFVJQ29sdW1uIGNsYXNzZXM9XCJpcy0yXCI+XG4gICAgICAgICAgICAgICAgPFVJQnV0dG9uIGljb249e1wibWludXNcIn0gYWN0aW9uPXsoKSA9PiByZW1vdmUoaXRlbS5pZCl9IC8+XG4gICAgICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICB7L2lmfVxuICAgIDwvVUlDb2x1bW5zPlxuey9lYWNofVxueyNpZiAhcmVhZG9ubHl9XG4gICAgPFVJQ29sdW1ucyBjbGFzcz17Y2xhc3Nlc30+XG4gICAgICAgIDxVSUNvbHVtbiBjbGFzc2VzPVwiaXMtNlwiPlxuICAgICAgICAgICAgPFVJVGV4dGZpZWxkXG4gICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17bmV3VmFsLmlkfVxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICByZXF1aXJlZD17ZmFsc2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTRcIj5cbiAgICAgICAgICAgIDxVSU51bWJlciBiaW5kOnZhbHVlPXtuZXdWYWwubnVtYmVyfSAvPlxuICAgICAgICA8L1VJQ29sdW1uPlxuICAgICAgICA8VUlDb2x1bW4gY2xhc3Nlcz1cImlzLTJcIj5cbiAgICAgICAgICAgIDxVSUJ1dHRvbiBpY29uPXtcInBsdXNcIn0gYWN0aW9uPXsoKSA9PiBhZGQoKX0gLz5cbiAgICAgICAgPC9VSUNvbHVtbj5cbiAgICA8L1VJQ29sdW1ucz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInBhc3N3b3JkXCIsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wcyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG48aW5wdXRcbiAgICBpZD1cImZvcm0tZmllbGQtcGFzc3dvcmQte2ZpZWxkbmFtZX1cIlxuICAgIGNsYXNzPVwiaW5wdXQge3NpemUgPyBgaXMtJHtzaXplfWAgOiAnJ30ge2NvbG9yXG4gICAgICAgID8gYGlzLSR7Y29sb3J9YFxuICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgIHR5cGU9XCJwYXNzd29yZFwiXG4gICAgbmFtZT17ZmllbGRuYW1lfVxuICAgIGJpbmQ6dmFsdWVcbiAgICB7aW52YWxpZH1cbiAgICB7cmVxdWlyZWR9XG4gICAge3JlYWRvbmx5fVxuICAgIHtkaXNhYmxlZH1cbiAgICBwbGFjZWhvbGRlcj17JExPQ0FMRVtwbGFjZWhvbGRlcl19XG4gICAgYXV0b2NvbXBsZXRlPXtmaWVsZG5hbWV9XG4gICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgey4uLm90aGVyc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxGdWxsXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaW1hZ2VcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWx0XVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29ycz0nYW5vbnltb3VzJ11cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemUgPSA2NF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW2hlaWdodF1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnRhaW5lZD1mYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb3ZlcmVkPWZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50YWJsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzID0gJyddXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29uY2xpY2tdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ua2V5dXBdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHVybEZ1bGwsXG4gICAgICAgIHVybCxcbiAgICAgICAgaW1hZ2UsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBhbHQsXG4gICAgICAgIGNvcnMgPSBcImFub255bW91c1wiLFxuICAgICAgICBzaXplID0gNjQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNvbnRhaW5lZCA9IGZhbHNlLFxuICAgICAgICBjb3ZlcmVkID0gZmFsc2UsXG4gICAgICAgIHBvaW50YWJsZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNsaWNrID0gdW5kZWZpbmVkLFxuICAgICAgICBvbmtleXVwID0gdW5kZWZpbmVkLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgaW1hZ2VGaWd1cmUoKX1cbiAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeV9ub19ub25pbnRlcmFjdGl2ZV9lbGVtZW50X2ludGVyYWN0aW9ucyAtLT5cbiAgICA8ZmlndXJlXG4gICAgICAgIGNsYXNzPVwiaW1hZ2Uge2NsYXNzZXN9IHshd2lkdGggJiYgIWhlaWdodFxuICAgICAgICAgICAgPyBpc05hTihzaXplKVxuICAgICAgICAgICAgICAgID8gYGlzLSR7c2l6ZX1gXG4gICAgICAgICAgICAgICAgOiBgaXMtJHtzaXplfXgke3NpemV9YFxuICAgICAgICAgICAgOiAnJ31cIlxuICAgICAgICBjbGFzczppcy1jb250YWluZWQ9e2NvbnRhaW5lZH1cbiAgICAgICAgY2xhc3M6aXMtY292ZXJlZD17Y292ZXJlZH1cbiAgICAgICAgY2xhc3M6aXMtY2xpY2thYmxlPXsob25jbGljayAmJiBwb2ludGFibGUgIT09IGZhbHNlKSB8fCBwb2ludGFibGV9XG4gICAgICAgIHN0eWxlPXsod2lkdGggPyBgd2lkdGg6ICR7d2lkdGh9O2AgOiBcIlwiKSArXG4gICAgICAgICAgICAoaGVpZ2h0ID8gYGhlaWdodDogJHtoZWlnaHR9O2AgOiBcIlwiKX1cbiAgICA+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICAgIHtvbmNsaWNrfVxuICAgICAgICAgICAge29ua2V5dXB9XG4gICAgICAgICAgICBjbGFzcz1cIlwiXG4gICAgICAgICAgICBhbHQ9e2FsdCB8fCB0aXRsZX1cbiAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgIHNyYz17dXJsIHx8IGltYWdlfVxuICAgICAgICAgICAgY3Jvc3NPcmlnaW49e2NvcnN9XG4gICAgICAgIC8+XG4gICAgPC9maWd1cmU+XG57L3NuaXBwZXR9XG5cbnsjaWYgdXJsRnVsbH1cbiAgICA8YSBocmVmPXt1cmxGdWxsfSB0aXRsZT17dGl0bGUgfHwgYWx0fSB7b25jbGlja30+XG4gICAgICAgIHtAcmVuZGVyIGltYWdlRmlndXJlKCl9XG4gICAgPC9hPlxuezplbHNlfVxuICAgIHtAcmVuZGVyIGltYWdlRmlndXJlKCl9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL2xpc3QvdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlUaXRsZSBmcm9tIFwiLi4vdmFyaW91cy91aS50aXRsZS5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbnMuc3ZlbHRlXCI7XG5cbiAgICAvL1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhcmlhbnRzXSAtIFtcbmFycmF5IG9mIGdyb3Vwc1xue1xuaWQ6bnVtYmVyLFxudGl0bGU6c3RyaW5nfG9iamVjdCxcbmltYWdlOnN0cmluZ3xvYmplY3QsXG52YXJpYW50cyA9IFtcbmFycmF5IG9mIHZhbHVlcyB2YXJpYW50cyBpbiBncm91cFxue1xuaWQ6bnVtYmVyLFxudGl0bGU6c3RyaW5nfG9iamVjdCxcbmRlc2NyaXB0aW9uOnN0cmluZ3xvYmplY3QsXG5pbWFnZTpzdHJpbmd8b2JqZWN0LFxudmFsdWU6b2JqZWN0XG59XVxufVxuXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZSAtIG11bHRpcGxlICYmIG11bHRpcGxlIGluIGdyb3VwXG57XG5hcnJheSBvZiBhcnJheXMgb2Ygc2VsZWN0ZWQgdmFsdWVzIGluIGdyb3VwXG5pZiBubyBzZWxlY3Rpb24gZ3JvdXAgc2hvdWxkIGJlIGVtcHR5IGFycmF5XG5bZ3JvdXBJZF06IFsuLi52YXJpYW50c0lkXVxufVxubXVsdGlwbGUgJiYgb25lIGluIGdyb3VwXG57XG5bZ3JvdXBJZF06IHZhcmlhbnRJZFxufVxub25seSBvbmUgKG5vdCBtdWx0aXBsZSAmJiBvbmUgaW4gZ3JvdXApXG57XG5ncm91cDogZ3JvdXBJZFxudmFsdWU6IHZhcmlhbnRJZFxufVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBpbWFnZVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYnV0dG9uUHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0aXRsZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3RpdGxlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpbWFnZUNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ltYWdlQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtkZXNjcmlwdGlvbkNvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtsaXN0Q29tcG9uZW50XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdENvbXBvbmVudFByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0VUlJdGVtXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbdWlPbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3VpT2ZmXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBmaWVsZG5hbWUgPSBcInJhZGlvLWJ1dHRvbnNcIixcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoKSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGltYWdlLFxuICAgICAgICBidXR0b25Qcm9wcyA9IHt9LFxuICAgICAgICB0aXRsZUNvbXBvbmVudCA9IFVJVGl0bGUsXG4gICAgICAgIHRpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDUgfSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlLFxuICAgICAgICBpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zLFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBnZXRVSUl0ZW0gPSAodmFsdWVJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzQnV0dG9ucy5maW5kKChidG5WYWwpID0+IGJ0blZhbC52YWx1ZSA9PT0gdmFsdWVJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERlZmF1bHRJdGVtU3VibGltZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYW50c1swXS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdWlPbiA9IChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLmNvbG9yID0gXCJzdWNjZXNzXCI7XG4gICAgICAgICAgICBpdGVtLm91dGxpbmVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHVpT2ZmID0gKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY29sb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGl0ZW0ub3V0bGluZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGluaXRWYXJpYW50c0J1dHRvbigpO1xuICAgICAgICBzZWxlY3REZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBsZXQgdmFyaWFudHNCdXR0b25zID0gW10sXG4gICAgICAgIGxpc3RJdGVtcyA9ICRzdGF0ZShbXSk7XG5cbiAgICBmdW5jdGlvbiBpbml0VmFyaWFudHNCdXR0b24oKSB7XG4gICAgICAgIHZhcmlhbnRzQnV0dG9ucyA9IHZhcmlhbnRzLm1hcCgodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYnV0dG9uUHJvcHMsIC4uLnZhcmlhbnQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3RJdGVtcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogeyB2YWx1ZXM6IHZhcmlhbnRzQnV0dG9ucyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZShzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIGxldCB1aSA9IHtcbiAgICAgICAgICAgIG9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvZmY6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB1aS5vZmYgPSB2YWx1ZTtcbiAgICAgICAgICAgIHVpLm9uID0gc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHNlbGVjdGVkVmFsdWU7XG4gICAgICAgIHVwZGF0ZVVJKHVpKTtcbiAgICAgICAgLy9cbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVVSShjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLm9mZikge1xuICAgICAgICAgICAgdWlPZmYoZ2V0VUlJdGVtKGNoYW5nZXMub2ZmKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMub24pIHtcbiAgICAgICAgICAgIHVpT24oZ2V0VUlJdGVtKGNoYW5nZXMub24pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYW50c0J1dHRvbnMgPSB2YXJpYW50c0J1dHRvbnM7XG4gICAgICAgIGxpc3RJdGVtcyA9IGxpc3RJdGVtcztcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiBzZWxlY3REZWZhdWx0KCkge1xuICAgICAgICBpZiAodmFyaWFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVVJKHsgb246IHZhbHVlIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZWYWx1ZSA9IGdldERlZmF1bHRJdGVtU3VibGltZSgpO1xuICAgICAgICAgICAgICAgIHRvZ2dsZShkZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBTdmVsdGVDb21wb25lbnQgPSAkZGVyaXZlZChsaXN0Q29tcG9uZW50KTtcbjwvc2NyaXB0PlxuXG48U3ZlbHRlQ29tcG9uZW50XG4gICAgey4uLmxpc3RDb21wb25lbnRQcm9wc31cbiAgICBiaW5kOml0ZW1zPXtsaXN0SXRlbXN9XG4gICAge3RpdGxlQ29tcG9uZW50fVxuICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgIHtkZXNjcmlwdGlvbkNvbXBvbmVudH1cbiAgICBkZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzPXt7XG4gICAgICAgIC4uLmRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMsXG4gICAgICAgIGFjdGlvbihldmVudCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRvZ2dsZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfX1cbiAgICB7aW1hZ2VDb21wb25lbnR9XG4gICAge2ltYWdlQ29tcG9uZW50UHJvcHN9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoMTApLFxuICAgICAgICBtaW4gPSAwLFxuICAgICAgICBtYXggPSAxMDAsXG4gICAgICAgIHN0ZXAgPSAxLFxuICAgICAgICB0aWNrbWFya3MgPSBmYWxzZSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInJhbmdlXCIsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICByZXF1aXJlZCA9IHRydWUsXG4gICAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5ID0gZmFsc2UsXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3RoZXJzLm9uY2hhbmdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgb25pbnB1dCA9IFVJQ29tbW9uLm9uSW5wdXQoZmllbGRuYW1lLCBvdGhlcnMub25jaGFuZ2UpO1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uY2hhbmdlID0gb25pbnB1dDtcbiAgICAgICAgb3B0aW9uYWxQcm9wcy5vbmlucHV0ID0gb25pbnB1dDtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiByZWFkb25seX1cbiAgICA8cD57dmFsdWV9PC9wPlxuezplbHNlfVxuICAgIDxpbnB1dFxuICAgICAgICBpZD1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IGJpZy1udW1iZXIgc2xpZGVyIGhhcy1vdXRwdXQge3NpemVcbiAgICAgICAgICAgID8gYGlzLSR7c2l6ZX1gXG4gICAgICAgICAgICA6ICcnfSB7Y29sb3IgPyBgaXMtJHtjb2xvcn1gIDogJyd9ICB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIHttaW59XG4gICAgICAgIHttYXh9XG4gICAgICAgIHtzdGVwfVxuICAgICAgICBsaXN0PVwiZm9ybS1maWVsZC1yYW5nZS17ZmllbGRuYW1lfS10aWNrbWFya3NcIlxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIGF1dG9jb21wbGV0ZT17ZmllbGRuYW1lfVxuICAgICAgICBhcmlhLWNvbnRyb2xzPVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIHsuLi5vcHRpb25hbFByb3BzfVxuICAgICAgICB7Li4ub3RoZXJzfVxuICAgIC8+XG4gICAgPG91dHB1dCBmb3I9XCJmb3JtLWZpZWxkLXJhbmdlLXtmaWVsZG5hbWV9XCI+e3ZhbHVlfTwvb3V0cHV0PlxuICAgIHsjaWYgQXJyYXkuaXNBcnJheSh0aWNrbWFya3MpICYmIHRpY2ttYXJrcy5sZW5ndGh9XG4gICAgICAgIDxkYXRhbGlzdCBpZD1cImZvcm0tZmllbGQtcmFuZ2Ute2ZpZWxkbmFtZX0tdGlja21hcmtzXCI+XG4gICAgICAgICAgICB7I2VhY2ggdGlja21hcmtzIGFzIHRpY2ttYXJrfVxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e3RpY2ttYXJrLnZhbHVlfSBsYWJlbD17dGlja21hcmsubGFiZWx9Pjwvb3B0aW9uPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2RhdGFsaXN0PlxuICAgIHsvaWZ9XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgaW1wb3J0IFVJU2VsZWN0T3B0aW9uIGZyb20gXCIuL3VpLnNlbGVjdC5vcHRpb24uc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uL2NvbW1vblwiO1xuICAgIGltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2ZyYW1lL2NvbW1vblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlID0gW11dXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgW3ZhcmlhbnRzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwbGFjZWhvbGRlciA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW2VtcHR5VmFsdWVFbmFibGVkID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudW1iZXJ9ICBbZW1wdHlWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2VtcHR5VmFsdWVUaXRsZSA9IFwibm8tc2VsZWN0aW9uXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWU9XCJzZWxlY3QtbXVsdGlwbGVcIl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHkgPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3Jvd3MgPSA4XVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29sb3JdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbY2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbmNoYW5nZSA9ICh7dmFsdWU6YXJyYXkgb2Ygc3RyaW5nfG51bWJlciwgZmllbGQ6c3RyaW5nLCB2YXJpYW50czphcnJheSBvZiBvYmplY3R9KT0+dHJ1ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSBbXSxcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBlbXB0eVZhbHVlVGl0bGUgPSBcIm5vLXNlbGVjdGlvblwiLFxuICAgICAgICBlbXB0eVZhbHVlRW5hYmxlZCA9IHRydWUsXG4gICAgICAgIGVtcHR5VmFsdWUsXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic2VsZWN0LW11bHRpcGxlXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgcm93cyA9IDgsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzaXplLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgbGFzdFZhbHVlID0gJHN0YXRlLnNuYXBzaG90KHZhbHVlKTtcblxuICAgIGZ1bmN0aW9uIGlzQ2xlYXJWYWx1ZU1hY3JvKHBsYWluVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBsYWluVmFsdWUuaW5jbHVkZXMoVUlDb21tb24uQ0xFQVJfTUFDUk8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uc1ZhbHVlcyhldikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShldi5zZWxlY3RlZE9wdGlvbnMpLm1hcCgoZWwpID0+XG4gICAgICAgICAgICB0eXBlb2YgZWwuX192YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IGVsLl9fdmFsdWUgOiBlbC52YWx1ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVtcHR5VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZW1wdHlWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyBVSUNvbW1vbi5DTEVBUl9NQUNST1xuICAgICAgICAgICAgOiBlbXB0eVZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlkVG9WYXJpYW50KGlkKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiB2YXJpYW50LmlkID09IGlkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZUlkc1RvVmFyaWFudHMoKSB7XG4gICAgICAgIGNvbnN0IGV2ID0gZ2V0RW1wdHlWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdmFsdWUuZmlsdGVyKChpZCkgPT4gaWQgIT09IGV2KS5tYXAoaWRUb1ZhcmlhbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoZXYpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkSWRzID0gZ2V0U2VsZWN0ZWRPcHRpb25zVmFsdWVzKGV2LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoaXNDbGVhclZhbHVlTWFjcm8oc2VsZWN0ZWRJZHMpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZElkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gc2VsZWN0ZWRJZHM7XG4gICAgICAgIHZhbHVlID0gc2VsZWN0ZWRJZHM7XG4gICAgICAgIGlmIChub3RDb21tb24uY29tcGFyZVR3b0FycmF5cyhuZXdWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFyaWFudHM6IHZhbHVlSWRzVG9WYXJpYW50cygpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgc2VsZWN0ZWRWYXJpYW50cyA9ICRkZXJpdmVkKFxuICAgICAgICB2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlSWRzVG9WYXJpYW50cyh2YWx1ZSkgOiBbXVxuICAgICk7XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG4gICAgbGV0IFVJX0NMQVNTRVMgPSAkZGVyaXZlZChcbiAgICAgICAgW3NpemUsIGNvbG9yXVxuICAgICAgICAgICAgLmZpbHRlcigodmFsKSA9PiB2YWwpXG4gICAgICAgICAgICAubWFwKCh2YWwpID0+IGBpcy0ke3ZhbH1gKVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIHsjaWYgdmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RofVxuICAgICAgICB7I2VhY2ggc2VsZWN0ZWRWYXJpYW50cyBhcyBzZWxlY3RlZFZhcmlhbnR9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1yLTJcIj57JExPQ0FMRVtzZWxlY3RlZFZhcmlhbnQudGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgey9lYWNofVxuICAgIHs6ZWxzZSBpZiBlbXB0eVZhbHVlRW5hYmxlZH1cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJtci0yXCI+eyRMT0NBTEVbZW1wdHlWYWx1ZVRpdGxlXX08L3NwYW4+XG4gICAgey9pZn1cbns6ZWxzZX1cbiAgICA8ZGl2IGNsYXNzPVwic2VsZWN0IGlzLW11bHRpcGxlIHtVSV9DTEFTU0VTfSB7Y2xhc3Nlc30gXCI+XG4gICAgICAgIDxzZWxlY3RcbiAgICAgICAgICAgIG11bHRpcGxlPVwidHJ1ZVwiXG4gICAgICAgICAgICBpZD1cImZvcm0tZmllbGQtc2VsZWN0LXtmaWVsZG5hbWV9XCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkbmFtZX1cbiAgICAgICAgICAgIG9uaW5wdXQ9e29uSW5wdXR9XG4gICAgICAgICAgICBvbmNoYW5nZT17b25JbnB1dH1cbiAgICAgICAgICAgIG9uYmx1cj17b25JbnB1dH1cbiAgICAgICAgICAgIHt2YWx1ZX1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHtpbnZhbGlkfVxuICAgICAgICAgICAgc2l6ZT17cm93c31cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgZW1wdHlWYWx1ZUVuYWJsZWR9XG4gICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0eXBlb2YgZW1wdHlWYWx1ZSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBVSUNvbW1vbi5DTEVBUl9NQUNST1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBlbXB0eVZhbHVlfVxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17ZW1wdHlWYWx1ZVRpdGxlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgeyNlYWNoIHZhcmlhbnRzIGFzIHZhcmlhbnQgKHZhcmlhbnQuaWQpfVxuICAgICAgICAgICAgICAgIDxVSVNlbGVjdE9wdGlvbiB2YWx1ZT17dmFyaWFudC5pZH0gdGl0bGU9e3ZhcmlhbnQudGl0bGV9IC8+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2Plxuey9pZn1cbiIsImNvbnN0IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MgPSBcIm9rXCI7XG5jb25zdCBERUZBVUxUX1NUQVRVU19FUlJPUiA9IFwiZXJyb3JcIjtcblxuY29uc3QgTkFWSUdBVElPTl9ERUxBWV9TSE9SVCA9IDUwMDtcbmNvbnN0IE5BVklHQVRJT05fREVMQVlfTk9STUFMID0gMTUwMDtcbmNvbnN0IE5BVklHQVRJT05fREVMQVlfTE9ORyA9IDUwMDA7XG5cbmNvbnN0IE5BVklHQVRJT05fREVMQVlTID0ge1xuICAgIFNIT1JUOiBOQVZJR0FUSU9OX0RFTEFZX1NIT1JULFxuICAgIE5PUk1BTDogTkFWSUdBVElPTl9ERUxBWV9OT1JNQUwsXG4gICAgTE9ORzogTkFWSUdBVElPTl9ERUxBWV9MT05HLFxufTtcblxuY29uc3QgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUID0gTkFWSUdBVElPTl9ERUxBWV9OT1JNQUw7XG5cbmV4cG9ydCB7XG4gICAgREVGQVVMVF9TVEFUVVNfU1VDQ0VTUyxcbiAgICBERUZBVUxUX1NUQVRVU19FUlJPUixcbiAgICBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQsXG4gICAgTkFWSUdBVElPTl9ERUxBWVMsXG59O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgbm90UGF0aCBmcm9tIFwibm90LXBhdGhcIjtcblxuICAgIGltcG9ydCBVSVNlbGVjdCBmcm9tIFwiLi91aS5zZWxlY3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG4gICAgaW1wb3J0IHsgREVGQVVMVF9TVEFUVVNfU1VDQ0VTUyB9IGZyb20gXCIuLi8uLi9mcmFtZS9jb25zdFwiO1xuXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaW5wdXRTdGFydGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2Vob2xkZXJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtlbXB0eVZhbHVlVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RlbE5hbWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpb25OYW1lXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uRmlsdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uU29ydGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbYWN0aW9uUGFnZXJdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25TZWFyY2hdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25JZF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvblRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ljb25dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWlyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlwbGVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkYXRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlcnJvcnNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9ybUVycm9yc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb3JtTGV2ZWxFcnJvcl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXR1cm5WYXJpYW50XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBlbXB0eVZhbHVlVGl0bGUgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInNlbGVjdEZyb21Nb2RlbFwiLFxuICAgICAgICBtb2RlbE5hbWUgPSBcIlwiLFxuICAgICAgICBhY3Rpb25OYW1lID0gXCJcIixcbiAgICAgICAgYWN0aW9uRmlsdGVyID0ge30sXG4gICAgICAgIGFjdGlvblNvcnRlciA9IHt9LFxuICAgICAgICBhY3Rpb25QYWdlciA9IHt9LFxuICAgICAgICBhY3Rpb25TZWFyY2ggPSB1bmRlZmluZWQsXG4gICAgICAgIG9wdGlvbklkID0gXCI6X2lkXCIsXG4gICAgICAgIG9wdGlvblRpdGxlID0gXCI6dGl0bGVcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBtdWx0aXBsZSA9IGZhbHNlLFxuICAgICAgICBzaXplID0gOCxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuXG4gICAgICAgIHJldHVyblZhcmlhbnQgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4ub3RoZXJzXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gYXJndW1lbnRzU2V0UHJvdmlkZWQoKSB7XG4gICAgICAgIHJldHVybiBtb2RlbE5hbWUgJiYgYWN0aW9uTmFtZSAmJiBhY3Rpb25GaWx0ZXI7XG4gICAgfVxuXG4gICAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuICAgIGxldCB2YXJpYW50cyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IGRpc2FibGVkID0gJGRlcml2ZWQoIWxvYWRlZCk7XG5cbiAgICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1NldFByb3ZpZGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdEFwcCA9IG5vdENvbW1vbi5nZXRBcHAoKTtcbiAgICAgICAgICAgIGNvbnN0IE1vZGVsID0gbm90QXBwXG4gICAgICAgICAgICAgICAgLmdldE1vZGVsKG1vZGVsTmFtZSlcbiAgICAgICAgICAgICAgICAuc2V0RmlsdGVyKGFjdGlvbkZpbHRlcilcbiAgICAgICAgICAgICAgICAuc2V0U29ydGVyKGFjdGlvblNvcnRlcilcbiAgICAgICAgICAgICAgICAuc2V0UGFnZXIoYWN0aW9uUGFnZXIpXG4gICAgICAgICAgICAgICAgLnNldFNlYXJjaChhY3Rpb25TZWFyY2gpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNb2RlbFtgJGAgKyBhY3Rpb25OYW1lXSgpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gREVGQVVMVF9TVEFUVVNfU1VDQ0VTUykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB2YXJpYW50cyA9IHJlc3VsdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub3RQYXRoLmdldChvcHRpb25JZCwgaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogbm90UGF0aC5nZXQob3B0aW9uVGl0bGUsIGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbmVycm9yKHJlc3BvbnNlLmVycm9ycyB8fCByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZGF0YSkge1xuICAgICAgICBpZiAocmV0dXJuVmFyaWFudCkge1xuICAgICAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhcmlhbnRzLmZpbmQoKGl0bSkgPT4gaXRtLmlkID09PSBkYXRhLnZhbHVlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25jaGFuZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPFVJU2VsZWN0XG4gICAge3ZhbHVlfVxuICAgIGJpbmQ6dmFyaWFudHNcbiAgICBjbGFzcz17Y2xhc3Nlc31cbiAgICB7cGxhY2Vob2xkZXJ9XG4gICAge2VtcHR5VmFsdWVUaXRsZX1cbiAgICB7ZmllbGRuYW1lfVxuICAgIHtyZXF1aXJlZH1cbiAgICB7cmVhZG9ubHl9XG4gICAge2Rpc2FibGVkfVxuICAgIHttdWx0aXBsZX1cbiAgICB7c2l6ZX1cbiAgICB7dmFsaWR9XG4gICAgb25jaGFuZ2U9e29uQ2hhbmdlfVxuICAgIHsuLi5vdGhlcnN9XG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgXCJidWxtYS1zd2l0Y2hcIjtcbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcbiAgICBpbXBvcnQgVUlCb29sZWFuIGZyb20gXCIuLi92YXJpb3VzL3VpLmJvb2xlYW4uc3ZlbHRlXCI7XG5cbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJykuVUlJbnB1dFByb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbGFiZWwgPSBcIlwiLFxuICAgICAgICBoaWRlTGFiZWwgPSBmYWxzZSxcbiAgICAgICAgcGxhY2Vob2xkZXIgPSBcIlwiLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInN3aXRjaFwiLFxuICAgICAgICBzaXplLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFjdE9uID0gW1wib25ibHVyXCIsIFwib25pbnB1dFwiXSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcblxuICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG90aGVycy5vbmNoYW5nZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IG9uaW5wdXQgPSBVSUNvbW1vbi5vbklucHV0KGZpZWxkbmFtZSwgb3RoZXJzLm9uY2hhbmdlKTtcbiAgICAgICAgcmVhY3RPbi5mb3JFYWNoKChldmVudE5hbWUpID0+IChvcHRpb25hbFByb3BzW2V2ZW50TmFtZV0gPSBvbmlucHV0KSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgPFVJQm9vbGVhbiBMQ19UUlVFPXtsYWJlbH0gTENfRkFMU0U9e2xhYmVsfSB7dmFsdWV9IC8+XG57OmVsc2V9XG4gICAgeyNpZiAhbGFiZWwgJiYgIWhpZGVMYWJlbH1cbiAgICAgICAgPFVJQm9vbGVhbiB2YWx1ZT17ZmFsc2V9IC8+XG4gICAgey9pZn1cbiAgICA8aW5wdXRcbiAgICAgICAgaWQ9XCJmb3JtLWZpZWxkLXN3aXRjaC17ZmllbGRuYW1lfVwiXG4gICAgICAgIGNsYXNzPVwic3dpdGNoIHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgIGJpbmQ6Y2hlY2tlZD17dmFsdWV9XG4gICAgICAgIHBsYWNlaG9sZGVyPXskTE9DQUxFW3BsYWNlaG9sZGVyXX1cbiAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgIHtyZWFkb25seX1cbiAgICAgICAge2ludmFsaWR9XG4gICAgICAgIGFyaWEtY29udHJvbHM9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiaW5wdXQtZmllbGQtaGVscGVyLXtmaWVsZG5hbWV9XCJcbiAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgIHsuLi5vdGhlcnN9XG4gICAgLz5cbiAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiIGZvcj1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9XCI+XG4gICAgICAgIHsjaWYgIWhpZGVMYWJlbH1cbiAgICAgICAgICAgIHsjaWYgbGFiZWx9XG4gICAgICAgICAgICAgICAgeyRMT0NBTEVbbGFiZWxdfVxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxVSUJvb2xlYW4gdmFsdWU9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9pZn1cbiAgICA8L2xhYmVsPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4vdWkubGFiZWwuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIGltcG9ydCBcImJ1bG1hLXN3aXRjaFwiO1xuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpLlVJSW5wdXRQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB2YWx1ZSA9ICRiaW5kYWJsZShbXSksXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIGZpZWxkbmFtZSA9IFwic3dpdGNoXCIsXG4gICAgICAgIHJlcXVpcmVkID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgPSBmYWxzZSxcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgcmVhY3RPbiA9IFtcIm9uYmx1clwiLCBcIm9uaW5wdXRcIl0sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIiBpcy1yb3VuZGVkIFwiLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIGFkZElkKHZhcklkKSB7XG4gICAgICAgIGlmICghdmFsdWUuaW5jbHVkZXModmFySWQpKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhcklkKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1JZCh2YXJJZCkge1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXModmFySWQpKSB7XG4gICAgICAgICAgICB2YWx1ZS5zcGxpY2UodmFsdWUuaW5kZXhPZih2YXJJZCksIDEpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGV2ZW50RGF0YSwgZXYpIHtcbiAgICAgICAgY29uc3QgdmFySWQgPSBldi50YXJnZXQuaWQuc3BsaXQoXCItdmFyaWFudC1cIikuYXQoLTEpO1xuICAgICAgICBldi50YXJnZXQuY2hlY2tlZCA/IGFkZElkKHZhcklkKSA6IHJlbUlkKHZhcklkKTtcbiAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWU6ICRzdGF0ZS5zbmFwc2hvdCh2YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIG9uY2hhbmdlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgaW52YWxpZCA9ICRkZXJpdmVkKCF2YWxpZCk7XG5cbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG9uQ2hhbmdlKTtcbiAgICAgICAgcmVhY3RPbi5mb3JFYWNoKChldmVudE5hbWUpID0+IChvcHRpb25hbFByb3BzW2V2ZW50TmFtZV0gPSBvbmlucHV0KSk7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcmVhZG9ubHl9XG4gICAgeyNpZiB2YWx1ZX1cbiAgICAgICAge3ZhcmlhbnRzXG4gICAgICAgICAgICAuZmlsdGVyKCh2YXJpYW50KSA9PiB2YWx1ZS5pbmNsdWRlcyh2YXJpYW50LmlkKSlcbiAgICAgICAgICAgIC5tYXAoKHZhcmlhbnQpID0+IHZhcmlhbnQudGl0bGUpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfVxuICAgIHsvaWZ9XG57OmVsc2V9XG4gICAgeyNlYWNoIHZhcmlhbnRzIGFzIHZhcmlhbnQgKHZhcmlhbnQuaWQpfVxuICAgICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoLWxpc3QtaXRlbVwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInN3aXRjaCB7Y2xhc3Nlc30ge3ZhcmlhbnQudHlwZVxuICAgICAgICAgICAgICAgICAgICA/IGBpcy0ke3ZhcmlhbnQudHlwZX1gXG4gICAgICAgICAgICAgICAgICAgIDogJyd9XCJcbiAgICAgICAgICAgICAgICBpZD1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXt2YWx1ZS5pbmNsdWRlcyh2YXJpYW50LmlkKX1cbiAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZG5hbWV9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfS12YXJpYW50LXt2YXJpYW50LmlkfVwiXG4gICAgICAgICAgICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfS12YXJpYW50LXt2YXJpYW50LmlkfVwiXG4gICAgICAgICAgICAgICAgey4uLm9wdGlvbmFsUHJvcHN9XG4gICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgICAgIGNsYXNzPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgIGZvcj1cImZvcm0tZmllbGQtc3dpdGNoLXtmaWVsZG5hbWV9LXZhcmlhbnQte3ZhcmlhbnQuaWR9XCJcbiAgICAgICAgICAgICAgICBsYWJlbD17dmFyaWFudC50aXRsZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgIHsvZWFjaH1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgeyBVSUNvbHVtbiwgVUlDb2x1bW5zIH0gZnJvbSBcIi4uL2xheW91dFwiO1xuICAgIGltcG9ydCBVSVNlbGVjdE9wdGlvbiBmcm9tIFwiLi91aS5zZWxlY3Qub3B0aW9uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGNsZWFyVmFsdWVGcm9tRGVhZFZhcmlhbnRzKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbTENfQUREID0gXCJub3Qtbm9kZTphZGRfbGFiZWxcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW0xDX1NFTEVDVF9GUk9NX0xJU1QgPSBcIm5vdC1ub2RlOnNlbGVjdF9mcm9tX2xpc3RfbGFiZWxcIl1cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PHN0cmluZ3xudW1iZXI+fSBbdmFsdWVdIC0gbGlzdCBvZiBpdGVtIGlkc1xuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXk8b2JqZWN0Pn0gW3ZhcmlhbnRzXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lID0gJ3RhZyddXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHkgPSBmYWxzZV0gLSBleHBvcnQgbGV0IHJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2JlZm9yZUFkZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZ2V0SXRlbUlkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtnZXRJdGVtVGl0bGVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2dldEl0ZW1UeXBlXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtidWlsZEl0ZW1dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIExDX0FERCA9IFwibm90LW5vZGU6YWRkX2xhYmVsXCIsXG4gICAgICAgIExDX1NFTEVDVF9GUk9NX0xJU1QgPSBcIm5vdC1ub2RlOnNlbGVjdF9mcm9tX2xpc3RfbGFiZWxcIixcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoW10pLFxuICAgICAgICB2YXJpYW50cyA9IFtdLFxuICAgICAgICBmaWVsZG5hbWUgPSBcInRhZ1wiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIGJlZm9yZUFkZCA9ICgvKnZhcmlhbnQsIHZhcmlhbnRzKi8pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtSWQgPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnQuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEl0ZW1UaXRsZSA9ICh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFudC50aXRsZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgZ2V0SXRlbVR5cGUgPSAodmFyaWFudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnQ/LnR5cGUgPz8gXCJpbmZvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1aWxkSXRlbSA9ICh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBnZXRJdGVtSWQodmFyaWFudCksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGdldEl0ZW1UaXRsZSh2YXJpYW50KSxcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRJdGVtVHlwZSh2YXJpYW50KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb25jaGFuZ2UsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gdmFyaWFudElkVG9WYXJpYW50KGlkKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5maW5kKCh2YXJpYW50KSA9PiBnZXRJdGVtSWQodmFyaWFudCkgPT0gaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZUV2ZW50KCkge1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgaWQgPSBlLmN1cnJlbnRUYXJnZXQuZGF0YXNldC5pZDtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGlkKSkge1xuICAgICAgICAgICAgdmFsdWUuc3BsaWNlKHZhbHVlLmluZGV4T2YoaWQpLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGlkID0gZS5jdXJyZW50VGFyZ2V0LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcInNlbGVjdFwiKS52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRJZFRvVmFyaWFudChpZCk7XG4gICAgICAgIGlmICghdmFyaWFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmVmb3JlQWRkKHZhcmlhbnQsIHZhcmlhbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAmJiB2YWx1ZS5pbmRleE9mKGlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goaWQpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyVmFsdWVGcm9tRGVhZFZhcmlhbnRzKCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcih2YXJpYW50SWRUb1ZhcmlhbnQpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLypcbml0ZW0gPSB7XG4gIGlkLCAgICAgICAgLy91bmlxdWVcbiAgdGl0bGUsICAgICAvL3NvbWUgdGV4dFxuICB0eXBlICAgICAgIC8vZm9yIGNvbG9yaW5nIGl0ZW1zLCB1c3VhbCBodG1sIHRlbXBsYXRlIG5hbWVzIGRhbmdlciwgc3VjY2VzcywgZXRjXG59XG4qL1xuICAgIGxldCBpdGVtcyA9ICRkZXJpdmVkKFxuICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgLm1hcCh2YXJpYW50SWRUb1ZhcmlhbnQpXG4gICAgICAgICAgICAuZmlsdGVyKCh2YXJpYW50KSA9PiB2YXJpYW50KVxuICAgICAgICAgICAgLm1hcChidWlsZEl0ZW0pXG4gICAgKTtcbjwvc2NyaXB0PlxuXG48VUlDb2x1bW5zIGNsYXNzPXtjbGFzc2VzfT5cbiAgICA8VUlDb2x1bW4+XG4gICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtIChpdGVtLmlkKX1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXgtMSB0YWcgaXMte2l0ZW0udHlwZX1cIlxuICAgICAgICAgICAgICAgID57JExPQ0FMRVtpdGVtLnRpdGxlXX1cbiAgICAgICAgICAgICAgICB7I2lmICFyZWFkb25seX1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cImRlbGV0ZSBidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1pZD17aXRlbS5pZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZGVsZXRlIGlzLXNtYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3JlbW92ZX1cbiAgICAgICAgICAgICAgICAgICAgPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L1VJQ29sdW1uPlxuXG4gICAgeyNpZiAhcmVhZG9ubHl9XG4gICAgICAgIDxVSUNvbHVtbj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3QgaXMtc21hbGxcIj5cbiAgICAgICAgICAgICAgICA8c2VsZWN0PlxuICAgICAgICAgICAgICAgICAgICA8VUlTZWxlY3RPcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXstMX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e0xDX1NFTEVDVF9GUk9NX0xJU1R9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCB2YXJpYW50cyBhcyB2YXJpYW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgPFVJU2VsZWN0T3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3ZhcmlhbnQuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3ZhcmlhbnQudGl0bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxVSUJ1dHRvblxuICAgICAgICAgICAgICAgIGNvbG9yPXtcInByaW1hcnlcIn1cbiAgICAgICAgICAgICAgICBzaXplPXtcInNtYWxsXCJ9XG4gICAgICAgICAgICAgICAgYWN0aW9uPXthZGR9XG4gICAgICAgICAgICAgICAgdGl0bGU9e0xDX0FERH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvVUlDb2x1bW4+XG4gICAgey9pZn1cbjwvVUlDb2x1bW5zPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlL2luZGV4XCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb24uanNcIjtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGUnKS5VSUlucHV0UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCIrNyA5ODcgNjU0LTMyLTEwXCIsXG4gICAgICAgIHBhdHRlcm4gPSBcIlxcXFwrWzAtOV17MSwzfVxcXFxzK1swLTldezN9XFxcXHMrWzAtOV17M30tWzAtOV17Mn0tWzAtOV17Mn1cIixcbiAgICAgICAgZmllbGRuYW1lID0gXCJ0ZWxlcGhvbmVcIixcbiAgICAgICAgcmVxdWlyZWQgPSB0cnVlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgdmFsaWQgPSB0cnVlLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGxldCBpbnZhbGlkID0gJGRlcml2ZWQoIXZhbGlkKTtcbiAgICBjb25zdCBvcHRpb25hbFByb3BzID0ge307XG4gICAgaWYgKHR5cGVvZiBvdGhlcnMub25jaGFuZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBvbmlucHV0ID0gVUlDb21tb24ub25JbnB1dChmaWVsZG5hbWUsIG90aGVycy5vbmNoYW5nZSk7XG4gICAgICAgIG9wdGlvbmFsUHJvcHMub25jaGFuZ2UgPSBvbmlucHV0O1xuICAgICAgICBvcHRpb25hbFByb3BzLm9uaW5wdXQgPSBvbmlucHV0O1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJlYWRvbmx5fVxuICAgIDxwPnt2YWx1ZX08L3A+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgIGlkPVwiZm9ybS1maWVsZC10ZWxlcGhvbmUte2ZpZWxkbmFtZX1cIlxuICAgICAgICBjbGFzcz1cImlucHV0IHtzaXplID8gYGlzLSR7c2l6ZX1gIDogJyd9IHtjb2xvclxuICAgICAgICAgICAgPyBgaXMtJHtjb2xvcn1gXG4gICAgICAgICAgICA6ICcnfSB7Y2xhc3Nlc31cIlxuICAgICAgICB0eXBlPVwidGVsXCJcbiAgICAgICAgbmFtZT17ZmllbGRuYW1lfVxuICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgIHtwYXR0ZXJufVxuICAgICAgICB7aW52YWxpZH1cbiAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgcGxhY2Vob2xkZXI9eyRMT0NBTEVbcGxhY2Vob2xkZXJdfVxuICAgICAgICBhdXRvY29tcGxldGU9e2ZpZWxkbmFtZX1cbiAgICAgICAgYXJpYS1jb250cm9scz1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJpbnB1dC1maWVsZC1oZWxwZXIte2ZpZWxkbmFtZX1cIlxuICAgICAgICB7Li4ub3B0aW9uYWxQcm9wc31cbiAgICAgICAgey4uLm90aGVyc31cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVUlDb250cm9sIH0gZnJvbSBcIi4uL2lucHV0XCI7XG4gICAgaW1wb3J0IFVJRmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLmZpZWxkLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRhZ1ZhbHVlIGZyb20gXCIuL3VpLnRhZy52YWx1ZS5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtvYmplY3R9ICAgIFByb3BzXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gICAgdmFsdWVzID0gW11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbZ3JvdXBlZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgW211bHRpbGluZSA9IHRydWVdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSAgIFByb3BzXG4gICAgICovXG4gICAgbGV0IHsgdmFsdWVzID0gW10sIGdyb3VwZWQgPSB0cnVlLCBtdWx0aWxpbmUgPSB0cnVlIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIHZhbHVlcy5sZW5ndGh9XG4gICAgPFVJRmllbGQge2dyb3VwZWR9IHttdWx0aWxpbmV9PlxuICAgICAgICB7I2VhY2ggdmFsdWVzIGFzIHRhZ1ZhbHVlUHJvcHN9XG4gICAgICAgICAgICA8VUlDb250cm9sPlxuICAgICAgICAgICAgICAgIDxVSVRhZ1ZhbHVlIHsuLi50YWdWYWx1ZVByb3BzfSAvPlxuICAgICAgICAgICAgPC9VSUNvbnRyb2w+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L1VJRmllbGQ+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FycmF5PHN0cmluZz59ICBbZXJyb3JzID0gW11dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvdyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3MgPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2lkID0gJ2Vycm9ycy1saXN0J11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgZXJyb3JzID0gW10sXG4gICAgICAgIHNob3cgPSBmYWxzZSxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBpZCA9IFwiZXJyb3JzLWxpc3RcIixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBBcnJheS5pc0FycmF5KGVycm9ycykgJiYgZXJyb3JzLmxlbmd0aH1cbiAgICA8cCBjbGFzcz1cImhlbHAge2NsYXNzZXN9XCIge2lkfT5cbiAgICAgICAgeyNpZiBzaG93fVxuICAgICAgICAgICAgeyNlYWNoIGVycm9ycyBhcyBlcnJvciwgaW5kZXh9XG4gICAgICAgICAgICAgICAgPHNwYW4+eyRMT0NBTEVbZXJyb3JdfTwvc3Bhbj57aW5kZXggPCBlcnJvcnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICA/IFwiLCBcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHs6ZWxzZX0mbmJzcDt7L2lmfVxuICAgIDwvcD5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vZnJhbWUvY29tbW9uXCI7XG4gICAgaW1wb3J0IHsgVUlDb250ZW50IH0gZnJvbSBcIi4uL2Jsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbaWQgPSBcInVzZXJDYXJkXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgICAgIFtpbWFnZSA9IFwiaHR0cHM6Ly9idWxtYS5pby9pbWFnZXMvcGxhY2Vob2xkZXJzLzMyeDMyLnBuZ1wiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbdXNlcm5hbWUgPSBcIkpvaG4gRG9lXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgICAgIFtyb2xlID0gXCJhZG1pblwiXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbZXZlbnRzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtyZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50c10gLSByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbb25VcGRhdGUgPSAoZGF0YSk9PiB7dXNlcm5hbWU9ZGF0YS51c2VybmFtZTsgcm9sZSA9IGRhdGEucm9sZTt9XVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBpZCA9IFwidXNlckNhcmRcIixcbiAgICAgICAgaW1hZ2UgPSBcImh0dHBzOi8vYnVsbWEuaW8vaW1hZ2VzL3BsYWNlaG9sZGVycy8zMngzMi5wbmdcIixcbiAgICAgICAgdXNlcm5hbWUgPSBcIkpvaG4gRG9lXCIsXG4gICAgICAgIHJvbGUgPSBcImFkbWluXCIsXG4gICAgICAgIGV2ZW50cyA9IHt9LFxuICAgICAgICByZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50cy5iaW5kKG5vdENvbW1vbiksXG4gICAgICAgIG9uVXBkYXRlID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwidXNlcm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZSA9IGRhdGEudXNlcm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGRhdGEsIFwicm9sZVwiKSkge1xuICAgICAgICAgICAgICAgIHJvbGUgPSBkYXRhLnJvbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBJZCgpIHtcbiAgICAgICAgcmV0dXJuIGB1c2VyY2FyZC0ke2lkfWA7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkge1xuICAgICAgICByZXR1cm4gYCR7Z2V0Q29tcElkKCl9OnVwZGF0ZWA7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bihldmVudHMsIGdldFN0YW5kYXJ0VXBkYXRlRXZlbnROYW1lKCkpKSB7XG4gICAgICAgICAgICBldmVudHNbZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKV0gPSBvblVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlcihldmVudHMpO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxhcnRpY2xlIGlkPXtnZXRDb21wSWQoKX0gY2xhc3M9XCJtZWRpYVwiPlxuICAgIDxmaWd1cmUgY2xhc3M9XCJtZWRpYS1sZWZ0XCI+XG4gICAgICAgIDxwIGNsYXNzPVwiaW1hZ2UgaXMtMzJ4MzJcIj5cbiAgICAgICAgICAgIDxpbWcgc3JjPXtpbWFnZX0gYWx0PXt1c2VybmFtZX0gLz5cbiAgICAgICAgPC9wPlxuICAgIDwvZmlndXJlPlxuICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50XCI+XG4gICAgICAgIDxVSUNvbnRlbnQ+XG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICA8c3Ryb25nPnt1c2VybmFtZX08L3N0cm9uZz5cbiAgICAgICAgICAgICAgICA8c21hbGw+QDwvc21hbGw+XG4gICAgICAgICAgICAgICAgPHN0cm9uZz57cm9sZX08L3N0cm9uZz5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9VSUNvbnRlbnQ+XG4gICAgPC9kaXY+XG48L2FydGljbGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmb250ID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemUgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2lkZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcG9pbnRhYmxlID0gZmFsc2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRpdGxlID0gXCJcIixcbiAgICAgICAgZm9udCA9IFwiXCIsXG4gICAgICAgIHNpZGUgPSBcIlwiLFxuICAgICAgICBzaXplID0gXCJcIixcbiAgICAgICAgcG9pbnRhYmxlID0gZmFsc2UsXG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGV9XG4gICAgPHNwYW4gY2xhc3M9XCJpY29uLXRleHQge3BvaW50YWJsZSA/ICdpcy1jbGlja2FibGUnIDogJyd9XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfVwiPlxuICAgICAgICAgICAgPGlcbiAgICAgICAgICAgICAgICBjbGFzcz1cImlzLXRpdGxlLWljb24gZmFzXG4gICAgICBmYS17Zm9udH1cbiAgICAgIHtzaXplID09ICdtZWRpdW0nID8gJ2ZhLWxnJyA6ICcnfVxuICAgICAge3NpemUgPT0gJ2xhcmdlJyA/ICdmYS0yeCcgOiAnJ31cbiAgICAgIFwiXG4gICAgICAgICAgICA+PC9pPlxuICAgICAgICAgICAgPHNwYW4+eyRMT0NBTEVbdGl0bGVdfTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbns6ZWxzZX1cbiAgICA8c3BhblxuICAgICAgICBjbGFzcz1cIlxuICAgICAgICB7cG9pbnRhYmxlID8gJ2lzLWNsaWNrYWJsZScgOiAnJ31cbiAgICAgICAge3NpZGUgPyBgaXMtJHtzaWRlfWAgOiAnJ31cbiAgICAgICAgaWNvbiB7c2l6ZSA/IGBpcy0ke3NpemV9YCA6ICcnfSB7c2l6ZSA9PSAnbWVkaXVtJyA/ICdmYS1sZycgOiAnJ31cbntzaXplID09ICdsYXJnZScgPyAnZmEtMngnIDogJyd9XCJcbiAgICA+XG4gICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLXtmb250fVwiPjwvaT5cbiAgICA8L3NwYW4+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlUZXh0ZmllbGQgZnJvbSBcIi4uL2lucHV0L3VpLnRleHRmaWVsZC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUNvbHVtbiwgVUlDb2x1bW5zIH0gZnJvbSBcIi4uL2xheW91dFwiO1xuICAgIGltcG9ydCBVSUljb25Gb250IGZyb20gXCIuLi9pY29uL3VpLmljb24uZm9udC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUZpZWxkIGZyb20gXCIuLi9pbnB1dC91aS5maWVsZC5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3BsYWNlaG9sZGVyID0gJ25vdC1ub2RlOmZpZWxkX3NlYXJjaF9wbGFjZWhvbGRlciddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3Rlcm0gPSAnJ11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbZmllbGRuYW1lID0gJ3NlYXJjaFRlcm1JbnB1dCddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW2ljb24gPSAnc2VhcmNoJ11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJub3Qtbm9kZTpmaWVsZF9zZWFyY2hfcGxhY2Vob2xkZXJcIixcbiAgICAgICAgdGVybSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJzZWFyY2hUZXJtSW5wdXRcIixcbiAgICAgICAgaWNvbiA9IFwic2VhcmNoXCIsXG4gICAgICAgIGljb25TaWRlID0gXCJsZWZ0XCIsXG4gICAgICAgIHNpemUgPSBcIm5vcm1hbFwiLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaGFzSWNvbnNMZWZ0ID0gJGRlcml2ZWQoaWNvbiAmJiBpY29uU2lkZSA9PT0gXCJsZWZ0XCIpO1xuICAgIGxldCBoYXNJY29uc1JpZ2h0ID0gJGRlcml2ZWQoaWNvbiAmJiBpY29uU2lkZSA9PT0gXCJyaWdodFwiKTtcbjwvc2NyaXB0PlxuXG48VUlDb2x1bW5zIHJvbGU9XCJub25lXCI+XG4gICAgPFVJQ29sdW1uIHJvbGU9XCJub25lXCI+XG4gICAgICAgIDxVSUZpZWxkPlxuICAgICAgICAgICAgPFVJQ29udHJvbCB7aGFzSWNvbnNMZWZ0fSB7aGFzSWNvbnNSaWdodH0+XG4gICAgICAgICAgICAgICAgPFVJVGV4dGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWU9e3Rlcm19XG4gICAgICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICAgICAge2ZpZWxkbmFtZX1cbiAgICAgICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICB7c2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgcm9sZT17XCJzZWFyY2hib3hcIn1cbiAgICAgICAgICAgICAgICAgICAgey4uLm90aGVyc31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIHsjaWYgaWNvbn1cbiAgICAgICAgICAgICAgICAgICAgPFVJSWNvbkZvbnQgZm9udD17aWNvbn0gc2lkZT17aWNvblNpZGV9IC8+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvVUlDb250cm9sPlxuICAgICAgICA8L1VJRmllbGQ+XG4gICAgPC9VSUNvbHVtbj5cbjwvVUlDb2x1bW5zPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgRXJyb3JzTGlzdCBmcm9tIFwiLi4vdmFyaW91cy91aS5lcnJvcnMubGlzdC5zdmVsdGVcIjtcblxuICAgIGxldCB7XG4gICAgICAgIGlkID0gXCJnZW5lcmljLWZpZWxkXCIsXG4gICAgICAgIGlucHV0U3RhcnRlZCxcbiAgICAgICAgdmFsaWRhdGVkLFxuICAgICAgICB2YWxpZCxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmb3JtRXJyb3JzLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGFsbEVycm9ycyA9ICRzdGF0ZShbXSk7XG4gICAgbGV0IHNob3dFcnJvcnMgPSAkc3RhdGUodHJ1ZSk7XG5cbiAgICAkZWZmZWN0KCgpID0+IHtcbiAgICAgICAgYWxsRXJyb3JzID0gW1xuICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZXJyb3JzKSA/IGVycm9ycyA6IFtdKSxcbiAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGZvcm1FcnJvcnMpID8gZm9ybUVycm9ycyA6IFtdKSxcbiAgICAgICAgXTtcbiAgICAgICAgc2hvd0Vycm9ycyA9IGlucHV0U3RhcnRlZCAmJiB2YWxpZGF0ZWQgJiYgIXZhbGlkO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxFcnJvcnNMaXN0IHNob3c9e3Nob3dFcnJvcnN9IGVycm9ycz17YWxsRXJyb3JzfSBjbGFzcz17Y2xhc3Nlc30ge2lkfSAvPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQnV0dG9uIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVRhZyBmcm9tIFwiLi4vdmFyaW91cy91aS50YWcuc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyBidXR0b24gPSB7fSwgdGFnID0ge30sIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgdmFycyA9ICRzdGF0ZSh7fSk7XG5cbiAgICBsZXQgdGFnUG9zaXRpb24gPSB7XG4gICAgICAgIGxlZnQ6ICEhbGVmdCxcbiAgICAgICAgcmlnaHQ6ICEhcmlnaHQsXG4gICAgICAgIHRvcDogISF0b3AsXG4gICAgICAgIGJvdHRvbTogISFib3R0b20sXG4gICAgfTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgdmFyc1tgLS1zaWRpbmctbGVmdC1zaXplYF0gPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgdmFyc1tcIi0tc2lkaW5nLXJpZ2h0LXNpemVcIl0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICB2YXJzW1wiLS1zaWRpbmctdG9wLXNpemVcIl0gPSB0b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdHRvbSkge1xuICAgICAgICAgICAgdmFyc1tcIi0tc2lkaW5nLWJvdHRvbS1zaXplXCJdID0gYm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIHZhcnMgPSB2YXJzO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxzcGFuIGNsYXNzPVwiaXMtdGFnLWNvbnRhaW5lclwiPlxuICAgIDxVSUJ1dHRvbiB7Li4uYnV0dG9ufSAvPlxuICAgIDxVSVRhZyB7Li4udGFnfSB7dmFyc30gey4uLnRhZ1Bvc2l0aW9ufSAvPlxuPC9zcGFuPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbiBmcm9tIFwiLi4vYnV0dG9uL3VpLmJ1dHRvbi5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFt0cmlnZ2VyXSAtIGV4cG9ydCBsZXQgZGlyZWN0aW9uID0gJ2xlZnQnOyAgLy9sZWZ0L3JpZ2h0L3RvcC9ib3R0b20vYXJvdW5kXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHRyaWdnZXIgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCJDbGljayBtZSFcIixcbiAgICAgICAgICAgIGljb246IFwicGx1c1wiLFxuICAgICAgICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgICAgICAgc2l6ZTogXCJtZWRpdW1cIixcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRvcCA9IFwiMmVtXCIsXG4gICAgICAgIGxlZnQgPSBcIjJlbVwiLFxuICAgICAgICByaWdodCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IHBvc2l0aW9uU3R5bGUgPSAkc3RhdGUoXCJcIik7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgcG9zaXRpb25TdHlsZSA9IFwiXCI7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYHRvcDogJHt0b3B9O2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYGxlZnQ6ICR7bGVmdH07YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYHJpZ2h0OiAke3JpZ2h0fTtgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3R0b20pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3R5bGUgKz0gYGJvdHRvbTogJHtib3R0b219O2A7XG4gICAgICAgIH1cbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwiaXMtYWJzb2x1dGUge2NsYXNzZXN9XCIgc3R5bGU9e3Bvc2l0aW9uU3R5bGV9PlxuICAgIDxVSUJ1dHRvbiB7Li4udHJpZ2dlcn0gLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICAvKiBlc2xpbnQgc3ZlbHRlL25vLWF0LWh0bWwtdGFnczogMCAqL1xuXG4gICAgaW1wb3J0IFVJSWNvbkZvbnQgZnJvbSBcIi4vdWkuaWNvbi5mb250LnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlID0gXCJcIl0gLSBmb250IGljb24gdGl0bGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpemUgPSBcIlwiXSAgLSBmb250IGljb24gc2l6ZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZm9udCA9IFwiXCJdIC0gZm9udCBpY29uIG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N2ZyA9IFwiXCJdIC0gc3ZnIGljb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NyYyA9IFwiXCJdIC0gaW1hZ2UgaWNvblxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfHN0cmluZ30gd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IGhlaWdodFxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIHNpemUgPSBcIlwiLFxuICAgICAgICBmb250ID0gXCJcIixcbiAgICAgICAgc3ZnID0gXCJcIixcbiAgICAgICAgc3JjID0gXCJcIixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNpZiBmb250fVxuICAgIDxVSUljb25Gb250IHtmb250fSB7c2l6ZX0ge3RpdGxlfT48L1VJSWNvbkZvbnQ+XG57OmVsc2UgaWYgc3ZnfVxuICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPntAaHRtbCBzdmd9PC9zcGFuPlxuezplbHNlIGlmIHNyY31cbiAgICA8ZmlndXJlIGNsYXNzPVwiaW1hZ2Uge3dpZHRoICYmIGhlaWdodCA/IGBpcy0ke3dpZHRofXgke2hlaWdodH1gIDogJyd9IFwiPlxuICAgICAgICA8aW1nIHtzcmN9IHt0aXRsZX0gYWx0PXt0aXRsZX0ge3dpZHRofSB7aGVpZ2h0fSAvPlxuICAgIDwvZmlndXJlPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVUlJY29uRm9udCB9IGZyb20gXCIuLi9pY29uXCI7XG5cbiAgICBsZXQgeyB2YWxpZGF0ZWQsIHZhbGlkLCBzaWRlID0gXCJyaWdodFwiLCBzaXplID0gXCJzbWFsbFwiIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2lmIHZhbGlkYXRlZCA9PT0gdHJ1ZX1cbiAgICA8VUlJY29uRm9udCBmb250PXt2YWxpZCA/IFwiY2hlY2tcIiA6IFwiZXhjbGFtYXRpb24tdHJpYW5nbGVcIn0ge3NpZGV9IHtzaXplfSAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJRm9ybUlucHV0VmFsaWRhdGVkSWNvbiBmcm9tIFwiLi91aS5mb3JtLmlucHV0LnZhbGlkYXRlZC5pY29uLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCB7IFVJSWNvbkZvbnQgfSBmcm9tIFwiLi4vaWNvblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgVUlJbnB1dFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWVsZHR5cGVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGRuYW1lXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtmaWVsZG5hbWVQcmVmaXggPSBcImZvcm0tZmllbGQtXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGUgPSAnbGVmdCddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2l6ZT0gJ3NtYWxsJ11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2YWxpZCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsaWRhdGVkID0gZmFsc2VdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHZhbHVlID0gJGJpbmRhYmxlKFwiXCIpLFxuICAgICAgICByZWFkb25seSxcbiAgICAgICAgVUlJbnB1dCxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZpZWxkdHlwZSxcbiAgICAgICAgZmllbGRuYW1lLFxuICAgICAgICBmaWVsZG5hbWVQcmVmaXggPSBcImZvcm0tZmllbGQtXCIsXG4gICAgICAgIGljb24sXG4gICAgICAgIHZhbGlkID0gdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVkID0gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyc1xuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlJbnB1dCB7ZmllbGR0eXBlfSB7ZmllbGRuYW1lfSB7dmFsaWR9IHtyZWFkb25seX0gYmluZDp2YWx1ZSB7Li4ub3RoZXJzfSAvPlxuPCEtLSBlZGl0IFVJIHJlbmRlcmVyIC0tPlxueyNpZiBpY29ufVxuICAgIDxVSUljb25Gb250IGZvbnQ9e2ljb259IHNpZGU9e2ljb25TaWRlfSBzaXplPXtpY29uU2l6ZX0gLz5cbnsvaWZ9XG57I2lmICFyZWFkb25seX1cbiAgICA8IS0tIHZhbGlkYXRlZCBhbmQgdmFsaWQgc2hvdWxkIGJlIGNyZWF0ZWQgYnkgJHN0YXRlKCkgLS0+XG4gICAgPFVJRm9ybUlucHV0VmFsaWRhdGVkSWNvbiB7dmFsaWRhdGVkfSB7dmFsaWR9PjwvVUlGb3JtSW5wdXRWYWxpZGF0ZWRJY29uPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTGFiZWwgZnJvbSBcIi4uL2lucHV0L3VpLmxhYmVsLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBJbnB1dEVycm9ycyBmcm9tIFwiLi91aS5mb3JtLmlucHV0LmVycm9ycy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlGb3JtSW5wdXQgZnJvbSBcIi4vdWkuZm9ybS5pbnB1dC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250cm9sIGZyb20gXCIuLi9pbnB1dC91aS5jb250cm9sLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnB1dFN0YXJ0ZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWVsZG5hbWVcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmllbGR0eXBlXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWNvblNpZGVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpY29uU2l6ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXF1aXJlZCA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRvbmx5XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FibGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi9ldmVudHMudHlwZXMnKS5VSUV2ZW50SW5wdXRDaGFuZ2VDYWxsYmFja30gW29uY2hhbmdlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbGlkYXRlZF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlcnJvcnNdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9ybUVycm9yc11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgdmFsdWUgPSAkYmluZGFibGUoXCJcIiksXG4gICAgICAgIFVJSW5wdXQsXG4gICAgICAgIGlucHV0U3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgbGFiZWxWZXJ0aWNhbCA9IHRydWUsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gXCJcIixcbiAgICAgICAgZmllbGR0eXBlLFxuICAgICAgICBmaWVsZG5hbWUsXG4gICAgICAgIGZpZWxkbmFtZVByZWZpeCA9IFwiZm9ybS1maWVsZC1cIixcbiAgICAgICAgaWNvbiA9IFwiXCIsXG4gICAgICAgIGljb25TaWRlID0gXCJsZWZ0XCIsXG4gICAgICAgIGljb25TaXplID0gXCJzbWFsbFwiLFxuICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgICAgICB2YWxpZCA9IHRydWUsXG4gICAgICAgIHZhbGlkYXRlZCA9IGZhbHNlLFxuICAgICAgICBvbmNoYW5nZSA9ICgpID0+IHRydWUsXG4gICAgICAgIG9uZXJyb3IgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmb3JtRXJyb3JzID0gW10sXG4gICAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgaWNvbkNsYXNzZXMgPSAkZGVyaXZlZChcbiAgICAgICAgKGljb24gPyBcIiBoYXMtaWNvbnMtbGVmdCBcIiA6IFwiXCIpICsgXCIgaGFzLWljb25zLXJpZ2h0IFwiXG4gICAgKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgY29udHJvbCgpfVxuICAgIDxVSUNvbnRyb2wgY2xhc3M9e2ljb25DbGFzc2VzfT5cbiAgICAgICAgPFVJRm9ybUlucHV0XG4gICAgICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgICAgICB7VUlJbnB1dH1cbiAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIHtmaWVsZHR5cGV9XG4gICAgICAgICAgICB7ZmllbGRuYW1lfVxuICAgICAgICAgICAge2ZpZWxkbmFtZVByZWZpeH1cbiAgICAgICAgICAgIHtpY29ufVxuICAgICAgICAgICAge2ljb25TaWRlfVxuICAgICAgICAgICAge2ljb25TaXplfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge2lucHV0U3RhcnRlZH1cbiAgICAgICAgICAgIHt2YWxpZGF0ZWR9XG4gICAgICAgICAgICB7dmFsaWR9XG4gICAgICAgICAgICB7b25jaGFuZ2V9XG4gICAgICAgICAgICB7b25lcnJvcn1cbiAgICAgICAgICAgIHsuLi5vdGhlcnN9XG4gICAgICAgIC8+XG4gICAgPC9VSUNvbnRyb2w+XG57L3NuaXBwZXR9XG5cbnsjaWYgbGFiZWx9XG4gICAgeyNpZiBsYWJlbFZlcnRpY2FsfVxuICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgY2xhc3M9e2ZpZWxkdHlwZX1cbiAgICAgICAgICAgIGZvcj1cIntmaWVsZG5hbWVQcmVmaXh9e2ZpZWxkdHlwZX0te2ZpZWxkbmFtZX1cIlxuICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAvPlxuICAgICAgICB7QHJlbmRlciBjb250cm9sKCl9XG4gICAgezplbHNlfVxuICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgY2xhc3M9e2ZpZWxkdHlwZX1cbiAgICAgICAgICAgIGZvcj1cIntmaWVsZG5hbWVQcmVmaXh9e2ZpZWxkdHlwZX0te2ZpZWxkbmFtZX1cIlxuICAgICAgICA+XG4gICAgICAgICAgICB7bGFiZWx9OiB7QHJlbmRlciBjb250cm9sKCl9XG4gICAgICAgIDwvVUlMYWJlbD5cbiAgICB7L2lmfVxuezplbHNlfVxuICAgIHtAcmVuZGVyIGNvbnRyb2woKX1cbnsvaWZ9XG5cbjxJbnB1dEVycm9yc1xuICAgIHtpbnB1dFN0YXJ0ZWR9XG4gICAge3ZhbGlkYXRlZH1cbiAgICB7dmFsaWR9XG4gICAge2Vycm9yc31cbiAgICB7Zm9ybUVycm9yc31cbiAgICBpZD1cImlucHV0LWZpZWxkLWhlbHBlci17ZmllbGRuYW1lfVwiXG4vPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi91aS5pbWFnZS5zdmVsdGVcIjtcblxuICAgIGxldCB7IHZhbHVlcyA9IFtdLCAuLi5vdmVycmlkZSB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxueyNlYWNoIHZhbHVlcyBhcyBpdGVtIChpdGVtLnVybCl9XG4gICAgPFVJSW1hZ2Ugey4uLml0ZW19IHsuLi5vdmVycmlkZX0gLz5cbnsvZWFjaH1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgVUlCdXR0b25zUm93IH0gZnJvbSBcIi4uLy4uL2J1dHRvblwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbcGFnZV0gICAgICAgICAgICAgICAgLSBjdXJyZW50IHBhZ2VcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbcGFnZXNdICAgICAgICAgICAgICAgLSB0b3RhbCBjb3VudCBvZiBwYWdlc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtidXR0b25zUm93Q29tcG9uZW50ID0gVUlCdXR0b25zUm93XSAtIGJ1dHRvbnMgcm93IHVpIHN2ZWx0ZSBjb21wb25lbnRcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uc1Jvd0NvbXBvbmVudFByb3BzXSAgIC0gYnV0dG9ucyByb3cgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uUHJldlByb3BzXSAgIC0gcHJldiBidXR0b24gdWkgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uUHJvZ3Jlc3NQcm9wc10gICAtIGNlbnRlci9wcm9ncmVzcyBidXR0b24gdWkgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbYnV0dG9uTmV4dFByb3BzXSAgIC0gbmV4dCBidXR0b24gdWkgY29tcG9uZW50IHByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25uZXh0XSAgICAgICAgICAgIC0gY2FsbGJhY2sgb24gbmV4dFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtvbnByZXZdICAgICAgICAgICAgLSBjYWxsYmFjayBvbiBwcmV2XG4gICAgICogQHByb3BlcnR5ICAgIHtzdHJpbmd9ICAgIFtwcm9ncmVzc1RpdGxlU3RhcnQgPSAnJ10gIC0gcHJlZml4IG9mIHByb2dyZXNzIGJ1dHRvbiB0aXRsZVxuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbcHJvZ3Jlc3NUaXRsZURlbGltaXRlciA9ICcgLyAnXSAgLSB0ZXh0IHRoYXQgYnJlYWtzIG51bWJlcnMgb2YgY3VycmVudCBwYWdlIGFuZCB0b3RhbCBjb3VudCBvZiBwYWdlc1xuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbcHJvZ3Jlc3NUaXRsZUVuZCA9ICcnXSAgLSBzdWZmaXggb2YgcHJvZ3Jlc3MgYnV0dG9uIHRpdGxlXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHBhZ2UgPSAwLFxuICAgICAgICBwYWdlcyA9IDAsXG4gICAgICAgIGJ1dHRvbnNSb3dDb21wb25lbnQ6IFVJQnV0dG9uc1Jvd0NvbXBvbmVudCA9IFVJQnV0dG9uc1JvdyxcbiAgICAgICAgYnV0dG9uc1Jvd0NvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIGJ1dHRvblByZXZQcm9wcyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIm5vdC1ub2RlOmxpc3RfbmF2aWdhdGlvbl9wcmV2X2J1dHRvbl9sYWJlbFwiLFxuICAgICAgICB9LFxuICAgICAgICBidXR0b25Qcm9ncmVzc1Byb3BzID0ge30sXG4gICAgICAgIGJ1dHRvbk5leHRQcm9wcyA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIm5vdC1ub2RlOmxpc3RfbmF2aWdhdGlvbl9uZXh0X2J1dHRvbl9sYWJlbFwiLFxuICAgICAgICB9LFxuICAgICAgICAvL3RoaXMgaXMgcGxhY2Vob2xkZXJzIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIG9ubHksIGBwYWdlYCBzaG91bGQgYmUgbW9kaWZpZWQgb3V0c2lkZSBpbiBvbnByZXYvb25uZXh0IGNhbGxiYWNrc1xuICAgICAgICBvbnByZXYgPSAoKSA9PiB7XG4gICAgICAgICAgICBwYWdlID4gMCAmJiBwYWdlLS07XG4gICAgICAgIH0sXG4gICAgICAgIG9ubmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIHBhZ2UgPCBwYWdlcyAtIDEgJiYgcGFnZSsrO1xuICAgICAgICB9LFxuICAgICAgICBwcm9ncmVzc1RpdGxlU3RhcnQgPSBcIlwiLFxuICAgICAgICBwcm9ncmVzc1RpdGxlRGVsaW1pdGVyID0gXCIgLyBcIixcbiAgICAgICAgcHJvZ3Jlc3NUaXRsZUVuZCA9IFwiXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGN1cnJlbnRQYWdlID0gJGRlcml2ZWQocGFnZSArIDEpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgcGFnZXMgPiAwfVxuICAgIDxVSUJ1dHRvbnNSb3dDb21wb25lbnRcbiAgICAgICAgey4uLmJ1dHRvbnNSb3dDb21wb25lbnRQcm9wc31cbiAgICAgICAgbGVmdD17Y3VycmVudFBhZ2UgPiAxXG4gICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5idXR0b25QcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBvbnByZXYsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtdfVxuICAgICAgICBjZW50ZXI9e3BhZ2VzID4gMVxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uYnV0dG9uUHJvZ3Jlc3NQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYCR7cHJvZ3Jlc3NUaXRsZVN0YXJ0fSR7Y3VycmVudFBhZ2V9JHtwcm9ncmVzc1RpdGxlRGVsaW1pdGVyfSR7cGFnZXN9JHtwcm9ncmVzc1RpdGxlRW5kfWAsXG4gICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtdfVxuICAgICAgICByaWdodD17Y3VycmVudFBhZ2UgPCBwYWdlc1xuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uYnV0dG9uTmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogb25uZXh0LFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgOiBbXX1cbiAgICAvPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJQm94IGZyb20gXCIuLi8uLi9ibG9jay91aS5ib3guc3ZlbHRlXCI7XG5cbiAgICBsZXQgeyB0aXRsZSwgaWQsIF9pZCwgb25jbGljayB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25jbGljayh7XG4gICAgICAgICAgICBfaWQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlCb3ggb25jbGljaz17Y2xpY2t9IG9ua2V5dXA9e2NsaWNrfSBjbGFzcz1cImxpc3QtaXRlbS1zZWxlY3RhYmxlXCI+XG4gICAgPHNwYW4+e3RpdGxlfTwvc3Bhbj5cbjwvVUlCb3g+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUVuZGxlc3NMaXN0U2ltcGxlSXRlbSBmcm9tIFwiLi91aS5lbmRsZXNzLmxpc3Quc2ltcGxlLml0ZW0uc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJRW5kbGVzc0xpc3RFbXB0eVBsYWNlaG9sZGVyIGZyb20gXCIuLi91aS5saXN0LmVtcHR5LnBsYWNlaG9sZGVyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUVuZGxlc3NMaXN0TmF2aWdhdGlvbiBmcm9tIFwiLi91aS5lbmRsZXNzLmxpc3QubmF2aWdhdGlvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUJsb2NrIH0gZnJvbSBcIi4uLy4uL2Jsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZGF0YV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1Db21wb25lbnQgPSBVSUVuZGxlc3NMaXN0U2ltcGxlSXRlbV0gLSBsaXN0IGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1Db21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2VtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdEVtcHR5UGxhY2Vob2xkZXJdIC0gaWYgbGlzdCBpcyBlbXB0eVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2xpc3ROYXZpZ2F0aW9uQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdE5hdmlnYXRpb25dIC0gcHJldiBhbmQgbmV4dCBibG9ja1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlzdE5hdmlnYXRpb25Db21wb25lbnRQcm9wc11cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBkYXRhID0gJGJpbmRhYmxlKHtcbiAgICAgICAgICAgIGxpc3Q6IFtdLFxuICAgICAgICAgICAgc2tpcDogMCxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgcGFnZTogMCxcbiAgICAgICAgICAgIHBhZ2VzOiAwLFxuICAgICAgICB9KSxcbiAgICAgICAgaXRlbUNvbXBvbmVudDogVUlJdGVtQ29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdFNpbXBsZUl0ZW0sXG4gICAgICAgIGl0ZW1Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBlbXB0eUxpc3RQbGFjZWhvbGRlckNvbXBvbmVudDpcbiAgICAgICAgICAgIFVJRW1wdHlMaXN0UGxhY2Vob2xkZXIgPSBVSUVuZGxlc3NMaXN0RW1wdHlQbGFjZWhvbGRlcixcbiAgICAgICAgZW1wdHlMaXN0UGxhY2Vob2xkZXJDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbkNvbXBvbmVudDpcbiAgICAgICAgICAgIFVJTmF2aWdhdGlvbkNvbXBvbmVudCA9IFVJRW5kbGVzc0xpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbkNvbXBvbmVudFByb3BzID0ge30sXG4gICAgICAgIG9uc2VsZWN0LFxuICAgICAgICBvbnByZXYsXG4gICAgICAgIG9ubmV4dCxcbiAgICAgICAgaXRlbVJlbmRlcmVyLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlCbG9jayBjbGFzcz17Y2xhc3Nlc30+XG4gICAgeyNpZiBkYXRhPy5saXN0Py5sZW5ndGh9XG4gICAgICAgIHsjZWFjaCBkYXRhLmxpc3QgYXMgaXRlbSwgaW5kZXggKGl0ZW0uaWQpfVxuICAgICAgICAgICAgeyNpZiBpdGVtUmVuZGVyZXJ9XG4gICAgICAgICAgICAgICAge0ByZW5kZXIgaXRlbVJlbmRlcmVyKGl0ZW0sIGluZGV4KX1cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8VUlJdGVtQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uc2VsZWN0fVxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbUNvbXBvbmVudFByb3BzfVxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuICAgIHs6ZWxzZX1cbiAgICAgICAgPFVJRW1wdHlMaXN0UGxhY2Vob2xkZXIgey4uLmVtcHR5TGlzdFBsYWNlaG9sZGVyQ29tcG9uZW50UHJvcHN9IC8+XG4gICAgey9pZn1cbjwvVUlCbG9jaz5cbjxVSU5hdmlnYXRpb25Db21wb25lbnRcbiAgICB7Li4ubGlzdE5hdmlnYXRpb25Db21wb25lbnRQcm9wc31cbiAgICBiaW5kOnBhZ2U9e2RhdGEucGFnZX1cbiAgICBiaW5kOnBhZ2VzPXtkYXRhLnBhZ2VzfVxuICAgIGJpbmQ6c2tpcD17ZGF0YS5za2lwfVxuICAgIGJpbmQ6Y291bnQ9e2RhdGEuY291bnR9XG4gICAge29ucHJldn1cbiAgICB7b25uZXh0fVxuLz5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8vXG4gICAgaW1wb3J0IFVJTGlzdCBmcm9tIFwiLi4vdWkubGlzdC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlJbWFnZSBmcm9tIFwiLi4vLi4vaW1hZ2UvdWkuaW1hZ2Uuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbZmllbGRuYW1lID0gXCJsaXN0LXNlbGVjdFwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICBbbXVsdGlwbGUgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHdhbnQgbm90IG9uZSB2YXJpYW50IHNlbGVjdGVkXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgICAgIFthdExlYXN0T25lID0gdHJ1ZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gZW1wdHkgcmVzdWx0XG4gICAgICogQHByb3BlcnR5IHthcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5WYXJpYW50cz59IFt2YXJpYW50cyA9IFtdXSAgICAgICAgICAgdmFyaWFudHMgdG8gc2VsZWN0IGZyb21cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PG9iamVjdD59IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLi4uc2VsZWN0ZWRJdGVtc1ZhbHVlc11cbiAgICAgKiBAcHJvcGVydHkge2FycmF5PHN0cmluZ3xudW1iZXI+fSBbc2VsZWN0ZWRWYXJpYW50c0lkcyA9IFtdXSAgICAgICAgICAgICAgICAgICAgICBbLi4uc2VsZWN0ZWRJdGVtc0lkc11cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW3RpdGxlQ29tcG9uZW50UHJvcHM9IHsgc2l6ZTogNSB9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbaW1hZ2VDb21wb25lbnQgPSBVSUltYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbaW1hZ2VDb21wb25lbnRQcm9wcz0geyBjb3ZlcmVkOiB0cnVlIH1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtsaXN0Q29tcG9uZW50ID0gVUlMaXN0XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbbGlzdENvbXBvbmVudFByb3BzID0ge2FjdGlvbnNWaXNpYmxlOiB0cnVlfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW3N1YmxpbWVWYWx1ZSA9ICh2YWx1ZSkgPT4gdmFsdWUuaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFt1cGRhdGVWYXJpYW50ID0gKHZhbHVlSWQsIHByb3BzLCB0b2dnbGVUaXRsZSkgPT4gdm9pZF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldEl0ZW1JbmRleCA9IChpdGVtcywgdmFsdWVJZCkgPT4gbnVtYmVyXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbZ2V0SXRlbSA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IG9iamVjdF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldEl0ZW1WYWx1ZSA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IG9iamVjdF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2dldERlZmF1bHRJdGVtU3VibGltZSA9IChpdGVtcykgPT4gc3RyaW5nXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdXBkYXRlVmFyaWFudCA9IChpdGVtcywgdmFsdWVJZCwgcHJvcHMsIHRvZ2dsZVRpdGxlKSA9PiB2b2lkXVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdWlPbiA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHZvaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFt1aU9mZiA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHZvaWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtleHRlbmRWYXJpYW50VG9JdGVtTGlzdCA9IChpdGVtKSA9PiBvYmplY3RdXG4gICAgICovXG4gICAgbGV0IGl0ZW1zID0gJHN0YXRlKFtdKTtcbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZpZWxkbmFtZSA9IFwibGlzdC1zZWxlY3RcIixcbiAgICAgICAgbXVsdGlwbGUgPSBmYWxzZSxcbiAgICAgICAgYXRMZWFzdE9uZSA9IHRydWUsXG4gICAgICAgIHZhcmlhbnRzID0gW10sIC8vdmFyaWFudHMgdG8gc2VsZWN0IGZyb21cbiAgICAgICAgdmFsdWUgPSBbXSwgLy9zZWxlY3RlZCBvYmplY3RzXG4gICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMgPSBbXSwgLy9vbmx5IGlkcyBvZiBzZWxlY3RlZCB2YXJpYW50c1xuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBsaXN0Q29tcG9uZW50OiBVSUxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHsgYWN0aW9uc1Zpc2libGU6IHRydWUgfSxcbiAgICAgICAgc3VibGltZVZhbHVlID0gKHZhbHVlKSA9PiB2YWx1ZS5pZCwgLy9vYmplY3QgLT4gaWRcbiAgICAgICAgZ2V0SXRlbUluZGV4ID0gKGl0ZW1zLCB2YWx1ZUlkKSA9PlxuICAgICAgICAgICAgaXRlbXMuZmluZEluZGV4KCh2YWwpID0+IHZhbC52YWx1ZS5pZCA9PT0gdmFsdWVJZCksXG4gICAgICAgIGdldEl0ZW0gPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEl0ZW1JbmRleChpdGVtcywgdmFsdWVJZCk7XG4gICAgICAgICAgICAvL3JldHVybnMgdmFyaWFudHMgYnkgaXRzIGlkXG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMVxuICAgICAgICAgICAgICAgID8gaXRlbXMuZmluZCgoYnRuVmFsKSA9PiBidG5WYWwudmFsdWUuaWQgPT09IHZhbHVlSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEl0ZW1WYWx1ZSA9IChpdGVtcywgeyB2YWx1ZUlkIH0pID0+IHtcbiAgICAgICAgICAgIC8vIHJldHVybnMgdmFyaWFudCdzIHZhbHVlIGJ5IGlkIG9mIHZhcmlhbnRcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtKGl0ZW1zLCB7IHZhbHVlSWQgfSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0udmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERlZmF1bHRJdGVtU3VibGltZSA9IChpdGVtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA/IGl0ZW1zWzBdLmlkIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVWYXJpYW50ID0gKGl0ZW1zLCB2YWx1ZUlkLCBpdGVtUHJvcHMsIGJ1dHRvblByb3BzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEl0ZW1JbmRleChpdGVtcywgdmFsdWVJZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMoaXRlbVByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF1ba2V5XSA9IGl0ZW1Qcm9wc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtc1tpbmRleF0uYWN0aW9ucykgJiZcbiAgICAgICAgICAgICAgICBpdGVtc1tpbmRleF0uYWN0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGJ1dHRvblByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaW5kZXhdLmFjdGlvbnNbMF1ba2V5XSA9IGJ1dHRvblByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVpT24gPSAoaXRlbXMsIHsgdmFsdWVJZCB9KSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVWYXJpYW50KFxuICAgICAgICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJoYXMtYmFja2dyb3VuZC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiBcIm5vdC1ub2RlOmJvb2xlYW5zX3RydWVcIiwgY29sb3I6IFwic3VjY2Vzc1wiIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHVpT2ZmID0gKGl0ZW1zLCB7IHZhbHVlSWQgfSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlVmFyaWFudChcbiAgICAgICAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICAgICAgICB2YWx1ZUlkLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiBcIm5vdC1ub2RlOmJvb2xlYW5zX2ZhbHNlXCIsIGNvbG9yOiBcImRhbmdlclwiIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZFZhcmlhbnRUb0l0ZW1MaXN0ID0gKGl0bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0geyAuLi5pdG0gfTtcbiAgICAgICAgICAgIHJlcy5hY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwibm90LW5vZGU6Ym9vbGVhbnNfZmFsc2VcIixcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHRvZ2dsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2hhbmdlLFxuICAgICAgICAuLi5vdGhlcnNcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaXRlbXMgPSB2YXJpYW50cy5tYXAoZXh0ZW5kVmFyaWFudFRvSXRlbUxpc3QpO1xuICAgICAgICBpZiAodmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChhdExlYXN0T25lICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW1WYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdWkgPSB1cGRhdGVTZWxlY3RlZChpdGVtVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVVSSh1aSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0RGVmYXVsdCgpO1xuICAgIH0pO1xuICAgIC8vXG4gICAgZnVuY3Rpb24gY291bnRPZlNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBzZWxlY3RlZFZhcmlhbnRzSWRzLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgY29uc3Qgbm90TGFzdE9uZSA9ICgpID0+ICEoYXRMZWFzdE9uZSAmJiBjb3VudE9mU2VsZWN0ZWQoKSA9PT0gMSk7XG4gICAgLy9cbiAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZChkZXRhaWwpIHtcbiAgICAgICAgY29uc3QgdmFsdWVJZCA9IHN1YmxpbWVWYWx1ZShkZXRhaWwpO1xuICAgICAgICBsZXQgdWkgPSB7XG4gICAgICAgICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb2ZmOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzZWxlY3RlZFZhcmlhbnRzSWRzKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkVmFyaWFudHNJZHMuaW5jbHVkZXModmFsdWVJZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm90TGFzdE9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcy5pbmRleE9mKHZhbHVlSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB1aS5vZmYgPSB7IHZhbHVlSWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMucHVzaCh2YWx1ZUlkKTtcbiAgICAgICAgICAgICAgICB1aS5vbiA9IHsgdmFsdWVJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGF0TGVhc3RPbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGVkVmFyaWFudHNJZHMuaW5jbHVkZXModmFsdWVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50T2ZTZWxlY3RlZCgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWkub2ZmID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHNlbGVjdGVkVmFyaWFudHNJZHMucG9wKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVpLm9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcyA9IFt2YWx1ZUlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFZhcmlhbnRzSWRzLmluY2x1ZGVzKHZhbHVlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLm9mZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFyaWFudHNJZHMuc3BsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcy5pbmRleE9mKHZhbHVlSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLm9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYXJpYW50c0lkcy5wdXNoKHZhbHVlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1aTtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiB0b2dnbGUoZGV0YWlsKSB7XG4gICAgICAgIGxldCB1aSA9IHVwZGF0ZVNlbGVjdGVkKGRldGFpbCk7XG4gICAgICAgIHVwZGF0ZVVJKHVpKTtcbiAgICAgICAgLy9cbiAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgLy9cbiAgICAgICAgb25jaGFuZ2Uoe1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiAkc3RhdGUuc25hcHNob3QodmFsdWUpLFxuICAgICAgICAgICAgaWRzOiAkc3RhdGUuc25hcHNob3Qoc2VsZWN0ZWRWYXJpYW50c0lkcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVVJKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMub2ZmKSB7XG4gICAgICAgICAgICB1aU9mZihpdGVtcywgY2hhbmdlcy5vZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzLm9uKSB7XG4gICAgICAgICAgICB1aU9uKGl0ZW1zLCBjaGFuZ2VzLm9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKCkge1xuICAgICAgICBsZXQgbmV3VmFsID0gW107XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RlZFZhcmlhbnRzSWRzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNlbGVjdGVkVmFyaWFudHNJZHMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbmV3VmFsID0gc2VsZWN0ZWRWYXJpYW50c0lkc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbCkgPT4gdHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAubWFwKCh2YWx1ZUlkKSA9PlxuICAgICAgICAgICAgICAgICAgICBnZXRJdGVtVmFsdWUoaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IG5ld1ZhbDtcbiAgICB9XG4gICAgLy9cbiAgICBmdW5jdGlvbiBzZWxlY3REZWZhdWx0KCkge1xuICAgICAgICBpZiAoYXRMZWFzdE9uZSAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZWYWx1ZUlkID0gZ2V0RGVmYXVsdEl0ZW1TdWJsaW1lKGl0ZW1zKTtcbiAgICAgICAgICAgIGlmIChkZWZWYWx1ZUlkKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKHsgaWQ6IGRlZlZhbHVlSWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPFVJTGlzdENvbXBvbmVudFxuICAgIHt0aXRsZUNvbXBvbmVudFByb3BzfVxuICAgIHtpbWFnZUNvbXBvbmVudH1cbiAgICB7aW1hZ2VDb21wb25lbnRQcm9wc31cbiAgICB7Li4ub3RoZXJzfVxuICAgIHsuLi5saXN0Q29tcG9uZW50UHJvcHN9XG4gICAge2l0ZW1zfVxuLz5cbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBzdGF0aWMgbWV0aG9kcyB0byB3b3JrIHdpdGggU2VsZWN0b3JHcm91cHMgb2JqZWN0c1xuICpcbiAqIEBjbGFzcyBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gKi9cbmNsYXNzIExpc3RHcm91cHNVSVRyZWVEVE8ge1xuICAgIHN0YXRpYyBVSV9QUk9QU19ERUxUQV9PTiA9IHtcbiAgICAgICAgY2xhc3M6IFwiaGFzLWJhY2tncm91bmQtc3VjY2Vzc1wiLFxuICAgIH07XG5cbiAgICBzdGF0aWMgVUlfUFJPUFNfREVMVEFfT0ZGID0ge1xuICAgICAgICBjbGFzczogXCJcIixcbiAgICB9O1xuXG4gICAgc3RhdGljIFVJX1BST1BTX0RFTFRBX09OX0FDVElPTiA9IHtcbiAgICAgICAgdGl0bGU6IFwibm90LW5vZGU6Ym9vbGVhbnNfdHJ1ZVwiLFxuICAgICAgICBjb2xvcjogXCJzdWNjZXNzXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBVSV9QUk9QU19ERUxUQV9PRkZfQUNUSU9OID0ge1xuICAgICAgICB0aXRsZTogXCJub3Qtbm9kZTpib29sZWFuc19mYWxzZVwiLFxuICAgICAgICBjb2xvcjogXCJkYW5nZXJcIixcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aXRsZSBmaWVsZCBmcm9tIG9iamVjdCBhcyBzdHJpbmdcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICB2YWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHZhbC50aXRsZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0R3JvdXBUaXRsZSh7IHRpdGxlIH0pIHtcbiAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgaW1hZ2UgZmllbGQgZnJvbSBvYmplY3QgYXMgc3RyaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgdmFsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICB2YWwuaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cblxuICAgIHN0YXRpYyBjb252ZXJ0R3JvdXBJbWFnZSh7IGltYWdlIH0pIHtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB2YXJpYW50IG9iamVjdCB0byBzZWxlY3RvciBpdGVtIG9iamVjdFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlZhcmlhbnR9IHZhcmlhbnRcbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JJdGVtfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnRWYXJpYW50KHZhcmlhbnQsIGdyb3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB2YXJpYW50LmlkLFxuICAgICAgICAgICAgdGl0bGU6IHZhcmlhbnQudGl0bGUsXG4gICAgICAgICAgICB2YWx1ZTogeyB2YWx1ZUlkOiB2YXJpYW50LmlkLCBncm91cElkIH0sIC8vd2hhdCB3ZSB3aWxsIHN1YmxpbWVcbiAgICAgICAgfTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50c0dyb3VwfSBncm91cFxuICAgICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3VwfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZlcnRWYXJpYW50c0dyb3VwKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogZ3JvdXAuaWQsXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5jb252ZXJ0R3JvdXBUaXRsZShncm91cCksXG4gICAgICAgICAgICBpbWFnZTogdGhpcy5jb252ZXJ0R3JvdXBJbWFnZShncm91cCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIHZhbHVlczogZ3JvdXAudmFyaWFudHMubWFwKChpdG0pID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydFZhcmlhbnQoaXRtLCBncm91cC5pZClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50c0dyb3Vwc30gdmFyaWFudHNcbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzKHZhcmlhbnRzKSB7XG4gICAgICAgIHJldHVybiB2YXJpYW50cy5tYXAoKGl0bSkgPT4gdGhpcy5jb252ZXJ0VmFyaWFudHNHcm91cChpdG0pKTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHtncm91cDogbnVtYmVyLCBpZDogbnVtYmVyfSBhcyBTZWxlY3RlZFZhcmlhbnQgdHlwZSB7Z3JvdXBJZDogc3RyaW5nfG51bWJlciwgdmFsdWVJZDogc3RyaW5nfG51bWJlcn1cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtICAge29iamVjdH0gdmFsdWVcbiAgICAgKiBAcmV0dXJuICB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdGVkVmFyaWFudH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBzdWJsaW1lVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwSWQ6IHZhbHVlLmdyb3VwIHx8IHZhbHVlLmdyb3VwSWQsXG4gICAgICAgICAgICB2YWx1ZUlkOiB2YWx1ZS5pZCB8fCB2YWx1ZS52YWx1ZUlkLFxuICAgICAgICB9O1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGdyb3VwIGluIGFycmF5IGJ5IGdyb3VwSWQgb3IgdW5kZWZpbmVkIGlmIGl0cyBub3QgZm91bmRcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3Vwc30gc2VsZWN0b3JHcm91cHNJdGVtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cElkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9yR3JvdXBJbmRleChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBncm91cElkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2VsZWN0b3JHcm91cHNJdGVtcy5maW5kSW5kZXgoXG4gICAgICAgICAgICAoZ3JvdXApID0+IGdyb3VwLmlkID09PSBncm91cElkXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaW5kZXggOiB1bmRlZmluZWQ7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXB9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3JHcm91cChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3JHcm91cHNJdGVtc1tpbmRleF07XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXB9IGdyb3VwXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBzZWxlY3Rvckdyb3VwSGFzVmFyaWFudHMoZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGdyb3VwICYmXG4gICAgICAgICAgICBncm91cC5kZXNjcmlwdGlvbiAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShncm91cC5kZXNjcmlwdGlvbi52YWx1ZXMpXG4gICAgICAgICk7XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5TZWxlY3Rvckdyb3VwfSBncm91cFxuICAgICAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL3R5cGVzLmpzXCIpLlNlbGVjdG9ySXRlbXN9XG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNVSVRyZWVEVE9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2VsZWN0b3JHcm91cFZhcmlhbnRzKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBncm91cC5kZXNjcmlwdGlvbi52YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wYXJhdGlvbiBmdW5jdGlvbiwgKHZhbDogU2VsZWN0b3JJdGVtKT0+Ym9vbGVhbixcbiAgICAgKiB3aGljaCBjaGVja3MgaWYgdmFsIGhhcyBzcGVjaWZpZWQgdmFyaWFudElkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSB2YXJpYW50SWRcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlU2VsZWN0b3JHcm91cFZhbHVlSWRXaXRoKHZhcmlhbnRJZCkge1xuICAgICAgICByZXR1cm4gKHZhbCkgPT4gdmFsPy52YWx1ZT8udmFsdWVJZCA9PT0gdmFyaWFudElkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGl0ZW0gaW4gZ3JvdXAgYnkgZ3JvdXBJbmRleCBhbmQgaXRlbSB2YWx1ZUlkIG9yIHVuZGVmaW5lZCBpZiBpdHMgbm90IGZvdW5kXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXhcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5WYXJpYW50SWR9IHZhbHVlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3Rvckl0ZW1JbmRleChzZWxlY3Rvckdyb3Vwc0l0ZW1zLCBncm91cEluZGV4LCB2YWx1ZUlkKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGdyb3VwSW5kZXgpO1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0b3JHcm91cEhhc1ZhcmlhbnRzKGdyb3VwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtSW5kZXggPSB0aGlzLmdldFNlbGVjdG9yR3JvdXBWYXJpYW50cyhncm91cCkuZmluZEluZGV4KFxuICAgICAgICAgICAgdGhpcy5jb21wYXJlU2VsZWN0b3JHcm91cFZhbHVlSWRXaXRoKHZhbHVlSWQpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpdGVtSW5kZXggPiAtMSA/IGl0ZW1JbmRleCA6IHVuZGVmaW5lZDtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7Z3JvdXBJbmRleDogbnVtYmVyLCBpdGVtSW5kZXg6IG51bWJlcn0gb3IgdW5kZWZpbmVkIGZyb20gVmFyaWFudHNHcm91cHMgYnkgZ3JvdXBJZCwgdmFsdWVJZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSBncm91cElkXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuVmFyaWFudElkfSB2YWx1ZUlkXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLkl0ZW1JbmRleGVzIHwgdW5kZWZpbmVkfVxuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVUlUcmVlRFRPXG4gICAgICovXG4gICAgc3RhdGljIGdldFNlbGVjdG9ySXRlbUluZGV4ZXMoc2VsZWN0b3JHcm91cHNJdGVtcywgZ3JvdXBJZCwgdmFsdWVJZCkge1xuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwSW5kZXgoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgZ3JvdXBJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoZ3JvdXBJbmRleCA9PT0gLTEgfHwgdHlwZW9mIGdyb3VwSW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbUluZGV4ID0gdGhpcy5nZXRTZWxlY3Rvckl0ZW1JbmRleChcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgdmFsdWVJZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaXRlbUluZGV4ID09PSAtMSB8fCB0eXBlb2YgaXRlbUluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgaXRlbUluZGV4LFxuICAgICAgICB9O1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSAgIHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSWRzfSAgICAgICBpdGVtSWRzXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9ySXRlbX1cbiAgICAgKiBAbWVtYmVyb2YgTGlzdEdyb3Vwc1VJVHJlZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTZWxlY3Rvckl0ZW0oc2VsZWN0b3JHcm91cHNJdGVtcywgaXRlbUlkcykge1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSW5kZXhlcyB8IHVuZGVmaW5lZH0gKi9cbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0b3JJdGVtSW5kZXhlcyhcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBpdGVtSWRzLmdyb3VwSWQsXG4gICAgICAgICAgICBpdGVtSWRzLnZhbHVlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluZGV4ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRTZWxlY3Rvckdyb3VwKFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICAgICAgaW5kZXhlcy5ncm91cEluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yR3JvdXBIYXNWYXJpYW50cyhncm91cCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ3JvdXBWYXJpYW50cyA9IHRoaXMuZ2V0U2VsZWN0b3JHcm91cFZhcmlhbnRzKGdyb3VwKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cFZhcmlhbnRzW2luZGV4ZXMuaXRlbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHJldHVybiB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdGVkVmFyaWFudCB8IHVuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgVUlMaXN0U2VsZWN0V2l0aEdyb3Vwc0JlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0U2VsZWN0b3JJdGVtU3VibGltZShzZWxlY3Rvckdyb3Vwc0l0ZW1zKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMgJiZcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yR3JvdXBIYXNWYXJpYW50cyhzZWxlY3Rvckdyb3Vwc0l0ZW1zWzBdKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBzZWxlY3Rvckdyb3Vwc0l0ZW1zWzBdLmlkO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVJZCA9XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtc1swXS5kZXNjcmlwdGlvbi52YWx1ZXNbMF0/LnZhbHVlPy52YWx1ZUlkO1xuICAgICAgICAgICAgaWYgKFVJQ29tbW9uLnN0cmluZ3NPZk51bWJlcnMoW2dyb3VwSWQsIHZhbHVlSWRdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHNlbGVjdG9yIGl0ZW1zXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9IHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSWRzfSBpdGVtSWRzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW1Qcm9wc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY3Rpb25zVUlQcm9wc1xuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKiBAbWVtYmVyb2YgVUlMaXN0U2VsZWN0V2l0aEdyb3Vwc0JlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVTZWxlY3Rvckl0ZW0oXG4gICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgIGl0ZW1JZHMsXG4gICAgICAgIGl0ZW1Qcm9wcyxcbiAgICAgICAgYWN0aW9uc1VJUHJvcHNcbiAgICApIHtcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0b3JJdGVtSW5kZXhlcyhcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBpdGVtSWRzLmdyb3VwSWQsXG4gICAgICAgICAgICBpdGVtSWRzLnZhbHVlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoaXRlbVByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXNbaW5kZXhlcy5ncm91cEluZGV4XS5kZXNjcmlwdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgaW5kZXhlcy5pdGVtSW5kZXhcbiAgICAgICAgICAgIF1ba2V5XSA9IGl0ZW1Qcm9wc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShcbiAgICAgICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zW2luZGV4ZXMuZ3JvdXBJbmRleF0uZGVzY3JpcHRpb24udmFsdWVzW1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLml0ZW1JbmRleFxuICAgICAgICAgICAgICAgIF0uYWN0aW9uc1xuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgc2VsZWN0b3JHcm91cHNJdGVtc1tpbmRleGVzLmdyb3VwSW5kZXhdLmRlc2NyaXB0aW9uLnZhbHVlc1tcbiAgICAgICAgICAgICAgICBpbmRleGVzLml0ZW1JbmRleFxuICAgICAgICAgICAgXS5hY3Rpb25zLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVpUHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXNbaW5kZXhlcy5ncm91cEluZGV4XS5kZXNjcmlwdGlvbi52YWx1ZXNbXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuaXRlbUluZGV4XG4gICAgICAgICAgICAgICAgXVswXVtrZXldID0gYWN0aW9uc1VJUHJvcHNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSAvL3JlZmFjdG9yZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0b3JHcm91cHN9IHNlbGVjdG9yR3JvdXBzSXRlbXNcbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5JdGVtSWRzfSAgIGl0ZW1JZHNcbiAgICAgKiBAbWVtYmVyb2YgVUlMaXN0U2VsZWN0V2l0aEdyb3Vwc0JlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyB1aU9uKHNlbGVjdG9yR3JvdXBzSXRlbXMsIGl0ZW1JZHMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rvckl0ZW0oXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3Vwc0l0ZW1zLFxuICAgICAgICAgICAgaXRlbUlkcyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLlVJX1BST1BTX0RFTFRBX09OLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgLi4udGhpcy5VSV9QUk9QU19ERUxUQV9PTl9BQ1RJT04gfVxuICAgICAgICApO1xuICAgIH0gLy9yZWZhY3RvcmVkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLlNlbGVjdG9yR3JvdXBzfSBzZWxlY3Rvckdyb3Vwc0l0ZW1zXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuSXRlbUlkc30gICBpdGVtSWRzXG4gICAgICogQG1lbWJlcm9mIFVJTGlzdFNlbGVjdFdpdGhHcm91cHNCZWhhdmlvdXJcbiAgICAgKi9cbiAgICBzdGF0aWMgdWlPZmYoc2VsZWN0b3JHcm91cHNJdGVtcywgaXRlbUlkcykge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdG9ySXRlbShcbiAgICAgICAgICAgIHNlbGVjdG9yR3JvdXBzSXRlbXMsXG4gICAgICAgICAgICBpdGVtSWRzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuVUlfUFJPUFNfREVMVEFfT0ZGLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgLi4udGhpcy5VSV9QUk9QU19ERUxUQV9PRkZfQUNUSU9OIH1cbiAgICAgICAgKTtcbiAgICB9IC8vcmVmYWN0b3JlZFxuXG4gICAgc3RhdGljIHN5bmNVSVdpdGhWYWx1ZShzZWxlY3Rvckdyb3VwcywgaXRlbUluVmFsdWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBzZWxlY3Rvckdyb3Vwcykge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldFNlbGVjdG9yR3JvdXBWYXJpYW50cyhncm91cCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSWRzID0ge1xuICAgICAgICAgICAgICAgICAgICBncm91cElkOiBncm91cC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVJZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpdGVtSW5WYWx1ZShpdGVtSWRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVpT24oc2VsZWN0b3JHcm91cHMsIGl0ZW1JZHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWlPZmYoc2VsZWN0b3JHcm91cHMsIGl0ZW1JZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3JHcm91cHM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBzVUlUcmVlRFRPO1xuIiwiaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb24uanNcIjtcblxuY2xhc3MgTGlzdEdyb3Vwc1ZhbHVlRFRPTXVsdGlwbGVCZWhhdmlvdXIge1xuICAgIHN0YXRpYyBjb3VudEl0ZW1zSW5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlKS5yZWR1Y2UoKGEsIGIpID0+IChhICs9IGIubGVuZ3RoKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh2YWx1ZSkuZXZlcnkodGhpcy5ncm91cEl0ZW1zSXNWYWxpZClcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDoge307XG4gICAgfVxuXG4gICAgc3RhdGljIGdyb3VwSXRlbXNJc1ZhbGlkKGdyb3VwSXRlbXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGdyb3VwSXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwSXRlbXMuZXZlcnkoKGl0bSkgPT4gVUlDb21tb24uc3RyaW5nT3JOdW1iZXIoaXRtKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGl0ZW1JblZhbHVlKHZhbHVlLCBpdGVtKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKHZhbHVlLCBpdGVtLmdyb3VwSWQpICYmXG4gICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLmluY2x1ZGVzKGl0ZW0udmFsdWVJZClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xlYXJGcm9tRW1wdHlHcm91cHModmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JvdXBJc0VtcHR5KHZhbHVlW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBncm91cElzRW1wdHkoZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwICYmIEFycmF5LmlzQXJyYXkoZ3JvdXApKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGdyb3VwSXNGdWxsKHZhbHVlR3JvdXAsIHZhcmlhbnRzR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlR3JvdXAubGVuZ3RoID09PSB2YXJpYW50c0dyb3VwPy52YXJpYW50cz8ubGVuZ3RoO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmF0TGVhc3RPbmUgJiYgdGhpcy5jb3VudEl0ZW1zSW5WYWx1ZSh2YWx1ZSkgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLnNwbGljZShcbiAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0uaW5kZXhPZihpdGVtLnZhbHVlSWQpLFxuICAgICAgICAgICAgMVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsZWFyRnJvbUVtcHR5R3JvdXBzKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMuanMnKS5MaXN0R3JvdXBzT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJvZiBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJdGVtVG9WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5vbmx5T25lUGVyR3JvdXApIHtcbiAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0gPSBbaXRlbS52YWx1ZUlkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmFsdWVbaXRlbS5ncm91cElkXSB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZVtpdGVtLmdyb3VwSWRdKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2l0ZW0uZ3JvdXBJZF0gPSBbaXRlbS52YWx1ZUlkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZVtpdGVtLmdyb3VwSWRdLmluY2x1ZGVzKGl0ZW0udmFsdWVJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbaXRlbS5ncm91cElkXS5wdXNoKGl0ZW0udmFsdWVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdEFsbCh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyaWFudHMuZm9yRWFjaCgodmFyaWFudHNHcm91cCkgPT4ge1xuICAgICAgICAgICAgdmFyaWFudHNHcm91cC52YXJpYW50cy5mb3JFYWNoKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtVG9WYWx1ZShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlSWQ6IHZhcmlhbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiB2YXJpYW50c0dyb3VwLmlkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0Tm9uZSh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goKGdyb3VwSWQpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtncm91cElkXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdEFsbEluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghVUlDb21tb24uc3RyaW5nT3JOdW1iZXIoZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YXJpYW50c0dyb3VwID0gdmFyaWFudHMuZmluZCgoaXRtKSA9PiBpdG0uaWQgPT0gZ3JvdXBJZCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF2YXJpYW50c0dyb3VwIHx8XG4gICAgICAgICAgICAhdmFyaWFudHNHcm91cC52YXJpYW50cyB8fFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFyaWFudHNHcm91cC52YXJpYW50cylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFudHNHcm91cC52YXJpYW50cy5mb3JFYWNoKCh2YXJpYW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZEl0ZW1Ub1ZhbHVlKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICB2YWx1ZUlkOiB2YXJpYW50LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3ROb25lSW5Hcm91cCh2YXJpYW50cywgdmFsdWUsIGdyb3VwSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHZhbHVlW2dyb3VwSWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbZ3JvdXBJZF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgdmFyaWFudHMuZm9yRWFjaCgoZ3JvdXApID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwSXNFbXB0eShncm91cC5pZCkpIHJldHVybjtcbiAgICAgICAgICAgIGdyb3VwLnZhcmlhbnRzLmZvckVhY2goKHZhcmlhbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUluVmFsdWUodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZDogdmFyaWFudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0W2dyb3VwLmlkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtncm91cC5pZF0ucHVzaCh2YXJpYW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtncm91cC5pZF0gPSBbdmFyaWFudF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91cjtcbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbmNsYXNzIExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91ciB7XG4gICAgc3RhdGljIGNvdW50SXRlbXNJblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICAgICAgVUlDb21tb24uc3RyaW5nc09mTnVtYmVycyhbdmFsdWUudmFsdWVJZCwgdmFsdWUuZ3JvdXBJZF0pXG4gICAgICAgICAgICA/IDFcbiAgICAgICAgICAgIDogMDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJlxuICAgICAgICAgICAgVUlDb21tb24uc3RyaW5nc09mTnVtYmVycyhbdmFsdWUudmFsdWVJZCwgdmFsdWUuZ3JvdXBJZF0pXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IHsgdmFsdWVJZDogdW5kZWZpbmVkLCBncm91cElkOiB1bmRlZmluZWQgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIE9iamVjdC5oYXNPd24odmFsdWUsIFwiZ3JvdXBJZFwiKSAmJlxuICAgICAgICAgICAgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ2YWx1ZUlkXCIpICYmXG4gICAgICAgICAgICBVSUNvbW1vbi5zdHJpbmdzT2ZOdW1iZXJzKFt2YWx1ZS52YWx1ZUlkLCB2YWx1ZS5ncm91cElkXSkgJiZcbiAgICAgICAgICAgIHZhbHVlLmdyb3VwSWQgPT0gaXRlbS5ncm91cElkICYmXG4gICAgICAgICAgICB2YWx1ZS52YWx1ZUlkID09IGl0ZW0udmFsdWVJZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy5qcycpLkxpc3RHcm91cHNPcHRpb25zfSBvcHRpb25zXG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91clxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5hdExlYXN0T25lKSB7XG4gICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLnNwbGljZShcbiAgICAgICAgICAgICAgICB2YWx1ZVtpdGVtLmdyb3VwSWRdLmluZGV4T2YoaXRlbS52YWx1ZUlkKSxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGFkZEl0ZW1Ub1ZhbHVlKHZhbHVlLCBpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbml0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZS52YWx1ZUlkID0gaXRlbS52YWx1ZUlkO1xuICAgICAgICB2YWx1ZS5ncm91cElkID0gaXRlbS5ncm91cElkO1xuICAgIH1cblxuICAgIHN0YXRpYyB2YWx1ZUFzVmFyaWFudHModmFsdWUsIHZhcmlhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50SXRlbXNJblZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhbnRzXG4gICAgICAgICAgICAgICAgLmZpbmQoKGdyb3VwKSA9PiBncm91cC5pZCA9PT0gdmFsdWUuZ3JvdXBJZClcbiAgICAgICAgICAgICAgICAudmFyaWFudHMuZmluZCgodmFyaWFudCkgPT4gdmFyaWFudC5pZCA9PT0gdmFsdWUudmFsdWVJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91cjtcbiIsImltcG9ydCBVSUNvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uLmpzXCI7XG5cbmltcG9ydCBMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91ciBmcm9tIFwiLi9saXN0Lmdyb3Vwcy52YWx1ZS5kdG8ubXVsdGlwbGUuYmVoYXZpb3VyLmpzXCI7XG5pbXBvcnQgTGlzdEdyb3Vwc1ZhbHVlRFRPU2luZ2xlQmVoYXZpb3VyIGZyb20gXCIuL2xpc3QuZ3JvdXBzLnZhbHVlLmR0by5zaW5nbGUuYmVoYXZpb3VyLmpzXCI7XG5cbmNsYXNzIExpc3RHcm91cHNWYWx1ZURUTyB7XG4gICAgc3RhdGljIGJlaGF2aW91cihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm11bHRpcGxlXG4gICAgICAgICAgICA/IExpc3RHcm91cHNWYWx1ZURUT011bHRpcGxlQmVoYXZpb3VyXG4gICAgICAgICAgICA6IExpc3RHcm91cHNWYWx1ZURUT1NpbmdsZUJlaGF2aW91cjtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5pdFZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5pbml0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpdGVtSW5WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzLmpzJykuU2VsZWN0ZWRWYWx1ZXN9IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0xpc3RHcm91cHNPcHRpb25zfSBvcHRpb25zXG4gICAgICogQG1lbWJlcm9mIExpc3RHcm91cHNWYWx1ZURUT1xuICAgICAqL1xuICAgIHN0YXRpYyB0b2dnbGUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbUluVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW1Gcm9tVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRJdGVtVG9WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlSXRlbUZyb21WYWx1ZSh2YWx1ZSwgaXRlbSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5yZW1vdmVJdGVtRnJvbVZhbHVlKHZhbHVlLCBpdGVtLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWRkSXRlbVRvVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuYWRkSXRlbVRvVmFsdWUodmFsdWUsIGl0ZW0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3RBbGwodmFyaWFudHMsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0QWxsXCIpO1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5zZWxlY3RBbGwodmFyaWFudHMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VsZWN0Tm9uZSh2YXJpYW50cywgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3ROb25lXCIpO1xuICAgICAgICB0aGlzLmJlaGF2aW91cihvcHRpb25zKS5zZWxlY3ROb25lKHZhcmlhbnRzLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNlbGVjdEFsbEluR3JvdXAodmFyaWFudHMsIHZhbHVlLCBncm91cElkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2VsZWN0QWxsSW5Hcm91cFwiKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuc2VsZWN0QWxsSW5Hcm91cChcbiAgICAgICAgICAgIHZhcmlhbnRzLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBncm91cElkLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZWxlY3ROb25lSW5Hcm91cCh2YXJpYW50cywgdmFsdWUsIGdyb3VwSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3ROb25lSW5Hcm91cFwiKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvdXIob3B0aW9ucykuc2VsZWN0Tm9uZUluR3JvdXAoXG4gICAgICAgICAgICB2YXJpYW50cyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvdXIob3B0aW9ucykudmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXN0R3JvdXBzVmFsdWVEVE87XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvL1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL3VpLmxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uLy4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4uLy4uL2ltYWdlL3VpLmltYWdlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uLy4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IExpc3RHcm91cHNVSVRyZWVEVE8gZnJvbSBcIi4vZHRvL2xpc3QuZ3JvdXBzLnVpLnRyZWUuZHRvLmpzXCI7XG4gICAgaW1wb3J0IExpc3RHcm91cHNWYWx1ZURUTyBmcm9tIFwiLi9kdG8vbGlzdC5ncm91cHMudmFsdWUuZHRvLmpzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgICAgICBbZmllbGRuYW1lID0gXCJsaXN0LXNlbGVjdFwiXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgbmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbb25jaGFuZ2VdICBjYWxsYmFjayBvbiB2YWx1ZSBjaGFuZ2UgZXZlbnRcbiAgICAgKiBAcHJvcGVydHkge2FycmF5PGltcG9ydCgnLi90eXBlcy5qcycpLlZhcmlhbnRzR3JvdXBzPn0gICBbdmFyaWFudHMgPSBbXV0gICAgICAgICAgIHZhcmlhbnRzIHRvIHNlbGVjdCBmcm9tXG4gICAgICogQHByb3BlcnR5IHthcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5TZWxlY3RlZFZhbHVlc30gIFt2YXJpYW50c1NlbGVjdGVkXSAtIG11bHRpcGxlICYmIG11bHRpcGxlIGluIGdyb3VwXG4gICAgICogQHByb3BlcnR5IHthcnJheTxpbXBvcnQoJy4vdHlwZXMuanMnKS5TZWxlY3RlZFZhcmlhbnRzfSAgdmFsdWUgLSB7W2dyb3VwSWRdOiBbLi4udmFsdWVzT2ZTZWxlY3RlZEl0ZW1zXX1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2JlaGF2aW91clVJID0gTGlzdEdyb3Vwc1VJVHJlZURUT11cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2JlaGF2aW91clZhbHVlID0gTGlzdEdyb3Vwc1ZhbHVlRFRPXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICBbbXVsdGlwbGUgPSBmYWxzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHdhbnQgbm90IG9uZSB2YXJpYW50IHNlbGVjdGVkXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSAgICAgIFtvbmx5T25lUGVyR3JvdXAgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gICAgICBbYXRMZWFzdE9uZSA9IHRydWVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vIGVtcHR5IHJlc3VsdFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbdGl0bGVDb21wb25lbnRQcm9wcz0geyBzaXplOiA1IH1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gICAgIFtpbWFnZUNvbXBvbmVudCA9IFVJSW1hZ2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9ICAgICAgIFtpbWFnZUNvbXBvbmVudFByb3BzPSB7IGNvdmVyZWQ6IHRydWUgfV1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSAgICAgW2Rlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgICAgICBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259ICAgICBbbGlzdENvbXBvbmVudCA9IFVJTGlzdF1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICAgICAgW2xpc3RDb21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqL1xuXG4gICAgbGV0IHNlbGVjdG9yR3JvdXBzID0gJHN0YXRlKFtdKTtcbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIG9uY2hhbmdlID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgZmllbGRuYW1lID0gXCJsaXN0LXNlbGVjdC10YWdzXCIsXG4gICAgICAgIHZhcmlhbnRzID0gW10sXG4gICAgICAgIHZhcmlhbnRzU2VsZWN0ZWQgPSB7fSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGJlaGF2aW91clVJID0gTGlzdEdyb3Vwc1VJVHJlZURUTyxcbiAgICAgICAgYmVoYXZpb3VyVmFsdWUgPSBMaXN0R3JvdXBzVmFsdWVEVE8sXG4gICAgICAgIG11bHRpcGxlID0gZmFsc2UsXG4gICAgICAgIG9ubHlPbmVQZXJHcm91cCA9IHRydWUsXG4gICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlLFxuXG4gICAgICAgIHRpdGxlQ29tcG9uZW50ID0gVUlUaXRsZSxcbiAgICAgICAgdGl0bGVDb21wb25lbnRQcm9wcyA9IHsgc2l6ZTogNSB9LFxuICAgICAgICBpbWFnZUNvbXBvbmVudCA9IFVJSW1hZ2UsXG4gICAgICAgIGltYWdlQ29tcG9uZW50UHJvcHMgPSB7IGNvdmVyZWQ6IHRydWUgfSxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnQgPSBVSUJ1dHRvbnMsXG4gICAgICAgIGRlc2NyaXB0aW9uQ29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgbGlzdENvbXBvbmVudDogVUlMaXN0Q29tcG9uZW50ID0gVUlMaXN0LFxuICAgICAgICBsaXN0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVVSSgpIHtcbiAgICAgICAgc2VsZWN0b3JHcm91cHMgPSBiZWhhdmlvdXJVSS5zeW5jVUlXaXRoVmFsdWUoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3VwcyxcbiAgICAgICAgICAgIChpdGVtSWRzKSA9PlxuICAgICAgICAgICAgICAgIGJlaGF2aW91clZhbHVlLml0ZW1JblZhbHVlKHZhbHVlLCBpdGVtSWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3Rvckdyb3Vwc1wiLCBzZWxlY3Rvckdyb3Vwcyk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIHNlbGVjdG9yR3JvdXBzID0gYmVoYXZpb3VyVUkuYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzKHZhcmlhbnRzKTtcbiAgICAgICAgdmFsdWUgPSBiZWhhdmlvdXJWYWx1ZS5pbml0VmFsdWUodmFsdWUsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgfSk7XG5cbiAgICBleHBvcnQgY29uc3QgdmFsdWVBc1ZhcmlhbnRzID0gKCkgPT5cbiAgICAgICAgYmVoYXZpb3VyVmFsdWUudmFsdWVBc1ZhcmlhbnRzKHZhbHVlLCB2YXJpYW50cyk7XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICB2YXJpYW50c1NlbGVjdGVkID0gdmFsdWVBc1ZhcmlhbnRzKCk7XG4gICAgICAgIG9uY2hhbmdlKHtcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZG5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGNvbnN0IHRvZ2dsZUl0ZW0gPSAoaXRlbVZhbHVlKSA9PiB7XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnRvZ2dsZSh2YWx1ZSwgaXRlbVZhbHVlLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3Rvckdyb3Vwc1wiLCBzZWxlY3Rvckdyb3Vwcyk7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuPC9zY3JpcHQ+XG5cbjxVSUxpc3RDb21wb25lbnRcbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcz17e1xuICAgICAgICBhY3Rpb24oZXZlbnQsIGl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlSXRlbShpdGVtVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAuLi5kZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzLFxuICAgIH19XG4gICAge2ltYWdlQ29tcG9uZW50fVxuICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgIGl0ZW1zPXtzZWxlY3Rvckdyb3Vwc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICAvL1xuICAgIGltcG9ydCBVSUxpc3QgZnJvbSBcIi4uL3VpLmxpc3Quc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGl0bGUgZnJvbSBcIi4uLy4uL3ZhcmlvdXMvdWkudGl0bGUuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJSW1hZ2UgZnJvbSBcIi4uLy4uL2ltYWdlL3VpLmltYWdlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uLy4uL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnNTd2l0Y2hlcnMgZnJvbSBcIi4uLy4uL2J1dHRvbi91aS5idXR0b25zLnN3aXRjaGVycy5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBMaXN0R3JvdXBzVUlUcmVlRFRPIGZyb20gXCIuL2R0by9saXN0Lmdyb3Vwcy51aS50cmVlLmR0by5qc1wiO1xuICAgIGltcG9ydCBMaXN0R3JvdXBzVmFsdWVEVE8gZnJvbSBcIi4vZHRvL2xpc3QuZ3JvdXBzLnZhbHVlLmR0by5qc1wiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25jaGFuZ2VdICBjYWxsYmFjayBvbiB2YWx1ZSBjaGFuZ2UgZXZlbnRcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpZWxkbmFtZT1cImxpc3Qtc2VsZWN0LXRhZ3NcIl1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vdHlwZXMnKS5WYXJpYW50c0dyb3Vwc30gW3ZhcmlhbnRzID0gW11dIC1cbiAgICAgKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vdHlwZXMnKS5TZWxlY3RlZFZhbHVlc30gW3ZhcmlhbnRzU2VsZWN0ZWQgPSB7fV0gLSBtdWx0aXBsZSAmJiBtdWx0aXBsZSBpbiBncm91cFxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi90eXBlcycpLlNlbGVjdGVkVmFyaWFudHN9IFt2YWx1ZSA9IFtdXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYmVoYXZpb3VyVUkgPSBMaXN0R3JvdXBzVUlUcmVlRFRPXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbYmVoYXZpb3VyVmFsdWUgPSBMaXN0R3JvdXBzVmFsdWVEVE9dXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGlwbGUgPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29ubHlPbmVQZXJHcm91cCA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYXRMZWFzdE9uZSA9IHRydWVdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3RpdGxlQ29tcG9uZW50ID0gVUlUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW3RpdGxlQ29tcG9uZW50UHJvcHMgPSB7IHNpemU6IDV9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbWFnZUNvbXBvbmVudCA9IFVJSW1hZ2VdXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtpbWFnZUNvbXBvbmVudFByb3BzID0geyBjb3ZlcmVkOiB0cnVlIH1dXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2Rlc2NyaXB0aW9uQ29tcG9uZW50ID0gVUlCdXR0b25zU3dpdGNoZXJzXVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9XVxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtsaXN0Q29tcG9uZW50ID0gVUlMaXN0XVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbbGlzdENvbXBvbmVudFByb3BzID0ge31dXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbYWN0aW9uc0xpc3Q9W1wic2VsZWN0QWxsXCIsIFwic2VsZWN0Tm9uZVwiXV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmaWVsZG5hbWUgPSBcImxpc3Qtc2VsZWN0LXRhZ3NcIixcbiAgICAgICAgdmFyaWFudHMgPSBbXSxcbiAgICAgICAgdmFyaWFudHNTZWxlY3RlZCA9IHt9LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLy9iZWhhdmlvdXIgbWFuYWdlcnNcbiAgICAgICAgYmVoYXZpb3VyVUkgPSBMaXN0R3JvdXBzVUlUcmVlRFRPLFxuICAgICAgICBiZWhhdmlvdXJWYWx1ZSA9IExpc3RHcm91cHNWYWx1ZURUTyxcbiAgICAgICAgLy9iZWhhdmlvdXIgb3B0aW9uc1xuICAgICAgICBtdWx0aXBsZSA9IHRydWUsXG4gICAgICAgIG9ubHlPbmVQZXJHcm91cCA9IHRydWUsXG4gICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlLFxuICAgICAgICAvL2NvbW9wbmVudHMsIHJlbmRlcmVycyBhbmQgcHJvcHMgZm9yIHRoZW1cbiAgICAgICAgdGl0bGVDb21wb25lbnQgPSBVSVRpdGxlLFxuICAgICAgICB0aXRsZUNvbXBvbmVudFByb3BzID0geyBzaXplOiA1IH0sXG4gICAgICAgIGltYWdlQ29tcG9uZW50ID0gVUlJbWFnZSxcbiAgICAgICAgaW1hZ2VDb21wb25lbnRQcm9wcyA9IHsgY292ZXJlZDogdHJ1ZSB9LFxuICAgICAgICBkZXNjcmlwdGlvbkNvbXBvbmVudCA9IFVJQnV0dG9uc1N3aXRjaGVycyxcbiAgICAgICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBsaXN0Q29tcG9uZW50OiBVSUxpc3RDb21wb25lbnQgPSBVSUxpc3QsXG4gICAgICAgIGxpc3RDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBhY3Rpb25zTGlzdCA9IFtcInNlbGVjdEFsbFwiLCBcInNlbGVjdE5vbmVcIl0sXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgLy9cblxuICAgIGNvbnN0IEFWQUlMQUJMRV9BQ1RJT05TID0ge1xuICAgICAgICBzZWxlY3RBbGw6IHtcbiAgICAgICAgICAgIHRpdGxlOiBcItCS0YvQsdGA0LDRgtGMINCy0YHQtVwiLFxuICAgICAgICAgICAgY29sb3I6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgYWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0Tm9uZToge1xuICAgICAgICAgICAgdGl0bGU6IFwi0KHQvdGP0YLRjCDQstGL0LTQtdC70LXQvdC40LUg0YHQviDQstGB0LXRhVwiLFxuICAgICAgICAgICAgY29sb3I6IFwiXCIsXG4gICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Tm9uZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgbGV0IEFDVElPTlMgPSAkc3RhdGUoW10pO1xuICAgIGxldCBzZWxlY3Rvckdyb3VwcyA9ICRzdGF0ZShbXSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVVSSgpIHtcbiAgICAgICAgc2VsZWN0b3JHcm91cHMgPSBiZWhhdmlvdXJVSS5zeW5jVUlXaXRoVmFsdWUoXG4gICAgICAgICAgICBzZWxlY3Rvckdyb3VwcyxcbiAgICAgICAgICAgIChpdGVtSWRzKSA9PlxuICAgICAgICAgICAgICAgIGJlaGF2aW91clZhbHVlLml0ZW1JblZhbHVlKHZhbHVlLCBpdGVtSWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZWxlY3Rvckdyb3Vwc1wiLCBzZWxlY3Rvckdyb3Vwcyk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGNvbnN0IHZhbHVlQXNWYXJpYW50cyA9ICgpID0+XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnZhbHVlQXNWYXJpYW50cyh2YWx1ZSwgdmFyaWFudHMpO1xuXG4gICAgZnVuY3Rpb24gdHJpZ2dlckNoYW5nZSgpIHtcbiAgICAgICAgdmFyaWFudHNTZWxlY3RlZCA9IHZhbHVlQXNWYXJpYW50cygpO1xuICAgICAgICBvbmNoYW5nZSh7XG4gICAgICAgICAgICBmaWVsZDogZmllbGRuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBhY3Rpb25zTGlzdC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuaGFzT3duKEFWQUlMQUJMRV9BQ1RJT05TLCBuYW1lKVxuICAgICAgICAgICAgICAgID8gQUNUSU9OUy5wdXNoKEFWQUlMQUJMRV9BQ1RJT05TW25hbWVdKVxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBBQ1RJT05TID0gQUNUSU9OUztcbiAgICAgICAgc2VsZWN0b3JHcm91cHMgPSBiZWhhdmlvdXJVSS5idWlsZFNlbGVjdG9ySXRlbXNGcm9tVmFyaWFudHModmFyaWFudHMpO1xuICAgICAgICB2YWx1ZSA9IGJlaGF2aW91clZhbHVlLmluaXRWYWx1ZSh2YWx1ZSwgeyBtdWx0aXBsZSB9KTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICB9KTtcblxuICAgIGV4cG9ydCBjb25zdCBzZWxlY3RBbGwgPSAoKSA9PiB7XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnNlbGVjdEFsbCh2YXJpYW50cywgdmFsdWUsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHNlbGVjdE5vbmUgPSAoKSA9PiB7XG4gICAgICAgIGJlaGF2aW91clZhbHVlLnNlbGVjdE5vbmUodmFyaWFudHMsIHZhbHVlLCB7XG4gICAgICAgICAgICBtdWx0aXBsZSxcbiAgICAgICAgICAgIG9ubHlPbmVQZXJHcm91cCxcbiAgICAgICAgICAgIGF0TGVhc3RPbmUsXG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydCBjb25zdCBzZWxlY3RBbGxJbkdyb3VwID0gKGdyb3VwSWQpID0+IHtcbiAgICAgICAgYmVoYXZpb3VyVmFsdWUuc2VsZWN0QWxsSW5Hcm91cCh2YXJpYW50cywgdmFsdWUsIGdyb3VwSWQsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0IGNvbnN0IHNlbGVjdE5vbmVJbkdyb3VwID0gKGdyb3VwSWQpID0+IHtcbiAgICAgICAgYmVoYXZpb3VyLnNlbGVjdE5vbmVJbkdyb3VwKHZhcmlhbnRzLCB2YWx1ZSwgZ3JvdXBJZCwge1xuICAgICAgICAgICAgbXVsdGlwbGUsXG4gICAgICAgICAgICBvbmx5T25lUGVyR3JvdXAsXG4gICAgICAgICAgICBhdExlYXN0T25lLFxuICAgICAgICB9KTtcbiAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICBleHBvcnQgY29uc3QgdG9nZ2xlSXRlbSA9IChpdGVtVmFsdWUpID0+IHtcbiAgICAgICAgYmVoYXZpb3VyVmFsdWUudG9nZ2xlKHZhbHVlLCBpdGVtVmFsdWUsIHtcbiAgICAgICAgICAgIG11bHRpcGxlLFxuICAgICAgICAgICAgb25seU9uZVBlckdyb3VwLFxuICAgICAgICAgICAgYXRMZWFzdE9uZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgfTtcbjwvc2NyaXB0PlxuXG48VUlCdXR0b25zIHZhbHVlcz17QUNUSU9OU30gY2VudGVyZWQ9e3RydWV9IC8+XG5cbjxVSUxpc3RDb21wb25lbnRcbiAgICB7Li4ubGlzdENvbXBvbmVudFByb3BzfVxuICAgIHt0aXRsZUNvbXBvbmVudH1cbiAgICB7dGl0bGVDb21wb25lbnRQcm9wc31cbiAgICB7ZGVzY3JpcHRpb25Db21wb25lbnR9XG4gICAgZGVzY3JpcHRpb25Db21wb25lbnRQcm9wcz17e1xuICAgICAgICBhY3Rpb24oZXZlbnQsIGl0ZW1WYWx1ZSkge1xuICAgICAgICAgICAgdG9nZ2xlSXRlbShpdGVtVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICAuLi5kZXNjcmlwdGlvbkNvbXBvbmVudFByb3BzLFxuICAgIH19XG4gICAge2ltYWdlQ29tcG9uZW50fVxuICAgIHtpbWFnZUNvbXBvbmVudFByb3BzfVxuICAgIGl0ZW1zPXtzZWxlY3Rvckdyb3Vwc31cbi8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgICBpbXBvcnQgeyBvbk1vdW50LCBvbkRlc3Ryb3kgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUJ1dHRvbkNsb3NlIH0gZnJvbSBcIi4uL2J1dHRvblwiO1xuXG4gICAgbGV0IG92ZXJmbG93U2F2ZSA9ICRzdGF0ZShcIlwiKTtcblxuICAgIGNvbnN0IGRlZmF1bHRDbG9zZUJ1dHRvblByb3BzID0ge1xuICAgICAgICBjbGFzczogXCJpcy1hYnNvbHV0ZSBpcy1zaWRlZC1yaWdodCBpcy1zaWRlZC10b3BcIixcbiAgICAgICAgc3R5bGU6IFwiLS1zaWRpbmctcmlnaHQtc2l6ZTogMnJlbTsgLS1zaWRpbmctdG9wLXNpemU6IDJyZW1cIixcbiAgICAgICAgc2l6ZTogXCJub3JtYWxcIixcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbY2xvc2VCdXR0b24gPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gICBbY2xvc2VCdXR0b25Qcm9wcyA9IGRlZmF1bHRDbG9zZUJ1dHRvblByb3BzXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gIFtzaG93ID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICBbY2xvc2VPbkNsaWNrID0gdHJ1ZV1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gICBbbGF5ZXIgPSAxXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9ICAgW3pJbmRleFN0ZXAgPSAxMDAwXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgIFtyb2xlID0gJ2J1dHRvbiddXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9ICAgW3RhYkluZGV4ID0gJ2J1dHRvbiddXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY2xvc2VCdXR0b24gPSBmYWxzZSxcbiAgICAgICAgY2xvc2VCdXR0b25Qcm9wcyA9IGRlZmF1bHRDbG9zZUJ1dHRvblByb3BzLFxuICAgICAgICBzaG93ID0gdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrID0gdHJ1ZSxcbiAgICAgICAgbGF5ZXIgPSAxLFxuICAgICAgICBjbGFzczogY2xhc3NlcyA9IFwiXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBvbnJlamVjdCA9ICgpID0+IGZhbHNlLFxuICAgICAgICB6SW5kZXhTdGVwID0gMTAwMCxcbiAgICAgICAgcm9sZSA9IFwiYnV0dG9uXCIsXG4gICAgICAgIHRhYkluZGV4ID0gXCIwXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb3ZlcmxheUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKGNsb3NlT25DbGljaykge1xuICAgICAgICAgICAgY2xvc2VPdmVybGF5KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VCdXR0b25DbGljaygpIHtcbiAgICAgICAgcmVqZWN0T3ZlcmxheSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlT3ZlcmxheShlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLm9yaWdpbmFsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS5vcmlnaW5hbFRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImlzLW92ZXJsYXlcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0T3ZlcmxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3RPdmVybGF5KGRhdGEgPSB7fSkge1xuICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgICAgIG9ucmVqZWN0KGRhdGEpO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBvdmVyZmxvd1NhdmUgPSBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3dTYXZlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3dTYXZlO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjaWYgc2hvd31cbiAgICA8ZGl2XG4gICAgICAgIHRyYW5zaXRpb246ZmFkZVxuICAgICAgICBjbGFzcz1cImlzLW92ZXJsYXkgbm90LW92ZXJsYXkge2NsYXNzZXN9XCJcbiAgICAgICAgb25jbGljaz17b3ZlcmxheUNsaWNrfVxuICAgICAgICBvbmtleXVwPXtvdmVybGF5Q2xpY2t9XG4gICAgICAgIHtyb2xlfVxuICAgICAgICB7dGFiSW5kZXh9XG4gICAgICAgIHN0eWxlPVwiei1pbmRleDoge3pJbmRleFN0ZXAgKiBsYXllcn07XCJcbiAgICA+XG4gICAgICAgIHsjaWYgY2xvc2VCdXR0b259XG4gICAgICAgICAgICA8VUlCdXR0b25DbG9zZSB7Li4uY2xvc2VCdXR0b25Qcm9wc30gb25jbGljaz17Y2xvc2VCdXR0b25DbGlja30gLz5cbiAgICAgICAgey9pZn1cbiAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJT3ZlcmxheSBmcm9tIFwiLi91aS5vdmVybGF5LnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFVJQm94IGZyb20gXCIuLi9ibG9jay91aS5ib3guc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29udGVudCBmcm9tIFwiLi4vYmxvY2svdWkuY29udGVudC5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVRpdGxlIGZyb20gXCIuLi92YXJpb3VzL3VpLnRpdGxlLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJ1dHRvbnNSb3cgZnJvbSBcIi4uL2J1dHRvbi91aS5idXR0b25zLnJvdy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBVSUxvYWRlciB9IGZyb20gXCIuLi92YXJpb3VzXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYnV0dG9uc1Bvc2l0aW9uID0gXCJib3R0b21cIl0gICAgICAgICAgIHRvcCwgdG9wT2ZDb250ZW50LCBib3R0b21cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmdWxsc2NyZWVuID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2xvc2VCdXR0b24gPSBmYWxzZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcHBseUJ1dHRvbiA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGl0bGVTaXplID0gMl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93ID0gZmFsc2VdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZGluZyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGU9IFwiTW9kYWwgd2luZG93XCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdWJ0aXRsZSA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzcyA9IFwiXCJdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtvdmVybGF5Q2xhc3MgPSBcIlwiXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYnV0dG9uc0NsYXNzID0gXCJcIl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW1dBSVRJTkdfVEVYVCA9IFwi0J7QsdGA0LDQsdC+0YLQutCwXCJdXG4gICAgICogQHByb3BlcnR5IHtpbXBvcnQoJ3N2ZWx0ZScpLlNuaXBwZXR9IFtjaGlsZHJlbl1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgYnV0dG9uc1Bvc2l0aW9uID0gXCJib3R0b21cIixcbiAgICAgICAgZnVsbHNjcmVlbiA9IGZhbHNlLFxuICAgICAgICBjbG9zZUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICBhcHBseUJ1dHRvbiA9IGZhbHNlLFxuICAgICAgICB0aXRsZVNpemUgPSAyLFxuICAgICAgICBzaG93ID0gZmFsc2UsXG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgdGl0bGUgPSBcIk1vZGFsIHdpbmRvd1wiLFxuICAgICAgICBzdWJ0aXRsZSA9IFwiXCIsXG4gICAgICAgIGNsYXNzOiBjbGFzc2VzID0gXCJcIixcbiAgICAgICAgb3ZlcmxheUNsYXNzOiBvdmVybGF5Q2xhc3MgPSBcIlwiLFxuICAgICAgICBidXR0b25zQ2xhc3M6IGJ1dHRvbnNDbGFzcyA9IFwiXCIsXG4gICAgICAgIFdBSVRJTkdfVEVYVCA9IFwi0J7QsdGA0LDQsdC+0YLQutCwXCIsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I3NuaXBwZXQgYnV0dG9ucyhtb3JlQ2xhc3Nlc3MgPSBcIlwiKX1cbiAgICA8VUlCdXR0b25zUm93XG4gICAgICAgIGNsYXNzPXtidXR0b25zQ2xhc3MgfHwgbW9yZUNsYXNzZXNzfVxuICAgICAgICBsZWZ0PXtjbG9zZUJ1dHRvbiA/IFtjbG9zZUJ1dHRvbl0gOiBbXX1cbiAgICAgICAgcmlnaHQ9e2FwcGx5QnV0dG9uID8gW2FwcGx5QnV0dG9uXSA6IFtdfVxuICAgIC8+XG57L3NuaXBwZXR9XG5cbjxVSU92ZXJsYXkge3Nob3d9IGNsb3NlT25DbGljaz17ZmFsc2V9IGNsb3NlQnV0dG9uPXtmYWxzZX0gY2xhc3M9e292ZXJsYXlDbGFzc30+XG4gICAgPFVJQm94IGNsYXNzPXtgJHtjbGFzc2VzfSAke2Z1bGxzY3JlZW4gPyBcImlzLWZ1bGxzY3JlZW5cIiA6IFwiXCJ9YH0+XG4gICAgICAgIHsjaWYgYnV0dG9uc1Bvc2l0aW9uID09PSBcInRvcFwifVxuICAgICAgICAgICAge0ByZW5kZXIgYnV0dG9ucyhcIlwiKX1cbiAgICAgICAgey9pZn1cbiAgICAgICAgPFVJVGl0bGUgc2l6ZT17dGl0bGVTaXplfSB7dGl0bGV9IHtzdWJ0aXRsZX0gLz5cbiAgICAgICAgPFVJQ29udGVudD5cbiAgICAgICAgICAgIDxVSUxvYWRlciBzaXplPVwicGFnZVwiIHtsb2FkaW5nfSB0aXRsZT17V0FJVElOR19URVhUfSAvPlxuXG4gICAgICAgICAgICB7I2lmIGJ1dHRvbnNQb3NpdGlvbiA9PT0gXCJ0b3BPZkNvbnRlbnRcIn1cbiAgICAgICAgICAgICAgICB7QHJlbmRlciBidXR0b25zKFwiXCIpfVxuICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAge0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXG4gICAgICAgICAgICB7I2lmIGJ1dHRvbnNQb3NpdGlvbiA9PT0gXCJib3R0b21cIn1cbiAgICAgICAgICAgICAgICB7QHJlbmRlciBidXR0b25zKGBpcy1tb2JpbGUgJHtmdWxsc2NyZWVuID8gXCJpcy1mb290ZXJcIiA6IFwiXCJ9YCl9XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L1VJQ29udGVudD5cbiAgICA8L1VJQm94PlxuPC9VSU92ZXJsYXk+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlCdXR0b25zIGZyb20gXCIuLi9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlPdmVybGF5IGZyb20gXCIuL3VpLm92ZXJsYXkuc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgeyBVSUVuZGxlc3NMaXN0IH0gZnJvbSBcIi4uL2xpc3QvZW5kbGVzc1wiO1xuICAgIGltcG9ydCBVSVNpbXBsZVNlYXJjaElucHV0IGZyb20gXCIuLi92YXJpb3VzL3VpLnNpbXBsZS5zZWFyY2guaW5wdXQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVUlCb3gsIFVJQmxvY2sgfSBmcm9tIFwiLi4vYmxvY2tcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmICAgICB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSAgICB7Ym9vbGVhbn0gICBbc2hvd11cbiAgICAgKiBAcHJvcGVydHkgICAge2Jvb2xlYW59ICAgW3Nob3dTZWFyY2ggPSB0cnVlXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7c3RyaW5nfSAgICBbdGVybV1cbiAgICAgKiBAcHJvcGVydHkgICAgeyhmdWxsc2NyZWVufHdpZGV8bm9ybWFsfG5hcnJvdyl9IFtzaXplXSAgIDEwMHZ3LCA3NXZ3LCA1MHZ3LCAyNXZ3XG4gICAgICogQHByb3BlcnR5ICAgIHthbnl9ICAgICAgIFtpbnB1dENvbXBvbmVudF1cbiAgICAgKiBAcHJvcGVydHkgICAge29iamVjdH0gICAgW2lucHV0Q29tcG9uZW50UHJvcHNdXG4gICAgICogQHByb3BlcnR5ICAgIHthbnl9ICAgICAgIFtvdXRwdXRDb21wb25lbnRdXG4gICAgICogQHByb3BlcnR5ICAgIHtvYmplY3R9ICAgIFtvdXRwdXRDb21wb25lbnRQcm9wc11cbiAgICAgKiBAcHJvcGVydHkgICAge29iamVjdH0gICAgW2J1dHRvbnNQcm9wcyA9IHsgY2VudGVyZWQ6IHRydWUsIGNsYXNzOiBcIm10LTVcIix9XVxuICAgICAqIEBwcm9wZXJ0eSAgICB7b2JqZWN0fSAgICBbcmVzdWx0c11cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29ucHJldl1cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29ubmV4dF1cbiAgICAgKiBAcHJvcGVydHkgICAge2Z1bmN0aW9ufSAgW29uY2hhbmdlXVxuICAgICAqIEBwcm9wZXJ0eSAgICB7ZnVuY3Rpb259ICBbb25yZWplY3RdXG4gICAgICogQHByb3BlcnR5ICAgIHtmdW5jdGlvbn0gIFtvbnJlc29sdmVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHNob3cgPSB0cnVlLFxuICAgICAgICBzaG93U2VhcmNoID0gdHJ1ZSxcbiAgICAgICAgdGVybSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgc2l6ZSA9IFwibmFycm93XCIsXG4gICAgICAgIGlucHV0Q29tcG9uZW50OiBVSUlucHV0Q29tcG9uZW50ID0gVUlTaW1wbGVTZWFyY2hJbnB1dCxcbiAgICAgICAgaW5wdXRDb21wb25lbnRQcm9wcyA9IHt9LFxuICAgICAgICBvdXRwdXRDb21wb25lbnQ6IFVJT3V0cHV0Q29tcG9uZW50ID0gVUlFbmRsZXNzTGlzdCxcbiAgICAgICAgb3V0cHV0Q29tcG9uZW50UHJvcHMgPSB7fSxcbiAgICAgICAgYnV0dG9uc1Byb3BzID0ge1xuICAgICAgICAgICAgY2VudGVyZWQ6IHRydWUsXG4gICAgICAgICAgICBjbGFzczogXCJtdC01XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdEJ1dHRvblByb3BzID0ge30sXG4gICAgICAgIHJlc3VsdHMgPSAkYmluZGFibGUoeyBsaXN0OiBbXSwgcGFnZTogMCwgcGFnZXM6IDAsIHNraXA6IDAsIGNvdW50OiAwIH0pLFxuICAgICAgICBvbmNoYW5nZSxcbiAgICAgICAgb25wcmV2LFxuICAgICAgICBvbm5leHQsXG4gICAgICAgIG9ucmVzb2x2ZSxcbiAgICAgICAgb25yZWplY3QsXG4gICAgICAgIGl0ZW1SZW5kZXJlcixcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0aXRsZTogJExPQ0FMRVtcIm5vdC1ub2RlOmJ1dHRvbl9jYW5jZWxfbGFiZWxcIl0sXG4gICAgICAgICAgICBhY3Rpb246IG9ucmVqZWN0LFxuICAgICAgICAgICAgLi4ucmVqZWN0QnV0dG9uUHJvcHMsXG4gICAgICAgIH0sXG4gICAgXTtcbjwvc2NyaXB0PlxuXG48VUlPdmVybGF5IHtvbnJlamVjdH0ge3Nob3d9IGNsb3NlT25DbGljaz17dHJ1ZX0gY2xvc2VCdXR0b249e2ZhbHNlfT5cbiAgICA8VUlCb3ggY2xhc3M9XCJtb2RhbC1zZWxlY3RvciB7c2l6ZX1cIj5cbiAgICAgICAgeyNpZiBzaG93U2VhcmNofVxuICAgICAgICAgICAgPFVJSW5wdXRDb21wb25lbnQge29uY2hhbmdlfSBiaW5kOnRlcm0gey4uLmlucHV0Q29tcG9uZW50UHJvcHN9IC8+XG4gICAgICAgIHsvaWZ9XG5cbiAgICAgICAgPFVJT3V0cHV0Q29tcG9uZW50XG4gICAgICAgICAgICBiaW5kOmRhdGE9e3Jlc3VsdHN9XG4gICAgICAgICAgICB7b25wcmV2fVxuICAgICAgICAgICAge29ubmV4dH1cbiAgICAgICAgICAgIG9uc2VsZWN0PXtvbnJlc29sdmV9XG4gICAgICAgICAgICBjbGFzcz1cImhhcy1oZWlnaHQtdXAtdG8tNjAgb3ZlcmZsb3ctc2Nyb2xsXCJcbiAgICAgICAgICAgIHsuLi5vdXRwdXRDb21wb25lbnRQcm9wc31cbiAgICAgICAgICAgIHtpdGVtUmVuZGVyZXJ9XG4gICAgICAgIC8+XG5cbiAgICAgICAgPFVJQnV0dG9ucyB7Li4uYnV0dG9uc1Byb3BzfSB2YWx1ZXM9e2J1dHRvbnN9IC8+XG4gICAgPC9VSUJveD5cbjwvVUlPdmVybGF5PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBMT0NBTEUgfSBmcm9tIFwiLi4vLi4vbG9jYWxlXCI7XG5cbiAgICBsZXQge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgdGl0bGVTbmlwLFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBtZXNzYWdlU25pcCxcbiAgICAgICAgY2xhc3M6IGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBjb2xvcixcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGFydGljbGUgY2xhc3M9XCJtZXNzYWdlIHtjbGFzc2VzfSB7Y29sb3IgPyBgaXMtJHtjb2xvcn1gIDogJyd9XCI+XG4gICAgPGRpdiBjbGFzcz1cIm1lc3NhZ2UtaGVhZGVyXCI+XG4gICAgICAgIHsjaWYgdGl0bGVTbmlwfVxuICAgICAgICAgICAge0ByZW5kZXIgdGl0bGVTbmlwKHRpdGxlKX1cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHA+eyRMT0NBTEVbdGl0bGVdfTwvcD5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1ib2R5XCI+XG4gICAgICAgIHsjaWYgbWVzc2FnZVNuaXB9XG4gICAgICAgICAgICB7QHJlbmRlciBtZXNzYWdlU25pcChtZXNzYWdlKX1cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHA+eyRMT0NBTEVbbWVzc2FnZV19PC9wPlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuPC9hcnRpY2xlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlNZXNzYWdlIGZyb20gXCIuL3VpLm1lc3NhZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gVUlDb21tb24uQ0xBU1NfRVJSLCAuLi5wcm9wcyB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPFVJTWVzc2FnZSB7Li4ucHJvcHN9IGNsYXNzPXtjbGFzc2VzfSAvPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlNZXNzYWdlIGZyb20gXCIuL3VpLm1lc3NhZ2Uuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuICAgIGxldCB7IGNsYXNzOiBjbGFzc2VzID0gVUlDb21tb24uQ0xBU1NfT0ssIC4uLnByb3BzIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG48VUlNZXNzYWdlIHsuLi5wcm9wc30gY2xhc3M9e2NsYXNzZXN9IC8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgVUlCdXR0b24gfSBmcm9tIFwiLi4vYnV0dG9uXCI7XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uL2xvY2FsZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvdyA9IGZhbHNlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWVzc2FnZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2FncmVlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBzaG93ID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbWVzc2FnZSA9IFwi0JTQu9GPINGD0LvRg9GH0YjQtdC90LjRjyDRgNCw0LHQvtGC0Ysg0YHQsNC50YLQsCDQuCDQtdCz0L4g0LLQt9Cw0LjQvNC+0LTQtdC50YHRgtCy0LjRjyDRgSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y/QvNC4INC80Ysg0LjRgdC/0L7Qu9GM0LfRg9C10Lwg0YTQsNC50LvRiyBjb29raWUuINCf0YDQvtC00L7Qu9C20LDRjyDRgNCw0LHQvtGC0YMg0YEg0YHQsNC50YLQvtC8LCDQktGLINGA0LDQt9GA0LXRiNCw0LXRgtC1INC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC1IGNvb2tpZS3RhNCw0LnQu9C+0LIuINCS0Ysg0LLRgdC10LPQtNCwINC80L7QttC10YLQtSDQvtGC0LrQu9GO0YfQuNGC0Ywg0YTQsNC50LvRiyBjb29raWUg0LIg0L3QsNGB0YLRgNC+0LnQutCw0YUg0JLQsNGI0LXQs9C+INCx0YDQsNGD0LfQtdGA0LAuXCIsXG4gICAgICAgIGFncmVlID0gXCLQpdC+0YDQvtGI0L5cIixcbiAgICAgICAgY29vbGRvd24gPSAzMTUzNjAwMDAwMCxcbiAgICAgICAgbHNLZXkgPSBcImNvb2tpZV9kYXRlXCIsXG4gICAgICAgIGlkID0gXCJjb29raWVfbm90aWZpY2F0aW9uXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGxldCBjb29raWVEYXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obHNLZXkpO1xuICAgICAgICBpZiAoIWNvb2tpZURhdGUgfHwgK2Nvb2tpZURhdGUgKyBjb29sZG93biA8IERhdGUubm93KCkpIHtcbiAgICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhY2NlcHQoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxzS2V5LCBEYXRlLm5vdygpKTtcbiAgICAgICAgc2hvdyA9IGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHNob3d9XG4gICAgPGRpdiB7aWR9PlxuICAgICAgICA8cD57JExPQ0FMRVttZXNzYWdlXX08L3A+XG4gICAgICAgIDxVSUJ1dHRvbiBvbmNsaWNrPXthY2NlcHR9IGNvbG9yPVwic3VjY2Vzc1wiIGNsYXNzPVwiY29va2llX2FjY2VwdFwiXG4gICAgICAgICAgICA+eyRMT0NBTEVbYWdyZWVdfTwvVUlCdXR0b25cbiAgICAgICAgPlxuICAgIDwvZGl2Plxuey9pZn1cbiIsIi8vYmxvY2sgZWxlbWVudHNcbmltcG9ydCAqIGFzIEJsb2NrcyBmcm9tIFwiLi9ibG9ja1wiO1xuZXhwb3J0IHsgQmxvY2tzIH07XG5cbi8vZ2VuZXJhbCBlbGVtZW50c1xuaW1wb3J0ICogYXMgVmFyaW91cyBmcm9tIFwiLi92YXJpb3VzXCI7XG5leHBvcnQgeyBWYXJpb3VzIH07XG5cbi8vXG5pbXBvcnQgKiBhcyBCdXR0b25zIGZyb20gXCIuL2J1dHRvblwiO1xuZXhwb3J0IHsgQnV0dG9ucyB9O1xuXG4vL2Zvcm0gZWxlbWVudHNcbmltcG9ydCAqIGFzIEZvcm1zIGZyb20gXCIuL2Zvcm1cIjtcbmV4cG9ydCB7IEZvcm1zIH07XG5cbi8vaWNvbnMgdmFyaWFudHNcbmltcG9ydCAqIGFzIEljb25zIGZyb20gXCIuL2ljb25cIjtcbmV4cG9ydCB7IEljb25zIH07XG5cbi8vaW1hZ2VzIHVpXG5pbXBvcnQgKiBhcyBJbWFnZXMgZnJvbSBcIi4vaW1hZ2VcIjtcbmV4cG9ydCB7IEltYWdlcyB9O1xuXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4vaW5wdXRcIjtcbmV4cG9ydCB7IElucHV0cyB9O1xuXG5pbXBvcnQgKiBhcyBMYXlvdXRzIGZyb20gXCIuL2xheW91dFwiO1xuZXhwb3J0IHsgTGF5b3V0cyB9O1xuXG5pbXBvcnQgKiBhcyBMaW5rcyBmcm9tIFwiLi9saW5rXCI7XG5leHBvcnQgeyBMaW5rcyB9O1xuXG5pbXBvcnQgKiBhcyBMaXN0cyBmcm9tIFwiLi9saXN0XCI7XG5leHBvcnQgeyBMaXN0cyB9O1xuXG5pbXBvcnQgKiBhcyBNb2RhbHMgZnJvbSBcIi4vbW9kYWxcIjtcbmV4cG9ydCB7IE1vZGFscyB9O1xuXG5pbXBvcnQgKiBhcyBOb3RpZmljYXRpb25zIGZyb20gXCIuL25vdGlmaWNhdGlvblwiO1xuZXhwb3J0IHsgTm90aWZpY2F0aW9ucyB9O1xuXG5pbXBvcnQgVUlDb21tb24gZnJvbSBcIi4vY29tbW9uXCI7XG5leHBvcnQgeyBVSUNvbW1vbiB9O1xuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwid29sZnk4Ny1ldmVudGVtaXR0ZXJcIjtcbmltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG5jb25zdCBNRVRBX01FVEhPRF9JTklUID0gU3ltYm9sKFwiaW5pdFwiKSxcbiAgICBNRVRBX0RBVEEgPSBTeW1ib2woXCJkYXRhXCIpLFxuICAgIE1FVEFfV09SS0lORyA9IFN5bWJvbChcIndvcmtpbmdcIiksXG4gICAgTUVUQV9PUFRJT05TID0gU3ltYm9sKFwib3B0aW9uc1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3Mgbm90QmFzZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpc1tNRVRBX0RBVEFdID0ge307XG4gICAgICAgIHRoaXNbTUVUQV9XT1JLSU5HXSA9IHt9O1xuICAgICAgICB0aGlzW01FVEFfT1BUSU9OU10gPSB7fTtcbiAgICAgICAgdGhpc1tNRVRBX01FVEhPRF9JTklUXShpbnB1dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFtNRVRBX01FVEhPRF9JTklUXShpbnB1dCkge1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpbnB1dCwgXCJkYXRhXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGlucHV0LCBcIndvcmtpbmdcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhpbnB1dC53b3JraW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaW5wdXQsIFwib3B0aW9uc1wiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKGlucHV0Lm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2cgPSBub3RDb21tb24uZ2VuTG9nTXNnKHRoaXMuZ2V0V29ya2luZyhcIm5hbWVcIikpO1xuICAgICAgICB0aGlzLmluZm8gPSB0aGlzLmxvZztcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG5vdENvbW1vbi5nZW5Mb2dEZWJ1Zyh0aGlzLmdldFdvcmtpbmcoXCJuYW1lXCIpKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG5vdENvbW1vbi5nZW5Mb2dFcnJvcih0aGlzLmdldFdvcmtpbmcoXCJuYW1lXCIpKTtcbiAgICB9XG5cbiAgICBzZXRDb21tb24od2hhdCwgYXJncykge1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAvKiBzZXQgY29sbGVjdGlvbiAqL1xuICAgICAgICAgICAgICAgIHdoYXQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgLyogc2V0IGNvbGxlY3Rpb24gZWxlbWVudCAqL1xuICAgICAgICAgICAgICAgIG5vdFBhdGguc2V0KFxuICAgICAgICAgICAgICAgICAgICBhcmdzWzBdIC8qIHBhdGggKi8sXG4gICAgICAgICAgICAgICAgICAgIHdoYXQgLyogY29sbGVjdGlvbiAqLyxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIC8qIGhlbHBlcnMgKi8sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbMV0gLyogdmFsdWUgKi9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRDb21tb24od2hhdCwgYXJncykge1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvKiBpZiB3ZSB3YW50IGdldCBkYXRhIGJ5IHBhdGggKi9cbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RQYXRoLmdldChhcmdzWzBdLCB3aGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlmIHdlIHdhbnQgZ2V0IGRhdGEgYnkgcGF0aCB3aXRoIGRlZmF1bHQgdmFsdWUgKi9cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIGxldCByZXMgPSBub3RQYXRoLmdldChhcmdzWzBdLCB3aGF0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogbm8gZGF0YSwgcmV0dXJuIGRlZmF1bHQgdmFsdWUgKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogZGF0YSwgcmV0dXJuIGl0ICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogcmV0dXJuIGZ1bGwgY29sbGVjdGlvbiAqL1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aGF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICBDT1JFIE9CSkVDVFxuICAgICAgREFUQSAtIGluZm9ybWF0aW9uXG4gICAgICBPUFRJT05TIC0gaG93IHRvIHdvcmtcbiAgICAgIFdPUktJTkcgLSB0ZW1wb3JhcmlseSBnZW5lcmF0ZWQgaW4gcHJvY2Nlc3NcbiAgKi9cblxuICAgIHNldERhdGEoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzW01FVEFfREFUQV0gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbW1vbih0aGlzLmdldERhdGEoKSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbW1vbih0aGlzW01FVEFfREFUQV0sIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgc2V0T3B0aW9ucygpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbTUVUQV9PUFRJT05TXSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29tbW9uKHRoaXMuZ2V0T3B0aW9ucygpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbW1vbih0aGlzW01FVEFfT1BUSU9OU10sIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgc2V0V29ya2luZygpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXNbTUVUQV9XT1JLSU5HXSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29tbW9uKHRoaXMuZ2V0V29ya2luZygpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFdvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbW1vbih0aGlzW01FVEFfV09SS0lOR10sIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmVwb3J0KGUpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5yZXBvcnQpIHtcbiAgICAgICAgICAgIG5vdENvbW1vbi5yZXBvcnQoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRBcHAoKSB7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uZ2V0QXBwKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudCgpO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKG51bGwpO1xuICAgICAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgIH1cbn1cbiIsImltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcblxuaW1wb3J0IHsgTkFWSUdBVElPTl9ERUxBWVMsIE5BVklHQVRJT05fREVMQVlfREVGQVVMVCB9IGZyb20gXCIuL2NvbnN0LmpzXCI7XG5cbmNvbnN0IE9QVF9NT0RFX0hJU1RPUlkgPSBTeW1ib2woXCJoaXN0b3J5XCIpLFxuICAgIE9QVF9NT0RFX0hBU0ggPSBTeW1ib2woXCJoYXNoXCIpLFxuICAgIE9QVF9ERUZBVUxUX0NIRUNLX0lOVEVSVkFMID0gNTA7XG5cbmNsYXNzIG5vdFJvdXRlciBleHRlbmRzIG5vdEJhc2Uge1xuICAgIGhvc3QgPSBcIlwiO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgcm91dGVzOiBbXSxcbiAgICAgICAgICAgICAgICBtb2RlOiBPUFRfTU9ERV9ISVNUT1JZLFxuICAgICAgICAgICAgICAgIHJvb3Q6IFwiL1wiLCAvL2Fsd2F5cyBpbiBzbGFzaGVzIC91c2VyLywgLywgL2lucHV0Ly4gYW5kIG5vIC91c2VyIG9yIGlucHV0L2xldmVsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlbGF5czogTkFWSUdBVElPTl9ERUxBWVMsXG4gICAgICAgICAgICAgICAgZGVsYXlfZGVmYXVsdDogTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBvYmplY3Qgd2l0aCBuYW1lZCBkZWxheXNcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZWxheXNcbiAgICAgKiBAcmV0dXJucyB7bm90Um91dGVyfVxuICAgICAqL1xuICAgIHNldERlbGF5cyhkZWxheXMpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiZGVsYXlzXCIsIGRlbGF5cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IG5hdmlnYXRpb24gZGVsYXksIHByb3ZpZGVkIGFzIG5hbWUgb2Ygb25lIG9mIGBkZWxheXNgIG9yIGluIG51bWJlciBmb3JtXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBkZWxheVxuICAgICAqIEByZXR1cm5zIHtub3RSb3V0ZXJ9XG4gICAgICovXG4gICAgc2V0RGVmYXVsdE5hdmlnYXRpb25EZWxheShkZWxheSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJkZWxheV9kZWZhdWx0XCIsIHRoaXMuZGVsYXlBc01zKGRlbGF5KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIG9mIG1zLCBpZiBub3Qgc2V0IHJldHVybnMgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0TmF2aWdhdGlvbkRlbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKGBkZWxheV9kZWZhdWx0YCwgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgRW5zdXJlcyB0aGF0IGRlbGF5IGlzIGluIG1zLCBpZiBpdHMgcHJvdmlkZWQgYXMgbmFtZSBvZiBhbGlhcywgc2VhcmNoZXMgZm9yIGl0IGFuZCByZXR1cm5zLCBpZiBub3QgZm91bmQgLSByZXR1cm5zIHdvcmtpbmcgZGVmYXVsdF9kZWxheVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gZGVsYXkgICAgbmFtZSBvZiBkZWxheSBhbGlhcyBvciBudW1iZXIgb2YgbXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAgICAgICAgICAgICAgIGRlbGF5IGluIG1zXG4gICAgICovXG4gICAgZGVsYXlBc01zKGRlbGF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsYXkgPT09IFwic3RyaW5nXCIgJiYgZGVsYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXG4gICAgICAgICAgICAgICAgICAgIGBkZWxheXMuJHtkZWxheX1gLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgdXJsICAgICB3ZSBnbyB0byB1cmxcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSAgICAgICBkZWxheSAgIG5hbWUgb2YgZGVsYXkgYWxpYXMgb3IgbnVtYmVyIG9mIG1zXG4gICAgICogIEByZXR1cm5zIHtOb2RlSlMuVGltZW91dH0gICAgICAgICAgICB0aW1lb3V0IGlkZW50aWZpY2F0b3JcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZVdpdGhEZWxheSh1cmwsIGRlbGF5LCBkb0JlZm9yZSkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0eXBlb2YgZG9CZWZvcmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkb0JlZm9yZSgpO1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZSh1cmwpO1xuICAgICAgICB9LCB0aGlzLmRlbGF5QXNNcyhkZWxheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZSBicm93c2VyIEhpc3RvcnkgQVBJXG4gICAgICovXG4gICAgaGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwibW9kZVwiLCBPUFRfTU9ERV9ISVNUT1JZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgaGFzaCBwYXJ0IGFzIGNvbnRhaW5lciBmb3IgbG9jYXRpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBoYXNoKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlXCIsIE9QVF9NT0RFX0hBU0gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvb3Qgc2hvdWxkIHN0YXJ0IGFuZCBlbmQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb290XG4gICAgICogQHJldHVybnMge25vdFJvdXRlcn1cbiAgICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgXCJyb290XCIsXG4gICAgICAgICAgICByb290ICYmIHJvb3QgIT09IFwiL1wiID8gXCIvXCIgKyB0aGlzLmNsZWFyU2xhc2hlcyhyb290KSArIFwiL1wiIDogXCIvXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xlYXIgZmlyc3QgYW5kIGxhc3Qgc2xhc2hlcyBmcm9tIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBjbGVhclNsYXNoZXMocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC50b1N0cmluZygpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuXG4gICAgYWRkKHJlLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gcmU7XG4gICAgICAgICAgICByZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bGUgPSB7XG4gICAgICAgICAgICByZTogcmUsXG4gICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikucHVzaChydWxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgYWRkTGlzdChsaXN0KSB7XG4gICAgICAgIGZvciAobGV0IHQgaW4gbGlzdCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodCwgbGlzdFt0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVtb3ZlKHBhcmFtKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgaSA9IDAsIHI7XG4gICAgICAgICAgICBpIDwgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpLmxlbmd0aCxcbiAgICAgICAgICAgIChyID0gdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpW2ldKTtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChyLmhhbmRsZXIgPT09IHBhcmFtIHx8IHIucmUgPT09IHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVzXCIpLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKHtcbiAgICAgICAgICAgIHJvdXRlczogW10sXG4gICAgICAgICAgICBtb2RlOiBPUFRfTU9ERV9ISVNUT1JZLFxuICAgICAgICAgICAgcm9vdDogXCIvXCIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwiaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuXG4gICAgc2V0SW5pdGlhbGl6ZWQodmFsID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRXb3JraW5nKFwiaW5pdGlhbGl6ZWRcIiwgdmFsKTtcbiAgICB9XG5cbiAgICBnZXRGcmFnbWVudCgpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIikgPT09IE9QVF9NT0RFX0hJU1RPUlkpIHtcbiAgICAgICAgICAgIGlmICghbG9jYXRpb24pIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmNsZWFyU2xhc2hlcyhcbiAgICAgICAgICAgICAgICBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2gpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlKC9cXD8oLiopJC8sIFwiXCIpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ya2luZyhcInJvb3RcIikgIT0gXCIvXCJcbiAgICAgICAgICAgICAgICAgICAgPyBmcmFnbWVudC5yZXBsYWNlKHRoaXMuZ2V0V29ya2luZyhcInJvb3RcIiksIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIDogZnJhZ21lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdykgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyU2xhc2hlcyhmcmFnbWVudCk7XG4gICAgfVxuXG4gICAgY2hlY2tMb2NhdGlvbigpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldFdvcmtpbmcoXCJjdXJyZW50XCIpLFxuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KCksXG4gICAgICAgICAgICBpbml0ID0gdGhpcy5pc0luaXRpYWxpemVkKCk7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBmcmFnbWVudCB8fCAhaW5pdCkge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiY3VycmVudFwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBocmVmQ2xpY2soKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBnZXRSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKTtcbiAgICB9XG5cbiAgICBsaXN0ZW4obG9vcEludGVydmFsID0gT1BUX0RFRkFVTFRfQ0hFQ0tfSU5URVJWQUwpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiY3VycmVudFwiLCBcIm5vdEluaXRpYWxpemVkXCIpO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuZ2V0V29ya2luZyhcImludGVydmFsXCIpKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFxuICAgICAgICAgICAgXCJpbnRlcnZhbFwiLFxuICAgICAgICAgICAgc2V0SW50ZXJ2YWwodGhpcy5jaGVja0xvY2F0aW9uLmJpbmQodGhpcyksIGxvb3BJbnRlcnZhbClcbiAgICAgICAgKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLmhyZWZDbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2hlY2soZikge1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSBmIHx8IHRoaXMuZ2V0RnJhZ21lbnQoKSxcbiAgICAgICAgICAgIGZhaWxCYWNrID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIikubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXRoID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKSArIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKVtpXS5yZSxcbiAgICAgICAgICAgICAgICBmdWxsUkUgPSB0aGlzLmNsZWFyU2xhc2hlcyhkZWNvZGVVUkkocGF0aCkpLFxuICAgICAgICAgICAgICAgIG1hdGNoID0gZnJhZ21lbnQubWF0Y2goZnVsbFJFKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbFJFID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxCYWNrID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlc1wiKVtpXS5oYW5kbGVyLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0IHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJSb3V0ZVwiLCB0aGlzLmdldFdvcmtpbmcoXCJyb3V0ZXNcIilbaV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhaWxCYWNrKSB7XG4gICAgICAgICAgICBmYWlsQmFjay5yb3V0ZS5oYW5kbGVyLmFwcGx5KHRoaXMuaG9zdCB8fCB7fSwgZmFpbEJhY2subWF0Y2gpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJSb3V0ZVwiLCBmYWlsQmFjay5yb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJlZnJlc2hlcyBwYWdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgdGltZSB0byB3YWl0IGluIG1zXG4gICAgICovXG4gICAgcmVmcmVzaCh0aW1lb3V0ID0gMCkge1xuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWZyZXNoKCksIHRpbWVvdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVjayh0aGlzLmdldFdvcmtpbmcoXCJjdXJyZW50XCIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgbG9jYXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIG5hdmlnYXRlKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHBhdGggPyBwYXRoIDogXCJcIjtcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldFdvcmtpbmcoXCJtb2RlXCIpKSB7XG4gICAgICAgICAgICBjYXNlIE9QVF9NT0RFX0hJU1RPUlk6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdSb3V0ZSA9IHRoaXMuZ2V0RnVsbFJvdXRlKHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdSb3V0ZSA9PT0gdGhpcy5sYXN0Um91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Um91dGUgPSBuZXdSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgXCJcIiwgdGhpcy5sYXN0Um91dGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BUX01PREVfSEFTSDoge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLm1hdGNoKC8jKC4qKSQvKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMoLiopJC8sIFwiXCIpICsgXCIjXCIgKyBwYXRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICByZXR1cm5zIGFwcCByb290ICsgcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRGdWxsUm91dGUocGF0aCA9IFwiXCIpIHtcbiAgICAgICAgcGF0aCA9IHRoaXMuY2xlYXJTbGFzaGVzKHBhdGgpO1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy5nZXRXb3JraW5nKFwicm9vdFwiKTtcbiAgICAgICAgaWYgKHJvb3QgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKHJvb3Quc3Vic3RyaW5nKDEpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIiArIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInJvb3RcIikgKyB0aGlzLmNsZWFyU2xhc2hlcyhwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBsaW5rcyB3aXRoIG4taHJlZiBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8SFRNTEFuY2hvckVsZW1lbnQ+fVxuICAgICAqL1xuICAgIGdldEFsbExpbmtzKCkge1xuICAgICAgICBjb25zdCBhbGxFbGVtZW50cyA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbChcImFcIik7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwLCBhdHRzID0gYWxsRWxlbWVudHNbal0uYXR0cmlidXRlcywgbiA9IGF0dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGkgPCBuO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHNbaV0ubm9kZU5hbWUuaW5kZXhPZihcIm4taHJlZlwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goYWxsRWxlbWVudHNbal0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVyb3V0ZSBhbGwgbGlua3MoYW5jaG9yIHRhZ3MpIHdpdGggbi1ocmVmIGF0dHJpYnV0ZS5cbiAgICAgKiBEaXNhYmxlIG5hdmlnYXRpb24gdG8gaHJlZi5cbiAgICAgKiBAcmV0dXJucyB7bm90Um91dGVyfVxuICAgICAqL1xuICAgIHJlUm91dGVFeGlzdGVkKCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5nZXRBbGxMaW5rcygpO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGxpc3QubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFJlcm91dGluZyhsaXN0W3RdLCBsaXN0W3RdLmdldEF0dHJpYnV0ZShcIm4taHJlZlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgYGVsYCBpcyBub3QgaW5pdGlhbGl6ZWQsIGFkZHMgb25jbGljayBsaXN0ZW5lciB0byBuYXZpZ2F0ZSB0byBgbGlua2AgbG9jYXRpb24uXG4gICAgICogRGlzYWJsZXMgZGVmYXVsdCBuYXZpZ2F0aW9uIHRvIGhyZWYuXG4gICAgICogQHBhcmFtIHtIVE1MQW5jaG9yRWxlbWVudH0gICBlbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgbGlua1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgaW5pdFJlcm91dGluZyhlbCwgbGluaykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghZWwubm90Um91dGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGxldCBmdWxsTGluayA9IHRoaXMuZ2V0RnVsbFJvdXRlKGxpbmspO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBmdWxsTGluayk7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZShsaW5rKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVsLm5vdFJvdXRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBub3RSb3V0ZXIoKTtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uL2NvbW1vbi5qc1wiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4uL2Jhc2UuanNcIjtcblxuY29uc3QgTE9HX1BSRUZJWCA9IFwiQVBJUXVlZVwiO1xuXG5jbGFzcyBub3RBUElRdWV1ZSBleHRlbmRzIG5vdEJhc2Uge1xuICAgIHN0YXRpYyBRVUVVRV9DSEVDS19JTlRFUlZBTCA9IDEwMDtcblxuICAgIHN0YXRpYyBNQVhfQlVTWV9USU1FID0gMzAwO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWUgPyBvcHRpb25zLm5hbWUgOiBMT0dfUFJFRklYLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmJ1c3lTaW5jZSA9IC0xO1xuICAgICAgICB0aGlzLmFmdGVyRW1wdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ1c3lTaW5jZSA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgICB0aGlzLmNoZWNrUXVldWUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHRoaXMuUVVFVUVfQ0hFQ0tfSU5URVJWQUxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjaGVja1F1ZXVlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpICYmICF0aGlzLmlzQnVzeSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ1c3koKVxuICAgICAgICAgICAgICAgIC5ydW5OZXh0KClcbiAgICAgICAgICAgICAgICAudGhlbih0aGlzLnNldEZyZWUuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyZWUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0J1c3koKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFmdGVyRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSB0aGlzLmFmdGVyRW1wdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJFbXB0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFRvUXVldWUodGFzaykge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFzayk7XG4gICAgfVxuXG4gICAgcnVuTmV4dCgpIHtcbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLnF1ZXVlLm1hcCgoYWN0aW9uKSA9PiBhY3Rpb24udGl0bGUpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyAmJiB0aGlzLmRlYnVnKGB0YXNrcyBbJHtsaXN0fV1gKTtcbiAgICAgICAgbGV0IHRhc2sgPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICghbm90Q29tbW9uLmlzRnVuYyh0YXNrLmFjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcItCSINC30LDQtNCw0L3QuNC4INC90LXRgiDQuNGB0L/QvtC70L3QuNC80L7QuSDRh9Cw0YHRgtC4LCBhY3Rpb24g0L3QtSDRhNGD0L3QutGG0LjRj1wiLFxuICAgICAgICAgICAgICAgICAgICB0YXNrLnRpdGxlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm90Q29tbW9uLmlzRnVuYyh0YXNrLnJlc29sdmUpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yICYmXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCLQkiDQt9Cw0LTQsNC90LjQuCDQvdC10YIg0LLQvtC30LLRgNCw0YLQvdC+0Lkg0YfQsNGB0YLQuCwgcmVzb2x2ZSDQvdC1INGE0YPQvdC60YbQuNGPXCIsXG4gICAgICAgICAgICAgICAgICAgIHRhc2sudGl0bGVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2suYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhc2suYWN0aW9uKCkudGhlbih0YXNrLnJlc29sdmUpO1xuICAgIH1cblxuICAgIGlzQnVzeSgpIHtcbiAgICAgICAgbGV0IGJ1c3kgPSAhIXRoaXMuYnVzeSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICBpZiAoYnVzeSAmJiB0aGlzLmJ1c3lTaW5jZSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAobm93IC0gdGhpcy5idXN5U2luY2UgPiBub3RBUElRdWV1ZS5NQVhfQlVTWV9USU1FKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGcmVlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEJ1c3koKSB7XG4gICAgICAgIHRoaXMuYnVzeSA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVzeVNpbmNlID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldEZyZWUoKSB7XG4gICAgICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1c3lTaW5jZSA9IC0xO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog0JjRgdC/0L7Qu9C90LjRgtC10LvRjCDQt9Cw0L/RgNC+0YHQvtCyXG4gICAgICogQHBhcmFtICAgICAge2Z1bmN0aW9ufSAgIGFjdGlvbiAgICAgINC00L7Qu9C20L3QsCDQstC+0LfQstGA0LDRidCw0YLRjCBQcm9taXNlXG4gICAgICogQHBhcmFtICAgICAge2Z1bmN0aW9ufSAgIFthZnRlckVtcHR5ID0gdW5kZWZpbmVkXSAg0LHRg9C00LXRgiDQstGL0L/QvtC70L3QtdC90LAg0LrQvtCz0LTQsCDQvtGH0YPRgNGD0LTRjCDQvtC/0YPRgdGC0LXQtdGCINC4INCx0YPQtNC10YIg0YHQstC+0LHQvtC00L3QsC4g0L/QvtC70LXQt9C90LAg0L/RgNC4INC/0LDRh9C60LUg0L7QtNC90L7RgtC40L/QvdGL0YUg0LfQsNC00LDQvdC40LlcbiAgICAgKiBAcGFyYW0gICAgICAge3N0cmluZ30gICAgW3RpdGxlID0gJyddICAgIG9wdGlvbmFsIHRpdGxlIG9mIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyAgICB7UHJvbWlzZX0gICAg0YDQtdC30YPQu9GM0YLQsNGCINGE0YPQvdC60YbQuNC4XG4gICAgICoqL1xuICAgIHJ1bihhY3Rpb24sIGFmdGVyRW1wdHkgPSB1bmRlZmluZWQsIHRpdGxlID0gXCJcIikge1xuICAgICAgICBpZiAoYWZ0ZXJFbXB0eSAmJiB0eXBlb2YgdGhpcy5hZnRlckVtcHR5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmFmdGVyRW1wdHkgPSBhZnRlckVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9RdWV1ZSh7IGFjdGlvbiwgcmVzb2x2ZSwgdGl0bGUgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWN0aW9uSXNRdWV1ZWQodGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuc29tZSgocXVldWVkKSA9PiBxdWV1ZWQudGl0bGUgPT0gdGl0bGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgYWN0aW9uICAgICAg0LTQvtC70LbQvdCwINCy0L7Qt9Cy0YDQsNGJ0LDRgtGMIFByb21pc2VcbiAgICAgKiBAcGFyYW0gICAgICB7ZnVuY3Rpb259ICAgW2FmdGVyRW1wdHkgPSB1bmRlZmluZWRdICDQsdGD0LTQtdGCINCy0YvQv9C+0LvQvdC10L3QsCDQutC+0LPQtNCwINC+0YfRg9GA0YPQtNGMINC+0L/Rg9GB0YLQtdC10YIg0Lgg0LHRg9C00LXRgiDRgdCy0L7QsdC+0LTQvdCwLiDQv9C+0LvQtdC30L3QsCDQv9GA0Lgg0L/QsNGH0LrQtSDQvtC00L3QvtGC0LjQv9C90YvRhSDQt9Cw0LTQsNC90LjQuVxuICAgICAqIEBwYXJhbSAgICAgICB7c3RyaW5nfSAgICBbdGl0bGUgPSAnJ10gICAgb3B0aW9uYWwgdGl0bGUgb2YgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gICAge1Byb21pc2V9XG4gICAgICogQG1lbWJlcm9mIG5vdEFQSVF1ZXVlXG4gICAgICovXG4gICAgcnVuSWZOb3RRdWV1ZWQoYWN0aW9uLCBhZnRlckVtcHR5ID0gdW5kZWZpbmVkLCB0aXRsZSA9IFwiXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uSXNRdWV1ZWQodGl0bGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW4oYWN0aW9uLCBhZnRlckVtcHR5LCB0aXRsZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEFQSVF1ZXVlO1xuIiwibGV0IG5vdEFQSU9wdGlvbnMgPSB7XG4gICAgcnBzOiA1MCxcbiAgICBwcm90b2NvbDogJ2h0dHAnLFxuICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgIHBvcnQ6IDkwMDBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEFQSU9wdGlvbnM7XG4iLCJpbXBvcnQgbm90QmFzZSBmcm9tICcuLi9iYXNlLmpzJztcbmNvbnN0IExPR19QUkVGSVggPSAnQVBJQ29ubmVjdGlvbic7XG5cbmNsYXNzIG5vdEFQSUNvbm5lY3Rpb24gZXh0ZW5kcyBub3RCYXNle1xuICAgIHN0YXRpYyBpbnQ7XG4gICAgc3RhdGljIG9ubGluZTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWU/b3B0aW9ucy5uYW1lOkxPR19QUkVGSVhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcnVuKCkge1xuICAgICAgICB0aGlzLmludCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrLmJpbmQodGhpcyksIDEwMDApO1xuICAgIH1cblxuICAgIHBhdXNlKCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmludCk7XG4gICAgfVxuXG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgIH1cblxuICAgIGlzT25saW5lKCl7XG4gICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZTtcbiAgICB9XG5cbiAgICBjaGVjaygpIHtcbiAgICAgICAgbGV0IHQgPSB0aGlzLmlzT25saW5lKCk7XG4gICAgICAgIGlmICh0aGlzLm9ubGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub25saW5lICE9PSB0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ubGluZSA9IHQ7XG4gICAgfVxuXG4gICAgY2hhbmdlU3RhdGUob25saW5lID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG9ubGluZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvbmxpbmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnb2ZmbGluZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RBUElDb25uZWN0aW9uO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5jb25zdCBBTEwgPSB7fTtcblxuZnVuY3Rpb24gZXhpc3Qoa2V5KSB7XG4gICAgcmV0dXJuIG5vdENvbW1vbi5vYmpIYXMoQUxMLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGV4aXN0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIEFMTFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShcbiAgICBrZXksXG4gICAgcHJvcHMgPSB7XG4gICAgICAgIHJhdzogW10sXG4gICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgIH1cbikge1xuICAgIGlmICghZXhpc3Qoa2V5KSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIEFMTFtrZXldID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFMTFtrZXldW25hbWVdID0gd3JpdGFibGUocHJvcHNbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdG9yZSdzIHByb3BzIHdhc24ndCBzcGVjaWZpZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFMTFtrZXldO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgb2JqZWN0IHRoYXQgaXMgZmFrZSBTdG9yZVxuICogU29tZSB0aW1lIHRoaXMgaXMgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBsb2NhbCB2YXIsXG4gKiBiZWZvcmUgeW91IGNvdWxkIGdldCBhY3R1YWwgU3RvcmVzIGZyb20gY2VudHJhbCBzdG9yYWdlIGJ5IGl0cyBJRFxuICpcdEBwYXJhbXMge21peGVkfSB2YWwgXHRkYXRhIG9mIHR5cGUgdGhhdCBpcyBhY3R1YWwgc3RvcmFnZSB3aWxsIGNvbnRhaW5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZmFrZSh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmUoZikge1xuICAgICAgICAgICAgZih2YWwpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7fSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGUsIGdldCwgZmFrZSB9O1xuIiwiY29uc3RcbiAgICAvL2ludGVyZmFjZVxuICAgIE9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFkgPSBbJ19pZCcsICdpZCcsICdJRCddLFxuICAgIERFRkFVTFRfRklMVEVSID0ge30sXG4gICAgREVGQVVMVF9TRUFSQ0ggPSAnJyxcbiAgICBERUZBVUxUX1JFVFVSTiA9IHt9LFxuICAgIERFRkFVTFRfUEFHRV9OVU1CRVIgPSAxLFxuICAgIERFRkFVTFRfUEFHRV9TSVpFID0gMTAsXG4gICAgLy9yZWNvcmRcbiAgICBNRVRBX0lOVEVSRkFDRSA9IFN5bWJvbCgnaW50ZXJmYWNlJyksXG4gICAgTUVUQV9NQVBfVE9fSU5URVJGQUNFID0gW1xuICAgICAgICAnZ2V0QWN0aW9uc0NvdW50JyxcbiAgICAgICAgJ2dldEFjdGlvbnMnLFxuICAgICAgICAnc2V0RmluZEJ5JyxcbiAgICAgICAgJ3Jlc2V0RmlsdGVyJyxcbiAgICAgICAgJ3NldEZpbHRlcicsXG4gICAgICAgICdnZXRGaWx0ZXInLFxuICAgICAgICAnc2V0U29ydGVyJyxcbiAgICAgICAgJ2dldFNvcnRlcicsXG4gICAgICAgICdyZXNldFNvcnRlcicsXG4gICAgICAgICdzZXRQYWdlTnVtYmVyJyxcbiAgICAgICAgJ3NldFBhZ2VTaXplJyxcbiAgICAgICAgJ3NldFBhZ2VyJyxcbiAgICAgICAgJ3NldFJldHVybicsXG4gICAgICAgICdzZXRTZWFyY2gnLFxuICAgICAgICAnZ2V0U2VhcmNoJyxcbiAgICAgICAgJ3Jlc2V0U2VhcmNoJyxcbiAgICAgICAgJ3Jlc2V0UGFnZXInLFxuICAgICAgICAnZ2V0UGFnZXInLFxuICAgICAgICAnYWRkRm9ybUZpZWxkVHlwZScsXG4gICAgICAgICdhZGRGb3JtRmllbGQnLFxuICAgICAgICAnZ2V0RmllbGRUeXBlcycsXG4gICAgICAgICdnZXRBY3Rpb25Gb3JtRmllbGRzJ1xuICAgIF0sXG4gICAgREVGQVVMVF9BQ1RJT05fUFJFRklYID0gJyQnO1xuXG5leHBvcnQge1xuICAgIE9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFksXG4gICAgREVGQVVMVF9GSUxURVIsXG4gICAgREVGQVVMVF9QQUdFX05VTUJFUixcbiAgICBERUZBVUxUX1BBR0VfU0laRSxcbiAgICBERUZBVUxUX1NFQVJDSCxcbiAgICBERUZBVUxUX1JFVFVSTixcbiAgICBNRVRBX0lOVEVSRkFDRSxcbiAgICBNRVRBX01BUF9UT19JTlRFUkZBQ0UsXG4gICAgREVGQVVMVF9BQ1RJT05fUFJFRklYXG59O1xuIiwiaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4vYmFzZS5qc1wiO1xuXG5jb25zdCBPUFRfREVGQVVMVF9JTkRFWF9GSUVMRF9OQU1FX1BSSU9SSVRZID0gW1wiX2lkXCIsIFwiaWRcIiwgXCJJRFwiXSxcbiAgICBERUZBVUxUX0ZJTFRFUiA9IHt9LFxuICAgIERFRkFVTFRfU0VBUkNIID0gXCJcIixcbiAgICBERUZBVUxUX1JFVFVSTiA9IHt9LFxuICAgIERFRkFVTFRfUEFHRV9OVU1CRVIgPSAwLFxuICAgIERFRkFVTFRfUEFHRV9TSVpFID0gMTAsXG4gICAgREVGQVVMVF9BQ1RJT05fUFJFRklYID0gXCIkXCIsXG4gICAgREVGQVVMVF9XU19ST1VURV9BQ1RJT05fU1BMSVRURVIgPSBcIi8vXCI7XG5cbmNsYXNzIG5vdEludGVyZmFjZSBleHRlbmRzIG5vdEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKG1hbmlmZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIHdvcmtpbmc6IHtcbiAgICAgICAgICAgICAgICBuYW1lOlxuICAgICAgICAgICAgICAgICAgICBcIm5ldHdvcmsgaW50ZXJmYWNlIGZvcjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAobWFuaWZlc3QubW9kZWwgPyBtYW5pZmVzdC5tb2RlbCA6IFwidW5rbm93blwiKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IERFRkFVTFRfRklMVEVSLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogREVGQVVMVF9TRUFSQ0gsXG4gICAgICAgICAgICAgICAgcmV0dXJuOiBERUZBVUxUX1JFVFVSTixcbiAgICAgICAgICAgICAgICBwYWdlcjoge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBERUZBVUxUX1BBR0VfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogREVGQVVMVF9QQUdFX05VTUJFUixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG4gICAgICAgIHRoaXMuaW5pdEFjdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5pdEFjdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldEFjdGlvbnNDb3VudCgpID4gMCkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbnMgPSB0aGlzLmdldEFjdGlvbnMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbk5hbWUgaW4gYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEFjdGlvbihhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluaXRBY3Rpb24oYWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAoIW5vdENvbW1vbi5vYmpIYXModGhpcywgREVGQVVMVF9BQ1RJT05fUFJFRklYICsgYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXNbREVGQVVMVF9BQ1RJT05fUFJFRklYICsgYWN0aW9uTmFtZV0gPSAoXG4gICAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGZpbGVVcGxvYWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVVwbG9hZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdEhUVFAoXG4gICAgICAgIHJlY29yZCxcbiAgICAgICAgYWN0aW9uTmFtZSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBoZWFkZXJzID0ge30sXG4gICAgICAgIGZpbGVVcGxvYWQgPSBmYWxzZSxcbiAgICAgICAgZmlsZXNcbiAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGVEYXRhID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICByZWNvcmQuZ2V0RGF0YSAmJiB0eXBlb2YgcmVjb3JkLmdldERhdGEgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IHJlY29yZC5nZXREYXRhKClcbiAgICAgICAgICAgICAgICAgICAgOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSB0aGlzLmdldEFjdGlvbkRhdGEoYWN0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHRoaXMuY29sbGVjdFJlcXVlc3REYXRhKGFjdGlvbkRhdGEpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNFbmNvZGVkID0gdGhpcy5lbmNvZGVSZXF1ZXN0KHJlcXVlc3RQYXJhbXMpLFxuICAgICAgICAgICAgICAgIC8vaWQgPSB0aGlzLmdldElEKGNvbXBvc2l0ZURhdGEsIGFjdGlvbkRhdGEsIGFjdGlvbk5hbWUpLFxuICAgICAgICAgICAgICAgIGFwaVNlcnZlclVSTCA9IHRoaXMuZ2V0U2VydmVyVVJMKCksXG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5nZXRVUkwoY29tcG9zaXRlRGF0YSwgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgICAgaWYgKGZpbGVVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmdldFVSTChwYXJhbXMsIGFjdGlvbkRhdGEsIGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgZmQuYXBwZW5kKFwiZmlsZVwiLCBmaWxlcyk7XG4gICAgICAgICAgICAgICAgb3B0cy5ib2R5ID0gZmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgW1wiT1BUSU9OU1wiLCBcIkdFVFwiXS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uRGF0YS5tZXRob2QudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICApID09PSAtMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBhY3Rpb25EYXRhLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5nZXREYXRhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZWNvcmQuZ2V0RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVjb3JkLmdldERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlY29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRzLm1ldGhvZCA9IGFjdGlvbkRhdGEubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoaGVhZGVycyAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGFwaVNlcnZlclVSTCArIHVybCArIHJlcXVlc3RQYXJhbXNFbmNvZGVkLCBvcHRzKS50aGVuKFxuICAgICAgICAgICAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBub3RDb21tb24uZXJyb3IoZSk7XG4gICAgICAgICAgICBub3RDb21tb24ucmVwb3J0KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdFdTKHJlY29yZCwgYWN0aW9uTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSB0aGlzLmdldEFjdGlvbkRhdGEoYWN0aW9uTmFtZSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHRoaXMuY29sbGVjdFJlcXVlc3REYXRhKGFjdGlvbkRhdGEpO1xuICAgICAgICAgICAgY29uc3QgV1MgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0V1NDbGllbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VOYW1lID0gdGhpcy5nZXRXU1JlcXVlc3ROYW1lKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RQYXJhbXMsIHJlY29yZC5nZXREYXRhKCkpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoYWN0aW9uRGF0YSwgXCJ0eXBlXCIpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFjdGlvbkRhdGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGFjdGlvbkRhdGEudHlwZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBhY3Rpb25EYXRhLnR5cGUgIT09IFwicmVxdWVzdFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gV1MubWVzc2FnZShhY3Rpb25EYXRhLnR5cGUsIG1lc3NhZ2VOYW1lLCBwYXlsb2FkKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAocmVzcG9uc2UpID0+IHJlc3BvbnNlLnBheWxvYWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gV1MucmVxdWVzdChtZXNzYWdlTmFtZSwgcGF5bG9hZCkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZS5wYXlsb2FkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbm90Q29tbW9uLmVycm9yKGUpO1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3QoKSB7XG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gdGhpcy5nZXRBY3Rpb25EYXRhKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZWxlY3RUcmFuc3BvcnQoYWN0aW9uRGF0YSkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RXUyguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgY2FzZSBcImh0dHBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0SFRUUCguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZsaW5lXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3NJc1VwKGFjdGlvbkRhdGEpIHtcbiAgICAgICAgaWYgKGFjdGlvbkRhdGEud3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxldCBjbGllbnQ7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcIndzQ2xpZW50XCIpICYmXG4gICAgICAgICAgICAgICAgYWN0aW9uRGF0YS53c0NsaWVudFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50ID0gbm90Q29tbW9uLmdldEFwcCgpLmdldFdTQ2xpZW50KGFjdGlvbkRhdGEud3NDbGllbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBub3RDb21tb24uZ2V0QXBwKCkuZ2V0V1NDbGllbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGllbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0VHJhbnNwb3J0KGFjdGlvbkRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMud3NJc1VwKGFjdGlvbkRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ3c1wiOyAvL2ZvciB3cy93c3NcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcIm1ldGhvZFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cFwiOyAvL2ZvciBodHRwL2h0dHBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvL2ZvciBvZmZsaW5lXG4gICAgfVxuXG4gICAgZ2V0TW9kZWxOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcyAmJiB0aGlzLm1hbmlmZXN0ID8gdGhpcy5tYW5pZmVzdC5tb2RlbCA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9uRGF0YShhY3Rpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGlvbnMoKSAmJiB0aGlzLmdldEFjdGlvbnMoKVthY3Rpb25OYW1lXVxuICAgICAgICAgICAgPyB0aGlzLmdldEFjdGlvbnMoKVthY3Rpb25OYW1lXVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIGdldEFjdGlvbnNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWN0aW9ucygpID8gT2JqZWN0LmtleXModGhpcy5nZXRBY3Rpb25zKCkpLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaWZlc3QgJiYgdGhpcy5tYW5pZmVzdC5hY3Rpb25zXG4gICAgICAgICAgICA/IHRoaXMubWFuaWZlc3QuYWN0aW9uc1xuICAgICAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICBwYXJzZVBhcmFtcyhzdGFydCwgZW5kLCBsaW5lLCByZWNvcmQpIHtcbiAgICAgICAgbGV0IGZpZWxkTmFtZSA9IFwiXCI7XG4gICAgICAgIGxldCBsZW4gPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsaW5lLmluZGV4T2Yoc3RhcnQpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBpbmQgPSBsaW5lLmluZGV4T2Yoc3RhcnQpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0U2xpY2UgPSBpbmQgKyBsZW47XG4gICAgICAgICAgICBsZXQgZW5kU2xpY2UgPSBsaW5lLmluZGV4T2YoZW5kKTtcbiAgICAgICAgICAgIGlmIChpbmQgPiBlbmRTbGljZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmllbGROYW1lID0gbGluZS5zbGljZShzdGFydFNsaWNlLCBlbmRTbGljZSk7XG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09IFwiXCIpIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5sb2cgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyBmaWVsZE5hbWUgKyBlbmQsXG4gICAgICAgICAgICAgICAgICAgIG5vdFBhdGguZ2V0KGZpZWxkTmFtZSwgcmVjb3JkKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgZmllbGROYW1lICsgZW5kLFxuICAgICAgICAgICAgICAgIG5vdFBhdGguZ2V0KGZpZWxkTmFtZSwgcmVjb3JkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG5cbiAgICBwYXJzZUxpbmUobGluZSwgcmVjb3JkLCBhY3Rpb25OYW1lKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoXCI6bW9kZWxOYW1lXCIsIHRoaXMubWFuaWZlc3QubW9kZWwpO1xuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKFwiOmFjdGlvbk5hbWVcIiwgYWN0aW9uTmFtZSk7XG4gICAgICAgIGxpbmUgPSB0aGlzLnBhcnNlUGFyYW1zKFwiOnJlY29yZFtcIiwgXCJdXCIsIGxpbmUsIHJlY29yZCk7XG4gICAgICAgIGxpbmUgPSB0aGlzLnBhcnNlUGFyYW1zKFwiOlwiLCBcIj9cIiwgbGluZSwgcmVjb3JkKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG4gICAgZ2V0VVJMKHJlY29yZCwgYWN0aW9uRGF0YSwgYWN0aW9uTmFtZSkge1xuICAgICAgICB2YXIgbGluZSA9XG4gICAgICAgICAgICB0aGlzLnBhcnNlTGluZSh0aGlzLm1hbmlmZXN0LnVybCwgcmVjb3JkLCBhY3Rpb25OYW1lKSArXG4gICAgICAgICAgICAobm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcInBvc3RGaXhcIilcbiAgICAgICAgICAgICAgICA/IHRoaXMucGFyc2VMaW5lKGFjdGlvbkRhdGEucG9zdEZpeCwgcmVjb3JkLCBhY3Rpb25OYW1lKVxuICAgICAgICAgICAgICAgIDogXCJcIik7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIGdldFNlcnZlclVSTCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKVxuICAgICAgICAgICAgPyBub3RDb21tb24uZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcImFwaS5zZXJ2ZXIudXJsXCIsIFwiXCIpXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgfVxuXG4gICAgZ2V0V1NSZXF1ZXN0TmFtZShhY3Rpb25OYW1lKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMubWFuaWZlc3QubW9kZWw7XG4gICAgICAgIHJldHVybiBgJHttb2RlbE5hbWV9JHtERUZBVUxUX1dTX1JPVVRFX0FDVElPTl9TUExJVFRFUn0ke2FjdGlvbk5hbWV9YDtcbiAgICB9XG5cbiAgICBlbmNvZGVSZXF1ZXN0KGRhdGEpIHtcbiAgICAgICAgbGV0IHAgPSBcIj9cIjtcbiAgICAgICAgZm9yIChsZXQgdCBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbdF0gIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YVt0XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAgKz1cbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHQpICtcbiAgICAgICAgICAgICAgICAgICAgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3RdLmNvbnN0cnVjdG9yID09PSBPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KGRhdGFbdF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhW3RdXG4gICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICBcIiZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL2ZvciB0ZXN0IHB1cnBvc2Ugb25seSwgc3BlY2lhbCB0ZXN0IHNlcnZlciBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInRlc3RcIikpIHtcbiAgICAgICAgICAgIHAgKz0gXCImdGVzdD0xXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidGVzdC5zZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgcCArPSBcIiZzZXNzaW9uPVwiICsgdGhpcy5nZXRPcHRpb25zKFwidGVzdC5zZXNzaW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInRlc3Quc2Vzc2lvblwiKSkge1xuICAgICAgICAgICAgICAgIHAgKz0gXCImcm9sZT1cIiArIHRoaXMuZ2V0T3B0aW9ucyhcInRlc3Qucm9sZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBjb2xsZWN0UmVxdWVzdERhdGEoYWN0aW9uRGF0YSkge1xuICAgICAgICBsZXQgcmVxdWVzdERhdGEgPSB7fTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcImRhdGFcIikgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoYWN0aW9uRGF0YS5kYXRhKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aW9uRGF0YS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGFQcm92aWRlck5hbWUgPVxuICAgICAgICAgICAgICAgICAgICBcImdldFwiICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihhY3Rpb25EYXRhLmRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tkYXRhUHJvdmlkZXJOYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGhpc1tkYXRhUHJvdmlkZXJOYW1lXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gdGhpc1tkYXRhUHJvdmlkZXJOYW1lXSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzb3J0ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZpbHRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2VhcmNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXR1cm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIF0uaW5kZXhPZihhY3Rpb25EYXRhLmRhdGFbaV0pID4gLTFcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbYWN0aW9uRGF0YS5kYXRhW2ldXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhID0gT2JqZWN0LmFzc2lnbihyZXF1ZXN0RGF0YSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3REYXRhO1xuICAgIH1cblxuICAgIGdldElEKHJlY29yZCwgYWN0aW9uRGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0SWQsXG4gICAgICAgICAgICBsaXN0ID0gT1BUX0RFRkFVTFRfSU5ERVhfRklFTERfTkFNRV9QUklPUklUWSxcbiAgICAgICAgICAgIHByZWZpeGVzID0gW1wiXCIsIHRoaXMubWFuaWZlc3QubW9kZWxdO1xuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhhY3Rpb25EYXRhLCBcImluZGV4XCIpICYmIGFjdGlvbkRhdGEuaW5kZXgpIHtcbiAgICAgICAgICAgIGxpc3QgPSBbYWN0aW9uRGF0YS5pbmRleF0uY29uY2F0KFxuICAgICAgICAgICAgICAgIE9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJlIG9mIHByZWZpeGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhyZWNvcmQsIHByZSArIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdElkID0gcmVjb3JkW3ByZSArIHRdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdElkO1xuICAgIH1cblxuICAgIHNldEZpbmRCeShrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RmlsdGVyKG9iaik7XG4gICAgfVxuXG4gICAgc2V0RmlsdGVyKGZpbHRlckRhdGEgPSBERUZBVUxUX0ZJTFRFUikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJmaWx0ZXJcIiwgZmlsdGVyRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRGaWx0ZXIoKTtcbiAgICB9XG5cbiAgICBnZXRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJmaWx0ZXJcIik7XG4gICAgfVxuXG4gICAgc2V0U2VhcmNoKHNlYXJjaERhdGEgPSBERUZBVUxUX1NFQVJDSCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJzZWFyY2hcIiwgc2VhcmNoRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0U2VhcmNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRTZWFyY2goKTtcbiAgICB9XG5cbiAgICBnZXRTZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJzZWFyY2hcIik7XG4gICAgfVxuXG4gICAgc2V0U29ydGVyKHNvcnRlckRhdGEpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwic29ydGVyXCIsIHNvcnRlckRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldFNvcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U29ydGVyKHt9KTtcbiAgICB9XG5cbiAgICBnZXRTb3J0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJzb3J0ZXJcIik7XG4gICAgfVxuXG4gICAgc2V0UmV0dXJuKHJldHVybkRhdGEgPSBERUZBVUxUX1JFVFVSTikge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJyZXR1cm5cIiwgcmV0dXJuRGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlc2V0UmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRSZXR1cm4oe30pO1xuICAgIH1cblxuICAgIGdldFJldHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInJldHVyblwiKTtcbiAgICB9XG5cbiAgICBzZXRQYWdlTnVtYmVyKHBhZ2VOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicGFnZXIucGFnZVwiLCBwYWdlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0UGFnZVNpemUocGFnZVNpemUpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicGFnZXIuc2l6ZVwiLCBwYWdlU2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vcGFnZVNpemUgPSBERUZBVUxUX1BBR0VfU0laRSwgcGFnZU51bWJlciA9IERFRkFVTFRfUEFHRV9OVU1CRVJcbiAgICBzZXRQYWdlcigpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8XG4gICAgICAgICAgICAgICAgaXNOYU4oYXJndW1lbnRzWzBdKSB8fFxuICAgICAgICAgICAgICAgIGlzTmFOKGFyZ3VtZW50c1sxXSkpICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0uY29uc3RydWN0b3IgPT09IE9iamVjdCAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhcmd1bWVudHNbMF0sIFwicGFnZVwiKSAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhhcmd1bWVudHNbMF0sIFwic2l6ZVwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicGFnZXJcIiwge1xuICAgICAgICAgICAgICAgIHNpemU6IHBhZ2VyLnNpemUgfHwgREVGQVVMVF9QQUdFX1NJWkUsXG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZXIucGFnZSB8fCBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAhaXNOYU4oYXJndW1lbnRzWzBdKSAmJlxuICAgICAgICAgICAgIWlzTmFOKGFyZ3VtZW50c1sxXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJwYWdlclwiLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogYXJndW1lbnRzWzBdIHx8IERFRkFVTFRfUEFHRV9TSVpFLFxuICAgICAgICAgICAgICAgIHBhZ2U6IGFyZ3VtZW50c1sxXSB8fCBERUZBVUxUX1BBR0VfTlVNQkVSLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRQYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFnZXIoKTtcbiAgICB9XG5cbiAgICBnZXRQYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInBhZ2VyXCIpO1xuICAgIH1cblxuICAgIGdldFJlY29yZCgpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhKCk7XG4gICAgfVxuXG4gICAgZ2V0RGVmYXVsdEFzUGxhaW5PYmplY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5tYW5pZmVzdCB8fCAhdGhpcy5tYW5pZmVzdC5maWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgT2JqZWN0LmtleXModGhpcy5tYW5pZmVzdC5maWVsZHMpKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bih0aGlzLm1hbmlmZXN0LmZpZWxkc1tmaWVsZE5hbWVdLCBcImRlZmF1bHRcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLm1hbmlmZXN0LmZpZWxkc1tmaWVsZE5hbWVdLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IFsuLi5kZWZhdWx0VmFsdWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IHsgLi4uZGVmYXVsdFZhbHVlIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RJbnRlcmZhY2U7XG4iLCJpbXBvcnQgbm90QmFzZSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG5pbXBvcnQge1xuICAgIE1FVEFfSU5URVJGQUNFLFxuICAgIE1FVEFfTUFQX1RPX0lOVEVSRkFDRSxcbiAgICBERUZBVUxUX0FDVElPTl9QUkVGSVgsXG59IGZyb20gXCIuL29wdGlvbnNcIjtcblxuaW1wb3J0IG5vdEludGVyZmFjZSBmcm9tIFwiLi9pbnRlcmZhY2VcIjtcblxuY2xhc3Mgbm90UmVjb3JkIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgY29uc3RydWN0b3IobWFuaWZlc3QsIGl0ZW0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0gPT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgIGl0ZW0gPT09IG51bGwgfHxcbiAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSBcIm9iamVjdFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5pc1Byb3h5KSB7XG4gICAgICAgICAgICBub3RDb21tb24uZXJyb3IoXCJ0aGlzIGlzIFByb3h5IGl0ZW1cIik7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiAoaXRlbS5pc1JlY29yZCB8fCBpdGVtLmlzUHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sbGVjdGlvbihtYW5pZmVzdCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHt9KTtcbiAgICAgICAgdGhpc1tNRVRBX0lOVEVSRkFDRV0gPSBuZXcgbm90SW50ZXJmYWNlKG1hbmlmZXN0LCB7fSk7XG4gICAgICAgIHRoaXMuc2V0RGF0YShpdGVtKTtcbiAgICAgICAgdGhpcy5pbnRlcmZhY2VVcCgpO1xuICAgICAgICB0aGlzLm1hcFRvSW50ZXJmYWNlKCk7XG4gICAgICAgIHRoaXMubWFwVG9NZXRob2RzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRvRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RGF0YSh0aGlzW01FVEFfSU5URVJGQUNFXS5nZXREZWZhdWx0QXNQbGFpbk9iamVjdCgpKTtcbiAgICB9XG5cbiAgICBtYXBUb0ludGVyZmFjZSgpIHtcbiAgICAgICAgbGV0IHJlYyA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHQgb2YgTUVUQV9NQVBfVE9fSU5URVJGQUNFKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpc1tNRVRBX0lOVEVSRkFDRV1bdF0gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGhpc1tNRVRBX0lOVEVSRkFDRV1bdF0gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHJlY1tNRVRBX0lOVEVSRkFDRV1bdF0oLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcyA9PSByZWNbTUVUQV9JTlRFUkZBQ0VdID8gcmVjIDogcmVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYXBUb01ldGhvZHMoKSB7XG4gICAgICAgIGxldCBtYW5pZmVzdCA9IHRoaXNbTUVUQV9JTlRFUkZBQ0VdLm1hbmlmZXN0LFxuICAgICAgICAgICAgYXBwID0gbm90Q29tbW9uLmdldEFwcCgpLFxuICAgICAgICAgICAgbWV0aG9kcyA9IHt9O1xuICAgICAgICBpZiAobWFuaWZlc3QubWV0aG9kcykge1xuICAgICAgICAgICAgbWV0aG9kcyA9IG1hbmlmZXN0Lm1ldGhvZHM7XG4gICAgICAgIH0gZWxzZSBpZiAoYXBwKSB7XG4gICAgICAgICAgICBtZXRob2RzID0gYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgW1wibW9kZWxzXCIsIHRoaXNbTUVUQV9JTlRFUkZBQ0VdLm1hbmlmZXN0Lm1vZGVsXS5qb2luKFwiLlwiKSxcbiAgICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kcykge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24obWV0aG9kcywgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1t0XSA9IG1ldGhvZHNbdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlQ29sbGVjdGlvbihtYW5pZmVzdCwgaXRlbXMpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKG5ldyBub3RSZWNvcmQobWFuaWZlc3QsIGl0ZW1zW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgaW50ZXJmYWNlVXAoKSB7XG4gICAgICAgIGlmICh0aGlzW01FVEFfSU5URVJGQUNFXS5nZXRBY3Rpb25zQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgIGxldCBhY3Rpb25zID0gdGhpc1tNRVRBX0lOVEVSRkFDRV0uZ2V0QWN0aW9ucygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25VcChpLCBhY3Rpb25zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvblVwKGluZGV4KSB7XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093bih0aGlzLCBbREVGQVVMVF9BQ1RJT05fUFJFRklYICsgaW5kZXhdKSkge1xuICAgICAgICAgICAgdGhpc1tERUZBVUxUX0FDVElPTl9QUkVGSVggKyBpbmRleF0gPSAoLi4ucGFyYW1zKSA9PlxuICAgICAgICAgICAgICAgIHRoaXNbTUVUQV9JTlRFUkZBQ0VdLnJlcXVlc3QodGhpcywgaW5kZXgsIC4uLnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcbiAgLT4gJ3BhdGgudG8ua2V5JywgdmFsdWVPZktleVxuICA8LSBvaywgd2l0aCBvbmUgb25DaGFuZ2UgZXZlbnQgdHJpZ2dlcmVkXG4gICovXG5cbiAgICBzZXRBdHRyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RGF0YShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKlxuICAtPlxuICB7XG4gICAgJ2tleVBhdGgnOiB2YWx1ZSxcbiAgICAna2V5LnN1YlBhdGgnOiB2YWx1ZTIsXG4gICAgJ2tleVBhdGguMC50aXRsZSc6IHZhbHVlM1xuICB9XG4gIDwtIG9rLCB3aXRoIGJ1bmNoIG9mIG9uQ2hhbmdlIGV2ZW50cyB0cmlnZ2VyZWRcbiAgKi9cbiAgICBzZXRBdHRycyhvYmplY3RQYXJ0KSB7XG4gICAgICAgIC8vbm90Q29tbW9uLmxvZygnc2V0QXR0cnMnLCBvYmplY3RQYXJ0LCBPYmplY3Qua2V5cyhvYmplY3RQYXJ0KSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG9iamVjdFBhcnQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmplY3RQYXJ0ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvYmplY3RQYXJ0KS5sZW5ndGggPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGF0aCBpbiBvYmplY3RQYXJ0KSB7XG4gICAgICAgICAgICAgICAgLy9ub3RDb21tb24ubG9nKCdzZXRBdHRycyBvbmUgdG8gZ28nLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIocGF0aCwgb2JqZWN0UGFydFtwYXRoXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAtPiAncGF0aFRvS2V5J1xuICA8LSB2YWx1ZTFcbiAgKi9cbiAgICBnZXRBdHRyKHdoYXQsIHBsYWluID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHByeCA9IHRoaXMuZ2V0RGF0YSh3aGF0LCB7fSk7XG4gICAgICAgIGlmIChwbGFpbikge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5zdHJpcFByb3h5KHByeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJ4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgLT4gWydwYXRoVG9LZXknLCAncGF0aC50by5rZXknLCAnc2ltcGxlS2V5JywuLi5dXG4gIDwtIFt2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzLC4uLl1cbiAgKi9cbiAgICBnZXRBdHRycyh3aGF0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHdoYXQgJiYgd2hhdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXRoIG9mIHdoYXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdldEF0dHIocGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0TWFuaWZlc3QoKSB7XG4gICAgICAgIGlmICh0aGlzW01FVEFfSU5URVJGQUNFXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbTUVUQV9JTlRFUkZBQ0VdLm1hbmlmZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXRlbShpdGVtKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RSZWNvcmQ7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0IG5vdFJlY29yZCBmcm9tIFwiLi9yZWNvcmQuanNcIjtcbmltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcbmltcG9ydCBub3RSb3V0ZXIgZnJvbSBcIi4vcm91dGVyLmpzXCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9IFtPUFRfQ09OVFJPTExFUl9QUkVGSVggPSBcIm5jXCJdIGNvbnRyb2xsZXIgbmFtZXMgcHJlZml4IG5jIGFrYSBOb3RDb250cm9sbGVyXG4gKi9cbmNvbnN0IE9QVF9DT05UUk9MTEVSX1BSRUZJWCA9IFwibmNcIjtcbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9IFtPUFRfUkVDT1JEX1BSRUZJWCA9IFwibnJcIl0gcmVjb3JkIG5hbWVzIHByZWZpeCBuciBha2EgTm90UmVjb3JkXG4gKi9cbmNvbnN0IE9QVF9SRUNPUkRfUFJFRklYID0gXCJuclwiO1xuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gW0RFRkFVTFRfV1NfQ0xJRU5UX05BTUUgPSBcIm1haW5cIl0gZGVmYXVsdCBuYW1lIG9mIFdTIGNsaWVudFxuICovXG5jb25zdCBERUZBVUxUX1dTX0NMSUVOVF9OQU1FID0gXCJtYWluXCI7XG5cbi8qKlxuICogQ2xhc3Mgb2YgYXBwbGljYXRpb25cbiAqIEBjbGFzc1xuICovXG5jbGFzcyBub3RBcHAgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7ZnVuY3Rpb259IERFRkFVTFRfV1NfQ0xJRU5UX05BTUUgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gZGVlcCBtZXJnZXMgb2Ygb2JqZWN0c1xuICAgICAqL1xuICAgIHN0YXRpYyBERUZBVUxUX1dTX0NMSUVOVF9OQU1FID0gREVGQVVMVF9XU19DTElFTlRfTkFNRTtcbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgYXBwbGljYXRpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgICAgICAgICBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY29udHJvbGxlcnMgIGNvbnRyb2xsZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBvcHRpb25zLm1hbmlmZXN0VVJMIFVSTCBvZiBuZXR3b3JrIG1hbmlmZXN0IHdpdGggYWxsIGF2YWlsYWJsZSBtb2RlbHMvYWN0aW9ucy9maWVsZHMgcmVxdWVzdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgd29ya2luZzoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnRlcmZhY2VzOiB7fSxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyczogbm90Q29tbW9uLm9iakhhcyhvcHRpb25zLCBcImNvbnRyb2xsZXJzXCIpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5jb250cm9sbGVyc1xuICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgICAgIGluaXRDb250cm9sbGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250cm9sbGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIHVpczoge30sXG4gICAgICAgICAgICAgICAgd3NjOiB7fSxcbiAgICAgICAgICAgICAgICB3c3M6IHt9LFxuICAgICAgICAgICAgICAgIHNlcnZpY2VzOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcz8ubG9nICYmIHRoaXMubG9nKFwic3RhcnQgYXBwXCIpO1xuICAgICAgICBub3RDb21tb24ucmVnaXN0ZXIoXCJhcHBcIiwgdGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdE1hbmlmZXN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFwcGxpY2F0aW9uIGFjY29yZGluZyB0byBuZXR3b3JrIG1hbmlmZXN0LCB3aGljaCBpcyByZXRyaWV2ZWQgZnJvbSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBpbml0TWFuaWZlc3QoKSB7XG4gICAgICAgIG5vdENvbW1vblxuICAgICAgICAgICAgLmdldEpTT04odGhpcy5nZXRPcHRpb25zKFwibWFuaWZlc3RVUkxcIikpXG4gICAgICAgICAgICAudGhlbigobWFuaWZlc3QpID0+IHRoaXMuc2V0SW50ZXJmYWNlTWFuaWZlc3QobWFuaWZlc3QpKVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiBub3RDb21tb24ucmVwb3J0KGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmUgcGFnZSByb3V0aW5nIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgaW5pdFJvdXRlcigpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwicm91dGVyXCIsIG5vdFJvdXRlcik7XG4gICAgICAgIHRoaXMuZ2V0V29ya2luZyhcInJvdXRlclwiKS5zZXRSb290KHRoaXMuZ2V0T3B0aW9ucyhcInJvdXRlci5yb290XCIpKTtcbiAgICAgICAgbm90Um91dGVyLnJlUm91dGVFeGlzdGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbGwgdGhlIHJvdXRlcyBoYW5kbGVycyBhbmQgcHVzaGVzIHRoZW0gaW50byByb3V0ZXJcbiAgICAgKi9cbiAgICBleGVjUm91dGVyKCkge1xuICAgICAgICB2YXIgcm91dGllSW5wdXQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmdldE9wdGlvbnMoXCJyb3V0ZXIubWFuaWZlc3RcIikubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCByb3V0ZUJsb2NrID0gdGhpcy5nZXRPcHRpb25zKFwicm91dGVyLm1hbmlmZXN0XCIpW3RdLFxuICAgICAgICAgICAgICAgIHBhdGhzID0gcm91dGVCbG9jay5wYXRocyxcbiAgICAgICAgICAgICAgICBzY2hlbWVzID0gcm91dGVCbG9jay5zY2hlbWVzLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIgPSByb3V0ZUJsb2NrLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdGhTY2hlbWUgPVxuICAgICAgICAgICAgICAgICAgICBzY2hlbWVzICYmIEFycmF5LmlzQXJyYXkoc2NoZW1lcykgJiYgc2NoZW1lcy5sZW5ndGggPiBpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNjaGVtZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgcm91dGllSW5wdXRbcGF0aHNbaV1dID0gdGhpcy5iaW5kQ29udHJvbGxlcihcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgcGF0aFNjaGVtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwicm91dGVyXCIpLmFkZExpc3Qocm91dGllSW5wdXQpLmxpc3RlbigpOyAvLy5uYXZpZ2F0ZSh0aGlzLmdldE9wdGlvbnMoJ3JvdXRlci5pbmRleCcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGludGVyZmFjZSBtYW5pZmVzdCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gIG1hbmlmZXN0ICAgIGludGVyZmFjZSBtYW5pZmVzdFxuICAgICAqL1xuICAgIHNldEludGVyZmFjZU1hbmlmZXN0KG1hbmlmZXN0KSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUobWFuaWZlc3QpO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJpbnRlcmZhY2VNYW5pZmVzdFwiLCBtYW5pZmVzdCk7XG4gICAgICAgIHRoaXMuaW5pdFJvdXRlcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgY29uc3RydWN0b3Igb2YgaW50ZXJmYWNlIG1vZGVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBtb2RlbE5hbWUgICBtb2RlbCBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gICAgaW50ZXJmYWNlIG1vZGVsIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZ2V0SW50ZXJmYWNlTWFuaWZlc3QobW9kZWxOYW1lKSB7XG4gICAgICAgIGlmIChtb2RlbE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2VNYW5pZmVzdFwiKVttb2RlbE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRpbmcgQXBwbGljYXRpb24sIHJlbG9hZHMgaW50ZXJmYWNlcywgaW5pdCBjb250cm9sbGVyIGxhdW5jaGVkLCBzdGFydCBhZ2FpblxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLy/QvdGD0LbQvdC+INC40L3QuNGG0LjQsNC70LjQt9C40YDQvtCy0LDRgtGMXG4gICAgICAgIC8v0LzQvtC00LXQu9C4INC/0L7Qu9GD0YfQtdC90L3Ri9C80Lgg0LjQvdGC0LXRgNGE0LXQudGB0LDQvNC4XG4gICAgICAgIHRoaXMudXBkYXRlSW50ZXJmYWNlcygpO1xuICAgICAgICAvL9C40L3QuNGG0LjQu9C40YbQuNGA0L7QstCw0YLRjCDQuCDQt9Cw0L/Rg9GB0YLQuNGC0Ywg0LrQvtC90YLRgNC+0LvQu9C10YAg0LjQvdC40YbQuNCw0LvQuNC30LDRhtC40LhcbiAgICAgICAgdGhpcy5pbml0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0QXBwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6YXRpb24gb2Ygc2VydmljZXMsIHN0YXJ0dXAgb2Ygcm91dGluZ1xuICAgICAqL1xuICAgIHN0YXJ0QXBwKCkge1xuICAgICAgICB0aGlzLmluaXRTZXJ2aWNlcygpO1xuICAgICAgICAvL9GB0L7Qt9C00LDRgtGMINC60L7QvdGC0YDQvtC70LvQtdGA0YtcbiAgICAgICAgLy/RgNC+0YPRgtC10YAg0Lgg0L/RgNC40LLRj9C30LDRgtGMINC6INC90LXQvNGDINC60L7QvdGC0YDQvtC70LvQtdGA0YtcbiAgICAgICAgdGhpcy5leGVjUm91dGVyKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImFmdGVyU3RhcnRlZFwiLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyTmFtZSBjb250cm9sbGVyIGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29udHJvbGxlclBhdGhTY2hlbWVcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IGZ1bmN0aW9uIGNyZWF0ZXMgbmV3IGNvbnRyb2xsZXIgaW5zdGFuY2UgYW5kIHBhc3MgaW4gbm90QXBwIGluc3RhbmNlLCBhcmd1bWVudHMgZnJvbSByb3V0ZXIgcGFyc2VyIGFuZCBwYXRoU2NoZW1lXG4gICAgICovXG4gICAgYmluZENvbnRyb2xsZXIoY29udHJvbGxlck5hbWUsIGNvbnRyb2xsZXJQYXRoU2NoZW1lKSB7XG4gICAgICAgIGxldCBhcHAgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbmV3IGNvbnRyb2xsZXJOYW1lKGFwcCwgYXJndW1lbnRzLCBjb250cm9sbGVyUGF0aFNjaGVtZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgJ2luaXRpYWxpemF0aW9uJyBjb250cm9sbGVyIHdoaWNoIGlzIHJ1bnMgb25jZSxcbiAgICAgKiB0byBwZXJmb3JtIGN1c3RvbSBpbml0aWFsaXphdGlvbnMgcm91dGluZXMgYnkgYXBwbGljYXRpb24gY29kZVxuICAgICAqL1xuICAgIGluaXRDb250cm9sbGVyKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZ2V0T3B0aW9ucyhcImluaXRDb250cm9sbGVyXCIpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgaW5pdENvbnRyb2xsZXIgPSB0aGlzLmdldE9wdGlvbnMoXCJpbml0Q29udHJvbGxlclwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcImluaXRDb250cm9sbGVyXCIsIG5ldyBpbml0Q29udHJvbGxlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdvcmtpbmcgY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHdvcmtpbmcgY29udHJvbGxlclxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwiY3VycmVudENvbnRyb2xsZXJcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveWVzIHdvcmtpbmcgY29udHJvbGxlciB0aGVuIHNldHMgcHJvdmlkZWQgYXMgd29ya2luZ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjdHJsIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBub3RBcHAgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzZXRDdXJyZW50Q29udHJvbGxlcihjdHJsKSB7XG4gICAgICAgIGxldCBvbGRDdHJsID0gdGhpcy5nZXRDdXJyZW50Q29udHJvbGxlcigpO1xuICAgICAgICBpZiAob2xkQ3RybCAmJiBvbGRDdHJsLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIG9sZEN0cmwuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcImN1cnJlbnRDb250cm9sbGVyXCIsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFycm93IGZ1bmN0aW9uOiAobW9kZWxJbml0RGF0YSA9IHt9KSA9PiBub3RSZWNvcmRcbiAgICAgKiBGYWN0b3J5IHRoYXQgY3JlYXRlcyBub3RSZWNvcmQgaW5zdGFuY2VzIHdpdGggYmluZGVkXG4gICAgICogcmVjb3JkTWFuaWZlc3QgYW5kIHByb3ZpZGVkIGRhdGEgdG8gaW5pdGlhbGl6ZSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkTWFuaWZlc3RcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICAgKiBAbWVtYmVyb2Ygbm90QXBwXG4gICAgICovXG4gICAgY3JlYXRlSW50ZXJmYWNlTW9kZWxGYWN0b3J5KHJlY29yZE1hbmlmZXN0KSB7XG4gICAgICAgIHJldHVybiAocmVjb3JkRGF0YSkgPT4gbmV3IG5vdFJlY29yZChyZWNvcmRNYW5pZmVzdCwgcmVjb3JkRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGludGVyZmFjZXMsIHJlY3JlYXRlcyBhbGwgYWNjb3JkaW5nIHRvIE9wdGlvbnMuaW50ZXJhZmFjZU1hbmlmZXN0XG4gICAgICovXG4gICAgdXBkYXRlSW50ZXJmYWNlcygpIHtcbiAgICAgICAgdGhpcy5jbGVhckludGVyZmFjZXMoKTtcbiAgICAgICAgbGV0IG1hbmlmZXN0cyA9IHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZU1hbmlmZXN0XCIpO1xuICAgICAgICBpZiAobWFuaWZlc3RzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIG1hbmlmZXN0cykge1xuICAgICAgICAgICAgICAgIGxldCByZWNvcmRNYW5pZmVzdCA9IG1hbmlmZXN0c1tuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkTWV0aG9kcyA9IHRoaXMuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1vZGVsc1wiLCBuYW1lXS5qb2luKFwiLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmVjb3JkTWFuaWZlc3QubWV0aG9kcyA9IHJlY29yZE1ldGhvZHM7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZUludCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlSW50ZXJmYWNlTW9kZWxGYWN0b3J5KHJlY29yZE1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVyZmFjZShuYW1lLCBuYW1lSW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGludGVyZmFjZSBuYW1lIChtb2RlbE5hbWUpIHRvIHN0YW5kYXJ0aXppZWQgcHJlZml4TW9kZWxOYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgaW50ZXJmYWNlIG1vZGVsIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICBub3QgcmVjb3JkIG5hbWVcbiAgICAgKi9cbiAgICBnZXRSZWNvcmROYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIE9QVF9SRUNPUkRfUFJFRklYICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBjb250cm9sbGVyIG5hbWUgKGNvbnRyb2xsZXJOYW1lKSB0byBzdGFuZGFydGl6aWVkIHByZWZpeENvbnRyb2xsZXJOYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29udHJvbGxlciBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gICAgbm90IGNvbnRyb2xsZXIgbmFtZVxuICAgICAqL1xuICAgIGdldENvbnRyb2xsZXJOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIE9QVF9DT05UUk9MTEVSX1BSRUZJWCArIG5vdENvbW1vbi5jYXBpdGFsaXplRmlyc3RMZXR0ZXIobmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBuYW1lZCBpbnRlcmZhY2UgZmFjdG9yeSBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtb2RlbEZhY3RvcnlcbiAgICAgKiBAcmV0dXJuIHtub3RBcHB9XG4gICAgICogQG1lbWJlcm9mIG5vdEFwcFxuICAgICAqL1xuICAgIHNldEludGVyZmFjZShuYW1lLCBtb2RlbEZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0V29ya2luZyhgaW50ZXJmYWNlcy4ke25hbWV9YCwgbW9kZWxGYWN0b3J5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBuZXR3b3JrIGludGVyZmFjZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhbGwgbmV0d29yayBpbnN0ZXJmYWNlc1xuICAgICAqL1xuICAgIGdldEludGVyZmFjZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJpbnRlcmZhY2VzXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgaW50ZXJmYWNlcyBsaXN0IGNsZWFyXG4gICAgICogQHJldHVybnMge29iamVjdH0gbm90QXBwIGluc3RhbmNlXG4gICAgICovXG4gICAgY2xlYXJJbnRlcmZhY2VzKCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJpbnRlcmZhY2VzXCIsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBXZWJTb2NrZXRzIGNsaWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1ERUZBVUxUX1dTX0NMSUVOVF9OQU1FXSBuYW1lIG9mIGNsaWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB3c2MgIG5vdFdTQ2xpZW50IGluc3RhbmNlXG4gICAgICogQHJldHVybnMge29iamVjdH0gbm90QXBwIGluc3RhbmNlXG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNldFdTQ2xpZW50KG5hbWUgPSBERUZBVUxUX1dTX0NMSUVOVF9OQU1FLCB3c2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0V29ya2luZyhgd3NjLiR7bmFtZX1gLCB3c2MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2ViIHNvY2tldHMgY2xpZW50IGluc3RhbmNlIGJ5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9REVGQVVMVF9XU19DTElFTlRfTkFNRV1cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbnN0YW5jZSBvZiBub3RXU0NsaWVudFxuICAgICAqL1xuICAgIGdldFdTQ2xpZW50KG5hbWUgPSBERUZBVUxUX1dTX0NMSUVOVF9OQU1FKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoYHdzYy4ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBuZXR3b3JrIGludGVyZmFjZSBjbGFzcyBpbml0aWFsaXphdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBuZXR3b3JrIGludGVyZmFjZVxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn0gaW50ZXJmYWNlIGNsYXNzIGluaXRpYWxpemF0b3JcbiAgICAgKi9cbiAgICBnZXRJbnRlcmZhY2UobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmZhY2VzKClbbmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXR3b3JrIGludGVyZmFjZSAobW9kZWwpIGluaXRpYWxpemVkIHdpdGggcHJvdmlkZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGludGVyZmFjZShtb2RlbE5hbWUpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtkYXRhPXt9XSAgICBtb2RlbCBkYXRhXG4gICAgICogQHJldHVybnMgbmV0d29yayBpbnRlcmZhY2UgaW5pdGlhbGl6ZXMgd2l0aCBwcm92aWRlZCBkYXRhXG4gICAgICovXG4gICAgZ2V0TW9kZWwobmFtZSwgZGF0YSA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEludGVyZmFjZShuYW1lKShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHZhbCBzZXJ2aWNlXG4gICAgICovXG4gICAgc2V0U2VydmljZShuYW1lLCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0V29ya2luZyhgc2VydmljZXMuJHtuYW1lfWAsIHZhbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgc2VydmljZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8ZnVuY3Rpb259IHNlcnZpY2VcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhgc2VydmljZXMuJHtuYW1lfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFsbCBwcm92aWRlZCBzZXJ2aWNlc1xuICAgICAqL1xuICAgIGluaXRTZXJ2aWNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInNlcnZpY2VzXCIpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzZXJ2TmFtZSBpbiB0aGlzLmdldE9wdGlvbnMoXCJzZXJ2aWNlc1wiKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXJ2ID0gdGhpcy5nZXRPcHRpb25zKGBzZXJ2aWNlcy4ke3NlcnZOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2VHlwZSA9IG5vdENvbW1vbi5kZXRlY3RUeXBlKHNlcnYpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlcnZUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VydmljZShzZXJ2TmFtZSwgbmV3IHNlcnYodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlcnZpY2Uoc2Vydk5hbWUsIHNlcnYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzPy5lcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgU2VydmljZSAoJHtzZXJ2TmFtZX0pIGluaXQgZXJyb3JgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1vZHVsZSBkZWRpY2F0ZWQgb3B0aW9ucyByZWFkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSAgIG1vZHVsZSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVhZGVyIG9iamVjdCB7Z2V0KHBhdGhUb1ZhbHVlLCBkZWZhdWx0VmFsdWUpfVxuICAgICAqL1xuICAgIGdldENvbmZpZ1JlYWRlckZvck1vZHVsZShtb2R1bGVOYW1lID0gXCJcIikge1xuICAgICAgICBjb25zdCBtb2RDb25mUGF0aCA9IFtcIm1vZHVsZXNcIiwgbW9kdWxlTmFtZV0uam9pbihcIi5cIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IChzdWJQYXRoLCBmYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdWJQYXRoICYmIHR5cGVvZiBzdWJQYXRoID09IFwic3RyaW5nXCIgJiYgc3ViUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFttb2RDb25mUGF0aCwgc3ViUGF0aF0uam9pbihcIi5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMobW9kQ29uZlBhdGgsIGZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kdWxlIGRlZGljYXRlZCBvcHRpb25zIHJlYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kdWxlTmFtZT0nJ10gICBtb2R1bGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJlYWRlciBvYmplY3Qge2dldChwYXRoVG9WYWx1ZSwgZGVmYXVsdFZhbHVlKX1cbiAgICAgKi9cbiAgICBtb2R1bGVDb25maWcobW9kdWxlTmFtZSA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnUmVhZGVyRm9yTW9kdWxlKG1vZHVsZU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IG5vdEFwcDtcbiIsImltcG9ydCBub3RDb21tb24gZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5pbXBvcnQgbm90QmFzZSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBOQVZJR0FUSU9OX0RFTEFZX0RFRkFVTFQgfSBmcm9tIFwiLi9jb25zdC5qc1wiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX0FDVElPTl9OQU1FID0gXCJkZWZhdWx0XCJdICAgICAgZGVmYXVsdCBhY3Rpb24gbmFtZVxuICovXG5jb25zdCBPUFRfREVGQVVMVF9BQ1RJT05fTkFNRSA9IFwiZGVmYXVsdFwiO1xuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfSAgW09QVF9ERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUiA9IFwibWFpbi5jb250ZW50XCJdICBzZWxlY3RvciBvZiBjb250YWluZXIgSFRNTFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCJtYWluLmNvbnRlbnRcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gIFtPUFRfREVGQVVMVF9QTFVSQUxfTkFNRSA9IFwiTW9kZWxzXCJdICBkZWZhdWx0IHBsdXJhbCBuYW1lIG9mIGVudGl0aWVzXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX1BMVVJBTF9OQU1FID0gXCJNb2RlbHNcIjtcblxuLyoqXG4gKiBAY29uc3Qge3N0cmluZ30gIFtPUFRfREVGQVVMVF9TSU5HTEVfTkFNRSA9IFwiTW9kZWxcIl0gIGRlZmF1bHQgc2luZ2xlIG5hbWUgb2YgZW50aXRpZXNcbiAqL1xuY29uc3QgT1BUX0RFRkFVTFRfU0lOR0xFX05BTUUgPSBcIk1vZGVsXCI7XG5cbi8qKlxuICogQGNvbnN0IHtzdHJpbmd9ICBbT1BUX0RFRkFVTFRfTU9EVUxFX05BTUU9XCJtYWluXCJdICBkZWZhdWx0IG1vZHVsZSBuYW1lXG4gKi9cbmNvbnN0IE9QVF9ERUZBVUxUX01PRFVMRV9OQU1FID0gXCJtYWluXCI7XG5cbi8qKlxuICogQGNvbnN0IHtib29sZWFufSAgW09QVF9ERUZBVUxUX0FVVE9fTkFNRSA9IHRydWVdICBpZiBzaG9vdWxkIGJlIHVzZWQgYXV0byBuYW1lIGdlbmVyYXRvclxuICovXG5jb25zdCBPUFRfREVGQVVMVF9BVVRPX05BTUUgPSB0cnVlO1xuXG4vKipcbiAqICBCYXNpYyBjbGFzcyBmb3IgdXNlciBjb250cm9sbGVyXG4gKiAgQGV4dGVuZHMgbm90QmFzZVxuICovXG5jbGFzcyBub3RDb250cm9sbGVyIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgLyoqXG4gICAgICogIEBzdGF0aWMge251bWJlcn0gUEFSQU1TX0xFTkdUSCAgbnVtYmVyIG9mIHBhcmFtcyBpbiBVUkwgcGF0aFxuICAgICAqL1xuICAgIHN0YXRpYyBQQVJBTVNfTEVOR1RIID0gMjtcbiAgICAvKipcbiAgICAgKiAgQHN0YXRpYyB7c3RyaW5nfSBNT0RVTEVfTkFNRSAgbmFtZSBvZiBtb2R1bGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PRFVMRV9OQU1FKCkge1xuICAgICAgICByZXR1cm4gT1BUX0RFRkFVTFRfTU9EVUxFX05BTUU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBAc3RhdGljIHtzdHJpbmd9IE1PREVMX05BTUUgIG5hbWUgb2YgbW9kZWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX05BTUUoKSB7XG4gICAgICAgIHJldHVybiBcIk1vZGVsTmFtZVwiO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTEFCRUxTKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGx1cmFsOiBgJHtPUFRfREVGQVVMVF9NT0RVTEVfTkFNRX06bW9kZWxfbGFiZWxfcGx1cmFsYCxcbiAgICAgICAgICAgIHNpbmdsZTogYCR7T1BUX0RFRkFVTFRfTU9EVUxFX05BTUV9Om1vZGVsX2xhYmVsX3NpbmdsZWAsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSAgICB7b2JqZWN0fG51bGx9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBlbHM7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSAgICB7b2JqZWN0fG51bGx9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBtYWtlO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUgICAge251bGx8aW1wb3J0KCcuL2FwcC5qcycpLmRlZmF1bHR9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBhcHA7XG4gICAgLyoqXG4gICAgICogIEBjbGFzc1xuICAgICAqICBAcGFyYW0ge2ltcG9ydCgnLi9hcHAuanMnKS5kZWZhdWx0fSBhcHBcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgICBuYW1lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBwLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuYXBwLnNldEN1cnJlbnRDb250cm9sbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHJlYWR5OiBmYWxzZSxcbiAgICAgICAgICAgIHZpZXdzOiB7fSxcbiAgICAgICAgICAgIGxpYnM6IHt9LFxuICAgICAgICAgICAgaGVscGVyczoge30sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVpID0ge307XG4gICAgICAgIHRoaXMuZWxzID0ge307XG4gICAgICAgIHRoaXMuc2V0RGF0YSh7fSk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBPUFRfREVGQVVMVF9NT0RVTEVfTkFNRSxcbiAgICAgICAgICAgIGNvbnRhaW5lclNlbGVjdG9yOiBPUFRfREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IsXG4gICAgICAgICAgICBwcmVmaXg6IGFwcC5nZXRPcHRpb25zKFwicGF0aHMubW9kdWxlXCIpLFxuICAgICAgICAgICAgbmFtZXM6IHtcbiAgICAgICAgICAgICAgICBwbHVyYWw6IE9QVF9ERUZBVUxUX1BMVVJBTF9OQU1FLFxuICAgICAgICAgICAgICAgIHNpbmdsZTogT1BUX0RFRkFVTFRfU0lOR0xFX05BTUUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRVUkxQcmVmaXgoYXBwLmdldE9wdGlvbnMoXCJyb3V0ZXIucm9vdFwiKSk7XG4gICAgICAgIC8qXG4gICAgICDRgdGA0LDQt9GDINC00LXQu9Cw0LXQvCDQtNC+0YHRgtGD0L/QvdGL0LzQuCDQvNC+0LTQtdC70Lggbm90UmVjb3JkINC40LcgbmNgQ29udHJvbGxlck5hbWVgINCx0YPQtNGD0YIg0LTQvtGB0YLRg9C/0L3RiyDQutCw0LogdGhpcy5ucmBNb2RlbE5hbWVgXG4gICAgKi9cbiAgICAgICAgbGV0IGludGVyZmFjZXMgPSBhcHAuZ2V0SW50ZXJmYWNlcygpO1xuICAgICAgICB0aGlzLm1ha2UgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCBpbiBpbnRlcmZhY2VzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihpbnRlcmZhY2VzLCB0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFrZVt0XSA9IGludGVyZmFjZXNbdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbihcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hcHAgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgdWlOYW1lIGluIHRoaXMudWkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVpW3VpTmFtZV0uZGVzdHJveSAmJiB0aGlzLnVpW3VpTmFtZV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudWlbdWlOYW1lXS4kZGVzdHJveSAmJiB0aGlzLnVpW3VpTmFtZV0uJGRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVpW3VpTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tYWtlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGN1cnJlbnQgbm90QXBwXG4gICAgICogIEByZXR1cm4ge2ltcG9ydCgnLi9hcHAuanMnKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIGdldEFwcCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBkZWZhdWx0IGNvbnRyb2xsZXIgbW9kZWxcbiAgICAgKiAgQHBhcmFtIHtpbXBvcnQoJy4vcmVjb3JkLmpzJyl9ICBtb2RlbCAgbm90UmVjb3JkIGludGVyZmFjZSBvYmplY3RcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn1cbiAgICAgKi9cbiAgICBzZXRNb2RlbChtb2RlbCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJtb2RlbFwiLCBtb2RlbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBJZiB6ZXJvIG9yIG9uZSBhcmd1bWVudCBwcm92aWRlZCB0aGlzIG1vZGVsTmFtZSBpbnN0YW5jZSB3aWxsIGJlIHJldHVybmVkXG4gICAgICogIElmIHR3byBwcm92aWRlZCBhbmQgZmlyc3QgaXMgYSBzdHJpbmcgdGhhbiBpbnN0YW5jZSBvZiBuYW1lIHdpbGwgYmUgcmV0dXJuZWQgaW5pdGlhbGl6ZWQgd2l0aCBzZWNvbmQgb2JqZWN0IHBhcmFtIG9yIGVtcHR5IG9iamVjdFxuICAgICAqICBAcGFyYW0ge3N0cmluZ3xvYmplY3R9ICAgICAgW25hbWVdICAgIG1vZGVsTmFtZSBvZiBpbnN0YW5jZSB0byByZXR1cm4gb3IgaW5pdGlhbCBkYXRhIGZvciBpbnN0YW5jZVxuICAgICAqICBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgW2RhdGFdICAgIG1vZGVsIGRhdGFcbiAgICAgKiAgQHJldHVybiB7aW1wb3J0KCcuL3JlY29yZC5qcycpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZ2V0TW9kZWwobmFtZSwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGludCA9IHRoaXMuZ2V0SW50ZXJmYWNlKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGludCAmJiBpbnQoZGF0YSB8fCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbnQgPSB0aGlzLmdldEludGVyZmFjZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGludCAmJiBpbnQobmFtZSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2xsZXIgaW50ZXJmYWNlIGlmIG5hbWUgaXMgbm90IHNwZWNpZmllZCBvciBpbnRlcmZhY2Ugb2Ygc3BlY2lmaWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9XCJcIl1cbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBtZW1iZXJvZiBub3RDb250cm9sbGVyXG4gICAgICovXG4gICAgZ2V0SW50ZXJmYWNlKG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcD8uZ2V0SW50ZXJmYWNlKG5hbWUgfHwgdGhpcy5nZXRNb2RlbE5hbWUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgY3VycmVudCBtb2RlbCBuYW1lXG4gICAgICogIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRNb2RlbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJtb2RlbE5hbWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTZXRzIGRlZmF1bHQgY29udHJvbGxlciBtb2RlbCBuYW1lXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgbW9kZWxOYW1lICBub3RSZWNvcmQgaW50ZXJmYWNlIG9iamVjdFxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfVxuICAgICAqL1xuICAgIHNldE1vZGVsTmFtZShtb2RlbE5hbWUpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwibW9kZWxOYW1lXCIsIG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKG1vZGVsTmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBjdXJyZW50IG1vZGVsIHByaW1hcnkgSUQgZmllbGQgbmFtZVxuICAgICAqICBAcmV0dXJuIHtpbXBvcnQoJy4vcmVjb3JkLmpzJyl9XG4gICAgICovXG4gICAgZ2V0TW9kZWxJREZpZWxkTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm1vZGVsSURGaWVsZE5hbWVcIiwgXCJfaWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgY3VycmVudCBtb2RlbCBwcmltYXJ5IElEIGZpZWxkIG5hbWVcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn1cbiAgICAgKi9cbiAgICBzZXRNb2RlbElERmllbGROYW1lKHZhbCA9IFwiX2lkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0V29ya2luZyhcIm1vZGVsSURGaWVsZE5hbWVcIiwgdmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgTWFya3MgdGhpcyBjb250cm9sbGVyIGFzIHJlYWR5XG4gICAgICogIGVtaXRzIFwicmVhZHlcIi9cImJ1c3lcIiBldmVudHNcbiAgICAgKiAgQHBhcmFtIHtCb29sZWFufSAgdmFsICB0cnVlL2ZhbHNlXG4gICAgICovXG4gICAgc2V0UmVhZHkodmFsID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJyZWFkeVwiLCB2YWwpO1xuICAgICAgICB2YWwgPyB0aGlzLmVtaXQoXCJyZWFkeVwiKSA6IHRoaXMuZW1pdChcImJ1c3lcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgbW9kdWxlIFVSTCBwcmVmaXhcbiAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbCBVUkwgcHJlZml4XG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRVUkxQcmVmaXgodmFsKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcInVybFByZWZpeFwiLCB2YWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF1dG9OYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG1vZHVsZSB1cmwgcHJlZml4XG4gICAgICogIEByZXR1cm4gIHtzdHJpbmd9IHByZWZpeFxuICAgICAqL1xuICAgIGdldFVSTFByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcInVybFByZWZpeFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyBtb2R1bGUgbmFtZVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmFsIG5hbWUgb2YgdGhlIG1vZHVsZVxuICAgICAqICBAcmV0dXJuIHtub3RDb250cm9sbGVyfSB0aGlzXG4gICAgICovXG4gICAgc2V0TW9kdWxlTmFtZSh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwibW9kdWxlTmFtZVwiLCBub3RDb21tb24ubG93ZXJGaXJzdExldHRlcih2YWwpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdXRvTmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIG5hbWVcbiAgICAgKiAgQHJldHVybiAge3N0cmluZ30gbW9kdWxlIG5hbWVcbiAgICAgKi9cbiAgICBnZXRNb2R1bGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibW9kdWxlTmFtZVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGlzIG1vZHVsZSBwYXRoIHByZWZpeFxuICAgICAqICBAcmV0dXJuIHtzdHJpbmd9ICBwYXRoIHRvIG1vZHVsZSBkaXJcbiAgICAgKi9cbiAgICBnZXRNb2R1bGVQcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBub3RDb21tb24uZ2V0QXBwKCkuZ2V0T3B0aW9ucyhcInBhdGhzLm1vZHVsZXNcIiksXG4gICAgICAgICAgICB0aGlzLmdldE1vZHVsZU5hbWUoKSxcbiAgICAgICAgXS5qb2luKFwiL1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0aGlzIG1vZGVsIFVSTCB3aXRoIFVSTCBwcmVmaXhcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfSAgdXJsIHBhdGhcbiAgICAgKi9cbiAgICBnZXRNb2RlbFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5idWlsZFVSTCh7XG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMuZ2V0VVJMUHJlZml4KCksXG4gICAgICAgICAgICBtb2R1bGU6IHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoaXMgbW9kZWwgYWN0aW9uIFVSTCB3aXRoIFVSTCBwcmVmaXhcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWQgICAgICAgc29tZSBpZGVudGlmaWNhdG9yIG9mIG1vZGVsXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIGFjdGlvbiAgIGFjdGlvbiBuYW1lXG4gICAgICogIEByZXR1cm4ge3N0cmluZ30gIHVybCBwYXRoXG4gICAgICovXG4gICAgZ2V0TW9kZWxBY3Rpb25VUkwoaWQsIGFjdGlvbiA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5idWlsZFVSTCh7XG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMuZ2V0VVJMUHJlZml4KCksXG4gICAgICAgICAgICBtb2R1bGU6IHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxOYW1lKCksXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB1cmwgZnJvbSB2YWx1ZSBjb250ZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICB2YWxcbiAgICAgKiovXG4gICAgYnVpbGRVUkwodmFsKSB7XG4gICAgICAgIHJldHVybiBub3RDb21tb24uYnVpbGRVUkwodmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgVXBkYXRlcyB3b3JraW5nIG5hbWVcbiAgICAgKiAgQHJldHVybiB7bm90Q29udHJvbGxlcn0gdGhpc1xuICAgICAqL1xuICAgIHVwZGF0ZUF1dG9OYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwiYXV0b05hbWVcIiwgT1BUX0RFRkFVTFRfQVVUT19OQU1FKSkge1xuICAgICAgICAgICAgLy90aGlzLnNldFdvcmtpbmcoJ25hbWUnLCB0aGlzLmdldE1vZGVsVVJMKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIG9iamVjdCBuYW1lXG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgbmFtZSBvZiB0aGUgb2JqZWN0XG4gICAgICogIEByZXR1cm4ge25vdENvbnRyb2xsZXJ9IHRoaXNcbiAgICAgKi9cbiAgICBzZXROYW1lKHZhbCkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJuYW1lXCIsIHZhbCk7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcImF1dG9OYW1lXCIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEdldHMgb2JqZWN0IG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJuYW1lXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBQcmVsb2FkIHJlY29yZHMgZnJvbSBzZXJ2ZXIsIHVzaW5nIGxpc3RBbGwgbWV0aG9kLFxuICAgICAqICByZXR1cm5zIFByb21pc2VcbiAgICAgKiAgQHBhcmFtIHtvYmplY3R9ICBsaXN0ICBtYXAgb2YgcHJlbG9hZGVkIHJlY29yZHNcbiAgICAgKiAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBwcmVsb2FkTGliKGxpc3QgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJsb2FkaW5nXCIsIFtdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0IGluIGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwibG9hZGluZ1wiKS5wdXNoKGxpc3RbdF0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VbbGlzdFt0XV0oe30pXG4gICAgICAgICAgICAgICAgICAgICAgICAuJGxpc3RBbGwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0T3B0aW9ucyhcImxpYnNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKFwibGlic1wiLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImxpYnNcIilbdF0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwibG9hZGluZ1wiKS5pbmRleE9mKGxpc3RbdF0pID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwibG9hZGluZ1wiKS5zcGxpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmluZGV4T2YobGlzdFt0XSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFdvcmtpbmcoXCJsb2FkaW5nXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnQoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRXb3JraW5nKFwibG9hZGluZ1wiKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW1pdHMgYWZ0ZXJSZW5kZXIgZXZlbnRcbiAgICAgKi9cbiAgICBvbkFmdGVyUmVuZGVyKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJhZnRlclJlbmRlclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgVHJhbnNmb3JtIHJvdXRlIG5hbWUgaW4gYWN0aW9uIG5hbWVcbiAgICAgKiAgQHBhcmFtIHtTdHJpbmd9ICAgbmFtZSB0cmFuZm9ybSBhY3Rpb24gbmFtZVxuICAgICAqICBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QWN0aW9uTmFtZShuYW1lID0gT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIFwicnVuXCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBHZXQgZGVmYXVsdCBjb250cm9sbGVyIGFjdGlvbiBuYW1lXG4gICAgICogIEByZXR1cm4ge1N0cmluZ30gZGVmYXVsdCBhY3Rpb24gZnJvbSBvcHRpb25zXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGlvbk5hbWUoXG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJkZWZhdWx0QWN0aW9uXCIsIE9QVF9ERUZBVUxUX0FDVElPTl9OQU1FKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSb3V0ZSBwYXJhbXMgaW50byBzcGVjaWZpYyBydW5bUm91dGVfbmFtZV0gZnVuY3Rpb25cbiAgICAgKiAgQHBhcmFtIHthcnJheX0gICBwYXJhbXMgICBjb250cm9sbGVyIGlucHV0IHBhcmFtc1xuICAgICAqICBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgcm91dGUocGFyYW1zKSB7XG4gICAgICAgIGxldCBbcm91dGVyTmFtZSwgLi4uc3ViUGFyYW1zXSA9IHBhcmFtcyxcbiAgICAgICAgICAgIGFjdGlvbk5hbWUgPSB0aGlzLmdldEFjdGlvbk5hbWUoXG4gICAgICAgICAgICAgICAgcm91dGVyTmFtZSA/IHJvdXRlck5hbWUgOiBPUFRfREVGQVVMVF9BQ1RJT05fTkFNRVxuICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2FjdGlvbk5hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudEFjdGlvbihhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHRoaXNbYWN0aW9uTmFtZV0oc3ViUGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW3RoaXMuZ2V0RGVmYXVsdEFjdGlvbk5hbWUoKV0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudEFjdGlvbih0aGlzLmdldERlZmF1bHRBY3Rpb25OYW1lKCkpO1xuICAgICAgICAgICAgdGhpc1t0aGlzLmdldERlZmF1bHRBY3Rpb25OYW1lKCldKHN1YlBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRBY3Rpb24odW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiYgdGhpcy5lcnJvcihcIk5vIGFjdGlvbiBpbiByb3V0ZXJcIiwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgd29ya2luZyBhY3Rpb25cbiAgICAgKiBAcGFyYW1zIHtzdHJpbmd9IGFjdGlvbk5hbWUgY3VycmVudCBhY3Rpb24gbmFtZVxuICAgICAqL1xuICAgIHNldEN1cnJlbnRBY3Rpb24oYWN0aW9uTmFtZSkge1xuICAgICAgICB0aGlzLnNldFdvcmtpbmcoXCJhY3Rpb25cIiwgYWN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB3b3JraW5nIGFjdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGN1cnJlbnQgYWN0aW9uIG5hbWVcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50QWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwiYWN0aW9uXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gYXBwbGljYXRpb24gb3B0aW9uc1xuICAgICAqICBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0QXBwT3B0aW9ucygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcCgpLmdldE9wdGlvbnMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJldHVybnMgbW9kdWxlIG9wdGlvbnNcbiAgICAgKiAgQHBhcmFtICB7c3RyaW5nfSAgIFttb2R1bGVOYW1lXSAgICBuYW1lIG9mIHRoZSBtb2R1bGUgd2hpY2ggb3B0aW9ucyByZXF1ZXN0ZWRcbiAgICAgKiAgQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuXG4gICAgZ2V0TW9kdWxlT3B0aW9ucyhtb2R1bGVOYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBcHAoKS5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgIFtcIm1vZHVsZXNcIiwgbW9kdWxlTmFtZSB8fCB0aGlzLmdldE1vZHVsZU5hbWUoKV0uam9pbihcIi5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiYgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG1vZHVsZSBzZXJ2aWNlc1xuICAgICAqICBAcGFyYW0gIHtzdHJpbmd9ICAgbW9kdWxlTmFtZSAgICBuYW1lIG9mIHRoZSBtb2R1bGUgd2hpY2ggc2VydmljZXMgcmVxdWVzdGVkXG4gICAgICogIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cblxuICAgIGdldFNlcnZpY2VzKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcCgpLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgW1wic2VydmljZXNcIiwgbW9kdWxlTmFtZSB8fCB0aGlzLmdldE1vZHVsZU5hbWUoKV0uam9pbihcIi5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgJiYgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIG1vZHVsZSBjb21wb25lbnRzXG4gICAgICogIEBwYXJhbSAge3N0cmluZ30gICBtb2R1bGVOYW1lICAgIG5hbWUgb2YgdGhlIG1vZHVsZSB3aGljaCBjb21wb25lbnRzIHJlcXVlc3RlZFxuICAgICAqICBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG5cbiAgICBnZXRDb21wb25lbnRzKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcCgpLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgW1wiY29tcG9uZW50c1wiLCBtb2R1bGVOYW1lIHx8IHRoaXMuZ2V0TW9kdWxlTmFtZSgpXS5qb2luKFwiLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFJlZnJlc2hlcyBjdXJyZW50IFVSTCwgcmUtcnVuIGFsbCBhY3Rpb25cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgdGltZSB0byB3YWl0IGluIG1zXG4gICAgICovXG4gICAgcmVmcmVzaCh0aW1lb3V0ID0gMCkge1xuICAgICAgICB0aGlzLmFwcD8uZ2V0V29ya2luZyhcInJvdXRlclwiKS5yZWZyZXNoKHRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGF0aCBwYXR0ZXJuIGZvciByb3V0ZXJcbiAgICAgKiBAcGFyYW1zIHtudW1iZXJ9IFswXSBwYXJhbXNDb3VudCAgIG51bWJlciBvZiBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICBwYXR0ZXJuIGZvciBjb250cm9sbGVyIHN1cHBvcnRlZCB1cmxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29udHJvbGxlclJvdXRlKHBhcmFtc0NvdW50ID0gMCkge1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5NT0RVTEVfTkFNRSAmJiB0aGlzLk1PRFVMRV9OQU1FLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub3RDb21tb24ubG93ZXJGaXJzdExldHRlcih0aGlzLk1PRFVMRV9OQU1FKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuTU9ERUxfTkFNRSAmJiB0aGlzLk1PREVMX05BTUUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHRoaXMuTU9ERUxfTkFNRSkpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBbcGF0aC5qb2luKFwiL1wiKV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiLyhbXi9dKylcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBhdGggcGF0dGVybnMgZm9yIHJvdXRlclxuICAgICAqIEBwYXJhbXMge251bWJlcn0gWzBdIHBhcmFtc0RlZXAgICBob3cgbWFueSBwYXRocyB3aXRoIHBhcmFtcyBpbiB0aGUgZW5kXG4gICAgICogQHJldHVybiB7c3RyaW5nW119ICBwYXR0ZXJucyBmb3IgY29udHJvbGxlciBzdXBwb3J0ZWQgdXJsIGluIG9yZGVyIG9mIHNpbXBsaWZpY2F0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldENvbnRyb2xsZXJSb3V0ZXMocGFyYW1zRGVlcCA9IDApIHtcbiAgICAgICAgbGV0IHJvdXRlcyA9IFt0aGlzLmdldENvbnRyb2xsZXJSb3V0ZSgwKV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zRGVlcDsgaSsrKSB7XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdCh0aGlzLmdldENvbnRyb2xsZXJSb3V0ZShpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3V0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByb3V0ZXIgcnVsZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByb3V0ZXIgcnVsZSB7cGF0aHM6U3RyaW5nW10sIGNvbnRyb2xsZXI6bm90Q29udHJvbGxlcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um91dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aHM6IHRoaXMuZ2V0Q29udHJvbGxlclJvdXRlcyh0aGlzLlBBUkFNU19MRU5HVEgpLFxuICAgICAgICAgICAgY29udHJvbGxlcjogdGhpcyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEFwcGxpY2F0aW9uIHJvdXRlclxuICAgICAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcm91dGVyLmpzJykuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBnZXRSb3V0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcD8uZ2V0V29ya2luZyhcInJvdXRlclwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGxvY2F0aW9uIHRvIGB1cmxgIGFmdGVyIGBkZWxheWAgbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgIGRlbGF5ICAgbnVtYmVyIGluIG1zIG9yIG5hbWUgb2YgZGVsYXlcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZVdpdGhEZWxheShcbiAgICAgICAgdXJsLFxuICAgICAgICBkZWxheSA9IE5BVklHQVRJT05fREVMQVlfREVGQVVMVCxcbiAgICAgICAgZG9CZWZvcmUgPSAoKSA9PiB7fVxuICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZXIoKS5uYXZpZ2F0ZVdpdGhEZWxheSh1cmwsIGRlbGF5LCBkb0JlZm9yZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBsb2NhdGlvbiB0byBgdXJsYFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZSh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVyKCkubmF2aWdhdGUodXJsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgTmF2aWdhdGluZyB0byB0aGlzIGNvbnRyb2xsZXIgbWFpbiBtb2RlbCBgYWN0aW9uYCB3aXRoIHByb3ZpZGVkIGBpZGAsXG4gICAgICogIGVtcHR5IGBpZGAgd2lsbCBiZSBkcm9wcGVkIGZyb20gcmVzdWx0aW5nIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb249XCJcIl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdICAgICAgICAgICAgZGVsYXkgaW4gbXMgYmVmb3JlIG5hdmlnYXRlXG4gICAgICogQHBhcmFtICAge2Z1bmN0aW9ufSAgW2RvQmVmb3JlXSAgICAgIHdpbGwgZXhlY3V0ZWQgb25seSBpZiBkZWxheWVkIGFmdGVyIGRlbGF5IGJ1dCBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBtZW1iZXJvZiBub3RDb250cm9sbGVyXG4gICAgICovXG4gICAgbmF2aWdhdGVBY3Rpb24oaWQsIGFjdGlvbiA9IFwiXCIsIGRlbGF5ID0gMCwgZG9CZWZvcmUgPSAoKSA9PiB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZU1vZHVsZUFjdGlvbihcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kdWxlTmFtZSgpLFxuICAgICAgICAgICAgdGhpcy5nZXRNb2RlbE5hbWUoKSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkb0JlZm9yZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBOYXZpZ2F0aW5nIHRvIHRoaXMgY29udHJvbGxlciBtb2R1bGUgbW9kZWwgb2YgYG1vZGVsTmFtZWAgYGFjdGlvbmAgd2l0aCBwcm92aWRlZCBgaWRgLFxuICAgICAqICBlbXB0eSBgaWRgIHdpbGwgYmUgZHJvcHBlZCBmcm9tIHJlc3VsdGluZyB1cmxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2FjdGlvbj1cIlwiXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gICAgICAgICAgICBkZWxheSBpbiBtcyBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcGFyYW0gICB7ZnVuY3Rpb259ICBbZG9CZWZvcmVdICAgICAgd2lsbCBleGVjdXRlZCBvbmx5IGlmIGRlbGF5ZWQgYWZ0ZXIgZGVsYXkgYnV0IGJlZm9yZSBuYXZpZ2F0ZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQG1lbWJlcm9mIG5vdENvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZU1vZGVsQWN0aW9uKFxuICAgICAgICBtb2RlbE5hbWUsXG4gICAgICAgIGlkLFxuICAgICAgICBhY3Rpb24gPSBcIlwiLFxuICAgICAgICBkZWxheSA9IDAsXG4gICAgICAgIGRvQmVmb3JlID0gKCkgPT4ge31cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGVNb2R1bGVBY3Rpb24oXG4gICAgICAgICAgICB0aGlzLmdldE1vZHVsZU5hbWUoKSxcbiAgICAgICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkb0JlZm9yZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBOYXZpZ2F0aW5nIHRvIGBtb2R1bGVOYW1lYCBgbW9kZWxOYW1lYCBgYWN0aW9uYCB3aXRoIHByb3ZpZGVkIGBpZGAsXG4gICAgICogIGVtcHR5IGBpZGAgd2lsbCBiZSBkcm9wcGVkIGZyb20gcmVzdWx0aW5nIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW9kZWxOYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthY3Rpb249XCJcIl1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdICAgICAgICAgICAgZGVsYXkgaW4gbXMgYmVmb3JlIG5hdmlnYXRlXG4gICAgICogQHBhcmFtICAge2Z1bmN0aW9ufSAgW2RvQmVmb3JlXSAgICAgIHdpbGwgZXhlY3V0ZWQgb25seSBpZiBkZWxheWVkIGFmdGVyIGRlbGF5IGJ1dCBiZWZvcmUgbmF2aWdhdGVcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqIEBtZW1iZXJvZiBub3RDb250cm9sbGVyXG4gICAgICovXG4gICAgbmF2aWdhdGVNb2R1bGVBY3Rpb24oXG4gICAgICAgIG1vZHVsZU5hbWUsXG4gICAgICAgIG1vZGVsTmFtZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGlvbiA9IFwiXCIsXG4gICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgZG9CZWZvcmUgPSAoKSA9PiB7fVxuICAgICkge1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJvdXRlcigpLm5hdmlnYXRlV2l0aERlbGF5KFxuICAgICAgICAgICAgICAgIG5vdENvbW1vbi5idWlsZFVSTCh7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeDogdGhpcy5nZXRVUkxQcmVmaXgoKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBtb2R1bGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogbW9kZWxOYW1lLFxuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgICAgIGRvQmVmb3JlXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVyKCkubmF2aWdhdGUoXG4gICAgICAgICAgICAgICAgbm90Q29tbW9uLmJ1aWxkVVJMKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiB0aGlzLmdldFVSTFByZWZpeCgpLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBtb2RlbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG1lbnUgaXRlbSBmcm9tIGNoaWxkIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtub3RDb250cm9sbGVyfSBjaGlsZENvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KCcuL3R5cGVzLmpzJykuTmF2aWdhdGlvbkl0ZW0+fVxuICAgICAqIEBtZW1iZXJvZiBub3RDb250cm9sbGVyXG4gICAgICovXG4gICAgc3RhdGljIGdldENvbW1vbk1lbnUoY2hpbGRDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBzZWN0aW9uOiBjaGlsZENvbnN0cnVjdG9yLk1PRFVMRV9OQU1FLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aXRsZTogY2hpbGRDb25zdHJ1Y3Rvci5MQUJFTFMucGx1cmFsLFxuICAgICAgICAgICAgICAgIHVybDogYC8ke25vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ29uc3RydWN0b3IuTU9EVUxFX05BTUVcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICl9LyR7bm90Q29tbW9uLmxvd2VyRmlyc3RMZXR0ZXIoY2hpbGRDb25zdHJ1Y3Rvci5NT0RFTF9OQU1FKX1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TWVudSgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdENvbnRyb2xsZXI7XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblxuY29uc3QgQUxMID0ge307XG5cbmZ1bmN0aW9uIGV4aXN0KGtleSkge1xuICAgIHJldHVybiBPYmplY3QuaGFzT3duKEFMTCwga2V5KTtcbn1cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChleGlzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBBTExba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUoXG4gICAga2V5LFxuICAgIHByb3BzID0ge1xuICAgICAgICByYXc6IFtdLFxuICAgICAgICBmaWx0ZXJlZDogW10sXG4gICAgICAgIHNlbGVjdGVkOiB7fSxcbiAgICB9XG4pIHtcbiAgICBpZiAoIWV4aXN0KGtleSkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBBTExba2V5XSA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBBTExba2V5XVtuYW1lXSA9IHdyaXRhYmxlKHByb3BzW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RvcmUncyBwcm9wcyB3YXNuJ3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBTExba2V5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIG9iamVjdCB0aGF0IGlzIGZha2UgU3RvcmVcbiAqIFNvbWUgdGltZSB0aGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGluaXRpYWxpemUgbG9jYWwgdmFyLFxuICogYmVmb3JlIHlvdSBjb3VsZCBnZXQgYWN0dWFsIFN0b3JlcyBmcm9tIGNlbnRyYWwgc3RvcmFnZSBieSBpdHMgSURcbiAqXHRAcGFyYW1zIHttaXhlZH0gdmFsIFx0ZGF0YSBvZiB0eXBlIHRoYXQgaXMgYWN0dWFsIHN0b3JhZ2Ugd2lsbCBjb250YWluXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGZha2UodmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlKGYpIHtcbiAgICAgICAgICAgIGYodmFsKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KCkge30sXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlLCBnZXQsIGZha2UgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCAnYnVsbWEtc3dpdGNoJztcblxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF1cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsdWVdXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmllbGRuYW1lXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkaXNhYmxlZF1cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3R5bGluZ11cbiAgICovXG5cbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgbGV0IHtcbiAgICAgIGlkID0gJycsXG4gICAgICB2YWx1ZSA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICBmaWVsZG5hbWUgPSAnc3dpdGNoJyxcbiAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgc3R5bGluZyA9IFwiIGlzLXJvdW5kZWQgaXMtc3VjY2VzcyBcIlxuICB9ID0gJHByb3BzKCk7XG5cbmZ1bmN0aW9uIG9uSW5wdXQoZXYpe1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgZmllbGQ6IGZpZWxkbmFtZSxcbiAgICAgICAgdmFsdWU6IGV2LnRhcmdldC50eXBlID09PSAnY2hlY2tib3gnID8gZXYudGFyZ2V0LmNoZWNrZWQ6ZXYudGFyZ2V0LnZhbHVlXG4gICAgfTtcbiAgICBkaXNwYXRjaCgnY2hhbmdlJywgZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbjwvc2NyaXB0PlxuXG48aW5wdXQgdHlwZT1cImNoZWNrYm94XCJcbiAgY2xhc3M9XCJzd2l0Y2gge3N0eWxpbmd9XCJcbiAgaWQ9XCJlZGl0LXRhYmxlLXJvdy1jZWxsLWlubGluZS1zd2l0Y2gte2ZpZWxkbmFtZX0te2lkfVwiXG4gIGJpbmQ6Y2hlY2tlZD17dmFsdWV9XG4gIG5hbWU9XCJ7ZmllbGRuYW1lfVwiXG4gIHtyZWFkb25seX0ge2Rpc2FibGVkfVxuICBvbmlucHV0PXtvbklucHV0fVxuICAvPlxuPGxhYmVsIGNsYXNzPVwibGFiZWxcIiBmb3I9XCJlZGl0LXRhYmxlLXJvdy1jZWxsLWlubGluZS1zd2l0Y2gte2ZpZWxkbmFtZX0te2lkfVwiPjwvbGFiZWw+XG4iLCI8c2NyaXB0PlxuICAgIC8qXG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuKi9cbiAgICBcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICogQHByb3BlcnR5IHthbnl9IFt2YWx1ZXNdIC0gaXRlbSA9IHtcbmlkLCAgICAgICAgLy91bmlxdWVcbnRpdGxlLCAgICAgLy9zb21lIHRleHRcbnZhbHVlLCAgICAgIC8vZm9yIGRvdWJsZSB0YWdzXG5jb2xvciAgICAgICAvL2NvbG9yaW5nXG59XG4gICAqL1xuXG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGxldCB7IHZhbHVlcyA9IFtdIH0gPSAkcHJvcHMoKTtcbjwvc2NyaXB0PlxuXG57I2VhY2ggdmFsdWVzIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgIHsjaWYgT2JqZWN0Lmhhc093bihpdGVtLCBcInZhbHVlXCIpfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibXgtMSB0YWdzIGhhcy1hZGRvbnNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGFnXCI+e2l0ZW0udGl0bGV9PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0YWcgaXMte2l0ZW0uY29sb3J9IHtpdGVtLmN1c3RvbUNsYXNzZXN9XCI+XG4gICAgICAgICAgICAgICAgeyNpZiBpdGVtLnVybH1cbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17aXRlbS51cmx9IGNsYXNzPXtpdGVtLnVybEN1c3RvbUNsYXNzZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICA+e2l0ZW0udmFsdWV9PC9hXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIHtpdGVtLnZhbHVlfVxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJteC0xIHRhZyBpcy17aXRlbS5jb2xvcn0ge2l0ZW0uY3VzdG9tQ2xhc3Nlc31cIj5cbiAgICAgICAgICAgIHsjaWYgaXRlbS51cmx9XG4gICAgICAgICAgICAgICAgPGEgaHJlZj17aXRlbS51cmx9IGNsYXNzPXtpdGVtLnVybEN1c3RvbUNsYXNzZXN9PntpdGVtLnRpdGxlfTwvYVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICB7aXRlbS50aXRsZX1cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvc3Bhbj5cbiAgICB7L2lmfVxuey9lYWNofVxuXG48c3R5bGU+XG4gICAgLnRhZ3M6bm90KDpsYXN0LWNoaWxkKSB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IG5vbmU7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIGxldCB0aXRsZSA9ICRzdGF0ZShcIlwiKTtcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkLnR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkLCBcInRpdGxlUGF0aFwiKSkge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gbm90UGF0aC5nZXQoZmllbGQudGl0bGVQYXRoLCBpdGVtLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgT2JqZWN0Lmhhc093bihmaWVsZCwgXCJ0aXRsZUNvbXBvc2VyXCIpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGZpZWxkLnRpdGxlQ29tcG9zZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBmaWVsZC50aXRsZUNvbXBvc2VyKGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IG5vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb25cIjtcblxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi8uLi9sb2NhbGVcIjtcblxuICAgIGltcG9ydCBVSUJ1dHRvbnMgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2J1dHRvbi91aS5idXR0b25zLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUxpbmtzIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9saW5rL3VpLmxpbmtzLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUltYWdlcyBmcm9tIFwiLi4vLi4vLi4vZWxlbWVudHMvaW1hZ2UvdWkuaW1hZ2VzLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUJvb2xlYW5zIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmJvb2xlYW5zLnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IFRhYmxlU3dpdGNoIGZyb20gXCIuL2NvbnRyb2xzL3VpLnN3aXRjaC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVGFibGVUYWdzIGZyb20gXCIuL2NvbnRyb2xzL3VpLnRhZ3Muc3ZlbHRlXCI7XG5cbiAgICBsZXQge1xuICAgICAgICBnZXRJdGVtSWQgPSAoaXRlbSkgPT4gaXRlbS5faWQsXG4gICAgICAgIGZpZWxkID0ge30sXG4gICAgICAgIGl0ZW0gPSB7fSxcbiAgICAgICAgaGVscGVycyA9IHt9XG4gICAgfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbjx0ZFxuICAgIGNsYXNzPXsoZmllbGQuaGlkZU9uTW9iaWxlID8gXCIgaXMtaGlkZGVuLXRvdWNoIFwiIDogXCJcIikgK1xuICAgICAgICAoZmllbGQuY2xhc3NlcyA/IGAgJHtmaWVsZC5jbGFzc2VzfSBgIDogXCJcIil9XG4gICAge3RpdGxlfVxuPlxuICAgIHsjaWYgZmllbGQudHlwZSA9PT0gXCJsaW5rXCJ9XG4gICAgICAgIDxVSUxpbmtzIHZhbHVlcz17bm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyl9IC8+XG4gICAgezplbHNlIGlmIGZpZWxkLnR5cGUgPT09IFwiYnV0dG9uXCJ9XG4gICAgICAgIDxVSUJ1dHRvbnMgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJpbWFnZVwifVxuICAgICAgICA8VUlJbWFnZXMgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJib29sZWFuXCJ9XG4gICAgICAgIDxVSUJvb2xlYW5zIHZhbHVlcz17bm90UGF0aC5nZXQoZmllbGQucGF0aCwgaXRlbSwgaGVscGVycyl9IC8+XG4gICAgezplbHNlIGlmIGZpZWxkLnR5cGUgPT09IFwidGFnXCJ9XG4gICAgICAgIDxUYWJsZVRhZ3MgdmFsdWVzPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX0gLz5cbiAgICB7OmVsc2UgaWYgZmllbGQudHlwZSA9PT0gXCJzd2l0Y2hcIn1cbiAgICAgICAgPFRhYmxlU3dpdGNoXG4gICAgICAgICAgICBpZD17Z2V0SXRlbUlkKGl0ZW0pfVxuICAgICAgICAgICAgZmllbGRuYW1lPXtmaWVsZC5wYXRofVxuICAgICAgICAgICAgb246Y2hhbmdlPXtmaWVsZC5vbkNoYW5nZX1cbiAgICAgICAgICAgIHZhbHVlPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmaWVsZC5kaXNhYmxlZH1cbiAgICAgICAgICAgIHJlYWRvbmx5PXtmaWVsZC5yZWFkb25seX1cbiAgICAgICAgLz5cbiAgICB7OmVsc2UgaWYgZmllbGQuY29tcG9uZW50fVxuICAgICAgICA8ZmllbGQuY29tcG9uZW50XG4gICAgICAgICAgICBpZD17Z2V0SXRlbUlkKGl0ZW0pfVxuICAgICAgICAgICAgb246Y2hhbmdlPXtmaWVsZC5vbkNoYW5nZX1cbiAgICAgICAgICAgIGZpZWxkbmFtZT17ZmllbGQucGF0aH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmaWVsZC5kaXNhYmxlZH1cbiAgICAgICAgICAgIHJlYWRvbmx5PXtmaWVsZC5yZWFkb25seX1cbiAgICAgICAgICAgIHZhbHVlPXtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKX1cbiAgICAgICAgICAgIHsuLi5maWVsZC5vcHRpb25zfVxuICAgICAgICAvPlxuICAgIHs6ZWxzZSBpZiBmaWVsZCAmJiB0eXBlb2YgZmllbGQgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzTmFOKGZpZWxkLm1heExlbmd0aCkgJiYgZmllbGQubWF4TGVuZ3RofVxuICAgICAgICB7bm90Q29tbW9uLnN0ckxlbmd0aENhcChcbiAgICAgICAgICAgIG5vdFBhdGguZ2V0KGZpZWxkLnBhdGgsIGl0ZW0sIGhlbHBlcnMpLFxuICAgICAgICAgICAgZmllbGQubWF4TGVuZ3RoXG4gICAgICAgICl9XG4gICAgezplbHNlfVxuICAgICAgICB7JExPQ0FMRVtub3RQYXRoLmdldChmaWVsZC5wYXRoLCBpdGVtLCBoZWxwZXJzKV19XG4gICAgey9pZn1cbjwvdGQ+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgVUlUYWJsZUNlbGwgZnJvbSAnLi9ub3RUYWJsZUNlbGwuc3ZlbHRlJztcbiAgaW1wb3J0ICogYXMgU3RvcmVzIGZyb20gJy4vc3RvcmVzLmpzJztcbiAgXG4gIGltcG9ydCB7b25Nb3VudCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyfSBmcm9tICdzdmVsdGUnO1xuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBsZXQgaXRlbUlkID0gJHN0YXRlKCksIHNlbGVjdGVkTGlzdDtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICAgIGl0ZW1JZCA9IGdldEl0ZW1JZChpdGVtKTtcbiAgICAgIHNlbGVjdGVkTGlzdCA9IFN0b3Jlcy5nZXQoaWQpLnNlbGVjdGVkO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge2FueX0gaWRcbiAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtXVxuICAgKiBAcHJvcGVydHkge2FueX0gW2hlbHBlcnNdXG4gICAqIEBwcm9wZXJ0eSB7YW55fSBbZmllbGRzXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93U2VsZWN0XVxuICAgKiBAcHJvcGVydHkge2FueX0gW2dldEl0ZW1JZF1cbiAgICovXG5cbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgbGV0IHtcbiAgICAgIGlkLFxuICAgICAgaXRlbSA9IHt9LFxuICAgICAgaGVscGVycyA9IHt9LFxuICAgICAgZmllbGRzID0gW10sXG4gICAgICBzaG93U2VsZWN0ID0gZmFsc2UsXG4gICAgICBnZXRJdGVtSWQgPSAoKT0+e31cbiAgfSA9ICRwcm9wcygpO1xuXG4gIGZ1bmN0aW9uIG9uUm93U2VsZWN0KGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2goJ3Jvd1NlbGVjdENoYW5nZScsIHtcbiAgICAgICAgICBpZDogICAgICAgaXRlbUlkLFxuICAgICAgICAgIHNlbGVjdGVkOiAkc2VsZWN0ZWRMaXN0W2l0ZW1JZF1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuPC9zY3JpcHQ+XG5cbjx0cj5cbiAgeyNpZiBzaG93U2VsZWN0ICYmICRzZWxlY3RlZExpc3QgfVxuICA8dGQ+XG4gICAgPGlucHV0IGlkPVwidGFibGUtcm93LXNlbGVjdC17Z2V0SXRlbUlkKGl0ZW0pfVwiIHR5cGU9XCJjaGVja2JveFwiIGRhdGEtaWQ9XCJ7Z2V0SXRlbUlkKGl0ZW0pfVwiIGJpbmQ6Y2hlY2tlZD17JHNlbGVjdGVkTGlzdFtpdGVtSWRdfSBwbGFjZWhvbGRlcj1cIlwiIG5hbWU9XCJyb3dfc2VsZWN0ZWRfe2dldEl0ZW1JZChpdGVtKX1cIiBvbmNoYW5nZT17b25Sb3dTZWxlY3R9IC8+XG4gIDwvdGQ+XG4gIHsvaWZ9XG4gIHsjZWFjaCBmaWVsZHMgYXMgZmllbGQgfVxuICA8VUlUYWJsZUNlbGwge2ZpZWxkfSB7aGVscGVyc30ge2l0ZW19IHtnZXRJdGVtSWR9IC8+XG4gIHsvZWFjaH1cbjwvdHI+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi8uLi9sb2NhbGVcIjtcblxuICAgIGltcG9ydCAqIGFzIFN0b3JlcyBmcm9tIFwiLi9zdG9yZXMuanNcIjtcblxuICAgIGltcG9ydCBVSVRhYmxlUm93IGZyb20gXCIuL25vdFRhYmxlUm93LnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgVUlMaW5rcyB9IGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9saW5rXCI7XG4gICAgaW1wb3J0IHsgVUlCdXR0b25zIH0gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2J1dHRvblwiO1xuICAgIGltcG9ydCBVSUljb24gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mb250LnN2ZWx0ZVwiO1xuXG4gICAgaW1wb3J0IHsgb25Nb3VudCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gaWRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gZmlsdGVyVUlcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2hlbHBlcnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtzdGF0ZV1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ZpbHRlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NvcnRlcl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ZpZWxkc11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlbGVjdGVkXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbXNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFthY3Rpb25zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbbGlua3NdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWFyY2hdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbc2hvd1NlYXJjaF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzaG93U2VsZWN0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NlbGVjdEFsbF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2dldEl0ZW1JZF1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZpbHRlclVJLFxuICAgICAgICBoZWxwZXJzID0ge30sXG4gICAgICAgIHN0YXRlID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgZmlsdGVyID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgc29ydGVyID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgZmllbGRzID0gW10sXG4gICAgICAgIHNlbGVjdGVkID0gJGJpbmRhYmxlKHt9KSxcbiAgICAgICAgaXRlbXMgPSAkYmluZGFibGUoW10pLFxuICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgIGxpbmtzID0gW10sXG4gICAgICAgIHNlYXJjaCA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgc2hvd1NlYXJjaCA9IHRydWUsXG4gICAgICAgIHNob3dTZWxlY3QgPSB0cnVlLFxuICAgICAgICBzZWxlY3RBbGwgPSAkYmluZGFibGUoZmFsc2UpLFxuICAgICAgICBnZXRJdGVtSWQgPSAoaXRlbSkgPT4gaXRlbS5faWQsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG93U2VsZWN0KSB7XG4gICAgICAgICAgICBTdG9yZXMuZ2V0KGlkKS5zZWxlY3RlZC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFN0b3Jlcy5nZXQoaWQpLnJlZmluZWQuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaXRlbXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChzaG93U2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbUlkIGluIHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbXMuc29tZSgoaXRlbSkgPT4gZ2V0SXRlbUlkKGl0ZW0pID09PSBpdGVtSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0ZWRbaXRlbUlkXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghT2JqZWN0Lmhhc093bihzZWxlY3RlZCwgaXRlbUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkW2l0ZW1JZF0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgU3RvcmVzLmdldChpZCkuc3RhdGUuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvblNlYXJjaElucHV0KGV2KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGV2LmN1cnJlbnRUYXJnZXQudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgZGlzcGF0Y2goXCJzZWFyY2hDaGFuZ2VcIiwgZGF0YSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TZWFyY2hDaGFuZ2UoeyBkZXRhaWwgfSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcGF0Y2goXCJzZWFyY2hDaGFuZ2VcIiwgZGV0YWlsKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkZpbHRlckNoYW5nZSh7IGRldGFpbCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXNwYXRjaChcImZpbHRlckNoYW5nZVwiLCBkZXRhaWwpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvUHJldigpIHtcbiAgICAgICAgZGlzcGF0Y2goXCJnb1RvUHJldlBhZ2VcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29OZXh0KCkge1xuICAgICAgICBkaXNwYXRjaChcImdvVG9OZXh0UGFnZVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb1RvKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBsZXQgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgZGlzcGF0Y2goXCJnb1RvUGFnZVwiLCBwYXJzZUludChlbC5kYXRhc2V0LnBhZ2UpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU2VsZWN0QWxsKCkge1xuICAgICAgICBTdG9yZXMuZ2V0KGlkKS5zZWxlY3RlZC51cGRhdGUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVbZ2V0SXRlbUlkKGl0ZW0pXSA9IHNlbGVjdEFsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkZpZWxkSGVhZENsaWNrKGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHByb3BQYXRoID0gZmllbGQucGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHNvcnRlciwgcHJvcFBhdGgpKSB7XG4gICAgICAgICAgICBzb3J0ZXJbcHJvcFBhdGhdID0gcGFyc2VJbnQoc29ydGVyW3Byb3BQYXRoXSkgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRlciA9IHtcbiAgICAgICAgICAgICAgICBbcHJvcFBhdGhdOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaChcInNvcnRlckNoYW5nZVwiLCBzb3J0ZXIpO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIGxpbmtzLmxlbmd0aH1cbiAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZFwiPlxuICAgICAgICA8VUlMaW5rcyB2YWx1ZXM9e2xpbmtzfSAvPlxuICAgIDwvZGl2Plxuey9pZn1cbnsjaWYgYWN0aW9ucy5sZW5ndGh9XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkIGlzLWdyb3VwZWRcIj5cbiAgICAgICAgPFVJQnV0dG9ucyB2YWx1ZXM9e2FjdGlvbnN9IC8+XG4gICAgPC9kaXY+XG57L2lmfVxueyNpZiBzaG93U2VhcmNofVxuICAgIHsjaWYgZmlsdGVyVUl9XG4gICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50ID0gZmlsdGVyVUl9XG4gICAgICAgIDxTdmVsdGVDb21wb25lbnRcbiAgICAgICAgICAgIGJpbmQ6ZmlsdGVyXG4gICAgICAgICAgICBvbjpjaGFuZ2U9e29uRmlsdGVyQ2hhbmdlfVxuICAgICAgICAgICAgb246c2VhcmNoQ2hhbmdlPXtvblNlYXJjaENoYW5nZX1cbiAgICAgICAgLz5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJpbnB1dFwiXG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCLQn9C+0LjRgdC6XCJcbiAgICAgICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17c2VhcmNofVxuICAgICAgICAgICAgICAgICAgICBvbmlucHV0PXtvblNlYXJjaElucHV0fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cbnsvaWZ9XG48dGFibGUgY2xhc3M9XCJ0YWJsZVwiPlxuICAgIDx0aGVhZD5cbiAgICAgICAgPHRyPlxuICAgICAgICAgICAgeyNpZiBzaG93U2VsZWN0fVxuICAgICAgICAgICAgICAgIDx0aFxuICAgICAgICAgICAgICAgICAgICA+PGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJ0YWJsZS1yb3ctc2VsZWN0LXBhZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZDpjaGVja2VkPXtzZWxlY3RBbGx9XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwicm93X3NlbGVjdGVkX2FsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNoYW5nZT17b25TZWxlY3RBbGx9XG4gICAgICAgICAgICAgICAgICAgIC8+PC90aFxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2VhY2ggZmllbGRzIGFzIGZpZWxkfVxuICAgICAgICAgICAgICAgIHtAY29uc3QgcHJvcFBhdGggPSBmaWVsZC5wYXRoLnN1YnN0cmluZygxKX1cbiAgICAgICAgICAgICAgICA8dGhcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9eyhmaWVsZC5oaWRlT25Nb2JpbGUgPyBcIiBpcy1oaWRkZW4tdG91Y2hcIiA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmaWVsZC5zb3J0YWJsZSA/IFwiIGlzLWNsaWNrYWJsZVwiIDogXCJcIil9XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uRmllbGRIZWFkQ2xpY2soZmllbGQpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBmaWVsZC5zb3J0YWJsZSAmJiBPYmplY3QuaGFzT3duKHNvcnRlciwgcHJvcFBhdGgpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPFVJSWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ9e3NvcnRlcltwcm9wUGF0aF0gPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJzb3J0LXVwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInNvcnQtZG93blwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtmaWVsZC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGFibGU9e3RydWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICB7JExPQ0FMRVtmaWVsZC50aXRsZV19XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICAgIDx0Ym9keT5cbiAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uX2lkKX1cbiAgICAgICAgICAgIDxVSVRhYmxlUm93XG4gICAgICAgICAgICAgICAge2lkfVxuICAgICAgICAgICAgICAgIHtpdGVtfVxuICAgICAgICAgICAgICAgIHtmaWVsZHN9XG4gICAgICAgICAgICAgICAge2hlbHBlcnN9XG4gICAgICAgICAgICAgICAge3Nob3dTZWxlY3R9XG4gICAgICAgICAgICAgICAge2dldEl0ZW1JZH1cbiAgICAgICAgICAgICAgICBvbjpyb3dTZWxlY3RDaGFuZ2VcbiAgICAgICAgICAgIC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L3Rib2R5PlxuPC90YWJsZT5cbnsjaWYgc3RhdGU/LnBhZ2luYXRpb24/LnBhZ2VzPy5saXN0Lmxlbmd0aCA+IDF9XG4gICAgPG5hdiBjbGFzcz1cInBhZ2luYXRpb24gaXMtY2VudGVyZWRcIiBhcmlhLWxhYmVsPVwicGFnaW5hdGlvblwiPlxuICAgICAgICA8YSBocmVmIGNsYXNzPVwicGFnaW5hdGlvbi1wcmV2aW91c1wiIG9uY2xpY2s9e2dvUHJldn0+0J3QsNC30LDQtDwvYT5cbiAgICAgICAgPGEgaHJlZiBjbGFzcz1cInBhZ2luYXRpb24tbmV4dFwiIG9uY2xpY2s9e2dvTmV4dH0+0JLQv9C10YDQtdC0PC9hPlxuICAgICAgICA8dWwgY2xhc3M9XCJwYWdpbmF0aW9uLWxpc3RcIj5cbiAgICAgICAgICAgIHsjaWYgc3RhdGUucGFnaW5hdGlvbiAmJiBzdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzICYmIHN0YXRlLnBhZ2luYXRpb24ucGFnZXMubGlzdH1cbiAgICAgICAgICAgICAgICB7I2VhY2ggc3RhdGUucGFnaW5hdGlvbi5wYWdlcy5saXN0IGFzIHBhZ2V9XG4gICAgICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgcGFnZS5hY3RpdmV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInBhZ2luYXRpb24tbGluayBpcy1jdXJyZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cItCh0YLRgNCw0L3QuNGG0LAge3BhZ2UuaW5kZXh9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1jdXJyZW50PVwicGFnZVwiPntwYWdlLmluZGV4ICsgMX08L2FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInBhZ2luYXRpb24tbGlua1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCLQodGC0YDQsNC90LjRhtCwIHtwYWdlLmluZGV4fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtcGFnZT17cGFnZS5pbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17Z29Ub30+e3BhZ2UuaW5kZXggKyAxfTwvYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC91bD5cbiAgICA8L25hdj5cbnsvaWZ9XG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJ3b2xmeTg3LWV2ZW50ZW1pdHRlclwiO1xuaW1wb3J0IG5vdFBhdGggZnJvbSBcIm5vdC1wYXRoXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb24uanNcIjtcblxuaW1wb3J0ICogYXMgU3RvcmVzIGZyb20gXCIuL3N0b3Jlcy5qc1wiO1xuaW1wb3J0IFVJVGFibGUgZnJvbSBcIi4vbm90VGFibGUuc3ZlbHRlXCI7XG5cbmNvbnN0IENPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYID0gXCJfX2R1YmxpY2F0ZV9fXCI7XG5cbmNvbnN0IE9QVF9ERUZBVUxUX1BBR0VfU0laRSA9IDIwLFxuICAgIE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSID0gMCxcbiAgICBPUFRfREVGQVVMVF9QQUdFX1JBTkdFID0gNixcbiAgICBPUFRfREVGQVVMVF9TT1JUX0RJUkVDVElPTiA9IDEsXG4gICAgT1BUX0RFRkFVTFRfU0VBUkNIID0gXCJcIixcbiAgICBPUFRfREVGQVVMVF9SRVRVUk4gPSB7fSxcbiAgICBPUFRfREVGQVVMVF9DT01CSU5FRCA9IGZhbHNlLFxuICAgIE9QVF9ERUZBVUxUX0NPTUJJTkVEX0FDVElPTiA9IFwibGlzdEFuZENvdW50XCIsXG4gICAgT1BUX0RFRkFVTFRfQ09VTlRfQUNUSU9OID0gXCJjb3VudFwiLFxuICAgIE9QVF9ERUZBVUxUX0xJU1RfQUNUSU9OID0gXCJsaXN0XCIsXG4gICAgT1BUX0RFRkFVTFRfU09SVF9GSUVMRCA9IFwiX2lkXCIsXG4gICAgT1BUX0ZJRUxEX05BTUVfUFJFX1BST0MgPSBcInByZXByb2Nlc3NvclwiO1xuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgdWk6IFVJVGFibGUsXG4gICAgbGlua3M6IFtdLFxuICAgIGFjdGlvbnM6IFtdLFxuICAgIGVuZGxlc3M6IGZhbHNlLFxuICAgIGlkRmllbGQ6IFwiX2lkXCIsXG4gICAgZ2V0SXRlbUlkOiAoaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4gaXRlbS5faWQ7XG4gICAgfSxcbn07XG5cbmNsYXNzIG5vdFRhYmxlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaWQgPSBcInRhYmxlLVwiICsgTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgICAgICAgLi4uKGlucHV0Lm9wdGlvbnMgPyBpbnB1dC5vcHRpb25zIDoge30pLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVpID0ge307XG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIHJhdzogW10sXG4gICAgICAgICAgICBmaWx0ZXJlZDogW10sXG4gICAgICAgICAgICByZWZpbmVkOiBbXSxcbiAgICAgICAgICAgIHNlbGVjdGVkOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgdG86IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYWdlczoge1xuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgdG86IDAsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtpbmcgPSB7fTtcblxuICAgICAgICB0aGlzLnN0b3JlcyA9IFN0b3Jlcy5jcmVhdGUodGhpcy5pZCwge1xuICAgICAgICAgICAgcmF3OiBbXSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBbXSxcbiAgICAgICAgICAgIHJlZmluZWQ6IFtdLFxuICAgICAgICAgICAgc2VsZWN0ZWQ6IHt9LFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB3b3JraW5nOiB0aGlzLndvcmtpbmcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3RvcmVzLndvcmtpbmcuc3Vic2NyaWJlKHRoaXMub25Xb3JraW5nVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL9C/0L7Qu9GD0YfQtdC90L3Ri9C1INC40Lcg0YHQtdGC0LhcbiAgICAgICAgdGhpcy5zdG9yZXMucmF3LnN1YnNjcmliZSh0aGlzLm9uUmF3VXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL9C/0YDQuNC80LXQvdC10L3RiyDRhNC40LvRjNGC0YDRiywg0YHQvtGA0YLQuNGA0L7QstC60Lgg0Lgg0YIu0LQuXG4gICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnN1YnNjcmliZSh0aGlzLm9uRmlsdGVyZWRVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIC8v0YPRgNC10LfQsNC90Ysg0LTQviDQvNC40L3QuNC80LDQu9GM0L3QvtCz0L4g0L3QsNCx0L7RgNCwLCDRgtC+0YfQvdC+INGB0L7QvtGC0LLQtdGB0YLQstGD0Y7RidC10LPQviDRgtCw0LHQu9C40YfQvdC+0LzRgyDRhNC+0YDQvNCw0YLRg1xuICAgICAgICB0aGlzLnN0b3Jlcy5yZWZpbmVkLnN1YnNjcmliZSh0aGlzLm9uUmVmaW5lZFVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy/RgdC70L7QstCw0YDRjCDRgSDQuNC00LXQvdGC0LjRhNC40LrQsNGC0L7RgNCw0LzQuCDQstGL0LHRgNCw0L3QvdGL0YUg0YHRgtGA0L7QulxuICAgICAgICB0aGlzLnN0b3Jlcy5zZWxlY3RlZC5zdWJzY3JpYmUodGhpcy5vblNlbGVjdGVkVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAvL3BhZ2luYXRpb24sIGl0ZW1zIGluZm9ybWF0aW9uXG4gICAgICAgIHRoaXMuc3RvcmVzLnN0YXRlLnN1YnNjcmliZSh0aGlzLm9uU3RhdGVVcGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXMoaW5wdXQsIFwiZGF0YVwiKSAmJiBBcnJheS5pc0FycmF5KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3Jlcy5yYXcudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICB2YWwgPSBpbnB1dC5kYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0Q29tYmluZWRBY3Rpb25OYW1lKFxuICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgIFwiaW50ZXJmYWNlLmNvbWJpbmVkQWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5vcHRpb25zLCBcImZpbHRlclwiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIodGhpcy5vcHRpb25zLmZpbHRlciwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0RmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5vcHRpb25zLCBcInBhZ2VyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhZ2VyKHRoaXMub3B0aW9ucy5wYWdlciwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyh0aGlzLm9wdGlvbnMsIFwic29ydGVyXCIpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNvcnRlcih0aGlzLm9wdGlvbnMuc29ydGVyLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTb3J0ZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXModGhpcy5vcHRpb25zLCBcInJldHVyblwiKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSZXR1cm4odGhpcy5vcHRpb25zLnJldHVybik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldFJldHVybigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKHRoaXMub3B0aW9ucywgXCJzZWFyY2hcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VhcmNoKHRoaXMub3B0aW9ucy5zZWFyY2gsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb25Xb3JraW5nVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgb25SYXdVcGRhdGUodmFsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5yYXcgPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgb25GaWx0ZXJlZFVwZGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkID0gdmFsO1xuICAgICAgICB0aGlzLnJlZmluZUZpbHRlcmVkKCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgb25SZWZpbmVkVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRhdGEucmVmaW5lZCA9IHZhbDtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGVkKCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgb25TdGF0ZVVwZGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBvblNlYXJjaENoYW5nZShsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VhcmNoKGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2goKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uU29ydGVyQ2hhbmdlKHNvcnRlcikge1xuICAgICAgICBpZiAoc29ydGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNvcnRlcihzb3J0ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNvcnRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25GaWx0ZXJDaGFuZ2UoeyBmaWx0ZXIsIGFjdGlvbk5hbWUgfSkge1xuICAgICAgICBpZiAoYWN0aW9uTmFtZS5pbmRleE9mKE9QVF9ERUZBVUxUX0NPTUJJTkVEX0FDVElPTikgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29tYmluZWRBY3Rpb25OYW1lKGFjdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0RmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNlbGVjdGVkVXBkYXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRhdGEuc2VsZWN0ZWQgPSB2YWw7XG4gICAgfVxuXG4gICAgY2xlYXJTZWxlY3RlZCgpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNlbGVjdGVkID0ge307XG4gICAgfVxuXG4gICAgZ2V0U2VsZWN0ZWQob2JqZWN0ID0gZmFsc2UsIHN0b3JlID0gXCJyZWZpbmVkXCIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLmRhdGEuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuc2VsZWN0ZWRbaWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5keCA9IHRoaXMuZGF0YVtzdG9yZV0uZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICAgICAgICAgKGl0ZW0pID0+IGl0ZW0uX2lkID09PSBpZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5keCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLmRhdGFbc3RvcmVdW2luZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBnZXRJdGVtSWQoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiZ2V0SXRlbUlkXCIsIERFRkFVTFRfT1BUSU9OUy5nZXRJdGVtSWQpKGl0ZW0pO1xuICAgIH1cblxuICAgIHNlbGVjdEFsbCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuc2VsZWN0ZWQudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5kYXRhLmZpbHRlcmVkLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0aGlzLmdldEl0ZW1JZChpdGVtKV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdE5vbmUoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVzLnNlbGVjdGVkLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5maWx0ZXJlZC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVbdGhpcy5nZXRJdGVtSWQoaXRlbSldID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMudWkudGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMudWkudGFibGUgPSBuZXcgdGhpcy5vcHRpb25zLnVpKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMub3B0aW9ucy50YXJnZXRFbCxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJVSTogdGhpcy5nZXRPcHRpb25zKFwiZmlsdGVyVUlcIiwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0SGVscGVycygpKSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IHRoaXMuZ2V0QWN0aW9ucygpLFxuICAgICAgICAgICAgICAgICAgICBsaW5rczogdGhpcy5nZXRMaW5rcygpLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3dTZWxlY3Q6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dTZWxlY3RcIiksXG4gICAgICAgICAgICAgICAgICAgIHNob3dTZWFyY2g6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dTZWFyY2hcIiksXG4gICAgICAgICAgICAgICAgICAgIHNob3dTb3J0OiB0aGlzLmdldE9wdGlvbnMoXCJzaG93U29ydFwiKSxcbiAgICAgICAgICAgICAgICAgICAgaWRGaWVsZDogdGhpcy5nZXRPcHRpb25zKFwiaWRGaWVsZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SXRlbUlkOiB0aGlzLmdldE9wdGlvbnMoXCJnZXRJdGVtSWRcIiksXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5nZXRGaWx0ZXIoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aS50YWJsZS4kb24oXCJzZWFyY2hDaGFuZ2VcIiwgKGUpID0+IHRoaXMub25TZWFyY2hDaGFuZ2UoZS5kZXRhaWwpKTtcbiAgICAgICAgdGhpcy51aS50YWJsZS4kb24oXCJzb3J0ZXJDaGFuZ2VcIiwgKGUpID0+IHRoaXMub25Tb3J0ZXJDaGFuZ2UoZS5kZXRhaWwpKTtcbiAgICAgICAgdGhpcy51aS50YWJsZS4kb24oXCJmaWx0ZXJDaGFuZ2VcIiwgKGUpID0+IHRoaXMub25GaWx0ZXJDaGFuZ2UoZS5kZXRhaWwpKTtcbiAgICAgICAgdGhpcy51aS50YWJsZS4kb24oXCJnb1RvUGFnZVwiLCAoZSkgPT4gdGhpcy5nb1RvUGFnZShlLmRldGFpbCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImdvVG9OZXh0UGFnZVwiLCAoKSA9PiB0aGlzLmdvVG9OZXh0KCkpO1xuICAgICAgICB0aGlzLnVpLnRhYmxlLiRvbihcImdvVG9QcmV2UGFnZVwiLCAoKSA9PiB0aGlzLmdvVG9QcmV2KCkpO1xuICAgIH1cblxuICAgIGdldEFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJhY3Rpb25zXCIsIFtdKTtcbiAgICB9XG5cbiAgICBnZXRMaW5rcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImxpbmtzXCIsIFtdKTtcbiAgICB9XG5cbiAgICBnZXRIZWxwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhlbHBlcnMgfHwge307XG4gICAgfVxuXG4gICAgc2V0V29ya2luZyhrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmVzLndvcmtpbmcudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIG5vdFBhdGguc2V0KGtleSwgdmFsLCB0aGlzLmdldEhlbHBlcnMoKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFdvcmtpbmcoa2V5LCBkZWYpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5vdFBhdGguZ2V0KGtleSwgdGhpcy53b3JraW5nLCB0aGlzLmdldEhlbHBlcnMoKSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRTdGF0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmVzLnN0YXRlLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICBub3RQYXRoLnNldChrZXksIHZhbCwgdGhpcy5nZXRIZWxwZXJzKCksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRTdGF0ZShrZXksIGRlZikge1xuICAgICAgICBsZXQgcmVzID0gbm90UGF0aC5nZXQoa2V5LCB0aGlzLnN0YXRlLCB0aGlzLmdldEhlbHBlcnMoKSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRPcHRpb25zKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbm90UGF0aC5zZXQoa2V5LCB0aGlzLm9wdGlvbnMsIHRoaXMuZ2V0SGVscGVycygpLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldE9wdGlvbnMoa2V5LCBkZWYpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5vdFBhdGguZ2V0KGtleSwgdGhpcy5vcHRpb25zLCB0aGlzLmdldEhlbHBlcnMoKSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRGaWx0ZXIoaGFzaCwgd2l0aG91dEludmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJmaWx0ZXJcIiwgaGFzaCk7XG4gICAgICAgIGlmICh3aXRob3V0SW52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludmFsaWRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXNldEZpbHRlcigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcImZpbHRlclwiLCB7fSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldEZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoXCJmaWx0ZXJcIik7XG4gICAgfVxuXG4gICAgc2V0UGFnZXIoaGFzaCwgd2l0aG91dEludmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJwYWdlclwiLCBoYXNoKTtcbiAgICAgICAgaWYgKHdpdGhvdXRJbnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXREZWZhdWx0UGFnZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHRoaXMuZ2V0T3B0aW9ucyhcInBhZ2VyLnBhZ2VcIikpXG4gICAgICAgICAgICA/IE9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSXG4gICAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9ucyhcInBhZ2VyLnBhZ2VcIik7XG4gICAgfVxuXG4gICAgZ2V0RGVmYXVsdFBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gaXNOYU4odGhpcy5nZXRPcHRpb25zKFwicGFnZXIuc2l6ZVwiKSlcbiAgICAgICAgICAgID8gT1BUX0RFRkFVTFRfUEFHRV9TSVpFXG4gICAgICAgICAgICA6IHRoaXMuZ2V0T3B0aW9ucyhcInBhZ2VyLnNpemVcIik7XG4gICAgfVxuXG4gICAgcmVzZXRQYWdlcigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInBhZ2VyXCIsIHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMuZ2V0RGVmYXVsdFBhZ2VTaXplKCksXG4gICAgICAgICAgICBwYWdlOiB0aGlzLmdldERlZmF1bHRQYWdlTnVtYmVyKCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFBhZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZShcInBhZ2VyXCIpO1xuICAgIH1cblxuICAgIHNldFNvcnRlcihoYXNoLCB3aXRob3V0SW52YWxpZGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwic29ydGVyXCIsIGhhc2gpO1xuICAgICAgICBpZiAod2l0aG91dEludmFsaWRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlRGF0YSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzZXRTb3J0ZXIod2l0aG91dEludmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0ID0ge307XG4gICAgICAgIHRbT1BUX0RFRkFVTFRfU09SVF9GSUVMRF0gPSBPUFRfREVGQVVMVF9TT1JUX0RJUkVDVElPTjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0U29ydGVyKHQsIHdpdGhvdXRJbnZhbGlkYXRpb24pO1xuICAgIH1cblxuICAgIGdldFNvcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInNvcnRlclwiKTtcbiAgICB9XG5cbiAgICBnZXRTb3J0ZXJEaXJlY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmdldFNvcnRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNvcnRlcigpW25hbWVzWzBdXTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gT1BUX0RFRkFVTFRfU09SVF9ESVJFQ1RJT047XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTZWFyY2goKSB7XG4gICAgICAgIGxldCBzZWFyY2ggPVxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuZ2V0V29ya2luZyhcInNlYXJjaFwiKSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdGhpcy5nZXRXb3JraW5nKFwic2VhcmNoXCIpICE9PSBudWxsO1xuICAgICAgICByZXR1cm4gc2VhcmNoID8gdGhpcy5nZXRXb3JraW5nKFwic2VhcmNoXCIpIDogXCJcIjtcbiAgICB9XG5cbiAgICBzZXRTZWFyY2gobGluZSA9IE9QVF9ERUZBVUxUX1NFQVJDSCwgd2l0aG91dEludmFsaWRhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInNlYXJjaFwiLCBsaW5lKTtcbiAgICAgICAgaWYgKHdpdGhvdXRJbnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldFJldHVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcInJldHVyblwiKTtcbiAgICB9XG5cbiAgICBzZXRSZXR1cm4ocmV0ID0gT1BUX0RFRkFVTFRfUkVUVVJOKSB7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcInJldHVyblwiLCByZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjbGVhckZpbHRlcmVkRGF0YSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5zcGxpY2UoMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGVhclJhd0RhdGEoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVzLnJhdy51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyUmVmaW5lZERhdGEoKSB7XG4gICAgICAgIHRoaXMuc3RvcmVzLnJlZmluZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbC5zcGxpY2UoMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnZhbGlkYXRlRGF0YSgpIHtcbiAgICAgICAgLy9jbGVhcmluZyBmaWx0ZXJlZCBhbmQgc29ydGVkXG4gICAgICAgIHRoaXMuY2xlYXJGaWx0ZXJlZERhdGEoKTtcbiAgICAgICAgLy9pbiBjYXNlIGxpdmUgbG9hZGluZyBmcm9tIHNlcnZlclxuICAgICAgICBpZiAodGhpcy5pc0xpdmUoKSkge1xuICAgICAgICAgICAgLy9jbGVhcmluZyBsb2FkZWQgZGF0YVxuICAgICAgICAgICAgdGhpcy5jbGVhclJhd0RhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICAvL3Jlc3NldCBwYWdlciBhbnl3YXlcbiAgICAgICAgdGhpcy5yZXNldFBhZ2VyKCk7XG4gICAgfVxuXG4gICAgaXNMaXZlKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlXCIpICYmIHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5mYWN0b3J5XCIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2V0VXBkYXRpbmcoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXCJ1cGRhdGluZ1wiLCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZXRVcGRhdGVkKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwidXBkYXRpbmdcIiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmVXBkYXRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKFwidXBkYXRpbmdcIik7XG4gICAgfVxuXG4gICAgZ2V0RGF0YUludGVyZmFjZSgpIHtcbiAgICAgICAgbGV0IGZhY3RvcnkgPSB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UuZmFjdG9yeVwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TG9hZERhdGFBY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmxpc3RBY3Rpb25cIilcbiAgICAgICAgICAgID8gdGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmxpc3RBY3Rpb25cIilcbiAgICAgICAgICAgIDogT1BUX0RFRkFVTFRfTElTVF9BQ1RJT047XG4gICAgfVxuXG4gICAgc2V0Q29tYmluZWRBY3Rpb25OYW1lKGFjdGlvbk5hbWUgPSBPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT04pIHtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwiaW50ZXJmYWNlLmNvbWJpbmVkQWN0aW9uXCIsIGFjdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGdldENvbWJpbmVkQWN0aW9uTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcImludGVyZmFjZS5jb21iaW5lZEFjdGlvblwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldFdvcmtpbmcoXCJpbnRlcmZhY2UuY29tYmluZWRBY3Rpb25cIilcbiAgICAgICAgICAgIDogT1BUX0RFRkFVTFRfQ09NQklORURfQUNUSU9OO1xuICAgIH1cblxuICAgIGdldENvdW50QWN0aW9uTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5jb3VudEFjdGlvblwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldE9wdGlvbnMoXCJpbnRlcmZhY2UuY291bnRBY3Rpb25cIilcbiAgICAgICAgICAgIDogT1BUX0RFRkFVTFRfQ09VTlRfQUNUSU9OO1xuICAgIH1cblxuICAgIGxvYWREYXRhKCkge1xuICAgICAgICAvL2xvYWQgZnJvbSBzZXJ2ZXJcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5nZXREYXRhSW50ZXJmYWNlKClcbiAgICAgICAgICAgICAgICAuc2V0RmlsdGVyKHRoaXMuZ2V0RmlsdGVyKCkpXG4gICAgICAgICAgICAgICAgLnNldFNvcnRlcih0aGlzLmdldFNvcnRlcigpKVxuICAgICAgICAgICAgICAgIC5zZXRSZXR1cm4odGhpcy5nZXRSZXR1cm4oKSlcbiAgICAgICAgICAgICAgICAuc2V0U2VhcmNoKHRoaXMuZ2V0U2VhcmNoKCkpXG4gICAgICAgICAgICAgICAgLnNldFBhZ2VyKHRoaXMuZ2V0UGFnZXIoKSksXG4gICAgICAgICAgICBhY3Rpb25OYW1lO1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwiaW50ZXJmYWNlLmNvbWJpbmVkXCIsIE9QVF9ERUZBVUxUX0NPTUJJTkVEKSkge1xuICAgICAgICAgICAgYWN0aW9uTmFtZSA9IHRoaXMuZ2V0Q29tYmluZWRBY3Rpb25OYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb25OYW1lID0gdGhpcy5nZXRMb2FkRGF0YUFjdGlvbk5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVlcnlbXCIkXCIgKyBhY3Rpb25OYW1lXSgpO1xuICAgIH1cblxuICAgIGdvVG9OZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IGlzTmFOKHRoaXMuZ2V0U3RhdGUoXCJwYWdlci5wYWdlXCIpKVxuICAgICAgICAgICAgPyB0aGlzLmdldERlZmF1bHRQYWdlTnVtYmVyKClcbiAgICAgICAgICAgIDogdGhpcy5nZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIikgKyAxO1xuICAgICAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgICAgICAgXCJwYWdlci5wYWdlXCIsXG4gICAgICAgICAgICBNYXRoLm1pbihuZXh0LCB0aGlzLmdldFN0YXRlKFwicGFnaW5hdGlvbi5wYWdlcy50b1wiKSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgfVxuXG4gICAgZ29Ub1ByZXYoKSB7XG4gICAgICAgIGxldCBwcmV2ID0gaXNOYU4odGhpcy5nZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIikpXG4gICAgICAgICAgICA/IHRoaXMuZ2V0RGVmYXVsdFBhZ2VOdW1iZXIoKVxuICAgICAgICAgICAgOiB0aGlzLmdldFN0YXRlKFwicGFnZXIucGFnZVwiKSAtIDE7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICAgICAgICBcInBhZ2VyLnBhZ2VcIixcbiAgICAgICAgICAgIE1hdGgubWF4KHByZXYsIHRoaXMuZ2V0U3RhdGUoXCJwYWdpbmF0aW9uLnBhZ2VzLmZyb21cIikpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgIH1cblxuICAgIGdvVG9GaXJzdCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIiwgdGhpcy5nZXRTdGF0ZShcInBhZ2luYXRpb24ucGFnZXMuZnJvbVwiKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgIH1cblxuICAgIGdvVG9MYXN0KCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKFwicGFnZXIucGFnZVwiLCB0aGlzLmdldFN0YXRlKFwicGFnaW5hdGlvbi5wYWdlcy50b1wiKSk7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgIH1cblxuICAgIGdvVG9QYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShcInBhZ2VyLnBhZ2VcIiwgcGFnZU51bWJlcik7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YSgpO1xuICAgIH1cblxuICAgIHRlc3REYXRhSXRlbShpdGVtKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHRoaXMuZ2V0U2VhcmNoKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBpdGVtKSB7XG4gICAgICAgICAgICB2YXIgdG9Db21wID0gaXRlbVtrXS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodG9Db21wLmluZGV4T2Yoc3RyVmFsdWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Um93c0NvdW50KCkge1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmdldERhdGFJbnRlcmZhY2UoKS5zZXRGaWx0ZXIodGhpcy5nZXRGaWx0ZXIoKSk7XG4gICAgICAgIHJldHVybiBxdWVyeVtcIiRcIiArIHRoaXMuZ2V0Q291bnRBY3Rpb25OYW1lKCldKClcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uKGRhdGEuY291bnQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cGRhdGVQYWdpbmF0aW9uKGl0ZW1zQ291bnQpIHtcbiAgICAgICAgdGhpcy5sb2coXCJ1cGRhdGUgcGFnaW5hdGlvblwiLCBpdGVtc0NvdW50KTtcbiAgICAgICAgdGhpcy5zdGF0ZS5wYWdpbmF0aW9uLnBhZ2VzLmxpc3Quc3BsaWNlKFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucGFnaW5hdGlvbi5wYWdlcy5saXN0Lmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBsZXQgaXRlbXNGcm9tID1cbiAgICAgICAgICAgICAgICAodGhpcy5nZXRQYWdlcigpLnBhZ2UgLSBPUFRfREVGQVVMVF9QQUdFX05VTUJFUikgKlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFBhZ2VyKCkuc2l6ZSArXG4gICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIHBhZ2VzQ291bnQgPVxuICAgICAgICAgICAgICAgIGl0ZW1zQ291bnQgJSB0aGlzLmdldFBhZ2VyKCkuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IE1hdGguZmxvb3IoaXRlbXNDb3VudCAvIHRoaXMuZ2V0UGFnZXIoKS5zaXplKSArIDFcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKGl0ZW1zQ291bnQgLyB0aGlzLmdldFBhZ2VyKCkuc2l6ZSksXG4gICAgICAgICAgICBwYWdlc0Zyb20gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBPUFRfREVGQVVMVF9QQUdFX05VTUJFUixcbiAgICAgICAgICAgICAgICB0aGlzLmdldFBhZ2VyKCkucGFnZSAtIE9QVF9ERUZBVUxUX1BBR0VfUkFOR0VcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBwYWdlc1RvID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgcGFnZXNDb3VudCAtICgxIC0gT1BUX0RFRkFVTFRfUEFHRV9OVU1CRVIpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UGFnZXIoKS5wYWdlICsgT1BUX0RFRkFVTFRfUEFHRV9SQU5HRVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIGl0ZW1zVG8gPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBpdGVtc0Zyb20gKyB0aGlzLmdldFBhZ2VyKCkuc2l6ZSAtIDEsXG4gICAgICAgICAgICAgICAgaXRlbXNDb3VudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgZm9yIChsZXQgdCA9IHBhZ2VzRnJvbTsgdCA8PSBwYWdlc1RvOyB0KyspIHtcbiAgICAgICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHQsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0ID09PSB0aGlzLmdldFBhZ2VyKCkucGFnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9yZXMuc3RhdGUudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwidXBkYXRlIHBhZ2luYXRpb25cIiwgdmFsKTtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLml0ZW1zLmNvdW50ID0gaXRlbXNDb3VudDtcbiAgICAgICAgICAgIHZhbC5wYWdpbmF0aW9uLml0ZW1zLmZyb20gPSBpdGVtc0Zyb207XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5pdGVtcy50byA9IGl0ZW1zVG87XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5jb3VudCA9IHBhZ2VzQ291bnQ7XG4gICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5mcm9tID0gcGFnZXNGcm9tO1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24ucGFnZXMudG8gPSBwYWdlc1RvO1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24ucGFnZXMuY3VycmVudCA9IHRoaXMuZ2V0UGFnZXIoKS5wYWdlO1xuICAgICAgICAgICAgdmFsLnBhZ2luYXRpb24ucGFnZXMubGlzdC5zcGxpY2UoXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICB2YWwucGFnaW5hdGlvbi5wYWdlcy5saXN0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAuLi5saXN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlRGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMaXZlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlmVXBkYXRpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRPcHRpb25zKFwiZW5kbGVzc1wiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUmF3RGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRVcGRhdGluZygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcImludGVyZmFjZS5jb21iaW5lZFwiLCBPUFRfREVGQVVMVF9DT01CSU5FRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWREYXRhKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmdWxsID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RDb21tb24ub2JqSGFzKGRhdGEsIFwic3RhdHVzXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhkYXRhLCBcInJlc3VsdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldE9wdGlvbnMoXCJlbmRsZXNzXCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRmlsdGVyZWREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEucmVzdWx0Lmxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoZGF0YSwgXCJsaXN0XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEubGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwucHVzaCguLi5kYXRhLmxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5wdXNoKC4uLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxhc3RDb3VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGwgPyBkYXRhLnJlc3VsdC5jb3VudCA6IGRhdGEuY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvbih0aGlzLmdldFdvcmtpbmcoXCJsYXN0Q291bnRcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godGhpcy5lcnJvci5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0aGlzLnNldFVwZGF0ZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZXMuZmlsdGVyZWQudXBkYXRlKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwucHVzaCguLi5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuZ2V0Um93c0NvdW50LmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aGlzLmVycm9yLmJpbmQodGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRoaXMuc2V0VXBkYXRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbG9jYWwgbWFnaWNcbiAgICAgICAgICAgIHRoaXMuc2V0VXBkYXRpbmcoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VXBkYXRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0RGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBwcm9jZXNzRGF0YSgpIHtcbiAgICAgICAgbGV0IHRoYXRGaWx0ZXIgPSB0aGlzLmdldEZpbHRlcigpO1xuICAgICAgICAvL3RoaXMuZ2V0RGF0YSgncm93cycpLl9fc2V0UGFzc2l2ZTtcbiAgICAgICAgdGhpcy5sb2codGhpcy5nZXREYXRhKCkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgdGhhdEZpbHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdGhhdEZpbHRlciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoYXRGaWx0ZXIuZmlsdGVyU2VhcmNoICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0aGF0RmlsdGVyLmZpbHRlclNlYXJjaCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhhdEZpbHRlci5maWx0ZXJTZWFyY2gubGVuZ3RoID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsLnNwbGljZShcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgdmFsLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5kYXRhLnJhdy5maWx0ZXIodGhpcy50ZXN0RGF0YUl0ZW0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVzLmZpbHRlcmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsLnNwbGljZSgwLCB2YWwubGVuZ3RoLCAuLi50aGlzLmRhdGEucmF3KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8vL3NvcnRlclxuICAgICAgICBsZXQgdGhhdFNvcnRlciA9IHRoaXMuZ2V0U29ydGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhhdFNvcnRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGF0U29ydGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3Jlcy5maWx0ZXJlZC51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhbC5zb3J0KChpdGVtMSwgaXRlbTIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQxID0gbm90UGF0aC5nZXQodGhhdFNvcnRlci5zb3J0QnlGaWVsZCwgaXRlbTEsIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gbm90UGF0aC5nZXQodGhhdFNvcnRlci5zb3J0QnlGaWVsZCwgaXRlbTIsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHQxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0MSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0MiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxLmxvY2FsZUNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxLmxvY2FsZUNvbXBhcmUoKSAqIC10aGF0U29ydGVyLnNvcnREaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodDEgPCB0MiA/IDEgOiAtMSkgKiB0aGF0U29ydGVyLnNvcnREaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlcnJvcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2dnZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2dnZXIuZXJyb3IoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvZygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2dnZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2dnZXIubG9nKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVja0ZpZWxkc05hbWVzKCkge1xuICAgICAgICBjb25zdCBmaWVsZElkID0gdGhpcy5nZXRPcHRpb25zKFwiaWRGaWVsZFwiKTtcbiAgICAgICAgY29uc3QgcGF0aElkID0gXCI6XCIgKyBmaWVsZElkO1xuICAgICAgICBsZXQgZmllbGRzID0gdGhpcy5nZXRPcHRpb25zKFwiZmllbGRzXCIsIFtdKTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAocGF0aElkID09PSBmaWVsZC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgZmllbGQucGF0aCA9IGZpZWxkLnBhdGggKyBDT05TVF9JRF9EVUJMSUNBVEVfUE9TVEZJWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVhZEZpZWxkVmFsdWUocGF0aCwgaXRlbSwgaGVscGVycykge1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKENPTlNUX0lEX0RVQkxJQ0FURV9QT1NURklYKSA+IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZElkID0gdGhpcy5nZXRPcHRpb25zKFwiaWRGaWVsZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJZCA9IFwiOlwiICsgZmllbGRJZDtcbiAgICAgICAgICAgIHJldHVybiBub3RQYXRoLmdldChwYXRoSWQsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vdFBhdGguZ2V0KHBhdGgsIGl0ZW0sIGhlbHBlcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVmaW5lRmlsdGVyZWQoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja0ZpZWxkc05hbWVzKCk7XG4gICAgICAgIHRoaXMuZGF0YS5maWx0ZXJlZC5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpKSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZFt0aGlzLmdldE9wdGlvbnMoXCJpZEZpZWxkXCIpXSA9XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bdGhpcy5nZXRPcHRpb25zKFwiaWRGaWVsZFwiKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwgW10pLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXByb2Nlc3NlZCA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRoaXMucmVhZEZpZWxkVmFsdWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9ucyhcImhlbHBlcnNcIilcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLm9iakhhcyhmaWVsZCwgT1BUX0ZJRUxEX05BTUVfUFJFX1BST0MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwcm9jZXNzZWQgPSBmaWVsZFtPUFRfRklFTERfTkFNRV9QUkVfUFJPQ10oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJFcnJvciB3aGlsZSBwcmVwcm9jZXNzaW5nIGNlbGwgdmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm90UGF0aC5zZXQoZmllbGQucGF0aCwgcmVmaW5lZCwgcHJlcHJvY2Vzc2VkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub3RQYXRoLnNldChmaWVsZC5wYXRoLCByZWZpbmVkLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0b3Jlcy5yZWZpbmVkLnVwZGF0ZSgodmFsKSA9PiB7XG4gICAgICAgICAgICB2YWwuc3BsaWNlKDAsIHZhbC5sZW5ndGgsIC4uLnJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnVpKSB7XG4gICAgICAgICAgICB0aGlzLnVpW25hbWVdLiRkZXN0cm95ICYmIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVpW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RUYWJsZTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IFVJTG9hZGVyIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLmxvYWRlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlDb250YWluZXIgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2xheW91dC91aS5jb250YWluZXIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTm90aWZpY2F0aW9uRXJyb3IgZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL25vdGlmaWNhdGlvbi91aS5lcnJvci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOb3RpZmljYXRpb25TdWNjZXNzIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9ub3RpZmljYXRpb24vdWkuc3VjY2Vzcy5zdmVsdGVcIjtcblxuICAgIC8vaGlkZGVuIC0gbm8gbG9hZGVyXG4gICAgLy9jb250YWluZXIgLSBwYXJlbnQgY29udGFpbmVyIG9mIGZvcm1cblxuICAgIGxldCBzdWNjZXNzID0gJHN0YXRlKGZhbHNlKTtcblxuICAgIGxldCBlcnJvciA9ICRzdGF0ZShmYWxzZSk7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2NvbnRhaW5lcl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xvYWRlclRpdGxlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRlckFjdGl2ZV0gLSBzdGF0ZSBpZiBmb3JtIGxvYWRpbmdcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2xvYWRlclNpemVdIC0gcGFnZSAtIHdob2xlIHBhZ2VcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N1Y2Nlc3NUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N1Y2Nlc3NNZXNzYWdlXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JUaXRsZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2Vycm9yTWVzc2FnZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgY29udGFpbmVyID0ge30sXG4gICAgICAgIGxvYWRlclRpdGxlID0gJGJpbmRhYmxlKFwi0J7RgtC/0YDQsNCy0LrQsCDQtNCw0L3QvdGL0YUg0L3QsCDRgdC10YDQstC10YBcIiksXG4gICAgICAgIGxvYWRlckFjdGl2ZSA9ICRiaW5kYWJsZShmYWxzZSksXG4gICAgICAgIGxvYWRlclNpemUgPSAkYmluZGFibGUoXCJjb250YWluZXJcIiksXG4gICAgICAgIHN1Y2Nlc3NUaXRsZSA9ICRiaW5kYWJsZShcIk9LXCIpLFxuICAgICAgICBzdWNjZXNzTWVzc2FnZSA9ICRiaW5kYWJsZShcIlwiKSxcbiAgICAgICAgZXJyb3JUaXRsZSA9ICRiaW5kYWJsZShcIkVycm9yXCIpLFxuICAgICAgICBlcnJvck1lc3NhZ2UgPSAkYmluZGFibGUoXCJcIiksXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNob3dTdWNjZXNzKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBpZiAobWVzc2FnZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGl0bGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdWNjZXNzVGl0bGUgPSB0aXRsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzaG93RXJyb3IodGl0bGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBlcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChtZXNzYWdlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGl0bGUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvclRpdGxlID0gdGl0bGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0TG9hZGluZygpIHtcbiAgICAgICAgbG9hZGVyQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiByZXNldExvYWRpbmcoKSB7XG4gICAgICAgIGxvYWRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBoaWRlQWxsKCkge1xuICAgICAgICBsb2FkZXJBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48VUlMb2FkZXJcbiAgICBiaW5kOmxvYWRpbmc9e2xvYWRlckFjdGl2ZX1cbiAgICBiaW5kOnRpdGxlPXtsb2FkZXJUaXRsZX1cbiAgICBiaW5kOnNpemU9e2xvYWRlclNpemV9XG4vPlxuPFVJQ29udGFpbmVyIHsuLi5jb250YWluZXJ9PlxuICAgIHsjaWYgZXJyb3J9XG4gICAgICAgIDxVSU5vdGlmaWNhdGlvbkVycm9yXG4gICAgICAgICAgICBiaW5kOnRpdGxlPXtlcnJvclRpdGxlfVxuICAgICAgICAgICAgYmluZDptZXNzYWdlPXtlcnJvck1lc3NhZ2V9XG4gICAgICAgIC8+XG4gICAgey9pZn1cbiAgICB7I2lmIHN1Y2Nlc3N9XG4gICAgICAgIDxVSU5vdGlmaWNhdGlvblN1Y2Nlc3NcbiAgICAgICAgICAgIGJpbmQ6dGl0bGU9e3N1Y2Nlc3NUaXRsZX1cbiAgICAgICAgICAgIGJpbmQ6bWVzc2FnZT17c3VjY2Vzc01lc3NhZ2V9XG4gICAgICAgIC8+XG4gICAgey9pZn1cbjwvVUlDb250YWluZXI+XG4iLCJpbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vLi4vYmFzZVwiO1xuXG5pbXBvcnQgVUlBY3Rpb25Db250YWluZXIgZnJvbSBcIi4vdWkuYWN0aW9uLmNvbnRhaW5lci5zdmVsdGVcIjtcbmNvbnN0IERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCIuY29udGFpbmVyXCI7XG5pbXBvcnQgeyBERUZBVUxUX1NUQVRVU19TVUNDRVNTIH0gZnJvbSBcIi4uLy4uL2NvbnN0XCI7XG5cbmNsYXNzIG5vdEFjdGlvblVJIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgLy9VSSByZW5kZXJlciBjb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAjdWlDb21wb25lbnQgPSBudWxsO1xuICAgICN1aSA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICAgIHRhcmdldCA9IG51bGwsXG4gICAgICAgIG5hbWUgPSBcIkRlZmF1bHRcIixcbiAgICAgICAgb3B0aW9ucyA9IHt9LFxuICAgICAgICB3b3JraW5nID0ge30sXG4gICAgICAgIGRhdGEgPSB7fSxcbiAgICAgICAgdWkgPSBVSUFjdGlvbkNvbnRhaW5lciwgLy9kZWZhdWx0IFVJXG4gICAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7bmFtZX1BY3Rpb25VSWAsXG4gICAgICAgICAgICAgICAgLi4ud29ya2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VpQ29tcG9uZW50ID0gdWk7XG4gICAgICAgIHRoaXMuaW5pdFVJKCk7XG4gICAgfVxuXG4gICAgaW5pdFVJKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXRFbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUNoaWxkKHRhcmdldC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHRoaXMuI3VpID0gbmV3IHRoaXMuI3VpQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHRoaXMuZ2V0T3B0aW9ucygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRMb2FkaW5nKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJsb2FkaW5nXCIpO1xuICAgICAgICB0aGlzLiN1aS5zZXRMb2FkaW5nKCk7XG4gICAgfVxuXG4gICAgcmVzZXRMb2FkaW5nKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJsb2FkZWRcIik7XG4gICAgICAgIHRoaXMuI3VpLnJlc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgICAgIGlmICh0aGlzLiN1aSkge1xuICAgICAgICAgICAgdGhpcy4jdWkuJGRlc3Ryb3kgJiYgdGhpcy4jdWkuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuI3VpLmRlc3Ryb3kgJiYgdGhpcy4jdWkuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy4jdWkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1Jlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9ybVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtRXJyb3JzKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgIEZvcm0gdmFsaWRhdGlvbiByZXN1bHRcbiAgICAgKiovXG4gICAgc2V0Rm9ybVN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuI3VpLnNob3dTdWNjZXNzKCk7XG4gICAgICAgIHRoaXMuZW1pdChcInN1Y2Nlc3NcIik7XG4gICAgfVxuXG4gICAgc2V0Rm9ybUVycm9ycyhyZXN1bHQpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgZm9ybTogW10sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN0YXR1cy5mb3JtLnB1c2gocmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmIE9iamVjdC5rZXlzKHJlc3VsdC5lcnJvcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXR1cy5maWVsZHMgPSB7IC4uLnJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiN1aS5zaG93RXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgc3RhdHVzKTtcbiAgICB9XG5cbiAgICAvKioqXG4gICAgICogUmVkZWZpbmFibGUgZ2V0dGVyc1xuICAgICAqKi9cbiAgICBnZXRUYXJnZXRFbCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLmdldE9wdGlvbnMoXCJ0YXJnZXRcIiwgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IpO1xuICAgICAgICBpZiAodGFyZ2V0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEVsO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXRFbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0RWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aW9uVUkgcGFyZW50IGVsZW1lbnQgaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdEFjdGlvblVJO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vY29tbW9uXCI7XG5cbmltcG9ydCB7IEZJRUxEUywgQ09NUE9ORU5UUywgVkFSSUFOVFMgfSBmcm9tIFwiLi4vLi4vTElCLmpzXCI7XG5cbmNsYXNzIG5vdEZvcm1VdGlscyB7XG4gICAgc3RhdGljIHZhbGlkYXRvciA9IG51bGw7XG5cbiAgICBzdGF0aWMgYWRkQ29tcG9uZW50KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIENPTVBPTkVOVFMuYWRkKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWRkVmFyaWFudHMobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgVkFSSUFOVFMuYWRkKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYWRkRmllbGQobmFtZSwgZmllbGQpIHtcbiAgICAgICAgRklFTERTLmFkZChuYW1lLCBmaWVsZCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFjdGlvbkZpZWxkc0luaXQoZmllbGROYW1lLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZS5mb3JFYWNoKChzdWJGaWVsZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbkZpZWxkc0luaXQoc3ViRmllbGROYW1lLCBvcHRpb25zLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFub3RDb21tb24ub2JqSGFzKG9wdGlvbnMsIFwiZmllbGRzXCIpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm90Q29tbW9uLm9iakhhcyhvcHRpb25zLmZpZWxkcywgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmllbGRzW2ZpZWxkTmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29weWluZyBpbml0aWFsIGRhdGFcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIGRhdGEgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YVtmaWVsZE5hbWVdICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgZGF0YVtmaWVsZE5hbWVdICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkc1tmaWVsZE5hbWVdLnZhbHVlID0gZGF0YVtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RGb3JtVXRpbHM7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb25cIjtcblxuY29uc3QgREVGQVVMVF9GSUVMRCA9IHtcbiAgICBsYWJlbDogXCJcIixcbiAgICBwbGFjZWhvbGRlcjogXCJcIixcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHZpc2libGU6IHRydWUsXG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdmFsaWRhdGVkOiBmYWxzZSxcbiAgICB2YWxpZDogZmFsc2UsXG4gICAgZXJyb3JzOiBmYWxzZSxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBmaWVsZCBtYW5pZmVzdFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgICAgICBuYW1lL3R5cGUgb2YgdGhlIGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gbXV0YXRpb24gIG11dGF0aW9uIHRvIG1hbmlmZXN0IGZyb20gbGlicmFyeVxuICogQHBhcmFtIHtPYmplY3R9IFZBUklBTlRTICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCB2YWx1ZSB2YXJpYW50c1xuICogQHBhcmFtIHtPYmplY3R9IEZJRUxEUyAgICBzdG9yZSB3aGljaCBjb250YWlucyBuYW1lZCBsaXN0cyBvZiBmaWVsZCBtYW5pZmVzdHNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgZmllbGQgbWFuaWZlc3RcbiAqKi9cbmZ1bmN0aW9uIGZpZWxkSW5pdCh0eXBlLCBtdXRhdGlvbiA9IHt9LCBWQVJJQU5UUywgRklFTERTKSB7XG4gICAgbGV0IGZpZWxkID0geyAuLi5ERUZBVUxUX0ZJRUxEIH07XG4gICAgLy9nZXR0aW5nIGZpZWxkIGNvcmUgbWFuaWZlc3RcbiAgICBpZiAoRklFTERTLmNvbnRhaW5zKHR5cGUpKSB7XG4gICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICAuLi5GSUVMRFMuZ2V0KHR5cGUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvL2FkZGluZyBtdXRhdGlvbnNcbiAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIC4uLm11dGF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvL2FkZGluZyB2YXJpYW50cyBsaXN0IHRvIGZpZWxkIGZyb20gVkFSSUFOVFMgc3RvcmVcbiAgICBpZiAoXG4gICAgICAgIG5vdENvbW1vbi5vYmpIYXMoZmllbGQsIFwidmFyaWFudHNTb3VyY2VcIikgJiZcbiAgICAgICAgVkFSSUFOVFMuY29udGFpbnMoZmllbGQudmFyaWFudHNTb3VyY2UpXG4gICAgKSB7XG4gICAgICAgIGZpZWxkLnZhcmlhbnRzID0gVkFSSUFOVFMuZ2V0KGZpZWxkLnZhcmlhbnRzU291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWZpZWxkLnZhcmlhbnRzIHx8IGZpZWxkLnZhcmlhbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZmllbGQudmFyaWFudHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb24gb2YgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gZmllbGROYW1lICAgICBuYW1lIG9mIHRoZSBmaWVsZCB0eXBlIGlmIHN0cmluZywgYXJyYXkgb2Ygc3RyaW5ncyA9IHN1YmZvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIFZBUklBTlRTICAgICAgc3RvcmUgd2hpY2ggY29udGFpbnMgbmFtZWQgbGlzdHMgb2YgZmllbGQgdmFsdWUgdmFyaWFudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgICAgIEZJRUxEUyAgICAgICAgc3RvcmUgd2hpY2ggY29udGFpbnMgbmFtZWQgbGlzdHMgb2YgZmllbGQgbWFuaWZlc3RzXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgICAgICBmb3JtRmllbGRzT3B0aW9ucyAgIGZvcm0gd2lkZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICoqL1xuZnVuY3Rpb24gaW5pdEZvcm1CeUZpZWxkKFxuICAgIGZvcm0gPSB7fSxcbiAgICBmaWVsZE5hbWUgPSBbXSxcbiAgICBWQVJJQU5UUyxcbiAgICBGSUVMRFMsXG4gICAgZm9ybUZpZWxkc09wdGlvbnMsXG4gICAgZGF0YVxuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGROYW1lKSkge1xuICAgICAgICBmaWVsZE5hbWUuZm9yRWFjaCgoc3ViRm9ybUZpZWxkTmFtZSkgPT5cbiAgICAgICAgICAgIGluaXRGb3JtQnlGaWVsZChcbiAgICAgICAgICAgICAgICBmb3JtLFxuICAgICAgICAgICAgICAgIHN1YkZvcm1GaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgVkFSSUFOVFMsXG4gICAgICAgICAgICAgICAgRklFTERTLFxuICAgICAgICAgICAgICAgIGZvcm1GaWVsZHNPcHRpb25zLFxuICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3JtRmllbGRzT3B0aW9ucyAmJlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmb3JtRmllbGRzT3B0aW9ucywgXCJtdXRhdGlvbnNcIikgJiZcbiAgICAgICAgICAgIG5vdENvbW1vbi5vYmpIYXMoZm9ybUZpZWxkc09wdGlvbnMubXV0YXRpb25zLCBmaWVsZE5hbWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3B0cyA9IGZvcm1GaWVsZHNPcHRpb25zLm11dGF0aW9uc1tmaWVsZE5hbWVdOyAvL29wdGlvbiBtdXRhdGlvbiBmb3IgZmllbGRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAmJiBub3RDb21tb24ub2JqSGFzKGRhdGEsIGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIG9wdHMudmFsdWUgPSBkYXRhW2ZpZWxkTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9ybVtmaWVsZE5hbWVdID0gZmllbGRJbml0KGZpZWxkTmFtZSwgb3B0cywgVkFSSUFOVFMsIEZJRUxEUyk7XG4gICAgICAgIC8vaWYgZm9ybSByZWFkb25seSwgbWFya2luZyBldmVyeSBmaWVsZCBhcyByZWFkb25seVxuICAgICAgICBpZiAoZm9ybUZpZWxkc09wdGlvbnMgJiYgZm9ybUZpZWxkc09wdGlvbnMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIGZvcm1bZmllbGROYW1lXS5yZWFkb25seSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm07XG59XG5cbi8qKlxuICogIE1hcmtpbmcgZmllbGQgYXMgaW52YWxpZCBieSBvd24gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgIGZpZWxkTmFtZSAgICAgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEBwYXJhbSB7YW55fSAgICAgICAgICAgICAgdmFsdWUgICAgICAgICB2YWx1ZSBvZiBmaWVsZFxuICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICBlcnJvcnMgICAgICAgIGxpc3Qgb2YgZXJyb3JzXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBzZXRGaWVsZEludmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSwgZXJyb3JzKSB7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmVycm9ycyA9IFsuLi5lcnJvcnNdO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWxpZCA9IGZhbHNlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBmb3JtO1xufVxuXG4vKipcbiAqICBNYXJraW5nIGZpZWxkIGFzIHZhbGlkIGJ5IG93biB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgZmllbGROYW1lICAgICBuYW1lIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIHthbnl9ICAgICAgICAgICAgICB2YWx1ZSAgICAgICAgIHZhbHVlIG9mIGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBzZXRGaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZXJyb3JzID0gZmFsc2U7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLnZhbGlkID0gdHJ1ZTtcbiAgICBmb3JtW2ZpZWxkTmFtZV0udmFsdWUgPSB2YWx1ZTtcblxuICAgIGZvciAobGV0IGZuYW1lIGluIGZvcm0pIHtcbiAgICAgICAgaWYgKGZuYW1lICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGZvcm1bZm5hbWVdLmVycm9ycykgJiZcbiAgICAgICAgICAgICAgICBmb3JtW2ZuYW1lXS5lcnJvcnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBmb3JtW2ZuYW1lXS5lcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtW2ZuYW1lXS5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGZpZWxkIGhhcyBlcnJvcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgZm9ybSAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgZmllbGROYW1lICAgICBuYW1lIG9mIHRoZSBmaWVsZFxuICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgIHRydWUgLSB2YWxpZCwgZmFsc2UgLWludmFsaWRcbiAqKi9cbmZ1bmN0aW9uIGlzRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoZm9ybVtmaWVsZE5hbWVdLmVycm9ycyk7XG59XG5cbi8qKlxuICogRm9ybSBsZXZlbCB2YWxpZGF0b3IgZXJyb3IgaW4gdGhpcyBmaWVsZFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcGFyYW0gIHtBcnJheTxzdHJpbmc+fSAgIGVycm9ycyAgICAgICAgbGlzdCBvZiBlcnJvcnNcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqKi9cbmZ1bmN0aW9uIHNldEZvcm1GaWVsZEludmFsaWQoZm9ybSwgZmllbGROYW1lLCBlcnJvcnMpIHtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZm9ybUVycm9ycyA9IFsuLi5lcnJvcnNdO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS5pbnB1dFN0YXJ0ZWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWxpZCA9IGZhbHNlO1xuICAgIGZvcm1bZmllbGROYW1lXS5mb3JtTGV2ZWxFcnJvciA9IHRydWU7XG4gICAgcmV0dXJuIGZvcm07XG59XG4vKipcbiAqIEZvcm0gbGV2ZWwgdmFsaWRhdG9yIHN1Y2Nlc3MgaW4gdGhpcyBmaWVsZFxuICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgICBmb3JtICAgICAgICAgIGZvcm0gc3RydWN0dXJlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICBmaWVsZE5hbWUgICAgIG5hbWUgb2YgdGhlIGZpZWxkXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBzdHJ1Y3R1cmUgb2JqZWN0XG4gKiovXG5mdW5jdGlvbiBzZXRGb3JtRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpIHtcbiAgICBmb3JtW2ZpZWxkTmFtZV0uZm9ybUVycm9ycyA9IGZhbHNlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIGZvcm1bZmllbGROYW1lXS52YWxpZCA9IHRydWU7XG4gICAgZm9ybVtmaWVsZE5hbWVdLmZvcm1MZXZlbEVycm9yID0gZmFsc2U7XG4gICAgcmV0dXJuIGZvcm07XG59XG5cbi8qKlxuICogVXBkYXRlcyBmaWVsZHMgYW5kIGZvcm0gZXJyb3IgbGFiZWxzXG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgIGZvcm0gICAgICAgICAgICAgICAgICBmb3JtIHN0cnVjdHVyZSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cyAgICAgIHJlc3VsdHMgb2YgdmFsaWRhdGlvblxuICoqL1xuZnVuY3Rpb24gdXBkYXRlRm9ybVZhbGlkYXRpb25TdGF0dXMoXG4gICAge1xuICAgICAgICBmb3JtLFxuICAgICAgICBmb3JtRXJyb3JzLFxuICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLFxuICAgIH0gLyogRm9ybVZhbGlkYXRpb25TZXNzaW9uLmdldENvbXBsZXRlUmVzdWx0KCkgKi9cbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRpb25TdGF0dXMuZm9ybSkgJiYgdmFsaWRhdGlvblN0YXR1cy5mb3JtLmxlbmd0aCkge1xuICAgICAgICBmb3JtRXJyb3JzLnNwbGljZSgwLCBmb3JtRXJyb3JzLmxlbmd0aCwgLi4udmFsaWRhdGlvblN0YXR1cy5mb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtRXJyb3JzLnNwbGljZSgwLCBmb3JtRXJyb3JzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmICh2YWxpZGF0aW9uU3RhdHVzLmZpZWxkcykge1xuICAgICAgICBmb3IgKGxldCBmaWVsZE5hbWUgaW4gdmFsaWRhdGlvblN0YXR1cy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV0pICYmXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXS5sZW5ndGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHNldEZvcm1GaWVsZEludmFsaWQoXG4gICAgICAgICAgICAgICAgICAgIGZvcm0sXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblN0YXR1cy5maWVsZHNbZmllbGROYW1lXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEZvcm1GaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEZpZWxkc1Zpc2liaWxpdHkoZm9ybSwgZmllbGRzTGlzdCwgdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzTGlzdCkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybSkuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBmb3JtW2ZpZWxkTmFtZV0udmlzaWJsZSA9IGZpZWxkc0xpc3QuaW5jbHVkZXMoZmllbGROYW1lKVxuICAgICAgICAgICAgICAgID8gdmFsXG4gICAgICAgICAgICAgICAgOiAhdmFsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2V0RmllbGRWYWx1ZShmb3JtLCBmaWVsZE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5vdENvbW1vbi5vYmpIYXMoZm9ybSwgZmllbGROYW1lKSkge1xuICAgICAgICBmb3JtW2ZpZWxkTmFtZV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmllbGRJc1Zpc2libGVBbmRGaWxsZWQoZm9ybSwgZmllbGROYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgbm90Q29tbW9uLm9iakhhcyhmb3JtLCBmaWVsZE5hbWUpICYmXG4gICAgICAgIGZvcm1bZmllbGROYW1lXS5lbmFibGVkICYmXG4gICAgICAgIGZvcm1bZmllbGROYW1lXS52aXNpYmxlICYmXG4gICAgICAgIHR5cGVvZiBmb3JtW2ZpZWxkTmFtZV0udmFsdWUgIT09IFwidW5kZWZpbmVkXCJcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0RGF0YShmaWVsZHMsIGZvcm0pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZmllbGRzLmZsYXQoKS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkSXNWaXNpYmxlQW5kRmlsbGVkKGZvcm0sIGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gZm9ybVtmaWVsZE5hbWVdLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZpZWxkSW5pdCxcbiAgICBpbml0Rm9ybUJ5RmllbGQsXG4gICAgc2V0RmllbGRJbnZhbGlkLFxuICAgIHNldEZpZWxkVmFsaWQsXG4gICAgaXNGaWVsZFZhbGlkLFxuICAgIHNldEZvcm1GaWVsZEludmFsaWQsXG4gICAgc2V0Rm9ybUZpZWxkVmFsaWQsXG4gICAgdXBkYXRlRm9ybVZhbGlkYXRpb25TdGF0dXMsXG4gICAgZmllbGRJc1Zpc2libGVBbmRGaWxsZWQsXG4gICAgc2V0RmllbGRzVmlzaWJpbGl0eSxcbiAgICBzZXRGaWVsZFZhbHVlLFxuICAgIGNvbGxlY3REYXRhLFxufTtcbiIsImNvbnN0IGVtcHR5RmllbGRzUmVzdWx0cyA9IChkYXRhKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICAgIGFjY1tjdXJyXSA9IFtdO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn07XG5cbmNvbnN0IEZJRUxEUyA9IFtcImZpZWxkc1wiLCBcImZvcm1cIl07XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgI2NsZWFuID0gdHJ1ZTtcbiAgICAjcmVzdWx0O1xuXG4gICAgY29uc3RydWN0b3IocmVzdWx0KSB7XG4gICAgICAgIHRoaXMuI3Jlc3VsdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuI3Jlc3VsdCkuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUZJRUxEUy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuI3Jlc3VsdFtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2xlYW4gPSB0aGlzLiNyZXN1bHQuZm9ybS5lcnJvcnMubGVuZ3RoID09PSAwO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy4jZ2V0RmllbGRzTGlzdCgpO1xuICAgICAgICBmb3IgKGxldCBmaWVsZE5hbWUgb2YgbGlzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaWVsZERpcnR5KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4jcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldCBjbGVhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NsZWFuO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXREZWZhdWx0UmVzdWx0KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpZWxkczogZW1wdHlGaWVsZHNSZXN1bHRzKGRhdGEpLFxuICAgICAgICAgICAgZm9ybToge1xuICAgICAgICAgICAgICAgIGZpZWxkczogZW1wdHlGaWVsZHNSZXN1bHRzKGRhdGEpLFxuICAgICAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldFJlcG9ydCgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy4jZ2V0Q29tcGxldGVSZXN1bHQoKSkpO1xuICAgIH1cblxuICAgIGdldERldGFpbGVkUmVwb3J0KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuI3Jlc3VsdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy4jcmVzdWx0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNGaWVsZERpcnR5KGZpZWxkTmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuI3Jlc3VsdC5maWVsZHNbZmllbGROYW1lXSkgJiZcbiAgICAgICAgICAgIHRoaXMuI3Jlc3VsdC5maWVsZHNbZmllbGROYW1lXS5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuI3Jlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdKSAmJlxuICAgICAgICAgICAgdGhpcy4jcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0ubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGdldENvbXBsZXRlUmVzdWx0Rm9yRmllbGQoZmllbGROYW1lKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkUmVzdWx0ID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuI3Jlc3VsdC5maWVsZHNbZmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgIGZpZWxkUmVzdWx0LnB1c2goLi4udGhpcy4jcmVzdWx0LmZpZWxkc1tmaWVsZE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLiNyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgIGZpZWxkUmVzdWx0LnB1c2goLi4udGhpcy4jcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFJlc3VsdDtcbiAgICB9XG5cbiAgICAjZ2V0Q29tcGxldGVSZXN1bHQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdENvbXBsZXRlID0ge1xuICAgICAgICAgICAgY2xlYW46IHRoaXMuI2NsZWFuLFxuICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgICAgIGZvcm06IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy4jZ2V0RmllbGRzTGlzdCgpO1xuICAgICAgICBmb3IgKGxldCBmaWVsZE5hbWUgb2YgbGlzdCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy5nZXRDb21wbGV0ZVJlc3VsdEZvckZpZWxkKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdENvbXBsZXRlLmZpZWxkc1tmaWVsZE5hbWVdID0gZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdENvbXBsZXRlLmZvcm0gPSBbLi4udGhpcy4jcmVzdWx0LmZvcm0uZXJyb3JzXTtcbiAgICAgICAgaWYgKHJlc3VsdENvbXBsZXRlLmZvcm0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0Q29tcGxldGUuZm9ybTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Q29tcGxldGU7XG4gICAgfVxuXG4gICAgI2dldEZpZWxkc0xpc3QoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuI3Jlc3VsdC5maWVsZHMpO1xuICAgICAgICBjb25zdCBmaWVsZHNJbkZvcm0gPSBPYmplY3Qua2V5cyh0aGlzLiNyZXN1bHQuZm9ybS5maWVsZHMpO1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoWy4uLmZpZWxkc0luRm9ybSwgLi4uZmllbGRzXSldO1xuICAgIH1cbn07XG4iLCIvKipcbipcdFRlbXBsYXRlIG9mIGVycm9yLmpzXG4qXHRGb3IgYnVpbGRpbmcgZm9yIHNwZWNpZmljIGVudmlyb25tZW50LlxuKlx0Tm9kZS5qcyBvciBCcm93c2VyXG4qXHRAcGFyYW0ge3N0cmluZ31cdGVudlx0bm9kZXxicm93c2VyIGluIHdpY2ggZW52IGl0IHdpbGwgYmUgcnVubmluZ1xuKlx0QHBhcmFtIHtzdHJpbmd9XHR1cmxcdFVSTCBvZiByZXBvcnQgY29sbGVjdG9yXG4qXHRAcGFyYW0ge3N0cmluZ31cdGtleVx0a2V5IHRvIGluZGV0aWZpY2F0ZSByZXBvcnRlclxuKi9cbi8qKlxuKiBFcnJvciByZXBvcnRpbmcgd2l0aCBmZWF0dXJlcywgc2F2aW5nIGJyb3dzZXIgaW5mbywgdXJpIGFuZCBzbyBvbi5cbiogQG1vZHVsZSBub3QtZXJyb3IvZXJyb3JcbiovXG5jbGFzcyBub3RFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucyA9IHt9LCBlcnJvciA9IG51bGwpe1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5hZG9wdChlcnJvcik7XG5cdFx0dGhpcy5maWxsKCk7XG5cdFx0dGhpcy5nZXRUaW1lKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0Klx0QWRvcHRpbmcgbmF0aXZlIGVycm9yIG9iamVjdFxuXHQqXHRAcGFyYW0ge0Vycm9yfVx0ZXJyb3IgXHRFcnJvciBvYmplY3Rcblx0Klx0QHJldHVybiB7bm90RXJyb3J9XHRcdGNoYWluYWJsZVxuXHQqL1xuXHRhZG9wdChlcnJvcil7XG5cdFx0aWYoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcil7XG5cdFx0XHR0aGlzLnBhcmVudCA9IGVycm9yO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGdldFN0YWNrKCl7XG5cdFx0aWYodGhpcy5wYXJlbnQpe1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LnN0YWNrO1xuXHRcdH1lbHNle1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhY2s7XG5cdFx0fVxuXHR9XG5cblx0Z2V0RGV0YWlscygpe1xuXHRcdGxldCBzcmMgPSB0aGlzO1xuXHRcdGlmKHRoaXMucGFyZW50KXtcblx0XHRcdHNyYyA9IHRoaXMucGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29sdW1uTnVtYmVyOiAgICBcdHNyYy5jb2x1bW5OdW1iZXIsXG5cdFx0XHRmaWxlTmFtZTogICAgICAgIFx0c3JjLmZpbGVOYW1lLFxuXHRcdFx0bGluZU51bWJlcjogICAgICBcdHNyYy5saW5lTnVtYmVyLFxuXHRcdFx0bmFtZTogICAgICAgICAgICBcdHNyYy5uYW1lLFxuXHRcdFx0bWVzc2FnZTogICAgICAgIFx0c3JjLm1lc3NhZ2UsXG5cdFx0XHRzdGFjazogICAgICAgICAgXHRzcmMuc3RhY2tcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCpcdFVwZGF0aW5nIHRoaXMuZW52LmRhdGUgcHJvcGVydHlcblx0Klx0QHJldHVybiAge29iamVjdH1cdHt0aW1lc3RhbXAsIG9mZnNldH1cblx0Ki9cblx0Z2V0VGltZSgpe1xuXHRcdGxldCBkYXRlID0gbmV3IERhdGUoKTtcblx0XHR0aGlzLmVudi5kYXRlID0ge1xuXHRcdFx0dGltZXN0YW1wIDogZGF0ZS5nZXRUaW1lKCksXG5cdFx0XHRvZmZzZXQ6IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKVxuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMuZW52LmRhdGU7XG5cdH1cblxuXG5cdC8qKlxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCoqKlx0Tm9kZS5qcyBTZWN0aW9uXG5cdCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KiovXG5cblx0LyoqXG5cdCpcdEZpbHRlcmluZyBvdXQga2V5IGJ5IGB3aGl0ZWAgbGlzdFxuXHQqXHRAcGFyYW0ge29iamVjdH0gb2JqZWN0IGhhc2ggdG8gYmUgY29waWVkIGFjY29yZGluZyBmaWx0ZXIgYHdoaXRlYCBsaXN0XG5cdCpcdEBwYXJhbSB7YXJyYXl9IGZpbHRlciBhcnJheSBvZiBzdGluZywgd2hpY2ggcmVwcmVzZW50cyBrZXlzIHdlIHdhbnQgdG8gYmVcblx0Klx0XHRcdFx0XHRcdGNvcGllZCBpbiByZXN1bHRpbmcgb2JqZWN0IGZyb20gc291cmNlXG5cdCpcdEByZXR1cm4ge29iamVjdH1cdFx0d2hpdGUgbGlzdGVkIGhhc2hcblx0Ki9cblx0ZmlsdGVyRW52KG9iamVjdCwgZmlsdGVyKXtcblx0XHRsZXQgcmVzdWx0ID0ge307XG5cdFx0Zm9yKGxldCB0IG9mIGZpbHRlcil7XG5cdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCB0KSl7XG5cdFx0XHRcdHJlc3VsdFt0XSA9IG9iamVjdFt0XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQqXHRDb2xsZWN0aW5nIGluZm9ybWF0aW9uIHNwZWNpZmljIGZvciBOb2RlLmpzIFY4XG5cdCpcdEByZXR1cm4ge25vdEVycm9yfVx0XHRjaGFpbmFibGVcblx0Ki9cblx0ZmlsbCgpe1xuXHRcdC8qKlxuXHRcdCpcdFlvdSB3YW50IHNvbWUgZmllbGRzIGZyb20gZW52IGJ1dCBub3QgYWxsLCBjYXVzZSB0aGVyZSBhcmUgcGFzc3dvcmRzXG5cdFx0Klx0ZnJvbSBkYiwgYXBpIGtleXMgYW5kIGV0Y1xuXHRcdCovXG5cdFx0dGhpcy5lbnYgPSB7XG5cdFx0XHRicm93c2VyOiBcdGZhbHNlLFxuXHRcdFx0bm9kZTogXHRcdHRydWUsXG5cdFx0XHR2ZXJzaW9uczogT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy52ZXJzaW9ucyksXG5cdFx0XHR2YXJzOiBcdFx0dGhpcy5maWx0ZXJFbnYocHJvY2Vzcy5lbnYsIHRoaXMub3B0aW9ucy53aGl0ZWxpc3QgfHwgWydOT0RFX0VOViddKVxuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBub3RFcnJvcjtcblxuIiwiXG5jb25zdCBub3RFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Iubm9kZS5janMnKTtcblxuXG4vL3JlcG9ydGFibGVcbmNsYXNzIG5vdFZhbGlkYXRpb25FcnJvciBleHRlbmRzIG5vdEVycm9ye1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBmaWVsZHMgPSB7fSwgZXJyID0gbnVsbCwgcGFyYW1zID0ge30pe1xuICAgIHN1cGVyKG1lc3NhZ2UsIHtmaWVsZHMsIHBhcmFtc30sIGVycik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgKiBTZXRzIGhhc2ggb2YgZmllbGRzIGVycm9ycyBtZXNzYWdlcyBmb3IgdXNhZ2UgaW4gZm9ybXNcbiAgKlx0QHJldHVybiB7T2JqZWN0fVx0aGFzaCBvZiBmaWVsZC0+ZXJyb3JzIFtrZXk6c3RyaW5nXTogQXJyYXk8c3RyaW5nPlxuICAqKi9cbiAgc2V0RmllbGRzRXJyb3JzKG1lc3NhZ2VzKXtcbiAgICB0aGlzLm9wdGlvbnMuZmllbGRzID0gbWVzc2FnZXM7XG4gIH1cblxuICAvKipcbiAgKiBSZXR1cm5zIGhhc2ggb2YgZXJyb3JzXG4gICpcdEByZXR1cm4ge09iamVjdH1cdGhhc2ggb2YgZmllbGQtPmVycm9ycyBba2V5OnN0cmluZ106IEFycmF5PHN0cmluZz5cbiAgKiovXG4gIGdldEZpZWxkc0Vycm9ycygpe1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmllbGRzO1xuICB9XG5cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vdFZhbGlkYXRpb25FcnJvcjtcblxuIiwiLyoqXG4gKiBUZXN0IGFyZ3VtZW50IHR5cGUgdG8gYmUgJ2Z1bmN0aW9uJ1xuICogQHBhcmFtIHthbnl9ICBmdW5jICAgIHBvc3NpYmxlIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSAgICAgaWYgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gKiovXG5jb25zdCBpc0Z1bmMgPSAoZnVuYykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYXJndW1lbnQgaXMgQXN5bmMgZnVuY3Rpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgIGlmIHRoaXMgZnVuY3Rpb24gaXMgY29uc3RydWN0ZWQgYXMgQXN5bmNGdW5jdGlvblxuICoqL1xuY29uc3QgaXNBc3luYyA9IChmdW5jKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJBc3luY0Z1bmN0aW9uXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIChwcm9jLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoaXNGdW5jKHByb2MpKSB7XG4gICAgICAgIGlmIChpc0FzeW5jKHByb2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvYyguLi5wYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb2MoLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCJjb25zdCBWYWxpZGF0aW9uUmVzdWx0ID0gcmVxdWlyZShcIi4vcmVzdWx0XCIpO1xuY29uc3Qgbm90VmFpbGRhdGlvbkVycm9yID0gcmVxdWlyZShcIm5vdC1lcnJvci9zcmMvdmFsaWRhdGlvbi5lcnJvci5ub2RlLmNqc1wiKTtcbmNvbnN0IGV4ZWN1dGVPYmplY3RGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuY29uc3QgVmFsaWRhdGlvblNlc3Npb24gPSBhc3luYyAodmFsaWRhdG9ycywgZGF0YSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFZhbGlkYXRpb25SZXN1bHQuZ2V0RGVmYXVsdFJlc3VsdChkYXRhKTtcbiAgICBhd2FpdCB2YWxpZGF0ZUZpZWxkcyh7IHZhbGlkYXRvcnMsIGRhdGEsIHJlc3VsdCB9KTtcbiAgICBhd2FpdCB2YWxpZGF0ZUZvcm0oeyB2YWxpZGF0b3JzLCBkYXRhLCByZXN1bHQgfSk7XG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uUmVzdWx0KHJlc3VsdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25TZXNzaW9uO1xuXG5jb25zdCB2YWxpZGF0ZUZpZWxkcyA9IGFzeW5jICh7IHZhbGlkYXRvcnMsIGRhdGEsIHJlc3VsdCB9KSA9PiB7XG4gICAgZm9yIChsZXQgdCBpbiBkYXRhKSB7XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlRmllbGQodCwgZGF0YVt0XSwgdmFsaWRhdG9ycywgcmVzdWx0KTtcbiAgICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKGZpZWxkTmFtZSwgdmFsdWUsIHZhbGlkYXRvcnMsIHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IGZpZWxkVmFsaWRhdG9ycyA9IGdldEZpZWxkVmFsaWRhdG9ycyhmaWVsZE5hbWUsIHZhbGlkYXRvcnMpO1xuICAgIHJldHVybiBhd2FpdCBydW5GaWVsZFZhbGlkYXRvcnMoZmllbGROYW1lLCB2YWx1ZSwgZmllbGRWYWxpZGF0b3JzLCByZXN1bHQpO1xufTtcblxuY29uc3QgZ2V0RmllbGRWYWxpZGF0b3JzID0gKG5hbWUsIHZhbGlkYXRvcnMpID0+IHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycyAmJiB2YWxpZGF0b3JzLmZpZWxkcyAmJiB2YWxpZGF0b3JzLmZpZWxkc1tuYW1lXVxuICAgICAgICA/IHZhbGlkYXRvcnMuZmllbGRzW25hbWVdXG4gICAgICAgIDogW107XG59O1xuXG5jb25zdCBydW5GaWVsZFZhbGlkYXRvcnMgPSBhc3luYyAoZmllbGROYW1lLCB2YWx1ZSwgdmFsaWRhdG9ycywgcmVzdWx0KSA9PiB7XG4gICAgZm9yIChsZXQgdmFsaWRhdG9yUnVsZSBvZiB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGF3YWl0IGV4ZWN1dGVPYmplY3RGdW5jdGlvbihcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JSdWxlW1widmFsaWRhdG9yXCJdLFxuICAgICAgICAgICAgICAgIFt2YWx1ZV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgc2V0RmllbGRFcnJvcihmaWVsZE5hbWUsIHZhbGlkYXRvclJ1bGUubWVzc2FnZSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBub3RWYWlsZGF0aW9uRXJyb3IgfHwgIXZhbGlkYXRvclJ1bGUubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHNldEZpZWxkRXJyb3IoZmllbGROYW1lLCBlLm1lc3NhZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEZpZWxkRXJyb3IoZmllbGROYW1lLCB2YWxpZGF0b3JSdWxlLm1lc3NhZ2UsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBzZXRGaWVsZEVycm9yID0gKGZpZWxkTmFtZSwgZXJyb3JNZXNzYWdlLCByZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5maWVsZHNbZmllbGROYW1lXS5pbmNsdWRlcyhlcnJvck1lc3NhZ2UpKSB7XG4gICAgICAgIHJlc3VsdC5maWVsZHNbZmllbGROYW1lXS5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgfVxufTtcblxuY29uc3QgdmFsaWRhdGVGb3JtID0gYXN5bmMgKHsgdmFsaWRhdG9ycywgZGF0YSwgcmVzdWx0IH0pID0+IHtcbiAgICBjb25zdCBmb3JtVmFsaWRhdG9ycyA9IGdldEZvcm1WYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgIGF3YWl0IHJ1bkZvcm1WYWxpZGF0b3JzKGRhdGEsIGZvcm1WYWxpZGF0b3JzLCByZXN1bHQpO1xufTtcblxuY29uc3QgZ2V0Rm9ybVZhbGlkYXRvcnMgPSAodmFsaWRhdG9ycykgPT4ge1xuICAgIHJldHVybiB2YWxpZGF0b3JzICYmIHZhbGlkYXRvcnMuZm9ybSA/IHZhbGlkYXRvcnMuZm9ybSA6IFtdO1xufTtcblxuY29uc3QgcnVuRm9ybVZhbGlkYXRvcnMgPSBhc3luYyAoZGF0YSwgZm9ybVZhbGlkYXRvcnMsIHJlc3VsdCkgPT4ge1xuICAgIGZvciAobGV0IHZhbGlkYXRvciBvZiBmb3JtVmFsaWRhdG9ycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdG9yKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiB0eXBlb2YgZS5nZXRGaWVsZHNFcnJvcnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBlLmdldEZpZWxkc0Vycm9ycygpO1xuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZm9ybUVycm9ycy5mb3JtKSAmJlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtRXJyb3JzKGZvcm1FcnJvcnMuZm9ybSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLmZpZWxkcyAmJlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtRmllbGRzRXJyb3JzKGZvcm1FcnJvcnMuZmllbGRzLCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgYWRkRm9ybUVycm9ycyA9IChlcnJvcnMsIHJlc3VsdCkgPT4ge1xuICAgIGVycm9ycy5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgICBhZGRGb3JtRXJyb3IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBhZGRGb3JtRXJyb3IgPSAoZXJyb3JNZXNzYWdlLCByZXN1bHQpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5mb3JtLmVycm9ycy5pbmNsdWRlcyhlcnJvck1lc3NhZ2UpKSB7XG4gICAgICAgIHJlc3VsdC5mb3JtLmVycm9ycy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgfVxufTtcblxuY29uc3QgYWRkRm9ybUZpZWxkc0Vycm9ycyA9IChmaWVsZHNFcnJvcnMsIHJlc3VsdCkgPT4ge1xuICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiBmaWVsZHNFcnJvcnMpIHtcbiAgICAgICAgYWRkRm9ybUZpZWxkRXJyb3JzKGZpZWxkTmFtZSwgZmllbGRzRXJyb3JzW2ZpZWxkTmFtZV0sIHJlc3VsdCk7XG4gICAgfVxufTtcblxuY29uc3QgYWRkRm9ybUZpZWxkRXJyb3JzID0gKGZpZWxkTmFtZSwgZXJyb3JNZXNzYWdlcywgcmVzdWx0KSA9PiB7XG4gICAgZXJyb3JNZXNzYWdlcy5mb3JFYWNoKChlcnJvcikgPT4ge1xuICAgICAgICBhZGRGb3JtRmllbGRFcnJvcihmaWVsZE5hbWUsIGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xufTtcblxuY29uc3QgYWRkRm9ybUZpZWxkRXJyb3IgPSAoZmllbGROYW1lLCBlcnJvck1lc3NhZ2UsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXSkpIHtcbiAgICAgICAgcmVzdWx0LmZvcm0uZmllbGRzW2ZpZWxkTmFtZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQuZm9ybS5maWVsZHNbZmllbGROYW1lXS5pbmNsdWRlcyhlcnJvck1lc3NhZ2UpKSB7XG4gICAgICAgIHJlc3VsdC5mb3JtLmZpZWxkc1tmaWVsZE5hbWVdLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59O1xuIiwiY29uc3QgY29tcG9zZUZpZWxkc1ZhbGlkYXRvcnMgPSAoZGF0YSwgdmFsaWRhdG9yc0xpYikgPT4ge1xuICAgIGlmICh2YWxpZGF0b3JzTGliICYmIHZhbGlkYXRvcnNMaWIuZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGxpc3QuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzTGliLmZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gdmFsaWRhdG9yc0xpYi5maWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG5cbmNvbnN0IGNvbXBvc2VGb3JtVmFsaWRhdG9ycyA9IChuYW1lLCB2YWxpZGF0b3JzTGliKSA9PiB7XG4gICAgaWYgKCF2YWxpZGF0b3JzTGliKSByZXR1cm4gW107XG4gICAgaWYgKHZhbGlkYXRvcnNMaWIuZm9ybXMgJiYgQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzTGliLmZvcm1zW25hbWVdKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yc0xpYi5mb3Jtc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdG9yc0xpYi5mb3JtKSkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yc0xpYi5mb3JtO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb21wb3NlRmllbGRzVmFsaWRhdG9ycyxcbiAgICBjb21wb3NlRm9ybVZhbGlkYXRvcnMsXG59O1xuIiwiY29uc3Qge1xuICAgIGNvbXBvc2VGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGNvbXBvc2VGb3JtVmFsaWRhdG9ycyxcbn0gPSByZXF1aXJlKFwiLi9ydW5uZXIudXRpbHMuanNcIik7XG5cbmNvbnN0IFZhbGlkYXRpb25TZXNzaW9uID0gcmVxdWlyZShcIi4vc2Vzc2lvbi5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIHZhbGlkYXRpb24gcnVubmVyIGZ1bmN0aW9uIGZyb20gcHJvdmlkZWQgdmFsaWRhdGlvbiBydWxlcyBsaWJcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgdmFsaWRhdGlvbkxpYiBvYmplY3QgY29udGFpbmluZyBmaWVsZHMgdmFsaWRhdGlvbiBydWxlcyBhbmQgZm9ybSBzcGVjaWZpYyBydWxlc1xuICogQHJldHVybnMge2Z1bmN0aW9ufSAoZGF0YTogb2JqZWN0LCBmb3JtTmFtZTogc3RyaW5nKT0+UHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PlxuICoqL1xuY29uc3QgVmFsaWRhdGlvblJ1bm5lciA9ICh2YWxpZGF0b3JzTGliKSA9PiB7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGlvbiBzZXNzaW9uIHJ1bm5lclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgICAgb2JqZWN0IHRvIHZhbGlkYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1OYW1lXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICoqL1xuICAgIHJldHVybiAoZGF0YSwgZm9ybU5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IHtcbiAgICAgICAgICAgIC8vZmllbGRzIHNwZWNpZmljIHZhbGlkYXRvcnNcbiAgICAgICAgICAgIGZpZWxkczogY29tcG9zZUZpZWxkc1ZhbGlkYXRvcnMoZGF0YSwgdmFsaWRhdG9yc0xpYiksXG4gICAgICAgICAgICAvL2Zvcm0gc3BlY2lmaWMgdmFsaWRhdG9yc1xuICAgICAgICAgICAgZm9ybTogY29tcG9zZUZvcm1WYWxpZGF0b3JzKGZvcm1OYW1lLCB2YWxpZGF0b3JzTGliKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25TZXNzaW9uKHZhbGlkYXRvcnMsIGRhdGEpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25SdW5uZXI7XG4iLCJjb25zdCBhdWdtZW50RmllbGRzVmFsaWRhdG9ycyA9IChmaWVsZFZhbGlkYXRvcnMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIHJldHVybiBmaWVsZFZhbGlkYXRvcnMubWFwKChmaWVsZFJ1bGUpID0+XG4gICAgICAgIGF1Z21lbnRGaWVsZFZhbGlkYXRvcihmaWVsZFJ1bGUsIGdldFZhbGlkYXRvckVudilcbiAgICApO1xufTtcblxuY29uc3QgYXVnbWVudEZpZWxkVmFsaWRhdG9yID0gKHJ1bGUsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGlmIChydWxlLnZhbGlkYXRvciAmJiB0eXBlb2YgcnVsZS52YWxpZGF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBydWxlVmFsaWRhdG9yID0gcnVsZS52YWxpZGF0b3I7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIC4uLnJ1bGUsXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSByZXN1bHQudmFsaWRhdG9yO1xuICAgICAgICByZXN1bHQudmFsaWRhdG9yID0gKHZhbCkgPT4gcnVsZVZhbGlkYXRvcih2YWwsIGdldFZhbGlkYXRvckVudigpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGU7XG59O1xuXG5jb25zdCBhdWdtZW50Rm9ybVZhbGlkYXRvcnMgPSAocnVsZXMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIHJldHVybiBydWxlcy5tYXAoKHJ1bGUpID0+IGF1Z21lbnRGb3JtVmFsaWRhdG9yKHJ1bGUsIGdldFZhbGlkYXRvckVudikpO1xufTtcblxuY29uc3QgYXVnbWVudEZvcm1WYWxpZGF0b3IgPSAocnVsZSwgZ2V0VmFsaWRhdG9yRW52KSA9PiB7XG4gICAgcmV0dXJuICh2YWwpID0+IHJ1bGUodmFsLCBnZXRWYWxpZGF0b3JFbnYoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhdWdtZW50RmllbGRzVmFsaWRhdG9ycyxcbiAgICBhdWdtZW50RmllbGRWYWxpZGF0b3IsXG4gICAgYXVnbWVudEZvcm1WYWxpZGF0b3JzLFxuICAgIGF1Z21lbnRGb3JtVmFsaWRhdG9yLFxufTtcbiIsImNvbnN0IG9iakhhcyA9IChvYmosIG5hbWUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgbmFtZSk7XG59O1xuY29uc3Qge1xuICAgIGF1Z21lbnRGaWVsZHNWYWxpZGF0b3JzLFxuICAgIGF1Z21lbnRGb3JtVmFsaWRhdG9ycyxcbn0gPSByZXF1aXJlKFwiLi9idWlsZGVyLnV0aWxzXCIpO1xuXG4vKipcbiAqIEB0eXBlZGVmICAge29iamVjdH0gICAgbm90VmFsaWRhdGlvblNjaGVtYVxuICogQHByb3BlcnR5ICB7b2JqZWN0fSAgICBbZmllbGRzXVxuICogQHByb3BlcnR5ICB7YXJyYXl9ICAgICBbZm9ybV1cbiAqIEBwcm9wZXJ0eSAge29iamVjdH0gICAgW2Zvcm1zXVxuICovXG5cbi8qKlxuICogcmV0dXJucyB2YWxpZCBlbXB0eSB2YWxpZGF0aW9uIHNjaGVtZVxuICpcbiAqIEByZXR1cm4ge25vdFZhbGlkYXRpb25TY2hlbWF9XG4gKi9cbmNvbnN0IGVtcHR5U2NoZW1lID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpZWxkczoge30sXG4gICAgICAgIGZvcm1zOiB7fSxcbiAgICB9O1xufTtcbi8qKlxuICpcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsaWRhdG9yc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0VmFsaWRhdG9yRW52XG4gKiBAcmV0dXJuIHtub3RWYWxpZGF0aW9uU2NoZW1hfVxuICovXG5jb25zdCB2YWxpZGF0aW9uQnVpbGRlciA9ICh2YWxpZGF0b3JzLCBnZXRWYWxpZGF0b3JFbnYpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvcnMgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsaWRhdG9ycyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZW1wdHlTY2hlbWUoKTtcbiAgICB9XG4gICAgY29uc3QgYXVnbWVudGVkID0ge307XG4gICAgaWYgKG9iakhhcyh2YWxpZGF0b3JzLCBcImZpZWxkc1wiKSkge1xuICAgICAgICBhdWdtZW50ZWQuZmllbGRzID0gdHJhbnNmb3JtRmllbGRzVmFsaWRhdG9ycyhcbiAgICAgICAgICAgIHZhbGlkYXRvcnMuZmllbGRzLFxuICAgICAgICAgICAgZ2V0VmFsaWRhdG9yRW52XG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmIChvYmpIYXModmFsaWRhdG9ycywgXCJmb3Jtc1wiKSkge1xuICAgICAgICBhdWdtZW50ZWQuZm9ybXMgPSB0cmFuc2Zvcm1Gb3Jtc1ZhbGlkYXRvcnMoXG4gICAgICAgICAgICB2YWxpZGF0b3JzLmZvcm1zLFxuICAgICAgICAgICAgZ2V0VmFsaWRhdG9yRW52XG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9iakhhcyh2YWxpZGF0b3JzLCBcImZvcm1cIikpIHtcbiAgICAgICAgICAgIGF1Z21lbnRlZC5mb3JtID0gYXVnbWVudEZvcm1WYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMuZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF1Z21lbnRlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGlvbkJ1aWxkZXI7XG5cbmNvbnN0IHRyYW5zZm9ybUZpZWxkc1ZhbGlkYXRvcnMgPSAoZmllbGRzLCBnZXRWYWxpZGF0b3JFbnYpID0+IHtcbiAgICBjb25zdCBhdWdtZW50ZWQgPSB7fTtcbiAgICBmb3IgKGxldCBmaWVsZE5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkc1tmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgYXVnbWVudGVkW2ZpZWxkTmFtZV0gPSBhdWdtZW50RmllbGRzVmFsaWRhdG9ycyhcbiAgICAgICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXSxcbiAgICAgICAgICAgICAgICBnZXRWYWxpZGF0b3JFbnZcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF1Z21lbnRlZDtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybUZvcm1zVmFsaWRhdG9ycyA9IChmb3Jtc1ZhbGlkYXRvcnMsIGdldFZhbGlkYXRvckVudikgPT4ge1xuICAgIGNvbnN0IGF1Z21lbnRlZCA9IHt9O1xuICAgIGZvciAobGV0IGZvcm1OYW1lIGluIGZvcm1zVmFsaWRhdG9ycykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmb3Jtc1ZhbGlkYXRvcnNbZm9ybU5hbWVdKSkge1xuICAgICAgICAgICAgYXVnbWVudGVkW2Zvcm1OYW1lXSA9IGF1Z21lbnRGb3JtVmFsaWRhdG9ycyhcbiAgICAgICAgICAgICAgICBmb3Jtc1ZhbGlkYXRvcnNbZm9ybU5hbWVdLFxuICAgICAgICAgICAgICAgIGdldFZhbGlkYXRvckVudlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXVnbWVudGVkO1xufTtcbiIsImNvbnN0IFNlc3Npb24gPSByZXF1aXJlKFwiLi9zZXNzaW9uXCIpO1xuY29uc3QgUnVubmVyID0gcmVxdWlyZShcIi4vcnVubmVyXCIpO1xuY29uc3QgQnVpbGRlciA9IHJlcXVpcmUoXCIuL2J1aWxkZXJcIik7XG5jb25zdCBSZXN1bHQgPSByZXF1aXJlKFwiLi9yZXN1bHRcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5hbWU6IFwibm90LXZhbGlkYXRpb25cIixcbiAgICBTZXNzaW9uLFxuICAgIFJ1bm5lcixcbiAgICBCdWlsZGVyLFxuICAgIFJlc3VsdCxcbn07XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVSUxhYmVsIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9pbnB1dC91aS5sYWJlbC5zdmVsdGVcIjtcblxuICAgIGltcG9ydCB7IENPTVBPTkVOVFMgfSBmcm9tIFwiLi4vLi4vTElCLmpzXCI7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYWJlbF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZG9ubHldXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbaG9yaXpvbnRhbF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2NvbnRyb2xzXVxuICAgICAqIEBwcm9wZXJ0eSB7aW1wb3J0KCcuLi8uLi8uLi9lbGVtZW50cy9ldmVudHMudHlwZXMnKS5VSUV2ZW50SW5wdXRDaGFuZ2VDYWxsYmFja30gb25jaGFuZ2VcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzZXNdIC0gZmllbGQgc3R5bGUgbW9kaWZpY2F0aW9uXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWRkb25zXSAtIC8vYWRkb25zXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWRkb25zQ2VudGVyZWRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWRkb25zUmlnaHRdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXBlZF0gLSAvL2dyb3VwIGZsYWdcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cGVkTXVsdGlsaW5lXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwZWRSaWdodF1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncm91cGVkQ2VudGVyZWRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGxhYmVsID0gXCJcIixcbiAgICAgICAgbmFtZSA9IFwiZ2VuZXJpYyBmaWVsZFwiLFxuICAgICAgICByZWFkb25seSA9IGZhbHNlLFxuICAgICAgICBob3Jpem9udGFsID0gZmFsc2UsXG4gICAgICAgIGNvbnRyb2xzID0gW10sXG4gICAgICAgIGNsYXNzZXMgPSBcIlwiLFxuICAgICAgICBhZGRvbnMgPSBmYWxzZSxcbiAgICAgICAgYWRkb25zQ2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgYWRkb25zUmlnaHQgPSBmYWxzZSxcbiAgICAgICAgZ3JvdXBlZCA9IGZhbHNlLFxuICAgICAgICBncm91cGVkTXVsdGlsaW5lID0gZmFsc2UsXG4gICAgICAgIGdyb3VwZWRSaWdodCA9IGZhbHNlLFxuICAgICAgICBncm91cGVkQ2VudGVyZWQgPSBmYWxzZSxcbiAgICAgICAgb25jaGFuZ2UgPSAoKSA9PiB0cnVlLFxuICAgICAgICBmb3JtRmllbGRQcmVmaXggPSBcImZvcm0tZmllbGQtXCIsXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IGZpZWxkQ2xhc3NlcyA9ICRzdGF0ZShcIlwiKTtcbiAgICBsZXQgaGlkZGVuID0gJHN0YXRlKGZhbHNlKTtcbiAgICBsZXQgZmllbGRJZCA9ICRzdGF0ZSgpO1xuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBcIiBcIiArIGNsYXNzZXM7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBhZGRvbnMgPyBcIiBoYXMtYWRkb25zIFwiIDogXCJcIjtcbiAgICAgICAgZmllbGRDbGFzc2VzICs9IGFkZG9uc0NlbnRlcmVkID8gXCIgaGFzLWFkZG9ucy1jZW50ZXJlZCBcIiA6IFwiXCI7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBhZGRvbnNSaWdodCA/IFwiIGhhcy1hZGRvbnMtcmlnaHQgXCIgOiBcIlwiO1xuXG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBncm91cGVkID8gXCIgaXMtZ3JvdXBlZCBcIiA6IFwiXCI7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBncm91cGVkTXVsdGlsaW5lID8gXCIgaXMtZ3JvdXBlZC1tdWx0aWxpbmUgXCIgOiBcIlwiO1xuICAgICAgICBmaWVsZENsYXNzZXMgKz0gZ3JvdXBlZFJpZ2h0ID8gXCIgaXMtZ3JvdXBlZC1yaWdodCBcIiA6IFwiXCI7XG4gICAgICAgIGZpZWxkQ2xhc3NlcyArPSBncm91cGVkQ2VudGVyZWQgPyBcIiBpcy1ncm91cGVkLWNlbnRlcmVkIFwiIDogXCJcIjtcblxuICAgICAgICBpZiAocmVhZG9ubHkpIHtcbiAgICAgICAgICAgIGNvbnRyb2xzLmZvckVhY2goKGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vdEhpZGRlbiA9IGNvbnRyb2xzLmZpbHRlcihcbiAgICAgICAgICAgIChjb250cm9sKSA9PiBjb250cm9sLmNvbXBvbmVudCAhPT0gXCJVSUhpZGRlblwiXG4gICAgICAgICk7XG4gICAgICAgIGhpZGRlbiA9IG5vdEhpZGRlbi5sZW5ndGggPT09IDA7XG4gICAgICAgIGxldCB0bXAgPSBjb250cm9scy5tYXAoKGl0bSkgPT4gaXRtLmNvbXBvbmVudCkuam9pbihcIl9cIik7XG4gICAgICAgIGZpZWxkSWQgPSBgJHtmb3JtRmllbGRQcmVmaXh9JHt0bXB9LSR7bmFtZX1gO1xuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaGlkZGVufVxuICAgIHsjZWFjaCBjb250cm9scyBhcyBjb250cm9sfVxuICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IENPTVBPTkVOVFMuZ2V0KGNvbnRyb2wuY29tcG9uZW50KX1cbiAgICAgICAgPFN2ZWx0ZUNvbXBvbmVudCB7Li4uY29udHJvbH0ge29uY2hhbmdlfSBmaWVsZG5hbWU9e25hbWV9IC8+XG4gICAgey9lYWNofVxuezplbHNlIGlmIGhvcml6b250YWx9XG4gICAgPGRpdiBjbGFzcz1cImZpZWxkIGlzLWhvcml6b250YWwge2ZpZWxkQ2xhc3Nlc30ge2ZpZWxkSWR9XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZC1sYWJlbCBpcy1ub3JtYWxcIj5cbiAgICAgICAgICAgIDxVSUxhYmVsIGZvcj17ZmllbGRJZH0gbGFiZWw9e2xhYmVsIHx8IGNvbnRyb2xzWzBdLmxhYmVsfSAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkLWJvZHlcIiBpZD17ZmllbGRJZH0+XG4gICAgICAgICAgICB7I2VhY2ggY29udHJvbHMgYXMgY29udHJvbH1cbiAgICAgICAgICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudF8xID0gQ09NUE9ORU5UUy5nZXQoY29udHJvbC5jb21wb25lbnQpfVxuICAgICAgICAgICAgICAgIDxTdmVsdGVDb21wb25lbnRfMSB7Li4uY29udHJvbH0ge29uY2hhbmdlfSBmaWVsZG5hbWU9e25hbWV9IC8+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuezplbHNlfVxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZCB7ZmllbGRDbGFzc2VzfSB7ZmllbGRJZH1cIj5cbiAgICAgICAgeyNlYWNoIGNvbnRyb2xzIGFzIGNvbnRyb2x9XG4gICAgICAgICAgICA8VUlMYWJlbFxuICAgICAgICAgICAgICAgIGZvcj1cImZvcm0tZmllbGQte2NvbnRyb2wuY29tcG9uZW50fS17bmFtZX1cIlxuICAgICAgICAgICAgICAgIGxhYmVsPXtjb250cm9sLmxhYmVsfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIHtAY29uc3QgU3ZlbHRlQ29tcG9uZW50XzIgPSBDT01QT05FTlRTLmdldChjb250cm9sLmNvbXBvbmVudCl9XG4gICAgICAgICAgICA8U3ZlbHRlQ29tcG9uZW50XzIgey4uLmNvbnRyb2x9IHtvbmNoYW5nZX0gZmllbGRuYW1lPXtuYW1lfSAvPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgXCJidWxtYS1wYWdlbG9hZGVyXCI7XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICAgIGxldCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uL2xvY2FsZVwiO1xuXG4gICAgaW1wb3J0IFVJRmllbGQgZnJvbSBcIi4vZmllbGQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IEZvcm1IZWxwZXJzIGZyb20gXCIuL2Zvcm0uaGVscGVycy5qc1wiO1xuXG4gICAgLy92YWxpZGF0aW9uIHN0YXR1c1xuICAgIGxldCBmb3JtRXJyb3JzID0gJHN0YXRlKFtdKTtcbiAgICBsZXQgZm9ybUhhc0Vycm9ycyA9ICRzdGF0ZShmYWxzZSk7XG4gICAgbGV0IGZpZWxkc0hhc0Vycm9ycyA9ICRzdGF0ZShmYWxzZSk7XG4gICAgbGV0IHN1Y2Nlc3MgPSAkc3RhdGUoZmFsc2UpO1xuXG4gICAgLy9pbnB1dCBkYXRhXG4gICAgLy9mb3JtIHN0cnVjdHVyZSBvYmplY3RcblxuICAgIC8vaGlkZGVuIC0gbm8gbG9hZGVyXG4gICAgLy9jb250YWluZXIgLSBwYXJlbnQgY29udGFpbmVyIG9mIGZvcm1cblxuICAgIC8vZmllbGRzIGxpc3Qgc3RydWN0dXJlXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbZm9ybV0gLSB7XG5bZmllbGROYW1lOiBzdHJpbmddID0+IGRlc2NyaXB0aW9uOiBvYmplY3Rcbn1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkaW5nXSAtIHN0YXRlIGlmIGZvcm0gbG9hZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbG9hZGVyXSAtIHBhZ2UgLSB3aG9sZSBwYWdlXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtmaWVsZHNdIC0gZWFjaCBpdGVtIGlzIGEgcm93XG5pZiBpdGVtIGlzIGFycmF5LCB0aGVuIHRoZXJlIGZldyBmaWVsZHMgaW4gYSByb3dcbltcbltuYW1lLCBhZ2VdLFxuW2VtYWlsLCB0ZWxlcGhvbmVdXG5iaW8sXG5hZ3JlZWRcbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW1NVQ0NFU1NfVEVYVF0gLSBmb3JtIHJlc3VsdCBsYWJlbHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW1dBSVRJTkdfVEVYVF1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSAtIGZvcm0gbGFiZWxzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidXR0b25zRmlyc3RdIC0gaWYgeW91IHdhbnQgYnV0dG9uIG9uIHRvcFxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hvcml6b250YWxdIC0gaWYgZm9ybSBmaWVsZHMgc2hvdWxkIGhhdmUgaG9yaXpvbnRhbCBsYXlvdXRcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3N1Ym1pdF0gLSBidXR0b25zIGxhYmVscyBhbmQgYXZhaWxhYmlsaXR5XG4gICAgICogQHByb3BlcnR5IHthbnl9IFtjYW5jZWxdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIGZvcm0gPSAkYmluZGFibGUoe30pLFxuICAgICAgICBsb2FkaW5nID0gJGJpbmRhYmxlKGZhbHNlKSxcbiAgICAgICAgbG9hZGVyID0gXCJjb250YWluZXJcIixcbiAgICAgICAgZmllbGRzID0gW10sXG4gICAgICAgIFNVQ0NFU1NfVEVYVCA9IFwi0J7Qv9C10YDQsNGG0LjRjyDQt9Cw0LLQtdGA0YjQtdC90LBcIixcbiAgICAgICAgV0FJVElOR19URVhUID0gXCLQntGC0L/RgNCw0LLQutCwINC00LDQvdC90YvRhSDQvdCwINGB0LXRgNCy0LXRgFwiLFxuICAgICAgICB0aXRsZSA9IFwiXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uID0gXCJcIixcbiAgICAgICAgYnV0dG9uc0ZpcnN0ID0gZmFsc2UsXG4gICAgICAgIGhvcml6b250YWwgPSBmYWxzZSxcbiAgICAgICAgc3VibWl0ID0ge1xuICAgICAgICAgICAgY2FwdGlvbjogXCLQntGC0L/RgNCw0LLQuNGC0YxcIixcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbCA9IHtcbiAgICAgICAgICAgIGNhcHRpb246IFwi0J3QsNC30LDQtFwiLFxuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgZm9ybUludmFsaWQgPSAkZGVyaXZlZChmb3JtSGFzRXJyb3JzIHx8IGZpZWxkc0hhc0Vycm9ycyk7XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gY29sbGVjdERhdGEoKSB7XG4gICAgICAgIHJldHVybiBGb3JtSGVscGVycy5jb2xsZWN0RGF0YShmaWVsZHMsIGZvcm0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZEludmFsaWQoZmllbGROYW1lLCB2YWx1ZSwgZXJyb3JzKSB7XG4gICAgICAgIGZvcm0gPSBGb3JtSGVscGVycy5zZXRGaWVsZEludmFsaWQoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSwgZXJyb3JzKTtcbiAgICAgICAgZmllbGRzSGFzRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0RmllbGRWYWxpZChmaWVsZE5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGZvcm0gPSBGb3JtSGVscGVycy5zZXRGaWVsZFZhbGlkKGZvcm0sIGZpZWxkTmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkVmFsaWQoZmllbGROYW1lKSB7XG4gICAgICAgIHJldHVybiBGb3JtSGVscGVycy5pc0ZpZWxkVmFsaWQoZm9ybSwgZmllbGROYW1lKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0Rm9ybUZpZWxkSW52YWxpZChmaWVsZE5hbWUsIGVycm9ycykge1xuICAgICAgICBmb3JtID0gRm9ybUhlbHBlcnMuc2V0Rm9ybUZpZWxkSW52YWxpZChmb3JtLCBmaWVsZE5hbWUsIGVycm9ycyk7XG4gICAgICAgIGRpc3BhdGNoKGBmaWVsZC5pbnZhbGlkYCwge1xuICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0Rm9ybUZpZWxkVmFsaWQoZmllbGROYW1lKSB7XG4gICAgICAgIGZvcm0gPSBGb3JtSGVscGVycy5zZXRGb3JtRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpO1xuICAgICAgICBkaXNwYXRjaChgZmllbGQudmFsaWRgLCB7XG4gICAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyhcbiAgICAgICAgdmFsaWRhdGlvblN0YXR1cyAvKiBGb3JtVmFsaWRhdGlvblNlc3Npb24uZ2V0Q29tcGxldGVSZXN1bHQoKSAqL1xuICAgICkge1xuICAgICAgICBmb3JtSGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIGZpZWxkc0hhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25TdGF0dXMuZm9ybSkgJiZcbiAgICAgICAgICAgIHZhbGlkYXRpb25TdGF0dXMuZm9ybS5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmb3JtRXJyb3JzLnNwbGljZSgwLCBmb3JtRXJyb3JzLmxlbmd0aCwgLi4udmFsaWRhdGlvblN0YXR1cy5mb3JtKTtcbiAgICAgICAgICAgIGZvcm1IYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybUVycm9ycy5zcGxpY2UoMCwgZm9ybUVycm9ycy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1FcnJvcnMgPSBmb3JtRXJyb3JzO1xuICAgICAgICBpZiAodmFsaWRhdGlvblN0YXR1cy5maWVsZHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBvZiBPYmplY3Qua2V5cyhmb3JtKSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdKSAmJlxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uU3RhdHVzLmZpZWxkc1tmaWVsZE5hbWVdLmxlbmd0aFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBGb3JtSGVscGVycy5zZXRGb3JtRmllbGRJbnZhbGlkKFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25TdGF0dXMuZmllbGRzW2ZpZWxkTmFtZV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzSGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBGb3JtSGVscGVycy5zZXRGb3JtRmllbGRWYWxpZChmb3JtLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzaG93U3VjY2VzcygpIHtcbiAgICAgICAgc3VjY2VzcyA9IHRydWU7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldExvYWRpbmcoKSB7XG4gICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiByZXNldExvYWRpbmcoKSB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0RmllbGRzVmlzaWJpbGl0eShmaWVsZHNMaXN0LCB2YWwpIHtcbiAgICAgICAgaWYgKEZvcm1IZWxwZXJzLnNldEZpZWxkc1Zpc2liaWxpdHkoZm9ybSwgZmllbGRzTGlzdCwgdmFsKSkge1xuICAgICAgICAgICAgZm9ybSA9IGZvcm07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc2V0VmlzaWJsZUZpZWxkcyhmaWVsZHNMaXN0KSB7XG4gICAgICAgIHNldEZpZWxkc1Zpc2liaWxpdHkoZmllbGRzTGlzdCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHNldEludmlzaWJsZUZpZWxkcyhmaWVsZHNMaXN0KSB7XG4gICAgICAgIHNldEZpZWxkc1Zpc2liaWxpdHkoZmllbGRzTGlzdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZFZhbHVlKGZpZWxkTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKEZvcm1IZWxwZXJzLnNldEZpZWxkVmFsdWUoZm9ybSwgZmllbGROYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIG9uRmllbGRDaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gdXBkYXRlRmllbGQoZmllbGROYW1lLCBwcm9wcykge1xuICAgICAgICBmb3JtW2ZpZWxkTmFtZV0gPSB7XG4gICAgICAgICAgICAuLi5mb3JtW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybSA9IGZvcm07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25GaWVsZENoYW5nZShldikge1xuICAgICAgICBsZXQgZGF0YSA9IGV2LmRldGFpbDtcbiAgICAgICAgZm9ybVtkYXRhLmZpZWxkXS52YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIGZvcm0gPSBmb3JtO1xuICAgICAgICBkaXNwYXRjaChcImNoYW5nZVwiLCBkYXRhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJtaXRGb3JtKGUpIHtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoKFwic3VibWl0XCIsIGNvbGxlY3REYXRhKCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0Rm9ybSgpIHtcbiAgICAgICAgZGlzcGF0Y2goXCJyZWplY3RcIik7XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJmb3JtLWNvbnRhaW5lclwiPlxuICAgIHsjaWYgbG9hZGVyICE9PSBcImhpZGRlblwifVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cIntsb2FkZXIgPT09ICdwYWdlJ1xuICAgICAgICAgICAgICAgID8gJ3BhZ2Vsb2FkZXInXG4gICAgICAgICAgICAgICAgOiAnY29udGFpbmVybG9hZGVyJ30ge2xvYWRpbmcgPyAnaXMtYWN0aXZlJyA6ICcnfVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj57JExPQ0FMRVtXQUlUSU5HX1RFWFRdfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cblxuICAgIHsjaWYgc3VjY2Vzc31cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbiBpcy1zdWNjZXNzXCI+XG4gICAgICAgICAgICA8aDMgY2xhc3M9XCJmb3JtLXN1Y2Nlc3MtbWVzc2FnZVwiPnskTE9DQUxFW1NVQ0NFU1NfVEVYVF19PC9oMz5cbiAgICAgICAgPC9kaXY+XG4gICAgezplbHNlfVxuICAgICAgICB7I2lmIHRpdGxlfVxuICAgICAgICAgICAgPGg1IGNsYXNzPVwidGl0bGUgaXMtNVwiPnskTE9DQUxFW3RpdGxlXX08L2g1PlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIGRlc2NyaXB0aW9ufVxuICAgICAgICAgICAgPGg2IGNsYXNzPVwic3VidGl0bGUgaXMtNlwiPnskTE9DQUxFW2Rlc2NyaXB0aW9uXX08L2g2PlxuICAgICAgICB7L2lmfVxuICAgICAgICB7I2lmIGJ1dHRvbnNGaXJzdH1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zIGlzLWdyb3VwZWQgaXMtY2VudGVyZWRcIj5cbiAgICAgICAgICAgICAgICB7I2lmIGNhbmNlbC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbiBpcy1vdXRsaW5lZCB7Y2FuY2VsLmNsYXNzZXN9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3JlamVjdEZvcm19PnskTE9DQUxFW2NhbmNlbC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICB7I2lmIHN1Ym1pdC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtzdWJtaXRGb3JtfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Zvcm1JbnZhbGlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeSBpcy1ob3ZlcmVkIHtzdWJtaXQuY2xhc3Nlc31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgPnskTE9DQUxFW3N1Ym1pdC5jYXB0aW9uXX08L2J1dHRvblxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICB7I2lmIGZvcm1FcnJvcnMubGVuZ3RoID4gMH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZWRpdC1mb3JtLWVycm9yIG5vdGlmaWNhdGlvbiBpcy1kYW5nZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge2Zvcm1FcnJvcnMuam9pbihcIiwgXCIpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9pZn1cblxuICAgICAgICB7I2VhY2ggZmllbGRzIGFzIGZpZWxkfVxuICAgICAgICAgICAgeyNpZiBBcnJheS5pc0FycmF5KGZpZWxkKX1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICB7I2VhY2ggZmllbGQgYXMgc3ViZmllbGR9XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGZvcm1bc3ViZmllbGRdICYmIGZvcm1bc3ViZmllbGRdLmNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGZvcm1bc3ViZmllbGRdLnZpc2libGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiY29sdW1uIHtmb3JtW3N1YmZpZWxkXS5maWVsZFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdpcy0nICsgZm9ybVtzdWJmaWVsZF0uZmllbGRTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJ30gXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFVJRmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9scz17W2Zvcm1bc3ViZmllbGRdXX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uRmllbGRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17c3ViZmllbGR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2hvcml6b250YWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2Zvcm1bc3ViZmllbGRdLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIG5vdGlmaWNhdGlvbiBpcy1kYW5nZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3ViZmllbGQgJ3tzdWJmaWVsZH0nIGlzIG5vdCByZWdpc3RlcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7OmVsc2UgaWYgZm9ybVtmaWVsZF0gJiYgZm9ybVtmaWVsZF0uY29tcG9uZW50fVxuICAgICAgICAgICAgICAgIHsjaWYgZm9ybVtmaWVsZF0udmlzaWJsZX1cbiAgICAgICAgICAgICAgICAgICAgPFVJRmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzPXtbZm9ybVtmaWVsZF1dfVxuICAgICAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXtvbkZpZWxkQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT17ZmllbGR9XG4gICAgICAgICAgICAgICAgICAgICAgICB7aG9yaXpvbnRhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsPXtmb3JtW2ZpZWxkXS5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJub3RpZmljYXRpb24gaXMtZGFuZ2VyXCI+XG4gICAgICAgICAgICAgICAgICAgIEZpZWxkICd7ZmllbGR9JyBpcyBub3QgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuXG4gICAgICAgIHsjaWYgIWJ1dHRvbnNGaXJzdH1cbiAgICAgICAgICAgIHsjaWYgZm9ybUVycm9ycy5sZW5ndGggPiAwfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlZGl0LWZvcm0tZXJyb3Igbm90aWZpY2F0aW9uIGlzLWRhbmdlclwiPlxuICAgICAgICAgICAgICAgICAgICB7I2VhY2ggZm9ybUVycm9ycyBhcyBmb3JtRXJyb3J9XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57JExPQ0FMRVtmb3JtRXJyb3JdfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgey9lYWNofVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zIGlzLWdyb3VwZWQgaXMtY2VudGVyZWRcIj5cbiAgICAgICAgICAgICAgICB7I2lmIGNhbmNlbC5lbmFibGVkfVxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ1dHRvbiB7Y2FuY2VsLmNsYXNzZXMgPyBjYW5jZWwuY2xhc3NlcyA6ICcnfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXtyZWplY3RGb3JtfT57JExPQ0FMRVtjYW5jZWwuY2FwdGlvbl19PC9idXR0b25cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgeyNpZiBzdWJtaXQuZW5hYmxlZH1cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17c3VibWl0Rm9ybX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtmb3JtSW52YWxpZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnV0dG9uIGlzLXByaW1hcnkgaXMtaG92ZXJlZCB7c3VibWl0LmNsYXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN1Ym1pdC5jbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJ31cIj57JExPQ0FMRVtzdWJtaXQuY2FwdGlvbl19PC9idXR0b25cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICB7L2lmfVxuPC9kaXY+XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi9jb21tb25cIjtcblxuY29uc3QgREVGQVVMVF9SVUxFUyA9IHtcbiAgICBub3RSZWFkb25seSh2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFkb25seTogIXYsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICByZWFkb25seSh2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWFkb25seTogdixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVuYWJsZSh2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNhYmxlZDogIXYsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkaXNhYmxlKHYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiB2LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBub3RGb3JtUnVsZXMge1xuICAgIHN0YXRpYyAjUlVMRVMgPSB7IC4uLkRFRkFVTFRfUlVMRVMgfTtcblxuICAgIHN0YXRpYyBhZGQobmFtZSwgZnVuYykge1xuICAgICAgICBpZiAoIW5vdENvbW1vbi5vYmpIYXModGhpcy4jUlVMRVMsIG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLiNSVUxFU1tuYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyh0aGlzLiNSVUxFUywgbmFtZSkgJiZcbiAgICAgICAgICAgICFPYmplY3Qua2V5cyhERUZBVUxUX1JVTEVTKS5pbmNsdWRlcyhuYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLiNSVUxFU1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBleGVjKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSwgZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jUlVMRVNbcnVsZV0odmFsdWUsIG1hc3Rlciwgc2xhdmVzLCBmb3JtKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBSdW5uZXIgfSBmcm9tIFwibm90LXZhbGlkYXRpb25cIjtcblxuaW1wb3J0IHsgVkFSSUFOVFMgfSBmcm9tIFwiLi4vLi4vTElCLmpzXCI7XG5pbXBvcnQgTGliIGZyb20gXCIuLi8uLi9saWIuanNcIjtcbmltcG9ydCBub3RDb21tb24gZnJvbSBcIi4uLy4uL2NvbW1vblwiO1xuaW1wb3J0IG5vdEJhc2UgZnJvbSBcIi4uLy4uL2Jhc2VcIjtcblxuaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi8uLi9lbGVtZW50cy9jb21tb24uanNcIjtcbmltcG9ydCBGb3JtSGVscGVycyBmcm9tIFwiLi9mb3JtLmhlbHBlcnMuanNcIjtcbmltcG9ydCBVSUZvcm1Db21wb25lbnQgZnJvbSBcIi4vZm9ybS5zdmVsdGVcIjtcbmltcG9ydCBub3RGb3JtUnVsZXMgZnJvbSBcIi4vZm9ybS5ydWxlcy5qc1wiO1xuXG5pbXBvcnQgeyBERUZBVUxUX1NUQVRVU19TVUNDRVNTIH0gZnJvbSBcIi4uLy4uL2NvbnN0XCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SID0gXCIuZm9ybVwiO1xuY29uc3QgREVGQVVMVF9BQ1RJT05fTkFNRSA9IFwiZGVmYXVsdFwiO1xuXG5jbGFzcyBub3RGb3JtIGV4dGVuZHMgbm90QmFzZSB7XG4gICAgLy9VSSByZW5kZXJlciBjb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAjdWlDb21wb25lbnQgPSBudWxsO1xuICAgIC8vZm9ybSB2YWxpZGF0aW9uXG4gICAgI3ZhbGlkYXRpb25SdW5uZXIgPSBudWxsO1xuICAgIC8vdWkgY29tcG9uZW50XG4gICAgI2Zvcm0gPSBudWxsO1xuICAgIC8vbW9kZWwuYWN0aW9uXG4gICAgI2FjdGlvbiA9IERFRkFVTFRfQUNUSU9OX05BTUU7XG4gICAgLy9maWVsZHMgc2NoZW1hc1xuICAgICNmaWVsZHMgPSBuZXcgTGliKCk7IC8vZmllbGRzIG9mIFVJXG4gICAgLy92YXJpYW50cyBzZXRzIGZvciBzZWxlY3QgbWVudXMgYW5kIHNvIG9uXG4gICAgI3ZhcmlhbnRzID0gbnVsbDsgLy92YXJpYW50cyBmb3IgVUlcblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgICAgbmFtZSA9IFwiRGVmYXVsdFwiLFxuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgICAgIHdvcmtpbmcgPSB7fSxcbiAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICB1aSA9IFVJRm9ybUNvbXBvbmVudCwgLy9kZWZhdWx0IFVJXG4gICAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICB3b3JraW5nOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7bmFtZX1Gb3JtYCxcbiAgICAgICAgICAgICAgICAuLi53b3JraW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdmFyaWFudHMgPSBuZXcgTGliKFZBUklBTlRTLmdldENvbnRlbnQoKSk7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VpQ29tcG9uZW50ID0gdWk7XG4gICAgICAgIGlmIChub3RDb21tb24ub2JqSGFzKG9wdGlvbnMsIFwiYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICB0aGlzLiNhY3Rpb24gPSBvcHRpb25zLmFjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRGb3JtKCk7XG4gICAgfVxuXG4gICAgaW5pdEZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvSW5pdFwiLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5pbml0TGlicygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJhdXRvUmVuZGVyXCIsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRVSSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdExpYnMoKSB7XG4gICAgICAgIHRoaXMuaW5pdEZpZWxkcygpO1xuICAgICAgICB0aGlzLmluaXRWYXJpYW50cygpO1xuICAgICAgICB0aGlzLmluaXRWYWxpZGF0b3IoKTtcbiAgICB9XG5cbiAgICByZUluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdExpYnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVVSSgpO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIGluaXRGaWVsZHMoKSB7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gdGhpcy5nZXRGb3JtTWFuaWZlc3QoKTtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5vYmpIYXMobWFuaWZlc3QsIFwiZmllbGRzXCIpICYmIHRoaXMuI2ZpZWxkcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZpZWxkcy5pbXBvcnQobWFuaWZlc3QuZmllbGRzKTsgLy9hbGwgZmllbGRzIGF2YWlsYWJsZSBpbiBtb2RlbCBtYW5pZmVzdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdFZhcmlhbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwidmFyaWFudHNcIikpIHtcbiAgICAgICAgICAgIHRoaXMuI3ZhcmlhbnRzLmltcG9ydCh0aGlzLmdldE9wdGlvbnMoXCJ2YXJpYW50c1wiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NyZWF0aW5nIHZhbGlkYXRvcnMgcnVubmVyIGZvciB0aGlzIHNwZWNpZmljIGZvcm1cbiAgICBpbml0VmFsaWRhdG9yKCkge1xuICAgICAgICB0aGlzLiN2YWxpZGF0aW9uUnVubmVyID0gUnVubmVyKHRoaXMuZ2V0Rm9ybVZhbGlkYXRvcnMoKSk7XG4gICAgfVxuXG4gICAgaW5pdFVJKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLiNnZXRGb3JtUHJvcHMoe1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0OiB0aGlzLmdldEZvcm1NYW5pZmVzdCgpLFxuICAgICAgICAgICAgICAgIGZvcm1PcHRpb25zOiB0aGlzLmdldEZvcm1PcHRpb25zKCksXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRGb3JtRGF0YSgpLFxuICAgICAgICAgICAgICAgIGluamVjdGVkUHJvcHM6IHRoaXMuZ2V0Rm9ybUluamVjdGVkUHJvcHMoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRGb3JtVGFyZ2V0RWwoKTtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtID0gbmV3IHRoaXMuI3VpQ29tcG9uZW50KHtcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI2JpbmRVSUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUZvcm0oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVVJKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLiNnZXRGb3JtUHJvcHMoe1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0OiB0aGlzLmdldEZvcm1NYW5pZmVzdCgpLFxuICAgICAgICAgICAgICAgIGZvcm1PcHRpb25zOiB0aGlzLmdldEZvcm1PcHRpb25zKCksXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRGb3JtRGF0YSgpLFxuICAgICAgICAgICAgICAgIGluamVjdGVkUHJvcHM6IHRoaXMuZ2V0Rm9ybUluamVjdGVkUHJvcHMoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jZm9ybS4kc2V0KHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVGb3JtKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAjYmluZFVJRXZlbnRzKCkge1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcImNoYW5nZVwiLCAoKSA9PiB0aGlzLnZhbGlkYXRlRm9ybSgpKTtcbiAgICAgICAgdGhpcy4jZm9ybS4kb24oXCJjaGFuZ2VcIiwgKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgZXYuZGV0YWlsKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChgY2hhbmdlLiR7ZXYuZGV0YWlsLmZpZWxkfWAsIGV2LmRldGFpbC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcInN1Ym1pdFwiLCAoZXYpID0+IHRoaXMuc3VibWl0KGV2LmRldGFpbCkpO1xuICAgICAgICB0aGlzLiNmb3JtLiRvbihcInJlamVjdFwiLCAoKSA9PiB0aGlzLnJlamVjdCgpKTtcbiAgICAgICAgdGhpcy4jZm9ybS4kb24oXCJlcnJvclwiLCAoeyBkZXRhaWwgfSkgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZGV0YWlsKSk7XG4gICAgICAgIHRoaXMuI2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cygpO1xuICAgIH1cblxuICAgICNiaW5kTWFzdGVyU2xhdmVFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IG1hc3RlcnMgPSB0aGlzLmdldE9wdGlvbnMoXCJtYXN0ZXJzXCIsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFtYXN0ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbWFzdGVyIGluIG1hc3RlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gbWFzdGVyc1ttYXN0ZXJdO1xuICAgICAgICAgICAgZm9yIChsZXQgcnVsZU5hbWUgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlU2xhdmVzID0gcnVsZXNbcnVsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2FkZE1hc3RlclNsYXZlRXZlbnRzKHJ1bGVOYW1lLCBtYXN0ZXIsIHJ1bGVTbGF2ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgI2FkZE1hc3RlclNsYXZlRXZlbnRzKHJ1bGUsIG1hc3Rlciwgc2xhdmVzID0gW10pIHtcbiAgICAgICAgdGhpcy5vbihgY2hhbmdlLiR7bWFzdGVyfWAsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jZXhlY1NsYXZlUnVsZShydWxlLCBtYXN0ZXIsIHNsYXZlcywgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KGBjaGFuZ2UuJHttYXN0ZXJ9YCwgdGhpcy5nZXRGb3JtRGF0YSgpW21hc3Rlcl0pO1xuICAgIH1cblxuICAgICNleGVjU2xhdmVSdWxlKHJ1bGUsIG1hc3Rlciwgc2xhdmVzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBjbWQgPSBub3RGb3JtUnVsZXMuZXhlYyhydWxlLCBtYXN0ZXIsIHNsYXZlcywgdmFsdWUsIHRoaXMpO1xuICAgICAgICBzbGF2ZXMuZm9yRWFjaCgoc2xhdmVGaWVsZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaWVsZChzbGF2ZUZpZWxkLCBjbWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJyZWFkb25seVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHRoaXMuI3ZhbGlkYXRpb25SdW5uZXIoXG4gICAgICAgICAgICAgICAgdGhpcy4jZm9ybS5jb2xsZWN0RGF0YSgpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9ybUFjdGlvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy4jZm9ybS51cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyh2YWxpZGF0aW9uUmVzdWx0LmdldFJlcG9ydCgpKTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5jbGVhbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHZhbGlkYXRpb25SZXN1bHQuZ2V0UmVwb3J0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSB7XG4gICAgICAgICAgICAgICAgZm9ybTogW1VJQ29tbW9uLkVSUk9SX0RFRkFVTFQsIGUubWVzc2FnZV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy4jZm9ybSAmJiB0aGlzLiNmb3JtLnVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKHJlcG9ydCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCByZXBvcnQpO1xuICAgICAgICAgICAgbm90Q29tbW9uLnJlcG9ydChlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1Ym1pdChkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInN1Ym1pdFwiLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcInJlamVjdFwiKTtcbiAgICB9XG5cbiAgICAvL2JpbmRpbmcgZXZlbnQgdG8gYWN0dWFsIFVJXG4gICAgJG9uKCkge1xuICAgICAgICBpZiAodGhpcy4jZm9ybSkge1xuICAgICAgICAgICAgdGhpcy4jZm9ybS4kb24oLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvYWRpbmcoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImxvYWRpbmdcIik7XG4gICAgICAgIHRoaXMuI2Zvcm0uc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIHJlc2V0TG9hZGluZygpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG9hZGVkXCIpO1xuICAgICAgICB0aGlzLiNmb3JtLnJlc2V0TG9hZGluZygpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgICAgIGlmICh0aGlzLiNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLiNmb3JtLiRkZXN0cm95ICYmIHRoaXMuI2Zvcm0uJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0uZGVzdHJveSAmJiB0aGlzLiNmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3ZhbGlkYXRpb25SdW5uZXIgPSBudWxsO1xuICAgICAgICB0aGlzLiNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLiNmaWVsZHMgPSBudWxsO1xuICAgICAgICB0aGlzLiN2YXJpYW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhudWxsKTtcbiAgICAgICAgdGhpcy5zZXRXb3JraW5nKG51bGwpO1xuICAgICAgICB0aGlzLnNldERhdGEobnVsbCk7XG4gICAgfVxuXG4gICAgI2dldEZvcm1Qcm9wcyh7XG4gICAgICAgIG1hbmlmZXN0LCAvL21vZGVsIG1hbmlmZXN0XG4gICAgICAgIGZvcm1PcHRpb25zID0ge1xuICAgICAgICAgICAgdWk6IHt9LFxuICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgfSwgLy9zb21lIG9wdGlvbnNcbiAgICAgICAgZGF0YSA9IG51bGwsIC8vaW5pdGlhbCBkYXRhIGZvciBmb3JtXG4gICAgICAgIGluamVjdGVkUHJvcHMgPSB7fSxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuI2FjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtT3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBmb3JtT3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdWk6IHt9LFxuICAgICAgICAgICAgICAgIGZpZWxkczoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZm9ybSA9IEZvcm1IZWxwZXJzLmluaXRGb3JtQnlGaWVsZChcbiAgICAgICAgICAgIC8vZm9ybSBzZWVkIG9iamVjdFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAvKlxuICAgICAgRm9ybSBzdHJ1Y3R1cmVcbiAgICAgIFtcbiAgICAgICAgLy9lYWNoIGl0ZW0gaXMgbGluZSBvZiBmb3JtXG4gICAgICAgIC8vZmllbGQgLSBmaWVsZCB0YWtlcyB3aG9sZSBsaW5lIG9mIGZvcm1cbiAgICAgICAgLy9bZmllbGQxLCBmaWVsZDJdIC0gZmV3IGZpZWxkcyBpbiBvbmUgbGluZVxuICAgICAgICBuYW1lRmlyc3QsIG5hbWVMYXN0XG4gICAgICAgIFthZ2UsIGNvdW50cnksIGxhbmd1YWdlXSxcbiAgICAgICAgW2VtYWlsLCB0ZWxlcGhvbmVdXG4gICAgICBdXG4gICAgICAqL1xuICAgICAgICAgICAgbWFuaWZlc3QuYWN0aW9uc1thY3Rpb25dLmZpZWxkcywgLy9mb3JtIGZpZWxkcyBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHRoaXMuI3ZhcmlhbnRzLCAvL3ZhcmlhbnRzIGxpYnJhcnlcbiAgICAgICAgICAgIHRoaXMuI2ZpZWxkcywgLy9maWVsZHMgbGlicmFyeVxuICAgICAgICAgICAgZm9ybU9wdGlvbnMuZmllbGRzLCAvL2Zvcm0gd2lkZSBmaWVsZHMgb3B0aW9uc1xuICAgICAgICAgICAgZGF0YVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvL2lmIG5vIGF1dG8gaW5pdCBvZiBmb3JtIHN0cnVjdHVyZSwgc2V0IHRvIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgICAgIGxvYWRpbmc6ICF0aGlzLmdldE9wdGlvbnMoXCJhdXRvSW5pdFwiLCB0cnVlKSxcbiAgICAgICAgICAgIHRpdGxlOiBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0udGl0bGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbWFuaWZlc3QuYWN0aW9uc1thY3Rpb25dLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZmllbGRzOiBtYW5pZmVzdC5hY3Rpb25zW2FjdGlvbl0uZmllbGRzLFxuICAgICAgICAgICAgZm9ybSxcbiAgICAgICAgICAgIC8vaW5qZWN0aW5nIG9wdGlvbnMgdG8gVUkgZnJvbSB0b3AgbGV2ZWwgaW5wdXRcbiAgICAgICAgICAgIC4uLmZvcm1PcHRpb25zLnVpLCAvL2Zvcm0gVUkgb3B0aW9uc1xuICAgICAgICAgICAgLi4uaW5qZWN0ZWRQcm9wcyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JraW5nKFwibmFtZVwiKTtcbiAgICB9XG5cbiAgICBnZXRGb3JtQWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYWN0aW9uO1xuICAgIH1cblxuICAgIHNldEZvcm1BY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgJiYgdmFsICE9PSB0aGlzLiNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuI2FjdGlvbiA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0gJiYgdGhpcy4jZm9ybS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbml0Rm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc1Jlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IERFRkFVTFRfU1RBVFVTX1NVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9ybVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtRXJyb3JzKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgIEZvcm0gdmFsaWRhdGlvbiByZXN1bHRcbiAgICAgKiovXG4gICAgc2V0Rm9ybVN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuI2Zvcm0uc2hvd1N1Y2Nlc3MoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtRXJyb3JzKHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwicmVhZG9ubHlcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgZm9ybTogW10sXG4gICAgICAgICAgICBmaWVsZHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN0YXR1cy5mb3JtLnB1c2gocmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmIE9iamVjdC5rZXlzKHJlc3VsdC5lcnJvcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXR1cy5maWVsZHMgPSB7IC4uLnJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmb3JtLnVwZGF0ZUZvcm1WYWxpZGF0aW9uU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YXJpYW50IGJ5IGNvbGxlY3Rpb24gbmFtZSBhbmQgaXRlbSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgIG5hbWUgIG5hbWUgb2YgdGhlIHZhcmlhbnRzIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9ICBpZCAgICBpdGVtIGlkZW50aWZpY2F0b3JcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICAgICAgICAgICBpdGVtXG4gICAgICoqL1xuICAgIGdldFZhcmlhbnQobmFtZSwgaWQpIHtcbiAgICAgICAgbGV0IGxpYiA9IHRoaXMuI3ZhcmlhbnRzLmdldChuYW1lKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGxpYi5maW5kKChpdGVtKSA9PiBpdGVtLmlkID09PSBpZCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqKlxuICAgICAqIFJlZGVmaW5hYmxlIGdldHRlcnNcbiAgICAgKiovXG5cbiAgICBnZXRGb3JtVGFyZ2V0RWwoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsID0gdGhpcy5nZXRPcHRpb25zKFwidGFyZ2V0XCIsIERFRkFVTFRfQ09OVEFJTkVSX1NFTEVDVE9SKTtcbiAgICAgICAgaWYgKHRhcmdldEVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRFbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0RWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldEVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvcm0gcGFyZW50IGVsZW1lbnQgaXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtVmFsaWRhdG9ycygpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9ucyhcInZhbGlkYXRvcnNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbnMoXCJ2YWxpZGF0b3JzXCIsIHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI21pc3NpbmdPdmVycmlkZVdhcm5pbmcoXCJ2YWxpZGF0b3JzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rm9ybU1hbmlmZXN0KCkge1xuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLmdldE1vZGVsTmFtZSgpO1xuICAgICAgICBpZiAobW9kZWxOYW1lICYmIG5vdENvbW1vbi5nZXRBcHAoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRJbnRlcmZhY2VNYW5pZmVzdChtb2RlbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbnMoXCJtYW5pZmVzdFwiLCB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwibWFuaWZlc3RcIiwge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcIm1hbmlmZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rm9ybURhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLmdldERhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jbWlzc2luZ092ZXJyaWRlV2FybmluZyhcImRhdGFcIik7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtT3B0aW9ucygpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwidWlcIiwgdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKFwiZmllbGRzXCIsIHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVpOiB0aGlzLmdldE9wdGlvbnMoXCJ1aVwiLCB7fSksXG4gICAgICAgICAgICAgICAgZmllbGRzOiB0aGlzLmdldE9wdGlvbnMoXCJmaWVsZHNcIiwge30pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI21pc3NpbmdPdmVycmlkZVdhcm5pbmcoXCJvcHRpb25zXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1aToge30sXG4gICAgICAgICAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtSW5qZWN0ZWRQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcImluamVjdGVkXCIsIHt9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBlbXB0eSBtZXNzYWdlXG4gICAgICoqL1xuICAgICNtaXNzaW5nT3ZlcnJpZGVXYXJuaW5nKG1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5lcnJvcihcbiAgICAgICAgICAgIGAke21pc3Npbmd9IGZvciAke3RoaXMuZ2V0V29ya2luZyhcIm5hbWVcIil9IGZvcm0gaXMgbm90IGRlZmluZWRgXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybSBvcGVyYXRpb25zXG4gICAgICoqL1xuICAgIGNvbGxlY3REYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKFwicmVhZG9ubHlcIiwgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuI2Zvcm0uY29sbGVjdERhdGEoKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKHsgLi4uZGF0YSB9KTsgLy91cGRhdGUgaW4gaW5uZXIgc3RvcmVcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgdXBkYXRlRmllbGQoZmllbGROYW1lLCBwcm9wcykge1xuICAgICAgICB0aGlzLiNmb3JtLnVwZGF0ZUZpZWxkKGZpZWxkTmFtZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIGdldE1vZGVsKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmZhY2UobmFtZSkoZGF0YSB8fCB7fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbnRlcmZhY2UoKShuYW1lIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEludGVyZmFjZShuYW1lID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5vdENvbW1vbi5nZXRBcHAoKS5nZXRJbnRlcmZhY2UobmFtZSB8fCB0aGlzLmdldE1vZGVsTmFtZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBjdXJyZW50IG1vZGVsIG5hbWVcbiAgICAgKiAgQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1vZGVsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9ucyhcIm1vZGVsXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Rm9ybTtcbiIsIjxzY3JpcHQ+XG5cbiAgaW1wb3J0IFVJQnV0dG9ucyBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9idXR0b24vdWkuYnV0dG9ucy5zdmVsdGUnO1xuXG4gIGltcG9ydCB7XG4gICAgICBjcmVhdGVFdmVudERpc3BhdGNoZXIsXG4gICAgICBvbk1vdW50XG4gIH0gZnJvbSAnc3ZlbHRlJztcblxuICBsZXQgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dNb2Rlc11cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFttb2RlXVxuICAgKiBAcHJvcGVydHkge2FueX0gW2Zvcm1zXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0LWZvcm0nLFxuICAgICAgc2hvd01vZGVzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJGJpbmRhYmxlKCdkZWZhdWx0JyksXG4gICAgICBmb3JtcyA9IFtdXG4gIH0gPSAkcHJvcHMoKTtcblxuICBmdW5jdGlvbiBzZXRNb2RlKHZhbCkge1xuICAgICAgbW9kZSA9IHZhbDtcbiAgICAgIGRpc3BhdGNoKCdtb2RlJywgdmFsKTtcbiAgICAgIHVwZGF0ZU1vZGVzQnV0dG9ucygpO1xuICB9XG5cbiAgbGV0IEZPUk1TX0JVVFRPTlMgPSAkc3RhdGUoW10pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZU1vZGVzQnV0dG9ucygpIHtcbiAgICAgIEZPUk1TX0JVVFRPTlMgPSBmb3Jtcy5maWx0ZXIoZm9ybSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChtb2RlICE9PSBmb3JtLm1vZGUpO1xuICAgICAgfSkubWFwKGZvcm0gPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRpdGxlOiBmb3JtLnRpdGxlLFxuICAgICAgICAgICAgICBvdXRsaW5lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICBhY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzZXRNb2RlKGZvcm0ubW9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICAgIHVwZGF0ZU1vZGVzQnV0dG9ucygpO1xuICB9KTtcblxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJibG9jay1jb250YWluZXJcIiBpZD1cIntuYW1lfS1mb3JtLXNldFwiPlxuICA8ZGl2IGNsYXNzPVwiZm9ybS1wYXBlclwiICBpZD1cIntuYW1lfS1mb3JtLXNldC1jb250YWluZXJcIj48L2Rpdj5cbiAgeyNpZiBzaG93TW9kZXN9XG4gIDxVSUJ1dHRvbnMgY2VudGVyZWQ9e3RydWV9IGJpbmQ6dmFsdWVzPXtGT1JNU19CVVRUT05TfSBjbGFzc2VzPSdtdC00JyAvPlxuICB7L2lmfVxuPC9kaXY+XG4iLCJpbXBvcnQgbm90QmFzZSBmcm9tIFwiLi4vLi4vYmFzZVwiO1xuXG5pbXBvcnQgVUlGb3JtU2V0Q29tcG9uZW50IGZyb20gXCIuL2Zvcm0uc2V0LnN2ZWx0ZVwiO1xuaW1wb3J0IFVJRm9ybUNvbXBvbmVudCBmcm9tIFwiLi9mb3JtLnN2ZWx0ZVwiO1xuXG5jb25zdCBERUZBVUxUX0NPTlRBSU5FUl9TRUxFQ1RPUiA9IFwiLmZvcm0tc2V0XCI7XG5jb25zdCBERUZBVUxUX0ZPUk1fU0VUX05BTUUgPSBcImZvcm0tc2V0XCI7XG5cbmNsYXNzIG5vdEZvcm1TZXQgZXh0ZW5kcyBub3RCYXNlIHtcbiAgICAjZm9ybVNldENvbXBvbmVudCA9IG51bGw7XG4gICAgI2Zvcm1Db21wb25lbnQgPSBudWxsO1xuXG4gICAgI2Zvcm0gPSBudWxsO1xuICAgICNmcmFtZSA9IG51bGw7XG5cbiAgICAvKlxuICBuZXcgbm90Rm9ybVNldCh7XG4gICAgb3B0aW9uczp7XG4gICAgICB0YXJnZXQ6IGVsLFxuICAgICAgZm9ybXM6IFt7XG4gICAgICAgIG1vZGU6ICdmb3JtMScsXG4gICAgICAgIHRpdGxlOiAnRm9ybSAxJyxcbiAgICAgICAgZm9ybTogZm9ybUNvbnN0cnVjdG9yMSAvL2N1c3RvbSBjb25zdHJ1Y3RvcnNcbiAgICAgIH0se1xuICAgICAgICBtb2RlOiAnZm9ybTInLFxuICAgICAgICB0aXRsZTogJ0Zvcm0gMicsXG4gICAgICAgIHByb3BzOiB7fSAgICAgICAgICAgICAvL3BhcmFtcyB0byBjcmVhdGUgbm90Rm9ybSBpbnN0YW5jZVxuICAgICAgfSx7XG4gICAgICAgIG1vZGU6ICdmb3JtMycsXG4gICAgICAgIHRpdGxlOiAnRm9ybSAzJyxcbiAgICAgICAgZm9ybTogZm9ybUNvbnN0cnVjdG9yMyAvL2N1c3RvbSBjb25zdHJ1Y3RvcnNcbiAgICAgIH1dXG4gICAgfVxuICB9KTtcbiAgKi9cblxuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgb3B0aW9ucyA9IHt9LFxuICAgICAgICBmb3JtQ29tcG9uZW50ID0gVUlGb3JtQ29tcG9uZW50LFxuICAgICAgICBmb3JtU2V0Q29tcG9uZW50ID0gVUlGb3JtU2V0Q29tcG9uZW50LFxuICAgIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IERFRkFVTFRfRk9STV9TRVRfTkFNRSxcbiAgICAgICAgICAgICAgICBtb2RlOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICBzaG93TW9kZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmb3JtQ29tcG9uZW50ID0gZm9ybUNvbXBvbmVudDtcbiAgICAgICAgdGhpcy4jZm9ybVNldENvbXBvbmVudCA9IGZvcm1TZXRDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuc2V0Rm9ybU1vZGUodGhpcy5nZXRPcHRpb25zKFwibW9kZVwiKSk7XG4gICAgICAgIHRoaXMuaW5pdFVJKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGFsaXppbmcgZm9ybSBmcmFtZSBtb2RlLCB3aXRoIHN3aXRjaGVycyBiZXR3ZWVuIG1vZGVzXG4gICAgICoqL1xuICAgIGluaXRVSSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRGcmFtZVRhcmdldEVsKCk7XG4gICAgICAgIHdoaWxlICh0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoKSB0YXJnZXQucmVtb3ZlQ2hpbGQodGFyZ2V0LmZpcnN0Q2hpbGQpO1xuICAgICAgICB0aGlzLiNmcmFtZSA9IG5ldyB0aGlzLiNmb3JtU2V0Q29tcG9uZW50KHtcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BzOiB0aGlzLiNnZXRGcmFtZVByb3BzKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNmcmFtZS4kb24oXCJtb2RlXCIsIChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRGb3JtTW9kZShldi5kZXRhaWwpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvcm0oKTtcbiAgICB9XG5cbiAgICBzZXRGb3JtTW9kZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTW9kZUV4aXN0cyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXb3JraW5nKFwibW9kZVwiLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0V29ya2luZyhcIm1vZGVcIiwgdGhpcy5nZXRGaXJzdE1vZGUoKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1Nb2RlSW5VSSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlRm9ybU1vZGVJblVJKCkge1xuICAgICAgICBpZiAodGhpcy4jZnJhbWUgJiYgdGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jZnJhbWUuJHNldCh7IG1vZGU6IHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIikgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V29ya2luZyhcIm1vZGVcIik7XG4gICAgfVxuXG4gICAgdXBkYXRlRm9ybSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95Rm9ybSgpO1xuICAgICAgICBpZiAodGhpcy5nZXRXb3JraW5nKFwibW9kZVwiKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJGb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXJGb3JtKCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuZ2V0Rm9ybVRhcmdldEVsKCk7XG4gICAgICAgIGNvbnN0IGZvcm1Db25maWcgPSB0aGlzLmdldEZvcm1Db25maWcoKTtcbiAgICAgICAgaWYgKCEodGFyZ2V0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBmb3JtQ29uZmlnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXJyb3Igd2hpbGUgZm9ybSByZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlTW9kZSA9IChtb2RlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEZvcm1Nb2RlKG1vZGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmb3JtQ29uZmlnLmZvcm0pIHtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXRFbC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlQ2hpbGQodGFyZ2V0RWwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLiNmb3JtID0gbmV3IGZvcm1Db25maWcuZm9ybSh7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogeyB0YXJnZXQ6IHRhcmdldEVsLCBjaGFuZ2VNb2RlIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtQ29uZmlnLnByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLiNmb3JtID0gbmV3IHRoaXMuI2Zvcm1Db21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0RWwsXG4gICAgICAgICAgICAgICAgLi4uZm9ybUNvbmZpZy5wcm9wcyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VNb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGb3JtQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKFwiZm9ybXNcIikuZmluZChcbiAgICAgICAgICAgIChmb3JtKSA9PiBmb3JtLm1vZGUgPT09IHRoaXMuZ2V0Rm9ybU1vZGUoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRlc3Ryb3lGb3JtKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJFbCA9IHRoaXMuZ2V0Rm9ybVRhcmdldEVsKCk7XG4gICAgICAgIGlmIChjb250YWluZXJFbCkge1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5lckVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbC5yZW1vdmVDaGlsZChjb250YWluZXJFbC5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNmb3JtICYmIHRoaXMuI2Zvcm0uJGRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuI2Zvcm0uJGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmb3JtID0gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95RnJhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNmcmFtZSAmJiB0aGlzLiNmcmFtZS4kZGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy4jZnJhbWUuJGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmcmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaXNNb2RlRXhpc3RzKG1vZGUpIHtcbiAgICAgICAgY29uc3QgZm9ybXMgPSB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiLCBbXSk7XG4gICAgICAgIHJldHVybiBmb3Jtcy5zb21lKChpdGVtKSA9PiBpdGVtLm1vZGUgPT09IG1vZGUpO1xuICAgIH1cblxuICAgIGdldEZpcnN0TW9kZSgpIHtcbiAgICAgICAgY29uc3QgZm9ybXMgPSB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiLCBbXSk7XG4gICAgICAgIGlmIChmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybXNbMF0ubW9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLiNmb3JtU2V0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZm9ybUNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVzdHJveUZvcm0oKTtcbiAgICAgICAgdGhpcy5kZXN0cm95RnJhbWUoKTtcbiAgICAgICAgdGhpcy5zZXREYXRhKG51bGwpO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMobnVsbCk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhudWxsKTtcbiAgICB9XG5cbiAgICBnZXRGcmFtZVRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldE9wdGlvbnMoXCJ0YXJnZXRcIiwgREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IpO1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm0gc2V0IHRhcmdldCBpcyBub3QgSFRNTEVsZW1lbnQgb3Igc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Rm9ybVRhcmdldEVsKCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRPcHRpb25zKFwibmFtZVwiLCBERUZBVUxUX0ZPUk1fU0VUX05BTUUpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7bmFtZX0tZm9ybS1zZXQtY29udGFpbmVyYCk7XG4gICAgfVxuXG4gICAgI2dldEZyYW1lUHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaG93TW9kZXM6IHRoaXMuZ2V0T3B0aW9ucyhcInNob3dNb2Rlc1wiLCB0cnVlKSxcbiAgICAgICAgICAgIG1vZGU6IHRoaXMuZ2V0Rm9ybU1vZGUoKSxcbiAgICAgICAgICAgIGZvcm1zOiB0aGlzLmdldE9wdGlvbnMoXCJmb3Jtc1wiLCBbXSksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lXCIsIERFRkFVTFRfRk9STV9TRVRfTkFNRSksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RGb3JtU2V0O1xuIiwiPHNjcmlwdD5cblxuICBpbXBvcnQge0xPQ0FMRX0gZnJvbSAnLi4vLi4vLi4vbG9jYWxlJztcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgKiBAcHJvcGVydHkge2FueX0gW2dvXVxuICAgKi9cblxuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBsZXQgeyByb290ID0gJycsIGl0ZW1zID0gW10sIGdvID0gbnVsbCB9ID0gJHByb3BzKCk7XG5cbiAgZnVuY3Rpb24gb25DbGljayhldil7XG4gICAgICBpZih0eXBlb2YgZ28gPT09ICdmdW5jdGlvbicpe1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZ28oZXYuY3VycmVudFRhcmdldC5kYXRhc2V0LmhyZWYpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbjwvc2NyaXB0PlxuXG48bmF2IGNsYXNzPVwiYnJlYWRjcnVtYlwiIGFyaWEtbGFiZWw9XCJicmVhZGNydW1ic1wiPlxuICA8dWw+XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGxpbmssIGluZGV4fVxuICAgIHsjaWYgKGl0ZW1zLmxlbmd0aCA9PT0gKGluZGV4ICsgMSkpIH1cbiAgICA8bGkgY2xhc3M9XCJpcy1hY3RpdmVcIj48YSBocmVmPVwie3Jvb3R9e2xpbmsudXJsfVwiIGRhdGEtaHJlZj1cIntsaW5rLnVybH1cIiBhcmlhLWN1cnJlbnQ9XCJwYWdlXCI+eyRMT0NBTEVbbGluay50aXRsZV19PC9hPjwvbGk+XG4gICAgezplbHNlIH1cbiAgICB7I2lmIGxpbmsudXJsID09PSBmYWxzZSB9XG4gICAgPGxpIGNsYXNzPVwiaXMtcGxhaW4tY3J1bWJcIj57JExPQ0FMRVtsaW5rLnRpdGxlXX08L2xpPlxuICAgIHs6ZWxzZX1cbiAgICA8bGk+PGEgaHJlZj1cIntyb290fXtsaW5rLnVybH1cIiBkYXRhLWhyZWY9XCJ7bGluay51cmx9XCIgb25jbGljaz17b25DbGlja30+eyRMT0NBTEVbbGluay50aXRsZV19PC9hPjwvbGk+XG4gICAgey9pZn1cbiAgICB7L2lmfVxuICAgIHsvZWFjaH1cbiAgPC91bD5cbjwvbmF2PlxuIiwiY2xhc3Mgbm90QnJlYWRjcnVtYnN7XG5cbiAgICBzdGF0aWMgVUlDb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgc3RhdGljIHVpID0gbnVsbDtcbiAgICBzdGF0aWMgaGVhZCA9IFtdO1xuICAgIHN0YXRpYyB0YWlsID0gW107XG5cbiAgICBzdGF0aWMgcmVuZGVyKHt0YXJnZXQsIHJvb3QgPSAnJywgbmF2aWdhdGV9KXtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgaWYobm90QnJlYWRjcnVtYnMuVUlDb25zdHJ1Y3Rvcil7XG4gICAgICAgICAgICB0aGlzLnVpID0gbmV3IG5vdEJyZWFkY3J1bWJzLlVJQ29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBwcm9wczp7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiAgdGhpcy5nZXRCcmVhZGNydW1icygpLFxuICAgICAgICAgICAgICAgICAgICByb290OiAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGdvOiAgICAgIG5hdmlnYXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0SGVhZChoZWFkKXtcbiAgICAgICAgdGhpcy5oZWFkLnNwbGljZSgwLHRoaXMuaGVhZC5sZW5ndGgsLi4uaGVhZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXRUYWlsKHRhaWwpe1xuICAgICAgICB0aGlzLnRhaWwuc3BsaWNlKDAsIHRoaXMudGFpbC5sZW5ndGgsLi4udGFpbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRCcmVhZGNydW1icygpe1xuICAgICAgICBsZXQgY3J1bWJzID0gW107XG4gICAgICAgIGNydW1icy5wdXNoKC4uLnRoaXMuaGVhZCk7XG4gICAgICAgIGNydW1icy5wdXNoKC4uLnRoaXMudGFpbCk7XG4gICAgICAgIHJldHVybiBjcnVtYnM7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZSgpe1xuICAgICAgICBpZih0aGlzLnVpKXtcbiAgICAgICAgICAgIHRoaXMudWkuJHNldCh7IGl0ZW1zOiB0aGlzLmdldEJyZWFkY3J1bWJzKCkgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlKCl7XG4gICAgICAgIGlmICh0aGlzLnVpKSB7XG4gICAgICAgICAgICB0aGlzLnVpLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnVpID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90QnJlYWRjcnVtYnM7XG4iLCJpbXBvcnQgVUlCcmVhZGNydW1icyBmcm9tICcuL3VpLmJyZWFkY3J1bWJzLnN2ZWx0ZSc7XG5pbXBvcnQgbm90QnJlYWRjcnVtYnMgZnJvbSAnLi9icmVhZGNydW1icy5qcyc7XG5cbm5vdEJyZWFkY3J1bWJzLlVJQ29uc3RydWN0b3IgPSBVSUJyZWFkY3J1bWJzO1xuXG5leHBvcnQgZGVmYXVsdCBub3RCcmVhZGNydW1icztcbiIsImltcG9ydCB7IENPTVBPTkVOVFMgfSBmcm9tIFwiLi4vLi4vTElCLmpzXCI7XG5pbXBvcnQgVUlDb21tb24gZnJvbSBcIi4uLy4uLy4uL2VsZW1lbnRzL2NvbW1vbi5qc1wiO1xuXG5jbGFzcyBNZW51IHtcbiAgICBzdGF0aWMgTUFYX1RPVUNIX1dJRFRIID0gMTAyMztcblxuICAgIHN0YXRpYyBERUZBVUxUID0ge1xuICAgICAgICBzZWN0aW9uOiBcImFueVwiLFxuICAgICAgICBzZWN0aW9uVGl0bGU6IFwi0JzQtdC90Y5cIixcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIC8vbGluaywgYnV0dG9uLCBkcm9wZG93biwgY29tcG9uZW50XG4gICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICBvcGVuOiBmYWxzZSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge2ltcG9ydCgnLi4vLi4vYXBwLmpzJykuZGVmYXVsdCB8IG51bGx9XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBNZW51XG4gICAgICovXG4gICAgc3RhdGljIGFwcCA9IG51bGw7XG4gICAgc3RhdGljIGRpcmVjdE5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICBzdGF0aWMgbWVudTtcbiAgICBzdGF0aWMgb3B0aW9ucyA9IHtcbiAgICAgICAgZGlyZWN0TmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgIG5hdmlnYXRlOiAodXJscykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXJlY3ROYXZpZ2F0aW9uKCkgJiYgdGhpcy5hcHApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuYXBwLmdldFdvcmtpbmcoXCJyb3V0ZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMubmF2aWdhdGUodXJscy5zaG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uYXNzaWduKHVybHMuZnVsbCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHN0YXRpYyBoaWRlKCkge31cblxuICAgIHN0YXRpYyBpdGVtcyA9IFtdO1xuICAgIHN0YXRpYyBzZWN0aW9ucyA9IFtdO1xuICAgIHN0YXRpYyBsb2NhdGlvbjtcbiAgICBzdGF0aWMgaW50ZXJ2YWw7XG5cbiAgICBzdGF0aWMgc2V0QXBwKGFwcCkge1xuICAgICAgICBpZiAoIXRoaXMuYXBwKSB7XG4gICAgICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRPcHRpb25zUGF0aFRvKHdoYXQpIHtcbiAgICAgICAgcmV0dXJuIGBtZW51LiR7dGhpcy5vcHRpb25zLnR5cGV9LiR7d2hhdH1gO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0RpcmVjdE5hdmlnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcFxuICAgICAgICAgICAgPyB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcImRpcmVjdE5hdmlnYXRpb25cIiksXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpcmVjdE5hdmlnYXRpb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmRpcmVjdE5hdmlnYXRpb247XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBicmFuZDogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcImJyYW5kXCIsIHRoaXMub3B0aW9ucy5icmFuZCksXG4gICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcIml0ZW1zXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaXRlbXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJzZWN0aW9uc1wiKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRTZWxlY3RvcjogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zUGF0aFRvKFwidGFyZ2V0U2VsZWN0b3JcIiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50YXJnZXRTZWxlY3RvclxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdG9nZ2xlU2VsZWN0b3I6IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcInRvZ2dsZVNlbGVjdG9yXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9nZ2xlU2VsZWN0b3JcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG9wZW46IHRoaXMuYXBwLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3B0aW9uc1BhdGhUbyhcIm9wZW5cIiksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcGVuXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBkaXJlY3ROYXZpZ2F0aW9uOiB0aGlzLmFwcC5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE9wdGlvbnNQYXRoVG8oXCJkaXJlY3ROYXZpZ2F0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGlyZWN0TmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcm9vdDogdGhpcy5hcHAuZ2V0T3B0aW9ucyhcInJvdXRlci5yb290XCIsIHRoaXMub3B0aW9ucy5yb290KSxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZTogdGhpcy5vcHRpb25zLm5hdmlnYXRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50OiB0aGlzLmdldENvbXBvbmVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Q29tcG9uZW50KG5hbWUpIHtcbiAgICAgICAgaWYgKENPTVBPTkVOVFMuY29udGFpbnMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBDT01QT05FTlRTLmdldChuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBpbml0RmllbGQobGlzdCwgZmllbGRzID0gW10pIHtcbiAgICAgICAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd24oaXRlbSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bZmllbGRdID0gdGhpcy5ERUZBVUxUW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGl0ZW0sIFwiaXRlbXNcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRGaWVsZChpdGVtLml0ZW1zLCBmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc29ydExpc3QobGlzdCkge1xuICAgICAgICBsaXN0LnNvcnQoKGl0ZW0xLCBpdGVtMikgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oaXRlbTEsIFwiaXRlbXNcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRMaXN0KGl0ZW0xLml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKGl0ZW0yLCBcIml0ZW1zXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0TGlzdChpdGVtMi5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbTEucHJpb3JpdHkgPT09IGl0ZW0yLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0xLnRpdGxlID4gaXRlbTIudGl0bGUgPyAxIDogLTE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtMS5wcmlvcml0eSA8IGl0ZW0yLnByaW9yaXR5ID8gMSA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVtb3ZlRHVibGljYXRlcyhzZWN0aW9ucykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJpb3JpdHkgPSBzZWN0aW9uc1tpXS5wcmlvcml0eTtcbiAgICAgICAgICAgIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbi5pZCA9PT0gc2VjdGlvbnNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoaXRlbSwgaW5keCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5keCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gaXRlbS5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucy5zcGxpY2Uoc2VjdGlvbnMuaW5kZXhPZihpdGVtKSwgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9uc1tpXS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWN0aW9ucztcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlcGFyZURhdGEoKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICBpdGVtcy5wdXNoKC4uLnRoaXMuZ2V0T3B0aW9ucygpLml0ZW1zKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIHNlY3Rpb25zLnB1c2goLi4udGhpcy5nZXRPcHRpb25zKCkuc2VjdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuaW5pdEZpZWxkKHNlY3Rpb25zLCBbXCJwcmlvcml0eVwiXSk7XG4gICAgICAgIHRoaXMucmVtb3ZlRHVibGljYXRlcyhzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5pdEZpZWxkKGl0ZW1zLCBbXCJwcmlvcml0eVwiLCBcInNlY3Rpb25cIiwgXCJ0eXBlXCJdKTtcbiAgICAgICAgdGhpcy5zb3J0TGlzdChzZWN0aW9ucyk7XG5cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBpZDogdGhpcy5ERUZBVUxULnNlY3Rpb24sXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5ERUZBVUxULnNlY3Rpb25UaXRsZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ydExpc3QoaXRlbXMpO1xuXG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIH1cblxuICAgIHN0YXRpYyByZW1vdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMubWVudS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5tZW51ID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlSW5kaWNhdG9yKHNlY3Rpb25JZCwgaXRlbUlkLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlY3Rpb24oc2VjdGlvbklkLCAoc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgc2VjdGlvbi5pbmRpY2F0b3Iuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbShpdGVtSWQsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpdGVtLmluZGljYXRvci5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlVGFnKHNlY3Rpb25JZCwgaXRlbUlkLCB0YWcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWN0aW9uKHNlY3Rpb25JZCwgKHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNlY3Rpb24udGFnID0gdGFnO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVJdGVtKGl0ZW1JZCwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0udGFnID0gdGFnO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlU2VjdGlvblRhZyhzZWN0aW9uSWQsIHRhZykge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlY3Rpb24oc2VjdGlvbklkLCAoc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgc2VjdGlvbi50YWcgPSB7IC4uLnNlY3Rpb24udGFnLCAuLi50YWcgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZUl0ZW1UYWcoaXRlbUlkLCB0YWcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVJdGVtKGl0ZW1JZCwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGl0ZW0udGFnID0geyAuLi5pdGVtLnRhZywgLi4udGFnIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVTZWN0aW9uKHNlY3Rpb25JZCwgcHJvYykge1xuICAgICAgICBpZiAodGhpcy5zZWN0aW9ucyAmJiBzZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb24gaW4gdGhpcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlY3Rpb25zW3NlY3Rpb25dLmlkICE9PSBzZWN0aW9uSWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHByb2ModGhpcy5zZWN0aW9uc1tzZWN0aW9uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LiRzZXQoeyBzZWN0aW9uczogdGhpcy5zZWN0aW9ucyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVTZWN0aW9uSXRlbXMoc2VjdGlvbklkLCBwcm9jKSB7XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25zICYmIHNlY3Rpb25JZCkge1xuICAgICAgICAgICAgbGV0IG9sZExpc3QgPSB0aGlzLml0ZW1zLmZpbHRlcihcbiAgICAgICAgICAgICAgICAoaXRlbSkgPT4gaXRlbS5zZWN0aW9uID09PSBzZWN0aW9uSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIG9sZExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YoaSksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKC4uLnByb2Mob2xkTGlzdCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudS4kc2V0KHsgaXRlbXM6IHRoaXMuaXRlbXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlSXRlbShpdGVtSWQsIHByb2MpIHtcbiAgICAgICAgaWYgKGl0ZW1JZCAmJiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCAhPT0gaXRlbUlkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgcHJvYyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVudS4kc2V0KHsgaXRlbXM6IHRoaXMuaXRlbXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgaXNUb3VjaCgpIHtcbiAgICAgICAgcmV0dXJuIFVJQ29tbW9uLmlzTW9iaWxlKHRydWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRTZWN0aW9uQ29tcG9uZW50KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWVudTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUluZGljYXRvciBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlXCI7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1dXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHJvb3QgPSBcIlwiLCBpdGVtID0ge30sIG9ubmF2aWdhdGUgPSAoKSA9PiB7fSB9ID0gJHByb3BzKCk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9ubmF2aWdhdGUoe1xuICAgICAgICAgICAgZnVsbDogZXYudGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIiksXG4gICAgICAgICAgICBzaG9ydDogZXYudGFyZ2V0LmRhdGFzZXQuaHJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiB0eXBlb2YgaXRlbS51cmwgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlbS51cmwgIT09IGZhbHNlfVxuICAgIDxsaSBjbGFzcz17aXRlbS5jbGFzc2VzfT5cbiAgICAgICAgPGEgaHJlZj1cIntyb290fXtpdGVtLnVybH1cIiBkYXRhLWhyZWY9e2l0ZW0udXJsfSBvbmNsaWNrPXtvbkNsaWNrfT5cbiAgICAgICAgICAgIHskTE9DQUxFW2l0ZW0udGl0bGVdfVxuICAgICAgICAgICAgeyNpZiBpdGVtLnRhZ31cbiAgICAgICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLnRhZ30gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2lmIGl0ZW0uaW5kaWNhdG9yfVxuICAgICAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17aXRlbS5pZH0gey4uLml0ZW0uaW5kaWNhdG9yfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9hPlxuICAgIDwvbGk+XG57OmVsc2V9XG4gICAgPGxpIGNsYXNzPVwiaXMtbm8tZm9sbG93LXN1YnRpdGxlIHtpdGVtLmNsYXNzZXN9XCI+XG4gICAgICAgIHskTE9DQUxFW2l0ZW0udGl0bGVdfVxuICAgICAgICB7I2lmIGl0ZW0udGFnfVxuICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS50YWd9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgICAgIHsjaWYgaXRlbS5pbmRpY2F0b3J9XG4gICAgICAgICAgICA8VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLmluZGljYXRvcn0gLz5cbiAgICAgICAgey9pZn1cbiAgICA8L2xpPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgY29uc3QgQ0xBU1NfSUNPTiA9IHtcbiAgICAgICAgT1BFTkVEOiBcImZhLWFuZ2xlLWRvd25cIixcbiAgICAgICAgQ0xPU0VEOiBcImZhLWFuZ2xlLXVwXCIsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpY29uX29wZW5lZF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2ljb25fY2xvc2VkXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nsb3NlZF0gICAgcmV0dXJucyBpZiB3ZSBzaG91bGQgYXBwbHkgdG9nZ2xlIG9yIGlmIGZhbHNlIC0gcmVqZWN0IGl0IGFuZCB0b2dnbGUgYmFja3dhcmRcbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgaWNvbl9vcGVuZWQgPSBDTEFTU19JQ09OLk9QRU5FRCxcbiAgICAgICAgaWNvbl9jbG9zZWQgPSBDTEFTU19JQ09OLkNMT1NFRCxcbiAgICAgICAgY2xvc2VkLFxuICAgICAgICBvbnRvZ2dsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKSAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjbG9zZWQgPSAhY2xvc2VkO1xuICAgICAgICBpZiAoIW9udG9nZ2xlKGNsb3NlZCkpIHtcbiAgICAgICAgICAgIGNsb3NlZCA9ICFjbG9zZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbjwvc2NyaXB0PlxuXG48c3BhblxuICAgIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy10b2dnbGUtc3VibWVudSBpcy1wdWxsZWQtcmlnaHRcIlxuICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgb25rZXl1cD17b25DbGlja31cbiAgICByb2xlPVwiYnV0dG9uXCJcbiAgICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIDxpIGNsYXNzPVwiZmFzIHtjbG9zZWQgPyBpY29uX2Nsb3NlZCA6IGljb25fb3BlbmVkfVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbjwvc3Bhbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgTE9DQUxFIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuICAgIGltcG9ydCBVSUljb24gZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5mb250LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUluZGljYXRvciBmcm9tIFwiLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS5pbmRpY2F0b3Iuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJVGFnIGZyb20gXCIuLi8uLi8uLi8uLi9lbGVtZW50cy92YXJpb3VzL3VpLnRhZy5zdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBDT01QT05FTlRTIH0gZnJvbSBcIi4uLy4uLy4uL0xJQi5qc1wiO1xuICAgIGxldCB7IGl0ZW0gPSB7fSwgY2hpbGRyZW4gfSA9ICRwcm9wcygpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbS5pY29ufVxuICAgIDxVSUljb24gey4uLml0ZW0uaWNvbn0gLz5cbns6ZWxzZSBpZiBpdGVtLnR5cGUgPT09IFwiY29tcG9uZW50XCIgJiYgaXRlbS5jb21wb25lbnQgJiYgQ09NUE9ORU5UUy5jb250YWlucyhpdGVtLmNvbXBvbmVudCl9XG4gICAge0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBDT01QT05FTlRTLmdldChpdGVtLmNvbXBvbmVudCl9XG4gICAgPFN2ZWx0ZUNvbXBvbmVudCBpZD17aXRlbS5pZH0gey4uLml0ZW0ucHJvcHN9IC8+XG57OmVsc2V9XG4gICAgPHNwYW4gY2xhc3M9XCJpcy1uby1saW5rXCI+eyRMT0NBTEVbaXRlbS50aXRsZV19PC9zcGFuPlxuey9pZn1cbnsjaWYgaXRlbS50YWd9XG4gICAgPFVJVGFnIGlkPXtpdGVtLmlkfSB7Li4uaXRlbS50YWd9IC8+XG57L2lmfVxueyNpZiBpdGVtLmluZGljYXRvcn1cbiAgICA8VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLmluZGljYXRvcn0gLz5cbnsvaWZ9XG57QHJlbmRlciBjaGlsZHJlbj8uKCl9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBVaV9pdGVtcyBmcm9tIFwiLi91aS5pdGVtcy5zdmVsdGVcIjtcblxuICAgIGltcG9ydCBVSVNpZGVNZW51SXRlbVdpdGhvdXRDaGlsZHJlbiBmcm9tIFwiLi91aS5pdGVtLndpdGhvdXQuY2hpbGRyZW4uc3ZlbHRlXCI7XG5cbiAgICBpbXBvcnQgVUlTaWRlTWVudVRyaWdnZXIgZnJvbSBcIi4vdWkudHJpZ2dlci5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlTaWRlTWVudUl0ZW1MYWJlbCBmcm9tIFwiLi91aS5pdGVtLmxhYmVsLnN2ZWx0ZVwiO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3Jvb3RdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbG9zZWRdXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW29ubmF2aWdhdGVdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHJvb3QgPSBcIlwiLCBpdGVtcyA9IFtdLCBjbG9zZWQsIG9ubmF2aWdhdGUgPSAoKSA9PiB7fSB9ID0gJHByb3BzKCk7XG5cbiAgICBjb25zdCBjcmVhdGVDbG9zZWRJdGVtc0xpYiA9IChsc3QpID0+IHtcbiAgICAgICAgY29uc3QgbGliID0ge307XG4gICAgICAgIGxzdC5mb3JFYWNoKChpdG0sIGluZGV4KSA9PiAobGliW2luZGV4XSA9IGl0bS5jbG9zZWQpKTtcbiAgICAgICAgcmV0dXJuIGxpYjtcbiAgICB9O1xuXG4gICAgbGV0IGNsb3NlZENoaWxkcmVuID0gJHN0YXRlKGNyZWF0ZUNsb3NlZEl0ZW1zTGliKGl0ZW1zKSk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG9ubmF2aWdhdGUoe1xuICAgICAgICAgICAgZnVsbDogZXYudGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIiksXG4gICAgICAgICAgICBzaG9ydDogZXYudGFyZ2V0LmRhdGFzZXQuaHJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG48L3NjcmlwdD5cblxuPHVsIGNsYXNzPVwibWVudS1saXN0IHtjbG9zZWQgPyAnaXMtY2xvc2VkJyA6ICcnfVwiPlxuICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtLCBpbmRleH1cbiAgICAgICAgeyNpZiBpdGVtLml0ZW1zICYmIGl0ZW0uaXRlbXMubGVuZ3RofVxuICAgICAgICAgICAgPGxpIGNsYXNzPVwiaXMtbm8tZm9sbG93LXN1YnRpdGxlIHtpdGVtLmNsYXNzZXN9XCI+XG4gICAgICAgICAgICAgICAgeyNpZiB0eXBlb2YgaXRlbS51cmwgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlbS51cmwgIT09IGZhbHNlfVxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cIntyb290fXtpdGVtLnVybH1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1ocmVmPXtpdGVtLnVybH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImhhcy1zdWJpdGVtc1wiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxVSVNpZGVNZW51SXRlbUxhYmVsIHtpdGVtfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VUlTaWRlTWVudVRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZDpjbG9zZWQ9e2Nsb3NlZENoaWxkcmVuW2luZGV4XX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9VSVNpZGVNZW51SXRlbUxhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICA8VUlTaWRlTWVudUl0ZW1MYWJlbCB7aXRlbX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VUlTaWRlTWVudVRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kOmNsb3NlZD17Y2xvc2VkQ2hpbGRyZW5baW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9VSVNpZGVNZW51SXRlbUxhYmVsPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPFVpX2l0ZW1zXG4gICAgICAgICAgICAgICAgICAgIHtyb290fVxuICAgICAgICAgICAgICAgICAgICBpdGVtcz17aXRlbS5pdGVtc31cbiAgICAgICAgICAgICAgICAgICAgYmluZDpjbG9zZWQ9e2Nsb3NlZENoaWxkcmVuW2luZGV4XX1cbiAgICAgICAgICAgICAgICAgICAge29ubmF2aWdhdGV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxVSVNpZGVNZW51SXRlbVdpdGhvdXRDaGlsZHJlbiB7cm9vdH0ge2l0ZW19IHtvbm5hdmlnYXRlfSAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbjwvdWw+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IExPQ0FMRSB9IGZyb20gXCIuLi8uLi8uLi8uLi9sb2NhbGVcIjtcbiAgICBpbXBvcnQgVUlJbmRpY2F0b3IgZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuaW5kaWNhdG9yLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSVNpZGVNZW51SXRlbXMgZnJvbSBcIi4vdWkuaXRlbXMuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IHsgQ09NUE9ORU5UUyB9IGZyb20gXCIuLi8uLi8uLi9MSUIuanNcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHthbnl9ICAgICAgc2VjdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSAgICAgIFtpdGVtc11cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gICBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb25uYXZpZ2F0ZV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHsgc2VjdGlvbiwgaXRlbXMgPSBbXSwgcm9vdCA9IFwiXCIsIG9ubmF2aWdhdGUgPSAoKSA9PiB7fSB9ID0gJHByb3BzKCk7XG5cbiAgICBsZXQgc2VjdGlvbkl0ZW1zID0gJGRlcml2ZWQoXG4gICAgICAgIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gc2VjdGlvbi5pZCA9PT0gaXRlbS5zZWN0aW9uKVxuICAgICk7XG48L3NjcmlwdD5cblxueyNpZiBzZWN0aW9ufVxuICAgIHsjaWYgc2VjdGlvbkl0ZW1zLmxlbmd0aCB8fCBzZWN0aW9uLmNvbXBvbmVudCB8fCBzZWN0aW9uLnRhZyB8fCBzZWN0aW9uLmluZGljYXRvcn1cbiAgICAgICAgPHAgY2xhc3M9XCJtZW51LWxhYmVsIHtzZWN0aW9uLmNsYXNzZXN9XCI+XG4gICAgICAgICAgICB7I2lmIHNlY3Rpb24udHlwZSA9PT0gXCJjb21wb25lbnRcIiAmJiBzZWN0aW9uLmNvbXBvbmVudCAmJiBDT01QT05FTlRTLmNvbnRhaW5zKHNlY3Rpb24uY29tcG9uZW50KX1cbiAgICAgICAgICAgICAgICB7QGNvbnN0IFN2ZWx0ZUNvbXBvbmVudCA9IENPTVBPTkVOVFMuZ2V0KHNlY3Rpb24uY29tcG9uZW50KX1cbiAgICAgICAgICAgICAgICA8U3ZlbHRlQ29tcG9uZW50IGlkPXtzZWN0aW9uLmlkfSB7Li4uc2VjdGlvbi5wcm9wc30gLz5cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICB7JExPQ0FMRVtzZWN0aW9uLnRpdGxlXX1cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2lmIHNlY3Rpb24udGFnfVxuICAgICAgICAgICAgICAgIDxVSUluZGljYXRvciBpZD17c2VjdGlvbi5pZH0gey4uLnNlY3Rpb24udGFnfSAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjaWYgc2VjdGlvbi5pbmRpY2F0b3J9XG4gICAgICAgICAgICAgICAgPFVJSW5kaWNhdG9yIGlkPXtzZWN0aW9uLmlkfSB7Li4uc2VjdGlvbi5pbmRpY2F0b3J9IC8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3A+XG4gICAgey9pZn1cbnsvaWZ9XG57I2lmIHNlY3Rpb25JdGVtcy5sZW5ndGh9XG4gICAgPFVJU2lkZU1lbnVJdGVtcyB7cm9vdH0gaXRlbXM9e3NlY3Rpb25JdGVtc30ge29ubmF2aWdhdGV9IC8+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgVUlTaWRlTWVudVNlY3Rpb24gZnJvbSBcIi4vdWkuc2VjdGlvbi5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VjdGlvbnNdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtuYXZpZ2F0ZSA9ICgpPT51bmRlZmluZWRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHJvb3QgPSBcIlwiLCBpdGVtcyA9IFtdLCBzZWN0aW9ucyA9IFtdLCBuYXZpZ2F0ZSA9IG51bGwgfSA9ICRwcm9wcygpO1xuXG4gICAgZnVuY3Rpb24gb25DbGljayhldikge1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5hdmlnYXRlKGV2KTtcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG57I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbn1cbiAgICA8VUlTaWRlTWVudVNlY3Rpb24ge3NlY3Rpb259IHtpdGVtc30ge3Jvb3R9IG9ubmF2aWdhdGU9e29uQ2xpY2t9IC8+XG57L2VhY2h9XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblxuY29uc3QgU2lkZU1lbnVTdGF0ZSA9IHdyaXRhYmxlKHtcbiAgICBvcGVuOiB0cnVlLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNpZGVNZW51U3RhdGU7XG4iLCJpbXBvcnQgTWVudSBmcm9tIFwiLi4vbWVudS5qc1wiO1xuaW1wb3J0IFVJU2lkZU1lbnUgZnJvbSBcIi4vdWkuc2lkZS5tZW51LnN2ZWx0ZVwiO1xuXG5pbXBvcnQgU2lkZU1lbnVTdGF0ZSBmcm9tIFwiLi9zdG9yZS5qc1wiO1xuaW1wb3J0IHsgbW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbmNvbnN0IFRZUEUgPSBcInNpZGVcIjtcblxuY2xhc3Mgbm90U2lkZU1lbnUgZXh0ZW5kcyBNZW51IHtcbiAgICBzdGF0aWMgbmF2O1xuICAgIHN0YXRpYyBtYWluO1xuICAgIHN0YXRpYyBhc2lkZTtcblxuICAgIHN0YXRpYyBERUZBVUxUID0ge1xuICAgICAgICBzZWN0aW9uOiBcImFueVwiLFxuICAgICAgICBzZWN0aW9uVGl0bGU6IFwi0JzQtdC90Y5cIixcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgIH07XG5cbiAgICBzdGF0aWMgb3B0aW9ucyA9IHtcbiAgICAgICAgZGlyZWN0TmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgIHR5cGU6IFRZUEUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc2VjdGlvbnM6IFtdLFxuICAgICAgICB0YXJnZXRTZWxlY3RvcjogYCMke1RZUEV9LW1lbnVgLFxuICAgICAgICB0b2dnbGVTZWxlY3RvcjogYC4ke1RZUEV9LW1lbnUtdG9nZ2xlYCxcbiAgICAgICAgcm9vdDogXCIvXCIsXG4gICAgICAgIG9wZW46IHRydWUsXG4gICAgICAgIG5hdmlnYXRlOiAodXJscykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAuZW1pdChcInRvcC1uYXZiYXItYnVyZ2VyOnVwZGF0ZVwiLCB7IGNsb3NlZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RpcmVjdE5hdmlnYXRpb24oKSAmJiB0aGlzLmFwcCkge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jID0gdGhpcy5hcHAuZ2V0V29ya2luZyhcInJvdXRlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5uYXZpZ2F0ZSh1cmxzLnNob3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbi5hc3NpZ24odXJscy5mdWxsKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgc3RhdGljIHJlbmRlcihhcHApIHtcbiAgICAgICAgaWYgKGFwcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBcHAoYXBwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXBhcmVEYXRhKCk7XG4gICAgICAgIGlmICghdGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVVJKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51KSB7XG4gICAgICAgICAgICB0aGlzLm1lbnUuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVUkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVVSSgpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVudSA9IG1vdW50KFVJU2lkZU1lbnUsIHtcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICAgICAgc2VjdGlvbnM6IHRoaXMuc2VjdGlvbnMsXG4gICAgICAgICAgICAgICAgcm9vdDogdGhpcy5nZXRPcHRpb25zKCkucm9vdCxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZTogdGhpcy5nZXRPcHRpb25zKCkubmF2aWdhdGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbml0U2l6ZVJlc3BvbnNlKCk7XG5cbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKHRoaXMudXBkYXRlTWVudUFjdGl2ZUl0ZW0uYmluZCh0aGlzKSwgMjAwKTtcbiAgICAgICAgdGhpcy5iaW5kVG9nZ2xlKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGl0ZW1Jc0FjdGl2ZShpdGVtVVJMKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb2NhdGlvbiArIFwiL1wiKS5pbmRleE9mKGl0ZW1VUkwgKyBcIi9cIikgPiAtMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlTWVudSgpIHtcbiAgICAgICAgQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3IgKyBcIiBhXCIpXG4gICAgICAgICkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbUlzQWN0aXZlKGl0ZW0uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVwZGF0ZU1lbnVBY3RpdmVJdGVtKCkge1xuICAgICAgICBsZXQgdXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBsYXN0TG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uO1xuICAgICAgICBpZiAobGFzdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAodXJsICE9PSBsYXN0TG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gdXJsO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGluaXRTaXplUmVzcG9uc2UoKSB7XG4gICAgICAgIHRoaXMubmF2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm5hdi5uYXZiYXJcIik7XG4gICAgICAgIHRoaXMuYXNpZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYXNpZGVcIik7XG4gICAgICAgIHRoaXMubWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtYWluXCIpO1xuICAgICAgICB0aGlzLnJlc2l6ZUFzaWRlQW5kTWFpbih0aGlzLmFzaWRlLCB0aGlzLm1haW4sIHRoaXMubmF2KTtcbiAgICAgICAgdGhpcy5yZXNpemVNYWluKHRoaXMubWFpbiwgdGhpcy5hc2lkZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMucmVzaXplTWFpbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPcHRpb25zKCkub3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZXNpemVNYWluKCkge1xuICAgICAgICBpZiAodGhpcy5pc1RvdWNoKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzaWRlLmNsYXNzTGlzdC5jb250YWlucyhcImlzLWFjdGl2ZVwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gdGhpcy5hc2lkZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5zdHlsZS5oZWlnaHQgPT09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1haW4uc3R5bGUubWFyZ2luTGVmdCA9IHJlY3Qud2lkdGggKyByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzaXplQXNpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmFzaWRlLnN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMubmF2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5hc2lkZS5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSByZWN0LmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuYXNpZGUuc3R5bGUubWFyZ2luVG9wID0gcmVjdC5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzaXplQXNpZGVBbmRNYWluKCkge1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMubmF2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmFzaWRlLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHJlY3QuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAvL3RoaXMuYXNpZGUuc3R5bGUucGFkZGluZ1RvcCA9IChyZWN0LmhlaWdodCkgKyAncHgnO1xuICAgICAgICAvL3RoaXMubWFpbi5zdHlsZS5tYXJnaW5Ub3AgPSAocmVjdC5oZWlnaHQpICsgJ3B4JztcbiAgICB9XG5cbiAgICBzdGF0aWMgYmluZFRvZ2dsZSgpIHtcbiAgICAgICAgbGV0IGVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5nZXRPcHRpb25zKCkudG9nZ2xlU2VsZWN0b3IpO1xuICAgICAgICBBcnJheS5mcm9tKGVscykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHRvZ2dsZShlKSB7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5hc2lkZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzaWRlLmNsYXNzTGlzdC50b2dnbGUoXCJpcy1jbG9zZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU1haW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGhpZGUoZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QuYWRkKFwiaXMtY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNpemVNYWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgU2lkZU1lbnVTdGF0ZS51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIHNob3coZSkge1xuICAgICAgICBlICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuYXNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG91Y2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNpZGUuY2xhc3NMaXN0LmFkZChcImlzLWFjdGl2ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hc2lkZS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNpemVNYWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgU2lkZU1lbnVTdGF0ZS51cGRhdGUoKHZhbCkgPT4ge1xuICAgICAgICAgICAgdmFsLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNPcGVuKCkge1xuICAgICAgICBpZiAodGhpcy5hc2lkZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb3VjaCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuYXNpZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXMtY2xvc2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFNpZGVNZW51O1xuIiwiPHNjcmlwdD5cbiAgICAvKiBlc2xpbnQgc3ZlbHRlL25vLWF0LWh0bWwtdGFnczogMCAqL1xuICAgIGltcG9ydCBVSUljb24gZnJvbSBcIi4uLy4uLy4uLy4uL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5zdmVsdGVcIjtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9wc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGl0bGVdXG4gICAgICogQHByb3BlcnR5IHthbnl9IFtpY29uXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICB1cmwgPSBcIi9cIixcbiAgICAgICAgdGl0bGUgPSBcIlwiLFxuICAgICAgICBpY29uID0ge1xuICAgICAgICAgICAgc3JjOiBcImh0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS81NngyOFwiLFxuICAgICAgICAgICAgd2lkdGg6IDI4LFxuICAgICAgICAgICAgaGVpZ2h0OiA1NixcbiAgICAgICAgfSxcbiAgICB9ID0gJHByb3BzKCk7XG48L3NjcmlwdD5cblxuPGEgY2xhc3M9XCJuYXZiYXItaXRlbVwiIGhyZWY9e3VybH0+XG4gICAgPFVJSWNvbiB7Li4uaWNvbn0gLz5cbiAgICB7I2lmIHRpdGxlfVxuICAgICAgICB7QGh0bWwgYDxzcGFuIGNsYXNzPVwibmF2YmFyLWl0ZW0tYnJhbmQtdGl0bGVcIj4ke3RpdGxlfTwvc3Bhbj5gfVxuICAgIHsvaWZ9XG48L2E+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQge0xPQ0FMRX0gZnJvbSAnLi4vLi4vLi4vLi4vbG9jYWxlJztcblxuICBpbXBvcnQgVUlJY29uIGZyb20gJy4uLy4uLy4uLy4uL2VsZW1lbnRzL2ljb24vdWkuaWNvbi5zdmVsdGUnO1xuICBpbXBvcnQgVUlUYWcgZnJvbSAnLi4vLi4vLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS50YWcuc3ZlbHRlJztcbiAgaW1wb3J0IFVJSW5kaWNhdG9yIGZyb20gJy4uLy4uLy4uLy4uL2VsZW1lbnRzL3ZhcmlvdXMvdWkuaW5kaWNhdG9yLnN2ZWx0ZSc7XG4gIGltcG9ydCB7Q09NUE9ORU5UU30gZnJvbSAnLi4vLi4vLi4vTElCLmpzJztcbiAgbGV0IHsgaXRlbSB9ID0gJHByb3BzKCk7XG4gIC8qXG4gIHN0cmluZyB0aXRsZVxuICBvYmplY3QgaWNvbjtcbiAgb2JqZWN0IHRhZztcbiAgc3RyaW5nIHR5cGU7XG4gIENsYXNzIGNvbXBvbmVudDtcbiAgb2JqZWN0IGluZGljYXRvcjtcbiAgb2JqZWN0IG9wdGlvbnM7XG4gICovXG5cblxuPC9zY3JpcHQ+XG5cbnsjaWYgaXRlbS5pY29ufVxuPFVJSWNvbiB7Li4uaXRlbS5pY29ufSAvPlxuezplbHNlIGlmIChpdGVtLnR5cGU9PT0nY29tcG9uZW50JyAmJiBpdGVtLmNvbXBvbmVudCAmJiBDT01QT05FTlRTLmNvbnRhaW5zKGl0ZW0uY29tcG9uZW50KSkgfVxue0Bjb25zdCBTdmVsdGVDb21wb25lbnQgPSBDT01QT05FTlRTLmdldChpdGVtLmNvbXBvbmVudCl9XG48U3ZlbHRlQ29tcG9uZW50XG4gIGlkPXtpdGVtLmlkfVxuICB7Li4uaXRlbS5wcm9wc31cbiAgIC8+XG57OmVsc2V9XG57JExPQ0FMRVtpdGVtLnRpdGxlXX1cbnsvaWZ9XG5cbnsjaWYgaXRlbS50YWcgfVxuPFVJVGFnIHRvcD17dHJ1ZX0gcmlnaHQ9e3RydWV9IHNpemU9J3NtYWxsJyBpZD17aXRlbS5pZH0gey4uLml0ZW0udGFnfT48L1VJVGFnPlxuey9pZn1cblxueyNpZiBpdGVtLmluZGljYXRvciB9XG48VUlJbmRpY2F0b3IgaWQ9e2l0ZW0uaWR9IHsuLi5pdGVtLmluZGljYXRvcn0gLz5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IFVJSXRlbUNvbnRlbnQgZnJvbSBcIi4vdWkuaXRlbS5jb250ZW50LnN2ZWx0ZVwiO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbaXRlbV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2hpZGRlbl1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzZXNdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7IHJvb3QgPSBcIlwiLCBpdGVtID0ge30sIGhpZGRlbiA9IFwiXCIsIGNsYXNzZXMgPSBcIlwiIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZGlzcGF0Y2goXCJjbGlja1wiLCB7IGV2ZW50LCBlbGVtZW50OiBpdGVtIH0pO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIGl0ZW0uYnJlYWt9XG4gICAgPGhyIGNsYXNzPVwibmF2YmFyLWRpdmlkZXIge2hpZGRlbiA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YCA6ICcnfSBcIiAvPlxuey9pZn1cblxueyNpZiBpdGVtLnVybH1cbiAgICA8YVxuICAgICAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtIHtoaWRkZW5cbiAgICAgICAgICAgID8gYGlzLWhpZGRlbi0ke2hpZGRlbn1gXG4gICAgICAgICAgICA6ICcnfSB7aXRlbS5jbGFzc2VzfSB7Y2xhc3Nlc30gXCJcbiAgICAgICAgaHJlZj1cIntyb290fXtpdGVtLnVybH1cIlxuICAgICAgICBkYXRhLWhyZWY9e2l0ZW0udXJsfVxuICAgID5cbiAgICAgICAgPFVJSXRlbUNvbnRlbnQge2l0ZW19IC8+XG4gICAgPC9hPlxuezplbHNlfVxuICAgIDxkaXZcbiAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgb25rZXl1cD17b25DbGlja31cbiAgICAgICAgY2xhc3M9XCJuYXZiYXItaXRlbSB7aGlkZGVuXG4gICAgICAgICAgICA/IGBpcy1oaWRkZW4tJHtoaWRkZW59YFxuICAgICAgICAgICAgOiAnJ30ge2l0ZW0uY2xhc3Nlc30ge2NsYXNzZXN9XCJcbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgPlxuICAgICAgICA8VUlJdGVtQ29udGVudCB7aXRlbX0gLz5cbiAgICA8L2Rpdj5cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gICAgaW1wb3J0IFVJSXRlbUNvbnRlbnQgZnJvbSBcIi4vdWkuaXRlbS5jb250ZW50LnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSUl0ZW0gZnJvbSBcIi4vdWkuaXRlbS5zdmVsdGVcIjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFByb3BzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtyb290XVxuICAgICAqIEBwcm9wZXJ0eSB7YW55fSBbc2VjdGlvbl1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaGlkZGVuXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2hvdmVyYWJsZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJvd2xlc3NdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHRdXG4gICAgICovXG5cbiAgICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICAgIGxldCB7XG4gICAgICAgIHJvb3QgPSBcIlwiLFxuICAgICAgICBzZWN0aW9uID0ge30sXG4gICAgICAgIGl0ZW1zID0gW10sXG4gICAgICAgIGhpZGRlbiA9IFwiXCIsXG4gICAgICAgIGhvdmVyYWJsZSA9IHRydWUsXG4gICAgICAgIGFycm93bGVzcyA9IGZhbHNlLFxuICAgICAgICByaWdodCA9IGZhbHNlLFxuICAgIH0gPSAkcHJvcHMoKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZGlzcGF0Y2goXCJjbGlja1wiLCB7IGV2ZW50LCBlbGVtZW50OiBzZWN0aW9uIH0pO1xuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIGl0ZW1zLmxlbmd0aH1cbiAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwibmF2YmFyLWl0ZW0gaGFzLWRyb3Bkb3duIHtob3ZlcmFibGVcbiAgICAgICAgICAgID8gJ2lzLWhvdmVyYWJsZSdcbiAgICAgICAgICAgIDogJyd9IHtoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiAnJ30gXCJcbiAgICA+XG4gICAgICAgIDxhXG4gICAgICAgICAgICBocmVmXG4gICAgICAgICAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgICAgY2xhc3M9XCJuYXZiYXItbGluayB7YXJyb3dsZXNzID8gJ2lzLWFycm93bGVzcycgOiAnJ31cIlxuICAgICAgICA+XG4gICAgICAgICAgICA8VUlJdGVtQ29udGVudCBpdGVtPXtzZWN0aW9ufSAvPlxuICAgICAgICA8L2E+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItZHJvcGRvd24ge3JpZ2h0ID8gJ2lzLXJpZ2h0JyA6ICcnfVwiPlxuICAgICAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgICAgICAgICAgIDxVSUl0ZW0ge3Jvb3R9IHtpdGVtfSBvbjpjbGljayAvPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbns6ZWxzZSBpZiBzZWN0aW9uLnVybH1cbiAgICA8YVxuICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtIHtoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiAnJ30gXCJcbiAgICAgICAgaHJlZj1cIntyb290fXtzZWN0aW9uLnVybH1cIlxuICAgICAgICBkYXRhLWhyZWY9e3NlY3Rpb24udXJsfVxuICAgICAgICBvbmNsaWNrPXtvbkNsaWNrfVxuICAgID5cbiAgICAgICAgPFVJSXRlbUNvbnRlbnQgaXRlbT17c2VjdGlvbn0gLz5cbiAgICA8L2E+XG57OmVsc2V9XG4gICAgPGRpdlxuICAgICAgICBjbGFzcz1cIm5hdmJhci1pdGVtIHtoaWRkZW4gPyBgaXMtaGlkZGVuLSR7aGlkZGVufWAgOiAnJ30gXCJcbiAgICAgICAgb25jbGljaz17b25DbGlja31cbiAgICAgICAgb25rZXl1cD17b25DbGlja31cbiAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgPlxuICAgICAgICA8VUlJdGVtQ29udGVudCBpdGVtPXtzZWN0aW9ufSAvPlxuICAgIDwvZGl2Plxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgY29uc3QgQ09NUE9ORU5UX05BTUUgPSBcInRvcC1uYXZiYXItYnVyZ2VyXCI7XG5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgaW1wb3J0IFNpZGVNZW51U3RvcmUgZnJvbSBcIi4uL3NpZGUvc3RvcmVcIjtcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cbiAgICBpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi8uLi8uLi9jb21tb25cIjtcblxuXG5cbiAgICBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNsb3NlZCA9ICFjbG9zZWQ7XG4gICAgICAgIGRpc3BhdGNoKFwidG9nZ2xlXCIsIHtcbiAgICAgICAgICAgIGNsb3NlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIENPTVBPTkVOVF9OQU1FICsgXCI6dXBkYXRlXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2V2ZW50c11cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3JlZ2lzdGVyXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Nsb3NlZF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW29uVXBkYXRlXVxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgICBsZXQge1xuICAgICAgICBldmVudHMgPSAkYmluZGFibGUoe30pLFxuICAgICAgICByZWdpc3RlciA9IG5vdENvbW1vbi5yZWdpc3RlcldpZGdldEV2ZW50cy5iaW5kKG5vdENvbW1vbiksXG4gICAgICAgIGNsb3NlZCA9ICRiaW5kYWJsZSh0cnVlKSxcbiAgICAgICAgb25VcGRhdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY2xvc2VkID0gZGF0YS5jbG9zZWQ7XG4gICAgICAgIH1cbiAgICB9ID0gJHByb3BzKCk7XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgaWYgKCFub3RDb21tb24ub2JqSGFzKGV2ZW50cywgZ2V0U3RhbmRhcnRVcGRhdGVFdmVudE5hbWUoKSkpIHtcbiAgICAgICAgICAgIGV2ZW50c1tnZXRTdGFuZGFydFVwZGF0ZUV2ZW50TmFtZSgpXSA9IG9uVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyKGV2ZW50cyk7XG4gICAgfSk7XG5cbiAgICBTaWRlTWVudVN0b3JlLnN1YnNjcmliZSgodmFsKSA9PiB7XG4gICAgICAgIGNsb3NlZCA9ICF2YWwub3BlbjtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9KTtcbjwvc2NyaXB0PlxuXG48YVxuICAgIGhyZWZcbiAgICBvbmNsaWNrPXt0b2dnbGV9XG4gICAgcm9sZT1cImJ1dHRvblwiXG4gICAgY2xhc3M9XCJuYXZiYXItYnVyZ2VyIHtjbG9zZWQgPyAnJyA6ICdpcy1hY3RpdmUnfVwiXG4gICAgYXJpYS1sYWJlbD1cIm1lbnVcIlxuICAgIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiXG4gICAgZGF0YS10YXJnZXQ9XCJuYXZiYXJcIlxuPlxuICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxuPC9hPlxuIiwiPCEtLSBAbWlncmF0aW9uLXRhc2sgRXJyb3Igd2hpbGUgbWlncmF0aW5nIFN2ZWx0ZSBjb2RlOiBDYW4ndCBtaWdyYXRlIGNvZGUgd2l0aCBiZWZvcmVVcGRhdGUuIFBsZWFzZSBtaWdyYXRlIGJ5IGhhbmQuIC0tPlxuPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwic3ZlbHRlXCI7XG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICAgIGltcG9ydCBTaWRlTWVudSBmcm9tIFwiLi4vc2lkZVwiO1xuXG4gICAgaW1wb3J0IFVJQnJhbmQgZnJvbSBcIi4vdWkuYnJhbmQuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IFVJTmF2YmFySXRlbSBmcm9tIFwiLi91aS5pdGVtLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBVSU5hdmJhclNlY3Rpb24gZnJvbSBcIi4vdWkuc2VjdGlvbi5zdmVsdGVcIjtcbiAgICBpbXBvcnQgVUlOYXZiYXJCdXJnZXIgZnJvbSBcIi4vdWkuYnVyZ2VyLnN2ZWx0ZVwiO1xuICAgIFxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUHJvcHNcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW3NlY3Rpb25zXSAtIGltcG9ydCB7IGJlZm9yZVVwZGF0ZSB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICAgKiBAcHJvcGVydHkge2FueX0gW2l0ZW1zXVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAgICAgKiBAcHJvcGVydHkge2FueX0gW25hdmlnYXRlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2JyYW5kXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Nob3dCdXJnZXJdXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYnVyZ2VyQ29udHJvbHNTaWRlbWVudV1cbiAgICAgKi9cblxuICAgIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gICAgbGV0IHtcbiAgICAgICAgc2VjdGlvbnMgPSBbXSxcbiAgICAgICAgaXRlbXMgPSBbXSxcbiAgICAgICAgcm9vdCA9IFwiXCIsXG4gICAgICAgIG5hdmlnYXRlID0gbnVsbCxcbiAgICAgICAgYnJhbmQgPSBmYWxzZSxcbiAgICAgICAgc2hvd0J1cmdlciA9IHRydWUsXG4gICAgICAgIGJ1cmdlckNvbnRyb2xzU2lkZW1lbnUgPSB0cnVlXG4gICAgfSA9ICRwcm9wcygpO1xuXG4gICAgbGV0IG1lbnVDbG9zZWQgPSAkc3RhdGUodHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKHsgZGV0YWlsIH0pIHtcbiAgICAgICAgbGV0IHsgZXZlbnQsIGVsZW1lbnQgfSA9IGRldGFpbDtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZWxlbWVudCwgXCJhY3Rpb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmFjdGlvbihldmVudCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZSh7XG4gICAgICAgICAgICAgICAgZnVsbDogZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLFxuICAgICAgICAgICAgICAgIHNob3J0OiBldmVudC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuaHJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgc2VjdGlvbnNJdGVtc0NvdW50ID0ge307XG4gICAgbGV0IHNlY3Rpb25zSXRlbXMgPSB7fTtcbiAgICAvKlxuICAgIGJlZm9yZVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zSXRlbXNbc2VjdGlvbi5pZF0gPSBpdGVtcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKHQpID0+IHQuc2VjdGlvbiA9PT0gc2VjdGlvbi5pZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlY3Rpb25zSXRlbXNDb3VudFtzZWN0aW9uLmlkXSA9IGl0ZW1zLmZpbHRlcihcbiAgICAgICAgICAgICAgICAodCkgPT4gdC5zZWN0aW9uID09PSBzZWN0aW9uLmlkXG4gICAgICAgICAgICApLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuKi9cbiAgICBmdW5jdGlvbiB0b2dnbGVCdXJnZXIoeyBkZXRhaWwgfSkge1xuICAgICAgICBpZiAoYnVyZ2VyQ29udHJvbHNTaWRlbWVudSkge1xuICAgICAgICAgICAgU2lkZU1lbnUudG9nZ2xlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwYXRjaChcInRvZ2dsZUJ1cmdlclwiLCBkZXRhaWwpO1xuICAgICAgICAgICAgbWVudUNsb3NlZCA9IGRldGFpbC5jbG9zZWQ7XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIm5hdmJhci1icmFuZFwiPlxuICAgIHsjaWYgYnJhbmR9XG4gICAgICAgIDxVSUJyYW5kIHsuLi5icmFuZH0gLz5cbiAgICB7L2lmfVxuICAgIHsjZWFjaCBzZWN0aW9ucyBhcyBzZWN0aW9uIChzZWN0aW9uLmlkKX1cbiAgICAgICAgeyNpZiBzZWN0aW9uLnNob3dPblRvdWNofVxuICAgICAgICAgICAgPFVJTmF2YmFySXRlbVxuICAgICAgICAgICAgICAgIGhpZGRlbj1cImRlc2t0b3BcIlxuICAgICAgICAgICAgICAgIGl0ZW09e3NlY3Rpb259XG4gICAgICAgICAgICAgICAge3Jvb3R9XG4gICAgICAgICAgICAgICAgb246Y2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICAvPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgICAgIHsjaWYgaXRlbS5zaG93T25Ub3VjaH1cbiAgICAgICAgICAgIDxVSU5hdmJhckl0ZW0gaGlkZGVuPVwiZGVza3RvcFwiIHtpdGVtfSB7cm9vdH0gb246Y2xpY2s9e29uQ2xpY2t9IC8+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuICAgIHsjaWYgc2hvd0J1cmdlcn1cbiAgICAgICAgPFVJTmF2YmFyQnVyZ2VyIG9uOnRvZ2dsZT17dG9nZ2xlQnVyZ2VyfSAvPlxuICAgIHsvaWZ9XG48L2Rpdj5cbjxkaXYgaWQ9XCJuYXZiYXJcIiBjbGFzcz1cIm5hdmJhci1tZW51IHttZW51Q2xvc2VkID8gJycgOiAnaXMtYWN0aXZlJ31cIj5cbiAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLXN0YXJ0XCI+XG4gICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtfVxuICAgICAgICAgICAgeyNpZiBpdGVtLnBsYWNlID09PSBcInN0YXJ0XCJ9XG4gICAgICAgICAgICAgICAgPFVJTmF2YmFySXRlbSBoaWRkZW49XCJ0b3VjaFwiIHtpdGVtfSBvbjpjbGljaz17b25DbGlja30gLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWVuZFwiPlxuICAgICAgICB7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbiAoc2VjdGlvbi5pZCl9XG4gICAgICAgICAgICB7I2lmIChzZWN0aW9uc0l0ZW1zQ291bnRbc2VjdGlvbi5pZF0gfHwgc2VjdGlvbi5pbmRpY2F0b3IgfHwgc2VjdGlvbi50YWcpICYmIHNlY3Rpb24ucGxhY2UgPT0gXCJlbmRcIn1cbiAgICAgICAgICAgICAgICA8VUlOYXZiYXJTZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0PXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICBoaWRkZW49e3NlY3Rpb24uaGlkZGVufVxuICAgICAgICAgICAgICAgICAgICB7cm9vdH1cbiAgICAgICAgICAgICAgICAgICAge3NlY3Rpb259XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zPXtzZWN0aW9uc0l0ZW1zW3NlY3Rpb24uaWRdfVxuICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17b25DbGlja31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgey9lYWNofVxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCJpbXBvcnQgTWVudSBmcm9tIFwiLi4vbWVudS5qc1wiO1xuaW1wb3J0IFVJTmF2YmFyVG9wIGZyb20gXCIuL3VpLnRvcC5zdmVsdGVcIjtcbmltcG9ydCB7IG1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5jb25zdCBUWVBFID0gXCJ0b3BcIjtcblxuY2xhc3Mgbm90VG9wTWVudSBleHRlbmRzIE1lbnUge1xuICAgIHN0YXRpYyBERUZBVUxUID0ge1xuICAgICAgICBzZWN0aW9uOiBcImFueVwiLFxuICAgICAgICBzZWN0aW9uVGl0bGU6IFwi0JzQtdC90Y5cIixcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIC8vbGluaywgYnV0dG9uLCBkcm9wZG93biwgY29tcG9uZW50XG4gICAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgICBwbGFjZTogXCJtYWluXCIsXG4gICAgfTtcblxuICAgIHN0YXRpYyBvcHRpb25zID0ge1xuICAgICAgICBicmFuZDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFRZUEUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc2VjdGlvbnM6IFtdLFxuICAgICAgICB0YXJnZXRTZWxlY3RvcjogYCMke1RZUEV9LW1lbnVgLFxuICAgICAgICByb290OiBcIi9cIixcbiAgICAgICAgZGlyZWN0TmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAgIG5hdmlnYXRlOiAodXJscykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXJlY3ROYXZpZ2F0aW9uKCkgJiYgdGhpcy5hcHApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuYXBwLmdldFdvcmtpbmcoXCJyb3V0ZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMubmF2aWdhdGUodXJscy5zaG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQubG9jYXRpb24uYXNzaWduKHVybHMuZnVsbCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHN0YXRpYyByZW5kZXIoYXBwKSB7XG4gICAgICAgIGlmIChhcHApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXBwKGFwcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlRGF0YSgpO1xuICAgICAgICBpZiAoIXRoaXMubWVudSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVudSA9IG1vdW50KFVJTmF2YmFyVG9wLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5kOiB0aGlzLmdldE9wdGlvbnMoKS5icmFuZCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25zOiB0aGlzLnNlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICByb290OiB0aGlzLmdldE9wdGlvbnMoKS5yb290LFxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZTogdGhpcy5nZXRPcHRpb25zKCkubmF2aWdhdGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudUFjdGl2ZUl0ZW0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAyMDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdXBkYXRlTWVudSh1cmwpIHtcbiAgICAgICAgQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3IgKyBcIiBhc2lkZS5tZW51IGFcIlxuICAgICAgICAgICAgKVxuICAgICAgICApLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpdGVtLmhyZWYgPT0gdXJsIHx8XG4gICAgICAgICAgICAgICAgKHVybC5ocmVmICYmIHVybC5ocmVmLmluZGV4T2YoaXRlbS5ocmVmKSA9PSAwKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKFwiaXMtYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJpcy1hY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cGRhdGVNZW51QWN0aXZlSXRlbSgpIHtcbiAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgbGFzdExvY2F0aW9uID0gdGhpcy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKGxhc3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKHVybCAhPT0gbGFzdExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnUodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1lbnUodXJsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB0b2dnbGUoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5nZXRPcHRpb25zKCkudGFyZ2V0U2VsZWN0b3IpO1xuICAgICAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKFwiaXMtYWN0aXZlXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBoaWRlKCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZ2V0T3B0aW9ucygpLnRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcImlzLWFjdGl2ZVwiKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0QnVyZ2VyU3RhdGUobWVudUNsb3NlZCkge1xuICAgICAgICB0aGlzLm1lbnUuJHNldCh7XG4gICAgICAgICAgICBtZW51Q2xvc2VkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vdFRvcE1lbnU7XG4iLCJjb25zdCBERUZBVUxUX1RSQVNGT1JNRVIgPSAocmVzKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBPYmplY3QuaGFzT3duKHJlcywgXCJzdGF0dXNcIikgJiYgT2JqZWN0Lmhhc093bihyZXMsIFwicmVzdWx0XCIpXG4gICAgICAgID8gcmVzLnJlc3VsdFxuICAgICAgICA6IHJlcztcbn07XG5cbmV4cG9ydCB7IERFRkFVTFRfVFJBU0ZPUk1FUiB9O1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBERUZBVUxUX1RSQVNGT1JNRVIgfSBmcm9tIFwiLi9jb25zdFwiO1xuZXhwb3J0IGRlZmF1bHQgKHsgQUNUSU9OLCBUSVRMRSwgVUlDb25zdHJ1Y3RvciwgZGF0YVByb3ZpZGVyLCBnb0JhY2sgfSkgPT4ge1xuICAgIHJldHVybiBjbGFzcyB7XG4gICAgICAgIHN0YXRpYyBhc3luYyBydW4oY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0QnJlYWRjcnVtYnMoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYNCf0YDQvtGB0LzQvtGC0YAgXCIke1RJVExFfVwiYCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnByZWxvYWRWYXJpYW50cyhBQ1RJT04pO1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnVpW0FDVElPTl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuJGRlc3Ryb3lVSSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmMoZGF0YVByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdENvbW1vbi5pc0FzeW5jKGRhdGFQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgZGF0YVByb3ZpZGVyKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhUHJvdmlkZXIocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IC4uLmRhdGFQcm92aWRlciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFRyYW5zZm9ybWVyID0gY29udHJvbGxlci5nZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICBgJHtBQ1RJT059LnRyYW5zZm9ybWVyYCxcbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9UUkFTRk9STUVSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnVpW0FDVElPTl0gPSBuZXcgVUlDb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHsgcGFyYW1zLCAuLi5yZXN1bHRUcmFuc2Zvcm1lcihkYXRhKSB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYWZ0ZXI6cmVuZGVyOiR7QUNUSU9OfWApO1xuICAgICAgICAgICAgICAgIGlmIChnb0JhY2sgJiYgbm90Q29tbW9uLmlzRnVuYyhnb0JhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXS5vbihcInJlamVjdFwiLCAoKSA9PiBnb0JhY2soKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbmNvbnN0IFBSRUxPQURBQkxFID0gW1wiY3JlYXRlXCIsIFwidXBkYXRlXCIsIFwibGlzdFwiLCBcImRlbGV0ZVwiLCBcImRldGFpbHNcIl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENSVURWYXJpYW50c1ByZWxvYWRlciB7XG4gICAgc3RhdGljIGFzeW5jIHByZWxvYWQoY29udHJvbGxlciwgdHlwZSA9IFwibGlzdFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIVBSRUxPQURBQkxFLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByZWxvYWQgPSBjb250cm9sbGVyLmdldE9wdGlvbnMoYCR7dHlwZX0ucHJlbG9hZGAsIHt9KTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwcmVsb2FkKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHByZWxvYWQgPSBjb250cm9sbGVyLmdldE9wdGlvbnMoYHByZWxvYWRgLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocHJlbG9hZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsaWJQcm9wcyA9IE9iamVjdC5rZXlzKHByZWxvYWQpO1xuICAgICAgICAgICAgICAgIGxldCBwcm9tcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxpYlByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGVsTmFtZSA9IG5vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKHByZWxvYWRbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgTW9kZWwgPSBjb250cm9sbGVyLm1ha2VbbW9kZWxOYW1lXSh7fSk7XG4gICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2goTW9kZWwuJGxpc3RBbGwoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9tcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaWJQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IGxpYlByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldLnN0YXR1cyA9PT0gXCJva1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHJlc3VsdHNbaV0ucmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNMaXN0ID0gcmVzdWx0c1tpXS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW50cyA9IHJlc3VsdHNMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRPcHRpb25zKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB2YXJpYW50cy4ke3R5cGV9LiR7cHJvcE5hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIubG9nKFwicHJlbG9hZCBmaW5pc2hlZFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJjb25zdCBERUZBVUxUX0FDVElPTiA9IFwibGlzdFwiO1xuXG5jbGFzcyBub3RDUlVEUm91dGVyIHtcbiAgICBzdGF0aWMgZXh0cmFjdEFjdGlvbk5hbWUoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIGxldCBhY3Rpb25OYW1lID0gREVGQVVMVF9BQ1RJT047XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zWzBdID09PSBcImNyZWF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IFwiY3JlYXRlXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuYWN0aW9uSGFuZGxlckV4aXN0cyhwYXJhbXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IHBhcmFtc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IFwiZGV0YWlsc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zWzFdID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZSA9IFwiZGVsZXRlXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtc1sxXSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUgPSBcInVwZGF0ZVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lID0gcGFyYW1zWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25OYW1lO1xuICAgIH1cblxuICAgIHN0YXRpYyByb3V0ZShjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSBub3RDUlVEUm91dGVyLmV4dHJhY3RBY3Rpb25OYW1lKFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udHJvbGxlci5zZXRDdXJyZW50QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucnVuQWN0aW9uKGFjdGlvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RDUlVEUm91dGVyO1xuIiwiaW1wb3J0IHsgVUlTdWNjZXNzLCBVSUVycm9yIH0gZnJvbSBcIi4uLy4uL2VsZW1lbnRzL25vdGlmaWNhdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDUlVETWVzc2FnZSB7XG4gICAgc3RhdGljIGVycm9yKGNvbnRyb2xsZXIsIHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VUkoXG4gICAgICAgICAgICBcIl9fbWVzc2FnZV9fXCIsXG4gICAgICAgICAgICBuZXcgVUlFcnJvcih7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7IHRpdGxlLCBtZXNzYWdlIH0sXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdWNjZXNzKGNvbnRyb2xsZXIsIHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VUkoXG4gICAgICAgICAgICBcIl9fbWVzc2FnZV9fXCIsXG4gICAgICAgICAgICBuZXcgVUlTdWNjZXNzKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHsgdGl0bGUsIG1lc3NhZ2UgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbm90TG9jYWxlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2xvY2FsZVwiO1xuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBub3RGb3JtIH0gZnJvbSBcIi4uLy4uLy4uL2NvbXBvbmVudHNcIjtcbmltcG9ydCB7IERFRkFVTFRfVFJBU0ZPUk1FUiB9IGZyb20gXCIuLi8uLi9jb25zdFwiO1xuaW1wb3J0IHsgTkFWSUdBVElPTl9ERUxBWV9ERUZBVUxUIH0gZnJvbSBcIi4uLy4uLy4uL2NvbnN0XCI7XG5pbXBvcnQgeyBtb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgREVGQVVMVF9CUkVBRENSVU1CX1RBSUwgPSBcItCf0YDQvtGB0LzQvtGC0YBcIjtcblxuLyoqXG4gKiBHZW5lcmljIENSVUQgYWN0aW9uIGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgQ1JVREdlbmVyaWNBY3Rpb24ge1xuICAgIHN0YXRpYyBnZXQgTkFWSUdBVElPTl9ERUxBWSgpIHtcbiAgICAgICAgcmV0dXJuIE5BVklHQVRJT05fREVMQVlfREVGQVVMVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBicmVhZGNydW1icyB0YWlsIHRlbXBsYXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBkZWFmdWx0QnJlYWRjcnVtYnNUYWlsKCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9CUkVBRENSVU1CX1RBSUw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGliYXJhcnkgb2YgYnJlYWRjcnVtYnMgdGFpbHMgc3RyaW5ncyB0ZW1wbGF0ZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgYnJlYWRjcnVtYnNUYWlscygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXNldDogREVGQVVMVF9CUkVBRENSVU1CX1RBSUwsXG4gICAgICAgICAgICBzZXQ6ICfQn9GA0L7RgdC80L7RgtGALCBcIns6dGl0bGV9XCInLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGVtcGxhdGUgb2YgYnJlYWRjcnVtYnMgdGFpbFxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgICB0ZW1wbGF0ZSBzdHJpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QnJlYWRjcnVtYnNUYWlsKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJyZWFkY3J1bWJzVGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RDb21tb24uc2VsZWN0KFxuICAgICAgICAgICAgdGhpcy5icmVhZGNydW1ic1RhaWxzLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRoaXMuZGVhZnVsdEJyZWFkY3J1bWJzVGFpbFxuICAgICAgICApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IEFDVElPTiB0aGlzIGNvbnRyb2xsZXIgYWN0aW9uIG5hbWUsIHVzZWQgaW4gVVJJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBBQ1RJT04oKSB7XG4gICAgICAgIHJldHVybiBcImRldGFpbHNcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT04gICAgbmV0d29yayBtb2RlbCBpbnRlcmZhY2UgYWN0aW9uIG5hbWUsIHVzZWQgaW4gQVBJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNT0RFTF9BQ1RJT05fR0VUKCkge1xuICAgICAgICByZXR1cm4gXCJnZXRcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTiAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9QVVQoKSB7XG4gICAgICAgIHJldHVybiBcImdldFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge29iamVjdH0gVUlDb25zdHJ1Y3RvciAgICBjb25zdHJ1Y3RvciBvZiBVSSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFVJQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBub3RGb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtmdW5jdGlvbn0gICBUUkFOU0ZPUk1FUiAgICAgcmVzcG9uc2UucmVzdWx0IHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIGlmIHdhbnQgdG8gY2hhbmdlIGl0J3Mgc3RydWN0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGdldCBUUkFOU0ZPUk1FUigpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfVFJBU0ZPUk1FUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYW1lIG9mIG1vZGVsIGlkZW50aWZpY2FpdG9uIGZpZWxkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIGRlZmF1bHQgaWQgZmllbGQgbmFtZSBpcyAnX2lkJ1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRJZEZpZWxkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0uaWRGaWVsZGAsIFwiX2lkXCIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2FkRGF0YVF1ZXJ5KGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBpZEZpZWxkID0gdGhpcy5nZXRJZEZpZWxkKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4geyBbaWRGaWVsZF06IHBhcmFtc1swXSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBQcm9taXNlIG9mIEFQSSByZXBvbnNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgYXJyYXkgb2Ygc3RyaW5ncyBwYXJzZWQgZnJvbSBVUkkgYnkgcm91dGVyIGFuZCBwYXNzZWQgdG8gY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSAgIEFQSSByZXNwb25zZSB7c3RhdHVzOnN0cmluZywgcmVzdWx0OmFueSwgbWVzc2FnZTpzdHJpbmcsIGVycm9yczoge1tmaWVsZG5hbWVdOlsuLi5lcnJvck1lc3NhZ2VzXX19XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxvYWREYXRhKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMubG9hZERhdGFRdWVyeShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gdGhpcy5nZXRNb2RlbEFjdGlvbk5hbWUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBhd2FpdCBjb250cm9sbGVyLmdldE1vZGVsKHF1ZXJ5KVtgJCR7YWN0aW9uTmFtZX1gXSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbW9kZWwgQVBJIGFjdGlvbiBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9ICAgIG5ldHdvcmsgaW50ZXJmYWNlIG1vZGVsIGFjdGlvbiBuYW1lLCBmb3IgQVBJOyBkZWZhdWx0OiB0aGlzLk1PREVMX0FDVElPTl9HRVRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TW9kZWxBY3Rpb25OYW1lKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgIGAke3RoaXMuQUNUSU9OfS5hY3Rpb25OYW1lYCxcbiAgICAgICAgICAgIHRoaXMuTU9ERUxfQUNUSU9OX0dFVFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYnJlYWRjcnVtYnMgdGFpbCwgd2l0aG91dCByZXN1bHQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIHByZXNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICBjb250cm9sbGVyLnNldEJyZWFkY3J1bWJzKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5nZXRCcmVhZGNydW1ic1RhaWwoXCJwcmVzZXRcIiksXG4gICAgICAgICAgICAgICAgdXJsOiBjb250cm9sbGVyLmdldE1vZGVsQWN0aW9uVVJMKHBhcmFtc1swXSwgZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFRpdGxlKGNvbnRvbGxlciwgcGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gY29udG9sbGVyLmdldEl0ZW1UaXRsZShyZXNwb25zZS5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYnJlYWRjcnVtYnMgdGFpbCB3aXRoIHJlc3BvbnNlIGRldGFpbHMsIGFrYSB0aXRsZSBvZiBsb2FkZWQgaXRlbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgICAgIEFQSSByZXNwb25zZSBpbiB3cmFwcGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlLnJlc3VsdCAgQVBJIHJlc3BvbnNlIHJlc3VsdFxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5nZXRUaXRsZShjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgYnJlYWRjcnVtYnNUYWlsVGVtcGxhdGUgPSB0aGlzLmdldEJyZWFkY3J1bWJzVGFpbChcInNldFwiKTtcbiAgICAgICAgY29udHJvbGxlci5zZXRCcmVhZGNydW1icyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGJyZWFkY3J1bWJzVGFpbFRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgID8gbm90TG9jYWxlLmZvcm1hdChicmVhZGNydW1ic1RhaWxUZW1wbGF0ZSwgeyB0aXRsZSB9KVxuICAgICAgICAgICAgICAgICAgICA6IHRpdGxlLFxuICAgICAgICAgICAgICAgIHVybDogY29udHJvbGxlci5nZXRNb2RlbEFjdGlvblVSTChwYXJhbXNbMF0sIGZhbHNlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyByZXNwb25zZSBvbiBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlLnN0YXR1c1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgIHRydWUgaWYgcmVzcG9uc2UgaXMgYmFkXG4gICAgICovXG4gICAgc3RhdGljIGlzUmVzcG9uc2VCYWQocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZSB8fCByZXNwb25zZS5zdGF0dXMgIT09IFwib2tcIjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VmFsaWRhdG9ycyhjb250cm9sbGVyKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY29udHJvbGxlci5nZXRWYWxpZGF0b3JzICYmIGNvbnRyb2xsZXIuZ2V0VmFsaWRhdG9ycygpKSB8fFxuICAgICAgICAgICAgY29udHJvbGxlci5nZXRPcHRpb25zKFwiVmFsaWRhdG9yc1wiKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JqZWN0IHdpdGggYWxsIG9wdGlvbnMgbmVlZGVkIHRvIGluaXRpYWxpemUgVUkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlICAgICBBUEkgcmVwb25zZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICB1aSBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBwcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHNBY3Rpb25OYW1lID0gdGhpcy5nZXRNb2RlbEFjdGlvbk5hbWUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBjb250cm9sbGVyLmdldE1vZGVsTmFtZSgpLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogZGV0YWlsc0FjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZTogYCR7Y29udHJvbGxlci5nZXROYW1lKCl9LiR7dGhpcy5BQ1RJT059Rm9ybWAsXG4gICAgICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogdGhpcy5nZXRWYWxpZGF0b3JzKGNvbnRyb2xsZXIpLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBjb250cm9sbGVyLmdldE9wdGlvbnMoYHZhcmlhbnRzLiR7dGhpcy5BQ1RJT059YCwge30pLFxuICAgICAgICAgICAgICAgIG1hc3RlcnM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0ubWFzdGVyc2AsIHt9KSxcbiAgICAgICAgICAgICAgICBpbmplY3RlZDogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5pbmplY3RlZGAsIHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLlRSQU5TRk9STUVSKHJlc3BvbnNlLnJlc3VsdCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGlzIGFjdGlvbiBVSSBjb21wb25lbnQgZnJvbSBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gICAgaW5zdGFuY2Ugb2YgVUkgY29tcG9uZW50XG4gICAgICovXG4gICAgc3RhdGljIGdldFVJKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZ2V0VUkodGhpcy5BQ1RJT04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgVUkgb2YgdGhpcyBhY3Rpb24gaW4gY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1aSAgICAgICAgICAgaW5zdGFuY2Ugb2YgVUkgY29tcG9uZW50XG4gICAgICovXG4gICAgc3RhdGljIHNldFVJKGNvbnRyb2xsZXIsIHVpKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VUkodGhpcy5BQ1RJT04sIHVpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2V0cyB2aWEgYC4kc2V0YCBtZXRob2QgYGxvYWRpbmdgIHRvIGB0cnVlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9jb250cm9sbGVyLmNydWQnKX0gY29udHJvbGxlclxuICAgICAqIEBtZW1iZXJvZiBDUlVER2VuZXJpY0FjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRVSUxvYWRpbmcoY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmdldFVJKGNvbnRyb2xsZXIpLiRzZXQoeyBsb2FkaW5nOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIHZpYSBgLiRzZXRgIG1ldGhvZCBgbG9hZGluZ2AgdG8gYGZhbHNlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9jb250cm9sbGVyLmNydWQnKX0gY29udHJvbGxlclxuICAgICAqIEBtZW1iZXJvZiBDUlVER2VuZXJpY0FjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRVSUxvYWRlZChjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0VUkoY29udHJvbGxlcikuJHNldCh7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZXRzIHZpYSBgLiRzZXRgIG1ldGhvZCBgZXJyb3JgIHRvIGBtZXNzYWdlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9jb250cm9sbGVyLmNydWQnKX0gY29udHJvbGxlclxuICAgICAqIEBwYXJhbSAgIHtFcnJvcn0gbWVzc2FnZSAgICAgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBtZW1iZXJvZiBDUlVER2VuZXJpY0FjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRVSUVycm9yKGNvbnRyb2xsZXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5nZXRVSShjb250cm9sbGVyKS4kc2V0KHsgZXJyb3I6IG1lc3NhZ2UgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgZXZlbnRzIHRvIGFjdGlvbiBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgICAgIEFQSSByZXNwb25zZVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBiaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhjb250cm9sbGVyLmdvQmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnQoY29udHJvbGxlciwgXCJyZWplY3RcIiwgKCkgPT4gY29udHJvbGxlci5nb0JhY2soKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIGV2ZW50IGhhbmRsZXIgbmFtZWQgZXZlbnQgdG8gVUkuIENoZWNrcyBkaWZmZXJlbnQgYmluZGVyIG5vdGF0aW9uICRvbi9vblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAgICAgICAgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICAgY2FsbGJhY2sgZnVuY3Rpb24gb24gZXZlbnRcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBiaW5kVUlFdmVudChjb250cm9sbGVyLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdWkgPSB0aGlzLmdldFVJKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAodWkuJG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdWkuJG9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpLm9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdWkub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRydWUsIGlmIFVJIG9mIHRoaXMgYWN0aW9uIGFscmVhZHkgZXhpc3RzLFxuICAgICAqIGZhbHNlLCBpZiBVSSBvZiB0aGlzIGFjdGlvbiB3YXNuJ3QgZXhpc3RlZCBhbmQgb3RoZXIgVUlzIHdlcmUgZGVzdG9yeWVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgdHJ1ZSBpZiBVSSBvZiB0aGlzIGFjdGlvbiBleGlzdHMsIGZhbHNlIGlmIFVJIG9mIG90aGVyIHdhcyBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNVSVJlbmRlcmVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VUkoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRpYyB0d2Vha1VJT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVVSSh1aUNvbXBvbmVudCwgY29udHJvbGxlciwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKG5vdENvbW1vbi5pc0Z1bmModWlDb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW91bnQoXG4gICAgICAgICAgICAgICAgdWlDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgdGhpcy50d2Vha1VJT3B0aW9ucyh0aGlzLnByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdWlDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgdGhpcy50d2Vha1VJT3B0aW9ucyh0aGlzLnByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1pbmcgYWN0aW9uIHByZXBhcmF0aW9uIGFuZCByZW5kZXJzIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHN0YXJ0aW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGJlZm9yZTpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9pZiBVSSBmb3IgdGhpcyBhY3Rpb24gZXhpc3RzIGV4aXRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVUlSZW5kZXJlZChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaW5kaWNhdGluZyB0aGF0IHdlIGFyZSB3b3JraW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgICAgICAvL3ByZWxvYWRpbmcgZm9ybSB2YXJpYW50c1xuICAgICAgICAgICAgYXdhaXQgY29udHJvbGxlci5wcmVsb2FkVmFyaWFudHModGhpcy5BQ1RJT04pO1xuICAgICAgICAgICAgLy9zZXR0aW5nIGluaXRpYWwgc3RhdGUgb2YgYnJlYWRjcnVtYnMgdGFpbFxuICAgICAgICAgICAgdGhpcy5wcmVzZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9sb2FkaW5nIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5sb2FkRGF0YShjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2UgaWYgcmVzcG9uc2UgaXMgJ2JhZCdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVzcG9uc2VCYWQocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0aW5nIGJyZWFkY3J1bWJzIHRhaWwgd2l0aCBtb3JlIGRldGFpbHMgZnJvbSByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5zZXRCcmVhZGNydW1icyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vY3JlYXRpbmcgYWN0aW9uIFVJIGNvbXBvbmVudFxuICAgICAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGNvbnN0IHVpQ29tcG9uZW50ID0gdGhpcy5VSUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGNvbnN0IHVpID0gdGhpcy5jcmVhdGVVSSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRVSShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIC8vYmluZCBldmVudHMgdG8gVUlcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnRzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9pbmZvcm0gdGhhdCB3ZSBhcmUgcmVhZHlcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgYWZ0ZXI6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaW5mb3JtaW5nIGFib3V0IGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBleGNlcHRpb246cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zLCBlKTtcbiAgICAgICAgICAgIC8vcmVwb3J0aW5nIGV4Y2VwdGlvblxuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdvQmFja0FmdGVyRGVsYXkoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmdvQmFjayh0aGlzLk5BVklHQVRJT05fREVMQVkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnb0JhY2soY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmdvQmFjaygwKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENSVURHZW5lcmljQWN0aW9uO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uIGZyb20gXCIuL2FjdGlvblwiO1xuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5jb25zdCBBQ1RJT04gPSBcImNyZWF0ZVwiO1xuY29uc3QgREVGQVVMVF9CUkVBRENSVU1CX1RBSUwgPSBcItCh0L7Qt9C00LDQvdC40LVcIjtcblxuY2xhc3MgQ1JVREdlbmVyaWNBY3Rpb25DcmVhdGUgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvbiB7XG4gICAgc3RhdGljIGdldCBkZWFmdWx0QnJlYWRjcnVtYnNUYWlsKCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9CUkVBRENSVU1CX1RBSUw7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBicmVhZGNydW1ic1RhaWxzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgQUNUSU9OKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IE1PREVMX0FDVElPTiAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9HRVQoKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpYyB7c3RyaW5nfSBNT0RFTF9BQ1RJT04gICAgbmV0d29yayBtb2RlbCBpbnRlcmZhY2UgYWN0aW9uIG5hbWUsIHVzZWQgaW4gQVBJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNT0RFTF9BQ1RJT05fUFVUKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL2NvbnRyb2xsZXIuY3J1ZCcpfSBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHthbnl9ICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbXNdXG4gICAgICogQHJldHVybnMge2ltcG9ydCgnbm90LW5vZGUvc3JjL3R5cGVzJykubm90QXBwUmVzcG9uc2V9XG4gICAgICovXG4gICAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBzdGF0aWMgbG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGRlZkRhdGEgPSBjb250cm9sbGVyLmNyZWF0ZURlZmF1bHQoKTtcbiAgICAgICAgaWYgKGRlZkRhdGEuZ2V0RGF0YSkge1xuICAgICAgICAgICAgZGVmRGF0YSA9IGRlZkRhdGEuZ2V0RGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IFwib2tcIixcbiAgICAgICAgICAgIHJlc3VsdDogZGVmRGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VGl0bGUoY29udG9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBjb250b2xsZXIuZ2V0SXRlbVRpdGxlKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gdGhpcy5nZXRNb2RlbEFjdGlvbk5hbWUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBjb250cm9sbGVyLmdldE1vZGVsTmFtZSgpLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBgJHtjb250cm9sbGVyLmdldE5hbWUoKX0uJHt0aGlzLkFDVElPTn1Gb3JtYCxcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JzOiB0aGlzLmdldFZhbGlkYXRvcnMoY29udHJvbGxlciksXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgdmFyaWFudHMuJHt0aGlzLkFDVElPTn1gLCB7fSksXG4gICAgICAgICAgICAgICAgbWFzdGVyczogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS5tYXN0ZXJzYCwge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuVFJBTlNGT1JNRVIocmVzcG9uc2UpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGV2ZW50cyB0byBhY3Rpb24gVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtyZXNwb25zZV0gICAgIEFQSSByZXNwb25zZVxuICAgICAqL1xuICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgc3RhdGljIGJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIuZ29CYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInJlamVjdFwiLCAoKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuZ29CYWNrKGNvbnRyb2xsZXIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RDb21tb24uaXNGdW5jKGNvbnRyb2xsZXIub25BY3Rpb25TdWJtaXQpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50KGNvbnRyb2xsZXIsIFwic3VibWl0XCIsIGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KHRoaXMuQUNUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMubG9hZERhdGFRdWVyeShjb250cm9sbGVyLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi5ldi5kZXRhaWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nb0JhY2tBZnRlckRlbGF5KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZTtcbiIsImltcG9ydCBDUlVER2VuZXJpY0FjdGlvbkNyZWF0ZSBmcm9tIFwiLi9nZW5lcmljL2NyZWF0ZVwiO1xuXG5jbGFzcyBDUlVEQWN0aW9uQ3JlYXRlIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb25DcmVhdGUge31cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREFjdGlvbkNyZWF0ZTtcbiIsImltcG9ydCBDUlVER2VuZXJpY0FjdGlvbiBmcm9tIFwiLi9hY3Rpb25cIjtcblxuLyoqXG4gKiBHZW5lcmljIENSVUQgRGV0YWlscyBhY3Rpb24gY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBDUlVER2VuZXJpY0FjdGlvblJlYWQgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvbiB7XG4gICAgc3RhdGljIHR3ZWFrVUlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5vcHRpb25zLnVpID0ge1xuICAgICAgICAgICAgc3VibWl0OiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtaW5nIGFjdGlvbiBwcmVwYXJhdGlvbiBhbmQgcmVuZGVycyBVSVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2YgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcyAgICAgbGlzdCBvZiByb3V0ZSBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmRlZmluZWQ+fVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBydW4oY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSBzdGFydGluZ1xuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBiZWZvcmU6cmVuZGVyOiR7dGhpcy5BQ1RJT059YCwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vaWYgVUkgZm9yIHRoaXMgYWN0aW9uIGV4aXN0cyBleGl0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc1VJUmVuZGVyZWQoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2luZGljYXRpbmcgdGhhdCB3ZSBhcmUgd29ya2luZ1xuICAgICAgICAgICAgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuICYmIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbigpO1xuICAgICAgICAgICAgLy9wcmVsb2FkaW5nIGZvcm0gdmFyaWFudHNcbiAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKHRoaXMuQUNUSU9OKTtcbiAgICAgICAgICAgIC8vc2V0dGluZyBpbml0aWFsIHN0YXRlIG9mIGJyZWFkY3J1bWJzIHRhaWxcbiAgICAgICAgICAgIHRoaXMucHJlc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vbG9hZGluZyBkYXRhXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMubG9hZERhdGEoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIC8vc2hvd2luZyBlcnJvciBtZXNzYWdlIGlmIHJlc3BvbnNlIGlzICdiYWQnXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jlc3BvbnNlQmFkKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cGRhdGluZyBicmVhZGNydW1icyB0YWlsIHdpdGggbW9yZSBkZXRhaWxzIGZyb20gcmVzcG9uc2VcbiAgICAgICAgICAgIHRoaXMuc2V0QnJlYWRjcnVtYnMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2NyZWF0aW5nIGFjdGlvbiBVSSBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbnN0IHVpQ29tcG9uZW50ID0gdGhpcy5VSUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy5zZXRVSShcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICAgICAgICAgIG5ldyB1aUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50d2Vha1VJT3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZVVJT3B0aW9ucyhjb250cm9sbGVyLCByZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL2JpbmQgZXZlbnRzIHRvIFVJXG4gICAgICAgICAgICB0aGlzLmJpbmRVSUV2ZW50cyhjb250cm9sbGVyLCBwYXJhbXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHJlYWR5XG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGFmdGVyOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvL2luZm9ybWluZyBhYm91dCBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgZXhjZXB0aW9uOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcywgZSk7XG4gICAgICAgICAgICAvL3JlcG9ydGluZyBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREdlbmVyaWNBY3Rpb25SZWFkO1xuIiwiaW1wb3J0IENSVURHZW5lcmljQWN0aW9uUmVhZCBmcm9tIFwiLi9nZW5lcmljL3JlYWRcIjtcblxuLyoqXG4gKiBDUlVEIGFjdGlvbiBkZXRhaWxzXG4gKi9cbmNsYXNzIENSVURBY3Rpb25EZXRhaWxzIGV4dGVuZHMgQ1JVREdlbmVyaWNBY3Rpb25SZWFkIHt9XG5cbmV4cG9ydCBkZWZhdWx0IENSVURBY3Rpb25EZXRhaWxzO1xuIiwiaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi4vLi4vLi4vY29tbW9uXCI7XG5pbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb24gZnJvbSBcIi4vYWN0aW9uXCI7XG5cbmNvbnN0IERFRkFVTFRfQlJFQURDUlVNQl9UQUlMID0gXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0L3QuNC1XCI7XG4vKipcbiAqIEdlbmVyaWMgQ1JVRCBVcGRhdGUgYWN0aW9uIGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGUgZXh0ZW5kcyBDUlVER2VuZXJpY0FjdGlvbiB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBicmVhZGNydW1icyB0YWlsIHRlbXBsYXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBkZWFmdWx0QnJlYWRjcnVtYnNUYWlsKCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9CUkVBRENSVU1CX1RBSUw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGliYXJhcnkgb2YgYnJlYWRjcnVtYnMgdGFpbHMgc3RyaW5ncyB0ZW1wbGF0ZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgYnJlYWRjcnVtYnNUYWlscygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXNldDogREVGQVVMVF9CUkVBRENSVU1CX1RBSUwsXG4gICAgICAgICAgICBzZXQ6IGAke0RFRkFVTFRfQlJFQURDUlVNQl9UQUlMfTogXCJ7OnRpdGxlfVwiYCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljIHtzdHJpbmd9IEFDVElPTiB0aGlzIGNvbnRyb2xsZXIgYWN0aW9uIG5hbWUsIHVzZWQgaW4gVVJJXG4gICAgICovXG4gICAgc3RhdGljIGdldCBBQ1RJT04oKSB7XG4gICAgICAgIHJldHVybiBcInVwZGF0ZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OX0dFVCAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9HRVQoKSB7XG4gICAgICAgIHJldHVybiBcImdldFJhd1wiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWMge3N0cmluZ30gTU9ERUxfQUNUSU9OX1BVVCAgICBuZXR3b3JrIG1vZGVsIGludGVyZmFjZSBhY3Rpb24gbmFtZSwgdXNlZCBpbiBBUElcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE1PREVMX0FDVElPTl9QVVQoKSB7XG4gICAgICAgIHJldHVybiBcInVwZGF0ZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb2JqZWN0IHdpdGggYWxsIG9wdGlvbnMgbmVlZGVkIHRvIGluaXRpYWxpemUgVUkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlICAgICBBUEkgcmVwb25zZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAgICB1aSBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBwcmVwYXJlVUlPcHRpb25zKGNvbnRyb2xsZXIsIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBjb250cm9sbGVyLmdldENvbnRhaW5lcklubmVyRWxlbWVudCgpLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBjb250cm9sbGVyLmdldE1vZGVsTmFtZSgpLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5NT0RFTF9BQ1RJT05fUFVULCAvL3dpbGwgYmUgdXNlZCB0byBnZXQgZm9ybSBmaWVsZHMgaW5mb3JtYXRpb24gZnJvbSBtYW5pZmVzdFxuICAgICAgICAgICAgICAgIG5hbWU6IGAke2NvbnRyb2xsZXIuZ2V0TmFtZSgpfS4ke3RoaXMuQUNUSU9OfUZvcm1gLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcnM6IHRoaXMuZ2V0VmFsaWRhdG9ycyhjb250cm9sbGVyKSxcbiAgICAgICAgICAgICAgICB2YXJpYW50czogY29udHJvbGxlci5nZXRPcHRpb25zKGB2YXJpYW50cy4ke3RoaXMuQUNUSU9OfWAsIHt9KSxcbiAgICAgICAgICAgICAgICB1aTogY29udHJvbGxlci5nZXRPcHRpb25zKGAke3RoaXMuQUNUSU9OfS51aWAsIHt9KSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0uZmllbGRzYCwge30pLFxuICAgICAgICAgICAgICAgIG1hc3RlcnM6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHt0aGlzLkFDVElPTn0ubWFzdGVyc2AsIHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiB0aGlzLlRSQU5TRk9STUVSKG5vdENvbW1vbi5zdHJpcFByb3h5KHJlc3BvbnNlLnJlc3VsdCkpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGV2ZW50cyB0byBhY3Rpb24gVUlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29udHJvbGxlciAgIGluc3RhbmNlIG9mIGNvbnRyb2xsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMgICAgIGxpc3Qgb2Ygcm91dGUgcGFyYW1zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtyZXNwb25zZV0gICAgIEFQSSByZXNwb25zZVxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBiaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSkge1xuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhjb250cm9sbGVyLmdvQmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFVJRXZlbnQoY29udHJvbGxlciwgXCJyZWplY3RcIiwgKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmdvQmFjayhjb250cm9sbGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90Q29tbW9uLmlzRnVuYyhjb250cm9sbGVyLm9uQWN0aW9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudChjb250cm9sbGVyLCBcInN1Ym1pdFwiLCBhc3luYyAoZXYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgY29udHJvbGxlci5vbkFjdGlvblN1Ym1pdCh0aGlzLkFDVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmxvYWREYXRhUXVlcnkoY29udHJvbGxlciwgcGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZXYuZGV0YWlsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ29CYWNrQWZ0ZXJEZWxheShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRydWUsIGlmIFVJIG9mIHRoaXMgYWN0aW9uIGFscmVhZHkgZXhpc3RzLFxuICAgICAqIGZhbHNlLCBpZiBVSSBvZiB0aGlzIGFjdGlvbiB3YXNuJ3QgZXhpc3RlZCBhbmQgb3RoZXIgVUlzIHdlcmUgZGVzdG9yeWVkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICAgdHJ1ZSBpZiBVSSBvZiB0aGlzIGFjdGlvbiBleGlzdHMsIGZhbHNlIGlmIFVJIG9mIG90aGVyIHdhcyBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNVSVJlbmRlcmVkKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VUkoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1pbmcgYWN0aW9uIHByZXBhcmF0aW9uIGFuZCByZW5kZXJzIFVJXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zICAgICBsaXN0IG9mIHJvdXRlIHBhcmFtc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vaW5mb3JtIHRoYXQgd2UgYXJlIHN0YXJ0aW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLmVtaXQoYGJlZm9yZTpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBbcGFyYW1zXSk7XG4gICAgICAgICAgICAvL2lmIFVJIGZvciB0aGlzIGFjdGlvbiBleGlzdHMgZXhpdGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVSVJlbmRlcmVkKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9pbmRpY2F0aW5nIHRoYXQgd2UgYXJlIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVuZGVyTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgICAgIC8vcHJlbG9hZGluZyBmb3JtIHZhcmlhbnRzXG4gICAgICAgICAgICBhd2FpdCBjb250cm9sbGVyLnByZWxvYWRWYXJpYW50cyh0aGlzLkFDVElPTik7XG4gICAgICAgICAgICAvL3NldHRpbmcgaW5pdGlhbCBzdGF0ZSBvZiBicmVhZGNydW1icyB0YWlsXG4gICAgICAgICAgICB0aGlzLnByZXNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL2xvYWRpbmcgZGF0YVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmxvYWREYXRhKGNvbnRyb2xsZXIsIHBhcmFtcyk7XG4gICAgICAgICAgICAvL3Nob3dpbmcgZXJyb3IgbWVzc2FnZSBpZiByZXNwb25zZSBpcyAnYmFkJ1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXNwb25zZUJhZChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRpbmcgYnJlYWRjcnVtYnMgdGFpbCB3aXRoIG1vcmUgZGV0YWlscyBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICB0aGlzLnNldEJyZWFkY3J1bWJzKGNvbnRyb2xsZXIsIHBhcmFtcywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgLy9jcmVhdGluZyBhY3Rpb24gVUkgY29tcG9uZW50XG4gICAgICAgICAgICBjb25zdCB1aUNvbXBvbmVudCA9IHRoaXMuVUlDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHRoaXMuc2V0VUkoXG4gICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICBuZXcgdWlDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHdlYWtVSU9wdGlvbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVVSU9wdGlvbnMoY29udHJvbGxlciwgcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy9iaW5kIGV2ZW50cyB0byBVSVxuICAgICAgICAgICAgdGhpcy5iaW5kVUlFdmVudHMoY29udHJvbGxlciwgcGFyYW1zLCByZXNwb25zZSk7XG4gICAgICAgICAgICAvL2luZm9ybSB0aGF0IHdlIGFyZSByZWFkeVxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KGBhZnRlcjpyZW5kZXI6JHt0aGlzLkFDVElPTn1gLCBwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvL2luZm9ybWluZyBhYm91dCBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgZXhjZXB0aW9uOnJlbmRlcjoke3RoaXMuQUNUSU9OfWAsIHBhcmFtcywgZSk7XG4gICAgICAgICAgICAvL3JlcG9ydGluZyBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgLy9zaG93aW5nIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlTG9hZGluZ1NjcmVlbiAmJiBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGU7XG4iLCJpbXBvcnQgQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGUgZnJvbSBcIi4vZ2VuZXJpYy91cGRhdGVcIjtcblxuLyoqXG4gKiBDUlVEIGFjdGlvbiB1cGRhdGVcbiAqL1xuY2xhc3MgQ1JVREFjdGlvblVwZGF0ZSBleHRlbmRzIENSVURHZW5lcmljQWN0aW9uVXBkYXRlIHt9XG5cbmV4cG9ydCBkZWZhdWx0IENSVURBY3Rpb25VcGRhdGU7XG4iLCJpbXBvcnQgbm90QWN0aW9uVUkgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvYWN0aW9uL2FjdGlvbi51aS5qc1wiO1xuXG5jb25zdCBBQ1RJT04gPSBcImRlbGV0ZVwiO1xuY29uc3QgTU9ERUxfQUNUSU9OID0gXCJkZWxldGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1JVREFjdGlvbkRlbGV0ZSB7XG4gICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnVpW0FDVElPTl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuJGRlc3Ryb3lVSSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250cm9sbGVyLnVpW0FDVElPTl0gPSBuZXcgbm90QWN0aW9uVUkoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ1JVRERlbGV0ZVwiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogY29udHJvbGxlci5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlckFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVyU3R5bGU6IFwiY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlclRpdGxlOiBcIm5vdC1ub2RlOmNydWRfZGVsZXRlX2FjdGlvbl93YWl0aW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGBjcnVkLWRlbGV0ZS1hY3Rpb24tJHtwYXJhbXNbMF19YCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0QnJlYWRjcnVtYnMoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwi0KPQtNCw0LvQtdC90LjQtVwiLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbnRyb2xsZXIuZ2V0TW9kZWxBY3Rpb25VUkwocGFyYW1zWzBdLCBBQ1RJT04pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpcm0oXCLQo9C00LDQu9C40YLRjCDQt9Cw0L/QuNGB0Yw/XCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlQWN0aW9uTmFtZSA9IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhcbiAgICAgICAgICAgICAgICAgICAgYCR7QUNUSU9OfS5hY3Rpb25OYW1lYCxcbiAgICAgICAgICAgICAgICAgICAgTU9ERUxfQUNUSU9OXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgY29udHJvbGxlci5vbkFjdGlvblN1Ym1pdChcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBwYXJhbXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZ29MaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZ29MaXN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbm90VGFibGUgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50c1wiO1xuXG5jb25zdCBBQ1RJT04gPSBcImxpc3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1JVREFjdGlvbkxpc3Qge1xuICAgIHN0YXRpYyB0d2Vha0FjdGlvbnNMaXN0KGNvbnRyb2xsZXIsIEFDVElPTlNfTElTVCkge1xuICAgICAgICBpZiAoY29udHJvbGxlci5nZXRPcHRpb25zKGAke0FDVElPTn0uY3JlYXRlQWN0aW9uYCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIEFDVElPTlNfTElTVC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCLQodC+0LfQtNCw0YLRjFwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4gY29udHJvbGxlci5nb0NyZWF0ZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFDVElPTlNfTElTVDtcbiAgICB9XG5cbiAgICBzdGF0aWMgdHdlYWtVSU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9jb250cm9sbGVyLmNydWQnKS5kZWZhdWx0fSBjb250cm9sbGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2FjdGlvbnM9W1wiZGV0YWlsc1wiLCBcInVwZGF0ZVwiLCBcImRlbGV0ZVwiXV1cbiAgICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IFtwcmVwZW5kPVtdXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gW2FwcGVuZD1bXV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmx5SWNvbnM9dHJ1ZV1cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fVxuICAgICAqIEBtZW1iZXJvZiBDUlVEQWN0aW9uTGlzdFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBY3Rpb25zQnV0dG9ucyhcbiAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgYWN0aW9ucyA9IFtcImRldGFpbHNcIiwgXCJ1cGRhdGVcIiwgXCJkZWxldGVcIl0sXG4gICAgICAgIHByZXBlbmQgPSBbXSxcbiAgICAgICAgYXBwZW5kID0gW10sXG4gICAgICAgIG9ubHlJY29ucyA9IHRydWVcbiAgICApIHtcbiAgICAgICAgY29uc3QgQUNUSU9OUyA9IHtcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IGNvbnRyb2xsZXIuZ29EZXRhaWxzKHZhbHVlLCBkZWxheSksXG4gICAgICAgICAgICAgICAgLi4uKG9ubHlJY29uc1xuICAgICAgICAgICAgICAgICAgICA/IHsgaWNvbjogXCJjaXJjbGUtaW5mb1wiIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IHRpdGxlOiBcItCf0L7QtNGA0L7QsdC90LXQtVwiIH0pLFxuICAgICAgICAgICAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IGNvbnRyb2xsZXIuZ29VcGRhdGUodmFsdWUsIGRlbGF5KSxcbiAgICAgICAgICAgICAgICAuLi4ob25seUljb25zID8geyBpY29uOiBcImVkaXRcIiB9IDogeyB0aXRsZTogXCLQmNC30LzQtdC90LjRgtGMXCIgfSksXG4gICAgICAgICAgICAgICAgY29sb3I6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgICAgIHNpemU6IFwic21hbGxcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGU6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IGNvbnRyb2xsZXIuZ29EZWxldGUodmFsdWUsIGRlbGF5KSxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJkYW5nZXJcIixcbiAgICAgICAgICAgICAgICAuLi4ob25seUljb25zID8geyBpY29uOiBcInRyYXNoXCIgfSA6IHsgdGl0bGU6IFwi0KPQtNCw0LvQuNGC0YxcIiB9KSxcbiAgICAgICAgICAgICAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwib3V0bGluZWRcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdGlvbnNCdXR0b25zID0gWy4uLnByZXBlbmRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhY3Rpb25zKSkge1xuICAgICAgICAgICAgYWN0aW9ucy5mb3JFYWNoKChhY3Rpb25OYW1lKSA9PlxuICAgICAgICAgICAgICAgIGFjdGlvbnNCdXR0b25zLnB1c2goQUNUSU9OU1thY3Rpb25OYW1lXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9uc0J1dHRvbnMucHVzaCguLi5hcHBlbmQpO1xuICAgICAgICByZXR1cm4gYWN0aW9uc0J1dHRvbnM7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIHJ1bihjb250cm9sbGVyLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vaW5kaWNhdGluZyB0aGF0IHdlIGFyZSB3b3JraW5nXG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbmRlckxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW5kZXJMb2FkaW5nU2NyZWVuKCk7XG5cbiAgICAgICAgICAgIGF3YWl0IGNvbnRyb2xsZXIucHJlbG9hZFZhcmlhbnRzKEFDVElPTik7XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2V0QnJlYWRjcnVtYnMoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwi0KHQv9C40YHQvtC6XCIsXG4gICAgICAgICAgICAgICAgICAgIHVybDogY29udHJvbGxlci5nZXRNb2RlbFVSTCgpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIudWlbQUNUSU9OXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci4kZGVzdHJveVVJKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIudWlbQUNUSU9OXSA9IG5ldyBub3RUYWJsZShcbiAgICAgICAgICAgICAgICB0aGlzLnR3ZWFrVUlPcHRpb25zKENSVURBY3Rpb25MaXN0LnByZXBhcmVPcHRpb25zKGNvbnRyb2xsZXIpKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29udHJvbGxlci5lbWl0KFxuICAgICAgICAgICAgICAgIGBhZnRlcjpyZW5kZXI6JHtBQ1RJT059YCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci51aVtBQ1RJT05dXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvL2luZm9ybWluZyBhYm91dCBleGNlcHRpb25cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW1pdChgZXhjZXB0aW9uOnJlbmRlcjoke0FDVElPTn1gLCBwYXJhbXMsIGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5yZXBvcnQoZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLnNob3dFcnJvck1lc3NhZ2UoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZUxvYWRpbmdTY3JlZW4gJiYgY29udHJvbGxlci5yZW1vdmVMb2FkaW5nU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlcGFyZU9wdGlvbnMoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBERUZBVUxUX09QVElPTlNfVEFCTEUgPSB7XG4gICAgICAgICAgICBpbnRlcmZhY2U6IGNvbnRyb2xsZXIuZ2V0T3B0aW9ucyhgJHtBQ1RJT059LmludGVyZmFjZWAsIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmYWN0b3J5OiBjb250cm9sbGVyLmdldEludGVyZmFjZSgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBmaWVsZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNob3dTZWxlY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGdldEl0ZW1JZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWRGaWVsZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcHJlbG9hZDoge30sXG4gICAgICAgICAgICBmaWx0ZXJVSTogY29udHJvbGxlci5nZXRPcHRpb25zKGAke0FDVElPTn0uZmlsdGVyVUlgKSxcbiAgICAgICAgICAgIHBhZ2VyOiB7IHNpemU6IDUwLCBwYWdlOiAwIH0sXG4gICAgICAgICAgICBzb3J0ZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogLTEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1aTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICAvL2Zvcm1pbmcgYWN0aW9ucyBidXR0b25zIGxpc3RcbiAgICAgICAgbGV0IEFDVElPTlNfTElTVCA9IFsuLi5jb250cm9sbGVyLmdldE9wdGlvbnMoYCR7QUNUSU9OfS5hY3Rpb25zYCwgW10pXTtcbiAgICAgICAgQUNUSU9OU19MSVNUID0gdGhpcy50d2Vha0FjdGlvbnNMaXN0KGNvbnRyb2xsZXIsIEFDVElPTlNfTElTVCk7XG4gICAgICAgIC8vXG4gICAgICAgIGNvbnN0IFRBQkxFX09QVElPTlMgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGNvbnRyb2xsZXIuZ2V0Q29udGFpbmVySW5uZXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgZW5kbGVzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogQUNUSU9OU19MSVNULFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMoREVGQVVMVF9PUFRJT05TX1RBQkxFKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGxldCBvcHRWYWwgPSBjb250cm9sbGVyLmdldE9wdGlvbnMoXG4gICAgICAgICAgICAgICAgYCR7QUNUSU9OfS4ke2tleX1gLFxuICAgICAgICAgICAgICAgIERFRkFVTFRfT1BUSU9OU19UQUJMRVtrZXldXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRWYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBUQUJMRV9PUFRJT05TLm9wdGlvbnNba2V5XSA9IG9wdFZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUQUJMRV9PUFRJT05TO1xuICAgIH1cbn1cbiIsImltcG9ydCBDUlVEQWN0aW9uQ3JlYXRlIGZyb20gXCIuL2NyZWF0ZVwiO1xuaW1wb3J0IENSVURBY3Rpb25EZXRhaWxzIGZyb20gXCIuL2RldGFpbHNcIjtcbmltcG9ydCBDUlVEQWN0aW9uVXBkYXRlIGZyb20gXCIuL3VwZGF0ZVwiO1xuaW1wb3J0IENSVURBY3Rpb25EZWxldGUgZnJvbSBcIi4vZGVsZXRlXCI7XG5pbXBvcnQgQ1JVREFjdGlvbkxpc3QgZnJvbSBcIi4vbGlzdFwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlOiBDUlVEQWN0aW9uQ3JlYXRlLFxuICAgIGRldGFpbHM6IENSVURBY3Rpb25EZXRhaWxzLFxuICAgIHVwZGF0ZTogQ1JVREFjdGlvblVwZGF0ZSxcbiAgICBkZWxldGU6IENSVURBY3Rpb25EZWxldGUsXG4gICAgbGlzdDogQ1JVREFjdGlvbkxpc3QsXG59O1xuIiwiaW1wb3J0IFVJQ29tbW9uIGZyb20gXCIuLi8uLi9lbGVtZW50cy9jb21tb25cIjtcblxuaW1wb3J0IG5vdEJyZWFkY3J1bWJzIGZyb20gXCIuLi9jb21wb25lbnRzL2JyZWFkY3J1bWJzXCI7XG5cbmltcG9ydCBVSUxvYWRlciBmcm9tIFwiLi4vLi4vZWxlbWVudHMvdmFyaW91cy91aS5sb2FkZXIuc3ZlbHRlXCI7XG5cbmltcG9ydCBub3RDb250cm9sbGVyIGZyb20gXCIuLi9jb250cm9sbGVyXCI7XG5pbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuaW1wb3J0IENSVURWYXJpYW50c1ByZWxvYWRlciBmcm9tIFwiLi92YXJpYW50cy5wcmVsb2FkZXIuanNcIjtcbmltcG9ydCBDUlVEUm91dGVyIGZyb20gXCIuL3JvdXRlci5qc1wiO1xuaW1wb3J0IENSVURNZXNzYWdlIGZyb20gXCIuL21lc3NhZ2UuanNcIjtcbmltcG9ydCBDUlVEQWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBtb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblxuY29uc3QgQlJFQURDUlVNQlMgPSBbXTtcbmNvbnN0IFRJVExFX0ZJRUxEU19QUklPUklUWSA9IFtcInRpdGxlXCIsIFwibGFiZWxcIiwgXCJpZFwiLCBcIm5hbWVcIl07XG5cbmNvbnN0IExPQURJTkdfU0NSRUVOX1VJX05BTUUgPSBcImxvYWRpbmdfc2NyZWVuXCI7XG5cbmNsYXNzIG5vdENSVUQgZXh0ZW5kcyBub3RDb250cm9sbGVyIHtcbiAgICAjYWN0aW9ucyA9IHsgLi4uQ1JVREFjdGlvbnMgfTtcbiAgICAjcm91dGVyID0gQ1JVRFJvdXRlcjtcbiAgICAjcHJlbG9hZGVyID0gQ1JVRFZhcmlhbnRzUHJlbG9hZGVyO1xuXG4gICAgVElUTEVfRklFTERTX1BSSU9SSVRZID0gVElUTEVfRklFTERTX1BSSU9SSVRZO1xuXG4gICAgc3RhdGljIEVSUk9SX0RFRkFVTFQgPSBVSUNvbW1vbi5FUlJPUl9ERUZBVUxUO1xuXG4gICAgVE9QX0NMQVNTID0gW1wiYm94XCJdO1xuICAgIE1BSU5fQ0xBU1MgPSBbXCJib3hcIl07XG4gICAgQk9UVE9NX0NMQVNTID0gW1wiYm94XCJdO1xuXG4gICAgV1NfQ0hFQ0tfSU5URVJWQUwgPSAyMDA7XG5cbiAgICBzdGF0aWMgZ2V0IExBQkVMUygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgcGx1cmFsOiBgJHt0aGlzLk1PRFVMRV9OQU1FfToke3RoaXMuTU9ERUxfTkFNRX1fbGFiZWxfcGx1cmFsYCxcbiAgICAgICAgICAgIHNpbmdsZTogYCR7dGhpcy5NT0RVTEVfTkFNRX06JHt0aGlzLk1PREVMX05BTUV9X2xhYmVsX3NpbmdsZWAsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRNZW51KGl0ZW1DdXN0b21Qcm9wcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbjogdGhpcy5NT0RVTEVfTkFNRSxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5MQUJFTFMucGx1cmFsLFxuICAgICAgICAgICAgICAgIHVybDogYC8ke25vdENvbW1vbi5sb3dlckZpcnN0TGV0dGVyKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9OQU1FXG4gICAgICAgICAgICAgICAgKX0vJHtub3RDb21tb24ubG93ZXJGaXJzdExldHRlcih0aGlzLk1PREVMX05BTUUpfWAsXG4gICAgICAgICAgICAgICAgLi4uaXRlbUN1c3RvbVByb3BzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgYXBwLFxuICAgICAgICBuYW1lLFxuICAgICAgICB7IGFjdGlvbnMsIHJvdXRlciwgcHJlbG9hZGVyIH0gPSB7XG4gICAgICAgICAgICBhY3Rpb25zOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByb3V0ZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZWxvYWRlcjogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGFwcCwgYENSVUQuJHtuYW1lfWApO1xuICAgICAgICBpZiAoYWN0aW9ucykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy4jYWN0aW9ucyA9IHsgLi4udGhpcy4jYWN0aW9ucywgLi4uYWN0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3JvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlbG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNwcmVsb2FkZXIgPSBwcmVsb2FkZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aSA9IHt9O1xuICAgICAgICB0aGlzLmVscyA9IHt9O1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoXCJuYW1lc1wiLCB7XG4gICAgICAgICAgICBtb2R1bGU6IFwiXCIsXG4gICAgICAgICAgICBwbHVyYWw6IFwicGx1cmFsXCIsXG4gICAgICAgICAgICBzaW5nbGU6IFwic2luZ2xlXCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMoXG4gICAgICAgICAgICBcImNvbnRhaW5lclNlbGVjdG9yXCIsXG4gICAgICAgICAgICB0aGlzLmFwcD8uZ2V0T3B0aW9ucyhcImNydWQuY29udGFpbmVyU2VsZWN0b3JcIilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5idWlsZEZyYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldFZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICAvL25vdC1tb2R1bGUtbmFtZSAtPiBbbm90LG1vZHVsZSxuYW1lXVxuICAgICAgICBjb25zdCBNb2R1bGVOYW1lUGFydHMgPSB0aGlzLmdldE1vZHVsZU5hbWUoKS5zcGxpdChcIi1cIik7XG4gICAgICAgIC8vW25vdCxtb2R1bGUsbmFtZV0gLT4gTW9kdWxlTmFtZVxuICAgICAgICBjb25zdCBNb2R1bGVOYW1lID0gKFxuICAgICAgICAgICAgTW9kdWxlTmFtZVBhcnRzWzBdID09PSBcIm5vdFwiXG4gICAgICAgICAgICAgICAgPyBNb2R1bGVOYW1lUGFydHMuc3BsaWNlKDEpXG4gICAgICAgICAgICAgICAgOiBNb2R1bGVOYW1lUGFydHNcbiAgICAgICAgKVxuICAgICAgICAgICAgLm1hcChub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKVxuICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gYG5zJHtNb2R1bGVOYW1lfUNvbW1vbmA7XG4gICAgICAgIGNvbnN0IENvbW1vbk1vZHVsZVNlcnZpY2UgPSB0aGlzLmFwcD8uZ2V0U2VydmljZShzZXJ2aWNlTmFtZSk7XG4gICAgICAgIHRoaXMuc2V0V29ya2luZyhcbiAgICAgICAgICAgIFwidmFsaWRhdG9yc1wiLFxuICAgICAgICAgICAgQ29tbW9uTW9kdWxlU2VydmljZS5hdWdtZW50VmFsaWRhdG9ycyh2YWxpZGF0b3JzKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldFZhbGlkYXRvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtpbmcoXCJ2YWxpZGF0b3JzXCIpO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICBsZXQgbmV3SGVhZCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5nZXRNb2R1bGVOYW1lKCkgJiYgdGhpcy5nZXRPcHRpb25zKFwibmFtZXMubW9kdWxlXCIpKSB7XG4gICAgICAgICAgICBuZXdIZWFkLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmdldE9wdGlvbnMoXCJuYW1lcy5tb2R1bGVcIiksXG4gICAgICAgICAgICAgICAgdXJsOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG5ld0hlYWQucHVzaCh7XG4gICAgICAgICAgICB0aXRsZTogdGhpcy5nZXRPcHRpb25zKFwibmFtZXMucGx1cmFsXCIpLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmdldE1vZGVsVVJMKCksXG4gICAgICAgIH0pO1xuICAgICAgICBCUkVBRENSVU1CUy5zcGxpY2UoMCwgQlJFQURDUlVNQlMubGVuZ3RoLCAuLi5uZXdIZWFkKTtcbiAgICAgICAgbm90QnJlYWRjcnVtYnMuc2V0SGVhZChCUkVBRENSVU1CUykucmVuZGVyKHtcbiAgICAgICAgICAgIHJvb3Q6IFwiXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuZWxzLnRvcCxcbiAgICAgICAgICAgIG5hdmlnYXRlOiAodXJsKSA9PiB0aGlzLmFwcD8uZ2V0V29ya2luZyhcInJvdXRlclwiKS5uYXZpZ2F0ZSh1cmwpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb3V0ZSh0aGlzLmdldE9wdGlvbnMoXCJwYXJhbXNcIikpO1xuICAgIH1cblxuICAgIHN0YXJ0V2hlbldTQ2xpZW50UmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmFwcD8uZ2V0V1NDbGllbnQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwPy5nZXRXU0NsaWVudCgpLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwXG4gICAgICAgICAgICAgICAgICAgIC5nZXRXU0NsaWVudCgpXG4gICAgICAgICAgICAgICAgICAgIC5vbmNlKFwiY29ubmVjdGVkXCIsIHRoaXMuc3RhcnRXaGVuV1NDbGllbnRSZWFkeS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5zdGFydFdoZW5XU0NsaWVudFJlYWR5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5XU19DSEVDS19JTlRFUlZBTFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEJyZWFkY3J1bWJzKHRhaWwpIHtcbiAgICAgICAgbm90QnJlYWRjcnVtYnMuc2V0VGFpbCh0YWlsKS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBiYWNrVG9MaXN0KCkge1xuICAgICAgICB0aGlzLm5hdmlnYXRlKHRoaXMubGlua0JhY2tUb0xpc3QoKSk7XG4gICAgfVxuXG4gICAgbGlua0JhY2tUb0xpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vZGVsVVJMKCk7XG4gICAgfVxuXG4gICAgYWZ0ZXJBY3Rpb24oYWN0aW9uID0gXCJsaXN0XCIpIHtcbiAgICAgICAgbGV0IG5hdkJhY2sgPSB0aGlzLmFwcD8uZ2V0T3B0aW9ucyhcImNydWQubmF2aWdhdGVCYWNrQWZ0ZXJcIiwgW10pO1xuICAgICAgICBpZiAobmF2QmFjayAmJiBBcnJheS5pc0FycmF5KG5hdkJhY2spICYmIG5hdkJhY2suaW5kZXhPZihhY3Rpb24pID4gLTEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFja1RvTGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnVpbGRGcmFtZSgpIHtcbiAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgIHRoaXMuYXBwPy5nZXRPcHRpb25zKFwiY3J1ZC5jb250YWluZXJTZWxlY3RvclwiLCBcImJvZHlcIilcbiAgICAgICAgKTtcbiAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxzLnRvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWxzLnRvcC5pZCA9IFwiY3J1ZC10b3BcIjtcbiAgICAgICAgdGhpcy5nZXRGcmFtZUNsYXNzZXMoKS5UT1BfQ0xBU1MuZm9yRWFjaCgobmFtZSkgPT5cbiAgICAgICAgICAgIHRoaXMuZWxzLnRvcC5jbGFzc0xpc3QuYWRkKG5hbWUpXG4gICAgICAgICk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuZWxzLnRvcCk7XG4gICAgICAgIHRoaXMuZWxzLm1haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmVscy5tYWluLmlkID0gXCJjcnVkLW1haW5cIjtcbiAgICAgICAgdGhpcy5nZXRGcmFtZUNsYXNzZXMoKS5NQUlOX0NMQVNTLmZvckVhY2goKG5hbWUpID0+XG4gICAgICAgICAgICB0aGlzLmVscy5tYWluLmNsYXNzTGlzdC5hZGQobmFtZSlcbiAgICAgICAgKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5lbHMubWFpbik7XG4gICAgICAgIHRoaXMuZWxzLmJvdHRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZWxzLmJvdHRvbS5pZCA9IFwiY3J1ZC1ib3R0b21cIjtcbiAgICAgICAgdGhpcy5nZXRGcmFtZUNsYXNzZXMoKS5CT1RUT01fQ0xBU1MuZm9yRWFjaCgobmFtZSkgPT5cbiAgICAgICAgICAgIHRoaXMuZWxzLmJvdHRvbS5jbGFzc0xpc3QuYWRkKG5hbWUpXG4gICAgICAgICk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuZWxzLmJvdHRvbSk7XG4gICAgfVxuXG4gICAgZ2V0RnJhbWVDbGFzc2VzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVE9QX0NMQVNTOiB0aGlzLlRPUF9DTEFTUyxcbiAgICAgICAgICAgIE1BSU5fQ0xBU1M6IHRoaXMuTUFJTl9DTEFTUyxcbiAgICAgICAgICAgIEJPVFRPTV9DTEFTUzogdGhpcy5CT1RUT01fQ0xBU1MsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0Q29udGFpbmVyVG9wRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxzLnRvcDtcbiAgICB9XG5cbiAgICBnZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVscy5tYWluO1xuICAgIH1cblxuICAgIGdldENvbnRhaW5lckJvdHRvbUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVscy5ib3R0b207XG4gICAgfVxuXG4gICAgYXN5bmMgcHJlbG9hZFZhcmlhbnRzKHR5cGUgPSBcImxpc3RcIikge1xuICAgICAgICBhd2FpdCB0aGlzLiNwcmVsb2FkZXIucHJlbG9hZCh0aGlzLCB0eXBlKTtcbiAgICB9XG5cbiAgICBnZXRUaXRsZUZyb21MaWIocHJvcE5hbWUsIGlkKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSB0aGlzLmdldEN1cnJlbnRBY3Rpb24oKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyAmJlxuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcIm5vdENSVUQuZ2V0VGl0bGVGcm9tTGliIGlzIG9ic29sZXRlLCB1c2Ugbm90Q1JVRC5nZXRQcmVsb2FkZWRWYXJpYW50VGl0bGUoYWN0aW9uTmFtZSwgcHJvcE5hbWUsIGlkKVwiXG4gICAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmVsb2FkZWRWYXJpYW50VGl0bGUoYWN0aW9uTmFtZSwgcHJvcE5hbWUsIGlkKTtcbiAgICB9XG5cbiAgICBnZXRQcmVsb2FkZWRWYXJpYW50cyhhY3Rpb25OYW1lLCBwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb25zKGB2YXJpYW50cy4ke2FjdGlvbk5hbWV9LiR7cHJvcE5hbWV9YCwgW10pO1xuICAgIH1cblxuICAgIGdldFByZWxvYWRlZFZhcmlhbnRUaXRsZShhY3Rpb25OYW1lLCBwcm9wTmFtZSwgaWQpIHtcbiAgICAgICAgY29uc3QgdmFyaWFudHMgPSB0aGlzLmdldFByZWxvYWRlZFZhcmlhbnRzKGFjdGlvbk5hbWUsIHByb3BOYW1lKTtcbiAgICAgICAgY29uc3QgaXRlbSA9IHZhcmlhbnRzLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGlkKTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRpdGxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0SXRlbVRpdGxlKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gdGhpcy5USVRMRV9GSUVMRFNfUFJJT1JJVFkuZmluZCgoa2V5KSA9PlxuICAgICAgICAgICAgbm90Q29tbW9uLm9iakhhcyhpdGVtLCBrZXkpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtW2ZpZWxkTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vZGVsKHt9KS50b0RlZmF1bHQoKTtcbiAgICB9XG5cbiAgICByb3V0ZShwYXJhbXMgPSBbXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JvdXRlci5yb3V0ZSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydChlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yTWVzc2FnZShlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvbkhhbmRsZXJFeGlzdHMoYWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy4jYWN0aW9ucykuaW5jbHVkZXMoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzW1wicnVuXCIgKyBub3RDb21tb24uY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGFjdGlvbk5hbWUpXSA9PT1cbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBydW5BY3Rpb24oYWN0aW9uTmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLiNhY3Rpb25zKS5pbmNsdWRlcyhhY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2FjdGlvbnNbYWN0aW9uTmFtZV0ucnVuKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgdGhpc1tcInJ1blwiICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihhY3Rpb25OYW1lKV0gPT09XG4gICAgICAgICAgICBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tcInJ1blwiICsgbm90Q29tbW9uLmNhcGl0YWxpemVGaXJzdExldHRlcihhY3Rpb25OYW1lKV0oXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBObyBzdWNoIGFjdGlvbjogJHthY3Rpb25OYW1lfSBpbiBjb250b2xsZXIgJHt0aGlzLmdldFdvcmtpbmcoXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICAgICAgICAgKX1gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENoYW5nZXMgbG9jYXRpb24gdG8gY3JlYXRlIHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW2RlbGF5PTBdIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29DcmVhdGUoZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29BZnRlckRlbGF5KHRoaXMuZ2V0TW9kZWxBY3Rpb25VUkwoXCJcIiwgXCJjcmVhdGVcIiksIGRlbGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudCBkZXRhaWxzIHBhZ2UsIGFmdGVyIGRlbGF5XG4gICAgICogIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgIGlkICAgICAgICAgIHRhcmdldCBkb2N1bWVudCBpZFxuICAgICAqICBAcGFyYW0ge251bWJlcnxzdHJpbmd9ICBbZGVsYXk9MF0gICBudW1iZXIgZm9yIG1zLCBvciBzdHJpbmcgaWYgd2UgdXNlIGBkZWxheXNgIGFsaXNlcyBha2EgU0hPUlQsIE5PUk1BTCwgTE9OR1xuICAgICAqL1xuICAgIGdvRGV0YWlscyhpZCwgZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29BZnRlckRlbGF5KHRoaXMuZ2V0TW9kZWxBY3Rpb25VUkwoaWQsIFwiXCIpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBsb2NhdGlvbiB0byBkb2N1bWVudCB1cGRhdGUgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgaWQgICAgICAgICAgdGFyZ2V0IGRvY3VtZW50IGlkXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gIFtkZWxheT0wXSAgIG51bWJlciBmb3IgbXMsIG9yIHN0cmluZyBpZiB3ZSB1c2UgYGRlbGF5c2AgYWxpc2VzIGFrYSBTSE9SVCwgTk9STUFMLCBMT05HXG4gICAgICovXG4gICAgZ29VcGRhdGUoaWQsIGRlbGF5ID0gMCkge1xuICAgICAgICB0aGlzLmdvQWZ0ZXJEZWxheSh0aGlzLmdldE1vZGVsQWN0aW9uVVJMKGlkLCBcInVwZGF0ZVwiKSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDaGFuZ2VzIGxvY2F0aW9uIHRvIGRvY3VtZW50IGRlbGV0ZSBwYWdlLCBhZnRlciBkZWxheVxuICAgICAqICBAcGFyYW0ge3N0cmluZ30gICAgICAgICBpZCAgICAgICAgICB0YXJnZXQgZG9jdW1lbnQgaWRcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgW2RlbGF5PTBdICAgbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb0RlbGV0ZShpZCwgZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29BZnRlckRlbGF5KHRoaXMuZ2V0TW9kZWxBY3Rpb25VUkwoaWQsIFwiZGVsZXRlXCIpLCBkZWxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENoYW5nZXMgbG9jYXRpb24gdG8gZG9jdW1lbnRzIGxpc3QgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgW2RlbGF5PTBdICAgbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb0xpc3QoZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29BZnRlckRlbGF5KHRoaXMuZ2V0TW9kZWxVUkwoKSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gZGVsYXlcbiAgICAgKi9cbiAgICBnb0FmdGVyRGVsYXkodXJsLCBkZWxheSA9IDApIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVdpdGhEZWxheSh1cmwsIGRlbGF5LCAoKSA9PiB0aGlzLiRkZXN0cm95VUkoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENoYW5nZXMgbG9jYXRpb24gdG8gZG9jdW1lbnRzIGxpc3QgcGFnZSwgYWZ0ZXIgZGVsYXlcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSAgW2RlbGF5PTBdICAgbnVtYmVyIGZvciBtcywgb3Igc3RyaW5nIGlmIHdlIHVzZSBgZGVsYXlzYCBhbGlzZXMgYWthIFNIT1JULCBOT1JNQUwsIExPTkdcbiAgICAgKi9cbiAgICBnb0JhY2soZGVsYXkgPSAwKSB7XG4gICAgICAgIHRoaXMuZ29MaXN0KGRlbGF5KTtcbiAgICB9XG5cbiAgICBhc3luYyBvbkFjdGlvblN1Ym1pdChhY3Rpb24sIGl0ZW0pIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYWN0aW9uVUkgPSB0aGlzLnVpW2FjdGlvbl07XG4gICAgICAgIGlmIChhY3Rpb25VSSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhY3Rpb25VSS5zZXRMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0TW9kZWwoaXRlbSlbYCQke2FjdGlvbn1gXSgpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gYWN0aW9uVUkucHJvY2Vzc1Jlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gYWN0aW9uVUkucHJvY2Vzc1Jlc3VsdChlKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uVUkucmVzZXRMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1maW5hbGx5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aW9uIFVJIGRvZXNudCBleGlzdFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICRkZXN0cm95VUkoKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy51aSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95VUlCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95VUlCeU5hbWUobmFtZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKHRoaXMudWksIG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnVpW25hbWVdLiRkZXN0cm95ICYmIHRoaXMudWlbbmFtZV0uJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMudWlbbmFtZV0uZGVzdHJveSAmJiB0aGlzLnVpW25hbWVdLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVpW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvd0Vycm9yTWVzc2FnZShyZXMpIHtcbiAgICAgICAgdGhpcy5lcnJvciAmJiB0aGlzLmVycm9yKHJlcyk7XG4gICAgICAgIHRoaXMuYXBwICYmXG4gICAgICAgICAgICB0aGlzLmFwcC5lbWl0KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCf0YDQvtC40LfQvtGI0LvQsCDQvtGI0LjQsdC60LBcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXMubWVzc2FnZSA/IHJlcy5tZXNzYWdlIDogVUlDb21tb24uRVJST1JfREVGQVVMVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBDUlVETWVzc2FnZS5lcnJvcihcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBcItCf0YDQvtC40LfQvtGI0LvQsCDQvtGI0LjQsdC60LBcIixcbiAgICAgICAgICAgIHJlcy5tZXNzYWdlID8gcmVzLm1lc3NhZ2UgOiBVSUNvbW1vbi5FUlJPUl9ERUZBVUxUXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgc2hvd1N1Y2Nlc3NNZXNzYWdlKHRpdGxlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuYXBwICYmIHRoaXMuYXBwLmVtaXQoXCJzdWNjZXNzXCIsIHsgdGl0bGUsIG1lc3NhZ2UgfSk7XG4gICAgICAgIENSVURNZXNzYWdlLnN1Y2Nlc3ModGhpcywgdGl0bGUsIG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHNldFVJKG5hbWUsIHZhbCwgc2luZ2xlVUkgPSB0cnVlKSB7XG4gICAgICAgIGlmIChzaW5nbGVVSSkge1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveVVJKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aVtuYW1lXSA9IHZhbDtcbiAgICB9XG5cbiAgICBnZXRVSShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpW25hbWVdO1xuICAgIH1cblxuICAgIGdldEFjdGlvblVJKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aVt0aGlzLmdldEN1cnJlbnRBY3Rpb24oKV07XG4gICAgfVxuXG4gICAgcmVuZGVyTG9hZGluZ1NjcmVlbigpIHtcbiAgICAgICAgdGhpcy5zZXRVSShMT0FESU5HX1NDUkVFTl9VSV9OQU1FLCB0aGlzLmNyZWF0ZUxvYWRlclVJKCkpO1xuICAgIH1cblxuICAgIHJlbW92ZUxvYWRpbmdTY3JlZW4oKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVVJQnlOYW1lKExPQURJTkdfU0NSRUVOX1VJX05BTUUpO1xuICAgIH1cblxuICAgIGNyZWF0ZUxvYWRlclVJKCkge1xuICAgICAgICByZXR1cm4gbW91bnQoVUlMb2FkZXIsIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXRDb250YWluZXJJbm5lckVsZW1lbnQoKSxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbm90Q1JVRDtcbiIsImNvbnN0IFJPVVRFX0xJU1QgPSBcImxpc3RcIjtcbi8qKlxuICogUnVucyBjb250cm9sbGVyIGFjdGlvbiBieSBuYW1lIHRoYXQgZ2V0cyBmcm9tIFVSSSBwYXJhbXNcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBub3RDUlVEUGxhaW5Sb3V0ZXIge1xuICAgIHN0YXRpYyBERUZBVUxUX1JPVVRFID0gUk9VVEVfTElTVDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IGl0ZW0gZnJvbSBwYXJhbXMgb3IgdGhyb3dzIEVycm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zIGFycmF5IG9mIHN0cmluZ3MgcGFyc2VkIGZyb20gVVJJIGJ5IHJvdXRlIHJ1bGVzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZXh0cmFjdEFjdGlvbk5hbWUocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ERUZBVUxUX1JPVVRFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgY29udHJvbGxlciBhY3Rpb24gb3IgdGhyb3dzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRyb2xsZXIgICBpbnN0YW5jZSBvZiBub3RDb250cm9sbGVyIGRlc2NlbmRhbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgcm91dGUoY29udHJvbGxlciwgcGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gdGhpcy5leHRyYWN0QWN0aW9uTmFtZShwYXJhbXMpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zZXRDdXJyZW50QWN0aW9uKGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucnVuQWN0aW9uKGFjdGlvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RDUlVEUGxhaW5Sb3V0ZXI7XG4iLCJpbXBvcnQgbm90Q29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuLyoqXG4gKiBSdW5zIGNvbnRyb2xsZXIgYWN0aW9uIGJ5IG5hbWUgdGhhdCBnZXRzIGZyb20gVVJJIHBhcmFtc1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIG5vdENSVURSb3V0ZXJTd2l0Y2gge1xuICAgIC8qKlxuICAgICAqIFZhcmlhbnRzIG9mIHRoaXMgYWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldCByb3V0ZXNWYXJpYW50cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgcm91dGVOYW1lOiBBY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB2YXJpYW50IG5hbWUgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICBuYW1lIG9mIHJvdXRlIHZhcmlhbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNSb3V0ZVZhcmlhbnRWYWxpZChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lICE9PSBcIlwiICYmIG5vdENvbW1vbi5vYmpIYXModGhpcy5yb3V0ZXNWYXJpYW50cywgbmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHdoaWNoIG9mIHJvdXRlcyB2YXJpYW50IHNob3VsZCBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2Ygbm90Q29udHJvbGxlciBkZXNjZW5kYW50XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gICAgcGFyYW1zICBwYXJhbXMgcGFzc2VkIHRvIHJvdXRlclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59ICAgIG5hbWUgb2Ygcm91dGUgdmFyaWFudFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHN0YXRpYyBhc3luYyBkZXRlcm1pbmVSb3V0ZShjb250cm9sbGVyLCBwYXJhbXMgPSBbXSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGNvbnRyb2xsZXIgYWN0aW9uIG9yIHRocm93c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb250cm9sbGVyICAgaW5zdGFuY2Ugb2Ygbm90Q29udHJvbGxlciBkZXNjZW5kYW50XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJvdXRlKGNvbnRyb2xsZXIsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uTmFtZSA9IGF3YWl0IHRoaXMuZGV0ZXJtaW5lUm91dGUoY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUm91dGVWYXJpYW50VmFsaWQoYWN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNldEN1cnJlbnRBY3Rpb24oYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVyQWN0aW9uID0gdGhpcy5yb3V0ZXNWYXJpYW50c1thY3Rpb25OYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobm90Q29tbW9uLmlzQXN5bmMocm91dGVyQWN0aW9uLnJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcm91dGVyQWN0aW9uLnJ1bihjb250cm9sbGVyLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlckFjdGlvbi5ydW4oY29udHJvbGxlciwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYE5vIHN1Y2ggYWN0aW9uOiAke2FjdGlvbk5hbWV9IGluIGNvbnRvbGxlciAke2NvbnRyb2xsZXIuZ2V0V29ya2luZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICl9YFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIucmVwb3J0KGUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93RXJyb3JNZXNzYWdlKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBub3RDUlVEUm91dGVyU3dpdGNoO1xuIiwiaW1wb3J0IFVJR2VuZXJpY1NlbGVjdG9yIGZyb20gXCIuLi8uLi9lbGVtZW50cy9tb2RhbC91aS5nZW5lcmljLnNlbGVjdG9yLnN2ZWx0ZVwiO1xuaW1wb3J0IHsgbW91bnQsIHVubW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cbmNvbnN0IGVtcHR5UmVzdWx0ID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpc3Q6IFtdLFxuICAgICAgICBjb3VudDogMCxcbiAgICAgICAgcGFnZTogMCxcbiAgICAgICAgcGFnZXM6IDAsXG4gICAgICAgIHNraXA6IDAsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIG5vdFNlcnZpY2VNb2RlbFNlYXJjaCB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBtb2RlbE5hbWUpIHtcbiAgICAgICAgdGhpcy5tb2RlbE5hbWUgPSBtb2RlbE5hbWU7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFwcDtcbiAgICB9XG5cbiAgICBnZXRTZWFyY2hSb3V0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcImxpc3RBbmRDb3VudFwiO1xuICAgIH1cblxuICAgIGdldERhdGFMb2FkUm91dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJnZXRcIjtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm1TZWFyY2hSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5saXN0ID0gcmVzdWx0Lmxpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIF9pZDogaXRlbS5faWQsXG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW1bYCR7dGhpcy5tb2RlbE5hbWV9SURgXSxcbiAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS5uYW1lIHx8IGl0ZW0udGl0bGUgfHwgaXRlbS5sYWJlbCB8fCBpdGVtLnVzZXJuYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtU2VsZWN0ZWRSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfaWQ6IHJlc3VsdC5faWQsXG4gICAgICAgICAgICBbYCR7dGhpcy5tb2RlbE5hbWV9SURgXTogcmVzdWx0LmlkLFxuICAgICAgICAgICAgdGl0bGU6IHJlc3VsdC50aXRsZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBzZWFyY2hCeVRlcm0odGVybSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRlcm0udmFsdWUubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5hcHAuZ2V0TW9kZWwodGhpcy5tb2RlbE5hbWUpO1xuICAgICAgICAgICAgICAgIG1vZGVsLnNldFNlYXJjaCh0ZXJtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsW2AkJHt0aGlzLmdldFNlYXJjaFJvdXRlTmFtZSgpfWBdKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJva1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVNlYXJjaFJlc3VsdChyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gbW91bnQoVUlHZW5lcmljU2VsZWN0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWwuJG9uKFwidGVybUNoYW5nZVwiLCBhc3luYyAoeyBkZXRhaWwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZWFyY2hCeVRlcm0oZGV0YWlsKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuJHNldCh7IHJlc3VsdHMgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlbC4kb24oXCJuZXh0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJuZXh0IHNlbGVjdG9yIHJlc3VsdHNcIik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlbC4kb24oXCJwcmV2XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcmV2IHNlbGVjdG9yIHJlc3VsdHNcIik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBlbC4kb24oXCJyZWplY3RcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWwuJG9uKFwicmVzb2x2ZVwiLCAoeyBkZXRhaWwgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnRyYW5zZm9ybVNlbGVjdGVkUmVzdWx0KGRldGFpbCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZERhdGEoX2lkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2lkICYmIF9pZC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5hcHAuZ2V0TW9kZWwodGhpcy5tb2RlbE5hbWUsIHsgX2lkIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWxbXG4gICAgICAgICAgICAgICAgICAgIGAkJHt0aGlzLmdldERhdGFMb2FkUm91dGVOYW1lKCl9YFxuICAgICAgICAgICAgICAgIF0oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBcIm9rXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmFwcC5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy9pbXBvcnQgJ2JhYmVsLXBvbHlmaWxsL2Rpc3QvcG9seWZpbGwnO1xuXG4vKlxuICBDb21tb24gZnVuY3Rpb25zXG4qL1xuaW1wb3J0IG5vdENvbW1vbiBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLypcbiAgZnJhbWV3b3JrIHdpZGUgcGFyc2VyIGZvciBkYXRhIGFjY2Vzc1xuKi9cbmltcG9ydCBub3RQYXRoIGZyb20gXCJub3QtcGF0aFwiO1xuXG5pbXBvcnQgbm90Um91dGVyIGZyb20gXCIuL3JvdXRlci5qc1wiO1xuXG5pbXBvcnQgKiBhcyBub3RBUEkgZnJvbSBcIi4vYXBpXCI7XG5pbXBvcnQgKiBhcyBub3RTdG9yZXMgZnJvbSBcIi4vc3RvcmVzXCI7XG4vKlxuICBiYXNpYyBldmVudCBoYW5kbGVycyBhbmQgY29yZSBkYXRhIG1vZGlmaWVyc1xuKi9cbmltcG9ydCBub3RCYXNlIGZyb20gXCIuL2Jhc2UuanNcIjtcblxuaW1wb3J0IHsgQ09NUE9ORU5UUywgRklFTERTLCBWQVJJQU5UUyB9IGZyb20gXCIuL0xJQi5qc1wiO1xuLypcbiAgYXBwbGljYXRpb24gbWFpbiBpbmZyYXN0cnVjdHVyZSBzZXR0ZXJcbiovXG5pbXBvcnQgbm90QXBwIGZyb20gXCIuL2FwcC5qc1wiO1xuLypcbiAgdXNlciBjb250cm9sbGVyc1xuKi9cbmltcG9ydCBub3RDb250cm9sbGVyIGZyb20gXCIuL2NvbnRyb2xsZXIuanNcIjtcbmltcG9ydCBub3RSZWNvcmQgZnJvbSBcIi4vcmVjb3JkLmpzXCI7IC8vICB3cmFwcGVyIGZvciBkYXRhIHdpdGggc2VydmVyIGxpdmUgaW50ZXJhY3Rpb25zXG5pbXBvcnQgbm90SW50ZXJmYWNlIGZyb20gXCIuL2ludGVyZmFjZS5qc1wiOyAvLyAgd3JhcHBlciBmb3IgZGF0YSB3aXRoIHNlcnZlciBsaXZlIGludGVyYWN0aW9uc1xuXG5pbXBvcnQge1xuICAgIG5vdFRhYmxlLFxuICAgIFVJRm9ybSxcbiAgICBub3RGb3JtLFxuICAgIG5vdEZvcm1TZXQsXG4gICAgbm90Rm9ybVJ1bGVzLFxuICAgIG5vdEZvcm1VdGlscyxcbiAgICBub3RGb3JtSGVscGVycyxcbiAgICBub3RCcmVhZGNydW1icyxcbiAgICBub3RUb3BNZW51LFxuICAgIG5vdFNpZGVNZW51LFxufSBmcm9tIFwiLi9jb21wb25lbnRzXCI7XG5cbmltcG9ydCBjcmVhdGVDUlVEQWN0aW9uVUlWaWV3IGZyb20gXCIuL2NydWQvY3JlYXRlLmNydWQuYWN0aW9uLnVpLnZpZXcuanNcIjtcbmltcG9ydCBub3RDUlVEIGZyb20gXCIuL2NydWQvY29udHJvbGxlci5jcnVkLmpzXCI7XG5pbXBvcnQgbm90Q1JVRFJvdXRlciBmcm9tIFwiLi9jcnVkL3JvdXRlci5qc1wiO1xuaW1wb3J0IG5vdENSVURSb3V0ZXJQbGFpbiBmcm9tIFwiLi9jcnVkL3JvdXRlci5wbGFpbi5qc1wiO1xuaW1wb3J0IG5vdENSVURSb3V0ZXJTd2l0Y2ggZnJvbSBcIi4vY3J1ZC9yb3V0ZXIuc3dpdGNoLmpzXCI7XG5pbXBvcnQgbm90U2VydmljZU1vZGVsU2VhcmNoIGZyb20gXCIuL2NydWQvc2VhcmNoLnNlcnZpY2UuanNcIjtcblxuY29uc3QgbmNDUlVEID0gbm90Q1JVRDsgLy9sZWdhY3kgYWxpYXNcblxuZXhwb3J0IHtcbiAgICBDT01QT05FTlRTLFxuICAgIEZJRUxEUyxcbiAgICBVSUZvcm0sXG4gICAgVkFSSUFOVFMsXG4gICAgbmNDUlVELFxuICAgIGNyZWF0ZUNSVURBY3Rpb25VSVZpZXcsXG4gICAgbm90QVBJLFxuICAgIG5vdEFwcCxcbiAgICBub3RCYXNlLFxuICAgIG5vdEJyZWFkY3J1bWJzLFxuICAgIG5vdENSVUQsXG4gICAgbm90Q29tbW9uLFxuICAgIG5vdENvbnRyb2xsZXIsXG4gICAgbm90Rm9ybSxcbiAgICBub3RGb3JtU2V0LFxuICAgIG5vdEZvcm1VdGlscyxcbiAgICBub3RGb3JtSGVscGVycyxcbiAgICBub3RGb3JtUnVsZXMsXG4gICAgbm90SW50ZXJmYWNlLFxuICAgIG5vdFBhdGgsXG4gICAgbm90UmVjb3JkLFxuICAgIG5vdFJvdXRlcixcbiAgICBub3RDUlVEUm91dGVyLFxuICAgIG5vdENSVURSb3V0ZXJQbGFpbixcbiAgICBub3RDUlVEUm91dGVyU3dpdGNoLFxuICAgIG5vdFNlcnZpY2VNb2RlbFNlYXJjaCxcbiAgICBub3RTaWRlTWVudSxcbiAgICBub3RTdG9yZXMsXG4gICAgbm90VGFibGUsXG4gICAgbm90VG9wTWVudSxcbn07XG4iLCJpbXBvcnQgXCIuL3Njc3Mvc3R5bGUuc2Nzc1wiO1xuXG5pbXBvcnQgKiBhcyBzdmVsdGUgZnJvbSBcInN2ZWx0ZVwiO1xuXG5pbXBvcnQgKiBhcyBFbGVtZW50cyBmcm9tIFwiLi9lbGVtZW50c1wiO1xuXG5pbXBvcnQgKiBhcyBGcmFtZSBmcm9tIFwiLi9mcmFtZVwiO1xuXG5pbXBvcnQgeyBMT0NBTEUsIHNheSwgbm90TG9jYWxlIH0gZnJvbSBcIi4vbG9jYWxlXCI7XG5cbmNvbnN0IExvY2FsZSA9IHsgTE9DQUxFLCBzYXksIG5vdExvY2FsZSB9O1xuY29uc3QgVUlDb21tb24gPSBFbGVtZW50cy5VSUNvbW1vbjtcblxuY29uc3QgeyBub3RDb21tb24sIENPTVBPTkVOVFMsIEZJRUxEUywgVkFSSUFOVFMsIG5vdEZvcm1VdGlscyB9ID0gRnJhbWU7XG5cbk9iamVjdC5rZXlzKEVsZW1lbnRzKS5mb3JFYWNoKChjb21wb25lbnRzU2V0TmFtZSkgPT4ge1xuICAgIE9iamVjdC5rZXlzKEVsZW1lbnRzW2NvbXBvbmVudHNTZXROYW1lXSkuZm9yRWFjaCgoY29tcG9uZW50TmFtZSkgPT4ge1xuICAgICAgICBGcmFtZS5ub3RGb3JtVXRpbHMuYWRkQ29tcG9uZW50KFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIEVsZW1lbnRzW2NvbXBvbmVudHNTZXROYW1lXVtjb21wb25lbnROYW1lXVxuICAgICAgICApO1xuICAgIH0pO1xufSk7XG5cbmV4cG9ydCB7XG4gICAgc3ZlbHRlLFxuICAgIC8vVUlcbiAgICBFbGVtZW50cyxcbiAgICBVSUNvbW1vbixcbiAgICAvL2FwcGxpY2F0aW9uIGZyYW1ld29ya1xuICAgIEZyYW1lLFxuICAgIC8vc2hvcnRzIGZvciBjb21tb24gZWxlbWVudHNcbiAgICBub3RDb21tb24sXG4gICAgbm90Rm9ybVV0aWxzLFxuICAgIENPTVBPTkVOVFMsXG4gICAgRklFTERTLFxuICAgIFZBUklBTlRTLFxuICAgIC8vbG9jYWxpemF0aW9uXG4gICAgTG9jYWxlLFxuICAgIExPQ0FMRSxcbiAgICBzYXksXG4gICAgbm90TG9jYWxlLFxufTtcbiJdLCJuYW1lcyI6WyJib2xkIiwibm9ybWFsIiwidy5zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZSIsIncub3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24iLCJnZXQiLCJlLnN0YXRlX3Vuc2FmZV9tdXRhdGlvbiIsIncuaHlkcmF0aW9uX21pc21hdGNoIiwiZS5zdGF0ZV9kZXNjcmlwdG9yc19maXhlZCIsImUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkIiwidy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaCIsImUuZGVyaXZlZF9yZWZlcmVuY2VzX3NlbGYiLCJlLmVmZmVjdF9vcnBoYW4iLCJlLmVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWQiLCJlLmVmZmVjdF9pbl90ZWFyZG93biIsImlzX21pY3JvX3Rhc2tfcXVldWVkIiwiZS5lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkIiwiZS5zdGF0ZV91bnNhZmVfbG9jYWxfcmVhZCIsImUuaHlkcmF0aW9uX2ZhaWxlZCIsIncubGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50IiwiaW5kZXgiLCJ3Lmh5ZHJhdGlvbl9odG1sX2NoYW5nZWQiLCJlLmludmFsaWRfc25pcHBldCIsIncuaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIiLCJjbHN4IiwiX2Nsc3giLCJ3Lmh5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZCIsImxpbmVhciIsImUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlIiwiZ2V0X3N0b3JlIiwiZS5wcm9wc19yZXN0X3JlYWRvbmx5IiwiZS5wcm9wc19pbnZhbGlkX3ZhbHVlIiwiZS5ydW5lX291dHNpZGVfc3ZlbHRlIiwiZS5saWZlY3ljbGVfbGVnYWN5X29ubHkiLCJpbnB1dFZhbHVlc0V4dHJhY3RvcnMiLCJPYmplY3QiLCJmcmVlemUiLCJjaGVja2JveCIsImlucEVsIiwiZGVmYXVsdFZhbHVlIiwidW5kZWZpbmVkIiwiaGFzT3duIiwiY2hlY2tlZCIsInVuY2hlY2tlZCIsInZhbHVlIiwiVUlDb21tb24iLCJfY2xhc3NDYWxsQ2hlY2siLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJleHRyYWN0VmFsdWVGcm9tSW5wdXQiLCJ0eXBlIiwib25JbnB1dCIsImZpZWxkIiwib25jaGFuZ2UiLCJhZGRpdGlvbmFsIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImN1cnJlbnRUYXJnZXQiLCJpc0VudGVyRXZlbnQiLCJlIiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwib25seU9uRW50ZXIiLCJjYWxsYmFjayIsImlzTW9iaWxlIiwidGVzdE1vYmlsZSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJtc01hdGNoTWVkaWEiLCJ0ZXN0UXVlcnkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJtYXhfd2lkdGgiLCJNT0JJTEVfV0lEVEhfQlJFQUtfUE9JTlQiLCJtYXRjaGVzIiwicmVtb3ZlQm9keVNjcm9sbCIsImRvY3VtZW50IiwiYm9keSIsImNsYXNzTGlzdCIsImFkZCIsIlNDUk9MTF9ESVNBQkxFUl9DTEFTUyIsInJlc3RvcmVCb2R5U2Nyb2xsIiwicmVtb3ZlIiwiZm9ybWF0UGhvbmUiLCJ2YWwiLCJmaWxsZXIiLCJGSUxMRVIiLCJzbG90cyIsImRpZ2l0cyIsInJlcGxhY2UiLCJkIiwidW5zaGlmdCIsInN0YWNrIiwiQXJyYXkiLCJmcm9tIiwiZm9yRWFjaCIsImRpZ2l0Iiwic2xvdCIsImxlbnMiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwidCIsImRpZiIsInBhcnNlSW50Iiwic2V0TW9uZXlTaWduIiwiTU9ORVlfU0lHTiIsImZvcm1hdFByaWNlIiwicHJpY2UiLCJtYWpvciIsIk1hdGgiLCJmbG9vciIsIm1pbm9yIiwidG9TdHJpbmciLCJmb3JtYXRMb2NhbGVEYXRldGltZSIsImR0Iiwib3B0cyIsImRhdGUiLCJ0aW1lIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJ0cnlGb3JtYXRMb2NhbGVEYXRlVGltZSIsIkRhdGUiLCJmb3JtYXRUaW1lc3RhbXAiLCJ0aW1lc3RhbXAiLCJvZmZzZXQiLCJvZmZzZXRMb2NhbCIsImdldFRpbWV6b25lT2Zmc2V0IiwiZGVsdGFPZmZzZXQiLCJsb2NhbERhdGVUaW1lIiwidG9Mb2NhbGVTdHJpbmciLCJkZWNsT2ZOdW0iLCJuIiwidGV4dF9mb3JtcyIsImFicyIsIm4xIiwiaHVtYW5pemVkVGltZURpZmYiLCJjdXJyZW50VGltZSIsImdldFRpbWUiLCJzZWMiLCJyb3VuZCIsInVuaXQiLCJUSU1FIiwiU0VDT05EUyIsIm1pbiIsIk1JTlVURVMiLCJob3VycyIsIkhPVVJTIiwic3R5bGVzT2JqZWN0VG9TdHJpbmciLCJzdHlsZXMiLCJrZXlzIiwibWFwIiwicHJvcCIsImpvaW4iLCJzdHJpbmdPck51bWJlciIsImluZGV4T2YiLCJzdHJpbmdzT2ZOdW1iZXJzIiwibGlzdCIsImV2ZXJ5IiwiX2RlZmluZVByb3BlcnR5IiwidG9wIiwiYmVoYXZpb3IiLCIkLnJlc3RfcHJvcHMiLCIkLnVzZXJfZWZmZWN0IiwiJC5zZXQiLCJpbml0RGljdCIsInRhcmdldCIsImhhbmRsZXIiLCJSZWZsZWN0IiwiUHJveHkiLCJjcmVhdGVMb2NhbGUiLCJzdWJzY3JpYmUiLCJzZXQiLCJ1cGRhdGUiLCJ3cml0YWJsZSIsInJlc2V0IiwiTE9DQUxFIiwidGhpcyIsInNyYyIsIm5vdFBhdGgiLCJyZXF1aXJlJCQwIiwiaXNNZXJnZWFibGVPYmplY3QiLCJpc05vbk51bGxPYmplY3QiLCJpc1NwZWNpYWwiLCJzdHJpbmdWYWx1ZSIsInByb3RvdHlwZSIsImNhbGwiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIiQkdHlwZW9mIiwiZW1wdHlUYXJnZXQiLCJpc0FycmF5IiwiY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQiLCJvcHRpb25zQXJndW1lbnQiLCJjbG9uZSIsImRlZXBtZXJnZSIsImRlZmF1bHRBcnJheU1lcmdlIiwic291cmNlIiwiY29uY2F0IiwiZWxlbWVudCIsIm1lcmdlT2JqZWN0IiwiZGVzdGluYXRpb24iLCJzb3VyY2VJc0FycmF5IiwidGFyZ2V0SXNBcnJheSIsIm9wdGlvbnMiLCJhcnJheU1lcmdlIiwic291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCIsImFsbCIsImRlZXBtZXJnZUFsbCIsImFycmF5IiwiRXJyb3IiLCJwcmV2IiwibmV4dCIsIm5vdENvbW1vbiIsImlzRXJyb3IiLCJzdGF0dXMiLCJtdXRlIiwiRU5WX1RZUEUiLCJwYWQiLCJnZXRUb2RheURhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsIm9iakhhcyIsIm9iaiIsIm5hbWUiLCJjb3B5T2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicGFydENvcHlPYmoiLCJwYXJ0T2JqIiwiaW5jbHVkZXMiLCJjb21wYXJlVHdvQXJyYXlzIiwiYSIsImIiLCJpc0Z1bmMiLCJmdW5jIiwiaXNBc3luYyIsImNvbnN0cnVjdG9yIiwiZXhlY3V0ZU9iamVjdEZ1bmN0aW9uIiwicGFyYW1zIiwicHJvYyIsIm1hcEJpbmQiLCJ0byIsIml0ZW0iLCJiaW5kIiwiaXNDbGFzcyIsImZuIiwidGVzdCIsImRldGVjdFR5cGUiLCJ0ZXN0aWUiLCJkYXRhIiwibG9jYWxJc29EYXRlIiwibG9jYWxJc29TdHJpbmciLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0VG9kYXkiLCJ0b2RheSIsImJhY2tsb2dBZGQiLCJtc2ciLCJiYWNrbG9nIiwicHVzaCIsImR1bXBCYWNrbG9nIiwicm93Iiwic2hpZnQiLCJMT0ciLCJsb2dNc2ciLCJub3ciLCJsb2ciLCJjcmVhdGVMb2dnZXIiLCJwcmVmaXgiLCJnZW5Mb2dNc2ciLCJlcnJvciIsImdlbkxvZ0Vycm9yIiwiZGVidWciLCJnZW5Mb2dEZWJ1ZyIsInJlcG9ydCIsImlzRGV2IiwiREVWX0VOViIsIk5PT1AiLCJsb2dFcnJvciIsImdldEFwcCIsInJlcG9ydGVyIiwiZ2V0U2VydmljZSIsImNhdGNoIiwidHJhY2UiLCJ0cmltQmFja3NsYXNoIiwic3RyIiwic3Vic3RyaW5nIiwiYnVpbGRVUkwiLCJtb2R1bGUiLCJtb2RlbCIsImlkIiwiYWN0aW9uIiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZmlsdGVyIiwiZWwiLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwibG93ZXJGaXJzdExldHRlciIsInN0cmluZyIsInRvTG93ZXJDYXNlIiwic3RyTGVuZ3RoQ2FwIiwiTUFYX1RJVExFX0xFTkdUSCIsIlBPU1RfRklYIiwic3Vic3RyIiwiZXNjYXBlSHRtbCIsInVuc2FmZSIsInN0YXJ0QXBwIiwic3RhcnRlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJleHRlbmRBcHBDb25maWciLCJjb25mIiwiY29uZjIiLCJkZWVwTWVyZ2UiLCJhYnNvcmJNb2R1bGUiLCJkZWZhdWx0Q29uZiIsIm1vZCIsInRhcmdldHMiLCJoYXNPd25Qcm9wZXJ0eSIsInNlcnZpY2VzIiwidWlzIiwid2NzIiwibWFuaWZlc3QiLCJjb250cm9sbGVycyIsIm5vdEVudiIsImRlZmluZUlmTm90RXhpc3RzIiwicmVnaXN0ZXIiLCJyZWdpc3RyeSIsIm1vdmVJdGVtIiwib2xkX2luZGV4IiwibmV3X2luZGV4IiwiaW5SYW5nZSIsIm51bSIsInNwbGljZSIsInN0cmlwUHJveHkiLCJpc1Byb3h5IiwiYXNzaWduIiwicGlwZSIsImZ1bmNzIiwicmVzdWx0IiwiZ2V0QVBJIiwiZ2V0TWFuYWdlciIsInNldE1hbmFnZXIiLCJ2IiwiTUFOQUdFUiIsImdldEpTT04iLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJ3YWl0IiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiLCJyZWdpc3RlcldpZGdldEV2ZW50cyIsImV2ZW50cyIsImV2ZW50TmFtZSIsIm9uIiwibmF2aWdhdGUiLCJnZXRXb3JraW5nIiwic2VsZWN0IiwidmFyaWFudHNTZXQiLCJkZWYiLCJfbm90Q29tbW9uIiwiTk9UX0VOVl9UWVBFIiwiYWJzb3JiU2VydmljZXMiLCJzZXJ2IiwiZXh0ZW5kV1NDbGllbnQiLCJ3c2NOYW1lIiwid3NjT3B0aW9ucyIsImNvbm5lY3Rpb24iLCJyb3V0ZXIiLCJyb3V0ZXMiLCJtZXNzZW5nZXIiLCJyb3V0ZVR5cGUiLCJhYnNvcmJXU0MiLCJ3c0NsaWVudE5hbWUiLCJhYnNvcmJVSXMiLCJ1aSIsImFic29yYkZpZWxkcyIsIm5vdExvY2FsZSIsIl9FdmVudEVtaXR0ZXIiLCJfdGhpcyIsIl9jYWxsU3VwZXIiLCJkaWN0IiwiaGVscGVycyIsInJlc3RvcmVGcm9tU3RvcmFnZSIsIl9pbmhlcml0cyIsImZvcm1hdCIsInBhcnNlU3VicyIsInNheSIsInBocmFzZSIsInRtcGwiLCJzYXZlVG9TdG9yYWdlIiwiZW1pdCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJnZXRJdGVtIiwidm9jYWJ1bGFyeSIsIkV2ZW50RW1pdHRlciIsIiQucHJvcCIsIiQuZGVyaXZlZCIsIiQucHJveHkiLCIkLnNuYXBzaG90IiwiJC5zZXRfdGV4dCIsIlVJQm9vbGVhbiIsIiQuc3RhdGUiLCIkLmVhY2giLCIkLmdldCIsIiQuc25pcHBldCIsIiQuYmluZF90aGlzIiwiJC5zZXRfY2xhc3MiLCIkLnRlbXBsYXRlX2VmZmVjdCIsIiQuY2xzeCIsIm9uQ2xpY2siLCJVSUJ1dHRvbiIsIlVJQnV0dG9uU3dpdGNoIiwiJC5zcHJlYWRfcHJvcHMiLCJVSUJ1dHRvbnMiLCIkLm11dGFibGVfc3RhdGUiLCJ0ZXh0IiwiJC5tdXRhdGUiLCIkLmV2ZW50IiwiJC53aW5kb3ciLCIkLmRlcml2ZWRfc2FmZV9lcXVhbCIsIiQucHJldmVudERlZmF1bHQiLCIkLnRvZ2dsZV9jbGFzcyIsIiQuYW5pbWF0aW9uIiwiJC50cmFuc2l0aW9uIiwiJC5odG1sIiwiVUlDaGVja2JveElucHV0IiwiJC5iaW5kX3ZhbHVlIiwiTGliIiwic2VlZExpYiIsIl9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjIiwiX2xpYiIsImltcG9ydCIsImdldENvbnRlbnQiLCJjb21wIiwibW9kZSIsImNvbnRhaW5zIiwiX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwiYnVsayIsImYiLCJpc0VtcHR5IiwiQ09NUE9ORU5UUyIsIkZJRUxEUyIsIlZBUklBTlRTIiwiVUlMaW5rIiwiVUlUaXRsZSIsIiQuc2V0X2F0dHJpYnV0ZSIsIlVJTGlzdEl0ZW0iLCJVSUxpc3RFbXB0eVBsYWNlaG9sZGVyIiwiVUlJbWFnZSIsIlVJTGlzdCIsIkRFRkFVTFRfU1RBVFVTX1NVQ0NFU1MiLCJOQVZJR0FUSU9OX0RFTEFZX1NIT1JUIiwiTkFWSUdBVElPTl9ERUxBWV9OT1JNQUwiLCJOQVZJR0FUSU9OX0RFTEFZX0xPTkciLCJOQVZJR0FUSU9OX0RFTEFZUyIsIlNIT1JUIiwiTk9STUFMIiwiTE9ORyIsIk5BVklHQVRJT05fREVMQVlfREVGQVVMVCIsIlVJQnV0dG9uc1JvdyIsIiQudXBkYXRlX3Byb3AiLCJVSUVuZGxlc3NMaXN0U2ltcGxlSXRlbSIsIlVJRW5kbGVzc0xpc3RFbXB0eVBsYWNlaG9sZGVyIiwiVUlFbmRsZXNzTGlzdE5hdmlnYXRpb24iLCJMaXN0R3JvdXBzVUlUcmVlRFRPIiwiY29udmVydEdyb3VwVGl0bGUiLCJ0aXRsZSIsImNvbnZlcnRHcm91cEltYWdlIiwiaW1hZ2UiLCJjb252ZXJ0VmFyaWFudCIsInZhcmlhbnQiLCJncm91cElkIiwidmFsdWVJZCIsImNvbnZlcnRWYXJpYW50c0dyb3VwIiwiZ3JvdXAiLCJkZXNjcmlwdGlvbiIsInZhbHVlcyIsInZhcmlhbnRzIiwiaXRtIiwiYnVpbGRTZWxlY3Rvckl0ZW1zRnJvbVZhcmlhbnRzIiwiX3RoaXMyIiwic3VibGltZVZhbHVlIiwiZ2V0U2VsZWN0b3JHcm91cEluZGV4Iiwic2VsZWN0b3JHcm91cHNJdGVtcyIsImZpbmRJbmRleCIsImdldFNlbGVjdG9yR3JvdXAiLCJzZWxlY3Rvckdyb3VwSGFzVmFyaWFudHMiLCJnZXRTZWxlY3Rvckdyb3VwVmFyaWFudHMiLCJjb21wYXJlU2VsZWN0b3JHcm91cFZhbHVlSWRXaXRoIiwidmFyaWFudElkIiwiZ2V0U2VsZWN0b3JJdGVtSW5kZXgiLCJncm91cEluZGV4IiwiaXRlbUluZGV4IiwiZ2V0U2VsZWN0b3JJdGVtSW5kZXhlcyIsImdldFNlbGVjdG9ySXRlbSIsIml0ZW1JZHMiLCJpbmRleGVzIiwiZ3JvdXBWYXJpYW50cyIsImdldERlZmF1bHRTZWxlY3Rvckl0ZW1TdWJsaW1lIiwidXBkYXRlU2VsZWN0b3JJdGVtIiwiaXRlbVByb3BzIiwiYWN0aW9uc1VJUHJvcHMiLCJhY3Rpb25zIiwidWlQcm9wcyIsInVpT24iLCJVSV9QUk9QU19ERUxUQV9PTiIsIlVJX1BST1BTX0RFTFRBX09OX0FDVElPTiIsInVpT2ZmIiwiVUlfUFJPUFNfREVMVEFfT0ZGIiwiVUlfUFJPUFNfREVMVEFfT0ZGX0FDVElPTiIsInN5bmNVSVdpdGhWYWx1ZSIsInNlbGVjdG9yR3JvdXBzIiwiaXRlbUluVmFsdWUiLCJpdGVtcyIsImNsYXNzIiwiY29sb3IiLCJMaXN0R3JvdXBzVmFsdWVEVE9NdWx0aXBsZUJlaGF2aW91ciIsImNvdW50SXRlbXNJblZhbHVlIiwiaW5pdFZhbHVlIiwiZ3JvdXBJdGVtc0lzVmFsaWQiLCJncm91cEl0ZW1zIiwiY2xlYXJGcm9tRW1wdHlHcm91cHMiLCJncm91cElzRW1wdHkiLCJncm91cElzRnVsbCIsInZhbHVlR3JvdXAiLCJ2YXJpYW50c0dyb3VwIiwicmVtb3ZlSXRlbUZyb21WYWx1ZSIsImF0TGVhc3RPbmUiLCJhZGRJdGVtVG9WYWx1ZSIsIm9ubHlPbmVQZXJHcm91cCIsInNlbGVjdEFsbCIsInNlbGVjdE5vbmUiLCJzZWxlY3RBbGxJbkdyb3VwIiwiX3RoaXMzIiwiZmluZCIsInNlbGVjdE5vbmVJbkdyb3VwIiwidmFsdWVBc1ZhcmlhbnRzIiwiX3RoaXM0IiwiTGlzdEdyb3Vwc1ZhbHVlRFRPU2luZ2xlQmVoYXZpb3VyIiwiTGlzdEdyb3Vwc1ZhbHVlRFRPIiwiYmVoYXZpb3VyIiwibXVsdGlwbGUiLCJ0b2dnbGUiLCJjb25zb2xlIiwiVUlCdXR0b25zU3dpdGNoZXJzIiwiVUlCdXR0b25DbG9zZSIsIlVJU2ltcGxlU2VhcmNoSW5wdXQiLCJVSUVuZGxlc3NMaXN0IiwiTUVUQV9NRVRIT0RfSU5JVCIsIk1FVEFfREFUQSIsIk1FVEFfV09SS0lORyIsIk1FVEFfT1BUSU9OUyIsIm5vdEJhc2UiLCJpbnB1dCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2V0RGF0YSIsInNldFdvcmtpbmciLCJ3b3JraW5nIiwic2V0T3B0aW9ucyIsImluZm8iLCJzZXRDb21tb24iLCJ3aGF0IiwiYXJncyIsImdldENvbW1vbiIsImdldERhdGEiLCJnZXRPcHRpb25zIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50IiwiT1BUX01PREVfSElTVE9SWSIsIk9QVF9NT0RFX0hBU0giLCJPUFRfREVGQVVMVF9DSEVDS19JTlRFUlZBTCIsIm5vdFJvdXRlciIsIl9ub3RCYXNlIiwicm9vdCIsImluaXRpYWxpemVkIiwiZGVsYXlzIiwiZGVsYXlfZGVmYXVsdCIsInNldERlbGF5cyIsInNldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkiLCJkZWxheSIsImRlbGF5QXNNcyIsImdldERlZmF1bHROYXZpZ2F0aW9uRGVsYXkiLCJuYXZpZ2F0ZVdpdGhEZWxheSIsImRvQmVmb3JlIiwiaGlzdG9yeSIsImhhc2giLCJzZXRSb290IiwiY2xlYXJTbGFzaGVzIiwicGF0aCIsInJlIiwicnVsZSIsImFkZExpc3QiLCJwYXJhbSIsImkiLCJyIiwiZmx1c2giLCJpc0luaXRpYWxpemVkIiwic2V0SW5pdGlhbGl6ZWQiLCJnZXRGcmFnbWVudCIsImZyYWdtZW50IiwibG9jYXRpb24iLCJkZWNvZGVVUkkiLCJwYXRobmFtZSIsInNlYXJjaCIsIm1hdGNoIiwiaHJlZiIsImNoZWNrTG9jYXRpb24iLCJjdXJyZW50IiwiaW5pdCIsImNoZWNrIiwiaHJlZkNsaWNrIiwiZ2V0Um9vdCIsImxpc3RlbiIsImxvb3BJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImZhaWxCYWNrIiwiZnVsbFJFIiwicm91dGUiLCJhcHBseSIsImhvc3QiLCJyZWZyZXNoIiwidGltZW91dCIsIm5ld1JvdXRlIiwiZ2V0RnVsbFJvdXRlIiwibGFzdFJvdXRlIiwicHVzaFN0YXRlIiwiZ2V0QWxsTGlua3MiLCJhbGxFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqIiwiYXR0cyIsImF0dHJpYnV0ZXMiLCJub2RlTmFtZSIsInJlUm91dGVFeGlzdGVkIiwiaW5pdFJlcm91dGluZyIsImdldEF0dHJpYnV0ZSIsImxpbmsiLCJub3RSb3V0ZXJJbml0aWFsaXplZCIsImZ1bGxMaW5rIiwic2V0QXR0cmlidXRlIiwiTE9HX1BSRUZJWCIsIm5vdEFQSVF1ZXVlIiwiYnVzeSIsInF1ZXVlIiwiYnVzeVNpbmNlIiwiYWZ0ZXJFbXB0eSIsInN0YXJ0Iiwic3RvcCIsImludGVydmFsIiwiY2hlY2tRdWV1ZSIsIlFVRVVFX0NIRUNLX0lOVEVSVkFMIiwiaXNCdXN5Iiwic2V0QnVzeSIsInJ1bk5leHQiLCJzZXRGcmVlIiwiYWRkVG9RdWV1ZSIsInRhc2siLCJyZXNvbHZlIiwiTUFYX0JVU1lfVElNRSIsInJ1biIsInJlamVjdCIsImFjdGlvbklzUXVldWVkIiwic29tZSIsInF1ZXVlZCIsInJ1bklmTm90UXVldWVkIiwibm90QVBJT3B0aW9ucyIsInJwcyIsInByb3RvY29sIiwicG9ydCIsIm5vdEFQSUNvbm5lY3Rpb24iLCJvbmxpbmUiLCJpbnQiLCJwYXVzZSIsInJlc3VtZSIsImlzT25saW5lIiwib25MaW5lIiwiY2hhbmdlU3RhdGUiLCJBTEwiLCJleGlzdCIsImNyZWF0ZSIsInByb3BzIiwicmF3IiwiZmlsdGVyZWQiLCJzZWxlY3RlZCIsImZha2UiLCJNRVRBX0lOVEVSRkFDRSIsIk1FVEFfTUFQX1RPX0lOVEVSRkFDRSIsIkRFRkFVTFRfQUNUSU9OX1BSRUZJWCIsIk9QVF9ERUZBVUxUX0lOREVYX0ZJRUxEX05BTUVfUFJJT1JJVFkiLCJERUZBVUxUX0ZJTFRFUiIsIkRFRkFVTFRfU0VBUkNIIiwiREVGQVVMVF9SRVRVUk4iLCJERUZBVUxUX1BBR0VfTlVNQkVSIiwiREVGQVVMVF9QQUdFX1NJWkUiLCJERUZBVUxUX1dTX1JPVVRFX0FDVElPTl9TUExJVFRFUiIsIm5vdEludGVyZmFjZSIsInJldHVybiIsInBhZ2VyIiwic2l6ZSIsInBhZ2UiLCJpbml0QWN0aW9ucyIsImdldEFjdGlvbnNDb3VudCIsImdldEFjdGlvbnMiLCJhY3Rpb25OYW1lIiwiaW5pdEFjdGlvbiIsImhlYWRlcnMiLCJmaWxlVXBsb2FkIiwiZmlsZXMiLCJyZXF1ZXN0IiwicmVxdWVzdEhUVFAiLCJyZWNvcmQiLCJjb21wb3NpdGVEYXRhIiwiYWN0aW9uRGF0YSIsImdldEFjdGlvbkRhdGEiLCJyZXF1ZXN0UGFyYW1zIiwiY29sbGVjdFJlcXVlc3REYXRhIiwicmVxdWVzdFBhcmFtc0VuY29kZWQiLCJlbmNvZGVSZXF1ZXN0IiwiYXBpU2VydmVyVVJMIiwiZ2V0U2VydmVyVVJMIiwiZ2V0VVJMIiwiZmQiLCJGb3JtRGF0YSIsImFwcGVuZCIsIm1ldGhvZCIsIkFjY2VwdCIsInJlcXVlc3RXUyIsIldTIiwiZ2V0V1NDbGllbnQiLCJtZXNzYWdlTmFtZSIsImdldFdTUmVxdWVzdE5hbWUiLCJwYXlsb2FkIiwibWVzc2FnZSIsInNlbGVjdFRyYW5zcG9ydCIsIndzSXNVcCIsIndzIiwiY2xpZW50Iiwid3NDbGllbnQiLCJnZXRNb2RlbE5hbWUiLCJwYXJzZVBhcmFtcyIsImVuZCIsImxpbmUiLCJmaWVsZE5hbWUiLCJsZW4iLCJpbmQiLCJzdGFydFNsaWNlIiwiZW5kU2xpY2UiLCJwYXJzZUxpbmUiLCJwb3N0Rml4IiwibW9kZWxOYW1lIiwicCIsInJlcXVlc3REYXRhIiwiZGF0YVByb3ZpZGVyTmFtZSIsImdldElEIiwicmVzdWx0SWQiLCJwcmVmaXhlcyIsInByZSIsInNldEZpbmRCeSIsInNldEZpbHRlciIsImZpbHRlckRhdGEiLCJyZXNldEZpbHRlciIsImdldEZpbHRlciIsInNldFNlYXJjaCIsInNlYXJjaERhdGEiLCJyZXNldFNlYXJjaCIsImdldFNlYXJjaCIsInNldFNvcnRlciIsInNvcnRlckRhdGEiLCJyZXNldFNvcnRlciIsImdldFNvcnRlciIsInNldFJldHVybiIsInJldHVybkRhdGEiLCJyZXNldFJldHVybiIsImdldFJldHVybiIsInNldFBhZ2VOdW1iZXIiLCJwYWdlTnVtYmVyIiwic2V0UGFnZVNpemUiLCJwYWdlU2l6ZSIsInNldFBhZ2VyIiwiaXNOYU4iLCJyZXNldFBhZ2VyIiwiZ2V0UGFnZXIiLCJnZXRSZWNvcmQiLCJnZXREZWZhdWx0QXNQbGFpbk9iamVjdCIsImZpZWxkcyIsImRlZmF1bHQiLCJub3RSZWNvcmQiLCJpc1JlY29yZCIsImlzUHJvcGVydHkiLCJjcmVhdGVDb2xsZWN0aW9uIiwiaW50ZXJmYWNlVXAiLCJtYXBUb0ludGVyZmFjZSIsIm1hcFRvTWV0aG9kcyIsInRvRGVmYXVsdCIsInJlYyIsImFwcCIsIm1ldGhvZHMiLCJjb2xsZWN0aW9uIiwiYWN0aW9uVXAiLCJzZXRBdHRyIiwic2V0QXR0cnMiLCJvYmplY3RQYXJ0IiwiZ2V0QXR0ciIsInBsYWluIiwicHJ4IiwiZ2V0QXR0cnMiLCJnZXRNYW5pZmVzdCIsIk9QVF9DT05UUk9MTEVSX1BSRUZJWCIsIk9QVF9SRUNPUkRfUFJFRklYIiwiREVGQVVMVF9XU19DTElFTlRfTkFNRSIsIm5vdEFwcCIsImludGVyZmFjZXMiLCJpbml0Q29udHJvbGxlciIsImN1cnJlbnRDb250cm9sbGVyIiwid3NjIiwid3NzIiwiaW5pdE1hbmlmZXN0Iiwic2V0SW50ZXJmYWNlTWFuaWZlc3QiLCJpbml0Um91dGVyIiwiZXhlY1JvdXRlciIsInJvdXRpZUlucHV0Iiwicm91dGVCbG9jayIsInBhdGhzIiwic2NoZW1lcyIsImNvbnRyb2xsZXIiLCJwYXRoU2NoZW1lIiwiYmluZENvbnRyb2xsZXIiLCJnZXRJbnRlcmZhY2VNYW5pZmVzdCIsInVwZGF0ZUludGVyZmFjZXMiLCJpbml0U2VydmljZXMiLCJjb250cm9sbGVyTmFtZSIsImNvbnRyb2xsZXJQYXRoU2NoZW1lIiwiZ2V0Q3VycmVudENvbnRyb2xsZXIiLCJzZXRDdXJyZW50Q29udHJvbGxlciIsImN0cmwiLCJvbGRDdHJsIiwiY3JlYXRlSW50ZXJmYWNlTW9kZWxGYWN0b3J5IiwicmVjb3JkTWFuaWZlc3QiLCJyZWNvcmREYXRhIiwiY2xlYXJJbnRlcmZhY2VzIiwibWFuaWZlc3RzIiwicmVjb3JkTWV0aG9kcyIsIm5hbWVJbnQiLCJzZXRJbnRlcmZhY2UiLCJnZXRSZWNvcmROYW1lIiwiZ2V0Q29udHJvbGxlck5hbWUiLCJtb2RlbEZhY3RvcnkiLCJnZXRJbnRlcmZhY2VzIiwic2V0V1NDbGllbnQiLCJnZXRJbnRlcmZhY2UiLCJnZXRNb2RlbCIsInNldFNlcnZpY2UiLCJzZXJ2TmFtZSIsInNlcnZUeXBlIiwiZ2V0Q29uZmlnUmVhZGVyRm9yTW9kdWxlIiwibW9kdWxlTmFtZSIsIm1vZENvbmZQYXRoIiwic3ViUGF0aCIsImZhbGxiYWNrIiwibW9kdWxlQ29uZmlnIiwiT1BUX0RFRkFVTFRfQUNUSU9OX05BTUUiLCJPUFRfREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IiLCJPUFRfREVGQVVMVF9QTFVSQUxfTkFNRSIsIk9QVF9ERUZBVUxUX1NJTkdMRV9OQU1FIiwiT1BUX0RFRkFVTFRfTU9EVUxFX05BTUUiLCJPUFRfREVGQVVMVF9BVVRPX05BTUUiLCJub3RDb250cm9sbGVyIiwicmVhZHkiLCJ2aWV3cyIsImxpYnMiLCJlbHMiLCJjb250YWluZXJTZWxlY3RvciIsIm5hbWVzIiwicGx1cmFsIiwic2luZ2xlIiwic2V0VVJMUHJlZml4IiwibWFrZSIsInVpTmFtZSIsIiRkZXN0cm95Iiwic2V0TW9kZWwiLCJzZXRNb2RlbE5hbWUiLCJnZXRNb2RlbElERmllbGROYW1lIiwic2V0TW9kZWxJREZpZWxkTmFtZSIsInNldFJlYWR5IiwidXBkYXRlQXV0b05hbWUiLCJnZXRVUkxQcmVmaXgiLCJzZXRNb2R1bGVOYW1lIiwiZ2V0TW9kdWxlTmFtZSIsImdldE1vZHVsZVByZWZpeCIsImdldE1vZGVsVVJMIiwiZ2V0TW9kZWxBY3Rpb25VUkwiLCJzZXROYW1lIiwiZ2V0TmFtZSIsInByZWxvYWRMaWIiLCIkbGlzdEFsbCIsImVyciIsIm9uQWZ0ZXJSZW5kZXIiLCJnZXRBY3Rpb25OYW1lIiwiZ2V0RGVmYXVsdEFjdGlvbk5hbWUiLCJyb3V0ZXJOYW1lIiwic3ViUGFyYW1zIiwic2V0Q3VycmVudEFjdGlvbiIsImdldEN1cnJlbnRBY3Rpb24iLCJnZXRBcHBPcHRpb25zIiwiZ2V0TW9kdWxlT3B0aW9ucyIsImdldFNlcnZpY2VzIiwiZ2V0Q29tcG9uZW50cyIsImdldFJvdXRlciIsIm5hdmlnYXRlQWN0aW9uIiwibmF2aWdhdGVNb2R1bGVBY3Rpb24iLCJuYXZpZ2F0ZU1vZGVsQWN0aW9uIiwiZ2V0Q29udHJvbGxlclJvdXRlIiwicGFyYW1zQ291bnQiLCJNT0RVTEVfTkFNRSIsIk1PREVMX05BTUUiLCJnZXRDb250cm9sbGVyUm91dGVzIiwicGFyYW1zRGVlcCIsImdldFJvdXRlcyIsIlBBUkFNU19MRU5HVEgiLCJnZXRDb21tb25NZW51IiwiY2hpbGRDb25zdHJ1Y3RvciIsInNlY3Rpb24iLCJMQUJFTFMiLCJnZXRNZW51IiwiU3RvcmVzLmdldCIsIiQuYmluZF9jaGVja2VkIiwiJC5zdG9yZV9tdXRhdGUiLCIkLnVudHJhY2siLCJDT05TVF9JRF9EVUJMSUNBVEVfUE9TVEZJWCIsIk9QVF9ERUZBVUxUX1BBR0VfU0laRSIsIk9QVF9ERUZBVUxUX1BBR0VfTlVNQkVSIiwiT1BUX0RFRkFVTFRfUEFHRV9SQU5HRSIsIk9QVF9ERUZBVUxUX1NPUlRfRElSRUNUSU9OIiwiT1BUX0RFRkFVTFRfU0VBUkNIIiwiT1BUX0RFRkFVTFRfUkVUVVJOIiwiT1BUX0RFRkFVTFRfQ09NQklORUQiLCJPUFRfREVGQVVMVF9DT01CSU5FRF9BQ1RJT04iLCJPUFRfREVGQVVMVF9DT1VOVF9BQ1RJT04iLCJPUFRfREVGQVVMVF9MSVNUX0FDVElPTiIsIk9QVF9ERUZBVUxUX1NPUlRfRklFTEQiLCJPUFRfRklFTERfTkFNRV9QUkVfUFJPQyIsIkRFRkFVTFRfT1BUSU9OUyIsIlVJVGFibGUiLCJsaW5rcyIsImVuZGxlc3MiLCJpZEZpZWxkIiwiZ2V0SXRlbUlkIiwiX2lkIiwibm90VGFibGUiLCJyYW5kb20iLCJyZWZpbmVkIiwic3RhdGUiLCJwYWdpbmF0aW9uIiwiY291bnQiLCJwYWdlcyIsInN0b3JlcyIsIlN0b3JlcyIsIm9uV29ya2luZ1VwZGF0ZSIsIm9uUmF3VXBkYXRlIiwib25GaWx0ZXJlZFVwZGF0ZSIsIm9uUmVmaW5lZFVwZGF0ZSIsIm9uU2VsZWN0ZWRVcGRhdGUiLCJvblN0YXRlVXBkYXRlIiwic2V0Q29tYmluZWRBY3Rpb25OYW1lIiwic29ydGVyIiwicmVuZGVyIiwidXBkYXRlRGF0YSIsInJlZmluZUZpbHRlcmVkIiwiY2xlYXJTZWxlY3RlZCIsIm9uU2VhcmNoQ2hhbmdlIiwib25Tb3J0ZXJDaGFuZ2UiLCJvbkZpbHRlckNoYW5nZSIsImdldFNlbGVjdGVkIiwib2JqZWN0Iiwic3RvcmUiLCJpbmR4IiwidGFibGUiLCJ0YXJnZXRFbCIsImZpbHRlclVJIiwiZ2V0SGVscGVycyIsImdldExpbmtzIiwic2hvd1NlbGVjdCIsInNob3dTZWFyY2giLCJzaG93U29ydCIsIiRvbiIsImRldGFpbCIsImdvVG9QYWdlIiwiZ29Ub05leHQiLCJnb1RvUHJldiIsIl90aGlzNSIsInNldFN0YXRlIiwiX3RoaXM2IiwiZ2V0U3RhdGUiLCJ3aXRob3V0SW52YWxpZGF0aW9uIiwiaW52YWxpZGF0ZURhdGEiLCJnZXREZWZhdWx0UGFnZU51bWJlciIsImdldERlZmF1bHRQYWdlU2l6ZSIsImdldFNvcnRlckRpcmVjdGlvbiIsInJldCIsImNsZWFyRmlsdGVyZWREYXRhIiwiY2xlYXJSYXdEYXRhIiwiY2xlYXJSZWZpbmVkRGF0YSIsImlzTGl2ZSIsInNldFVwZGF0aW5nIiwic2V0VXBkYXRlZCIsImlmVXBkYXRpbmciLCJnZXREYXRhSW50ZXJmYWNlIiwiZmFjdG9yeSIsImdldExvYWREYXRhQWN0aW9uTmFtZSIsImdldENvbWJpbmVkQWN0aW9uTmFtZSIsImdldENvdW50QWN0aW9uTmFtZSIsImxvYWREYXRhIiwicXVlcnkiLCJtYXgiLCJnb1RvRmlyc3QiLCJnb1RvTGFzdCIsInRlc3REYXRhSXRlbSIsInN0clZhbHVlIiwiayIsInRvQ29tcCIsImdldFJvd3NDb3VudCIsIl90aGlzNyIsInVwZGF0ZVBhZ2luYXRpb24iLCJpdGVtc0NvdW50IiwiX3RoaXM4IiwiaXRlbXNGcm9tIiwicGFnZXNDb3VudCIsInBhZ2VzRnJvbSIsInBhZ2VzVG8iLCJpdGVtc1RvIiwiYWN0aXZlIiwiX3RoaXM5IiwiZnVsbCIsInByb2Nlc3NEYXRhIiwiX3RoaXMxMCIsInRoYXRGaWx0ZXIiLCJmaWx0ZXJTZWFyY2giLCJ0aGF0U29ydGVyIiwic29ydCIsIml0ZW0xIiwiaXRlbTIiLCJ0MSIsInNvcnRCeUZpZWxkIiwidDIiLCJsb2NhbGVDb21wYXJlIiwic29ydERpcmVjdGlvbiIsImxvZ2dlciIsImNoZWNrRmllbGRzTmFtZXMiLCJmaWVsZElkIiwicGF0aElkIiwicmVhZEZpZWxkVmFsdWUiLCJfdGhpczExIiwicHJlcHJvY2Vzc2VkIiwiREVGQVVMVF9DT05UQUlORVJfU0VMRUNUT1IiLCJfdWlDb21wb25lbnQiLCJXZWFrTWFwIiwiX3VpIiwibm90QWN0aW9uVUkiLCJVSUFjdGlvbkNvbnRhaW5lciIsIl9jbGFzc1ByaXZhdGVGaWVsZFNldCIsImluaXRVSSIsImdldFRhcmdldEVsIiwiY2hpbGRyZW4iLCJyZW1vdmVDaGlsZCIsImZpcnN0Q2hpbGQiLCJzZXRMb2FkaW5nIiwicmVzZXRMb2FkaW5nIiwicHJvY2Vzc1Jlc3VsdCIsInNldEZvcm1TdWNjZXNzIiwic2V0Rm9ybUVycm9ycyIsInNob3dTdWNjZXNzIiwiZm9ybSIsImVycm9ycyIsInNob3dFcnJvciIsIkhUTUxFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIm5vdEZvcm1VdGlscyIsImFkZENvbXBvbmVudCIsImFkZFZhcmlhbnRzIiwiYWRkRmllbGQiLCJhY3Rpb25GaWVsZHNJbml0Iiwic3ViRmllbGROYW1lIiwiREVGQVVMVF9GSUVMRCIsImxhYmVsIiwicGxhY2Vob2xkZXIiLCJlbmFibGVkIiwidmlzaWJsZSIsInJlcXVpcmVkIiwidmFsaWRhdGVkIiwidmFsaWQiLCJmaWVsZEluaXQiLCJtdXRhdGlvbiIsInZhcmlhbnRzU291cmNlIiwiaW5pdEZvcm1CeUZpZWxkIiwiZm9ybUZpZWxkc09wdGlvbnMiLCJzdWJGb3JtRmllbGROYW1lIiwibXV0YXRpb25zIiwicmVhZG9ubHkiLCJzZXRGaWVsZEludmFsaWQiLCJzZXRGaWVsZFZhbGlkIiwiZm5hbWUiLCJpc0ZpZWxkVmFsaWQiLCJzZXRGb3JtRmllbGRJbnZhbGlkIiwiZm9ybUVycm9ycyIsImlucHV0U3RhcnRlZCIsImZvcm1MZXZlbEVycm9yIiwic2V0Rm9ybUZpZWxkVmFsaWQiLCJ1cGRhdGVGb3JtVmFsaWRhdGlvblN0YXR1cyIsInZhbGlkYXRpb25TdGF0dXMiLCJzZXRGaWVsZHNWaXNpYmlsaXR5IiwiZmllbGRzTGlzdCIsInNldEZpZWxkVmFsdWUiLCJmaWVsZElzVmlzaWJsZUFuZEZpbGxlZCIsImNvbGxlY3REYXRhIiwiZmxhdCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsIkRFRkFVTFRfUlVMRVMiLCJub3RSZWFkb25seSIsImVuYWJsZSIsImRpc2FibGVkIiwiZGlzYWJsZSIsIm5vdEZvcm1SdWxlcyIsIl9hc3NlcnRDbGFzc0JyYW5kIiwiX1JVTEVTIiwiXyIsImV4ZWMiLCJtYXN0ZXIiLCJzbGF2ZXMiLCJERUZBVUxUX0FDVElPTl9OQU1FIiwiX3ZhbGlkYXRpb25SdW5uZXIiLCJfZm9ybSIsIl9hY3Rpb24iLCJfZmllbGRzIiwiX3ZhcmlhbnRzIiwiX25vdEZvcm1fYnJhbmQiLCJXZWFrU2V0Iiwibm90Rm9ybSIsIlVJRm9ybUNvbXBvbmVudCIsIl9jbGFzc1ByaXZhdGVNZXRob2RJbml0U3BlYyIsImluaXRGb3JtIiwiaW5pdExpYnMiLCJpbml0RmllbGRzIiwiaW5pdFZhcmlhbnRzIiwiaW5pdFZhbGlkYXRvciIsInJlSW5pdCIsInVwZGF0ZVVJIiwiZ2V0Rm9ybU1hbmlmZXN0IiwiUnVubmVyIiwiZ2V0Rm9ybVZhbGlkYXRvcnMiLCJfZ2V0Rm9ybVByb3BzIiwiZm9ybU9wdGlvbnMiLCJnZXRGb3JtT3B0aW9ucyIsImdldEZvcm1EYXRhIiwiaW5qZWN0ZWRQcm9wcyIsImdldEZvcm1JbmplY3RlZFByb3BzIiwiZ2V0Rm9ybVRhcmdldEVsIiwiX2JpbmRVSUV2ZW50cyIsInZhbGlkYXRlRm9ybSIsIiRzZXQiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiZ2V0Rm9ybUFjdGlvbiIsImdldFJlcG9ydCIsImNsZWFuIiwiRVJST1JfREVGQVVMVCIsInN1Ym1pdCIsInNldEZvcm1BY3Rpb24iLCJnZXRWYXJpYW50IiwibGliIiwiX21pc3NpbmdPdmVycmlkZVdhcm5pbmciLCJ1cGRhdGVGaWVsZCIsImV2IiwiX2JpbmRNYXN0ZXJTbGF2ZUV2ZW50cyIsIm1hc3RlcnMiLCJydWxlcyIsInJ1bGVOYW1lIiwicnVsZVNsYXZlcyIsIl9hZGRNYXN0ZXJTbGF2ZUV2ZW50cyIsIl9leGVjU2xhdmVSdWxlIiwiY21kIiwic2xhdmVGaWVsZCIsIkZvcm1IZWxwZXJzIiwibG9hZGluZyIsIm1pc3NpbmciLCJERUZBVUxUX0ZPUk1fU0VUX05BTUUiLCJfZm9ybVNldENvbXBvbmVudCIsIl9mb3JtQ29tcG9uZW50IiwiX2ZyYW1lIiwiX25vdEZvcm1TZXRfYnJhbmQiLCJub3RGb3JtU2V0IiwiZm9ybUNvbXBvbmVudCIsImZvcm1TZXRDb21wb25lbnQiLCJVSUZvcm1TZXRDb21wb25lbnQiLCJzaG93TW9kZXMiLCJzZXRGb3JtTW9kZSIsImdldEZyYW1lVGFyZ2V0RWwiLCJfZ2V0RnJhbWVQcm9wcyIsInVwZGF0ZUZvcm0iLCJpc01vZGVFeGlzdHMiLCJnZXRGaXJzdE1vZGUiLCJ1cGRhdGVGb3JtTW9kZUluVUkiLCJnZXRGb3JtTW9kZSIsImRlc3Ryb3lGb3JtIiwicmVuZGVyRm9ybSIsImZvcm1Db25maWciLCJnZXRGb3JtQ29uZmlnIiwiY2hhbmdlTW9kZSIsImNvbnRhaW5lckVsIiwibGFzdENoaWxkIiwiZGVzdHJveUZyYW1lIiwiZm9ybXMiLCJub3RCcmVhZGNydW1icyIsIlVJQ29uc3RydWN0b3IiLCJnZXRCcmVhZGNydW1icyIsImdvIiwic2V0SGVhZCIsImhlYWQiLCJzZXRUYWlsIiwidGFpbCIsImNydW1icyIsIlVJQnJlYWRjcnVtYnMiLCJNZW51IiwiaGlkZSIsInNldEFwcCIsImdldE9wdGlvbnNQYXRoVG8iLCJpc0RpcmVjdE5hdmlnYXRpb24iLCJkaXJlY3ROYXZpZ2F0aW9uIiwiYnJhbmQiLCJzZWN0aW9ucyIsInRhcmdldFNlbGVjdG9yIiwidG9nZ2xlU2VsZWN0b3IiLCJvcGVuIiwiZ2V0Q29tcG9uZW50IiwiaW5pdEZpZWxkIiwiREVGQVVMVCIsInNvcnRMaXN0IiwicHJpb3JpdHkiLCJyZW1vdmVEdWJsaWNhdGVzIiwicHJlcGFyZURhdGEiLCJzZWN0aW9uVGl0bGUiLCJtZW51IiwidXBkYXRlSW5kaWNhdG9yIiwic2VjdGlvbklkIiwiaXRlbUlkIiwidXBkYXRlU2VjdGlvbiIsImluZGljYXRvciIsInVwZGF0ZUl0ZW0iLCJ1cGRhdGVUYWciLCJ0YWciLCJ1cGRhdGVTZWN0aW9uVGFnIiwidXBkYXRlSXRlbVRhZyIsInVwZGF0ZVNlY3Rpb25JdGVtcyIsIm9sZExpc3QiLCJpc1RvdWNoIiwiZ2V0U2VjdGlvbkNvbXBvbmVudCIsIl9NZW51IiwidXJscyIsInNob3J0IiwiVUlJY29uIiwiU2lkZU1lbnVTdGF0ZSIsIlRZUEUiLCJub3RTaWRlTWVudSIsImNyZWF0ZVVJIiwibW91bnQiLCJVSVNpZGVNZW51IiwiaW5pdFNpemVSZXNwb25zZSIsInVwZGF0ZU1lbnVBY3RpdmVJdGVtIiwiYmluZFRvZ2dsZSIsIml0ZW1Jc0FjdGl2ZSIsIml0ZW1VUkwiLCJ1cGRhdGVNZW51IiwibGFzdExvY2F0aW9uIiwibmF2IiwiYXNpZGUiLCJtYWluIiwicmVzaXplQXNpZGVBbmRNYWluIiwicmVzaXplTWFpbiIsInNob3ciLCJzdHlsZSIsImRpc3BsYXkiLCJtYXJnaW5MZWZ0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImhlaWdodCIsIndpZHRoIiwibGVmdCIsInJlc2l6ZUFzaWRlIiwiaW5uZXJIZWlnaHQiLCJtYXJnaW5Ub3AiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNPcGVuIiwiX25vdFNpZGVNZW51IiwiY2xvc2VkIiwiU2lkZU1lbnVTdG9yZSIsIlNpZGVNZW51Iiwibm90VG9wTWVudSIsIlVJTmF2YmFyVG9wIiwic2V0QnVyZ2VyU3RhdGUiLCJtZW51Q2xvc2VkIiwiX25vdFRvcE1lbnUiLCJwbGFjZSIsIkRFRkFVTFRfVFJBU0ZPUk1FUiIsIkFDVElPTiIsIlRJVExFIiwiZGF0YVByb3ZpZGVyIiwiZ29CYWNrIiwiX2NsYXNzIiwic2V0QnJlYWRjcnVtYnMiLCJwcmVsb2FkVmFyaWFudHMiLCIkZGVzdHJveVVJIiwicmVzdWx0VHJhbnNmb3JtZXIiLCJnZXRDb250YWluZXJJbm5lckVsZW1lbnQiLCJzaG93RXJyb3JNZXNzYWdlIiwiUFJFTE9BREFCTEUiLCJDUlVEVmFyaWFudHNQcmVsb2FkZXIiLCJwcmVsb2FkIiwibGliUHJvcHMiLCJwcm9tcyIsIk1vZGVsIiwicmVzdWx0cyIsInByb3BOYW1lIiwicmVzdWx0c0xpc3QiLCJERUZBVUxUX0FDVElPTiIsIm5vdENSVURSb3V0ZXIiLCJleHRyYWN0QWN0aW9uTmFtZSIsImFjdGlvbkhhbmRsZXJFeGlzdHMiLCJydW5BY3Rpb24iLCJDUlVETWVzc2FnZSIsInNldFVJIiwiVUlFcnJvciIsInN1Y2Nlc3MiLCJVSVN1Y2Nlc3MiLCJERUZBVUxUX0JSRUFEQ1JVTUJfVEFJTCIsIkNSVURHZW5lcmljQWN0aW9uIiwicHJlc2V0IiwiZ2V0QnJlYWRjcnVtYnNUYWlsIiwiYnJlYWRjcnVtYnNUYWlscyIsImRlYWZ1bHRCcmVhZGNydW1ic1RhaWwiLCJnZXRJZEZpZWxkIiwibG9hZERhdGFRdWVyeSIsImdldE1vZGVsQWN0aW9uTmFtZSIsIk1PREVMX0FDVElPTl9HRVQiLCJwcmVzZXRCcmVhZGNydW1icyIsImdldFRpdGxlIiwiY29udG9sbGVyIiwiZ2V0SXRlbVRpdGxlIiwiYnJlYWRjcnVtYnNUYWlsVGVtcGxhdGUiLCJpc1Jlc3BvbnNlQmFkIiwiZ2V0VmFsaWRhdG9ycyIsInByZXBhcmVVSU9wdGlvbnMiLCJkZXRhaWxzQWN0aW9uTmFtZSIsInZhbGlkYXRvcnMiLCJpbmplY3RlZCIsIlRSQU5TRk9STUVSIiwiZ2V0VUkiLCJzZXRVSUxvYWRpbmciLCJzZXRVSUxvYWRlZCIsInNldFVJRXJyb3IiLCJiaW5kVUlFdmVudHMiLCJiaW5kVUlFdmVudCIsImlzVUlSZW5kZXJlZCIsInR3ZWFrVUlPcHRpb25zIiwidWlDb21wb25lbnQiLCJyZW5kZXJMb2FkaW5nU2NyZWVuIiwicmVtb3ZlTG9hZGluZ1NjcmVlbiIsImdvQmFja0FmdGVyRGVsYXkiLCJOQVZJR0FUSU9OX0RFTEFZIiwiQ1JVREdlbmVyaWNBY3Rpb25DcmVhdGUiLCJfQ1JVREdlbmVyaWNBY3Rpb24iLCJkZWZEYXRhIiwiY3JlYXRlRGVmYXVsdCIsIm9uQWN0aW9uU3VibWl0IiwiQ1JVREFjdGlvbkNyZWF0ZSIsIl9DUlVER2VuZXJpY0FjdGlvbkNyZSIsIkNSVURHZW5lcmljQWN0aW9uUmVhZCIsIkNSVURBY3Rpb25EZXRhaWxzIiwiX0NSVURHZW5lcmljQWN0aW9uUmVhIiwiQ1JVREdlbmVyaWNBY3Rpb25VcGRhdGUiLCJNT0RFTF9BQ1RJT05fUFVUIiwiQ1JVREFjdGlvblVwZGF0ZSIsIl9DUlVER2VuZXJpY0FjdGlvblVwZCIsIk1PREVMX0FDVElPTiIsIkNSVURBY3Rpb25EZWxldGUiLCJsb2FkZXJBY3RpdmUiLCJsb2FkZXJTdHlsZSIsImxvYWRlclRpdGxlIiwiY29udGFpbmVyIiwiY29uZmlybSIsImRlbGV0ZUFjdGlvbk5hbWUiLCJnb0xpc3QiLCJDUlVEQWN0aW9uTGlzdCIsInR3ZWFrQWN0aW9uc0xpc3QiLCJBQ1RJT05TX0xJU1QiLCJnb0NyZWF0ZSIsImNyZWF0ZUFjdGlvbnNCdXR0b25zIiwicHJlcGVuZCIsIm9ubHlJY29ucyIsIkFDVElPTlMiLCJkZXRhaWxzIiwiZ29EZXRhaWxzIiwiaWNvbiIsImdvVXBkYXRlIiwiZGVsZXRlIiwiZ29EZWxldGUiLCJhY3Rpb25zQnV0dG9ucyIsInByZXBhcmVPcHRpb25zIiwiREVGQVVMVF9PUFRJT05TX1RBQkxFIiwiaW50ZXJmYWNlIiwiY29tYmluZWQiLCJUQUJMRV9PUFRJT05TIiwib3B0VmFsIiwiQlJFQURDUlVNQlMiLCJUSVRMRV9GSUVMRFNfUFJJT1JJVFkiLCJMT0FESU5HX1NDUkVFTl9VSV9OQU1FIiwiX2FjdGlvbnMiLCJfcm91dGVyIiwiX3ByZWxvYWRlciIsIm5vdENSVUQiLCJfbm90Q29udHJvbGxlciIsInByZWxvYWRlciIsIkNSVURBY3Rpb25zIiwiQ1JVRFJvdXRlciIsImJ1aWxkRnJhbWUiLCJzZXRWYWxpZGF0b3JzIiwiTW9kdWxlTmFtZVBhcnRzIiwic3BsaXQiLCJNb2R1bGVOYW1lIiwic2VydmljZU5hbWUiLCJDb21tb25Nb2R1bGVTZXJ2aWNlIiwiYXVnbWVudFZhbGlkYXRvcnMiLCJuZXdIZWFkIiwic3RhcnRXaGVuV1NDbGllbnRSZWFkeSIsImlzQ29ubmVjdGVkIiwib25jZSIsIldTX0NIRUNLX0lOVEVSVkFMIiwiYmFja1RvTGlzdCIsImxpbmtCYWNrVG9MaXN0IiwiYWZ0ZXJBY3Rpb24iLCJuYXZCYWNrIiwiYmFjayIsImNyZWF0ZUVsZW1lbnQiLCJnZXRGcmFtZUNsYXNzZXMiLCJUT1BfQ0xBU1MiLCJhcHBlbmRDaGlsZCIsIk1BSU5fQ0xBU1MiLCJib3R0b20iLCJCT1RUT01fQ0xBU1MiLCJnZXRDb250YWluZXJUb3BFbGVtZW50IiwiZ2V0Q29udGFpbmVyQm90dG9tRWxlbWVudCIsImdldFRpdGxlRnJvbUxpYiIsImdldFByZWxvYWRlZFZhcmlhbnRUaXRsZSIsImdldFByZWxvYWRlZFZhcmlhbnRzIiwiZ29BZnRlckRlbGF5IiwiYWN0aW9uVUkiLCJkZXN0cm95VUlCeU5hbWUiLCJzaG93U3VjY2Vzc01lc3NhZ2UiLCJzaW5nbGVVSSIsImdldEFjdGlvblVJIiwiY3JlYXRlTG9hZGVyVUkiLCJVSUxvYWRlciIsIml0ZW1DdXN0b21Qcm9wcyIsIlJPVVRFX0xJU1QiLCJub3RDUlVEUGxhaW5Sb3V0ZXIiLCJERUZBVUxUX1JPVVRFIiwibm90Q1JVRFJvdXRlclN3aXRjaCIsImlzUm91dGVWYXJpYW50VmFsaWQiLCJyb3V0ZXNWYXJpYW50cyIsImRldGVybWluZVJvdXRlIiwicm91dGVyQWN0aW9uIiwiZW1wdHlSZXN1bHQiLCJza2lwIiwibm90U2VydmljZU1vZGVsU2VhcmNoIiwiZ2V0U2VhcmNoUm91dGVOYW1lIiwiZ2V0RGF0YUxvYWRSb3V0ZU5hbWUiLCJ0cmFuc2Zvcm1TZWFyY2hSZXN1bHQiLCJ1c2VybmFtZSIsInRyYW5zZm9ybVNlbGVjdGVkUmVzdWx0Iiwic2VhcmNoQnlUZXJtIiwidGVybSIsIm9wZW5TZWxlY3RvciIsIlVJR2VuZXJpY1NlbGVjdG9yIiwidW5tb3VudCIsIm5jQ1JVRCIsIkxvY2FsZSIsIkVsZW1lbnRzIiwiRnJhbWUi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aUNBQWlDLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDaEUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUM7O0NBRTFCLEdBQUcsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO0NBQzFCLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDO0NBQzlCOztDQUVBLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtDQUM3QyxJQUFJLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDMUIsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUU7Q0FDcEIsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFPLEVBQUUsS0FBSyxDQUFDO0NBQzFFO0NBQ0E7O0NBRUEsR0FBRyxPQUFPLElBQUk7Q0FDZDs7Q0FFQSxFQUFFLElBQUksZ0JBQWdCLENBQUMsS0FBSyxDQUFDLEtBQUssZ0JBQWdCLEVBQUU7Q0FDcEQ7Q0FDQSxHQUFHLElBQUksR0FBRyxFQUFFO0NBQ1osR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUM7O0NBRTFCLEdBQUcsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO0NBQzFCLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDO0NBQzlCOztDQUVBLEdBQUcsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7Q0FDMUI7Q0FDQSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sRUFBUSxDQUFDLEVBQUUs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RSxHQUFHLEVBQUUsS0FBSyxFQUFFO0NBQ3pCLEVBQUUsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNO0NBQzdCLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRTtDQUNkLEdBQUcsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDMUIsR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0NBQzlCLEdBQUcsTUFBTSxJQUFJLEdBQUcsY0FBYyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7Q0FDdEMsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO0NBQ3pCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7Q0FDbkIsSUFBSSxPQUFPLElBQUk7Q0FDZjtDQUNBO0NBQ0EsRUFBRSxPQUFPLEtBQUs7Q0FDZCxFQUFFO0NBQ0YsQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFO0NBQ3ZDLEVBQUUsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNO0NBQzdCLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRTtDQUNkLEdBQUcsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDMUIsR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0NBQzlCLEdBQUcsSUFBSSxPQUFPLENBQUMsS0FBSyxRQUFRLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFO0NBQ3hELElBQUksTUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUM7Q0FDN0MsSUFBSSxJQUFJLFVBQVUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUU7Q0FDaEQ7Q0FDQTtDQUNBO0NBQ0EsS0FBSyxVQUFVLENBQUMsWUFBWSxHQUFHLElB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TWtFLE1BQU0sR0FBRztHQUFFM3lDLE1BQU07R0FBRStOLEdBQUc7Q0FBRVYsYUFBQUE7Q0FBVTtBQUN4QyxPQUFNM1YsUUFBUSxHQUFHazdDO0FBRVgsT0FBQTtHQUFFcHdDLFNBQVM7R0FBRThPLFVBQVU7R0FBRUMsTUFBTTtHQUFFQyxRQUFRO0NBQUUybkIsRUFBQUE7Q0FBYSxDQUFDLEdBQUcwWjtDQUVsRTc3QyxNQUFNLENBQUNzSCxJQUFJLENBQUNzMEMsUUFBUSxDQUFDLENBQUMvM0MsT0FBTyxDQUFDLFVBQUNpNEMsaUJBQWlCLEVBQUs7Q0FDakQ5N0MsRUFBQUEsTUFBTSxDQUFDc0gsSUFBSSxDQUFDczBDLFFBQVEsQ0FBQ0UsaUJBQWlCLENBQUMsQ0FBQyxDQUFDajRDLE9BQU8sQ0FBQyxVQUFDazRDLGFBQWEsRUFBSztDQUNoRUYsSUFBQUEsY0FBa0IsQ0FBQ3paLFlBQVksQ0FDM0IyWixhQUFhLEVBQ2JILFFBQVEsQ0FBQ0UsaUJBQWlCLENBQUMsQ0FBQ0MsYUFBYSxDQUM3QyxDQUFDO0NBQ0wsR0FBQyxDQUFDO0NBQ04sQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyIsInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDY0LDY1LDY2LDkyLDkzLDk0LDk1LDk2LDE5MSwxOTIsMTkzLDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMF19
